begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Read a symbol table in ECOFF format (Third-Eye).    Copyright 1986, 87, 89, 90, 91, 92, 93, 94, 95, 96, 97, 1998    Free Software Foundation, Inc.    Original version contributed by Alessandro Forin (af@cs.cmu.edu) at    CMU.  Major work by Per Bothner, John Gilmore and Ian Lance Taylor    at Cygnus Support.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This module provides the function mdebug_build_psymtabs.  It reads    ECOFF debugging information into partial symbol tables.  The    debugging information is read from two structures.  A struct    ecoff_debug_swap includes the sizes of each ECOFF structure and    swapping routines; these are fixed for a particular target.  A    struct ecoff_debug_info points to the debugging information for a    particular object file.     ECOFF symbol tables are mostly written in the byte order of the    target machine.  However, one section of the table (the auxiliary    symbol information) is written in the host byte order.  There is a    bit in the other symbol info which describes which host byte order    was used.  ECOFF thereby takes the trophy from Intel `b.out' for    the most brain-dead adaptation of a file format to byte order.     This module can read all four of the known byte-order combinations,    on any type of host.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"buildsym.h"
end_include

begin_include
include|#
directive|include
file|"stabsread.h"
end_include

begin_include
include|#
directive|include
file|"complaints.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_comment
comment|/* These are needed if the tm.h file does not contain the necessary    mips specific definitions.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MIPS_EFI_SYMBOL_NAME
end_ifndef

begin_define
define|#
directive|define
name|MIPS_EFI_SYMBOL_NAME
value|"__GDB_EFI_INFO__"
end_define

begin_decl_stmt
specifier|extern
name|void
name|ecoff_relocate_efi
name|PARAMS
argument_list|(
operator|(
expr|struct
name|symbol
operator|*
operator|,
name|CORE_ADDR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|"coff/sym.h"
end_include

begin_include
include|#
directive|include
file|"coff/symconst.h"
end_include

begin_typedef
typedef|typedef
struct|struct
name|mips_extra_func_info
block|{
name|long
name|numargs
decl_stmt|;
name|PDR
name|pdr
decl_stmt|;
block|}
typedef|*
name|mips_extra_func_info_t
typedef|;
end_typedef

begin_ifndef
ifndef|#
directive|ifndef
name|RA_REGNUM
end_ifndef

begin_define
define|#
directive|define
name|RA_REGNUM
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"gdb_stat.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"gdb-stabs.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"coff/ecoff.h"
end_include

begin_comment
comment|/* COFF-like aspects of ecoff files */
end_comment

begin_include
include|#
directive|include
file|"libaout.h"
end_include

begin_comment
comment|/* Private BFD a.out information.  */
end_comment

begin_include
include|#
directive|include
file|"aout/aout64.h"
end_include

begin_include
include|#
directive|include
file|"aout/stab_gnu.h"
end_include

begin_comment
comment|/* STABS information */
end_comment

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_comment
comment|/* Needed inside partial-stab.h */
end_comment

begin_comment
comment|/* Provide a default mapping from a ecoff register number to a gdb REGNUM.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ECOFF_REG_TO_REGNUM
end_ifndef

begin_define
define|#
directive|define
name|ECOFF_REG_TO_REGNUM
parameter_list|(
name|num
parameter_list|)
value|(num)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Provide a way to test if we have both ECOFF and ELF symbol tables.      We use this define in order to know whether we should override a     symbol's ECOFF section with its ELF section.  This is necessary in     case the symbol's ELF section could not be represented in ECOFF.  */
end_comment

begin_define
define|#
directive|define
name|ECOFF_IN_ELF
parameter_list|(
name|bfd
parameter_list|)
value|(bfd_get_flavour (bfd) == bfd_target_elf_flavour \&& bfd_get_section_by_name (bfd, ".mdebug") != NULL)
end_define

begin_escape
end_escape

begin_comment
comment|/* We put a pointer to this structure in the read_symtab_private field    of the psymtab.  */
end_comment

begin_struct
struct|struct
name|symloc
block|{
comment|/* Index of the FDR that this psymtab represents.  */
name|int
name|fdr_idx
decl_stmt|;
comment|/* The BFD that the psymtab was created from.  */
name|bfd
modifier|*
name|cur_bfd
decl_stmt|;
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
name|debug_swap
decl_stmt|;
name|struct
name|ecoff_debug_info
modifier|*
name|debug_info
decl_stmt|;
name|struct
name|mdebug_pending
modifier|*
modifier|*
name|pending_list
decl_stmt|;
comment|/* Pointer to external symbols for this file.  */
name|EXTR
modifier|*
name|extern_tab
decl_stmt|;
comment|/* Size of extern_tab.  */
name|int
name|extern_count
decl_stmt|;
name|enum
name|language
name|pst_language
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|PST_PRIVATE
parameter_list|(
name|p
parameter_list|)
value|((struct symloc *)(p)->read_symtab_private)
end_define

begin_define
define|#
directive|define
name|FDR_IDX
parameter_list|(
name|p
parameter_list|)
value|(PST_PRIVATE(p)->fdr_idx)
end_define

begin_define
define|#
directive|define
name|CUR_BFD
parameter_list|(
name|p
parameter_list|)
value|(PST_PRIVATE(p)->cur_bfd)
end_define

begin_define
define|#
directive|define
name|DEBUG_SWAP
parameter_list|(
name|p
parameter_list|)
value|(PST_PRIVATE(p)->debug_swap)
end_define

begin_define
define|#
directive|define
name|DEBUG_INFO
parameter_list|(
name|p
parameter_list|)
value|(PST_PRIVATE(p)->debug_info)
end_define

begin_define
define|#
directive|define
name|PENDING_LIST
parameter_list|(
name|p
parameter_list|)
value|(PST_PRIVATE(p)->pending_list)
end_define

begin_define
define|#
directive|define
name|SC_IS_TEXT
parameter_list|(
name|sc
parameter_list|)
value|((sc) == scText \ 		   || (sc) == scRConst \           	   || (sc) == scInit \           	   || (sc) == scFini)
end_define

begin_define
define|#
directive|define
name|SC_IS_DATA
parameter_list|(
name|sc
parameter_list|)
value|((sc) == scData \ 		   || (sc) == scSData \ 		   || (sc) == scRData \ 		   || (sc) == scPData \ 		   || (sc) == scXData)
end_define

begin_define
define|#
directive|define
name|SC_IS_COMMON
parameter_list|(
name|sc
parameter_list|)
value|((sc) == scCommon || (sc) == scSCommon)
end_define

begin_define
define|#
directive|define
name|SC_IS_BSS
parameter_list|(
name|sc
parameter_list|)
value|((sc) == scBss || (sc) == scSBss)
end_define

begin_define
define|#
directive|define
name|SC_IS_UNDEF
parameter_list|(
name|sc
parameter_list|)
value|((sc) == scUndefined || (sc) == scSUndefined)
end_define

begin_escape
end_escape

begin_comment
comment|/* Things we import explicitly from other modules */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|info_verbose
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Various complaints about symbol reading that don't abort the process */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|complaint
name|bad_file_number_complaint
init|=
block|{
literal|"bad file number %d"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|complaint
name|index_complaint
init|=
block|{
literal|"bad aux index at symbol %s"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|complaint
name|aux_index_complaint
init|=
block|{
literal|"bad proc end in aux found from symbol %s"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|complaint
name|block_index_complaint
init|=
block|{
literal|"bad aux index at block symbol %s"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|complaint
name|unknown_ext_complaint
init|=
block|{
literal|"unknown external symbol %s"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|complaint
name|unknown_sym_complaint
init|=
block|{
literal|"unknown local symbol %s"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|complaint
name|unknown_st_complaint
init|=
block|{
literal|"with type %d"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|complaint
name|block_overflow_complaint
init|=
block|{
literal|"block containing %s overfilled"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|complaint
name|basic_type_complaint
init|=
block|{
literal|"cannot map ECOFF basic type 0x%x for %s"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|complaint
name|unknown_type_qual_complaint
init|=
block|{
literal|"unknown type qualifier 0x%x"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|complaint
name|array_index_type_complaint
init|=
block|{
literal|"illegal array index type for %s, assuming int"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|complaint
name|bad_tag_guess_complaint
init|=
block|{
literal|"guessed tag type of %s incorrectly"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|complaint
name|block_member_complaint
init|=
block|{
literal|"declaration block contains unhandled symbol type %d"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|complaint
name|stEnd_complaint
init|=
block|{
literal|"stEnd with storage class %d not handled"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|complaint
name|unknown_mdebug_symtype_complaint
init|=
block|{
literal|"unknown symbol type 0x%x"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|complaint
name|stab_unknown_complaint
init|=
block|{
literal|"unknown stabs symbol %s"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|complaint
name|pdr_for_nonsymbol_complaint
init|=
block|{
literal|"PDR for %s, but no symbol"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|complaint
name|pdr_static_symbol_complaint
init|=
block|{
literal|"can't handle PDR for static proc at 0x%lx"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|complaint
name|bad_setjmp_pdr_complaint
init|=
block|{
literal|"fixing bad setjmp PDR from libc"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|complaint
name|bad_fbitfield_complaint
init|=
block|{
literal|"can't handle TIR fBitfield for %s"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|complaint
name|bad_continued_complaint
init|=
block|{
literal|"illegal TIR continued for %s"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|complaint
name|bad_rfd_entry_complaint
init|=
block|{
literal|"bad rfd entry for %s: file %d, index %d"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|complaint
name|unexpected_type_code_complaint
init|=
block|{
literal|"unexpected type code for %s"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|complaint
name|unable_to_cross_ref_complaint
init|=
block|{
literal|"unable to cross ref btTypedef for %s"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|complaint
name|bad_indirect_xref_complaint
init|=
block|{
literal|"unable to cross ref btIndirect for %s"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|complaint
name|illegal_forward_tq0_complaint
init|=
block|{
literal|"illegal tq0 in forward typedef for %s"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|complaint
name|illegal_forward_bt_complaint
init|=
block|{
literal|"illegal bt %d in forward typedef for %s"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|complaint
name|bad_linetable_guess_complaint
init|=
block|{
literal|"guessed size of linetable for %s incorrectly"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|complaint
name|bad_ext_ifd_complaint
init|=
block|{
literal|"bad ifd for external symbol: %d (max %d)"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|complaint
name|bad_ext_iss_complaint
init|=
block|{
literal|"bad iss for external symbol: %ld (max %ld)"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Macros and extra defs */
end_comment

begin_comment
comment|/* Puns: hard to find whether -g was used and how */
end_comment

begin_define
define|#
directive|define
name|MIN_GLEVEL
value|GLEVEL_0
end_define

begin_define
define|#
directive|define
name|compare_glevel
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
define|\
value|(((a) == GLEVEL_3) ? ((b)< GLEVEL_3) :			\ 	 ((b) == GLEVEL_3) ? -1 : (int)((b) - (a)))
end_define

begin_escape
end_escape

begin_comment
comment|/* Things that really are local to this module */
end_comment

begin_comment
comment|/* Remember what we deduced to be the source language of this psymtab. */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|language
name|psymtab_language
init|=
name|language_unknown
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current BFD.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd
modifier|*
name|cur_bfd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* How to parse debugging information for CUR_BFD.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
name|debug_swap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointers to debugging information for CUR_BFD.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ecoff_debug_info
modifier|*
name|debug_info
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to current file decriptor record, and its index */
end_comment

begin_decl_stmt
specifier|static
name|FDR
modifier|*
name|cur_fdr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cur_fd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Index of current symbol */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cur_sdx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Note how much "debuggable" this image is.  We would like    to see at least one FDR with full symbols */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_gdbinfo
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|max_glevel
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When examining .o files, report on undefined symbols */
end_comment

begin_decl_stmt
specifier|static
name|int
name|n_undef_symbols
decl_stmt|,
name|n_undef_labels
decl_stmt|,
name|n_undef_vars
decl_stmt|,
name|n_undef_procs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pseudo symbol to use when putting stabs into the symbol table.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|stabs_symbol
index|[]
init|=
name|STABS_SYMBOL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Types corresponding to mdebug format bt* basic types.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|mdebug_type_void
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|mdebug_type_char
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|mdebug_type_short
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|mdebug_type_int_32
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|mdebug_type_int
value|mdebug_type_int_32
end_define

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|mdebug_type_int_64
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|mdebug_type_long_32
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|mdebug_type_long_64
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|mdebug_type_long_long_64
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|mdebug_type_unsigned_char
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|mdebug_type_unsigned_short
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|mdebug_type_unsigned_int_32
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|mdebug_type_unsigned_int_64
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|mdebug_type_unsigned_long_32
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|mdebug_type_unsigned_long_64
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|mdebug_type_unsigned_long_long_64
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|mdebug_type_adr_32
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|mdebug_type_adr_64
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|mdebug_type_float
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|mdebug_type_double
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|mdebug_type_complex
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|mdebug_type_double_complex
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|mdebug_type_fixed_dec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|mdebug_type_float_dec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|mdebug_type_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Types for symbols from files compiled without debugging info.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|nodebug_func_symbol_type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|nodebug_var_symbol_type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we have seen ecoff debugging info for a file.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|found_ecoff_debugging_info
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward declarations */
end_comment

begin_decl_stmt
specifier|static
name|void
name|add_pending
name|PARAMS
argument_list|(
operator|(
name|FDR
operator|*
operator|,
name|char
operator|*
operator|,
expr|struct
name|type
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mdebug_pending
modifier|*
name|is_pending_symbol
name|PARAMS
argument_list|(
operator|(
name|FDR
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pop_parse_stack
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|push_parse_stack
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|fdr_name
name|PARAMS
argument_list|(
operator|(
name|FDR
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mdebug_psymtab_to_symtab
name|PARAMS
argument_list|(
operator|(
expr|struct
name|partial_symtab
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|upgrade_type
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|type
operator|*
operator|*
operator|,
name|int
operator|,
expr|union
name|aux_ext
operator|*
operator|,
name|int
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|parse_partial_symbols
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|,
expr|struct
name|section_offsets
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FDR
modifier|*
name|get_rfd
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|has_opaque_xref
name|PARAMS
argument_list|(
operator|(
name|FDR
operator|*
operator|,
name|SYMR
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cross_ref
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
expr|union
name|aux_ext
operator|*
operator|,
expr|struct
name|type
operator|*
operator|*
operator|,
expr|enum
name|type_code
operator|,
name|char
operator|*
operator|*
operator|,
name|int
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|symbol
modifier|*
name|new_symbol
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|new_type
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block
modifier|*
name|new_block
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|symtab
modifier|*
name|new_symtab
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|linetable
modifier|*
name|new_linetable
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|blockvector
modifier|*
name|new_bvect
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|parse_symbol
name|PARAMS
argument_list|(
operator|(
name|SYMR
operator|*
operator|,
expr|union
name|aux_ext
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|,
expr|struct
name|section_offsets
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|parse_type
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
expr|union
name|aux_ext
operator|*
operator|,
name|unsigned
name|int
operator|,
name|int
operator|*
operator|,
name|int
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|symbol
modifier|*
name|mylookup_symbol
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
expr|struct
name|block
operator|*
operator|,
name|namespace_enum
operator|,
expr|enum
name|address_class
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|block
modifier|*
name|shrink_block
name|PARAMS
argument_list|(
operator|(
expr|struct
name|block
operator|*
operator|,
expr|struct
name|symtab
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|PTR
name|xzalloc
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sort_blocks
name|PARAMS
argument_list|(
operator|(
expr|struct
name|symtab
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|compare_blocks
name|PARAMS
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|,
specifier|const
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|partial_symtab
modifier|*
name|new_psymtab
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
expr|struct
name|objfile
operator|*
operator|,
expr|struct
name|section_offsets
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|psymtab_to_symtab_1
name|PARAMS
argument_list|(
operator|(
expr|struct
name|partial_symtab
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_block
name|PARAMS
argument_list|(
operator|(
expr|struct
name|block
operator|*
operator|,
expr|struct
name|symtab
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_symbol
name|PARAMS
argument_list|(
operator|(
expr|struct
name|symbol
operator|*
operator|,
expr|struct
name|block
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|add_line
name|PARAMS
argument_list|(
operator|(
expr|struct
name|linetable
operator|*
operator|,
name|int
operator|,
name|CORE_ADDR
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|linetable
modifier|*
name|shrink_linetable
name|PARAMS
argument_list|(
operator|(
expr|struct
name|linetable
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|handle_psymbol_enumerators
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|,
name|FDR
operator|*
operator|,
name|int
operator|,
name|CORE_ADDR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|mdebug_next_symbol_text
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Address bounds for the signal trampoline in inferior, if any */
end_comment

begin_decl_stmt
name|CORE_ADDR
name|sigtramp_address
decl_stmt|,
name|sigtramp_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Allocate zeroed memory */
end_comment

begin_function
specifier|static
name|PTR
name|xzalloc
parameter_list|(
name|size
parameter_list|)
name|unsigned
name|int
name|size
decl_stmt|;
block|{
name|PTR
name|p
init|=
name|xmalloc
argument_list|(
name|size
argument_list|)
decl_stmt|;
name|memset
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Exported procedure: Builds a symtab from the PST partial one.    Restores the environment in effect when PST was created, delegates    most of the work to an ancillary procedure, and sorts    and reorders the symtab list at the end */
end_comment

begin_function
specifier|static
name|void
name|mdebug_psymtab_to_symtab
parameter_list|(
name|pst
parameter_list|)
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|pst
condition|)
return|return;
if|if
condition|(
name|info_verbose
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Reading in symbols for %s..."
argument_list|,
name|pst
operator|->
name|filename
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
name|next_symbol_text_func
operator|=
name|mdebug_next_symbol_text
expr_stmt|;
name|psymtab_to_symtab_1
argument_list|(
name|pst
argument_list|,
name|pst
operator|->
name|filename
argument_list|)
expr_stmt|;
comment|/* Match with global symbols.  This only needs to be done once,      after all of the symtabs and dependencies have been read in.   */
name|scan_file_globals
argument_list|(
name|pst
operator|->
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_verbose
condition|)
name|printf_filtered
argument_list|(
literal|"done.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* File-level interface functions */
end_comment

begin_comment
comment|/* Find a file descriptor given its index RF relative to a file CF */
end_comment

begin_function
specifier|static
name|FDR
modifier|*
name|get_rfd
parameter_list|(
name|cf
parameter_list|,
name|rf
parameter_list|)
name|int
name|cf
decl_stmt|,
name|rf
decl_stmt|;
block|{
name|FDR
modifier|*
name|fdrs
decl_stmt|;
specifier|register
name|FDR
modifier|*
name|f
decl_stmt|;
name|RFDT
name|rfd
decl_stmt|;
name|fdrs
operator|=
name|debug_info
operator|->
name|fdr
expr_stmt|;
name|f
operator|=
name|fdrs
operator|+
name|cf
expr_stmt|;
comment|/* Object files do not have the RFD table, all refs are absolute */
if|if
condition|(
name|f
operator|->
name|rfdBase
operator|==
literal|0
condition|)
return|return
name|fdrs
operator|+
name|rf
return|;
call|(
modifier|*
name|debug_swap
operator|->
name|swap_rfd_in
call|)
argument_list|(
name|cur_bfd
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
name|debug_info
operator|->
name|external_rfd
operator|+
operator|(
operator|(
name|f
operator|->
name|rfdBase
operator|+
name|rf
operator|)
operator|*
name|debug_swap
operator|->
name|external_rfd_size
operator|)
operator|)
argument_list|,
operator|&
name|rfd
argument_list|)
expr_stmt|;
return|return
name|fdrs
operator|+
name|rfd
return|;
block|}
end_function

begin_comment
comment|/* Return a safer print NAME for a file descriptor */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|fdr_name
parameter_list|(
name|f
parameter_list|)
name|FDR
modifier|*
name|f
decl_stmt|;
block|{
if|if
condition|(
name|f
operator|->
name|rss
operator|==
operator|-
literal|1
condition|)
return|return
literal|"<stripped file>"
return|;
if|if
condition|(
name|f
operator|->
name|rss
operator|==
literal|0
condition|)
return|return
literal|"<NFY>"
return|;
return|return
name|debug_info
operator|->
name|ss
operator|+
name|f
operator|->
name|issBase
operator|+
name|f
operator|->
name|rss
return|;
block|}
end_function

begin_comment
comment|/* Read in and parse the symtab of the file OBJFILE.  Symbols from    different sections are relocated via the SECTION_OFFSETS.  */
end_comment

begin_function
name|void
name|mdebug_build_psymtabs
parameter_list|(
name|objfile
parameter_list|,
name|swap
parameter_list|,
name|info
parameter_list|,
name|section_offsets
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
name|swap
decl_stmt|;
name|struct
name|ecoff_debug_info
modifier|*
name|info
decl_stmt|;
name|struct
name|section_offsets
modifier|*
name|section_offsets
decl_stmt|;
block|{
name|cur_bfd
operator|=
name|objfile
operator|->
name|obfd
expr_stmt|;
name|debug_swap
operator|=
name|swap
expr_stmt|;
name|debug_info
operator|=
name|info
expr_stmt|;
comment|/* Make sure all the FDR information is swapped in.  */
if|if
condition|(
name|info
operator|->
name|fdr
operator|==
operator|(
name|FDR
operator|*
operator|)
name|NULL
condition|)
block|{
name|char
modifier|*
name|fdr_src
decl_stmt|;
name|char
modifier|*
name|fdr_end
decl_stmt|;
name|FDR
modifier|*
name|fdr_ptr
decl_stmt|;
name|info
operator|->
name|fdr
operator|=
operator|(
name|FDR
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|psymbol_obstack
argument_list|,
operator|(
name|info
operator|->
name|symbolic_header
operator|.
name|ifdMax
operator|*
sizeof|sizeof
argument_list|(
name|FDR
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|fdr_src
operator|=
name|info
operator|->
name|external_fdr
expr_stmt|;
name|fdr_end
operator|=
operator|(
name|fdr_src
operator|+
name|info
operator|->
name|symbolic_header
operator|.
name|ifdMax
operator|*
name|swap
operator|->
name|external_fdr_size
operator|)
expr_stmt|;
name|fdr_ptr
operator|=
name|info
operator|->
name|fdr
expr_stmt|;
for|for
control|(
init|;
name|fdr_src
operator|<
name|fdr_end
condition|;
name|fdr_src
operator|+=
name|swap
operator|->
name|external_fdr_size
operator|,
name|fdr_ptr
operator|++
control|)
call|(
modifier|*
name|swap
operator|->
name|swap_fdr_in
call|)
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|fdr_src
argument_list|,
name|fdr_ptr
argument_list|)
expr_stmt|;
block|}
name|parse_partial_symbols
argument_list|(
name|objfile
argument_list|,
name|section_offsets
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Check to make sure file was compiled with -g.  If not, warn the      user of this limitation.  */
block|if (compare_glevel (max_glevel, GLEVEL_2)< 0)     {       if (max_gdbinfo == 0) 	printf_unfiltered ("\n%s not compiled with -g, debugging support is limited.\n", 		 objfile->name);       printf_unfiltered ("You should compile with -g2 or -g3 for best debugging support.\n");       gdb_flush (gdb_stdout);     }
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Local utilities */
end_comment

begin_comment
comment|/* Map of FDR indexes to partial symtabs */
end_comment

begin_struct
struct|struct
name|pst_map
block|{
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
comment|/* the psymtab proper */
name|long
name|n_globals
decl_stmt|;
comment|/* exported globals (external symbols) */
name|long
name|globals_offset
decl_stmt|;
comment|/* cumulative */
block|}
struct|;
end_struct

begin_comment
comment|/* Utility stack, used to nest procedures and blocks properly.    It is a doubly linked list, to avoid too many alloc/free.    Since we might need it quite a few times it is NOT deallocated    after use. */
end_comment

begin_struct
specifier|static
struct|struct
name|parse_stack
block|{
name|struct
name|parse_stack
modifier|*
name|next
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
name|struct
name|symtab
modifier|*
name|cur_st
decl_stmt|;
comment|/* Current symtab. */
name|struct
name|block
modifier|*
name|cur_block
decl_stmt|;
comment|/* Block in it. */
comment|/* What are we parsing.  stFile, or stBlock are for files and      blocks.  stProc or stStaticProc means we have seen the start of a      procedure, but not the start of the block within in.  When we see      the start of that block, we change it to stNil, without pushing a      new block, i.e. stNil means both a procedure and a block.  */
name|int
name|blocktype
decl_stmt|;
name|int
name|maxsyms
decl_stmt|;
comment|/* Max symbols in this block. */
name|struct
name|type
modifier|*
name|cur_type
decl_stmt|;
comment|/* Type we parse fields for. */
name|int
name|cur_field
decl_stmt|;
comment|/* Field number in cur_type. */
name|CORE_ADDR
name|procadr
decl_stmt|;
comment|/* Start addres of this procedure */
name|int
name|numargs
decl_stmt|;
comment|/* Its argument count */
block|}
modifier|*
name|top_stack
struct|;
end_struct

begin_comment
comment|/* Top stack ptr */
end_comment

begin_comment
comment|/* Enter a new lexical context */
end_comment

begin_function
specifier|static
name|void
name|push_parse_stack
parameter_list|()
block|{
name|struct
name|parse_stack
modifier|*
name|new
decl_stmt|;
comment|/* Reuse frames if possible */
if|if
condition|(
name|top_stack
operator|&&
name|top_stack
operator|->
name|prev
condition|)
name|new
operator|=
name|top_stack
operator|->
name|prev
expr_stmt|;
else|else
name|new
operator|=
operator|(
expr|struct
name|parse_stack
operator|*
operator|)
name|xzalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|parse_stack
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize new frame with previous content */
if|if
condition|(
name|top_stack
condition|)
block|{
specifier|register
name|struct
name|parse_stack
modifier|*
name|prev
init|=
name|new
operator|->
name|prev
decl_stmt|;
operator|*
name|new
operator|=
operator|*
name|top_stack
expr_stmt|;
name|top_stack
operator|->
name|prev
operator|=
name|new
expr_stmt|;
name|new
operator|->
name|prev
operator|=
name|prev
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|top_stack
expr_stmt|;
block|}
name|top_stack
operator|=
name|new
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Exit a lexical context */
end_comment

begin_function
specifier|static
name|void
name|pop_parse_stack
parameter_list|()
block|{
if|if
condition|(
operator|!
name|top_stack
condition|)
return|return;
if|if
condition|(
name|top_stack
operator|->
name|next
condition|)
name|top_stack
operator|=
name|top_stack
operator|->
name|next
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Cross-references might be to things we haven't looked at    yet, e.g. type references.  To avoid too many type    duplications we keep a quick fixup table, an array    of lists of references indexed by file descriptor */
end_comment

begin_struct
struct|struct
name|mdebug_pending
block|{
name|struct
name|mdebug_pending
modifier|*
name|next
decl_stmt|;
comment|/* link */
name|char
modifier|*
name|s
decl_stmt|;
comment|/* the unswapped symbol */
name|struct
name|type
modifier|*
name|t
decl_stmt|;
comment|/* its partial type descriptor */
block|}
struct|;
end_struct

begin_comment
comment|/* The pending information is kept for an entire object file, and used    to be in the sym_private field.  I took it out when I split    mdebugread from mipsread, because this might not be the only type    of symbols read from an object file.  Instead, we allocate the    pending information table when we create the partial symbols, and    we store a pointer to the single table in each psymtab.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|mdebug_pending
modifier|*
modifier|*
name|pending_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Check whether we already saw symbol SH in file FH */
end_comment

begin_function
specifier|static
name|struct
name|mdebug_pending
modifier|*
name|is_pending_symbol
parameter_list|(
name|fh
parameter_list|,
name|sh
parameter_list|)
name|FDR
modifier|*
name|fh
decl_stmt|;
name|char
modifier|*
name|sh
decl_stmt|;
block|{
name|int
name|f_idx
init|=
name|fh
operator|-
name|debug_info
operator|->
name|fdr
decl_stmt|;
specifier|register
name|struct
name|mdebug_pending
modifier|*
name|p
decl_stmt|;
comment|/* Linear search is ok, list is typically no more than 10 deep */
for|for
control|(
name|p
operator|=
name|pending_list
index|[
name|f_idx
index|]
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
name|p
operator|->
name|s
operator|==
name|sh
condition|)
break|break;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Add a new symbol SH of type T */
end_comment

begin_function
specifier|static
name|void
name|add_pending
parameter_list|(
name|fh
parameter_list|,
name|sh
parameter_list|,
name|t
parameter_list|)
name|FDR
modifier|*
name|fh
decl_stmt|;
name|char
modifier|*
name|sh
decl_stmt|;
name|struct
name|type
modifier|*
name|t
decl_stmt|;
block|{
name|int
name|f_idx
init|=
name|fh
operator|-
name|debug_info
operator|->
name|fdr
decl_stmt|;
name|struct
name|mdebug_pending
modifier|*
name|p
init|=
name|is_pending_symbol
argument_list|(
name|fh
argument_list|,
name|sh
argument_list|)
decl_stmt|;
comment|/* Make sure we do not make duplicates */
if|if
condition|(
operator|!
name|p
condition|)
block|{
name|p
operator|=
operator|(
operator|(
expr|struct
name|mdebug_pending
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|current_objfile
operator|->
name|psymbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mdebug_pending
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|p
operator|->
name|s
operator|=
name|sh
expr_stmt|;
name|p
operator|->
name|t
operator|=
name|t
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|pending_list
index|[
name|f_idx
index|]
expr_stmt|;
name|pending_list
index|[
name|f_idx
index|]
operator|=
name|p
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Parsing Routines proper. */
end_comment

begin_comment
comment|/* Parse a single symbol. Mostly just make up a GDB symbol for it.    For blocks, procedures and types we open a new lexical context.    This is basically just a big switch on the symbol's type.  Argument    AX is the base pointer of aux symbols for this file (fh->iauxBase).    EXT_SH points to the unswapped symbol, which is needed for struct,    union, etc., types; it is NULL for an EXTR.  BIGEND says whether    aux symbols are big-endian or little-endian.  Return count of    SYMR's handled (normally one).  */
end_comment

begin_function
specifier|static
name|int
name|parse_symbol
parameter_list|(
name|sh
parameter_list|,
name|ax
parameter_list|,
name|ext_sh
parameter_list|,
name|bigend
parameter_list|,
name|section_offsets
parameter_list|)
name|SYMR
modifier|*
name|sh
decl_stmt|;
name|union
name|aux_ext
modifier|*
name|ax
decl_stmt|;
name|char
modifier|*
name|ext_sh
decl_stmt|;
name|int
name|bigend
decl_stmt|;
name|struct
name|section_offsets
modifier|*
name|section_offsets
decl_stmt|;
block|{
specifier|const
name|bfd_size_type
name|external_sym_size
init|=
name|debug_swap
operator|->
name|external_sym_size
decl_stmt|;
name|void
argument_list|(
argument|* const swap_sym_in
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|,
name|SYMR
operator|*
operator|)
argument_list|)
operator|=
name|debug_swap
operator|->
name|swap_sym_in
expr_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|symbol
modifier|*
name|s
decl_stmt|;
name|struct
name|block
modifier|*
name|b
decl_stmt|;
name|struct
name|mdebug_pending
modifier|*
name|pend
decl_stmt|;
name|struct
name|type
modifier|*
name|t
decl_stmt|;
name|struct
name|field
modifier|*
name|f
decl_stmt|;
name|int
name|count
init|=
literal|1
decl_stmt|;
name|enum
name|address_class
name|class
decl_stmt|;
name|TIR
name|tir
decl_stmt|;
name|long
name|svalue
init|=
name|sh
operator|->
name|value
decl_stmt|;
name|int
name|bitsize
decl_stmt|;
if|if
condition|(
name|ext_sh
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|name
operator|=
name|debug_info
operator|->
name|ssext
operator|+
name|sh
operator|->
name|iss
expr_stmt|;
else|else
name|name
operator|=
name|debug_info
operator|->
name|ss
operator|+
name|cur_fdr
operator|->
name|issBase
operator|+
name|sh
operator|->
name|iss
expr_stmt|;
switch|switch
condition|(
name|sh
operator|->
name|sc
condition|)
block|{
case|case
name|scText
case|:
case|case
name|scRConst
case|:
comment|/* Do not relocate relative values. 	 The value of a stEnd symbol is the displacement from the 	 corresponding start symbol value. 	 The value of a stBlock symbol is the displacement from the 	 procedure address.  */
if|if
condition|(
name|sh
operator|->
name|st
operator|!=
name|stEnd
operator|&&
name|sh
operator|->
name|st
operator|!=
name|stBlock
condition|)
name|sh
operator|->
name|value
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
expr_stmt|;
break|break;
case|case
name|scData
case|:
case|case
name|scSData
case|:
case|case
name|scRData
case|:
case|case
name|scPData
case|:
case|case
name|scXData
case|:
name|sh
operator|->
name|value
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_DATA
argument_list|)
expr_stmt|;
break|break;
case|case
name|scBss
case|:
case|case
name|scSBss
case|:
name|sh
operator|->
name|value
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_BSS
argument_list|)
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|sh
operator|->
name|st
condition|)
block|{
case|case
name|stNil
case|:
break|break;
case|case
name|stGlobal
case|:
comment|/* external symbol, goes into global block */
name|class
operator|=
name|LOC_STATIC
expr_stmt|;
name|b
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|BLOCKVECTOR
argument_list|(
name|top_stack
operator|->
name|cur_st
argument_list|)
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
expr_stmt|;
name|s
operator|=
name|new_symbol
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|s
argument_list|)
operator|=
operator|(
name|CORE_ADDR
operator|)
name|sh
operator|->
name|value
expr_stmt|;
goto|goto
name|data
goto|;
case|case
name|stStatic
case|:
comment|/* static data, goes into current block. */
name|class
operator|=
name|LOC_STATIC
expr_stmt|;
name|b
operator|=
name|top_stack
operator|->
name|cur_block
expr_stmt|;
name|s
operator|=
name|new_symbol
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|SC_IS_COMMON
argument_list|(
name|sh
operator|->
name|sc
argument_list|)
condition|)
block|{
comment|/* It is a FORTRAN common block.  At least for SGI Fortran the 	     address is not in the symbol; we need to fix it later in 	     scan_file_globals.  */
name|int
name|bucket
init|=
name|hashname
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|s
argument_list|)
argument_list|)
decl_stmt|;
name|SYMBOL_VALUE_CHAIN
argument_list|(
name|s
argument_list|)
operator|=
name|global_sym_chain
index|[
name|bucket
index|]
expr_stmt|;
name|global_sym_chain
index|[
name|bucket
index|]
operator|=
name|s
expr_stmt|;
block|}
else|else
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|s
argument_list|)
operator|=
operator|(
name|CORE_ADDR
operator|)
name|sh
operator|->
name|value
expr_stmt|;
goto|goto
name|data
goto|;
case|case
name|stLocal
case|:
comment|/* local variable, goes into current block */
if|if
condition|(
name|sh
operator|->
name|sc
operator|==
name|scRegister
condition|)
block|{
name|class
operator|=
name|LOC_REGISTER
expr_stmt|;
name|svalue
operator|=
name|ECOFF_REG_TO_REGNUM
argument_list|(
name|svalue
argument_list|)
expr_stmt|;
block|}
else|else
name|class
operator|=
name|LOC_LOCAL
expr_stmt|;
name|b
operator|=
name|top_stack
operator|->
name|cur_block
expr_stmt|;
name|s
operator|=
name|new_symbol
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|s
argument_list|)
operator|=
name|svalue
expr_stmt|;
name|data
label|:
comment|/* Common code for symbols describing data */
name|SYMBOL_NAMESPACE
argument_list|(
name|s
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|s
argument_list|)
operator|=
name|class
expr_stmt|;
name|add_symbol
argument_list|(
name|s
argument_list|,
name|b
argument_list|)
expr_stmt|;
comment|/* Type could be missing if file is compiled without debugging info.  */
if|if
condition|(
name|SC_IS_UNDEF
argument_list|(
name|sh
operator|->
name|sc
argument_list|)
operator|||
name|sh
operator|->
name|sc
operator|==
name|scNil
operator|||
name|sh
operator|->
name|index
operator|==
name|indexNil
condition|)
name|SYMBOL_TYPE
argument_list|(
name|s
argument_list|)
operator|=
name|nodebug_var_symbol_type
expr_stmt|;
else|else
name|SYMBOL_TYPE
argument_list|(
name|s
argument_list|)
operator|=
name|parse_type
argument_list|(
name|cur_fd
argument_list|,
name|ax
argument_list|,
name|sh
operator|->
name|index
argument_list|,
literal|0
argument_list|,
name|bigend
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Value of a data symbol is its memory address */
break|break;
case|case
name|stParam
case|:
comment|/* arg to procedure, goes into current block */
name|max_gdbinfo
operator|++
expr_stmt|;
name|found_ecoff_debugging_info
operator|=
literal|1
expr_stmt|;
name|top_stack
operator|->
name|numargs
operator|++
expr_stmt|;
comment|/* Special GNU C++ name.  */
if|if
condition|(
name|is_cplus_marker
argument_list|(
name|name
index|[
literal|0
index|]
argument_list|)
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|'t'
operator|&&
name|name
index|[
literal|2
index|]
operator|==
literal|0
condition|)
name|name
operator|=
literal|"this"
expr_stmt|;
comment|/* FIXME, not alloc'd in obstack */
name|s
operator|=
name|new_symbol
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|s
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
switch|switch
condition|(
name|sh
operator|->
name|sc
condition|)
block|{
case|case
name|scRegister
case|:
comment|/* Pass by value in register.  */
name|SYMBOL_CLASS
argument_list|(
name|s
argument_list|)
operator|=
name|LOC_REGPARM
expr_stmt|;
name|svalue
operator|=
name|ECOFF_REG_TO_REGNUM
argument_list|(
name|svalue
argument_list|)
expr_stmt|;
break|break;
case|case
name|scVar
case|:
comment|/* Pass by reference on stack.  */
name|SYMBOL_CLASS
argument_list|(
name|s
argument_list|)
operator|=
name|LOC_REF_ARG
expr_stmt|;
break|break;
case|case
name|scVarRegister
case|:
comment|/* Pass by reference in register.  */
name|SYMBOL_CLASS
argument_list|(
name|s
argument_list|)
operator|=
name|LOC_REGPARM_ADDR
expr_stmt|;
name|svalue
operator|=
name|ECOFF_REG_TO_REGNUM
argument_list|(
name|svalue
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Pass by value on stack.  */
name|SYMBOL_CLASS
argument_list|(
name|s
argument_list|)
operator|=
name|LOC_ARG
expr_stmt|;
break|break;
block|}
name|SYMBOL_VALUE
argument_list|(
name|s
argument_list|)
operator|=
name|svalue
expr_stmt|;
name|SYMBOL_TYPE
argument_list|(
name|s
argument_list|)
operator|=
name|parse_type
argument_list|(
name|cur_fd
argument_list|,
name|ax
argument_list|,
name|sh
operator|->
name|index
argument_list|,
literal|0
argument_list|,
name|bigend
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|add_symbol
argument_list|(
name|s
argument_list|,
name|top_stack
operator|->
name|cur_block
argument_list|)
expr_stmt|;
break|break;
case|case
name|stLabel
case|:
comment|/* label, goes into current block */
name|s
operator|=
name|new_symbol
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|s
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
comment|/* so that it can be used */
name|SYMBOL_CLASS
argument_list|(
name|s
argument_list|)
operator|=
name|LOC_LABEL
expr_stmt|;
comment|/* but not misused */
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|s
argument_list|)
operator|=
operator|(
name|CORE_ADDR
operator|)
name|sh
operator|->
name|value
expr_stmt|;
name|SYMBOL_TYPE
argument_list|(
name|s
argument_list|)
operator|=
name|mdebug_type_int
expr_stmt|;
name|add_symbol
argument_list|(
name|s
argument_list|,
name|top_stack
operator|->
name|cur_block
argument_list|)
expr_stmt|;
break|break;
case|case
name|stProc
case|:
comment|/* Procedure, usually goes into global block */
case|case
name|stStaticProc
case|:
comment|/* Static procedure, goes into current block */
name|s
operator|=
name|new_symbol
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|s
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|s
argument_list|)
operator|=
name|LOC_BLOCK
expr_stmt|;
comment|/* Type of the return value */
if|if
condition|(
name|SC_IS_UNDEF
argument_list|(
name|sh
operator|->
name|sc
argument_list|)
operator|||
name|sh
operator|->
name|sc
operator|==
name|scNil
condition|)
name|t
operator|=
name|mdebug_type_int
expr_stmt|;
else|else
block|{
name|t
operator|=
name|parse_type
argument_list|(
name|cur_fd
argument_list|,
name|ax
argument_list|,
name|sh
operator|->
name|index
operator|+
literal|1
argument_list|,
literal|0
argument_list|,
name|bigend
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|STREQ
argument_list|(
name|name
argument_list|,
literal|"malloc"
argument_list|)
operator|&&
name|t
operator|->
name|code
operator|==
name|TYPE_CODE_VOID
condition|)
block|{
comment|/* I don't know why, but, at least under Alpha GNU/Linux, 		 when linking against a malloc without debugging 		 symbols, its read as a function returning void---this 		 is bad because it means we cannot call functions with 		 string arguments interactively; i.e., "call 		 printf("howdy\n")" would fail with the error message 		 "program has no memory available".  To avoid this, we 		 patch up the type and make it void* 		 instead. (davidm@azstarnet.com) 		 */
name|t
operator|=
name|make_pointer_type
argument_list|(
name|t
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
name|b
operator|=
name|top_stack
operator|->
name|cur_block
expr_stmt|;
if|if
condition|(
name|sh
operator|->
name|st
operator|==
name|stProc
condition|)
block|{
name|struct
name|blockvector
modifier|*
name|bv
init|=
name|BLOCKVECTOR
argument_list|(
name|top_stack
operator|->
name|cur_st
argument_list|)
decl_stmt|;
comment|/* The next test should normally be true, but provides a 	     hook for nested functions (which we don't want to make 	     global). */
if|if
condition|(
name|b
operator|==
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|STATIC_BLOCK
argument_list|)
condition|)
name|b
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
expr_stmt|;
comment|/* Irix 5 sometimes has duplicate names for the same 	     function.  We want to add such names up at the global 	     level, not as a nested function.  */
elseif|else
if|if
condition|(
name|sh
operator|->
name|value
operator|==
name|top_stack
operator|->
name|procadr
condition|)
name|b
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
expr_stmt|;
block|}
name|add_symbol
argument_list|(
name|s
argument_list|,
name|b
argument_list|)
expr_stmt|;
comment|/* Make a type for the procedure itself */
name|SYMBOL_TYPE
argument_list|(
name|s
argument_list|)
operator|=
name|lookup_function_type
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Create and enter a new lexical context */
name|b
operator|=
name|new_block
argument_list|(
name|top_stack
operator|->
name|maxsyms
argument_list|)
expr_stmt|;
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|s
argument_list|)
operator|=
name|b
expr_stmt|;
name|BLOCK_FUNCTION
argument_list|(
name|b
argument_list|)
operator|=
name|s
expr_stmt|;
name|BLOCK_START
argument_list|(
name|b
argument_list|)
operator|=
name|BLOCK_END
argument_list|(
name|b
argument_list|)
operator|=
name|sh
operator|->
name|value
expr_stmt|;
name|BLOCK_SUPERBLOCK
argument_list|(
name|b
argument_list|)
operator|=
name|top_stack
operator|->
name|cur_block
expr_stmt|;
name|add_block
argument_list|(
name|b
argument_list|,
name|top_stack
operator|->
name|cur_st
argument_list|)
expr_stmt|;
comment|/* Not if we only have partial info */
if|if
condition|(
name|SC_IS_UNDEF
argument_list|(
name|sh
operator|->
name|sc
argument_list|)
operator|||
name|sh
operator|->
name|sc
operator|==
name|scNil
condition|)
break|break;
name|push_parse_stack
argument_list|()
expr_stmt|;
name|top_stack
operator|->
name|cur_block
operator|=
name|b
expr_stmt|;
name|top_stack
operator|->
name|blocktype
operator|=
name|sh
operator|->
name|st
expr_stmt|;
name|top_stack
operator|->
name|cur_type
operator|=
name|SYMBOL_TYPE
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|top_stack
operator|->
name|cur_field
operator|=
operator|-
literal|1
expr_stmt|;
name|top_stack
operator|->
name|procadr
operator|=
name|sh
operator|->
name|value
expr_stmt|;
name|top_stack
operator|->
name|numargs
operator|=
literal|0
expr_stmt|;
break|break;
comment|/* Beginning of code for structure, union, and enum definitions. 	       They all share a common set of local variables, defined here.  */
block|{
name|enum
name|type_code
name|type_code
decl_stmt|;
name|char
modifier|*
name|ext_tsym
decl_stmt|;
name|int
name|nfields
decl_stmt|;
name|long
name|max_value
decl_stmt|;
name|struct
name|field
modifier|*
name|f
decl_stmt|;
case|case
name|stStruct
case|:
comment|/* Start a block defining a struct type */
name|type_code
operator|=
name|TYPE_CODE_STRUCT
expr_stmt|;
goto|goto
name|structured_common
goto|;
case|case
name|stUnion
case|:
comment|/* Start a block defining a union type */
name|type_code
operator|=
name|TYPE_CODE_UNION
expr_stmt|;
goto|goto
name|structured_common
goto|;
case|case
name|stEnum
case|:
comment|/* Start a block defining an enum type */
name|type_code
operator|=
name|TYPE_CODE_ENUM
expr_stmt|;
goto|goto
name|structured_common
goto|;
case|case
name|stBlock
case|:
comment|/* Either a lexical block, or some type */
if|if
condition|(
name|sh
operator|->
name|sc
operator|!=
name|scInfo
operator|&&
operator|!
name|SC_IS_COMMON
argument_list|(
name|sh
operator|->
name|sc
argument_list|)
condition|)
goto|goto
name|case_stBlock_code
goto|;
comment|/* Lexical block */
name|type_code
operator|=
name|TYPE_CODE_UNDEF
expr_stmt|;
comment|/* We have a type.  */
comment|/* Common code for handling struct, union, enum, and/or as-yet- 	   unknown-type blocks of info about structured data.  `type_code' 	   has been set to the proper TYPE_CODE, if we know it.  */
name|structured_common
label|:
name|found_ecoff_debugging_info
operator|=
literal|1
expr_stmt|;
name|push_parse_stack
argument_list|()
expr_stmt|;
name|top_stack
operator|->
name|blocktype
operator|=
name|stBlock
expr_stmt|;
comment|/* First count the number of fields and the highest value. */
name|nfields
operator|=
literal|0
expr_stmt|;
name|max_value
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ext_tsym
operator|=
name|ext_sh
operator|+
name|external_sym_size
init|;
condition|;
name|ext_tsym
operator|+=
name|external_sym_size
control|)
block|{
name|SYMR
name|tsym
decl_stmt|;
call|(
modifier|*
name|swap_sym_in
call|)
argument_list|(
name|cur_bfd
argument_list|,
name|ext_tsym
argument_list|,
operator|&
name|tsym
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tsym
operator|.
name|st
condition|)
block|{
case|case
name|stEnd
case|:
goto|goto
name|end_of_fields
goto|;
case|case
name|stMember
case|:
if|if
condition|(
name|nfields
operator|==
literal|0
operator|&&
name|type_code
operator|==
name|TYPE_CODE_UNDEF
condition|)
comment|/* If the type of the member is Nil (or Void), 		     without qualifiers, assume the tag is an 		     enumeration. 		     Alpha cc -migrate enums are recognized by a zero 		     index and a zero symbol value. 		     DU 4.0 cc enums are recognized by a member type of 		     btEnum without qualifiers and a zero symbol value.  */
if|if
condition|(
name|tsym
operator|.
name|index
operator|==
name|indexNil
operator|||
operator|(
name|tsym
operator|.
name|index
operator|==
literal|0
operator|&&
name|sh
operator|->
name|value
operator|==
literal|0
operator|)
condition|)
name|type_code
operator|=
name|TYPE_CODE_ENUM
expr_stmt|;
else|else
block|{
call|(
modifier|*
name|debug_swap
operator|->
name|swap_tir_in
call|)
argument_list|(
name|bigend
argument_list|,
operator|&
name|ax
index|[
name|tsym
operator|.
name|index
index|]
operator|.
name|a_ti
argument_list|,
operator|&
name|tir
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tir
operator|.
name|bt
operator|==
name|btNil
operator|||
name|tir
operator|.
name|bt
operator|==
name|btVoid
operator|||
operator|(
name|tir
operator|.
name|bt
operator|==
name|btEnum
operator|&&
name|sh
operator|->
name|value
operator|==
literal|0
operator|)
operator|)
operator|&&
name|tir
operator|.
name|tq0
operator|==
name|tqNil
condition|)
name|type_code
operator|=
name|TYPE_CODE_ENUM
expr_stmt|;
block|}
name|nfields
operator|++
expr_stmt|;
if|if
condition|(
name|tsym
operator|.
name|value
operator|>
name|max_value
condition|)
name|max_value
operator|=
name|tsym
operator|.
name|value
expr_stmt|;
break|break;
case|case
name|stBlock
case|:
case|case
name|stUnion
case|:
case|case
name|stEnum
case|:
case|case
name|stStruct
case|:
block|{
if|#
directive|if
literal|0
comment|/* This is a no-op; is it trying to tell us something 		     we should be checking?  */
block|if (tsym.sc == scVariant);
comment|/*UNIMPLEMENTED*/
endif|#
directive|endif
if|if
condition|(
name|tsym
operator|.
name|index
operator|!=
literal|0
condition|)
block|{
comment|/* This is something like a struct within a 			 struct.  Skip over the fields of the inner 			 struct.  The -1 is because the for loop will 			 increment ext_tsym.  */
name|ext_tsym
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|debug_info
operator|->
name|external_sym
operator|+
operator|(
operator|(
name|cur_fdr
operator|->
name|isymBase
operator|+
name|tsym
operator|.
name|index
operator|-
literal|1
operator|)
operator|*
name|external_sym_size
operator|)
operator|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|stTypedef
case|:
comment|/* mips cc puts out a typedef for struct x if it is not yet 		   defined when it encounters 		   struct y { struct x *xp; }; 		   Just ignore it. */
break|break;
case|case
name|stIndirect
case|:
comment|/* Irix5 cc puts out a stIndirect for struct x if it is not 		   yet defined when it encounters 		   struct y { struct x *xp; }; 		   Just ignore it. */
break|break;
default|default:
name|complain
argument_list|(
operator|&
name|block_member_complaint
argument_list|,
name|tsym
operator|.
name|st
argument_list|)
expr_stmt|;
block|}
block|}
name|end_of_fields
label|:
empty_stmt|;
comment|/* In an stBlock, there is no way to distinguish structs, 	   unions, and enums at this point.  This is a bug in the 	   original design (that has been fixed with the recent 	   addition of the stStruct, stUnion, and stEnum symbol 	   types.)  The way you can tell is if/when you see a variable 	   or field of that type.  In that case the variable's type 	   (in the AUX table) says if the type is struct, union, or 	   enum, and points back to the stBlock here.  So you can 	   patch the tag kind up later - but only if there actually is 	   a variable or field of that type.  	   So until we know for sure, we will guess at this point. 	   The heuristic is: 	   If the first member has index==indexNil or a void type, 	   assume we have an enumeration. 	   Otherwise, if there is more than one member, and all 	   the members have offset 0, assume we have a union. 	   Otherwise, assume we have a struct.  	   The heuristic could guess wrong in the case of of an 	   enumeration with no members or a union with one (or zero) 	   members, or when all except the last field of a struct have 	   width zero.  These are uncommon and/or illegal situations, 	   and in any case guessing wrong probably doesn't matter 	   much.  	   But if we later do find out we were wrong, we fixup the tag 	   kind.  Members of an enumeration must be handled 	   differently from struct/union fields, and that is harder to 	   patch up, but luckily we shouldn't need to.  (If there are 	   any enumeration members, we can tell for sure it's an enum 	   here.) */
if|if
condition|(
name|type_code
operator|==
name|TYPE_CODE_UNDEF
condition|)
if|if
condition|(
name|nfields
operator|>
literal|1
operator|&&
name|max_value
operator|==
literal|0
condition|)
name|type_code
operator|=
name|TYPE_CODE_UNION
expr_stmt|;
else|else
name|type_code
operator|=
name|TYPE_CODE_STRUCT
expr_stmt|;
comment|/* Create a new type or use the pending type.  */
name|pend
operator|=
name|is_pending_symbol
argument_list|(
name|cur_fdr
argument_list|,
name|ext_sh
argument_list|)
expr_stmt|;
if|if
condition|(
name|pend
operator|==
operator|(
expr|struct
name|mdebug_pending
operator|*
operator|)
name|NULL
condition|)
block|{
name|t
operator|=
name|new_type
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|add_pending
argument_list|(
name|cur_fdr
argument_list|,
name|ext_sh
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
else|else
name|t
operator|=
name|pend
operator|->
name|t
expr_stmt|;
comment|/* Do not set the tag name if it is a compiler generated tag name 	   (.Fxx or .xxfake or empty) for unnamed struct/union/enums. 	   Alpha cc puts out an sh->iss of zero for those.  */
if|if
condition|(
name|sh
operator|->
name|iss
operator|==
literal|0
operator|||
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|||
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|TYPE_TAG_NAME
argument_list|(
name|t
argument_list|)
operator|=
name|NULL
expr_stmt|;
else|else
name|TYPE_TAG_NAME
argument_list|(
name|t
argument_list|)
operator|=
name|obconcat
argument_list|(
operator|&
name|current_objfile
operator|->
name|symbol_obstack
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|TYPE_CODE
argument_list|(
name|t
argument_list|)
operator|=
name|type_code
expr_stmt|;
name|TYPE_LENGTH
argument_list|(
name|t
argument_list|)
operator|=
name|sh
operator|->
name|value
expr_stmt|;
name|TYPE_NFIELDS
argument_list|(
name|t
argument_list|)
operator|=
name|nfields
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
operator|=
name|f
operator|=
operator|(
operator|(
expr|struct
name|field
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|t
argument_list|,
name|nfields
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|type_code
operator|==
name|TYPE_CODE_ENUM
condition|)
block|{
name|int
name|unsigned_enum
init|=
literal|1
decl_stmt|;
comment|/* This is a non-empty enum. */
comment|/* DEC c89 has the number of enumerators in the sh.value field, 	       not the type length, so we have to compensate for that 	       incompatibility quirk. 	       This might do the wrong thing for an enum with one or two 	       enumerators and gcc -gcoff -fshort-enums, but these cases 	       are hopefully rare enough. 	       Alpha cc -migrate has a sh.value field of zero, we adjust 	       that too.  */
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_NFIELDS
argument_list|(
name|t
argument_list|)
operator|||
name|TYPE_LENGTH
argument_list|(
name|t
argument_list|)
operator|==
literal|0
condition|)
name|TYPE_LENGTH
argument_list|(
name|t
argument_list|)
operator|=
name|TARGET_INT_BIT
operator|/
name|HOST_CHAR_BIT
expr_stmt|;
for|for
control|(
name|ext_tsym
operator|=
name|ext_sh
operator|+
name|external_sym_size
init|;
condition|;
name|ext_tsym
operator|+=
name|external_sym_size
control|)
block|{
name|SYMR
name|tsym
decl_stmt|;
name|struct
name|symbol
modifier|*
name|enum_sym
decl_stmt|;
call|(
modifier|*
name|swap_sym_in
call|)
argument_list|(
name|cur_bfd
argument_list|,
name|ext_tsym
argument_list|,
operator|&
name|tsym
argument_list|)
expr_stmt|;
if|if
condition|(
name|tsym
operator|.
name|st
operator|!=
name|stMember
condition|)
break|break;
name|FIELD_BITPOS
argument_list|(
operator|*
name|f
argument_list|)
operator|=
name|tsym
operator|.
name|value
expr_stmt|;
name|FIELD_TYPE
argument_list|(
operator|*
name|f
argument_list|)
operator|=
name|t
expr_stmt|;
name|FIELD_NAME
argument_list|(
operator|*
name|f
argument_list|)
operator|=
name|debug_info
operator|->
name|ss
operator|+
name|cur_fdr
operator|->
name|issBase
operator|+
name|tsym
operator|.
name|iss
expr_stmt|;
name|FIELD_BITSIZE
argument_list|(
operator|*
name|f
argument_list|)
operator|=
literal|0
expr_stmt|;
name|enum_sym
operator|=
operator|(
operator|(
expr|struct
name|symbol
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|current_objfile
operator|->
name|symbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|PTR
operator|)
name|enum_sym
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
name|SYMBOL_NAME
argument_list|(
name|enum_sym
argument_list|)
operator|=
name|obsavestring
argument_list|(
name|f
operator|->
name|name
argument_list|,
name|strlen
argument_list|(
name|f
operator|->
name|name
argument_list|)
argument_list|,
operator|&
name|current_objfile
operator|->
name|symbol_obstack
argument_list|)
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|enum_sym
argument_list|)
operator|=
name|LOC_CONST
expr_stmt|;
name|SYMBOL_TYPE
argument_list|(
name|enum_sym
argument_list|)
operator|=
name|t
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|enum_sym
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|enum_sym
argument_list|)
operator|=
name|tsym
operator|.
name|value
expr_stmt|;
if|if
condition|(
name|SYMBOL_VALUE
argument_list|(
name|enum_sym
argument_list|)
operator|<
literal|0
condition|)
name|unsigned_enum
operator|=
literal|0
expr_stmt|;
name|add_symbol
argument_list|(
name|enum_sym
argument_list|,
name|top_stack
operator|->
name|cur_block
argument_list|)
expr_stmt|;
comment|/* Skip the stMembers that we've handled. */
name|count
operator|++
expr_stmt|;
name|f
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|unsigned_enum
condition|)
name|TYPE_FLAGS
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_FLAG_UNSIGNED
expr_stmt|;
block|}
comment|/* make this the current type */
name|top_stack
operator|->
name|cur_type
operator|=
name|t
expr_stmt|;
name|top_stack
operator|->
name|cur_field
operator|=
literal|0
expr_stmt|;
comment|/* Do not create a symbol for alpha cc unnamed structs.  */
if|if
condition|(
name|sh
operator|->
name|iss
operator|==
literal|0
condition|)
break|break;
comment|/* gcc puts out an empty struct for an opaque struct definitions, 	   do not create a symbol for it either.  */
if|if
condition|(
name|TYPE_NFIELDS
argument_list|(
name|t
argument_list|)
operator|==
literal|0
condition|)
block|{
name|TYPE_FLAGS
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_FLAG_STUB
expr_stmt|;
break|break;
block|}
name|s
operator|=
name|new_symbol
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|s
argument_list|)
operator|=
name|STRUCT_NAMESPACE
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|s
argument_list|)
operator|=
name|LOC_TYPEDEF
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|s
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SYMBOL_TYPE
argument_list|(
name|s
argument_list|)
operator|=
name|t
expr_stmt|;
name|add_symbol
argument_list|(
name|s
argument_list|,
name|top_stack
operator|->
name|cur_block
argument_list|)
expr_stmt|;
break|break;
comment|/* End of local variables shared by struct, union, enum, and 	   block (as yet unknown struct/union/enum) processing.  */
block|}
name|case_stBlock_code
label|:
name|found_ecoff_debugging_info
operator|=
literal|1
expr_stmt|;
comment|/* beginnning of (code) block. Value of symbol 	 is the displacement from procedure start */
name|push_parse_stack
argument_list|()
expr_stmt|;
comment|/* Do not start a new block if this is the outermost block of a 	 procedure.  This allows the LOC_BLOCK symbol to point to the 	 block with the local variables, so funcname::var works.  */
if|if
condition|(
name|top_stack
operator|->
name|blocktype
operator|==
name|stProc
operator|||
name|top_stack
operator|->
name|blocktype
operator|==
name|stStaticProc
condition|)
block|{
name|top_stack
operator|->
name|blocktype
operator|=
name|stNil
expr_stmt|;
break|break;
block|}
name|top_stack
operator|->
name|blocktype
operator|=
name|stBlock
expr_stmt|;
name|b
operator|=
name|new_block
argument_list|(
name|top_stack
operator|->
name|maxsyms
argument_list|)
expr_stmt|;
name|BLOCK_START
argument_list|(
name|b
argument_list|)
operator|=
name|sh
operator|->
name|value
operator|+
name|top_stack
operator|->
name|procadr
expr_stmt|;
name|BLOCK_SUPERBLOCK
argument_list|(
name|b
argument_list|)
operator|=
name|top_stack
operator|->
name|cur_block
expr_stmt|;
name|top_stack
operator|->
name|cur_block
operator|=
name|b
expr_stmt|;
name|add_block
argument_list|(
name|b
argument_list|,
name|top_stack
operator|->
name|cur_st
argument_list|)
expr_stmt|;
break|break;
case|case
name|stEnd
case|:
comment|/* end (of anything) */
if|if
condition|(
name|sh
operator|->
name|sc
operator|==
name|scInfo
operator|||
name|SC_IS_COMMON
argument_list|(
name|sh
operator|->
name|sc
argument_list|)
condition|)
block|{
comment|/* Finished with type */
name|top_stack
operator|->
name|cur_type
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sh
operator|->
name|sc
operator|==
name|scText
operator|&&
operator|(
name|top_stack
operator|->
name|blocktype
operator|==
name|stProc
operator|||
name|top_stack
operator|->
name|blocktype
operator|==
name|stStaticProc
operator|)
condition|)
block|{
comment|/* Finished with procedure */
name|struct
name|blockvector
modifier|*
name|bv
init|=
name|BLOCKVECTOR
argument_list|(
name|top_stack
operator|->
name|cur_st
argument_list|)
decl_stmt|;
name|struct
name|mips_extra_func_info
modifier|*
name|e
decl_stmt|;
name|struct
name|block
modifier|*
name|b
decl_stmt|;
name|struct
name|type
modifier|*
name|ftype
init|=
name|top_stack
operator|->
name|cur_type
decl_stmt|;
name|int
name|i
decl_stmt|;
name|BLOCK_END
argument_list|(
name|top_stack
operator|->
name|cur_block
argument_list|)
operator|+=
name|sh
operator|->
name|value
expr_stmt|;
comment|/* size */
comment|/* Make up special symbol to contain procedure specific info */
name|s
operator|=
name|new_symbol
argument_list|(
name|MIPS_EFI_SYMBOL_NAME
argument_list|)
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|s
argument_list|)
operator|=
name|LABEL_NAMESPACE
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|s
argument_list|)
operator|=
name|LOC_CONST
expr_stmt|;
name|SYMBOL_TYPE
argument_list|(
name|s
argument_list|)
operator|=
name|mdebug_type_void
expr_stmt|;
name|e
operator|=
operator|(
operator|(
expr|struct
name|mips_extra_func_info
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|current_objfile
operator|->
name|symbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mips_extra_func_info
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|PTR
operator|)
name|e
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mips_extra_func_info
argument_list|)
argument_list|)
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|s
argument_list|)
operator|=
operator|(
name|long
operator|)
name|e
expr_stmt|;
name|e
operator|->
name|numargs
operator|=
name|top_stack
operator|->
name|numargs
expr_stmt|;
name|e
operator|->
name|pdr
operator|.
name|framereg
operator|=
operator|-
literal|1
expr_stmt|;
name|add_symbol
argument_list|(
name|s
argument_list|,
name|top_stack
operator|->
name|cur_block
argument_list|)
expr_stmt|;
comment|/* Reallocate symbols, saving memory */
name|b
operator|=
name|shrink_block
argument_list|(
name|top_stack
operator|->
name|cur_block
argument_list|,
name|top_stack
operator|->
name|cur_st
argument_list|)
expr_stmt|;
comment|/* f77 emits proc-level with address bounds==[0,0], 	     So look for such child blocks, and patch them.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BLOCKVECTOR_NBLOCKS
argument_list|(
name|bv
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|block
modifier|*
name|b_bad
init|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|BLOCK_SUPERBLOCK
argument_list|(
name|b_bad
argument_list|)
operator|==
name|b
operator|&&
name|BLOCK_START
argument_list|(
name|b_bad
argument_list|)
operator|==
name|top_stack
operator|->
name|procadr
operator|&&
name|BLOCK_END
argument_list|(
name|b_bad
argument_list|)
operator|==
name|top_stack
operator|->
name|procadr
condition|)
block|{
name|BLOCK_START
argument_list|(
name|b_bad
argument_list|)
operator|=
name|BLOCK_START
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|BLOCK_END
argument_list|(
name|b_bad
argument_list|)
operator|=
name|BLOCK_END
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TYPE_NFIELDS
argument_list|(
name|ftype
argument_list|)
operator|<=
literal|0
condition|)
block|{
comment|/* No parameter type information is recorded with the function's 		 type.  Set that from the type of the parameter symbols. */
name|int
name|nparams
init|=
name|top_stack
operator|->
name|numargs
decl_stmt|;
name|int
name|iparams
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
if|if
condition|(
name|nparams
operator|>
literal|0
condition|)
block|{
name|TYPE_NFIELDS
argument_list|(
name|ftype
argument_list|)
operator|=
name|nparams
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|ftype
argument_list|)
operator|=
operator|(
expr|struct
name|field
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|ftype
argument_list|,
name|nparams
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|iparams
operator|=
literal|0
init|;
name|iparams
operator|<
name|nparams
condition|;
name|i
operator|++
control|)
block|{
name|sym
operator|=
name|BLOCK_SYM
argument_list|(
name|b
argument_list|,
name|i
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
condition|)
block|{
case|case
name|LOC_ARG
case|:
case|case
name|LOC_REF_ARG
case|:
case|case
name|LOC_REGPARM
case|:
case|case
name|LOC_REGPARM_ADDR
case|:
name|TYPE_FIELD_TYPE
argument_list|(
name|ftype
argument_list|,
name|iparams
argument_list|)
operator|=
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|iparams
operator|++
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|sh
operator|->
name|sc
operator|==
name|scText
operator|&&
name|top_stack
operator|->
name|blocktype
operator|==
name|stBlock
condition|)
block|{
comment|/* End of (code) block. The value of the symbol is the 	     displacement from the procedure`s start address of the 	     end of this block. */
name|BLOCK_END
argument_list|(
name|top_stack
operator|->
name|cur_block
argument_list|)
operator|=
name|sh
operator|->
name|value
operator|+
name|top_stack
operator|->
name|procadr
expr_stmt|;
name|shrink_block
argument_list|(
name|top_stack
operator|->
name|cur_block
argument_list|,
name|top_stack
operator|->
name|cur_st
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sh
operator|->
name|sc
operator|==
name|scText
operator|&&
name|top_stack
operator|->
name|blocktype
operator|==
name|stNil
condition|)
block|{
comment|/* End of outermost block.  Pop parse stack and ignore.  The 	     following stEnd of stProc will take care of the block.  */
empty_stmt|;
block|}
elseif|else
if|if
condition|(
name|sh
operator|->
name|sc
operator|==
name|scText
operator|&&
name|top_stack
operator|->
name|blocktype
operator|==
name|stFile
condition|)
block|{
comment|/* End of file.  Pop parse stack and ignore.  Higher 	     level code deals with this.  */
empty_stmt|;
block|}
else|else
name|complain
argument_list|(
operator|&
name|stEnd_complaint
argument_list|,
name|sh
operator|->
name|sc
argument_list|)
expr_stmt|;
name|pop_parse_stack
argument_list|()
expr_stmt|;
comment|/* restore previous lexical context */
break|break;
case|case
name|stMember
case|:
comment|/* member of struct or union */
name|f
operator|=
operator|&
name|TYPE_FIELDS
argument_list|(
name|top_stack
operator|->
name|cur_type
argument_list|)
index|[
name|top_stack
operator|->
name|cur_field
operator|++
index|]
expr_stmt|;
name|FIELD_NAME
argument_list|(
operator|*
name|f
argument_list|)
operator|=
name|name
expr_stmt|;
name|FIELD_BITPOS
argument_list|(
operator|*
name|f
argument_list|)
operator|=
name|sh
operator|->
name|value
expr_stmt|;
name|bitsize
operator|=
literal|0
expr_stmt|;
name|FIELD_TYPE
argument_list|(
operator|*
name|f
argument_list|)
operator|=
name|parse_type
argument_list|(
name|cur_fd
argument_list|,
name|ax
argument_list|,
name|sh
operator|->
name|index
argument_list|,
operator|&
name|bitsize
argument_list|,
name|bigend
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|FIELD_BITSIZE
argument_list|(
operator|*
name|f
argument_list|)
operator|=
name|bitsize
expr_stmt|;
break|break;
case|case
name|stIndirect
case|:
comment|/* forward declaration on Irix5 */
comment|/* Forward declarations from Irix5 cc are handled by cross_ref, 	 skip them.  */
break|break;
case|case
name|stTypedef
case|:
comment|/* type definition */
name|found_ecoff_debugging_info
operator|=
literal|1
expr_stmt|;
comment|/* Typedefs for forward declarations and opaque structs from alpha cc 	 are handled by cross_ref, skip them.  */
if|if
condition|(
name|sh
operator|->
name|iss
operator|==
literal|0
condition|)
break|break;
comment|/* Parse the type or use the pending type.  */
name|pend
operator|=
name|is_pending_symbol
argument_list|(
name|cur_fdr
argument_list|,
name|ext_sh
argument_list|)
expr_stmt|;
if|if
condition|(
name|pend
operator|==
operator|(
expr|struct
name|mdebug_pending
operator|*
operator|)
name|NULL
condition|)
block|{
name|t
operator|=
name|parse_type
argument_list|(
name|cur_fd
argument_list|,
name|ax
argument_list|,
name|sh
operator|->
name|index
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
name|bigend
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|add_pending
argument_list|(
name|cur_fdr
argument_list|,
name|ext_sh
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
else|else
name|t
operator|=
name|pend
operator|->
name|t
expr_stmt|;
comment|/* mips cc puts out a typedef with the name of the struct for forward 	 declarations. These should not go into the symbol table and 	 TYPE_NAME should not be set for them. 	 They can't be distinguished from an intentional typedef to 	 the same name however: 	 x.h: 		struct x { int ix; int jx; }; 		struct xx; 	 x.c: 		typedef struct x x; 		struct xx {int ixx; int jxx; }; 	 generates a cross referencing stTypedef for x and xx. 	 The user visible effect of this is that the type of a pointer 	 to struct foo sometimes is given as `foo *' instead of `struct foo *'. 	 The problem is fixed with alpha cc and Irix5 cc.  */
comment|/* However if the typedef cross references to an opaque aggregate, it 	 is safe to omit it from the symbol table.  */
if|if
condition|(
name|has_opaque_xref
argument_list|(
name|cur_fdr
argument_list|,
name|sh
argument_list|)
condition|)
break|break;
name|s
operator|=
name|new_symbol
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|s
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|s
argument_list|)
operator|=
name|LOC_TYPEDEF
expr_stmt|;
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|s
argument_list|)
operator|=
name|top_stack
operator|->
name|cur_block
expr_stmt|;
name|SYMBOL_TYPE
argument_list|(
name|s
argument_list|)
operator|=
name|t
expr_stmt|;
name|add_symbol
argument_list|(
name|s
argument_list|,
name|top_stack
operator|->
name|cur_block
argument_list|)
expr_stmt|;
comment|/* Incomplete definitions of structs should not get a name.  */
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|s
argument_list|)
argument_list|)
operator|==
name|NULL
operator|&&
operator|(
name|TYPE_NFIELDS
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|s
argument_list|)
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|s
argument_list|)
argument_list|)
operator|!=
name|TYPE_CODE_STRUCT
operator|&&
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|s
argument_list|)
argument_list|)
operator|!=
name|TYPE_CODE_UNION
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|s
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_PTR
operator|||
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|s
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_FUNC
condition|)
block|{
comment|/* If we are giving a name to a type such as "pointer to 		 foo" or "function returning foo", we better not set 		 the TYPE_NAME.  If the program contains "typedef char 		 *caddr_t;", we don't want all variables of type char 		 * to print as caddr_t.  This is not just a 		 consequence of GDB's type management; CC and GCC (at 		 least through version 2.4) both output variables of 		 either type char * or caddr_t with the type 		 refering to the stTypedef symbol for caddr_t.  If a future 		 compiler cleans this up it GDB is not ready for it 		 yet, but if it becomes ready we somehow need to 		 disable this check (without breaking the PCC/GCC2.4 		 case).  		 Sigh.  		 Fortunately, this check seems not to be necessary 		 for anything except pointers or functions.  */
block|}
else|else
name|TYPE_NAME
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|s
argument_list|)
argument_list|)
operator|=
name|SYMBOL_NAME
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|stFile
case|:
comment|/* file name */
name|push_parse_stack
argument_list|()
expr_stmt|;
name|top_stack
operator|->
name|blocktype
operator|=
name|sh
operator|->
name|st
expr_stmt|;
break|break;
comment|/* I`ve never seen these for C */
case|case
name|stRegReloc
case|:
break|break;
comment|/* register relocation */
case|case
name|stForward
case|:
break|break;
comment|/* forwarding address */
case|case
name|stConstant
case|:
break|break;
comment|/* constant */
default|default:
name|complain
argument_list|(
operator|&
name|unknown_mdebug_symtype_complaint
argument_list|,
name|sh
operator|->
name|st
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|count
return|;
block|}
end_function

begin_comment
comment|/* Parse the type information provided in the raw AX entries for    the symbol SH. Return the bitfield size in BS, in case.    We must byte-swap the AX entries before we use them; BIGEND says whether    they are big-endian or little-endian (from fh->fBigendian).  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|parse_type
parameter_list|(
name|fd
parameter_list|,
name|ax
parameter_list|,
name|aux_index
parameter_list|,
name|bs
parameter_list|,
name|bigend
parameter_list|,
name|sym_name
parameter_list|)
name|int
name|fd
decl_stmt|;
name|union
name|aux_ext
modifier|*
name|ax
decl_stmt|;
name|unsigned
name|int
name|aux_index
decl_stmt|;
name|int
modifier|*
name|bs
decl_stmt|;
name|int
name|bigend
decl_stmt|;
name|char
modifier|*
name|sym_name
decl_stmt|;
block|{
comment|/* Null entries in this map are treated specially */
specifier|static
name|struct
name|type
modifier|*
modifier|*
name|map_bt
index|[]
init|=
block|{
operator|&
name|mdebug_type_void
block|,
comment|/* btNil */
operator|&
name|mdebug_type_adr_32
block|,
comment|/* btAdr */
operator|&
name|mdebug_type_char
block|,
comment|/* btChar */
operator|&
name|mdebug_type_unsigned_char
block|,
comment|/* btUChar */
operator|&
name|mdebug_type_short
block|,
comment|/* btShort */
operator|&
name|mdebug_type_unsigned_short
block|,
comment|/* btUShort */
operator|&
name|mdebug_type_int_32
block|,
comment|/* btInt */
operator|&
name|mdebug_type_unsigned_int_32
block|,
comment|/* btUInt */
operator|&
name|mdebug_type_long_32
block|,
comment|/* btLong */
operator|&
name|mdebug_type_unsigned_long_32
block|,
comment|/* btULong */
operator|&
name|mdebug_type_float
block|,
comment|/* btFloat */
operator|&
name|mdebug_type_double
block|,
comment|/* btDouble */
literal|0
block|,
comment|/* btStruct */
literal|0
block|,
comment|/* btUnion */
literal|0
block|,
comment|/* btEnum */
literal|0
block|,
comment|/* btTypedef */
literal|0
block|,
comment|/* btRange */
literal|0
block|,
comment|/* btSet */
operator|&
name|mdebug_type_complex
block|,
comment|/* btComplex */
operator|&
name|mdebug_type_double_complex
block|,
comment|/* btDComplex */
literal|0
block|,
comment|/* btIndirect */
operator|&
name|mdebug_type_fixed_dec
block|,
comment|/* btFixedDec */
operator|&
name|mdebug_type_float_dec
block|,
comment|/* btFloatDec */
operator|&
name|mdebug_type_string
block|,
comment|/* btString */
literal|0
block|,
comment|/* btBit */
literal|0
block|,
comment|/* btPicture */
operator|&
name|mdebug_type_void
block|,
comment|/* btVoid */
literal|0
block|,
comment|/* DEC C++:  Pointer to member */
literal|0
block|,
comment|/* DEC C++:  Virtual function table */
literal|0
block|,
comment|/* DEC C++:  Class (Record) */
operator|&
name|mdebug_type_long_64
block|,
comment|/* btLong64  */
operator|&
name|mdebug_type_unsigned_long_64
block|,
comment|/* btULong64 */
operator|&
name|mdebug_type_long_long_64
block|,
comment|/* btLongLong64  */
operator|&
name|mdebug_type_unsigned_long_long_64
block|,
comment|/* btULongLong64 */
operator|&
name|mdebug_type_adr_64
block|,
comment|/* btAdr64 */
operator|&
name|mdebug_type_int_64
block|,
comment|/* btInt64  */
operator|&
name|mdebug_type_unsigned_int_64
block|,
comment|/* btUInt64 */
block|}
decl_stmt|;
name|TIR
name|t
index|[
literal|1
index|]
decl_stmt|;
name|struct
name|type
modifier|*
name|tp
init|=
literal|0
decl_stmt|;
name|enum
name|type_code
name|type_code
init|=
name|TYPE_CODE_UNDEF
decl_stmt|;
comment|/* Handle undefined types, they have indexNil. */
if|if
condition|(
name|aux_index
operator|==
name|indexNil
condition|)
return|return
name|mdebug_type_int
return|;
comment|/* Handle corrupt aux indices.  */
if|if
condition|(
name|aux_index
operator|>=
operator|(
name|debug_info
operator|->
name|fdr
operator|+
name|fd
operator|)
operator|->
name|caux
condition|)
block|{
name|complain
argument_list|(
operator|&
name|index_complaint
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
return|return
name|mdebug_type_int
return|;
block|}
name|ax
operator|+=
name|aux_index
expr_stmt|;
comment|/* Use aux as a type information record, map its basic type.  */
call|(
modifier|*
name|debug_swap
operator|->
name|swap_tir_in
call|)
argument_list|(
name|bigend
argument_list|,
operator|&
name|ax
operator|->
name|a_ti
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|bt
operator|>=
operator|(
sizeof|sizeof
argument_list|(
name|map_bt
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|map_bt
argument_list|)
operator|)
condition|)
block|{
name|complain
argument_list|(
operator|&
name|basic_type_complaint
argument_list|,
name|t
operator|->
name|bt
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
return|return
name|mdebug_type_int
return|;
block|}
if|if
condition|(
name|map_bt
index|[
name|t
operator|->
name|bt
index|]
condition|)
block|{
name|tp
operator|=
operator|*
name|map_bt
index|[
name|t
operator|->
name|bt
index|]
expr_stmt|;
block|}
else|else
block|{
name|tp
operator|=
name|NULL
expr_stmt|;
comment|/* Cannot use builtin types -- build our own */
switch|switch
condition|(
name|t
operator|->
name|bt
condition|)
block|{
case|case
name|btStruct
case|:
name|type_code
operator|=
name|TYPE_CODE_STRUCT
expr_stmt|;
break|break;
case|case
name|btUnion
case|:
name|type_code
operator|=
name|TYPE_CODE_UNION
expr_stmt|;
break|break;
case|case
name|btEnum
case|:
name|type_code
operator|=
name|TYPE_CODE_ENUM
expr_stmt|;
break|break;
case|case
name|btRange
case|:
name|type_code
operator|=
name|TYPE_CODE_RANGE
expr_stmt|;
break|break;
case|case
name|btSet
case|:
name|type_code
operator|=
name|TYPE_CODE_SET
expr_stmt|;
break|break;
case|case
name|btIndirect
case|:
comment|/* alpha cc -migrate uses this for typedefs. The true type will 	     be obtained by crossreferencing below.  */
name|type_code
operator|=
name|TYPE_CODE_ERROR
expr_stmt|;
break|break;
case|case
name|btTypedef
case|:
comment|/* alpha cc uses this for typedefs. The true type will be 	     obtained by crossreferencing below.  */
name|type_code
operator|=
name|TYPE_CODE_ERROR
expr_stmt|;
break|break;
default|default:
name|complain
argument_list|(
operator|&
name|basic_type_complaint
argument_list|,
name|t
operator|->
name|bt
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
return|return
name|mdebug_type_int
return|;
block|}
block|}
comment|/* Move on to next aux */
name|ax
operator|++
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|fBitfield
condition|)
block|{
name|int
name|width
init|=
name|AUX_GET_WIDTH
argument_list|(
name|bigend
argument_list|,
name|ax
argument_list|)
decl_stmt|;
comment|/* Inhibit core dumps with some cfront generated objects that 	 corrupt the TIR.  */
if|if
condition|(
name|bs
operator|==
operator|(
name|int
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* Alpha cc -migrate encodes char and unsigned char types 	     as short and unsigned short types with a field width of 8. 	     Enum types also have a field width which we ignore for now.  */
if|if
condition|(
name|t
operator|->
name|bt
operator|==
name|btShort
operator|&&
name|width
operator|==
literal|8
condition|)
name|tp
operator|=
name|mdebug_type_char
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|->
name|bt
operator|==
name|btUShort
operator|&&
name|width
operator|==
literal|8
condition|)
name|tp
operator|=
name|mdebug_type_unsigned_char
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|->
name|bt
operator|==
name|btEnum
condition|)
empty_stmt|;
else|else
name|complain
argument_list|(
operator|&
name|bad_fbitfield_complaint
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|bs
operator|=
name|width
expr_stmt|;
name|ax
operator|++
expr_stmt|;
block|}
comment|/* A btIndirect entry cross references to an aux entry containing      the type.  */
if|if
condition|(
name|t
operator|->
name|bt
operator|==
name|btIndirect
condition|)
block|{
name|RNDXR
name|rn
index|[
literal|1
index|]
decl_stmt|;
name|int
name|rf
decl_stmt|;
name|FDR
modifier|*
name|xref_fh
decl_stmt|;
name|int
name|xref_fd
decl_stmt|;
call|(
modifier|*
name|debug_swap
operator|->
name|swap_rndx_in
call|)
argument_list|(
name|bigend
argument_list|,
operator|&
name|ax
operator|->
name|a_rndx
argument_list|,
name|rn
argument_list|)
expr_stmt|;
name|ax
operator|++
expr_stmt|;
if|if
condition|(
name|rn
operator|->
name|rfd
operator|==
literal|0xfff
condition|)
block|{
name|rf
operator|=
name|AUX_GET_ISYM
argument_list|(
name|bigend
argument_list|,
name|ax
argument_list|)
expr_stmt|;
name|ax
operator|++
expr_stmt|;
block|}
else|else
name|rf
operator|=
name|rn
operator|->
name|rfd
expr_stmt|;
if|if
condition|(
name|rf
operator|==
operator|-
literal|1
condition|)
block|{
name|complain
argument_list|(
operator|&
name|bad_indirect_xref_complaint
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
return|return
name|mdebug_type_int
return|;
block|}
name|xref_fh
operator|=
name|get_rfd
argument_list|(
name|fd
argument_list|,
name|rf
argument_list|)
expr_stmt|;
name|xref_fd
operator|=
name|xref_fh
operator|-
name|debug_info
operator|->
name|fdr
expr_stmt|;
name|tp
operator|=
name|parse_type
argument_list|(
name|xref_fd
argument_list|,
name|debug_info
operator|->
name|external_aux
operator|+
name|xref_fh
operator|->
name|iauxBase
argument_list|,
name|rn
operator|->
name|index
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
name|xref_fh
operator|->
name|fBigendian
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
block|}
comment|/* All these types really point to some (common) MIPS type      definition, and only the type-qualifiers fully identify      them.  We'll make the same effort at sharing. */
if|if
condition|(
name|t
operator|->
name|bt
operator|==
name|btStruct
operator|||
name|t
operator|->
name|bt
operator|==
name|btUnion
operator|||
name|t
operator|->
name|bt
operator|==
name|btEnum
operator|||
comment|/* btSet (I think) implies that the name is a tag name, not a typedef 	 name.  This apparently is a MIPS extension for C sets.  */
name|t
operator|->
name|bt
operator|==
name|btSet
condition|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Try to cross reference this type, build new type on failure.  */
name|ax
operator|+=
name|cross_ref
argument_list|(
name|fd
argument_list|,
name|ax
argument_list|,
operator|&
name|tp
argument_list|,
name|type_code
argument_list|,
operator|&
name|name
argument_list|,
name|bigend
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|==
operator|(
expr|struct
name|type
operator|*
operator|)
name|NULL
condition|)
name|tp
operator|=
name|init_type
argument_list|(
name|type_code
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|current_objfile
argument_list|)
expr_stmt|;
comment|/* DEC c89 produces cross references to qualified aggregate types, 	 dereference them.  */
while|while
condition|(
name|TYPE_CODE
argument_list|(
name|tp
argument_list|)
operator|==
name|TYPE_CODE_PTR
operator|||
name|TYPE_CODE
argument_list|(
name|tp
argument_list|)
operator|==
name|TYPE_CODE_ARRAY
condition|)
name|tp
operator|=
name|tp
operator|->
name|target_type
expr_stmt|;
comment|/* Make sure that TYPE_CODE(tp) has an expected type code. 	 Any type may be returned from cross_ref if file indirect entries 	 are corrupted.  */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|tp
argument_list|)
operator|!=
name|TYPE_CODE_STRUCT
operator|&&
name|TYPE_CODE
argument_list|(
name|tp
argument_list|)
operator|!=
name|TYPE_CODE_UNION
operator|&&
name|TYPE_CODE
argument_list|(
name|tp
argument_list|)
operator|!=
name|TYPE_CODE_ENUM
condition|)
block|{
name|complain
argument_list|(
operator|&
name|unexpected_type_code_complaint
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Usually, TYPE_CODE(tp) is already type_code.  The main 	     exception is if we guessed wrong re struct/union/enum. 	     But for struct vs. union a wrong guess is harmless, so 	     don't complain().  */
if|if
condition|(
operator|(
name|TYPE_CODE
argument_list|(
name|tp
argument_list|)
operator|==
name|TYPE_CODE_ENUM
operator|&&
name|type_code
operator|!=
name|TYPE_CODE_ENUM
operator|)
operator|||
operator|(
name|TYPE_CODE
argument_list|(
name|tp
argument_list|)
operator|!=
name|TYPE_CODE_ENUM
operator|&&
name|type_code
operator|==
name|TYPE_CODE_ENUM
operator|)
condition|)
block|{
name|complain
argument_list|(
operator|&
name|bad_tag_guess_complaint
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|tp
argument_list|)
operator|!=
name|type_code
condition|)
block|{
name|TYPE_CODE
argument_list|(
name|tp
argument_list|)
operator|=
name|type_code
expr_stmt|;
block|}
comment|/* Do not set the tag name if it is a compiler generated tag name 	      (.Fxx or .xxfake or empty) for unnamed struct/union/enums.  */
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|||
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|TYPE_TAG_NAME
argument_list|(
name|tp
argument_list|)
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_TAG_NAME
argument_list|(
name|tp
argument_list|)
operator|==
name|NULL
operator|||
operator|!
name|STREQ
argument_list|(
name|TYPE_TAG_NAME
argument_list|(
name|tp
argument_list|)
argument_list|,
name|name
argument_list|)
condition|)
name|TYPE_TAG_NAME
argument_list|(
name|tp
argument_list|)
operator|=
name|obsavestring
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
operator|&
name|current_objfile
operator|->
name|type_obstack
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* All these types really point to some (common) MIPS type      definition, and only the type-qualifiers fully identify      them.  We'll make the same effort at sharing.      FIXME: We are not doing any guessing on range types.  */
if|if
condition|(
name|t
operator|->
name|bt
operator|==
name|btRange
condition|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Try to cross reference this type, build new type on failure.  */
name|ax
operator|+=
name|cross_ref
argument_list|(
name|fd
argument_list|,
name|ax
argument_list|,
operator|&
name|tp
argument_list|,
name|type_code
argument_list|,
operator|&
name|name
argument_list|,
name|bigend
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|==
operator|(
expr|struct
name|type
operator|*
operator|)
name|NULL
condition|)
name|tp
operator|=
name|init_type
argument_list|(
name|type_code
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|current_objfile
argument_list|)
expr_stmt|;
comment|/* Make sure that TYPE_CODE(tp) has an expected type code. 	 Any type may be returned from cross_ref if file indirect entries 	 are corrupted.  */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|tp
argument_list|)
operator|!=
name|TYPE_CODE_RANGE
condition|)
block|{
name|complain
argument_list|(
operator|&
name|unexpected_type_code_complaint
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Usually, TYPE_CODE(tp) is already type_code.  The main 	     exception is if we guessed wrong re struct/union/enum. */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|tp
argument_list|)
operator|!=
name|type_code
condition|)
block|{
name|complain
argument_list|(
operator|&
name|bad_tag_guess_complaint
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
name|TYPE_CODE
argument_list|(
name|tp
argument_list|)
operator|=
name|type_code
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|tp
argument_list|)
operator|==
name|NULL
operator|||
operator|!
name|STREQ
argument_list|(
name|TYPE_NAME
argument_list|(
name|tp
argument_list|)
argument_list|,
name|name
argument_list|)
condition|)
name|TYPE_NAME
argument_list|(
name|tp
argument_list|)
operator|=
name|obsavestring
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
operator|&
name|current_objfile
operator|->
name|type_obstack
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|t
operator|->
name|bt
operator|==
name|btTypedef
condition|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Try to cross reference this type, it should succeed.  */
name|ax
operator|+=
name|cross_ref
argument_list|(
name|fd
argument_list|,
name|ax
argument_list|,
operator|&
name|tp
argument_list|,
name|type_code
argument_list|,
operator|&
name|name
argument_list|,
name|bigend
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|==
operator|(
expr|struct
name|type
operator|*
operator|)
name|NULL
condition|)
block|{
name|complain
argument_list|(
operator|&
name|unable_to_cross_ref_complaint
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
name|tp
operator|=
name|mdebug_type_int
expr_stmt|;
block|}
block|}
comment|/* Deal with range types */
if|if
condition|(
name|t
operator|->
name|bt
operator|==
name|btRange
condition|)
block|{
name|TYPE_NFIELDS
argument_list|(
name|tp
argument_list|)
operator|=
literal|2
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|tp
argument_list|)
operator|=
operator|(
operator|(
expr|struct
name|field
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|tp
argument_list|,
literal|2
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|TYPE_FIELD_NAME
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|)
operator|=
name|obsavestring
argument_list|(
literal|"Low"
argument_list|,
name|strlen
argument_list|(
literal|"Low"
argument_list|)
argument_list|,
operator|&
name|current_objfile
operator|->
name|type_obstack
argument_list|)
expr_stmt|;
name|TYPE_FIELD_BITPOS
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|)
operator|=
name|AUX_GET_DNLOW
argument_list|(
name|bigend
argument_list|,
name|ax
argument_list|)
expr_stmt|;
name|ax
operator|++
expr_stmt|;
name|TYPE_FIELD_NAME
argument_list|(
name|tp
argument_list|,
literal|1
argument_list|)
operator|=
name|obsavestring
argument_list|(
literal|"High"
argument_list|,
name|strlen
argument_list|(
literal|"High"
argument_list|)
argument_list|,
operator|&
name|current_objfile
operator|->
name|type_obstack
argument_list|)
expr_stmt|;
name|TYPE_FIELD_BITPOS
argument_list|(
name|tp
argument_list|,
literal|1
argument_list|)
operator|=
name|AUX_GET_DNHIGH
argument_list|(
name|bigend
argument_list|,
name|ax
argument_list|)
expr_stmt|;
name|ax
operator|++
expr_stmt|;
block|}
comment|/* Parse all the type qualifiers now. If there are more      than 6 the game will continue in the next aux */
while|while
condition|(
literal|1
condition|)
block|{
define|#
directive|define
name|PARSE_TQ
parameter_list|(
name|tq
parameter_list|)
define|\
value|if (t->tq != tqNil) \ 	ax += upgrade_type(fd,&tp, t->tq, ax, bigend, sym_name); \       else \ 	break;
name|PARSE_TQ
argument_list|(
name|tq0
argument_list|)
expr_stmt|;
name|PARSE_TQ
argument_list|(
name|tq1
argument_list|)
expr_stmt|;
name|PARSE_TQ
argument_list|(
name|tq2
argument_list|)
expr_stmt|;
name|PARSE_TQ
argument_list|(
name|tq3
argument_list|)
expr_stmt|;
name|PARSE_TQ
argument_list|(
name|tq4
argument_list|)
expr_stmt|;
name|PARSE_TQ
argument_list|(
name|tq5
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|PARSE_TQ
comment|/* mips cc 2.x and gcc never put out continued aux entries.  */
if|if
condition|(
operator|!
name|t
operator|->
name|continued
condition|)
break|break;
call|(
modifier|*
name|debug_swap
operator|->
name|swap_tir_in
call|)
argument_list|(
name|bigend
argument_list|,
operator|&
name|ax
operator|->
name|a_ti
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|ax
operator|++
expr_stmt|;
block|}
comment|/* Complain for illegal continuations due to corrupt aux entries.  */
if|if
condition|(
name|t
operator|->
name|continued
condition|)
name|complain
argument_list|(
operator|&
name|bad_continued_complaint
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
return|return
name|tp
return|;
block|}
end_function

begin_comment
comment|/* Make up a complex type from a basic one.  Type is passed by    reference in TPP and side-effected as necessary. The type    qualifier TQ says how to handle the aux symbols at AX for    the symbol SX we are currently analyzing.  BIGEND says whether    aux symbols are big-endian or little-endian.    Returns the number of aux symbols we parsed. */
end_comment

begin_function
specifier|static
name|int
name|upgrade_type
parameter_list|(
name|fd
parameter_list|,
name|tpp
parameter_list|,
name|tq
parameter_list|,
name|ax
parameter_list|,
name|bigend
parameter_list|,
name|sym_name
parameter_list|)
name|int
name|fd
decl_stmt|;
name|struct
name|type
modifier|*
modifier|*
name|tpp
decl_stmt|;
name|int
name|tq
decl_stmt|;
name|union
name|aux_ext
modifier|*
name|ax
decl_stmt|;
name|int
name|bigend
decl_stmt|;
name|char
modifier|*
name|sym_name
decl_stmt|;
block|{
name|int
name|off
decl_stmt|;
name|struct
name|type
modifier|*
name|t
decl_stmt|;
comment|/* Used in array processing */
name|int
name|rf
decl_stmt|,
name|id
decl_stmt|;
name|FDR
modifier|*
name|fh
decl_stmt|;
name|struct
name|type
modifier|*
name|range
decl_stmt|;
name|struct
name|type
modifier|*
name|indx
decl_stmt|;
name|int
name|lower
decl_stmt|,
name|upper
decl_stmt|;
name|RNDXR
name|rndx
decl_stmt|;
switch|switch
condition|(
name|tq
condition|)
block|{
case|case
name|tqPtr
case|:
name|t
operator|=
name|lookup_pointer_type
argument_list|(
operator|*
name|tpp
argument_list|)
expr_stmt|;
operator|*
name|tpp
operator|=
name|t
expr_stmt|;
return|return
literal|0
return|;
case|case
name|tqProc
case|:
name|t
operator|=
name|lookup_function_type
argument_list|(
operator|*
name|tpp
argument_list|)
expr_stmt|;
operator|*
name|tpp
operator|=
name|t
expr_stmt|;
return|return
literal|0
return|;
case|case
name|tqArray
case|:
name|off
operator|=
literal|0
expr_stmt|;
comment|/* Determine and record the domain type (type of index) */
call|(
modifier|*
name|debug_swap
operator|->
name|swap_rndx_in
call|)
argument_list|(
name|bigend
argument_list|,
operator|&
name|ax
operator|->
name|a_rndx
argument_list|,
operator|&
name|rndx
argument_list|)
expr_stmt|;
name|id
operator|=
name|rndx
operator|.
name|index
expr_stmt|;
name|rf
operator|=
name|rndx
operator|.
name|rfd
expr_stmt|;
if|if
condition|(
name|rf
operator|==
literal|0xfff
condition|)
block|{
name|ax
operator|++
expr_stmt|;
name|rf
operator|=
name|AUX_GET_ISYM
argument_list|(
name|bigend
argument_list|,
name|ax
argument_list|)
expr_stmt|;
name|off
operator|++
expr_stmt|;
block|}
name|fh
operator|=
name|get_rfd
argument_list|(
name|fd
argument_list|,
name|rf
argument_list|)
expr_stmt|;
name|indx
operator|=
name|parse_type
argument_list|(
name|fh
operator|-
name|debug_info
operator|->
name|fdr
argument_list|,
name|debug_info
operator|->
name|external_aux
operator|+
name|fh
operator|->
name|iauxBase
argument_list|,
name|id
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
name|bigend
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
comment|/* The bounds type should be an integer type, but might be anything 	 else due to corrupt aux entries.  */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|indx
argument_list|)
operator|!=
name|TYPE_CODE_INT
condition|)
block|{
name|complain
argument_list|(
operator|&
name|array_index_type_complaint
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
name|indx
operator|=
name|mdebug_type_int
expr_stmt|;
block|}
comment|/* Get the bounds, and create the array type.  */
name|ax
operator|++
expr_stmt|;
name|lower
operator|=
name|AUX_GET_DNLOW
argument_list|(
name|bigend
argument_list|,
name|ax
argument_list|)
expr_stmt|;
name|ax
operator|++
expr_stmt|;
name|upper
operator|=
name|AUX_GET_DNHIGH
argument_list|(
name|bigend
argument_list|,
name|ax
argument_list|)
expr_stmt|;
name|ax
operator|++
expr_stmt|;
name|rf
operator|=
name|AUX_GET_WIDTH
argument_list|(
name|bigend
argument_list|,
name|ax
argument_list|)
expr_stmt|;
comment|/* bit size of array element */
name|range
operator|=
name|create_range_type
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|)
name|NULL
argument_list|,
name|indx
argument_list|,
name|lower
argument_list|,
name|upper
argument_list|)
expr_stmt|;
name|t
operator|=
name|create_array_type
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|)
name|NULL
argument_list|,
operator|*
name|tpp
argument_list|,
name|range
argument_list|)
expr_stmt|;
comment|/* We used to fill in the supplied array element bitsize 	 here if the TYPE_LENGTH of the target type was zero. 	 This happens for a `pointer to an array of anonymous structs', 	 but in this case the array element bitsize is also zero, 	 so nothing is gained. 	 And we used to check the TYPE_LENGTH of the target type against 	 the supplied array element bitsize. 	 gcc causes a mismatch for `pointer to array of object', 	 since the sdb directives it uses do not have a way of 	 specifying the bitsize, but it does no harm (the 	 TYPE_LENGTH should be correct) and we should be able to 	 ignore the erroneous bitsize from the auxiliary entry safely. 	 dbx seems to ignore it too.  */
comment|/* TYPE_FLAG_TARGET_STUB now takes care of the zero TYPE_LENGTH 	 problem.  */
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
operator|*
name|tpp
argument_list|)
operator|==
literal|0
condition|)
block|{
name|TYPE_FLAGS
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_FLAG_TARGET_STUB
expr_stmt|;
block|}
operator|*
name|tpp
operator|=
name|t
expr_stmt|;
return|return
literal|4
operator|+
name|off
return|;
case|case
name|tqVol
case|:
comment|/* Volatile -- currently ignored */
return|return
literal|0
return|;
case|case
name|tqConst
case|:
comment|/* Const -- currently ignored */
return|return
literal|0
return|;
default|default:
name|complain
argument_list|(
operator|&
name|unknown_type_qual_complaint
argument_list|,
name|tq
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Parse a procedure descriptor record PR.  Note that the procedure is    parsed _after_ the local symbols, now we just insert the extra    information we need into a MIPS_EFI_SYMBOL_NAME symbol that has    already been placed in the procedure's main block.  Note also that    images that have been partially stripped (ld -x) have been deprived    of local symbols, and we have to cope with them here.  FIRST_OFF is    the offset of the first procedure for this FDR; we adjust the    address by this amount, but I don't know why.  SEARCH_SYMTAB is the symtab    to look for the function which contains the MIPS_EFI_SYMBOL_NAME symbol    in question, or NULL to use top_stack->cur_block.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|parse_procedure
name|PARAMS
argument_list|(
operator|(
name|PDR
operator|*
operator|,
expr|struct
name|symtab
operator|*
operator|,
expr|struct
name|partial_symtab
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|parse_procedure
parameter_list|(
name|pr
parameter_list|,
name|search_symtab
parameter_list|,
name|pst
parameter_list|)
name|PDR
modifier|*
name|pr
decl_stmt|;
name|struct
name|symtab
modifier|*
name|search_symtab
decl_stmt|;
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
block|{
name|struct
name|symbol
modifier|*
name|s
decl_stmt|,
modifier|*
name|i
decl_stmt|;
name|struct
name|block
modifier|*
name|b
decl_stmt|;
name|struct
name|mips_extra_func_info
modifier|*
name|e
decl_stmt|;
name|char
modifier|*
name|sh_name
decl_stmt|;
comment|/* Simple rule to find files linked "-x" */
if|if
condition|(
name|cur_fdr
operator|->
name|rss
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|pr
operator|->
name|isym
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* Static procedure at address pr->adr.  Sigh. */
comment|/* FIXME-32x64.  assuming pr->adr fits in long.  */
name|complain
argument_list|(
operator|&
name|pdr_static_symbol_complaint
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|pr
operator|->
name|adr
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
comment|/* external */
name|EXTR
name|she
decl_stmt|;
call|(
modifier|*
name|debug_swap
operator|->
name|swap_ext_in
call|)
argument_list|(
name|cur_bfd
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
name|debug_info
operator|->
name|external_ext
operator|+
operator|(
name|pr
operator|->
name|isym
operator|*
name|debug_swap
operator|->
name|external_ext_size
operator|)
operator|)
argument_list|,
operator|&
name|she
argument_list|)
expr_stmt|;
name|sh_name
operator|=
name|debug_info
operator|->
name|ssext
operator|+
name|she
operator|.
name|asym
operator|.
name|iss
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Full symbols */
name|SYMR
name|sh
decl_stmt|;
call|(
modifier|*
name|debug_swap
operator|->
name|swap_sym_in
call|)
argument_list|(
name|cur_bfd
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
name|debug_info
operator|->
name|external_sym
operator|+
operator|(
operator|(
name|cur_fdr
operator|->
name|isymBase
operator|+
name|pr
operator|->
name|isym
operator|)
operator|*
name|debug_swap
operator|->
name|external_sym_size
operator|)
operator|)
argument_list|,
operator|&
name|sh
argument_list|)
expr_stmt|;
name|sh_name
operator|=
name|debug_info
operator|->
name|ss
operator|+
name|cur_fdr
operator|->
name|issBase
operator|+
name|sh
operator|.
name|iss
expr_stmt|;
block|}
if|if
condition|(
name|search_symtab
operator|!=
name|NULL
condition|)
block|{
if|#
directive|if
literal|0
comment|/* This loses both in the case mentioned (want a static, find a global), 	 but also if we are looking up a non-mangled name which happens to 	 match the name of a mangled function.  */
comment|/* We have to save the cur_fdr across the call to lookup_symbol. 	 If the pdr is for a static function and if a global function with 	 the same name exists, lookup_symbol will eventually read in the symtab 	 for the global function and clobber cur_fdr.  */
block|FDR *save_cur_fdr = cur_fdr;       s = lookup_symbol (sh_name, NULL, VAR_NAMESPACE, 0, NULL);       cur_fdr = save_cur_fdr;
else|#
directive|else
name|s
operator|=
name|mylookup_symbol
argument_list|(
name|sh_name
argument_list|,
name|BLOCKVECTOR_BLOCK
argument_list|(
name|BLOCKVECTOR
argument_list|(
name|search_symtab
argument_list|)
argument_list|,
name|STATIC_BLOCK
argument_list|)
argument_list|,
name|VAR_NAMESPACE
argument_list|,
name|LOC_BLOCK
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|s
operator|=
name|mylookup_symbol
argument_list|(
name|sh_name
argument_list|,
name|top_stack
operator|->
name|cur_block
argument_list|,
name|VAR_NAMESPACE
argument_list|,
name|LOC_BLOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
literal|0
condition|)
block|{
name|b
operator|=
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|complain
argument_list|(
operator|&
name|pdr_for_nonsymbol_complaint
argument_list|,
name|sh_name
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
return|return;
else|#
directive|else
comment|/* FIXME -- delete.  We can't do symbol allocation now; it's all done.  */
name|s
operator|=
name|new_symbol
argument_list|(
name|sh_name
argument_list|)
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|s
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|s
argument_list|)
operator|=
name|LOC_BLOCK
expr_stmt|;
comment|/* Donno its type, hope int is ok */
name|SYMBOL_TYPE
argument_list|(
name|s
argument_list|)
operator|=
name|lookup_function_type
argument_list|(
name|mdebug_type_int
argument_list|)
expr_stmt|;
name|add_symbol
argument_list|(
name|s
argument_list|,
name|top_stack
operator|->
name|cur_block
argument_list|)
expr_stmt|;
comment|/* Wont have symbols for this one */
name|b
operator|=
name|new_block
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|s
argument_list|)
operator|=
name|b
expr_stmt|;
name|BLOCK_FUNCTION
argument_list|(
name|b
argument_list|)
operator|=
name|s
expr_stmt|;
name|BLOCK_START
argument_list|(
name|b
argument_list|)
operator|=
name|pr
operator|->
name|adr
expr_stmt|;
comment|/* BOUND used to be the end of procedure's text, but the 	 argument is no longer passed in.  */
name|BLOCK_END
argument_list|(
name|b
argument_list|)
operator|=
name|bound
expr_stmt|;
name|BLOCK_SUPERBLOCK
argument_list|(
name|b
argument_list|)
operator|=
name|top_stack
operator|->
name|cur_block
expr_stmt|;
name|add_block
argument_list|(
name|b
argument_list|,
name|top_stack
operator|->
name|cur_st
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|i
operator|=
name|mylookup_symbol
argument_list|(
name|MIPS_EFI_SYMBOL_NAME
argument_list|,
name|b
argument_list|,
name|LABEL_NAMESPACE
argument_list|,
name|LOC_CONST
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
block|{
name|e
operator|=
operator|(
expr|struct
name|mips_extra_func_info
operator|*
operator|)
name|SYMBOL_VALUE
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|e
operator|->
name|pdr
operator|=
operator|*
name|pr
expr_stmt|;
name|e
operator|->
name|pdr
operator|.
name|isym
operator|=
operator|(
name|long
operator|)
name|s
expr_stmt|;
comment|/* GDB expects the absolute function start address for the 	 procedure descriptor in e->pdr.adr. 	 As the address in the procedure descriptor is usually relative, 	 we would have to relocate e->pdr.adr with cur_fdr->adr and 	 ANOFFSET (pst->section_offsets, SECT_OFF_TEXT). 	 Unfortunately cur_fdr->adr and e->pdr.adr are both absolute 	 in shared libraries on some systems, and on other systems 	 e->pdr.adr is sometimes offset by a bogus value. 	 To work around these problems, we replace e->pdr.adr with 	 the start address of the function.  */
name|e
operator|->
name|pdr
operator|.
name|adr
operator|=
name|BLOCK_START
argument_list|(
name|b
argument_list|)
expr_stmt|;
comment|/* Correct incorrect setjmp procedure descriptor from the library 	 to make backtrace through setjmp work.  */
if|if
condition|(
name|e
operator|->
name|pdr
operator|.
name|pcreg
operator|==
literal|0
operator|&&
name|STREQ
argument_list|(
name|sh_name
argument_list|,
literal|"setjmp"
argument_list|)
condition|)
block|{
name|complain
argument_list|(
operator|&
name|bad_setjmp_pdr_complaint
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|e
operator|->
name|pdr
operator|.
name|pcreg
operator|=
name|RA_REGNUM
expr_stmt|;
name|e
operator|->
name|pdr
operator|.
name|regmask
operator|=
literal|0x80000000
expr_stmt|;
name|e
operator|->
name|pdr
operator|.
name|regoffset
operator|=
operator|-
literal|4
expr_stmt|;
block|}
block|}
comment|/* It would be reasonable that functions that have been compiled      without debugging info have a btNil type for their return value,      and functions that are void and are compiled with debugging info      have btVoid.      gcc and DEC f77 put out btNil types for both cases, so btNil is mapped      to TYPE_CODE_VOID in parse_type to get the `compiled with debugging info'      case right.      The glevel field in cur_fdr could be used to determine the presence      of debugging info, but GCC doesn't always pass the -g switch settings      to the assembler and GAS doesn't set the glevel field from the -g switch      settings.      To work around these problems, the return value type of a TYPE_CODE_VOID      function is adjusted accordingly if no debugging info was found in the      compilation unit.  */
if|if
condition|(
name|processing_gcc_compilation
operator|==
literal|0
operator|&&
name|found_ecoff_debugging_info
operator|==
literal|0
operator|&&
name|TYPE_CODE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|s
argument_list|)
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_VOID
condition|)
name|SYMBOL_TYPE
argument_list|(
name|s
argument_list|)
operator|=
name|nodebug_func_symbol_type
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Relocate the extra function info pointed to by the symbol table.  */
end_comment

begin_function
name|void
name|ecoff_relocate_efi
parameter_list|(
name|sym
parameter_list|,
name|delta
parameter_list|)
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|CORE_ADDR
name|delta
decl_stmt|;
block|{
name|struct
name|mips_extra_func_info
modifier|*
name|e
decl_stmt|;
name|e
operator|=
operator|(
expr|struct
name|mips_extra_func_info
operator|*
operator|)
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|e
operator|->
name|pdr
operator|.
name|adr
operator|+=
name|delta
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse the external symbol ES. Just call parse_symbol() after    making sure we know where the aux are for it.    BIGEND says whether aux entries are big-endian or little-endian.     This routine clobbers top_stack->cur_block and ->cur_st. */
end_comment

begin_decl_stmt
specifier|static
name|void
name|parse_external
name|PARAMS
argument_list|(
operator|(
name|EXTR
operator|*
operator|,
name|int
operator|,
expr|struct
name|section_offsets
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|parse_external
parameter_list|(
name|es
parameter_list|,
name|bigend
parameter_list|,
name|section_offsets
parameter_list|)
name|EXTR
modifier|*
name|es
decl_stmt|;
name|int
name|bigend
decl_stmt|;
name|struct
name|section_offsets
modifier|*
name|section_offsets
decl_stmt|;
block|{
name|union
name|aux_ext
modifier|*
name|ax
decl_stmt|;
if|if
condition|(
name|es
operator|->
name|ifd
operator|!=
name|ifdNil
condition|)
block|{
name|cur_fd
operator|=
name|es
operator|->
name|ifd
expr_stmt|;
name|cur_fdr
operator|=
name|debug_info
operator|->
name|fdr
operator|+
name|cur_fd
expr_stmt|;
name|ax
operator|=
name|debug_info
operator|->
name|external_aux
operator|+
name|cur_fdr
operator|->
name|iauxBase
expr_stmt|;
block|}
else|else
block|{
name|cur_fdr
operator|=
name|debug_info
operator|->
name|fdr
expr_stmt|;
name|ax
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Reading .o files */
if|if
condition|(
name|SC_IS_UNDEF
argument_list|(
name|es
operator|->
name|asym
operator|.
name|sc
argument_list|)
operator|||
name|es
operator|->
name|asym
operator|.
name|sc
operator|==
name|scNil
condition|)
block|{
name|char
modifier|*
name|what
decl_stmt|;
switch|switch
condition|(
name|es
operator|->
name|asym
operator|.
name|st
condition|)
block|{
case|case
name|stNil
case|:
comment|/* These are generated for static symbols in .o files, 	     ignore them.  */
return|return;
case|case
name|stStaticProc
case|:
case|case
name|stProc
case|:
name|what
operator|=
literal|"procedure"
expr_stmt|;
name|n_undef_procs
operator|++
expr_stmt|;
break|break;
case|case
name|stGlobal
case|:
name|what
operator|=
literal|"variable"
expr_stmt|;
name|n_undef_vars
operator|++
expr_stmt|;
break|break;
case|case
name|stLabel
case|:
name|what
operator|=
literal|"label"
expr_stmt|;
name|n_undef_labels
operator|++
expr_stmt|;
break|break;
default|default:
name|what
operator|=
literal|"symbol"
expr_stmt|;
break|break;
block|}
name|n_undef_symbols
operator|++
expr_stmt|;
comment|/* FIXME:  Turn this into a complaint? */
if|if
condition|(
name|info_verbose
condition|)
name|printf_filtered
argument_list|(
literal|"Warning: %s `%s' is undefined (in %s)\n"
argument_list|,
name|what
argument_list|,
name|debug_info
operator|->
name|ssext
operator|+
name|es
operator|->
name|asym
operator|.
name|iss
argument_list|,
name|fdr_name
argument_list|(
name|cur_fdr
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|es
operator|->
name|asym
operator|.
name|st
condition|)
block|{
case|case
name|stProc
case|:
case|case
name|stStaticProc
case|:
comment|/* There is no need to parse the external procedure symbols. 	 If they are from objects compiled without -g, their index will 	 be indexNil, and the symbol definition from the minimal symbol 	 is preferrable (yielding a function returning int instead of int). 	 If the index points to a local procedure symbol, the local 	 symbol already provides the correct type. 	 Note that the index of the external procedure symbol points 	 to the local procedure symbol in the local symbol table, and 	 _not_ to the auxiliary symbol info.  */
break|break;
case|case
name|stGlobal
case|:
case|case
name|stLabel
case|:
comment|/* Global common symbols are resolved by the runtime loader, 	 ignore them.  */
if|if
condition|(
name|SC_IS_COMMON
argument_list|(
name|es
operator|->
name|asym
operator|.
name|sc
argument_list|)
condition|)
break|break;
comment|/* Note that the case of a symbol with indexNil must be handled 	 anyways by parse_symbol().  */
name|parse_symbol
argument_list|(
operator|&
name|es
operator|->
name|asym
argument_list|,
name|ax
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|bigend
argument_list|,
name|section_offsets
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Parse the line number info for file descriptor FH into    GDB's linetable LT.  MIPS' encoding requires a little bit    of magic to get things out.  Note also that MIPS' line    numbers can go back and forth, apparently we can live    with that and do not need to reorder our linetables */
end_comment

begin_decl_stmt
specifier|static
name|void
name|parse_lines
name|PARAMS
argument_list|(
operator|(
name|FDR
operator|*
operator|,
name|PDR
operator|*
operator|,
expr|struct
name|linetable
operator|*
operator|,
name|int
operator|,
expr|struct
name|partial_symtab
operator|*
operator|,
name|CORE_ADDR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|parse_lines
parameter_list|(
name|fh
parameter_list|,
name|pr
parameter_list|,
name|lt
parameter_list|,
name|maxlines
parameter_list|,
name|pst
parameter_list|,
name|lowest_pdr_addr
parameter_list|)
name|FDR
modifier|*
name|fh
decl_stmt|;
name|PDR
modifier|*
name|pr
decl_stmt|;
name|struct
name|linetable
modifier|*
name|lt
decl_stmt|;
name|int
name|maxlines
decl_stmt|;
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
name|CORE_ADDR
name|lowest_pdr_addr
decl_stmt|;
block|{
name|unsigned
name|char
modifier|*
name|base
decl_stmt|;
name|int
name|j
decl_stmt|,
name|k
decl_stmt|;
name|int
name|delta
decl_stmt|,
name|count
decl_stmt|,
name|lineno
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|fh
operator|->
name|cbLine
operator|==
literal|0
condition|)
return|return;
comment|/* Scan by procedure descriptors */
name|k
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|fh
operator|->
name|cpd
condition|;
name|j
operator|++
operator|,
name|pr
operator|++
control|)
block|{
name|CORE_ADDR
name|l
decl_stmt|;
name|CORE_ADDR
name|adr
decl_stmt|;
name|unsigned
name|char
modifier|*
name|halt
decl_stmt|;
comment|/* No code for this one */
if|if
condition|(
name|pr
operator|->
name|iline
operator|==
name|ilineNil
operator|||
name|pr
operator|->
name|lnLow
operator|==
operator|-
literal|1
operator|||
name|pr
operator|->
name|lnHigh
operator|==
operator|-
literal|1
condition|)
continue|continue;
comment|/* Determine start and end address of compressed line bytes for 	 this procedure.  */
name|base
operator|=
name|debug_info
operator|->
name|line
operator|+
name|fh
operator|->
name|cbLineOffset
expr_stmt|;
if|if
condition|(
name|j
operator|!=
operator|(
name|fh
operator|->
name|cpd
operator|-
literal|1
operator|)
condition|)
name|halt
operator|=
name|base
operator|+
name|pr
index|[
literal|1
index|]
operator|.
name|cbLineOffset
expr_stmt|;
else|else
name|halt
operator|=
name|base
operator|+
name|fh
operator|->
name|cbLine
expr_stmt|;
name|base
operator|+=
name|pr
operator|->
name|cbLineOffset
expr_stmt|;
name|adr
operator|=
name|pst
operator|->
name|textlow
operator|+
name|pr
operator|->
name|adr
operator|-
name|lowest_pdr_addr
expr_stmt|;
name|l
operator|=
name|adr
operator|>>
literal|2
expr_stmt|;
comment|/* in words */
for|for
control|(
name|lineno
operator|=
name|pr
operator|->
name|lnLow
init|;
name|base
operator|<
name|halt
condition|;
control|)
block|{
name|count
operator|=
operator|*
name|base
operator|&
literal|0x0f
expr_stmt|;
name|delta
operator|=
operator|*
name|base
operator|++
operator|>>
literal|4
expr_stmt|;
if|if
condition|(
name|delta
operator|>=
literal|8
condition|)
name|delta
operator|-=
literal|16
expr_stmt|;
if|if
condition|(
name|delta
operator|==
operator|-
literal|8
condition|)
block|{
name|delta
operator|=
operator|(
name|base
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator||
name|base
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|delta
operator|>=
literal|0x8000
condition|)
name|delta
operator|-=
literal|0x10000
expr_stmt|;
name|base
operator|+=
literal|2
expr_stmt|;
block|}
name|lineno
operator|+=
name|delta
expr_stmt|;
comment|/* first delta is 0 */
comment|/* Complain if the line table overflows. Could happen 	     with corrupt binaries.  */
if|if
condition|(
name|lt
operator|->
name|nitems
operator|>=
name|maxlines
condition|)
block|{
name|complain
argument_list|(
operator|&
name|bad_linetable_guess_complaint
argument_list|,
name|fdr_name
argument_list|(
name|fh
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|k
operator|=
name|add_line
argument_list|(
name|lt
argument_list|,
name|lineno
argument_list|,
name|l
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|l
operator|+=
name|count
operator|+
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Master parsing procedure for first-pass reading of file symbols    into a partial_symtab.  */
end_comment

begin_function
specifier|static
name|void
name|parse_partial_symbols
parameter_list|(
name|objfile
parameter_list|,
name|section_offsets
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|section_offsets
modifier|*
name|section_offsets
decl_stmt|;
block|{
specifier|const
name|bfd_size_type
name|external_sym_size
init|=
name|debug_swap
operator|->
name|external_sym_size
decl_stmt|;
specifier|const
name|bfd_size_type
name|external_rfd_size
init|=
name|debug_swap
operator|->
name|external_rfd_size
decl_stmt|;
specifier|const
name|bfd_size_type
name|external_ext_size
init|=
name|debug_swap
operator|->
name|external_ext_size
decl_stmt|;
name|void
argument_list|(
argument|* const swap_ext_in
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|,
name|EXTR
operator|*
operator|)
argument_list|)
operator|=
name|debug_swap
operator|->
name|swap_ext_in
expr_stmt|;
name|void
argument_list|(
argument|* const swap_sym_in
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|,
name|SYMR
operator|*
operator|)
argument_list|)
operator|=
name|debug_swap
operator|->
name|swap_sym_in
expr_stmt|;
name|void
argument_list|(
argument|* const swap_rfd_in
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|,
name|RFDT
operator|*
operator|)
argument_list|)
operator|=
name|debug_swap
operator|->
name|swap_rfd_in
expr_stmt|;
name|int
name|f_idx
decl_stmt|,
name|s_idx
decl_stmt|;
name|HDRR
modifier|*
name|hdr
init|=
operator|&
name|debug_info
operator|->
name|symbolic_header
decl_stmt|;
comment|/* Running pointers */
name|FDR
modifier|*
name|fh
decl_stmt|;
name|char
modifier|*
name|ext_out
decl_stmt|;
name|char
modifier|*
name|ext_out_end
decl_stmt|;
name|EXTR
modifier|*
name|ext_block
decl_stmt|;
specifier|register
name|EXTR
modifier|*
name|ext_in
decl_stmt|;
name|EXTR
modifier|*
name|ext_in_end
decl_stmt|;
name|SYMR
name|sh
decl_stmt|;
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
name|int
name|textlow_not_set
init|=
literal|1
decl_stmt|;
name|int
name|past_first_source_file
init|=
literal|0
decl_stmt|;
comment|/* List of current psymtab's include files */
name|char
modifier|*
modifier|*
name|psymtab_include_list
decl_stmt|;
name|int
name|includes_allocated
decl_stmt|;
name|int
name|includes_used
decl_stmt|;
name|EXTR
modifier|*
name|extern_tab
decl_stmt|;
name|struct
name|pst_map
modifier|*
name|fdr_to_pst
decl_stmt|;
comment|/* Index within current psymtab dependency list */
name|struct
name|partial_symtab
modifier|*
modifier|*
name|dependency_list
decl_stmt|;
name|int
name|dependencies_used
decl_stmt|,
name|dependencies_allocated
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|enum
name|language
name|prev_language
decl_stmt|;
name|asection
modifier|*
name|text_sect
decl_stmt|;
name|int
name|relocatable
init|=
literal|0
decl_stmt|;
comment|/* Irix 5.2 shared libraries have a fh->adr field of zero, but      the shared libraries are prelinked at a high memory address.      We have to adjust the start address of the object file for this case,      by setting it to the start address of the first procedure in the file.      But we should do no adjustments if we are debugging a .o file, where      the text section (and fh->adr) really starts at zero.  */
name|text_sect
operator|=
name|bfd_get_section_by_name
argument_list|(
name|cur_bfd
argument_list|,
literal|".text"
argument_list|)
expr_stmt|;
if|if
condition|(
name|text_sect
operator|!=
name|NULL
operator|&&
operator|(
name|bfd_get_section_flags
argument_list|(
name|cur_bfd
argument_list|,
name|text_sect
argument_list|)
operator|&
name|SEC_RELOC
operator|)
condition|)
name|relocatable
operator|=
literal|1
expr_stmt|;
name|extern_tab
operator|=
operator|(
name|EXTR
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|psymbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
name|EXTR
argument_list|)
operator|*
name|hdr
operator|->
name|iextMax
argument_list|)
expr_stmt|;
name|includes_allocated
operator|=
literal|30
expr_stmt|;
name|includes_used
operator|=
literal|0
expr_stmt|;
name|psymtab_include_list
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|alloca
argument_list|(
name|includes_allocated
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|next_symbol_text_func
operator|=
name|mdebug_next_symbol_text
expr_stmt|;
name|dependencies_allocated
operator|=
literal|30
expr_stmt|;
name|dependencies_used
operator|=
literal|0
expr_stmt|;
name|dependency_list
operator|=
operator|(
expr|struct
name|partial_symtab
operator|*
operator|*
operator|)
name|alloca
argument_list|(
name|dependencies_allocated
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|partial_symtab
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|last_source_file
operator|=
name|NULL
expr_stmt|;
comment|/*    * Big plan:    *    * Only parse the Local and External symbols, and the Relative FDR.    * Fixup enough of the loader symtab to be able to use it.    * Allocate space only for the file's portions we need to    * look at. (XXX)    */
name|max_gdbinfo
operator|=
literal|0
expr_stmt|;
name|max_glevel
operator|=
name|MIN_GLEVEL
expr_stmt|;
comment|/* Allocate the map FDR -> PST.      Minor hack: -O3 images might claim some global data belongs      to FDR -1. We`ll go along with that */
name|fdr_to_pst
operator|=
operator|(
expr|struct
name|pst_map
operator|*
operator|)
name|xzalloc
argument_list|(
operator|(
name|hdr
operator|->
name|ifdMax
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
expr|*
name|fdr_to_pst
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|fdr_to_pst
argument_list|)
expr_stmt|;
name|fdr_to_pst
operator|++
expr_stmt|;
block|{
name|struct
name|partial_symtab
modifier|*
name|pst
init|=
name|new_psymtab
argument_list|(
literal|""
argument_list|,
name|objfile
argument_list|,
name|section_offsets
argument_list|)
decl_stmt|;
name|fdr_to_pst
index|[
operator|-
literal|1
index|]
operator|.
name|pst
operator|=
name|pst
expr_stmt|;
name|FDR_IDX
argument_list|(
name|pst
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Allocate the global pending list.  */
name|pending_list
operator|=
operator|(
operator|(
expr|struct
name|mdebug_pending
operator|*
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|psymbol_obstack
argument_list|,
name|hdr
operator|->
name|ifdMax
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|mdebug_pending
operator|*
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|PTR
operator|)
name|pending_list
argument_list|,
literal|0
argument_list|,
name|hdr
operator|->
name|ifdMax
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|mdebug_pending
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Pass 0 over external syms: swap them in.  */
name|ext_block
operator|=
operator|(
name|EXTR
operator|*
operator|)
name|xmalloc
argument_list|(
name|hdr
operator|->
name|iextMax
operator|*
sizeof|sizeof
argument_list|(
name|EXTR
argument_list|)
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|ext_block
argument_list|)
expr_stmt|;
name|ext_out
operator|=
operator|(
name|char
operator|*
operator|)
name|debug_info
operator|->
name|external_ext
expr_stmt|;
name|ext_out_end
operator|=
name|ext_out
operator|+
name|hdr
operator|->
name|iextMax
operator|*
name|external_ext_size
expr_stmt|;
name|ext_in
operator|=
name|ext_block
expr_stmt|;
for|for
control|(
init|;
name|ext_out
operator|<
name|ext_out_end
condition|;
name|ext_out
operator|+=
name|external_ext_size
operator|,
name|ext_in
operator|++
control|)
call|(
modifier|*
name|swap_ext_in
call|)
argument_list|(
name|cur_bfd
argument_list|,
name|ext_out
argument_list|,
name|ext_in
argument_list|)
expr_stmt|;
comment|/* Pass 1 over external syms: Presize and partition the list */
name|ext_in
operator|=
name|ext_block
expr_stmt|;
name|ext_in_end
operator|=
name|ext_in
operator|+
name|hdr
operator|->
name|iextMax
expr_stmt|;
for|for
control|(
init|;
name|ext_in
operator|<
name|ext_in_end
condition|;
name|ext_in
operator|++
control|)
block|{
comment|/* See calls to complain below.  */
if|if
condition|(
name|ext_in
operator|->
name|ifd
operator|>=
operator|-
literal|1
operator|&&
name|ext_in
operator|->
name|ifd
operator|<
name|hdr
operator|->
name|ifdMax
operator|&&
name|ext_in
operator|->
name|asym
operator|.
name|iss
operator|>=
literal|0
operator|&&
name|ext_in
operator|->
name|asym
operator|.
name|iss
operator|<
name|hdr
operator|->
name|issExtMax
condition|)
name|fdr_to_pst
index|[
name|ext_in
operator|->
name|ifd
index|]
operator|.
name|n_globals
operator|++
expr_stmt|;
block|}
comment|/* Pass 1.5 over files:  partition out global symbol space */
name|s_idx
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|f_idx
operator|=
operator|-
literal|1
init|;
name|f_idx
operator|<
name|hdr
operator|->
name|ifdMax
condition|;
name|f_idx
operator|++
control|)
block|{
name|fdr_to_pst
index|[
name|f_idx
index|]
operator|.
name|globals_offset
operator|=
name|s_idx
expr_stmt|;
name|s_idx
operator|+=
name|fdr_to_pst
index|[
name|f_idx
index|]
operator|.
name|n_globals
expr_stmt|;
name|fdr_to_pst
index|[
name|f_idx
index|]
operator|.
name|n_globals
operator|=
literal|0
expr_stmt|;
block|}
comment|/* ECOFF in ELF:       For ECOFF in ELF, we skip the creation of the minimal symbols.      The ECOFF symbols should be a subset of the Elf symbols, and the       section information of the elf symbols will be more accurate.      FIXME!  What about Irix 5's native linker?       By default, Elf sections which don't exist in ECOFF       get put in ECOFF's absolute section by the gnu linker.      Since absolute sections don't get relocated, we       end up calculating an address different from that of       the symbol's minimal symbol (created earlier from the      Elf symtab).         To fix this, either :      1) don't create the duplicate symbol 	 (assumes ECOFF symtab is a subset of the ELF symtab; 	 assumes no side-effects result from ignoring ECOFF symbol)      2) create it, only if lookup for existing symbol in ELF's minimal          symbols fails 	 (inefficient;  	 assumes no side-effects result from ignoring ECOFF symbol)      3) create it, but lookup ELF's minimal symbol and use it's section         during relocation, then modify "uniqify" phase to merge and          eliminate the duplicate symbol 	 (highly inefficient)       I've implemented #1 here...      Skip the creation of the minimal symbols based on the ECOFF       symbol table. */
comment|/* Pass 2 over external syms: fill in external symbols */
name|ext_in
operator|=
name|ext_block
expr_stmt|;
name|ext_in_end
operator|=
name|ext_in
operator|+
name|hdr
operator|->
name|iextMax
expr_stmt|;
for|for
control|(
init|;
name|ext_in
operator|<
name|ext_in_end
condition|;
name|ext_in
operator|++
control|)
block|{
name|enum
name|minimal_symbol_type
name|ms_type
init|=
name|mst_text
decl_stmt|;
name|CORE_ADDR
name|svalue
init|=
name|ext_in
operator|->
name|asym
operator|.
name|value
decl_stmt|;
comment|/* The Irix 5 native tools seem to sometimes generate bogus 	   external symbols.  */
if|if
condition|(
name|ext_in
operator|->
name|ifd
operator|<
operator|-
literal|1
operator|||
name|ext_in
operator|->
name|ifd
operator|>=
name|hdr
operator|->
name|ifdMax
condition|)
block|{
name|complain
argument_list|(
operator|&
name|bad_ext_ifd_complaint
argument_list|,
name|ext_in
operator|->
name|ifd
argument_list|,
name|hdr
operator|->
name|ifdMax
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|ext_in
operator|->
name|asym
operator|.
name|iss
operator|<
literal|0
operator|||
name|ext_in
operator|->
name|asym
operator|.
name|iss
operator|>=
name|hdr
operator|->
name|issExtMax
condition|)
block|{
name|complain
argument_list|(
operator|&
name|bad_ext_iss_complaint
argument_list|,
name|ext_in
operator|->
name|asym
operator|.
name|iss
argument_list|,
name|hdr
operator|->
name|issExtMax
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|extern_tab
index|[
name|fdr_to_pst
index|[
name|ext_in
operator|->
name|ifd
index|]
operator|.
name|globals_offset
operator|+
name|fdr_to_pst
index|[
name|ext_in
operator|->
name|ifd
index|]
operator|.
name|n_globals
operator|++
index|]
operator|=
operator|*
name|ext_in
expr_stmt|;
if|if
condition|(
name|SC_IS_UNDEF
argument_list|(
name|ext_in
operator|->
name|asym
operator|.
name|sc
argument_list|)
operator|||
name|ext_in
operator|->
name|asym
operator|.
name|sc
operator|==
name|scNil
condition|)
continue|continue;
comment|/* Pass 3 over files, over local syms: fill in static symbols */
name|name
operator|=
name|debug_info
operator|->
name|ssext
operator|+
name|ext_in
operator|->
name|asym
operator|.
name|iss
expr_stmt|;
comment|/* Process ECOFF Symbol Types and Storage Classes */
switch|switch
condition|(
name|ext_in
operator|->
name|asym
operator|.
name|st
condition|)
block|{
case|case
name|stProc
case|:
comment|/* Beginnning of Procedure */
name|svalue
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
expr_stmt|;
break|break;
case|case
name|stStaticProc
case|:
comment|/* Load time only static procs */
name|ms_type
operator|=
name|mst_file_text
expr_stmt|;
name|svalue
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
expr_stmt|;
break|break;
case|case
name|stGlobal
case|:
comment|/* External symbol */
if|if
condition|(
name|SC_IS_COMMON
argument_list|(
name|ext_in
operator|->
name|asym
operator|.
name|sc
argument_list|)
condition|)
block|{
comment|/* The value of a common symbol is its size, not its address. 		   Ignore it.  */
continue|continue;
block|}
elseif|else
if|if
condition|(
name|SC_IS_DATA
argument_list|(
name|ext_in
operator|->
name|asym
operator|.
name|sc
argument_list|)
condition|)
block|{
name|ms_type
operator|=
name|mst_data
expr_stmt|;
name|svalue
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_DATA
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SC_IS_BSS
argument_list|(
name|ext_in
operator|->
name|asym
operator|.
name|sc
argument_list|)
condition|)
block|{
name|ms_type
operator|=
name|mst_bss
expr_stmt|;
name|svalue
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_BSS
argument_list|)
expr_stmt|;
block|}
else|else
name|ms_type
operator|=
name|mst_abs
expr_stmt|;
break|break;
case|case
name|stLabel
case|:
comment|/* Label */
if|if
condition|(
name|SC_IS_TEXT
argument_list|(
name|ext_in
operator|->
name|asym
operator|.
name|sc
argument_list|)
condition|)
block|{
name|ms_type
operator|=
name|mst_file_text
expr_stmt|;
name|svalue
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SC_IS_DATA
argument_list|(
name|ext_in
operator|->
name|asym
operator|.
name|sc
argument_list|)
condition|)
block|{
name|ms_type
operator|=
name|mst_file_data
expr_stmt|;
name|svalue
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_DATA
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SC_IS_BSS
argument_list|(
name|ext_in
operator|->
name|asym
operator|.
name|sc
argument_list|)
condition|)
block|{
name|ms_type
operator|=
name|mst_file_bss
expr_stmt|;
name|svalue
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_BSS
argument_list|)
expr_stmt|;
block|}
else|else
name|ms_type
operator|=
name|mst_abs
expr_stmt|;
break|break;
case|case
name|stLocal
case|:
case|case
name|stNil
case|:
comment|/* The alpha has the section start addresses in stLocal symbols 		 whose name starts with a `.'. Skip those but complain for all 		 other stLocal symbols. 		 Irix6 puts the section start addresses in stNil symbols, skip 		 those too.*/
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
continue|continue;
comment|/* Fall through.  */
default|default:
name|ms_type
operator|=
name|mst_unknown
expr_stmt|;
name|complain
argument_list|(
operator|&
name|unknown_ext_complaint
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ECOFF_IN_ELF
argument_list|(
name|cur_bfd
argument_list|)
condition|)
name|prim_record_minimal_symbol
argument_list|(
name|name
argument_list|,
name|svalue
argument_list|,
name|ms_type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
comment|/* Pass 3 over files, over local syms: fill in static symbols */
for|for
control|(
name|f_idx
operator|=
literal|0
init|;
name|f_idx
operator|<
name|hdr
operator|->
name|ifdMax
condition|;
name|f_idx
operator|++
control|)
block|{
name|struct
name|partial_symtab
modifier|*
name|save_pst
decl_stmt|;
name|EXTR
modifier|*
name|ext_ptr
decl_stmt|;
name|CORE_ADDR
name|textlow
decl_stmt|;
name|cur_fdr
operator|=
name|fh
operator|=
name|debug_info
operator|->
name|fdr
operator|+
name|f_idx
expr_stmt|;
if|if
condition|(
name|fh
operator|->
name|csym
operator|==
literal|0
condition|)
block|{
name|fdr_to_pst
index|[
name|f_idx
index|]
operator|.
name|pst
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
comment|/* Determine the start address for this object file from the 	 file header and relocate it, except for Irix 5.2 zero fh->adr.  */
if|if
condition|(
name|fh
operator|->
name|cpd
condition|)
block|{
name|textlow
operator|=
name|fh
operator|->
name|adr
expr_stmt|;
if|if
condition|(
name|relocatable
operator|||
name|textlow
operator|!=
literal|0
condition|)
name|textlow
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
expr_stmt|;
block|}
else|else
name|textlow
operator|=
literal|0
expr_stmt|;
name|pst
operator|=
name|start_psymtab_common
argument_list|(
name|objfile
argument_list|,
name|section_offsets
argument_list|,
name|fdr_name
argument_list|(
name|fh
argument_list|)
argument_list|,
name|textlow
argument_list|,
name|objfile
operator|->
name|global_psymbols
operator|.
name|next
argument_list|,
name|objfile
operator|->
name|static_psymbols
operator|.
name|next
argument_list|)
expr_stmt|;
name|pst
operator|->
name|read_symtab_private
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|psymbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symloc
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|PTR
operator|)
name|pst
operator|->
name|read_symtab_private
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symloc
argument_list|)
argument_list|)
expr_stmt|;
name|save_pst
operator|=
name|pst
expr_stmt|;
name|FDR_IDX
argument_list|(
name|pst
argument_list|)
operator|=
name|f_idx
expr_stmt|;
name|CUR_BFD
argument_list|(
name|pst
argument_list|)
operator|=
name|cur_bfd
expr_stmt|;
name|DEBUG_SWAP
argument_list|(
name|pst
argument_list|)
operator|=
name|debug_swap
expr_stmt|;
name|DEBUG_INFO
argument_list|(
name|pst
argument_list|)
operator|=
name|debug_info
expr_stmt|;
name|PENDING_LIST
argument_list|(
name|pst
argument_list|)
operator|=
name|pending_list
expr_stmt|;
comment|/* The way to turn this into a symtab is to call... */
name|pst
operator|->
name|read_symtab
operator|=
name|mdebug_psymtab_to_symtab
expr_stmt|;
comment|/* Set up language for the pst.          The language from the FDR is used if it is unambigious (e.g. cfront 	 with native cc and g++ will set the language to C). 	 Otherwise we have to deduce the language from the filename. 	 Native ecoff has every header file in a separate FDR, so 	 deduce_language_from_filename will return language_unknown for 	 a header file, which is not what we want. 	 But the FDRs for the header files are after the FDR for the source 	 file, so we can assign the language of the source file to the 	 following header files. Then we save the language in the private 	 pst data so that we can reuse it when building symtabs.  */
name|prev_language
operator|=
name|psymtab_language
expr_stmt|;
switch|switch
condition|(
name|fh
operator|->
name|lang
condition|)
block|{
case|case
name|langCplusplusV2
case|:
name|psymtab_language
operator|=
name|language_cplus
expr_stmt|;
break|break;
default|default:
name|psymtab_language
operator|=
name|deduce_language_from_filename
argument_list|(
name|fdr_name
argument_list|(
name|fh
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|psymtab_language
operator|==
name|language_unknown
condition|)
name|psymtab_language
operator|=
name|prev_language
expr_stmt|;
name|PST_PRIVATE
argument_list|(
name|pst
argument_list|)
operator|->
name|pst_language
operator|=
name|psymtab_language
expr_stmt|;
name|pst
operator|->
name|texthigh
operator|=
name|pst
operator|->
name|textlow
expr_stmt|;
comment|/* For stabs-in-ecoff files, the second symbol must be @stab. 	 This symbol is emitted by mips-tfile to signal that the 	 current object file uses encapsulated stabs instead of mips 	 ecoff for local symbols.  (It is the second symbol because 	 the first symbol is the stFile used to signal the start of a 	 file). */
name|processing_gcc_compilation
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fh
operator|->
name|csym
operator|>=
literal|2
condition|)
block|{
call|(
modifier|*
name|swap_sym_in
call|)
argument_list|(
name|cur_bfd
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
name|debug_info
operator|->
name|external_sym
operator|+
operator|(
name|fh
operator|->
name|isymBase
operator|+
literal|1
operator|)
operator|*
name|external_sym_size
operator|)
argument_list|,
operator|&
name|sh
argument_list|)
expr_stmt|;
if|if
condition|(
name|STREQ
argument_list|(
name|debug_info
operator|->
name|ss
operator|+
name|fh
operator|->
name|issBase
operator|+
name|sh
operator|.
name|iss
argument_list|,
name|stabs_symbol
argument_list|)
condition|)
name|processing_gcc_compilation
operator|=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|processing_gcc_compilation
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|cur_sdx
operator|=
literal|2
init|;
name|cur_sdx
operator|<
name|fh
operator|->
name|csym
condition|;
name|cur_sdx
operator|++
control|)
block|{
name|int
name|type_code
decl_stmt|;
name|char
modifier|*
name|namestring
decl_stmt|;
call|(
modifier|*
name|swap_sym_in
call|)
argument_list|(
name|cur_bfd
argument_list|,
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|debug_info
operator|->
name|external_sym
operator|)
operator|+
operator|(
name|fh
operator|->
name|isymBase
operator|+
name|cur_sdx
operator|)
operator|*
name|external_sym_size
operator|)
argument_list|,
operator|&
name|sh
argument_list|)
expr_stmt|;
name|type_code
operator|=
name|ECOFF_UNMARK_STAB
argument_list|(
name|sh
operator|.
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ECOFF_IS_STAB
argument_list|(
operator|&
name|sh
argument_list|)
condition|)
block|{
if|if
condition|(
name|sh
operator|.
name|st
operator|==
name|stProc
operator|||
name|sh
operator|.
name|st
operator|==
name|stStaticProc
condition|)
block|{
name|CORE_ADDR
name|procaddr
decl_stmt|;
name|long
name|isym
decl_stmt|;
name|sh
operator|.
name|value
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sh
operator|.
name|st
operator|==
name|stStaticProc
condition|)
block|{
name|namestring
operator|=
name|debug_info
operator|->
name|ss
operator|+
name|fh
operator|->
name|issBase
operator|+
name|sh
operator|.
name|iss
expr_stmt|;
name|prim_record_minimal_symbol_and_info
argument_list|(
name|namestring
argument_list|,
name|sh
operator|.
name|value
argument_list|,
name|mst_file_text
argument_list|,
name|NULL
argument_list|,
name|SECT_OFF_TEXT
argument_list|,
name|NULL
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
name|procaddr
operator|=
name|sh
operator|.
name|value
expr_stmt|;
name|isym
operator|=
name|AUX_GET_ISYM
argument_list|(
name|fh
operator|->
name|fBigendian
argument_list|,
operator|(
name|debug_info
operator|->
name|external_aux
operator|+
name|fh
operator|->
name|iauxBase
operator|+
name|sh
operator|.
name|index
operator|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|swap_sym_in
call|)
argument_list|(
name|cur_bfd
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
name|debug_info
operator|->
name|external_sym
operator|+
operator|(
operator|(
name|fh
operator|->
name|isymBase
operator|+
name|isym
operator|-
literal|1
operator|)
operator|*
name|external_sym_size
operator|)
operator|)
argument_list|,
operator|&
name|sh
argument_list|)
expr_stmt|;
if|if
condition|(
name|sh
operator|.
name|st
operator|==
name|stEnd
condition|)
block|{
name|CORE_ADDR
name|high
init|=
name|procaddr
operator|+
name|sh
operator|.
name|value
decl_stmt|;
comment|/* Kludge for Irix 5.2 zero fh->adr.  */
if|if
condition|(
operator|!
name|relocatable
operator|&&
operator|(
name|pst
operator|->
name|textlow
operator|==
literal|0
operator|||
name|procaddr
operator|<
name|pst
operator|->
name|textlow
operator|)
condition|)
name|pst
operator|->
name|textlow
operator|=
name|procaddr
expr_stmt|;
if|if
condition|(
name|high
operator|>
name|pst
operator|->
name|texthigh
condition|)
name|pst
operator|->
name|texthigh
operator|=
name|high
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|sh
operator|.
name|st
operator|==
name|stStatic
condition|)
block|{
switch|switch
condition|(
name|sh
operator|.
name|sc
condition|)
block|{
case|case
name|scUndefined
case|:
case|case
name|scSUndefined
case|:
case|case
name|scNil
case|:
case|case
name|scAbs
case|:
break|break;
case|case
name|scData
case|:
case|case
name|scSData
case|:
case|case
name|scRData
case|:
case|case
name|scPData
case|:
case|case
name|scXData
case|:
name|namestring
operator|=
name|debug_info
operator|->
name|ss
operator|+
name|fh
operator|->
name|issBase
operator|+
name|sh
operator|.
name|iss
expr_stmt|;
name|sh
operator|.
name|value
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_DATA
argument_list|)
expr_stmt|;
name|prim_record_minimal_symbol_and_info
argument_list|(
name|namestring
argument_list|,
name|sh
operator|.
name|value
argument_list|,
name|mst_file_data
argument_list|,
name|NULL
argument_list|,
name|SECT_OFF_DATA
argument_list|,
name|NULL
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* FIXME!  Shouldn't this use cases for bss,  			     then have the default be abs? */
name|namestring
operator|=
name|debug_info
operator|->
name|ss
operator|+
name|fh
operator|->
name|issBase
operator|+
name|sh
operator|.
name|iss
expr_stmt|;
name|sh
operator|.
name|value
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_BSS
argument_list|)
expr_stmt|;
name|prim_record_minimal_symbol_and_info
argument_list|(
name|namestring
argument_list|,
name|sh
operator|.
name|value
argument_list|,
name|mst_file_bss
argument_list|,
name|NULL
argument_list|,
name|SECT_OFF_BSS
argument_list|,
name|NULL
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
continue|continue;
block|}
comment|/* Handle stabs continuation */
block|{
name|char
modifier|*
name|stabstring
init|=
name|debug_info
operator|->
name|ss
operator|+
name|fh
operator|->
name|issBase
operator|+
name|sh
operator|.
name|iss
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|stabstring
argument_list|)
decl_stmt|;
while|while
condition|(
name|stabstring
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'\\'
condition|)
block|{
name|SYMR
name|sh2
decl_stmt|;
name|char
modifier|*
name|stabstring1
init|=
name|stabstring
decl_stmt|;
name|char
modifier|*
name|stabstring2
decl_stmt|;
name|int
name|len2
decl_stmt|;
comment|/* Ignore continuation char from 1st string */
name|len
operator|--
expr_stmt|;
comment|/* Read next stabstring */
name|cur_sdx
operator|++
expr_stmt|;
call|(
modifier|*
name|swap_sym_in
call|)
argument_list|(
name|cur_bfd
argument_list|,
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|debug_info
operator|->
name|external_sym
operator|)
operator|+
operator|(
name|fh
operator|->
name|isymBase
operator|+
name|cur_sdx
operator|)
operator|*
name|external_sym_size
operator|)
argument_list|,
operator|&
name|sh2
argument_list|)
expr_stmt|;
name|stabstring2
operator|=
name|debug_info
operator|->
name|ss
operator|+
name|fh
operator|->
name|issBase
operator|+
name|sh2
operator|.
name|iss
expr_stmt|;
name|len2
operator|=
name|strlen
argument_list|(
name|stabstring2
argument_list|)
expr_stmt|;
comment|/* Concatinate stabstring2 with stabstring1 */
if|if
condition|(
name|stabstring
operator|&&
name|stabstring
operator|!=
name|debug_info
operator|->
name|ss
operator|+
name|fh
operator|->
name|issBase
operator|+
name|sh
operator|.
name|iss
condition|)
name|stabstring
operator|=
name|xrealloc
argument_list|(
name|stabstring
argument_list|,
name|len
operator|+
name|len2
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|stabstring
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
name|len2
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|stabstring
argument_list|,
name|stabstring1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|stabstring
operator|+
name|len
argument_list|,
name|stabstring2
argument_list|)
expr_stmt|;
name|len
operator|+=
name|len2
expr_stmt|;
block|}
define|#
directive|define
name|SET_NAMESTRING
parameter_list|()
define|\
value|namestring = stabstring
define|#
directive|define
name|CUR_SYMBOL_TYPE
value|type_code
define|#
directive|define
name|CUR_SYMBOL_VALUE
value|sh.value
define|#
directive|define
name|START_PSYMTAB
parameter_list|(
name|ofile
parameter_list|,
name|secoff
parameter_list|,
name|fname
parameter_list|,
name|low
parameter_list|,
name|symoff
parameter_list|,
name|global_syms
parameter_list|,
name|static_syms
parameter_list|)
define|\
value|pst = save_pst
define|#
directive|define
name|END_PSYMTAB
parameter_list|(
name|pst
parameter_list|,
name|ilist
parameter_list|,
name|ninc
parameter_list|,
name|c_off
parameter_list|,
name|c_text
parameter_list|,
name|dep_list
parameter_list|,
name|n_deps
parameter_list|,
name|textlow_not_set
parameter_list|)
value|(void)0
define|#
directive|define
name|HANDLE_RBRAC
parameter_list|(
name|val
parameter_list|)
define|\
value|if ((val)> save_pst->texthigh) save_pst->texthigh = (val);
include|#
directive|include
file|"partial-stab.h"
if|if
condition|(
name|stabstring
operator|&&
name|stabstring
operator|!=
name|debug_info
operator|->
name|ss
operator|+
name|fh
operator|->
name|issBase
operator|+
name|sh
operator|.
name|iss
condition|)
name|free
argument_list|(
name|stabstring
argument_list|)
expr_stmt|;
block|}
comment|/* end - Handle continuation */
block|}
block|}
else|else
block|{
for|for
control|(
name|cur_sdx
operator|=
literal|0
init|;
name|cur_sdx
operator|<
name|fh
operator|->
name|csym
condition|;
control|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|enum
name|address_class
name|class
decl_stmt|;
call|(
modifier|*
name|swap_sym_in
call|)
argument_list|(
name|cur_bfd
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
name|debug_info
operator|->
name|external_sym
operator|+
operator|(
operator|(
name|fh
operator|->
name|isymBase
operator|+
name|cur_sdx
operator|)
operator|*
name|external_sym_size
operator|)
operator|)
argument_list|,
operator|&
name|sh
argument_list|)
expr_stmt|;
if|if
condition|(
name|ECOFF_IS_STAB
argument_list|(
operator|&
name|sh
argument_list|)
condition|)
block|{
name|cur_sdx
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* Non absolute static symbols go into the minimal table.  */
if|if
condition|(
name|SC_IS_UNDEF
argument_list|(
name|sh
operator|.
name|sc
argument_list|)
operator|||
name|sh
operator|.
name|sc
operator|==
name|scNil
operator|||
operator|(
name|sh
operator|.
name|index
operator|==
name|indexNil
operator|&&
operator|(
name|sh
operator|.
name|st
operator|!=
name|stStatic
operator|||
name|sh
operator|.
name|sc
operator|==
name|scAbs
operator|)
operator|)
condition|)
block|{
comment|/* FIXME, premature? */
name|cur_sdx
operator|++
expr_stmt|;
continue|continue;
block|}
name|name
operator|=
name|debug_info
operator|->
name|ss
operator|+
name|fh
operator|->
name|issBase
operator|+
name|sh
operator|.
name|iss
expr_stmt|;
switch|switch
condition|(
name|sh
operator|.
name|sc
condition|)
block|{
case|case
name|scText
case|:
case|case
name|scRConst
case|:
comment|/* The value of a stEnd symbol is the displacement from the 		     corresponding start symbol value, do not relocate it.  */
if|if
condition|(
name|sh
operator|.
name|st
operator|!=
name|stEnd
condition|)
name|sh
operator|.
name|value
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
expr_stmt|;
break|break;
case|case
name|scData
case|:
case|case
name|scSData
case|:
case|case
name|scRData
case|:
case|case
name|scPData
case|:
case|case
name|scXData
case|:
name|sh
operator|.
name|value
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_DATA
argument_list|)
expr_stmt|;
break|break;
case|case
name|scBss
case|:
case|case
name|scSBss
case|:
name|sh
operator|.
name|value
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_BSS
argument_list|)
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|sh
operator|.
name|st
condition|)
block|{
name|CORE_ADDR
name|high
decl_stmt|;
name|CORE_ADDR
name|procaddr
decl_stmt|;
name|int
name|new_sdx
decl_stmt|;
case|case
name|stStaticProc
case|:
name|prim_record_minimal_symbol_and_info
argument_list|(
name|name
argument_list|,
name|sh
operator|.
name|value
argument_list|,
name|mst_file_text
argument_list|,
name|NULL
argument_list|,
name|SECT_OFF_TEXT
argument_list|,
name|NULL
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|stProc
case|:
comment|/* Usually there is a local and a global stProc symbol 		     for a function. This means that the function name 		     has already been entered into the mimimal symbol table 		     while processing the global symbols in pass 2 above. 		     One notable exception is the PROGRAM name from 		     f77 compiled executables, it is only put out as 		     local stProc symbol, and a global MAIN__ stProc symbol 		     points to it.  It doesn't matter though, as gdb is 		     still able to find the PROGRAM name via the partial 		     symbol table, and the MAIN__ symbol via the minimal 		     symbol table.  */
if|if
condition|(
name|sh
operator|.
name|st
operator|==
name|stProc
condition|)
name|add_psymbol_to_list
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
name|VAR_NAMESPACE
argument_list|,
name|LOC_BLOCK
argument_list|,
operator|&
name|objfile
operator|->
name|global_psymbols
argument_list|,
literal|0
argument_list|,
name|sh
operator|.
name|value
argument_list|,
name|psymtab_language
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
else|else
name|add_psymbol_to_list
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
name|VAR_NAMESPACE
argument_list|,
name|LOC_BLOCK
argument_list|,
operator|&
name|objfile
operator|->
name|static_psymbols
argument_list|,
literal|0
argument_list|,
name|sh
operator|.
name|value
argument_list|,
name|psymtab_language
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* Skip over procedure to next one. */
if|if
condition|(
name|sh
operator|.
name|index
operator|>=
name|hdr
operator|->
name|iauxMax
condition|)
block|{
comment|/* Should not happen, but does when cross-compiling 			   with the MIPS compiler.  FIXME -- pull later.  */
name|complain
argument_list|(
operator|&
name|index_complaint
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|new_sdx
operator|=
name|cur_sdx
operator|+
literal|1
expr_stmt|;
comment|/* Don't skip at all */
block|}
else|else
name|new_sdx
operator|=
name|AUX_GET_ISYM
argument_list|(
name|fh
operator|->
name|fBigendian
argument_list|,
operator|(
name|debug_info
operator|->
name|external_aux
operator|+
name|fh
operator|->
name|iauxBase
operator|+
name|sh
operator|.
name|index
operator|)
argument_list|)
expr_stmt|;
name|procaddr
operator|=
name|sh
operator|.
name|value
expr_stmt|;
if|if
condition|(
name|new_sdx
operator|<=
name|cur_sdx
condition|)
block|{
comment|/* This should not happen either... FIXME.  */
name|complain
argument_list|(
operator|&
name|aux_index_complaint
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|new_sdx
operator|=
name|cur_sdx
operator|+
literal|1
expr_stmt|;
comment|/* Don't skip backward */
block|}
name|cur_sdx
operator|=
name|new_sdx
expr_stmt|;
call|(
modifier|*
name|swap_sym_in
call|)
argument_list|(
name|cur_bfd
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
name|debug_info
operator|->
name|external_sym
operator|+
operator|(
operator|(
name|fh
operator|->
name|isymBase
operator|+
name|cur_sdx
operator|-
literal|1
operator|)
operator|*
name|external_sym_size
operator|)
operator|)
argument_list|,
operator|&
name|sh
argument_list|)
expr_stmt|;
if|if
condition|(
name|sh
operator|.
name|st
operator|!=
name|stEnd
condition|)
continue|continue;
comment|/* Kludge for Irix 5.2 zero fh->adr.  */
if|if
condition|(
operator|!
name|relocatable
operator|&&
operator|(
name|pst
operator|->
name|textlow
operator|==
literal|0
operator|||
name|procaddr
operator|<
name|pst
operator|->
name|textlow
operator|)
condition|)
name|pst
operator|->
name|textlow
operator|=
name|procaddr
expr_stmt|;
name|high
operator|=
name|procaddr
operator|+
name|sh
operator|.
name|value
expr_stmt|;
if|if
condition|(
name|high
operator|>
name|pst
operator|->
name|texthigh
condition|)
name|pst
operator|->
name|texthigh
operator|=
name|high
expr_stmt|;
continue|continue;
case|case
name|stStatic
case|:
comment|/* Variable */
if|if
condition|(
name|SC_IS_DATA
argument_list|(
name|sh
operator|.
name|sc
argument_list|)
condition|)
name|prim_record_minimal_symbol_and_info
argument_list|(
name|name
argument_list|,
name|sh
operator|.
name|value
argument_list|,
name|mst_file_data
argument_list|,
name|NULL
argument_list|,
name|SECT_OFF_DATA
argument_list|,
name|NULL
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
else|else
name|prim_record_minimal_symbol_and_info
argument_list|(
name|name
argument_list|,
name|sh
operator|.
name|value
argument_list|,
name|mst_file_bss
argument_list|,
name|NULL
argument_list|,
name|SECT_OFF_BSS
argument_list|,
name|NULL
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|class
operator|=
name|LOC_STATIC
expr_stmt|;
break|break;
case|case
name|stIndirect
case|:
comment|/* Irix5 forward declaration */
comment|/* Skip forward declarations from Irix5 cc */
goto|goto
name|skip
goto|;
case|case
name|stTypedef
case|:
comment|/* Typedef */
comment|/* Skip typedefs for forward declarations and opaque 		     structs from alpha and mips cc.  */
if|if
condition|(
name|sh
operator|.
name|iss
operator|==
literal|0
operator|||
name|has_opaque_xref
argument_list|(
name|fh
argument_list|,
operator|&
name|sh
argument_list|)
condition|)
goto|goto
name|skip
goto|;
name|class
operator|=
name|LOC_TYPEDEF
expr_stmt|;
break|break;
case|case
name|stConstant
case|:
comment|/* Constant decl */
name|class
operator|=
name|LOC_CONST
expr_stmt|;
break|break;
case|case
name|stUnion
case|:
case|case
name|stStruct
case|:
case|case
name|stEnum
case|:
case|case
name|stBlock
case|:
comment|/* { }, str, un, enum*/
comment|/* Do not create a partial symbol for cc unnamed aggregates 		     and gcc empty aggregates. */
if|if
condition|(
operator|(
name|sh
operator|.
name|sc
operator|==
name|scInfo
operator|||
name|SC_IS_COMMON
argument_list|(
name|sh
operator|.
name|sc
argument_list|)
operator|)
operator|&&
name|sh
operator|.
name|iss
operator|!=
literal|0
operator|&&
name|sh
operator|.
name|index
operator|!=
name|cur_sdx
operator|+
literal|2
condition|)
block|{
name|add_psymbol_to_list
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
name|STRUCT_NAMESPACE
argument_list|,
name|LOC_TYPEDEF
argument_list|,
operator|&
name|objfile
operator|->
name|static_psymbols
argument_list|,
literal|0
argument_list|,
operator|(
name|CORE_ADDR
operator|)
literal|0
argument_list|,
name|psymtab_language
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
name|handle_psymbol_enumerators
argument_list|(
name|objfile
argument_list|,
name|fh
argument_list|,
name|sh
operator|.
name|st
argument_list|,
name|sh
operator|.
name|value
argument_list|)
expr_stmt|;
comment|/* Skip over the block */
name|new_sdx
operator|=
name|sh
operator|.
name|index
expr_stmt|;
if|if
condition|(
name|new_sdx
operator|<=
name|cur_sdx
condition|)
block|{
comment|/* This happens with the Ultrix kernel. */
name|complain
argument_list|(
operator|&
name|block_index_complaint
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|new_sdx
operator|=
name|cur_sdx
operator|+
literal|1
expr_stmt|;
comment|/* Don't skip backward */
block|}
name|cur_sdx
operator|=
name|new_sdx
expr_stmt|;
continue|continue;
case|case
name|stFile
case|:
comment|/* File headers */
case|case
name|stLabel
case|:
comment|/* Labels */
case|case
name|stEnd
case|:
comment|/* Ends of files */
goto|goto
name|skip
goto|;
case|case
name|stLocal
case|:
comment|/* Local variables */
comment|/* Normally these are skipped because we skip over 		     all blocks we see.  However, these can occur 		     as visible symbols in a .h file that contains code. */
goto|goto
name|skip
goto|;
default|default:
comment|/* Both complaints are valid:  one gives symbol name, 		     the other the offending symbol type.  */
name|complain
argument_list|(
operator|&
name|unknown_sym_complaint
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|complain
argument_list|(
operator|&
name|unknown_st_complaint
argument_list|,
name|sh
operator|.
name|st
argument_list|)
expr_stmt|;
name|cur_sdx
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* Use this gdb symbol */
name|add_psymbol_to_list
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
name|VAR_NAMESPACE
argument_list|,
name|class
argument_list|,
operator|&
name|objfile
operator|->
name|static_psymbols
argument_list|,
literal|0
argument_list|,
name|sh
operator|.
name|value
argument_list|,
name|psymtab_language
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|skip
label|:
name|cur_sdx
operator|++
expr_stmt|;
comment|/* Go to next file symbol */
block|}
comment|/* Now do enter the external symbols. */
name|ext_ptr
operator|=
operator|&
name|extern_tab
index|[
name|fdr_to_pst
index|[
name|f_idx
index|]
operator|.
name|globals_offset
index|]
expr_stmt|;
name|cur_sdx
operator|=
name|fdr_to_pst
index|[
name|f_idx
index|]
operator|.
name|n_globals
expr_stmt|;
name|PST_PRIVATE
argument_list|(
name|save_pst
argument_list|)
operator|->
name|extern_count
operator|=
name|cur_sdx
expr_stmt|;
name|PST_PRIVATE
argument_list|(
name|save_pst
argument_list|)
operator|->
name|extern_tab
operator|=
name|ext_ptr
expr_stmt|;
for|for
control|(
init|;
operator|--
name|cur_sdx
operator|>=
literal|0
condition|;
name|ext_ptr
operator|++
control|)
block|{
name|enum
name|address_class
name|class
decl_stmt|;
name|SYMR
modifier|*
name|psh
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|CORE_ADDR
name|svalue
decl_stmt|;
if|if
condition|(
name|ext_ptr
operator|->
name|ifd
operator|!=
name|f_idx
condition|)
name|abort
argument_list|()
expr_stmt|;
name|psh
operator|=
operator|&
name|ext_ptr
operator|->
name|asym
expr_stmt|;
comment|/* Do not add undefined symbols to the partial symbol table.  */
if|if
condition|(
name|SC_IS_UNDEF
argument_list|(
name|psh
operator|->
name|sc
argument_list|)
operator|||
name|psh
operator|->
name|sc
operator|==
name|scNil
condition|)
continue|continue;
name|svalue
operator|=
name|psh
operator|->
name|value
expr_stmt|;
switch|switch
condition|(
name|psh
operator|->
name|sc
condition|)
block|{
case|case
name|scText
case|:
case|case
name|scRConst
case|:
name|svalue
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
expr_stmt|;
break|break;
case|case
name|scData
case|:
case|case
name|scSData
case|:
case|case
name|scRData
case|:
case|case
name|scPData
case|:
case|case
name|scXData
case|:
name|svalue
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_DATA
argument_list|)
expr_stmt|;
break|break;
case|case
name|scBss
case|:
case|case
name|scSBss
case|:
name|svalue
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_BSS
argument_list|)
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|psh
operator|->
name|st
condition|)
block|{
case|case
name|stNil
case|:
comment|/* These are generated for static symbols in .o files, 		     ignore them.  */
continue|continue;
case|case
name|stProc
case|:
case|case
name|stStaticProc
case|:
comment|/* External procedure symbols have been entered 		     into the minimal symbol table in pass 2 above. 		     Ignore them, as parse_external will ignore them too.  */
continue|continue;
case|case
name|stLabel
case|:
name|class
operator|=
name|LOC_LABEL
expr_stmt|;
break|break;
default|default:
name|complain
argument_list|(
operator|&
name|unknown_ext_complaint
argument_list|,
name|debug_info
operator|->
name|ssext
operator|+
name|psh
operator|->
name|iss
argument_list|)
expr_stmt|;
comment|/* Fall through, pretend it's global.  */
case|case
name|stGlobal
case|:
comment|/* Global common symbols are resolved by the runtime loader, 		     ignore them.  */
if|if
condition|(
name|SC_IS_COMMON
argument_list|(
name|psh
operator|->
name|sc
argument_list|)
condition|)
continue|continue;
name|class
operator|=
name|LOC_STATIC
expr_stmt|;
break|break;
block|}
name|name
operator|=
name|debug_info
operator|->
name|ssext
operator|+
name|psh
operator|->
name|iss
expr_stmt|;
name|add_psymbol_to_list
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
name|VAR_NAMESPACE
argument_list|,
name|class
argument_list|,
operator|&
name|objfile
operator|->
name|global_psymbols
argument_list|,
literal|0
argument_list|,
name|svalue
argument_list|,
name|psymtab_language
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Link pst to FDR. end_psymtab returns NULL if the psymtab was 	 empty and put on the free list.  */
name|fdr_to_pst
index|[
name|f_idx
index|]
operator|.
name|pst
operator|=
name|end_psymtab
argument_list|(
name|save_pst
argument_list|,
name|psymtab_include_list
argument_list|,
name|includes_used
argument_list|,
operator|-
literal|1
argument_list|,
name|save_pst
operator|->
name|texthigh
argument_list|,
name|dependency_list
argument_list|,
name|dependencies_used
argument_list|,
name|textlow_not_set
argument_list|)
expr_stmt|;
name|includes_used
operator|=
literal|0
expr_stmt|;
name|dependencies_used
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|objfile
operator|->
name|ei
operator|.
name|entry_point
operator|>=
name|save_pst
operator|->
name|textlow
operator|&&
name|objfile
operator|->
name|ei
operator|.
name|entry_point
operator|<
name|save_pst
operator|->
name|texthigh
condition|)
block|{
name|objfile
operator|->
name|ei
operator|.
name|entry_file_lowpc
operator|=
name|save_pst
operator|->
name|textlow
expr_stmt|;
name|objfile
operator|->
name|ei
operator|.
name|entry_file_highpc
operator|=
name|save_pst
operator|->
name|texthigh
expr_stmt|;
block|}
comment|/* The objfile has its functions reordered if this partial symbol 	 table overlaps any other partial symbol table. 	 We cannot assume a reordered objfile if a partial symbol table 	 is contained within another partial symbol table, as partial symbol 	 tables for include files with executable code are contained 	 within the partial symbol table for the including source file, 	 and we do not want to flag the objfile reordered for these cases.  	 This strategy works well for Irix-5.2 shared libraries, but we 	 might have to use a more elaborate (and slower) algorithm for 	 other cases.  */
name|save_pst
operator|=
name|fdr_to_pst
index|[
name|f_idx
index|]
operator|.
name|pst
expr_stmt|;
if|if
condition|(
name|save_pst
operator|!=
name|NULL
operator|&&
name|save_pst
operator|->
name|textlow
operator|!=
literal|0
operator|&&
operator|!
operator|(
name|objfile
operator|->
name|flags
operator|&
name|OBJF_REORDERED
operator|)
condition|)
block|{
name|ALL_OBJFILE_PSYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|pst
argument_list|)
block|{
if|if
condition|(
name|save_pst
operator|!=
name|pst
operator|&&
name|save_pst
operator|->
name|textlow
operator|>=
name|pst
operator|->
name|textlow
operator|&&
name|save_pst
operator|->
name|textlow
operator|<
name|pst
operator|->
name|texthigh
operator|&&
name|save_pst
operator|->
name|texthigh
operator|>
name|pst
operator|->
name|texthigh
condition|)
block|{
name|objfile
operator|->
name|flags
operator||=
name|OBJF_REORDERED
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
comment|/* Now scan the FDRs for dependencies */
for|for
control|(
name|f_idx
operator|=
literal|0
init|;
name|f_idx
operator|<
name|hdr
operator|->
name|ifdMax
condition|;
name|f_idx
operator|++
control|)
block|{
name|fh
operator|=
name|f_idx
operator|+
name|debug_info
operator|->
name|fdr
expr_stmt|;
name|pst
operator|=
name|fdr_to_pst
index|[
name|f_idx
index|]
operator|.
name|pst
expr_stmt|;
if|if
condition|(
name|pst
operator|==
operator|(
expr|struct
name|partial_symtab
operator|*
operator|)
name|NULL
condition|)
continue|continue;
comment|/* This should catch stabs-in-ecoff. */
if|if
condition|(
name|fh
operator|->
name|crfd
operator|<=
literal|1
condition|)
continue|continue;
comment|/* Skip the first file indirect entry as it is a self dependency 	 for source files or a reverse .h -> .c dependency for header files.  */
name|pst
operator|->
name|number_of_dependencies
operator|=
literal|0
expr_stmt|;
name|pst
operator|->
name|dependencies
operator|=
operator|(
operator|(
expr|struct
name|partial_symtab
operator|*
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|psymbol_obstack
argument_list|,
operator|(
operator|(
name|fh
operator|->
name|crfd
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|partial_symtab
operator|*
argument_list|)
operator|)
argument_list|)
operator|)
expr_stmt|;
for|for
control|(
name|s_idx
operator|=
literal|1
init|;
name|s_idx
operator|<
name|fh
operator|->
name|crfd
condition|;
name|s_idx
operator|++
control|)
block|{
name|RFDT
name|rh
decl_stmt|;
call|(
modifier|*
name|swap_rfd_in
call|)
argument_list|(
name|cur_bfd
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
name|debug_info
operator|->
name|external_rfd
operator|+
operator|(
name|fh
operator|->
name|rfdBase
operator|+
name|s_idx
operator|)
operator|*
name|external_rfd_size
operator|)
argument_list|,
operator|&
name|rh
argument_list|)
expr_stmt|;
if|if
condition|(
name|rh
operator|<
literal|0
operator|||
name|rh
operator|>=
name|hdr
operator|->
name|ifdMax
condition|)
block|{
name|complain
argument_list|(
operator|&
name|bad_file_number_complaint
argument_list|,
name|rh
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Skip self dependencies of header files.  */
if|if
condition|(
name|rh
operator|==
name|f_idx
condition|)
continue|continue;
comment|/* Do not add to dependeny list if psymtab was empty.  */
if|if
condition|(
name|fdr_to_pst
index|[
name|rh
index|]
operator|.
name|pst
operator|==
operator|(
expr|struct
name|partial_symtab
operator|*
operator|)
name|NULL
condition|)
continue|continue;
name|pst
operator|->
name|dependencies
index|[
name|pst
operator|->
name|number_of_dependencies
operator|++
index|]
operator|=
name|fdr_to_pst
index|[
name|rh
index|]
operator|.
name|pst
expr_stmt|;
block|}
block|}
comment|/* Remove the dummy psymtab created for -O3 images above, if it is      still empty, to enable the detection of stripped executables.  */
if|if
condition|(
name|objfile
operator|->
name|psymtabs
operator|->
name|next
operator|==
name|NULL
operator|&&
name|objfile
operator|->
name|psymtabs
operator|->
name|number_of_dependencies
operator|==
literal|0
operator|&&
name|objfile
operator|->
name|psymtabs
operator|->
name|n_global_syms
operator|==
literal|0
operator|&&
name|objfile
operator|->
name|psymtabs
operator|->
name|n_static_syms
operator|==
literal|0
condition|)
name|objfile
operator|->
name|psymtabs
operator|=
name|NULL
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If the current psymbol has an enumerated type, we need to add    all the the enum constants to the partial symbol table.  */
end_comment

begin_function
specifier|static
name|void
name|handle_psymbol_enumerators
parameter_list|(
name|objfile
parameter_list|,
name|fh
parameter_list|,
name|stype
parameter_list|,
name|svalue
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|FDR
modifier|*
name|fh
decl_stmt|;
name|int
name|stype
decl_stmt|;
name|CORE_ADDR
name|svalue
decl_stmt|;
block|{
specifier|const
name|bfd_size_type
name|external_sym_size
init|=
name|debug_swap
operator|->
name|external_sym_size
decl_stmt|;
name|void
argument_list|(
argument|* const swap_sym_in
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|,
name|SYMR
operator|*
operator|)
argument_list|)
operator|=
name|debug_swap
operator|->
name|swap_sym_in
expr_stmt|;
name|char
modifier|*
name|ext_sym
init|=
operator|(
operator|(
name|char
operator|*
operator|)
name|debug_info
operator|->
name|external_sym
operator|+
operator|(
operator|(
name|fh
operator|->
name|isymBase
operator|+
name|cur_sdx
operator|+
literal|1
operator|)
operator|*
name|external_sym_size
operator|)
operator|)
decl_stmt|;
name|SYMR
name|sh
decl_stmt|;
name|TIR
name|tir
decl_stmt|;
switch|switch
condition|(
name|stype
condition|)
block|{
case|case
name|stEnum
case|:
break|break;
case|case
name|stBlock
case|:
comment|/* It is an enumerated type if the next symbol entry is a stMember 	 and its auxiliary index is indexNil or its auxiliary entry 	 is a plain btNil or btVoid. 	 Alpha cc -migrate enums are recognized by a zero index and 	 a zero symbol value. 	 DU 4.0 cc enums are recognized by a member type of btEnum without 	 qualifiers and a zero symbol value.  */
call|(
modifier|*
name|swap_sym_in
call|)
argument_list|(
name|cur_bfd
argument_list|,
name|ext_sym
argument_list|,
operator|&
name|sh
argument_list|)
expr_stmt|;
if|if
condition|(
name|sh
operator|.
name|st
operator|!=
name|stMember
condition|)
return|return;
if|if
condition|(
name|sh
operator|.
name|index
operator|==
name|indexNil
operator|||
operator|(
name|sh
operator|.
name|index
operator|==
literal|0
operator|&&
name|svalue
operator|==
literal|0
operator|)
condition|)
break|break;
call|(
modifier|*
name|debug_swap
operator|->
name|swap_tir_in
call|)
argument_list|(
name|fh
operator|->
name|fBigendian
argument_list|,
operator|&
operator|(
name|debug_info
operator|->
name|external_aux
operator|+
name|fh
operator|->
name|iauxBase
operator|+
name|sh
operator|.
name|index
operator|)
operator|->
name|a_ti
argument_list|,
operator|&
name|tir
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tir
operator|.
name|bt
operator|!=
name|btNil
operator|&&
name|tir
operator|.
name|bt
operator|!=
name|btVoid
operator|&&
operator|(
name|tir
operator|.
name|bt
operator|!=
name|btEnum
operator|||
name|svalue
operator|!=
literal|0
operator|)
operator|)
operator|||
name|tir
operator|.
name|tq0
operator|!=
name|tqNil
condition|)
return|return;
break|break;
default|default:
return|return;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
call|(
modifier|*
name|swap_sym_in
call|)
argument_list|(
name|cur_bfd
argument_list|,
name|ext_sym
argument_list|,
operator|&
name|sh
argument_list|)
expr_stmt|;
if|if
condition|(
name|sh
operator|.
name|st
operator|!=
name|stMember
condition|)
break|break;
name|name
operator|=
name|debug_info
operator|->
name|ss
operator|+
name|cur_fdr
operator|->
name|issBase
operator|+
name|sh
operator|.
name|iss
expr_stmt|;
comment|/* Note that the value doesn't matter for enum constants 	 in psymtabs, just in symtabs.  */
name|add_psymbol_to_list
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
name|VAR_NAMESPACE
argument_list|,
name|LOC_CONST
argument_list|,
operator|&
name|objfile
operator|->
name|static_psymbols
argument_list|,
literal|0
argument_list|,
operator|(
name|CORE_ADDR
operator|)
literal|0
argument_list|,
name|psymtab_language
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|ext_sym
operator|+=
name|external_sym_size
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|mdebug_next_symbol_text
parameter_list|(
name|objfile
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
comment|/* argument objfile is currently unused */
block|{
name|SYMR
name|sh
decl_stmt|;
name|cur_sdx
operator|++
expr_stmt|;
call|(
modifier|*
name|debug_swap
operator|->
name|swap_sym_in
call|)
argument_list|(
name|cur_bfd
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
name|debug_info
operator|->
name|external_sym
operator|+
operator|(
operator|(
name|cur_fdr
operator|->
name|isymBase
operator|+
name|cur_sdx
operator|)
operator|*
name|debug_swap
operator|->
name|external_sym_size
operator|)
operator|)
argument_list|,
operator|&
name|sh
argument_list|)
expr_stmt|;
return|return
name|debug_info
operator|->
name|ss
operator|+
name|cur_fdr
operator|->
name|issBase
operator|+
name|sh
operator|.
name|iss
return|;
block|}
end_function

begin_comment
comment|/* Ancillary function to psymtab_to_symtab().  Does all the work    for turning the partial symtab PST into a symtab, recurring    first on all dependent psymtabs.  The argument FILENAME is    only passed so we can see in debug stack traces what file    is being read.     This function has a split personality, based on whether the    symbol table contains ordinary ecoff symbols, or stabs-in-ecoff.    The flow of control and even the memory allocation differs.  FIXME.  */
end_comment

begin_function
specifier|static
name|void
name|psymtab_to_symtab_1
parameter_list|(
name|pst
parameter_list|,
name|filename
parameter_list|)
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|bfd_size_type
name|external_sym_size
decl_stmt|;
name|bfd_size_type
name|external_pdr_size
decl_stmt|;
name|void
argument_list|(
argument|*swap_sym_in
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|,
name|SYMR
operator|*
operator|)
argument_list|)
expr_stmt|;
name|void
argument_list|(
argument|*swap_pdr_in
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|,
name|PDR
operator|*
operator|)
argument_list|)
expr_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|symtab
modifier|*
name|st
decl_stmt|;
name|FDR
modifier|*
name|fh
decl_stmt|;
name|struct
name|linetable
modifier|*
name|lines
decl_stmt|;
name|CORE_ADDR
name|lowest_pdr_addr
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|pst
operator|->
name|readin
condition|)
return|return;
name|pst
operator|->
name|readin
operator|=
literal|1
expr_stmt|;
comment|/* Read in all partial symbtabs on which this one is dependent.      NOTE that we do have circular dependencies, sigh.  We solved      that by setting pst->readin before this point.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pst
operator|->
name|number_of_dependencies
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|pst
operator|->
name|dependencies
index|[
name|i
index|]
operator|->
name|readin
condition|)
block|{
comment|/* Inform about additional files to be read in.  */
if|if
condition|(
name|info_verbose
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|" "
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"and "
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%s..."
argument_list|,
name|pst
operator|->
name|dependencies
index|[
name|i
index|]
operator|->
name|filename
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
comment|/* Flush output */
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
comment|/* We only pass the filename for debug purposes */
name|psymtab_to_symtab_1
argument_list|(
name|pst
operator|->
name|dependencies
index|[
name|i
index|]
argument_list|,
name|pst
operator|->
name|dependencies
index|[
name|i
index|]
operator|->
name|filename
argument_list|)
expr_stmt|;
block|}
comment|/* Do nothing if this is a dummy psymtab.  */
if|if
condition|(
name|pst
operator|->
name|n_global_syms
operator|==
literal|0
operator|&&
name|pst
operator|->
name|n_static_syms
operator|==
literal|0
operator|&&
name|pst
operator|->
name|textlow
operator|==
literal|0
operator|&&
name|pst
operator|->
name|texthigh
operator|==
literal|0
condition|)
return|return;
comment|/* Now read the symbols for this symtab */
name|cur_bfd
operator|=
name|CUR_BFD
argument_list|(
name|pst
argument_list|)
expr_stmt|;
name|debug_swap
operator|=
name|DEBUG_SWAP
argument_list|(
name|pst
argument_list|)
expr_stmt|;
name|debug_info
operator|=
name|DEBUG_INFO
argument_list|(
name|pst
argument_list|)
expr_stmt|;
name|pending_list
operator|=
name|PENDING_LIST
argument_list|(
name|pst
argument_list|)
expr_stmt|;
name|external_sym_size
operator|=
name|debug_swap
operator|->
name|external_sym_size
expr_stmt|;
name|external_pdr_size
operator|=
name|debug_swap
operator|->
name|external_pdr_size
expr_stmt|;
name|swap_sym_in
operator|=
name|debug_swap
operator|->
name|swap_sym_in
expr_stmt|;
name|swap_pdr_in
operator|=
name|debug_swap
operator|->
name|swap_pdr_in
expr_stmt|;
name|current_objfile
operator|=
name|pst
operator|->
name|objfile
expr_stmt|;
name|cur_fd
operator|=
name|FDR_IDX
argument_list|(
name|pst
argument_list|)
expr_stmt|;
name|fh
operator|=
operator|(
operator|(
name|cur_fd
operator|==
operator|-
literal|1
operator|)
condition|?
operator|(
name|FDR
operator|*
operator|)
name|NULL
else|:
name|debug_info
operator|->
name|fdr
operator|+
name|cur_fd
operator|)
expr_stmt|;
name|cur_fdr
operator|=
name|fh
expr_stmt|;
comment|/* See comment in parse_partial_symbols about the @stabs sentinel. */
name|processing_gcc_compilation
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fh
operator|!=
operator|(
name|FDR
operator|*
operator|)
name|NULL
operator|&&
name|fh
operator|->
name|csym
operator|>=
literal|2
condition|)
block|{
name|SYMR
name|sh
decl_stmt|;
call|(
modifier|*
name|swap_sym_in
call|)
argument_list|(
name|cur_bfd
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
name|debug_info
operator|->
name|external_sym
operator|+
operator|(
name|fh
operator|->
name|isymBase
operator|+
literal|1
operator|)
operator|*
name|external_sym_size
operator|)
argument_list|,
operator|&
name|sh
argument_list|)
expr_stmt|;
if|if
condition|(
name|STREQ
argument_list|(
name|debug_info
operator|->
name|ss
operator|+
name|fh
operator|->
name|issBase
operator|+
name|sh
operator|.
name|iss
argument_list|,
name|stabs_symbol
argument_list|)
condition|)
block|{
comment|/* We indicate that this is a GCC compilation so that certain 	     features will be enabled in stabsread/dbxread.  */
name|processing_gcc_compilation
operator|=
literal|2
expr_stmt|;
block|}
block|}
if|if
condition|(
name|processing_gcc_compilation
operator|!=
literal|0
condition|)
block|{
comment|/* This symbol table contains stabs-in-ecoff entries.  */
comment|/* Parse local symbols first */
if|if
condition|(
name|fh
operator|->
name|csym
operator|<=
literal|2
condition|)
comment|/* FIXME, this blows psymtab->symtab ptr */
block|{
name|current_objfile
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
for|for
control|(
name|cur_sdx
operator|=
literal|2
init|;
name|cur_sdx
operator|<
name|fh
operator|->
name|csym
condition|;
name|cur_sdx
operator|++
control|)
block|{
name|SYMR
name|sh
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|CORE_ADDR
name|valu
decl_stmt|;
call|(
modifier|*
name|swap_sym_in
call|)
argument_list|(
name|cur_bfd
argument_list|,
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|debug_info
operator|->
name|external_sym
operator|)
operator|+
operator|(
name|fh
operator|->
name|isymBase
operator|+
name|cur_sdx
operator|)
operator|*
name|external_sym_size
operator|)
argument_list|,
operator|&
name|sh
argument_list|)
expr_stmt|;
name|name
operator|=
name|debug_info
operator|->
name|ss
operator|+
name|fh
operator|->
name|issBase
operator|+
name|sh
operator|.
name|iss
expr_stmt|;
name|valu
operator|=
name|sh
operator|.
name|value
expr_stmt|;
comment|/* XXX This is a hack.  It will go away!  */
if|if
condition|(
name|ECOFF_IS_STAB
argument_list|(
operator|&
name|sh
argument_list|)
operator|||
operator|(
name|name
index|[
literal|0
index|]
operator|==
literal|'#'
operator|)
condition|)
block|{
name|int
name|type_code
init|=
name|ECOFF_UNMARK_STAB
argument_list|(
name|sh
operator|.
name|index
argument_list|)
decl_stmt|;
comment|/* We should never get non N_STAB symbols here, but they 		 should be harmless, so keep process_one_symbol from 		 complaining about them.  */
if|if
condition|(
name|type_code
operator|&
name|N_STAB
condition|)
block|{
name|process_one_symbol
argument_list|(
name|type_code
argument_list|,
literal|0
argument_list|,
name|valu
argument_list|,
name|name
argument_list|,
name|pst
operator|->
name|section_offsets
argument_list|,
name|pst
operator|->
name|objfile
argument_list|)
expr_stmt|;
block|}
comment|/* Similarly a hack.  */
elseif|else
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
block|{
name|process_one_symbol
argument_list|(
name|N_SLINE
argument_list|,
literal|0
argument_list|,
name|valu
argument_list|,
name|name
argument_list|,
name|pst
operator|->
name|section_offsets
argument_list|,
name|pst
operator|->
name|objfile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|type_code
operator|==
name|N_FUN
condition|)
block|{
comment|/* Make up special symbol to contain 		     procedure specific info */
name|struct
name|mips_extra_func_info
modifier|*
name|e
init|=
operator|(
operator|(
expr|struct
name|mips_extra_func_info
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|current_objfile
operator|->
name|symbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mips_extra_func_info
argument_list|)
argument_list|)
operator|)
decl_stmt|;
name|struct
name|symbol
modifier|*
name|s
init|=
name|new_symbol
argument_list|(
name|MIPS_EFI_SYMBOL_NAME
argument_list|)
decl_stmt|;
name|memset
argument_list|(
operator|(
name|PTR
operator|)
name|e
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mips_extra_func_info
argument_list|)
argument_list|)
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|s
argument_list|)
operator|=
name|LABEL_NAMESPACE
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|s
argument_list|)
operator|=
name|LOC_CONST
expr_stmt|;
name|SYMBOL_TYPE
argument_list|(
name|s
argument_list|)
operator|=
name|mdebug_type_void
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|s
argument_list|)
operator|=
operator|(
name|long
operator|)
name|e
expr_stmt|;
name|e
operator|->
name|pdr
operator|.
name|framereg
operator|=
operator|-
literal|1
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|s
argument_list|,
operator|&
name|local_symbols
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|sh
operator|.
name|st
operator|==
name|stLabel
condition|)
block|{
if|if
condition|(
name|sh
operator|.
name|index
operator|==
name|indexNil
condition|)
block|{
comment|/* This is what the gcc2_compiled and __gnu_compiled_* 		     show up as.  So don't complain.  */
empty_stmt|;
block|}
else|else
block|{
comment|/* Handle encoded stab line number. */
name|valu
operator|+=
name|ANOFFSET
argument_list|(
name|pst
operator|->
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
expr_stmt|;
name|record_line
argument_list|(
name|current_subfile
argument_list|,
name|sh
operator|.
name|index
argument_list|,
name|valu
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|sh
operator|.
name|st
operator|==
name|stProc
operator|||
name|sh
operator|.
name|st
operator|==
name|stStaticProc
operator|||
name|sh
operator|.
name|st
operator|==
name|stStatic
operator|||
name|sh
operator|.
name|st
operator|==
name|stEnd
condition|)
comment|/* These are generated by gcc-2.x, do not complain */
empty_stmt|;
else|else
name|complain
argument_list|(
operator|&
name|stab_unknown_complaint
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|st
operator|=
name|end_symtab
argument_list|(
name|pst
operator|->
name|texthigh
argument_list|,
name|pst
operator|->
name|objfile
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
expr_stmt|;
name|end_stabs
argument_list|()
expr_stmt|;
comment|/* Sort the symbol table now, we are done adding symbols to it. 	 We must do this before parse_procedure calls lookup_symbol.  */
name|sort_symtab_syms
argument_list|(
name|st
argument_list|)
expr_stmt|;
comment|/* There used to be a call to sort_blocks here, but this should not 	 be necessary for stabs symtabs.  And as sort_blocks modifies the 	 start address of the GLOBAL_BLOCK to the FIRST_LOCAL_BLOCK, 	 it did the wrong thing if the first procedure in a file was 	 generated via asm statements.  */
comment|/* Fill in procedure info next.  */
if|if
condition|(
name|fh
operator|->
name|cpd
operator|>
literal|0
condition|)
block|{
name|PDR
modifier|*
name|pr_block
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|char
modifier|*
name|pdr_ptr
decl_stmt|;
name|char
modifier|*
name|pdr_end
decl_stmt|;
name|PDR
modifier|*
name|pdr_in
decl_stmt|;
name|PDR
modifier|*
name|pdr_in_end
decl_stmt|;
name|pr_block
operator|=
operator|(
name|PDR
operator|*
operator|)
name|xmalloc
argument_list|(
name|fh
operator|->
name|cpd
operator|*
sizeof|sizeof
argument_list|(
name|PDR
argument_list|)
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|pr_block
argument_list|)
expr_stmt|;
name|pdr_ptr
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|debug_info
operator|->
name|external_pdr
operator|+
name|fh
operator|->
name|ipdFirst
operator|*
name|external_pdr_size
operator|)
expr_stmt|;
name|pdr_end
operator|=
name|pdr_ptr
operator|+
name|fh
operator|->
name|cpd
operator|*
name|external_pdr_size
expr_stmt|;
name|pdr_in
operator|=
name|pr_block
expr_stmt|;
for|for
control|(
init|;
name|pdr_ptr
operator|<
name|pdr_end
condition|;
name|pdr_ptr
operator|+=
name|external_pdr_size
operator|,
name|pdr_in
operator|++
control|)
block|{
call|(
modifier|*
name|swap_pdr_in
call|)
argument_list|(
name|cur_bfd
argument_list|,
name|pdr_ptr
argument_list|,
name|pdr_in
argument_list|)
expr_stmt|;
comment|/* Determine lowest PDR address, the PDRs are not always 		 sorted.  */
if|if
condition|(
name|pdr_in
operator|==
name|pr_block
condition|)
name|lowest_pdr_addr
operator|=
name|pdr_in
operator|->
name|adr
expr_stmt|;
elseif|else
if|if
condition|(
name|pdr_in
operator|->
name|adr
operator|<
name|lowest_pdr_addr
condition|)
name|lowest_pdr_addr
operator|=
name|pdr_in
operator|->
name|adr
expr_stmt|;
block|}
name|pdr_in
operator|=
name|pr_block
expr_stmt|;
name|pdr_in_end
operator|=
name|pdr_in
operator|+
name|fh
operator|->
name|cpd
expr_stmt|;
for|for
control|(
init|;
name|pdr_in
operator|<
name|pdr_in_end
condition|;
name|pdr_in
operator|++
control|)
name|parse_procedure
argument_list|(
name|pdr_in
argument_list|,
name|st
argument_list|,
name|pst
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* This symbol table contains ordinary ecoff entries.  */
name|int
name|f_max
decl_stmt|;
name|int
name|maxlines
decl_stmt|;
name|EXTR
modifier|*
name|ext_ptr
decl_stmt|;
comment|/* How many symbols will we need */
comment|/* FIXME, this does not count enum values. */
name|f_max
operator|=
name|pst
operator|->
name|n_global_syms
operator|+
name|pst
operator|->
name|n_static_syms
expr_stmt|;
if|if
condition|(
name|fh
operator|==
literal|0
condition|)
block|{
name|maxlines
operator|=
literal|0
expr_stmt|;
name|st
operator|=
name|new_symtab
argument_list|(
literal|"unknown"
argument_list|,
name|f_max
argument_list|,
literal|0
argument_list|,
name|pst
operator|->
name|objfile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|f_max
operator|+=
name|fh
operator|->
name|csym
operator|+
name|fh
operator|->
name|cpd
expr_stmt|;
name|maxlines
operator|=
literal|2
operator|*
name|fh
operator|->
name|cline
expr_stmt|;
name|st
operator|=
name|new_symtab
argument_list|(
name|pst
operator|->
name|filename
argument_list|,
literal|2
operator|*
name|f_max
argument_list|,
name|maxlines
argument_list|,
name|pst
operator|->
name|objfile
argument_list|)
expr_stmt|;
comment|/* The proper language was already determined when building 	     the psymtab, use it.  */
name|st
operator|->
name|language
operator|=
name|PST_PRIVATE
argument_list|(
name|pst
argument_list|)
operator|->
name|pst_language
expr_stmt|;
block|}
name|psymtab_language
operator|=
name|st
operator|->
name|language
expr_stmt|;
name|lines
operator|=
name|LINETABLE
argument_list|(
name|st
argument_list|)
expr_stmt|;
comment|/* Get a new lexical context */
name|push_parse_stack
argument_list|()
expr_stmt|;
name|top_stack
operator|->
name|cur_st
operator|=
name|st
expr_stmt|;
name|top_stack
operator|->
name|cur_block
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|BLOCKVECTOR
argument_list|(
name|st
argument_list|)
argument_list|,
name|STATIC_BLOCK
argument_list|)
expr_stmt|;
name|BLOCK_START
argument_list|(
name|top_stack
operator|->
name|cur_block
argument_list|)
operator|=
name|pst
operator|->
name|textlow
expr_stmt|;
name|BLOCK_END
argument_list|(
name|top_stack
operator|->
name|cur_block
argument_list|)
operator|=
literal|0
expr_stmt|;
name|top_stack
operator|->
name|blocktype
operator|=
name|stFile
expr_stmt|;
name|top_stack
operator|->
name|maxsyms
operator|=
literal|2
operator|*
name|f_max
expr_stmt|;
name|top_stack
operator|->
name|cur_type
operator|=
literal|0
expr_stmt|;
name|top_stack
operator|->
name|procadr
operator|=
literal|0
expr_stmt|;
name|top_stack
operator|->
name|numargs
operator|=
literal|0
expr_stmt|;
name|found_ecoff_debugging_info
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fh
condition|)
block|{
name|char
modifier|*
name|sym_ptr
decl_stmt|;
name|char
modifier|*
name|sym_end
decl_stmt|;
comment|/* Parse local symbols first */
name|sym_ptr
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|debug_info
operator|->
name|external_sym
operator|+
name|fh
operator|->
name|isymBase
operator|*
name|external_sym_size
operator|)
expr_stmt|;
name|sym_end
operator|=
name|sym_ptr
operator|+
name|fh
operator|->
name|csym
operator|*
name|external_sym_size
expr_stmt|;
while|while
condition|(
name|sym_ptr
operator|<
name|sym_end
condition|)
block|{
name|SYMR
name|sh
decl_stmt|;
name|int
name|c
decl_stmt|;
call|(
modifier|*
name|swap_sym_in
call|)
argument_list|(
name|cur_bfd
argument_list|,
name|sym_ptr
argument_list|,
operator|&
name|sh
argument_list|)
expr_stmt|;
name|c
operator|=
name|parse_symbol
argument_list|(
operator|&
name|sh
argument_list|,
name|debug_info
operator|->
name|external_aux
operator|+
name|fh
operator|->
name|iauxBase
argument_list|,
name|sym_ptr
argument_list|,
name|fh
operator|->
name|fBigendian
argument_list|,
name|pst
operator|->
name|section_offsets
argument_list|)
expr_stmt|;
name|sym_ptr
operator|+=
name|c
operator|*
name|external_sym_size
expr_stmt|;
block|}
comment|/* Linenumbers.  At the end, check if we can save memory. 	     parse_lines has to look ahead an arbitrary number of PDR 	     structures, so we swap them all first.  */
if|if
condition|(
name|fh
operator|->
name|cpd
operator|>
literal|0
condition|)
block|{
name|PDR
modifier|*
name|pr_block
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|char
modifier|*
name|pdr_ptr
decl_stmt|;
name|char
modifier|*
name|pdr_end
decl_stmt|;
name|PDR
modifier|*
name|pdr_in
decl_stmt|;
name|PDR
modifier|*
name|pdr_in_end
decl_stmt|;
name|pr_block
operator|=
operator|(
name|PDR
operator|*
operator|)
name|xmalloc
argument_list|(
name|fh
operator|->
name|cpd
operator|*
sizeof|sizeof
argument_list|(
name|PDR
argument_list|)
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|pr_block
argument_list|)
expr_stmt|;
name|pdr_ptr
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|debug_info
operator|->
name|external_pdr
operator|+
name|fh
operator|->
name|ipdFirst
operator|*
name|external_pdr_size
operator|)
expr_stmt|;
name|pdr_end
operator|=
name|pdr_ptr
operator|+
name|fh
operator|->
name|cpd
operator|*
name|external_pdr_size
expr_stmt|;
name|pdr_in
operator|=
name|pr_block
expr_stmt|;
for|for
control|(
init|;
name|pdr_ptr
operator|<
name|pdr_end
condition|;
name|pdr_ptr
operator|+=
name|external_pdr_size
operator|,
name|pdr_in
operator|++
control|)
block|{
call|(
modifier|*
name|swap_pdr_in
call|)
argument_list|(
name|cur_bfd
argument_list|,
name|pdr_ptr
argument_list|,
name|pdr_in
argument_list|)
expr_stmt|;
comment|/* Determine lowest PDR address, the PDRs are not always 		     sorted.  */
if|if
condition|(
name|pdr_in
operator|==
name|pr_block
condition|)
name|lowest_pdr_addr
operator|=
name|pdr_in
operator|->
name|adr
expr_stmt|;
elseif|else
if|if
condition|(
name|pdr_in
operator|->
name|adr
operator|<
name|lowest_pdr_addr
condition|)
name|lowest_pdr_addr
operator|=
name|pdr_in
operator|->
name|adr
expr_stmt|;
block|}
name|parse_lines
argument_list|(
name|fh
argument_list|,
name|pr_block
argument_list|,
name|lines
argument_list|,
name|maxlines
argument_list|,
name|pst
argument_list|,
name|lowest_pdr_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|lines
operator|->
name|nitems
operator|<
name|fh
operator|->
name|cline
condition|)
name|lines
operator|=
name|shrink_linetable
argument_list|(
name|lines
argument_list|)
expr_stmt|;
comment|/* Fill in procedure info next.  */
name|pdr_in
operator|=
name|pr_block
expr_stmt|;
name|pdr_in_end
operator|=
name|pdr_in
operator|+
name|fh
operator|->
name|cpd
expr_stmt|;
for|for
control|(
init|;
name|pdr_in
operator|<
name|pdr_in_end
condition|;
name|pdr_in
operator|++
control|)
name|parse_procedure
argument_list|(
name|pdr_in
argument_list|,
literal|0
argument_list|,
name|pst
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
block|}
name|LINETABLE
argument_list|(
name|st
argument_list|)
operator|=
name|lines
expr_stmt|;
comment|/* .. and our share of externals. 	 XXX use the global list to speed up things here. how? 	 FIXME, Maybe quit once we have found the right number of ext's? */
name|top_stack
operator|->
name|cur_st
operator|=
name|st
expr_stmt|;
name|top_stack
operator|->
name|cur_block
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|BLOCKVECTOR
argument_list|(
name|top_stack
operator|->
name|cur_st
argument_list|)
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
expr_stmt|;
name|top_stack
operator|->
name|blocktype
operator|=
name|stFile
expr_stmt|;
name|top_stack
operator|->
name|maxsyms
operator|=
operator|(
name|debug_info
operator|->
name|symbolic_header
operator|.
name|isymMax
operator|+
name|debug_info
operator|->
name|symbolic_header
operator|.
name|ipdMax
operator|+
name|debug_info
operator|->
name|symbolic_header
operator|.
name|iextMax
operator|)
expr_stmt|;
name|ext_ptr
operator|=
name|PST_PRIVATE
argument_list|(
name|pst
argument_list|)
operator|->
name|extern_tab
expr_stmt|;
for|for
control|(
name|i
operator|=
name|PST_PRIVATE
argument_list|(
name|pst
argument_list|)
operator|->
name|extern_count
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|ext_ptr
operator|++
control|)
name|parse_external
argument_list|(
name|ext_ptr
argument_list|,
name|fh
operator|->
name|fBigendian
argument_list|,
name|pst
operator|->
name|section_offsets
argument_list|)
expr_stmt|;
comment|/* If there are undefined symbols, tell the user. 	 The alpha has an undefined symbol for every symbol that is 	 from a shared library, so tell the user only if verbose is on.  */
if|if
condition|(
name|info_verbose
operator|&&
name|n_undef_symbols
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"File %s contains %d unresolved references:"
argument_list|,
name|st
operator|->
name|filename
argument_list|,
name|n_undef_symbols
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n\t%4d variables\n\t%4d procedures\n\t%4d labels\n"
argument_list|,
name|n_undef_vars
argument_list|,
name|n_undef_procs
argument_list|,
name|n_undef_labels
argument_list|)
expr_stmt|;
name|n_undef_symbols
operator|=
name|n_undef_labels
operator|=
name|n_undef_vars
operator|=
name|n_undef_procs
operator|=
literal|0
expr_stmt|;
block|}
name|pop_parse_stack
argument_list|()
expr_stmt|;
name|st
operator|->
name|primary
operator|=
literal|1
expr_stmt|;
comment|/* Sort the symbol table now, we are done adding symbols to it.*/
name|sort_symtab_syms
argument_list|(
name|st
argument_list|)
expr_stmt|;
name|sort_blocks
argument_list|(
name|st
argument_list|)
expr_stmt|;
block|}
comment|/* Now link the psymtab and the symtab.  */
name|pst
operator|->
name|symtab
operator|=
name|st
expr_stmt|;
name|current_objfile
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Ancillary parsing procedures. */
end_comment

begin_comment
comment|/* Return 1 if the symbol pointed to by SH has a cross reference    to an opaque aggregate type, else 0.  */
end_comment

begin_function
specifier|static
name|int
name|has_opaque_xref
parameter_list|(
name|fh
parameter_list|,
name|sh
parameter_list|)
name|FDR
modifier|*
name|fh
decl_stmt|;
name|SYMR
modifier|*
name|sh
decl_stmt|;
block|{
name|TIR
name|tir
decl_stmt|;
name|union
name|aux_ext
modifier|*
name|ax
decl_stmt|;
name|RNDXR
name|rn
index|[
literal|1
index|]
decl_stmt|;
name|unsigned
name|int
name|rf
decl_stmt|;
if|if
condition|(
name|sh
operator|->
name|index
operator|==
name|indexNil
condition|)
return|return
literal|0
return|;
name|ax
operator|=
name|debug_info
operator|->
name|external_aux
operator|+
name|fh
operator|->
name|iauxBase
operator|+
name|sh
operator|->
name|index
expr_stmt|;
call|(
modifier|*
name|debug_swap
operator|->
name|swap_tir_in
call|)
argument_list|(
name|fh
operator|->
name|fBigendian
argument_list|,
operator|&
name|ax
operator|->
name|a_ti
argument_list|,
operator|&
name|tir
argument_list|)
expr_stmt|;
if|if
condition|(
name|tir
operator|.
name|bt
operator|!=
name|btStruct
operator|&&
name|tir
operator|.
name|bt
operator|!=
name|btUnion
operator|&&
name|tir
operator|.
name|bt
operator|!=
name|btEnum
condition|)
return|return
literal|0
return|;
name|ax
operator|++
expr_stmt|;
call|(
modifier|*
name|debug_swap
operator|->
name|swap_rndx_in
call|)
argument_list|(
name|fh
operator|->
name|fBigendian
argument_list|,
operator|&
name|ax
operator|->
name|a_rndx
argument_list|,
name|rn
argument_list|)
expr_stmt|;
if|if
condition|(
name|rn
operator|->
name|rfd
operator|==
literal|0xfff
condition|)
name|rf
operator|=
name|AUX_GET_ISYM
argument_list|(
name|fh
operator|->
name|fBigendian
argument_list|,
name|ax
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|rf
operator|=
name|rn
operator|->
name|rfd
expr_stmt|;
if|if
condition|(
name|rf
operator|!=
operator|-
literal|1
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Lookup the type at relative index RN.  Return it in TPP    if found and in any event come up with its name PNAME.    BIGEND says whether aux symbols are big-endian or not (from fh->fBigendian).    Return value says how many aux symbols we ate. */
end_comment

begin_function
specifier|static
name|int
name|cross_ref
parameter_list|(
name|fd
parameter_list|,
name|ax
parameter_list|,
name|tpp
parameter_list|,
name|type_code
parameter_list|,
name|pname
parameter_list|,
name|bigend
parameter_list|,
name|sym_name
parameter_list|)
name|int
name|fd
decl_stmt|;
name|union
name|aux_ext
modifier|*
name|ax
decl_stmt|;
name|struct
name|type
modifier|*
modifier|*
name|tpp
decl_stmt|;
name|enum
name|type_code
name|type_code
decl_stmt|;
comment|/* Use to alloc new type if none is found. */
name|char
modifier|*
modifier|*
name|pname
decl_stmt|;
name|int
name|bigend
decl_stmt|;
name|char
modifier|*
name|sym_name
decl_stmt|;
block|{
name|RNDXR
name|rn
index|[
literal|1
index|]
decl_stmt|;
name|unsigned
name|int
name|rf
decl_stmt|;
name|int
name|result
init|=
literal|1
decl_stmt|;
name|FDR
modifier|*
name|fh
decl_stmt|;
name|char
modifier|*
name|esh
decl_stmt|;
name|SYMR
name|sh
decl_stmt|;
name|int
name|xref_fd
decl_stmt|;
name|struct
name|mdebug_pending
modifier|*
name|pend
decl_stmt|;
operator|*
name|tpp
operator|=
operator|(
expr|struct
name|type
operator|*
operator|)
name|NULL
expr_stmt|;
call|(
modifier|*
name|debug_swap
operator|->
name|swap_rndx_in
call|)
argument_list|(
name|bigend
argument_list|,
operator|&
name|ax
operator|->
name|a_rndx
argument_list|,
name|rn
argument_list|)
expr_stmt|;
comment|/* Escape index means 'the next one' */
if|if
condition|(
name|rn
operator|->
name|rfd
operator|==
literal|0xfff
condition|)
block|{
name|result
operator|++
expr_stmt|;
name|rf
operator|=
name|AUX_GET_ISYM
argument_list|(
name|bigend
argument_list|,
name|ax
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rf
operator|=
name|rn
operator|->
name|rfd
expr_stmt|;
block|}
comment|/* mips cc uses a rf of -1 for opaque struct definitions.      Set TYPE_FLAG_STUB for these types so that check_typedef will      resolve them if the struct gets defined in another compilation unit.  */
if|if
condition|(
name|rf
operator|==
operator|-
literal|1
condition|)
block|{
operator|*
name|pname
operator|=
literal|"<undefined>"
expr_stmt|;
operator|*
name|tpp
operator|=
name|init_type
argument_list|(
name|type_code
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|current_objfile
argument_list|)
expr_stmt|;
name|TYPE_FLAGS
argument_list|(
operator|*
name|tpp
argument_list|)
operator||=
name|TYPE_FLAG_STUB
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/* mips cc uses an escaped rn->index of 0 for struct return types      of procedures that were compiled without -g. These will always remain      undefined.  */
if|if
condition|(
name|rn
operator|->
name|rfd
operator|==
literal|0xfff
operator|&&
name|rn
operator|->
name|index
operator|==
literal|0
condition|)
block|{
operator|*
name|pname
operator|=
literal|"<undefined>"
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/* Find the relative file descriptor and the symbol in it.  */
name|fh
operator|=
name|get_rfd
argument_list|(
name|fd
argument_list|,
name|rf
argument_list|)
expr_stmt|;
name|xref_fd
operator|=
name|fh
operator|-
name|debug_info
operator|->
name|fdr
expr_stmt|;
if|if
condition|(
name|rn
operator|->
name|index
operator|>=
name|fh
operator|->
name|csym
condition|)
block|{
comment|/* File indirect entry is corrupt.  */
operator|*
name|pname
operator|=
literal|"<illegal>"
expr_stmt|;
name|complain
argument_list|(
operator|&
name|bad_rfd_entry_complaint
argument_list|,
name|sym_name
argument_list|,
name|xref_fd
argument_list|,
name|rn
operator|->
name|index
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/* If we have processed this symbol then we left a forwarding      pointer to the type in the pending list.  If not, we`ll put      it in a list of pending types, to be processed later when      the file will be.  In any event, we collect the name for the      type here.  */
name|esh
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|debug_info
operator|->
name|external_sym
operator|+
operator|(
operator|(
name|fh
operator|->
name|isymBase
operator|+
name|rn
operator|->
name|index
operator|)
operator|*
name|debug_swap
operator|->
name|external_sym_size
operator|)
operator|)
expr_stmt|;
call|(
modifier|*
name|debug_swap
operator|->
name|swap_sym_in
call|)
argument_list|(
name|cur_bfd
argument_list|,
name|esh
argument_list|,
operator|&
name|sh
argument_list|)
expr_stmt|;
comment|/* Make sure that this type of cross reference can be handled.  */
if|if
condition|(
operator|(
name|sh
operator|.
name|sc
operator|!=
name|scInfo
operator|||
operator|(
name|sh
operator|.
name|st
operator|!=
name|stBlock
operator|&&
name|sh
operator|.
name|st
operator|!=
name|stTypedef
operator|&&
name|sh
operator|.
name|st
operator|!=
name|stIndirect
operator|&&
name|sh
operator|.
name|st
operator|!=
name|stStruct
operator|&&
name|sh
operator|.
name|st
operator|!=
name|stUnion
operator|&&
name|sh
operator|.
name|st
operator|!=
name|stEnum
operator|)
operator|)
operator|&&
operator|(
name|sh
operator|.
name|st
operator|!=
name|stBlock
operator|||
operator|!
name|SC_IS_COMMON
argument_list|(
name|sh
operator|.
name|sc
argument_list|)
operator|)
condition|)
block|{
comment|/* File indirect entry is corrupt.  */
operator|*
name|pname
operator|=
literal|"<illegal>"
expr_stmt|;
name|complain
argument_list|(
operator|&
name|bad_rfd_entry_complaint
argument_list|,
name|sym_name
argument_list|,
name|xref_fd
argument_list|,
name|rn
operator|->
name|index
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
operator|*
name|pname
operator|=
name|debug_info
operator|->
name|ss
operator|+
name|fh
operator|->
name|issBase
operator|+
name|sh
operator|.
name|iss
expr_stmt|;
name|pend
operator|=
name|is_pending_symbol
argument_list|(
name|fh
argument_list|,
name|esh
argument_list|)
expr_stmt|;
if|if
condition|(
name|pend
condition|)
operator|*
name|tpp
operator|=
name|pend
operator|->
name|t
expr_stmt|;
else|else
block|{
comment|/* We have not yet seen this type.  */
if|if
condition|(
operator|(
name|sh
operator|.
name|iss
operator|==
literal|0
operator|&&
name|sh
operator|.
name|st
operator|==
name|stTypedef
operator|)
operator|||
name|sh
operator|.
name|st
operator|==
name|stIndirect
condition|)
block|{
name|TIR
name|tir
decl_stmt|;
comment|/* alpha cc puts out a stTypedef with a sh.iss of zero for 	     two cases: 	     a) forward declarations of structs/unions/enums which are not 		defined in this compilation unit. 		For these the type will be void. This is a bad design decision 		as cross referencing across compilation units is impossible 		due to the missing name. 	     b) forward declarations of structs/unions/enums/typedefs which 		are defined later in this file or in another file in the same 		compilation unit. Irix5 cc uses a stIndirect symbol for this. 		Simply cross reference those again to get the true type. 	     The forward references are not entered in the pending list and 	     in the symbol table.  */
call|(
modifier|*
name|debug_swap
operator|->
name|swap_tir_in
call|)
argument_list|(
name|bigend
argument_list|,
operator|&
operator|(
name|debug_info
operator|->
name|external_aux
operator|+
name|fh
operator|->
name|iauxBase
operator|+
name|sh
operator|.
name|index
operator|)
operator|->
name|a_ti
argument_list|,
operator|&
name|tir
argument_list|)
expr_stmt|;
if|if
condition|(
name|tir
operator|.
name|tq0
operator|!=
name|tqNil
condition|)
name|complain
argument_list|(
operator|&
name|illegal_forward_tq0_complaint
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tir
operator|.
name|bt
condition|)
block|{
case|case
name|btVoid
case|:
operator|*
name|tpp
operator|=
name|init_type
argument_list|(
name|type_code
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|current_objfile
argument_list|)
expr_stmt|;
operator|*
name|pname
operator|=
literal|"<undefined>"
expr_stmt|;
break|break;
case|case
name|btStruct
case|:
case|case
name|btUnion
case|:
case|case
name|btEnum
case|:
name|cross_ref
argument_list|(
name|xref_fd
argument_list|,
operator|(
name|debug_info
operator|->
name|external_aux
operator|+
name|fh
operator|->
name|iauxBase
operator|+
name|sh
operator|.
name|index
operator|+
literal|1
operator|)
argument_list|,
name|tpp
argument_list|,
name|type_code
argument_list|,
name|pname
argument_list|,
name|fh
operator|->
name|fBigendian
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|btTypedef
case|:
comment|/* Follow a forward typedef. This might recursively 		 call cross_ref till we get a non typedef'ed type. 		 FIXME: This is not correct behaviour, but gdb currently 		 cannot handle typedefs without type copying. Type 		 copying is impossible as we might have mutual forward 		 references between two files and the copied type would not 		 get filled in when we later parse its definition.  */
operator|*
name|tpp
operator|=
name|parse_type
argument_list|(
name|xref_fd
argument_list|,
name|debug_info
operator|->
name|external_aux
operator|+
name|fh
operator|->
name|iauxBase
argument_list|,
name|sh
operator|.
name|index
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
name|fh
operator|->
name|fBigendian
argument_list|,
name|debug_info
operator|->
name|ss
operator|+
name|fh
operator|->
name|issBase
operator|+
name|sh
operator|.
name|iss
argument_list|)
expr_stmt|;
name|add_pending
argument_list|(
name|fh
argument_list|,
name|esh
argument_list|,
operator|*
name|tpp
argument_list|)
expr_stmt|;
break|break;
default|default:
name|complain
argument_list|(
operator|&
name|illegal_forward_bt_complaint
argument_list|,
name|tir
operator|.
name|bt
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
operator|*
name|tpp
operator|=
name|init_type
argument_list|(
name|type_code
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|current_objfile
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|result
return|;
block|}
elseif|else
if|if
condition|(
name|sh
operator|.
name|st
operator|==
name|stTypedef
condition|)
block|{
comment|/* Parse the type for a normal typedef. This might recursively call 	     cross_ref till we get a non typedef'ed type. 	     FIXME: This is not correct behaviour, but gdb currently 	     cannot handle typedefs without type copying. But type copying is 	     impossible as we might have mutual forward references between 	     two files and the copied type would not get filled in when 	     we later parse its definition.   */
operator|*
name|tpp
operator|=
name|parse_type
argument_list|(
name|xref_fd
argument_list|,
name|debug_info
operator|->
name|external_aux
operator|+
name|fh
operator|->
name|iauxBase
argument_list|,
name|sh
operator|.
name|index
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
name|fh
operator|->
name|fBigendian
argument_list|,
name|debug_info
operator|->
name|ss
operator|+
name|fh
operator|->
name|issBase
operator|+
name|sh
operator|.
name|iss
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Cross reference to a struct/union/enum which is defined 	     in another file in the same compilation unit but that file 	     has not been parsed yet. 	     Initialize the type only, it will be filled in when 	     it's definition is parsed.  */
operator|*
name|tpp
operator|=
name|init_type
argument_list|(
name|type_code
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|current_objfile
argument_list|)
expr_stmt|;
block|}
name|add_pending
argument_list|(
name|fh
argument_list|,
name|esh
argument_list|,
operator|*
name|tpp
argument_list|)
expr_stmt|;
block|}
comment|/* We used one auxent normally, two if we got a "next one" rf. */
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Quick&dirty lookup procedure, to avoid the MI ones that require    keeping the symtab sorted */
end_comment

begin_function
specifier|static
name|struct
name|symbol
modifier|*
name|mylookup_symbol
parameter_list|(
name|name
parameter_list|,
name|block
parameter_list|,
name|namespace
parameter_list|,
name|class
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|struct
name|block
modifier|*
name|block
decl_stmt|;
name|namespace_enum
name|namespace
decl_stmt|;
name|enum
name|address_class
name|class
decl_stmt|;
block|{
specifier|register
name|int
name|bot
decl_stmt|,
name|top
decl_stmt|,
name|inc
decl_stmt|;
specifier|register
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|bot
operator|=
literal|0
expr_stmt|;
name|top
operator|=
name|BLOCK_NSYMS
argument_list|(
name|block
argument_list|)
expr_stmt|;
name|inc
operator|=
name|name
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
name|bot
operator|<
name|top
condition|)
block|{
name|sym
operator|=
name|BLOCK_SYM
argument_list|(
name|block
argument_list|,
name|bot
argument_list|)
expr_stmt|;
if|if
condition|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
index|[
literal|0
index|]
operator|==
name|inc
operator|&&
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|==
name|namespace
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|class
operator|&&
name|strcmp
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|sym
return|;
name|bot
operator|++
expr_stmt|;
block|}
name|block
operator|=
name|BLOCK_SUPERBLOCK
argument_list|(
name|block
argument_list|)
expr_stmt|;
if|if
condition|(
name|block
condition|)
return|return
name|mylookup_symbol
argument_list|(
name|name
argument_list|,
name|block
argument_list|,
name|namespace
argument_list|,
name|class
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Add a new symbol S to a block B.    Infrequently, we will need to reallocate the block to make it bigger.    We only detect this case when adding to top_stack->cur_block, since    that's the only time we know how big the block is.  FIXME.  */
end_comment

begin_function
specifier|static
name|void
name|add_symbol
parameter_list|(
name|s
parameter_list|,
name|b
parameter_list|)
name|struct
name|symbol
modifier|*
name|s
decl_stmt|;
name|struct
name|block
modifier|*
name|b
decl_stmt|;
block|{
name|int
name|nsyms
init|=
name|BLOCK_NSYMS
argument_list|(
name|b
argument_list|)
operator|++
decl_stmt|;
name|struct
name|block
modifier|*
name|origb
decl_stmt|;
name|struct
name|parse_stack
modifier|*
name|stackp
decl_stmt|;
if|if
condition|(
name|b
operator|==
name|top_stack
operator|->
name|cur_block
operator|&&
name|nsyms
operator|>=
name|top_stack
operator|->
name|maxsyms
condition|)
block|{
name|complain
argument_list|(
operator|&
name|block_overflow_complaint
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
comment|/* In this case shrink_block is actually grow_block, since 		   BLOCK_NSYMS(b) is larger than its current size.  */
name|origb
operator|=
name|b
expr_stmt|;
name|b
operator|=
name|shrink_block
argument_list|(
name|top_stack
operator|->
name|cur_block
argument_list|,
name|top_stack
operator|->
name|cur_st
argument_list|)
expr_stmt|;
comment|/* Now run through the stack replacing pointers to the 	 original block.  shrink_block has already done this 	 for the blockvector and BLOCK_FUNCTION.  */
for|for
control|(
name|stackp
operator|=
name|top_stack
init|;
name|stackp
condition|;
name|stackp
operator|=
name|stackp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|stackp
operator|->
name|cur_block
operator|==
name|origb
condition|)
block|{
name|stackp
operator|->
name|cur_block
operator|=
name|b
expr_stmt|;
name|stackp
operator|->
name|maxsyms
operator|=
name|BLOCK_NSYMS
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|BLOCK_SYM
argument_list|(
name|b
argument_list|,
name|nsyms
argument_list|)
operator|=
name|s
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a new block B to a symtab S */
end_comment

begin_function
specifier|static
name|void
name|add_block
parameter_list|(
name|b
parameter_list|,
name|s
parameter_list|)
name|struct
name|block
modifier|*
name|b
decl_stmt|;
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
block|{
name|struct
name|blockvector
modifier|*
name|bv
init|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|bv
operator|=
operator|(
expr|struct
name|blockvector
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|PTR
operator|)
name|bv
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|blockvector
argument_list|)
operator|+
name|BLOCKVECTOR_NBLOCKS
argument_list|(
name|bv
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|bv
operator|->
name|block
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bv
operator|!=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
condition|)
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
operator|=
name|bv
expr_stmt|;
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|BLOCKVECTOR_NBLOCKS
argument_list|(
name|bv
argument_list|)
operator|++
argument_list|)
operator|=
name|b
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a new linenumber entry (LINENO,ADR) to a linevector LT.    MIPS' linenumber encoding might need more than one byte    to describe it, LAST is used to detect these continuation lines.     Combining lines with the same line number seems like a bad idea.    E.g: There could be a line number entry with the same line number after the    prologue and GDB should not ignore it (this is a better way to find    a prologue than mips_skip_prologue).    But due to the compressed line table format there are line number entries    for the same line which are needed to bridge the gap to the next    line number entry. These entries have a bogus address info with them    and we are unable to tell them from intended duplicate line number    entries.    This is another reason why -ggdb debugging format is preferable.  */
end_comment

begin_function
specifier|static
name|int
name|add_line
parameter_list|(
name|lt
parameter_list|,
name|lineno
parameter_list|,
name|adr
parameter_list|,
name|last
parameter_list|)
name|struct
name|linetable
modifier|*
name|lt
decl_stmt|;
name|int
name|lineno
decl_stmt|;
name|CORE_ADDR
name|adr
decl_stmt|;
name|int
name|last
decl_stmt|;
block|{
comment|/* DEC c89 sometimes produces zero linenos which confuse gdb.      Change them to something sensible. */
if|if
condition|(
name|lineno
operator|==
literal|0
condition|)
name|lineno
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|last
operator|==
literal|0
condition|)
name|last
operator|=
operator|-
literal|2
expr_stmt|;
comment|/* make sure we record first line */
if|if
condition|(
name|last
operator|==
name|lineno
condition|)
comment|/* skip continuation lines */
return|return
name|lineno
return|;
name|lt
operator|->
name|item
index|[
name|lt
operator|->
name|nitems
index|]
operator|.
name|line
operator|=
name|lineno
expr_stmt|;
name|lt
operator|->
name|item
index|[
name|lt
operator|->
name|nitems
operator|++
index|]
operator|.
name|pc
operator|=
name|adr
operator|<<
literal|2
expr_stmt|;
return|return
name|lineno
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Sorting and reordering procedures */
end_comment

begin_comment
comment|/* Blocks with a smaller low bound should come first */
end_comment

begin_function
specifier|static
name|int
name|compare_blocks
parameter_list|(
name|arg1
parameter_list|,
name|arg2
parameter_list|)
specifier|const
name|PTR
name|arg1
decl_stmt|;
specifier|const
name|PTR
name|arg2
decl_stmt|;
block|{
specifier|register
name|int
name|addr_diff
decl_stmt|;
name|struct
name|block
modifier|*
modifier|*
name|b1
init|=
operator|(
expr|struct
name|block
operator|*
operator|*
operator|)
name|arg1
decl_stmt|;
name|struct
name|block
modifier|*
modifier|*
name|b2
init|=
operator|(
expr|struct
name|block
operator|*
operator|*
operator|)
name|arg2
decl_stmt|;
name|addr_diff
operator|=
operator|(
name|BLOCK_START
argument_list|(
operator|(
operator|*
name|b1
operator|)
argument_list|)
operator|)
operator|-
operator|(
name|BLOCK_START
argument_list|(
operator|(
operator|*
name|b2
operator|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|addr_diff
operator|==
literal|0
condition|)
return|return
operator|(
name|BLOCK_END
argument_list|(
operator|(
operator|*
name|b2
operator|)
argument_list|)
operator|)
operator|-
operator|(
name|BLOCK_END
argument_list|(
operator|(
operator|*
name|b1
operator|)
argument_list|)
operator|)
return|;
return|return
name|addr_diff
return|;
block|}
end_function

begin_comment
comment|/* Sort the blocks of a symtab S.    Reorder the blocks in the blockvector by code-address,    as required by some MI search routines */
end_comment

begin_function
specifier|static
name|void
name|sort_blocks
parameter_list|(
name|s
parameter_list|)
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
block|{
name|struct
name|blockvector
modifier|*
name|bv
init|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|BLOCKVECTOR_NBLOCKS
argument_list|(
name|bv
argument_list|)
operator|<=
literal|2
condition|)
block|{
comment|/* Cosmetic */
if|if
condition|(
name|BLOCK_END
argument_list|(
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|BLOCK_START
argument_list|(
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|BLOCK_END
argument_list|(
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|STATIC_BLOCK
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|BLOCK_START
argument_list|(
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|STATIC_BLOCK
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/*    * This is very unfortunate: normally all functions are compiled in    * the order they are found, but if the file is compiled -O3 things    * are very different.  It would be nice to find a reliable test    * to detect -O3 images in advance.    */
if|if
condition|(
name|BLOCKVECTOR_NBLOCKS
argument_list|(
name|bv
argument_list|)
operator|>
literal|3
condition|)
name|qsort
argument_list|(
operator|&
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|FIRST_LOCAL_BLOCK
argument_list|)
argument_list|,
name|BLOCKVECTOR_NBLOCKS
argument_list|(
name|bv
argument_list|)
operator|-
name|FIRST_LOCAL_BLOCK
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|block
operator|*
argument_list|)
argument_list|,
name|compare_blocks
argument_list|)
expr_stmt|;
block|{
specifier|register
name|CORE_ADDR
name|high
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
init|=
name|BLOCKVECTOR_NBLOCKS
argument_list|(
name|bv
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
name|FIRST_LOCAL_BLOCK
init|;
name|i
operator|<
name|j
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|high
operator|<
name|BLOCK_END
argument_list|(
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
name|high
operator|=
name|BLOCK_END
argument_list|(
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|BLOCK_END
argument_list|(
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
argument_list|)
operator|=
name|high
expr_stmt|;
block|}
name|BLOCK_START
argument_list|(
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
argument_list|)
operator|=
name|BLOCK_START
argument_list|(
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|FIRST_LOCAL_BLOCK
argument_list|)
argument_list|)
expr_stmt|;
name|BLOCK_START
argument_list|(
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|STATIC_BLOCK
argument_list|)
argument_list|)
operator|=
name|BLOCK_START
argument_list|(
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
argument_list|)
expr_stmt|;
name|BLOCK_END
argument_list|(
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|STATIC_BLOCK
argument_list|)
argument_list|)
operator|=
name|BLOCK_END
argument_list|(
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Constructor/restructor/destructor procedures */
end_comment

begin_comment
comment|/* Allocate a new symtab for NAME.  Needs an estimate of how many symbols    MAXSYMS and linenumbers MAXLINES we'll put in it */
end_comment

begin_function
specifier|static
name|struct
name|symtab
modifier|*
name|new_symtab
parameter_list|(
name|name
parameter_list|,
name|maxsyms
parameter_list|,
name|maxlines
parameter_list|,
name|objfile
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|maxsyms
decl_stmt|;
name|int
name|maxlines
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|struct
name|symtab
modifier|*
name|s
init|=
name|allocate_symtab
argument_list|(
name|name
argument_list|,
name|objfile
argument_list|)
decl_stmt|;
name|LINETABLE
argument_list|(
name|s
argument_list|)
operator|=
name|new_linetable
argument_list|(
name|maxlines
argument_list|)
expr_stmt|;
comment|/* All symtabs must have at least two blocks */
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
operator|=
name|new_bvect
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|BLOCKVECTOR_BLOCK
argument_list|(
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
operator|=
name|new_block
argument_list|(
name|maxsyms
argument_list|)
expr_stmt|;
name|BLOCKVECTOR_BLOCK
argument_list|(
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
argument_list|,
name|STATIC_BLOCK
argument_list|)
operator|=
name|new_block
argument_list|(
name|maxsyms
argument_list|)
expr_stmt|;
name|BLOCK_SUPERBLOCK
argument_list|(
name|BLOCKVECTOR_BLOCK
argument_list|(
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
argument_list|,
name|STATIC_BLOCK
argument_list|)
argument_list|)
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
expr_stmt|;
name|s
operator|->
name|free_code
operator|=
name|free_linetable
expr_stmt|;
name|s
operator|->
name|debugformat
operator|=
name|obsavestring
argument_list|(
literal|"ECOFF"
argument_list|,
literal|5
argument_list|,
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|)
expr_stmt|;
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Allocate a new partial_symtab NAME */
end_comment

begin_function
specifier|static
name|struct
name|partial_symtab
modifier|*
name|new_psymtab
parameter_list|(
name|name
parameter_list|,
name|objfile
parameter_list|,
name|section_offsets
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|section_offsets
modifier|*
name|section_offsets
decl_stmt|;
block|{
name|struct
name|partial_symtab
modifier|*
name|psymtab
decl_stmt|;
name|psymtab
operator|=
name|allocate_psymtab
argument_list|(
name|name
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|psymtab
operator|->
name|section_offsets
operator|=
name|section_offsets
expr_stmt|;
comment|/* Keep a backpointer to the file's symbols */
name|psymtab
operator|->
name|read_symtab_private
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|psymbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symloc
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|PTR
operator|)
name|psymtab
operator|->
name|read_symtab_private
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symloc
argument_list|)
argument_list|)
expr_stmt|;
name|CUR_BFD
argument_list|(
name|psymtab
argument_list|)
operator|=
name|cur_bfd
expr_stmt|;
name|DEBUG_SWAP
argument_list|(
name|psymtab
argument_list|)
operator|=
name|debug_swap
expr_stmt|;
name|DEBUG_INFO
argument_list|(
name|psymtab
argument_list|)
operator|=
name|debug_info
expr_stmt|;
name|PENDING_LIST
argument_list|(
name|psymtab
argument_list|)
operator|=
name|pending_list
expr_stmt|;
comment|/* The way to turn this into a symtab is to call... */
name|psymtab
operator|->
name|read_symtab
operator|=
name|mdebug_psymtab_to_symtab
expr_stmt|;
return|return
operator|(
name|psymtab
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Allocate a linetable array of the given SIZE.  Since the struct    already includes one item, we subtract one when calculating the    proper size to allocate.  */
end_comment

begin_function
specifier|static
name|struct
name|linetable
modifier|*
name|new_linetable
parameter_list|(
name|size
parameter_list|)
name|int
name|size
decl_stmt|;
block|{
name|struct
name|linetable
modifier|*
name|l
decl_stmt|;
name|size
operator|=
operator|(
name|size
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|l
operator|->
name|item
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|linetable
argument_list|)
expr_stmt|;
name|l
operator|=
operator|(
expr|struct
name|linetable
operator|*
operator|)
name|xmalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|l
operator|->
name|nitems
operator|=
literal|0
expr_stmt|;
return|return
name|l
return|;
block|}
end_function

begin_comment
comment|/* Oops, too big. Shrink it.  This was important with the 2.4 linetables,    I am not so sure about the 3.4 ones.     Since the struct linetable already includes one item, we subtract one when    calculating the proper size to allocate.  */
end_comment

begin_function
specifier|static
name|struct
name|linetable
modifier|*
name|shrink_linetable
parameter_list|(
name|lt
parameter_list|)
name|struct
name|linetable
modifier|*
name|lt
decl_stmt|;
block|{
return|return
operator|(
expr|struct
name|linetable
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|PTR
operator|)
name|lt
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|linetable
argument_list|)
operator|+
operator|(
operator|(
name|lt
operator|->
name|nitems
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|lt
operator|->
name|item
argument_list|)
operator|)
operator|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Allocate and zero a new blockvector of NBLOCKS blocks. */
end_comment

begin_function
specifier|static
name|struct
name|blockvector
modifier|*
name|new_bvect
parameter_list|(
name|nblocks
parameter_list|)
name|int
name|nblocks
decl_stmt|;
block|{
name|struct
name|blockvector
modifier|*
name|bv
decl_stmt|;
name|int
name|size
decl_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|blockvector
argument_list|)
operator|+
name|nblocks
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|block
operator|*
argument_list|)
expr_stmt|;
name|bv
operator|=
operator|(
expr|struct
name|blockvector
operator|*
operator|)
name|xzalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|BLOCKVECTOR_NBLOCKS
argument_list|(
name|bv
argument_list|)
operator|=
name|nblocks
expr_stmt|;
return|return
name|bv
return|;
block|}
end_function

begin_comment
comment|/* Allocate and zero a new block of MAXSYMS symbols */
end_comment

begin_function
specifier|static
name|struct
name|block
modifier|*
name|new_block
parameter_list|(
name|maxsyms
parameter_list|)
name|int
name|maxsyms
decl_stmt|;
block|{
name|int
name|size
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|block
argument_list|)
operator|+
operator|(
name|maxsyms
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
operator|*
argument_list|)
decl_stmt|;
return|return
operator|(
expr|struct
name|block
operator|*
operator|)
name|xzalloc
argument_list|(
name|size
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Ooops, too big. Shrink block B in symtab S to its minimal size.    Shrink_block can also be used by add_symbol to grow a block.  */
end_comment

begin_function
specifier|static
name|struct
name|block
modifier|*
name|shrink_block
parameter_list|(
name|b
parameter_list|,
name|s
parameter_list|)
name|struct
name|block
modifier|*
name|b
decl_stmt|;
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
block|{
name|struct
name|block
modifier|*
name|new
decl_stmt|;
name|struct
name|blockvector
modifier|*
name|bv
init|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Just reallocate it and fix references to the old one */
name|new
operator|=
operator|(
expr|struct
name|block
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|PTR
operator|)
name|b
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|block
argument_list|)
operator|+
operator|(
operator|(
name|BLOCK_NSYMS
argument_list|(
name|b
argument_list|)
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
operator|*
argument_list|)
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Should chase pointers to old one.  Fortunately, that`s just 	   the block`s function and inferior blocks */
if|if
condition|(
name|BLOCK_FUNCTION
argument_list|(
name|new
argument_list|)
operator|&&
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|BLOCK_FUNCTION
argument_list|(
name|new
argument_list|)
argument_list|)
operator|==
name|b
condition|)
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|BLOCK_FUNCTION
argument_list|(
name|new
argument_list|)
argument_list|)
operator|=
name|new
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BLOCKVECTOR_NBLOCKS
argument_list|(
name|bv
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|i
argument_list|)
operator|==
name|b
condition|)
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|i
argument_list|)
operator|=
name|new
expr_stmt|;
elseif|else
if|if
condition|(
name|BLOCK_SUPERBLOCK
argument_list|(
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|b
condition|)
name|BLOCK_SUPERBLOCK
argument_list|(
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|i
argument_list|)
argument_list|)
operator|=
name|new
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_comment
comment|/* Create a new symbol with printname NAME */
end_comment

begin_function
specifier|static
name|struct
name|symbol
modifier|*
name|new_symbol
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|symbol
modifier|*
name|s
init|=
operator|(
operator|(
expr|struct
name|symbol
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|current_objfile
operator|->
name|symbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
operator|)
decl_stmt|;
name|memset
argument_list|(
operator|(
name|PTR
operator|)
name|s
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|SYMBOL_NAME
argument_list|(
name|s
argument_list|)
operator|=
name|obsavestring
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
operator|&
name|current_objfile
operator|->
name|symbol_obstack
argument_list|)
expr_stmt|;
name|SYMBOL_LANGUAGE
argument_list|(
name|s
argument_list|)
operator|=
name|psymtab_language
expr_stmt|;
name|SYMBOL_INIT_DEMANGLED_NAME
argument_list|(
name|s
argument_list|,
operator|&
name|current_objfile
operator|->
name|symbol_obstack
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* Create a new type with printname NAME */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|new_type
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|type
modifier|*
name|t
decl_stmt|;
name|t
operator|=
name|alloc_type
argument_list|(
name|current_objfile
argument_list|)
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
operator|=
name|name
expr_stmt|;
name|TYPE_CPLUS_SPECIFIC
argument_list|(
name|t
argument_list|)
operator|=
operator|(
expr|struct
name|cplus_struct_type
operator|*
operator|)
operator|&
name|cplus_struct_default
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read ECOFF debugging information from a BFD section.  This is    called from elfread.c.  It parses the section into a    ecoff_debug_info struct, and then lets the rest of the file handle    it as normal.  */
end_comment

begin_function
name|void
name|elfmdebug_build_psymtabs
parameter_list|(
name|objfile
parameter_list|,
name|swap
parameter_list|,
name|sec
parameter_list|,
name|section_offsets
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
name|swap
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|section_offsets
modifier|*
name|section_offsets
decl_stmt|;
block|{
name|bfd
modifier|*
name|abfd
init|=
name|objfile
operator|->
name|obfd
decl_stmt|;
name|struct
name|ecoff_debug_info
modifier|*
name|info
decl_stmt|;
name|info
operator|=
operator|(
operator|(
expr|struct
name|ecoff_debug_info
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|psymbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ecoff_debug_info
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|swap
operator|->
name|read_debug_info
call|)
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|info
argument_list|)
condition|)
name|error
argument_list|(
literal|"Error reading ECOFF debugging information: %s"
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|mdebug_build_psymtabs
argument_list|(
name|objfile
argument_list|,
name|swap
argument_list|,
name|info
argument_list|,
name|section_offsets
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Things used for calling functions in the inferior.    These functions are exported to our companion    mips-tdep.c file and are here because they play    with the symbol-table explicitly. */
end_comment

begin_comment
comment|/* Sigtramp: make sure we have all the necessary information    about the signal trampoline code. Since the official code    from MIPS does not do so, we make up that information ourselves.    If they fix the library (unlikely) this code will neutralize itself. */
end_comment

begin_comment
comment|/* FIXME: This function is called only by mips-tdep.c.  It needs to be    here because it calls functions defined in this file, but perhaps    this could be handled in a better way.  Only compile it in when    tm-mips.h is included. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TM_MIPS_H
end_ifdef

begin_function
name|void
name|fixup_sigtramp
parameter_list|()
block|{
name|struct
name|symbol
modifier|*
name|s
decl_stmt|;
name|struct
name|symtab
modifier|*
name|st
decl_stmt|;
name|struct
name|block
modifier|*
name|b
decl_stmt|,
modifier|*
name|b0
init|=
name|NULL
decl_stmt|;
name|sigtramp_address
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* We have to handle the following cases here:      a) The Mips library has a sigtramp label within sigvec.      b) Irix has a _sigtramp which we want to use, but it also has sigvec.  */
name|s
operator|=
name|lookup_symbol
argument_list|(
literal|"sigvec"
argument_list|,
literal|0
argument_list|,
name|VAR_NAMESPACE
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
literal|0
condition|)
block|{
name|b0
operator|=
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|lookup_symbol
argument_list|(
literal|"sigtramp"
argument_list|,
name|b0
argument_list|,
name|VAR_NAMESPACE
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|==
literal|0
condition|)
block|{
comment|/* No sigvec or no sigtramp inside sigvec, try _sigtramp.  */
name|s
operator|=
name|lookup_symbol
argument_list|(
literal|"_sigtramp"
argument_list|,
literal|0
argument_list|,
name|VAR_NAMESPACE
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* But maybe this program uses its own version of sigvec */
if|if
condition|(
name|s
operator|==
literal|0
condition|)
return|return;
comment|/* Did we or MIPSco fix the library ? */
if|if
condition|(
name|SYMBOL_CLASS
argument_list|(
name|s
argument_list|)
operator|==
name|LOC_BLOCK
condition|)
block|{
name|sigtramp_address
operator|=
name|BLOCK_START
argument_list|(
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|sigtramp_end
operator|=
name|BLOCK_END
argument_list|(
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|sigtramp_address
operator|=
name|SYMBOL_VALUE
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|sigtramp_end
operator|=
name|sigtramp_address
operator|+
literal|0x88
expr_stmt|;
comment|/* black magic */
comment|/* But what symtab does it live in ? */
name|st
operator|=
name|find_pc_symtab
argument_list|(
name|SYMBOL_VALUE
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
comment|/*    * Ok, there goes the fix: turn it into a procedure, with all the    * needed info.  Note we make it a nested procedure of sigvec,    * which is the way the (assembly) code is actually written.    */
name|SYMBOL_NAMESPACE
argument_list|(
name|s
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|s
argument_list|)
operator|=
name|LOC_BLOCK
expr_stmt|;
name|SYMBOL_TYPE
argument_list|(
name|s
argument_list|)
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FUNC
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|st
operator|->
name|objfile
argument_list|)
expr_stmt|;
name|TYPE_TARGET_TYPE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|s
argument_list|)
argument_list|)
operator|=
name|mdebug_type_void
expr_stmt|;
comment|/* Need a block to allocate MIPS_EFI_SYMBOL_NAME in */
name|b
operator|=
name|new_block
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|s
argument_list|)
operator|=
name|b
expr_stmt|;
name|BLOCK_START
argument_list|(
name|b
argument_list|)
operator|=
name|sigtramp_address
expr_stmt|;
name|BLOCK_END
argument_list|(
name|b
argument_list|)
operator|=
name|sigtramp_end
expr_stmt|;
name|BLOCK_FUNCTION
argument_list|(
name|b
argument_list|)
operator|=
name|s
expr_stmt|;
name|BLOCK_SUPERBLOCK
argument_list|(
name|b
argument_list|)
operator|=
name|BLOCK_SUPERBLOCK
argument_list|(
name|b0
argument_list|)
expr_stmt|;
name|add_block
argument_list|(
name|b
argument_list|,
name|st
argument_list|)
expr_stmt|;
name|sort_blocks
argument_list|(
name|st
argument_list|)
expr_stmt|;
comment|/* Make a MIPS_EFI_SYMBOL_NAME entry for it */
block|{
name|struct
name|mips_extra_func_info
modifier|*
name|e
init|=
operator|(
operator|(
expr|struct
name|mips_extra_func_info
operator|*
operator|)
name|xzalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mips_extra_func_info
argument_list|)
argument_list|)
operator|)
decl_stmt|;
name|e
operator|->
name|numargs
operator|=
literal|0
expr_stmt|;
comment|/* the kernel thinks otherwise */
name|e
operator|->
name|pdr
operator|.
name|frameoffset
operator|=
literal|32
expr_stmt|;
name|e
operator|->
name|pdr
operator|.
name|framereg
operator|=
name|SP_REGNUM
expr_stmt|;
comment|/* Note that setting pcreg is no longer strictly necessary as        mips_frame_saved_pc is now aware of signal handler frames.  */
name|e
operator|->
name|pdr
operator|.
name|pcreg
operator|=
name|PC_REGNUM
expr_stmt|;
name|e
operator|->
name|pdr
operator|.
name|regmask
operator|=
operator|-
literal|2
expr_stmt|;
comment|/* Offset to saved r31, in the sigtramp case the saved registers        are above the frame in the sigcontext.        We have 4 alignment bytes, 12 bytes for onstack, mask and pc,        32 * 4 bytes for the general registers, 12 bytes for mdhi, mdlo, ownedfp        and 32 * 4 bytes for the floating point registers.  */
name|e
operator|->
name|pdr
operator|.
name|regoffset
operator|=
literal|4
operator|+
literal|12
operator|+
literal|31
operator|*
literal|4
expr_stmt|;
name|e
operator|->
name|pdr
operator|.
name|fregmask
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Offset to saved f30 (first saved *double* register).  */
name|e
operator|->
name|pdr
operator|.
name|fregoffset
operator|=
literal|4
operator|+
literal|12
operator|+
literal|32
operator|*
literal|4
operator|+
literal|12
operator|+
literal|30
operator|*
literal|4
expr_stmt|;
name|e
operator|->
name|pdr
operator|.
name|isym
operator|=
operator|(
name|long
operator|)
name|s
expr_stmt|;
name|e
operator|->
name|pdr
operator|.
name|adr
operator|=
name|sigtramp_address
expr_stmt|;
name|current_objfile
operator|=
name|st
operator|->
name|objfile
expr_stmt|;
comment|/* Keep new_symbol happy */
name|s
operator|=
name|new_symbol
argument_list|(
name|MIPS_EFI_SYMBOL_NAME
argument_list|)
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|s
argument_list|)
operator|=
operator|(
name|long
operator|)
name|e
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|s
argument_list|)
operator|=
name|LABEL_NAMESPACE
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|s
argument_list|)
operator|=
name|LOC_CONST
expr_stmt|;
name|SYMBOL_TYPE
argument_list|(
name|s
argument_list|)
operator|=
name|mdebug_type_void
expr_stmt|;
name|current_objfile
operator|=
name|NULL
expr_stmt|;
block|}
name|BLOCK_SYM
argument_list|(
name|b
argument_list|,
name|BLOCK_NSYMS
argument_list|(
name|b
argument_list|)
operator|++
argument_list|)
operator|=
name|s
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TM_MIPS_H */
end_comment

begin_function
name|void
name|_initialize_mdebugread
parameter_list|()
block|{
name|mdebug_type_void
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_VOID
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"void"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|mdebug_type_char
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"char"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|mdebug_type_unsigned_char
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|1
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"unsigned char"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|mdebug_type_short
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"short"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|mdebug_type_unsigned_short
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|2
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"unsigned short"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|mdebug_type_int_32
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
literal|"int"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|mdebug_type_unsigned_int_32
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|4
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"unsigned int"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|mdebug_type_int_64
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|8
argument_list|,
literal|0
argument_list|,
literal|"int"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|mdebug_type_unsigned_int_64
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|8
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"unsigned int"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|mdebug_type_long_32
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
literal|"long"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|mdebug_type_unsigned_long_32
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|4
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"unsigned long"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|mdebug_type_long_64
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|8
argument_list|,
literal|0
argument_list|,
literal|"long"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|mdebug_type_unsigned_long_64
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|8
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"unsigned long"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|mdebug_type_long_long_64
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|8
argument_list|,
literal|0
argument_list|,
literal|"long long"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|mdebug_type_unsigned_long_long_64
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|8
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"unsigned long long"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|mdebug_type_adr_32
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_PTR
argument_list|,
literal|4
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"adr_32"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|TYPE_TARGET_TYPE
argument_list|(
name|mdebug_type_adr_32
argument_list|)
operator|=
name|mdebug_type_void
expr_stmt|;
name|mdebug_type_adr_64
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_PTR
argument_list|,
literal|8
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"adr_64"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|TYPE_TARGET_TYPE
argument_list|(
name|mdebug_type_adr_64
argument_list|)
operator|=
name|mdebug_type_void
expr_stmt|;
name|mdebug_type_float
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
name|TARGET_FLOAT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"float"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|mdebug_type_double
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
name|TARGET_DOUBLE_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"double"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|mdebug_type_complex
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_COMPLEX
argument_list|,
literal|2
operator|*
name|TARGET_FLOAT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"complex"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|TYPE_TARGET_TYPE
argument_list|(
name|mdebug_type_complex
argument_list|)
operator|=
name|mdebug_type_float
expr_stmt|;
name|mdebug_type_double_complex
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_COMPLEX
argument_list|,
literal|2
operator|*
name|TARGET_DOUBLE_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"double complex"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|TYPE_TARGET_TYPE
argument_list|(
name|mdebug_type_double_complex
argument_list|)
operator|=
name|mdebug_type_double
expr_stmt|;
comment|/* Is a "string" the way btString means it the same as TYPE_CODE_STRING?      FIXME.  */
name|mdebug_type_string
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_STRING
argument_list|,
name|TARGET_CHAR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"string"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/* We use TYPE_CODE_INT to print these as integers.  Does this do any      good?  Would we be better off with TYPE_CODE_ERROR?  Should      TYPE_CODE_ERROR print things in hex if it knows the size?  */
name|mdebug_type_fixed_dec
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_INT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"fixed decimal"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|mdebug_type_float_dec
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_ERROR
argument_list|,
name|TARGET_DOUBLE_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"floating decimal"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|nodebug_func_symbol_type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FUNC
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"<function, no debug info>"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|TYPE_TARGET_TYPE
argument_list|(
name|nodebug_func_symbol_type
argument_list|)
operator|=
name|mdebug_type_int
expr_stmt|;
name|nodebug_var_symbol_type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_INT_BIT
operator|/
name|HOST_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"<variable, no debug info>"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

