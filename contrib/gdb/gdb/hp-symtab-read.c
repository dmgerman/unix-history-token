begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Read hp debug symbols and convert to internal format, for GDB.    Copyright 1993, 1996 Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.     Written by the Center for Software Science at the University of Utah    and by Cygnus Support.  */
end_comment

begin_comment
comment|/* Common include for hp-symtab-read.c and hp-psymtab-read.c.  * Note this has nested includes for a bunch of stuff.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"hpread.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_include
include|#
directive|include
file|"complaints.h"
end_include

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|struct
name|complaint
name|hpread_unhandled_end_common_complaint
init|=
block|{
literal|"unhandled symbol in hp-symtab-read.c: DNTT_TYPE_COMMON/DNTT_TYPE_END.\n"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|complaint
name|hpread_unhandled_type_complaint
init|=
block|{
literal|"hpread_type_translate: unhandled type code."
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|complaint
name|hpread_struct_complaint
init|=
block|{
literal|"hpread_read_struct_type: expected SVAR type..."
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|complaint
name|hpread_array_complaint
init|=
block|{
literal|"error in hpread_array_type."
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|complaint
name|hpread_type_lookup_complaint
init|=
block|{
literal|"error in hpread_type_lookup()."
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|complaint
name|hpread_unexpected_end_complaint
init|=
block|{
literal|"internal error in hp-symtab-read.c: Unexpected DNTT_TYPE_END kind."
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|complaint
name|hpread_tagdef_complaint
init|=
block|{
literal|"error processing class tagdef"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|complaint
name|hpread_unhandled_common_complaint
init|=
block|{
literal|"unhandled symbol in hp-symtab-read.c: DNTT_TYPE_COMMON."
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|complaint
name|hpread_unhandled_blockdata_complaint
init|=
block|{
literal|"unhandled symbol in hp-symtab-read.c: DNTT_TYPE_BLOCKDATA."
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward procedure declarations */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|hpread_get_scope_start
name|PARAMS
argument_list|(
operator|(
name|sltpointer
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|hpread_get_line
name|PARAMS
argument_list|(
operator|(
name|sltpointer
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|hpread_get_location
name|PARAMS
argument_list|(
operator|(
name|sltpointer
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|hpread_psymtab_to_symtab_1
name|PARAMS
argument_list|(
operator|(
expr|struct
name|partial_symtab
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|hpread_psymtab_to_symtab
name|PARAMS
argument_list|(
operator|(
expr|struct
name|partial_symtab
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|symtab
modifier|*
name|hpread_expand_symtab
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|CORE_ADDR
operator|,
name|int
operator|,
expr|struct
name|section_offsets
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hpread_type_translate
name|PARAMS
argument_list|(
operator|(
name|dnttpointer
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
modifier|*
name|hpread_lookup_type
name|PARAMS
argument_list|(
operator|(
name|dnttpointer
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|hpread_alloc_type
name|PARAMS
argument_list|(
operator|(
name|dnttpointer
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|hpread_read_enum_type
name|PARAMS
argument_list|(
operator|(
name|dnttpointer
operator|,
expr|union
name|dnttentry
operator|*
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|hpread_read_function_type
name|PARAMS
argument_list|(
operator|(
name|dnttpointer
operator|,
expr|union
name|dnttentry
operator|*
operator|,
expr|struct
name|objfile
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|hpread_read_doc_function_type
name|PARAMS
argument_list|(
operator|(
name|dnttpointer
operator|,
expr|union
name|dnttentry
operator|*
operator|,
expr|struct
name|objfile
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|hpread_read_struct_type
name|PARAMS
argument_list|(
operator|(
name|dnttpointer
operator|,
expr|union
name|dnttentry
operator|*
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|hpread_get_nth_template_arg
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|hpread_read_templ_arg_type
name|PARAMS
argument_list|(
operator|(
name|dnttpointer
operator|,
expr|union
name|dnttentry
operator|*
operator|,
expr|struct
name|objfile
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|hpread_read_set_type
name|PARAMS
argument_list|(
operator|(
name|dnttpointer
operator|,
expr|union
name|dnttentry
operator|*
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|hpread_read_array_type
name|PARAMS
argument_list|(
operator|(
name|dnttpointer
operator|,
expr|union
name|dnttentry
operator|*
name|dn_bufp
operator|,
expr|struct
name|objfile
operator|*
name|objfile
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|hpread_read_subrange_type
name|PARAMS
argument_list|(
operator|(
name|dnttpointer
operator|,
expr|union
name|dnttentry
operator|*
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|hpread_type_lookup
name|PARAMS
argument_list|(
operator|(
name|dnttpointer
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|sltpointer
name|hpread_record_lines
name|PARAMS
argument_list|(
operator|(
expr|struct
name|subfile
operator|*
operator|,
name|sltpointer
operator|,
name|sltpointer
operator|,
expr|struct
name|objfile
operator|*
operator|,
name|CORE_ADDR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|hpread_process_one_debug_symbol
name|PARAMS
argument_list|(
operator|(
expr|union
name|dnttentry
operator|*
operator|,
name|char
operator|*
operator|,
expr|struct
name|section_offsets
operator|*
operator|,
expr|struct
name|objfile
operator|*
operator|,
name|CORE_ADDR
operator|,
name|int
operator|,
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hpread_get_scope_depth
name|PARAMS
argument_list|(
operator|(
expr|union
name|dnttentry
operator|*
operator|,
expr|struct
name|objfile
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fix_static_member_physnames
name|PARAMS
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|,
name|char
operator|*
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fixup_class_method_type
name|PARAMS
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|,
expr|struct
name|type
operator|*
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|hpread_adjust_bitoffsets
name|PARAMS
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dnttpointer
name|hpread_get_next_skip_over_anon_unions
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|dnttpointer
operator|,
expr|union
name|dnttentry
operator|*
operator|*
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Global to indicate presence of HP-compiled objects,    in particular, SOM executable file with SOM debug info     Defined in symtab.c, used in hppa-tdep.c. */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|hp_som_som_object_present
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Static used to indicate a class type that requires a    fix-up of one of its method types */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|fixup_class
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Static used to indicate the method type that is to be    used to fix-up the type for fixup_class */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|fixup_method
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Get the nesting depth for the source line identified by INDEX.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|hpread_get_scope_start
parameter_list|(
name|index
parameter_list|,
name|objfile
parameter_list|)
name|sltpointer
name|index
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|union
name|sltentry
modifier|*
name|sl_bufp
decl_stmt|;
name|sl_bufp
operator|=
name|hpread_get_slt
argument_list|(
name|index
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
return|return
name|sl_bufp
operator|->
name|sspec
operator|.
name|backptr
operator|.
name|dnttp
operator|.
name|index
return|;
block|}
end_function

begin_comment
comment|/* Get the source line number the the line identified by INDEX.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|hpread_get_line
parameter_list|(
name|index
parameter_list|,
name|objfile
parameter_list|)
name|sltpointer
name|index
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|union
name|sltentry
modifier|*
name|sl_bufp
decl_stmt|;
name|sl_bufp
operator|=
name|hpread_get_slt
argument_list|(
name|index
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
return|return
name|sl_bufp
operator|->
name|snorm
operator|.
name|line
return|;
block|}
end_function

begin_comment
comment|/* Find the code address associated with a given sltpointer */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|hpread_get_location
parameter_list|(
name|index
parameter_list|,
name|objfile
parameter_list|)
name|sltpointer
name|index
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|union
name|sltentry
modifier|*
name|sl_bufp
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* code location of special sltentrys is determined from context */
name|sl_bufp
operator|=
name|hpread_get_slt
argument_list|(
name|index
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|sl_bufp
operator|->
name|snorm
operator|.
name|sltdesc
operator|==
name|SLT_END
condition|)
block|{
comment|/* find previous normal sltentry and get address */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
operator|(
name|sl_bufp
operator|->
name|snorm
operator|.
name|sltdesc
operator|!=
name|SLT_NORMAL
operator|)
operator|&&
operator|(
name|sl_bufp
operator|->
name|snorm
operator|.
name|sltdesc
operator|!=
name|SLT_NORMAL_OFFSET
operator|)
operator|&&
operator|(
name|sl_bufp
operator|->
name|snorm
operator|.
name|sltdesc
operator|!=
name|SLT_EXIT
operator|)
operator|)
condition|;
name|i
operator|++
control|)
name|sl_bufp
operator|=
name|hpread_get_slt
argument_list|(
name|index
operator|-
name|i
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|sl_bufp
operator|->
name|snorm
operator|.
name|sltdesc
operator|==
name|SLT_NORMAL_OFFSET
condition|)
return|return
name|sl_bufp
operator|->
name|snormoff
operator|.
name|address
return|;
else|else
return|return
name|sl_bufp
operator|->
name|snorm
operator|.
name|address
return|;
block|}
comment|/* find next normal sltentry and get address */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
operator|(
name|sl_bufp
operator|->
name|snorm
operator|.
name|sltdesc
operator|!=
name|SLT_NORMAL
operator|)
operator|&&
operator|(
name|sl_bufp
operator|->
name|snorm
operator|.
name|sltdesc
operator|!=
name|SLT_NORMAL_OFFSET
operator|)
operator|&&
operator|(
name|sl_bufp
operator|->
name|snorm
operator|.
name|sltdesc
operator|!=
name|SLT_EXIT
operator|)
operator|)
condition|;
name|i
operator|++
control|)
name|sl_bufp
operator|=
name|hpread_get_slt
argument_list|(
name|index
operator|+
name|i
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|sl_bufp
operator|->
name|snorm
operator|.
name|sltdesc
operator|==
name|SLT_NORMAL_OFFSET
condition|)
return|return
name|sl_bufp
operator|->
name|snormoff
operator|.
name|address
return|;
else|else
return|return
name|sl_bufp
operator|->
name|snorm
operator|.
name|address
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if an HP debug symbol of type KIND has a name associated with  * it, else return 0. (This function is not currently used, but I'll  * leave it here in case it proves useful later on. - RT).  */
end_comment

begin_function
name|int
name|hpread_has_name
parameter_list|(
name|kind
parameter_list|)
name|enum
name|dntt_entry_type
name|kind
decl_stmt|;
block|{
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|DNTT_TYPE_SRCFILE
case|:
case|case
name|DNTT_TYPE_MODULE
case|:
case|case
name|DNTT_TYPE_FUNCTION
case|:
case|case
name|DNTT_TYPE_DOC_FUNCTION
case|:
case|case
name|DNTT_TYPE_ENTRY
case|:
case|case
name|DNTT_TYPE_IMPORT
case|:
case|case
name|DNTT_TYPE_LABEL
case|:
case|case
name|DNTT_TYPE_FPARAM
case|:
case|case
name|DNTT_TYPE_SVAR
case|:
case|case
name|DNTT_TYPE_DVAR
case|:
case|case
name|DNTT_TYPE_CONST
case|:
case|case
name|DNTT_TYPE_TYPEDEF
case|:
case|case
name|DNTT_TYPE_TAGDEF
case|:
case|case
name|DNTT_TYPE_MEMENUM
case|:
case|case
name|DNTT_TYPE_FIELD
case|:
case|case
name|DNTT_TYPE_SA
case|:
case|case
name|DNTT_TYPE_BLOCKDATA
case|:
case|case
name|DNTT_TYPE_MEMFUNC
case|:
case|case
name|DNTT_TYPE_DOC_MEMFUNC
case|:
return|return
literal|1
return|;
case|case
name|DNTT_TYPE_BEGIN
case|:
case|case
name|DNTT_TYPE_END
case|:
case|case
name|DNTT_TYPE_POINTER
case|:
case|case
name|DNTT_TYPE_ENUM
case|:
case|case
name|DNTT_TYPE_SET
case|:
case|case
name|DNTT_TYPE_ARRAY
case|:
case|case
name|DNTT_TYPE_STRUCT
case|:
case|case
name|DNTT_TYPE_UNION
case|:
case|case
name|DNTT_TYPE_VARIANT
case|:
case|case
name|DNTT_TYPE_FILE
case|:
case|case
name|DNTT_TYPE_FUNCTYPE
case|:
case|case
name|DNTT_TYPE_SUBRANGE
case|:
case|case
name|DNTT_TYPE_WITH
case|:
case|case
name|DNTT_TYPE_COMMON
case|:
case|case
name|DNTT_TYPE_COBSTRUCT
case|:
case|case
name|DNTT_TYPE_XREF
case|:
case|case
name|DNTT_TYPE_MACRO
case|:
case|case
name|DNTT_TYPE_CLASS_SCOPE
case|:
case|case
name|DNTT_TYPE_REFERENCE
case|:
case|case
name|DNTT_TYPE_PTRMEM
case|:
case|case
name|DNTT_TYPE_PTRMEMFUNC
case|:
case|case
name|DNTT_TYPE_CLASS
case|:
case|case
name|DNTT_TYPE_GENFIELD
case|:
case|case
name|DNTT_TYPE_VFUNC
case|:
case|case
name|DNTT_TYPE_MEMACCESS
case|:
case|case
name|DNTT_TYPE_INHERITANCE
case|:
case|case
name|DNTT_TYPE_FRIEND_CLASS
case|:
case|case
name|DNTT_TYPE_FRIEND_FUNC
case|:
case|case
name|DNTT_TYPE_MODIFIER
case|:
case|case
name|DNTT_TYPE_OBJECT_ID
case|:
case|case
name|DNTT_TYPE_TEMPLATE
case|:
case|case
name|DNTT_TYPE_TEMPLATE_ARG
case|:
case|case
name|DNTT_TYPE_FUNC_TEMPLATE
case|:
case|case
name|DNTT_TYPE_LINK
case|:
comment|/* DNTT_TYPE_DYN_ARRAY_DESC ? */
comment|/* DNTT_TYPE_DESC_SUBRANGE ? */
comment|/* DNTT_TYPE_BEGIN_EXT ? */
comment|/* DNTT_TYPE_INLN ? */
comment|/* DNTT_TYPE_INLN_LIST ? */
comment|/* DNTT_TYPE_ALIAS ? */
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Do the dirty work of reading in the full symbol from a partial symbol    table.  */
end_comment

begin_function
specifier|static
name|void
name|hpread_psymtab_to_symtab_1
parameter_list|(
name|pst
parameter_list|)
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
block|{
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Get out quick if passed junk.  */
if|if
condition|(
operator|!
name|pst
condition|)
return|return;
comment|/* Complain if we've already read in this symbol table.  */
if|if
condition|(
name|pst
operator|->
name|readin
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Psymtab for %s already read in.  Shouldn't happen.\n"
argument_list|,
name|pst
operator|->
name|filename
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Read in all partial symtabs on which this one is dependent */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pst
operator|->
name|number_of_dependencies
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|pst
operator|->
name|dependencies
index|[
name|i
index|]
operator|->
name|readin
condition|)
block|{
comment|/* Inform about additional files that need to be read in.  */
if|if
condition|(
name|info_verbose
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|" "
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"and "
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%s..."
argument_list|,
name|pst
operator|->
name|dependencies
index|[
name|i
index|]
operator|->
name|filename
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
comment|/* Flush output */
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
name|hpread_psymtab_to_symtab_1
argument_list|(
name|pst
operator|->
name|dependencies
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* If it's real...  */
if|if
condition|(
name|LDSYMLEN
argument_list|(
name|pst
argument_list|)
condition|)
block|{
comment|/* Init stuff necessary for reading in symbols */
name|buildsym_init
argument_list|()
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|really_free_pendings
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pst
operator|->
name|symtab
operator|=
name|hpread_expand_symtab
argument_list|(
name|pst
operator|->
name|objfile
argument_list|,
name|LDSYMOFF
argument_list|(
name|pst
argument_list|)
argument_list|,
name|LDSYMLEN
argument_list|(
name|pst
argument_list|)
argument_list|,
name|pst
operator|->
name|textlow
argument_list|,
name|pst
operator|->
name|texthigh
operator|-
name|pst
operator|->
name|textlow
argument_list|,
name|pst
operator|->
name|section_offsets
argument_list|,
name|pst
operator|->
name|filename
argument_list|)
expr_stmt|;
name|sort_symtab_syms
argument_list|(
name|pst
operator|->
name|symtab
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
name|pst
operator|->
name|readin
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read in all of the symbols for a given psymtab for real.    Be verbose about it if the user wants that.  */
end_comment

begin_function
name|void
name|hpread_psymtab_to_symtab
parameter_list|(
name|pst
parameter_list|)
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
block|{
comment|/* Get out quick if given junk.  */
if|if
condition|(
operator|!
name|pst
condition|)
return|return;
comment|/* Sanity check.  */
if|if
condition|(
name|pst
operator|->
name|readin
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Psymtab for %s already read in.  Shouldn't happen.\n"
argument_list|,
name|pst
operator|->
name|filename
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* elz: setting the flag to indicate that the code of the target      was compiled using an HP compiler (aCC, cc)       the processing_acc_compilation variable is declared in the       file buildsym.h, the HP_COMPILED_TARGET is defined to be equal      to 3 in the file tm_hppa.h*/
name|processing_gcc_compilation
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|LDSYMLEN
argument_list|(
name|pst
argument_list|)
operator|||
name|pst
operator|->
name|number_of_dependencies
condition|)
block|{
comment|/* Print the message now, before reading the string table,          to avoid disconcerting pauses.  */
if|if
condition|(
name|info_verbose
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Reading in symbols for %s..."
argument_list|,
name|pst
operator|->
name|filename
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
name|hpread_psymtab_to_symtab_1
argument_list|(
name|pst
argument_list|)
expr_stmt|;
comment|/* Match with global symbols.  This only needs to be done once,          after all of the symtabs and dependencies have been read in.   */
name|scan_file_globals
argument_list|(
name|pst
operator|->
name|objfile
argument_list|)
expr_stmt|;
comment|/* Finish up the debug error message.  */
if|if
condition|(
name|info_verbose
condition|)
name|printf_filtered
argument_list|(
literal|"done.\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Read in a defined section of a specific object file's symbols.     DESC is the file descriptor for the file, positioned at the    beginning of the symtab    SYM_OFFSET is the offset within the file of    the beginning of the symbols we want to read    SYM_SIZE is the size of the symbol info to read in.    TEXT_OFFSET is the beginning of the text segment we are reading symbols for    TEXT_SIZE is the size of the text segment read in.    SECTION_OFFSETS are the relocation offsets which get added to each symbol. */
end_comment

begin_function
specifier|static
name|struct
name|symtab
modifier|*
name|hpread_expand_symtab
parameter_list|(
name|objfile
parameter_list|,
name|sym_offset
parameter_list|,
name|sym_size
parameter_list|,
name|text_offset
parameter_list|,
name|text_size
parameter_list|,
name|section_offsets
parameter_list|,
name|filename
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|int
name|sym_offset
decl_stmt|;
name|int
name|sym_size
decl_stmt|;
name|CORE_ADDR
name|text_offset
decl_stmt|;
name|int
name|text_size
decl_stmt|;
name|struct
name|section_offsets
modifier|*
name|section_offsets
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|char
modifier|*
name|namestring
decl_stmt|;
name|union
name|dnttentry
modifier|*
name|dn_bufp
decl_stmt|;
name|unsigned
name|max_symnum
decl_stmt|;
name|int
name|at_module_boundary
init|=
literal|0
decl_stmt|;
comment|/* 1 => at end, -1 => at beginning */
name|int
name|sym_index
init|=
name|sym_offset
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|dntt_type_block
argument_list|)
decl_stmt|;
name|current_objfile
operator|=
name|objfile
expr_stmt|;
name|subfile_stack
operator|=
literal|0
expr_stmt|;
name|last_source_file
operator|=
literal|0
expr_stmt|;
comment|/* Demangling style -- if EDG style already set, don't change it,      as HP style causes some problems with the KAI EDG compiler */
if|if
condition|(
name|current_demangling_style
operator|!=
name|edg_demangling
condition|)
block|{
comment|/* Otherwise, ensure that we are using HP style demangling */
name|set_demangling_style
argument_list|(
name|HP_DEMANGLING_STYLE_STRING
argument_list|)
expr_stmt|;
block|}
name|dn_bufp
operator|=
name|hpread_get_lntt
argument_list|(
name|sym_index
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|==
operator|(
name|unsigned
name|char
operator|)
name|DNTT_TYPE_SRCFILE
operator|)
operator|||
operator|(
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|==
operator|(
name|unsigned
name|char
operator|)
name|DNTT_TYPE_MODULE
operator|)
operator|)
condition|)
block|{
name|start_symtab
argument_list|(
literal|"globals"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|record_debugformat
argument_list|(
literal|"HP"
argument_list|)
expr_stmt|;
block|}
comment|/* The psymtab builder (hp-psymtab-read.c) is the one that    * determined the "sym_size" argument (i.e. how many DNTT symbols    * are in this symtab), which we use to compute "max_symnum"    * (point in DNTT to which we read).     *    * Perhaps this should be changed so that     * process_one_debug_symbol() "knows" when    * to stop reading (based on reading from the MODULE to the matching    * END), and take out this reliance on a #-syms being passed in...    * (I'm worried about the reliability of this number). But I'll    * leave it as-is, for now. - RT    *    * The change above has been made. I've left the "for" loop control    * in to prepare for backing this out again. -JB    */
name|max_symnum
operator|=
name|sym_size
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|dntt_type_block
argument_list|)
expr_stmt|;
comment|/* No reason to multiply on pst side and divide on sym side... FIXME */
comment|/* Read in and process each debug symbol within the specified range.    */
for|for
control|(
name|symnum
operator|=
literal|0
init|;
name|symnum
operator|<
name|max_symnum
condition|;
name|symnum
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
comment|/* Allow this to be interruptable */
name|dn_bufp
operator|=
name|hpread_get_lntt
argument_list|(
name|sym_index
operator|+
name|symnum
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn_bufp
operator|->
name|dblock
operator|.
name|extension
condition|)
continue|continue;
comment|/* Yow!  We call SET_NAMESTRING on things without names!  */
name|SET_NAMESTRING
argument_list|(
name|dn_bufp
argument_list|,
operator|&
name|namestring
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|hpread_process_one_debug_symbol
argument_list|(
name|dn_bufp
argument_list|,
name|namestring
argument_list|,
name|section_offsets
argument_list|,
name|objfile
argument_list|,
name|text_offset
argument_list|,
name|text_size
argument_list|,
name|filename
argument_list|,
name|symnum
operator|+
name|sym_index
argument_list|,
operator|&
name|at_module_boundary
argument_list|)
expr_stmt|;
comment|/* OLD COMMENTS: This routine is only called for psts.  All psts        * correspond to MODULES.  If we ever do lazy-reading of globals        * from the LNTT, then there will be a pst which ends when the        * LNTT ends, and not at an END MODULE entry.  Then we'll have        * to re-visit this break.           if( at_end_of_module )            break;         */
comment|/* We no longer break out of the loop when we reach the end of a          module. The reason is that with CTTI, the compiler can generate          function symbols (for template function instantiations) which are not          in any module; typically they show up beyond a module's end, and          before the next module's start.  We include them in the current          module.  However, we still don't trust the MAX_SYMNUM value from          the psymtab, so we break out if we enter a new module. */
if|if
condition|(
name|at_module_boundary
operator|==
operator|-
literal|1
condition|)
break|break;
block|}
name|current_objfile
operator|=
name|NULL
expr_stmt|;
name|hp_som_som_object_present
operator|=
literal|1
expr_stmt|;
comment|/* Indicate we've processed an HP SOM SOM file */
return|return
name|end_symtab
argument_list|(
name|text_offset
operator|+
name|text_size
argument_list|,
name|objfile
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Convert basic types from HP debug format into GDB internal format.  */
end_comment

begin_function
specifier|static
name|int
name|hpread_type_translate
parameter_list|(
name|typep
parameter_list|)
name|dnttpointer
name|typep
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|typep
operator|.
name|dntti
operator|.
name|immediate
condition|)
block|{
name|error
argument_list|(
literal|"error in hpread_type_translate\n."
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|typep
operator|.
name|dntti
operator|.
name|type
condition|)
block|{
case|case
name|HP_TYPE_BOOLEAN
case|:
case|case
name|HP_TYPE_BOOLEAN_S300_COMPAT
case|:
case|case
name|HP_TYPE_BOOLEAN_VAX_COMPAT
case|:
return|return
name|FT_BOOLEAN
return|;
case|case
name|HP_TYPE_CHAR
case|:
comment|/* C signed char, C++ plain char */
case|case
name|HP_TYPE_WIDE_CHAR
case|:
return|return
name|FT_CHAR
return|;
case|case
name|HP_TYPE_INT
case|:
if|if
condition|(
name|typep
operator|.
name|dntti
operator|.
name|bitlength
operator|<=
literal|8
condition|)
return|return
name|FT_SIGNED_CHAR
return|;
comment|/* C++ signed char */
if|if
condition|(
name|typep
operator|.
name|dntti
operator|.
name|bitlength
operator|<=
literal|16
condition|)
return|return
name|FT_SHORT
return|;
if|if
condition|(
name|typep
operator|.
name|dntti
operator|.
name|bitlength
operator|<=
literal|32
condition|)
return|return
name|FT_INTEGER
return|;
return|return
name|FT_LONG_LONG
return|;
case|case
name|HP_TYPE_LONG
case|:
if|if
condition|(
name|typep
operator|.
name|dntti
operator|.
name|bitlength
operator|<=
literal|8
condition|)
return|return
name|FT_SIGNED_CHAR
return|;
comment|/* C++ signed char. */
return|return
name|FT_LONG
return|;
case|case
name|HP_TYPE_UNSIGNED_LONG
case|:
if|if
condition|(
name|typep
operator|.
name|dntti
operator|.
name|bitlength
operator|<=
literal|8
condition|)
return|return
name|FT_UNSIGNED_CHAR
return|;
comment|/* C/C++ unsigned char */
if|if
condition|(
name|typep
operator|.
name|dntti
operator|.
name|bitlength
operator|<=
literal|16
condition|)
return|return
name|FT_UNSIGNED_SHORT
return|;
if|if
condition|(
name|typep
operator|.
name|dntti
operator|.
name|bitlength
operator|<=
literal|32
condition|)
return|return
name|FT_UNSIGNED_LONG
return|;
return|return
name|FT_UNSIGNED_LONG_LONG
return|;
case|case
name|HP_TYPE_UNSIGNED_INT
case|:
if|if
condition|(
name|typep
operator|.
name|dntti
operator|.
name|bitlength
operator|<=
literal|8
condition|)
return|return
name|FT_UNSIGNED_CHAR
return|;
if|if
condition|(
name|typep
operator|.
name|dntti
operator|.
name|bitlength
operator|<=
literal|16
condition|)
return|return
name|FT_UNSIGNED_SHORT
return|;
if|if
condition|(
name|typep
operator|.
name|dntti
operator|.
name|bitlength
operator|<=
literal|32
condition|)
return|return
name|FT_UNSIGNED_INTEGER
return|;
return|return
name|FT_UNSIGNED_LONG_LONG
return|;
case|case
name|HP_TYPE_REAL
case|:
case|case
name|HP_TYPE_REAL_3000
case|:
case|case
name|HP_TYPE_DOUBLE
case|:
if|if
condition|(
name|typep
operator|.
name|dntti
operator|.
name|bitlength
operator|==
literal|64
condition|)
return|return
name|FT_DBL_PREC_FLOAT
return|;
if|if
condition|(
name|typep
operator|.
name|dntti
operator|.
name|bitlength
operator|==
literal|128
condition|)
return|return
name|FT_EXT_PREC_FLOAT
return|;
return|return
name|FT_FLOAT
return|;
case|case
name|HP_TYPE_COMPLEX
case|:
case|case
name|HP_TYPE_COMPLEXS3000
case|:
if|if
condition|(
name|typep
operator|.
name|dntti
operator|.
name|bitlength
operator|==
literal|128
condition|)
return|return
name|FT_DBL_PREC_COMPLEX
return|;
if|if
condition|(
name|typep
operator|.
name|dntti
operator|.
name|bitlength
operator|==
literal|192
condition|)
return|return
name|FT_EXT_PREC_COMPLEX
return|;
return|return
name|FT_COMPLEX
return|;
case|case
name|HP_TYPE_VOID
case|:
return|return
name|FT_VOID
return|;
case|case
name|HP_TYPE_STRING200
case|:
case|case
name|HP_TYPE_LONGSTRING200
case|:
case|case
name|HP_TYPE_FTN_STRING_SPEC
case|:
case|case
name|HP_TYPE_MOD_STRING_SPEC
case|:
case|case
name|HP_TYPE_MOD_STRING_3000
case|:
case|case
name|HP_TYPE_FTN_STRING_S300_COMPAT
case|:
case|case
name|HP_TYPE_FTN_STRING_VAX_COMPAT
case|:
return|return
name|FT_STRING
return|;
case|case
name|HP_TYPE_TEMPLATE_ARG
case|:
return|return
name|FT_TEMPLATE_ARG
return|;
case|case
name|HP_TYPE_TEXT
case|:
case|case
name|HP_TYPE_FLABEL
case|:
case|case
name|HP_TYPE_PACKED_DECIMAL
case|:
case|case
name|HP_TYPE_ANYPOINTER
case|:
case|case
name|HP_TYPE_GLOBAL_ANYPOINTER
case|:
case|case
name|HP_TYPE_LOCAL_ANYPOINTER
case|:
default|default:
name|warning
argument_list|(
literal|"hpread_type_translate: unhandled type code.\n"
argument_list|)
expr_stmt|;
return|return
name|FT_VOID
return|;
block|}
block|}
end_function

begin_comment
comment|/* Given a position in the DNTT, return a pointer to the   * already-built "struct type" (if any), for the type defined   * at that position.  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
modifier|*
name|hpread_lookup_type
parameter_list|(
name|hp_type
parameter_list|,
name|objfile
parameter_list|)
name|dnttpointer
name|hp_type
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|unsigned
name|old_len
decl_stmt|;
name|int
name|index
init|=
name|hp_type
operator|.
name|dnttp
operator|.
name|index
decl_stmt|;
name|int
name|size_changed
init|=
literal|0
decl_stmt|;
comment|/* The immediate flag indicates this doesn't actually point to    * a type DNTT.    */
if|if
condition|(
name|hp_type
operator|.
name|dntti
operator|.
name|immediate
condition|)
return|return
name|NULL
return|;
comment|/* For each objfile, we maintain a "type vector".    * This an array of "struct type *"'s with one pointer per DNTT index.    * Given a DNTT index, we look in this array to see if we have    * already processed this DNTT and if it is a type definition.    * If so, then we can locate a pointer to the already-built    * "struct type", and not build it again.    *     * The need for this arises because our DNTT-walking code wanders    * around. In particular, it will encounter the same type multiple    * times (once for each object of that type). We don't want to     * built multiple "struct type"'s for the same thing.    *    * Having said this, I should point out that this type-vector is    * an expensive way to keep track of this. If most DNTT entries are     * 3 words, the type-vector will be 1/3 the size of the DNTT itself.    * Alternative solutions:    * - Keep a compressed or hashed table. Less memory, but more expensive    *   to search and update.    * - (Suggested by JB): Overwrite the DNTT entry itself    *   with the info. Create a new type code "ALREADY_BUILT", and modify    *   the DNTT to have that type code and point to the already-built entry.    * -RT    */
if|if
condition|(
name|index
operator|<
name|LNTT_SYMCOUNT
argument_list|(
name|objfile
argument_list|)
condition|)
block|{
if|if
condition|(
name|index
operator|>=
name|TYPE_VECTOR_LENGTH
argument_list|(
name|objfile
argument_list|)
condition|)
block|{
name|old_len
operator|=
name|TYPE_VECTOR_LENGTH
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
comment|/* See if we need to allocate a type-vector. */
if|if
condition|(
name|old_len
operator|==
literal|0
condition|)
block|{
name|TYPE_VECTOR_LENGTH
argument_list|(
name|objfile
argument_list|)
operator|=
name|LNTT_SYMCOUNT
argument_list|(
name|objfile
argument_list|)
operator|+
name|GNTT_SYMCOUNT
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
name|TYPE_VECTOR
argument_list|(
name|objfile
argument_list|)
operator|=
operator|(
expr|struct
name|type
operator|*
operator|*
operator|)
name|xmmalloc
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
name|TYPE_VECTOR_LENGTH
argument_list|(
name|objfile
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|TYPE_VECTOR
argument_list|(
name|objfile
argument_list|)
index|[
name|old_len
index|]
argument_list|,
literal|0
argument_list|,
operator|(
name|TYPE_VECTOR_LENGTH
argument_list|(
name|objfile
argument_list|)
operator|-
name|old_len
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* See if we need to resize type-vector. With my change to            * initially allocate a correct-size type-vector, this code            * should no longer trigger.            */
while|while
condition|(
name|index
operator|>=
name|TYPE_VECTOR_LENGTH
argument_list|(
name|objfile
argument_list|)
condition|)
block|{
name|TYPE_VECTOR_LENGTH
argument_list|(
name|objfile
argument_list|)
operator|*=
literal|2
expr_stmt|;
name|size_changed
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|size_changed
condition|)
block|{
name|TYPE_VECTOR
argument_list|(
name|objfile
argument_list|)
operator|=
operator|(
expr|struct
name|type
operator|*
operator|*
operator|)
name|xmrealloc
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
operator|(
name|char
operator|*
operator|)
name|TYPE_VECTOR
argument_list|(
name|objfile
argument_list|)
argument_list|,
operator|(
name|TYPE_VECTOR_LENGTH
argument_list|(
name|objfile
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|TYPE_VECTOR
argument_list|(
name|objfile
argument_list|)
index|[
name|old_len
index|]
argument_list|,
literal|0
argument_list|,
operator|(
name|TYPE_VECTOR_LENGTH
argument_list|(
name|objfile
argument_list|)
operator|-
name|old_len
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|&
name|TYPE_VECTOR
argument_list|(
name|objfile
argument_list|)
index|[
name|index
index|]
return|;
block|}
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Possibly allocate a GDB internal type so we can internalize HP_TYPE.    Note we'll just return the address of a GDB internal type if we already    have it lying around.  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|hpread_alloc_type
parameter_list|(
name|hp_type
parameter_list|,
name|objfile
parameter_list|)
name|dnttpointer
name|hp_type
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|struct
name|type
modifier|*
modifier|*
name|type_addr
decl_stmt|;
name|type_addr
operator|=
name|hpread_lookup_type
argument_list|(
name|hp_type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|type_addr
operator|==
literal|0
condition|)
block|{
operator|*
name|type_addr
operator|=
name|alloc_type
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
comment|/* A hack - if we really are a C++ class symbol, then this default      * will get overriden later on.      */
name|TYPE_CPLUS_SPECIFIC
argument_list|(
operator|*
name|type_addr
argument_list|)
operator|=
operator|(
expr|struct
name|cplus_struct_type
operator|*
operator|)
operator|&
name|cplus_struct_default
expr_stmt|;
block|}
return|return
operator|*
name|type_addr
return|;
block|}
end_function

begin_comment
comment|/* Read a native enumerated type and return it in GDB internal form.  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|hpread_read_enum_type
parameter_list|(
name|hp_type
parameter_list|,
name|dn_bufp
parameter_list|,
name|objfile
parameter_list|)
name|dnttpointer
name|hp_type
decl_stmt|;
name|union
name|dnttentry
modifier|*
name|dn_bufp
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|struct
name|pending
modifier|*
modifier|*
name|symlist
decl_stmt|,
modifier|*
name|osyms
decl_stmt|,
modifier|*
name|syms
decl_stmt|;
name|struct
name|pending
modifier|*
name|local_list
init|=
name|NULL
decl_stmt|;
name|int
name|o_nsyms
decl_stmt|,
name|nsyms
init|=
literal|0
decl_stmt|;
name|dnttpointer
name|mem
decl_stmt|;
name|union
name|dnttentry
modifier|*
name|memp
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|long
name|n
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
comment|/* Allocate a GDB type. If we've already read in this enum type,    * it'll return the already built GDB type, so stop here.    * (Note: I added this check, to conform with what's done for     *  struct, union, class.    *  I assume this is OK. - RT)    */
name|type
operator|=
name|hpread_alloc_type
argument_list|(
name|hp_type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_ENUM
condition|)
return|return
name|type
return|;
comment|/* HP C supports "sized enums", where a specifier such as "short" or      "char" can be used to get enums of different sizes. So don't assume      an enum is always 4 bytes long. pai/1997-08-21 */
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
name|dn_bufp
operator|->
name|denum
operator|.
name|bitlength
operator|/
literal|8
expr_stmt|;
name|symlist
operator|=
operator|&
name|file_symbols
expr_stmt|;
name|osyms
operator|=
operator|*
name|symlist
expr_stmt|;
name|o_nsyms
operator|=
name|osyms
condition|?
name|osyms
operator|->
name|nsyms
else|:
literal|0
expr_stmt|;
comment|/* Get a name for each member and add it to our list of members.      * The list of "mem" SOM records we are walking should all be    * SOM type DNTT_TYPE_MEMENUM (not checked).    */
name|mem
operator|=
name|dn_bufp
operator|->
name|denum
operator|.
name|firstmem
expr_stmt|;
while|while
condition|(
name|mem
operator|.
name|word
operator|&&
name|mem
operator|.
name|word
operator|!=
name|DNTTNIL
condition|)
block|{
name|memp
operator|=
name|hpread_get_lntt
argument_list|(
name|mem
operator|.
name|dnttp
operator|.
name|index
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|name
operator|=
name|VT
argument_list|(
name|objfile
argument_list|)
operator|+
name|memp
operator|->
name|dmember
operator|.
name|name
expr_stmt|;
name|sym
operator|=
operator|(
expr|struct
name|symbol
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|sym
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|=
name|obsavestring
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|)
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_CONST
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|memp
operator|->
name|dmember
operator|.
name|value
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
name|symlist
argument_list|)
expr_stmt|;
name|nsyms
operator|++
expr_stmt|;
name|mem
operator|=
name|memp
operator|->
name|dmember
operator|.
name|nextmem
expr_stmt|;
block|}
comment|/* Now that we know more about the enum, fill in more info.  */
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_CODE_ENUM
expr_stmt|;
name|TYPE_FLAGS
argument_list|(
name|type
argument_list|)
operator|&=
operator|~
name|TYPE_FLAG_STUB
expr_stmt|;
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|=
name|nsyms
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
expr|struct
name|field
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|type_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
operator|*
name|nsyms
argument_list|)
expr_stmt|;
comment|/* Find the symbols for the members and put them into the type.      The symbols can be found in the symlist that we put them on      to cause them to be defined.  osyms contains the old value      of that symlist; everything up to there was defined by us.       Note that we preserve the order of the enum constants, so      that in something like "enum {FOO, LAST_THING=FOO}" we print      FOO, not LAST_THING.  */
for|for
control|(
name|syms
operator|=
operator|*
name|symlist
operator|,
name|n
operator|=
literal|0
init|;
name|syms
condition|;
name|syms
operator|=
name|syms
operator|->
name|next
control|)
block|{
name|int
name|j
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|syms
operator|==
name|osyms
condition|)
name|j
operator|=
name|o_nsyms
expr_stmt|;
for|for
control|(
init|;
name|j
operator|<
name|syms
operator|->
name|nsyms
condition|;
name|j
operator|++
operator|,
name|n
operator|++
control|)
block|{
name|struct
name|symbol
modifier|*
name|xsym
init|=
name|syms
operator|->
name|symbol
index|[
name|j
index|]
decl_stmt|;
name|SYMBOL_TYPE
argument_list|(
name|xsym
argument_list|)
operator|=
name|type
expr_stmt|;
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|n
argument_list|)
operator|=
name|SYMBOL_NAME
argument_list|(
name|xsym
argument_list|)
expr_stmt|;
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|n
argument_list|)
operator|=
name|SYMBOL_VALUE
argument_list|(
name|xsym
argument_list|)
expr_stmt|;
name|TYPE_FIELD_BITSIZE
argument_list|(
name|type
argument_list|,
name|n
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|syms
operator|==
name|osyms
condition|)
break|break;
block|}
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Read and internalize a native function debug symbol.  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|hpread_read_function_type
parameter_list|(
name|hp_type
parameter_list|,
name|dn_bufp
parameter_list|,
name|objfile
parameter_list|,
name|newblock
parameter_list|)
name|dnttpointer
name|hp_type
decl_stmt|;
name|union
name|dnttentry
modifier|*
name|dn_bufp
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|int
name|newblock
decl_stmt|;
block|{
name|struct
name|type
modifier|*
name|type
decl_stmt|,
modifier|*
name|type1
decl_stmt|;
name|struct
name|pending
modifier|*
name|syms
decl_stmt|;
name|struct
name|pending
modifier|*
name|local_list
init|=
name|NULL
decl_stmt|;
name|int
name|nsyms
init|=
literal|0
decl_stmt|;
name|dnttpointer
name|param
decl_stmt|;
name|union
name|dnttentry
modifier|*
name|paramp
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|long
name|n
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|int
name|record_args
init|=
literal|1
decl_stmt|;
comment|/* See if we've already read in this type.  */
name|type
operator|=
name|hpread_alloc_type
argument_list|(
name|hp_type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_FUNC
condition|)
block|{
name|record_args
operator|=
literal|0
expr_stmt|;
comment|/* already read in, don't modify type */
block|}
else|else
block|{
comment|/* Nope, so read it in and store it away.  */
if|if
condition|(
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_FUNCTION
operator|||
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_MEMFUNC
condition|)
name|type1
operator|=
name|lookup_function_type
argument_list|(
name|hpread_type_lookup
argument_list|(
name|dn_bufp
operator|->
name|dfunc
operator|.
name|retval
argument_list|,
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_FUNCTYPE
condition|)
name|type1
operator|=
name|lookup_function_type
argument_list|(
name|hpread_type_lookup
argument_list|(
name|dn_bufp
operator|->
name|dfunctype
operator|.
name|retval
argument_list|,
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
else|else
comment|/* expect DNTT_TYPE_FUNC_TEMPLATE */
name|type1
operator|=
name|lookup_function_type
argument_list|(
name|hpread_type_lookup
argument_list|(
name|dn_bufp
operator|->
name|dfunc_template
operator|.
name|retval
argument_list|,
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|type
argument_list|,
operator|(
name|char
operator|*
operator|)
name|type1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Mark it -- in the middle of processing */
name|TYPE_FLAGS
argument_list|(
name|type
argument_list|)
operator||=
name|TYPE_FLAG_INCOMPLETE
expr_stmt|;
block|}
comment|/* Now examine each parameter noting its type, location, and a      wealth of other information.  */
if|if
condition|(
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_FUNCTION
operator|||
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_MEMFUNC
condition|)
name|param
operator|=
name|dn_bufp
operator|->
name|dfunc
operator|.
name|firstparam
expr_stmt|;
elseif|else
if|if
condition|(
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_FUNCTYPE
condition|)
name|param
operator|=
name|dn_bufp
operator|->
name|dfunctype
operator|.
name|firstparam
expr_stmt|;
else|else
comment|/* expect DNTT_TYPE_FUNC_TEMPLATE */
name|param
operator|=
name|dn_bufp
operator|->
name|dfunc_template
operator|.
name|firstparam
expr_stmt|;
while|while
condition|(
name|param
operator|.
name|word
operator|&&
name|param
operator|.
name|word
operator|!=
name|DNTTNIL
condition|)
block|{
name|paramp
operator|=
name|hpread_get_lntt
argument_list|(
name|param
operator|.
name|dnttp
operator|.
name|index
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|nsyms
operator|++
expr_stmt|;
name|param
operator|=
name|paramp
operator|->
name|dfparam
operator|.
name|nextparam
expr_stmt|;
comment|/* Get the name.  */
name|name
operator|=
name|VT
argument_list|(
name|objfile
argument_list|)
operator|+
name|paramp
operator|->
name|dfparam
operator|.
name|name
expr_stmt|;
name|sym
operator|=
operator|(
expr|struct
name|symbol
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memset
argument_list|(
name|sym
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|=
name|obsavestring
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|)
expr_stmt|;
comment|/* Figure out where it lives.  */
if|if
condition|(
name|paramp
operator|->
name|dfparam
operator|.
name|regparam
condition|)
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_REGPARM
expr_stmt|;
elseif|else
if|if
condition|(
name|paramp
operator|->
name|dfparam
operator|.
name|indirect
condition|)
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_REF_ARG
expr_stmt|;
else|else
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_ARG
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
if|if
condition|(
name|paramp
operator|->
name|dfparam
operator|.
name|copyparam
condition|)
block|{
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|paramp
operator|->
name|dfparam
operator|.
name|location
expr_stmt|;
ifdef|#
directive|ifdef
name|HPREAD_ADJUST_STACK_ADDRESS
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|+=
name|HPREAD_ADJUST_STACK_ADDRESS
argument_list|(
name|CURRENT_FUNCTION_VALUE
argument_list|(
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* This is likely a pass-by-invisible reference parameter, 	     Hack on the symbol class to make GDB happy.  */
comment|/* ??rehrauer: This appears to be broken w/r/t to passing              C values of type float and struct.  Perhaps this ought              to be highighted as a special case, but for now, just              allowing these to be LOC_ARGs seems to work fine.              */
if|#
directive|if
literal|0
block|SYMBOL_CLASS (sym) = LOC_REGPARM_ADDR;
endif|#
directive|endif
block|}
else|else
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|paramp
operator|->
name|dfparam
operator|.
name|location
expr_stmt|;
comment|/* Get its type.  */
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|hpread_type_lookup
argument_list|(
name|paramp
operator|->
name|dfparam
operator|.
name|type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* Add it to the symbol list.  */
comment|/* Note 1 (RT) At the moment, add_symbol_to_list() is also being        * called on FPARAM symbols from the process_one_debug_symbol()        * level... so parameters are getting added twice! (this shows        * up in the symbol dump you get from "maint print symbols ...").        * Note 2 (RT) I took out the processing of FPARAM from the         * process_one_debug_symbol() level, so at the moment parameters are only        * being processed here. This seems to have no ill effect.        */
comment|/* Note 3 (pai/1997-08-11) I removed the add_symbol_to_list() which put          each fparam on the local_symbols list from here.  Now we use the          local_list to which fparams are added below, and set the param_symbols          global to point to that at the end of this routine. */
comment|/* elz: I added this new list of symbols which is local to the function.          this list is the one which is actually used to build the type for the          function rather than the gloabal list pointed to by symlist.          Using a global list to keep track of the parameters is wrong, because           this function is called recursively if one parameter happend to be          a function itself with more parameters in it. Adding parameters to the          same global symbol list would not work!                Actually it did work in case of cc compiled programs where you do           not check the parameter lists of the arguments. */
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|local_list
argument_list|)
expr_stmt|;
block|}
comment|/* If type was read in earlier, don't bother with modifying      the type struct */
if|if
condition|(
operator|!
name|record_args
condition|)
goto|goto
name|finish
goto|;
comment|/* Note how many parameters we found.  */
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|=
name|nsyms
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
expr|struct
name|field
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|type_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
operator|*
name|nsyms
argument_list|)
expr_stmt|;
comment|/* Find the symbols for the parameters and       use them to fill parameter-type information into the function-type.      The parameter symbols can be found in the local_list that we just put them on. */
comment|/* Note that we preserve the order of the parameters, so      that in something like "enum {FOO, LAST_THING=FOO}" we print      FOO, not LAST_THING.  */
comment|/* get the parameters types from the local list not the global list      so that the type can be correctly constructed for functions which      have function as parameters */
for|for
control|(
name|syms
operator|=
name|local_list
operator|,
name|n
operator|=
literal|0
init|;
name|syms
condition|;
name|syms
operator|=
name|syms
operator|->
name|next
control|)
block|{
name|int
name|j
init|=
literal|0
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|syms
operator|->
name|nsyms
condition|;
name|j
operator|++
operator|,
name|n
operator|++
control|)
block|{
name|struct
name|symbol
modifier|*
name|xsym
init|=
name|syms
operator|->
name|symbol
index|[
name|j
index|]
decl_stmt|;
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|n
argument_list|)
operator|=
name|SYMBOL_NAME
argument_list|(
name|xsym
argument_list|)
expr_stmt|;
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|n
argument_list|)
operator|=
name|SYMBOL_TYPE
argument_list|(
name|xsym
argument_list|)
expr_stmt|;
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|n
argument_list|)
operator|=
name|n
expr_stmt|;
name|TYPE_FIELD_BITSIZE
argument_list|(
name|type
argument_list|,
name|n
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Mark it as having been processed */
name|TYPE_FLAGS
argument_list|(
name|type
argument_list|)
operator|&=
operator|~
operator|(
name|TYPE_FLAG_INCOMPLETE
operator|)
expr_stmt|;
comment|/* Check whether we need to fix-up a class type with this function's type */
if|if
condition|(
name|fixup_class
operator|&&
operator|(
name|fixup_method
operator|==
name|type
operator|)
condition|)
block|{
name|fixup_class_method_type
argument_list|(
name|fixup_class
argument_list|,
name|fixup_method
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|fixup_class
operator|=
name|NULL
expr_stmt|;
name|fixup_method
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Set the param list of this level of the context stack      to our local list.  Do this only if this function was      called for creating a new block, and not if it was called      simply to get the function type. This prevents recursive      invocations from trashing param_symbols. */
name|finish
label|:
if|if
condition|(
name|newblock
condition|)
name|param_symbols
operator|=
name|local_list
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Read and internalize a native DOC function debug symbol.  */
end_comment

begin_comment
comment|/* This is almost identical to hpread_read_function_type(), except  * for references to dn_bufp->ddocfunc instead of db_bufp->dfunc.  * Since debug information for DOC functions is more likely to be  * volatile, please leave it this way.  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|hpread_read_doc_function_type
parameter_list|(
name|hp_type
parameter_list|,
name|dn_bufp
parameter_list|,
name|objfile
parameter_list|,
name|newblock
parameter_list|)
name|dnttpointer
name|hp_type
decl_stmt|;
name|union
name|dnttentry
modifier|*
name|dn_bufp
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|int
name|newblock
decl_stmt|;
block|{
name|struct
name|type
modifier|*
name|type
decl_stmt|,
modifier|*
name|type1
decl_stmt|;
name|struct
name|pending
modifier|*
name|syms
decl_stmt|;
name|struct
name|pending
modifier|*
name|local_list
init|=
name|NULL
decl_stmt|;
name|int
name|nsyms
init|=
literal|0
decl_stmt|;
name|dnttpointer
name|param
decl_stmt|;
name|union
name|dnttentry
modifier|*
name|paramp
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|long
name|n
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|int
name|record_args
init|=
literal|1
decl_stmt|;
comment|/* See if we've already read in this type.  */
name|type
operator|=
name|hpread_alloc_type
argument_list|(
name|hp_type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_FUNC
condition|)
block|{
name|record_args
operator|=
literal|0
expr_stmt|;
comment|/* already read in, don't modify type */
block|}
else|else
block|{
comment|/* Nope, so read it in and store it away.  */
if|if
condition|(
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_DOC_FUNCTION
operator|||
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_DOC_MEMFUNC
condition|)
name|type1
operator|=
name|lookup_function_type
argument_list|(
name|hpread_type_lookup
argument_list|(
name|dn_bufp
operator|->
name|ddocfunc
operator|.
name|retval
argument_list|,
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|type
argument_list|,
operator|(
name|char
operator|*
operator|)
name|type1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Mark it -- in the middle of processing */
name|TYPE_FLAGS
argument_list|(
name|type
argument_list|)
operator||=
name|TYPE_FLAG_INCOMPLETE
expr_stmt|;
block|}
comment|/* Now examine each parameter noting its type, location, and a      wealth of other information.  */
if|if
condition|(
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_DOC_FUNCTION
operator|||
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_DOC_MEMFUNC
condition|)
name|param
operator|=
name|dn_bufp
operator|->
name|ddocfunc
operator|.
name|firstparam
expr_stmt|;
while|while
condition|(
name|param
operator|.
name|word
operator|&&
name|param
operator|.
name|word
operator|!=
name|DNTTNIL
condition|)
block|{
name|paramp
operator|=
name|hpread_get_lntt
argument_list|(
name|param
operator|.
name|dnttp
operator|.
name|index
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|nsyms
operator|++
expr_stmt|;
name|param
operator|=
name|paramp
operator|->
name|dfparam
operator|.
name|nextparam
expr_stmt|;
comment|/* Get the name.  */
name|name
operator|=
name|VT
argument_list|(
name|objfile
argument_list|)
operator|+
name|paramp
operator|->
name|dfparam
operator|.
name|name
expr_stmt|;
name|sym
operator|=
operator|(
expr|struct
name|symbol
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memset
argument_list|(
name|sym
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|=
name|name
expr_stmt|;
comment|/* Figure out where it lives.  */
if|if
condition|(
name|paramp
operator|->
name|dfparam
operator|.
name|regparam
condition|)
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_REGPARM
expr_stmt|;
elseif|else
if|if
condition|(
name|paramp
operator|->
name|dfparam
operator|.
name|indirect
condition|)
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_REF_ARG
expr_stmt|;
else|else
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_ARG
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
if|if
condition|(
name|paramp
operator|->
name|dfparam
operator|.
name|copyparam
condition|)
block|{
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|paramp
operator|->
name|dfparam
operator|.
name|location
expr_stmt|;
ifdef|#
directive|ifdef
name|HPREAD_ADJUST_STACK_ADDRESS
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|+=
name|HPREAD_ADJUST_STACK_ADDRESS
argument_list|(
name|CURRENT_FUNCTION_VALUE
argument_list|(
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* This is likely a pass-by-invisible reference parameter, 	     Hack on the symbol class to make GDB happy.  */
comment|/* ??rehrauer: This appears to be broken w/r/t to passing              C values of type float and struct.  Perhaps this ought              to be highighted as a special case, but for now, just              allowing these to be LOC_ARGs seems to work fine.              */
if|#
directive|if
literal|0
block|SYMBOL_CLASS (sym) = LOC_REGPARM_ADDR;
endif|#
directive|endif
block|}
else|else
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|paramp
operator|->
name|dfparam
operator|.
name|location
expr_stmt|;
comment|/* Get its type.  */
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|hpread_type_lookup
argument_list|(
name|paramp
operator|->
name|dfparam
operator|.
name|type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* Add it to the symbol list.  */
comment|/* Note 1 (RT) At the moment, add_symbol_to_list() is also being        * called on FPARAM symbols from the process_one_debug_symbol()        * level... so parameters are getting added twice! (this shows        * up in the symbol dump you get from "maint print symbols ...").        * Note 2 (RT) I took out the processing of FPARAM from the         * process_one_debug_symbol() level, so at the moment parameters are only        * being processed here. This seems to have no ill effect.        */
comment|/* Note 3 (pai/1997-08-11) I removed the add_symbol_to_list() which put          each fparam on the local_symbols list from here.  Now we use the          local_list to which fparams are added below, and set the param_symbols          global to point to that at the end of this routine. */
comment|/* elz: I added this new list of symbols which is local to the function.          this list is the one which is actually used to build the type for the          function rather than the gloabal list pointed to by symlist.          Using a global list to keep track of the parameters is wrong, because           this function is called recursively if one parameter happend to be          a function itself with more parameters in it. Adding parameters to the          same global symbol list would not work!                Actually it did work in case of cc compiled programs where you do not check the          parameter lists of the arguments.  */
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|local_list
argument_list|)
expr_stmt|;
block|}
comment|/* If type was read in earlier, don't bother with modifying      the type struct */
if|if
condition|(
operator|!
name|record_args
condition|)
goto|goto
name|finish
goto|;
comment|/* Note how many parameters we found.  */
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|=
name|nsyms
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
expr|struct
name|field
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|type_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
operator|*
name|nsyms
argument_list|)
expr_stmt|;
comment|/* Find the symbols for the parameters and       use them to fill parameter-type information into the function-type.      The parameter symbols can be found in the local_list that we just put them on. */
comment|/* Note that we preserve the order of the parameters, so      that in something like "enum {FOO, LAST_THING=FOO}" we print      FOO, not LAST_THING.  */
comment|/* get the parameters types from the local list not the global list      so that the type can be correctly constructed for functions which      have function as parameters   */
for|for
control|(
name|syms
operator|=
name|local_list
operator|,
name|n
operator|=
literal|0
init|;
name|syms
condition|;
name|syms
operator|=
name|syms
operator|->
name|next
control|)
block|{
name|int
name|j
init|=
literal|0
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|syms
operator|->
name|nsyms
condition|;
name|j
operator|++
operator|,
name|n
operator|++
control|)
block|{
name|struct
name|symbol
modifier|*
name|xsym
init|=
name|syms
operator|->
name|symbol
index|[
name|j
index|]
decl_stmt|;
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|n
argument_list|)
operator|=
name|SYMBOL_NAME
argument_list|(
name|xsym
argument_list|)
expr_stmt|;
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|n
argument_list|)
operator|=
name|SYMBOL_TYPE
argument_list|(
name|xsym
argument_list|)
expr_stmt|;
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|n
argument_list|)
operator|=
name|n
expr_stmt|;
name|TYPE_FIELD_BITSIZE
argument_list|(
name|type
argument_list|,
name|n
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Mark it as having been processed */
name|TYPE_FLAGS
argument_list|(
name|type
argument_list|)
operator|&=
operator|~
operator|(
name|TYPE_FLAG_INCOMPLETE
operator|)
expr_stmt|;
comment|/* Check whether we need to fix-up a class type with this function's type */
if|if
condition|(
name|fixup_class
operator|&&
operator|(
name|fixup_method
operator|==
name|type
operator|)
condition|)
block|{
name|fixup_class_method_type
argument_list|(
name|fixup_class
argument_list|,
name|fixup_method
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|fixup_class
operator|=
name|NULL
expr_stmt|;
name|fixup_method
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Set the param list of this level of the context stack      to our local list.  Do this only if this function was      called for creating a new block, and not if it was called      simply to get the function type. This prevents recursive      invocations from trashing param_symbols. */
name|finish
label|:
if|if
condition|(
name|newblock
condition|)
name|param_symbols
operator|=
name|local_list
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* A file-level variable which keeps track of the current-template  * being processed. Set in hpread_read_struct_type() while processing  * a template type. Referred to in hpread_get_nth_templ_arg().  * Yes, this is a kludge, but it arises from the kludge that already  * exists in symtab.h, namely the fact that they encode  * "template argument n" with fundamental type FT_TEMPLATE_ARG and  * bitlength n. This means that deep in processing fundamental types  * I need to ask the question "what template am I in the middle of?".  * The alternative to stuffing a global would be to pass an argument  * down the chain of calls just for this purpose.  *   * There may be problems handling nested templates... tough.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|current_template
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Read in and internalize a structure definition.    * This same routine is called for struct, union, and class types.  * Also called for templates, since they build a very similar  * type entry as for class types.  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|hpread_read_struct_type
parameter_list|(
name|hp_type
parameter_list|,
name|dn_bufp
parameter_list|,
name|objfile
parameter_list|)
name|dnttpointer
name|hp_type
decl_stmt|;
name|union
name|dnttentry
modifier|*
name|dn_bufp
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
comment|/* The data members get linked together into a list of struct nextfield's */
struct|struct
name|nextfield
block|{
name|struct
name|nextfield
modifier|*
name|next
decl_stmt|;
name|struct
name|field
name|field
decl_stmt|;
name|unsigned
name|char
name|attributes
decl_stmt|;
comment|/* store visibility and virtuality info */
define|#
directive|define
name|ATTR_VIRTUAL
value|1
define|#
directive|define
name|ATTR_PRIVATE
value|2
define|#
directive|define
name|ATTR_PROTECT
value|3
block|}
struct|;
comment|/* The methods get linked together into a list of struct next_fn_field's */
struct|struct
name|next_fn_field
block|{
name|struct
name|next_fn_field
modifier|*
name|next
decl_stmt|;
name|struct
name|fn_fieldlist
name|field
decl_stmt|;
name|struct
name|fn_field
name|fn_field
decl_stmt|;
name|int
name|num_fn_fields
decl_stmt|;
block|}
struct|;
comment|/* The template args get linked together into a list of struct next_template's */
struct|struct
name|next_template
block|{
name|struct
name|next_template
modifier|*
name|next
decl_stmt|;
name|struct
name|template_arg
name|arg
decl_stmt|;
block|}
struct|;
comment|/* The template instantiations get linked together into a list of these... */
struct|struct
name|next_instantiation
block|{
name|struct
name|next_instantiation
modifier|*
name|next
decl_stmt|;
name|struct
name|type
modifier|*
name|t
decl_stmt|;
block|}
struct|;
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|struct
name|type
modifier|*
name|baseclass
decl_stmt|;
name|struct
name|type
modifier|*
name|memtype
decl_stmt|;
name|struct
name|nextfield
modifier|*
name|list
init|=
literal|0
decl_stmt|,
modifier|*
name|tmp_list
init|=
literal|0
decl_stmt|;
name|struct
name|next_fn_field
modifier|*
name|fn_list
init|=
literal|0
decl_stmt|;
name|struct
name|next_fn_field
modifier|*
name|fn_p
decl_stmt|;
name|struct
name|next_template
modifier|*
name|t_new
decl_stmt|,
modifier|*
name|t_list
init|=
literal|0
decl_stmt|;
name|struct
name|nextfield
modifier|*
name|new
decl_stmt|;
name|struct
name|next_fn_field
modifier|*
name|fn_new
decl_stmt|;
name|struct
name|next_instantiation
modifier|*
name|i_new
decl_stmt|,
modifier|*
name|i_list
init|=
literal|0
decl_stmt|;
name|int
name|n
decl_stmt|,
name|nfields
init|=
literal|0
decl_stmt|,
name|n_fn_fields
init|=
literal|0
decl_stmt|,
name|n_fn_fields_total
init|=
literal|0
decl_stmt|;
name|int
name|n_base_classes
init|=
literal|0
decl_stmt|,
name|n_templ_args
init|=
literal|0
decl_stmt|;
name|int
name|ninstantiations
init|=
literal|0
decl_stmt|;
name|dnttpointer
name|field
decl_stmt|,
name|fn_field
decl_stmt|,
name|parent
decl_stmt|;
name|union
name|dnttentry
modifier|*
name|fieldp
decl_stmt|,
modifier|*
name|fn_fieldp
decl_stmt|,
modifier|*
name|parentp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|static_member
init|=
literal|0
decl_stmt|;
name|int
name|const_member
init|=
literal|0
decl_stmt|;
name|int
name|volatile_member
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|vtbl_offset
decl_stmt|;
name|int
name|need_bitvectors
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|method_name
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|method_alias
init|=
name|NULL
decl_stmt|;
comment|/* Is it something we've already dealt with?  */
name|type
operator|=
name|hpread_alloc_type
argument_list|(
name|hp_type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
operator|)
operator|||
operator|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_UNION
operator|)
operator|||
operator|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_CLASS
operator|)
operator|||
operator|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_TEMPLATE
operator|)
condition|)
return|return
name|type
return|;
comment|/* Get the basic type correct.  */
if|if
condition|(
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_STRUCT
condition|)
block|{
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_CODE_STRUCT
expr_stmt|;
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
name|dn_bufp
operator|->
name|dstruct
operator|.
name|bitlength
operator|/
literal|8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_UNION
condition|)
block|{
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_CODE_UNION
expr_stmt|;
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
name|dn_bufp
operator|->
name|dunion
operator|.
name|bitlength
operator|/
literal|8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_CLASS
condition|)
block|{
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_CODE_CLASS
expr_stmt|;
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
name|dn_bufp
operator|->
name|dclass
operator|.
name|bitlength
operator|/
literal|8
expr_stmt|;
comment|/* Overrides the TYPE_CPLUS_SPECIFIC(type) with allocated memory        * rather than&cplus_struct_default.        */
name|allocate_cplus_struct_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Fill in declared-type.        * (The C++ compiler will emit TYPE_CODE_CLASS         * for all 3 of "class", "struct"        * "union", and we have to look at the "class_decl" field if we        * want to know how it was really declared)        */
comment|/* (0==class, 1==union, 2==struct) */
name|TYPE_DECLARED_TYPE
argument_list|(
name|type
argument_list|)
operator|=
name|dn_bufp
operator|->
name|dclass
operator|.
name|class_decl
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_TEMPLATE
condition|)
block|{
comment|/* Get the basic type correct.  */
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_CODE_TEMPLATE
expr_stmt|;
name|allocate_cplus_struct_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_DECLARED_TYPE
argument_list|(
name|type
argument_list|)
operator|=
name|DECLARED_TYPE_TEMPLATE
expr_stmt|;
block|}
else|else
return|return
name|type
return|;
name|TYPE_FLAGS
argument_list|(
name|type
argument_list|)
operator|&=
operator|~
name|TYPE_FLAG_STUB
expr_stmt|;
comment|/* For classes, read the parent list.    * Question (RT): Do we need to do this for templates also?    */
if|if
condition|(
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_CLASS
condition|)
block|{
comment|/* First read the parent-list (classes from which we derive fields) */
name|parent
operator|=
name|dn_bufp
operator|->
name|dclass
operator|.
name|parentlist
expr_stmt|;
while|while
condition|(
name|parent
operator|.
name|word
operator|&&
name|parent
operator|.
name|word
operator|!=
name|DNTTNIL
condition|)
block|{
name|parentp
operator|=
name|hpread_get_lntt
argument_list|(
name|parent
operator|.
name|dnttp
operator|.
name|index
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* "parentp" should point to a DNTT_TYPE_INHERITANCE record */
comment|/* Get space to record the next field/data-member. */
name|new
operator|=
operator|(
expr|struct
name|nextfield
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nextfield
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|list
expr_stmt|;
name|list
operator|=
name|new
expr_stmt|;
name|FIELD_BITSIZE
argument_list|(
name|list
operator|->
name|field
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* The "classname" field is actually a DNTT pointer to the base class */
name|baseclass
operator|=
name|hpread_type_lookup
argument_list|(
name|parentp
operator|->
name|dinheritance
operator|.
name|classname
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|FIELD_TYPE
argument_list|(
name|list
operator|->
name|field
argument_list|)
operator|=
name|baseclass
expr_stmt|;
name|list
operator|->
name|field
operator|.
name|name
operator|=
name|type_name_no_tag
argument_list|(
name|FIELD_TYPE
argument_list|(
name|list
operator|->
name|field
argument_list|)
argument_list|)
expr_stmt|;
name|list
operator|->
name|attributes
operator|=
literal|0
expr_stmt|;
comment|/* Check for virtuality of base, and set the        * offset of the base subobject within the object.        * (Offset set to -1 for virtual bases (for now).)        */
if|if
condition|(
name|parentp
operator|->
name|dinheritance
operator|.
name|Virtual
condition|)
block|{
name|B_SET
argument_list|(
operator|&
operator|(
name|list
operator|->
name|attributes
operator|)
argument_list|,
name|ATTR_VIRTUAL
argument_list|)
expr_stmt|;
name|parentp
operator|->
name|dinheritance
operator|.
name|offset
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|FIELD_BITPOS
argument_list|(
name|list
operator|->
name|field
argument_list|)
operator|=
name|parentp
operator|->
name|dinheritance
operator|.
name|offset
expr_stmt|;
comment|/* Check visibility */
switch|switch
condition|(
name|parentp
operator|->
name|dinheritance
operator|.
name|visibility
condition|)
block|{
case|case
literal|1
case|:
name|B_SET
argument_list|(
operator|&
operator|(
name|list
operator|->
name|attributes
operator|)
argument_list|,
name|ATTR_PROTECT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|B_SET
argument_list|(
operator|&
operator|(
name|list
operator|->
name|attributes
operator|)
argument_list|,
name|ATTR_PRIVATE
argument_list|)
expr_stmt|;
break|break;
block|}
name|n_base_classes
operator|++
expr_stmt|;
name|nfields
operator|++
expr_stmt|;
name|parent
operator|=
name|parentp
operator|->
name|dinheritance
operator|.
name|next
expr_stmt|;
block|}
block|}
comment|/* For templates, read the template argument list.    * This must be done before processing the member list, because    * the member list may refer back to this. E.g.:    *   template<class T1, class T2> class q2 {    *     public:    *     T1 a;    *     T2 b;    *   };    * We need to read the argument list "T1", "T2" first.    */
if|if
condition|(
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_TEMPLATE
condition|)
block|{
comment|/* Kludge alert: This stuffs a global "current_template" which      * is referred to by hpread_get_nth_templ_arg(). The global      * is cleared at the end of this routine.      */
name|current_template
operator|=
name|type
expr_stmt|;
comment|/* Read in the argument list */
name|field
operator|=
name|dn_bufp
operator|->
name|dtemplate
operator|.
name|arglist
expr_stmt|;
while|while
condition|(
name|field
operator|.
name|word
operator|&&
name|field
operator|.
name|word
operator|!=
name|DNTTNIL
condition|)
block|{
comment|/* Get this template argument*/
name|fieldp
operator|=
name|hpread_get_lntt
argument_list|(
name|field
operator|.
name|dnttp
operator|.
name|index
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|fieldp
operator|->
name|dblock
operator|.
name|kind
operator|!=
name|DNTT_TYPE_TEMPLATE_ARG
condition|)
block|{
name|warning
argument_list|(
literal|"Invalid debug info: Template argument entry is of wrong kind"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Bump the count */
name|n_templ_args
operator|++
expr_stmt|;
comment|/* Allocate and fill in a struct next_template */
name|t_new
operator|=
operator|(
expr|struct
name|next_template
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|next_template
argument_list|)
argument_list|)
expr_stmt|;
name|t_new
operator|->
name|next
operator|=
name|t_list
expr_stmt|;
name|t_list
operator|=
name|t_new
expr_stmt|;
name|t_list
operator|->
name|arg
operator|.
name|name
operator|=
name|VT
argument_list|(
name|objfile
argument_list|)
operator|+
name|fieldp
operator|->
name|dtempl_arg
operator|.
name|name
expr_stmt|;
name|t_list
operator|->
name|arg
operator|.
name|type
operator|=
name|hpread_read_templ_arg_type
argument_list|(
name|field
argument_list|,
name|fieldp
argument_list|,
name|objfile
argument_list|,
name|t_list
operator|->
name|arg
operator|.
name|name
argument_list|)
expr_stmt|;
comment|/* Walk to the next template argument */
name|field
operator|=
name|fieldp
operator|->
name|dtempl_arg
operator|.
name|nextarg
expr_stmt|;
block|}
block|}
name|TYPE_NTEMPLATE_ARGS
argument_list|(
name|type
argument_list|)
operator|=
name|n_templ_args
expr_stmt|;
if|if
condition|(
name|n_templ_args
operator|>
literal|0
condition|)
name|TYPE_TEMPLATE_ARGS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
expr|struct
name|template_arg
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|type_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|template_arg
argument_list|)
operator|*
name|n_templ_args
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
name|n_templ_args
init|;
name|t_list
condition|;
name|t_list
operator|=
name|t_list
operator|->
name|next
control|)
block|{
name|n
operator|-=
literal|1
expr_stmt|;
name|TYPE_TEMPLATE_ARG
argument_list|(
name|type
argument_list|,
name|n
argument_list|)
operator|=
name|t_list
operator|->
name|arg
expr_stmt|;
block|}
comment|/* Next read in and internalize all the fields/members.  */
if|if
condition|(
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_STRUCT
condition|)
name|field
operator|=
name|dn_bufp
operator|->
name|dstruct
operator|.
name|firstfield
expr_stmt|;
elseif|else
if|if
condition|(
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_UNION
condition|)
name|field
operator|=
name|dn_bufp
operator|->
name|dunion
operator|.
name|firstfield
expr_stmt|;
elseif|else
if|if
condition|(
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_CLASS
condition|)
name|field
operator|=
name|dn_bufp
operator|->
name|dclass
operator|.
name|memberlist
expr_stmt|;
elseif|else
if|if
condition|(
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_TEMPLATE
condition|)
name|field
operator|=
name|dn_bufp
operator|->
name|dtemplate
operator|.
name|memberlist
expr_stmt|;
else|else
name|field
operator|.
name|word
operator|=
name|DNTTNIL
expr_stmt|;
while|while
condition|(
name|field
operator|.
name|word
operator|&&
name|field
operator|.
name|word
operator|!=
name|DNTTNIL
condition|)
block|{
name|fieldp
operator|=
name|hpread_get_lntt
argument_list|(
name|field
operator|.
name|dnttp
operator|.
name|index
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* At this point "fieldp" may point to either a DNTT_TYPE_FIELD        * or a DNTT_TYPE_GENFIELD record.         */
name|vtbl_offset
operator|=
literal|0
expr_stmt|;
name|static_member
operator|=
literal|0
expr_stmt|;
name|const_member
operator|=
literal|0
expr_stmt|;
name|volatile_member
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fieldp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_GENFIELD
condition|)
block|{
comment|/* The type will be GENFIELD if the field is a method or          * a static member (or some other cases -- see below)          */
comment|/* Follow a link to get to the record for the field. */
name|fn_field
operator|=
name|fieldp
operator|->
name|dgenfield
operator|.
name|field
expr_stmt|;
name|fn_fieldp
operator|=
name|hpread_get_lntt
argument_list|(
name|fn_field
operator|.
name|dnttp
operator|.
name|index
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* Virtual funcs are indicated by a VFUNC which points to the          * real entry          */
if|if
condition|(
name|fn_fieldp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_VFUNC
condition|)
block|{
name|vtbl_offset
operator|=
name|fn_fieldp
operator|->
name|dvfunc
operator|.
name|vtbl_offset
expr_stmt|;
name|fn_field
operator|=
name|fn_fieldp
operator|->
name|dvfunc
operator|.
name|funcptr
expr_stmt|;
name|fn_fieldp
operator|=
name|hpread_get_lntt
argument_list|(
name|fn_field
operator|.
name|dnttp
operator|.
name|index
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
comment|/* A function's entry may be preceded by a modifier which          * labels it static/constant/volatile.          */
if|if
condition|(
name|fn_fieldp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_MODIFIER
condition|)
block|{
name|static_member
operator|=
name|fn_fieldp
operator|->
name|dmodifier
operator|.
name|m_static
expr_stmt|;
name|const_member
operator|=
name|fn_fieldp
operator|->
name|dmodifier
operator|.
name|m_const
expr_stmt|;
name|volatile_member
operator|=
name|fn_fieldp
operator|->
name|dmodifier
operator|.
name|m_volatile
expr_stmt|;
name|fn_field
operator|=
name|fn_fieldp
operator|->
name|dmodifier
operator|.
name|type
expr_stmt|;
name|fn_fieldp
operator|=
name|hpread_get_lntt
argument_list|(
name|fn_field
operator|.
name|dnttp
operator|.
name|index
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
comment|/* Check whether we have a method */
if|if
condition|(
operator|(
name|fn_fieldp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_MEMFUNC
operator|)
operator|||
operator|(
name|fn_fieldp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_FUNCTION
operator|)
operator|||
operator|(
name|fn_fieldp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_DOC_MEMFUNC
operator|)
operator|||
operator|(
name|fn_fieldp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_DOC_FUNCTION
operator|)
condition|)
block|{
comment|/* Method found */
name|short
name|ix
init|=
literal|0
decl_stmt|;
comment|/* Look up function type of method */
name|memtype
operator|=
name|hpread_type_lookup
argument_list|(
name|fn_field
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* Methods can be seen before classes in the SOM records.              If we are processing this class because it's a parameter of a              method, at this point the method's type is actually incomplete;              we'll have to fix it up later; mark the class for this. */
if|if
condition|(
name|TYPE_INCOMPLETE
argument_list|(
name|memtype
argument_list|)
condition|)
block|{
name|TYPE_FLAGS
argument_list|(
name|type
argument_list|)
operator||=
name|TYPE_FLAG_INCOMPLETE
expr_stmt|;
if|if
condition|(
name|fixup_class
condition|)
name|warning
argument_list|(
literal|"Two classes to fix up for method??  Type information may be incorrect for some classes."
argument_list|)
expr_stmt|;
if|if
condition|(
name|fixup_method
condition|)
name|warning
argument_list|(
literal|"Two methods to be fixed up at once?? Type information may be incorrect for some classes."
argument_list|)
expr_stmt|;
name|fixup_class
operator|=
name|type
expr_stmt|;
comment|/* remember this class has to be fixed up */
name|fixup_method
operator|=
name|memtype
expr_stmt|;
comment|/* remember the method type to be used in fixup */
block|}
comment|/* HP aCC generates operator names without the "operator" keyword, and              generates null strings as names for operators that are               user-defined type conversions to basic types (e.g. operator int ()).              So try to reconstruct name as best as possible. */
name|method_name
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|VT
argument_list|(
name|objfile
argument_list|)
operator|+
name|fn_fieldp
operator|->
name|dfunc
operator|.
name|name
operator|)
expr_stmt|;
name|method_alias
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|VT
argument_list|(
name|objfile
argument_list|)
operator|+
name|fn_fieldp
operator|->
name|dfunc
operator|.
name|alias
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|method_name
operator|||
comment|/* no name */
operator|!
operator|*
name|method_name
operator|||
comment|/* or null name */
name|cplus_mangle_opname
argument_list|(
name|method_name
argument_list|,
name|DMGL_ANSI
argument_list|)
condition|)
comment|/* or name is an operator like "<" */
block|{
name|char
modifier|*
name|tmp_name
init|=
name|cplus_demangle
argument_list|(
name|method_alias
argument_list|,
name|DMGL_ANSI
argument_list|)
decl_stmt|;
name|char
modifier|*
name|op_string
init|=
name|strstr
argument_list|(
name|tmp_name
argument_list|,
literal|"operator"
argument_list|)
decl_stmt|;
name|method_name
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|op_string
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* don't overwrite VT! */
name|strcpy
argument_list|(
name|method_name
argument_list|,
name|op_string
argument_list|)
expr_stmt|;
block|}
comment|/* First check if a method of the same name has already been seen. */
name|fn_p
operator|=
name|fn_list
expr_stmt|;
while|while
condition|(
name|fn_p
condition|)
block|{
if|if
condition|(
name|STREQ
argument_list|(
name|fn_p
operator|->
name|field
operator|.
name|name
argument_list|,
name|method_name
argument_list|)
condition|)
break|break;
name|fn_p
operator|=
name|fn_p
operator|->
name|next
expr_stmt|;
block|}
comment|/* If no such method was found, allocate a new entry in the list */
if|if
condition|(
operator|!
name|fn_p
condition|)
block|{
comment|/* Get space to record this member function */
comment|/* Note: alloca used; this will disappear on routine exit */
name|fn_new
operator|=
operator|(
expr|struct
name|next_fn_field
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|next_fn_field
argument_list|)
argument_list|)
expr_stmt|;
name|fn_new
operator|->
name|next
operator|=
name|fn_list
expr_stmt|;
name|fn_list
operator|=
name|fn_new
expr_stmt|;
comment|/* Fill in the fields of the struct nextfield */
comment|/* Record the (unmangled) method name */
name|fn_list
operator|->
name|field
operator|.
name|name
operator|=
name|method_name
expr_stmt|;
comment|/* Initial space for overloaded methods */
comment|/* Note: xmalloc is used; this will persist after this routine exits */
name|fn_list
operator|->
name|field
operator|.
name|fn_fields
operator|=
operator|(
expr|struct
name|fn_field
operator|*
operator|)
name|xmalloc
argument_list|(
literal|5
operator|*
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|fn_field
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|fn_list
operator|->
name|field
operator|.
name|length
operator|=
literal|1
expr_stmt|;
comment|/* Init # of overloaded instances */
name|fn_list
operator|->
name|num_fn_fields
operator|=
literal|5
expr_stmt|;
comment|/* # of entries for which space allocated */
name|fn_p
operator|=
name|fn_list
expr_stmt|;
name|ix
operator|=
literal|0
expr_stmt|;
comment|/* array index for fn_field */
comment|/* Bump the total count of the distinctly named methods */
name|n_fn_fields
operator|++
expr_stmt|;
block|}
else|else
comment|/* Another overloaded instance of an already seen method name */
block|{
if|if
condition|(
operator|++
operator|(
name|fn_p
operator|->
name|field
operator|.
name|length
operator|)
operator|>
name|fn_p
operator|->
name|num_fn_fields
condition|)
block|{
comment|/* Increase space allocated for overloaded instances */
name|fn_p
operator|->
name|field
operator|.
name|fn_fields
operator|=
operator|(
expr|struct
name|fn_field
operator|*
operator|)
name|xrealloc
argument_list|(
name|fn_p
operator|->
name|field
operator|.
name|fn_fields
argument_list|,
operator|(
name|fn_p
operator|->
name|num_fn_fields
operator|+
literal|5
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|fn_field
argument_list|)
argument_list|)
expr_stmt|;
name|fn_p
operator|->
name|num_fn_fields
operator|+=
literal|5
expr_stmt|;
block|}
name|ix
operator|=
name|fn_p
operator|->
name|field
operator|.
name|length
operator|-
literal|1
expr_stmt|;
comment|/* array index for fn_field */
block|}
comment|/* "physname" is intended to be the name of this overloaded instance. */
if|if
condition|(
operator|(
name|fn_fieldp
operator|->
name|dfunc
operator|.
name|language
operator|==
name|HP_LANGUAGE_CPLUSPLUS
operator|)
operator|&&
name|method_alias
operator|&&
operator|*
name|method_alias
condition|)
comment|/* not a null string */
name|fn_p
operator|->
name|field
operator|.
name|fn_fields
index|[
name|ix
index|]
operator|.
name|physname
operator|=
name|method_alias
expr_stmt|;
else|else
name|fn_p
operator|->
name|field
operator|.
name|fn_fields
index|[
name|ix
index|]
operator|.
name|physname
operator|=
name|method_name
expr_stmt|;
comment|/* What's expected here is the function type */
comment|/* But mark it as NULL if the method was incompletely processed              We'll fix this up later when the method is fully processed */
if|if
condition|(
name|TYPE_INCOMPLETE
argument_list|(
name|memtype
argument_list|)
condition|)
block|{
name|fn_p
operator|->
name|field
operator|.
name|fn_fields
index|[
name|ix
index|]
operator|.
name|type
operator|=
name|NULL
expr_stmt|;
name|fn_p
operator|->
name|field
operator|.
name|fn_fields
index|[
name|ix
index|]
operator|.
name|args
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|fn_p
operator|->
name|field
operator|.
name|fn_fields
index|[
name|ix
index|]
operator|.
name|type
operator|=
name|memtype
expr_stmt|;
comment|/* The argument list */
name|fn_p
operator|->
name|field
operator|.
name|fn_fields
index|[
name|ix
index|]
operator|.
name|type
operator|->
name|type_specific
operator|.
name|arg_types
operator|=
operator|(
expr|struct
name|type
operator|*
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|type_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
operator|*
operator|(
name|memtype
operator|->
name|nfields
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|memtype
operator|->
name|nfields
condition|;
name|i
operator|++
control|)
name|fn_p
operator|->
name|field
operator|.
name|fn_fields
index|[
name|ix
index|]
operator|.
name|type
operator|->
name|type_specific
operator|.
name|arg_types
index|[
name|i
index|]
operator|=
name|memtype
operator|->
name|fields
index|[
name|i
index|]
operator|.
name|type
expr_stmt|;
comment|/* void termination */
name|fn_p
operator|->
name|field
operator|.
name|fn_fields
index|[
name|ix
index|]
operator|.
name|type
operator|->
name|type_specific
operator|.
name|arg_types
index|[
name|memtype
operator|->
name|nfields
index|]
operator|=
name|builtin_type_void
expr_stmt|;
comment|/* pai: It's not clear why this args field has to be set.  Perhaps                * it should be eliminated entirely. */
name|fn_p
operator|->
name|field
operator|.
name|fn_fields
index|[
name|ix
index|]
operator|.
name|args
operator|=
operator|(
expr|struct
name|type
operator|*
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|type_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
operator|*
operator|(
name|memtype
operator|->
name|nfields
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|memtype
operator|->
name|nfields
condition|;
name|i
operator|++
control|)
name|fn_p
operator|->
name|field
operator|.
name|fn_fields
index|[
name|ix
index|]
operator|.
name|args
index|[
name|i
index|]
operator|=
name|memtype
operator|->
name|fields
index|[
name|i
index|]
operator|.
name|type
expr_stmt|;
comment|/* null-terminated, unlike arg_types above e*/
name|fn_p
operator|->
name|field
operator|.
name|fn_fields
index|[
name|ix
index|]
operator|.
name|args
index|[
name|memtype
operator|->
name|nfields
index|]
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* For virtual functions, fill in the voffset field with the            * virtual table offset. (This is just copied over from the            * SOM record; not sure if it is what GDB expects here...).            * But if the function is a static method, set it to 1.            *             * Note that we have to add 1 because 1 indicates a static            * method, and 0 indicates a non-static, non-virtual method */
if|if
condition|(
name|static_member
condition|)
name|fn_p
operator|->
name|field
operator|.
name|fn_fields
index|[
name|ix
index|]
operator|.
name|voffset
operator|=
name|VOFFSET_STATIC
expr_stmt|;
else|else
name|fn_p
operator|->
name|field
operator|.
name|fn_fields
index|[
name|ix
index|]
operator|.
name|voffset
operator|=
name|vtbl_offset
condition|?
name|vtbl_offset
operator|+
literal|1
else|:
literal|0
expr_stmt|;
comment|/* Also fill in the fcontext field with the current            * class. (The latter isn't quite right: should be the baseclass            * that defines the virtual function... Note we do have            * a variable "baseclass" that we could stuff into the fcontext            * field, but "baseclass" isn't necessarily right either,            * since the virtual function could have been defined more            * than one level up).            */
if|if
condition|(
name|vtbl_offset
operator|!=
literal|0
condition|)
name|fn_p
operator|->
name|field
operator|.
name|fn_fields
index|[
name|ix
index|]
operator|.
name|fcontext
operator|=
name|type
expr_stmt|;
else|else
name|fn_p
operator|->
name|field
operator|.
name|fn_fields
index|[
name|ix
index|]
operator|.
name|fcontext
operator|=
name|NULL
expr_stmt|;
comment|/* Other random fields pertaining to this method */
name|fn_p
operator|->
name|field
operator|.
name|fn_fields
index|[
name|ix
index|]
operator|.
name|is_const
operator|=
name|const_member
expr_stmt|;
name|fn_p
operator|->
name|field
operator|.
name|fn_fields
index|[
name|ix
index|]
operator|.
name|is_volatile
operator|=
name|volatile_member
expr_stmt|;
comment|/* ?? */
switch|switch
condition|(
name|fieldp
operator|->
name|dgenfield
operator|.
name|visibility
condition|)
block|{
case|case
literal|1
case|:
name|fn_p
operator|->
name|field
operator|.
name|fn_fields
index|[
name|ix
index|]
operator|.
name|is_protected
operator|=
literal|1
expr_stmt|;
name|fn_p
operator|->
name|field
operator|.
name|fn_fields
index|[
name|ix
index|]
operator|.
name|is_private
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|fn_p
operator|->
name|field
operator|.
name|fn_fields
index|[
name|ix
index|]
operator|.
name|is_protected
operator|=
literal|0
expr_stmt|;
name|fn_p
operator|->
name|field
operator|.
name|fn_fields
index|[
name|ix
index|]
operator|.
name|is_private
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
comment|/* public */
name|fn_p
operator|->
name|field
operator|.
name|fn_fields
index|[
name|ix
index|]
operator|.
name|is_protected
operator|=
literal|0
expr_stmt|;
name|fn_p
operator|->
name|field
operator|.
name|fn_fields
index|[
name|ix
index|]
operator|.
name|is_private
operator|=
literal|0
expr_stmt|;
block|}
name|fn_p
operator|->
name|field
operator|.
name|fn_fields
index|[
name|ix
index|]
operator|.
name|is_stub
operator|=
literal|0
expr_stmt|;
comment|/* HP aCC emits both MEMFUNC and FUNCTION entries for a method;              if the class points to the FUNCTION, there is usually separate              code for the method; but if we have a MEMFUNC, the method has              been inlined (and there is usually no FUNCTION entry)              FIXME Not sure if this test is accurate. pai/1997-08-22 */
if|if
condition|(
operator|(
name|fn_fieldp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_MEMFUNC
operator|)
operator|||
operator|(
name|fn_fieldp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_DOC_MEMFUNC
operator|)
condition|)
name|fn_p
operator|->
name|field
operator|.
name|fn_fields
index|[
name|ix
index|]
operator|.
name|is_inlined
operator|=
literal|1
expr_stmt|;
else|else
name|fn_p
operator|->
name|field
operator|.
name|fn_fields
index|[
name|ix
index|]
operator|.
name|is_inlined
operator|=
literal|0
expr_stmt|;
name|fn_p
operator|->
name|field
operator|.
name|fn_fields
index|[
name|ix
index|]
operator|.
name|dummy
operator|=
literal|0
expr_stmt|;
comment|/* Bump the total count of the member functions */
name|n_fn_fields_total
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fn_fieldp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_SVAR
condition|)
block|{
comment|/* This case is for static data members of classes */
comment|/* pai:: FIXME -- check that "staticmem" bit is set */
comment|/* Get space to record this static member */
name|new
operator|=
operator|(
expr|struct
name|nextfield
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nextfield
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|list
expr_stmt|;
name|list
operator|=
name|new
expr_stmt|;
name|list
operator|->
name|field
operator|.
name|name
operator|=
name|VT
argument_list|(
name|objfile
argument_list|)
operator|+
name|fn_fieldp
operator|->
name|dsvar
operator|.
name|name
expr_stmt|;
name|FIELD_BITSIZE
argument_list|(
name|list
operator|->
name|field
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* indicates static member */
name|SET_FIELD_PHYSNAME
argument_list|(
name|list
operator|->
name|field
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* initialize to empty */
name|memtype
operator|=
name|hpread_type_lookup
argument_list|(
name|fn_fieldp
operator|->
name|dsvar
operator|.
name|type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|FIELD_TYPE
argument_list|(
name|list
operator|->
name|field
argument_list|)
operator|=
name|memtype
expr_stmt|;
name|list
operator|->
name|attributes
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|fieldp
operator|->
name|dgenfield
operator|.
name|visibility
condition|)
block|{
case|case
literal|1
case|:
name|B_SET
argument_list|(
operator|&
operator|(
name|list
operator|->
name|attributes
operator|)
argument_list|,
name|ATTR_PROTECT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|B_SET
argument_list|(
operator|&
operator|(
name|list
operator|->
name|attributes
operator|)
argument_list|,
name|ATTR_PRIVATE
argument_list|)
expr_stmt|;
break|break;
block|}
name|nfields
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fn_fieldp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_FIELD
condition|)
block|{
comment|/* FIELDs follow GENFIELDs for fields of anonymous unions.                Code below is replicated from the case for FIELDs further                below, except that fieldp is replaced by fn_fieldp */
if|if
condition|(
operator|!
name|fn_fieldp
operator|->
name|dfield
operator|.
name|a_union
condition|)
name|warning
argument_list|(
literal|"Debug info inconsistent: FIELD of anonymous union doesn't have a_union bit set"
argument_list|)
expr_stmt|;
comment|/* Get space to record the next field/data-member. */
name|new
operator|=
operator|(
expr|struct
name|nextfield
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nextfield
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|list
expr_stmt|;
name|list
operator|=
name|new
expr_stmt|;
name|list
operator|->
name|field
operator|.
name|name
operator|=
name|VT
argument_list|(
name|objfile
argument_list|)
operator|+
name|fn_fieldp
operator|->
name|dfield
operator|.
name|name
expr_stmt|;
name|FIELD_BITPOS
argument_list|(
name|list
operator|->
name|field
argument_list|)
operator|=
name|fn_fieldp
operator|->
name|dfield
operator|.
name|bitoffset
expr_stmt|;
if|if
condition|(
name|fn_fieldp
operator|->
name|dfield
operator|.
name|bitlength
operator|%
literal|8
condition|)
name|list
operator|->
name|field
operator|.
name|bitsize
operator|=
name|fn_fieldp
operator|->
name|dfield
operator|.
name|bitlength
expr_stmt|;
else|else
name|list
operator|->
name|field
operator|.
name|bitsize
operator|=
literal|0
expr_stmt|;
name|memtype
operator|=
name|hpread_type_lookup
argument_list|(
name|fn_fieldp
operator|->
name|dfield
operator|.
name|type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|list
operator|->
name|field
operator|.
name|type
operator|=
name|memtype
expr_stmt|;
name|list
operator|->
name|attributes
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|fn_fieldp
operator|->
name|dfield
operator|.
name|visibility
condition|)
block|{
case|case
literal|1
case|:
name|B_SET
argument_list|(
operator|&
operator|(
name|list
operator|->
name|attributes
operator|)
argument_list|,
name|ATTR_PROTECT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|B_SET
argument_list|(
operator|&
operator|(
name|list
operator|->
name|attributes
operator|)
argument_list|,
name|ATTR_PRIVATE
argument_list|)
expr_stmt|;
break|break;
block|}
name|nfields
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fn_fieldp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_SVAR
condition|)
block|{
comment|/* Field of anonymous union; union is not inside a class */
if|if
condition|(
operator|!
name|fn_fieldp
operator|->
name|dsvar
operator|.
name|a_union
condition|)
name|warning
argument_list|(
literal|"Debug info inconsistent: SVAR field in anonymous union doesn't have a_union bit set"
argument_list|)
expr_stmt|;
comment|/* Get space to record the next field/data-member. */
name|new
operator|=
operator|(
expr|struct
name|nextfield
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nextfield
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|list
expr_stmt|;
name|list
operator|=
name|new
expr_stmt|;
name|list
operator|->
name|field
operator|.
name|name
operator|=
name|VT
argument_list|(
name|objfile
argument_list|)
operator|+
name|fn_fieldp
operator|->
name|dsvar
operator|.
name|name
expr_stmt|;
name|FIELD_BITPOS
argument_list|(
name|list
operator|->
name|field
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* FIXME is this always true? */
name|FIELD_BITSIZE
argument_list|(
name|list
operator|->
name|field
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* use length from type */
name|memtype
operator|=
name|hpread_type_lookup
argument_list|(
name|fn_fieldp
operator|->
name|dsvar
operator|.
name|type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|list
operator|->
name|field
operator|.
name|type
operator|=
name|memtype
expr_stmt|;
name|list
operator|->
name|attributes
operator|=
literal|0
expr_stmt|;
comment|/* No info to set visibility -- always public */
name|nfields
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fn_fieldp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_DVAR
condition|)
block|{
comment|/* Field of anonymous union; union is not inside a class */
if|if
condition|(
operator|!
name|fn_fieldp
operator|->
name|ddvar
operator|.
name|a_union
condition|)
name|warning
argument_list|(
literal|"Debug info inconsistent: DVAR field in anonymous union doesn't have a_union bit set"
argument_list|)
expr_stmt|;
comment|/* Get space to record the next field/data-member. */
name|new
operator|=
operator|(
expr|struct
name|nextfield
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nextfield
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|list
expr_stmt|;
name|list
operator|=
name|new
expr_stmt|;
name|list
operator|->
name|field
operator|.
name|name
operator|=
name|VT
argument_list|(
name|objfile
argument_list|)
operator|+
name|fn_fieldp
operator|->
name|ddvar
operator|.
name|name
expr_stmt|;
name|FIELD_BITPOS
argument_list|(
name|list
operator|->
name|field
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* FIXME is this always true? */
name|FIELD_BITSIZE
argument_list|(
name|list
operator|->
name|field
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* use length from type */
name|memtype
operator|=
name|hpread_type_lookup
argument_list|(
name|fn_fieldp
operator|->
name|ddvar
operator|.
name|type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|list
operator|->
name|field
operator|.
name|type
operator|=
name|memtype
expr_stmt|;
name|list
operator|->
name|attributes
operator|=
literal|0
expr_stmt|;
comment|/* No info to set visibility -- always public */
name|nfields
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* Not a method, nor a static data member, nor an anon union field */
comment|/* This case is for miscellaneous type entries (local enums,              local function templates, etc.) that can be present              inside a class. */
comment|/* Enums -- will be handled by other code that takes care              of DNTT_TYPE_ENUM; here we see only DNTT_TYPE_MEMENUM so              it's not clear we could have handled them here at all. */
comment|/* FUNC_TEMPLATE: is handled by other code (??). */
comment|/* MEMACCESS: modified access for inherited member. Not              sure what to do with this, ignoriing it at present. */
comment|/* What other entries can appear following a GENFIELD which              we do not handle above?  (MODIFIER, VFUNC handled above.) */
if|if
condition|(
operator|(
name|fn_fieldp
operator|->
name|dblock
operator|.
name|kind
operator|!=
name|DNTT_TYPE_MEMACCESS
operator|)
operator|&&
operator|(
name|fn_fieldp
operator|->
name|dblock
operator|.
name|kind
operator|!=
name|DNTT_TYPE_MEMENUM
operator|)
operator|&&
operator|(
name|fn_fieldp
operator|->
name|dblock
operator|.
name|kind
operator|!=
name|DNTT_TYPE_FUNC_TEMPLATE
operator|)
condition|)
name|warning
argument_list|(
literal|"Internal error: Unexpected debug record kind %d found following DNTT_GENFIELD"
argument_list|,
name|fn_fieldp
operator|->
name|dblock
operator|.
name|kind
argument_list|)
expr_stmt|;
block|}
comment|/* walk to the next FIELD or GENFIELD */
name|field
operator|=
name|fieldp
operator|->
name|dgenfield
operator|.
name|nextfield
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fieldp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_FIELD
condition|)
block|{
comment|/* Ordinary structure/union/class field */
name|struct
name|type
modifier|*
name|anon_union_type
decl_stmt|;
comment|/* Get space to record the next field/data-member. */
name|new
operator|=
operator|(
expr|struct
name|nextfield
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nextfield
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|list
expr_stmt|;
name|list
operator|=
name|new
expr_stmt|;
name|list
operator|->
name|field
operator|.
name|name
operator|=
name|VT
argument_list|(
name|objfile
argument_list|)
operator|+
name|fieldp
operator|->
name|dfield
operator|.
name|name
expr_stmt|;
comment|/* A FIELD by itself (without a GENFIELD) can also be a static member */
if|if
condition|(
name|fieldp
operator|->
name|dfield
operator|.
name|staticmem
condition|)
block|{
name|FIELD_BITPOS
argument_list|(
name|list
operator|->
name|field
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
name|FIELD_BITSIZE
argument_list|(
name|list
operator|->
name|field
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
else|else
comment|/* Non-static data member */
block|{
name|FIELD_BITPOS
argument_list|(
name|list
operator|->
name|field
argument_list|)
operator|=
name|fieldp
operator|->
name|dfield
operator|.
name|bitoffset
expr_stmt|;
if|if
condition|(
name|fieldp
operator|->
name|dfield
operator|.
name|bitlength
operator|%
literal|8
condition|)
name|FIELD_BITSIZE
argument_list|(
name|list
operator|->
name|field
argument_list|)
operator|=
name|fieldp
operator|->
name|dfield
operator|.
name|bitlength
expr_stmt|;
else|else
name|FIELD_BITSIZE
argument_list|(
name|list
operator|->
name|field
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
name|memtype
operator|=
name|hpread_type_lookup
argument_list|(
name|fieldp
operator|->
name|dfield
operator|.
name|type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|FIELD_TYPE
argument_list|(
name|list
operator|->
name|field
argument_list|)
operator|=
name|memtype
expr_stmt|;
name|list
operator|->
name|attributes
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|fieldp
operator|->
name|dfield
operator|.
name|visibility
condition|)
block|{
case|case
literal|1
case|:
name|B_SET
argument_list|(
operator|&
operator|(
name|list
operator|->
name|attributes
operator|)
argument_list|,
name|ATTR_PROTECT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|B_SET
argument_list|(
operator|&
operator|(
name|list
operator|->
name|attributes
operator|)
argument_list|,
name|ATTR_PRIVATE
argument_list|)
expr_stmt|;
break|break;
block|}
name|nfields
operator|++
expr_stmt|;
comment|/* Note 1: First, we have to check if the current field is an anonymous            union. If it is, then *its* fields are threaded along in the            nextfield chain. :-( This was supposed to help debuggers, but is            really just a nuisance since we deal with anonymous unions anyway by            checking that the name is null.  So anyway, we skip over the fields            of the anonymous union. pai/1997-08-22 */
comment|/* Note 2: In addition, the bitoffsets for the fields of the anon union            are relative to the enclosing struct, *NOT* relative to the anon            union!  This is an even bigger nuisance -- we have to go in and munge            the anon union's type information appropriately. pai/1997-08-22 */
comment|/* Both tasks noted above are done by a separate function.  This takes us            to the next FIELD or GENFIELD, skipping anon unions, and recursively            processing intermediate types. */
name|field
operator|=
name|hpread_get_next_skip_over_anon_unions
argument_list|(
literal|1
argument_list|,
name|field
argument_list|,
operator|&
name|fieldp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* neither field nor genfield ?? is this possible?? */
comment|/* pai:: FIXME walk to the next -- how? */
name|warning
argument_list|(
literal|"Internal error: unexpected DNTT kind %d encountered as field of struct"
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"Skipping remaining fields of struct"
argument_list|)
expr_stmt|;
break|break;
comment|/* get out of loop of fields */
block|}
block|}
comment|/* If it's a template, read in the instantiation list */
if|if
condition|(
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_TEMPLATE
condition|)
block|{
name|ninstantiations
operator|=
literal|0
expr_stmt|;
name|field
operator|=
name|dn_bufp
operator|->
name|dtemplate
operator|.
name|expansions
expr_stmt|;
while|while
condition|(
name|field
operator|.
name|word
operator|&&
name|field
operator|.
name|word
operator|!=
name|DNTTNIL
condition|)
block|{
name|fieldp
operator|=
name|hpread_get_lntt
argument_list|(
name|field
operator|.
name|dnttp
operator|.
name|index
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* The expansions or nextexp should point to a tagdef */
if|if
condition|(
name|fieldp
operator|->
name|dblock
operator|.
name|kind
operator|!=
name|DNTT_TYPE_TAGDEF
condition|)
break|break;
name|i_new
operator|=
operator|(
expr|struct
name|next_instantiation
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|next_instantiation
argument_list|)
argument_list|)
expr_stmt|;
name|i_new
operator|->
name|next
operator|=
name|i_list
expr_stmt|;
name|i_list
operator|=
name|i_new
expr_stmt|;
name|i_list
operator|->
name|t
operator|=
name|hpread_type_lookup
argument_list|(
name|field
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|ninstantiations
operator|++
expr_stmt|;
comment|/* And the "type" field of that should point to a class */
name|field
operator|=
name|fieldp
operator|->
name|dtag
operator|.
name|type
expr_stmt|;
name|fieldp
operator|=
name|hpread_get_lntt
argument_list|(
name|field
operator|.
name|dnttp
operator|.
name|index
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|fieldp
operator|->
name|dblock
operator|.
name|kind
operator|!=
name|DNTT_TYPE_CLASS
condition|)
break|break;
comment|/* Get the next expansion */
name|field
operator|=
name|fieldp
operator|->
name|dclass
operator|.
name|nextexp
expr_stmt|;
block|}
block|}
name|TYPE_NINSTANTIATIONS
argument_list|(
name|type
argument_list|)
operator|=
name|ninstantiations
expr_stmt|;
if|if
condition|(
name|ninstantiations
operator|>
literal|0
condition|)
name|TYPE_INSTANTIATIONS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
expr|struct
name|type
operator|*
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|type_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
operator|*
name|ninstantiations
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
name|ninstantiations
init|;
name|i_list
condition|;
name|i_list
operator|=
name|i_list
operator|->
name|next
control|)
block|{
name|n
operator|-=
literal|1
expr_stmt|;
name|TYPE_INSTANTIATION
argument_list|(
name|type
argument_list|,
name|n
argument_list|)
operator|=
name|i_list
operator|->
name|t
expr_stmt|;
block|}
comment|/* Copy the field-list to GDB's symbol table */
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|=
name|nfields
expr_stmt|;
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
operator|=
name|n_base_classes
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
expr|struct
name|field
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|type_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
operator|*
name|nfields
argument_list|)
expr_stmt|;
comment|/* Copy the saved-up fields into the field vector.  */
for|for
control|(
name|n
operator|=
name|nfields
operator|,
name|tmp_list
operator|=
name|list
init|;
name|tmp_list
condition|;
name|tmp_list
operator|=
name|tmp_list
operator|->
name|next
control|)
block|{
name|n
operator|-=
literal|1
expr_stmt|;
name|TYPE_FIELD
argument_list|(
name|type
argument_list|,
name|n
argument_list|)
operator|=
name|tmp_list
operator|->
name|field
expr_stmt|;
block|}
comment|/* Copy the "function-field-list" (i.e., the list of member    * functions in the class) to GDB's symbol table     */
name|TYPE_NFN_FIELDS
argument_list|(
name|type
argument_list|)
operator|=
name|n_fn_fields
expr_stmt|;
name|TYPE_NFN_FIELDS_TOTAL
argument_list|(
name|type
argument_list|)
operator|=
name|n_fn_fields_total
expr_stmt|;
name|TYPE_FN_FIELDLISTS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
expr|struct
name|fn_fieldlist
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|type_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|fn_fieldlist
argument_list|)
operator|*
name|n_fn_fields
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
name|n_fn_fields
init|;
name|fn_list
condition|;
name|fn_list
operator|=
name|fn_list
operator|->
name|next
control|)
block|{
name|n
operator|-=
literal|1
expr_stmt|;
name|TYPE_FN_FIELDLIST
argument_list|(
name|type
argument_list|,
name|n
argument_list|)
operator|=
name|fn_list
operator|->
name|field
expr_stmt|;
block|}
comment|/* pai:: FIXME -- perhaps each bitvector should be created individually */
for|for
control|(
name|n
operator|=
name|nfields
operator|,
name|tmp_list
operator|=
name|list
init|;
name|tmp_list
condition|;
name|tmp_list
operator|=
name|tmp_list
operator|->
name|next
control|)
block|{
name|n
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
name|tmp_list
operator|->
name|attributes
condition|)
block|{
name|need_bitvectors
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|need_bitvectors
condition|)
block|{
comment|/* pai:: this step probably redundant */
name|ALLOCATE_CPLUS_STRUCT_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_FIELD_VIRTUAL_BITS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
name|B_TYPE
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|type
argument_list|,
name|B_BYTES
argument_list|(
name|nfields
argument_list|)
argument_list|)
expr_stmt|;
name|B_CLRALL
argument_list|(
name|TYPE_FIELD_VIRTUAL_BITS
argument_list|(
name|type
argument_list|)
argument_list|,
name|nfields
argument_list|)
expr_stmt|;
name|TYPE_FIELD_PRIVATE_BITS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
name|B_TYPE
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|type
argument_list|,
name|B_BYTES
argument_list|(
name|nfields
argument_list|)
argument_list|)
expr_stmt|;
name|B_CLRALL
argument_list|(
name|TYPE_FIELD_PRIVATE_BITS
argument_list|(
name|type
argument_list|)
argument_list|,
name|nfields
argument_list|)
expr_stmt|;
name|TYPE_FIELD_PROTECTED_BITS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
name|B_TYPE
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|type
argument_list|,
name|B_BYTES
argument_list|(
name|nfields
argument_list|)
argument_list|)
expr_stmt|;
name|B_CLRALL
argument_list|(
name|TYPE_FIELD_PROTECTED_BITS
argument_list|(
name|type
argument_list|)
argument_list|,
name|nfields
argument_list|)
expr_stmt|;
comment|/* this field vector isn't actually used with HP aCC */
name|TYPE_FIELD_IGNORE_BITS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
name|B_TYPE
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|type
argument_list|,
name|B_BYTES
argument_list|(
name|nfields
argument_list|)
argument_list|)
expr_stmt|;
name|B_CLRALL
argument_list|(
name|TYPE_FIELD_IGNORE_BITS
argument_list|(
name|type
argument_list|)
argument_list|,
name|nfields
argument_list|)
expr_stmt|;
while|while
condition|(
name|nfields
operator|--
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|B_TST
argument_list|(
operator|&
operator|(
name|list
operator|->
name|attributes
operator|)
argument_list|,
name|ATTR_VIRTUAL
argument_list|)
condition|)
name|SET_TYPE_FIELD_VIRTUAL
argument_list|(
name|type
argument_list|,
name|nfields
argument_list|)
expr_stmt|;
if|if
condition|(
name|B_TST
argument_list|(
operator|&
operator|(
name|list
operator|->
name|attributes
operator|)
argument_list|,
name|ATTR_PRIVATE
argument_list|)
condition|)
name|SET_TYPE_FIELD_PRIVATE
argument_list|(
name|type
argument_list|,
name|nfields
argument_list|)
expr_stmt|;
if|if
condition|(
name|B_TST
argument_list|(
operator|&
operator|(
name|list
operator|->
name|attributes
operator|)
argument_list|,
name|ATTR_PROTECT
argument_list|)
condition|)
name|SET_TYPE_FIELD_PROTECTED
argument_list|(
name|type
argument_list|,
name|nfields
argument_list|)
expr_stmt|;
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
block|}
block|}
else|else
block|{
name|TYPE_FIELD_VIRTUAL_BITS
argument_list|(
name|type
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|TYPE_FIELD_PROTECTED_BITS
argument_list|(
name|type
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|TYPE_FIELD_PRIVATE_BITS
argument_list|(
name|type
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|has_vtable
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* Allocate space for class runtime information */
name|TYPE_RUNTIME_PTR
argument_list|(
name|type
argument_list|)
operator|=
operator|(
expr|struct
name|runtime_info
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|runtime_info
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set flag for vtable */
name|TYPE_VTABLE
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* The first non-virtual base class with a vtable. */
name|TYPE_PRIMARY_BASE
argument_list|(
name|type
argument_list|)
operator|=
name|primary_base_class
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* The virtual base list. */
name|TYPE_VIRTUAL_BASE_LIST
argument_list|(
name|type
argument_list|)
operator|=
name|virtual_base_list
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
else|else
name|TYPE_RUNTIME_PTR
argument_list|(
name|type
argument_list|)
operator|=
name|NULL
expr_stmt|;
comment|/* If this is a local type (C++ - declared inside a function), record file name& line # */
if|if
condition|(
name|hpread_get_scope_depth
argument_list|(
name|dn_bufp
argument_list|,
name|objfile
argument_list|,
literal|1
comment|/* no need for real depth */
argument_list|)
condition|)
block|{
name|TYPE_LOCALTYPE_PTR
argument_list|(
name|type
argument_list|)
operator|=
operator|(
expr|struct
name|local_type_info
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|local_type_info
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_LOCALTYPE_FILE
argument_list|(
name|type
argument_list|)
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|current_subfile
operator|->
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|TYPE_LOCALTYPE_FILE
argument_list|(
name|type
argument_list|)
argument_list|,
name|current_subfile
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_subfile
operator|->
name|line_vector
operator|&&
operator|(
name|current_subfile
operator|->
name|line_vector
operator|->
name|nitems
operator|>
literal|0
operator|)
condition|)
name|TYPE_LOCALTYPE_LINE
argument_list|(
name|type
argument_list|)
operator|=
name|current_subfile
operator|->
name|line_vector
operator|->
name|item
index|[
name|current_subfile
operator|->
name|line_vector
operator|->
name|nitems
operator|-
literal|1
index|]
operator|.
name|line
expr_stmt|;
else|else
name|TYPE_LOCALTYPE_LINE
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|TYPE_LOCALTYPE_PTR
argument_list|(
name|type
argument_list|)
operator|=
name|NULL
expr_stmt|;
comment|/* Clear the global saying what template we are in the middle of processing */
name|current_template
operator|=
name|NULL
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Adjust the physnames for each static member of a struct    or class type to be something like "A::x"; then various    other pieces of code that do a lookup_symbol on the phyname    work correctly.    TYPE is a pointer to the struct/class type    NAME is a char * (string) which is the class/struct name    Void return */
end_comment

begin_function
specifier|static
name|void
name|fix_static_member_physnames
parameter_list|(
name|type
parameter_list|,
name|class_name
parameter_list|,
name|objfile
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|char
modifier|*
name|class_name
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
comment|/* We fix the member names only for classes or structs */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_CODE_STRUCT
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TYPE_FIELD_STATIC
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
block|{
if|if
condition|(
name|TYPE_FIELD_STATIC_PHYSNAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
return|return;
comment|/* physnames are already set */
name|SET_FIELD_PHYSNAME
argument_list|(
name|type
operator|->
name|fields
index|[
name|i
index|]
argument_list|,
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|type_obstack
argument_list|,
name|strlen
argument_list|(
name|class_name
argument_list|)
operator|+
name|strlen
argument_list|(
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
operator|+
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|TYPE_FIELD_STATIC_PHYSNAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|class_name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|TYPE_FIELD_STATIC_PHYSNAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
literal|"::"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|TYPE_FIELD_STATIC_PHYSNAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Fix-up the type structure for a CLASS so that the type entry  * for a method (previously marked with a null type in hpread_read_struct_type()  * is set correctly to METHOD.  * OBJFILE is as for other such functions.   * Void return. */
end_comment

begin_function
specifier|static
name|void
name|fixup_class_method_type
parameter_list|(
name|class
parameter_list|,
name|method
parameter_list|,
name|objfile
parameter_list|)
name|struct
name|type
modifier|*
name|class
decl_stmt|;
name|struct
name|type
modifier|*
name|method
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
if|if
condition|(
operator|!
name|class
operator|||
operator|!
name|method
operator|||
operator|!
name|objfile
condition|)
return|return;
comment|/* Only for types that have methods */
if|if
condition|(
operator|(
name|TYPE_CODE
argument_list|(
name|class
argument_list|)
operator|!=
name|TYPE_CODE_CLASS
operator|)
operator|&&
operator|(
name|TYPE_CODE
argument_list|(
name|class
argument_list|)
operator|!=
name|TYPE_CODE_UNION
operator|)
condition|)
return|return;
comment|/* Loop over all methods and find the one marked with a NULL type */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TYPE_NFN_FIELDS
argument_list|(
name|class
argument_list|)
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|TYPE_FN_FIELDLIST_LENGTH
argument_list|(
name|class
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|TYPE_FN_FIELD_TYPE
argument_list|(
name|TYPE_FN_FIELDLIST1
argument_list|(
name|class
argument_list|,
name|i
argument_list|)
argument_list|,
name|j
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* Set the method type */
name|TYPE_FN_FIELD_TYPE
argument_list|(
name|TYPE_FN_FIELDLIST1
argument_list|(
name|class
argument_list|,
name|i
argument_list|)
argument_list|,
name|j
argument_list|)
operator|=
name|method
expr_stmt|;
comment|/* The argument list */
operator|(
name|TYPE_FN_FIELD_TYPE
argument_list|(
name|TYPE_FN_FIELDLIST1
argument_list|(
name|class
argument_list|,
name|i
argument_list|)
argument_list|,
name|j
argument_list|)
operator|)
operator|->
name|type_specific
operator|.
name|arg_types
operator|=
operator|(
expr|struct
name|type
operator|*
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|type_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
operator|*
operator|(
name|method
operator|->
name|nfields
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|method
operator|->
name|nfields
condition|;
name|k
operator|++
control|)
operator|(
name|TYPE_FN_FIELD_TYPE
argument_list|(
name|TYPE_FN_FIELDLIST1
argument_list|(
name|class
argument_list|,
name|i
argument_list|)
argument_list|,
name|j
argument_list|)
operator|)
operator|->
name|type_specific
operator|.
name|arg_types
index|[
name|k
index|]
operator|=
name|method
operator|->
name|fields
index|[
name|k
index|]
operator|.
name|type
expr_stmt|;
comment|/* void termination */
operator|(
name|TYPE_FN_FIELD_TYPE
argument_list|(
name|TYPE_FN_FIELDLIST1
argument_list|(
name|class
argument_list|,
name|i
argument_list|)
argument_list|,
name|j
argument_list|)
operator|)
operator|->
name|type_specific
operator|.
name|arg_types
index|[
name|method
operator|->
name|nfields
index|]
operator|=
name|builtin_type_void
expr_stmt|;
comment|/* pai: It's not clear why this args field has to be set.  Perhaps            * it should be eliminated entirely. */
operator|(
name|TYPE_FN_FIELD
argument_list|(
name|TYPE_FN_FIELDLIST1
argument_list|(
name|class
argument_list|,
name|i
argument_list|)
argument_list|,
name|j
argument_list|)
operator|)
operator|.
name|args
operator|=
operator|(
expr|struct
name|type
operator|*
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|type_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
operator|*
operator|(
name|method
operator|->
name|nfields
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|method
operator|->
name|nfields
condition|;
name|k
operator|++
control|)
operator|(
name|TYPE_FN_FIELD
argument_list|(
name|TYPE_FN_FIELDLIST1
argument_list|(
name|class
argument_list|,
name|i
argument_list|)
argument_list|,
name|j
argument_list|)
operator|)
operator|.
name|args
index|[
name|k
index|]
operator|=
name|method
operator|->
name|fields
index|[
name|k
index|]
operator|.
name|type
expr_stmt|;
comment|/* null-terminated, unlike arg_types above */
operator|(
name|TYPE_FN_FIELD
argument_list|(
name|TYPE_FN_FIELDLIST1
argument_list|(
name|class
argument_list|,
name|i
argument_list|)
argument_list|,
name|j
argument_list|)
operator|)
operator|.
name|args
index|[
name|method
operator|->
name|nfields
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* Break out of both loops -- only one method to fix up in a class */
goto|goto
name|finish
goto|;
block|}
name|finish
label|:
name|TYPE_FLAGS
argument_list|(
name|class
argument_list|)
operator|&=
operator|~
name|TYPE_FLAG_INCOMPLETE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If we're in the middle of processing a template, get a pointer  * to the Nth template argument.  * An example may make this clearer:  *   template<class T1, class T2> class q2 {  *     public:  *     T1 a;  *     T2 b;  *   };  * The type for "a" will be "first template arg" and  * the type for "b" will be "second template arg".  * We need to look these up in order to fill in "a" and "b"'s type.  * This is called from hpread_type_lookup().  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|hpread_get_nth_template_arg
parameter_list|(
name|objfile
parameter_list|,
name|n
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
if|if
condition|(
name|current_template
operator|!=
name|NULL
condition|)
return|return
name|TYPE_TEMPLATE_ARG
argument_list|(
name|current_template
argument_list|,
name|n
argument_list|)
operator|.
name|type
return|;
else|else
return|return
name|lookup_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_TEMPLATE_ARG
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Read in and internalize a TEMPL_ARG (template arg) symbol.  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|hpread_read_templ_arg_type
parameter_list|(
name|hp_type
parameter_list|,
name|dn_bufp
parameter_list|,
name|objfile
parameter_list|,
name|name
parameter_list|)
name|dnttpointer
name|hp_type
decl_stmt|;
name|union
name|dnttentry
modifier|*
name|dn_bufp
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|type
modifier|*
name|type
decl_stmt|;
comment|/* See if it's something we've already deal with.  */
name|type
operator|=
name|hpread_alloc_type
argument_list|(
name|hp_type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_TEMPLATE_ARG
condition|)
return|return
name|type
return|;
comment|/* Nope.  Fill in the appropriate fields.  */
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_CODE_TEMPLATE_ARG
expr_stmt|;
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|=
name|name
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Read in and internalize a set debug symbol.  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|hpread_read_set_type
parameter_list|(
name|hp_type
parameter_list|,
name|dn_bufp
parameter_list|,
name|objfile
parameter_list|)
name|dnttpointer
name|hp_type
decl_stmt|;
name|union
name|dnttentry
modifier|*
name|dn_bufp
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|struct
name|type
modifier|*
name|type
decl_stmt|;
comment|/* See if it's something we've already deal with.  */
name|type
operator|=
name|hpread_alloc_type
argument_list|(
name|hp_type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_SET
condition|)
return|return
name|type
return|;
comment|/* Nope.  Fill in the appropriate fields.  */
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_CODE_SET
expr_stmt|;
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
name|dn_bufp
operator|->
name|dset
operator|.
name|bitlength
operator|/
literal|8
expr_stmt|;
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
operator|=
name|hpread_type_lookup
argument_list|(
name|dn_bufp
operator|->
name|dset
operator|.
name|subtype
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Read in and internalize an array debug symbol.  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|hpread_read_array_type
parameter_list|(
name|hp_type
parameter_list|,
name|dn_bufp
parameter_list|,
name|objfile
parameter_list|)
name|dnttpointer
name|hp_type
decl_stmt|;
name|union
name|dnttentry
modifier|*
name|dn_bufp
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|struct
name|type
modifier|*
name|type
decl_stmt|;
comment|/* Allocate an array type symbol.    * Why no check for already-read here, like in the other    * hpread_read_xxx_type routines?  Because it kept us     * from properly determining the size of the array!      */
name|type
operator|=
name|hpread_alloc_type
argument_list|(
name|hp_type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_CODE_ARRAY
expr_stmt|;
comment|/* Although the hp-symtab.h does not *require* this to be the case,    * GDB is assuming that "arrayisbytes" and "elemisbytes" be consistent.    * I.e., express both array-length and element-length in bits,    * or express both array-length and element-length in bytes.    */
if|if
condition|(
operator|!
operator|(
operator|(
name|dn_bufp
operator|->
name|darray
operator|.
name|arrayisbytes
operator|&&
name|dn_bufp
operator|->
name|darray
operator|.
name|elemisbytes
operator|)
operator|||
operator|(
operator|!
name|dn_bufp
operator|->
name|darray
operator|.
name|arrayisbytes
operator|&&
operator|!
name|dn_bufp
operator|->
name|darray
operator|.
name|elemisbytes
operator|)
operator|)
condition|)
block|{
name|warning
argument_list|(
literal|"error in hpread_array_type.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|dn_bufp
operator|->
name|darray
operator|.
name|arraylength
operator|==
literal|0x7fffffff
condition|)
block|{
comment|/* The HP debug format represents char foo[]; as an array with      * length 0x7fffffff.  Internally GDB wants to represent this      *	as an array of length zero.        */
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dn_bufp
operator|->
name|darray
operator|.
name|arrayisbytes
condition|)
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
name|dn_bufp
operator|->
name|darray
operator|.
name|arraylength
expr_stmt|;
else|else
comment|/* arraylength is in bits */
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
name|dn_bufp
operator|->
name|darray
operator|.
name|arraylength
operator|/
literal|8
expr_stmt|;
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
operator|=
name|hpread_type_lookup
argument_list|(
name|dn_bufp
operator|->
name|darray
operator|.
name|elemtype
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* The one "field" is used to store the subscript type */
comment|/* Since C and C++ multi-dimensional arrays are simply represented    * as: array of array of ..., we only need one subscript-type    * per array. This subscript type is typically a subrange of integer.    * If this gets extended to support languages like Pascal, then    * we need to fix this to represent multi-dimensional arrays properly.    */
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
expr|struct
name|field
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|type_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
operator|=
name|hpread_type_lookup
argument_list|(
name|dn_bufp
operator|->
name|darray
operator|.
name|indextype
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Read in and internalize a subrange debug symbol.  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|hpread_read_subrange_type
parameter_list|(
name|hp_type
parameter_list|,
name|dn_bufp
parameter_list|,
name|objfile
parameter_list|)
name|dnttpointer
name|hp_type
decl_stmt|;
name|union
name|dnttentry
modifier|*
name|dn_bufp
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|struct
name|type
modifier|*
name|type
decl_stmt|;
comment|/* Is it something we've already dealt with.  */
name|type
operator|=
name|hpread_alloc_type
argument_list|(
name|hp_type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_RANGE
condition|)
return|return
name|type
return|;
comment|/* Nope, internalize it.  */
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_CODE_RANGE
expr_stmt|;
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
name|dn_bufp
operator|->
name|dsubr
operator|.
name|bitlength
operator|/
literal|8
expr_stmt|;
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|=
literal|2
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
expr|struct
name|field
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|type_obstack
argument_list|,
literal|2
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn_bufp
operator|->
name|dsubr
operator|.
name|dyn_low
condition|)
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
operator|=
literal|0
expr_stmt|;
else|else
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
operator|=
name|dn_bufp
operator|->
name|dsubr
operator|.
name|lowbound
expr_stmt|;
if|if
condition|(
name|dn_bufp
operator|->
name|dsubr
operator|.
name|dyn_high
condition|)
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
literal|1
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
literal|1
argument_list|)
operator|=
name|dn_bufp
operator|->
name|dsubr
operator|.
name|highbound
expr_stmt|;
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
operator|=
name|hpread_type_lookup
argument_list|(
name|dn_bufp
operator|->
name|dsubr
operator|.
name|subtype
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* struct type * hpread_type_lookup(hp_type, objfile)  *   Arguments:  *     hp_type: A pointer into the DNTT specifying what type we  *              are about to "look up"., or else [for fundamental types  *              like int, float, ...] an "immediate" structure describing  *              the type.  *     objfile: ?  *   Return value: A pointer to a "struct type" (representation of a  *                 type in GDB's internal symbol table - see gdbtypes.h)  *   Routine description:  *     There are a variety of places when scanning the DNTT when we  *     need to interpret a "type" field. The simplest and most basic   *     example is when we're processing the symbol table record  *     for a data symbol (a SVAR or DVAR record). That has  *     a "type" field specifying the type of the data symbol. That  *     "type" field is either an "immediate" type specification (for the  *     fundamental types) or a DNTT pointer (for more complicated types).   *     For the more complicated types, we may or may not have already  *     processed the pointed-to type. (Multiple data symbols can of course  *     share the same type).  *     The job of hpread_type_lookup() is to process this "type" field.  *     Most of the real work is done in subroutines. Here we interpret  *     the immediate flag. If not immediate, chase the DNTT pointer to  *     find our way to the SOM record describing the type, switch on  *     the SOM kind, and then call an appropriate subroutine depending  *     on what kind of type we are constructing. (e.g., an array type,  *     a struct/class type, etc).  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|hpread_type_lookup
parameter_list|(
name|hp_type
parameter_list|,
name|objfile
parameter_list|)
name|dnttpointer
name|hp_type
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|union
name|dnttentry
modifier|*
name|dn_bufp
decl_stmt|;
name|struct
name|type
modifier|*
name|tmp_type
decl_stmt|;
comment|/* First see if it's a simple builtin type.  */
if|if
condition|(
name|hp_type
operator|.
name|dntti
operator|.
name|immediate
condition|)
comment|/* If this is a template argument, the argument number is      * encoded in the bitlength. All other cases, just return      * GDB's representation of this fundamental type.      */
if|if
condition|(
name|hp_type
operator|.
name|dntti
operator|.
name|type
operator|==
name|HP_TYPE_TEMPLATE_ARG
condition|)
return|return
name|hpread_get_nth_template_arg
argument_list|(
name|objfile
argument_list|,
name|hp_type
operator|.
name|dntti
operator|.
name|bitlength
argument_list|)
return|;
else|else
return|return
name|lookup_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|hpread_type_translate
argument_list|(
name|hp_type
argument_list|)
argument_list|)
return|;
comment|/* Not a builtin type.  We'll have to read it in.  */
if|if
condition|(
name|hp_type
operator|.
name|dnttp
operator|.
name|index
operator|<
name|LNTT_SYMCOUNT
argument_list|(
name|objfile
argument_list|)
condition|)
name|dn_bufp
operator|=
name|hpread_get_lntt
argument_list|(
name|hp_type
operator|.
name|dnttp
operator|.
name|index
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
else|else
comment|/* This is a fancy way of returning NULL */
return|return
name|lookup_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_VOID
argument_list|)
return|;
switch|switch
condition|(
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
condition|)
block|{
case|case
name|DNTT_TYPE_SRCFILE
case|:
case|case
name|DNTT_TYPE_MODULE
case|:
case|case
name|DNTT_TYPE_ENTRY
case|:
case|case
name|DNTT_TYPE_BEGIN
case|:
case|case
name|DNTT_TYPE_END
case|:
case|case
name|DNTT_TYPE_IMPORT
case|:
case|case
name|DNTT_TYPE_LABEL
case|:
case|case
name|DNTT_TYPE_FPARAM
case|:
case|case
name|DNTT_TYPE_SVAR
case|:
case|case
name|DNTT_TYPE_DVAR
case|:
case|case
name|DNTT_TYPE_CONST
case|:
case|case
name|DNTT_TYPE_MEMENUM
case|:
case|case
name|DNTT_TYPE_VARIANT
case|:
case|case
name|DNTT_TYPE_FILE
case|:
case|case
name|DNTT_TYPE_WITH
case|:
case|case
name|DNTT_TYPE_COMMON
case|:
case|case
name|DNTT_TYPE_COBSTRUCT
case|:
case|case
name|DNTT_TYPE_XREF
case|:
case|case
name|DNTT_TYPE_SA
case|:
case|case
name|DNTT_TYPE_MACRO
case|:
case|case
name|DNTT_TYPE_BLOCKDATA
case|:
case|case
name|DNTT_TYPE_CLASS_SCOPE
case|:
case|case
name|DNTT_TYPE_MEMACCESS
case|:
case|case
name|DNTT_TYPE_INHERITANCE
case|:
case|case
name|DNTT_TYPE_OBJECT_ID
case|:
case|case
name|DNTT_TYPE_FRIEND_CLASS
case|:
case|case
name|DNTT_TYPE_FRIEND_FUNC
case|:
comment|/* These are not types - something went wrong.  */
comment|/* This is a fancy way of returning NULL */
return|return
name|lookup_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_VOID
argument_list|)
return|;
case|case
name|DNTT_TYPE_FUNCTION
case|:
comment|/* We wind up here when dealing with class member functions         * (called from hpread_read_struct_type(), i.e. when processing        * the class definition itself).        */
return|return
name|hpread_read_function_type
argument_list|(
name|hp_type
argument_list|,
name|dn_bufp
argument_list|,
name|objfile
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|DNTT_TYPE_DOC_FUNCTION
case|:
return|return
name|hpread_read_doc_function_type
argument_list|(
name|hp_type
argument_list|,
name|dn_bufp
argument_list|,
name|objfile
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|DNTT_TYPE_TYPEDEF
case|:
block|{
comment|/* A typedef - chase it down by making a recursive call */
name|struct
name|type
modifier|*
name|structtype
init|=
name|hpread_type_lookup
argument_list|(
name|dn_bufp
operator|->
name|dtype
operator|.
name|type
argument_list|,
name|objfile
argument_list|)
decl_stmt|;
comment|/* The following came from the base hpread.c that we inherited.          * It is WRONG so I have commented it out. - RT          *...  	char *suffix; 	suffix = VT (objfile) + dn_bufp->dtype.name;  	TYPE_NAME (structtype) = suffix;           * ... further explanation ....          *          * What we have here is a typedef pointing to a typedef.          * E.g.,          * typedef int foo;          * typedef foo fum;          *          * What we desire to build is (these are pictures          * of "struct type"'s):           *          *  +---------+     +----------+     +------------+          *  | typedef |     | typedef  |     | fund. type |          *  |     type| ->  |      type| ->  |            |          *  | "fum"   |     | "foo"    |     | "int"      |          *  +---------+     +----------+     +------------+          *          * What this commented-out code is doing is smashing the          * name of pointed-to-type to be the same as the pointed-from          * type. So we wind up with something like:          *          *  +---------+     +----------+     +------------+          *  | typedef |     | typedef  |     | fund. type |          *  |     type| ->  |      type| ->  |            |          *  | "fum"   |     | "fum"    |     | "fum"      |          *  +---------+     +----------+     +------------+          *           */
return|return
name|structtype
return|;
block|}
case|case
name|DNTT_TYPE_TAGDEF
case|:
block|{
comment|/* Just a little different from above.  We have to tack on 	 * an identifier of some kind (struct, union, enum, class, etc).            */
name|struct
name|type
modifier|*
name|structtype
init|=
name|hpread_type_lookup
argument_list|(
name|dn_bufp
operator|->
name|dtype
operator|.
name|type
argument_list|,
name|objfile
argument_list|)
decl_stmt|;
name|char
modifier|*
name|prefix
decl_stmt|,
modifier|*
name|suffix
decl_stmt|;
name|suffix
operator|=
name|VT
argument_list|(
name|objfile
argument_list|)
operator|+
name|dn_bufp
operator|->
name|dtype
operator|.
name|name
expr_stmt|;
comment|/* Lookup the next type in the list.  It should be a structure, 	 * union, class, enum, or template type.            * We will need to attach that to our name.            */
if|if
condition|(
name|dn_bufp
operator|->
name|dtype
operator|.
name|type
operator|.
name|dnttp
operator|.
name|index
operator|<
name|LNTT_SYMCOUNT
argument_list|(
name|objfile
argument_list|)
condition|)
name|dn_bufp
operator|=
name|hpread_get_lntt
argument_list|(
name|dn_bufp
operator|->
name|dtype
operator|.
name|type
operator|.
name|dnttp
operator|.
name|index
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
else|else
block|{
name|complain
argument_list|(
operator|&
name|hpread_type_lookup_complaint
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_STRUCT
condition|)
block|{
name|prefix
operator|=
literal|"struct "
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_UNION
condition|)
block|{
name|prefix
operator|=
literal|"union "
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_CLASS
condition|)
block|{
comment|/* Further field for CLASS saying how it was really declared */
comment|/* 0==class, 1==union, 2==struct */
if|if
condition|(
name|dn_bufp
operator|->
name|dclass
operator|.
name|class_decl
operator|==
literal|0
condition|)
name|prefix
operator|=
literal|"class "
expr_stmt|;
elseif|else
if|if
condition|(
name|dn_bufp
operator|->
name|dclass
operator|.
name|class_decl
operator|==
literal|1
condition|)
name|prefix
operator|=
literal|"union "
expr_stmt|;
elseif|else
if|if
condition|(
name|dn_bufp
operator|->
name|dclass
operator|.
name|class_decl
operator|==
literal|2
condition|)
name|prefix
operator|=
literal|"struct "
expr_stmt|;
else|else
name|prefix
operator|=
literal|""
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_ENUM
condition|)
block|{
name|prefix
operator|=
literal|"enum "
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_TEMPLATE
condition|)
block|{
name|prefix
operator|=
literal|"template "
expr_stmt|;
block|}
else|else
block|{
name|prefix
operator|=
literal|""
expr_stmt|;
block|}
comment|/* Build the correct name.  */
name|structtype
operator|->
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|type_obstack
argument_list|,
name|strlen
argument_list|(
name|prefix
argument_list|)
operator|+
name|strlen
argument_list|(
name|suffix
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|structtype
argument_list|)
operator|=
name|strcpy
argument_list|(
name|TYPE_NAME
argument_list|(
name|structtype
argument_list|)
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|structtype
argument_list|)
operator|=
name|strcat
argument_list|(
name|TYPE_NAME
argument_list|(
name|structtype
argument_list|)
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
name|TYPE_TAG_NAME
argument_list|(
name|structtype
argument_list|)
operator|=
name|suffix
expr_stmt|;
comment|/* For classes/structs, we have to set the static member "physnames"            to point to strings like "Class::Member" */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|structtype
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
condition|)
name|fix_static_member_physnames
argument_list|(
name|structtype
argument_list|,
name|suffix
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
return|return
name|structtype
return|;
block|}
case|case
name|DNTT_TYPE_POINTER
case|:
comment|/* Pointer type - call a routine in gdbtypes.c that constructs        * the appropriate GDB type.        */
return|return
name|make_pointer_type
argument_list|(
name|hpread_type_lookup
argument_list|(
name|dn_bufp
operator|->
name|dptr
operator|.
name|pointsto
argument_list|,
name|objfile
argument_list|)
argument_list|,
name|NULL
argument_list|)
return|;
case|case
name|DNTT_TYPE_REFERENCE
case|:
comment|/* C++ reference type - call a routine in gdbtypes.c that constructs        * the appropriate GDB type.        */
return|return
name|make_reference_type
argument_list|(
name|hpread_type_lookup
argument_list|(
name|dn_bufp
operator|->
name|dreference
operator|.
name|pointsto
argument_list|,
name|objfile
argument_list|)
argument_list|,
name|NULL
argument_list|)
return|;
case|case
name|DNTT_TYPE_ENUM
case|:
return|return
name|hpread_read_enum_type
argument_list|(
name|hp_type
argument_list|,
name|dn_bufp
argument_list|,
name|objfile
argument_list|)
return|;
case|case
name|DNTT_TYPE_SET
case|:
return|return
name|hpread_read_set_type
argument_list|(
name|hp_type
argument_list|,
name|dn_bufp
argument_list|,
name|objfile
argument_list|)
return|;
case|case
name|DNTT_TYPE_SUBRANGE
case|:
return|return
name|hpread_read_subrange_type
argument_list|(
name|hp_type
argument_list|,
name|dn_bufp
argument_list|,
name|objfile
argument_list|)
return|;
case|case
name|DNTT_TYPE_ARRAY
case|:
return|return
name|hpread_read_array_type
argument_list|(
name|hp_type
argument_list|,
name|dn_bufp
argument_list|,
name|objfile
argument_list|)
return|;
case|case
name|DNTT_TYPE_STRUCT
case|:
case|case
name|DNTT_TYPE_UNION
case|:
return|return
name|hpread_read_struct_type
argument_list|(
name|hp_type
argument_list|,
name|dn_bufp
argument_list|,
name|objfile
argument_list|)
return|;
case|case
name|DNTT_TYPE_FIELD
case|:
return|return
name|hpread_type_lookup
argument_list|(
name|dn_bufp
operator|->
name|dfield
operator|.
name|type
argument_list|,
name|objfile
argument_list|)
return|;
case|case
name|DNTT_TYPE_FUNCTYPE
case|:
comment|/* Here we want to read the function SOMs and return a         * type for it. We get here, for instance, when processing        * pointer-to-function type.        */
return|return
name|hpread_read_function_type
argument_list|(
name|hp_type
argument_list|,
name|dn_bufp
argument_list|,
name|objfile
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|DNTT_TYPE_PTRMEM
case|:
comment|/* Declares a C++ pointer-to-data-member type.         * The "pointsto" field defines the class,        * while the "memtype" field defines the pointed-to-type.        */
block|{
name|struct
name|type
modifier|*
name|ptrmemtype
decl_stmt|;
name|struct
name|type
modifier|*
name|class_type
decl_stmt|;
name|struct
name|type
modifier|*
name|memtype
decl_stmt|;
name|memtype
operator|=
name|hpread_type_lookup
argument_list|(
name|dn_bufp
operator|->
name|dptrmem
operator|.
name|memtype
argument_list|,
name|objfile
argument_list|)
operator|,
name|class_type
operator|=
name|hpread_type_lookup
argument_list|(
name|dn_bufp
operator|->
name|dptrmem
operator|.
name|pointsto
argument_list|,
name|objfile
argument_list|)
operator|,
name|ptrmemtype
operator|=
name|alloc_type
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
name|smash_to_member_type
argument_list|(
name|ptrmemtype
argument_list|,
name|class_type
argument_list|,
name|memtype
argument_list|)
expr_stmt|;
return|return
name|make_pointer_type
argument_list|(
name|ptrmemtype
argument_list|,
name|NULL
argument_list|)
return|;
block|}
break|break;
case|case
name|DNTT_TYPE_PTRMEMFUNC
case|:
comment|/* Defines a C++ pointer-to-function-member type.         * The "pointsto" field defines the class,        * while the "memtype" field defines the pointed-to-type.        */
block|{
name|struct
name|type
modifier|*
name|ptrmemtype
decl_stmt|;
name|struct
name|type
modifier|*
name|class_type
decl_stmt|;
name|struct
name|type
modifier|*
name|functype
decl_stmt|;
name|struct
name|type
modifier|*
name|retvaltype
decl_stmt|;
name|int
name|nargs
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|type
modifier|*
modifier|*
name|args_type
decl_stmt|;
name|class_type
operator|=
name|hpread_type_lookup
argument_list|(
name|dn_bufp
operator|->
name|dptrmem
operator|.
name|pointsto
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|functype
operator|=
name|hpread_type_lookup
argument_list|(
name|dn_bufp
operator|->
name|dptrmem
operator|.
name|memtype
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|retvaltype
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|functype
argument_list|)
expr_stmt|;
name|nargs
operator|=
name|TYPE_NFIELDS
argument_list|(
name|functype
argument_list|)
expr_stmt|;
name|args_type
operator|=
operator|(
expr|struct
name|type
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|nargs
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nargs
condition|;
name|i
operator|++
control|)
block|{
name|args_type
index|[
name|i
index|]
operator|=
name|TYPE_FIELD_TYPE
argument_list|(
name|functype
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|args_type
index|[
name|nargs
index|]
operator|=
name|NULL
expr_stmt|;
name|ptrmemtype
operator|=
name|alloc_type
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
name|smash_to_method_type
argument_list|(
name|ptrmemtype
argument_list|,
name|class_type
argument_list|,
name|retvaltype
argument_list|,
name|args_type
argument_list|)
expr_stmt|;
return|return
name|make_pointer_type
argument_list|(
name|ptrmemtype
argument_list|,
name|NULL
argument_list|)
return|;
block|}
break|break;
case|case
name|DNTT_TYPE_CLASS
case|:
return|return
name|hpread_read_struct_type
argument_list|(
name|hp_type
argument_list|,
name|dn_bufp
argument_list|,
name|objfile
argument_list|)
return|;
case|case
name|DNTT_TYPE_GENFIELD
case|:
comment|/* Chase pointer from GENFIELD to FIELD, and make recursive        * call on that.        */
return|return
name|hpread_type_lookup
argument_list|(
name|dn_bufp
operator|->
name|dgenfield
operator|.
name|field
argument_list|,
name|objfile
argument_list|)
return|;
case|case
name|DNTT_TYPE_VFUNC
case|:
comment|/* C++ virtual function.        * We get here in the course of processing a class type which        * contains virtual functions. Just go through another level        * of indirection to get to the pointed-to function SOM.        */
return|return
name|hpread_type_lookup
argument_list|(
name|dn_bufp
operator|->
name|dvfunc
operator|.
name|funcptr
argument_list|,
name|objfile
argument_list|)
return|;
case|case
name|DNTT_TYPE_MODIFIER
case|:
comment|/* Check the modifiers and then just make a recursive call on        * the "type" pointed to by the modifier DNTT.        *         * pai:: FIXME -- do we ever want to handle "m_duplicate" and        * "m_void" modifiers?  Is static_flag really needed here?        * (m_static used for methods of classes, elsewhere).        */
name|tmp_type
operator|=
name|make_cv_type
argument_list|(
name|dn_bufp
operator|->
name|dmodifier
operator|.
name|m_const
argument_list|,
name|dn_bufp
operator|->
name|dmodifier
operator|.
name|m_volatile
argument_list|,
name|hpread_type_lookup
argument_list|(
name|dn_bufp
operator|->
name|dmodifier
operator|.
name|type
argument_list|,
name|objfile
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|tmp_type
return|;
case|case
name|DNTT_TYPE_MEMFUNC
case|:
comment|/* Member function. Treat like a function.        * I think we get here in the course of processing a         * pointer-to-member-function type...        */
return|return
name|hpread_read_function_type
argument_list|(
name|hp_type
argument_list|,
name|dn_bufp
argument_list|,
name|objfile
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|DNTT_TYPE_DOC_MEMFUNC
case|:
return|return
name|hpread_read_doc_function_type
argument_list|(
name|hp_type
argument_list|,
name|dn_bufp
argument_list|,
name|objfile
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|DNTT_TYPE_TEMPLATE
case|:
comment|/* Template - sort of the header for a template definition,        * which like a class, points to a member list and also points        * to a TEMPLATE_ARG list of type-arguments.        */
return|return
name|hpread_read_struct_type
argument_list|(
name|hp_type
argument_list|,
name|dn_bufp
argument_list|,
name|objfile
argument_list|)
return|;
case|case
name|DNTT_TYPE_TEMPLATE_ARG
case|:
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* The TEMPLATE record points to an argument list of        * TEMPLATE_ARG records, each of which describes one        * of the type-arguments.         */
name|name
operator|=
name|VT
argument_list|(
name|objfile
argument_list|)
operator|+
name|dn_bufp
operator|->
name|dtempl_arg
operator|.
name|name
expr_stmt|;
return|return
name|hpread_read_templ_arg_type
argument_list|(
name|hp_type
argument_list|,
name|dn_bufp
argument_list|,
name|objfile
argument_list|,
name|name
argument_list|)
return|;
block|}
case|case
name|DNTT_TYPE_FUNC_TEMPLATE
case|:
comment|/* We wind up here when processing a TEMPLATE type,         * if the template has member function(s).        * Treat it like a FUNCTION.        */
return|return
name|hpread_read_function_type
argument_list|(
name|hp_type
argument_list|,
name|dn_bufp
argument_list|,
name|objfile
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|DNTT_TYPE_LINK
case|:
comment|/* The LINK record is used to link up templates with instantiations.        * There is no type associated with the LINK record per se.        */
return|return
name|lookup_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_VOID
argument_list|)
return|;
comment|/* Also not yet handled... */
comment|/* case DNTT_TYPE_DYN_ARRAY_DESC: */
comment|/* case DNTT_TYPE_DESC_SUBRANGE: */
comment|/* case DNTT_TYPE_BEGIN_EXT: */
comment|/* case DNTT_TYPE_INLN: */
comment|/* case DNTT_TYPE_INLN_LIST: */
comment|/* case DNTT_TYPE_ALIAS: */
default|default:
comment|/* A fancy way of returning NULL */
return|return
name|lookup_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_VOID
argument_list|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|sltpointer
name|hpread_record_lines
parameter_list|(
name|subfile
parameter_list|,
name|s_idx
parameter_list|,
name|e_idx
parameter_list|,
name|objfile
parameter_list|,
name|offset
parameter_list|)
name|struct
name|subfile
modifier|*
name|subfile
decl_stmt|;
name|sltpointer
name|s_idx
decl_stmt|,
name|e_idx
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|CORE_ADDR
name|offset
decl_stmt|;
block|{
name|union
name|sltentry
modifier|*
name|sl_bufp
decl_stmt|;
while|while
condition|(
name|s_idx
operator|<=
name|e_idx
condition|)
block|{
name|sl_bufp
operator|=
name|hpread_get_slt
argument_list|(
name|s_idx
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* Only record "normal" entries in the SLT.  */
if|if
condition|(
name|sl_bufp
operator|->
name|snorm
operator|.
name|sltdesc
operator|==
name|SLT_NORMAL
operator|||
name|sl_bufp
operator|->
name|snorm
operator|.
name|sltdesc
operator|==
name|SLT_EXIT
condition|)
name|record_line
argument_list|(
name|subfile
argument_list|,
name|sl_bufp
operator|->
name|snorm
operator|.
name|line
argument_list|,
name|sl_bufp
operator|->
name|snorm
operator|.
name|address
operator|+
name|offset
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sl_bufp
operator|->
name|snorm
operator|.
name|sltdesc
operator|==
name|SLT_NORMAL_OFFSET
condition|)
name|record_line
argument_list|(
name|subfile
argument_list|,
name|sl_bufp
operator|->
name|snormoff
operator|.
name|line
argument_list|,
name|sl_bufp
operator|->
name|snormoff
operator|.
name|address
operator|+
name|offset
argument_list|)
expr_stmt|;
name|s_idx
operator|++
expr_stmt|;
block|}
return|return
name|e_idx
return|;
block|}
end_function

begin_comment
comment|/* Given a function "f" which is a member of a class, find  * the classname that it is a member of. Used to construct  * the name (e.g., "c::f") which GDB will put in the  * "demangled name" field of the function's symbol.  * Called from hpread_process_one_debug_symbol()  * If "f" is not a member function, return NULL.  */
end_comment

begin_function
name|char
modifier|*
name|class_of
parameter_list|(
name|functype
parameter_list|)
name|struct
name|type
modifier|*
name|functype
decl_stmt|;
block|{
name|struct
name|type
modifier|*
name|first_param_type
decl_stmt|;
name|char
modifier|*
name|first_param_name
decl_stmt|;
name|struct
name|type
modifier|*
name|pointed_to_type
decl_stmt|;
name|char
modifier|*
name|class_name
decl_stmt|;
comment|/* Check that the function has a first argument "this",    * and that "this" is a pointer to a class. If not,    * functype is not a member function, so return NULL.    */
if|if
condition|(
name|TYPE_NFIELDS
argument_list|(
name|functype
argument_list|)
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
name|first_param_name
operator|=
name|TYPE_FIELD_NAME
argument_list|(
name|functype
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_param_name
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* paranoia */
if|if
condition|(
name|strcmp
argument_list|(
name|first_param_name
argument_list|,
literal|"this"
argument_list|)
condition|)
return|return
name|NULL
return|;
name|first_param_type
operator|=
name|TYPE_FIELD_TYPE
argument_list|(
name|functype
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_param_type
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* paranoia */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|first_param_type
argument_list|)
operator|!=
name|TYPE_CODE_PTR
condition|)
return|return
name|NULL
return|;
comment|/* Get the thing that "this" points to, check that    * it's a class, and get its class name.    */
name|pointed_to_type
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|first_param_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|pointed_to_type
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* paranoia */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|pointed_to_type
argument_list|)
operator|!=
name|TYPE_CODE_CLASS
condition|)
return|return
name|NULL
return|;
name|class_name
operator|=
name|TYPE_NAME
argument_list|(
name|pointed_to_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|class_name
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* paranoia */
comment|/* The class name may be of the form "class c", in which case    * we want to strip off the leading "class ".    */
if|if
condition|(
name|strncmp
argument_list|(
name|class_name
argument_list|,
literal|"class "
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
name|class_name
operator|+=
literal|6
expr_stmt|;
return|return
name|class_name
return|;
block|}
end_function

begin_comment
comment|/* Internalize one native debug symbol.   * Called in a loop from hpread_expand_symtab().   * Arguments:  *   dn_bufp:   *   name:   *   section_offsets:  *   objfile:  *   text_offset:   *   text_size:   *   filename:   *   index: 		Index of this symbol  *   at_module_boundary_p Pointer to boolean flag to control caller's loop.  */
end_comment

begin_function
specifier|static
name|void
name|hpread_process_one_debug_symbol
parameter_list|(
name|dn_bufp
parameter_list|,
name|name
parameter_list|,
name|section_offsets
parameter_list|,
name|objfile
parameter_list|,
name|text_offset
parameter_list|,
name|text_size
parameter_list|,
name|filename
parameter_list|,
name|index
parameter_list|,
name|at_module_boundary_p
parameter_list|)
name|union
name|dnttentry
modifier|*
name|dn_bufp
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|section_offsets
modifier|*
name|section_offsets
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|CORE_ADDR
name|text_offset
decl_stmt|;
name|int
name|text_size
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|index
decl_stmt|;
name|int
modifier|*
name|at_module_boundary_p
decl_stmt|;
block|{
name|unsigned
name|long
name|desc
decl_stmt|;
name|int
name|type
decl_stmt|;
name|CORE_ADDR
name|valu
decl_stmt|;
name|int
name|offset
init|=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
decl_stmt|;
name|int
name|data_offset
init|=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_DATA
argument_list|)
decl_stmt|;
name|union
name|dnttentry
modifier|*
name|dn_temp
decl_stmt|;
name|dnttpointer
name|hp_type
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|struct
name|context_stack
modifier|*
name|new
decl_stmt|;
name|char
modifier|*
name|class_scope_name
decl_stmt|;
specifier|extern
name|int
name|is_in_import_list
parameter_list|()
function_decl|;
comment|/* in somread.c */
comment|/* Allocate one GDB debug symbol and fill in some default values. */
name|sym
operator|=
operator|(
expr|struct
name|symbol
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|sym
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|=
name|obsavestring
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|)
expr_stmt|;
name|SYMBOL_LANGUAGE
argument_list|(
name|sym
argument_list|)
operator|=
name|language_auto
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
name|SYMBOL_LINE
argument_list|(
name|sym
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_TYPEDEF
expr_stmt|;
comment|/* Just a trick in case the SOM debug symbol is a type definition.    * There are routines that are set up to build a GDB type symbol, given    * a SOM dnttpointer. So we set up a dummy SOM dnttpointer "hp_type".    * This allows us to call those same routines.    */
name|hp_type
operator|.
name|dnttp
operator|.
name|extension
operator|=
literal|1
expr_stmt|;
name|hp_type
operator|.
name|dnttp
operator|.
name|immediate
operator|=
literal|0
expr_stmt|;
name|hp_type
operator|.
name|dnttp
operator|.
name|global
operator|=
literal|0
expr_stmt|;
name|hp_type
operator|.
name|dnttp
operator|.
name|index
operator|=
name|index
expr_stmt|;
comment|/* This "type" is the type of SOM record.    * Switch on SOM type.    */
name|type
operator|=
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|DNTT_TYPE_SRCFILE
case|:
comment|/* This type of symbol indicates from which source file or        * include file any following data comes. It may indicate:        *        * o   The start of an entirely new source file (and thus        *     a new module)        *        * o   The start of a different source file due to #include        *        * o   The end of an include file and the return to the original        *     file. Thus if "foo.c" includes "bar.h", we see first        *     a SRCFILE for foo.c, then one for bar.h, and then one for        *     foo.c again.        *        * If it indicates the start of a new module then we must        * finish the symbol table of the previous module         * (if any) and start accumulating a new symbol table.          */
name|valu
operator|=
name|text_offset
expr_stmt|;
if|if
condition|(
operator|!
name|last_source_file
condition|)
block|{
comment|/*            * A note on "last_source_file": this is a char* pointing            * to the actual file name.  "start_symtab" sets it,            * "end_symtab" clears it.            *            * So if "last_source_file" is NULL, then either this is            * the first record we are looking at, or a previous call            * to "end_symtab()" was made to close out the previous            * module.  Since we're now quitting the scan loop when we            * see a MODULE END record, we should never get here, except            * in the case that we're not using the quick look-up tables            * and have to use the old system as a fall-back.            */
name|start_symtab
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|,
name|valu
argument_list|)
expr_stmt|;
name|record_debugformat
argument_list|(
literal|"HP"
argument_list|)
expr_stmt|;
name|SL_INDEX
argument_list|(
name|objfile
argument_list|)
operator|=
name|dn_bufp
operator|->
name|dsfile
operator|.
name|address
expr_stmt|;
block|}
else|else
block|{
comment|/* Either a new include file, or a SRCFILE record            * saying we are back in the main source (or out of            * a nested include file) again.            */
name|SL_INDEX
argument_list|(
name|objfile
argument_list|)
operator|=
name|hpread_record_lines
argument_list|(
name|current_subfile
argument_list|,
name|SL_INDEX
argument_list|(
name|objfile
argument_list|)
argument_list|,
name|dn_bufp
operator|->
name|dsfile
operator|.
name|address
argument_list|,
name|objfile
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
comment|/* A note on "start_subfile".  This routine will check        * the name we pass it and look for an existing subfile        * of that name.  There's thus only one sub-file for the        * actual source (e.g. for "foo.c" in foo.c), despite the        * fact that we'll see lots of SRCFILE entries for foo.c        * inside foo.c.        */
name|start_subfile
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|DNTT_TYPE_MODULE
case|:
comment|/*        * We no longer ignore DNTT_TYPE_MODULE symbols.  The module         * represents the meaningful semantic structure of a compilation        * unit.  We expect to start the psymtab-to-symtab expansion        * looking at a MODULE entry, and to end it at the corresponding        * END MODULE entry.        *        *--Begin outdated comments        *         * This record signifies the start of a new source module        * In C/C++ there is no explicit "module" construct in the language,        * but each compilation unit is implicitly a module and they        * do emit the DNTT_TYPE_MODULE records.        * The end of the module is marked by a matching DNTT_TYPE_END record.        *        * The reason GDB gets away with ignoring the DNTT_TYPE_MODULE record         * is it notices the DNTT_TYPE_END record for the previous         * module (see comments under DNTT_TYPE_END case), and then treats        * the next DNTT_TYPE_SRCFILE record as if it were the module-start record.        * (i.e., it makes a start_symtab() call).        * This scheme seems a little convoluted, but I'll leave it         * alone on the principle "if it ain't broke don't fix        * it". (RT).        *        *-- End outdated comments        */
name|valu
operator|=
name|text_offset
expr_stmt|;
if|if
condition|(
operator|!
name|last_source_file
condition|)
block|{
comment|/* Start of a new module. We know this because "last_source_file"            * is NULL, which can only happen the first time or if we just             * made a call to end_symtab() to close out the previous module.            */
name|start_symtab
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|,
name|valu
argument_list|)
expr_stmt|;
name|SL_INDEX
argument_list|(
name|objfile
argument_list|)
operator|=
name|dn_bufp
operator|->
name|dmodule
operator|.
name|address
expr_stmt|;
block|}
else|else
block|{
comment|/* This really shouldn't happen if we're using the quick            * look-up tables, as it would mean we'd scanned past an            * END MODULE entry.  But if we're not using the tables,            * we started the module on the SRCFILE entry, so it's ok.            * For now, accept this.            */
comment|/* warning( "Error expanding psymtab, missed module end, found entry for %s",       *           name );       */
operator|*
name|at_module_boundary_p
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|start_subfile
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|DNTT_TYPE_FUNCTION
case|:
case|case
name|DNTT_TYPE_ENTRY
case|:
comment|/* A function or secondary entry point.  */
name|valu
operator|=
name|dn_bufp
operator|->
name|dfunc
operator|.
name|lowaddr
operator|+
name|offset
expr_stmt|;
comment|/* Record lines up to this point. */
name|SL_INDEX
argument_list|(
name|objfile
argument_list|)
operator|=
name|hpread_record_lines
argument_list|(
name|current_subfile
argument_list|,
name|SL_INDEX
argument_list|(
name|objfile
argument_list|)
argument_list|,
name|dn_bufp
operator|->
name|dfunc
operator|.
name|address
argument_list|,
name|objfile
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|WITHIN_FUNCTION
argument_list|(
name|objfile
argument_list|)
operator|=
literal|1
expr_stmt|;
name|CURRENT_FUNCTION_VALUE
argument_list|(
name|objfile
argument_list|)
operator|=
name|valu
expr_stmt|;
comment|/* Stack must be empty now.  */
if|if
condition|(
name|context_stack_depth
operator|!=
literal|0
condition|)
name|complain
argument_list|(
operator|&
name|lbrac_unmatched_complaint
argument_list|,
operator|(
name|char
operator|*
operator|)
name|symnum
argument_list|)
expr_stmt|;
name|new
operator|=
name|push_context
argument_list|(
literal|0
argument_list|,
name|valu
argument_list|)
expr_stmt|;
comment|/* Built a type for the function. This includes processing        * the symbol records for the function parameters.        */
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_BLOCK
expr_stmt|;
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|hpread_read_function_type
argument_list|(
name|hp_type
argument_list|,
name|dn_bufp
argument_list|,
name|objfile
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* The "SYMBOL_NAME" field is expected to be the mangled name        * (if any), which we get from the "alias" field of the SOM record        * if that exists.        */
if|if
condition|(
operator|(
name|dn_bufp
operator|->
name|dfunc
operator|.
name|language
operator|==
name|HP_LANGUAGE_CPLUSPLUS
operator|)
operator|&&
name|dn_bufp
operator|->
name|dfunc
operator|.
name|alias
operator|&&
comment|/* has an alias */
operator|*
operator|(
name|char
operator|*
operator|)
operator|(
name|VT
argument_list|(
name|objfile
argument_list|)
operator|+
name|dn_bufp
operator|->
name|dfunc
operator|.
name|alias
operator|)
condition|)
comment|/* not a null string */
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|=
name|VT
argument_list|(
name|objfile
argument_list|)
operator|+
name|dn_bufp
operator|->
name|dfunc
operator|.
name|alias
expr_stmt|;
else|else
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|=
name|VT
argument_list|(
name|objfile
argument_list|)
operator|+
name|dn_bufp
operator|->
name|dfunc
operator|.
name|name
expr_stmt|;
comment|/* Special hack to get around HP compilers' insistence on        * reporting "main" as "_MAIN_" for C/C++ */
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
literal|"_MAIN_"
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|VT
argument_list|(
name|objfile
argument_list|)
operator|+
name|dn_bufp
operator|->
name|dfunc
operator|.
name|name
argument_list|,
literal|"main"
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|=
name|VT
argument_list|(
name|objfile
argument_list|)
operator|+
name|dn_bufp
operator|->
name|dfunc
operator|.
name|name
expr_stmt|;
comment|/* The SYMBOL_CPLUS_DEMANGLED_NAME field is expected to        * be the demangled name.        */
if|if
condition|(
name|dn_bufp
operator|->
name|dfunc
operator|.
name|language
operator|==
name|HP_LANGUAGE_CPLUSPLUS
condition|)
block|{
comment|/* SYMBOL_INIT_DEMANGLED_NAME is a macro which winds up          * calling the demangler in libiberty (cplus_demangle()) to          * do the job. This generally does the job, even though          * it's intended for the GNU compiler and not the aCC compiler          * Note that SYMBOL_INIT_DEMANGLED_NAME calls the          * demangler with arguments DMGL_PARAMS | DMGL_ANSI.          * Generally, we don't want params when we display          * a demangled name, but when I took out the DMGL_PARAMS,          * some things broke, so I'm leaving it in here, and          * working around the issue in stack.c. - RT          */
name|SYMBOL_INIT_DEMANGLED_NAME
argument_list|(
name|sym
argument_list|,
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|==
name|VT
argument_list|(
name|objfile
argument_list|)
operator|+
name|dn_bufp
operator|->
name|dfunc
operator|.
name|alias
operator|)
operator|&&
operator|(
operator|!
name|SYMBOL_CPLUS_DEMANGLED_NAME
argument_list|(
name|sym
argument_list|)
operator|)
condition|)
block|{
comment|/* Well, the symbol name is mangled, but the            * demangler in libiberty failed so the demangled            * field is still NULL. Try to            * do the job ourselves based on the "name" field            * in the SOM record. A complication here is that            * the name field contains only the function name            * (like "f"), whereas we want the class qualification            * (as in "c::f"). Try to reconstruct that.            */
name|char
modifier|*
name|basename
decl_stmt|;
name|char
modifier|*
name|classname
decl_stmt|;
name|char
modifier|*
name|dem_name
decl_stmt|;
name|basename
operator|=
name|VT
argument_list|(
name|objfile
argument_list|)
operator|+
name|dn_bufp
operator|->
name|dfunc
operator|.
name|name
expr_stmt|;
name|classname
operator|=
name|class_of
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|classname
condition|)
block|{
name|dem_name
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|basename
argument_list|)
operator|+
name|strlen
argument_list|(
name|classname
argument_list|)
operator|+
literal|3
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|dem_name
argument_list|,
name|classname
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|dem_name
argument_list|,
literal|"::"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|dem_name
argument_list|,
name|basename
argument_list|)
expr_stmt|;
name|SYMBOL_CPLUS_DEMANGLED_NAME
argument_list|(
name|sym
argument_list|)
operator|=
name|dem_name
expr_stmt|;
name|SYMBOL_LANGUAGE
argument_list|(
name|sym
argument_list|)
operator|=
name|language_cplus
expr_stmt|;
block|}
block|}
block|}
comment|/* Add the function symbol to the list of symbols in this blockvector */
if|if
condition|(
name|dn_bufp
operator|->
name|dfunc
operator|.
name|global
condition|)
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|global_symbols
argument_list|)
expr_stmt|;
else|else
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|file_symbols
argument_list|)
expr_stmt|;
name|new
operator|->
name|name
operator|=
name|sym
expr_stmt|;
comment|/* Search forward to the next BEGIN and also read        * in the line info up to that point.         * Not sure why this is needed.        * In HP FORTRAN this code is harmful since there           * may not be a BEGIN after the FUNCTION.        * So I made it C/C++ specific. - RT        */
if|if
condition|(
name|dn_bufp
operator|->
name|dfunc
operator|.
name|language
operator|==
name|HP_LANGUAGE_C
operator|||
name|dn_bufp
operator|->
name|dfunc
operator|.
name|language
operator|==
name|HP_LANGUAGE_CPLUSPLUS
condition|)
block|{
while|while
condition|(
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|!=
name|DNTT_TYPE_BEGIN
condition|)
block|{
name|dn_bufp
operator|=
name|hpread_get_lntt
argument_list|(
operator|++
name|index
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn_bufp
operator|->
name|dblock
operator|.
name|extension
condition|)
continue|continue;
block|}
name|SL_INDEX
argument_list|(
name|objfile
argument_list|)
operator|=
name|hpread_record_lines
argument_list|(
name|current_subfile
argument_list|,
name|SL_INDEX
argument_list|(
name|objfile
argument_list|)
argument_list|,
name|dn_bufp
operator|->
name|dbegin
operator|.
name|address
argument_list|,
name|objfile
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|SYMBOL_LINE
argument_list|(
name|sym
argument_list|)
operator|=
name|hpread_get_line
argument_list|(
name|dn_bufp
operator|->
name|dbegin
operator|.
name|address
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
name|record_line
argument_list|(
name|current_subfile
argument_list|,
name|SYMBOL_LINE
argument_list|(
name|sym
argument_list|)
argument_list|,
name|valu
argument_list|)
expr_stmt|;
break|break;
case|case
name|DNTT_TYPE_DOC_FUNCTION
case|:
name|valu
operator|=
name|dn_bufp
operator|->
name|ddocfunc
operator|.
name|lowaddr
operator|+
name|offset
expr_stmt|;
comment|/* Record lines up to this point. */
name|SL_INDEX
argument_list|(
name|objfile
argument_list|)
operator|=
name|hpread_record_lines
argument_list|(
name|current_subfile
argument_list|,
name|SL_INDEX
argument_list|(
name|objfile
argument_list|)
argument_list|,
name|dn_bufp
operator|->
name|ddocfunc
operator|.
name|address
argument_list|,
name|objfile
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|WITHIN_FUNCTION
argument_list|(
name|objfile
argument_list|)
operator|=
literal|1
expr_stmt|;
name|CURRENT_FUNCTION_VALUE
argument_list|(
name|objfile
argument_list|)
operator|=
name|valu
expr_stmt|;
comment|/* Stack must be empty now.  */
if|if
condition|(
name|context_stack_depth
operator|!=
literal|0
condition|)
name|complain
argument_list|(
operator|&
name|lbrac_unmatched_complaint
argument_list|,
operator|(
name|char
operator|*
operator|)
name|symnum
argument_list|)
expr_stmt|;
name|new
operator|=
name|push_context
argument_list|(
literal|0
argument_list|,
name|valu
argument_list|)
expr_stmt|;
comment|/* Built a type for the function. This includes processing        * the symbol records for the function parameters.        */
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_BLOCK
expr_stmt|;
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|hpread_read_doc_function_type
argument_list|(
name|hp_type
argument_list|,
name|dn_bufp
argument_list|,
name|objfile
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* The "SYMBOL_NAME" field is expected to be the mangled name        * (if any), which we get from the "alias" field of the SOM record        * if that exists.        */
if|if
condition|(
operator|(
name|dn_bufp
operator|->
name|ddocfunc
operator|.
name|language
operator|==
name|HP_LANGUAGE_CPLUSPLUS
operator|)
operator|&&
name|dn_bufp
operator|->
name|ddocfunc
operator|.
name|alias
operator|&&
comment|/* has an alias */
operator|*
operator|(
name|char
operator|*
operator|)
operator|(
name|VT
argument_list|(
name|objfile
argument_list|)
operator|+
name|dn_bufp
operator|->
name|ddocfunc
operator|.
name|alias
operator|)
condition|)
comment|/* not a null string */
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|=
name|VT
argument_list|(
name|objfile
argument_list|)
operator|+
name|dn_bufp
operator|->
name|ddocfunc
operator|.
name|alias
expr_stmt|;
else|else
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|=
name|VT
argument_list|(
name|objfile
argument_list|)
operator|+
name|dn_bufp
operator|->
name|ddocfunc
operator|.
name|name
expr_stmt|;
comment|/* Special hack to get around HP compilers' insistence on        * reporting "main" as "_MAIN_" for C/C++ */
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
literal|"_MAIN_"
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|VT
argument_list|(
name|objfile
argument_list|)
operator|+
name|dn_bufp
operator|->
name|ddocfunc
operator|.
name|name
argument_list|,
literal|"main"
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|=
name|VT
argument_list|(
name|objfile
argument_list|)
operator|+
name|dn_bufp
operator|->
name|ddocfunc
operator|.
name|name
expr_stmt|;
if|if
condition|(
name|dn_bufp
operator|->
name|ddocfunc
operator|.
name|language
operator|==
name|HP_LANGUAGE_CPLUSPLUS
condition|)
block|{
comment|/* SYMBOL_INIT_DEMANGLED_NAME is a macro which winds up          * calling the demangler in libiberty (cplus_demangle()) to          * do the job. This generally does the job, even though          * it's intended for the GNU compiler and not the aCC compiler          * Note that SYMBOL_INIT_DEMANGLED_NAME calls the          * demangler with arguments DMGL_PARAMS | DMGL_ANSI.          * Generally, we don't want params when we display          * a demangled name, but when I took out the DMGL_PARAMS,          * some things broke, so I'm leaving it in here, and          * working around the issue in stack.c. - RT           */
name|SYMBOL_INIT_DEMANGLED_NAME
argument_list|(
name|sym
argument_list|,
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|==
name|VT
argument_list|(
name|objfile
argument_list|)
operator|+
name|dn_bufp
operator|->
name|ddocfunc
operator|.
name|alias
operator|)
operator|&&
operator|(
operator|!
name|SYMBOL_CPLUS_DEMANGLED_NAME
argument_list|(
name|sym
argument_list|)
operator|)
condition|)
block|{
comment|/* Well, the symbol name is mangled, but the            * demangler in libiberty failed so the demangled            * field is still NULL. Try to            * do the job ourselves based on the "name" field            * in the SOM record. A complication here is that            * the name field contains only the function name            * (like "f"), whereas we want the class qualification            * (as in "c::f"). Try to reconstruct that.            */
name|char
modifier|*
name|basename
decl_stmt|;
name|char
modifier|*
name|classname
decl_stmt|;
name|char
modifier|*
name|dem_name
decl_stmt|;
name|basename
operator|=
name|VT
argument_list|(
name|objfile
argument_list|)
operator|+
name|dn_bufp
operator|->
name|ddocfunc
operator|.
name|name
expr_stmt|;
name|classname
operator|=
name|class_of
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|classname
condition|)
block|{
name|dem_name
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|basename
argument_list|)
operator|+
name|strlen
argument_list|(
name|classname
argument_list|)
operator|+
literal|3
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|dem_name
argument_list|,
name|classname
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|dem_name
argument_list|,
literal|"::"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|dem_name
argument_list|,
name|basename
argument_list|)
expr_stmt|;
name|SYMBOL_CPLUS_DEMANGLED_NAME
argument_list|(
name|sym
argument_list|)
operator|=
name|dem_name
expr_stmt|;
name|SYMBOL_LANGUAGE
argument_list|(
name|sym
argument_list|)
operator|=
name|language_cplus
expr_stmt|;
block|}
block|}
block|}
comment|/* Add the function symbol to the list of symbols in this blockvector */
if|if
condition|(
name|dn_bufp
operator|->
name|ddocfunc
operator|.
name|global
condition|)
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|global_symbols
argument_list|)
expr_stmt|;
else|else
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|file_symbols
argument_list|)
expr_stmt|;
name|new
operator|->
name|name
operator|=
name|sym
expr_stmt|;
comment|/* Search forward to the next BEGIN and also read        * in the line info up to that point.         * Not sure why this is needed.        * In HP FORTRAN this code is harmful since there           * may not be a BEGIN after the FUNCTION.        * So I made it C/C++ specific. - RT        */
if|if
condition|(
name|dn_bufp
operator|->
name|ddocfunc
operator|.
name|language
operator|==
name|HP_LANGUAGE_C
operator|||
name|dn_bufp
operator|->
name|ddocfunc
operator|.
name|language
operator|==
name|HP_LANGUAGE_CPLUSPLUS
condition|)
block|{
while|while
condition|(
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|!=
name|DNTT_TYPE_BEGIN
condition|)
block|{
name|dn_bufp
operator|=
name|hpread_get_lntt
argument_list|(
operator|++
name|index
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn_bufp
operator|->
name|dblock
operator|.
name|extension
condition|)
continue|continue;
block|}
name|SL_INDEX
argument_list|(
name|objfile
argument_list|)
operator|=
name|hpread_record_lines
argument_list|(
name|current_subfile
argument_list|,
name|SL_INDEX
argument_list|(
name|objfile
argument_list|)
argument_list|,
name|dn_bufp
operator|->
name|dbegin
operator|.
name|address
argument_list|,
name|objfile
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|SYMBOL_LINE
argument_list|(
name|sym
argument_list|)
operator|=
name|hpread_get_line
argument_list|(
name|dn_bufp
operator|->
name|dbegin
operator|.
name|address
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
name|record_line
argument_list|(
name|current_subfile
argument_list|,
name|SYMBOL_LINE
argument_list|(
name|sym
argument_list|)
argument_list|,
name|valu
argument_list|)
expr_stmt|;
break|break;
case|case
name|DNTT_TYPE_BEGIN
case|:
comment|/* Begin a new scope. */
if|if
condition|(
name|context_stack_depth
operator|==
literal|1
comment|/* this means we're at function level */
operator|&&
name|context_stack
index|[
literal|0
index|]
operator|.
name|name
operator|!=
name|NULL
comment|/* this means it's a function */
operator|&&
name|context_stack
index|[
literal|0
index|]
operator|.
name|depth
operator|==
literal|0
comment|/* this means it's the first BEGIN                                           we've seen after the FUNCTION */
condition|)
block|{
comment|/* This is the first BEGIN after a FUNCTION.          * We ignore this one, since HP compilers always insert          * at least one BEGIN, i.e. it's:          *           *     FUNCTION          *     argument symbols          *     BEGIN          *     local symbols          *        (possibly nested BEGIN ... END's if there are inner { } blocks)          *     END          *     END          *          * By ignoring this first BEGIN, the local symbols get treated          * as belonging to the function scope, and "print func::local_sym"          * works (which is what we want).          */
comment|/* All we do here is increase the depth count associated with          * the FUNCTION entry in the context stack. This ensures that          * the next BEGIN we see (if any), representing a real nested { }          * block, will get processed.          */
name|context_stack
index|[
literal|0
index|]
operator|.
name|depth
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* Record lines up to this SLT pointer. */
name|SL_INDEX
argument_list|(
name|objfile
argument_list|)
operator|=
name|hpread_record_lines
argument_list|(
name|current_subfile
argument_list|,
name|SL_INDEX
argument_list|(
name|objfile
argument_list|)
argument_list|,
name|dn_bufp
operator|->
name|dbegin
operator|.
name|address
argument_list|,
name|objfile
argument_list|,
name|offset
argument_list|)
expr_stmt|;
comment|/* Calculate start address of new scope */
name|valu
operator|=
name|hpread_get_location
argument_list|(
name|dn_bufp
operator|->
name|dbegin
operator|.
name|address
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|valu
operator|+=
name|offset
expr_stmt|;
comment|/* Relocate for dynamic loading */
comment|/* We use the scope start DNTT index as nesting depth identifier! */
name|desc
operator|=
name|hpread_get_scope_start
argument_list|(
name|dn_bufp
operator|->
name|dbegin
operator|.
name|address
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|new
operator|=
name|push_context
argument_list|(
name|desc
argument_list|,
name|valu
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DNTT_TYPE_END
case|:
comment|/* End a scope.  */
comment|/* Valid end kinds are:        *  MODULE        *  FUNCTION        *  WITH        *  COMMON        *  BEGIN        *  CLASS_SCOPE        */
name|SL_INDEX
argument_list|(
name|objfile
argument_list|)
operator|=
name|hpread_record_lines
argument_list|(
name|current_subfile
argument_list|,
name|SL_INDEX
argument_list|(
name|objfile
argument_list|)
argument_list|,
name|dn_bufp
operator|->
name|dend
operator|.
name|address
argument_list|,
name|objfile
argument_list|,
name|offset
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dn_bufp
operator|->
name|dend
operator|.
name|endkind
condition|)
block|{
case|case
name|DNTT_TYPE_MODULE
case|:
comment|/* Ending a module ends the symbol table for that module.              * Calling end_symtab() has the side effect of clearing the            * last_source_file pointer, which in turn signals             * process_one_debug_symbol() to treat the next DNTT_TYPE_SRCFILE            * record as a module-begin.            */
name|valu
operator|=
name|text_offset
operator|+
name|text_size
operator|+
name|offset
expr_stmt|;
comment|/* Tell our caller that we're done with expanding the            * debug information for a module.            */
operator|*
name|at_module_boundary_p
operator|=
literal|1
expr_stmt|;
comment|/* Don't do this, as our caller will do it!            *            *	  (void) end_symtab (valu, objfile, 0);            */
break|break;
case|case
name|DNTT_TYPE_FUNCTION
case|:
comment|/* Ending a function, well, ends the function's scope.  */
name|dn_temp
operator|=
name|hpread_get_lntt
argument_list|(
name|dn_bufp
operator|->
name|dend
operator|.
name|beginscope
operator|.
name|dnttp
operator|.
name|index
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|valu
operator|=
name|dn_temp
operator|->
name|dfunc
operator|.
name|hiaddr
operator|+
name|offset
expr_stmt|;
comment|/* Insert func params into local list */
name|merge_symbol_lists
argument_list|(
operator|&
name|param_symbols
argument_list|,
operator|&
name|local_symbols
argument_list|)
expr_stmt|;
name|new
operator|=
name|pop_context
argument_list|()
expr_stmt|;
comment|/* Make a block for the local symbols within.  */
name|finish_block
argument_list|(
name|new
operator|->
name|name
argument_list|,
operator|&
name|local_symbols
argument_list|,
name|new
operator|->
name|old_blocks
argument_list|,
name|new
operator|->
name|start_addr
argument_list|,
name|valu
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|WITHIN_FUNCTION
argument_list|(
name|objfile
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* This may have to change for Pascal */
name|local_symbols
operator|=
name|new
operator|->
name|locals
expr_stmt|;
name|param_symbols
operator|=
name|new
operator|->
name|params
expr_stmt|;
break|break;
case|case
name|DNTT_TYPE_BEGIN
case|:
if|if
condition|(
name|context_stack_depth
operator|==
literal|1
operator|&&
name|context_stack
index|[
literal|0
index|]
operator|.
name|name
operator|!=
name|NULL
operator|&&
name|context_stack
index|[
literal|0
index|]
operator|.
name|depth
operator|==
literal|1
condition|)
block|{
comment|/* This is the END corresponding to the              * BEGIN which we ignored - see DNTT_TYPE_BEGIN case above.              */
name|context_stack
index|[
literal|0
index|]
operator|.
name|depth
operator|--
expr_stmt|;
block|}
else|else
block|{
comment|/* Ending a local scope.  */
name|valu
operator|=
name|hpread_get_location
argument_list|(
name|dn_bufp
operator|->
name|dend
operator|.
name|address
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* Why in the hell is this needed?  */
name|valu
operator|+=
name|offset
operator|+
literal|9
expr_stmt|;
comment|/* Relocate for dynamic loading */
name|new
operator|=
name|pop_context
argument_list|()
expr_stmt|;
name|desc
operator|=
name|dn_bufp
operator|->
name|dend
operator|.
name|beginscope
operator|.
name|dnttp
operator|.
name|index
expr_stmt|;
if|if
condition|(
name|desc
operator|!=
name|new
operator|->
name|depth
condition|)
name|complain
argument_list|(
operator|&
name|lbrac_mismatch_complaint
argument_list|,
operator|(
name|char
operator|*
operator|)
name|symnum
argument_list|)
expr_stmt|;
comment|/* Make a block for the local symbols within.  */
name|finish_block
argument_list|(
name|new
operator|->
name|name
argument_list|,
operator|&
name|local_symbols
argument_list|,
name|new
operator|->
name|old_blocks
argument_list|,
name|new
operator|->
name|start_addr
argument_list|,
name|valu
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|local_symbols
operator|=
name|new
operator|->
name|locals
expr_stmt|;
name|param_symbols
operator|=
name|new
operator|->
name|params
expr_stmt|;
block|}
break|break;
case|case
name|DNTT_TYPE_WITH
case|:
comment|/* Since we ignore the DNTT_TYPE_WITH that starts the scope,            * we can ignore the DNTT_TYPE_END that ends it.            */
break|break;
case|case
name|DNTT_TYPE_COMMON
case|:
comment|/* End a FORTRAN common block. We don't currently handle these */
name|complain
argument_list|(
operator|&
name|hpread_unhandled_end_common_complaint
argument_list|)
expr_stmt|;
break|break;
case|case
name|DNTT_TYPE_CLASS_SCOPE
case|:
comment|/* pai: FIXME Not handling nested classes for now -- must            * maintain a stack */
name|class_scope_name
operator|=
name|NULL
expr_stmt|;
if|#
directive|if
literal|0
comment|/* End a class scope */
block|valu = hpread_get_location (dn_bufp->dend.address, objfile);
comment|/* Why in the hell is this needed?  */
block|valu += offset + 9;
comment|/* Relocate for dynamic loading */
block|new = pop_context (); 	  desc = dn_bufp->dend.beginscope.dnttp.index; 	  if (desc != new->depth) 	    complain (&lbrac_mismatch_complaint, (char *) symnum);
comment|/* Make a block for the local symbols within.  */
block|finish_block (new->name,&local_symbols, new->old_blocks, 			new->start_addr, valu, objfile); 	  local_symbols = new->locals; 	  param_symbols = new->params;
endif|#
directive|endif
break|break;
default|default:
name|complain
argument_list|(
operator|&
name|hpread_unexpected_end_complaint
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
comment|/* DNTT_TYPE_IMPORT is not handled */
case|case
name|DNTT_TYPE_LABEL
case|:
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
name|LABEL_NAMESPACE
expr_stmt|;
break|break;
case|case
name|DNTT_TYPE_FPARAM
case|:
comment|/* Function parameters.  */
comment|/* Note 1: This code was present in the 4.16 sources, and then          removed, because fparams are handled in          hpread_read_function_type().  However, while fparam symbols          are indeed handled twice, this code here cannot be removed          because then they don't get added to the local symbol list of          the function's code block, which leads to a failure to look          up locals, "this"-relative member names, etc.  So I've put          this code back in. pai/1997-07-21 */
comment|/* Note 2: To fix a defect, we stopped adding FPARAMS to local_symbols          in hpread_read_function_type(), so FPARAMS had to be handled          here.  I changed the location to be the appropriate argument          kinds rather than LOC_LOCAL. pai/1997-08-08 */
comment|/* Note 3: Well, the fix in Note 2 above broke argument printing          in traceback frames, and further it makes assumptions about the          order of the FPARAM entries from HP compilers (cc and aCC in particular          generate them in reverse orders -- fixing one breaks for the other).          So I've added code in hpread_read_function_type() to add fparams          to a param_symbols list for the current context level.  These are          then merged into local_symbols when a function end is reached.          pai/1997-08-11 */
break|break;
comment|/* do nothing; handled in hpread_read_function_type() */
if|#
directive|if
literal|0
comment|/* Old code */
block|if (dn_bufp->dfparam.regparam)         SYMBOL_CLASS (sym) = LOC_REGISTER;       else if (dn_bufp->dfparam.indirect) 	SYMBOL_CLASS (sym) = LOC_REF_ARG;       else 	SYMBOL_CLASS (sym) = LOC_ARG;       SYMBOL_NAMESPACE (sym) = VAR_NAMESPACE;       if (dn_bufp->dfparam.copyparam)         {           SYMBOL_VALUE (sym) = dn_bufp->dfparam.location;
ifdef|#
directive|ifdef
name|HPREAD_ADJUST_STACK_ADDRESS
block|SYMBOL_VALUE (sym)             += HPREAD_ADJUST_STACK_ADDRESS (CURRENT_FUNCTION_VALUE (objfile));
endif|#
directive|endif
block|}       else         SYMBOL_VALUE (sym) = dn_bufp->dfparam.location;       SYMBOL_TYPE (sym) = hpread_type_lookup (dn_bufp->dfparam.type, objfile);       add_symbol_to_list (sym,&fparam_symbols);       break;
endif|#
directive|endif
case|case
name|DNTT_TYPE_SVAR
case|:
comment|/* Static variables.  */
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_STATIC
expr_stmt|;
comment|/* Note: There is a case that arises with globals in shared        * libraries where we need to set the address to LOC_INDIRECT.        * This case is if you have a global "g" in one library, and        * it is referenced "extern<type> g;" in another library.        * If we're processing the symbols for the referencing library,        * we'll see a global "g", but in this case the address given        * in the symbol table contains a pointer to the real "g".        * We use the storage class LOC_INDIRECT to indicate this. RT        */
if|if
condition|(
name|is_in_import_list
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|objfile
argument_list|)
condition|)
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_INDIRECT
expr_stmt|;
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym
argument_list|)
operator|=
name|dn_bufp
operator|->
name|dsvar
operator|.
name|location
operator|+
name|data_offset
expr_stmt|;
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|hpread_type_lookup
argument_list|(
name|dn_bufp
operator|->
name|dsvar
operator|.
name|type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn_bufp
operator|->
name|dsvar
operator|.
name|global
condition|)
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|global_symbols
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|WITHIN_FUNCTION
argument_list|(
name|objfile
argument_list|)
condition|)
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|local_symbols
argument_list|)
expr_stmt|;
else|else
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|file_symbols
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn_bufp
operator|->
name|dsvar
operator|.
name|thread_specific
condition|)
block|{
comment|/* Thread-local variable.            */
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_THREAD_LOCAL_STATIC
expr_stmt|;
name|SYMBOL_BASEREG
argument_list|(
name|sym
argument_list|)
operator|=
name|CR27_REGNUM
expr_stmt|;
if|if
condition|(
name|objfile
operator|->
name|flags
operator|&
name|OBJF_SHARED
condition|)
block|{
comment|/*                * This variable is not only thread local but                * in a shared library.                *                * Alas, the shared lib structures are private                * to "somsolib.c".  But C lets us point to one.                */
name|struct
name|so_list
modifier|*
name|so
decl_stmt|;
if|if
condition|(
name|objfile
operator|->
name|obj_private
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Internal error in reading shared library information."
argument_list|)
expr_stmt|;
name|so
operator|=
operator|(
operator|(
name|obj_private_data_t
operator|*
operator|)
operator|(
name|objfile
operator|->
name|obj_private
operator|)
operator|)
operator|->
name|so_info
expr_stmt|;
if|if
condition|(
name|so
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Internal error in reading shared library information."
argument_list|)
expr_stmt|;
comment|/* Thread-locals in shared libraries do NOT have the                * standard offset ("data_offset"), so we re-calculate                * where to look for this variable, using a call-back                * to interpret the private shared-library data.                */
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym
argument_list|)
operator|=
name|dn_bufp
operator|->
name|dsvar
operator|.
name|location
operator|+
name|so_lib_thread_start_addr
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|DNTT_TYPE_DVAR
case|:
comment|/* Dynamic variables.  */
if|if
condition|(
name|dn_bufp
operator|->
name|ddvar
operator|.
name|regvar
condition|)
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_REGISTER
expr_stmt|;
else|else
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_LOCAL
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|dn_bufp
operator|->
name|ddvar
operator|.
name|location
expr_stmt|;
ifdef|#
directive|ifdef
name|HPREAD_ADJUST_STACK_ADDRESS
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|+=
name|HPREAD_ADJUST_STACK_ADDRESS
argument_list|(
name|CURRENT_FUNCTION_VALUE
argument_list|(
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|hpread_type_lookup
argument_list|(
name|dn_bufp
operator|->
name|ddvar
operator|.
name|type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn_bufp
operator|->
name|ddvar
operator|.
name|global
condition|)
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|global_symbols
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|WITHIN_FUNCTION
argument_list|(
name|objfile
argument_list|)
condition|)
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|local_symbols
argument_list|)
expr_stmt|;
else|else
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|file_symbols
argument_list|)
expr_stmt|;
break|break;
case|case
name|DNTT_TYPE_CONST
case|:
comment|/* A constant (pascal?).  */
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_CONST
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|dn_bufp
operator|->
name|dconst
operator|.
name|location
expr_stmt|;
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|hpread_type_lookup
argument_list|(
name|dn_bufp
operator|->
name|dconst
operator|.
name|type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn_bufp
operator|->
name|dconst
operator|.
name|global
condition|)
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|global_symbols
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|WITHIN_FUNCTION
argument_list|(
name|objfile
argument_list|)
condition|)
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|local_symbols
argument_list|)
expr_stmt|;
else|else
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|file_symbols
argument_list|)
expr_stmt|;
break|break;
case|case
name|DNTT_TYPE_TYPEDEF
case|:
comment|/* A typedef. We do want to process these, since a name is        * added to the namespace for the typedef'ed name.        */
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|hpread_type_lookup
argument_list|(
name|dn_bufp
operator|->
name|dtype
operator|.
name|type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn_bufp
operator|->
name|dtype
operator|.
name|global
condition|)
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|global_symbols
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|WITHIN_FUNCTION
argument_list|(
name|objfile
argument_list|)
condition|)
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|local_symbols
argument_list|)
expr_stmt|;
else|else
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|file_symbols
argument_list|)
expr_stmt|;
break|break;
case|case
name|DNTT_TYPE_TAGDEF
case|:
block|{
name|int
name|global
init|=
name|dn_bufp
operator|->
name|dtag
operator|.
name|global
decl_stmt|;
comment|/* Structure, union, enum, template, or class tag definition */
comment|/* We do want to process these, since a name is        * added to the namespace for the tag name (and if C++ class,        * for the typename also).        */
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
name|STRUCT_NAMESPACE
expr_stmt|;
comment|/* The tag contains in its "type" field a pointer to the        * DNTT_TYPE_STRUCT, DNTT_TYPE_UNION, DNTT_TYPE_ENUM,         * DNTT_TYPE_CLASS or DNTT_TYPE_TEMPLATE        * record that actually defines the type.        */
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|hpread_type_lookup
argument_list|(
name|dn_bufp
operator|->
name|dtype
operator|.
name|type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|sym
operator|->
name|type
argument_list|)
operator|=
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|TYPE_TAG_NAME
argument_list|(
name|sym
operator|->
name|type
argument_list|)
operator|=
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn_bufp
operator|->
name|dtag
operator|.
name|global
condition|)
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|global_symbols
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|WITHIN_FUNCTION
argument_list|(
name|objfile
argument_list|)
condition|)
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|local_symbols
argument_list|)
expr_stmt|;
else|else
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|file_symbols
argument_list|)
expr_stmt|;
comment|/* If this is a C++ class, then we additionally         * need to define a typedef for the        * class type. E.g., so that the name "c" becomes visible as        * a type name when the user says "class c { ... }".        * In order to figure this out, we need to chase down the "type"        * field to get to the DNTT_TYPE_CLASS record.         *        * We also add the typename for ENUM. Though this isn't        * strictly correct, it is necessary because of the debug info        * generated by the aCC compiler, in which we cannot        * distinguish between:        *   enum e { ... };        * and        *   typedef enum { ... } e;        * I.e., the compiler emits the same debug info for the above        * two cases, in both cases "e" appearing as a tagdef.        * Therefore go ahead and generate the typename so that        * "ptype e" will work in the above cases.        *        * We also add the typename for TEMPLATE, so as to allow "ptype t"        * when "t" is a template name.         */
if|if
condition|(
name|dn_bufp
operator|->
name|dtype
operator|.
name|type
operator|.
name|dnttp
operator|.
name|index
operator|<
name|LNTT_SYMCOUNT
argument_list|(
name|objfile
argument_list|)
condition|)
name|dn_bufp
operator|=
name|hpread_get_lntt
argument_list|(
name|dn_bufp
operator|->
name|dtag
operator|.
name|type
operator|.
name|dnttp
operator|.
name|index
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
else|else
block|{
name|complain
argument_list|(
operator|&
name|hpread_tagdef_complaint
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_CLASS
operator|||
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_ENUM
operator|||
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_TEMPLATE
condition|)
block|{
name|struct
name|symbol
modifier|*
name|newsym
decl_stmt|;
name|newsym
operator|=
operator|(
expr|struct
name|symbol
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|newsym
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
name|SYMBOL_NAME
argument_list|(
name|newsym
argument_list|)
operator|=
name|name
expr_stmt|;
name|SYMBOL_LANGUAGE
argument_list|(
name|newsym
argument_list|)
operator|=
name|language_auto
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|newsym
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
name|SYMBOL_LINE
argument_list|(
name|newsym
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|newsym
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|newsym
argument_list|)
operator|=
name|LOC_TYPEDEF
expr_stmt|;
name|SYMBOL_TYPE
argument_list|(
name|newsym
argument_list|)
operator|=
name|sym
operator|->
name|type
expr_stmt|;
if|if
condition|(
name|global
condition|)
name|add_symbol_to_list
argument_list|(
name|newsym
argument_list|,
operator|&
name|global_symbols
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|WITHIN_FUNCTION
argument_list|(
name|objfile
argument_list|)
condition|)
name|add_symbol_to_list
argument_list|(
name|newsym
argument_list|,
operator|&
name|local_symbols
argument_list|)
expr_stmt|;
else|else
name|add_symbol_to_list
argument_list|(
name|newsym
argument_list|,
operator|&
name|file_symbols
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|DNTT_TYPE_POINTER
case|:
comment|/* Declares a pointer type. Should not be necessary to do anything        * with the type at this level; these are processed        * at the hpread_type_lookup() level.         */
break|break;
case|case
name|DNTT_TYPE_ENUM
case|:
comment|/* Declares an enum type. Should not be necessary to do anything        * with the type at this level; these are processed        * at the hpread_type_lookup() level.         */
break|break;
case|case
name|DNTT_TYPE_MEMENUM
case|:
comment|/* Member of enum */
comment|/* Ignored at this level, but hpread_read_enum_type() will take        * care of walking the list of enumeration members.        */
break|break;
case|case
name|DNTT_TYPE_SET
case|:
comment|/* Declares a set type. Should not be necessary to do anything        * with the type at this level; these are processed        * at the hpread_type_lookup() level.         */
break|break;
case|case
name|DNTT_TYPE_SUBRANGE
case|:
comment|/* Declares a subrange type. Should not be necessary to do anything        * with the type at this level; these are processed        * at the hpread_type_lookup() level.         */
break|break;
case|case
name|DNTT_TYPE_ARRAY
case|:
comment|/* Declares an array type. Should not be necessary to do anything        * with the type at this level; these are processed        * at the hpread_type_lookup() level.         */
break|break;
case|case
name|DNTT_TYPE_STRUCT
case|:
case|case
name|DNTT_TYPE_UNION
case|:
comment|/* Declares an struct/union type.         * Should not be necessary to do anything        * with the type at this level; these are processed        * at the hpread_type_lookup() level.         */
break|break;
case|case
name|DNTT_TYPE_FIELD
case|:
comment|/* Structure/union/class field */
comment|/* Ignored at this level, but hpread_read_struct_type() will take        * care of walking the list of structure/union/class members.        */
break|break;
comment|/* DNTT_TYPE_VARIANT is not handled by GDB */
comment|/* DNTT_TYPE_FILE is not handled by GDB */
case|case
name|DNTT_TYPE_FUNCTYPE
case|:
comment|/* Function type */
comment|/* Ignored at this level, handled within hpread_type_lookup() */
break|break;
case|case
name|DNTT_TYPE_WITH
case|:
comment|/* This is emitted within methods to indicate "with<class>"         * scoping rules (i.e., indicate that the class data members        * are directly visible).        * However, since GDB already infers this by looking at the        * "this" argument, interpreting the DNTT_TYPE_WITH         * symbol record is unnecessary.        */
break|break;
case|case
name|DNTT_TYPE_COMMON
case|:
comment|/* FORTRAN common. Not yet handled. */
name|complain
argument_list|(
operator|&
name|hpread_unhandled_common_complaint
argument_list|)
expr_stmt|;
break|break;
comment|/* DNTT_TYPE_COBSTRUCT is not handled by GDB.  */
comment|/* DNTT_TYPE_XREF is not handled by GDB.  */
comment|/* DNTT_TYPE_SA is not handled by GDB.  */
comment|/* DNTT_TYPE_MACRO is not handled by GDB */
case|case
name|DNTT_TYPE_BLOCKDATA
case|:
comment|/* Not sure what this is - part of FORTRAN support maybe?         * Anyway, not yet handled.        */
name|complain
argument_list|(
operator|&
name|hpread_unhandled_blockdata_complaint
argument_list|)
expr_stmt|;
break|break;
case|case
name|DNTT_TYPE_CLASS_SCOPE
case|:
comment|/* The compiler brackets member functions with a CLASS_SCOPE/END        * pair of records, presumably to put them in a different scope        * from the module scope where they are normally defined.        * E.g., in the situation:        *   void f() { ... }        *   void c::f() { ...}        * The member function "c::f" will be bracketed by a CLASS_SCOPE/END.        * This causes "break f" at the module level to pick the        * the file-level function f(), not the member function        * (which needs to be referenced via "break c::f").         *         * Here we record the class name to generate the demangled names of        * member functions later.        *        * FIXME Not being used now for anything -- cplus_demangle seems        * enough for getting the class-qualified names of functions. We        * may need this for handling nested classes and types.  */
comment|/* pai: FIXME Not handling nested classes for now -- need to        * maintain a stack */
name|dn_temp
operator|=
name|hpread_get_lntt
argument_list|(
name|dn_bufp
operator|->
name|dclass_scope
operator|.
name|type
operator|.
name|dnttp
operator|.
name|index
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn_temp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_TAGDEF
condition|)
name|class_scope_name
operator|=
name|VT
argument_list|(
name|objfile
argument_list|)
operator|+
name|dn_temp
operator|->
name|dtag
operator|.
name|name
expr_stmt|;
else|else
name|class_scope_name
operator|=
name|NULL
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Begin a new scope.  */
block|SL_INDEX (objfile) = hpread_record_lines (current_subfile, 						SL_INDEX (objfile), 						dn_bufp->dclass_scope.address, 						objfile, offset);       valu = hpread_get_location (dn_bufp->dclass_scope.address, objfile);       valu += offset;
comment|/* Relocate for dynamic loading */
block|desc = hpread_get_scope_start (dn_bufp->dclass_scope.address, objfile);
comment|/* We use the scope start DNTT index as the nesting depth identifier! */
block|new = push_context (desc, valu);
endif|#
directive|endif
break|break;
case|case
name|DNTT_TYPE_REFERENCE
case|:
comment|/* Declares a C++ reference type. Should not be necessary to do anything        * with the type at this level; these are processed        * at the hpread_type_lookup() level.        */
break|break;
case|case
name|DNTT_TYPE_PTRMEM
case|:
comment|/* Declares a C++ pointer-to-data-member type. This does not        * need to be handled at this level; being a type description it        * is instead handled at the hpread_type_lookup() level.        */
break|break;
case|case
name|DNTT_TYPE_PTRMEMFUNC
case|:
comment|/* Declares a C++ pointer-to-function-member type. This does not        * need to be handled at this level; being a type description it        * is instead handled at the hpread_type_lookup() level.        */
break|break;
case|case
name|DNTT_TYPE_CLASS
case|:
comment|/* Declares a class type.         * Should not be necessary to do anything        * with the type at this level; these are processed        * at the hpread_type_lookup() level.         */
break|break;
case|case
name|DNTT_TYPE_GENFIELD
case|:
comment|/* I believe this is used for class member functions */
comment|/* Ignored at this level, but hpread_read_struct_type() will take        * care of walking the list of class members.        */
break|break;
case|case
name|DNTT_TYPE_VFUNC
case|:
comment|/* Virtual function */
comment|/* This does not have to be handled at this level; handled in        * the course of processing class symbols.        */
break|break;
case|case
name|DNTT_TYPE_MEMACCESS
case|:
comment|/* DDE ignores this symbol table record.        * It has something to do with "modified access" to class members.        * I'll assume we can safely ignore it too.        */
break|break;
case|case
name|DNTT_TYPE_INHERITANCE
case|:
comment|/* These don't have to be handled here, since they are handled        * within hpread_read_struct_type() in the process of constructing        * a class type.        */
break|break;
case|case
name|DNTT_TYPE_FRIEND_CLASS
case|:
case|case
name|DNTT_TYPE_FRIEND_FUNC
case|:
comment|/* These can safely be ignored, as GDB doesn't need this        * info. DDE only uses it in "describe". We may later want        * to extend GDB's "ptype" to give this info, but for now        * it seems safe enough to ignore it.        */
break|break;
case|case
name|DNTT_TYPE_MODIFIER
case|:
comment|/* Intended to supply "modified access" to a type */
comment|/* From the way DDE handles this, it looks like it always        * modifies a type. Therefore it is safe to ignore it at this        * level, and handle it in hpread_type_lookup().        */
break|break;
case|case
name|DNTT_TYPE_OBJECT_ID
case|:
comment|/* Just ignore this - that's all DDE does */
break|break;
case|case
name|DNTT_TYPE_MEMFUNC
case|:
comment|/* Member function */
comment|/* This does not have to be handled at this level; handled in        * the course of processing class symbols.        */
break|break;
case|case
name|DNTT_TYPE_DOC_MEMFUNC
case|:
comment|/* Member function */
comment|/* This does not have to be handled at this level; handled in        * the course of processing class symbols.        */
break|break;
case|case
name|DNTT_TYPE_TEMPLATE
case|:
comment|/* Template - sort of the header for a template definition,        * which like a class, points to a member list and also points        * to a TEMPLATE_ARG list of type-arguments.        * We do not need to process TEMPLATE records at this level though.        */
break|break;
case|case
name|DNTT_TYPE_TEMPLATE_ARG
case|:
comment|/* The TEMPLATE record points to an argument list of        * TEMPLATE_ARG records, each of which describes one        * of the type-arguments.        * We do not need to process TEMPLATE_ARG records at this level though.        */
break|break;
case|case
name|DNTT_TYPE_FUNC_TEMPLATE
case|:
comment|/* This will get emitted for member functions of templates.        * But we don't need to process this record at this level though,        * we will process it in the course of processing a TEMPLATE        * record.        */
break|break;
case|case
name|DNTT_TYPE_LINK
case|:
comment|/* The LINK record is used to link up templates with instantiations. */
comment|/* It is not clear why this is needed, and furthermore aCC does        * not appear to generate this, so I think we can safely ignore it. - RT        */
break|break;
comment|/* DNTT_TYPE_DYN_ARRAY_DESC is not handled by GDB */
comment|/* DNTT_TYPE_DESC_SUBRANGE is not handled by GDB */
comment|/* DNTT_TYPE_BEGIN_EXT is not handled by GDB */
comment|/* DNTT_TYPE_INLN is not handled by GDB */
comment|/* DNTT_TYPE_INLN_LIST is not handled by GDB */
comment|/* DNTT_TYPE_ALIAS is not handled by GDB */
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Get nesting depth for a DNTT entry.  * DN_BUFP points to a DNTT entry.  * OBJFILE is the object file.  * REPORT_NESTED is a flag; if 0, real nesting depth is  * reported, if it is 1, the function simply returns a   * non-zero value if the nesting depth is anything> 0.  *   * Return value is an integer.  0 => not a local type / name  * positive return => type or name is local to some   * block or function.  */
end_comment

begin_comment
comment|/* elz: ATTENTION: FIXME: NOTE: WARNING!!!!    this function now returns 0 right away. It was taking too much time    at start up. Now, though, the local types are not handled correctly. */
end_comment

begin_function
specifier|static
name|int
name|hpread_get_scope_depth
parameter_list|(
name|dn_bufp
parameter_list|,
name|objfile
parameter_list|,
name|report_nested
parameter_list|)
name|union
name|dnttentry
modifier|*
name|dn_bufp
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|int
name|report_nested
decl_stmt|;
block|{
specifier|register
name|int
name|index
decl_stmt|;
specifier|register
name|union
name|dnttentry
modifier|*
name|dn_tmp
decl_stmt|;
specifier|register
name|short
name|depth
init|=
literal|0
decl_stmt|;
comment|/****************************/
return|return
literal|0
return|;
comment|/****************************/
name|index
operator|=
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|dn_bufp
operator|)
operator|-
name|LNTT
argument_list|(
name|objfile
argument_list|)
operator|)
operator|/
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|dntt_type_block
argument_list|)
operator|)
expr_stmt|;
while|while
condition|(
operator|--
name|index
operator|>=
literal|0
condition|)
block|{
name|dn_tmp
operator|=
name|hpread_get_lntt
argument_list|(
name|index
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dn_tmp
operator|->
name|dblock
operator|.
name|kind
condition|)
block|{
case|case
name|DNTT_TYPE_MODULE
case|:
return|return
name|depth
return|;
case|case
name|DNTT_TYPE_END
case|:
comment|/* index is signed int; dnttp.index is 29-bit unsigned int! */
name|index
operator|=
operator|(
name|int
operator|)
name|dn_tmp
operator|->
name|dend
operator|.
name|beginscope
operator|.
name|dnttp
operator|.
name|index
expr_stmt|;
break|break;
case|case
name|DNTT_TYPE_BEGIN
case|:
case|case
name|DNTT_TYPE_FUNCTION
case|:
case|case
name|DNTT_TYPE_DOC_FUNCTION
case|:
case|case
name|DNTT_TYPE_WITH
case|:
case|case
name|DNTT_TYPE_COMMON
case|:
case|case
name|DNTT_TYPE_CLASS_SCOPE
case|:
name|depth
operator|++
expr_stmt|;
if|if
condition|(
name|report_nested
condition|)
return|return
literal|1
return|;
break|break;
default|default:
break|break;
block|}
block|}
return|return
name|depth
return|;
block|}
end_function

begin_comment
comment|/* Adjust the bitoffsets for all fields of an anonymous union of    type TYPE by negative BITS.  This handles HP aCC's hideous habit    of giving members of anonymous unions bit offsets relative to the    enclosing structure instead of relative to the union itself. */
end_comment

begin_function
specifier|static
name|void
name|hpread_adjust_bitoffsets
parameter_list|(
name|type
parameter_list|,
name|bits
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|int
name|bits
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* This is done only for unions; caller had better check that      it is an anonymous one. */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_CODE_UNION
condition|)
return|return;
comment|/* Adjust each field; since this is a union, there are no base      classes. Also no static membes.  Also, no need for recursion as      the members of this union if themeselves structs or unions, have      the correct bitoffsets; if an anonymous union is a member of this      anonymous union, the code in hpread_read_struct_type() will      adjust for that. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
condition|;
name|i
operator|++
control|)
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
operator|-=
name|bits
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Because of quirks in HP compilers' treatment of anonymous unions inside    classes, we have to chase through a chain of threaded FIELD entries.    If we encounter an anonymous union in the chain, we must recursively skip over    that too.     This function does a "next" in the chain of FIELD entries, but transparently    skips over anonymous unions' fields (recursively).        Inputs are the number of times to do "next" at the top level, the dnttpointer    (FIELD) and entry pointer (FIELDP) for the dntt record corresponding to it,    and the ubiquitous objfile parameter. (Note: FIELDP is a **.)  Return value    is a dnttpointer for the new field after all the skipped ones */
end_comment

begin_function
specifier|static
name|dnttpointer
name|hpread_get_next_skip_over_anon_unions
parameter_list|(
name|skip_fields
parameter_list|,
name|field
parameter_list|,
name|fieldp
parameter_list|,
name|objfile
parameter_list|)
name|int
name|skip_fields
decl_stmt|;
name|dnttpointer
name|field
decl_stmt|;
name|union
name|dnttentry
modifier|*
modifier|*
name|fieldp
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|struct
name|type
modifier|*
name|anon_type
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|bitoffset
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|skip_fields
condition|;
name|i
operator|++
control|)
block|{
comment|/* Get type of item we're looking at now; recursively processes the types          of these intermediate items we skip over, so they aren't lost. */
name|anon_type
operator|=
name|hpread_type_lookup
argument_list|(
operator|(
operator|*
name|fieldp
operator|)
operator|->
name|dfield
operator|.
name|type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|anon_type
operator|=
name|CHECK_TYPEDEF
argument_list|(
name|anon_type
argument_list|)
expr_stmt|;
name|bitoffset
operator|=
operator|(
operator|*
name|fieldp
operator|)
operator|->
name|dfield
operator|.
name|bitoffset
expr_stmt|;
name|name
operator|=
name|VT
argument_list|(
name|objfile
argument_list|)
operator|+
operator|(
operator|*
name|fieldp
operator|)
operator|->
name|dfield
operator|.
name|name
expr_stmt|;
comment|/* First skip over one item to avoid stack death on recursion */
name|field
operator|=
operator|(
operator|*
name|fieldp
operator|)
operator|->
name|dfield
operator|.
name|nextfield
expr_stmt|;
operator|*
name|fieldp
operator|=
name|hpread_get_lntt
argument_list|(
name|field
operator|.
name|dnttp
operator|.
name|index
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* Do we have another anonymous union? If so, adjust the bitoffsets          of its members and skip over its members. */
if|if
condition|(
operator|(
name|TYPE_CODE
argument_list|(
name|anon_type
argument_list|)
operator|==
name|TYPE_CODE_UNION
operator|)
operator|&&
operator|(
operator|!
name|name
operator|||
name|STREQ
argument_list|(
name|name
argument_list|,
literal|""
argument_list|)
operator|)
condition|)
block|{
name|hpread_adjust_bitoffsets
argument_list|(
name|anon_type
argument_list|,
name|bitoffset
argument_list|)
expr_stmt|;
name|field
operator|=
name|hpread_get_next_skip_over_anon_unions
argument_list|(
name|TYPE_NFIELDS
argument_list|(
name|anon_type
argument_list|)
argument_list|,
name|field
argument_list|,
name|fieldp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|field
return|;
block|}
end_function

end_unit

