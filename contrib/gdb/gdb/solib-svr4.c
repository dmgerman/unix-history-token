begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Handle SVR4 shared libraries for GDB, the GNU Debugger.    Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000,    2001    Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"elf/external.h"
end_include

begin_include
include|#
directive|include
file|"elf/common.h"
end_include

begin_include
include|#
directive|include
file|"elf/mips.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"solist.h"
end_include

begin_include
include|#
directive|include
file|"solib-svr4.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|SVR4_FETCH_LINK_MAP_OFFSETS
end_ifndef

begin_define
define|#
directive|define
name|SVR4_FETCH_LINK_MAP_OFFSETS
parameter_list|()
value|svr4_fetch_link_map_offsets ()
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|struct
name|link_map_offsets
modifier|*
name|svr4_fetch_link_map_offsets
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|link_map_offsets
modifier|*
name|legacy_fetch_link_map_offsets
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* fetch_link_map_offsets_gdbarch_data is a handle used to obtain the    architecture specific link map offsets fetching function.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|gdbarch_data
modifier|*
name|fetch_link_map_offsets_gdbarch_data
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* legacy_svr4_fetch_link_map_offsets_hook is a pointer to a function    which is used to fetch link map offsets.  It will only be set    by solib-legacy.c, if at all. */
end_comment

begin_function_decl
name|struct
name|link_map_offsets
modifier|*
function_decl|(
modifier|*
name|legacy_svr4_fetch_link_map_offsets_hook
function_decl|)
parameter_list|(
name|void
parameter_list|)
init|=
literal|0
function_decl|;
end_function_decl

begin_comment
comment|/* Link map info to include in an allocated so_list entry */
end_comment

begin_struct
struct|struct
name|lm_info
block|{
comment|/* Pointer to copy of link map from inferior.  The type is char *        rather than void *, so that we may use byte offsets to find the        various fields without the need for a cast.  */
name|char
modifier|*
name|lm
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* On SVR4 systems, a list of symbols in the dynamic linker where    GDB can try to place a breakpoint to monitor shared library    events.     If none of these symbols are found, or other errors occur, then    SVR4 systems will fall back to using a symbol as the "startup    mapping complete" breakpoint address.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|solib_break_names
index|[]
init|=
block|{
literal|"r_debug_state"
block|,
literal|"_r_debug_state"
block|,
literal|"_dl_debug_state"
block|,
literal|"rtld_db_dlactivity"
block|,
literal|"_rtld_debug_state"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|BKPT_AT_SYMBOL
value|1
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|BKPT_AT_SYMBOL
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|char
modifier|*
name|bkpt_names
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|SOLIB_BKPT_NAME
name|SOLIB_BKPT_NAME
block|,
comment|/* Prefer configured name if it exists. */
endif|#
directive|endif
literal|"_start"
block|,
literal|"main"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|char
modifier|*
name|main_name_list
index|[]
init|=
block|{
literal|"main_$main"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Macro to extract an address from a solib structure.    When GDB is configured for some 32-bit targets (e.g. Solaris 2.7    sparc), BFD is configured to handle 64-bit targets, so CORE_ADDR is    64 bits.  We have to extract only the significant bits of addresses    to get the right address when accessing the core file BFD.  */
end_comment

begin_define
define|#
directive|define
name|SOLIB_EXTRACT_ADDRESS
parameter_list|(
name|MEMBER
parameter_list|)
define|\
value|extract_address (&(MEMBER), sizeof (MEMBER))
end_define

begin_comment
comment|/* local data declarations */
end_comment

begin_comment
comment|/* link map access functions */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|LM_ADDR
parameter_list|(
name|struct
name|so_list
modifier|*
name|so
parameter_list|)
block|{
name|struct
name|link_map_offsets
modifier|*
name|lmo
init|=
name|SVR4_FETCH_LINK_MAP_OFFSETS
argument_list|()
decl_stmt|;
return|return
operator|(
name|CORE_ADDR
operator|)
name|extract_signed_integer
argument_list|(
name|so
operator|->
name|lm_info
operator|->
name|lm
operator|+
name|lmo
operator|->
name|l_addr_offset
argument_list|,
name|lmo
operator|->
name|l_addr_size
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|CORE_ADDR
name|LM_NEXT
parameter_list|(
name|struct
name|so_list
modifier|*
name|so
parameter_list|)
block|{
name|struct
name|link_map_offsets
modifier|*
name|lmo
init|=
name|SVR4_FETCH_LINK_MAP_OFFSETS
argument_list|()
decl_stmt|;
return|return
name|extract_address
argument_list|(
name|so
operator|->
name|lm_info
operator|->
name|lm
operator|+
name|lmo
operator|->
name|l_next_offset
argument_list|,
name|lmo
operator|->
name|l_next_size
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|CORE_ADDR
name|LM_NAME
parameter_list|(
name|struct
name|so_list
modifier|*
name|so
parameter_list|)
block|{
name|struct
name|link_map_offsets
modifier|*
name|lmo
init|=
name|SVR4_FETCH_LINK_MAP_OFFSETS
argument_list|()
decl_stmt|;
return|return
name|extract_address
argument_list|(
name|so
operator|->
name|lm_info
operator|->
name|lm
operator|+
name|lmo
operator|->
name|l_name_offset
argument_list|,
name|lmo
operator|->
name|l_name_size
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|IGNORE_FIRST_LINK_MAP_ENTRY
parameter_list|(
name|struct
name|so_list
modifier|*
name|so
parameter_list|)
block|{
name|struct
name|link_map_offsets
modifier|*
name|lmo
init|=
name|SVR4_FETCH_LINK_MAP_OFFSETS
argument_list|()
decl_stmt|;
return|return
name|extract_address
argument_list|(
name|so
operator|->
name|lm_info
operator|->
name|lm
operator|+
name|lmo
operator|->
name|l_prev_offset
argument_list|,
name|lmo
operator|->
name|l_prev_size
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|debug_base
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Base of dynamic linker structures */
end_comment

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|breakpoint_addr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Address where end bkpt is set */
end_comment

begin_comment
comment|/* Local function prototypes */
end_comment

begin_function_decl
specifier|static
name|int
name|match_main
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|CORE_ADDR
name|bfd_lookup_symbol
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*     LOCAL FUNCTION     bfd_lookup_symbol -- lookup the value for a specific symbol     SYNOPSIS     CORE_ADDR bfd_lookup_symbol (bfd *abfd, char *symname)     DESCRIPTION     An expensive way to lookup the value of a single symbol for    bfd's that are only temporary anyway.  This is used by the    shared library support to find the address of the debugger    interface structures in the shared library.     Note that 0 is specifically allowed as an error return (no    such symbol).  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|bfd_lookup_symbol
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|char
modifier|*
name|symname
parameter_list|)
block|{
name|long
name|storage_needed
decl_stmt|;
name|asymbol
modifier|*
name|sym
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symbol_table
decl_stmt|;
name|unsigned
name|int
name|number_of_symbols
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|back_to
decl_stmt|;
name|CORE_ADDR
name|symaddr
init|=
literal|0
decl_stmt|;
name|storage_needed
operator|=
name|bfd_get_symtab_upper_bound
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|storage_needed
operator|>
literal|0
condition|)
block|{
name|symbol_table
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|storage_needed
argument_list|)
expr_stmt|;
name|back_to
operator|=
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
operator|(
name|PTR
operator|)
name|symbol_table
argument_list|)
expr_stmt|;
name|number_of_symbols
operator|=
name|bfd_canonicalize_symtab
argument_list|(
name|abfd
argument_list|,
name|symbol_table
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|number_of_symbols
condition|;
name|i
operator|++
control|)
block|{
name|sym
operator|=
operator|*
name|symbol_table
operator|++
expr_stmt|;
if|if
condition|(
name|STREQ
argument_list|(
name|sym
operator|->
name|name
argument_list|,
name|symname
argument_list|)
condition|)
block|{
comment|/* Bfd symbols are section relative. */
name|symaddr
operator|=
name|sym
operator|->
name|value
operator|+
name|sym
operator|->
name|section
operator|->
name|vma
expr_stmt|;
break|break;
block|}
block|}
name|do_cleanups
argument_list|(
name|back_to
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|symaddr
condition|)
return|return
name|symaddr
return|;
comment|/* On FreeBSD, the dynamic linker is stripped by default.  So we'll      have to check the dynamic string table too.  */
name|storage_needed
operator|=
name|bfd_get_dynamic_symtab_upper_bound
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|storage_needed
operator|>
literal|0
condition|)
block|{
name|symbol_table
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|storage_needed
argument_list|)
expr_stmt|;
name|back_to
operator|=
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
operator|(
name|PTR
operator|)
name|symbol_table
argument_list|)
expr_stmt|;
name|number_of_symbols
operator|=
name|bfd_canonicalize_dynamic_symtab
argument_list|(
name|abfd
argument_list|,
name|symbol_table
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|number_of_symbols
condition|;
name|i
operator|++
control|)
block|{
name|sym
operator|=
operator|*
name|symbol_table
operator|++
expr_stmt|;
if|if
condition|(
name|STREQ
argument_list|(
name|sym
operator|->
name|name
argument_list|,
name|symname
argument_list|)
condition|)
block|{
comment|/* Bfd symbols are section relative. */
name|symaddr
operator|=
name|sym
operator|->
name|value
operator|+
name|sym
operator|->
name|section
operator|->
name|vma
expr_stmt|;
break|break;
block|}
block|}
name|do_cleanups
argument_list|(
name|back_to
argument_list|)
expr_stmt|;
block|}
return|return
name|symaddr
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HANDLE_SVR4_EXEC_EMULATORS
end_ifdef

begin_comment
comment|/*    Solaris BCP (the part of Solaris which allows it to run SunOS4    a.out files) throws in another wrinkle. Solaris does not fill    in the usual a.out link map structures when running BCP programs,    the only way to get at them is via groping around in the dynamic    linker.    The dynamic linker and it's structures are located in the shared    C library, which gets run as the executable's "interpreter" by    the kernel.     Note that we can assume nothing about the process state at the time    we need to find these structures.  We may be stopped on the first    instruction of the interpreter (C shared library), the first    instruction of the executable itself, or somewhere else entirely    (if we attached to the process for example).  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|debug_base_symbols
index|[]
init|=
block|{
literal|"r_debug"
block|,
comment|/* Solaris 2.3 */
literal|"_r_debug"
block|,
comment|/* Solaris 2.1, 2.2 */
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|look_for_base
parameter_list|(
name|int
parameter_list|,
name|CORE_ADDR
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*     LOCAL FUNCTION     look_for_base -- examine file for each mapped address segment     SYNOPSYS     static int look_for_base (int fd, CORE_ADDR baseaddr)     DESCRIPTION     This function is passed to proc_iterate_over_mappings, which    causes it to get called once for each mapped address space, with    an open file descriptor for the file mapped to that space, and the    base address of that mapped space.     Our job is to find the debug base symbol in the file that this    fd is open on, if it exists, and if so, initialize the dynamic    linker structure base address debug_base.     Note that this is a computationally expensive proposition, since    we basically have to open a bfd on every call, so we specifically    avoid opening the exec file.  */
end_comment

begin_function
specifier|static
name|int
name|look_for_base
parameter_list|(
name|int
name|fd
parameter_list|,
name|CORE_ADDR
name|baseaddr
parameter_list|)
block|{
name|bfd
modifier|*
name|interp_bfd
decl_stmt|;
name|CORE_ADDR
name|address
init|=
literal|0
decl_stmt|;
name|char
modifier|*
modifier|*
name|symbolp
decl_stmt|;
comment|/* If the fd is -1, then there is no file that corresponds to this      mapped memory segment, so skip it.  Also, if the fd corresponds      to the exec file, skip it as well. */
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
operator|||
operator|(
name|exec_bfd
operator|!=
name|NULL
operator|&&
name|fdmatch
argument_list|(
name|fileno
argument_list|(
operator|(
name|FILE
operator|*
operator|)
operator|(
name|exec_bfd
operator|->
name|iostream
operator|)
argument_list|)
argument_list|,
name|fd
argument_list|)
operator|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Try to open whatever random file this fd corresponds to.  Note that      we have no way currently to find the filename.  Don't gripe about      any problems we might have, just fail. */
if|if
condition|(
operator|(
name|interp_bfd
operator|=
name|bfd_fdopenr
argument_list|(
literal|"unnamed"
argument_list|,
name|gnutarget
argument_list|,
name|fd
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|bfd_check_format
argument_list|(
name|interp_bfd
argument_list|,
name|bfd_object
argument_list|)
condition|)
block|{
comment|/* FIXME-leak: on failure, might not free all memory associated with          interp_bfd.  */
name|bfd_close
argument_list|(
name|interp_bfd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Now try to find our debug base symbol in this file, which we at      least know to be a valid ELF executable or shared library. */
for|for
control|(
name|symbolp
operator|=
name|debug_base_symbols
init|;
operator|*
name|symbolp
operator|!=
name|NULL
condition|;
name|symbolp
operator|++
control|)
block|{
name|address
operator|=
name|bfd_lookup_symbol
argument_list|(
name|interp_bfd
argument_list|,
operator|*
name|symbolp
argument_list|)
expr_stmt|;
if|if
condition|(
name|address
operator|!=
literal|0
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|address
operator|==
literal|0
condition|)
block|{
comment|/* FIXME-leak: on failure, might not free all memory associated with          interp_bfd.  */
name|bfd_close
argument_list|(
name|interp_bfd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Eureka!  We found the symbol.  But now we may need to relocate it      by the base address.  If the symbol's value is less than the base      address of the shared library, then it hasn't yet been relocated      by the dynamic linker, and we have to do it ourself.  FIXME: Note      that we make the assumption that the first segment that corresponds      to the shared library has the base address to which the library      was relocated. */
if|if
condition|(
name|address
operator|<
name|baseaddr
condition|)
block|{
name|address
operator|+=
name|baseaddr
expr_stmt|;
block|}
name|debug_base
operator|=
name|address
expr_stmt|;
comment|/* FIXME-leak: on failure, might not free all memory associated with      interp_bfd.  */
name|bfd_close
argument_list|(
name|interp_bfd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HANDLE_SVR4_EXEC_EMULATORS */
end_comment

begin_comment
comment|/*     LOCAL FUNCTION     elf_locate_base -- locate the base address of dynamic linker structs    for SVR4 elf targets.     SYNOPSIS     CORE_ADDR elf_locate_base (void)     DESCRIPTION     For SVR4 elf targets the address of the dynamic linker's runtime    structure is contained within the dynamic info section in the    executable file.  The dynamic section is also mapped into the    inferior address space.  Because the runtime loader fills in the    real address before starting the inferior, we have to read in the    dynamic info section from the inferior address space.    If there are any errors while trying to find the address, we    silently return 0, otherwise the found address is returned.   */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|elf_locate_base
parameter_list|(
name|void
parameter_list|)
block|{
name|sec_ptr
name|dyninfo_sect
decl_stmt|;
name|int
name|dyninfo_sect_size
decl_stmt|;
name|CORE_ADDR
name|dyninfo_addr
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|char
modifier|*
name|bufend
decl_stmt|;
name|int
name|arch_size
decl_stmt|;
comment|/* Find the start address of the .dynamic section.  */
name|dyninfo_sect
operator|=
name|bfd_get_section_by_name
argument_list|(
name|exec_bfd
argument_list|,
literal|".dynamic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dyninfo_sect
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|dyninfo_addr
operator|=
name|bfd_section_vma
argument_list|(
name|exec_bfd
argument_list|,
name|dyninfo_sect
argument_list|)
expr_stmt|;
comment|/* Read in .dynamic section, silently ignore errors.  */
name|dyninfo_sect_size
operator|=
name|bfd_section_size
argument_list|(
name|exec_bfd
argument_list|,
name|dyninfo_sect
argument_list|)
expr_stmt|;
name|buf
operator|=
name|alloca
argument_list|(
name|dyninfo_sect_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_read_memory
argument_list|(
name|dyninfo_addr
argument_list|,
name|buf
argument_list|,
name|dyninfo_sect_size
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Find the DT_DEBUG entry in the the .dynamic section.      For mips elf we look for DT_MIPS_RLD_MAP, mips elf apparently has      no DT_DEBUG entries.  */
name|arch_size
operator|=
name|bfd_get_arch_size
argument_list|(
name|exec_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|arch_size
operator|==
operator|-
literal|1
condition|)
comment|/* failure */
return|return
literal|0
return|;
if|if
condition|(
name|arch_size
operator|==
literal|32
condition|)
block|{
comment|/* 32-bit elf */
for|for
control|(
name|bufend
operator|=
name|buf
operator|+
name|dyninfo_sect_size
init|;
name|buf
operator|<
name|bufend
condition|;
name|buf
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Dyn
argument_list|)
control|)
block|{
name|Elf32_External_Dyn
modifier|*
name|x_dynp
init|=
operator|(
name|Elf32_External_Dyn
operator|*
operator|)
name|buf
decl_stmt|;
name|long
name|dyn_tag
decl_stmt|;
name|CORE_ADDR
name|dyn_ptr
decl_stmt|;
name|dyn_tag
operator|=
name|bfd_h_get_32
argument_list|(
name|exec_bfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|x_dynp
operator|->
name|d_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|dyn_tag
operator|==
name|DT_NULL
condition|)
break|break;
elseif|else
if|if
condition|(
name|dyn_tag
operator|==
name|DT_DEBUG
condition|)
block|{
name|dyn_ptr
operator|=
name|bfd_h_get_32
argument_list|(
name|exec_bfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|x_dynp
operator|->
name|d_un
operator|.
name|d_ptr
argument_list|)
expr_stmt|;
return|return
name|dyn_ptr
return|;
block|}
elseif|else
if|if
condition|(
name|dyn_tag
operator|==
name|DT_MIPS_RLD_MAP
condition|)
block|{
name|char
modifier|*
name|pbuf
decl_stmt|;
name|pbuf
operator|=
name|alloca
argument_list|(
name|TARGET_PTR_BIT
operator|/
name|HOST_CHAR_BIT
argument_list|)
expr_stmt|;
comment|/* DT_MIPS_RLD_MAP contains a pointer to the address 		 of the dynamic link structure.  */
name|dyn_ptr
operator|=
name|bfd_h_get_32
argument_list|(
name|exec_bfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|x_dynp
operator|->
name|d_un
operator|.
name|d_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_read_memory
argument_list|(
name|dyn_ptr
argument_list|,
name|pbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|pbuf
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|extract_unsigned_integer
argument_list|(
name|pbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|pbuf
argument_list|)
argument_list|)
return|;
block|}
block|}
block|}
else|else
comment|/* 64-bit elf */
block|{
for|for
control|(
name|bufend
operator|=
name|buf
operator|+
name|dyninfo_sect_size
init|;
name|buf
operator|<
name|bufend
condition|;
name|buf
operator|+=
sizeof|sizeof
argument_list|(
name|Elf64_External_Dyn
argument_list|)
control|)
block|{
name|Elf64_External_Dyn
modifier|*
name|x_dynp
init|=
operator|(
name|Elf64_External_Dyn
operator|*
operator|)
name|buf
decl_stmt|;
name|long
name|dyn_tag
decl_stmt|;
name|CORE_ADDR
name|dyn_ptr
decl_stmt|;
name|dyn_tag
operator|=
name|bfd_h_get_64
argument_list|(
name|exec_bfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|x_dynp
operator|->
name|d_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|dyn_tag
operator|==
name|DT_NULL
condition|)
break|break;
elseif|else
if|if
condition|(
name|dyn_tag
operator|==
name|DT_DEBUG
condition|)
block|{
name|dyn_ptr
operator|=
name|bfd_h_get_64
argument_list|(
name|exec_bfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|x_dynp
operator|->
name|d_un
operator|.
name|d_ptr
argument_list|)
expr_stmt|;
return|return
name|dyn_ptr
return|;
block|}
block|}
block|}
comment|/* DT_DEBUG entry not found.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*     LOCAL FUNCTION     locate_base -- locate the base address of dynamic linker structs     SYNOPSIS     CORE_ADDR locate_base (void)     DESCRIPTION     For both the SunOS and SVR4 shared library implementations, if the    inferior executable has been linked dynamically, there is a single    address somewhere in the inferior's data space which is the key to    locating all of the dynamic linker's runtime structures.  This    address is the value of the debug base symbol.  The job of this    function is to find and return that address, or to return 0 if there    is no such address (the executable is statically linked for example).     For SunOS, the job is almost trivial, since the dynamic linker and    all of it's structures are statically linked to the executable at    link time.  Thus the symbol for the address we are looking for has    already been added to the minimal symbol table for the executable's    objfile at the time the symbol file's symbols were read, and all we    have to do is look it up there.  Note that we explicitly do NOT want    to find the copies in the shared library.     The SVR4 version is a bit more complicated because the address    is contained somewhere in the dynamic info section.  We have to go    to a lot more work to discover the address of the debug base symbol.    Because of this complexity, we cache the value we find and return that    value on subsequent invocations.  Note there is no copy in the    executable symbol tables.   */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|locate_base
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Check to see if we have a currently valid address, and if so, avoid      doing all this work again and just return the cached address.  If      we have no cached address, try to locate it in the dynamic info      section for ELF executables.  */
if|if
condition|(
name|debug_base
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|exec_bfd
operator|!=
name|NULL
operator|&&
name|bfd_get_flavour
argument_list|(
name|exec_bfd
argument_list|)
operator|==
name|bfd_target_elf_flavour
condition|)
name|debug_base
operator|=
name|elf_locate_base
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|HANDLE_SVR4_EXEC_EMULATORS
comment|/* Try it the hard way for emulated executables.  */
elseif|else
if|if
condition|(
operator|!
name|ptid_equal
argument_list|(
name|inferior_ptid
argument_list|,
name|null_ptid
argument_list|)
operator|&&
name|target_has_execution
condition|)
name|proc_iterate_over_mappings
argument_list|(
name|look_for_base
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
operator|(
name|debug_base
operator|)
return|;
block|}
end_function

begin_comment
comment|/*     LOCAL FUNCTION     first_link_map_member -- locate first member in dynamic linker's map     SYNOPSIS     static CORE_ADDR first_link_map_member (void)     DESCRIPTION     Find the first element in the inferior's dynamic link map, and    return its address in the inferior.  This function doesn't copy the    link map entry itself into our address space; current_sos actually    does the reading.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|first_link_map_member
parameter_list|(
name|void
parameter_list|)
block|{
name|CORE_ADDR
name|lm
init|=
literal|0
decl_stmt|;
name|struct
name|link_map_offsets
modifier|*
name|lmo
init|=
name|SVR4_FETCH_LINK_MAP_OFFSETS
argument_list|()
decl_stmt|;
name|char
modifier|*
name|r_map_buf
init|=
name|xmalloc
argument_list|(
name|lmo
operator|->
name|r_map_size
argument_list|)
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|cleanups
init|=
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|r_map_buf
argument_list|)
decl_stmt|;
name|read_memory
argument_list|(
name|debug_base
operator|+
name|lmo
operator|->
name|r_map_offset
argument_list|,
name|r_map_buf
argument_list|,
name|lmo
operator|->
name|r_map_size
argument_list|)
expr_stmt|;
name|lm
operator|=
name|extract_address
argument_list|(
name|r_map_buf
argument_list|,
name|lmo
operator|->
name|r_map_size
argument_list|)
expr_stmt|;
comment|/* FIXME:  Perhaps we should validate the info somehow, perhaps by      checking r_version for a known version number, or r_state for      RT_CONSISTENT. */
name|do_cleanups
argument_list|(
name|cleanups
argument_list|)
expr_stmt|;
return|return
operator|(
name|lm
operator|)
return|;
block|}
end_function

begin_comment
comment|/*    LOCAL FUNCTION    open_symbol_file_object    SYNOPSIS    void open_symbol_file_object (void *from_tty)    DESCRIPTION    If no open symbol file, attempt to locate and open the main symbol   file.  On SVR4 systems, this is the first link map entry.  If its   name is here, we can open it.  Useful when attaching to a process   without first loading its symbol file.    If FROM_TTYP dereferences to a non-zero integer, allow messages to   be printed.  This parameter is a pointer rather than an int because   open_symbol_file_object() is called via catch_errors() and   catch_errors() requires a pointer argument. */
end_comment

begin_function
specifier|static
name|int
name|open_symbol_file_object
parameter_list|(
name|void
modifier|*
name|from_ttyp
parameter_list|)
block|{
name|CORE_ADDR
name|lm
decl_stmt|,
name|l_name
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|errcode
decl_stmt|;
name|int
name|from_tty
init|=
operator|*
operator|(
name|int
operator|*
operator|)
name|from_ttyp
decl_stmt|;
name|struct
name|link_map_offsets
modifier|*
name|lmo
init|=
name|SVR4_FETCH_LINK_MAP_OFFSETS
argument_list|()
decl_stmt|;
name|char
modifier|*
name|l_name_buf
init|=
name|xmalloc
argument_list|(
name|lmo
operator|->
name|l_name_size
argument_list|)
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|cleanups
init|=
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|l_name_buf
argument_list|)
decl_stmt|;
if|if
condition|(
name|symfile_objfile
condition|)
if|if
condition|(
operator|!
name|query
argument_list|(
literal|"Attempt to reload symbols from process? "
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|debug_base
operator|=
name|locate_base
argument_list|()
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* failed somehow... */
comment|/* First link map member should be the executable.  */
if|if
condition|(
operator|(
name|lm
operator|=
name|first_link_map_member
argument_list|()
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* failed somehow... */
comment|/* Read address of name from target memory to GDB.  */
name|read_memory
argument_list|(
name|lm
operator|+
name|lmo
operator|->
name|l_name_offset
argument_list|,
name|l_name_buf
argument_list|,
name|lmo
operator|->
name|l_name_size
argument_list|)
expr_stmt|;
comment|/* Convert the address to host format.  */
name|l_name
operator|=
name|extract_address
argument_list|(
name|l_name_buf
argument_list|,
name|lmo
operator|->
name|l_name_size
argument_list|)
expr_stmt|;
comment|/* Free l_name_buf.  */
name|do_cleanups
argument_list|(
name|cleanups
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_name
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* No filename.  */
comment|/* Now fetch the filename from target memory.  */
name|target_read_string
argument_list|(
name|l_name
argument_list|,
operator|&
name|filename
argument_list|,
name|SO_NAME_MAX_PATH_SIZE
operator|-
literal|1
argument_list|,
operator|&
name|errcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|errcode
condition|)
block|{
name|warning
argument_list|(
literal|"failed to read exec filename from attached file: %s"
argument_list|,
name|safe_strerror
argument_list|(
name|errcode
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|filename
argument_list|)
expr_stmt|;
comment|/* Have a pathname: read the symbol file.  */
name|symbol_file_add_main
argument_list|(
name|filename
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* LOCAL FUNCTION     current_sos -- build a list of currently loaded shared objects     SYNOPSIS     struct so_list *current_sos ()     DESCRIPTION     Build a list of `struct so_list' objects describing the shared    objects currently loaded in the inferior.  This list does not    include an entry for the main executable file.     Note that we only gather information directly available from the    inferior --- we don't examine any of the shared library files    themselves.  The declaration of `struct so_list' says which fields    we provide values for.  */
end_comment

begin_function
specifier|static
name|struct
name|so_list
modifier|*
name|svr4_current_sos
parameter_list|(
name|void
parameter_list|)
block|{
name|CORE_ADDR
name|lm
decl_stmt|;
name|struct
name|so_list
modifier|*
name|head
init|=
literal|0
decl_stmt|;
name|struct
name|so_list
modifier|*
modifier|*
name|link_ptr
init|=
operator|&
name|head
decl_stmt|;
comment|/* Make sure we've looked up the inferior's dynamic linker's base      structure.  */
if|if
condition|(
operator|!
name|debug_base
condition|)
block|{
name|debug_base
operator|=
name|locate_base
argument_list|()
expr_stmt|;
comment|/* If we can't find the dynamic linker's base structure, this 	 must not be a dynamically linked executable.  Hmm.  */
if|if
condition|(
operator|!
name|debug_base
condition|)
return|return
literal|0
return|;
block|}
comment|/* Walk the inferior's link map list, and build our list of      `struct so_list' nodes.  */
name|lm
operator|=
name|first_link_map_member
argument_list|()
expr_stmt|;
while|while
condition|(
name|lm
condition|)
block|{
name|struct
name|link_map_offsets
modifier|*
name|lmo
init|=
name|SVR4_FETCH_LINK_MAP_OFFSETS
argument_list|()
decl_stmt|;
name|struct
name|so_list
modifier|*
name|new
init|=
operator|(
expr|struct
name|so_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|so_list
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
init|=
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|new
argument_list|)
decl_stmt|;
name|memset
argument_list|(
name|new
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|lm_info
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|lm_info
argument_list|)
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|new
operator|->
name|lm_info
argument_list|)
expr_stmt|;
name|new
operator|->
name|lm_info
operator|->
name|lm
operator|=
name|xmalloc
argument_list|(
name|lmo
operator|->
name|link_map_size
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|new
operator|->
name|lm_info
operator|->
name|lm
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|new
operator|->
name|lm_info
operator|->
name|lm
argument_list|,
literal|0
argument_list|,
name|lmo
operator|->
name|link_map_size
argument_list|)
expr_stmt|;
name|read_memory
argument_list|(
name|lm
argument_list|,
name|new
operator|->
name|lm_info
operator|->
name|lm
argument_list|,
name|lmo
operator|->
name|link_map_size
argument_list|)
expr_stmt|;
name|lm
operator|=
name|LM_NEXT
argument_list|(
name|new
argument_list|)
expr_stmt|;
comment|/* For SVR4 versions, the first entry in the link map is for the          inferior executable, so we must ignore it.  For some versions of          SVR4, it has no name.  For others (Solaris 2.3 for example), it          does have a name, so we can no longer use a missing name to          decide when to ignore it. */
if|if
condition|(
name|IGNORE_FIRST_LINK_MAP_ENTRY
argument_list|(
name|new
argument_list|)
condition|)
name|free_so
argument_list|(
name|new
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|errcode
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
comment|/* Extract this shared object's name.  */
name|target_read_string
argument_list|(
name|LM_NAME
argument_list|(
name|new
argument_list|)
argument_list|,
operator|&
name|buffer
argument_list|,
name|SO_NAME_MAX_PATH_SIZE
operator|-
literal|1
argument_list|,
operator|&
name|errcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|errcode
operator|!=
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"current_sos: Can't read pathname for load map: %s\n"
argument_list|,
name|safe_strerror
argument_list|(
name|errcode
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strncpy
argument_list|(
name|new
operator|->
name|so_name
argument_list|,
name|buffer
argument_list|,
name|SO_NAME_MAX_PATH_SIZE
operator|-
literal|1
argument_list|)
expr_stmt|;
name|new
operator|->
name|so_name
index|[
name|SO_NAME_MAX_PATH_SIZE
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|xfree
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|new
operator|->
name|so_original_name
argument_list|,
name|new
operator|->
name|so_name
argument_list|)
expr_stmt|;
block|}
comment|/* If this entry has no name, or its name matches the name 	     for the main executable, don't include it in the list.  */
if|if
condition|(
operator|!
name|new
operator|->
name|so_name
index|[
literal|0
index|]
operator|||
name|match_main
argument_list|(
name|new
operator|->
name|so_name
argument_list|)
condition|)
name|free_so
argument_list|(
name|new
argument_list|)
expr_stmt|;
else|else
block|{
name|new
operator|->
name|next
operator|=
literal|0
expr_stmt|;
operator|*
name|link_ptr
operator|=
name|new
expr_stmt|;
name|link_ptr
operator|=
operator|&
name|new
operator|->
name|next
expr_stmt|;
block|}
block|}
name|discard_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
return|return
name|head
return|;
block|}
end_function

begin_comment
comment|/* On some systems, the only way to recognize the link map entry for    the main executable file is by looking at its name.  Return    non-zero iff SONAME matches one of the known main executable names.  */
end_comment

begin_function
specifier|static
name|int
name|match_main
parameter_list|(
name|char
modifier|*
name|soname
parameter_list|)
block|{
name|char
modifier|*
modifier|*
name|mainp
decl_stmt|;
for|for
control|(
name|mainp
operator|=
name|main_name_list
init|;
operator|*
name|mainp
operator|!=
name|NULL
condition|;
name|mainp
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|soname
argument_list|,
operator|*
name|mainp
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if PC lies in the dynamic symbol resolution code of the    SVR4 run time loader.  */
end_comment

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|interp_text_sect_low
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|interp_text_sect_high
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|interp_plt_sect_low
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|interp_plt_sect_high
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|svr4_in_dynsym_resolve_code
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
return|return
operator|(
operator|(
name|pc
operator|>=
name|interp_text_sect_low
operator|&&
name|pc
operator|<
name|interp_text_sect_high
operator|)
operator|||
operator|(
name|pc
operator|>=
name|interp_plt_sect_low
operator|&&
name|pc
operator|<
name|interp_plt_sect_high
operator|)
operator|||
name|in_plt_section
argument_list|(
name|pc
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*     LOCAL FUNCTION     enable_break -- arrange for dynamic linker to hit breakpoint     SYNOPSIS     int enable_break (void)     DESCRIPTION     Both the SunOS and the SVR4 dynamic linkers have, as part of their    debugger interface, support for arranging for the inferior to hit    a breakpoint after mapping in the shared libraries.  This function    enables that breakpoint.     For SunOS, there is a special flag location (in_debugger) which we    set to 1.  When the dynamic linker sees this flag set, it will set    a breakpoint at a location known only to itself, after saving the    original contents of that place and the breakpoint address itself,    in it's own internal structures.  When we resume the inferior, it    will eventually take a SIGTRAP when it runs into the breakpoint.    We handle this (in a different place) by restoring the contents of    the breakpointed location (which is only known after it stops),    chasing around to locate the shared libraries that have been    loaded, then resuming.     For SVR4, the debugger interface structure contains a member (r_brk)    which is statically initialized at the time the shared library is    built, to the offset of a function (_r_debug_state) which is guaran-    teed to be called once before mapping in a library, and again when    the mapping is complete.  At the time we are examining this member,    it contains only the unrelocated offset of the function, so we have    to do our own relocation.  Later, when the dynamic linker actually    runs, it relocates r_brk to be the actual address of _r_debug_state().     The debugger interface structure also contains an enumeration which    is set to either RT_ADD or RT_DELETE prior to changing the mapping,    depending upon whether or not the library is being mapped or unmapped,    and then set to RT_CONSISTENT after the library is mapped/unmapped.  */
end_comment

begin_function
specifier|static
name|int
name|enable_break
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|success
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|BKPT_AT_SYMBOL
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
name|char
modifier|*
modifier|*
name|bkpt_namep
decl_stmt|;
name|asection
modifier|*
name|interp_sect
decl_stmt|;
comment|/* First, remove all the solib event breakpoints.  Their addresses      may have changed since the last time we ran the program.  */
name|remove_solib_event_breakpoints
argument_list|()
expr_stmt|;
name|interp_text_sect_low
operator|=
name|interp_text_sect_high
operator|=
literal|0
expr_stmt|;
name|interp_plt_sect_low
operator|=
name|interp_plt_sect_high
operator|=
literal|0
expr_stmt|;
comment|/* Find the .interp section; if not found, warn the user and drop      into the old breakpoint at symbol code.  */
name|interp_sect
operator|=
name|bfd_get_section_by_name
argument_list|(
name|exec_bfd
argument_list|,
literal|".interp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|interp_sect
condition|)
block|{
name|unsigned
name|int
name|interp_sect_size
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|CORE_ADDR
name|load_addr
init|=
literal|0
decl_stmt|;
name|int
name|load_addr_found
init|=
literal|0
decl_stmt|;
name|struct
name|so_list
modifier|*
name|inferior_sos
decl_stmt|;
name|bfd
modifier|*
name|tmp_bfd
init|=
name|NULL
decl_stmt|;
name|int
name|tmp_fd
init|=
operator|-
literal|1
decl_stmt|;
name|char
modifier|*
name|tmp_pathname
init|=
name|NULL
decl_stmt|;
name|CORE_ADDR
name|sym_addr
init|=
literal|0
decl_stmt|;
comment|/* Read the contents of the .interp section into a local buffer;          the contents specify the dynamic linker this program uses.  */
name|interp_sect_size
operator|=
name|bfd_section_size
argument_list|(
name|exec_bfd
argument_list|,
name|interp_sect
argument_list|)
expr_stmt|;
name|buf
operator|=
name|alloca
argument_list|(
name|interp_sect_size
argument_list|)
expr_stmt|;
name|bfd_get_section_contents
argument_list|(
name|exec_bfd
argument_list|,
name|interp_sect
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|,
name|interp_sect_size
argument_list|)
expr_stmt|;
comment|/* Now we need to figure out where the dynamic linker was          loaded so that we can load its symbols and place a breakpoint          in the dynamic linker itself.           This address is stored on the stack.  However, I've been unable          to find any magic formula to find it for Solaris (appears to          be trivial on GNU/Linux).  Therefore, we have to try an alternate          mechanism to find the dynamic linker's base address.  */
name|tmp_fd
operator|=
name|solib_open
argument_list|(
name|buf
argument_list|,
operator|&
name|tmp_pathname
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp_fd
operator|>=
literal|0
condition|)
name|tmp_bfd
operator|=
name|bfd_fdopenr
argument_list|(
name|tmp_pathname
argument_list|,
name|gnutarget
argument_list|,
name|tmp_fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp_bfd
operator|==
name|NULL
condition|)
goto|goto
name|bkpt_at_symbol
goto|;
comment|/* Make sure the dynamic linker's really a useful object.  */
if|if
condition|(
operator|!
name|bfd_check_format
argument_list|(
name|tmp_bfd
argument_list|,
name|bfd_object
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"Unable to grok dynamic linker %s as an object file"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|bfd_close
argument_list|(
name|tmp_bfd
argument_list|)
expr_stmt|;
goto|goto
name|bkpt_at_symbol
goto|;
block|}
comment|/* If the entry in _DYNAMIC for the dynamic linker has already          been filled in, we can read its base address from there. */
name|inferior_sos
operator|=
name|svr4_current_sos
argument_list|()
expr_stmt|;
if|if
condition|(
name|inferior_sos
condition|)
block|{
comment|/* Connected to a running target.  Update our shared library table. */
name|solib_add
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|auto_solib_add
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|inferior_sos
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|buf
argument_list|,
name|inferior_sos
operator|->
name|so_original_name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|load_addr_found
operator|=
literal|1
expr_stmt|;
name|load_addr
operator|=
name|LM_ADDR
argument_list|(
name|inferior_sos
argument_list|)
expr_stmt|;
break|break;
block|}
name|inferior_sos
operator|=
name|inferior_sos
operator|->
name|next
expr_stmt|;
block|}
comment|/* Otherwise we find the dynamic linker's base address by examining 	 the current pc (which should point at the entry point for the 	 dynamic linker) and subtracting the offset of the entry point.  */
if|if
condition|(
operator|!
name|load_addr_found
condition|)
name|load_addr
operator|=
name|read_pc
argument_list|()
operator|-
name|tmp_bfd
operator|->
name|start_address
expr_stmt|;
comment|/* Record the relocated start and end address of the dynamic linker          text and plt section for svr4_in_dynsym_resolve_code.  */
name|interp_sect
operator|=
name|bfd_get_section_by_name
argument_list|(
name|tmp_bfd
argument_list|,
literal|".text"
argument_list|)
expr_stmt|;
if|if
condition|(
name|interp_sect
condition|)
block|{
name|interp_text_sect_low
operator|=
name|bfd_section_vma
argument_list|(
name|tmp_bfd
argument_list|,
name|interp_sect
argument_list|)
operator|+
name|load_addr
expr_stmt|;
name|interp_text_sect_high
operator|=
name|interp_text_sect_low
operator|+
name|bfd_section_size
argument_list|(
name|tmp_bfd
argument_list|,
name|interp_sect
argument_list|)
expr_stmt|;
block|}
name|interp_sect
operator|=
name|bfd_get_section_by_name
argument_list|(
name|tmp_bfd
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|interp_sect
condition|)
block|{
name|interp_plt_sect_low
operator|=
name|bfd_section_vma
argument_list|(
name|tmp_bfd
argument_list|,
name|interp_sect
argument_list|)
operator|+
name|load_addr
expr_stmt|;
name|interp_plt_sect_high
operator|=
name|interp_plt_sect_low
operator|+
name|bfd_section_size
argument_list|(
name|tmp_bfd
argument_list|,
name|interp_sect
argument_list|)
expr_stmt|;
block|}
comment|/* Now try to set a breakpoint in the dynamic linker.  */
for|for
control|(
name|bkpt_namep
operator|=
name|solib_break_names
init|;
operator|*
name|bkpt_namep
operator|!=
name|NULL
condition|;
name|bkpt_namep
operator|++
control|)
block|{
name|sym_addr
operator|=
name|bfd_lookup_symbol
argument_list|(
name|tmp_bfd
argument_list|,
operator|*
name|bkpt_namep
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym_addr
operator|!=
literal|0
condition|)
break|break;
block|}
comment|/* We're done with the temporary bfd.  */
name|bfd_close
argument_list|(
name|tmp_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym_addr
operator|!=
literal|0
condition|)
block|{
name|create_solib_event_breakpoint
argument_list|(
name|load_addr
operator|+
name|sym_addr
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* For whatever reason we couldn't set a breakpoint in the dynamic          linker.  Warn and drop into the old code.  */
name|bkpt_at_symbol
label|:
name|warning
argument_list|(
literal|"Unable to find dynamic linker breakpoint function.\nGDB will be unable to debug shared library initializers\nand track explicitly loaded dynamic code."
argument_list|)
expr_stmt|;
block|}
comment|/* Scan through the list of symbols, trying to look up the symbol and      set a breakpoint there.  Terminate loop when we/if we succeed. */
name|breakpoint_addr
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|bkpt_namep
operator|=
name|bkpt_names
init|;
operator|*
name|bkpt_namep
operator|!=
name|NULL
condition|;
name|bkpt_namep
operator|++
control|)
block|{
name|msymbol
operator|=
name|lookup_minimal_symbol
argument_list|(
operator|*
name|bkpt_namep
argument_list|,
name|NULL
argument_list|,
name|symfile_objfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|msymbol
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|create_solib_event_breakpoint
argument_list|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
comment|/* Nothing good happened.  */
name|success
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* BKPT_AT_SYMBOL */
return|return
operator|(
name|success
operator|)
return|;
block|}
end_function

begin_comment
comment|/*     LOCAL FUNCTION     special_symbol_handling -- additional shared library symbol handling     SYNOPSIS     void special_symbol_handling ()     DESCRIPTION     Once the symbols from a shared object have been loaded in the usual    way, we are called to do any system specific symbol handling that     is needed.     For SunOS4, this consisted of grunging around in the dynamic    linkers structures to find symbol definitions for "common" symbols    and adding them to the minimal symbol table for the runtime common    objfile.     However, for SVR4, there's nothing to do.   */
end_comment

begin_function
specifier|static
name|void
name|svr4_special_symbol_handling
parameter_list|(
name|void
parameter_list|)
block|{ }
end_function

begin_comment
comment|/* Relocate the main executable.  This function should be called upon    stopping the inferior process at the entry point to the program.     The entry point from BFD is compared to the PC and if they are    different, the main executable is relocated by the proper amount.         As written it will only attempt to relocate executables which    lack interpreter sections.  It seems likely that only dynamic    linker executables will get relocated, though it should work    properly for a position-independent static executable as well.  */
end_comment

begin_function
specifier|static
name|void
name|svr4_relocate_main_executable
parameter_list|(
name|void
parameter_list|)
block|{
name|asection
modifier|*
name|interp_sect
decl_stmt|;
name|CORE_ADDR
name|pc
init|=
name|read_pc
argument_list|()
decl_stmt|;
comment|/* Decide if the objfile needs to be relocated.  As indicated above,      we will only be here when execution is stopped at the beginning      of the program.  Relocation is necessary if the address at which      we are presently stopped differs from the start address stored in      the executable AND there's no interpreter section.  The condition      regarding the interpreter section is very important because if      there *is* an interpreter section, execution will begin there      instead.  When there is an interpreter section, the start address      is (presumably) used by the interpreter at some point to start      execution of the program.       If there is an interpreter, it is normal for it to be set to an      arbitrary address at the outset.  The job of finding it is      handled in enable_break().       So, to summarize, relocations are necessary when there is no      interpreter section and the start address obtained from the      executable is different from the address at which GDB is      currently stopped.            [ The astute reader will note that we also test to make sure that        the executable in question has the DYNAMIC flag set.  It is my        opinion that this test is unnecessary (undesirable even).  It        was added to avoid inadvertent relocation of an executable        whose e_type member in the ELF header is not ET_DYN.  There may        be a time in the future when it is desirable to do relocations        on other types of files as well in which case this condition        should either be removed or modified to accomodate the new file        type.  (E.g, an ET_EXEC executable which has been built to be        position-independent could safely be relocated by the OS if        desired.  It is true that this violates the ABI, but the ABI        has been known to be bent from time to time.)  - Kevin, Nov 2000. ]      */
name|interp_sect
operator|=
name|bfd_get_section_by_name
argument_list|(
name|exec_bfd
argument_list|,
literal|".interp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|interp_sect
operator|==
name|NULL
operator|&&
operator|(
name|bfd_get_file_flags
argument_list|(
name|exec_bfd
argument_list|)
operator|&
name|DYNAMIC
operator|)
operator|!=
literal|0
operator|&&
name|bfd_get_start_address
argument_list|(
name|exec_bfd
argument_list|)
operator|!=
name|pc
condition|)
block|{
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|struct
name|section_offsets
modifier|*
name|new_offsets
decl_stmt|;
name|int
name|i
decl_stmt|,
name|changed
decl_stmt|;
name|CORE_ADDR
name|displacement
decl_stmt|;
comment|/* It is necessary to relocate the objfile.  The amount to 	 relocate by is simply the address at which we are stopped 	 minus the starting address from the executable.  	 We relocate all of the sections by the same amount.  This 	 behavior is mandated by recent editions of the System V ABI.  	 According to the System V Application Binary Interface, 	 Edition 4.1, page 5-5:  	   ...  Though the system chooses virtual addresses for 	   individual processes, it maintains the segments' relative 	   positions.  Because position-independent code uses relative 	   addressesing between segments, the difference between 	   virtual addresses in memory must match the difference 	   between virtual addresses in the file.  The difference 	   between the virtual address of any segment in memory and 	   the corresponding virtual address in the file is thus a 	   single constant value for any one executable or shared 	   object in a given process.  This difference is the base 	   address.  One use of the base address is to relocate the 	   memory image of the program during dynamic linking.  	 The same language also appears in Edition 4.0 of the System V 	 ABI and is left unspecified in some of the earlier editions.  */
name|displacement
operator|=
name|pc
operator|-
name|bfd_get_start_address
argument_list|(
name|exec_bfd
argument_list|)
expr_stmt|;
name|changed
operator|=
literal|0
expr_stmt|;
name|new_offsets
operator|=
name|xcalloc
argument_list|(
name|symfile_objfile
operator|->
name|num_sections
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|section_offsets
argument_list|)
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|new_offsets
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|symfile_objfile
operator|->
name|num_sections
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|displacement
operator|!=
name|ANOFFSET
argument_list|(
name|symfile_objfile
operator|->
name|section_offsets
argument_list|,
name|i
argument_list|)
condition|)
name|changed
operator|=
literal|1
expr_stmt|;
name|new_offsets
operator|->
name|offsets
index|[
name|i
index|]
operator|=
name|displacement
expr_stmt|;
block|}
if|if
condition|(
name|changed
condition|)
name|objfile_relocate
argument_list|(
name|symfile_objfile
argument_list|,
name|new_offsets
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*     GLOBAL FUNCTION     svr4_solib_create_inferior_hook -- shared library startup support     SYNOPSIS     void svr4_solib_create_inferior_hook()     DESCRIPTION     When gdb starts up the inferior, it nurses it along (through the    shell) until it is ready to execute it's first instruction.  At this    point, this function gets called via expansion of the macro    SOLIB_CREATE_INFERIOR_HOOK.     For SunOS executables, this first instruction is typically the    one at "_start", or a similar text label, regardless of whether    the executable is statically or dynamically linked.  The runtime    startup code takes care of dynamically linking in any shared    libraries, once gdb allows the inferior to continue.     For SVR4 executables, this first instruction is either the first    instruction in the dynamic linker (for dynamically linked    executables) or the instruction at "start" for statically linked    executables.  For dynamically linked executables, the system    first exec's /lib/libc.so.N, which contains the dynamic linker,    and starts it running.  The dynamic linker maps in any needed    shared libraries, maps in the actual user executable, and then    jumps to "start" in the user executable.     For both SunOS shared libraries, and SVR4 shared libraries, we    can arrange to cooperate with the dynamic linker to discover the    names of shared libraries that are dynamically linked, and the    base addresses to which they are linked.     This function is responsible for discovering those names and    addresses, and saving sufficient information about them to allow    their symbols to be read at a later time.     FIXME     Between enable_break() and disable_break(), this code does not    properly handle hitting breakpoints which the user might have    set in the startup code or in the dynamic linker itself.  Proper    handling will probably have to wait until the implementation is    changed to use the "breakpoint handler function" method.     Also, what if child has exit()ed?  Must exit loop somehow.  */
end_comment

begin_function
specifier|static
name|void
name|svr4_solib_create_inferior_hook
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Relocate the main executable if necessary.  */
name|svr4_relocate_main_executable
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|enable_break
argument_list|()
condition|)
block|{
name|warning
argument_list|(
literal|"shared library handler failed to enable breakpoint"
argument_list|)
expr_stmt|;
return|return;
block|}
if|#
directive|if
name|defined
argument_list|(
name|_SCO_DS
argument_list|)
comment|/* SCO needs the loop below, other systems should be using the      special shared library breakpoints and the shared library breakpoint      service routine.       Now run the target.  It will eventually hit the breakpoint, at      which point all of the libraries will have been mapped in and we      can go groveling around in the dynamic linker structures to find      out what we need to know about them. */
name|clear_proceed_status
argument_list|()
expr_stmt|;
name|stop_soon_quietly
operator|=
literal|1
expr_stmt|;
name|stop_signal
operator|=
name|TARGET_SIGNAL_0
expr_stmt|;
do|do
block|{
name|target_resume
argument_list|(
name|pid_to_ptid
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|,
name|stop_signal
argument_list|)
expr_stmt|;
name|wait_for_inferior
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|stop_signal
operator|!=
name|TARGET_SIGNAL_TRAP
condition|)
do|;
name|stop_soon_quietly
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* defined(_SCO_DS) */
block|}
end_function

begin_function
specifier|static
name|void
name|svr4_clear_solib
parameter_list|(
name|void
parameter_list|)
block|{
name|debug_base
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|svr4_free_so
parameter_list|(
name|struct
name|so_list
modifier|*
name|so
parameter_list|)
block|{
name|xfree
argument_list|(
name|so
operator|->
name|lm_info
operator|->
name|lm
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|so
operator|->
name|lm_info
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clear any bits of ADDR that wouldn't fit in a target-format    data pointer.  "Data pointer" here refers to whatever sort of    address the dynamic linker uses to manage its sections.  At the    moment, we don't support shared libraries on any processors where    code and data pointers are different sizes.     This isn't really the right solution.  What we really need here is    a way to do arithmetic on CORE_ADDR values that respects the    natural pointer/address correspondence.  (For example, on the MIPS,    converting a 32-bit pointer to a 64-bit CORE_ADDR requires you to    sign-extend the value.  There, simply truncating the bits above    TARGET_PTR_BIT, as we do below, is no good.)  This should probably    be a new gdbarch method or something.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|svr4_truncate_ptr
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|)
block|{
if|if
condition|(
name|TARGET_PTR_BIT
operator|==
sizeof|sizeof
argument_list|(
name|CORE_ADDR
argument_list|)
operator|*
literal|8
condition|)
comment|/* We don't need to truncate anything, and the bit twiddling below        will fail due to overflow problems.  */
return|return
name|addr
return|;
else|else
return|return
name|addr
operator|&
operator|(
operator|(
operator|(
name|CORE_ADDR
operator|)
literal|1
operator|<<
name|TARGET_PTR_BIT
operator|)
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|svr4_relocate_section_addresses
parameter_list|(
name|struct
name|so_list
modifier|*
name|so
parameter_list|,
name|struct
name|section_table
modifier|*
name|sec
parameter_list|)
block|{
name|sec
operator|->
name|addr
operator|=
name|svr4_truncate_ptr
argument_list|(
name|sec
operator|->
name|addr
operator|+
name|LM_ADDR
argument_list|(
name|so
argument_list|)
argument_list|)
expr_stmt|;
name|sec
operator|->
name|endaddr
operator|=
name|svr4_truncate_ptr
argument_list|(
name|sec
operator|->
name|endaddr
operator|+
name|LM_ADDR
argument_list|(
name|so
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fetch a link_map_offsets structure for native targets using struct    definitions from link.h.  See solib-legacy.c for the function    which does the actual work.        Note: For non-native targets (i.e. cross-debugging situations),    a target specific fetch_link_map_offsets() function should be    defined and registered via set_solib_svr4_fetch_link_map_offsets().  */
end_comment

begin_function
specifier|static
name|struct
name|link_map_offsets
modifier|*
name|legacy_fetch_link_map_offsets
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|legacy_svr4_fetch_link_map_offsets_hook
condition|)
return|return
name|legacy_svr4_fetch_link_map_offsets_hook
argument_list|()
return|;
else|else
block|{
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"legacy_fetch_link_map_offsets called without legacy "
literal|"link_map support enabled."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Fetch a link_map_offsets structure using the method registered in the    architecture vector.  */
end_comment

begin_function
specifier|static
name|struct
name|link_map_offsets
modifier|*
name|svr4_fetch_link_map_offsets
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|link_map_offsets
modifier|*
function_decl|(
modifier|*
name|flmo
function_decl|)
parameter_list|(
name|void
parameter_list|)
init|=
name|gdbarch_data
argument_list|(
name|fetch_link_map_offsets_gdbarch_data
argument_list|)
function_decl|;
if|if
condition|(
name|flmo
operator|==
name|NULL
condition|)
block|{
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"svr4_fetch_link_map_offsets: fetch_link_map_offsets "
literal|"method not defined for this architecture."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
return|return
operator|(
name|flmo
argument_list|()
operator|)
return|;
block|}
end_function

begin_comment
comment|/* set_solib_svr4_fetch_link_map_offsets() is intended to be called by    a<arch>_gdbarch_init() function.  It is used to establish an    architecture specific link_map_offsets fetcher for the architecture    being defined.  */
end_comment

begin_decl_stmt
name|void
name|set_solib_svr4_fetch_link_map_offsets
argument_list|(
expr|struct
name|gdbarch
operator|*
name|gdbarch
argument_list|,
expr|struct
name|link_map_offsets
operator|*
call|(
modifier|*
name|flmo
call|)
argument_list|(
name|void
argument_list|)
argument_list|)
block|{
name|set_gdbarch_data
argument_list|(
name|gdbarch
argument_list|,
name|fetch_link_map_offsets_gdbarch_data
argument_list|,
name|flmo
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Initialize the architecture specific link_map_offsets fetcher.     This is called after<arch>_gdbarch_init() has set up its struct    gdbarch for the new architecture, so care must be taken to use the    value set by set_solib_svr4_fetch_link_map_offsets(), above.  We    do, however, attempt to provide a reasonable alternative (for    native targets anyway) if the<arch>_gdbarch_init() fails to call    set_solib_svr4_fetch_link_map_offsets().  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|init_fetch_link_map_offsets
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|)
block|{
name|struct
name|link_map_offsets
modifier|*
argument_list|(
operator|*
name|flmo
argument_list|)
init|=
name|gdbarch_data
argument_list|(
name|fetch_link_map_offsets_gdbarch_data
argument_list|)
decl_stmt|;
if|if
condition|(
name|flmo
operator|==
name|NULL
condition|)
return|return
name|legacy_fetch_link_map_offsets
return|;
else|else
return|return
name|flmo
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|target_so_ops
name|svr4_so_ops
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|_initialize_svr4_solib
parameter_list|(
name|void
parameter_list|)
block|{
name|fetch_link_map_offsets_gdbarch_data
operator|=
name|register_gdbarch_data
argument_list|(
name|init_fetch_link_map_offsets
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|svr4_so_ops
operator|.
name|relocate_section_addresses
operator|=
name|svr4_relocate_section_addresses
expr_stmt|;
name|svr4_so_ops
operator|.
name|free_so
operator|=
name|svr4_free_so
expr_stmt|;
name|svr4_so_ops
operator|.
name|clear_solib
operator|=
name|svr4_clear_solib
expr_stmt|;
name|svr4_so_ops
operator|.
name|solib_create_inferior_hook
operator|=
name|svr4_solib_create_inferior_hook
expr_stmt|;
name|svr4_so_ops
operator|.
name|special_symbol_handling
operator|=
name|svr4_special_symbol_handling
expr_stmt|;
name|svr4_so_ops
operator|.
name|current_sos
operator|=
name|svr4_current_sos
expr_stmt|;
name|svr4_so_ops
operator|.
name|open_symbol_file_object
operator|=
name|open_symbol_file_object
expr_stmt|;
name|svr4_so_ops
operator|.
name|in_dynsym_resolve_code
operator|=
name|svr4_in_dynsym_resolve_code
expr_stmt|;
comment|/* FIXME: Don't do this here.  *_gdbarch_init() should set so_ops. */
name|current_target_so_ops
operator|=
operator|&
name|svr4_so_ops
expr_stmt|;
block|}
end_function

end_unit

