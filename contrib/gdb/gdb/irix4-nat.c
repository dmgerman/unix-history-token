begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Native support for the SGI Iris running IRIX version 4, for GDB.    Copyright 1988, 1989, 1990, 1991, 1992, 1993, 1995, 1996, 1999, 2000,    2001 Free Software Foundation, Inc.    Contributed by Alessandro Forin(af@cs.cmu.edu) at CMU    and by Per Bothner(bothner@cs.wisc.edu) at U.Wisconsin.    Implemented for Irix 4.x by Garrett A. Wollman.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/procfs.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_comment
comment|/* For JB_XXX.  */
end_comment

begin_comment
comment|/* Prototypes for supply_gregset etc. */
end_comment

begin_include
include|#
directive|include
file|"gregset.h"
end_include

begin_comment
comment|/* Size of elements in jmpbuf */
end_comment

begin_define
define|#
directive|define
name|JB_ELEMENT_SIZE
value|4
end_define

begin_typedef
typedef|typedef
name|unsigned
name|int
name|greg_t
typedef|;
end_typedef

begin_comment
comment|/* why isn't this defined? */
end_comment

begin_function_decl
specifier|static
name|void
name|fetch_core_registers
parameter_list|(
name|char
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|int
parameter_list|,
name|CORE_ADDR
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * See the comment in m68k-tdep.c regarding the utility of these functions.  */
end_comment

begin_function
name|void
name|supply_gregset
parameter_list|(
name|gregset_t
modifier|*
name|gregsetp
parameter_list|)
block|{
specifier|register
name|int
name|regi
decl_stmt|;
specifier|register
name|greg_t
modifier|*
name|regp
init|=
operator|(
name|greg_t
operator|*
operator|)
operator|(
name|gregsetp
operator|->
name|gp_regs
operator|)
decl_stmt|;
specifier|static
name|char
name|zerobuf
index|[
name|MAX_REGISTER_RAW_SIZE
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
comment|/* FIXME: somewhere, there should be a #define for the meaning      of this magic number 32; we should use that. */
for|for
control|(
name|regi
operator|=
literal|0
init|;
name|regi
operator|<
literal|32
condition|;
name|regi
operator|++
control|)
name|supply_register
argument_list|(
name|regi
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
name|regi
operator|)
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|PC_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|gregsetp
operator|->
name|gp_pc
operator|)
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|HI_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|gregsetp
operator|->
name|gp_mdhi
operator|)
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|LO_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|gregsetp
operator|->
name|gp_mdlo
operator|)
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|CAUSE_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|gregsetp
operator|->
name|gp_cause
operator|)
argument_list|)
expr_stmt|;
comment|/* Fill inaccessible registers with zero.  */
name|supply_register
argument_list|(
name|BADVADDR_REGNUM
argument_list|,
name|zerobuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fill_gregset
parameter_list|(
name|gregset_t
modifier|*
name|gregsetp
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
name|int
name|regi
decl_stmt|;
specifier|register
name|greg_t
modifier|*
name|regp
init|=
operator|(
name|greg_t
operator|*
operator|)
operator|(
name|gregsetp
operator|->
name|gp_regs
operator|)
decl_stmt|;
comment|/* same FIXME as above wrt 32 */
for|for
control|(
name|regi
operator|=
literal|0
init|;
name|regi
operator|<
literal|32
condition|;
name|regi
operator|++
control|)
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|regno
operator|==
name|regi
operator|)
condition|)
operator|*
operator|(
name|regp
operator|+
name|regi
operator|)
operator|=
operator|*
operator|(
name|greg_t
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|regi
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|regno
operator|==
name|PC_REGNUM
operator|)
condition|)
name|gregsetp
operator|->
name|gp_pc
operator|=
operator|*
operator|(
name|greg_t
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|PC_REGNUM
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|regno
operator|==
name|CAUSE_REGNUM
operator|)
condition|)
name|gregsetp
operator|->
name|gp_cause
operator|=
operator|*
operator|(
name|greg_t
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|CAUSE_REGNUM
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|regno
operator|==
name|HI_REGNUM
operator|)
condition|)
name|gregsetp
operator|->
name|gp_mdhi
operator|=
operator|*
operator|(
name|greg_t
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|HI_REGNUM
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|regno
operator|==
name|LO_REGNUM
operator|)
condition|)
name|gregsetp
operator|->
name|gp_mdlo
operator|=
operator|*
operator|(
name|greg_t
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|LO_REGNUM
argument_list|)
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Now we do the same thing for floating-point registers.  * We don't bother to condition on FP0_REGNUM since any  * reasonable MIPS configuration has an R3010 in it.  *  * Again, see the comments in m68k-tdep.c.  */
end_comment

begin_function
name|void
name|supply_fpregset
parameter_list|(
name|fpregset_t
modifier|*
name|fpregsetp
parameter_list|)
block|{
specifier|register
name|int
name|regi
decl_stmt|;
specifier|static
name|char
name|zerobuf
index|[
name|MAX_REGISTER_RAW_SIZE
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
for|for
control|(
name|regi
operator|=
literal|0
init|;
name|regi
operator|<
literal|32
condition|;
name|regi
operator|++
control|)
name|supply_register
argument_list|(
name|FP0_REGNUM
operator|+
name|regi
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|fpregsetp
operator|->
name|fp_r
operator|.
name|fp_regs
index|[
name|regi
index|]
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|FCRCS_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|fpregsetp
operator|->
name|fp_csr
argument_list|)
expr_stmt|;
comment|/* FIXME: how can we supply FCRIR_REGNUM?  SGI doesn't tell us. */
name|supply_register
argument_list|(
name|FCRIR_REGNUM
argument_list|,
name|zerobuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fill_fpregset
parameter_list|(
name|fpregset_t
modifier|*
name|fpregsetp
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
name|int
name|regi
decl_stmt|;
name|char
modifier|*
name|from
decl_stmt|,
modifier|*
name|to
decl_stmt|;
for|for
control|(
name|regi
operator|=
name|FP0_REGNUM
init|;
name|regi
operator|<
name|FP0_REGNUM
operator|+
literal|32
condition|;
name|regi
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|regno
operator|==
name|regi
operator|)
condition|)
block|{
name|from
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|regi
argument_list|)
index|]
expr_stmt|;
name|to
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|fpregsetp
operator|->
name|fp_r
operator|.
name|fp_regs
index|[
name|regi
operator|-
name|FP0_REGNUM
index|]
operator|)
expr_stmt|;
name|memcpy
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regi
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|regno
operator|==
name|FCRCS_REGNUM
operator|)
condition|)
name|fpregsetp
operator|->
name|fp_csr
operator|=
operator|*
operator|(
name|unsigned
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|FCRCS_REGNUM
argument_list|)
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Figure out where the longjmp will land.    We expect the first arg to be a pointer to the jmp_buf structure from which    we extract the pc (JB_PC) that we will land at.  The pc is copied into PC.    This routine returns true on success. */
end_comment

begin_function
name|int
name|get_longjmp_target
parameter_list|(
name|CORE_ADDR
modifier|*
name|pc
parameter_list|)
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|CORE_ADDR
name|jb_addr
decl_stmt|;
name|buf
operator|=
name|alloca
argument_list|(
name|TARGET_PTR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|)
expr_stmt|;
name|jb_addr
operator|=
name|read_register
argument_list|(
name|A0_REGNUM
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_read_memory
argument_list|(
name|jb_addr
operator|+
name|JB_PC
operator|*
name|JB_ELEMENT_SIZE
argument_list|,
name|buf
argument_list|,
name|TARGET_PTR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|)
condition|)
return|return
literal|0
return|;
operator|*
name|pc
operator|=
name|extract_address
argument_list|(
name|buf
argument_list|,
name|TARGET_PTR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Provide registers to GDB from a core file.     CORE_REG_SECT points to an array of bytes, which were obtained from    a core file which BFD thinks might contain register contents.     CORE_REG_SIZE is its size.     Normally, WHICH says which register set corelow suspects this is:      0 --- the general-purpose register set      2 --- the floating-point register set    However, for Irix 4, WHICH isn't used.     REG_ADDR is also unused.  */
end_comment

begin_function
specifier|static
name|void
name|fetch_core_registers
parameter_list|(
name|char
modifier|*
name|core_reg_sect
parameter_list|,
name|unsigned
name|core_reg_size
parameter_list|,
name|int
name|which
parameter_list|,
name|CORE_ADDR
name|reg_addr
parameter_list|)
block|{
if|if
condition|(
name|core_reg_size
operator|!=
name|REGISTER_BYTES
condition|)
block|{
name|warning
argument_list|(
literal|"wrong size gregset struct in core file"
argument_list|)
expr_stmt|;
return|return;
block|}
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|registers
argument_list|,
name|core_reg_sect
argument_list|,
name|core_reg_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Register that we are able to handle irix4 core file formats.    FIXME: is this really bfd_target_unknown_flavour? */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|core_fns
name|irix4_core_fns
init|=
block|{
name|bfd_target_unknown_flavour
block|,
comment|/* core_flavour */
name|default_check_format
block|,
comment|/* check_format */
name|default_core_sniffer
block|,
comment|/* core_sniffer */
name|fetch_core_registers
block|,
comment|/* core_read_registers */
name|NULL
comment|/* next */
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|_initialize_core_irix4
parameter_list|(
name|void
parameter_list|)
block|{
name|add_core_fns
argument_list|(
operator|&
name|irix4_core_fns
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

