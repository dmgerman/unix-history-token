begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Remote debugging interface for boot monitors, for GDB.    Copyright 1990, 1991, 1992, 1993, 1995, 1996    Free Software Foundation, Inc.    Contributed by Cygnus Support.  Written by Rob Savoye for Cygnus.    Resurrected from the ashes by Stu Grossman.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This file was derived from various remote-* modules. It is a collection    of generic support functions so GDB can talk directly to a ROM based    monitor. This saves use from having to hack an exception based handler    into existance, and makes for quick porting.     This module talks to a debug monitor called 'MONITOR', which    We communicate with MONITOR via either a direct serial line, or a TCP    (or possibly TELNET) stream to a terminal multiplexor,    which in turn talks to the target board.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"wait.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|ANSI_PROTOTYPES
end_ifdef

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"serial.h"
end_include

begin_include
include|#
directive|include
file|"monitor.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"gnu-regex.h"
end_include

begin_include
include|#
directive|include
file|"dcache.h"
end_include

begin_include
include|#
directive|include
file|"srec.h"
end_include

begin_decl_stmt
specifier|static
name|int
name|readchar
name|PARAMS
argument_list|(
operator|(
name|int
name|timeout
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|monitor_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|args
operator|,
name|int
name|fromtty
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|monitor_fetch_register
name|PARAMS
argument_list|(
operator|(
name|int
name|regno
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|monitor_store_register
name|PARAMS
argument_list|(
operator|(
name|int
name|regno
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|monitor_detach
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|args
operator|,
name|int
name|from_tty
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|monitor_resume
name|PARAMS
argument_list|(
operator|(
name|int
name|pid
operator|,
name|int
name|step
operator|,
expr|enum
name|target_signal
name|sig
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|monitor_interrupt
name|PARAMS
argument_list|(
operator|(
name|int
name|signo
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|monitor_interrupt_twice
name|PARAMS
argument_list|(
operator|(
name|int
name|signo
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|monitor_interrupt_query
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|monitor_wait_cleanup
name|PARAMS
argument_list|(
operator|(
name|int
name|old_timeout
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|monitor_wait
name|PARAMS
argument_list|(
operator|(
name|int
name|pid
operator|,
expr|struct
name|target_waitstatus
operator|*
name|status
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|monitor_fetch_registers
name|PARAMS
argument_list|(
operator|(
name|int
name|regno
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|monitor_store_registers
name|PARAMS
argument_list|(
operator|(
name|int
name|regno
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|monitor_prepare_to_store
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|monitor_xfer_memory
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
name|memaddr
operator|,
name|char
operator|*
name|myaddr
operator|,
name|int
name|len
operator|,
name|int
name|write
operator|,
expr|struct
name|target_ops
operator|*
name|target
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|monitor_files_info
name|PARAMS
argument_list|(
operator|(
expr|struct
name|target_ops
operator|*
name|ops
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|monitor_insert_breakpoint
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
name|addr
operator|,
name|char
operator|*
name|shadow
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|monitor_remove_breakpoint
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
name|addr
operator|,
name|char
operator|*
name|shadow
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|monitor_kill
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|monitor_load
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|file
operator|,
name|int
name|from_tty
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|monitor_mourn_inferior
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|monitor_stop
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|monitor_debug
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|prefix
operator|,
name|char
operator|*
name|string
operator|,
name|char
operator|*
name|suffix
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|monitor_read_memory
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
name|addr
operator|,
name|char
operator|*
name|myaddr
operator|,
name|int
name|len
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|monitor_write_memory
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
name|addr
operator|,
name|char
operator|*
name|myaddr
operator|,
name|int
name|len
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|monitor_expect_regexp
name|PARAMS
argument_list|(
operator|(
expr|struct
name|re_pattern_buffer
operator|*
name|pat
operator|,
name|char
operator|*
name|buf
operator|,
name|int
name|buflen
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|from_hex
name|PARAMS
argument_list|(
operator|(
name|int
name|a
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|get_hex_word
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|monitor_ops
modifier|*
name|current_monitor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hashmark
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* flag set by "set hash" */
end_comment

begin_decl_stmt
specifier|static
name|int
name|timeout
init|=
literal|30
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|in_monitor_wait
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means we are in monitor_wait() */
end_comment

begin_function_decl
specifier|static
name|void
function_decl|(
modifier|*
name|ofunc
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Old SIGINT signal handler */
end_comment

begin_comment
comment|/* Descriptor for I/O to remote machine.  Initialize it to NULL so    that monitor_open knows that we don't have a file open when the    program starts.  */
end_comment

begin_decl_stmt
specifier|static
name|serial_t
name|monitor_desc
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to regexp pattern matching data */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|re_pattern_buffer
name|register_pattern
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|register_fastmap
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|re_pattern_buffer
name|getmem_resp_delim_pattern
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|getmem_resp_delim_fastmap
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dump_reg_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means do a dump_registers cmd when 				   monitor_wait wakes up.  */
end_comment

begin_decl_stmt
specifier|static
name|DCACHE
modifier|*
name|remote_dcache
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* monitor_debug is like fputs_unfiltered, except it prints special    characters in printable fashion.  */
end_comment

begin_function
specifier|static
name|void
name|monitor_debug
parameter_list|(
name|prefix
parameter_list|,
name|string
parameter_list|,
name|suffix
parameter_list|)
name|char
modifier|*
name|prefix
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|char
modifier|*
name|suffix
decl_stmt|;
block|{
name|int
name|ch
decl_stmt|;
comment|/* print prefix and suffix after each line */
specifier|static
name|int
name|new_line
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|new_line
operator|==
literal|1
condition|)
block|{
comment|/* print prefix if last char was a newline */
name|fputs_unfiltered
argument_list|(
name|prefix
argument_list|,
name|gdb_stderr
argument_list|)
expr_stmt|;
name|new_line
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|strchr
argument_list|(
name|string
argument_list|,
literal|'\n'
argument_list|)
condition|)
comment|/* save state for next call */
name|new_line
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
operator|*
name|string
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
default|default:
if|if
condition|(
name|isprint
argument_list|(
name|ch
argument_list|)
condition|)
name|fputc_unfiltered
argument_list|(
name|ch
argument_list|,
name|gdb_stderr
argument_list|)
expr_stmt|;
else|else
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"\\%03o"
argument_list|,
name|ch
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
name|fputs_unfiltered
argument_list|(
literal|"\\\\"
argument_list|,
name|gdb_stderr
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\b'
case|:
name|fputs_unfiltered
argument_list|(
literal|"\\b"
argument_list|,
name|gdb_stderr
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\f'
case|:
name|fputs_unfiltered
argument_list|(
literal|"\\f"
argument_list|,
name|gdb_stderr
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
name|fputs_unfiltered
argument_list|(
literal|"\\n"
argument_list|,
name|gdb_stderr
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
name|fputs_unfiltered
argument_list|(
literal|"\\r"
argument_list|,
name|gdb_stderr
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
name|fputs_unfiltered
argument_list|(
literal|"\\t"
argument_list|,
name|gdb_stderr
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\v'
case|:
name|fputs_unfiltered
argument_list|(
literal|"\\v"
argument_list|,
name|gdb_stderr
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|new_line
operator|==
literal|1
condition|)
block|{
comment|/* print suffix if last char was a newline */
name|fputs_unfiltered
argument_list|(
name|suffix
argument_list|,
name|gdb_stderr
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
literal|"\n"
argument_list|,
name|gdb_stderr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* monitor_printf_noecho -- Send data to monitor, but don't expect an echo.    Works just like printf.  */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|ANSI_PROTOTYPES
name|monitor_printf_noecho
parameter_list|(
name|char
modifier|*
name|pattern
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
function|monitor_printf_noecho
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
endif|#
directive|endif
block|{
name|va_list
name|args
decl_stmt|;
name|char
name|sndbuf
index|[
literal|2000
index|]
decl_stmt|;
name|int
name|len
decl_stmt|;
if|#
directive|if
name|ANSI_PROTOTYPES
name|va_start
argument_list|(
name|args
argument_list|,
name|pattern
argument_list|)
expr_stmt|;
else|#
directive|else
name|char
modifier|*
name|pattern
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|pattern
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vsprintf
argument_list|(
name|sndbuf
argument_list|,
name|pattern
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|remote_debug
operator|>
literal|0
condition|)
name|monitor_debug
argument_list|(
literal|"sent -->"
argument_list|,
name|sndbuf
argument_list|,
literal|"<--"
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|sndbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|+
literal|1
operator|>
sizeof|sizeof
name|sndbuf
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|SERIAL_WRITE
argument_list|(
name|monitor_desc
argument_list|,
name|sndbuf
argument_list|,
name|len
argument_list|)
condition|)
name|fprintf_unfiltered
argument_list|(
name|stderr
argument_list|,
literal|"SERIAL_WRITE failed: %s\n"
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* monitor_printf -- Send data to monitor and check the echo.  Works just like    printf.  */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|ANSI_PROTOTYPES
name|monitor_printf
parameter_list|(
name|char
modifier|*
name|pattern
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
function|monitor_printf
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
endif|#
directive|endif
block|{
name|va_list
name|args
decl_stmt|;
name|char
name|sndbuf
index|[
literal|2000
index|]
decl_stmt|;
name|int
name|len
decl_stmt|;
ifdef|#
directive|ifdef
name|ANSI_PROTOTYPES
name|va_start
argument_list|(
name|args
argument_list|,
name|pattern
argument_list|)
expr_stmt|;
else|#
directive|else
name|char
modifier|*
name|pattern
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|pattern
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vsprintf
argument_list|(
name|sndbuf
argument_list|,
name|pattern
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|remote_debug
operator|>
literal|0
condition|)
name|monitor_debug
argument_list|(
literal|"sent -->"
argument_list|,
name|sndbuf
argument_list|,
literal|"<--"
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|sndbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|+
literal|1
operator|>
sizeof|sizeof
name|sndbuf
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|SERIAL_WRITE
argument_list|(
name|monitor_desc
argument_list|,
name|sndbuf
argument_list|,
name|len
argument_list|)
condition|)
name|fprintf_unfiltered
argument_list|(
name|stderr
argument_list|,
literal|"SERIAL_WRITE failed: %s\n"
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We used to expect that the next immediate output was the characters we      just output, but sometimes some extra junk appeared before the characters      we expected, like an extra prompt, or a portmaster sending telnet negotiations.      So, just start searching for what we sent, and skip anything unknown.  */
name|monitor_expect
argument_list|(
name|sndbuf
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read a character from the remote system, doing all the fancy    timeout stuff.  */
end_comment

begin_function
specifier|static
name|int
name|readchar
parameter_list|(
name|timeout
parameter_list|)
name|int
name|timeout
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
specifier|static
enum|enum
block|{
name|last_random
block|,
name|last_nl
block|,
name|last_cr
block|,
name|last_crnl
block|}
name|state
init|=
name|last_random
enum|;
name|int
name|looping
decl_stmt|;
do|do
block|{
name|looping
operator|=
literal|0
expr_stmt|;
name|c
operator|=
name|SERIAL_READCHAR
argument_list|(
name|monitor_desc
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|0
condition|)
block|{
name|c
operator|&=
literal|0x7f
expr_stmt|;
if|if
condition|(
name|remote_debug
operator|>
literal|0
condition|)
block|{
name|char
name|buf
index|[
literal|2
index|]
decl_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|monitor_debug
argument_list|(
literal|"read -->"
argument_list|,
name|buf
argument_list|,
literal|"<--"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Canonicialize \n\r combinations into one \r */
if|if
condition|(
operator|(
name|current_monitor
operator|->
name|flags
operator|&
name|MO_HANDLE_NL
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|==
literal|'\r'
operator|&&
name|state
operator|==
name|last_nl
operator|)
operator|||
operator|(
name|c
operator|==
literal|'\n'
operator|&&
name|state
operator|==
name|last_cr
operator|)
condition|)
block|{
name|state
operator|=
name|last_crnl
expr_stmt|;
name|looping
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\r'
condition|)
name|state
operator|=
name|last_cr
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|!=
literal|'\n'
condition|)
name|state
operator|=
name|last_random
expr_stmt|;
else|else
block|{
name|state
operator|=
name|last_nl
expr_stmt|;
name|c
operator|=
literal|'\r'
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|looping
condition|)
do|;
if|if
condition|(
name|c
operator|>=
literal|0
condition|)
return|return
name|c
return|;
if|if
condition|(
name|c
operator|==
name|SERIAL_TIMEOUT
condition|)
ifdef|#
directive|ifdef
name|MAINTENANCE_CMDS
if|if
condition|(
name|in_monitor_wait
condition|)
comment|/* Watchdog went off */
block|{
name|target_mourn_inferior
argument_list|()
expr_stmt|;
name|error
argument_list|(
literal|"Watchdog has expired.  Target detached.\n"
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|error
argument_list|(
literal|"Timeout reading from remote system."
argument_list|)
expr_stmt|;
name|perror_with_name
argument_list|(
literal|"remote-monitor"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Scan input from the remote system, until STRING is found.  If BUF is non-    zero, then collect input until we have collected either STRING or BUFLEN-1    chars.  In either case we terminate BUF with a 0.  If input overflows BUF    because STRING can't be found, return -1, else return number of chars in BUF    (minus the terminating NUL).  Note that in the non-overflow case, STRING    will be at the end of BUF.  */
end_comment

begin_function
name|int
name|monitor_expect
parameter_list|(
name|string
parameter_list|,
name|buf
parameter_list|,
name|buflen
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|buflen
decl_stmt|;
block|{
name|char
modifier|*
name|p
init|=
name|string
decl_stmt|;
name|int
name|obuflen
init|=
name|buflen
decl_stmt|;
name|int
name|c
decl_stmt|;
name|immediate_quit
operator|=
literal|1
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|buf
condition|)
block|{
if|if
condition|(
name|buflen
operator|<
literal|2
condition|)
block|{
operator|*
name|buf
operator|=
literal|'\000'
expr_stmt|;
name|immediate_quit
operator|=
literal|0
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|c
operator|=
name|readchar
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\000'
condition|)
continue|continue;
operator|*
name|buf
operator|++
operator|=
name|c
expr_stmt|;
name|buflen
operator|--
expr_stmt|;
block|}
else|else
name|c
operator|=
name|readchar
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
comment|/* Don't expect any ^C sent to be echoed */
if|if
condition|(
operator|*
name|p
operator|==
literal|'\003'
operator|||
name|c
operator|==
operator|*
name|p
condition|)
block|{
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
name|immediate_quit
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|buf
condition|)
block|{
operator|*
name|buf
operator|++
operator|=
literal|'\000'
expr_stmt|;
return|return
name|obuflen
operator|-
name|buflen
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
block|}
else|else
block|{
name|p
operator|=
name|string
expr_stmt|;
if|if
condition|(
name|c
operator|==
operator|*
name|p
condition|)
name|p
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Search for a regexp.  */
end_comment

begin_function
specifier|static
name|int
name|monitor_expect_regexp
parameter_list|(
name|pat
parameter_list|,
name|buf
parameter_list|,
name|buflen
parameter_list|)
name|struct
name|re_pattern_buffer
modifier|*
name|pat
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|buflen
decl_stmt|;
block|{
name|char
modifier|*
name|mybuf
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|buf
condition|)
name|mybuf
operator|=
name|buf
expr_stmt|;
else|else
block|{
name|mybuf
operator|=
name|alloca
argument_list|(
literal|1024
argument_list|)
expr_stmt|;
name|buflen
operator|=
literal|1024
expr_stmt|;
block|}
name|p
operator|=
name|mybuf
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|retval
decl_stmt|;
if|if
condition|(
name|p
operator|-
name|mybuf
operator|>=
name|buflen
condition|)
block|{
comment|/* Buffer about to overflow */
comment|/* On overflow, we copy the upper half of the buffer to the lower half.  Not    great, but it usually works... */
name|memcpy
argument_list|(
name|mybuf
argument_list|,
name|mybuf
operator|+
name|buflen
operator|/
literal|2
argument_list|,
name|buflen
operator|/
literal|2
argument_list|)
expr_stmt|;
name|p
operator|=
name|mybuf
operator|+
name|buflen
operator|/
literal|2
expr_stmt|;
block|}
operator|*
name|p
operator|++
operator|=
name|readchar
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
name|retval
operator|=
name|re_search
argument_list|(
name|pat
argument_list|,
name|mybuf
argument_list|,
name|p
operator|-
name|mybuf
argument_list|,
literal|0
argument_list|,
name|p
operator|-
name|mybuf
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|>=
literal|0
condition|)
return|return
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/* Keep discarding input until we see the MONITOR prompt.     The convention for dealing with the prompt is that you    o give your command    o *then* wait for the prompt.     Thus the last thing that a procedure does with the serial line    will be an monitor_expect_prompt().  Exception:  monitor_resume does not    wait for the prompt, because the terminal is being handed over    to the inferior.  However, the next thing which happens after that    is a monitor_wait which does wait for the prompt.    Note that this includes abnormal exit, e.g. error().  This is    necessary to prevent getting into states from which we can't    recover.  */
end_comment

begin_function
name|int
name|monitor_expect_prompt
parameter_list|(
name|buf
parameter_list|,
name|buflen
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|buflen
decl_stmt|;
block|{
return|return
name|monitor_expect
argument_list|(
name|PROMPT
argument_list|,
name|buf
argument_list|,
name|buflen
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Get N 32-bit words from remote, each preceded by a space, and put    them in registers starting at REGNO.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|get_hex_word
parameter_list|()
block|{
name|unsigned
name|long
name|val
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|ch
decl_stmt|;
do|do
name|ch
operator|=
name|readchar
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
do|while
condition|(
name|isspace
argument_list|(
name|ch
argument_list|)
condition|)
do|;
name|val
operator|=
name|from_hex
argument_list|(
name|ch
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|7
init|;
name|i
operator|>=
literal|1
condition|;
name|i
operator|--
control|)
block|{
name|ch
operator|=
name|readchar
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isxdigit
argument_list|(
name|ch
argument_list|)
condition|)
break|break;
name|val
operator|=
operator|(
name|val
operator|<<
literal|4
operator|)
operator||
name|from_hex
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|compile_pattern
parameter_list|(
name|pattern
parameter_list|,
name|compiled_pattern
parameter_list|,
name|fastmap
parameter_list|)
name|char
modifier|*
name|pattern
decl_stmt|;
name|struct
name|re_pattern_buffer
modifier|*
name|compiled_pattern
decl_stmt|;
name|char
modifier|*
name|fastmap
decl_stmt|;
block|{
name|int
name|tmp
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
name|compiled_pattern
operator|->
name|fastmap
operator|=
name|fastmap
expr_stmt|;
name|tmp
operator|=
name|re_set_syntax
argument_list|(
name|RE_SYNTAX_EMACS
argument_list|)
expr_stmt|;
name|val
operator|=
name|re_compile_pattern
argument_list|(
name|pattern
argument_list|,
name|strlen
argument_list|(
name|pattern
argument_list|)
argument_list|,
name|compiled_pattern
argument_list|)
expr_stmt|;
name|re_set_syntax
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|)
name|error
argument_list|(
literal|"compile_pattern: Can't compile pattern string `%s': %s!"
argument_list|,
name|pattern
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|fastmap
condition|)
name|re_compile_fastmap
argument_list|(
name|compiled_pattern
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Open a connection to a remote debugger. NAME is the filename used    for communication.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|dev_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|target_ops
modifier|*
name|targ_ops
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|monitor_open
parameter_list|(
name|args
parameter_list|,
name|mon_ops
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|struct
name|monitor_ops
modifier|*
name|mon_ops
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|mon_ops
operator|->
name|magic
operator|!=
name|MONITOR_OPS_MAGIC
condition|)
name|error
argument_list|(
literal|"Magic number of monitor_ops struct wrong."
argument_list|)
expr_stmt|;
name|targ_ops
operator|=
name|mon_ops
operator|->
name|target
expr_stmt|;
name|name
operator|=
name|targ_ops
operator|->
name|to_shortname
expr_stmt|;
if|if
condition|(
operator|!
name|args
condition|)
name|error
argument_list|(
literal|"Use `target %s DEVICE-NAME' to use a serial port, or \n\ `target %s HOST-NAME:PORT-NUMBER' to use a network connection."
argument_list|,
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|target_preopen
argument_list|(
name|from_tty
argument_list|)
expr_stmt|;
comment|/* Setup pattern for register dump */
if|if
condition|(
name|mon_ops
operator|->
name|register_pattern
condition|)
name|compile_pattern
argument_list|(
name|mon_ops
operator|->
name|register_pattern
argument_list|,
operator|&
name|register_pattern
argument_list|,
name|register_fastmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|mon_ops
operator|->
name|getmem
operator|.
name|resp_delim
condition|)
name|compile_pattern
argument_list|(
name|mon_ops
operator|->
name|getmem
operator|.
name|resp_delim
argument_list|,
operator|&
name|getmem_resp_delim_pattern
argument_list|,
name|getmem_resp_delim_fastmap
argument_list|)
expr_stmt|;
name|unpush_target
argument_list|(
name|targ_ops
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_name
condition|)
name|free
argument_list|(
name|dev_name
argument_list|)
expr_stmt|;
name|dev_name
operator|=
name|strsave
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|monitor_desc
operator|=
name|SERIAL_OPEN
argument_list|(
name|dev_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|monitor_desc
condition|)
name|perror_with_name
argument_list|(
name|dev_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|baud_rate
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|SERIAL_SETBAUDRATE
argument_list|(
name|monitor_desc
argument_list|,
name|baud_rate
argument_list|)
condition|)
block|{
name|SERIAL_CLOSE
argument_list|(
name|monitor_desc
argument_list|)
expr_stmt|;
name|perror_with_name
argument_list|(
name|dev_name
argument_list|)
expr_stmt|;
block|}
block|}
name|SERIAL_RAW
argument_list|(
name|monitor_desc
argument_list|)
expr_stmt|;
name|SERIAL_FLUSH_INPUT
argument_list|(
name|monitor_desc
argument_list|)
expr_stmt|;
comment|/* some systems only work with 2 stop bits */
name|SERIAL_SETSTOPBITS
argument_list|(
name|monitor_desc
argument_list|,
name|mon_ops
operator|->
name|stopbits
argument_list|)
expr_stmt|;
name|current_monitor
operator|=
name|mon_ops
expr_stmt|;
comment|/* See if we can wake up the monitor.  First, try sending a stop sequence,      then send the init strings.  Last, remove all breakpoints.  */
if|if
condition|(
name|current_monitor
operator|->
name|stop
condition|)
block|{
name|monitor_stop
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|current_monitor
operator|->
name|flags
operator|&
name|MO_NO_ECHO_ON_OPEN
operator|)
operator|==
literal|0
condition|)
block|{
name|monitor_expect_prompt
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* wake up the monitor and see if it's alive */
for|for
control|(
name|p
operator|=
name|mon_ops
operator|->
name|init
init|;
operator|*
name|p
operator|!=
name|NULL
condition|;
name|p
operator|++
control|)
block|{
comment|/* Some of the characters we send may not be echoed, 	 but we hope to get a prompt at the end of it all. */
if|if
condition|(
operator|(
name|current_monitor
operator|->
name|flags
operator|&
name|MO_NO_ECHO_ON_OPEN
operator|)
operator|==
literal|0
condition|)
name|monitor_printf
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
else|else
name|monitor_printf_noecho
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
name|monitor_expect_prompt
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|SERIAL_FLUSH_INPUT
argument_list|(
name|monitor_desc
argument_list|)
expr_stmt|;
comment|/* Remove all breakpoints */
if|if
condition|(
name|mon_ops
operator|->
name|clr_all_break
condition|)
block|{
name|monitor_printf
argument_list|(
name|mon_ops
operator|->
name|clr_all_break
argument_list|)
expr_stmt|;
name|monitor_expect_prompt
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|from_tty
condition|)
name|printf_unfiltered
argument_list|(
literal|"Remote target %s connected to %s\n"
argument_list|,
name|name
argument_list|,
name|dev_name
argument_list|)
expr_stmt|;
name|push_target
argument_list|(
name|targ_ops
argument_list|)
expr_stmt|;
name|inferior_pid
operator|=
literal|42000
expr_stmt|;
comment|/* Make run command think we are busy... */
comment|/* Give monitor_wait something to read */
name|monitor_printf
argument_list|(
name|current_monitor
operator|->
name|line_term
argument_list|)
expr_stmt|;
name|remote_dcache
operator|=
name|dcache_init
argument_list|(
name|monitor_read_memory
argument_list|,
name|monitor_write_memory
argument_list|)
expr_stmt|;
name|start_remote
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Close out all files and local state before this target loses    control.  */
end_comment

begin_function
name|void
name|monitor_close
parameter_list|(
name|quitting
parameter_list|)
name|int
name|quitting
decl_stmt|;
block|{
if|if
condition|(
name|monitor_desc
condition|)
name|SERIAL_CLOSE
argument_list|(
name|monitor_desc
argument_list|)
expr_stmt|;
name|monitor_desc
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Terminate the open connection to the remote debugger.  Use this    when you want to detach and do something else with your gdb.  */
end_comment

begin_function
specifier|static
name|void
name|monitor_detach
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|pop_target
argument_list|()
expr_stmt|;
comment|/* calls monitor_close to do the real work */
if|if
condition|(
name|from_tty
condition|)
name|printf_unfiltered
argument_list|(
literal|"Ending remote %s debugging\n"
argument_list|,
name|target_shortname
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Convert VALSTR into the target byte-ordered value of REGNO and store it.  */
end_comment

begin_function
name|char
modifier|*
name|monitor_supply_register
parameter_list|(
name|regno
parameter_list|,
name|valstr
parameter_list|)
name|int
name|regno
decl_stmt|;
name|char
modifier|*
name|valstr
decl_stmt|;
block|{
name|unsigned
name|LONGEST
name|val
decl_stmt|;
name|unsigned
name|char
name|regbuf
index|[
name|MAX_REGISTER_RAW_SIZE
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|val
operator|=
name|strtoul
argument_list|(
name|valstr
argument_list|,
operator|&
name|p
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
operator|&&
name|valstr
operator|==
name|p
condition|)
name|error
argument_list|(
literal|"monitor_supply_register (%d):  bad value from monitor: %s."
argument_list|,
name|regno
argument_list|,
name|valstr
argument_list|)
expr_stmt|;
comment|/* supply register stores in target byte order, so swap here */
name|store_unsigned_integer
argument_list|(
name|regbuf
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|regno
argument_list|,
name|regbuf
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Tell the remote machine to resume.  */
end_comment

begin_function
specifier|static
name|void
name|monitor_resume
parameter_list|(
name|pid
parameter_list|,
name|step
parameter_list|,
name|sig
parameter_list|)
name|int
name|pid
decl_stmt|,
name|step
decl_stmt|;
name|enum
name|target_signal
name|sig
decl_stmt|;
block|{
name|dcache_flush
argument_list|(
name|remote_dcache
argument_list|)
expr_stmt|;
if|if
condition|(
name|step
condition|)
name|monitor_printf
argument_list|(
name|STEP_CMD
argument_list|)
expr_stmt|;
else|else
block|{
name|monitor_printf
argument_list|(
name|CONT_CMD
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_monitor
operator|->
name|flags
operator|&
name|MO_NEED_REGDUMP_AFTER_CONT
condition|)
name|dump_reg_flag
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Parse the output of a register dump command.  A monitor specific    regexp is used to extract individual register descriptions of the    form REG=VAL.  Each description is split up into a name and a value    string which are passed down to monitor specific code.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|parse_register_dump
parameter_list|(
name|buf
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|regnamelen
decl_stmt|,
name|vallen
decl_stmt|;
name|char
modifier|*
name|regname
decl_stmt|,
modifier|*
name|val
decl_stmt|;
comment|/* Element 0 points to start of register name, and element 1 	 points to the start of the register value.  */
name|struct
name|re_registers
name|register_strings
decl_stmt|;
if|if
condition|(
name|re_search
argument_list|(
operator|&
name|register_pattern
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
literal|0
argument_list|,
name|len
argument_list|,
operator|&
name|register_strings
argument_list|)
operator|==
operator|-
literal|1
condition|)
break|break;
name|regnamelen
operator|=
name|register_strings
operator|.
name|end
index|[
literal|1
index|]
operator|-
name|register_strings
operator|.
name|start
index|[
literal|1
index|]
expr_stmt|;
name|regname
operator|=
name|buf
operator|+
name|register_strings
operator|.
name|start
index|[
literal|1
index|]
expr_stmt|;
name|vallen
operator|=
name|register_strings
operator|.
name|end
index|[
literal|2
index|]
operator|-
name|register_strings
operator|.
name|start
index|[
literal|2
index|]
expr_stmt|;
name|val
operator|=
name|buf
operator|+
name|register_strings
operator|.
name|start
index|[
literal|2
index|]
expr_stmt|;
name|current_monitor
operator|->
name|supply_register
argument_list|(
name|regname
argument_list|,
name|regnamelen
argument_list|,
name|val
argument_list|,
name|vallen
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|register_strings
operator|.
name|end
index|[
literal|0
index|]
expr_stmt|;
name|len
operator|-=
name|register_strings
operator|.
name|end
index|[
literal|0
index|]
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Send ^C to target to halt it.  Target will respond, and send us a    packet.  */
end_comment

begin_function
specifier|static
name|void
name|monitor_interrupt
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{
comment|/* If this doesn't work, try more severe steps.  */
name|signal
argument_list|(
name|signo
argument_list|,
name|monitor_interrupt_twice
argument_list|)
expr_stmt|;
if|if
condition|(
name|remote_debug
condition|)
name|printf_unfiltered
argument_list|(
literal|"monitor_interrupt called\n"
argument_list|)
expr_stmt|;
name|target_stop
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The user typed ^C twice.  */
end_comment

begin_function
specifier|static
name|void
name|monitor_interrupt_twice
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{
name|signal
argument_list|(
name|signo
argument_list|,
name|ofunc
argument_list|)
expr_stmt|;
name|monitor_interrupt_query
argument_list|()
expr_stmt|;
name|signal
argument_list|(
name|signo
argument_list|,
name|monitor_interrupt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Ask the user what to do when an interrupt is received.  */
end_comment

begin_function
specifier|static
name|void
name|monitor_interrupt_query
parameter_list|()
block|{
name|target_terminal_ours
argument_list|()
expr_stmt|;
if|if
condition|(
name|query
argument_list|(
literal|"Interrupted while waiting for the program.\n\ Give up (and stop debugging it)? "
argument_list|)
condition|)
block|{
name|target_mourn_inferior
argument_list|()
expr_stmt|;
name|return_to_top_level
argument_list|(
name|RETURN_QUIT
argument_list|)
expr_stmt|;
block|}
name|target_terminal_inferior
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|monitor_wait_cleanup
parameter_list|(
name|old_timeout
parameter_list|)
name|int
name|old_timeout
decl_stmt|;
block|{
name|timeout
operator|=
name|old_timeout
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|ofunc
argument_list|)
expr_stmt|;
name|in_monitor_wait
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Wait until the remote machine stops, then return, storing status in    status just as `wait' would.  */
end_comment

begin_function
specifier|static
name|int
name|monitor_wait
parameter_list|(
name|pid
parameter_list|,
name|status
parameter_list|)
name|int
name|pid
decl_stmt|;
name|struct
name|target_waitstatus
modifier|*
name|status
decl_stmt|;
block|{
name|int
name|old_timeout
init|=
name|timeout
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|int
name|resp_len
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_EXITED
expr_stmt|;
name|status
operator|->
name|value
operator|.
name|integer
operator|=
literal|0
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|monitor_wait_cleanup
argument_list|,
name|old_timeout
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MAINTENANCE_CMDS
name|in_monitor_wait
operator|=
literal|1
expr_stmt|;
name|timeout
operator|=
name|watchdog
operator|>
literal|0
condition|?
name|watchdog
else|:
operator|-
literal|1
expr_stmt|;
else|#
directive|else
name|timeout
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Don't time out -- user program is running. */
endif|#
directive|endif
name|ofunc
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|monitor_interrupt
argument_list|)
expr_stmt|;
do|do
block|{
name|resp_len
operator|=
name|monitor_expect_prompt
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp_len
operator|<=
literal|0
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"monitor_wait:  excessive response from monitor: %s."
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|resp_len
operator|<
literal|0
condition|)
do|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|ofunc
argument_list|)
expr_stmt|;
name|timeout
operator|=
name|old_timeout
expr_stmt|;
if|if
condition|(
name|dump_reg_flag
operator|&&
name|current_monitor
operator|->
name|dump_registers
condition|)
block|{
name|dump_reg_flag
operator|=
literal|0
expr_stmt|;
name|monitor_printf
argument_list|(
name|current_monitor
operator|->
name|dump_registers
argument_list|)
expr_stmt|;
name|resp_len
operator|=
name|monitor_expect_prompt
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|current_monitor
operator|->
name|register_pattern
condition|)
name|parse_register_dump
argument_list|(
name|buf
argument_list|,
name|resp_len
argument_list|)
expr_stmt|;
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_STOPPED
expr_stmt|;
name|status
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_TRAP
expr_stmt|;
name|discard_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
name|in_monitor_wait
operator|=
literal|0
expr_stmt|;
return|return
name|inferior_pid
return|;
block|}
end_function

begin_comment
comment|/* Fetch register REGNO, or all registers if REGNO is -1. Returns    errno value.  */
end_comment

begin_function
specifier|static
name|void
name|monitor_fetch_register
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|;
specifier|static
name|char
name|zerobuf
index|[
name|MAX_REGISTER_RAW_SIZE
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
name|char
name|regbuf
index|[
name|MAX_REGISTER_RAW_SIZE
operator|*
literal|2
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|name
operator|=
name|REGNAMES
argument_list|(
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
block|{
name|supply_register
argument_list|(
name|regno
argument_list|,
name|zerobuf
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* send the register examine command */
name|monitor_printf
argument_list|(
name|current_monitor
operator|->
name|getreg
operator|.
name|cmd
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* If RESP_DELIM is specified, we search for that as a leading      delimiter for the register value.  Otherwise, we just start      searching from the start of the buf.  */
if|if
condition|(
name|current_monitor
operator|->
name|getreg
operator|.
name|resp_delim
condition|)
name|monitor_expect
argument_list|(
name|current_monitor
operator|->
name|getreg
operator|.
name|resp_delim
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Read upto the maximum number of hex digits for this register, skipping      spaces, but stop reading if something else is seen.  Some monitors      like to drop leading zeros.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
operator|*
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|int
name|c
decl_stmt|;
name|c
operator|=
name|readchar
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
while|while
condition|(
name|c
operator|==
literal|' '
condition|)
name|c
operator|=
name|readchar
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isxdigit
argument_list|(
name|c
argument_list|)
condition|)
break|break;
name|regbuf
index|[
name|i
index|]
operator|=
name|c
expr_stmt|;
block|}
name|regbuf
index|[
name|i
index|]
operator|=
literal|'\000'
expr_stmt|;
comment|/* terminate the number */
comment|/* If TERM is present, we wait for that to show up.  Also, (if TERM      is present), we will send TERM_CMD if that is present.  In any      case, we collect all of the output into buf, and then wait for      the normal prompt.  */
if|if
condition|(
name|current_monitor
operator|->
name|getreg
operator|.
name|term
condition|)
block|{
name|monitor_expect
argument_list|(
name|current_monitor
operator|->
name|getreg
operator|.
name|term
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* get response */
if|if
condition|(
name|current_monitor
operator|->
name|getreg
operator|.
name|term_cmd
condition|)
block|{
name|monitor_printf
argument_list|(
name|current_monitor
operator|->
name|getreg
operator|.
name|term_cmd
argument_list|)
expr_stmt|;
name|monitor_expect_prompt
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|monitor_expect_prompt
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* get response */
name|monitor_supply_register
argument_list|(
name|regno
argument_list|,
name|regbuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read the remote registers into the block regs.  */
end_comment

begin_function
specifier|static
name|void
name|monitor_dump_regs
parameter_list|()
block|{
if|if
condition|(
name|current_monitor
operator|->
name|dump_registers
condition|)
block|{
name|char
name|buf
index|[
literal|200
index|]
decl_stmt|;
name|int
name|resp_len
decl_stmt|;
name|monitor_printf
argument_list|(
name|current_monitor
operator|->
name|dump_registers
argument_list|)
expr_stmt|;
name|resp_len
operator|=
name|monitor_expect_prompt
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|parse_register_dump
argument_list|(
name|buf
argument_list|,
name|resp_len
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/* Need some way to read registers */
block|}
end_function

begin_function
specifier|static
name|void
name|monitor_fetch_registers
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
if|if
condition|(
name|current_monitor
operator|->
name|getreg
operator|.
name|cmd
condition|)
block|{
if|if
condition|(
name|regno
operator|>=
literal|0
condition|)
block|{
name|monitor_fetch_register
argument_list|(
name|regno
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|NUM_REGS
condition|;
name|regno
operator|++
control|)
name|monitor_fetch_register
argument_list|(
name|regno
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|monitor_dump_regs
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Store register REGNO, or all if REGNO == 0.  Return errno value.  */
end_comment

begin_function
specifier|static
name|void
name|monitor_store_register
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|LONGEST
name|val
decl_stmt|;
name|name
operator|=
name|REGNAMES
argument_list|(
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
return|return;
name|val
operator|=
name|read_register
argument_list|(
name|regno
argument_list|)
expr_stmt|;
comment|/* send the register deposit command */
name|monitor_printf
argument_list|(
name|current_monitor
operator|->
name|setreg
operator|.
name|cmd
argument_list|,
name|name
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* It's possible that there are actually some monitors out there that    will prompt you when you set a register.  In that case, you may    need to add some code here to deal with TERM and TERM_CMD (see    monitor_fetch_register to get an idea of what's needed...) */
name|monitor_expect_prompt
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Store the remote registers.  */
end_comment

begin_function
specifier|static
name|void
name|monitor_store_registers
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
if|if
condition|(
name|regno
operator|>=
literal|0
condition|)
block|{
name|monitor_store_register
argument_list|(
name|regno
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|NUM_REGS
condition|;
name|regno
operator|++
control|)
name|monitor_store_register
argument_list|(
name|regno
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get ready to modify the registers array.  On machines which store    individual registers, this doesn't need to do anything.  On machines    which store all the registers in one fell swoop, this makes sure    that registers contains all the registers from the program being    debugged.  */
end_comment

begin_function
specifier|static
name|void
name|monitor_prepare_to_store
parameter_list|()
block|{
comment|/* Do nothing, since we can store individual regs */
block|}
end_function

begin_function
specifier|static
name|void
name|monitor_files_info
parameter_list|(
name|ops
parameter_list|)
name|struct
name|target_ops
modifier|*
name|ops
decl_stmt|;
block|{
name|printf_unfiltered
argument_list|(
literal|"\tAttached to %s at %d baud.\n"
argument_list|,
name|dev_name
argument_list|,
name|baud_rate
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|monitor_write_memory
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|unsigned
name|LONGEST
name|val
decl_stmt|;
name|char
modifier|*
name|cmd
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Use memory fill command for leading 0 bytes.  */
if|if
condition|(
name|current_monitor
operator|->
name|fill
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|myaddr
index|[
name|i
index|]
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|i
operator|>
literal|4
condition|)
comment|/* More than 4 zeros is worth doing */
block|{
if|if
condition|(
name|current_monitor
operator|->
name|flags
operator|&
name|MO_FILL_USES_ADDR
condition|)
name|monitor_printf
argument_list|(
name|current_monitor
operator|->
name|fill
argument_list|,
name|memaddr
argument_list|,
name|memaddr
operator|+
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|monitor_printf
argument_list|(
name|current_monitor
operator|->
name|fill
argument_list|,
name|memaddr
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|monitor_expect_prompt
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|i
return|;
block|}
block|}
if|if
condition|(
operator|(
name|memaddr
operator|&
literal|0x7
operator|)
operator|==
literal|0
operator|&&
name|len
operator|>=
literal|8
operator|&&
name|current_monitor
operator|->
name|setmem
operator|.
name|cmdll
condition|)
block|{
name|len
operator|=
literal|8
expr_stmt|;
name|cmd
operator|=
name|current_monitor
operator|->
name|setmem
operator|.
name|cmdll
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|memaddr
operator|&
literal|0x3
operator|)
operator|==
literal|0
operator|&&
name|len
operator|>=
literal|4
operator|&&
name|current_monitor
operator|->
name|setmem
operator|.
name|cmdl
condition|)
block|{
name|len
operator|=
literal|4
expr_stmt|;
name|cmd
operator|=
name|current_monitor
operator|->
name|setmem
operator|.
name|cmdl
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|memaddr
operator|&
literal|0x1
operator|)
operator|==
literal|0
operator|&&
name|len
operator|>=
literal|2
operator|&&
name|current_monitor
operator|->
name|setmem
operator|.
name|cmdw
condition|)
block|{
name|len
operator|=
literal|2
expr_stmt|;
name|cmd
operator|=
name|current_monitor
operator|->
name|setmem
operator|.
name|cmdw
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
literal|1
expr_stmt|;
name|cmd
operator|=
name|current_monitor
operator|->
name|setmem
operator|.
name|cmdb
expr_stmt|;
block|}
name|val
operator|=
name|extract_unsigned_integer
argument_list|(
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|monitor_printf
argument_list|(
name|cmd
argument_list|,
name|memaddr
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|monitor_expect_prompt
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|len
return|;
block|}
end_function

begin_comment
comment|/* This is an alternate form of monitor_read_memory which is used for monitors    which can only read a single byte/word/etc. at a time.  */
end_comment

begin_function
specifier|static
name|int
name|monitor_read_memory_single
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|unsigned
name|LONGEST
name|val
decl_stmt|;
name|char
name|membuf
index|[
sizeof|sizeof
argument_list|(
name|LONGEST
argument_list|)
operator|*
literal|2
operator|+
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|cmd
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|memaddr
operator|&
literal|0x7
operator|)
operator|==
literal|0
operator|&&
name|len
operator|>=
literal|8
operator|&&
name|current_monitor
operator|->
name|getmem
operator|.
name|cmdll
condition|)
block|{
name|len
operator|=
literal|8
expr_stmt|;
name|cmd
operator|=
name|current_monitor
operator|->
name|getmem
operator|.
name|cmdll
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|memaddr
operator|&
literal|0x3
operator|)
operator|==
literal|0
operator|&&
name|len
operator|>=
literal|4
operator|&&
name|current_monitor
operator|->
name|getmem
operator|.
name|cmdl
condition|)
block|{
name|len
operator|=
literal|4
expr_stmt|;
name|cmd
operator|=
name|current_monitor
operator|->
name|getmem
operator|.
name|cmdl
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|memaddr
operator|&
literal|0x1
operator|)
operator|==
literal|0
operator|&&
name|len
operator|>=
literal|2
operator|&&
name|current_monitor
operator|->
name|getmem
operator|.
name|cmdw
condition|)
block|{
name|len
operator|=
literal|2
expr_stmt|;
name|cmd
operator|=
name|current_monitor
operator|->
name|getmem
operator|.
name|cmdw
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
literal|1
expr_stmt|;
name|cmd
operator|=
name|current_monitor
operator|->
name|getmem
operator|.
name|cmdb
expr_stmt|;
block|}
comment|/* Send the examine command.  */
name|monitor_printf
argument_list|(
name|cmd
argument_list|,
name|memaddr
argument_list|)
expr_stmt|;
comment|/* If RESP_DELIM is specified, we search for that as a leading delimiter for    the register value.  Otherwise, we just start searching from the start of    the buf.  */
if|if
condition|(
name|current_monitor
operator|->
name|getmem
operator|.
name|resp_delim
condition|)
name|monitor_expect_regexp
argument_list|(
operator|&
name|getmem_resp_delim_pattern
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Now, read the appropriate number of hex digits for this loc, skipping    spaces.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
operator|*
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|int
name|c
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|c
operator|=
name|readchar
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|isxdigit
argument_list|(
name|c
argument_list|)
condition|)
break|break;
if|if
condition|(
name|c
operator|==
literal|' '
condition|)
continue|continue;
name|error
argument_list|(
literal|"monitor_read_memory_single (0x%x):  bad response from monitor: %.*s%c."
argument_list|,
name|memaddr
argument_list|,
name|i
argument_list|,
name|membuf
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
name|membuf
index|[
name|i
index|]
operator|=
name|c
expr_stmt|;
block|}
name|membuf
index|[
name|i
index|]
operator|=
literal|'\000'
expr_stmt|;
comment|/* terminate the number */
comment|/* If TERM is present, we wait for that to show up.  Also, (if TERM is    present), we will send TERM_CMD if that is present.  In any case, we collect    all of the output into buf, and then wait for the normal prompt.  */
if|if
condition|(
name|current_monitor
operator|->
name|getmem
operator|.
name|term
condition|)
block|{
name|monitor_expect
argument_list|(
name|current_monitor
operator|->
name|getmem
operator|.
name|term
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* get response */
if|if
condition|(
name|current_monitor
operator|->
name|getmem
operator|.
name|term_cmd
condition|)
block|{
name|monitor_printf
argument_list|(
name|current_monitor
operator|->
name|getmem
operator|.
name|term_cmd
argument_list|)
expr_stmt|;
name|monitor_expect_prompt
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|monitor_expect_prompt
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* get response */
name|p
operator|=
name|membuf
expr_stmt|;
name|val
operator|=
name|strtoul
argument_list|(
name|membuf
argument_list|,
operator|&
name|p
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
operator|&&
name|membuf
operator|==
name|p
condition|)
name|error
argument_list|(
literal|"monitor_read_memory_single (0x%x):  bad value from monitor: %s."
argument_list|,
name|memaddr
argument_list|,
name|membuf
argument_list|)
expr_stmt|;
comment|/* supply register stores in target byte order, so swap here */
name|store_unsigned_integer
argument_list|(
name|myaddr
argument_list|,
name|len
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
name|len
return|;
block|}
end_function

begin_comment
comment|/* Copy LEN bytes of data from debugger memory at MYADDR to inferior's memory    at MEMADDR.  Returns length moved.  Currently, we only do one byte at a    time.  */
end_comment

begin_function
specifier|static
name|int
name|monitor_read_memory
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|unsigned
name|LONGEST
name|val
decl_stmt|;
name|unsigned
name|char
name|regbuf
index|[
name|MAX_REGISTER_RAW_SIZE
index|]
decl_stmt|;
name|char
name|buf
index|[
literal|512
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|p1
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|resp_len
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|current_monitor
operator|->
name|flags
operator|&
name|MO_GETMEM_READ_SINGLE
condition|)
return|return
name|monitor_read_memory_single
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
return|;
name|len
operator|=
name|min
argument_list|(
name|len
argument_list|,
literal|16
argument_list|)
expr_stmt|;
comment|/* See if xfer would cross a 16 byte boundary.  If so, clip it.  */
if|if
condition|(
operator|(
operator|(
name|memaddr
operator|^
operator|(
name|memaddr
operator|+
name|len
operator|-
literal|1
operator|)
operator|)
operator|&
operator|~
literal|0xf
operator|)
operator|!=
literal|0
condition|)
name|len
operator|=
operator|(
operator|(
name|memaddr
operator|+
name|len
operator|)
operator|&
operator|~
literal|0xf
operator|)
operator|-
name|memaddr
expr_stmt|;
comment|/* send the memory examine command */
if|if
condition|(
name|current_monitor
operator|->
name|flags
operator|&
name|MO_GETMEM_NEEDS_RANGE
condition|)
name|monitor_printf
argument_list|(
name|current_monitor
operator|->
name|getmem
operator|.
name|cmdb
argument_list|,
name|memaddr
argument_list|,
name|memaddr
operator|+
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|monitor_printf
argument_list|(
name|current_monitor
operator|->
name|getmem
operator|.
name|cmdb
argument_list|,
name|memaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* If TERM is present, we wait for that to show up.  Also, (if TERM is    present), we will send TERM_CMD if that is present.  In any case, we collect    all of the output into buf, and then wait for the normal prompt.  */
if|if
condition|(
name|current_monitor
operator|->
name|getmem
operator|.
name|term
condition|)
block|{
name|resp_len
operator|=
name|monitor_expect
argument_list|(
name|current_monitor
operator|->
name|getmem
operator|.
name|term
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
expr_stmt|;
comment|/* get response */
if|if
condition|(
name|resp_len
operator|<=
literal|0
condition|)
name|error
argument_list|(
literal|"monitor_read_memory (0x%x):  excessive response from monitor: %.*s."
argument_list|,
name|memaddr
argument_list|,
name|resp_len
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_monitor
operator|->
name|getmem
operator|.
name|term_cmd
condition|)
block|{
name|SERIAL_WRITE
argument_list|(
name|monitor_desc
argument_list|,
name|current_monitor
operator|->
name|getmem
operator|.
name|term_cmd
argument_list|,
name|strlen
argument_list|(
name|current_monitor
operator|->
name|getmem
operator|.
name|term_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|monitor_expect_prompt
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|resp_len
operator|=
name|monitor_expect_prompt
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
expr_stmt|;
comment|/* get response */
name|p
operator|=
name|buf
expr_stmt|;
comment|/* If RESP_DELIM is specified, we search for that as a leading delimiter for      the values.  Otherwise, we just start searching from the start of the buf.    */
if|if
condition|(
name|current_monitor
operator|->
name|getmem
operator|.
name|resp_delim
condition|)
block|{
name|int
name|retval
decl_stmt|,
name|tmp
decl_stmt|;
name|struct
name|re_registers
name|resp_strings
decl_stmt|;
name|tmp
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|retval
operator|=
name|re_search
argument_list|(
operator|&
name|getmem_resp_delim_pattern
argument_list|,
name|p
argument_list|,
name|tmp
argument_list|,
literal|0
argument_list|,
name|tmp
argument_list|,
operator|&
name|resp_strings
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"monitor_read_memory (0x%x):  bad response from monitor: %.*s."
argument_list|,
name|memaddr
argument_list|,
name|resp_len
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|p
operator|+=
name|resp_strings
operator|.
name|end
index|[
literal|0
index|]
expr_stmt|;
if|#
directive|if
literal|0
block|p = strstr (p, current_monitor->getmem.resp_delim);       if (!p) 	error ("monitor_read_memory (0x%x):  bad response from monitor: %.*s.", 	       memaddr, resp_len, buf);       p += strlen (current_monitor->getmem.resp_delim);
endif|#
directive|endif
block|}
for|for
control|(
name|i
operator|=
name|len
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
comment|/* Skip non-hex chars, but bomb on end of string and newlines */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|isxdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\000'
operator|||
operator|*
name|p
operator|==
literal|'\n'
operator|||
operator|*
name|p
operator|==
literal|'\r'
condition|)
name|error
argument_list|(
literal|"monitor_read_memory (0x%x):  badly terminated response from monitor: %.*s"
argument_list|,
name|memaddr
argument_list|,
name|resp_len
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
name|val
operator|=
name|strtoul
argument_list|(
name|p
argument_list|,
operator|&
name|p1
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
operator|&&
name|p
operator|==
name|p1
condition|)
name|error
argument_list|(
literal|"monitor_read_memory (0x%x):  bad value from monitor: %.*s."
argument_list|,
name|memaddr
argument_list|,
name|resp_len
argument_list|,
name|buf
argument_list|)
expr_stmt|;
operator|*
name|myaddr
operator|++
operator|=
name|val
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|1
condition|)
break|break;
name|p
operator|=
name|p1
expr_stmt|;
block|}
return|return
name|len
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|monitor_xfer_memory
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|,
name|write
parameter_list|,
name|target
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|write
decl_stmt|;
name|struct
name|target_ops
modifier|*
name|target
decl_stmt|;
comment|/* ignored */
block|{
return|return
name|dcache_xfer_memory
argument_list|(
name|remote_dcache
argument_list|,
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|,
name|write
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|monitor_kill
parameter_list|()
block|{
return|return;
comment|/* ignore attempts to kill target system */
block|}
end_function

begin_comment
comment|/* All we actually do is set the PC to the start address of exec_bfd, and start    the program at that point.  */
end_comment

begin_function
specifier|static
name|void
name|monitor_create_inferior
parameter_list|(
name|exec_file
parameter_list|,
name|args
parameter_list|,
name|env
parameter_list|)
name|char
modifier|*
name|exec_file
decl_stmt|;
name|char
modifier|*
name|args
decl_stmt|;
name|char
modifier|*
modifier|*
name|env
decl_stmt|;
block|{
if|if
condition|(
name|args
operator|&&
operator|(
operator|*
name|args
operator|!=
literal|'\000'
operator|)
condition|)
name|error
argument_list|(
literal|"Args are not supported by the monitor."
argument_list|)
expr_stmt|;
name|clear_proceed_status
argument_list|()
expr_stmt|;
name|proceed
argument_list|(
name|bfd_get_start_address
argument_list|(
name|exec_bfd
argument_list|)
argument_list|,
name|TARGET_SIGNAL_0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clean up when a program exits.    The program actually lives on in the remote processor's RAM, and may be    run again without a download.  Don't leave it full of breakpoint    instructions.  */
end_comment

begin_function
specifier|static
name|void
name|monitor_mourn_inferior
parameter_list|()
block|{
name|unpush_target
argument_list|(
name|targ_ops
argument_list|)
expr_stmt|;
name|generic_mourn_inferior
argument_list|()
expr_stmt|;
comment|/* Do all the proper things now */
block|}
end_function

begin_define
define|#
directive|define
name|NUM_MONITOR_BREAKPOINTS
value|8
end_define

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|breakaddr
index|[
name|NUM_MONITOR_BREAKPOINTS
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Tell the monitor to add a breakpoint.  */
end_comment

begin_function
specifier|static
name|int
name|monitor_insert_breakpoint
parameter_list|(
name|addr
parameter_list|,
name|shadow
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
name|char
modifier|*
name|shadow
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
specifier|static
name|unsigned
name|char
name|break_insn
index|[]
init|=
name|BREAKPOINT
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_MONITOR_BREAKPOINTS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|breakaddr
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|breakaddr
index|[
name|i
index|]
operator|=
name|addr
expr_stmt|;
name|monitor_read_memory
argument_list|(
name|addr
argument_list|,
name|shadow
argument_list|,
sizeof|sizeof
argument_list|(
name|break_insn
argument_list|)
argument_list|)
expr_stmt|;
name|monitor_printf
argument_list|(
name|SET_BREAK_CMD
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|monitor_expect_prompt
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|error
argument_list|(
literal|"Too many breakpoints (> %d) for monitor."
argument_list|,
name|NUM_MONITOR_BREAKPOINTS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Tell the monitor to remove a breakpoint.  */
end_comment

begin_function
specifier|static
name|int
name|monitor_remove_breakpoint
parameter_list|(
name|addr
parameter_list|,
name|shadow
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
name|char
modifier|*
name|shadow
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_MONITOR_BREAKPOINTS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|breakaddr
index|[
name|i
index|]
operator|==
name|addr
condition|)
block|{
name|breakaddr
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|/* some monitors remove breakpoints based on the address */
if|if
condition|(
name|current_monitor
operator|->
name|flags
operator|&
name|MO_CLR_BREAK_USES_ADDR
condition|)
name|monitor_printf
argument_list|(
name|CLR_BREAK_CMD
argument_list|,
name|addr
argument_list|)
expr_stmt|;
else|else
name|monitor_printf
argument_list|(
name|CLR_BREAK_CMD
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|monitor_expect_prompt
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|fprintf_unfiltered
argument_list|(
name|stderr
argument_list|,
literal|"Can't find breakpoint associated with 0x%x\n"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* monitor_load -- download a file. */
end_comment

begin_function
specifier|static
name|void
name|monitor_load
parameter_list|(
name|file
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|dcache_flush
argument_list|(
name|remote_dcache
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_monitor
operator|->
name|load_routine
condition|)
name|current_monitor
operator|->
name|load_routine
argument_list|(
name|monitor_desc
argument_list|,
name|file
argument_list|,
name|hashmark
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* The default is ascii S-records */
name|monitor_printf
argument_list|(
name|LOAD_CMD
argument_list|)
expr_stmt|;
comment|/* tell the monitor to load */
if|if
condition|(
name|current_monitor
operator|->
name|loadresp
condition|)
name|monitor_expect
argument_list|(
name|current_monitor
operator|->
name|loadresp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|load_srec
argument_list|(
name|monitor_desc
argument_list|,
name|file
argument_list|,
literal|32
argument_list|,
name|SREC_ALL
argument_list|,
name|hashmark
argument_list|)
expr_stmt|;
name|monitor_expect_prompt
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Finally, make the PC point at the start address */
if|if
condition|(
name|exec_bfd
condition|)
name|write_pc
argument_list|(
name|bfd_get_start_address
argument_list|(
name|exec_bfd
argument_list|)
argument_list|)
expr_stmt|;
name|inferior_pid
operator|=
literal|0
expr_stmt|;
comment|/* No process now */
comment|/* This is necessary because many things were based on the PC at the time that    we attached to the monitor, which is no longer valid now that we have loaded    new code (and just changed the PC).  Another way to do this might be to call    normal_stop, except that the stack may not be valid, and things would get    horribly confused... */
name|clear_symtab_users
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|monitor_stop
parameter_list|()
block|{
if|if
condition|(
operator|(
name|current_monitor
operator|->
name|flags
operator|&
name|MO_SEND_BREAK_ON_STOP
operator|)
operator|!=
literal|0
condition|)
name|SERIAL_SEND_BREAK
argument_list|(
name|monitor_desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_monitor
operator|->
name|stop
condition|)
name|monitor_printf_noecho
argument_list|(
name|current_monitor
operator|->
name|stop
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Put a command string, in args, out to MONITOR.  Output from MONITOR    is placed on the users terminal until the prompt is seen. FIXME: We    read the characters ourseleves here cause of a nasty echo.  */
end_comment

begin_function
specifier|static
name|void
name|monitor_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|resp_len
decl_stmt|;
name|char
name|buf
index|[
literal|1000
index|]
decl_stmt|;
if|if
condition|(
name|monitor_desc
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"monitor target not open."
argument_list|)
expr_stmt|;
name|p
operator|=
name|PROMPT
expr_stmt|;
comment|/* Send the command.  Note that if no args were supplied, then we're      just sending the monitor a newline, which is sometimes useful.  */
name|monitor_printf
argument_list|(
literal|"%s\r"
argument_list|,
operator|(
name|args
condition|?
name|args
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
name|resp_len
operator|=
name|monitor_expect_prompt
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
name|buf
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
comment|/* Output the response */
block|}
end_function

begin_comment
comment|/* Convert hex digit A to a number.  */
end_comment

begin_function
specifier|static
name|int
name|from_hex
parameter_list|(
name|a
parameter_list|)
name|int
name|a
decl_stmt|;
block|{
if|if
condition|(
name|a
operator|>=
literal|'0'
operator|&&
name|a
operator|<=
literal|'9'
condition|)
return|return
name|a
operator|-
literal|'0'
return|;
if|if
condition|(
name|a
operator|>=
literal|'a'
operator|&&
name|a
operator|<=
literal|'f'
condition|)
return|return
name|a
operator|-
literal|'a'
operator|+
literal|10
return|;
if|if
condition|(
name|a
operator|>=
literal|'A'
operator|&&
name|a
operator|<=
literal|'F'
condition|)
return|return
name|a
operator|-
literal|'A'
operator|+
literal|10
return|;
name|error
argument_list|(
literal|"Reply contains invalid hex digit 0x%x"
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|target_ops
name|monitor_ops
init|=
block|{
name|NULL
block|,
comment|/* to_shortname */
name|NULL
block|,
comment|/* to_longname */
name|NULL
block|,
comment|/* to_doc */
name|NULL
block|,
comment|/* to_open */
name|monitor_close
block|,
comment|/* to_close */
name|NULL
block|,
comment|/* to_attach */
name|monitor_detach
block|,
comment|/* to_detach */
name|monitor_resume
block|,
comment|/* to_resume */
name|monitor_wait
block|,
comment|/* to_wait */
name|monitor_fetch_registers
block|,
comment|/* to_fetch_registers */
name|monitor_store_registers
block|,
comment|/* to_store_registers */
name|monitor_prepare_to_store
block|,
comment|/* to_prepare_to_store */
name|monitor_xfer_memory
block|,
comment|/* to_xfer_memory */
name|monitor_files_info
block|,
comment|/* to_files_info */
name|monitor_insert_breakpoint
block|,
comment|/* to_insert_breakpoint */
name|monitor_remove_breakpoint
block|,
comment|/* to_remove_breakpoint */
literal|0
block|,
comment|/* to_terminal_init */
literal|0
block|,
comment|/* to_terminal_inferior */
literal|0
block|,
comment|/* to_terminal_ours_for_output */
literal|0
block|,
comment|/* to_terminal_ours */
literal|0
block|,
comment|/* to_terminal_info */
name|monitor_kill
block|,
comment|/* to_kill */
name|monitor_load
block|,
comment|/* to_load */
literal|0
block|,
comment|/* to_lookup_symbol */
name|monitor_create_inferior
block|,
comment|/* to_create_inferior */
name|monitor_mourn_inferior
block|,
comment|/* to_mourn_inferior */
literal|0
block|,
comment|/* to_can_run */
literal|0
block|,
comment|/* to_notice_signals */
literal|0
block|,
comment|/* to_thread_alive */
name|monitor_stop
block|,
comment|/* to_stop */
name|process_stratum
block|,
comment|/* to_stratum */
literal|0
block|,
comment|/* to_next */
literal|1
block|,
comment|/* to_has_all_memory */
literal|1
block|,
comment|/* to_has_memory */
literal|1
block|,
comment|/* to_has_stack */
literal|1
block|,
comment|/* to_has_registers */
literal|1
block|,
comment|/* to_has_execution */
literal|0
block|,
comment|/* sections */
literal|0
block|,
comment|/* sections_end */
name|OPS_MAGIC
comment|/* to_magic */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Init the target_ops structure pointed at by OPS */
end_comment

begin_function
name|void
name|init_monitor_ops
parameter_list|(
name|ops
parameter_list|)
name|struct
name|target_ops
modifier|*
name|ops
decl_stmt|;
block|{
name|memcpy
argument_list|(
name|ops
argument_list|,
operator|&
name|monitor_ops
argument_list|,
sizeof|sizeof
name|monitor_ops
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Define additional commands that are usually only used by monitors.  */
end_comment

begin_function
name|void
name|_initialize_remote_monitors
parameter_list|()
block|{
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"hash"
argument_list|,
name|no_class
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|hashmark
argument_list|,
literal|"Set display of activity while downloading a file.\n\ When enabled, a hashmark \'#\' is displayed."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"monitor"
argument_list|,
name|class_obscure
argument_list|,
name|monitor_command
argument_list|,
literal|"Send a command to the debug monitor."
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

