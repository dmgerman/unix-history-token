begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Remote debugging interface for boot monitors, for GDB.     Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2002 Free Software Foundation, Inc.     Contributed by Cygnus Support.  Written by Rob Savoye for Cygnus.    Resurrected from the ashes by Stu Grossman.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This file was derived from various remote-* modules. It is a collection    of generic support functions so GDB can talk directly to a ROM based    monitor. This saves use from having to hack an exception based handler    into existence, and makes for quick porting.     This module talks to a debug monitor called 'MONITOR', which    We communicate with MONITOR via either a direct serial line, or a TCP    (or possibly TELNET) stream to a terminal multiplexor,    which in turn talks to the target board.  */
end_comment

begin_comment
comment|/* FIXME 32x64: This code assumes that registers and addresses are at    most 32 bits long.  If they can be larger, you will need to declare    values as LONGEST and use %llx or some such to print values when    building commands to send to the monitor.  Since we don't know of    any actual 64-bit targets with ROM monitors that use this code,    it's not an issue right now.  -sts 4/18/96  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"serial.h"
end_include

begin_include
include|#
directive|include
file|"monitor.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"gdb_regex.h"
end_include

begin_include
include|#
directive|include
file|"srec.h"
end_include

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_decl_stmt
specifier|static
name|char
modifier|*
name|dev_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|target_ops
modifier|*
name|targ_ops
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|monitor_vsprintf
parameter_list|(
name|char
modifier|*
name|sndbuf
parameter_list|,
name|char
modifier|*
name|pattern
parameter_list|,
name|va_list
name|args
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|readchar
parameter_list|(
name|int
name|timeout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|monitor_fetch_register
parameter_list|(
name|int
name|regno
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|monitor_store_register
parameter_list|(
name|int
name|regno
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|monitor_printable_string
parameter_list|(
name|char
modifier|*
name|newstr
parameter_list|,
name|char
modifier|*
name|oldstr
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|monitor_error
parameter_list|(
name|char
modifier|*
name|function
parameter_list|,
name|char
modifier|*
name|message
parameter_list|,
name|CORE_ADDR
name|memaddr
parameter_list|,
name|int
name|len
parameter_list|,
name|char
modifier|*
name|string
parameter_list|,
name|int
name|final_char
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|monitor_detach
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|monitor_resume
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
name|int
name|step
parameter_list|,
name|enum
name|target_signal
name|sig
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|monitor_interrupt
parameter_list|(
name|int
name|signo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|monitor_interrupt_twice
parameter_list|(
name|int
name|signo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|monitor_interrupt_query
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|monitor_wait_cleanup
parameter_list|(
name|void
modifier|*
name|old_timeout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ptid_t
name|monitor_wait
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
name|struct
name|target_waitstatus
modifier|*
name|status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|monitor_fetch_registers
parameter_list|(
name|int
name|regno
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|monitor_store_registers
parameter_list|(
name|int
name|regno
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|monitor_prepare_to_store
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|monitor_xfer_memory
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|write
parameter_list|,
name|struct
name|mem_attrib
modifier|*
name|attrib
parameter_list|,
name|struct
name|target_ops
modifier|*
name|target
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|monitor_files_info
parameter_list|(
name|struct
name|target_ops
modifier|*
name|ops
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|monitor_insert_breakpoint
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|char
modifier|*
name|shadow
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|monitor_remove_breakpoint
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|char
modifier|*
name|shadow
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|monitor_kill
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|monitor_load
parameter_list|(
name|char
modifier|*
name|file
parameter_list|,
name|int
name|from_tty
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|monitor_mourn_inferior
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|monitor_stop
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|monitor_read_memory
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|monitor_write_memory
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|monitor_write_memory_bytes
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|monitor_write_memory_block
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|monitor_expect_regexp
parameter_list|(
name|struct
name|re_pattern_buffer
modifier|*
name|pat
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|buflen
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|monitor_dump_regs
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static int from_hex (int a); static unsigned long get_hex_word (void);
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|parse_register_dump
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|monitor_ops
modifier|*
name|current_monitor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hashmark
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* flag set by "set hash" */
end_comment

begin_decl_stmt
specifier|static
name|int
name|timeout
init|=
literal|30
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|in_monitor_wait
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means we are in monitor_wait() */
end_comment

begin_function_decl
specifier|static
name|void
function_decl|(
modifier|*
name|ofunc
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Old SIGINT signal handler */
end_comment

begin_decl_stmt
specifier|static
name|CORE_ADDR
modifier|*
name|breakaddr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Descriptor for I/O to remote machine.  Initialize it to NULL so    that monitor_open knows that we don't have a file open when the    program starts.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|serial
modifier|*
name|monitor_desc
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to regexp pattern matching data */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|re_pattern_buffer
name|register_pattern
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|register_fastmap
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|re_pattern_buffer
name|getmem_resp_delim_pattern
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|getmem_resp_delim_fastmap
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|re_pattern_buffer
name|setmem_resp_delim_pattern
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|setmem_resp_delim_fastmap
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|re_pattern_buffer
name|setreg_resp_delim_pattern
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|setreg_resp_delim_fastmap
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dump_reg_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means do a dump_registers cmd when 				   monitor_wait wakes up.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|first_time
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* is this the first time we're executing after  				   gaving created the child proccess? */
end_comment

begin_define
define|#
directive|define
name|TARGET_BUF_SIZE
value|2048
end_define

begin_comment
comment|/* Monitor specific debugging information.  Typically only useful to    the developer of a new monitor interface. */
end_comment

begin_function_decl
specifier|static
name|void
name|monitor_debug
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
function_decl|ATTR_FORMAT
parameter_list|(
name|printf
parameter_list|,
function_decl|1
operator|,
function_decl|2
end_function_decl

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_decl_stmt
specifier|static
name|int
name|monitor_debug_p
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* NOTE: This file alternates between monitor_debug_p and remote_debug    when determining if debug information is printed.  Perhaphs this    could be simplified. */
end_comment

begin_function
specifier|static
name|void
name|monitor_debug
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
if|if
condition|(
name|monitor_debug_p
condition|)
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vfprintf_filtered
argument_list|(
name|gdb_stdlog
argument_list|,
name|fmt
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Convert a string into a printable representation, Return # byte in    the new string.  When LEN is>0 it specifies the size of the    string.  Otherwize strlen(oldstr) is used. */
end_comment

begin_function
specifier|static
name|void
name|monitor_printable_string
parameter_list|(
name|char
modifier|*
name|newstr
parameter_list|,
name|char
modifier|*
name|oldstr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|ch
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
name|len
operator|=
name|strlen
argument_list|(
name|oldstr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|ch
operator|=
name|oldstr
index|[
name|i
index|]
expr_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
default|default:
if|if
condition|(
name|isprint
argument_list|(
name|ch
argument_list|)
condition|)
operator|*
name|newstr
operator|++
operator|=
name|ch
expr_stmt|;
else|else
block|{
name|sprintf
argument_list|(
name|newstr
argument_list|,
literal|"\\x%02x"
argument_list|,
name|ch
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|newstr
operator|+=
literal|4
expr_stmt|;
block|}
break|break;
case|case
literal|'\\'
case|:
operator|*
name|newstr
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|newstr
operator|++
operator|=
literal|'\\'
expr_stmt|;
break|break;
case|case
literal|'\b'
case|:
operator|*
name|newstr
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|newstr
operator|++
operator|=
literal|'b'
expr_stmt|;
break|break;
case|case
literal|'\f'
case|:
operator|*
name|newstr
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|newstr
operator|++
operator|=
literal|'t'
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
operator|*
name|newstr
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|newstr
operator|++
operator|=
literal|'n'
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
operator|*
name|newstr
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|newstr
operator|++
operator|=
literal|'r'
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
operator|*
name|newstr
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|newstr
operator|++
operator|=
literal|'t'
expr_stmt|;
break|break;
case|case
literal|'\v'
case|:
operator|*
name|newstr
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|newstr
operator|++
operator|=
literal|'v'
expr_stmt|;
break|break;
block|}
block|}
operator|*
name|newstr
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print monitor errors with a string, converting the string to printable    representation.  */
end_comment

begin_function
specifier|static
name|void
name|monitor_error
parameter_list|(
name|char
modifier|*
name|function
parameter_list|,
name|char
modifier|*
name|message
parameter_list|,
name|CORE_ADDR
name|memaddr
parameter_list|,
name|int
name|len
parameter_list|,
name|char
modifier|*
name|string
parameter_list|,
name|int
name|final_char
parameter_list|)
block|{
name|int
name|real_len
init|=
operator|(
name|len
operator|==
literal|0
operator|&&
name|string
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
operator|)
condition|?
name|strlen
argument_list|(
name|string
argument_list|)
else|:
name|len
decl_stmt|;
name|char
modifier|*
name|safe_string
init|=
name|alloca
argument_list|(
operator|(
name|real_len
operator|*
literal|4
operator|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|monitor_printable_string
argument_list|(
name|safe_string
argument_list|,
name|string
argument_list|,
name|real_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|final_char
condition|)
name|error
argument_list|(
literal|"%s (0x%s): %s: %s%c"
argument_list|,
name|function
argument_list|,
name|paddr_nz
argument_list|(
name|memaddr
argument_list|)
argument_list|,
name|message
argument_list|,
name|safe_string
argument_list|,
name|final_char
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"%s (0x%s): %s: %s"
argument_list|,
name|function
argument_list|,
name|paddr_nz
argument_list|(
name|memaddr
argument_list|)
argument_list|,
name|message
argument_list|,
name|safe_string
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Convert hex digit A to a number.  */
end_comment

begin_function
specifier|static
name|int
name|fromhex
parameter_list|(
name|int
name|a
parameter_list|)
block|{
if|if
condition|(
name|a
operator|>=
literal|'0'
operator|&&
name|a
operator|<=
literal|'9'
condition|)
return|return
name|a
operator|-
literal|'0'
return|;
elseif|else
if|if
condition|(
name|a
operator|>=
literal|'a'
operator|&&
name|a
operator|<=
literal|'f'
condition|)
return|return
name|a
operator|-
literal|'a'
operator|+
literal|10
return|;
elseif|else
if|if
condition|(
name|a
operator|>=
literal|'A'
operator|&&
name|a
operator|<=
literal|'F'
condition|)
return|return
name|a
operator|-
literal|'A'
operator|+
literal|10
return|;
else|else
name|error
argument_list|(
literal|"Invalid hex digit %d"
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* monitor_vsprintf - similar to vsprintf but handles 64-bit addresses     This function exists to get around the problem that many host platforms    don't have a printf that can print 64-bit addresses.  The %A format    specification is recognized as a special case, and causes the argument    to be printed as a 64-bit hexadecimal address.     Only format specifiers of the form "[0-9]*[a-z]" are recognized.    If it is a '%s' format, the argument is a string; otherwise the    argument is assumed to be a long integer.     %% is also turned into a single %.  */
end_comment

begin_function
specifier|static
name|void
name|monitor_vsprintf
parameter_list|(
name|char
modifier|*
name|sndbuf
parameter_list|,
name|char
modifier|*
name|pattern
parameter_list|,
name|va_list
name|args
parameter_list|)
block|{
name|char
name|format
index|[
literal|10
index|]
decl_stmt|;
name|char
name|fmt
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
name|long
name|arg_int
decl_stmt|;
name|CORE_ADDR
name|arg_addr
decl_stmt|;
name|char
modifier|*
name|arg_string
decl_stmt|;
for|for
control|(
name|p
operator|=
name|pattern
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'%'
condition|)
block|{
comment|/* Copy the format specifier to a separate buffer.  */
name|format
index|[
literal|0
index|]
operator|=
operator|*
name|p
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
operator|*
name|p
operator|>=
literal|'0'
operator|&&
operator|*
name|p
operator|<=
literal|'9'
operator|&&
name|i
operator|<
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|format
argument_list|)
operator|-
literal|2
condition|;
name|i
operator|++
operator|,
name|p
operator|++
control|)
name|format
index|[
name|i
index|]
operator|=
operator|*
name|p
expr_stmt|;
name|format
index|[
name|i
index|]
operator|=
name|fmt
operator|=
operator|*
name|p
expr_stmt|;
name|format
index|[
name|i
operator|+
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Fetch the next argument and print it.  */
switch|switch
condition|(
name|fmt
condition|)
block|{
case|case
literal|'%'
case|:
name|strcpy
argument_list|(
name|sndbuf
argument_list|,
literal|"%"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
name|arg_addr
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|CORE_ADDR
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|sndbuf
argument_list|,
name|paddr_nz
argument_list|(
name|arg_addr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|arg_string
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|sndbuf
argument_list|,
name|format
argument_list|,
name|arg_string
argument_list|)
expr_stmt|;
break|break;
default|default:
name|arg_int
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|long
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|sndbuf
argument_list|,
name|format
argument_list|,
name|arg_int
argument_list|)
expr_stmt|;
break|break;
block|}
name|sndbuf
operator|+=
name|strlen
argument_list|(
name|sndbuf
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|sndbuf
operator|++
operator|=
operator|*
name|p
expr_stmt|;
block|}
operator|*
name|sndbuf
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_comment
comment|/* monitor_printf_noecho -- Send data to monitor, but don't expect an echo.    Works just like printf.  */
end_comment

begin_function
name|void
name|monitor_printf_noecho
parameter_list|(
name|char
modifier|*
name|pattern
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|char
name|sndbuf
index|[
literal|2000
index|]
decl_stmt|;
name|int
name|len
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|pattern
argument_list|)
expr_stmt|;
name|monitor_vsprintf
argument_list|(
name|sndbuf
argument_list|,
name|pattern
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|sndbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|+
literal|1
operator|>
sizeof|sizeof
name|sndbuf
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"failed internal consistency check"
argument_list|)
expr_stmt|;
if|if
condition|(
name|monitor_debug_p
condition|)
block|{
name|char
modifier|*
name|safe_string
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|strlen
argument_list|(
name|sndbuf
argument_list|)
operator|*
literal|4
operator|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|monitor_printable_string
argument_list|(
name|safe_string
argument_list|,
name|sndbuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"sent[%s]\n"
argument_list|,
name|safe_string
argument_list|)
expr_stmt|;
block|}
name|monitor_write
argument_list|(
name|sndbuf
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* monitor_printf -- Send data to monitor and check the echo.  Works just like    printf.  */
end_comment

begin_function
name|void
name|monitor_printf
parameter_list|(
name|char
modifier|*
name|pattern
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|char
name|sndbuf
index|[
literal|2000
index|]
decl_stmt|;
name|int
name|len
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|pattern
argument_list|)
expr_stmt|;
name|monitor_vsprintf
argument_list|(
name|sndbuf
argument_list|,
name|pattern
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|sndbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|+
literal|1
operator|>
sizeof|sizeof
name|sndbuf
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"failed internal consistency check"
argument_list|)
expr_stmt|;
if|if
condition|(
name|monitor_debug_p
condition|)
block|{
name|char
modifier|*
name|safe_string
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|len
operator|*
literal|4
operator|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|monitor_printable_string
argument_list|(
name|safe_string
argument_list|,
name|sndbuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"sent[%s]\n"
argument_list|,
name|safe_string
argument_list|)
expr_stmt|;
block|}
name|monitor_write
argument_list|(
name|sndbuf
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* We used to expect that the next immediate output was the characters we      just output, but sometimes some extra junk appeared before the characters      we expected, like an extra prompt, or a portmaster sending telnet negotiations.      So, just start searching for what we sent, and skip anything unknown.  */
name|monitor_debug
argument_list|(
literal|"ExpectEcho\n"
argument_list|)
expr_stmt|;
name|monitor_expect
argument_list|(
name|sndbuf
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write characters to the remote system.  */
end_comment

begin_function
name|void
name|monitor_write
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|buflen
parameter_list|)
block|{
if|if
condition|(
name|serial_write
argument_list|(
name|monitor_desc
argument_list|,
name|buf
argument_list|,
name|buflen
argument_list|)
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"serial_write failed: %s\n"
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read a binary character from the remote system, doing all the fancy    timeout stuff, but without interpreting the character in any way,    and without printing remote debug information.  */
end_comment

begin_function
name|int
name|monitor_readchar
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|int
name|looping
decl_stmt|;
do|do
block|{
name|looping
operator|=
literal|0
expr_stmt|;
name|c
operator|=
name|serial_readchar
argument_list|(
name|monitor_desc
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|0
condition|)
name|c
operator|&=
literal|0xff
expr_stmt|;
comment|/* don't lose bit 7 */
block|}
do|while
condition|(
name|looping
condition|)
do|;
if|if
condition|(
name|c
operator|>=
literal|0
condition|)
return|return
name|c
return|;
if|if
condition|(
name|c
operator|==
name|SERIAL_TIMEOUT
condition|)
name|error
argument_list|(
literal|"Timeout reading from remote system."
argument_list|)
expr_stmt|;
name|perror_with_name
argument_list|(
literal|"remote-monitor"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read a character from the remote system, doing all the fancy    timeout stuff.  */
end_comment

begin_function
specifier|static
name|int
name|readchar
parameter_list|(
name|int
name|timeout
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
specifier|static
enum|enum
block|{
name|last_random
block|,
name|last_nl
block|,
name|last_cr
block|,
name|last_crnl
block|}
name|state
init|=
name|last_random
enum|;
name|int
name|looping
decl_stmt|;
do|do
block|{
name|looping
operator|=
literal|0
expr_stmt|;
name|c
operator|=
name|serial_readchar
argument_list|(
name|monitor_desc
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|0
condition|)
block|{
name|c
operator|&=
literal|0x7f
expr_stmt|;
comment|/* This seems to interfere with proper function of the 	     input stream */
if|if
condition|(
name|monitor_debug_p
operator|||
name|remote_debug
condition|)
block|{
name|char
name|buf
index|[
literal|2
index|]
decl_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|puts_debug
argument_list|(
literal|"read -->"
argument_list|,
name|buf
argument_list|,
literal|"<--"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Canonicialize \n\r combinations into one \r */
if|if
condition|(
operator|(
name|current_monitor
operator|->
name|flags
operator|&
name|MO_HANDLE_NL
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|==
literal|'\r'
operator|&&
name|state
operator|==
name|last_nl
operator|)
operator|||
operator|(
name|c
operator|==
literal|'\n'
operator|&&
name|state
operator|==
name|last_cr
operator|)
condition|)
block|{
name|state
operator|=
name|last_crnl
expr_stmt|;
name|looping
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\r'
condition|)
name|state
operator|=
name|last_cr
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|!=
literal|'\n'
condition|)
name|state
operator|=
name|last_random
expr_stmt|;
else|else
block|{
name|state
operator|=
name|last_nl
expr_stmt|;
name|c
operator|=
literal|'\r'
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|looping
condition|)
do|;
if|if
condition|(
name|c
operator|>=
literal|0
condition|)
return|return
name|c
return|;
if|if
condition|(
name|c
operator|==
name|SERIAL_TIMEOUT
condition|)
if|#
directive|if
literal|0
comment|/* I fail to see how detaching here can be useful */
then|if (in_monitor_wait)
comment|/* Watchdog went off */
then|{ 	target_mourn_inferior (); 	error ("GDB serial timeout has expired.  Target detached.\n");       }     else
endif|#
directive|endif
name|error
argument_list|(
literal|"Timeout reading from remote system."
argument_list|)
expr_stmt|;
name|perror_with_name
argument_list|(
literal|"remote-monitor"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Scan input from the remote system, until STRING is found.  If BUF is non-    zero, then collect input until we have collected either STRING or BUFLEN-1    chars.  In either case we terminate BUF with a 0.  If input overflows BUF    because STRING can't be found, return -1, else return number of chars in BUF    (minus the terminating NUL).  Note that in the non-overflow case, STRING    will be at the end of BUF.  */
end_comment

begin_function
name|int
name|monitor_expect
parameter_list|(
name|char
modifier|*
name|string
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|buflen
parameter_list|)
block|{
name|char
modifier|*
name|p
init|=
name|string
decl_stmt|;
name|int
name|obuflen
init|=
name|buflen
decl_stmt|;
name|int
name|c
decl_stmt|;
if|if
condition|(
name|monitor_debug_p
condition|)
block|{
name|char
modifier|*
name|safe_string
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|strlen
argument_list|(
name|string
argument_list|)
operator|*
literal|4
operator|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|monitor_printable_string
argument_list|(
name|safe_string
argument_list|,
name|string
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"MON Expecting '%s'\n"
argument_list|,
name|safe_string
argument_list|)
expr_stmt|;
block|}
name|immediate_quit
operator|++
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|buf
condition|)
block|{
if|if
condition|(
name|buflen
operator|<
literal|2
condition|)
block|{
operator|*
name|buf
operator|=
literal|'\000'
expr_stmt|;
name|immediate_quit
operator|--
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|c
operator|=
name|readchar
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\000'
condition|)
continue|continue;
operator|*
name|buf
operator|++
operator|=
name|c
expr_stmt|;
name|buflen
operator|--
expr_stmt|;
block|}
else|else
name|c
operator|=
name|readchar
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
comment|/* Don't expect any ^C sent to be echoed */
if|if
condition|(
operator|*
name|p
operator|==
literal|'\003'
operator|||
name|c
operator|==
operator|*
name|p
condition|)
block|{
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
name|immediate_quit
operator|--
expr_stmt|;
if|if
condition|(
name|buf
condition|)
block|{
operator|*
name|buf
operator|++
operator|=
literal|'\000'
expr_stmt|;
return|return
name|obuflen
operator|-
name|buflen
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
block|}
else|else
block|{
comment|/* We got a character that doesn't match the string.  We need to 	     back up p, but how far?  If we're looking for "..howdy" and the 	     monitor sends "...howdy"?  There's certainly a match in there, 	     but when we receive the third ".", we won't find it if we just 	     restart the matching at the beginning of the string.  	     This is a Boyer-Moore kind of situation.  We want to reset P to 	     the end of the longest prefix of STRING that is a suffix of 	     what we've read so far.  In the example above, that would be 	     ".." --- the longest prefix of "..howdy" that is a suffix of 	     "...".  This longest prefix could be the empty string, if C 	     is nowhere to be found in STRING.  	     If this longest prefix is not the empty string, it must contain 	     C, so let's search from the end of STRING for instances of C, 	     and see if the portion of STRING before that is a suffix of 	     what we read before C.  Actually, we can search backwards from 	     p, since we know no prefix can be longer than that.  	     Note that we can use STRING itself, along with C, as a record 	     of what we've received so far.  :) */
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
operator|(
name|p
operator|-
name|string
operator|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|string
index|[
name|i
index|]
operator|==
name|c
condition|)
block|{
comment|/* Is this prefix a suffix of what we've read so far? 		   In other words, does                      string[0 .. i-1] == string[p - i, p - 1]? */
if|if
condition|(
operator|!
name|memcmp
argument_list|(
name|string
argument_list|,
name|p
operator|-
name|i
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|p
operator|=
name|string
operator|+
name|i
operator|+
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|p
operator|=
name|string
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Search for a regexp.  */
end_comment

begin_function
specifier|static
name|int
name|monitor_expect_regexp
parameter_list|(
name|struct
name|re_pattern_buffer
modifier|*
name|pat
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|buflen
parameter_list|)
block|{
name|char
modifier|*
name|mybuf
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|monitor_debug
argument_list|(
literal|"MON Expecting regexp\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
condition|)
name|mybuf
operator|=
name|buf
expr_stmt|;
else|else
block|{
name|mybuf
operator|=
name|alloca
argument_list|(
name|TARGET_BUF_SIZE
argument_list|)
expr_stmt|;
name|buflen
operator|=
name|TARGET_BUF_SIZE
expr_stmt|;
block|}
name|p
operator|=
name|mybuf
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|retval
decl_stmt|;
if|if
condition|(
name|p
operator|-
name|mybuf
operator|>=
name|buflen
condition|)
block|{
comment|/* Buffer about to overflow */
comment|/* On overflow, we copy the upper half of the buffer to the lower half.  Not    great, but it usually works... */
name|memcpy
argument_list|(
name|mybuf
argument_list|,
name|mybuf
operator|+
name|buflen
operator|/
literal|2
argument_list|,
name|buflen
operator|/
literal|2
argument_list|)
expr_stmt|;
name|p
operator|=
name|mybuf
operator|+
name|buflen
operator|/
literal|2
expr_stmt|;
block|}
operator|*
name|p
operator|++
operator|=
name|readchar
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
name|retval
operator|=
name|re_search
argument_list|(
name|pat
argument_list|,
name|mybuf
argument_list|,
name|p
operator|-
name|mybuf
argument_list|,
literal|0
argument_list|,
name|p
operator|-
name|mybuf
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|>=
literal|0
condition|)
return|return
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/* Keep discarding input until we see the MONITOR prompt.     The convention for dealing with the prompt is that you    o give your command    o *then* wait for the prompt.     Thus the last thing that a procedure does with the serial line will    be an monitor_expect_prompt().  Exception: monitor_resume does not    wait for the prompt, because the terminal is being handed over to    the inferior.  However, the next thing which happens after that is    a monitor_wait which does wait for the prompt.  Note that this    includes abnormal exit, e.g. error().  This is necessary to prevent    getting into states from which we can't recover.  */
end_comment

begin_function
name|int
name|monitor_expect_prompt
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|buflen
parameter_list|)
block|{
name|monitor_debug
argument_list|(
literal|"MON Expecting prompt\n"
argument_list|)
expr_stmt|;
return|return
name|monitor_expect
argument_list|(
name|current_monitor
operator|->
name|prompt
argument_list|,
name|buf
argument_list|,
name|buflen
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Get N 32-bit words from remote, each preceded by a space, and put    them in registers starting at REGNO.  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static unsigned long get_hex_word (void) {   unsigned long val;   int i;   int ch;    do     ch = readchar (timeout);   while (isspace (ch));    val = from_hex (ch);    for (i = 7; i>= 1; i--)     {       ch = readchar (timeout);       if (!isxdigit (ch)) 	break;       val = (val<< 4) | from_hex (ch);     }    return val; }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|compile_pattern
parameter_list|(
name|char
modifier|*
name|pattern
parameter_list|,
name|struct
name|re_pattern_buffer
modifier|*
name|compiled_pattern
parameter_list|,
name|char
modifier|*
name|fastmap
parameter_list|)
block|{
name|int
name|tmp
decl_stmt|;
specifier|const
name|char
modifier|*
name|val
decl_stmt|;
name|compiled_pattern
operator|->
name|fastmap
operator|=
name|fastmap
expr_stmt|;
name|tmp
operator|=
name|re_set_syntax
argument_list|(
name|RE_SYNTAX_EMACS
argument_list|)
expr_stmt|;
name|val
operator|=
name|re_compile_pattern
argument_list|(
name|pattern
argument_list|,
name|strlen
argument_list|(
name|pattern
argument_list|)
argument_list|,
name|compiled_pattern
argument_list|)
expr_stmt|;
name|re_set_syntax
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|)
name|error
argument_list|(
literal|"compile_pattern: Can't compile pattern string `%s': %s!"
argument_list|,
name|pattern
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|fastmap
condition|)
name|re_compile_fastmap
argument_list|(
name|compiled_pattern
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Open a connection to a remote debugger. NAME is the filename used    for communication.  */
end_comment

begin_function
name|void
name|monitor_open
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|struct
name|monitor_ops
modifier|*
name|mon_ops
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|mon_ops
operator|->
name|magic
operator|!=
name|MONITOR_OPS_MAGIC
condition|)
name|error
argument_list|(
literal|"Magic number of monitor_ops struct wrong."
argument_list|)
expr_stmt|;
name|targ_ops
operator|=
name|mon_ops
operator|->
name|target
expr_stmt|;
name|name
operator|=
name|targ_ops
operator|->
name|to_shortname
expr_stmt|;
if|if
condition|(
operator|!
name|args
condition|)
name|error
argument_list|(
literal|"Use `target %s DEVICE-NAME' to use a serial port, or \n\ `target %s HOST-NAME:PORT-NUMBER' to use a network connection."
argument_list|,
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|target_preopen
argument_list|(
name|from_tty
argument_list|)
expr_stmt|;
comment|/* Setup pattern for register dump */
if|if
condition|(
name|mon_ops
operator|->
name|register_pattern
condition|)
name|compile_pattern
argument_list|(
name|mon_ops
operator|->
name|register_pattern
argument_list|,
operator|&
name|register_pattern
argument_list|,
name|register_fastmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|mon_ops
operator|->
name|getmem
operator|.
name|resp_delim
condition|)
name|compile_pattern
argument_list|(
name|mon_ops
operator|->
name|getmem
operator|.
name|resp_delim
argument_list|,
operator|&
name|getmem_resp_delim_pattern
argument_list|,
name|getmem_resp_delim_fastmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|mon_ops
operator|->
name|setmem
operator|.
name|resp_delim
condition|)
name|compile_pattern
argument_list|(
name|mon_ops
operator|->
name|setmem
operator|.
name|resp_delim
argument_list|,
operator|&
name|setmem_resp_delim_pattern
argument_list|,
name|setmem_resp_delim_fastmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|mon_ops
operator|->
name|setreg
operator|.
name|resp_delim
condition|)
name|compile_pattern
argument_list|(
name|mon_ops
operator|->
name|setreg
operator|.
name|resp_delim
argument_list|,
operator|&
name|setreg_resp_delim_pattern
argument_list|,
name|setreg_resp_delim_fastmap
argument_list|)
expr_stmt|;
name|unpush_target
argument_list|(
name|targ_ops
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_name
condition|)
name|xfree
argument_list|(
name|dev_name
argument_list|)
expr_stmt|;
name|dev_name
operator|=
name|xstrdup
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|monitor_desc
operator|=
name|serial_open
argument_list|(
name|dev_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|monitor_desc
condition|)
name|perror_with_name
argument_list|(
name|dev_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|baud_rate
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|serial_setbaudrate
argument_list|(
name|monitor_desc
argument_list|,
name|baud_rate
argument_list|)
condition|)
block|{
name|serial_close
argument_list|(
name|monitor_desc
argument_list|)
expr_stmt|;
name|perror_with_name
argument_list|(
name|dev_name
argument_list|)
expr_stmt|;
block|}
block|}
name|serial_raw
argument_list|(
name|monitor_desc
argument_list|)
expr_stmt|;
name|serial_flush_input
argument_list|(
name|monitor_desc
argument_list|)
expr_stmt|;
comment|/* some systems only work with 2 stop bits */
name|serial_setstopbits
argument_list|(
name|monitor_desc
argument_list|,
name|mon_ops
operator|->
name|stopbits
argument_list|)
expr_stmt|;
name|current_monitor
operator|=
name|mon_ops
expr_stmt|;
comment|/* See if we can wake up the monitor.  First, try sending a stop sequence,      then send the init strings.  Last, remove all breakpoints.  */
if|if
condition|(
name|current_monitor
operator|->
name|stop
condition|)
block|{
name|monitor_stop
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|current_monitor
operator|->
name|flags
operator|&
name|MO_NO_ECHO_ON_OPEN
operator|)
operator|==
literal|0
condition|)
block|{
name|monitor_debug
argument_list|(
literal|"EXP Open echo\n"
argument_list|)
expr_stmt|;
name|monitor_expect_prompt
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* wake up the monitor and see if it's alive */
for|for
control|(
name|p
operator|=
name|mon_ops
operator|->
name|init
init|;
operator|*
name|p
operator|!=
name|NULL
condition|;
name|p
operator|++
control|)
block|{
comment|/* Some of the characters we send may not be echoed,          but we hope to get a prompt at the end of it all. */
if|if
condition|(
operator|(
name|current_monitor
operator|->
name|flags
operator|&
name|MO_NO_ECHO_ON_OPEN
operator|)
operator|==
literal|0
condition|)
name|monitor_printf
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
else|else
name|monitor_printf_noecho
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
name|monitor_expect_prompt
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|serial_flush_input
argument_list|(
name|monitor_desc
argument_list|)
expr_stmt|;
comment|/* Alloc breakpoints */
if|if
condition|(
name|mon_ops
operator|->
name|set_break
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|mon_ops
operator|->
name|num_breakpoints
operator|==
literal|0
condition|)
name|mon_ops
operator|->
name|num_breakpoints
operator|=
literal|8
expr_stmt|;
name|breakaddr
operator|=
operator|(
name|CORE_ADDR
operator|*
operator|)
name|xmalloc
argument_list|(
name|mon_ops
operator|->
name|num_breakpoints
operator|*
sizeof|sizeof
argument_list|(
name|CORE_ADDR
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|breakaddr
argument_list|,
literal|0
argument_list|,
name|mon_ops
operator|->
name|num_breakpoints
operator|*
sizeof|sizeof
argument_list|(
name|CORE_ADDR
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Remove all breakpoints */
if|if
condition|(
name|mon_ops
operator|->
name|clr_all_break
condition|)
block|{
name|monitor_printf
argument_list|(
name|mon_ops
operator|->
name|clr_all_break
argument_list|)
expr_stmt|;
name|monitor_expect_prompt
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|from_tty
condition|)
name|printf_unfiltered
argument_list|(
literal|"Remote target %s connected to %s\n"
argument_list|,
name|name
argument_list|,
name|dev_name
argument_list|)
expr_stmt|;
name|push_target
argument_list|(
name|targ_ops
argument_list|)
expr_stmt|;
name|inferior_ptid
operator|=
name|pid_to_ptid
argument_list|(
literal|42000
argument_list|)
expr_stmt|;
comment|/* Make run command think we are busy... */
comment|/* Give monitor_wait something to read */
name|monitor_printf
argument_list|(
name|current_monitor
operator|->
name|line_term
argument_list|)
expr_stmt|;
name|start_remote
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Close out all files and local state before this target loses    control.  */
end_comment

begin_function
name|void
name|monitor_close
parameter_list|(
name|int
name|quitting
parameter_list|)
block|{
if|if
condition|(
name|monitor_desc
condition|)
name|serial_close
argument_list|(
name|monitor_desc
argument_list|)
expr_stmt|;
comment|/* Free breakpoint memory */
if|if
condition|(
name|breakaddr
operator|!=
name|NULL
condition|)
block|{
name|xfree
argument_list|(
name|breakaddr
argument_list|)
expr_stmt|;
name|breakaddr
operator|=
name|NULL
expr_stmt|;
block|}
name|monitor_desc
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Terminate the open connection to the remote debugger.  Use this    when you want to detach and do something else with your gdb.  */
end_comment

begin_function
specifier|static
name|void
name|monitor_detach
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|pop_target
argument_list|()
expr_stmt|;
comment|/* calls monitor_close to do the real work */
if|if
condition|(
name|from_tty
condition|)
name|printf_unfiltered
argument_list|(
literal|"Ending remote %s debugging\n"
argument_list|,
name|target_shortname
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Convert VALSTR into the target byte-ordered value of REGNO and store it.  */
end_comment

begin_function
name|char
modifier|*
name|monitor_supply_register
parameter_list|(
name|int
name|regno
parameter_list|,
name|char
modifier|*
name|valstr
parameter_list|)
block|{
name|ULONGEST
name|val
decl_stmt|;
name|unsigned
name|char
name|regbuf
index|[
name|MAX_REGISTER_SIZE
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|valstr
expr_stmt|;
while|while
condition|(
name|p
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\r'
operator|||
operator|*
name|p
operator|==
literal|'\n'
condition|)
block|{
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
name|p
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|p
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|isxdigit
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
operator|*
name|p
operator|!=
literal|'x'
condition|)
block|{
break|break;
block|}
name|val
operator|<<=
literal|4
expr_stmt|;
name|val
operator|+=
name|fromhex
argument_list|(
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
block|}
name|monitor_debug
argument_list|(
literal|"Supplying Register %d %s\n"
argument_list|,
name|regno
argument_list|,
name|valstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
operator|&&
name|valstr
operator|==
name|p
condition|)
name|error
argument_list|(
literal|"monitor_supply_register (%d):  bad value from monitor: %s."
argument_list|,
name|regno
argument_list|,
name|valstr
argument_list|)
expr_stmt|;
comment|/* supply register stores in target byte order, so swap here */
name|store_unsigned_integer
argument_list|(
name|regbuf
argument_list|,
name|DEPRECATED_REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|regno
argument_list|,
name|regbuf
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Tell the remote machine to resume.  */
end_comment

begin_function
specifier|static
name|void
name|monitor_resume
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
name|int
name|step
parameter_list|,
name|enum
name|target_signal
name|sig
parameter_list|)
block|{
comment|/* Some monitors require a different command when starting a program */
name|monitor_debug
argument_list|(
literal|"MON resume\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_monitor
operator|->
name|flags
operator|&
name|MO_RUN_FIRST_TIME
operator|&&
name|first_time
operator|==
literal|1
condition|)
block|{
name|first_time
operator|=
literal|0
expr_stmt|;
name|monitor_printf
argument_list|(
literal|"run\r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_monitor
operator|->
name|flags
operator|&
name|MO_NEED_REGDUMP_AFTER_CONT
condition|)
name|dump_reg_flag
operator|=
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|step
condition|)
name|monitor_printf
argument_list|(
name|current_monitor
operator|->
name|step
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|current_monitor
operator|->
name|continue_hook
condition|)
call|(
modifier|*
name|current_monitor
operator|->
name|continue_hook
call|)
argument_list|()
expr_stmt|;
else|else
name|monitor_printf
argument_list|(
name|current_monitor
operator|->
name|cont
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_monitor
operator|->
name|flags
operator|&
name|MO_NEED_REGDUMP_AFTER_CONT
condition|)
name|dump_reg_flag
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Parse the output of a register dump command.  A monitor specific    regexp is used to extract individual register descriptions of the    form REG=VAL.  Each description is split up into a name and a value    string which are passed down to monitor specific code.  */
end_comment

begin_function
specifier|static
name|void
name|parse_register_dump
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|monitor_debug
argument_list|(
literal|"MON Parsing  register dump\n"
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|regnamelen
decl_stmt|,
name|vallen
decl_stmt|;
name|char
modifier|*
name|regname
decl_stmt|,
modifier|*
name|val
decl_stmt|;
comment|/* Element 0 points to start of register name, and element 1          points to the start of the register value.  */
name|struct
name|re_registers
name|register_strings
decl_stmt|;
name|memset
argument_list|(
operator|&
name|register_strings
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|re_registers
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|re_search
argument_list|(
operator|&
name|register_pattern
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
literal|0
argument_list|,
name|len
argument_list|,
operator|&
name|register_strings
argument_list|)
operator|==
operator|-
literal|1
condition|)
break|break;
name|regnamelen
operator|=
name|register_strings
operator|.
name|end
index|[
literal|1
index|]
operator|-
name|register_strings
operator|.
name|start
index|[
literal|1
index|]
expr_stmt|;
name|regname
operator|=
name|buf
operator|+
name|register_strings
operator|.
name|start
index|[
literal|1
index|]
expr_stmt|;
name|vallen
operator|=
name|register_strings
operator|.
name|end
index|[
literal|2
index|]
operator|-
name|register_strings
operator|.
name|start
index|[
literal|2
index|]
expr_stmt|;
name|val
operator|=
name|buf
operator|+
name|register_strings
operator|.
name|start
index|[
literal|2
index|]
expr_stmt|;
name|current_monitor
operator|->
name|supply_register
argument_list|(
name|regname
argument_list|,
name|regnamelen
argument_list|,
name|val
argument_list|,
name|vallen
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|register_strings
operator|.
name|end
index|[
literal|0
index|]
expr_stmt|;
name|len
operator|-=
name|register_strings
operator|.
name|end
index|[
literal|0
index|]
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Send ^C to target to halt it.  Target will respond, and send us a    packet.  */
end_comment

begin_function
specifier|static
name|void
name|monitor_interrupt
parameter_list|(
name|int
name|signo
parameter_list|)
block|{
comment|/* If this doesn't work, try more severe steps.  */
name|signal
argument_list|(
name|signo
argument_list|,
name|monitor_interrupt_twice
argument_list|)
expr_stmt|;
if|if
condition|(
name|monitor_debug_p
operator|||
name|remote_debug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"monitor_interrupt called\n"
argument_list|)
expr_stmt|;
name|target_stop
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The user typed ^C twice.  */
end_comment

begin_function
specifier|static
name|void
name|monitor_interrupt_twice
parameter_list|(
name|int
name|signo
parameter_list|)
block|{
name|signal
argument_list|(
name|signo
argument_list|,
name|ofunc
argument_list|)
expr_stmt|;
name|monitor_interrupt_query
argument_list|()
expr_stmt|;
name|signal
argument_list|(
name|signo
argument_list|,
name|monitor_interrupt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Ask the user what to do when an interrupt is received.  */
end_comment

begin_function
specifier|static
name|void
name|monitor_interrupt_query
parameter_list|(
name|void
parameter_list|)
block|{
name|target_terminal_ours
argument_list|()
expr_stmt|;
if|if
condition|(
name|query
argument_list|(
literal|"Interrupted while waiting for the program.\n\ Give up (and stop debugging it)? "
argument_list|)
condition|)
block|{
name|target_mourn_inferior
argument_list|()
expr_stmt|;
name|throw_exception
argument_list|(
name|RETURN_QUIT
argument_list|)
expr_stmt|;
block|}
name|target_terminal_inferior
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|monitor_wait_cleanup
parameter_list|(
name|void
modifier|*
name|old_timeout
parameter_list|)
block|{
name|timeout
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|old_timeout
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|ofunc
argument_list|)
expr_stmt|;
name|in_monitor_wait
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|monitor_wait_filter
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|bufmax
parameter_list|,
name|int
modifier|*
name|ext_resp_len
parameter_list|,
name|struct
name|target_waitstatus
modifier|*
name|status
parameter_list|)
block|{
name|int
name|resp_len
decl_stmt|;
do|do
block|{
name|resp_len
operator|=
name|monitor_expect_prompt
argument_list|(
name|buf
argument_list|,
name|bufmax
argument_list|)
expr_stmt|;
operator|*
name|ext_resp_len
operator|=
name|resp_len
expr_stmt|;
if|if
condition|(
name|resp_len
operator|<=
literal|0
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"monitor_wait:  excessive response from monitor: %s."
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|resp_len
operator|<
literal|0
condition|)
do|;
comment|/* Print any output characters that were preceded by ^O.  */
comment|/* FIXME - This would be great as a user settabgle flag */
if|if
condition|(
name|monitor_debug_p
operator|||
name|remote_debug
operator|||
name|current_monitor
operator|->
name|flags
operator|&
name|MO_PRINT_PROGRAM_OUTPUT
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|resp_len
operator|-
literal|1
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|buf
index|[
name|i
index|]
operator|==
literal|0x0f
condition|)
name|putchar_unfiltered
argument_list|(
name|buf
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Wait until the remote machine stops, then return, storing status in    status just as `wait' would.  */
end_comment

begin_function
specifier|static
name|ptid_t
name|monitor_wait
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
name|struct
name|target_waitstatus
modifier|*
name|status
parameter_list|)
block|{
name|int
name|old_timeout
init|=
name|timeout
decl_stmt|;
name|char
name|buf
index|[
name|TARGET_BUF_SIZE
index|]
decl_stmt|;
name|int
name|resp_len
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_EXITED
expr_stmt|;
name|status
operator|->
name|value
operator|.
name|integer
operator|=
literal|0
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|monitor_wait_cleanup
argument_list|,
operator|&
name|old_timeout
argument_list|)
expr_stmt|;
name|monitor_debug
argument_list|(
literal|"MON wait\n"
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* This is somthing other than a maintenance command */
block|in_monitor_wait = 1;   timeout = watchdog> 0 ? watchdog : -1;
else|#
directive|else
name|timeout
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Don't time out -- user program is running. */
endif|#
directive|endif
name|ofunc
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|monitor_interrupt
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_monitor
operator|->
name|wait_filter
condition|)
call|(
modifier|*
name|current_monitor
operator|->
name|wait_filter
call|)
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
operator|&
name|resp_len
argument_list|,
name|status
argument_list|)
expr_stmt|;
else|else
name|monitor_wait_filter
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
operator|&
name|resp_len
argument_list|,
name|status
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Transferred to monitor wait filter */
block|do     {       resp_len = monitor_expect_prompt (buf, sizeof (buf));        if (resp_len<= 0) 	fprintf_unfiltered (gdb_stderr, "monitor_wait:  excessive response from monitor: %s.", buf);     }   while (resp_len< 0);
comment|/* Print any output characters that were preceded by ^O.  */
comment|/* FIXME - This would be great as a user settabgle flag */
block|if (monitor_debug_p || remote_debug       || current_monitor->flags& MO_PRINT_PROGRAM_OUTPUT)     {       int i;        for (i = 0; i< resp_len - 1; i++) 	if (buf[i] == 0x0f) 	  putchar_unfiltered (buf[++i]);     }
endif|#
directive|endif
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|ofunc
argument_list|)
expr_stmt|;
name|timeout
operator|=
name|old_timeout
expr_stmt|;
if|#
directive|if
literal|0
block|if (dump_reg_flag&& current_monitor->dump_registers)     {       dump_reg_flag = 0;       monitor_printf (current_monitor->dump_registers);       resp_len = monitor_expect_prompt (buf, sizeof (buf));     }    if (current_monitor->register_pattern)     parse_register_dump (buf, resp_len);
else|#
directive|else
name|monitor_debug
argument_list|(
literal|"Wait fetching registers after stop\n"
argument_list|)
expr_stmt|;
name|monitor_dump_regs
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_STOPPED
expr_stmt|;
name|status
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_TRAP
expr_stmt|;
name|discard_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
name|in_monitor_wait
operator|=
literal|0
expr_stmt|;
return|return
name|inferior_ptid
return|;
block|}
end_function

begin_comment
comment|/* Fetch register REGNO, or all registers if REGNO is -1. Returns    errno value.  */
end_comment

begin_function
specifier|static
name|void
name|monitor_fetch_register
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|zerobuf
decl_stmt|;
name|char
modifier|*
name|regbuf
decl_stmt|;
name|int
name|i
decl_stmt|;
name|regbuf
operator|=
name|alloca
argument_list|(
name|MAX_REGISTER_SIZE
operator|*
literal|2
operator|+
literal|1
argument_list|)
expr_stmt|;
name|zerobuf
operator|=
name|alloca
argument_list|(
name|MAX_REGISTER_SIZE
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|zerobuf
argument_list|,
literal|0
argument_list|,
name|MAX_REGISTER_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_monitor
operator|->
name|regname
operator|!=
name|NULL
condition|)
name|name
operator|=
name|current_monitor
operator|->
name|regname
argument_list|(
name|regno
argument_list|)
expr_stmt|;
else|else
name|name
operator|=
name|current_monitor
operator|->
name|regnames
index|[
name|regno
index|]
expr_stmt|;
name|monitor_debug
argument_list|(
literal|"MON fetchreg %d '%s'\n"
argument_list|,
name|regno
argument_list|,
name|name
condition|?
name|name
else|:
literal|"(null name)"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|name
operator|||
operator|(
operator|*
name|name
operator|==
literal|'\0'
operator|)
condition|)
block|{
name|monitor_debug
argument_list|(
literal|"No register known for %d\n"
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|regno
argument_list|,
name|zerobuf
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* send the register examine command */
name|monitor_printf
argument_list|(
name|current_monitor
operator|->
name|getreg
operator|.
name|cmd
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* If RESP_DELIM is specified, we search for that as a leading      delimiter for the register value.  Otherwise, we just start      searching from the start of the buf.  */
if|if
condition|(
name|current_monitor
operator|->
name|getreg
operator|.
name|resp_delim
condition|)
block|{
name|monitor_debug
argument_list|(
literal|"EXP getreg.resp_delim\n"
argument_list|)
expr_stmt|;
name|monitor_expect
argument_list|(
name|current_monitor
operator|->
name|getreg
operator|.
name|resp_delim
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Handle case of first 32 registers listed in pairs.  */
if|if
condition|(
name|current_monitor
operator|->
name|flags
operator|&
name|MO_32_REGS_PAIRED
operator|&&
operator|(
name|regno
operator|&
literal|1
operator|)
operator|!=
literal|0
operator|&&
name|regno
operator|<
literal|32
condition|)
block|{
name|monitor_debug
argument_list|(
literal|"EXP getreg.resp_delim\n"
argument_list|)
expr_stmt|;
name|monitor_expect
argument_list|(
name|current_monitor
operator|->
name|getreg
operator|.
name|resp_delim
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Skip leading spaces and "0x" if MO_HEX_PREFIX flag is set */
if|if
condition|(
name|current_monitor
operator|->
name|flags
operator|&
name|MO_HEX_PREFIX
condition|)
block|{
name|int
name|c
decl_stmt|;
name|c
operator|=
name|readchar
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
while|while
condition|(
name|c
operator|==
literal|' '
condition|)
name|c
operator|=
name|readchar
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
literal|'0'
operator|)
operator|&&
operator|(
operator|(
name|c
operator|=
name|readchar
argument_list|(
name|timeout
argument_list|)
operator|)
operator|==
literal|'x'
operator|)
condition|)
empty_stmt|;
else|else
name|error
argument_list|(
literal|"Bad value returned from monitor while fetching register %x."
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
comment|/* Read upto the maximum number of hex digits for this register, skipping      spaces, but stop reading if something else is seen.  Some monitors      like to drop leading zeros.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DEPRECATED_REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
operator|*
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|int
name|c
decl_stmt|;
name|c
operator|=
name|readchar
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
while|while
condition|(
name|c
operator|==
literal|' '
condition|)
name|c
operator|=
name|readchar
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isxdigit
argument_list|(
name|c
argument_list|)
condition|)
break|break;
name|regbuf
index|[
name|i
index|]
operator|=
name|c
expr_stmt|;
block|}
name|regbuf
index|[
name|i
index|]
operator|=
literal|'\000'
expr_stmt|;
comment|/* terminate the number */
name|monitor_debug
argument_list|(
literal|"REGVAL '%s'\n"
argument_list|,
name|regbuf
argument_list|)
expr_stmt|;
comment|/* If TERM is present, we wait for that to show up.  Also, (if TERM      is present), we will send TERM_CMD if that is present.  In any      case, we collect all of the output into buf, and then wait for      the normal prompt.  */
if|if
condition|(
name|current_monitor
operator|->
name|getreg
operator|.
name|term
condition|)
block|{
name|monitor_debug
argument_list|(
literal|"EXP getreg.term\n"
argument_list|)
expr_stmt|;
name|monitor_expect
argument_list|(
name|current_monitor
operator|->
name|getreg
operator|.
name|term
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* get response */
block|}
if|if
condition|(
name|current_monitor
operator|->
name|getreg
operator|.
name|term_cmd
condition|)
block|{
name|monitor_debug
argument_list|(
literal|"EMIT getreg.term.cmd\n"
argument_list|)
expr_stmt|;
name|monitor_printf
argument_list|(
name|current_monitor
operator|->
name|getreg
operator|.
name|term_cmd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|current_monitor
operator|->
name|getreg
operator|.
name|term
operator|||
comment|/* Already expected or */
name|current_monitor
operator|->
name|getreg
operator|.
name|term_cmd
condition|)
comment|/* ack expected */
name|monitor_expect_prompt
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* get response */
name|monitor_supply_register
argument_list|(
name|regno
argument_list|,
name|regbuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Sometimes, it takes several commands to dump the registers */
end_comment

begin_comment
comment|/* This is a primitive for use by variations of monitor interfaces in    case they need to compose the operation.  */
end_comment

begin_function
name|int
name|monitor_dump_reg_block
parameter_list|(
name|char
modifier|*
name|block_cmd
parameter_list|)
block|{
name|char
name|buf
index|[
name|TARGET_BUF_SIZE
index|]
decl_stmt|;
name|int
name|resp_len
decl_stmt|;
name|monitor_printf
argument_list|(
name|block_cmd
argument_list|)
expr_stmt|;
name|resp_len
operator|=
name|monitor_expect_prompt
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|parse_register_dump
argument_list|(
name|buf
argument_list|,
name|resp_len
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Read the remote registers into the block regs.  */
end_comment

begin_comment
comment|/* Call the specific function if it has been provided */
end_comment

begin_function
specifier|static
name|void
name|monitor_dump_regs
parameter_list|(
name|void
parameter_list|)
block|{
name|char
name|buf
index|[
name|TARGET_BUF_SIZE
index|]
decl_stmt|;
name|int
name|resp_len
decl_stmt|;
if|if
condition|(
name|current_monitor
operator|->
name|dumpregs
condition|)
operator|(
operator|*
operator|(
name|current_monitor
operator|->
name|dumpregs
operator|)
operator|)
operator|(
operator|)
expr_stmt|;
comment|/* call supplied function */
elseif|else
if|if
condition|(
name|current_monitor
operator|->
name|dump_registers
condition|)
comment|/* default version */
block|{
name|monitor_printf
argument_list|(
name|current_monitor
operator|->
name|dump_registers
argument_list|)
expr_stmt|;
name|resp_len
operator|=
name|monitor_expect_prompt
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|parse_register_dump
argument_list|(
name|buf
argument_list|,
name|resp_len
argument_list|)
expr_stmt|;
block|}
else|else
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"failed internal consistency check"
argument_list|)
expr_stmt|;
comment|/* Need some way to read registers */
block|}
end_function

begin_function
specifier|static
name|void
name|monitor_fetch_registers
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
name|monitor_debug
argument_list|(
literal|"MON fetchregs\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_monitor
operator|->
name|getreg
operator|.
name|cmd
condition|)
block|{
if|if
condition|(
name|regno
operator|>=
literal|0
condition|)
block|{
name|monitor_fetch_register
argument_list|(
name|regno
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|NUM_REGS
condition|;
name|regno
operator|++
control|)
name|monitor_fetch_register
argument_list|(
name|regno
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|monitor_dump_regs
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Store register REGNO, or all if REGNO == 0.  Return errno value.  */
end_comment

begin_function
specifier|static
name|void
name|monitor_store_register
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|ULONGEST
name|val
decl_stmt|;
if|if
condition|(
name|current_monitor
operator|->
name|regname
operator|!=
name|NULL
condition|)
name|name
operator|=
name|current_monitor
operator|->
name|regname
argument_list|(
name|regno
argument_list|)
expr_stmt|;
else|else
name|name
operator|=
name|current_monitor
operator|->
name|regnames
index|[
name|regno
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|name
operator|||
operator|(
operator|*
name|name
operator|==
literal|'\0'
operator|)
condition|)
block|{
name|monitor_debug
argument_list|(
literal|"MON Cannot store unknown register\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|val
operator|=
name|read_register
argument_list|(
name|regno
argument_list|)
expr_stmt|;
name|monitor_debug
argument_list|(
literal|"MON storeg %d %s\n"
argument_list|,
name|regno
argument_list|,
name|phex
argument_list|(
name|val
argument_list|,
name|DEPRECATED_REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* send the register deposit command */
if|if
condition|(
name|current_monitor
operator|->
name|flags
operator|&
name|MO_REGISTER_VALUE_FIRST
condition|)
name|monitor_printf
argument_list|(
name|current_monitor
operator|->
name|setreg
operator|.
name|cmd
argument_list|,
name|val
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|current_monitor
operator|->
name|flags
operator|&
name|MO_SETREG_INTERACTIVE
condition|)
name|monitor_printf
argument_list|(
name|current_monitor
operator|->
name|setreg
operator|.
name|cmd
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|monitor_printf
argument_list|(
name|current_monitor
operator|->
name|setreg
operator|.
name|cmd
argument_list|,
name|name
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_monitor
operator|->
name|setreg
operator|.
name|resp_delim
condition|)
block|{
name|monitor_debug
argument_list|(
literal|"EXP setreg.resp_delim\n"
argument_list|)
expr_stmt|;
name|monitor_expect_regexp
argument_list|(
operator|&
name|setreg_resp_delim_pattern
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_monitor
operator|->
name|flags
operator|&
name|MO_SETREG_INTERACTIVE
condition|)
name|monitor_printf
argument_list|(
literal|"%s\r"
argument_list|,
name|paddr_nz
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|current_monitor
operator|->
name|setreg
operator|.
name|term
condition|)
block|{
name|monitor_debug
argument_list|(
literal|"EXP setreg.term\n"
argument_list|)
expr_stmt|;
name|monitor_expect
argument_list|(
name|current_monitor
operator|->
name|setreg
operator|.
name|term
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_monitor
operator|->
name|flags
operator|&
name|MO_SETREG_INTERACTIVE
condition|)
name|monitor_printf
argument_list|(
literal|"%s\r"
argument_list|,
name|paddr_nz
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
name|monitor_expect_prompt
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|monitor_expect_prompt
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_monitor
operator|->
name|setreg
operator|.
name|term_cmd
condition|)
comment|/* Mode exit required */
block|{
name|monitor_debug
argument_list|(
literal|"EXP setreg_termcmd\n"
argument_list|)
expr_stmt|;
name|monitor_printf
argument_list|(
literal|"%s"
argument_list|,
name|current_monitor
operator|->
name|setreg
operator|.
name|term_cmd
argument_list|)
expr_stmt|;
name|monitor_expect_prompt
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* monitor_store_register */
end_comment

begin_comment
comment|/* Store the remote registers.  */
end_comment

begin_function
specifier|static
name|void
name|monitor_store_registers
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
if|if
condition|(
name|regno
operator|>=
literal|0
condition|)
block|{
name|monitor_store_register
argument_list|(
name|regno
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|NUM_REGS
condition|;
name|regno
operator|++
control|)
name|monitor_store_register
argument_list|(
name|regno
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get ready to modify the registers array.  On machines which store    individual registers, this doesn't need to do anything.  On machines    which store all the registers in one fell swoop, this makes sure    that registers contains all the registers from the program being    debugged.  */
end_comment

begin_function
specifier|static
name|void
name|monitor_prepare_to_store
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Do nothing, since we can store individual regs */
block|}
end_function

begin_function
specifier|static
name|void
name|monitor_files_info
parameter_list|(
name|struct
name|target_ops
modifier|*
name|ops
parameter_list|)
block|{
name|printf_unfiltered
argument_list|(
literal|"\tAttached to %s at %d baud.\n"
argument_list|,
name|dev_name
argument_list|,
name|baud_rate
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|monitor_write_memory
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|unsigned
name|int
name|val
decl_stmt|,
name|hostval
decl_stmt|;
name|char
modifier|*
name|cmd
decl_stmt|;
name|int
name|i
decl_stmt|;
name|monitor_debug
argument_list|(
literal|"MON write %d %s\n"
argument_list|,
name|len
argument_list|,
name|paddr
argument_list|(
name|memaddr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_monitor
operator|->
name|flags
operator|&
name|MO_ADDR_BITS_REMOVE
condition|)
name|memaddr
operator|=
name|ADDR_BITS_REMOVE
argument_list|(
name|memaddr
argument_list|)
expr_stmt|;
comment|/* Use memory fill command for leading 0 bytes.  */
if|if
condition|(
name|current_monitor
operator|->
name|fill
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|myaddr
index|[
name|i
index|]
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|i
operator|>
literal|4
condition|)
comment|/* More than 4 zeros is worth doing */
block|{
name|monitor_debug
argument_list|(
literal|"MON FILL %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_monitor
operator|->
name|flags
operator|&
name|MO_FILL_USES_ADDR
condition|)
name|monitor_printf
argument_list|(
name|current_monitor
operator|->
name|fill
argument_list|,
name|memaddr
argument_list|,
operator|(
name|memaddr
operator|+
name|i
operator|)
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|monitor_printf
argument_list|(
name|current_monitor
operator|->
name|fill
argument_list|,
name|memaddr
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|monitor_expect_prompt
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|i
return|;
block|}
block|}
if|#
directive|if
literal|0
comment|/* Can't actually use long longs if VAL is an int (nice idea, though).  */
block|if ((memaddr& 0x7) == 0&& len>= 8&& current_monitor->setmem.cmdll)     {       len = 8;       cmd = current_monitor->setmem.cmdll;     }   else
endif|#
directive|endif
if|if
condition|(
operator|(
name|memaddr
operator|&
literal|0x3
operator|)
operator|==
literal|0
operator|&&
name|len
operator|>=
literal|4
operator|&&
name|current_monitor
operator|->
name|setmem
operator|.
name|cmdl
condition|)
block|{
name|len
operator|=
literal|4
expr_stmt|;
name|cmd
operator|=
name|current_monitor
operator|->
name|setmem
operator|.
name|cmdl
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|memaddr
operator|&
literal|0x1
operator|)
operator|==
literal|0
operator|&&
name|len
operator|>=
literal|2
operator|&&
name|current_monitor
operator|->
name|setmem
operator|.
name|cmdw
condition|)
block|{
name|len
operator|=
literal|2
expr_stmt|;
name|cmd
operator|=
name|current_monitor
operator|->
name|setmem
operator|.
name|cmdw
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
literal|1
expr_stmt|;
name|cmd
operator|=
name|current_monitor
operator|->
name|setmem
operator|.
name|cmdb
expr_stmt|;
block|}
name|val
operator|=
name|extract_unsigned_integer
argument_list|(
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|4
condition|)
block|{
name|hostval
operator|=
operator|*
operator|(
name|unsigned
name|int
operator|*
operator|)
name|myaddr
expr_stmt|;
name|monitor_debug
argument_list|(
literal|"Hostval(%08x) val(%08x)\n"
argument_list|,
name|hostval
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|current_monitor
operator|->
name|flags
operator|&
name|MO_NO_ECHO_ON_SETMEM
condition|)
name|monitor_printf_noecho
argument_list|(
name|cmd
argument_list|,
name|memaddr
argument_list|,
name|val
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|current_monitor
operator|->
name|flags
operator|&
name|MO_SETMEM_INTERACTIVE
condition|)
block|{
name|monitor_printf_noecho
argument_list|(
name|cmd
argument_list|,
name|memaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_monitor
operator|->
name|setmem
operator|.
name|resp_delim
condition|)
block|{
name|monitor_debug
argument_list|(
literal|"EXP setmem.resp_delim"
argument_list|)
expr_stmt|;
name|monitor_expect_regexp
argument_list|(
operator|&
name|setmem_resp_delim_pattern
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|monitor_printf
argument_list|(
literal|"%x\r"
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|current_monitor
operator|->
name|setmem
operator|.
name|term
condition|)
block|{
name|monitor_debug
argument_list|(
literal|"EXP setmem.term"
argument_list|)
expr_stmt|;
name|monitor_expect
argument_list|(
name|current_monitor
operator|->
name|setmem
operator|.
name|term
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|monitor_printf
argument_list|(
literal|"%x\r"
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|current_monitor
operator|->
name|setmem
operator|.
name|term_cmd
condition|)
block|{
comment|/* Emit this to get out of the memory editing state */
name|monitor_printf
argument_list|(
literal|"%s"
argument_list|,
name|current_monitor
operator|->
name|setmem
operator|.
name|term_cmd
argument_list|)
expr_stmt|;
comment|/* Drop through to expecting a prompt */
block|}
block|}
else|else
name|monitor_printf
argument_list|(
name|cmd
argument_list|,
name|memaddr
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|monitor_expect_prompt
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|len
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|monitor_write_memory_bytes
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|unsigned
name|char
name|val
decl_stmt|;
name|int
name|written
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Enter the sub mode */
name|monitor_printf
argument_list|(
name|current_monitor
operator|->
name|setmem
operator|.
name|cmdb
argument_list|,
name|memaddr
argument_list|)
expr_stmt|;
name|monitor_expect_prompt
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
condition|)
block|{
name|val
operator|=
operator|*
name|myaddr
expr_stmt|;
name|monitor_printf
argument_list|(
literal|"%x\r"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|myaddr
operator|++
expr_stmt|;
name|memaddr
operator|++
expr_stmt|;
name|written
operator|++
expr_stmt|;
comment|/* If we wanted to, here we could validate the address */
name|monitor_expect_prompt
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|len
operator|--
expr_stmt|;
block|}
comment|/* Now exit the sub mode */
name|monitor_printf
argument_list|(
name|current_monitor
operator|->
name|getreg
operator|.
name|term_cmd
argument_list|)
expr_stmt|;
name|monitor_expect_prompt
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|written
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|longlongendswap
parameter_list|(
name|unsigned
name|char
modifier|*
name|a
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|unsigned
name|char
name|x
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|j
operator|=
literal|7
expr_stmt|;
while|while
condition|(
name|i
operator|<
literal|4
condition|)
block|{
name|x
operator|=
operator|*
operator|(
name|a
operator|+
name|i
operator|)
expr_stmt|;
operator|*
operator|(
name|a
operator|+
name|i
operator|)
operator|=
operator|*
operator|(
name|a
operator|+
name|j
operator|)
expr_stmt|;
operator|*
operator|(
name|a
operator|+
name|j
operator|)
operator|=
name|x
expr_stmt|;
name|i
operator|++
operator|,
name|j
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Format 32 chars of long long value, advance the pointer */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|hexlate
init|=
literal|"0123456789abcdef"
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|char
modifier|*
name|longlong_hexchars
parameter_list|(
name|unsigned
name|long
name|long
name|value
parameter_list|,
name|char
modifier|*
name|outbuff
parameter_list|)
block|{
if|if
condition|(
name|value
operator|==
literal|0
condition|)
block|{
operator|*
name|outbuff
operator|++
operator|=
literal|'0'
expr_stmt|;
return|return
name|outbuff
return|;
block|}
else|else
block|{
specifier|static
name|unsigned
name|char
name|disbuf
index|[
literal|8
index|]
decl_stmt|;
comment|/* disassembly buffer */
name|unsigned
name|char
modifier|*
name|scan
decl_stmt|,
modifier|*
name|limit
decl_stmt|;
comment|/* loop controls */
name|unsigned
name|char
name|c
decl_stmt|,
name|nib
decl_stmt|;
name|int
name|leadzero
init|=
literal|1
decl_stmt|;
name|scan
operator|=
name|disbuf
expr_stmt|;
name|limit
operator|=
name|scan
operator|+
literal|8
expr_stmt|;
block|{
name|unsigned
name|long
name|long
modifier|*
name|dp
decl_stmt|;
name|dp
operator|=
operator|(
name|unsigned
name|long
name|long
operator|*
operator|)
name|scan
expr_stmt|;
operator|*
name|dp
operator|=
name|value
expr_stmt|;
block|}
name|longlongendswap
argument_list|(
name|disbuf
argument_list|)
expr_stmt|;
comment|/* FIXME: ONly on big endian hosts */
while|while
condition|(
name|scan
operator|<
name|limit
condition|)
block|{
name|c
operator|=
operator|*
name|scan
operator|++
expr_stmt|;
comment|/* a byte of our long long value */
if|if
condition|(
name|leadzero
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|0
condition|)
continue|continue;
else|else
name|leadzero
operator|=
literal|0
expr_stmt|;
comment|/* henceforth we print even zeroes */
block|}
name|nib
operator|=
name|c
operator|>>
literal|4
expr_stmt|;
comment|/* high nibble bits */
operator|*
name|outbuff
operator|++
operator|=
name|hexlate
index|[
name|nib
index|]
expr_stmt|;
name|nib
operator|=
name|c
operator|&
literal|0x0f
expr_stmt|;
comment|/* low nibble bits */
operator|*
name|outbuff
operator|++
operator|=
name|hexlate
index|[
name|nib
index|]
expr_stmt|;
block|}
return|return
name|outbuff
return|;
block|}
block|}
end_function

begin_comment
comment|/* longlong_hexchars */
end_comment

begin_comment
comment|/* I am only going to call this when writing virtual byte streams.    Which possably entails endian conversions  */
end_comment

begin_function
specifier|static
name|int
name|monitor_write_memory_longlongs
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
specifier|static
name|char
name|hexstage
index|[
literal|20
index|]
decl_stmt|;
comment|/* At least 16 digits required, plus null */
name|char
modifier|*
name|endstring
decl_stmt|;
name|long
name|long
modifier|*
name|llptr
decl_stmt|;
name|long
name|long
name|value
decl_stmt|;
name|int
name|written
init|=
literal|0
decl_stmt|;
name|llptr
operator|=
operator|(
name|unsigned
name|long
name|long
operator|*
operator|)
name|myaddr
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|monitor_printf
argument_list|(
name|current_monitor
operator|->
name|setmem
operator|.
name|cmdll
argument_list|,
name|memaddr
argument_list|)
expr_stmt|;
name|monitor_expect_prompt
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|>=
literal|8
condition|)
block|{
name|value
operator|=
operator|*
name|llptr
expr_stmt|;
name|endstring
operator|=
name|longlong_hexchars
argument_list|(
operator|*
name|llptr
argument_list|,
name|hexstage
argument_list|)
expr_stmt|;
operator|*
name|endstring
operator|=
literal|'\0'
expr_stmt|;
comment|/* NUll terminate for printf */
name|monitor_printf
argument_list|(
literal|"%s\r"
argument_list|,
name|hexstage
argument_list|)
expr_stmt|;
name|llptr
operator|++
expr_stmt|;
name|memaddr
operator|+=
literal|8
expr_stmt|;
name|written
operator|+=
literal|8
expr_stmt|;
comment|/* If we wanted to, here we could validate the address */
name|monitor_expect_prompt
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|len
operator|-=
literal|8
expr_stmt|;
block|}
comment|/* Now exit the sub mode */
name|monitor_printf
argument_list|(
name|current_monitor
operator|->
name|getreg
operator|.
name|term_cmd
argument_list|)
expr_stmt|;
name|monitor_expect_prompt
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|written
return|;
block|}
end_function

begin_comment
comment|/* */
end_comment

begin_comment
comment|/* ----- MONITOR_WRITE_MEMORY_BLOCK ---------------------------- */
end_comment

begin_comment
comment|/* This is for the large blocks of memory which may occur in downloading.    And for monitors which use interactive entry,    And for monitors which do not have other downloading methods.    Without this, we will end up calling monitor_write_memory many times    and do the entry and exit of the sub mode many times    This currently assumes...    MO_SETMEM_INTERACTIVE    ! MO_NO_ECHO_ON_SETMEM    To use this, the you have to patch the monitor_cmds block with    this function. Otherwise, its not tuned up for use by all    monitor variations.  */
end_comment

begin_function
specifier|static
name|int
name|monitor_write_memory_block
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|written
decl_stmt|;
name|written
operator|=
literal|0
expr_stmt|;
comment|/* FIXME: This would be a good place to put the zero test */
if|#
directive|if
literal|1
if|if
condition|(
operator|(
name|len
operator|>
literal|8
operator|)
operator|&&
operator|(
operator|(
operator|(
name|len
operator|&
literal|0x07
operator|)
operator|)
operator|==
literal|0
operator|)
operator|&&
name|current_monitor
operator|->
name|setmem
operator|.
name|cmdll
condition|)
block|{
return|return
name|monitor_write_memory_longlongs
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
return|;
block|}
endif|#
directive|endif
name|written
operator|=
name|monitor_write_memory_bytes
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|written
return|;
block|}
end_function

begin_comment
comment|/* This is an alternate form of monitor_read_memory which is used for monitors    which can only read a single byte/word/etc. at a time.  */
end_comment

begin_function
specifier|static
name|int
name|monitor_read_memory_single
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|unsigned
name|int
name|val
decl_stmt|;
name|char
name|membuf
index|[
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
literal|2
operator|+
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|cmd
decl_stmt|;
name|monitor_debug
argument_list|(
literal|"MON read single\n"
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Can't actually use long longs (nice idea, though).  In fact, the      call to strtoul below will fail if it tries to convert a value      that's too big to fit in a long.  */
block|if ((memaddr& 0x7) == 0&& len>= 8&& current_monitor->getmem.cmdll)     {       len = 8;       cmd = current_monitor->getmem.cmdll;     }   else
endif|#
directive|endif
if|if
condition|(
operator|(
name|memaddr
operator|&
literal|0x3
operator|)
operator|==
literal|0
operator|&&
name|len
operator|>=
literal|4
operator|&&
name|current_monitor
operator|->
name|getmem
operator|.
name|cmdl
condition|)
block|{
name|len
operator|=
literal|4
expr_stmt|;
name|cmd
operator|=
name|current_monitor
operator|->
name|getmem
operator|.
name|cmdl
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|memaddr
operator|&
literal|0x1
operator|)
operator|==
literal|0
operator|&&
name|len
operator|>=
literal|2
operator|&&
name|current_monitor
operator|->
name|getmem
operator|.
name|cmdw
condition|)
block|{
name|len
operator|=
literal|2
expr_stmt|;
name|cmd
operator|=
name|current_monitor
operator|->
name|getmem
operator|.
name|cmdw
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
literal|1
expr_stmt|;
name|cmd
operator|=
name|current_monitor
operator|->
name|getmem
operator|.
name|cmdb
expr_stmt|;
block|}
comment|/* Send the examine command.  */
name|monitor_printf
argument_list|(
name|cmd
argument_list|,
name|memaddr
argument_list|)
expr_stmt|;
comment|/* If RESP_DELIM is specified, we search for that as a leading      delimiter for the memory value.  Otherwise, we just start      searching from the start of the buf.  */
if|if
condition|(
name|current_monitor
operator|->
name|getmem
operator|.
name|resp_delim
condition|)
block|{
name|monitor_debug
argument_list|(
literal|"EXP getmem.resp_delim\n"
argument_list|)
expr_stmt|;
name|monitor_expect_regexp
argument_list|(
operator|&
name|getmem_resp_delim_pattern
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Now, read the appropriate number of hex digits for this loc,      skipping spaces.  */
comment|/* Skip leading spaces and "0x" if MO_HEX_PREFIX flag is set. */
if|if
condition|(
name|current_monitor
operator|->
name|flags
operator|&
name|MO_HEX_PREFIX
condition|)
block|{
name|int
name|c
decl_stmt|;
name|c
operator|=
name|readchar
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
while|while
condition|(
name|c
operator|==
literal|' '
condition|)
name|c
operator|=
name|readchar
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
literal|'0'
operator|)
operator|&&
operator|(
operator|(
name|c
operator|=
name|readchar
argument_list|(
name|timeout
argument_list|)
operator|)
operator|==
literal|'x'
operator|)
condition|)
empty_stmt|;
else|else
name|monitor_error
argument_list|(
literal|"monitor_read_memory_single"
argument_list|,
literal|"bad response from monitor"
argument_list|,
name|memaddr
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
operator|*
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|int
name|c
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|c
operator|=
name|readchar
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|isxdigit
argument_list|(
name|c
argument_list|)
condition|)
break|break;
if|if
condition|(
name|c
operator|==
literal|' '
condition|)
continue|continue;
name|monitor_error
argument_list|(
literal|"monitor_read_memory_single"
argument_list|,
literal|"bad response from monitor"
argument_list|,
name|memaddr
argument_list|,
name|i
argument_list|,
name|membuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|membuf
index|[
name|i
index|]
operator|=
name|c
expr_stmt|;
block|}
name|membuf
index|[
name|i
index|]
operator|=
literal|'\000'
expr_stmt|;
comment|/* terminate the number */
block|}
comment|/* If TERM is present, we wait for that to show up.  Also, (if TERM is    present), we will send TERM_CMD if that is present.  In any case, we collect    all of the output into buf, and then wait for the normal prompt.  */
if|if
condition|(
name|current_monitor
operator|->
name|getmem
operator|.
name|term
condition|)
block|{
name|monitor_expect
argument_list|(
name|current_monitor
operator|->
name|getmem
operator|.
name|term
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* get response */
if|if
condition|(
name|current_monitor
operator|->
name|getmem
operator|.
name|term_cmd
condition|)
block|{
name|monitor_printf
argument_list|(
name|current_monitor
operator|->
name|getmem
operator|.
name|term_cmd
argument_list|)
expr_stmt|;
name|monitor_expect_prompt
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|monitor_expect_prompt
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* get response */
name|p
operator|=
name|membuf
expr_stmt|;
name|val
operator|=
name|strtoul
argument_list|(
name|membuf
argument_list|,
operator|&
name|p
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
operator|&&
name|membuf
operator|==
name|p
condition|)
name|monitor_error
argument_list|(
literal|"monitor_read_memory_single"
argument_list|,
literal|"bad value from monitor"
argument_list|,
name|memaddr
argument_list|,
literal|0
argument_list|,
name|membuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* supply register stores in target byte order, so swap here */
name|store_unsigned_integer
argument_list|(
name|myaddr
argument_list|,
name|len
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
name|len
return|;
block|}
end_function

begin_comment
comment|/* Copy LEN bytes of data from debugger memory at MYADDR to inferior's    memory at MEMADDR.  Returns length moved.  Currently, we do no more    than 16 bytes at a time.  */
end_comment

begin_function
specifier|static
name|int
name|monitor_read_memory
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|unsigned
name|int
name|val
decl_stmt|;
name|char
name|buf
index|[
literal|512
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|p1
decl_stmt|;
name|int
name|resp_len
decl_stmt|;
name|int
name|i
decl_stmt|;
name|CORE_ADDR
name|dumpaddr
decl_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
block|{
name|monitor_debug
argument_list|(
literal|"Zero length call to monitor_read_memory\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|monitor_debug
argument_list|(
literal|"MON read block ta(%s) ha(%lx) %d\n"
argument_list|,
name|paddr_nz
argument_list|(
name|memaddr
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_monitor
operator|->
name|flags
operator|&
name|MO_ADDR_BITS_REMOVE
condition|)
name|memaddr
operator|=
name|ADDR_BITS_REMOVE
argument_list|(
name|memaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_monitor
operator|->
name|flags
operator|&
name|MO_GETMEM_READ_SINGLE
condition|)
return|return
name|monitor_read_memory_single
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
return|;
name|len
operator|=
name|min
argument_list|(
name|len
argument_list|,
literal|16
argument_list|)
expr_stmt|;
comment|/* Some dumpers align the first data with the preceeding 16      byte boundary. Some print blanks and start at the      requested boundary. EXACT_DUMPADDR    */
name|dumpaddr
operator|=
operator|(
name|current_monitor
operator|->
name|flags
operator|&
name|MO_EXACT_DUMPADDR
operator|)
condition|?
name|memaddr
else|:
name|memaddr
operator|&
operator|~
literal|0x0f
expr_stmt|;
comment|/* See if xfer would cross a 16 byte boundary.  If so, clip it.  */
if|if
condition|(
operator|(
operator|(
name|memaddr
operator|^
operator|(
name|memaddr
operator|+
name|len
operator|-
literal|1
operator|)
operator|)
operator|&
operator|~
literal|0xf
operator|)
operator|!=
literal|0
condition|)
name|len
operator|=
operator|(
operator|(
name|memaddr
operator|+
name|len
operator|)
operator|&
operator|~
literal|0xf
operator|)
operator|-
name|memaddr
expr_stmt|;
comment|/* send the memory examine command */
if|if
condition|(
name|current_monitor
operator|->
name|flags
operator|&
name|MO_GETMEM_NEEDS_RANGE
condition|)
name|monitor_printf
argument_list|(
name|current_monitor
operator|->
name|getmem
operator|.
name|cmdb
argument_list|,
name|memaddr
argument_list|,
name|memaddr
operator|+
name|len
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|current_monitor
operator|->
name|flags
operator|&
name|MO_GETMEM_16_BOUNDARY
condition|)
name|monitor_printf
argument_list|(
name|current_monitor
operator|->
name|getmem
operator|.
name|cmdb
argument_list|,
name|dumpaddr
argument_list|)
expr_stmt|;
else|else
name|monitor_printf
argument_list|(
name|current_monitor
operator|->
name|getmem
operator|.
name|cmdb
argument_list|,
name|memaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* If TERM is present, we wait for that to show up.  Also, (if TERM      is present), we will send TERM_CMD if that is present.  In any      case, we collect all of the output into buf, and then wait for      the normal prompt.  */
if|if
condition|(
name|current_monitor
operator|->
name|getmem
operator|.
name|term
condition|)
block|{
name|resp_len
operator|=
name|monitor_expect
argument_list|(
name|current_monitor
operator|->
name|getmem
operator|.
name|term
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
expr_stmt|;
comment|/* get response */
if|if
condition|(
name|resp_len
operator|<=
literal|0
condition|)
name|monitor_error
argument_list|(
literal|"monitor_read_memory"
argument_list|,
literal|"excessive response from monitor"
argument_list|,
name|memaddr
argument_list|,
name|resp_len
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_monitor
operator|->
name|getmem
operator|.
name|term_cmd
condition|)
block|{
name|serial_write
argument_list|(
name|monitor_desc
argument_list|,
name|current_monitor
operator|->
name|getmem
operator|.
name|term_cmd
argument_list|,
name|strlen
argument_list|(
name|current_monitor
operator|->
name|getmem
operator|.
name|term_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|monitor_expect_prompt
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|resp_len
operator|=
name|monitor_expect_prompt
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
expr_stmt|;
comment|/* get response */
name|p
operator|=
name|buf
expr_stmt|;
comment|/* If RESP_DELIM is specified, we search for that as a leading      delimiter for the values.  Otherwise, we just start searching      from the start of the buf.  */
if|if
condition|(
name|current_monitor
operator|->
name|getmem
operator|.
name|resp_delim
condition|)
block|{
name|int
name|retval
decl_stmt|,
name|tmp
decl_stmt|;
name|struct
name|re_registers
name|resp_strings
decl_stmt|;
name|monitor_debug
argument_list|(
literal|"MON getmem.resp_delim %s\n"
argument_list|,
name|current_monitor
operator|->
name|getmem
operator|.
name|resp_delim
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|resp_strings
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|re_registers
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|retval
operator|=
name|re_search
argument_list|(
operator|&
name|getmem_resp_delim_pattern
argument_list|,
name|p
argument_list|,
name|tmp
argument_list|,
literal|0
argument_list|,
name|tmp
argument_list|,
operator|&
name|resp_strings
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|<
literal|0
condition|)
name|monitor_error
argument_list|(
literal|"monitor_read_memory"
argument_list|,
literal|"bad response from monitor"
argument_list|,
name|memaddr
argument_list|,
name|resp_len
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
operator|+=
name|resp_strings
operator|.
name|end
index|[
literal|0
index|]
expr_stmt|;
if|#
directive|if
literal|0
block|p = strstr (p, current_monitor->getmem.resp_delim);       if (!p) 	monitor_error ("monitor_read_memory", 		       "bad response from monitor", 		       memaddr, resp_len, buf, 0);       p += strlen (current_monitor->getmem.resp_delim);
endif|#
directive|endif
block|}
name|monitor_debug
argument_list|(
literal|"MON scanning  %d ,%lx '%s'\n"
argument_list|,
name|len
argument_list|,
operator|(
name|long
operator|)
name|p
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_monitor
operator|->
name|flags
operator|&
name|MO_GETMEM_16_BOUNDARY
condition|)
block|{
name|char
name|c
decl_stmt|;
name|int
name|fetched
init|=
literal|0
decl_stmt|;
name|i
operator|=
name|len
expr_stmt|;
name|c
operator|=
operator|*
name|p
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|c
operator|==
literal|'\000'
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|'\r'
operator|)
operator|&&
name|i
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|isxdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|dumpaddr
operator|>=
name|memaddr
operator|)
operator|&&
operator|(
name|i
operator|>
literal|0
operator|)
condition|)
block|{
name|val
operator|=
name|fromhex
argument_list|(
name|c
argument_list|)
operator|*
literal|16
operator|+
name|fromhex
argument_list|(
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
operator|*
name|myaddr
operator|++
operator|=
name|val
expr_stmt|;
if|if
condition|(
name|monitor_debug_p
operator|||
name|remote_debug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"[%02x]"
argument_list|,
name|val
argument_list|)
expr_stmt|;
operator|--
name|i
expr_stmt|;
name|fetched
operator|++
expr_stmt|;
block|}
operator|++
name|dumpaddr
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
operator|++
name|p
expr_stmt|;
comment|/* skip a blank or other non hex char */
name|c
operator|=
operator|*
name|p
expr_stmt|;
block|}
if|if
condition|(
name|fetched
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Failed to read via monitor"
argument_list|)
expr_stmt|;
if|if
condition|(
name|monitor_debug_p
operator|||
name|remote_debug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
return|return
name|fetched
return|;
comment|/* Return the number of bytes actually read */
block|}
name|monitor_debug
argument_list|(
literal|"MON scanning bytes\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|len
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
comment|/* Skip non-hex chars, but bomb on end of string and newlines */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|isxdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\000'
operator|||
operator|*
name|p
operator|==
literal|'\n'
operator|||
operator|*
name|p
operator|==
literal|'\r'
condition|)
name|monitor_error
argument_list|(
literal|"monitor_read_memory"
argument_list|,
literal|"badly terminated response from monitor"
argument_list|,
name|memaddr
argument_list|,
name|resp_len
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
name|val
operator|=
name|strtoul
argument_list|(
name|p
argument_list|,
operator|&
name|p1
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
operator|&&
name|p
operator|==
name|p1
condition|)
name|monitor_error
argument_list|(
literal|"monitor_read_memory"
argument_list|,
literal|"bad value from monitor"
argument_list|,
name|memaddr
argument_list|,
name|resp_len
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|myaddr
operator|++
operator|=
name|val
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|1
condition|)
break|break;
name|p
operator|=
name|p1
expr_stmt|;
block|}
return|return
name|len
return|;
block|}
end_function

begin_comment
comment|/* Transfer LEN bytes between target address MEMADDR and GDB address    MYADDR.  Returns 0 for success, errno code for failure. TARGET is    unused. */
end_comment

begin_function
specifier|static
name|int
name|monitor_xfer_memory
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|write
parameter_list|,
name|struct
name|mem_attrib
modifier|*
name|attrib
parameter_list|,
name|struct
name|target_ops
modifier|*
name|target
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
if|if
condition|(
name|write
condition|)
block|{
if|if
condition|(
name|current_monitor
operator|->
name|flags
operator|&
name|MO_HAS_BLOCKWRITES
condition|)
name|res
operator|=
name|monitor_write_memory_block
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|else
name|res
operator|=
name|monitor_write_memory
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|res
operator|=
name|monitor_read_memory
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|monitor_kill
parameter_list|(
name|void
parameter_list|)
block|{
return|return;
comment|/* ignore attempts to kill target system */
block|}
end_function

begin_comment
comment|/* All we actually do is set the PC to the start address of exec_bfd, and start    the program at that point.  */
end_comment

begin_function
specifier|static
name|void
name|monitor_create_inferior
parameter_list|(
name|char
modifier|*
name|exec_file
parameter_list|,
name|char
modifier|*
name|args
parameter_list|,
name|char
modifier|*
modifier|*
name|env
parameter_list|)
block|{
if|if
condition|(
name|args
operator|&&
operator|(
operator|*
name|args
operator|!=
literal|'\000'
operator|)
condition|)
name|error
argument_list|(
literal|"Args are not supported by the monitor."
argument_list|)
expr_stmt|;
name|first_time
operator|=
literal|1
expr_stmt|;
name|clear_proceed_status
argument_list|()
expr_stmt|;
name|proceed
argument_list|(
name|bfd_get_start_address
argument_list|(
name|exec_bfd
argument_list|)
argument_list|,
name|TARGET_SIGNAL_0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clean up when a program exits.    The program actually lives on in the remote processor's RAM, and may be    run again without a download.  Don't leave it full of breakpoint    instructions.  */
end_comment

begin_function
specifier|static
name|void
name|monitor_mourn_inferior
parameter_list|(
name|void
parameter_list|)
block|{
name|unpush_target
argument_list|(
name|targ_ops
argument_list|)
expr_stmt|;
name|generic_mourn_inferior
argument_list|()
expr_stmt|;
comment|/* Do all the proper things now */
block|}
end_function

begin_comment
comment|/* Tell the monitor to add a breakpoint.  */
end_comment

begin_function
specifier|static
name|int
name|monitor_insert_breakpoint
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|char
modifier|*
name|shadow
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|bp
decl_stmt|;
name|int
name|bplen
decl_stmt|;
name|monitor_debug
argument_list|(
literal|"MON inst bkpt %s\n"
argument_list|,
name|paddr
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_monitor
operator|->
name|set_break
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"No set_break defined for this monitor"
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_monitor
operator|->
name|flags
operator|&
name|MO_ADDR_BITS_REMOVE
condition|)
name|addr
operator|=
name|ADDR_BITS_REMOVE
argument_list|(
name|addr
argument_list|)
expr_stmt|;
comment|/* Determine appropriate breakpoint size for this address.  */
name|bp
operator|=
name|gdbarch_breakpoint_from_pc
argument_list|(
name|current_gdbarch
argument_list|,
operator|&
name|addr
argument_list|,
operator|&
name|bplen
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|current_monitor
operator|->
name|num_breakpoints
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|breakaddr
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|breakaddr
index|[
name|i
index|]
operator|=
name|addr
expr_stmt|;
name|monitor_read_memory
argument_list|(
name|addr
argument_list|,
name|shadow
argument_list|,
name|bplen
argument_list|)
expr_stmt|;
name|monitor_printf
argument_list|(
name|current_monitor
operator|->
name|set_break
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|monitor_expect_prompt
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|error
argument_list|(
literal|"Too many breakpoints (> %d) for monitor."
argument_list|,
name|current_monitor
operator|->
name|num_breakpoints
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Tell the monitor to remove a breakpoint.  */
end_comment

begin_function
specifier|static
name|int
name|monitor_remove_breakpoint
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|char
modifier|*
name|shadow
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|monitor_debug
argument_list|(
literal|"MON rmbkpt %s\n"
argument_list|,
name|paddr
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_monitor
operator|->
name|clr_break
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"No clr_break defined for this monitor"
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_monitor
operator|->
name|flags
operator|&
name|MO_ADDR_BITS_REMOVE
condition|)
name|addr
operator|=
name|ADDR_BITS_REMOVE
argument_list|(
name|addr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|current_monitor
operator|->
name|num_breakpoints
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|breakaddr
index|[
name|i
index|]
operator|==
name|addr
condition|)
block|{
name|breakaddr
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|/* some monitors remove breakpoints based on the address */
if|if
condition|(
name|current_monitor
operator|->
name|flags
operator|&
name|MO_CLR_BREAK_USES_ADDR
condition|)
name|monitor_printf
argument_list|(
name|current_monitor
operator|->
name|clr_break
argument_list|,
name|addr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|current_monitor
operator|->
name|flags
operator|&
name|MO_CLR_BREAK_1_BASED
condition|)
name|monitor_printf
argument_list|(
name|current_monitor
operator|->
name|clr_break
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|monitor_printf
argument_list|(
name|current_monitor
operator|->
name|clr_break
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|monitor_expect_prompt
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Can't find breakpoint associated with 0x%s\n"
argument_list|,
name|paddr_nz
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* monitor_wait_srec_ack -- wait for the target to send an acknowledgement for    an S-record.  Return non-zero if the ACK is received properly.  */
end_comment

begin_function
specifier|static
name|int
name|monitor_wait_srec_ack
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|ch
decl_stmt|;
if|if
condition|(
name|current_monitor
operator|->
name|flags
operator|&
name|MO_SREC_ACK_PLUS
condition|)
block|{
return|return
operator|(
name|readchar
argument_list|(
name|timeout
argument_list|)
operator|==
literal|'+'
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|current_monitor
operator|->
name|flags
operator|&
name|MO_SREC_ACK_ROTATE
condition|)
block|{
comment|/* Eat two backspaces, a "rotating" char (|/-\), and a space.  */
if|if
condition|(
operator|(
name|ch
operator|=
name|readchar
argument_list|(
literal|1
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|ch
operator|=
name|readchar
argument_list|(
literal|1
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|ch
operator|=
name|readchar
argument_list|(
literal|1
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|ch
operator|=
name|readchar
argument_list|(
literal|1
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* monitor_load -- download a file. */
end_comment

begin_function
specifier|static
name|void
name|monitor_load
parameter_list|(
name|char
modifier|*
name|file
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|monitor_debug
argument_list|(
literal|"MON load\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_monitor
operator|->
name|load_routine
condition|)
name|current_monitor
operator|->
name|load_routine
argument_list|(
name|monitor_desc
argument_list|,
name|file
argument_list|,
name|hashmark
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* The default is ascii S-records */
name|int
name|n
decl_stmt|;
name|unsigned
name|long
name|load_offset
decl_stmt|;
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
comment|/* enable user to specify address for downloading as 2nd arg to load */
name|n
operator|=
name|sscanf
argument_list|(
name|file
argument_list|,
literal|"%s 0x%lx"
argument_list|,
name|buf
argument_list|,
operator|&
name|load_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|1
condition|)
name|file
operator|=
name|buf
expr_stmt|;
else|else
name|load_offset
operator|=
literal|0
expr_stmt|;
name|monitor_printf
argument_list|(
name|current_monitor
operator|->
name|load
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_monitor
operator|->
name|loadresp
condition|)
name|monitor_expect
argument_list|(
name|current_monitor
operator|->
name|loadresp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|load_srec
argument_list|(
name|monitor_desc
argument_list|,
name|file
argument_list|,
operator|(
name|bfd_vma
operator|)
name|load_offset
argument_list|,
literal|32
argument_list|,
name|SREC_ALL
argument_list|,
name|hashmark
argument_list|,
name|current_monitor
operator|->
name|flags
operator|&
name|MO_SREC_ACK
condition|?
name|monitor_wait_srec_ack
else|:
name|NULL
argument_list|)
expr_stmt|;
name|monitor_expect_prompt
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Finally, make the PC point at the start address */
if|if
condition|(
name|exec_bfd
condition|)
name|write_pc
argument_list|(
name|bfd_get_start_address
argument_list|(
name|exec_bfd
argument_list|)
argument_list|)
expr_stmt|;
comment|/* There used to be code here which would clear inferior_ptid and      call clear_symtab_users.  None of that should be necessary:      monitor targets should behave like remote protocol targets, and      since generic_load does none of those things, this function      shouldn't either.       Furthermore, clearing inferior_ptid is *incorrect*.  After doing      a load, we still have a valid connection to the monitor, with a      live processor state to fiddle with.  The user can type      `continue' or `jump *start' and make the program run.  If they do      these things, however, GDB will be talking to a running program      while inferior_ptid is null_ptid; this makes things like      reinit_frame_cache very confused.  */
block|}
end_function

begin_function
specifier|static
name|void
name|monitor_stop
parameter_list|(
name|void
parameter_list|)
block|{
name|monitor_debug
argument_list|(
literal|"MON stop\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|current_monitor
operator|->
name|flags
operator|&
name|MO_SEND_BREAK_ON_STOP
operator|)
operator|!=
literal|0
condition|)
name|serial_send_break
argument_list|(
name|monitor_desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_monitor
operator|->
name|stop
condition|)
name|monitor_printf_noecho
argument_list|(
name|current_monitor
operator|->
name|stop
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Put a COMMAND string out to MONITOR.  Output from MONITOR is placed    in OUTPUT until the prompt is seen. FIXME: We read the characters    ourseleves here cause of a nasty echo.  */
end_comment

begin_function
specifier|static
name|void
name|monitor_rcmd
parameter_list|(
name|char
modifier|*
name|command
parameter_list|,
name|struct
name|ui_file
modifier|*
name|outbuf
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|resp_len
decl_stmt|;
name|char
name|buf
index|[
literal|1000
index|]
decl_stmt|;
if|if
condition|(
name|monitor_desc
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"monitor target not open."
argument_list|)
expr_stmt|;
name|p
operator|=
name|current_monitor
operator|->
name|prompt
expr_stmt|;
comment|/* Send the command.  Note that if no args were supplied, then we're      just sending the monitor a newline, which is sometimes useful.  */
name|monitor_printf
argument_list|(
literal|"%s\r"
argument_list|,
operator|(
name|command
condition|?
name|command
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
name|resp_len
operator|=
name|monitor_expect_prompt
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
name|buf
argument_list|,
name|outbuf
argument_list|)
expr_stmt|;
comment|/* Output the response */
block|}
end_function

begin_comment
comment|/* Convert hex digit A to a number.  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static int from_hex (int a) {   if (a>= '0'&& a<= '9')     return a - '0';   if (a>= 'a'&& a<= 'f')     return a - 'a' + 10;   if (a>= 'A'&& a<= 'F')     return a - 'A' + 10;    error ("Reply contains invalid hex digit 0x%x", a); }
endif|#
directive|endif
end_endif

begin_function
name|char
modifier|*
name|monitor_get_dev_name
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|dev_name
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|target_ops
name|monitor_ops
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|init_base_monitor_ops
parameter_list|(
name|void
parameter_list|)
block|{
name|monitor_ops
operator|.
name|to_close
operator|=
name|monitor_close
expr_stmt|;
name|monitor_ops
operator|.
name|to_detach
operator|=
name|monitor_detach
expr_stmt|;
name|monitor_ops
operator|.
name|to_resume
operator|=
name|monitor_resume
expr_stmt|;
name|monitor_ops
operator|.
name|to_wait
operator|=
name|monitor_wait
expr_stmt|;
name|monitor_ops
operator|.
name|to_fetch_registers
operator|=
name|monitor_fetch_registers
expr_stmt|;
name|monitor_ops
operator|.
name|to_store_registers
operator|=
name|monitor_store_registers
expr_stmt|;
name|monitor_ops
operator|.
name|to_prepare_to_store
operator|=
name|monitor_prepare_to_store
expr_stmt|;
name|monitor_ops
operator|.
name|to_xfer_memory
operator|=
name|monitor_xfer_memory
expr_stmt|;
name|monitor_ops
operator|.
name|to_files_info
operator|=
name|monitor_files_info
expr_stmt|;
name|monitor_ops
operator|.
name|to_insert_breakpoint
operator|=
name|monitor_insert_breakpoint
expr_stmt|;
name|monitor_ops
operator|.
name|to_remove_breakpoint
operator|=
name|monitor_remove_breakpoint
expr_stmt|;
name|monitor_ops
operator|.
name|to_kill
operator|=
name|monitor_kill
expr_stmt|;
name|monitor_ops
operator|.
name|to_load
operator|=
name|monitor_load
expr_stmt|;
name|monitor_ops
operator|.
name|to_create_inferior
operator|=
name|monitor_create_inferior
expr_stmt|;
name|monitor_ops
operator|.
name|to_mourn_inferior
operator|=
name|monitor_mourn_inferior
expr_stmt|;
name|monitor_ops
operator|.
name|to_stop
operator|=
name|monitor_stop
expr_stmt|;
name|monitor_ops
operator|.
name|to_rcmd
operator|=
name|monitor_rcmd
expr_stmt|;
name|monitor_ops
operator|.
name|to_stratum
operator|=
name|process_stratum
expr_stmt|;
name|monitor_ops
operator|.
name|to_has_all_memory
operator|=
literal|1
expr_stmt|;
name|monitor_ops
operator|.
name|to_has_memory
operator|=
literal|1
expr_stmt|;
name|monitor_ops
operator|.
name|to_has_stack
operator|=
literal|1
expr_stmt|;
name|monitor_ops
operator|.
name|to_has_registers
operator|=
literal|1
expr_stmt|;
name|monitor_ops
operator|.
name|to_has_execution
operator|=
literal|1
expr_stmt|;
name|monitor_ops
operator|.
name|to_magic
operator|=
name|OPS_MAGIC
expr_stmt|;
block|}
end_function

begin_comment
comment|/* init_base_monitor_ops */
end_comment

begin_comment
comment|/* Init the target_ops structure pointed at by OPS */
end_comment

begin_function
name|void
name|init_monitor_ops
parameter_list|(
name|struct
name|target_ops
modifier|*
name|ops
parameter_list|)
block|{
if|if
condition|(
name|monitor_ops
operator|.
name|to_magic
operator|!=
name|OPS_MAGIC
condition|)
name|init_base_monitor_ops
argument_list|()
expr_stmt|;
name|memcpy
argument_list|(
name|ops
argument_list|,
operator|&
name|monitor_ops
argument_list|,
sizeof|sizeof
name|monitor_ops
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Define additional commands that are usually only used by monitors.  */
end_comment

begin_decl_stmt
specifier|extern
name|initialize_file_ftype
name|_initialize_remote_monitors
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -Wmissing-prototypes */
end_comment

begin_function
name|void
name|_initialize_remote_monitors
parameter_list|(
name|void
parameter_list|)
block|{
name|init_base_monitor_ops
argument_list|()
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"hash"
argument_list|,
name|no_class
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|hashmark
argument_list|,
literal|"Set display of activity while downloading a file.\n\ When enabled, a hashmark \'#\' is displayed."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"monitor"
argument_list|,
name|no_class
argument_list|,
name|var_zinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|monitor_debug_p
argument_list|,
literal|"Set debugging of remote monitor communication.\n\ When enabled, communication between GDB and the remote monitor\n\ is displayed."
argument_list|,
operator|&
name|setdebuglist
argument_list|)
argument_list|,
operator|&
name|showdebuglist
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

