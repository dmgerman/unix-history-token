begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Remote debugging interface for Tandem ST2000 phone switch, for GDB.     Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1998, 1999, 2000,    2001, 2002 Free Software Foundation, Inc.     Contributed by Cygnus Support.  Written by Jim Kingdon for Cygnus.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This file was derived from remote-eb.c, which did a similar job, but for    an AMD-29K running EBMON.  That file was in turn derived from remote.c    as mentioned in the following comment (left in for comic relief):     "This is like remote.c but is for an esoteric situation--    having an a29k board in a PC hooked up to a unix machine with    a serial line, and running ctty com1 on the PC, through which    the unix machine can run ebmon.  Not to mention that the PC    has PC/NFS, so it can access the same executables that gdb can,    over the net in real time."     In reality, this module talks to a debug monitor called 'STDEBUG', which    runs in a phone switch.  We communicate with STDEBUG via either a direct    serial line, or a TCP (or possibly TELNET) stream to a terminal multiplexor,    which in turn talks to the phone switch. */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|"serial.h"
end_include

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_decl_stmt
specifier|extern
name|struct
name|target_ops
name|st2000_ops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward declaration */
end_comment

begin_function_decl
specifier|static
name|void
name|st2000_close
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|st2000_fetch_register
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|st2000_store_register
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|LOG_FILE
value|"st2000.log"
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|LOG_FILE
argument_list|)
end_if

begin_decl_stmt
name|FILE
modifier|*
name|log_file
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|timeout
init|=
literal|24
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Descriptor for I/O to remote machine.  Initialize it to -1 so that    st2000_open knows that we don't have a file open when the program    starts.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|serial
modifier|*
name|st2000_desc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Send data to stdebug.  Works just like printf. */
end_comment

begin_function
specifier|static
name|void
name|printf_stdebug
parameter_list|(
name|char
modifier|*
name|pattern
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|char
name|buf
index|[
literal|200
index|]
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|pattern
argument_list|)
expr_stmt|;
name|vsprintf
argument_list|(
name|buf
argument_list|,
name|pattern
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|serial_write
argument_list|(
name|st2000_desc
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"serial_write failed: %s\n"
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read a character from the remote system, doing all the fancy timeout    stuff.  */
end_comment

begin_function
specifier|static
name|int
name|readchar
parameter_list|(
name|int
name|timeout
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|c
operator|=
name|serial_readchar
argument_list|(
name|st2000_desc
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG_FILE
name|putc
argument_list|(
name|c
operator|&
literal|0x7f
argument_list|,
name|log_file
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|c
operator|>=
literal|0
condition|)
return|return
name|c
operator|&
literal|0x7f
return|;
if|if
condition|(
name|c
operator|==
name|SERIAL_TIMEOUT
condition|)
block|{
if|if
condition|(
name|timeout
operator|==
literal|0
condition|)
return|return
name|c
return|;
comment|/* Polls shouldn't generate timeout errors */
name|error
argument_list|(
literal|"Timeout reading from remote system."
argument_list|)
expr_stmt|;
block|}
name|perror_with_name
argument_list|(
literal|"remote-st2000"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Scan input from the remote system, until STRING is found.  If DISCARD is    non-zero, then discard non-matching input, else print it out.    Let the user break out immediately.  */
end_comment

begin_function
specifier|static
name|void
name|expect
parameter_list|(
name|char
modifier|*
name|string
parameter_list|,
name|int
name|discard
parameter_list|)
block|{
name|char
modifier|*
name|p
init|=
name|string
decl_stmt|;
name|int
name|c
decl_stmt|;
name|immediate_quit
operator|++
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|c
operator|=
name|readchar
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
operator|*
name|p
operator|++
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
name|immediate_quit
operator|--
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|discard
condition|)
block|{
name|fwrite
argument_list|(
name|string
argument_list|,
literal|1
argument_list|,
operator|(
name|p
operator|-
literal|1
operator|)
operator|-
name|string
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|string
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Keep discarding input until we see the STDEBUG prompt.     The convention for dealing with the prompt is that you    o give your command    o *then* wait for the prompt.     Thus the last thing that a procedure does with the serial line    will be an expect_prompt().  Exception:  st2000_resume does not    wait for the prompt, because the terminal is being handed over    to the inferior.  However, the next thing which happens after that    is a st2000_wait which does wait for the prompt.    Note that this includes abnormal exit, e.g. error().  This is    necessary to prevent getting into states from which we can't    recover.  */
end_comment

begin_function
specifier|static
name|void
name|expect_prompt
parameter_list|(
name|int
name|discard
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|LOG_FILE
argument_list|)
comment|/* This is a convenient place to do this.  The idea is to do it often      enough that we never lose much data if we terminate abnormally.  */
name|fflush
argument_list|(
name|log_file
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|expect
argument_list|(
literal|"dbug> "
argument_list|,
name|discard
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get a hex digit from the remote system& return its value.    If ignore_space is nonzero, ignore spaces (not newline, tab, etc).  */
end_comment

begin_function
specifier|static
name|int
name|get_hex_digit
parameter_list|(
name|int
name|ignore_space
parameter_list|)
block|{
name|int
name|ch
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|ch
operator|=
name|readchar
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|>=
literal|'0'
operator|&&
name|ch
operator|<=
literal|'9'
condition|)
return|return
name|ch
operator|-
literal|'0'
return|;
elseif|else
if|if
condition|(
name|ch
operator|>=
literal|'A'
operator|&&
name|ch
operator|<=
literal|'F'
condition|)
return|return
name|ch
operator|-
literal|'A'
operator|+
literal|10
return|;
elseif|else
if|if
condition|(
name|ch
operator|>=
literal|'a'
operator|&&
name|ch
operator|<=
literal|'f'
condition|)
return|return
name|ch
operator|-
literal|'a'
operator|+
literal|10
return|;
elseif|else
if|if
condition|(
name|ch
operator|==
literal|' '
operator|&&
name|ignore_space
condition|)
empty_stmt|;
else|else
block|{
name|expect_prompt
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Invalid hex digit from remote system."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Get a byte from stdebug and put it in *BYT.  Accept any number    leading spaces.  */
end_comment

begin_function
specifier|static
name|void
name|get_hex_byte
parameter_list|(
name|char
modifier|*
name|byt
parameter_list|)
block|{
name|int
name|val
decl_stmt|;
name|val
operator|=
name|get_hex_digit
argument_list|(
literal|1
argument_list|)
operator|<<
literal|4
expr_stmt|;
name|val
operator||=
name|get_hex_digit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|*
name|byt
operator|=
name|val
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get N 32-bit words from remote, each preceded by a space,    and put them in registers starting at REGNO.  */
end_comment

begin_function
specifier|static
name|void
name|get_hex_regs
parameter_list|(
name|int
name|n
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
name|long
name|val
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
decl_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|8
condition|;
name|j
operator|++
control|)
name|val
operator|=
operator|(
name|val
operator|<<
literal|4
operator|)
operator|+
name|get_hex_digit
argument_list|(
name|j
operator|==
literal|0
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|regno
operator|++
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|val
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This is called not only when we first attach, but also when the    user types "run" after having attached.  */
end_comment

begin_function
specifier|static
name|void
name|st2000_create_inferior
parameter_list|(
name|char
modifier|*
name|execfile
parameter_list|,
name|char
modifier|*
name|args
parameter_list|,
name|char
modifier|*
modifier|*
name|env
parameter_list|)
block|{
name|int
name|entry_pt
decl_stmt|;
if|if
condition|(
name|args
operator|&&
operator|*
name|args
condition|)
name|error
argument_list|(
literal|"Can't pass arguments to remote STDEBUG process"
argument_list|)
expr_stmt|;
if|if
condition|(
name|execfile
operator|==
literal|0
operator|||
name|exec_bfd
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No executable file specified"
argument_list|)
expr_stmt|;
name|entry_pt
operator|=
operator|(
name|int
operator|)
name|bfd_get_start_address
argument_list|(
name|exec_bfd
argument_list|)
expr_stmt|;
comment|/* The "process" (board) is already stopped awaiting our commands, and    the program is already downloaded.  We just set its PC and go.  */
name|clear_proceed_status
argument_list|()
expr_stmt|;
comment|/* Tell wait_for_inferior that we've started a new process.  */
name|init_wait_for_inferior
argument_list|()
expr_stmt|;
comment|/* Set up the "saved terminal modes" of the inferior      based on what modes we are starting it with.  */
name|target_terminal_init
argument_list|()
expr_stmt|;
comment|/* Install inferior's terminal modes.  */
name|target_terminal_inferior
argument_list|()
expr_stmt|;
comment|/* insert_step_breakpoint ();  FIXME, do we need this?  */
comment|/* Let 'er rip... */
name|proceed
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|entry_pt
argument_list|,
name|TARGET_SIGNAL_DEFAULT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Open a connection to a remote debugger.    NAME is the filename used for communication.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|baudrate
init|=
literal|9600
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|dev_name
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|st2000_open
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
name|char
name|junk
index|[
literal|100
index|]
decl_stmt|;
name|target_preopen
argument_list|(
name|from_tty
argument_list|)
expr_stmt|;
name|n
operator|=
name|sscanf
argument_list|(
name|args
argument_list|,
literal|" %s %d %s"
argument_list|,
name|dev_name
argument_list|,
operator|&
name|baudrate
argument_list|,
name|junk
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
literal|2
condition|)
name|error
argument_list|(
literal|"Bad arguments.  Usage: target st2000<device><speed>\n\ or target st2000<host><port>\n"
argument_list|)
expr_stmt|;
name|st2000_close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|st2000_desc
operator|=
name|serial_open
argument_list|(
name|dev_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|st2000_desc
condition|)
name|perror_with_name
argument_list|(
name|dev_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|serial_setbaudrate
argument_list|(
name|st2000_desc
argument_list|,
name|baudrate
argument_list|)
condition|)
block|{
name|serial_close
argument_list|(
name|dev_name
argument_list|)
expr_stmt|;
name|perror_with_name
argument_list|(
name|dev_name
argument_list|)
expr_stmt|;
block|}
name|serial_raw
argument_list|(
name|st2000_desc
argument_list|)
expr_stmt|;
name|push_target
argument_list|(
operator|&
name|st2000_ops
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|LOG_FILE
argument_list|)
name|log_file
operator|=
name|fopen
argument_list|(
name|LOG_FILE
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|log_file
operator|==
name|NULL
condition|)
name|perror_with_name
argument_list|(
name|LOG_FILE
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Hello?  Are you there?  */
name|printf_stdebug
argument_list|(
literal|"\003"
argument_list|)
expr_stmt|;
comment|/* ^C wakes up dbug */
name|expect_prompt
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
name|printf
argument_list|(
literal|"Remote %s connected to %s\n"
argument_list|,
name|target_shortname
argument_list|,
name|dev_name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Close out all files and local state before this target loses control. */
end_comment

begin_function
specifier|static
name|void
name|st2000_close
parameter_list|(
name|int
name|quitting
parameter_list|)
block|{
name|serial_close
argument_list|(
name|st2000_desc
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|LOG_FILE
argument_list|)
if|if
condition|(
name|log_file
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|log_file
argument_list|)
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Error writing log file.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|log_file
argument_list|)
operator|!=
literal|0
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Error closing log file.\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Terminate the open connection to the remote debugger.    Use this when you want to detach and do something else    with your gdb.  */
end_comment

begin_function
specifier|static
name|void
name|st2000_detach
parameter_list|(
name|int
name|from_tty
parameter_list|)
block|{
name|pop_target
argument_list|()
expr_stmt|;
comment|/* calls st2000_close to do the real work */
if|if
condition|(
name|from_tty
condition|)
name|printf
argument_list|(
literal|"Ending remote %s debugging\n"
argument_list|,
name|target_shortname
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Tell the remote machine to resume.  */
end_comment

begin_function
specifier|static
name|void
name|st2000_resume
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
name|int
name|step
parameter_list|,
name|enum
name|target_signal
name|sig
parameter_list|)
block|{
if|if
condition|(
name|step
condition|)
block|{
name|printf_stdebug
argument_list|(
literal|"ST\r"
argument_list|)
expr_stmt|;
comment|/* Wait for the echo.  */
name|expect
argument_list|(
literal|"ST\r"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf_stdebug
argument_list|(
literal|"GO\r"
argument_list|)
expr_stmt|;
comment|/* Swallow the echo.  */
name|expect
argument_list|(
literal|"GO\r"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Wait until the remote machine stops, then return,    storing status in STATUS just as `wait' would.  */
end_comment

begin_function
specifier|static
name|ptid_t
name|st2000_wait
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
name|struct
name|target_waitstatus
modifier|*
name|status
parameter_list|)
block|{
name|int
name|old_timeout
init|=
name|timeout
decl_stmt|;
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_EXITED
expr_stmt|;
name|status
operator|->
name|value
operator|.
name|integer
operator|=
literal|0
expr_stmt|;
name|timeout
operator|=
literal|0
expr_stmt|;
comment|/* Don't time out -- user program is running. */
name|expect_prompt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Wait for prompt, outputting extraneous text */
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_STOPPED
expr_stmt|;
name|status
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_TRAP
expr_stmt|;
name|timeout
operator|=
name|old_timeout
expr_stmt|;
return|return
name|inferior_ptid
return|;
block|}
end_function

begin_comment
comment|/* Return the name of register number REGNO in the form input and    output by STDEBUG.  Currently, REGISTER_NAME just happens return    exactly what STDEBUG wants.  Lets take advantage of that just as    long as possible! */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|get_reg_name
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
specifier|static
name|char
name|buf
index|[
literal|50
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|b
decl_stmt|;
name|b
operator|=
name|buf
expr_stmt|;
for|for
control|(
name|p
operator|=
name|REGISTER_NAME
argument_list|(
name|regno
argument_list|)
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
operator|*
name|b
operator|++
operator|=
name|toupper
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
operator|*
name|b
operator|=
literal|'\000'
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/* Read the remote registers into the block REGS.  */
end_comment

begin_function
specifier|static
name|void
name|st2000_fetch_registers
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|regno
decl_stmt|;
comment|/* Yeah yeah, I know this is horribly inefficient.  But it isn't done      very often...  I'll clean it up later.  */
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<=
name|PC_REGNUM
condition|;
name|regno
operator|++
control|)
name|st2000_fetch_register
argument_list|(
name|regno
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fetch register REGNO, or all registers if REGNO is -1.    Returns errno value.  */
end_comment

begin_function
specifier|static
name|void
name|st2000_fetch_register
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
if|if
condition|(
name|regno
operator|==
operator|-
literal|1
condition|)
name|st2000_fetch_registers
argument_list|()
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|name
init|=
name|get_reg_name
argument_list|(
name|regno
argument_list|)
decl_stmt|;
name|printf_stdebug
argument_list|(
literal|"DR %s\r"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|expect
argument_list|(
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|expect
argument_list|(
literal|" : "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|get_hex_regs
argument_list|(
literal|1
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|expect_prompt
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* Store the remote registers from the contents of the block REGS.  */
end_comment

begin_function
specifier|static
name|void
name|st2000_store_registers
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|regno
decl_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<=
name|PC_REGNUM
condition|;
name|regno
operator|++
control|)
name|st2000_store_register
argument_list|(
name|regno
argument_list|)
expr_stmt|;
name|registers_changed
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Store register REGNO, or all if REGNO == 0.    Return errno value.  */
end_comment

begin_function
specifier|static
name|void
name|st2000_store_register
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
if|if
condition|(
name|regno
operator|==
operator|-
literal|1
condition|)
name|st2000_store_registers
argument_list|()
expr_stmt|;
else|else
block|{
name|printf_stdebug
argument_list|(
literal|"PR %s %x\r"
argument_list|,
name|get_reg_name
argument_list|(
name|regno
argument_list|)
argument_list|,
name|read_register
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
name|expect_prompt
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Get ready to modify the registers array.  On machines which store    individual registers, this doesn't need to do anything.  On machines    which store all the registers in one fell swoop, this makes sure    that registers contains all the registers from the program being    debugged.  */
end_comment

begin_function
specifier|static
name|void
name|st2000_prepare_to_store
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Do nothing, since we can store individual regs */
block|}
end_function

begin_function
specifier|static
name|void
name|st2000_files_info
parameter_list|(
name|void
parameter_list|)
block|{
name|printf
argument_list|(
literal|"\tAttached to %s at %d baud.\n"
argument_list|,
name|dev_name
argument_list|,
name|baudrate
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy LEN bytes of data from debugger memory at MYADDR    to inferior's memory at MEMADDR.  Returns length moved.  */
end_comment

begin_function
specifier|static
name|int
name|st2000_write_inferior_memory
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|unsigned
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|printf_stdebug
argument_list|(
literal|"PM.B %x %x\r"
argument_list|,
name|memaddr
operator|+
name|i
argument_list|,
name|myaddr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|expect_prompt
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|len
return|;
block|}
end_function

begin_comment
comment|/* Read LEN bytes from inferior memory at MEMADDR.  Put the result    at debugger address MYADDR.  Returns length moved.  */
end_comment

begin_function
specifier|static
name|int
name|st2000_read_inferior_memory
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Number of bytes read so far.  */
name|int
name|count
decl_stmt|;
comment|/* Starting address of this pass.  */
name|unsigned
name|long
name|startaddr
decl_stmt|;
comment|/* Number of bytes to read in this pass.  */
name|int
name|len_this_pass
decl_stmt|;
comment|/* Note that this code works correctly if startaddr is just less      than UINT_MAX (well, really CORE_ADDR_MAX if there was such a      thing).  That is, something like      st2000_read_bytes (CORE_ADDR_MAX - 4, foo, 4)      works--it never adds len to memaddr and gets 0.  */
comment|/* However, something like      st2000_read_bytes (CORE_ADDR_MAX - 3, foo, 4)      doesn't need to work.  Detect it and give up if there's an attempt      to do that.  */
if|if
condition|(
operator|(
operator|(
name|memaddr
operator|-
literal|1
operator|)
operator|+
name|len
operator|)
operator|<
name|memaddr
condition|)
block|{
name|errno
operator|=
name|EIO
expr_stmt|;
return|return
literal|0
return|;
block|}
name|startaddr
operator|=
name|memaddr
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|count
operator|<
name|len
condition|)
block|{
name|len_this_pass
operator|=
literal|16
expr_stmt|;
if|if
condition|(
operator|(
name|startaddr
operator|%
literal|16
operator|)
operator|!=
literal|0
condition|)
name|len_this_pass
operator|-=
name|startaddr
operator|%
literal|16
expr_stmt|;
if|if
condition|(
name|len_this_pass
operator|>
operator|(
name|len
operator|-
name|count
operator|)
condition|)
name|len_this_pass
operator|=
operator|(
name|len
operator|-
name|count
operator|)
expr_stmt|;
name|printf_stdebug
argument_list|(
literal|"DI.L %x %x\r"
argument_list|,
name|startaddr
argument_list|,
name|len_this_pass
argument_list|)
expr_stmt|;
name|expect
argument_list|(
literal|":  "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len_this_pass
condition|;
name|i
operator|++
control|)
name|get_hex_byte
argument_list|(
operator|&
name|myaddr
index|[
name|count
operator|++
index|]
argument_list|)
expr_stmt|;
name|expect_prompt
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|startaddr
operator|+=
name|len_this_pass
expr_stmt|;
block|}
return|return
name|len
return|;
block|}
end_function

begin_comment
comment|/* Transfer LEN bytes between GDB address MYADDR and target address    MEMADDR.  If WRITE is non-zero, transfer them to the target,    otherwise transfer them from the target.  TARGET is unused.     Returns the number of bytes transferred. */
end_comment

begin_function
specifier|static
name|int
name|st2000_xfer_inferior_memory
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|write
parameter_list|,
name|struct
name|mem_attrib
modifier|*
name|attrib
parameter_list|,
name|struct
name|target_ops
modifier|*
name|target
parameter_list|)
block|{
if|if
condition|(
name|write
condition|)
return|return
name|st2000_write_inferior_memory
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
return|;
else|else
return|return
name|st2000_read_inferior_memory
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|st2000_kill
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
return|return;
comment|/* Ignore attempts to kill target system */
block|}
end_function

begin_comment
comment|/* Clean up when a program exits.     The program actually lives on in the remote processor's RAM, and may be    run again without a download.  Don't leave it full of breakpoint    instructions.  */
end_comment

begin_function
specifier|static
name|void
name|st2000_mourn_inferior
parameter_list|(
name|void
parameter_list|)
block|{
name|remove_breakpoints
argument_list|()
expr_stmt|;
name|unpush_target
argument_list|(
operator|&
name|st2000_ops
argument_list|)
expr_stmt|;
name|generic_mourn_inferior
argument_list|()
expr_stmt|;
comment|/* Do all the proper things now */
block|}
end_function

begin_define
define|#
directive|define
name|MAX_STDEBUG_BREAKPOINTS
value|16
end_define

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|breakaddr
index|[
name|MAX_STDEBUG_BREAKPOINTS
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|st2000_insert_breakpoint
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|char
modifier|*
name|shadow
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|CORE_ADDR
name|bp_addr
init|=
name|addr
decl_stmt|;
name|int
name|bp_size
init|=
literal|0
decl_stmt|;
name|BREAKPOINT_FROM_PC
argument_list|(
operator|&
name|bp_addr
argument_list|,
operator|&
name|bp_size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|MAX_STDEBUG_BREAKPOINTS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|breakaddr
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|breakaddr
index|[
name|i
index|]
operator|=
name|addr
expr_stmt|;
name|st2000_read_inferior_memory
argument_list|(
name|bp_addr
argument_list|,
name|shadow
argument_list|,
name|bp_size
argument_list|)
expr_stmt|;
name|printf_stdebug
argument_list|(
literal|"BR %x H\r"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|expect_prompt
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Too many breakpoints (> 16) for STDBUG\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|st2000_remove_breakpoint
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|char
modifier|*
name|shadow
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_STDEBUG_BREAKPOINTS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|breakaddr
index|[
name|i
index|]
operator|==
name|addr
condition|)
block|{
name|breakaddr
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|printf_stdebug
argument_list|(
literal|"CB %d\r"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|expect_prompt
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Can't find breakpoint associated with 0x%x\n"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Put a command string, in args, out to STDBUG.  Output from STDBUG is placed    on the users terminal until the prompt is seen. */
end_comment

begin_function
specifier|static
name|void
name|st2000_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|fromtty
parameter_list|)
block|{
if|if
condition|(
operator|!
name|st2000_desc
condition|)
name|error
argument_list|(
literal|"st2000 target not open."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|args
condition|)
name|error
argument_list|(
literal|"Missing command."
argument_list|)
expr_stmt|;
name|printf_stdebug
argument_list|(
literal|"%s\r"
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|expect_prompt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Connect the user directly to STDBUG.  This command acts just like the    'cu' or 'tip' command.  Use<CR>~. or<CR>~^D to break out.  */
end_comment

begin_comment
comment|/*static struct ttystate ttystate; */
end_comment

begin_function
specifier|static
name|void
name|cleanup_tty
parameter_list|(
name|void
parameter_list|)
block|{
name|printf
argument_list|(
literal|"\r\n[Exiting connect mode]\r\n"
argument_list|)
expr_stmt|;
comment|/*  serial_restore(0,&ttystate); */
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* This all should now be in serial.c */
end_comment

begin_comment
unit|static void connect_command (char *args, int fromtty) {   fd_set readfds;   int numfds;   int c;   char cur_esc = 0;    dont_repeat ();    if (st2000_desc< 0)     error ("st2000 target not open.");    if (args)     fprintf ("This command takes no args.  They have been ignored.\n");    printf ("[Entering connect mode.  Use ~. or ~^D to escape]\n");    serial_raw (0,&ttystate);    make_cleanup (cleanup_tty, 0);    FD_ZERO (&readfds);    while (1)     {       do 	{ 	  FD_SET (0,&readfds); 	  FD_SET (deprecated_serial_fd (st2000_desc),&readfds); 	  numfds = select (sizeof (readfds) * 8,&readfds, 0, 0, 0); 	}       while (numfds == 0);        if (numfds< 0) 	perror_with_name ("select");        if (FD_ISSET (0,&readfds)) 	{
comment|/* tty input, send to stdebug */
end_comment

begin_endif
unit|c = getchar (); 	  if (c< 0) 	    perror_with_name ("connect");  	  printf_stdebug ("%c", c); 	  switch (cur_esc) 	    { 	    case 0: 	      if (c == '\r') 		cur_esc = c; 	      break; 	    case '\r': 	      if (c == '~') 		cur_esc = c; 	      else 		cur_esc = 0; 	      break; 	    case '~': 	      if (c == '.' || c == '\004') 		return; 	      else 		cur_esc = 0; 	    } 	}        if (FD_ISSET (deprecated_serial_fd (st2000_desc),&readfds)) 	{ 	  while (1) 	    { 	      c = readchar (0); 	      if (c< 0) 		break; 	      putchar (c); 	    } 	  fflush (stdout); 	}     } }
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_comment
comment|/* Define the target subroutine names */
end_comment

begin_decl_stmt
name|struct
name|target_ops
name|st2000_ops
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|init_st2000_ops
parameter_list|(
name|void
parameter_list|)
block|{
name|st2000_ops
operator|.
name|to_shortname
operator|=
literal|"st2000"
expr_stmt|;
name|st2000_ops
operator|.
name|to_longname
operator|=
literal|"Remote serial Tandem ST2000 target"
expr_stmt|;
name|st2000_ops
operator|.
name|to_doc
operator|=
literal|"Use a remote computer running STDEBUG connected by a serial line;\n\ or a network connection.\n\ Arguments are the name of the device for the serial line,\n\ the speed to connect at in bits per second."
expr_stmt|;
name|st2000_ops
operator|.
name|to_open
operator|=
name|st2000_open
expr_stmt|;
name|st2000_ops
operator|.
name|to_close
operator|=
name|st2000_close
expr_stmt|;
name|st2000_ops
operator|.
name|to_detach
operator|=
name|st2000_detach
expr_stmt|;
name|st2000_ops
operator|.
name|to_resume
operator|=
name|st2000_resume
expr_stmt|;
name|st2000_ops
operator|.
name|to_wait
operator|=
name|st2000_wait
expr_stmt|;
name|st2000_ops
operator|.
name|to_fetch_registers
operator|=
name|st2000_fetch_register
expr_stmt|;
name|st2000_ops
operator|.
name|to_store_registers
operator|=
name|st2000_store_register
expr_stmt|;
name|st2000_ops
operator|.
name|to_prepare_to_store
operator|=
name|st2000_prepare_to_store
expr_stmt|;
name|st2000_ops
operator|.
name|to_xfer_memory
operator|=
name|st2000_xfer_inferior_memory
expr_stmt|;
name|st2000_ops
operator|.
name|to_files_info
operator|=
name|st2000_files_info
expr_stmt|;
name|st2000_ops
operator|.
name|to_insert_breakpoint
operator|=
name|st2000_insert_breakpoint
expr_stmt|;
name|st2000_ops
operator|.
name|to_remove_breakpoint
operator|=
name|st2000_remove_breakpoint
expr_stmt|;
comment|/* Breakpoints */
name|st2000_ops
operator|.
name|to_kill
operator|=
name|st2000_kill
expr_stmt|;
name|st2000_ops
operator|.
name|to_create_inferior
operator|=
name|st2000_create_inferior
expr_stmt|;
name|st2000_ops
operator|.
name|to_mourn_inferior
operator|=
name|st2000_mourn_inferior
expr_stmt|;
name|st2000_ops
operator|.
name|to_stratum
operator|=
name|process_stratum
expr_stmt|;
name|st2000_ops
operator|.
name|to_has_all_memory
operator|=
literal|1
expr_stmt|;
name|st2000_ops
operator|.
name|to_has_memory
operator|=
literal|1
expr_stmt|;
name|st2000_ops
operator|.
name|to_has_stack
operator|=
literal|1
expr_stmt|;
name|st2000_ops
operator|.
name|to_has_registers
operator|=
literal|1
expr_stmt|;
name|st2000_ops
operator|.
name|to_has_execution
operator|=
literal|1
expr_stmt|;
comment|/* all mem, mem, stack, regs, exec */
name|st2000_ops
operator|.
name|to_magic
operator|=
name|OPS_MAGIC
expr_stmt|;
comment|/* Always the last thing */
block|}
end_function

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_function
name|void
name|_initialize_remote_st2000
parameter_list|(
name|void
parameter_list|)
block|{
name|init_st2000_ops
argument_list|()
expr_stmt|;
name|add_target
argument_list|(
operator|&
name|st2000_ops
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"st2000<command>"
argument_list|,
name|class_obscure
argument_list|,
name|st2000_command
argument_list|,
literal|"Send a command to the STDBUG monitor."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"connect"
argument_list|,
name|class_obscure
argument_list|,
name|connect_command
argument_list|,
literal|"Connect the terminal directly up to the STDBUG command monitor.\n\ Use<CR>~. or<CR>~^D to break out."
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

