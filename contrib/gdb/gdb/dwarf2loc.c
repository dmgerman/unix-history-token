begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* DWARF 2 location expression support for GDB.    Copyright 2003 Free Software Foundation, Inc.    Contributed by Daniel Jacobowitz, MontaVista Software, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or (at    your option) any later version.     This program is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"ui-out.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"ax.h"
end_include

begin_include
include|#
directive|include
file|"ax-gdb.h"
end_include

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"elf/dwarf2.h"
end_include

begin_include
include|#
directive|include
file|"dwarf2expr.h"
end_include

begin_include
include|#
directive|include
file|"dwarf2loc.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|DWARF2_REG_TO_REGNUM
end_ifndef

begin_define
define|#
directive|define
name|DWARF2_REG_TO_REGNUM
parameter_list|(
name|REG
parameter_list|)
value|(REG)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* A helper function for dealing with location lists.  Given a    symbol baton (BATON) and a pc value (PC), find the appropriate    location expression, set *LOCEXPR_LENGTH, and return a pointer    to the beginning of the expression.  Returns NULL on failure.     For now, only return the first matching location expression; there    can be more than one in the list.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|find_location_expression
parameter_list|(
name|struct
name|dwarf2_loclist_baton
modifier|*
name|baton
parameter_list|,
name|size_t
modifier|*
name|locexpr_length
parameter_list|,
name|CORE_ADDR
name|pc
parameter_list|)
block|{
name|CORE_ADDR
name|low
decl_stmt|,
name|high
decl_stmt|;
name|char
modifier|*
name|loc_ptr
decl_stmt|,
modifier|*
name|buf_end
decl_stmt|;
name|unsigned
name|int
name|addr_size
init|=
name|TARGET_ADDR_BIT
operator|/
name|TARGET_CHAR_BIT
decl_stmt|,
name|length
decl_stmt|;
name|CORE_ADDR
name|base_mask
init|=
operator|~
operator|(
operator|~
operator|(
name|CORE_ADDR
operator|)
literal|1
operator|<<
operator|(
name|addr_size
operator|*
literal|8
operator|-
literal|1
operator|)
operator|)
decl_stmt|;
comment|/* Adjust base_address for relocatable objects.  */
name|CORE_ADDR
name|base_offset
init|=
name|ANOFFSET
argument_list|(
name|baton
operator|->
name|objfile
operator|->
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|(
name|baton
operator|->
name|objfile
argument_list|)
argument_list|)
decl_stmt|;
name|CORE_ADDR
name|base_address
init|=
name|baton
operator|->
name|base_address
operator|+
name|base_offset
decl_stmt|;
name|loc_ptr
operator|=
name|baton
operator|->
name|data
expr_stmt|;
name|buf_end
operator|=
name|baton
operator|->
name|data
operator|+
name|baton
operator|->
name|size
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|low
operator|=
name|dwarf2_read_address
argument_list|(
name|loc_ptr
argument_list|,
name|buf_end
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
name|loc_ptr
operator|+=
name|length
expr_stmt|;
name|high
operator|=
name|dwarf2_read_address
argument_list|(
name|loc_ptr
argument_list|,
name|buf_end
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
name|loc_ptr
operator|+=
name|length
expr_stmt|;
comment|/* An end-of-list entry.  */
if|if
condition|(
name|low
operator|==
literal|0
operator|&&
name|high
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
comment|/* A base-address-selection entry.  */
if|if
condition|(
operator|(
name|low
operator|&
name|base_mask
operator|)
operator|==
name|base_mask
condition|)
block|{
name|base_address
operator|=
name|high
expr_stmt|;
continue|continue;
block|}
comment|/* Otherwise, a location expression entry.  */
name|low
operator|+=
name|base_address
expr_stmt|;
name|high
operator|+=
name|base_address
expr_stmt|;
name|length
operator|=
name|extract_unsigned_integer
argument_list|(
name|loc_ptr
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|loc_ptr
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|pc
operator|>=
name|low
operator|&&
name|pc
operator|<
name|high
condition|)
block|{
operator|*
name|locexpr_length
operator|=
name|length
expr_stmt|;
return|return
name|loc_ptr
return|;
block|}
name|loc_ptr
operator|+=
name|length
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This is the baton used when performing dwarf2 expression    evaluation.  */
end_comment

begin_struct
struct|struct
name|dwarf_expr_baton
block|{
name|struct
name|frame_info
modifier|*
name|frame
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Helper functions for dwarf2_evaluate_loc_desc.  */
end_comment

begin_comment
comment|/* Using the frame specified in BATON, read register REGNUM.  The lval    type will be returned in LVALP, and for lval_memory the register    save address will be returned in ADDRP.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|dwarf_expr_read_reg
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|int
name|dwarf_regnum
parameter_list|)
block|{
name|struct
name|dwarf_expr_baton
modifier|*
name|debaton
init|=
operator|(
expr|struct
name|dwarf_expr_baton
operator|*
operator|)
name|baton
decl_stmt|;
name|CORE_ADDR
name|result
decl_stmt|,
name|save_addr
decl_stmt|;
name|enum
name|lval_type
name|lval_type
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|optimized
decl_stmt|,
name|regnum
decl_stmt|,
name|realnum
decl_stmt|,
name|regsize
decl_stmt|;
name|regnum
operator|=
name|DWARF2_REG_TO_REGNUM
argument_list|(
name|dwarf_regnum
argument_list|)
expr_stmt|;
name|regsize
operator|=
name|register_size
argument_list|(
name|current_gdbarch
argument_list|,
name|regnum
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|regsize
argument_list|)
expr_stmt|;
name|frame_register
argument_list|(
name|debaton
operator|->
name|frame
argument_list|,
name|regnum
argument_list|,
operator|&
name|optimized
argument_list|,
operator|&
name|lval_type
argument_list|,
operator|&
name|save_addr
argument_list|,
operator|&
name|realnum
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* NOTE: cagney/2003-05-22: This extract is assuming that a DWARF 2      address is always unsigned.  That may or may not be true.  */
name|result
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
name|regsize
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Read memory at ADDR (length LEN) into BUF.  */
end_comment

begin_function
specifier|static
name|void
name|dwarf_expr_read_mem
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|CORE_ADDR
name|addr
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|read_memory
argument_list|(
name|addr
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Using the frame specified in BATON, find the location expression    describing the frame base.  Return a pointer to it in START and    its length in LENGTH.  */
end_comment

begin_function
specifier|static
name|void
name|dwarf_expr_frame_base
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|unsigned
name|char
modifier|*
modifier|*
name|start
parameter_list|,
name|size_t
modifier|*
name|length
parameter_list|)
block|{
comment|/* FIXME: cagney/2003-03-26: This code should be using      get_frame_base_address(), and then implement a dwarf2 specific      this_base method.  */
name|struct
name|symbol
modifier|*
name|framefunc
decl_stmt|;
name|struct
name|dwarf_expr_baton
modifier|*
name|debaton
init|=
operator|(
expr|struct
name|dwarf_expr_baton
operator|*
operator|)
name|baton
decl_stmt|;
name|framefunc
operator|=
name|get_frame_function
argument_list|(
name|debaton
operator|->
name|frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|SYMBOL_OPS
argument_list|(
name|framefunc
argument_list|)
operator|==
operator|&
name|dwarf2_loclist_funcs
condition|)
block|{
name|struct
name|dwarf2_loclist_baton
modifier|*
name|symbaton
decl_stmt|;
name|symbaton
operator|=
name|SYMBOL_LOCATION_BATON
argument_list|(
name|framefunc
argument_list|)
expr_stmt|;
operator|*
name|start
operator|=
name|find_location_expression
argument_list|(
name|symbaton
argument_list|,
name|length
argument_list|,
name|get_frame_pc
argument_list|(
name|debaton
operator|->
name|frame
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|dwarf2_locexpr_baton
modifier|*
name|symbaton
decl_stmt|;
name|symbaton
operator|=
name|SYMBOL_LOCATION_BATON
argument_list|(
name|framefunc
argument_list|)
expr_stmt|;
operator|*
name|length
operator|=
name|symbaton
operator|->
name|size
expr_stmt|;
operator|*
name|start
operator|=
name|symbaton
operator|->
name|data
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|start
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Could not find the frame base for \"%s\"."
argument_list|,
name|SYMBOL_NATURAL_NAME
argument_list|(
name|framefunc
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Using the objfile specified in BATON, find the address for the    current thread's thread-local storage with offset OFFSET.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|dwarf_expr_tls_address
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|CORE_ADDR
name|offset
parameter_list|)
block|{
name|struct
name|dwarf_expr_baton
modifier|*
name|debaton
init|=
operator|(
expr|struct
name|dwarf_expr_baton
operator|*
operator|)
name|baton
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
if|if
condition|(
name|target_get_thread_local_address_p
argument_list|()
condition|)
name|addr
operator|=
name|target_get_thread_local_address
argument_list|(
name|inferior_ptid
argument_list|,
name|debaton
operator|->
name|objfile
argument_list|,
name|offset
argument_list|)
expr_stmt|;
comment|/* It wouldn't be wrong here to try a gdbarch method, too; finding      TLS is an ABI-specific thing.  But we don't do that yet.  */
else|else
name|error
argument_list|(
literal|"Cannot find thread-local variables on this target"
argument_list|)
expr_stmt|;
return|return
name|addr
return|;
block|}
end_function

begin_comment
comment|/* Evaluate a location description, starting at DATA and with length    SIZE, to find the current location of variable VAR in the context    of FRAME.  */
end_comment

begin_function
specifier|static
name|struct
name|value
modifier|*
name|dwarf2_evaluate_loc_desc
parameter_list|(
name|struct
name|symbol
modifier|*
name|var
parameter_list|,
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|,
name|unsigned
name|char
modifier|*
name|data
parameter_list|,
name|unsigned
name|short
name|size
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|CORE_ADDR
name|result
decl_stmt|;
name|struct
name|gdbarch
modifier|*
name|arch
init|=
name|get_frame_arch
argument_list|(
name|frame
argument_list|)
decl_stmt|;
name|struct
name|value
modifier|*
name|retval
decl_stmt|;
name|struct
name|dwarf_expr_baton
name|baton
decl_stmt|;
name|struct
name|dwarf_expr_context
modifier|*
name|ctx
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
name|retval
operator|=
name|allocate_value
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
name|VALUE_LVAL
argument_list|(
name|retval
argument_list|)
operator|=
name|not_lval
expr_stmt|;
name|VALUE_OPTIMIZED_OUT
argument_list|(
name|retval
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|baton
operator|.
name|frame
operator|=
name|frame
expr_stmt|;
name|baton
operator|.
name|objfile
operator|=
name|objfile
expr_stmt|;
name|ctx
operator|=
name|new_dwarf_expr_context
argument_list|()
expr_stmt|;
name|ctx
operator|->
name|baton
operator|=
operator|&
name|baton
expr_stmt|;
name|ctx
operator|->
name|read_reg
operator|=
name|dwarf_expr_read_reg
expr_stmt|;
name|ctx
operator|->
name|read_mem
operator|=
name|dwarf_expr_read_mem
expr_stmt|;
name|ctx
operator|->
name|get_frame_base
operator|=
name|dwarf_expr_frame_base
expr_stmt|;
name|ctx
operator|->
name|get_tls_address
operator|=
name|dwarf_expr_tls_address
expr_stmt|;
name|dwarf_expr_eval
argument_list|(
name|ctx
argument_list|,
name|data
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|result
operator|=
name|dwarf_expr_fetch
argument_list|(
name|ctx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|num_pieces
operator|>
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
name|long
name|offset
init|=
literal|0
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|retval
operator|=
name|allocate_value
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
name|contents
operator|=
name|VALUE_CONTENTS_RAW
argument_list|(
name|retval
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ctx
operator|->
name|num_pieces
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|dwarf_expr_piece
modifier|*
name|p
init|=
operator|&
name|ctx
operator|->
name|pieces
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|in_reg
condition|)
block|{
name|bfd_byte
name|regval
index|[
name|MAX_REGISTER_SIZE
index|]
decl_stmt|;
name|int
name|gdb_regnum
init|=
name|DWARF2_REG_TO_REGNUM
argument_list|(
name|p
operator|->
name|value
argument_list|)
decl_stmt|;
name|get_frame_register
argument_list|(
name|frame
argument_list|,
name|gdb_regnum
argument_list|,
name|regval
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|contents
operator|+
name|offset
argument_list|,
name|regval
argument_list|,
name|p
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* In memory?  */
block|{
name|read_memory
argument_list|(
name|p
operator|->
name|value
argument_list|,
name|contents
operator|+
name|offset
argument_list|,
name|p
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
name|offset
operator|+=
name|p
operator|->
name|size
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ctx
operator|->
name|in_reg
condition|)
block|{
name|int
name|regnum
init|=
name|DWARF2_REG_TO_REGNUM
argument_list|(
name|result
argument_list|)
decl_stmt|;
name|retval
operator|=
name|value_from_register
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|var
argument_list|)
argument_list|,
name|regnum
argument_list|,
name|frame
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|retval
operator|=
name|allocate_value
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
name|VALUE_BFD_SECTION
argument_list|(
name|retval
argument_list|)
operator|=
name|SYMBOL_BFD_SECTION
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|VALUE_LVAL
argument_list|(
name|retval
argument_list|)
operator|=
name|lval_memory
expr_stmt|;
name|VALUE_LAZY
argument_list|(
name|retval
argument_list|)
operator|=
literal|1
expr_stmt|;
name|VALUE_ADDRESS
argument_list|(
name|retval
argument_list|)
operator|=
name|result
expr_stmt|;
block|}
name|set_value_initialized
argument_list|(
name|retval
argument_list|,
name|ctx
operator|->
name|initialized
argument_list|)
expr_stmt|;
name|free_dwarf_expr_context
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Helper functions and baton for dwarf2_loc_desc_needs_frame.  */
end_comment

begin_struct
struct|struct
name|needs_frame_baton
block|{
name|int
name|needs_frame
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Reads from registers do require a frame.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|needs_frame_read_reg
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|int
name|regnum
parameter_list|)
block|{
name|struct
name|needs_frame_baton
modifier|*
name|nf_baton
init|=
name|baton
decl_stmt|;
name|nf_baton
operator|->
name|needs_frame
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Reads from memory do not require a frame.  */
end_comment

begin_function
specifier|static
name|void
name|needs_frame_read_mem
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|CORE_ADDR
name|addr
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|memset
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Frame-relative accesses do require a frame.  */
end_comment

begin_function
specifier|static
name|void
name|needs_frame_frame_base
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|unsigned
name|char
modifier|*
modifier|*
name|start
parameter_list|,
name|size_t
modifier|*
name|length
parameter_list|)
block|{
specifier|static
name|char
name|lit0
init|=
name|DW_OP_lit0
decl_stmt|;
name|struct
name|needs_frame_baton
modifier|*
name|nf_baton
init|=
name|baton
decl_stmt|;
operator|*
name|start
operator|=
operator|&
name|lit0
expr_stmt|;
operator|*
name|length
operator|=
literal|1
expr_stmt|;
name|nf_baton
operator|->
name|needs_frame
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Thread-local accesses do require a frame.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|needs_frame_tls_address
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|CORE_ADDR
name|offset
parameter_list|)
block|{
name|struct
name|needs_frame_baton
modifier|*
name|nf_baton
init|=
name|baton
decl_stmt|;
name|nf_baton
operator|->
name|needs_frame
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero iff the location expression at DATA (length SIZE)    requires a frame to evaluate.  */
end_comment

begin_function
specifier|static
name|int
name|dwarf2_loc_desc_needs_frame
parameter_list|(
name|unsigned
name|char
modifier|*
name|data
parameter_list|,
name|unsigned
name|short
name|size
parameter_list|)
block|{
name|struct
name|needs_frame_baton
name|baton
decl_stmt|;
name|struct
name|dwarf_expr_context
modifier|*
name|ctx
decl_stmt|;
name|int
name|in_reg
decl_stmt|;
name|baton
operator|.
name|needs_frame
operator|=
literal|0
expr_stmt|;
name|ctx
operator|=
name|new_dwarf_expr_context
argument_list|()
expr_stmt|;
name|ctx
operator|->
name|baton
operator|=
operator|&
name|baton
expr_stmt|;
name|ctx
operator|->
name|read_reg
operator|=
name|needs_frame_read_reg
expr_stmt|;
name|ctx
operator|->
name|read_mem
operator|=
name|needs_frame_read_mem
expr_stmt|;
name|ctx
operator|->
name|get_frame_base
operator|=
name|needs_frame_frame_base
expr_stmt|;
name|ctx
operator|->
name|get_tls_address
operator|=
name|needs_frame_tls_address
expr_stmt|;
name|dwarf_expr_eval
argument_list|(
name|ctx
argument_list|,
name|data
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|in_reg
operator|=
name|ctx
operator|->
name|in_reg
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|num_pieces
operator|>
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* If the location has several pieces, and any of them are in          registers, then we will need a frame to fetch them from.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ctx
operator|->
name|num_pieces
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ctx
operator|->
name|pieces
index|[
name|i
index|]
operator|.
name|in_reg
condition|)
name|in_reg
operator|=
literal|1
expr_stmt|;
block|}
name|free_dwarf_expr_context
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return
name|baton
operator|.
name|needs_frame
operator|||
name|in_reg
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dwarf2_tracepoint_var_ref
parameter_list|(
name|struct
name|symbol
modifier|*
name|symbol
parameter_list|,
name|struct
name|agent_expr
modifier|*
name|ax
parameter_list|,
name|struct
name|axs_value
modifier|*
name|value
parameter_list|,
name|unsigned
name|char
modifier|*
name|data
parameter_list|,
name|int
name|size
parameter_list|)
block|{
if|if
condition|(
name|size
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Symbol \"%s\" has been optimized out."
argument_list|,
name|SYMBOL_PRINT_NAME
argument_list|(
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|1
operator|&&
name|data
index|[
literal|0
index|]
operator|>=
name|DW_OP_reg0
operator|&&
name|data
index|[
literal|0
index|]
operator|<=
name|DW_OP_reg31
condition|)
block|{
name|value
operator|->
name|kind
operator|=
name|axs_lvalue_register
expr_stmt|;
name|value
operator|->
name|u
operator|.
name|reg
operator|=
name|data
index|[
literal|0
index|]
operator|-
name|DW_OP_reg0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|data
index|[
literal|0
index|]
operator|==
name|DW_OP_regx
condition|)
block|{
name|ULONGEST
name|reg
decl_stmt|;
name|read_uleb128
argument_list|(
name|data
operator|+
literal|1
argument_list|,
name|data
operator|+
name|size
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|value
operator|->
name|kind
operator|=
name|axs_lvalue_register
expr_stmt|;
name|value
operator|->
name|u
operator|.
name|reg
operator|=
name|reg
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|data
index|[
literal|0
index|]
operator|==
name|DW_OP_fbreg
condition|)
block|{
comment|/* And this is worse than just minimal; we should honor the frame base 	 as above.  */
name|int
name|frame_reg
decl_stmt|;
name|LONGEST
name|frame_offset
decl_stmt|;
name|unsigned
name|char
modifier|*
name|buf_end
decl_stmt|;
name|buf_end
operator|=
name|read_sleb128
argument_list|(
name|data
operator|+
literal|1
argument_list|,
name|data
operator|+
name|size
argument_list|,
operator|&
name|frame_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf_end
operator|!=
name|data
operator|+
name|size
condition|)
name|error
argument_list|(
literal|"Unexpected opcode after DW_OP_fbreg for symbol \"%s\"."
argument_list|,
name|SYMBOL_PRINT_NAME
argument_list|(
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
name|TARGET_VIRTUAL_FRAME_POINTER
argument_list|(
name|ax
operator|->
name|scope
argument_list|,
operator|&
name|frame_reg
argument_list|,
operator|&
name|frame_offset
argument_list|)
expr_stmt|;
name|ax_reg
argument_list|(
name|ax
argument_list|,
name|frame_reg
argument_list|)
expr_stmt|;
name|ax_const_l
argument_list|(
name|ax
argument_list|,
name|frame_offset
argument_list|)
expr_stmt|;
name|ax_simple
argument_list|(
name|ax
argument_list|,
name|aop_add
argument_list|)
expr_stmt|;
name|ax_const_l
argument_list|(
name|ax
argument_list|,
name|frame_offset
argument_list|)
expr_stmt|;
name|ax_simple
argument_list|(
name|ax
argument_list|,
name|aop_add
argument_list|)
expr_stmt|;
name|value
operator|->
name|kind
operator|=
name|axs_lvalue_memory
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"Unsupported DWARF opcode in the location of \"%s\"."
argument_list|,
name|SYMBOL_PRINT_NAME
argument_list|(
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the value of SYMBOL in FRAME using the DWARF-2 expression    evaluator to calculate the location.  */
end_comment

begin_function
specifier|static
name|struct
name|value
modifier|*
name|locexpr_read_variable
parameter_list|(
name|struct
name|symbol
modifier|*
name|symbol
parameter_list|,
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|)
block|{
name|struct
name|dwarf2_locexpr_baton
modifier|*
name|dlbaton
init|=
name|SYMBOL_LOCATION_BATON
argument_list|(
name|symbol
argument_list|)
decl_stmt|;
name|struct
name|value
modifier|*
name|val
decl_stmt|;
name|val
operator|=
name|dwarf2_evaluate_loc_desc
argument_list|(
name|symbol
argument_list|,
name|frame
argument_list|,
name|dlbaton
operator|->
name|data
argument_list|,
name|dlbaton
operator|->
name|size
argument_list|,
name|dlbaton
operator|->
name|objfile
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero iff we need a frame to evaluate SYMBOL.  */
end_comment

begin_function
specifier|static
name|int
name|locexpr_read_needs_frame
parameter_list|(
name|struct
name|symbol
modifier|*
name|symbol
parameter_list|)
block|{
name|struct
name|dwarf2_locexpr_baton
modifier|*
name|dlbaton
init|=
name|SYMBOL_LOCATION_BATON
argument_list|(
name|symbol
argument_list|)
decl_stmt|;
return|return
name|dwarf2_loc_desc_needs_frame
argument_list|(
name|dlbaton
operator|->
name|data
argument_list|,
name|dlbaton
operator|->
name|size
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Print a natural-language description of SYMBOL to STREAM.  */
end_comment

begin_function
specifier|static
name|int
name|locexpr_describe_location
parameter_list|(
name|struct
name|symbol
modifier|*
name|symbol
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|)
block|{
comment|/* FIXME: be more extensive.  */
name|struct
name|dwarf2_locexpr_baton
modifier|*
name|dlbaton
init|=
name|SYMBOL_LOCATION_BATON
argument_list|(
name|symbol
argument_list|)
decl_stmt|;
if|if
condition|(
name|dlbaton
operator|->
name|size
operator|==
literal|1
operator|&&
name|dlbaton
operator|->
name|data
index|[
literal|0
index|]
operator|>=
name|DW_OP_reg0
operator|&&
name|dlbaton
operator|->
name|data
index|[
literal|0
index|]
operator|<=
name|DW_OP_reg31
condition|)
block|{
name|int
name|regno
init|=
name|DWARF2_REG_TO_REGNUM
argument_list|(
name|dlbaton
operator|->
name|data
index|[
literal|0
index|]
operator|-
name|DW_OP_reg0
argument_list|)
decl_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"a variable in register %s"
argument_list|,
name|REGISTER_NAME
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* The location expression for a TLS variable looks like this (on a      64-bit LE machine):       DW_AT_location    : 10 byte block: 3 4 0 0 0 0 0 0 0 e0                         (DW_OP_addr: 4; DW_OP_GNU_push_tls_address)            0x3 is the encoding for DW_OP_addr, which has an operand as long      as the size of an address on the target machine (here is 8      bytes).  0xe0 is the encoding for DW_OP_GNU_push_tls_address.      The operand represents the offset at which the variable is within      the thread local storage.  */
if|if
condition|(
name|dlbaton
operator|->
name|size
operator|>
literal|1
operator|&&
name|dlbaton
operator|->
name|data
index|[
name|dlbaton
operator|->
name|size
operator|-
literal|1
index|]
operator|==
name|DW_OP_GNU_push_tls_address
condition|)
if|if
condition|(
name|dlbaton
operator|->
name|data
index|[
literal|0
index|]
operator|==
name|DW_OP_addr
condition|)
block|{
name|int
name|bytes_read
decl_stmt|;
name|CORE_ADDR
name|offset
init|=
name|dwarf2_read_address
argument_list|(
operator|&
name|dlbaton
operator|->
name|data
index|[
literal|1
index|]
argument_list|,
operator|&
name|dlbaton
operator|->
name|data
index|[
name|dlbaton
operator|->
name|size
operator|-
literal|1
index|]
argument_list|,
operator|&
name|bytes_read
argument_list|)
decl_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"a thread-local variable at offset %s in the "
literal|"thread-local storage for `%s'"
argument_list|,
name|paddr_nz
argument_list|(
name|offset
argument_list|)
argument_list|,
name|dlbaton
operator|->
name|objfile
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"a variable with complex or multiple locations (DWARF2)"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Describe the location of SYMBOL as an agent value in VALUE, generating    any necessary bytecode in AX.     NOTE drow/2003-02-26: This function is extremely minimal, because    doing it correctly is extremely complicated and there is no    publicly available stub with tracepoint support for me to test    against.  When there is one this function should be revisited.  */
end_comment

begin_function
specifier|static
name|void
name|locexpr_tracepoint_var_ref
parameter_list|(
name|struct
name|symbol
modifier|*
name|symbol
parameter_list|,
name|struct
name|agent_expr
modifier|*
name|ax
parameter_list|,
name|struct
name|axs_value
modifier|*
name|value
parameter_list|)
block|{
name|struct
name|dwarf2_locexpr_baton
modifier|*
name|dlbaton
init|=
name|SYMBOL_LOCATION_BATON
argument_list|(
name|symbol
argument_list|)
decl_stmt|;
name|dwarf2_tracepoint_var_ref
argument_list|(
name|symbol
argument_list|,
name|ax
argument_list|,
name|value
argument_list|,
name|dlbaton
operator|->
name|data
argument_list|,
name|dlbaton
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The set of location functions used with the DWARF-2 expression    evaluator.  */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|symbol_ops
name|dwarf2_locexpr_funcs
init|=
block|{
name|locexpr_read_variable
block|,
name|locexpr_read_needs_frame
block|,
name|locexpr_describe_location
block|,
name|locexpr_tracepoint_var_ref
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Wrapper functions for location lists.  These generally find    the appropriate location expression and call something above.  */
end_comment

begin_comment
comment|/* Return the value of SYMBOL in FRAME using the DWARF-2 expression    evaluator to calculate the location.  */
end_comment

begin_function
specifier|static
name|struct
name|value
modifier|*
name|loclist_read_variable
parameter_list|(
name|struct
name|symbol
modifier|*
name|symbol
parameter_list|,
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|)
block|{
name|struct
name|dwarf2_loclist_baton
modifier|*
name|dlbaton
init|=
name|SYMBOL_LOCATION_BATON
argument_list|(
name|symbol
argument_list|)
decl_stmt|;
name|struct
name|value
modifier|*
name|val
decl_stmt|;
name|unsigned
name|char
modifier|*
name|data
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|data
operator|=
name|find_location_expression
argument_list|(
name|dlbaton
argument_list|,
operator|&
name|size
argument_list|,
name|frame
condition|?
name|get_frame_pc
argument_list|(
name|frame
argument_list|)
else|:
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|==
name|NULL
condition|)
block|{
name|val
operator|=
name|allocate_value
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
name|VALUE_LVAL
argument_list|(
name|val
argument_list|)
operator|=
name|not_lval
expr_stmt|;
name|VALUE_OPTIMIZED_OUT
argument_list|(
name|val
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|val
operator|=
name|dwarf2_evaluate_loc_desc
argument_list|(
name|symbol
argument_list|,
name|frame
argument_list|,
name|data
argument_list|,
name|size
argument_list|,
name|dlbaton
operator|->
name|objfile
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero iff we need a frame to evaluate SYMBOL.  */
end_comment

begin_function
specifier|static
name|int
name|loclist_read_needs_frame
parameter_list|(
name|struct
name|symbol
modifier|*
name|symbol
parameter_list|)
block|{
comment|/* If there's a location list, then assume we need to have a frame      to choose the appropriate location expression.  With tracking of      global variables this is not necessarily true, but such tracking      is disabled in GCC at the moment until we figure out how to      represent it.  */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Print a natural-language description of SYMBOL to STREAM.  */
end_comment

begin_function
specifier|static
name|int
name|loclist_describe_location
parameter_list|(
name|struct
name|symbol
modifier|*
name|symbol
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|)
block|{
comment|/* FIXME: Could print the entire list of locations.  */
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"a variable with multiple locations"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Describe the location of SYMBOL as an agent value in VALUE, generating    any necessary bytecode in AX.  */
end_comment

begin_function
specifier|static
name|void
name|loclist_tracepoint_var_ref
parameter_list|(
name|struct
name|symbol
modifier|*
name|symbol
parameter_list|,
name|struct
name|agent_expr
modifier|*
name|ax
parameter_list|,
name|struct
name|axs_value
modifier|*
name|value
parameter_list|)
block|{
name|struct
name|dwarf2_loclist_baton
modifier|*
name|dlbaton
init|=
name|SYMBOL_LOCATION_BATON
argument_list|(
name|symbol
argument_list|)
decl_stmt|;
name|unsigned
name|char
modifier|*
name|data
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|data
operator|=
name|find_location_expression
argument_list|(
name|dlbaton
argument_list|,
operator|&
name|size
argument_list|,
name|ax
operator|->
name|scope
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Variable \"%s\" is not available."
argument_list|,
name|SYMBOL_NATURAL_NAME
argument_list|(
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
name|dwarf2_tracepoint_var_ref
argument_list|(
name|symbol
argument_list|,
name|ax
argument_list|,
name|value
argument_list|,
name|data
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The set of location functions used with the DWARF-2 expression    evaluator and location lists.  */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|symbol_ops
name|dwarf2_loclist_funcs
init|=
block|{
name|loclist_read_variable
block|,
name|loclist_read_needs_frame
block|,
name|loclist_describe_location
block|,
name|loclist_tracepoint_var_ref
block|}
decl_stmt|;
end_decl_stmt

end_unit

