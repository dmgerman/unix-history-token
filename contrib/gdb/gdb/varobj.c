begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Implementation of the GDB variable objects API.    Copyright 1999, 2000, 2001 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"wrapper.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_include
include|#
directive|include
file|"varobj.h"
end_include

begin_comment
comment|/* Non-zero if we want to see trace of varobj level stuff.  */
end_comment

begin_decl_stmt
name|int
name|varobjdebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* String representations of gdb's format codes */
end_comment

begin_decl_stmt
name|char
modifier|*
name|varobj_format_string
index|[]
init|=
block|{
literal|"natural"
block|,
literal|"binary"
block|,
literal|"decimal"
block|,
literal|"hexadecimal"
block|,
literal|"octal"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* String representations of gdb's known languages */
end_comment

begin_decl_stmt
name|char
modifier|*
name|varobj_language_string
index|[]
init|=
block|{
literal|"unknown"
block|,
literal|"C"
block|,
literal|"C++"
block|,
literal|"Java"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Data structures */
end_comment

begin_comment
comment|/* Every root variable has one of these structures saved in its    varobj. Members which must be free'd are noted. */
end_comment

begin_struct
struct|struct
name|varobj_root
block|{
comment|/* Alloc'd expression for this parent. */
name|struct
name|expression
modifier|*
name|exp
decl_stmt|;
comment|/* Block for which this expression is valid */
name|struct
name|block
modifier|*
name|valid_block
decl_stmt|;
comment|/* The frame for this expression */
name|CORE_ADDR
name|frame
decl_stmt|;
comment|/* If 1, "update" always recomputes the frame& valid block      using the currently selected frame. */
name|int
name|use_selected_frame
decl_stmt|;
comment|/* Language info for this variable and its children */
name|struct
name|language_specific
modifier|*
name|lang
decl_stmt|;
comment|/* The varobj for this root node. */
name|struct
name|varobj
modifier|*
name|rootvar
decl_stmt|;
comment|/* Next root variable */
name|struct
name|varobj_root
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Every variable in the system has a structure of this type defined    for it. This structure holds all information necessary to manipulate    a particular object variable. Members which must be freed are noted. */
end_comment

begin_struct
struct|struct
name|varobj
block|{
comment|/* Alloc'd name of the variable for this object.. If this variable is a      child, then this name will be the child's source name.      (bar, not foo.bar) */
comment|/* NOTE: This is the "expression" */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* The alloc'd name for this variable's object. This is here for      convenience when constructing this object's children. */
name|char
modifier|*
name|obj_name
decl_stmt|;
comment|/* Index of this variable in its parent or -1 */
name|int
name|index
decl_stmt|;
comment|/* The type of this variable. This may NEVER be NULL. */
name|struct
name|type
modifier|*
name|type
decl_stmt|;
comment|/* The value of this expression or subexpression.  This may be NULL. */
name|struct
name|value
modifier|*
name|value
decl_stmt|;
comment|/* Did an error occur evaluating the expression or getting its value? */
name|int
name|error
decl_stmt|;
comment|/* The number of (immediate) children this variable has */
name|int
name|num_children
decl_stmt|;
comment|/* If this object is a child, this points to its immediate parent. */
name|struct
name|varobj
modifier|*
name|parent
decl_stmt|;
comment|/* A list of this object's children */
name|struct
name|varobj_child
modifier|*
name|children
decl_stmt|;
comment|/* Description of the root variable. Points to root variable for children. */
name|struct
name|varobj_root
modifier|*
name|root
decl_stmt|;
comment|/* The format of the output for this object */
name|enum
name|varobj_display_formats
name|format
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Every variable keeps a linked list of its children, described    by the following structure. */
end_comment

begin_comment
comment|/* FIXME: Deprecated.  All should use vlist instead */
end_comment

begin_struct
struct|struct
name|varobj_child
block|{
comment|/* Pointer to the child's data */
name|struct
name|varobj
modifier|*
name|child
decl_stmt|;
comment|/* Pointer to the next child */
name|struct
name|varobj_child
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* A stack of varobjs */
end_comment

begin_comment
comment|/* FIXME: Deprecated.  All should use vlist instead */
end_comment

begin_struct
struct|struct
name|vstack
block|{
name|struct
name|varobj
modifier|*
name|var
decl_stmt|;
name|struct
name|vstack
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|cpstack
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|cpstack
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* A list of varobjs */
end_comment

begin_struct
struct|struct
name|vlist
block|{
name|struct
name|varobj
modifier|*
name|var
decl_stmt|;
name|struct
name|vlist
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Private function prototypes */
end_comment

begin_comment
comment|/* Helper functions for the above subcommands. */
end_comment

begin_function_decl
specifier|static
name|int
name|delete_variable
parameter_list|(
name|struct
name|cpstack
modifier|*
modifier|*
parameter_list|,
name|struct
name|varobj
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|delete_variable_1
parameter_list|(
name|struct
name|cpstack
modifier|*
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|struct
name|varobj
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|install_variable
parameter_list|(
name|struct
name|varobj
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uninstall_variable
parameter_list|(
name|struct
name|varobj
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|varobj
modifier|*
name|child_exists
parameter_list|(
name|struct
name|varobj
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|varobj
modifier|*
name|create_child
parameter_list|(
name|struct
name|varobj
modifier|*
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|save_child_in_parent
parameter_list|(
name|struct
name|varobj
modifier|*
parameter_list|,
name|struct
name|varobj
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|remove_child_from_parent
parameter_list|(
name|struct
name|varobj
modifier|*
parameter_list|,
name|struct
name|varobj
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Utility routines */
end_comment

begin_function_decl
specifier|static
name|struct
name|varobj
modifier|*
name|new_variable
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|varobj
modifier|*
name|new_root_variable
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_variable
parameter_list|(
name|struct
name|varobj
modifier|*
name|var
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|cleanup
modifier|*
name|make_cleanup_free_variable
parameter_list|(
name|struct
name|varobj
modifier|*
name|var
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|type
modifier|*
name|get_type
parameter_list|(
name|struct
name|varobj
modifier|*
name|var
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|type
modifier|*
name|get_type_deref
parameter_list|(
name|struct
name|varobj
modifier|*
name|var
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|type
modifier|*
name|get_target_type
parameter_list|(
name|struct
name|type
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|varobj_display_formats
name|variable_default_display
parameter_list|(
name|struct
name|varobj
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|my_value_equal
parameter_list|(
name|struct
name|value
modifier|*
parameter_list|,
name|struct
name|value
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vpush
parameter_list|(
name|struct
name|vstack
modifier|*
modifier|*
name|pstack
parameter_list|,
name|struct
name|varobj
modifier|*
name|var
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|varobj
modifier|*
name|vpop
parameter_list|(
name|struct
name|vstack
modifier|*
modifier|*
name|pstack
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cppush
parameter_list|(
name|struct
name|cpstack
modifier|*
modifier|*
name|pstack
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|cppop
parameter_list|(
name|struct
name|cpstack
modifier|*
modifier|*
name|pstack
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Language-specific routines. */
end_comment

begin_function_decl
specifier|static
name|enum
name|varobj_languages
name|variable_language
parameter_list|(
name|struct
name|varobj
modifier|*
name|var
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|number_of_children
parameter_list|(
name|struct
name|varobj
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|name_of_variable
parameter_list|(
name|struct
name|varobj
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|name_of_child
parameter_list|(
name|struct
name|varobj
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|value
modifier|*
name|value_of_root
parameter_list|(
name|struct
name|varobj
modifier|*
modifier|*
name|var_handle
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|value
modifier|*
name|value_of_child
parameter_list|(
name|struct
name|varobj
modifier|*
name|parent
parameter_list|,
name|int
name|index
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|type
modifier|*
name|type_of_child
parameter_list|(
name|struct
name|varobj
modifier|*
name|var
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|variable_editable
parameter_list|(
name|struct
name|varobj
modifier|*
name|var
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|my_value_of_variable
parameter_list|(
name|struct
name|varobj
modifier|*
name|var
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|type_changeable
parameter_list|(
name|struct
name|varobj
modifier|*
name|var
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* C implementation */
end_comment

begin_function_decl
specifier|static
name|int
name|c_number_of_children
parameter_list|(
name|struct
name|varobj
modifier|*
name|var
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|c_name_of_variable
parameter_list|(
name|struct
name|varobj
modifier|*
name|parent
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|c_name_of_child
parameter_list|(
name|struct
name|varobj
modifier|*
name|parent
parameter_list|,
name|int
name|index
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|value
modifier|*
name|c_value_of_root
parameter_list|(
name|struct
name|varobj
modifier|*
modifier|*
name|var_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|value
modifier|*
name|c_value_of_child
parameter_list|(
name|struct
name|varobj
modifier|*
name|parent
parameter_list|,
name|int
name|index
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|type
modifier|*
name|c_type_of_child
parameter_list|(
name|struct
name|varobj
modifier|*
name|parent
parameter_list|,
name|int
name|index
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|c_variable_editable
parameter_list|(
name|struct
name|varobj
modifier|*
name|var
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|c_value_of_variable
parameter_list|(
name|struct
name|varobj
modifier|*
name|var
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* C++ implementation */
end_comment

begin_function_decl
specifier|static
name|int
name|cplus_number_of_children
parameter_list|(
name|struct
name|varobj
modifier|*
name|var
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cplus_class_num_children
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|int
name|children
index|[
literal|3
index|]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|cplus_name_of_variable
parameter_list|(
name|struct
name|varobj
modifier|*
name|parent
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|cplus_name_of_child
parameter_list|(
name|struct
name|varobj
modifier|*
name|parent
parameter_list|,
name|int
name|index
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|value
modifier|*
name|cplus_value_of_root
parameter_list|(
name|struct
name|varobj
modifier|*
modifier|*
name|var_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|value
modifier|*
name|cplus_value_of_child
parameter_list|(
name|struct
name|varobj
modifier|*
name|parent
parameter_list|,
name|int
name|index
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|type
modifier|*
name|cplus_type_of_child
parameter_list|(
name|struct
name|varobj
modifier|*
name|parent
parameter_list|,
name|int
name|index
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cplus_variable_editable
parameter_list|(
name|struct
name|varobj
modifier|*
name|var
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|cplus_value_of_variable
parameter_list|(
name|struct
name|varobj
modifier|*
name|var
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Java implementation */
end_comment

begin_function_decl
specifier|static
name|int
name|java_number_of_children
parameter_list|(
name|struct
name|varobj
modifier|*
name|var
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|java_name_of_variable
parameter_list|(
name|struct
name|varobj
modifier|*
name|parent
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|java_name_of_child
parameter_list|(
name|struct
name|varobj
modifier|*
name|parent
parameter_list|,
name|int
name|index
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|value
modifier|*
name|java_value_of_root
parameter_list|(
name|struct
name|varobj
modifier|*
modifier|*
name|var_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|value
modifier|*
name|java_value_of_child
parameter_list|(
name|struct
name|varobj
modifier|*
name|parent
parameter_list|,
name|int
name|index
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|type
modifier|*
name|java_type_of_child
parameter_list|(
name|struct
name|varobj
modifier|*
name|parent
parameter_list|,
name|int
name|index
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|java_variable_editable
parameter_list|(
name|struct
name|varobj
modifier|*
name|var
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|java_value_of_variable
parameter_list|(
name|struct
name|varobj
modifier|*
name|var
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* The language specific vector */
end_comment

begin_struct
struct|struct
name|language_specific
block|{
comment|/* The language of this variable */
name|enum
name|varobj_languages
name|language
decl_stmt|;
comment|/* The number of children of PARENT. */
name|int
function_decl|(
modifier|*
name|number_of_children
function_decl|)
parameter_list|(
name|struct
name|varobj
modifier|*
name|parent
parameter_list|)
function_decl|;
comment|/* The name (expression) of a root varobj. */
name|char
modifier|*
function_decl|(
modifier|*
name|name_of_variable
function_decl|)
parameter_list|(
name|struct
name|varobj
modifier|*
name|parent
parameter_list|)
function_decl|;
comment|/* The name of the INDEX'th child of PARENT. */
name|char
modifier|*
function_decl|(
modifier|*
name|name_of_child
function_decl|)
parameter_list|(
name|struct
name|varobj
modifier|*
name|parent
parameter_list|,
name|int
name|index
parameter_list|)
function_decl|;
comment|/* The ``struct value *'' of the root variable ROOT. */
name|struct
name|value
modifier|*
function_decl|(
modifier|*
name|value_of_root
function_decl|)
parameter_list|(
name|struct
name|varobj
modifier|*
modifier|*
name|root_handle
parameter_list|)
function_decl|;
comment|/* The ``struct value *'' of the INDEX'th child of PARENT. */
name|struct
name|value
modifier|*
function_decl|(
modifier|*
name|value_of_child
function_decl|)
parameter_list|(
name|struct
name|varobj
modifier|*
name|parent
parameter_list|,
name|int
name|index
parameter_list|)
function_decl|;
comment|/* The type of the INDEX'th child of PARENT. */
name|struct
name|type
modifier|*
function_decl|(
modifier|*
name|type_of_child
function_decl|)
parameter_list|(
name|struct
name|varobj
modifier|*
name|parent
parameter_list|,
name|int
name|index
parameter_list|)
function_decl|;
comment|/* Is VAR editable? */
name|int
function_decl|(
modifier|*
name|variable_editable
function_decl|)
parameter_list|(
name|struct
name|varobj
modifier|*
name|var
parameter_list|)
function_decl|;
comment|/* The current value of VAR. */
name|char
modifier|*
function_decl|(
modifier|*
name|value_of_variable
function_decl|)
parameter_list|(
name|struct
name|varobj
modifier|*
name|var
parameter_list|)
function_decl|;
block|}
struct|;
end_struct

begin_comment
comment|/* Array of known source language routines. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|language_specific
name|languages
index|[
name|vlang_end
index|]
index|[
sizeof|sizeof
argument_list|(
expr|struct
name|language_specific
argument_list|)
index|]
init|=
block|{
comment|/* Unknown (try treating as C */
block|{
name|vlang_unknown
block|,
name|c_number_of_children
block|,
name|c_name_of_variable
block|,
name|c_name_of_child
block|,
name|c_value_of_root
block|,
name|c_value_of_child
block|,
name|c_type_of_child
block|,
name|c_variable_editable
block|,
name|c_value_of_variable
block|}
block|,
comment|/* C */
block|{
name|vlang_c
block|,
name|c_number_of_children
block|,
name|c_name_of_variable
block|,
name|c_name_of_child
block|,
name|c_value_of_root
block|,
name|c_value_of_child
block|,
name|c_type_of_child
block|,
name|c_variable_editable
block|,
name|c_value_of_variable
block|}
block|,
comment|/* C++ */
block|{
name|vlang_cplus
block|,
name|cplus_number_of_children
block|,
name|cplus_name_of_variable
block|,
name|cplus_name_of_child
block|,
name|cplus_value_of_root
block|,
name|cplus_value_of_child
block|,
name|cplus_type_of_child
block|,
name|cplus_variable_editable
block|,
name|cplus_value_of_variable
block|}
block|,
comment|/* Java */
block|{
name|vlang_java
block|,
name|java_number_of_children
block|,
name|java_name_of_variable
block|,
name|java_name_of_child
block|,
name|java_value_of_root
block|,
name|java_value_of_child
block|,
name|java_type_of_child
block|,
name|java_variable_editable
block|,
name|java_value_of_variable
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A little convenience enum for dealing with C++/Java */
end_comment

begin_enum
enum|enum
name|vsections
block|{
name|v_public
init|=
literal|0
block|,
name|v_private
block|,
name|v_protected
block|}
enum|;
end_enum

begin_comment
comment|/* Private data */
end_comment

begin_comment
comment|/* Mappings of varobj_display_formats enums to gdb's format codes */
end_comment

begin_decl_stmt
specifier|static
name|int
name|format_code
index|[]
init|=
block|{
literal|0
block|,
literal|'t'
block|,
literal|'d'
block|,
literal|'x'
block|,
literal|'o'
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Header of the list of root variable objects */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|varobj_root
modifier|*
name|rootlist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rootcount
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of root varobjs in the list */
end_comment

begin_comment
comment|/* Prime number indicating the number of buckets in the hash table */
end_comment

begin_comment
comment|/* A prime large enough to avoid too many colisions */
end_comment

begin_define
define|#
directive|define
name|VAROBJ_TABLE_SIZE
value|227
end_define

begin_comment
comment|/* Pointer to the varobj hash table (built at run time) */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|vlist
modifier|*
modifier|*
name|varobj_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Is the variable X one of our "fake" children? */
end_comment

begin_define
define|#
directive|define
name|CPLUS_FAKE_CHILD
parameter_list|(
name|x
parameter_list|)
define|\
value|((x) != NULL&& (x)->type == NULL&& (x)->value == NULL)
end_define

begin_escape
end_escape

begin_comment
comment|/* API Implementation */
end_comment

begin_comment
comment|/* Creates a varobj (not its children) */
end_comment

begin_function
name|struct
name|varobj
modifier|*
name|varobj_create
parameter_list|(
name|char
modifier|*
name|objname
parameter_list|,
name|char
modifier|*
name|expression
parameter_list|,
name|CORE_ADDR
name|frame
parameter_list|,
name|enum
name|varobj_type
name|type
parameter_list|)
block|{
name|struct
name|varobj
modifier|*
name|var
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|old_fi
init|=
name|NULL
decl_stmt|;
name|struct
name|block
modifier|*
name|block
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
comment|/* Fill out a varobj structure for the (root) variable being constructed. */
name|var
operator|=
name|new_root_variable
argument_list|()
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup_free_variable
argument_list|(
name|var
argument_list|)
expr_stmt|;
if|if
condition|(
name|expression
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|enum
name|varobj_languages
name|lang
decl_stmt|;
comment|/* Parse and evaluate the expression, filling in as much          of the variable's data as possible */
comment|/* Allow creator to specify context of variable */
if|if
condition|(
operator|(
name|type
operator|==
name|USE_CURRENT_FRAME
operator|)
operator|||
operator|(
name|type
operator|==
name|USE_SELECTED_FRAME
operator|)
condition|)
name|fi
operator|=
name|selected_frame
expr_stmt|;
else|else
name|fi
operator|=
name|find_frame_addr_in_frame_chain
argument_list|(
name|frame
argument_list|)
expr_stmt|;
comment|/* frame = -2 means always use selected frame */
if|if
condition|(
name|type
operator|==
name|USE_SELECTED_FRAME
condition|)
name|var
operator|->
name|root
operator|->
name|use_selected_frame
operator|=
literal|1
expr_stmt|;
name|block
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|fi
operator|!=
name|NULL
condition|)
name|block
operator|=
name|get_frame_block
argument_list|(
name|fi
argument_list|)
expr_stmt|;
name|p
operator|=
name|expression
expr_stmt|;
name|innermost_block
operator|=
name|NULL
expr_stmt|;
comment|/* Wrap the call to parse expression, so we can           return a sensible error. */
if|if
condition|(
operator|!
name|gdb_parse_exp_1
argument_list|(
operator|&
name|p
argument_list|,
name|block
argument_list|,
literal|0
argument_list|,
operator|&
name|var
operator|->
name|root
operator|->
name|exp
argument_list|)
condition|)
block|{
return|return
name|NULL
return|;
block|}
comment|/* Don't allow variables to be created for types. */
if|if
condition|(
name|var
operator|->
name|root
operator|->
name|exp
operator|->
name|elts
index|[
literal|0
index|]
operator|.
name|opcode
operator|==
name|OP_TYPE
condition|)
block|{
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Attempt to use a type name as an expression."
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|var
operator|->
name|format
operator|=
name|variable_default_display
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|var
operator|->
name|root
operator|->
name|valid_block
operator|=
name|innermost_block
expr_stmt|;
name|var
operator|->
name|name
operator|=
name|savestring
argument_list|(
name|expression
argument_list|,
name|strlen
argument_list|(
name|expression
argument_list|)
argument_list|)
expr_stmt|;
comment|/* When the frame is different from the current frame,           we must select the appropriate frame before parsing          the expression, otherwise the value will not be current.          Since select_frame is so benign, just call it for all cases. */
if|if
condition|(
name|fi
operator|!=
name|NULL
condition|)
block|{
name|var
operator|->
name|root
operator|->
name|frame
operator|=
name|FRAME_FP
argument_list|(
name|fi
argument_list|)
expr_stmt|;
name|old_fi
operator|=
name|selected_frame
expr_stmt|;
name|select_frame
argument_list|(
name|fi
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* We definitively need to catch errors here.          If evaluate_expression succeeds we got the value we wanted.          But if it fails, we still go on with a call to evaluate_type()  */
if|if
condition|(
name|gdb_evaluate_expression
argument_list|(
name|var
operator|->
name|root
operator|->
name|exp
argument_list|,
operator|&
name|var
operator|->
name|value
argument_list|)
condition|)
block|{
comment|/* no error */
name|release_value
argument_list|(
name|var
operator|->
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|VALUE_LAZY
argument_list|(
name|var
operator|->
name|value
argument_list|)
condition|)
name|gdb_value_fetch_lazy
argument_list|(
name|var
operator|->
name|value
argument_list|)
expr_stmt|;
block|}
else|else
name|var
operator|->
name|value
operator|=
name|evaluate_type
argument_list|(
name|var
operator|->
name|root
operator|->
name|exp
argument_list|)
expr_stmt|;
name|var
operator|->
name|type
operator|=
name|VALUE_TYPE
argument_list|(
name|var
operator|->
name|value
argument_list|)
expr_stmt|;
comment|/* Set language info */
name|lang
operator|=
name|variable_language
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|var
operator|->
name|root
operator|->
name|lang
operator|=
name|languages
index|[
name|lang
index|]
expr_stmt|;
comment|/* Set ourselves as our root */
name|var
operator|->
name|root
operator|->
name|rootvar
operator|=
name|var
expr_stmt|;
comment|/* Reset the selected frame */
if|if
condition|(
name|fi
operator|!=
name|NULL
condition|)
name|select_frame
argument_list|(
name|old_fi
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* If the variable object name is null, that means this      is a temporary variable, so don't install it. */
if|if
condition|(
operator|(
name|var
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|objname
operator|!=
name|NULL
operator|)
condition|)
block|{
name|var
operator|->
name|obj_name
operator|=
name|savestring
argument_list|(
name|objname
argument_list|,
name|strlen
argument_list|(
name|objname
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If a varobj name is duplicated, the install will fail so          we must clenup */
if|if
condition|(
operator|!
name|install_variable
argument_list|(
name|var
argument_list|)
condition|)
block|{
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
name|discard_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
name|var
return|;
block|}
end_function

begin_comment
comment|/* Generates an unique name that can be used for a varobj */
end_comment

begin_function
name|char
modifier|*
name|varobj_gen_name
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|int
name|id
init|=
literal|0
decl_stmt|;
name|char
name|obj_name
index|[
literal|31
index|]
decl_stmt|;
comment|/* generate a name for this object */
name|id
operator|++
expr_stmt|;
name|sprintf
argument_list|(
name|obj_name
argument_list|,
literal|"var%d"
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return
name|xstrdup
argument_list|(
name|obj_name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given an "objname", returns the pointer to the corresponding varobj    or NULL if not found */
end_comment

begin_function
name|struct
name|varobj
modifier|*
name|varobj_get_handle
parameter_list|(
name|char
modifier|*
name|objname
parameter_list|)
block|{
name|struct
name|vlist
modifier|*
name|cv
decl_stmt|;
specifier|const
name|char
modifier|*
name|chp
decl_stmt|;
name|unsigned
name|int
name|index
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|i
init|=
literal|1
decl_stmt|;
for|for
control|(
name|chp
operator|=
name|objname
init|;
operator|*
name|chp
condition|;
name|chp
operator|++
control|)
block|{
name|index
operator|=
operator|(
name|index
operator|+
operator|(
name|i
operator|++
operator|*
operator|(
name|unsigned
name|int
operator|)
operator|*
name|chp
operator|)
operator|)
operator|%
name|VAROBJ_TABLE_SIZE
expr_stmt|;
block|}
name|cv
operator|=
operator|*
operator|(
name|varobj_table
operator|+
name|index
operator|)
expr_stmt|;
while|while
condition|(
operator|(
name|cv
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|cv
operator|->
name|var
operator|->
name|obj_name
argument_list|,
name|objname
argument_list|)
operator|!=
literal|0
operator|)
condition|)
name|cv
operator|=
name|cv
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|cv
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Variable object not found"
argument_list|)
expr_stmt|;
return|return
name|cv
operator|->
name|var
return|;
block|}
end_function

begin_comment
comment|/* Given the handle, return the name of the object */
end_comment

begin_function
name|char
modifier|*
name|varobj_get_objname
parameter_list|(
name|struct
name|varobj
modifier|*
name|var
parameter_list|)
block|{
return|return
name|var
operator|->
name|obj_name
return|;
block|}
end_function

begin_comment
comment|/* Given the handle, return the expression represented by the object */
end_comment

begin_function
name|char
modifier|*
name|varobj_get_expression
parameter_list|(
name|struct
name|varobj
modifier|*
name|var
parameter_list|)
block|{
return|return
name|name_of_variable
argument_list|(
name|var
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Deletes a varobj and all its children if only_children == 0,    otherwise deletes only the children; returns a malloc'ed list of all the     (malloc'ed) names of the variables that have been deleted (NULL terminated) */
end_comment

begin_function
name|int
name|varobj_delete
parameter_list|(
name|struct
name|varobj
modifier|*
name|var
parameter_list|,
name|char
modifier|*
modifier|*
modifier|*
name|dellist
parameter_list|,
name|int
name|only_children
parameter_list|)
block|{
name|int
name|delcount
decl_stmt|;
name|int
name|mycount
decl_stmt|;
name|struct
name|cpstack
modifier|*
name|result
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
modifier|*
name|cp
decl_stmt|;
comment|/* Initialize a stack for temporary results */
name|cppush
argument_list|(
operator|&
name|result
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|only_children
condition|)
comment|/* Delete only the variable children */
name|delcount
operator|=
name|delete_variable
argument_list|(
operator|&
name|result
argument_list|,
name|var
argument_list|,
literal|1
comment|/* only the children */
argument_list|)
expr_stmt|;
else|else
comment|/* Delete the variable and all its children */
name|delcount
operator|=
name|delete_variable
argument_list|(
operator|&
name|result
argument_list|,
name|var
argument_list|,
literal|0
comment|/* parent+children */
argument_list|)
expr_stmt|;
comment|/* We may have been asked to return a list of what has been deleted */
if|if
condition|(
name|dellist
operator|!=
name|NULL
condition|)
block|{
operator|*
name|dellist
operator|=
name|xmalloc
argument_list|(
operator|(
name|delcount
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|*
name|dellist
expr_stmt|;
name|mycount
operator|=
name|delcount
expr_stmt|;
operator|*
name|cp
operator|=
name|cppop
argument_list|(
operator|&
name|result
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|cp
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|mycount
operator|>
literal|0
operator|)
condition|)
block|{
name|mycount
operator|--
expr_stmt|;
name|cp
operator|++
expr_stmt|;
operator|*
name|cp
operator|=
name|cppop
argument_list|(
operator|&
name|result
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mycount
operator|||
operator|(
operator|*
name|cp
operator|!=
name|NULL
operator|)
condition|)
name|warning
argument_list|(
literal|"varobj_delete: assertion failed - mycount(=%d)<> 0"
argument_list|,
name|mycount
argument_list|)
expr_stmt|;
block|}
return|return
name|delcount
return|;
block|}
end_function

begin_comment
comment|/* Set/Get variable object display format */
end_comment

begin_function
name|enum
name|varobj_display_formats
name|varobj_set_display_format
parameter_list|(
name|struct
name|varobj
modifier|*
name|var
parameter_list|,
name|enum
name|varobj_display_formats
name|format
parameter_list|)
block|{
switch|switch
condition|(
name|format
condition|)
block|{
case|case
name|FORMAT_NATURAL
case|:
case|case
name|FORMAT_BINARY
case|:
case|case
name|FORMAT_DECIMAL
case|:
case|case
name|FORMAT_HEXADECIMAL
case|:
case|case
name|FORMAT_OCTAL
case|:
name|var
operator|->
name|format
operator|=
name|format
expr_stmt|;
break|break;
default|default:
name|var
operator|->
name|format
operator|=
name|variable_default_display
argument_list|(
name|var
argument_list|)
expr_stmt|;
block|}
return|return
name|var
operator|->
name|format
return|;
block|}
end_function

begin_function
name|enum
name|varobj_display_formats
name|varobj_get_display_format
parameter_list|(
name|struct
name|varobj
modifier|*
name|var
parameter_list|)
block|{
return|return
name|var
operator|->
name|format
return|;
block|}
end_function

begin_function
name|int
name|varobj_get_num_children
parameter_list|(
name|struct
name|varobj
modifier|*
name|var
parameter_list|)
block|{
if|if
condition|(
name|var
operator|->
name|num_children
operator|==
operator|-
literal|1
condition|)
name|var
operator|->
name|num_children
operator|=
name|number_of_children
argument_list|(
name|var
argument_list|)
expr_stmt|;
return|return
name|var
operator|->
name|num_children
return|;
block|}
end_function

begin_comment
comment|/* Creates a list of the immediate children of a variable object;    the return code is the number of such children or -1 on error */
end_comment

begin_function
name|int
name|varobj_list_children
parameter_list|(
name|struct
name|varobj
modifier|*
name|var
parameter_list|,
name|struct
name|varobj
modifier|*
modifier|*
modifier|*
name|childlist
parameter_list|)
block|{
name|struct
name|varobj
modifier|*
name|child
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* sanity check: have we been passed a pointer? */
if|if
condition|(
name|childlist
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
operator|*
name|childlist
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|var
operator|->
name|num_children
operator|==
operator|-
literal|1
condition|)
name|var
operator|->
name|num_children
operator|=
name|number_of_children
argument_list|(
name|var
argument_list|)
expr_stmt|;
comment|/* List of children */
operator|*
name|childlist
operator|=
name|xmalloc
argument_list|(
operator|(
name|var
operator|->
name|num_children
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|varobj
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|var
operator|->
name|num_children
condition|;
name|i
operator|++
control|)
block|{
comment|/* Mark as the end in case we bail out */
operator|*
operator|(
operator|(
operator|*
name|childlist
operator|)
operator|+
name|i
operator|)
operator|=
name|NULL
expr_stmt|;
comment|/* check if child exists, if not create */
name|name
operator|=
name|name_of_child
argument_list|(
name|var
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|child
operator|=
name|child_exists
argument_list|(
name|var
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|==
name|NULL
condition|)
name|child
operator|=
name|create_child
argument_list|(
name|var
argument_list|,
name|i
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|(
operator|*
name|childlist
operator|)
operator|+
name|i
operator|)
operator|=
name|child
expr_stmt|;
block|}
comment|/* End of list is marked by a NULL pointer */
operator|*
operator|(
operator|(
operator|*
name|childlist
operator|)
operator|+
name|i
operator|)
operator|=
name|NULL
expr_stmt|;
return|return
name|var
operator|->
name|num_children
return|;
block|}
end_function

begin_comment
comment|/* Obtain the type of an object Variable as a string similar to the one gdb    prints on the console */
end_comment

begin_function
name|char
modifier|*
name|varobj_get_type
parameter_list|(
name|struct
name|varobj
modifier|*
name|var
parameter_list|)
block|{
name|struct
name|value
modifier|*
name|val
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|struct
name|ui_file
modifier|*
name|stb
decl_stmt|;
name|char
modifier|*
name|thetype
decl_stmt|;
name|long
name|length
decl_stmt|;
comment|/* For the "fake" variables, do not return a type. (It's type is      NULL, too.) */
if|if
condition|(
name|CPLUS_FAKE_CHILD
argument_list|(
name|var
argument_list|)
condition|)
return|return
name|NULL
return|;
name|stb
operator|=
name|mem_fileopen
argument_list|()
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup_ui_file_delete
argument_list|(
name|stb
argument_list|)
expr_stmt|;
comment|/* To print the type, we simply create a zero ``struct value *'' and      cast it to our type. We then typeprint this variable. */
name|val
operator|=
name|value_zero
argument_list|(
name|var
operator|->
name|type
argument_list|,
name|not_lval
argument_list|)
expr_stmt|;
name|type_print
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|,
literal|""
argument_list|,
name|stb
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|thetype
operator|=
name|ui_file_xstrdup
argument_list|(
name|stb
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
name|thetype
return|;
block|}
end_function

begin_function
name|enum
name|varobj_languages
name|varobj_get_language
parameter_list|(
name|struct
name|varobj
modifier|*
name|var
parameter_list|)
block|{
return|return
name|variable_language
argument_list|(
name|var
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|varobj_get_attributes
parameter_list|(
name|struct
name|varobj
modifier|*
name|var
parameter_list|)
block|{
name|int
name|attributes
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|variable_editable
argument_list|(
name|var
argument_list|)
condition|)
comment|/* FIXME: define masks for attributes */
name|attributes
operator||=
literal|0x00000001
expr_stmt|;
comment|/* Editable */
return|return
name|attributes
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|varobj_get_value
parameter_list|(
name|struct
name|varobj
modifier|*
name|var
parameter_list|)
block|{
return|return
name|my_value_of_variable
argument_list|(
name|var
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Set the value of an object variable (if it is editable) to the    value of the given expression */
end_comment

begin_comment
comment|/* Note: Invokes functions that can call error() */
end_comment

begin_function
name|int
name|varobj_set_value
parameter_list|(
name|struct
name|varobj
modifier|*
name|var
parameter_list|,
name|char
modifier|*
name|expression
parameter_list|)
block|{
name|struct
name|value
modifier|*
name|val
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
comment|/* The argument "expression" contains the variable's new value.      We need to first construct a legal expression for this -- ugh! */
comment|/* Does this cover all the bases? */
name|struct
name|expression
modifier|*
name|exp
decl_stmt|;
name|struct
name|value
modifier|*
name|value
decl_stmt|;
name|int
name|saved_input_radix
init|=
name|input_radix
decl_stmt|;
if|if
condition|(
name|var
operator|->
name|value
operator|!=
name|NULL
operator|&&
name|variable_editable
argument_list|(
name|var
argument_list|)
operator|&&
operator|!
name|var
operator|->
name|error
condition|)
block|{
name|char
modifier|*
name|s
init|=
name|expression
decl_stmt|;
name|int
name|i
decl_stmt|;
name|input_radix
operator|=
literal|10
expr_stmt|;
comment|/* ALWAYS reset to decimal temporarily */
if|if
condition|(
operator|!
name|gdb_parse_exp_1
argument_list|(
operator|&
name|s
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|exp
argument_list|)
condition|)
comment|/* We cannot proceed without a well-formed expression. */
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|gdb_evaluate_expression
argument_list|(
name|exp
argument_list|,
operator|&
name|value
argument_list|)
condition|)
block|{
comment|/* We cannot proceed without a valid expression. */
name|xfree
argument_list|(
name|exp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|gdb_value_assign
argument_list|(
name|var
operator|->
name|value
argument_list|,
name|value
argument_list|,
operator|&
name|val
argument_list|)
condition|)
return|return
literal|0
return|;
name|value_free
argument_list|(
name|var
operator|->
name|value
argument_list|)
expr_stmt|;
name|release_value
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|var
operator|->
name|value
operator|=
name|val
expr_stmt|;
name|input_radix
operator|=
name|saved_input_radix
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns a malloc'ed list with all root variable objects */
end_comment

begin_function
name|int
name|varobj_list
parameter_list|(
name|struct
name|varobj
modifier|*
modifier|*
modifier|*
name|varlist
parameter_list|)
block|{
name|struct
name|varobj
modifier|*
modifier|*
name|cv
decl_stmt|;
name|struct
name|varobj_root
modifier|*
name|croot
decl_stmt|;
name|int
name|mycount
init|=
name|rootcount
decl_stmt|;
comment|/* Alloc (rootcount + 1) entries for the result */
operator|*
name|varlist
operator|=
name|xmalloc
argument_list|(
operator|(
name|rootcount
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|varobj
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|cv
operator|=
operator|*
name|varlist
expr_stmt|;
name|croot
operator|=
name|rootlist
expr_stmt|;
while|while
condition|(
operator|(
name|croot
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|mycount
operator|>
literal|0
operator|)
condition|)
block|{
operator|*
name|cv
operator|=
name|croot
operator|->
name|rootvar
expr_stmt|;
name|mycount
operator|--
expr_stmt|;
name|cv
operator|++
expr_stmt|;
name|croot
operator|=
name|croot
operator|->
name|next
expr_stmt|;
block|}
comment|/* Mark the end of the list */
operator|*
name|cv
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|mycount
operator|||
operator|(
name|croot
operator|!=
name|NULL
operator|)
condition|)
name|warning
argument_list|(
literal|"varobj_list: assertion failed - wrong tally of root vars (%d:%d)"
argument_list|,
name|rootcount
argument_list|,
name|mycount
argument_list|)
expr_stmt|;
return|return
name|rootcount
return|;
block|}
end_function

begin_comment
comment|/* Update the values for a variable and its children.  This is a    two-pronged attack.  First, re-parse the value for the root's    expression to see if it's changed.  Then go all the way    through its children, reconstructing them and noting if they've    changed.    Return value:     -1 if there was an error updating the varobj     -2 if the type changed     Otherwise it is the number of children + parent changed     Only root variables can be updated...      NOTE: This function may delete the caller's varobj. If it    returns -2, then it has done this and VARP will be modified    to point to the new varobj. */
end_comment

begin_function
name|int
name|varobj_update
parameter_list|(
name|struct
name|varobj
modifier|*
modifier|*
name|varp
parameter_list|,
name|struct
name|varobj
modifier|*
modifier|*
modifier|*
name|changelist
parameter_list|)
block|{
name|int
name|changed
init|=
literal|0
decl_stmt|;
name|int
name|type_changed
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|vleft
decl_stmt|;
name|int
name|error2
decl_stmt|;
name|struct
name|varobj
modifier|*
name|v
decl_stmt|;
name|struct
name|varobj
modifier|*
modifier|*
name|cv
decl_stmt|;
name|struct
name|varobj
modifier|*
modifier|*
name|templist
init|=
name|NULL
decl_stmt|;
name|struct
name|value
modifier|*
name|new
decl_stmt|;
name|struct
name|vstack
modifier|*
name|stack
init|=
name|NULL
decl_stmt|;
name|struct
name|vstack
modifier|*
name|result
init|=
name|NULL
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|old_fi
decl_stmt|;
comment|/* sanity check: have we been passed a pointer? */
if|if
condition|(
name|changelist
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
comment|/*  Only root variables can be updated... */
if|if
condition|(
operator|(
operator|*
name|varp
operator|)
operator|->
name|root
operator|->
name|rootvar
operator|!=
operator|*
name|varp
condition|)
comment|/* Not a root var */
return|return
operator|-
literal|1
return|;
comment|/* Save the selected stack frame, since we will need to change it      in order to evaluate expressions. */
name|old_fi
operator|=
name|selected_frame
expr_stmt|;
comment|/* Update the root variable. value_of_root can return NULL      if the variable is no longer around, i.e. we stepped out of      the frame in which a local existed. We are letting the       value_of_root variable dispose of the varobj if the type      has changed. */
name|type_changed
operator|=
literal|1
expr_stmt|;
name|new
operator|=
name|value_of_root
argument_list|(
name|varp
argument_list|,
operator|&
name|type_changed
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|==
name|NULL
condition|)
block|{
operator|(
operator|*
name|varp
operator|)
operator|->
name|error
operator|=
literal|1
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Initialize a stack for temporary results */
name|vpush
argument_list|(
operator|&
name|result
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* If this is a "use_selected_frame" varobj, and its type has changed,      them note that it's changed. */
if|if
condition|(
name|type_changed
condition|)
block|{
name|vpush
argument_list|(
operator|&
name|result
argument_list|,
operator|*
name|varp
argument_list|)
expr_stmt|;
name|changed
operator|++
expr_stmt|;
block|}
comment|/* If values are not equal, note that it's changed.      There a couple of exceptions here, though.      We don't want some types to be reported as "changed". */
elseif|else
if|if
condition|(
name|type_changeable
argument_list|(
operator|*
name|varp
argument_list|)
operator|&&
operator|!
name|my_value_equal
argument_list|(
operator|(
operator|*
name|varp
operator|)
operator|->
name|value
argument_list|,
name|new
argument_list|,
operator|&
name|error2
argument_list|)
condition|)
block|{
name|vpush
argument_list|(
operator|&
name|result
argument_list|,
operator|*
name|varp
argument_list|)
expr_stmt|;
name|changed
operator|++
expr_stmt|;
comment|/* error2 replaces var->error since this new value          WILL replace the old one. */
operator|(
operator|*
name|varp
operator|)
operator|->
name|error
operator|=
name|error2
expr_stmt|;
block|}
comment|/* We must always keep around the new value for this root      variable expression, or we lose the updated children! */
name|value_free
argument_list|(
operator|(
operator|*
name|varp
operator|)
operator|->
name|value
argument_list|)
expr_stmt|;
operator|(
operator|*
name|varp
operator|)
operator|->
name|value
operator|=
name|new
expr_stmt|;
comment|/* Initialize a stack */
name|vpush
argument_list|(
operator|&
name|stack
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Push the root's children */
if|if
condition|(
operator|(
operator|*
name|varp
operator|)
operator|->
name|children
operator|!=
name|NULL
condition|)
block|{
name|struct
name|varobj_child
modifier|*
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
operator|(
operator|*
name|varp
operator|)
operator|->
name|children
init|;
name|c
operator|!=
name|NULL
condition|;
name|c
operator|=
name|c
operator|->
name|next
control|)
name|vpush
argument_list|(
operator|&
name|stack
argument_list|,
name|c
operator|->
name|child
argument_list|)
expr_stmt|;
block|}
comment|/* Walk through the children, reconstructing them all. */
name|v
operator|=
name|vpop
argument_list|(
operator|&
name|stack
argument_list|)
expr_stmt|;
while|while
condition|(
name|v
operator|!=
name|NULL
condition|)
block|{
comment|/* Push any children */
if|if
condition|(
name|v
operator|->
name|children
operator|!=
name|NULL
condition|)
block|{
name|struct
name|varobj_child
modifier|*
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
name|v
operator|->
name|children
init|;
name|c
operator|!=
name|NULL
condition|;
name|c
operator|=
name|c
operator|->
name|next
control|)
name|vpush
argument_list|(
operator|&
name|stack
argument_list|,
name|c
operator|->
name|child
argument_list|)
expr_stmt|;
block|}
comment|/* Update this variable */
name|new
operator|=
name|value_of_child
argument_list|(
name|v
operator|->
name|parent
argument_list|,
name|v
operator|->
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|type_changeable
argument_list|(
name|v
argument_list|)
operator|&&
operator|!
name|my_value_equal
argument_list|(
name|v
operator|->
name|value
argument_list|,
name|new
argument_list|,
operator|&
name|error2
argument_list|)
condition|)
block|{
comment|/* Note that it's changed */
name|vpush
argument_list|(
operator|&
name|result
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|changed
operator|++
expr_stmt|;
block|}
comment|/* error2 replaces v->error since this new value          WILL replace the old one. */
name|v
operator|->
name|error
operator|=
name|error2
expr_stmt|;
comment|/* We must always keep new values, since children depend on it. */
if|if
condition|(
name|v
operator|->
name|value
operator|!=
name|NULL
condition|)
name|value_free
argument_list|(
name|v
operator|->
name|value
argument_list|)
expr_stmt|;
name|v
operator|->
name|value
operator|=
name|new
expr_stmt|;
comment|/* Get next child */
name|v
operator|=
name|vpop
argument_list|(
operator|&
name|stack
argument_list|)
expr_stmt|;
block|}
comment|/* Alloc (changed + 1) list entries */
comment|/* FIXME: add a cleanup for the allocated list(s)      because one day the select_frame called below can longjump */
operator|*
name|changelist
operator|=
name|xmalloc
argument_list|(
operator|(
name|changed
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|varobj
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|changed
operator|>
literal|1
condition|)
block|{
name|templist
operator|=
name|xmalloc
argument_list|(
operator|(
name|changed
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|varobj
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|cv
operator|=
name|templist
expr_stmt|;
block|}
else|else
name|cv
operator|=
operator|*
name|changelist
expr_stmt|;
comment|/* Copy from result stack to list */
name|vleft
operator|=
name|changed
expr_stmt|;
operator|*
name|cv
operator|=
name|vpop
argument_list|(
operator|&
name|result
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|cv
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|vleft
operator|>
literal|0
operator|)
condition|)
block|{
name|vleft
operator|--
expr_stmt|;
name|cv
operator|++
expr_stmt|;
operator|*
name|cv
operator|=
name|vpop
argument_list|(
operator|&
name|result
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vleft
condition|)
name|warning
argument_list|(
literal|"varobj_update: assertion failed - vleft<> 0"
argument_list|)
expr_stmt|;
if|if
condition|(
name|changed
operator|>
literal|1
condition|)
block|{
comment|/* Now we revert the order. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|changed
condition|;
name|i
operator|++
control|)
operator|*
operator|(
operator|*
name|changelist
operator|+
name|i
operator|)
operator|=
operator|*
operator|(
name|templist
operator|+
name|changed
operator|-
literal|1
operator|-
name|i
operator|)
expr_stmt|;
operator|*
operator|(
operator|*
name|changelist
operator|+
name|changed
operator|)
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Restore selected frame */
name|select_frame
argument_list|(
name|old_fi
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|type_changed
condition|)
return|return
operator|-
literal|2
return|;
else|else
return|return
name|changed
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Helper functions */
end_comment

begin_comment
comment|/*  * Variable object construction/destruction  */
end_comment

begin_function
specifier|static
name|int
name|delete_variable
parameter_list|(
name|struct
name|cpstack
modifier|*
modifier|*
name|resultp
parameter_list|,
name|struct
name|varobj
modifier|*
name|var
parameter_list|,
name|int
name|only_children_p
parameter_list|)
block|{
name|int
name|delcount
init|=
literal|0
decl_stmt|;
name|delete_variable_1
argument_list|(
name|resultp
argument_list|,
operator|&
name|delcount
argument_list|,
name|var
argument_list|,
name|only_children_p
argument_list|,
literal|1
comment|/* remove_from_parent_p */
argument_list|)
expr_stmt|;
return|return
name|delcount
return|;
block|}
end_function

begin_comment
comment|/* Delete the variable object VAR and its children */
end_comment

begin_comment
comment|/* IMPORTANT NOTE: If we delete a variable which is a child    and the parent is not removed we dump core.  It must be always    initially called with remove_from_parent_p set */
end_comment

begin_function
specifier|static
name|void
name|delete_variable_1
parameter_list|(
name|struct
name|cpstack
modifier|*
modifier|*
name|resultp
parameter_list|,
name|int
modifier|*
name|delcountp
parameter_list|,
name|struct
name|varobj
modifier|*
name|var
parameter_list|,
name|int
name|only_children_p
parameter_list|,
name|int
name|remove_from_parent_p
parameter_list|)
block|{
name|struct
name|varobj_child
modifier|*
name|vc
decl_stmt|;
name|struct
name|varobj_child
modifier|*
name|next
decl_stmt|;
comment|/* Delete any children of this variable, too. */
for|for
control|(
name|vc
operator|=
name|var
operator|->
name|children
init|;
name|vc
operator|!=
name|NULL
condition|;
name|vc
operator|=
name|next
control|)
block|{
if|if
condition|(
operator|!
name|remove_from_parent_p
condition|)
name|vc
operator|->
name|child
operator|->
name|parent
operator|=
name|NULL
expr_stmt|;
name|delete_variable_1
argument_list|(
name|resultp
argument_list|,
name|delcountp
argument_list|,
name|vc
operator|->
name|child
argument_list|,
literal|0
argument_list|,
name|only_children_p
argument_list|)
expr_stmt|;
name|next
operator|=
name|vc
operator|->
name|next
expr_stmt|;
name|xfree
argument_list|(
name|vc
argument_list|)
expr_stmt|;
block|}
comment|/* if we were called to delete only the children we are done here */
if|if
condition|(
name|only_children_p
condition|)
return|return;
comment|/* Otherwise, add it to the list of deleted ones and proceed to do so */
comment|/* If the name is null, this is a temporary variable, that has not      yet been installed, don't report it, it belongs to the caller... */
if|if
condition|(
name|var
operator|->
name|obj_name
operator|!=
name|NULL
condition|)
block|{
name|cppush
argument_list|(
name|resultp
argument_list|,
name|xstrdup
argument_list|(
name|var
operator|->
name|obj_name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|delcountp
operator|=
operator|*
name|delcountp
operator|+
literal|1
expr_stmt|;
block|}
comment|/* If this variable has a parent, remove it from its parent's list */
comment|/* OPTIMIZATION: if the parent of this variable is also being deleted,       (as indicated by remove_from_parent_p) we don't bother doing an      expensive list search to find the element to remove when we are      discarding the list afterwards */
if|if
condition|(
operator|(
name|remove_from_parent_p
operator|)
operator|&&
operator|(
name|var
operator|->
name|parent
operator|!=
name|NULL
operator|)
condition|)
block|{
name|remove_child_from_parent
argument_list|(
name|var
operator|->
name|parent
argument_list|,
name|var
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|var
operator|->
name|obj_name
operator|!=
name|NULL
condition|)
name|uninstall_variable
argument_list|(
name|var
argument_list|)
expr_stmt|;
comment|/* Free memory associated with this variable */
name|free_variable
argument_list|(
name|var
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Install the given variable VAR with the object name VAR->OBJ_NAME. */
end_comment

begin_function
specifier|static
name|int
name|install_variable
parameter_list|(
name|struct
name|varobj
modifier|*
name|var
parameter_list|)
block|{
name|struct
name|vlist
modifier|*
name|cv
decl_stmt|;
name|struct
name|vlist
modifier|*
name|newvl
decl_stmt|;
specifier|const
name|char
modifier|*
name|chp
decl_stmt|;
name|unsigned
name|int
name|index
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|i
init|=
literal|1
decl_stmt|;
for|for
control|(
name|chp
operator|=
name|var
operator|->
name|obj_name
init|;
operator|*
name|chp
condition|;
name|chp
operator|++
control|)
block|{
name|index
operator|=
operator|(
name|index
operator|+
operator|(
name|i
operator|++
operator|*
operator|(
name|unsigned
name|int
operator|)
operator|*
name|chp
operator|)
operator|)
operator|%
name|VAROBJ_TABLE_SIZE
expr_stmt|;
block|}
name|cv
operator|=
operator|*
operator|(
name|varobj_table
operator|+
name|index
operator|)
expr_stmt|;
while|while
condition|(
operator|(
name|cv
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|cv
operator|->
name|var
operator|->
name|obj_name
argument_list|,
name|var
operator|->
name|obj_name
argument_list|)
operator|!=
literal|0
operator|)
condition|)
name|cv
operator|=
name|cv
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|cv
operator|!=
name|NULL
condition|)
name|error
argument_list|(
literal|"Duplicate variable object name"
argument_list|)
expr_stmt|;
comment|/* Add varobj to hash table */
name|newvl
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|vlist
argument_list|)
argument_list|)
expr_stmt|;
name|newvl
operator|->
name|next
operator|=
operator|*
operator|(
name|varobj_table
operator|+
name|index
operator|)
expr_stmt|;
name|newvl
operator|->
name|var
operator|=
name|var
expr_stmt|;
operator|*
operator|(
name|varobj_table
operator|+
name|index
operator|)
operator|=
name|newvl
expr_stmt|;
comment|/* If root, add varobj to root list */
if|if
condition|(
name|var
operator|->
name|root
operator|->
name|rootvar
operator|==
name|var
condition|)
block|{
comment|/* Add to list of root variables */
if|if
condition|(
name|rootlist
operator|==
name|NULL
condition|)
name|var
operator|->
name|root
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
else|else
name|var
operator|->
name|root
operator|->
name|next
operator|=
name|rootlist
expr_stmt|;
name|rootlist
operator|=
name|var
operator|->
name|root
expr_stmt|;
name|rootcount
operator|++
expr_stmt|;
block|}
return|return
literal|1
return|;
comment|/* OK */
block|}
end_function

begin_comment
comment|/* Unistall the object VAR. */
end_comment

begin_function
specifier|static
name|void
name|uninstall_variable
parameter_list|(
name|struct
name|varobj
modifier|*
name|var
parameter_list|)
block|{
name|struct
name|vlist
modifier|*
name|cv
decl_stmt|;
name|struct
name|vlist
modifier|*
name|prev
decl_stmt|;
name|struct
name|varobj_root
modifier|*
name|cr
decl_stmt|;
name|struct
name|varobj_root
modifier|*
name|prer
decl_stmt|;
specifier|const
name|char
modifier|*
name|chp
decl_stmt|;
name|unsigned
name|int
name|index
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|i
init|=
literal|1
decl_stmt|;
comment|/* Remove varobj from hash table */
for|for
control|(
name|chp
operator|=
name|var
operator|->
name|obj_name
init|;
operator|*
name|chp
condition|;
name|chp
operator|++
control|)
block|{
name|index
operator|=
operator|(
name|index
operator|+
operator|(
name|i
operator|++
operator|*
operator|(
name|unsigned
name|int
operator|)
operator|*
name|chp
operator|)
operator|)
operator|%
name|VAROBJ_TABLE_SIZE
expr_stmt|;
block|}
name|cv
operator|=
operator|*
operator|(
name|varobj_table
operator|+
name|index
operator|)
expr_stmt|;
name|prev
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|cv
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|cv
operator|->
name|var
operator|->
name|obj_name
argument_list|,
name|var
operator|->
name|obj_name
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|prev
operator|=
name|cv
expr_stmt|;
name|cv
operator|=
name|cv
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|varobjdebug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"Deleting %s\n"
argument_list|,
name|var
operator|->
name|obj_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|cv
operator|==
name|NULL
condition|)
block|{
name|warning
argument_list|(
literal|"Assertion failed: Could not find variable object \"%s\" to delete"
argument_list|,
name|var
operator|->
name|obj_name
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|prev
operator|==
name|NULL
condition|)
operator|*
operator|(
name|varobj_table
operator|+
name|index
operator|)
operator|=
name|cv
operator|->
name|next
expr_stmt|;
else|else
name|prev
operator|->
name|next
operator|=
name|cv
operator|->
name|next
expr_stmt|;
name|xfree
argument_list|(
name|cv
argument_list|)
expr_stmt|;
comment|/* If root, remove varobj from root list */
if|if
condition|(
name|var
operator|->
name|root
operator|->
name|rootvar
operator|==
name|var
condition|)
block|{
comment|/* Remove from list of root variables */
if|if
condition|(
name|rootlist
operator|==
name|var
operator|->
name|root
condition|)
name|rootlist
operator|=
name|var
operator|->
name|root
operator|->
name|next
expr_stmt|;
else|else
block|{
name|prer
operator|=
name|NULL
expr_stmt|;
name|cr
operator|=
name|rootlist
expr_stmt|;
while|while
condition|(
operator|(
name|cr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|cr
operator|->
name|rootvar
operator|!=
name|var
operator|)
condition|)
block|{
name|prer
operator|=
name|cr
expr_stmt|;
name|cr
operator|=
name|cr
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|cr
operator|==
name|NULL
condition|)
block|{
name|warning
argument_list|(
literal|"Assertion failed: Could not find varobj \"%s\" in root list"
argument_list|,
name|var
operator|->
name|obj_name
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|prer
operator|==
name|NULL
condition|)
name|rootlist
operator|=
name|NULL
expr_stmt|;
else|else
name|prer
operator|->
name|next
operator|=
name|cr
operator|->
name|next
expr_stmt|;
block|}
name|rootcount
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Does a child with the name NAME exist in VAR? If so, return its data.    If not, return NULL. */
end_comment

begin_function
specifier|static
name|struct
name|varobj
modifier|*
name|child_exists
parameter_list|(
name|struct
name|varobj
modifier|*
name|var
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|varobj_child
modifier|*
name|vc
decl_stmt|;
for|for
control|(
name|vc
operator|=
name|var
operator|->
name|children
init|;
name|vc
operator|!=
name|NULL
condition|;
name|vc
operator|=
name|vc
operator|->
name|next
control|)
block|{
if|if
condition|(
name|STREQ
argument_list|(
name|vc
operator|->
name|child
operator|->
name|name
argument_list|,
name|name
argument_list|)
condition|)
return|return
name|vc
operator|->
name|child
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Create and install a child of the parent of the given name */
end_comment

begin_function
specifier|static
name|struct
name|varobj
modifier|*
name|create_child
parameter_list|(
name|struct
name|varobj
modifier|*
name|parent
parameter_list|,
name|int
name|index
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|varobj
modifier|*
name|child
decl_stmt|;
name|char
modifier|*
name|childs_name
decl_stmt|;
name|child
operator|=
name|new_variable
argument_list|()
expr_stmt|;
comment|/* name is allocated by name_of_child */
name|child
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|child
operator|->
name|index
operator|=
name|index
expr_stmt|;
name|child
operator|->
name|value
operator|=
name|value_of_child
argument_list|(
name|parent
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|CPLUS_FAKE_CHILD
argument_list|(
name|child
argument_list|)
operator|&&
name|child
operator|->
name|value
operator|==
name|NULL
operator|)
operator|||
name|parent
operator|->
name|error
condition|)
name|child
operator|->
name|error
operator|=
literal|1
expr_stmt|;
name|child
operator|->
name|parent
operator|=
name|parent
expr_stmt|;
name|child
operator|->
name|root
operator|=
name|parent
operator|->
name|root
expr_stmt|;
name|childs_name
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|strlen
argument_list|(
name|parent
operator|->
name|obj_name
argument_list|)
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|childs_name
argument_list|,
literal|"%s.%s"
argument_list|,
name|parent
operator|->
name|obj_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|child
operator|->
name|obj_name
operator|=
name|childs_name
expr_stmt|;
name|install_variable
argument_list|(
name|child
argument_list|)
expr_stmt|;
comment|/* Save a pointer to this child in the parent */
name|save_child_in_parent
argument_list|(
name|parent
argument_list|,
name|child
argument_list|)
expr_stmt|;
comment|/* Note the type of this child */
name|child
operator|->
name|type
operator|=
name|type_of_child
argument_list|(
name|child
argument_list|)
expr_stmt|;
return|return
name|child
return|;
block|}
end_function

begin_comment
comment|/* FIXME: This should be a generic add to list */
end_comment

begin_comment
comment|/* Save CHILD in the PARENT's data. */
end_comment

begin_function
specifier|static
name|void
name|save_child_in_parent
parameter_list|(
name|struct
name|varobj
modifier|*
name|parent
parameter_list|,
name|struct
name|varobj
modifier|*
name|child
parameter_list|)
block|{
name|struct
name|varobj_child
modifier|*
name|vc
decl_stmt|;
comment|/* Insert the child at the top */
name|vc
operator|=
name|parent
operator|->
name|children
expr_stmt|;
name|parent
operator|->
name|children
operator|=
operator|(
expr|struct
name|varobj_child
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|varobj_child
argument_list|)
argument_list|)
expr_stmt|;
name|parent
operator|->
name|children
operator|->
name|next
operator|=
name|vc
expr_stmt|;
name|parent
operator|->
name|children
operator|->
name|child
operator|=
name|child
expr_stmt|;
block|}
end_function

begin_comment
comment|/* FIXME: This should be a generic remove from list */
end_comment

begin_comment
comment|/* Remove the CHILD from the PARENT's list of children. */
end_comment

begin_function
specifier|static
name|void
name|remove_child_from_parent
parameter_list|(
name|struct
name|varobj
modifier|*
name|parent
parameter_list|,
name|struct
name|varobj
modifier|*
name|child
parameter_list|)
block|{
name|struct
name|varobj_child
modifier|*
name|vc
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
comment|/* Find the child in the parent's list */
name|prev
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|vc
operator|=
name|parent
operator|->
name|children
init|;
name|vc
operator|!=
name|NULL
condition|;
control|)
block|{
if|if
condition|(
name|vc
operator|->
name|child
operator|==
name|child
condition|)
break|break;
name|prev
operator|=
name|vc
expr_stmt|;
name|vc
operator|=
name|vc
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|prev
operator|==
name|NULL
condition|)
name|parent
operator|->
name|children
operator|=
name|vc
operator|->
name|next
expr_stmt|;
else|else
name|prev
operator|->
name|next
operator|=
name|vc
operator|->
name|next
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Miscellaneous utility functions.  */
end_comment

begin_comment
comment|/* Allocate memory and initialize a new variable */
end_comment

begin_function
specifier|static
name|struct
name|varobj
modifier|*
name|new_variable
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|varobj
modifier|*
name|var
decl_stmt|;
name|var
operator|=
operator|(
expr|struct
name|varobj
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|varobj
argument_list|)
argument_list|)
expr_stmt|;
name|var
operator|->
name|name
operator|=
name|NULL
expr_stmt|;
name|var
operator|->
name|obj_name
operator|=
name|NULL
expr_stmt|;
name|var
operator|->
name|index
operator|=
operator|-
literal|1
expr_stmt|;
name|var
operator|->
name|type
operator|=
name|NULL
expr_stmt|;
name|var
operator|->
name|value
operator|=
name|NULL
expr_stmt|;
name|var
operator|->
name|error
operator|=
literal|0
expr_stmt|;
name|var
operator|->
name|num_children
operator|=
operator|-
literal|1
expr_stmt|;
name|var
operator|->
name|parent
operator|=
name|NULL
expr_stmt|;
name|var
operator|->
name|children
operator|=
name|NULL
expr_stmt|;
name|var
operator|->
name|format
operator|=
literal|0
expr_stmt|;
name|var
operator|->
name|root
operator|=
name|NULL
expr_stmt|;
return|return
name|var
return|;
block|}
end_function

begin_comment
comment|/* Allocate memory and initialize a new root variable */
end_comment

begin_function
specifier|static
name|struct
name|varobj
modifier|*
name|new_root_variable
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|varobj
modifier|*
name|var
init|=
name|new_variable
argument_list|()
decl_stmt|;
name|var
operator|->
name|root
operator|=
operator|(
expr|struct
name|varobj_root
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|varobj_root
argument_list|)
argument_list|)
expr_stmt|;
empty_stmt|;
name|var
operator|->
name|root
operator|->
name|lang
operator|=
name|NULL
expr_stmt|;
name|var
operator|->
name|root
operator|->
name|exp
operator|=
name|NULL
expr_stmt|;
name|var
operator|->
name|root
operator|->
name|valid_block
operator|=
name|NULL
expr_stmt|;
name|var
operator|->
name|root
operator|->
name|frame
operator|=
operator|(
name|CORE_ADDR
operator|)
operator|-
literal|1
expr_stmt|;
name|var
operator|->
name|root
operator|->
name|use_selected_frame
operator|=
literal|0
expr_stmt|;
name|var
operator|->
name|root
operator|->
name|rootvar
operator|=
name|NULL
expr_stmt|;
return|return
name|var
return|;
block|}
end_function

begin_comment
comment|/* Free any allocated memory associated with VAR. */
end_comment

begin_function
specifier|static
name|void
name|free_variable
parameter_list|(
name|struct
name|varobj
modifier|*
name|var
parameter_list|)
block|{
comment|/* Free the expression if this is a root variable. */
if|if
condition|(
name|var
operator|->
name|root
operator|->
name|rootvar
operator|==
name|var
condition|)
block|{
name|free_current_contents
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|var
operator|->
name|root
operator|->
name|exp
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|var
operator|->
name|root
argument_list|)
expr_stmt|;
block|}
name|xfree
argument_list|(
name|var
operator|->
name|name
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|var
operator|->
name|obj_name
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|var
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_free_variable_cleanup
parameter_list|(
name|void
modifier|*
name|var
parameter_list|)
block|{
name|free_variable
argument_list|(
name|var
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|cleanup
modifier|*
name|make_cleanup_free_variable
parameter_list|(
name|struct
name|varobj
modifier|*
name|var
parameter_list|)
block|{
return|return
name|make_cleanup
argument_list|(
name|do_free_variable_cleanup
argument_list|,
name|var
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* This returns the type of the variable. This skips past typedefs    and returns the real type of the variable. It also dereferences    pointers and references. */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|get_type
parameter_list|(
name|struct
name|varobj
modifier|*
name|var
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|type
operator|=
name|var
operator|->
name|type
expr_stmt|;
while|while
condition|(
name|type
operator|!=
name|NULL
operator|&&
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_TYPEDEF
condition|)
name|type
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* This returns the type of the variable, dereferencing pointers, too. */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|get_type_deref
parameter_list|(
name|struct
name|varobj
modifier|*
name|var
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|type
operator|=
name|get_type
argument_list|(
name|var
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|NULL
operator|&&
operator|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_PTR
operator|||
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_REF
operator|)
condition|)
name|type
operator|=
name|get_target_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* This returns the target type (or NULL) of TYPE, also skipping    past typedefs, just like get_type (). */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|get_target_type
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|!=
name|NULL
condition|)
block|{
name|type
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
while|while
condition|(
name|type
operator|!=
name|NULL
operator|&&
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_TYPEDEF
condition|)
name|type
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* What is the default display for this variable? We assume that    everything is "natural". Any exceptions? */
end_comment

begin_function
specifier|static
name|enum
name|varobj_display_formats
name|variable_default_display
parameter_list|(
name|struct
name|varobj
modifier|*
name|var
parameter_list|)
block|{
return|return
name|FORMAT_NATURAL
return|;
block|}
end_function

begin_comment
comment|/* This function is similar to gdb's value_equal, except that this    one is "safe" -- it NEVER longjmps. It determines if the VAR's    value is the same as VAL2. */
end_comment

begin_function
specifier|static
name|int
name|my_value_equal
parameter_list|(
name|struct
name|value
modifier|*
name|val1
parameter_list|,
name|struct
name|value
modifier|*
name|val2
parameter_list|,
name|int
modifier|*
name|error2
parameter_list|)
block|{
name|int
name|r
decl_stmt|,
name|err1
decl_stmt|,
name|err2
decl_stmt|;
operator|*
name|error2
operator|=
literal|0
expr_stmt|;
comment|/* Special case: NULL values. If both are null, say      they're equal. */
if|if
condition|(
name|val1
operator|==
name|NULL
operator|&&
name|val2
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|val1
operator|==
name|NULL
operator|||
name|val2
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* This is bogus, but unfortunately necessary. We must know      exactly what caused an error -- reading val1 or val2 --  so      that we can really determine if we think that something has changed. */
name|err1
operator|=
literal|0
expr_stmt|;
name|err2
operator|=
literal|0
expr_stmt|;
comment|/* We do need to catch errors here because the whole purpose      is to test if value_equal() has errored */
if|if
condition|(
operator|!
name|gdb_value_equal
argument_list|(
name|val1
argument_list|,
name|val1
argument_list|,
operator|&
name|r
argument_list|)
condition|)
name|err1
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|gdb_value_equal
argument_list|(
name|val2
argument_list|,
name|val2
argument_list|,
operator|&
name|r
argument_list|)
condition|)
operator|*
name|error2
operator|=
name|err2
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|err1
operator|!=
name|err2
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|gdb_value_equal
argument_list|(
name|val1
argument_list|,
name|val2
argument_list|,
operator|&
name|r
argument_list|)
condition|)
block|{
comment|/* An error occurred, this could have happened if          either val1 or val2 errored. ERR1 and ERR2 tell          us which of these it is. If both errored, then          we assume nothing has changed. If one of them is          valid, though, then something has changed. */
if|if
condition|(
name|err1
operator|==
name|err2
condition|)
block|{
comment|/* both the old and new values caused errors, so 	     we say the value did not change */
comment|/* This is indeterminate, though. Perhaps we should 	     be safe and say, yes, it changed anyway?? */
return|return
literal|1
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* FIXME: The following should be generic for any pointer */
end_comment

begin_function
specifier|static
name|void
name|vpush
parameter_list|(
name|struct
name|vstack
modifier|*
modifier|*
name|pstack
parameter_list|,
name|struct
name|varobj
modifier|*
name|var
parameter_list|)
block|{
name|struct
name|vstack
modifier|*
name|s
decl_stmt|;
name|s
operator|=
operator|(
expr|struct
name|vstack
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|vstack
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|var
operator|=
name|var
expr_stmt|;
name|s
operator|->
name|next
operator|=
operator|*
name|pstack
expr_stmt|;
operator|*
name|pstack
operator|=
name|s
expr_stmt|;
block|}
end_function

begin_comment
comment|/* FIXME: The following should be generic for any pointer */
end_comment

begin_function
specifier|static
name|struct
name|varobj
modifier|*
name|vpop
parameter_list|(
name|struct
name|vstack
modifier|*
modifier|*
name|pstack
parameter_list|)
block|{
name|struct
name|vstack
modifier|*
name|s
decl_stmt|;
name|struct
name|varobj
modifier|*
name|v
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|pstack
operator|)
operator|->
name|var
operator|==
name|NULL
operator|&&
operator|(
operator|*
name|pstack
operator|)
operator|->
name|next
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|s
operator|=
operator|*
name|pstack
expr_stmt|;
name|v
operator|=
name|s
operator|->
name|var
expr_stmt|;
operator|*
name|pstack
operator|=
operator|(
operator|*
name|pstack
operator|)
operator|->
name|next
expr_stmt|;
name|xfree
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|v
return|;
block|}
end_function

begin_comment
comment|/* FIXME: The following should be generic for any pointer */
end_comment

begin_function
specifier|static
name|void
name|cppush
parameter_list|(
name|struct
name|cpstack
modifier|*
modifier|*
name|pstack
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|cpstack
modifier|*
name|s
decl_stmt|;
name|s
operator|=
operator|(
expr|struct
name|cpstack
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|cpstack
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|s
operator|->
name|next
operator|=
operator|*
name|pstack
expr_stmt|;
operator|*
name|pstack
operator|=
name|s
expr_stmt|;
block|}
end_function

begin_comment
comment|/* FIXME: The following should be generic for any pointer */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|cppop
parameter_list|(
name|struct
name|cpstack
modifier|*
modifier|*
name|pstack
parameter_list|)
block|{
name|struct
name|cpstack
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|v
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|pstack
operator|)
operator|->
name|name
operator|==
name|NULL
operator|&&
operator|(
operator|*
name|pstack
operator|)
operator|->
name|next
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|s
operator|=
operator|*
name|pstack
expr_stmt|;
name|v
operator|=
name|s
operator|->
name|name
expr_stmt|;
operator|*
name|pstack
operator|=
operator|(
operator|*
name|pstack
operator|)
operator|->
name|next
expr_stmt|;
name|xfree
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|v
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Language-dependencies  */
end_comment

begin_comment
comment|/* Common entry points */
end_comment

begin_comment
comment|/* Get the language of variable VAR. */
end_comment

begin_function
specifier|static
name|enum
name|varobj_languages
name|variable_language
parameter_list|(
name|struct
name|varobj
modifier|*
name|var
parameter_list|)
block|{
name|enum
name|varobj_languages
name|lang
decl_stmt|;
switch|switch
condition|(
name|var
operator|->
name|root
operator|->
name|exp
operator|->
name|language_defn
operator|->
name|la_language
condition|)
block|{
default|default:
case|case
name|language_c
case|:
name|lang
operator|=
name|vlang_c
expr_stmt|;
break|break;
case|case
name|language_cplus
case|:
name|lang
operator|=
name|vlang_cplus
expr_stmt|;
break|break;
case|case
name|language_java
case|:
name|lang
operator|=
name|vlang_java
expr_stmt|;
break|break;
block|}
return|return
name|lang
return|;
block|}
end_function

begin_comment
comment|/* Return the number of children for a given variable.    The result of this function is defined by the language    implementation. The number of children returned by this function    is the number of children that the user will see in the variable    display. */
end_comment

begin_function
specifier|static
name|int
name|number_of_children
parameter_list|(
name|struct
name|varobj
modifier|*
name|var
parameter_list|)
block|{
return|return
call|(
modifier|*
name|var
operator|->
name|root
operator|->
name|lang
operator|->
name|number_of_children
call|)
argument_list|(
name|var
argument_list|)
return|;
empty_stmt|;
block|}
end_function

begin_comment
comment|/* What is the expression for the root varobj VAR? Returns a malloc'd string. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|name_of_variable
parameter_list|(
name|struct
name|varobj
modifier|*
name|var
parameter_list|)
block|{
return|return
call|(
modifier|*
name|var
operator|->
name|root
operator|->
name|lang
operator|->
name|name_of_variable
call|)
argument_list|(
name|var
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* What is the name of the INDEX'th child of VAR? Returns a malloc'd string. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|name_of_child
parameter_list|(
name|struct
name|varobj
modifier|*
name|var
parameter_list|,
name|int
name|index
parameter_list|)
block|{
return|return
call|(
modifier|*
name|var
operator|->
name|root
operator|->
name|lang
operator|->
name|name_of_child
call|)
argument_list|(
name|var
argument_list|,
name|index
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* What is the ``struct value *'' of the root variable VAR?     TYPE_CHANGED controls what to do if the type of a    use_selected_frame = 1 variable changes.  On input,    TYPE_CHANGED = 1 means discard the old varobj, and replace    it with this one.  TYPE_CHANGED = 0 means leave it around.    NB: In both cases, var_handle will point to the new varobj,    so if you use TYPE_CHANGED = 0, you will have to stash the    old varobj pointer away somewhere before calling this.    On return, TYPE_CHANGED will be 1 if the type has changed, and     0 otherwise. */
end_comment

begin_function
specifier|static
name|struct
name|value
modifier|*
name|value_of_root
parameter_list|(
name|struct
name|varobj
modifier|*
modifier|*
name|var_handle
parameter_list|,
name|int
modifier|*
name|type_changed
parameter_list|)
block|{
name|struct
name|varobj
modifier|*
name|var
decl_stmt|;
if|if
condition|(
name|var_handle
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|var
operator|=
operator|*
name|var_handle
expr_stmt|;
comment|/* This should really be an exception, since this should      only get called with a root variable. */
if|if
condition|(
name|var
operator|->
name|root
operator|->
name|rootvar
operator|!=
name|var
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|var
operator|->
name|root
operator|->
name|use_selected_frame
condition|)
block|{
name|struct
name|varobj
modifier|*
name|tmp_var
decl_stmt|;
name|char
modifier|*
name|old_type
decl_stmt|,
modifier|*
name|new_type
decl_stmt|;
name|old_type
operator|=
name|varobj_get_type
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|tmp_var
operator|=
name|varobj_create
argument_list|(
name|NULL
argument_list|,
name|var
operator|->
name|name
argument_list|,
operator|(
name|CORE_ADDR
operator|)
literal|0
argument_list|,
name|USE_SELECTED_FRAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp_var
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|new_type
operator|=
name|varobj_get_type
argument_list|(
name|tmp_var
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|old_type
argument_list|,
name|new_type
argument_list|)
operator|==
literal|0
condition|)
block|{
name|varobj_delete
argument_list|(
name|tmp_var
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|type_changed
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|type_changed
condition|)
block|{
name|tmp_var
operator|->
name|obj_name
operator|=
name|savestring
argument_list|(
name|var
operator|->
name|obj_name
argument_list|,
name|strlen
argument_list|(
name|var
operator|->
name|obj_name
argument_list|)
argument_list|)
expr_stmt|;
name|varobj_delete
argument_list|(
name|var
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tmp_var
operator|->
name|obj_name
operator|=
name|varobj_gen_name
argument_list|()
expr_stmt|;
block|}
name|install_variable
argument_list|(
name|tmp_var
argument_list|)
expr_stmt|;
operator|*
name|var_handle
operator|=
name|tmp_var
expr_stmt|;
name|var
operator|=
operator|*
name|var_handle
expr_stmt|;
operator|*
name|type_changed
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
operator|*
name|type_changed
operator|=
literal|0
expr_stmt|;
block|}
return|return
call|(
modifier|*
name|var
operator|->
name|root
operator|->
name|lang
operator|->
name|value_of_root
call|)
argument_list|(
name|var_handle
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* What is the ``struct value *'' for the INDEX'th child of PARENT? */
end_comment

begin_function
specifier|static
name|struct
name|value
modifier|*
name|value_of_child
parameter_list|(
name|struct
name|varobj
modifier|*
name|parent
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|struct
name|value
modifier|*
name|value
decl_stmt|;
name|value
operator|=
call|(
modifier|*
name|parent
operator|->
name|root
operator|->
name|lang
operator|->
name|value_of_child
call|)
argument_list|(
name|parent
argument_list|,
name|index
argument_list|)
expr_stmt|;
comment|/* If we're being lazy, fetch the real value of the variable. */
if|if
condition|(
name|value
operator|!=
name|NULL
operator|&&
name|VALUE_LAZY
argument_list|(
name|value
argument_list|)
condition|)
block|{
comment|/* If we fail to fetch the value of the child, return 	 NULL so that callers notice that we're leaving an 	 error message. */
if|if
condition|(
operator|!
name|gdb_value_fetch_lazy
argument_list|(
name|value
argument_list|)
condition|)
name|value
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|value
return|;
block|}
end_function

begin_comment
comment|/* What is the type of VAR? */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|type_of_child
parameter_list|(
name|struct
name|varobj
modifier|*
name|var
parameter_list|)
block|{
comment|/* If the child had no evaluation errors, var->value      will be non-NULL and contain a valid type. */
if|if
condition|(
name|var
operator|->
name|value
operator|!=
name|NULL
condition|)
return|return
name|VALUE_TYPE
argument_list|(
name|var
operator|->
name|value
argument_list|)
return|;
comment|/* Otherwise, we must compute the type. */
return|return
call|(
modifier|*
name|var
operator|->
name|root
operator|->
name|lang
operator|->
name|type_of_child
call|)
argument_list|(
name|var
operator|->
name|parent
argument_list|,
name|var
operator|->
name|index
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Is this variable editable? Use the variable's type to make    this determination. */
end_comment

begin_function
specifier|static
name|int
name|variable_editable
parameter_list|(
name|struct
name|varobj
modifier|*
name|var
parameter_list|)
block|{
return|return
call|(
modifier|*
name|var
operator|->
name|root
operator|->
name|lang
operator|->
name|variable_editable
call|)
argument_list|(
name|var
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* GDB already has a command called "value_of_variable". Sigh. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|my_value_of_variable
parameter_list|(
name|struct
name|varobj
modifier|*
name|var
parameter_list|)
block|{
return|return
call|(
modifier|*
name|var
operator|->
name|root
operator|->
name|lang
operator|->
name|value_of_variable
call|)
argument_list|(
name|var
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Is VAR something that can change? Depending on language,    some variable's values never change. For example,    struct and unions never change values. */
end_comment

begin_function
specifier|static
name|int
name|type_changeable
parameter_list|(
name|struct
name|varobj
modifier|*
name|var
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|struct
name|type
modifier|*
name|type
decl_stmt|;
if|if
condition|(
name|CPLUS_FAKE_CHILD
argument_list|(
name|var
argument_list|)
condition|)
return|return
literal|0
return|;
name|type
operator|=
name|get_type
argument_list|(
name|var
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_STRUCT
case|:
case|case
name|TYPE_CODE_UNION
case|:
case|case
name|TYPE_CODE_ARRAY
case|:
name|r
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|r
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* C */
end_comment

begin_function
specifier|static
name|int
name|c_number_of_children
parameter_list|(
name|struct
name|varobj
modifier|*
name|var
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|struct
name|type
modifier|*
name|target
decl_stmt|;
name|int
name|children
decl_stmt|;
name|type
operator|=
name|get_type
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|target
operator|=
name|get_target_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|children
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_ARRAY
case|:
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|>
literal|0
operator|&&
name|TYPE_LENGTH
argument_list|(
name|target
argument_list|)
operator|>
literal|0
operator|&&
name|TYPE_ARRAY_UPPER_BOUND_TYPE
argument_list|(
name|type
argument_list|)
operator|!=
name|BOUND_CANNOT_BE_DETERMINED
condition|)
name|children
operator|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|/
name|TYPE_LENGTH
argument_list|(
name|target
argument_list|)
expr_stmt|;
else|else
name|children
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_STRUCT
case|:
case|case
name|TYPE_CODE_UNION
case|:
name|children
operator|=
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_PTR
case|:
comment|/* This is where things get compilcated. All pointers have one child.          Except, of course, for struct and union ptr, which we automagically          dereference for the user and function ptrs, which have no children.          We also don't dereference void* as we don't know what to show.          We can show char* so we allow it to be dereferenced.  If you decide          to test for it, please mind that a little magic is necessary to          properly identify it: char* has TYPE_CODE == TYPE_CODE_INT and           TYPE_NAME == "char" */
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|target
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_STRUCT
case|:
case|case
name|TYPE_CODE_UNION
case|:
name|children
operator|=
name|TYPE_NFIELDS
argument_list|(
name|target
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_FUNC
case|:
case|case
name|TYPE_CODE_VOID
case|:
name|children
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|children
operator|=
literal|1
expr_stmt|;
block|}
break|break;
default|default:
comment|/* Other types have no children */
break|break;
block|}
return|return
name|children
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|c_name_of_variable
parameter_list|(
name|struct
name|varobj
modifier|*
name|parent
parameter_list|)
block|{
return|return
name|savestring
argument_list|(
name|parent
operator|->
name|name
argument_list|,
name|strlen
argument_list|(
name|parent
operator|->
name|name
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|c_name_of_child
parameter_list|(
name|struct
name|varobj
modifier|*
name|parent
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|struct
name|type
modifier|*
name|target
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|type
operator|=
name|get_type
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|target
operator|=
name|get_target_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_ARRAY
case|:
block|{
comment|/* We never get here unless parent->num_children is greater than 0... */
name|int
name|len
init|=
literal|1
decl_stmt|;
while|while
condition|(
operator|(
name|int
operator|)
name|pow
argument_list|(
operator|(
name|double
operator|)
literal|10
argument_list|,
operator|(
name|double
operator|)
name|len
argument_list|)
operator|<
name|index
condition|)
name|len
operator|++
expr_stmt|;
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|+
name|len
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"%d"
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_CODE_STRUCT
case|:
case|case
name|TYPE_CODE_UNION
case|:
name|string
operator|=
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|name
operator|=
name|savestring
argument_list|(
name|string
argument_list|,
name|strlen
argument_list|(
name|string
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_PTR
case|:
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|target
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_STRUCT
case|:
case|case
name|TYPE_CODE_UNION
case|:
name|string
operator|=
name|TYPE_FIELD_NAME
argument_list|(
name|target
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|name
operator|=
name|savestring
argument_list|(
name|string
argument_list|,
name|strlen
argument_list|(
name|string
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|strlen
argument_list|(
name|parent
operator|->
name|name
argument_list|)
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"*%s"
argument_list|,
name|parent
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
comment|/* This should not happen */
name|name
operator|=
name|xstrdup
argument_list|(
literal|"???"
argument_list|)
expr_stmt|;
block|}
return|return
name|name
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|value
modifier|*
name|c_value_of_root
parameter_list|(
name|struct
name|varobj
modifier|*
modifier|*
name|var_handle
parameter_list|)
block|{
name|struct
name|value
modifier|*
name|new_val
decl_stmt|;
name|struct
name|varobj
modifier|*
name|var
init|=
operator|*
name|var_handle
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
name|int
name|within_scope
decl_stmt|;
comment|/*  Only root variables can be updated... */
if|if
condition|(
name|var
operator|->
name|root
operator|->
name|rootvar
operator|!=
name|var
condition|)
comment|/* Not a root var */
return|return
name|NULL
return|;
comment|/* Determine whether the variable is still around. */
if|if
condition|(
name|var
operator|->
name|root
operator|->
name|valid_block
operator|==
name|NULL
condition|)
name|within_scope
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|reinit_frame_cache
argument_list|()
expr_stmt|;
name|fi
operator|=
name|find_frame_addr_in_frame_chain
argument_list|(
name|var
operator|->
name|root
operator|->
name|frame
argument_list|)
expr_stmt|;
name|within_scope
operator|=
name|fi
operator|!=
name|NULL
expr_stmt|;
comment|/* FIXME: select_frame could fail */
if|if
condition|(
name|within_scope
condition|)
name|select_frame
argument_list|(
name|fi
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|within_scope
condition|)
block|{
comment|/* We need to catch errors here, because if evaluate          expression fails we just want to make val->error = 1 and          go on */
if|if
condition|(
name|gdb_evaluate_expression
argument_list|(
name|var
operator|->
name|root
operator|->
name|exp
argument_list|,
operator|&
name|new_val
argument_list|)
condition|)
block|{
if|if
condition|(
name|VALUE_LAZY
argument_list|(
name|new_val
argument_list|)
condition|)
block|{
comment|/* We need to catch errors because if 	         value_fetch_lazy fails we still want to continue 	         (after making val->error = 1) */
comment|/* FIXME: Shouldn't be using VALUE_CONTENTS?  The 	         comment on value_fetch_lazy() says it is only 	         called from the macro... */
if|if
condition|(
operator|!
name|gdb_value_fetch_lazy
argument_list|(
name|new_val
argument_list|)
condition|)
name|var
operator|->
name|error
operator|=
literal|1
expr_stmt|;
else|else
name|var
operator|->
name|error
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
name|var
operator|->
name|error
operator|=
literal|1
expr_stmt|;
name|release_value
argument_list|(
name|new_val
argument_list|)
expr_stmt|;
return|return
name|new_val
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|value
modifier|*
name|c_value_of_child
parameter_list|(
name|struct
name|varobj
modifier|*
name|parent
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|struct
name|value
modifier|*
name|value
decl_stmt|;
name|struct
name|value
modifier|*
name|temp
decl_stmt|;
name|struct
name|value
modifier|*
name|indval
decl_stmt|;
name|struct
name|type
modifier|*
name|type
decl_stmt|,
modifier|*
name|target
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|type
operator|=
name|get_type
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|target
operator|=
name|get_target_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|name
operator|=
name|name_of_child
argument_list|(
name|parent
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|temp
operator|=
name|parent
operator|->
name|value
expr_stmt|;
name|value
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_ARRAY
case|:
if|#
directive|if
literal|0
comment|/* This breaks if the array lives in a (vector) register. */
block|value = value_slice (temp, index, 1); 	  temp = value_coerce_array (value); 	  gdb_value_ind (temp,&value);
else|#
directive|else
name|indval
operator|=
name|value_from_longest
argument_list|(
name|builtin_type_int
argument_list|,
operator|(
name|LONGEST
operator|)
name|index
argument_list|)
expr_stmt|;
name|gdb_value_subscript
argument_list|(
name|temp
argument_list|,
name|indval
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|TYPE_CODE_STRUCT
case|:
case|case
name|TYPE_CODE_UNION
case|:
name|gdb_value_struct_elt
argument_list|(
name|NULL
argument_list|,
operator|&
name|value
argument_list|,
operator|&
name|temp
argument_list|,
name|NULL
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|,
literal|"vstructure"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_PTR
case|:
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|target
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_STRUCT
case|:
case|case
name|TYPE_CODE_UNION
case|:
name|gdb_value_struct_elt
argument_list|(
name|NULL
argument_list|,
operator|&
name|value
argument_list|,
operator|&
name|temp
argument_list|,
name|NULL
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|,
literal|"vstructure"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gdb_value_ind
argument_list|(
name|temp
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|value
operator|!=
name|NULL
condition|)
name|release_value
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|type
modifier|*
name|c_type_of_child
parameter_list|(
name|struct
name|varobj
modifier|*
name|parent
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|name_of_child
argument_list|(
name|parent
argument_list|,
name|index
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|parent
operator|->
name|type
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_ARRAY
case|:
name|type
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|parent
operator|->
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_STRUCT
case|:
case|case
name|TYPE_CODE_UNION
case|:
name|type
operator|=
name|lookup_struct_elt_type
argument_list|(
name|parent
operator|->
name|type
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_PTR
case|:
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|parent
operator|->
name|type
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_STRUCT
case|:
case|case
name|TYPE_CODE_UNION
case|:
name|type
operator|=
name|lookup_struct_elt_type
argument_list|(
name|parent
operator|->
name|type
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
name|type
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|parent
operator|->
name|type
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
comment|/* This should not happen as only the above types have children */
name|warning
argument_list|(
literal|"Child of parent whose type does not allow children"
argument_list|)
expr_stmt|;
comment|/* FIXME: Can we still go on? */
name|type
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
name|xfree
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|c_variable_editable
parameter_list|(
name|struct
name|varobj
modifier|*
name|var
parameter_list|)
block|{
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|get_type
argument_list|(
name|var
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_STRUCT
case|:
case|case
name|TYPE_CODE_UNION
case|:
case|case
name|TYPE_CODE_ARRAY
case|:
case|case
name|TYPE_CODE_FUNC
case|:
case|case
name|TYPE_CODE_MEMBER
case|:
case|case
name|TYPE_CODE_METHOD
case|:
return|return
literal|0
return|;
break|break;
default|default:
return|return
literal|1
return|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|c_value_of_variable
parameter_list|(
name|struct
name|varobj
modifier|*
name|var
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|type
decl_stmt|;
comment|/* BOGUS: if val_print sees a struct/class, it will print out its      children instead of "{...}" */
name|type
operator|=
name|get_type
argument_list|(
name|var
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_STRUCT
case|:
case|case
name|TYPE_CODE_UNION
case|:
return|return
name|xstrdup
argument_list|(
literal|"{...}"
argument_list|)
return|;
comment|/* break; */
case|case
name|TYPE_CODE_ARRAY
case|:
block|{
name|char
name|number
index|[
literal|18
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|number
argument_list|,
literal|"[%d]"
argument_list|,
name|var
operator|->
name|num_children
argument_list|)
expr_stmt|;
return|return
name|xstrdup
argument_list|(
name|number
argument_list|)
return|;
block|}
comment|/* break; */
default|default:
block|{
name|long
name|dummy
decl_stmt|;
name|struct
name|ui_file
modifier|*
name|stb
init|=
name|mem_fileopen
argument_list|()
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
init|=
name|make_cleanup_ui_file_delete
argument_list|(
name|stb
argument_list|)
decl_stmt|;
name|char
modifier|*
name|thevalue
decl_stmt|;
if|if
condition|(
name|var
operator|->
name|value
operator|==
name|NULL
condition|)
block|{
comment|/* This can happen if we attempt to get the value of a struct 	       member when the parent is an invalid pointer. This is an 	       error condition, so we should tell the caller. */
return|return
name|NULL
return|;
block|}
else|else
block|{
if|if
condition|(
name|VALUE_LAZY
argument_list|(
name|var
operator|->
name|value
argument_list|)
condition|)
name|gdb_value_fetch_lazy
argument_list|(
name|var
operator|->
name|value
argument_list|)
expr_stmt|;
name|val_print
argument_list|(
name|VALUE_TYPE
argument_list|(
name|var
operator|->
name|value
argument_list|)
argument_list|,
name|VALUE_CONTENTS_RAW
argument_list|(
name|var
operator|->
name|value
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VALUE_ADDRESS
argument_list|(
name|var
operator|->
name|value
argument_list|)
argument_list|,
name|stb
argument_list|,
name|format_code
index|[
operator|(
name|int
operator|)
name|var
operator|->
name|format
index|]
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|thevalue
operator|=
name|ui_file_xstrdup
argument_list|(
name|stb
argument_list|,
operator|&
name|dummy
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
return|return
name|thevalue
return|;
block|}
comment|/* break; */
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* C++ */
end_comment

begin_function
specifier|static
name|int
name|cplus_number_of_children
parameter_list|(
name|struct
name|varobj
modifier|*
name|var
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|int
name|children
decl_stmt|,
name|dont_know
decl_stmt|;
name|dont_know
operator|=
literal|1
expr_stmt|;
name|children
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|CPLUS_FAKE_CHILD
argument_list|(
name|var
argument_list|)
condition|)
block|{
name|type
operator|=
name|get_type_deref
argument_list|(
name|var
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|)
operator|==
name|TYPE_CODE_STRUCT
operator|)
operator|||
operator|(
operator|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|)
operator|==
name|TYPE_CODE_UNION
operator|)
condition|)
block|{
name|int
name|kids
index|[
literal|3
index|]
decl_stmt|;
name|cplus_class_num_children
argument_list|(
name|type
argument_list|,
name|kids
argument_list|)
expr_stmt|;
if|if
condition|(
name|kids
index|[
name|v_public
index|]
operator|!=
literal|0
condition|)
name|children
operator|++
expr_stmt|;
if|if
condition|(
name|kids
index|[
name|v_private
index|]
operator|!=
literal|0
condition|)
name|children
operator|++
expr_stmt|;
if|if
condition|(
name|kids
index|[
name|v_protected
index|]
operator|!=
literal|0
condition|)
name|children
operator|++
expr_stmt|;
comment|/* Add any baseclasses */
name|children
operator|+=
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|dont_know
operator|=
literal|0
expr_stmt|;
comment|/* FIXME: save children in var */
block|}
block|}
else|else
block|{
name|int
name|kids
index|[
literal|3
index|]
decl_stmt|;
name|type
operator|=
name|get_type_deref
argument_list|(
name|var
operator|->
name|parent
argument_list|)
expr_stmt|;
name|cplus_class_num_children
argument_list|(
name|type
argument_list|,
name|kids
argument_list|)
expr_stmt|;
if|if
condition|(
name|STREQ
argument_list|(
name|var
operator|->
name|name
argument_list|,
literal|"public"
argument_list|)
condition|)
name|children
operator|=
name|kids
index|[
name|v_public
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|var
operator|->
name|name
argument_list|,
literal|"private"
argument_list|)
condition|)
name|children
operator|=
name|kids
index|[
name|v_private
index|]
expr_stmt|;
else|else
name|children
operator|=
name|kids
index|[
name|v_protected
index|]
expr_stmt|;
name|dont_know
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|dont_know
condition|)
name|children
operator|=
name|c_number_of_children
argument_list|(
name|var
argument_list|)
expr_stmt|;
return|return
name|children
return|;
block|}
end_function

begin_comment
comment|/* Compute # of public, private, and protected variables in this class.    That means we need to descend into all baseclasses and find out    how many are there, too. */
end_comment

begin_function
specifier|static
name|void
name|cplus_class_num_children
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|int
name|children
index|[
literal|3
index|]
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|children
index|[
name|v_public
index|]
operator|=
literal|0
expr_stmt|;
name|children
index|[
name|v_private
index|]
operator|=
literal|0
expr_stmt|;
name|children
index|[
name|v_protected
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
init|;
name|i
operator|<
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
comment|/* If we have a virtual table pointer, omit it. */
if|if
condition|(
name|TYPE_VPTR_BASETYPE
argument_list|(
name|type
argument_list|)
operator|==
name|type
operator|&&
name|TYPE_VPTR_FIELDNO
argument_list|(
name|type
argument_list|)
operator|==
name|i
condition|)
continue|continue;
if|if
condition|(
name|TYPE_FIELD_PROTECTED
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
name|children
index|[
name|v_protected
index|]
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_FIELD_PRIVATE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
name|children
index|[
name|v_private
index|]
operator|++
expr_stmt|;
else|else
name|children
index|[
name|v_public
index|]
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|cplus_name_of_variable
parameter_list|(
name|struct
name|varobj
modifier|*
name|parent
parameter_list|)
block|{
return|return
name|c_name_of_variable
argument_list|(
name|parent
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|cplus_name_of_child
parameter_list|(
name|struct
name|varobj
modifier|*
name|parent
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|int
name|children
index|[
literal|3
index|]
decl_stmt|;
if|if
condition|(
name|CPLUS_FAKE_CHILD
argument_list|(
name|parent
argument_list|)
condition|)
block|{
comment|/* Looking for children of public, private, or protected. */
name|type
operator|=
name|get_type_deref
argument_list|(
name|parent
operator|->
name|parent
argument_list|)
expr_stmt|;
block|}
else|else
name|type
operator|=
name|get_type_deref
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|name
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_STRUCT
case|:
case|case
name|TYPE_CODE_UNION
case|:
name|cplus_class_num_children
argument_list|(
name|type
argument_list|,
name|children
argument_list|)
expr_stmt|;
if|if
condition|(
name|CPLUS_FAKE_CHILD
argument_list|(
name|parent
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Skip over vptr, if it exists. */
if|if
condition|(
name|TYPE_VPTR_BASETYPE
argument_list|(
name|type
argument_list|)
operator|==
name|type
operator|&&
name|index
operator|>=
name|TYPE_VPTR_FIELDNO
argument_list|(
name|type
argument_list|)
condition|)
name|index
operator|++
expr_stmt|;
comment|/* FIXME: This assumes that type orders 	     inherited, public, private, protected */
name|i
operator|=
name|index
operator|+
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|STREQ
argument_list|(
name|parent
operator|->
name|name
argument_list|,
literal|"private"
argument_list|)
operator|||
name|STREQ
argument_list|(
name|parent
operator|->
name|name
argument_list|,
literal|"protected"
argument_list|)
condition|)
name|i
operator|+=
name|children
index|[
name|v_public
index|]
expr_stmt|;
if|if
condition|(
name|STREQ
argument_list|(
name|parent
operator|->
name|name
argument_list|,
literal|"protected"
argument_list|)
condition|)
name|i
operator|+=
name|children
index|[
name|v_private
index|]
expr_stmt|;
name|name
operator|=
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|index
operator|<
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
condition|)
name|name
operator|=
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|index
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Everything beyond the baseclasses can 	     only be "public", "private", or "protected" */
name|index
operator|-=
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|index
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
name|children
index|[
name|v_public
index|]
operator|!=
literal|0
condition|)
block|{
name|name
operator|=
literal|"public"
expr_stmt|;
break|break;
block|}
case|case
literal|1
case|:
if|if
condition|(
name|children
index|[
name|v_private
index|]
operator|!=
literal|0
condition|)
block|{
name|name
operator|=
literal|"private"
expr_stmt|;
break|break;
block|}
case|case
literal|2
case|:
if|if
condition|(
name|children
index|[
name|v_protected
index|]
operator|!=
literal|0
condition|)
block|{
name|name
operator|=
literal|"protected"
expr_stmt|;
break|break;
block|}
default|default:
comment|/* error! */
break|break;
block|}
block|}
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|c_name_of_child
argument_list|(
name|parent
argument_list|,
name|index
argument_list|)
return|;
else|else
block|{
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
name|name
operator|=
name|savestring
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|name
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|value
modifier|*
name|cplus_value_of_root
parameter_list|(
name|struct
name|varobj
modifier|*
modifier|*
name|var_handle
parameter_list|)
block|{
return|return
name|c_value_of_root
argument_list|(
name|var_handle
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|value
modifier|*
name|cplus_value_of_child
parameter_list|(
name|struct
name|varobj
modifier|*
name|parent
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|struct
name|value
modifier|*
name|value
decl_stmt|;
if|if
condition|(
name|CPLUS_FAKE_CHILD
argument_list|(
name|parent
argument_list|)
condition|)
name|type
operator|=
name|get_type_deref
argument_list|(
name|parent
operator|->
name|parent
argument_list|)
expr_stmt|;
else|else
name|type
operator|=
name|get_type_deref
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|value
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|)
operator|==
name|TYPE_CODE_STRUCT
operator|)
operator|||
operator|(
operator|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|)
operator|==
name|TYPE_CODE_UNION
operator|)
condition|)
block|{
if|if
condition|(
name|CPLUS_FAKE_CHILD
argument_list|(
name|parent
argument_list|)
condition|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|value
modifier|*
name|temp
init|=
name|parent
operator|->
name|parent
operator|->
name|value
decl_stmt|;
if|if
condition|(
name|temp
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|name
operator|=
name|name_of_child
argument_list|(
name|parent
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|gdb_value_struct_elt
argument_list|(
name|NULL
argument_list|,
operator|&
name|value
argument_list|,
operator|&
name|temp
argument_list|,
name|NULL
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|,
literal|"cplus_structure"
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
name|NULL
condition|)
name|release_value
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|index
operator|>=
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* public, private, or protected */
return|return
name|NULL
return|;
block|}
else|else
block|{
comment|/* Baseclass */
if|if
condition|(
name|parent
operator|->
name|value
operator|!=
name|NULL
condition|)
block|{
name|struct
name|value
modifier|*
name|temp
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|parent
operator|->
name|value
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_PTR
operator|||
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|parent
operator|->
name|value
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_REF
condition|)
block|{
if|if
condition|(
operator|!
name|gdb_value_ind
argument_list|(
name|parent
operator|->
name|value
argument_list|,
operator|&
name|temp
argument_list|)
condition|)
return|return
name|NULL
return|;
block|}
else|else
name|temp
operator|=
name|parent
operator|->
name|value
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
name|NULL
condition|)
block|{
name|value
operator|=
name|value_cast
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|index
argument_list|)
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|release_value
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We failed to evaluate the parent's value, so don't even 		     bother trying to evaluate this child. */
return|return
name|NULL
return|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|value
operator|==
name|NULL
condition|)
return|return
name|c_value_of_child
argument_list|(
name|parent
argument_list|,
name|index
argument_list|)
return|;
return|return
name|value
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|type
modifier|*
name|cplus_type_of_child
parameter_list|(
name|struct
name|varobj
modifier|*
name|parent
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|type
decl_stmt|,
modifier|*
name|t
decl_stmt|;
if|if
condition|(
name|CPLUS_FAKE_CHILD
argument_list|(
name|parent
argument_list|)
condition|)
block|{
comment|/* Looking for the type of a child of public, private, or protected. */
name|t
operator|=
name|get_type_deref
argument_list|(
name|parent
operator|->
name|parent
argument_list|)
expr_stmt|;
block|}
else|else
name|t
operator|=
name|get_type_deref
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|type
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_STRUCT
case|:
case|case
name|TYPE_CODE_UNION
case|:
if|if
condition|(
name|CPLUS_FAKE_CHILD
argument_list|(
name|parent
argument_list|)
condition|)
block|{
name|char
modifier|*
name|name
init|=
name|cplus_name_of_child
argument_list|(
name|parent
argument_list|,
name|index
argument_list|)
decl_stmt|;
name|type
operator|=
name|lookup_struct_elt_type
argument_list|(
name|t
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|index
operator|<
name|TYPE_N_BASECLASSES
argument_list|(
name|t
argument_list|)
condition|)
name|type
operator|=
name|TYPE_FIELD_TYPE
argument_list|(
name|t
argument_list|,
name|index
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* special */
return|return
name|NULL
return|;
block|}
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|type
operator|==
name|NULL
condition|)
return|return
name|c_type_of_child
argument_list|(
name|parent
argument_list|,
name|index
argument_list|)
return|;
return|return
name|type
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cplus_variable_editable
parameter_list|(
name|struct
name|varobj
modifier|*
name|var
parameter_list|)
block|{
if|if
condition|(
name|CPLUS_FAKE_CHILD
argument_list|(
name|var
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|c_variable_editable
argument_list|(
name|var
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|cplus_value_of_variable
parameter_list|(
name|struct
name|varobj
modifier|*
name|var
parameter_list|)
block|{
comment|/* If we have one of our special types, don't print out      any value. */
if|if
condition|(
name|CPLUS_FAKE_CHILD
argument_list|(
name|var
argument_list|)
condition|)
return|return
name|xstrdup
argument_list|(
literal|""
argument_list|)
return|;
return|return
name|c_value_of_variable
argument_list|(
name|var
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Java */
end_comment

begin_function
specifier|static
name|int
name|java_number_of_children
parameter_list|(
name|struct
name|varobj
modifier|*
name|var
parameter_list|)
block|{
return|return
name|cplus_number_of_children
argument_list|(
name|var
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|java_name_of_variable
parameter_list|(
name|struct
name|varobj
modifier|*
name|parent
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|cplus_name_of_variable
argument_list|(
name|parent
argument_list|)
expr_stmt|;
comment|/* If  the name has "-" in it, it is because we      needed to escape periods in the name... */
name|p
operator|=
name|name
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\000'
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
condition|)
operator|*
name|p
operator|=
literal|'.'
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
return|return
name|name
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|java_name_of_child
parameter_list|(
name|struct
name|varobj
modifier|*
name|parent
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|name
operator|=
name|cplus_name_of_child
argument_list|(
name|parent
argument_list|,
name|index
argument_list|)
expr_stmt|;
comment|/* Escape any periods in the name... */
name|p
operator|=
name|name
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\000'
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'.'
condition|)
operator|*
name|p
operator|=
literal|'-'
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
return|return
name|name
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|value
modifier|*
name|java_value_of_root
parameter_list|(
name|struct
name|varobj
modifier|*
modifier|*
name|var_handle
parameter_list|)
block|{
return|return
name|cplus_value_of_root
argument_list|(
name|var_handle
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|value
modifier|*
name|java_value_of_child
parameter_list|(
name|struct
name|varobj
modifier|*
name|parent
parameter_list|,
name|int
name|index
parameter_list|)
block|{
return|return
name|cplus_value_of_child
argument_list|(
name|parent
argument_list|,
name|index
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|type
modifier|*
name|java_type_of_child
parameter_list|(
name|struct
name|varobj
modifier|*
name|parent
parameter_list|,
name|int
name|index
parameter_list|)
block|{
return|return
name|cplus_type_of_child
argument_list|(
name|parent
argument_list|,
name|index
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|java_variable_editable
parameter_list|(
name|struct
name|varobj
modifier|*
name|var
parameter_list|)
block|{
return|return
name|cplus_variable_editable
argument_list|(
name|var
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|java_value_of_variable
parameter_list|(
name|struct
name|varobj
modifier|*
name|var
parameter_list|)
block|{
return|return
name|cplus_value_of_variable
argument_list|(
name|var
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function_decl
specifier|extern
name|void
name|_initialize_varobj
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|_initialize_varobj
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|sizeof_table
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|vlist
operator|*
argument_list|)
operator|*
name|VAROBJ_TABLE_SIZE
decl_stmt|;
name|varobj_table
operator|=
name|xmalloc
argument_list|(
name|sizeof_table
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|varobj_table
argument_list|,
literal|0
argument_list|,
name|sizeof_table
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"debugvarobj"
argument_list|,
name|class_maintenance
argument_list|,
name|var_zinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|varobjdebug
argument_list|,
literal|"Set varobj debugging.\n\ When non-zero, varobj debugging is enabled."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

