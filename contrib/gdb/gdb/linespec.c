begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Parser for linespec for the GNU debugger, GDB.    Copyright 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995,    1996, 1997, 1998, 1999, 2000, 2001    Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"completer.h"
end_include

begin_include
include|#
directive|include
file|"cp-abi.h"
end_include

begin_comment
comment|/* Prototype for one function in parser-defs.h,    instead of including that entire file. */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|find_template_name_end
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* We share this one with symtab.c, but it is not exported widely. */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|operator_chars
parameter_list|(
name|char
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Prototypes for local functions */
end_comment

begin_function_decl
specifier|static
name|void
name|cplusplus_error
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
function_decl|ATTR_FORMAT
parameter_list|(
name|printf
parameter_list|,
function_decl|2
operator|,
function_decl|3
end_function_decl

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|static
name|int
name|total_number_of_methods
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|find_methods
parameter_list|(
name|struct
name|type
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|struct
name|symbol
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|build_canonical_line_spec
parameter_list|(
name|struct
name|symtab_and_line
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|find_toplevel_char
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|char
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|symtabs_and_lines
name|decode_line_2
parameter_list|(
name|struct
name|symbol
modifier|*
type|[]
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Helper functions. */
end_comment

begin_comment
comment|/* Issue a helpful hint on using the command completion feature on    single quoted demangled C++ symbols as part of the completion    error.  */
end_comment

begin_function
specifier|static
name|void
name|cplusplus_error
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|struct
name|ui_file
modifier|*
name|tmp_stream
decl_stmt|;
name|tmp_stream
operator|=
name|mem_fileopen
argument_list|()
expr_stmt|;
name|make_cleanup_ui_file_delete
argument_list|(
name|tmp_stream
argument_list|)
expr_stmt|;
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vfprintf_unfiltered
argument_list|(
name|tmp_stream
argument_list|,
name|fmt
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|name
operator|==
literal|'\''
condition|)
name|name
operator|++
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|tmp_stream
argument_list|,
operator|(
literal|"Hint: try '%s<TAB> or '%s<ESC-?>\n"
literal|"(Note leading single quote.)"
operator|)
argument_list|,
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|error_stream
argument_list|(
name|tmp_stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the number of methods described for TYPE, including the    methods from types it derives from. This can't be done in the symbol    reader because the type of the baseclass might still be stubbed    when the definition of the derived class is parsed.  */
end_comment

begin_function
specifier|static
name|int
name|total_number_of_methods
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
name|int
name|count
decl_stmt|;
name|CHECK_TYPEDEF
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CPLUS_SPECIFIC
argument_list|(
name|type
argument_list|)
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|count
operator|=
name|TYPE_NFN_FIELDS_TOTAL
argument_list|(
name|type
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
condition|;
name|n
operator|++
control|)
name|count
operator|+=
name|total_number_of_methods
argument_list|(
name|TYPE_BASECLASS
argument_list|(
name|type
argument_list|,
name|n
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|count
return|;
block|}
end_function

begin_comment
comment|/* Recursive helper function for decode_line_1.    Look for methods named NAME in type T.    Return number of matches.    Put matches in SYM_ARR, which should have been allocated with    a size of total_number_of_methods (T) * sizeof (struct symbol *).    Note that this function is g++ specific.  */
end_comment

begin_function
specifier|static
name|int
name|find_methods
parameter_list|(
name|struct
name|type
modifier|*
name|t
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|symbol
modifier|*
modifier|*
name|sym_arr
parameter_list|)
block|{
name|int
name|i1
init|=
literal|0
decl_stmt|;
name|int
name|ibase
decl_stmt|;
name|char
modifier|*
name|class_name
init|=
name|type_name_no_tag
argument_list|(
name|t
argument_list|)
decl_stmt|;
comment|/* Ignore this class if it doesn't have a name.  This is ugly, but      unless we figure out how to get the physname without the name of      the class, then the loop can't do any good.  */
if|if
condition|(
name|class_name
operator|&&
operator|(
name|lookup_symbol
argument_list|(
name|class_name
argument_list|,
operator|(
expr|struct
name|block
operator|*
operator|)
name|NULL
argument_list|,
name|STRUCT_NAMESPACE
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
operator|(
expr|struct
name|symtab
operator|*
operator|*
operator|)
name|NULL
argument_list|)
operator|)
condition|)
block|{
name|int
name|method_counter
decl_stmt|;
name|CHECK_TYPEDEF
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Loop over each method name.  At this level, all overloads of a name          are counted as a single name.  There is an inner loop which loops over          each overload.  */
for|for
control|(
name|method_counter
operator|=
name|TYPE_NFN_FIELDS
argument_list|(
name|t
argument_list|)
operator|-
literal|1
init|;
name|method_counter
operator|>=
literal|0
condition|;
operator|--
name|method_counter
control|)
block|{
name|int
name|field_counter
decl_stmt|;
name|char
modifier|*
name|method_name
init|=
name|TYPE_FN_FIELDLIST_NAME
argument_list|(
name|t
argument_list|,
name|method_counter
argument_list|)
decl_stmt|;
name|char
name|dem_opname
index|[
literal|64
index|]
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|method_name
argument_list|,
literal|"__"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|method_name
argument_list|,
literal|"op"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|method_name
argument_list|,
literal|"type"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|cplus_demangle_opname
argument_list|(
name|method_name
argument_list|,
name|dem_opname
argument_list|,
name|DMGL_ANSI
argument_list|)
condition|)
name|method_name
operator|=
name|dem_opname
expr_stmt|;
elseif|else
if|if
condition|(
name|cplus_demangle_opname
argument_list|(
name|method_name
argument_list|,
name|dem_opname
argument_list|,
literal|0
argument_list|)
condition|)
name|method_name
operator|=
name|dem_opname
expr_stmt|;
block|}
if|if
condition|(
name|strcmp_iw
argument_list|(
name|name
argument_list|,
name|method_name
argument_list|)
operator|==
literal|0
condition|)
comment|/* Find all the overloaded methods with that name.  */
for|for
control|(
name|field_counter
operator|=
name|TYPE_FN_FIELDLIST_LENGTH
argument_list|(
name|t
argument_list|,
name|method_counter
argument_list|)
operator|-
literal|1
init|;
name|field_counter
operator|>=
literal|0
condition|;
operator|--
name|field_counter
control|)
block|{
name|struct
name|fn_field
modifier|*
name|f
decl_stmt|;
name|char
modifier|*
name|phys_name
decl_stmt|;
name|f
operator|=
name|TYPE_FN_FIELDLIST1
argument_list|(
name|t
argument_list|,
name|method_counter
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_FN_FIELD_STUB
argument_list|(
name|f
argument_list|,
name|field_counter
argument_list|)
condition|)
block|{
name|char
modifier|*
name|tmp_name
decl_stmt|;
name|tmp_name
operator|=
name|gdb_mangle_name
argument_list|(
name|t
argument_list|,
name|method_counter
argument_list|,
name|field_counter
argument_list|)
expr_stmt|;
name|phys_name
operator|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|tmp_name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|phys_name
argument_list|,
name|tmp_name
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|tmp_name
argument_list|)
expr_stmt|;
block|}
else|else
name|phys_name
operator|=
name|TYPE_FN_FIELD_PHYSNAME
argument_list|(
name|f
argument_list|,
name|field_counter
argument_list|)
expr_stmt|;
comment|/* Destructor is handled by caller, dont add it to the list */
if|if
condition|(
name|is_destructor_name
argument_list|(
name|phys_name
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
name|sym_arr
index|[
name|i1
index|]
operator|=
name|lookup_symbol
argument_list|(
name|phys_name
argument_list|,
name|NULL
argument_list|,
name|VAR_NAMESPACE
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
operator|(
expr|struct
name|symtab
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym_arr
index|[
name|i1
index|]
condition|)
name|i1
operator|++
expr_stmt|;
else|else
block|{
comment|/* This error message gets printed, but the method 		       still seems to be found 		       fputs_filtered("(Cannot find method ", gdb_stdout); 		       fprintf_symbol_filtered (gdb_stdout, phys_name, 		       language_cplus, 		       DMGL_PARAMS | DMGL_ANSI); 		       fputs_filtered(" - possibly inlined.)\n", gdb_stdout); 		     */
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp_iw
argument_list|(
name|class_name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* For GCC 3.x and stabs, constructors and destructors have names 		 like __base_ctor and __complete_dtor.  Check the physname for now 		 if we're looking for a constructor.  */
for|for
control|(
name|field_counter
operator|=
name|TYPE_FN_FIELDLIST_LENGTH
argument_list|(
name|t
argument_list|,
name|method_counter
argument_list|)
operator|-
literal|1
init|;
name|field_counter
operator|>=
literal|0
condition|;
operator|--
name|field_counter
control|)
block|{
name|struct
name|fn_field
modifier|*
name|f
decl_stmt|;
name|char
modifier|*
name|phys_name
decl_stmt|;
name|f
operator|=
name|TYPE_FN_FIELDLIST1
argument_list|(
name|t
argument_list|,
name|method_counter
argument_list|)
expr_stmt|;
comment|/* GCC 3.x will never produce stabs stub methods, so we don't need 		     to handle this case.  */
if|if
condition|(
name|TYPE_FN_FIELD_STUB
argument_list|(
name|f
argument_list|,
name|field_counter
argument_list|)
condition|)
continue|continue;
name|phys_name
operator|=
name|TYPE_FN_FIELD_PHYSNAME
argument_list|(
name|f
argument_list|,
name|field_counter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_constructor_name
argument_list|(
name|phys_name
argument_list|)
condition|)
continue|continue;
comment|/* If this method is actually defined, include it in the 		     list.  */
name|sym_arr
index|[
name|i1
index|]
operator|=
name|lookup_symbol
argument_list|(
name|phys_name
argument_list|,
name|NULL
argument_list|,
name|VAR_NAMESPACE
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
operator|(
expr|struct
name|symtab
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym_arr
index|[
name|i1
index|]
condition|)
name|i1
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Only search baseclasses if there is no match yet, since names in      derived classes override those in baseclasses.       FIXME: The above is not true; it is only true of member functions      if they have the same number of arguments (??? - section 13.1 of the      ARM says the function members are not in the same scope but doesn't      really spell out the rules in a way I understand.  In any case, if      the number of arguments differ this is a case in which we can overload      rather than hiding without any problem, and gcc 2.4.5 does overload      rather than hiding in this case).  */
if|if
condition|(
name|i1
operator|==
literal|0
condition|)
for|for
control|(
name|ibase
operator|=
literal|0
init|;
name|ibase
operator|<
name|TYPE_N_BASECLASSES
argument_list|(
name|t
argument_list|)
condition|;
name|ibase
operator|++
control|)
name|i1
operator|+=
name|find_methods
argument_list|(
name|TYPE_BASECLASS
argument_list|(
name|t
argument_list|,
name|ibase
argument_list|)
argument_list|,
name|name
argument_list|,
name|sym_arr
operator|+
name|i1
argument_list|)
expr_stmt|;
return|return
name|i1
return|;
block|}
end_function

begin_comment
comment|/* Helper function for decode_line_1.    Build a canonical line spec in CANONICAL if it is non-NULL and if    the SAL has a symtab.    If SYMNAME is non-NULL the canonical line spec is `filename:symname'.    If SYMNAME is NULL the line number from SAL is used and the canonical    line spec is `filename:linenum'.  */
end_comment

begin_function
specifier|static
name|void
name|build_canonical_line_spec
parameter_list|(
name|struct
name|symtab_and_line
modifier|*
name|sal
parameter_list|,
name|char
modifier|*
name|symname
parameter_list|,
name|char
modifier|*
modifier|*
modifier|*
name|canonical
parameter_list|)
block|{
name|char
modifier|*
modifier|*
name|canonical_arr
decl_stmt|;
name|char
modifier|*
name|canonical_name
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|struct
name|symtab
modifier|*
name|s
init|=
name|sal
operator|->
name|symtab
decl_stmt|;
if|if
condition|(
name|s
operator|==
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|NULL
operator|||
name|s
operator|->
name|filename
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
operator|||
name|canonical
operator|==
operator|(
name|char
operator|*
operator|*
operator|*
operator|)
name|NULL
condition|)
return|return;
name|canonical_arr
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|canonical
operator|=
name|canonical_arr
expr_stmt|;
name|filename
operator|=
name|s
operator|->
name|filename
expr_stmt|;
if|if
condition|(
name|symname
operator|!=
name|NULL
condition|)
block|{
name|canonical_name
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|filename
argument_list|)
operator|+
name|strlen
argument_list|(
name|symname
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|canonical_name
argument_list|,
literal|"%s:%s"
argument_list|,
name|filename
argument_list|,
name|symname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|canonical_name
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|filename
argument_list|)
operator|+
literal|30
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|canonical_name
argument_list|,
literal|"%s:%d"
argument_list|,
name|filename
argument_list|,
name|sal
operator|->
name|line
argument_list|)
expr_stmt|;
block|}
name|canonical_arr
index|[
literal|0
index|]
operator|=
name|canonical_name
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find an instance of the character C in the string S that is outside    of all parenthesis pairs, single-quoted strings, and double-quoted    strings.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|find_toplevel_char
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|char
name|c
parameter_list|)
block|{
name|int
name|quoted
init|=
literal|0
decl_stmt|;
comment|/* zero if we're not in quotes; 				   '"' if we're in a double-quoted string; 				   '\'' if we're in a single-quoted string.  */
name|int
name|depth
init|=
literal|0
decl_stmt|;
comment|/* number of unclosed parens we've seen */
name|char
modifier|*
name|scan
decl_stmt|;
for|for
control|(
name|scan
operator|=
name|s
init|;
operator|*
name|scan
condition|;
name|scan
operator|++
control|)
block|{
if|if
condition|(
name|quoted
condition|)
block|{
if|if
condition|(
operator|*
name|scan
operator|==
name|quoted
condition|)
name|quoted
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|scan
operator|==
literal|'\\'
operator|&&
operator|*
operator|(
name|scan
operator|+
literal|1
operator|)
condition|)
name|scan
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|scan
operator|==
name|c
operator|&&
operator|!
name|quoted
operator|&&
name|depth
operator|==
literal|0
condition|)
return|return
name|scan
return|;
elseif|else
if|if
condition|(
operator|*
name|scan
operator|==
literal|'"'
operator|||
operator|*
name|scan
operator|==
literal|'\''
condition|)
name|quoted
operator|=
operator|*
name|scan
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|scan
operator|==
literal|'('
condition|)
name|depth
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|scan
operator|==
literal|')'
operator|&&
name|depth
operator|>
literal|0
condition|)
name|depth
operator|--
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Given a list of NELTS symbols in SYM_ARR, return a list of lines to    operate on (ask user if necessary).    If CANONICAL is non-NULL return a corresponding array of mangled names    as canonical line specs there.  */
end_comment

begin_function
specifier|static
name|struct
name|symtabs_and_lines
name|decode_line_2
parameter_list|(
name|struct
name|symbol
modifier|*
name|sym_arr
index|[]
parameter_list|,
name|int
name|nelts
parameter_list|,
name|int
name|funfirstline
parameter_list|,
name|char
modifier|*
modifier|*
modifier|*
name|canonical
parameter_list|)
block|{
name|struct
name|symtabs_and_lines
name|values
decl_stmt|,
name|return_values
decl_stmt|;
name|char
modifier|*
name|args
decl_stmt|,
modifier|*
name|arg1
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|prompt
decl_stmt|;
name|char
modifier|*
name|symname
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|char
modifier|*
modifier|*
name|canonical_arr
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
name|values
operator|.
name|sals
operator|=
operator|(
expr|struct
name|symtab_and_line
operator|*
operator|)
name|alloca
argument_list|(
name|nelts
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|symtab_and_line
argument_list|)
argument_list|)
expr_stmt|;
name|return_values
operator|.
name|sals
operator|=
operator|(
expr|struct
name|symtab_and_line
operator|*
operator|)
name|xmalloc
argument_list|(
name|nelts
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|symtab_and_line
argument_list|)
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|return_values
operator|.
name|sals
argument_list|)
expr_stmt|;
if|if
condition|(
name|canonical
condition|)
block|{
name|canonical_arr
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|nelts
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|canonical_arr
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|canonical_arr
argument_list|,
literal|0
argument_list|,
name|nelts
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|canonical
operator|=
name|canonical_arr
expr_stmt|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"[0] cancel\n[1] all\n"
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|nelts
condition|)
block|{
name|INIT_SAL
argument_list|(
operator|&
name|return_values
operator|.
name|sals
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* initialize to zeroes */
name|INIT_SAL
argument_list|(
operator|&
name|values
operator|.
name|sals
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym_arr
index|[
name|i
index|]
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|sym_arr
index|[
name|i
index|]
argument_list|)
operator|==
name|LOC_BLOCK
condition|)
block|{
name|values
operator|.
name|sals
index|[
name|i
index|]
operator|=
name|find_function_start_sal
argument_list|(
name|sym_arr
index|[
name|i
index|]
argument_list|,
name|funfirstline
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"[%d] %s at %s:%d\n"
argument_list|,
operator|(
name|i
operator|+
literal|2
operator|)
argument_list|,
name|SYMBOL_SOURCE_NAME
argument_list|(
name|sym_arr
index|[
name|i
index|]
argument_list|)
argument_list|,
name|values
operator|.
name|sals
index|[
name|i
index|]
operator|.
name|symtab
operator|->
name|filename
argument_list|,
name|values
operator|.
name|sals
index|[
name|i
index|]
operator|.
name|line
argument_list|)
expr_stmt|;
block|}
else|else
name|printf_unfiltered
argument_list|(
literal|"?HERE\n"
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|prompt
operator|=
name|getenv
argument_list|(
literal|"PS2"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|prompt
operator|=
literal|"> "
expr_stmt|;
block|}
name|args
operator|=
name|command_line_input
argument_list|(
name|prompt
argument_list|,
literal|0
argument_list|,
literal|"overload-choice"
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|==
literal|0
operator|||
operator|*
name|args
operator|==
literal|0
condition|)
name|error_no_arg
argument_list|(
literal|"one or more choice numbers"
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|args
condition|)
block|{
name|int
name|num
decl_stmt|;
name|arg1
operator|=
name|args
expr_stmt|;
while|while
condition|(
operator|*
name|arg1
operator|>=
literal|'0'
operator|&&
operator|*
name|arg1
operator|<=
literal|'9'
condition|)
name|arg1
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|arg1
operator|&&
operator|*
name|arg1
operator|!=
literal|' '
operator|&&
operator|*
name|arg1
operator|!=
literal|'\t'
condition|)
name|error
argument_list|(
literal|"Arguments must be choice numbers."
argument_list|)
expr_stmt|;
name|num
operator|=
name|atoi
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|num
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"canceled"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|num
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|canonical_arr
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nelts
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|canonical_arr
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
name|symname
operator|=
name|SYMBOL_NAME
argument_list|(
name|sym_arr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|canonical_arr
index|[
name|i
index|]
operator|=
name|savestring
argument_list|(
name|symname
argument_list|,
name|strlen
argument_list|(
name|symname
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|memcpy
argument_list|(
name|return_values
operator|.
name|sals
argument_list|,
name|values
operator|.
name|sals
argument_list|,
operator|(
name|nelts
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|symtab_and_line
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|return_values
operator|.
name|nelts
operator|=
name|nelts
expr_stmt|;
name|discard_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
name|return_values
return|;
block|}
if|if
condition|(
name|num
operator|>=
name|nelts
operator|+
literal|2
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"No choice number %d.\n"
argument_list|,
name|num
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|num
operator|-=
literal|2
expr_stmt|;
if|if
condition|(
name|values
operator|.
name|sals
index|[
name|num
index|]
operator|.
name|pc
condition|)
block|{
if|if
condition|(
name|canonical_arr
condition|)
block|{
name|symname
operator|=
name|SYMBOL_NAME
argument_list|(
name|sym_arr
index|[
name|num
index|]
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|symname
argument_list|)
expr_stmt|;
name|canonical_arr
index|[
name|i
index|]
operator|=
name|savestring
argument_list|(
name|symname
argument_list|,
name|strlen
argument_list|(
name|symname
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|return_values
operator|.
name|sals
index|[
name|i
operator|++
index|]
operator|=
name|values
operator|.
name|sals
index|[
name|num
index|]
expr_stmt|;
name|values
operator|.
name|sals
index|[
name|num
index|]
operator|.
name|pc
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|printf_unfiltered
argument_list|(
literal|"duplicate request for %d ignored.\n"
argument_list|,
name|num
argument_list|)
expr_stmt|;
block|}
block|}
name|args
operator|=
name|arg1
expr_stmt|;
while|while
condition|(
operator|*
name|args
operator|==
literal|' '
operator|||
operator|*
name|args
operator|==
literal|'\t'
condition|)
name|args
operator|++
expr_stmt|;
block|}
name|return_values
operator|.
name|nelts
operator|=
name|i
expr_stmt|;
name|discard_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
name|return_values
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The parser of linespec itself. */
end_comment

begin_comment
comment|/* Parse a string that specifies a line number.    Pass the address of a char * variable; that variable will be    advanced over the characters actually parsed.     The string can be:     LINENUM -- that line number in current file.  PC returned is 0.    FILE:LINENUM -- that line in that file.  PC returned is 0.    FUNCTION -- line number of openbrace of that function.    PC returned is the start of the function.    VARIABLE -- line number of definition of that variable.    PC returned is 0.    FILE:FUNCTION -- likewise, but prefer functions in that file.    *EXPR -- line in which address EXPR appears.     This may all be followed by an "if EXPR", which we ignore.     FUNCTION may be an undebuggable function found in minimal symbol table.     If the argument FUNFIRSTLINE is nonzero, we want the first line    of real code inside a function when a function is specified, and it is    not OK to specify a variable or type to get its line number.     DEFAULT_SYMTAB specifies the file to use if none is specified.    It defaults to current_source_symtab.    DEFAULT_LINE specifies the line number to use for relative    line numbers (that start with signs).  Defaults to current_source_line.    If CANONICAL is non-NULL, store an array of strings containing the canonical    line specs there if necessary. Currently overloaded member functions and    line numbers or static functions without a filename yield a canonical    line spec. The array and the line spec strings are allocated on the heap,    it is the callers responsibility to free them.     Note that it is possible to return zero for the symtab    if no file is validly specified.  Callers must check that.    Also, the line number returned may be invalid.  */
end_comment

begin_comment
comment|/* We allow single quotes in various places.  This is a hideous    kludge, which exists because the completer can't yet deal with the    lack of single quotes.  FIXME: write a linespec_completer which we    can use as appropriate instead of make_symbol_completion_list.  */
end_comment

begin_function
name|struct
name|symtabs_and_lines
name|decode_line_1
parameter_list|(
name|char
modifier|*
modifier|*
name|argptr
parameter_list|,
name|int
name|funfirstline
parameter_list|,
name|struct
name|symtab
modifier|*
name|default_symtab
parameter_list|,
name|int
name|default_line
parameter_list|,
name|char
modifier|*
modifier|*
modifier|*
name|canonical
parameter_list|)
block|{
name|struct
name|symtabs_and_lines
name|values
decl_stmt|;
name|struct
name|symtab_and_line
name|val
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|p1
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|,
modifier|*
name|pp
decl_stmt|,
modifier|*
name|ii
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
if|#
directive|if
literal|0
block|char *q1;
endif|#
directive|endif
specifier|register
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
specifier|register
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
comment|/* The symtab that SYM was found in.  */
name|struct
name|symtab
modifier|*
name|sym_symtab
decl_stmt|;
specifier|register
name|CORE_ADDR
name|pc
decl_stmt|;
specifier|register
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
name|char
modifier|*
name|copy
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym_class
decl_stmt|;
name|int
name|i1
decl_stmt|;
name|int
name|is_quoted
decl_stmt|;
name|int
name|is_quote_enclosed
decl_stmt|;
name|int
name|has_parens
decl_stmt|;
name|int
name|has_if
init|=
literal|0
decl_stmt|;
name|int
name|has_comma
init|=
literal|0
decl_stmt|;
name|struct
name|symbol
modifier|*
modifier|*
name|sym_arr
decl_stmt|;
name|struct
name|type
modifier|*
name|t
decl_stmt|;
name|char
modifier|*
name|saved_arg
init|=
operator|*
name|argptr
decl_stmt|;
specifier|extern
name|char
modifier|*
name|gdb_completer_quote_characters
decl_stmt|;
name|INIT_SAL
argument_list|(
operator|&
name|val
argument_list|)
expr_stmt|;
comment|/* initialize to zeroes */
comment|/* Defaults have defaults.  */
if|if
condition|(
name|default_symtab
operator|==
literal|0
condition|)
block|{
name|default_symtab
operator|=
name|current_source_symtab
expr_stmt|;
name|default_line
operator|=
name|current_source_line
expr_stmt|;
block|}
comment|/* See if arg is *PC */
if|if
condition|(
operator|*
operator|*
name|argptr
operator|==
literal|'*'
condition|)
block|{
operator|(
operator|*
name|argptr
operator|)
operator|++
expr_stmt|;
name|pc
operator|=
name|parse_and_eval_address_1
argument_list|(
name|argptr
argument_list|)
expr_stmt|;
name|values
operator|.
name|sals
operator|=
operator|(
expr|struct
name|symtab_and_line
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|symtab_and_line
argument_list|)
argument_list|)
expr_stmt|;
name|values
operator|.
name|nelts
operator|=
literal|1
expr_stmt|;
name|values
operator|.
name|sals
index|[
literal|0
index|]
operator|=
name|find_pc_line
argument_list|(
name|pc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|values
operator|.
name|sals
index|[
literal|0
index|]
operator|.
name|pc
operator|=
name|pc
expr_stmt|;
name|values
operator|.
name|sals
index|[
literal|0
index|]
operator|.
name|section
operator|=
name|find_pc_overlay
argument_list|(
name|pc
argument_list|)
expr_stmt|;
return|return
name|values
return|;
block|}
comment|/* 'has_if' is for the syntax:    *     (gdb) break foo if (a==b)    */
if|if
condition|(
operator|(
name|ii
operator|=
name|strstr
argument_list|(
operator|*
name|argptr
argument_list|,
literal|" if "
argument_list|)
operator|)
operator|!=
name|NULL
operator|||
operator|(
name|ii
operator|=
name|strstr
argument_list|(
operator|*
name|argptr
argument_list|,
literal|"\tif "
argument_list|)
operator|)
operator|!=
name|NULL
operator|||
operator|(
name|ii
operator|=
name|strstr
argument_list|(
operator|*
name|argptr
argument_list|,
literal|" if\t"
argument_list|)
operator|)
operator|!=
name|NULL
operator|||
operator|(
name|ii
operator|=
name|strstr
argument_list|(
operator|*
name|argptr
argument_list|,
literal|"\tif\t"
argument_list|)
operator|)
operator|!=
name|NULL
operator|||
operator|(
name|ii
operator|=
name|strstr
argument_list|(
operator|*
name|argptr
argument_list|,
literal|" if("
argument_list|)
operator|)
operator|!=
name|NULL
operator|||
operator|(
name|ii
operator|=
name|strstr
argument_list|(
operator|*
name|argptr
argument_list|,
literal|"\tif( "
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|has_if
operator|=
literal|1
expr_stmt|;
comment|/* Temporarily zap out "if (condition)" to not    * confuse the parenthesis-checking code below.    * This is undone below. Do not change ii!!    */
if|if
condition|(
name|has_if
condition|)
block|{
operator|*
name|ii
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* Set various flags.    * 'has_parens' is important for overload checking, where    * we allow things like:     *     (gdb) break c::f(int)    */
comment|/* Maybe arg is FILE : LINENUM or FILE : FUNCTION */
name|is_quoted
operator|=
operator|(
operator|*
operator|*
name|argptr
operator|&&
name|strchr
argument_list|(
name|get_gdb_completer_quote_characters
argument_list|()
argument_list|,
operator|*
operator|*
name|argptr
argument_list|)
operator|!=
name|NULL
operator|)
expr_stmt|;
name|has_parens
operator|=
operator|(
operator|(
name|pp
operator|=
name|strchr
argument_list|(
operator|*
name|argptr
argument_list|,
literal|'('
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|(
name|pp
operator|=
name|strrchr
argument_list|(
name|pp
argument_list|,
literal|')'
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
expr_stmt|;
comment|/* Now that we're safely past the has_parens check,    * put back " if (condition)" so outer layers can see it     */
if|if
condition|(
name|has_if
condition|)
operator|*
name|ii
operator|=
literal|' '
expr_stmt|;
comment|/* Maybe we were called with a line range FILENAME:LINENUM,FILENAME:LINENUM      and we must isolate the first half.  Outer layers will call again later      for the second half.       Don't count commas that appear in argument lists of overloaded      functions, or in quoted strings.  It's stupid to go to this much      trouble when the rest of the function is such an obvious roach hotel.  */
name|ii
operator|=
name|find_toplevel_char
argument_list|(
operator|*
name|argptr
argument_list|,
literal|','
argument_list|)
expr_stmt|;
name|has_comma
operator|=
operator|(
name|ii
operator|!=
literal|0
operator|)
expr_stmt|;
comment|/* Temporarily zap out second half to not    * confuse the code below.    * This is undone below. Do not change ii!!    */
if|if
condition|(
name|has_comma
condition|)
block|{
operator|*
name|ii
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* Maybe arg is FILE : LINENUM or FILE : FUNCTION */
comment|/* May also be CLASS::MEMBER, or NAMESPACE::NAME */
comment|/* Look for ':', but ignore inside of<> */
name|s
operator|=
name|NULL
expr_stmt|;
name|p
operator|=
operator|*
name|argptr
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'"'
condition|)
block|{
name|is_quote_enclosed
operator|=
literal|1
expr_stmt|;
operator|(
operator|*
name|argptr
operator|)
operator|++
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
else|else
name|is_quote_enclosed
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'<'
condition|)
block|{
name|char
modifier|*
name|temp_end
init|=
name|find_template_name_end
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|temp_end
condition|)
name|error
argument_list|(
literal|"malformed template specification in command"
argument_list|)
expr_stmt|;
name|p
operator|=
name|temp_end
expr_stmt|;
block|}
comment|/* Check for the end of the first half of the linespec.  End of line,          a tab, a double colon or the last single colon, or a space.  But          if enclosed in double quotes we do not break on enclosed spaces */
if|if
condition|(
operator|!
operator|*
name|p
operator|||
name|p
index|[
literal|0
index|]
operator|==
literal|'\t'
operator|||
operator|(
operator|(
name|p
index|[
literal|0
index|]
operator|==
literal|':'
operator|)
operator|&&
operator|(
operator|(
name|p
index|[
literal|1
index|]
operator|==
literal|':'
operator|)
operator|||
operator|(
name|strchr
argument_list|(
name|p
operator|+
literal|1
argument_list|,
literal|':'
argument_list|)
operator|==
name|NULL
operator|)
operator|)
operator|)
operator|||
operator|(
operator|(
name|p
index|[
literal|0
index|]
operator|==
literal|' '
operator|)
operator|&&
operator|!
name|is_quote_enclosed
operator|)
condition|)
break|break;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|strchr
argument_list|(
name|p
argument_list|,
literal|':'
argument_list|)
operator|==
name|NULL
condition|)
comment|/* Java qualified method. */
block|{
comment|/* Find the *last* '.', since the others are package qualifiers. */
for|for
control|(
name|p1
operator|=
name|p
init|;
operator|*
name|p1
condition|;
name|p1
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p1
operator|==
literal|'.'
condition|)
name|p
operator|=
name|p1
expr_stmt|;
block|}
break|break;
block|}
block|}
while|while
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|' '
operator|||
name|p
index|[
literal|0
index|]
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
comment|/* if the closing double quote was left at the end, remove it */
if|if
condition|(
name|is_quote_enclosed
condition|)
block|{
name|char
modifier|*
name|closing_quote
init|=
name|strchr
argument_list|(
name|p
operator|-
literal|1
argument_list|,
literal|'"'
argument_list|)
decl_stmt|;
if|if
condition|(
name|closing_quote
operator|&&
name|closing_quote
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
operator|*
name|closing_quote
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* Now that we've safely parsed the first half,    * put back ',' so outer layers can see it     */
if|if
condition|(
name|has_comma
condition|)
operator|*
name|ii
operator|=
literal|','
expr_stmt|;
if|if
condition|(
operator|(
name|p
index|[
literal|0
index|]
operator|==
literal|':'
operator|||
name|p
index|[
literal|0
index|]
operator|==
literal|'.'
operator|)
operator|&&
operator|!
name|has_parens
condition|)
block|{
comment|/*  C++ */
comment|/*  ... or Java */
if|if
condition|(
name|is_quoted
condition|)
operator|*
name|argptr
operator|=
operator|*
name|argptr
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'.'
operator|||
name|p
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
block|{
name|char
modifier|*
name|saved_arg2
init|=
operator|*
name|argptr
decl_stmt|;
name|char
modifier|*
name|temp_end
decl_stmt|;
comment|/* First check for "global" namespace specification, 	     of the form "::foo". If found, skip over the colons 	     and jump to normal symbol processing */
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|':'
operator|&&
operator|(
operator|(
operator|*
name|argptr
operator|==
name|p
operator|)
operator|||
operator|(
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
operator|)
operator|||
operator|(
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'\t'
operator|)
operator|)
condition|)
name|saved_arg2
operator|+=
literal|2
expr_stmt|;
comment|/* We have what looks like a class or namespace 	     scope specification (A::B), possibly with many 	     levels of namespaces or classes (A::B::C::D).  	     Some versions of the HP ANSI C++ compiler (as also possibly 	     other compilers) generate class/function/member names with 	     embedded double-colons if they are inside namespaces. To 	     handle this, we loop a few times, considering larger and 	     larger prefixes of the string as though they were single 	     symbols.  So, if the initially supplied string is 	     A::B::C::D::foo, we have to look up "A", then "A::B", 	     then "A::B::C", then "A::B::C::D", and finally 	     "A::B::C::D::foo" as single, monolithic symbols, because 	     A, B, C or D may be namespaces.  	     Note that namespaces can nest only inside other 	     namespaces, and not inside classes.  So we need only 	     consider *prefixes* of the string; there is no need to look up 	     "B::C" separately as a symbol in the previous example. */
name|p2
operator|=
name|p
expr_stmt|;
comment|/* save for restart */
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Extract the class name.  */
name|p1
operator|=
name|p
expr_stmt|;
while|while
condition|(
name|p
operator|!=
operator|*
name|argptr
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
operator|--
name|p
expr_stmt|;
name|copy
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|p
operator|-
operator|*
name|argptr
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|copy
argument_list|,
operator|*
name|argptr
argument_list|,
name|p
operator|-
operator|*
name|argptr
argument_list|)
expr_stmt|;
name|copy
index|[
name|p
operator|-
operator|*
name|argptr
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Discard the class name from the arg.  */
name|p
operator|=
name|p1
operator|+
operator|(
name|p1
index|[
literal|0
index|]
operator|==
literal|':'
condition|?
literal|2
else|:
literal|1
operator|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
operator|*
name|argptr
operator|=
name|p
expr_stmt|;
name|sym_class
operator|=
name|lookup_symbol
argument_list|(
name|copy
argument_list|,
literal|0
argument_list|,
name|STRUCT_NAMESPACE
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|symtab
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym_class
operator|&&
operator|(
name|t
operator|=
name|check_typedef
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym_class
argument_list|)
argument_list|)
operator|,
operator|(
name|TYPE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
operator|||
name|TYPE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_CODE_UNION
operator|)
operator|)
condition|)
block|{
comment|/* Arg token is not digits => try it as a function name 		     Find the next token(everything up to end or next blank). */
if|if
condition|(
operator|*
operator|*
name|argptr
operator|&&
name|strchr
argument_list|(
name|get_gdb_completer_quote_characters
argument_list|()
argument_list|,
operator|*
operator|*
name|argptr
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|p
operator|=
name|skip_quoted
argument_list|(
operator|*
name|argptr
argument_list|)
expr_stmt|;
operator|*
name|argptr
operator|=
operator|*
name|argptr
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
operator|*
name|argptr
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|' '
operator|&&
operator|*
name|p
operator|!=
literal|'\t'
operator|&&
operator|*
name|p
operator|!=
literal|','
operator|&&
operator|*
name|p
operator|!=
literal|':'
condition|)
name|p
operator|++
expr_stmt|;
block|}
comment|/*    q = operator_chars (*argptr,&q1);    if (q1 - q)    {    char *opname;    char *tmp = alloca (q1 - q + 1);    memcpy (tmp, q, q1 - q);    tmp[q1 - q] = '\0';    opname = cplus_mangle_opname (tmp, DMGL_ANSI);    if (opname == NULL)    {    cplusplus_error (saved_arg, "no mangling for \"%s\"\n", tmp);    }    copy = (char*) alloca (3 + strlen(opname));    sprintf (copy, "__%s", opname);    p = q1;    }    else  */
block|{
name|copy
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|p
operator|-
operator|*
name|argptr
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|copy
argument_list|,
operator|*
name|argptr
argument_list|,
name|p
operator|-
operator|*
name|argptr
argument_list|)
expr_stmt|;
name|copy
index|[
name|p
operator|-
operator|*
name|argptr
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|p
operator|!=
operator|*
name|argptr
operator|&&
name|copy
index|[
name|p
operator|-
operator|*
name|argptr
operator|-
literal|1
index|]
operator|&&
name|strchr
argument_list|(
name|get_gdb_completer_quote_characters
argument_list|()
argument_list|,
name|copy
index|[
name|p
operator|-
operator|*
name|argptr
operator|-
literal|1
index|]
argument_list|)
operator|!=
name|NULL
condition|)
name|copy
index|[
name|p
operator|-
operator|*
name|argptr
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* no line number may be specified */
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
operator|*
name|argptr
operator|=
name|p
expr_stmt|;
name|sym
operator|=
literal|0
expr_stmt|;
name|i1
operator|=
literal|0
expr_stmt|;
comment|/*  counter for the symbol array */
name|sym_arr
operator|=
operator|(
expr|struct
name|symbol
operator|*
operator|*
operator|)
name|alloca
argument_list|(
name|total_number_of_methods
argument_list|(
name|t
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|destructor_name_p
argument_list|(
name|copy
argument_list|,
name|t
argument_list|)
condition|)
block|{
comment|/* Destructors are a special case.  */
name|int
name|m_index
decl_stmt|,
name|f_index
decl_stmt|;
if|if
condition|(
name|get_destructor_fn_field
argument_list|(
name|t
argument_list|,
operator|&
name|m_index
argument_list|,
operator|&
name|f_index
argument_list|)
condition|)
block|{
name|struct
name|fn_field
modifier|*
name|f
init|=
name|TYPE_FN_FIELDLIST1
argument_list|(
name|t
argument_list|,
name|m_index
argument_list|)
decl_stmt|;
name|sym_arr
index|[
name|i1
index|]
operator|=
name|lookup_symbol
argument_list|(
name|TYPE_FN_FIELD_PHYSNAME
argument_list|(
name|f
argument_list|,
name|f_index
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|VAR_NAMESPACE
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
operator|(
expr|struct
name|symtab
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym_arr
index|[
name|i1
index|]
condition|)
name|i1
operator|++
expr_stmt|;
block|}
block|}
else|else
name|i1
operator|=
name|find_methods
argument_list|(
name|t
argument_list|,
name|copy
argument_list|,
name|sym_arr
argument_list|)
expr_stmt|;
if|if
condition|(
name|i1
operator|==
literal|1
condition|)
block|{
comment|/* There is exactly one field with that name.  */
name|sym
operator|=
name|sym_arr
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|sym
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_BLOCK
condition|)
block|{
name|values
operator|.
name|sals
operator|=
operator|(
expr|struct
name|symtab_and_line
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|symtab_and_line
argument_list|)
argument_list|)
expr_stmt|;
name|values
operator|.
name|nelts
operator|=
literal|1
expr_stmt|;
name|values
operator|.
name|sals
index|[
literal|0
index|]
operator|=
name|find_function_start_sal
argument_list|(
name|sym
argument_list|,
name|funfirstline
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|values
operator|.
name|nelts
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|values
return|;
block|}
if|if
condition|(
name|i1
operator|>
literal|0
condition|)
block|{
comment|/* There is more than one field with that name 		         (overloaded).  Ask the user which one to use.  */
return|return
name|decode_line_2
argument_list|(
name|sym_arr
argument_list|,
name|i1
argument_list|,
name|funfirstline
argument_list|,
name|canonical
argument_list|)
return|;
block|}
else|else
block|{
name|char
modifier|*
name|tmp
decl_stmt|;
if|if
condition|(
name|is_operator_name
argument_list|(
name|copy
argument_list|)
condition|)
block|{
name|tmp
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|copy
operator|+
literal|3
argument_list|)
operator|+
literal|9
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|tmp
argument_list|,
literal|"operator "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmp
argument_list|,
name|copy
operator|+
literal|3
argument_list|)
expr_stmt|;
block|}
else|else
name|tmp
operator|=
name|copy
expr_stmt|;
if|if
condition|(
name|tmp
index|[
literal|0
index|]
operator|==
literal|'~'
condition|)
name|cplusplus_error
argument_list|(
name|saved_arg
argument_list|,
literal|"the class `%s' does not have destructor defined\n"
argument_list|,
name|SYMBOL_SOURCE_NAME
argument_list|(
name|sym_class
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|cplusplus_error
argument_list|(
name|saved_arg
argument_list|,
literal|"the class %s does not have any method named %s\n"
argument_list|,
name|SYMBOL_SOURCE_NAME
argument_list|(
name|sym_class
argument_list|)
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Move pointer up to next possible class/namespace token */
name|p
operator|=
name|p2
operator|+
literal|1
expr_stmt|;
comment|/* restart with old value +1 */
comment|/* Move pointer ahead to next double-colon */
while|while
condition|(
operator|*
name|p
operator|&&
operator|(
name|p
index|[
literal|0
index|]
operator|!=
literal|' '
operator|)
operator|&&
operator|(
name|p
index|[
literal|0
index|]
operator|!=
literal|'\t'
operator|)
operator|&&
operator|(
name|p
index|[
literal|0
index|]
operator|!=
literal|'\''
operator|)
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'<'
condition|)
block|{
name|temp_end
operator|=
name|find_template_name_end
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|temp_end
condition|)
name|error
argument_list|(
literal|"malformed template specification in command"
argument_list|)
expr_stmt|;
name|p
operator|=
name|temp_end
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|p
index|[
literal|0
index|]
operator|==
literal|':'
operator|)
operator|&&
operator|(
name|p
index|[
literal|1
index|]
operator|==
literal|':'
operator|)
condition|)
break|break;
comment|/* found double-colon */
else|else
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
operator|!=
literal|':'
condition|)
break|break;
comment|/* out of the while (1) */
name|p2
operator|=
name|p
expr_stmt|;
comment|/* save restart for next time around */
operator|*
name|argptr
operator|=
name|saved_arg2
expr_stmt|;
comment|/* restore argptr */
block|}
comment|/* while (1) */
comment|/* Last chance attempt -- check entire name as a symbol */
comment|/* Use "copy" in preparation for jumping out of this block, 	     to be consistent with usage following the jump target */
name|copy
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|p
operator|-
name|saved_arg2
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|copy
argument_list|,
name|saved_arg2
argument_list|,
name|p
operator|-
name|saved_arg2
argument_list|)
expr_stmt|;
comment|/* Note: if is_quoted should be true, we snuff out quote here anyway */
name|copy
index|[
name|p
operator|-
name|saved_arg2
index|]
operator|=
literal|'\000'
expr_stmt|;
comment|/* Set argptr to skip over the name */
operator|*
name|argptr
operator|=
operator|(
operator|*
name|p
operator|==
literal|'\''
operator|)
condition|?
name|p
operator|+
literal|1
else|:
name|p
expr_stmt|;
comment|/* Look up entire name */
name|sym
operator|=
name|lookup_symbol
argument_list|(
name|copy
argument_list|,
literal|0
argument_list|,
name|VAR_NAMESPACE
argument_list|,
literal|0
argument_list|,
operator|&
name|sym_symtab
argument_list|)
expr_stmt|;
name|s
operator|=
operator|(
expr|struct
name|symtab
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* Prepare to jump: restore the " if (condition)" so outer layers see it */
comment|/* Symbol was found --> jump to normal symbol processing. 	     Code following "symbol_found" expects "copy" to have the 	     symbol name, "sym" to have the symbol pointer, "s" to be 	     a specified file's symtab, and sym_symtab to be the symbol's 	     symtab. */
comment|/* By jumping there we avoid falling through the FILE:LINE and 	     FILE:FUNC processing stuff below */
if|if
condition|(
name|sym
condition|)
goto|goto
name|symbol_found
goto|;
comment|/* Couldn't find any interpretation as classes/namespaces, so give up */
comment|/* The quotes are important if copy is empty.  */
name|cplusplus_error
argument_list|(
name|saved_arg
argument_list|,
literal|"Can't find member of namespace, class, struct, or union named \"%s\"\n"
argument_list|,
name|copy
argument_list|)
expr_stmt|;
block|}
comment|/*  end of C++  */
comment|/* Extract the file name.  */
name|p1
operator|=
name|p
expr_stmt|;
while|while
condition|(
name|p
operator|!=
operator|*
name|argptr
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
operator|--
name|p
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|p
operator|==
literal|'"'
operator|)
operator|&&
name|is_quote_enclosed
condition|)
operator|--
name|p
expr_stmt|;
name|copy
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|p
operator|-
operator|*
name|argptr
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
operator|*
name|argptr
operator|==
literal|'"'
operator|)
operator|&&
name|is_quote_enclosed
condition|)
block|{
name|memcpy
argument_list|(
name|copy
argument_list|,
operator|*
name|argptr
operator|+
literal|1
argument_list|,
name|p
operator|-
operator|*
name|argptr
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* It may have the ending quote right after the file name */
if|if
condition|(
name|copy
index|[
name|p
operator|-
operator|*
name|argptr
operator|-
literal|2
index|]
operator|==
literal|'"'
condition|)
name|copy
index|[
name|p
operator|-
operator|*
name|argptr
operator|-
literal|2
index|]
operator|=
literal|0
expr_stmt|;
else|else
name|copy
index|[
name|p
operator|-
operator|*
name|argptr
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|copy
argument_list|,
operator|*
name|argptr
argument_list|,
name|p
operator|-
operator|*
name|argptr
argument_list|)
expr_stmt|;
name|copy
index|[
name|p
operator|-
operator|*
name|argptr
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Find that file's data.  */
name|s
operator|=
name|lookup_symtab
argument_list|(
name|copy
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|have_full_symbols
argument_list|()
operator|&&
operator|!
name|have_partial_symbols
argument_list|()
condition|)
name|error
argument_list|(
literal|"No symbol table is loaded.  Use the \"file\" command."
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"No source file named %s."
argument_list|,
name|copy
argument_list|)
expr_stmt|;
block|}
comment|/* Discard the file name from the arg.  */
name|p
operator|=
name|p1
operator|+
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
operator|*
name|argptr
operator|=
name|p
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* No one really seems to know why this was added. It certainly      breaks the command line, though, whenever the passed      name is of the form ClassName::Method. This bit of code      singles out the class name, and if funfirstline is set (for      example, you are setting a breakpoint at this function),      you get an error. This did not occur with earlier      verions, so I am ifdef'ing this out. 3/29/99 */
block|else     {
comment|/* Check if what we have till now is a symbol name */
comment|/* We may be looking at a template instantiation such          as "foo<int>".  Check here whether we know about it,          instead of falling through to the code below which          handles ordinary function names, because that code          doesn't like seeing '<' and '>' in a name -- the          skip_quoted call doesn't go past them.  So see if we          can figure it out right now. */
block|copy = (char *) alloca (p - *argptr + 1);       memcpy (copy, *argptr, p - *argptr);       copy[p - *argptr] = '\000';       sym = lookup_symbol (copy, 0, VAR_NAMESPACE, 0,&sym_symtab);       if (sym) 	{
comment|/* Yes, we have a symbol; jump to symbol processing */
comment|/* Code after symbol_found expects S, SYM_SYMTAB, SYM,  	     and COPY to be set correctly */
block|*argptr = (*p == '\'') ? p + 1 : p; 	  s = (struct symtab *) 0; 	  goto symbol_found; 	}
comment|/* Otherwise fall out from here and go to file/line spec          processing, etc. */
block|}
endif|#
directive|endif
comment|/* S is specified file's symtab, or 0 if no file specified.      arg no longer contains the file name.  */
comment|/* Check whether arg is all digits (and sign) */
name|q
operator|=
operator|*
name|argptr
expr_stmt|;
if|if
condition|(
operator|*
name|q
operator|==
literal|'-'
operator|||
operator|*
name|q
operator|==
literal|'+'
condition|)
name|q
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|q
operator|>=
literal|'0'
operator|&&
operator|*
name|q
operator|<=
literal|'9'
condition|)
name|q
operator|++
expr_stmt|;
if|if
condition|(
name|q
operator|!=
operator|*
name|argptr
operator|&&
operator|(
operator|*
name|q
operator|==
literal|0
operator|||
operator|*
name|q
operator|==
literal|' '
operator|||
operator|*
name|q
operator|==
literal|'\t'
operator|||
operator|*
name|q
operator|==
literal|','
operator|)
condition|)
block|{
comment|/* We found a token consisting of all digits -- at least one digit.  */
enum|enum
name|sign
block|{
name|none
block|,
name|plus
block|,
name|minus
block|}
name|sign
init|=
name|none
enum|;
comment|/* We might need a canonical line spec if no file was specified.  */
name|int
name|need_canonical
init|=
operator|(
name|s
operator|==
literal|0
operator|)
condition|?
literal|1
else|:
literal|0
decl_stmt|;
comment|/* This is where we need to make sure that we have good defaults.          We must guarantee that this section of code is never executed          when we are called with just a function name, since          select_source_symtab calls us with such an argument  */
if|if
condition|(
name|s
operator|==
literal|0
operator|&&
name|default_symtab
operator|==
literal|0
condition|)
block|{
name|select_source_symtab
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|default_symtab
operator|=
name|current_source_symtab
expr_stmt|;
name|default_line
operator|=
name|current_source_line
expr_stmt|;
block|}
if|if
condition|(
operator|*
operator|*
name|argptr
operator|==
literal|'+'
condition|)
name|sign
operator|=
name|plus
operator|,
operator|(
operator|*
name|argptr
operator|)
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
operator|*
name|argptr
operator|==
literal|'-'
condition|)
name|sign
operator|=
name|minus
operator|,
operator|(
operator|*
name|argptr
operator|)
operator|++
expr_stmt|;
name|val
operator|.
name|line
operator|=
name|atoi
argument_list|(
operator|*
name|argptr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sign
condition|)
block|{
case|case
name|plus
case|:
if|if
condition|(
name|q
operator|==
operator|*
name|argptr
condition|)
name|val
operator|.
name|line
operator|=
literal|5
expr_stmt|;
if|if
condition|(
name|s
operator|==
literal|0
condition|)
name|val
operator|.
name|line
operator|=
name|default_line
operator|+
name|val
operator|.
name|line
expr_stmt|;
break|break;
case|case
name|minus
case|:
if|if
condition|(
name|q
operator|==
operator|*
name|argptr
condition|)
name|val
operator|.
name|line
operator|=
literal|15
expr_stmt|;
if|if
condition|(
name|s
operator|==
literal|0
condition|)
name|val
operator|.
name|line
operator|=
name|default_line
operator|-
name|val
operator|.
name|line
expr_stmt|;
else|else
name|val
operator|.
name|line
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|none
case|:
break|break;
comment|/* No need to adjust val.line.  */
block|}
while|while
condition|(
operator|*
name|q
operator|==
literal|' '
operator|||
operator|*
name|q
operator|==
literal|'\t'
condition|)
name|q
operator|++
expr_stmt|;
operator|*
name|argptr
operator|=
name|q
expr_stmt|;
if|if
condition|(
name|s
operator|==
literal|0
condition|)
name|s
operator|=
name|default_symtab
expr_stmt|;
comment|/* It is possible that this source file has more than one symtab,           and that the new line number specification has moved us from the          default (in s) to a new one.  */
name|val
operator|.
name|symtab
operator|=
name|find_line_symtab
argument_list|(
name|s
argument_list|,
name|val
operator|.
name|line
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|.
name|symtab
operator|==
literal|0
condition|)
name|val
operator|.
name|symtab
operator|=
name|s
expr_stmt|;
name|val
operator|.
name|pc
operator|=
literal|0
expr_stmt|;
name|values
operator|.
name|sals
operator|=
operator|(
expr|struct
name|symtab_and_line
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|symtab_and_line
argument_list|)
argument_list|)
expr_stmt|;
name|values
operator|.
name|sals
index|[
literal|0
index|]
operator|=
name|val
expr_stmt|;
name|values
operator|.
name|nelts
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|need_canonical
condition|)
name|build_canonical_line_spec
argument_list|(
name|values
operator|.
name|sals
argument_list|,
name|NULL
argument_list|,
name|canonical
argument_list|)
expr_stmt|;
return|return
name|values
return|;
block|}
comment|/* Arg token is not digits => try it as a variable name      Find the next token (everything up to end or next whitespace).  */
if|if
condition|(
operator|*
operator|*
name|argptr
operator|==
literal|'$'
condition|)
comment|/* May be a convenience variable */
name|p
operator|=
name|skip_quoted
argument_list|(
operator|*
name|argptr
operator|+
operator|(
operator|(
operator|(
operator|*
name|argptr
operator|)
index|[
literal|1
index|]
operator|==
literal|'$'
operator|)
condition|?
literal|2
else|:
literal|1
operator|)
argument_list|)
expr_stmt|;
comment|/* One or two $ chars possible */
elseif|else
if|if
condition|(
name|is_quoted
condition|)
block|{
name|p
operator|=
name|skip_quoted
argument_list|(
operator|*
name|argptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\''
condition|)
name|error
argument_list|(
literal|"Unmatched single quote."
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|has_parens
condition|)
block|{
name|p
operator|=
name|pp
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|skip_quoted
argument_list|(
operator|*
name|argptr
argument_list|)
expr_stmt|;
block|}
name|copy
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|p
operator|-
operator|*
name|argptr
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|copy
argument_list|,
operator|*
name|argptr
argument_list|,
name|p
operator|-
operator|*
name|argptr
argument_list|)
expr_stmt|;
name|copy
index|[
name|p
operator|-
operator|*
name|argptr
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|p
operator|!=
operator|*
name|argptr
operator|&&
name|copy
index|[
literal|0
index|]
operator|&&
name|copy
index|[
literal|0
index|]
operator|==
name|copy
index|[
name|p
operator|-
operator|*
name|argptr
operator|-
literal|1
index|]
operator|&&
name|strchr
argument_list|(
name|get_gdb_completer_quote_characters
argument_list|()
argument_list|,
name|copy
index|[
literal|0
index|]
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|copy
index|[
name|p
operator|-
operator|*
name|argptr
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|copy
operator|++
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
operator|*
name|argptr
operator|=
name|p
expr_stmt|;
comment|/* If it starts with $: may be a legitimate variable or routine name      (e.g. HP-UX millicode routines such as $$dyncall), or it may      be history value, or it may be a convenience variable */
if|if
condition|(
operator|*
name|copy
operator|==
literal|'$'
condition|)
block|{
name|struct
name|value
modifier|*
name|valx
decl_stmt|;
name|int
name|index
init|=
literal|0
decl_stmt|;
name|int
name|need_canonical
init|=
literal|0
decl_stmt|;
name|p
operator|=
operator|(
name|copy
index|[
literal|1
index|]
operator|==
literal|'$'
operator|)
condition|?
name|copy
operator|+
literal|2
else|:
name|copy
operator|+
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|>=
literal|'0'
operator|&&
operator|*
name|p
operator|<=
literal|'9'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|p
condition|)
comment|/* reached end of token without hitting non-digit */
block|{
comment|/* We have a value history reference */
name|sscanf
argument_list|(
operator|(
name|copy
index|[
literal|1
index|]
operator|==
literal|'$'
operator|)
condition|?
name|copy
operator|+
literal|2
else|:
name|copy
operator|+
literal|1
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|index
argument_list|)
expr_stmt|;
name|valx
operator|=
name|access_value_history
argument_list|(
operator|(
name|copy
index|[
literal|1
index|]
operator|==
literal|'$'
operator|)
condition|?
operator|-
name|index
else|:
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|valx
argument_list|)
argument_list|)
operator|!=
name|TYPE_CODE_INT
condition|)
name|error
argument_list|(
literal|"History values used in line specs must have integer values."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Not all digits -- may be user variable/function or a 	     convenience variable */
comment|/* Look up entire name as a symbol first */
name|sym
operator|=
name|lookup_symbol
argument_list|(
name|copy
argument_list|,
literal|0
argument_list|,
name|VAR_NAMESPACE
argument_list|,
literal|0
argument_list|,
operator|&
name|sym_symtab
argument_list|)
expr_stmt|;
name|s
operator|=
operator|(
expr|struct
name|symtab
operator|*
operator|)
literal|0
expr_stmt|;
name|need_canonical
operator|=
literal|1
expr_stmt|;
comment|/* Symbol was found --> jump to normal symbol processing. 	     Code following "symbol_found" expects "copy" to have the 	     symbol name, "sym" to have the symbol pointer, "s" to be 	     a specified file's symtab, and sym_symtab to be the symbol's 	     symtab. */
if|if
condition|(
name|sym
condition|)
goto|goto
name|symbol_found
goto|;
comment|/* If symbol was not found, look in minimal symbol tables */
name|msymbol
operator|=
name|lookup_minimal_symbol
argument_list|(
name|copy
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Min symbol was found --> jump to minsym processing. */
if|if
condition|(
name|msymbol
condition|)
goto|goto
name|minimal_symbol_found
goto|;
comment|/* Not a user variable or function -- must be convenience variable */
name|need_canonical
operator|=
operator|(
name|s
operator|==
literal|0
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|valx
operator|=
name|value_of_internalvar
argument_list|(
name|lookup_internalvar
argument_list|(
name|copy
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|valx
argument_list|)
argument_list|)
operator|!=
name|TYPE_CODE_INT
condition|)
name|error
argument_list|(
literal|"Convenience variables used in line specs must have integer values."
argument_list|)
expr_stmt|;
block|}
comment|/* Either history value or convenience value from above, in valx */
name|val
operator|.
name|symtab
operator|=
name|s
condition|?
name|s
else|:
name|default_symtab
expr_stmt|;
name|val
operator|.
name|line
operator|=
name|value_as_long
argument_list|(
name|valx
argument_list|)
expr_stmt|;
name|val
operator|.
name|pc
operator|=
literal|0
expr_stmt|;
name|values
operator|.
name|sals
operator|=
operator|(
expr|struct
name|symtab_and_line
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
name|val
argument_list|)
expr_stmt|;
name|values
operator|.
name|sals
index|[
literal|0
index|]
operator|=
name|val
expr_stmt|;
name|values
operator|.
name|nelts
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|need_canonical
condition|)
name|build_canonical_line_spec
argument_list|(
name|values
operator|.
name|sals
argument_list|,
name|NULL
argument_list|,
name|canonical
argument_list|)
expr_stmt|;
return|return
name|values
return|;
block|}
comment|/* Look up that token as a variable.      If file specified, use that file's per-file block to start with.  */
name|sym
operator|=
name|lookup_symbol
argument_list|(
name|copy
argument_list|,
operator|(
name|s
condition|?
name|BLOCKVECTOR_BLOCK
argument_list|(
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
argument_list|,
name|STATIC_BLOCK
argument_list|)
else|:
name|get_selected_block
argument_list|()
operator|)
argument_list|,
name|VAR_NAMESPACE
argument_list|,
literal|0
argument_list|,
operator|&
name|sym_symtab
argument_list|)
expr_stmt|;
name|symbol_found
label|:
comment|/* We also jump here from inside the C++ class/namespace  				   code on finding a symbol of the form "A::B::C" */
if|if
condition|(
name|sym
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_BLOCK
condition|)
block|{
comment|/* Arg is the name of a function */
name|values
operator|.
name|sals
operator|=
operator|(
expr|struct
name|symtab_and_line
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|symtab_and_line
argument_list|)
argument_list|)
expr_stmt|;
name|values
operator|.
name|sals
index|[
literal|0
index|]
operator|=
name|find_function_start_sal
argument_list|(
name|sym
argument_list|,
name|funfirstline
argument_list|)
expr_stmt|;
name|values
operator|.
name|nelts
operator|=
literal|1
expr_stmt|;
comment|/* Don't use the SYMBOL_LINE; if used at all it points to 	     the line containing the parameters or thereabouts, not 	     the first line of code.  */
comment|/* We might need a canonical line spec if it is a static 	     function.  */
if|if
condition|(
name|s
operator|==
literal|0
condition|)
block|{
name|struct
name|blockvector
modifier|*
name|bv
init|=
name|BLOCKVECTOR
argument_list|(
name|sym_symtab
argument_list|)
decl_stmt|;
name|struct
name|block
modifier|*
name|b
init|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|STATIC_BLOCK
argument_list|)
decl_stmt|;
if|if
condition|(
name|lookup_block_symbol
argument_list|(
name|b
argument_list|,
name|copy
argument_list|,
name|VAR_NAMESPACE
argument_list|)
operator|!=
name|NULL
condition|)
name|build_canonical_line_spec
argument_list|(
name|values
operator|.
name|sals
argument_list|,
name|copy
argument_list|,
name|canonical
argument_list|)
expr_stmt|;
block|}
return|return
name|values
return|;
block|}
else|else
block|{
if|if
condition|(
name|funfirstline
condition|)
name|error
argument_list|(
literal|"\"%s\" is not a function"
argument_list|,
name|copy
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|SYMBOL_LINE
argument_list|(
name|sym
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* We know its line number.  */
name|values
operator|.
name|sals
operator|=
operator|(
expr|struct
name|symtab_and_line
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|symtab_and_line
argument_list|)
argument_list|)
expr_stmt|;
name|values
operator|.
name|nelts
operator|=
literal|1
expr_stmt|;
name|memset
argument_list|(
operator|&
name|values
operator|.
name|sals
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|values
operator|.
name|sals
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|values
operator|.
name|sals
index|[
literal|0
index|]
operator|.
name|symtab
operator|=
name|sym_symtab
expr_stmt|;
name|values
operator|.
name|sals
index|[
literal|0
index|]
operator|.
name|line
operator|=
name|SYMBOL_LINE
argument_list|(
name|sym
argument_list|)
expr_stmt|;
return|return
name|values
return|;
block|}
else|else
comment|/* This can happen if it is compiled with a compiler which doesn't 	       put out line numbers for variables.  */
comment|/* FIXME: Shouldn't we just set .line and .symtab to zero 	       and return?  For example, "info line foo" could print 	       the address.  */
name|error
argument_list|(
literal|"Line number not known for symbol \"%s\""
argument_list|,
name|copy
argument_list|)
expr_stmt|;
block|}
block|}
name|msymbol
operator|=
name|lookup_minimal_symbol
argument_list|(
name|copy
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|minimal_symbol_found
label|:
comment|/* We also jump here from the case for variables 				   that begin with '$' */
if|if
condition|(
name|msymbol
operator|!=
name|NULL
condition|)
block|{
name|values
operator|.
name|sals
operator|=
operator|(
expr|struct
name|symtab_and_line
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|symtab_and_line
argument_list|)
argument_list|)
expr_stmt|;
name|values
operator|.
name|sals
index|[
literal|0
index|]
operator|=
name|find_pc_sect_line
argument_list|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
argument_list|,
operator|(
expr|struct
name|sec
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|values
operator|.
name|sals
index|[
literal|0
index|]
operator|.
name|section
operator|=
name|SYMBOL_BFD_SECTION
argument_list|(
name|msymbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|funfirstline
condition|)
block|{
name|values
operator|.
name|sals
index|[
literal|0
index|]
operator|.
name|pc
operator|+=
name|FUNCTION_START_OFFSET
expr_stmt|;
name|values
operator|.
name|sals
index|[
literal|0
index|]
operator|.
name|pc
operator|=
name|SKIP_PROLOGUE
argument_list|(
name|values
operator|.
name|sals
index|[
literal|0
index|]
operator|.
name|pc
argument_list|)
expr_stmt|;
block|}
name|values
operator|.
name|nelts
operator|=
literal|1
expr_stmt|;
return|return
name|values
return|;
block|}
if|if
condition|(
operator|!
name|have_full_symbols
argument_list|()
operator|&&
operator|!
name|have_partial_symbols
argument_list|()
operator|&&
operator|!
name|have_minimal_symbols
argument_list|()
condition|)
name|error
argument_list|(
literal|"No symbol table is loaded.  Use the \"file\" command."
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Function \"%s\" not defined."
argument_list|,
name|copy
argument_list|)
expr_stmt|;
return|return
name|values
return|;
comment|/* for lint */
block|}
end_function

end_unit

