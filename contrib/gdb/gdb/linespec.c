begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Parser for linespec for the GNU debugger, GDB.    Copyright 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995,    1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004    Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"source.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"completer.h"
end_include

begin_include
include|#
directive|include
file|"cp-abi.h"
end_include

begin_include
include|#
directive|include
file|"parser-defs.h"
end_include

begin_include
include|#
directive|include
file|"block.h"
end_include

begin_include
include|#
directive|include
file|"objc-lang.h"
end_include

begin_include
include|#
directive|include
file|"linespec.h"
end_include

begin_comment
comment|/* We share this one with symtab.c, but it is not exported widely. */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|operator_chars
parameter_list|(
name|char
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Prototypes for local functions */
end_comment

begin_function_decl
specifier|static
name|void
name|initialize_defaults
parameter_list|(
name|struct
name|symtab
modifier|*
modifier|*
name|default_symtab
parameter_list|,
name|int
modifier|*
name|default_line
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_flags
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
modifier|*
name|is_quoted
parameter_list|,
name|char
modifier|*
modifier|*
name|paren_pointer
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|symtabs_and_lines
name|decode_indirect
parameter_list|(
name|char
modifier|*
modifier|*
name|argptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|locate_first_half
parameter_list|(
name|char
modifier|*
modifier|*
name|argptr
parameter_list|,
name|int
modifier|*
name|is_quote_enclosed
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|symtabs_and_lines
name|decode_objc
parameter_list|(
name|char
modifier|*
modifier|*
name|argptr
parameter_list|,
name|int
name|funfirstline
parameter_list|,
name|struct
name|symtab
modifier|*
name|file_symtab
parameter_list|,
name|char
modifier|*
modifier|*
modifier|*
name|canonical
parameter_list|,
name|char
modifier|*
name|saved_arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|symtabs_and_lines
name|decode_compound
parameter_list|(
name|char
modifier|*
modifier|*
name|argptr
parameter_list|,
name|int
name|funfirstline
parameter_list|,
name|char
modifier|*
modifier|*
modifier|*
name|canonical
parameter_list|,
name|char
modifier|*
name|saved_arg
parameter_list|,
name|char
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|symbol
modifier|*
name|lookup_prefix_sym
parameter_list|(
name|char
modifier|*
modifier|*
name|argptr
parameter_list|,
name|char
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|symtabs_and_lines
name|find_method
parameter_list|(
name|int
name|funfirstline
parameter_list|,
name|char
modifier|*
modifier|*
modifier|*
name|canonical
parameter_list|,
name|char
modifier|*
name|saved_arg
parameter_list|,
name|char
modifier|*
name|copy
parameter_list|,
name|struct
name|type
modifier|*
name|t
parameter_list|,
name|struct
name|symbol
modifier|*
name|sym_class
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|collect_methods
parameter_list|(
name|char
modifier|*
name|copy
parameter_list|,
name|struct
name|type
modifier|*
name|t
parameter_list|,
name|struct
name|symbol
modifier|*
modifier|*
name|sym_arr
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|NORETURN
name|void
name|cplusplus_error
argument_list|(
specifier|const
name|char
operator|*
name|name
argument_list|,
specifier|const
name|char
operator|*
name|fmt
argument_list|,
operator|...
argument_list|)
name|ATTR_NORETURN
name|ATTR_FORMAT
argument_list|(
name|printf
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|total_number_of_methods
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|find_methods
parameter_list|(
name|struct
name|type
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|struct
name|symbol
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|add_matching_methods
parameter_list|(
name|int
name|method_counter
parameter_list|,
name|struct
name|type
modifier|*
name|t
parameter_list|,
name|struct
name|symbol
modifier|*
modifier|*
name|sym_arr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|add_constructors
parameter_list|(
name|int
name|method_counter
parameter_list|,
name|struct
name|type
modifier|*
name|t
parameter_list|,
name|struct
name|symbol
modifier|*
modifier|*
name|sym_arr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|build_canonical_line_spec
parameter_list|(
name|struct
name|symtab_and_line
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|find_toplevel_char
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|char
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|is_objc_method_format
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|symtabs_and_lines
name|decode_line_2
parameter_list|(
name|struct
name|symbol
modifier|*
type|[]
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|symtab
modifier|*
name|symtab_from_filename
parameter_list|(
name|char
modifier|*
modifier|*
name|argptr
parameter_list|,
name|char
modifier|*
name|p
parameter_list|,
name|int
name|is_quote_enclosed
parameter_list|,
name|int
modifier|*
name|not_found_ptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|symtabs_and_lines
name|decode_all_digits
parameter_list|(
name|char
modifier|*
modifier|*
name|argptr
parameter_list|,
name|struct
name|symtab
modifier|*
name|default_symtab
parameter_list|,
name|int
name|default_line
parameter_list|,
name|char
modifier|*
modifier|*
modifier|*
name|canonical
parameter_list|,
name|struct
name|symtab
modifier|*
name|file_symtab
parameter_list|,
name|char
modifier|*
name|q
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|symtabs_and_lines
name|decode_dollar
parameter_list|(
name|char
modifier|*
name|copy
parameter_list|,
name|int
name|funfirstline
parameter_list|,
name|struct
name|symtab
modifier|*
name|default_symtab
parameter_list|,
name|char
modifier|*
modifier|*
modifier|*
name|canonical
parameter_list|,
name|struct
name|symtab
modifier|*
name|file_symtab
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|symtabs_and_lines
name|decode_variable
parameter_list|(
name|char
modifier|*
name|copy
parameter_list|,
name|int
name|funfirstline
parameter_list|,
name|char
modifier|*
modifier|*
modifier|*
name|canonical
parameter_list|,
name|struct
name|symtab
modifier|*
name|file_symtab
parameter_list|,
name|int
modifier|*
name|not_found_ptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|symtabs_and_lines
name|symbol_found
parameter_list|(
name|int
name|funfirstline
parameter_list|,
name|char
modifier|*
modifier|*
modifier|*
name|canonical
parameter_list|,
name|char
modifier|*
name|copy
parameter_list|,
name|struct
name|symbol
modifier|*
name|sym
parameter_list|,
name|struct
name|symtab
modifier|*
name|file_symtab
parameter_list|,
name|struct
name|symtab
modifier|*
name|sym_symtab
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|symtabs_and_lines
name|minsym_found
parameter_list|(
name|int
name|funfirstline
parameter_list|,
name|struct
name|minimal_symbol
modifier|*
name|msymbol
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Helper functions. */
end_comment

begin_comment
comment|/* Issue a helpful hint on using the command completion feature on    single quoted demangled C++ symbols as part of the completion    error.  */
end_comment

begin_function
specifier|static
name|NORETURN
name|void
name|cplusplus_error
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|struct
name|ui_file
modifier|*
name|tmp_stream
decl_stmt|;
name|tmp_stream
operator|=
name|mem_fileopen
argument_list|()
expr_stmt|;
name|make_cleanup_ui_file_delete
argument_list|(
name|tmp_stream
argument_list|)
expr_stmt|;
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vfprintf_unfiltered
argument_list|(
name|tmp_stream
argument_list|,
name|fmt
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|name
operator|==
literal|'\''
condition|)
name|name
operator|++
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|tmp_stream
argument_list|,
operator|(
literal|"Hint: try '%s<TAB> or '%s<ESC-?>\n"
literal|"(Note leading single quote.)"
operator|)
argument_list|,
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|error_stream
argument_list|(
name|tmp_stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the number of methods described for TYPE, including the    methods from types it derives from. This can't be done in the symbol    reader because the type of the baseclass might still be stubbed    when the definition of the derived class is parsed.  */
end_comment

begin_function
specifier|static
name|int
name|total_number_of_methods
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
name|int
name|count
decl_stmt|;
name|CHECK_TYPEDEF
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CPLUS_SPECIFIC
argument_list|(
name|type
argument_list|)
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|count
operator|=
name|TYPE_NFN_FIELDS_TOTAL
argument_list|(
name|type
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
condition|;
name|n
operator|++
control|)
name|count
operator|+=
name|total_number_of_methods
argument_list|(
name|TYPE_BASECLASS
argument_list|(
name|type
argument_list|,
name|n
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|count
return|;
block|}
end_function

begin_comment
comment|/* Recursive helper function for decode_line_1.    Look for methods named NAME in type T.    Return number of matches.    Put matches in SYM_ARR, which should have been allocated with    a size of total_number_of_methods (T) * sizeof (struct symbol *).    Note that this function is g++ specific.  */
end_comment

begin_function
specifier|static
name|int
name|find_methods
parameter_list|(
name|struct
name|type
modifier|*
name|t
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|symbol
modifier|*
modifier|*
name|sym_arr
parameter_list|)
block|{
name|int
name|i1
init|=
literal|0
decl_stmt|;
name|int
name|ibase
decl_stmt|;
name|char
modifier|*
name|class_name
init|=
name|type_name_no_tag
argument_list|(
name|t
argument_list|)
decl_stmt|;
comment|/* Ignore this class if it doesn't have a name.  This is ugly, but      unless we figure out how to get the physname without the name of      the class, then the loop can't do any good.  */
if|if
condition|(
name|class_name
operator|&&
operator|(
name|lookup_symbol
argument_list|(
name|class_name
argument_list|,
operator|(
expr|struct
name|block
operator|*
operator|)
name|NULL
argument_list|,
name|STRUCT_DOMAIN
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
operator|(
expr|struct
name|symtab
operator|*
operator|*
operator|)
name|NULL
argument_list|)
operator|)
condition|)
block|{
name|int
name|method_counter
decl_stmt|;
name|int
name|name_len
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|CHECK_TYPEDEF
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Loop over each method name.  At this level, all overloads of a name          are counted as a single name.  There is an inner loop which loops over          each overload.  */
for|for
control|(
name|method_counter
operator|=
name|TYPE_NFN_FIELDS
argument_list|(
name|t
argument_list|)
operator|-
literal|1
init|;
name|method_counter
operator|>=
literal|0
condition|;
operator|--
name|method_counter
control|)
block|{
name|char
modifier|*
name|method_name
init|=
name|TYPE_FN_FIELDLIST_NAME
argument_list|(
name|t
argument_list|,
name|method_counter
argument_list|)
decl_stmt|;
name|char
name|dem_opname
index|[
literal|64
index|]
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|method_name
argument_list|,
literal|"__"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|method_name
argument_list|,
literal|"op"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|method_name
argument_list|,
literal|"type"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|cplus_demangle_opname
argument_list|(
name|method_name
argument_list|,
name|dem_opname
argument_list|,
name|DMGL_ANSI
argument_list|)
condition|)
name|method_name
operator|=
name|dem_opname
expr_stmt|;
elseif|else
if|if
condition|(
name|cplus_demangle_opname
argument_list|(
name|method_name
argument_list|,
name|dem_opname
argument_list|,
literal|0
argument_list|)
condition|)
name|method_name
operator|=
name|dem_opname
expr_stmt|;
block|}
if|if
condition|(
name|strcmp_iw
argument_list|(
name|name
argument_list|,
name|method_name
argument_list|)
operator|==
literal|0
condition|)
comment|/* Find all the overloaded methods with that name.  */
name|i1
operator|+=
name|add_matching_methods
argument_list|(
name|method_counter
argument_list|,
name|t
argument_list|,
name|sym_arr
operator|+
name|i1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|class_name
argument_list|,
name|name
argument_list|,
name|name_len
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|class_name
index|[
name|name_len
index|]
operator|==
literal|'\0'
operator|||
name|class_name
index|[
name|name_len
index|]
operator|==
literal|'<'
operator|)
condition|)
name|i1
operator|+=
name|add_constructors
argument_list|(
name|method_counter
argument_list|,
name|t
argument_list|,
name|sym_arr
operator|+
name|i1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Only search baseclasses if there is no match yet, since names in      derived classes override those in baseclasses.       FIXME: The above is not true; it is only true of member functions      if they have the same number of arguments (??? - section 13.1 of the      ARM says the function members are not in the same scope but doesn't      really spell out the rules in a way I understand.  In any case, if      the number of arguments differ this is a case in which we can overload      rather than hiding without any problem, and gcc 2.4.5 does overload      rather than hiding in this case).  */
if|if
condition|(
name|i1
operator|==
literal|0
condition|)
for|for
control|(
name|ibase
operator|=
literal|0
init|;
name|ibase
operator|<
name|TYPE_N_BASECLASSES
argument_list|(
name|t
argument_list|)
condition|;
name|ibase
operator|++
control|)
name|i1
operator|+=
name|find_methods
argument_list|(
name|TYPE_BASECLASS
argument_list|(
name|t
argument_list|,
name|ibase
argument_list|)
argument_list|,
name|name
argument_list|,
name|sym_arr
operator|+
name|i1
argument_list|)
expr_stmt|;
return|return
name|i1
return|;
block|}
end_function

begin_comment
comment|/* Add the symbols associated to methods of the class whose type is T    and whose name matches the method indexed by METHOD_COUNTER in the    array SYM_ARR.  Return the number of methods added.  */
end_comment

begin_function
specifier|static
name|int
name|add_matching_methods
parameter_list|(
name|int
name|method_counter
parameter_list|,
name|struct
name|type
modifier|*
name|t
parameter_list|,
name|struct
name|symbol
modifier|*
modifier|*
name|sym_arr
parameter_list|)
block|{
name|int
name|field_counter
decl_stmt|;
name|int
name|i1
init|=
literal|0
decl_stmt|;
for|for
control|(
name|field_counter
operator|=
name|TYPE_FN_FIELDLIST_LENGTH
argument_list|(
name|t
argument_list|,
name|method_counter
argument_list|)
operator|-
literal|1
init|;
name|field_counter
operator|>=
literal|0
condition|;
operator|--
name|field_counter
control|)
block|{
name|struct
name|fn_field
modifier|*
name|f
decl_stmt|;
name|char
modifier|*
name|phys_name
decl_stmt|;
name|f
operator|=
name|TYPE_FN_FIELDLIST1
argument_list|(
name|t
argument_list|,
name|method_counter
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_FN_FIELD_STUB
argument_list|(
name|f
argument_list|,
name|field_counter
argument_list|)
condition|)
block|{
name|char
modifier|*
name|tmp_name
decl_stmt|;
name|tmp_name
operator|=
name|gdb_mangle_name
argument_list|(
name|t
argument_list|,
name|method_counter
argument_list|,
name|field_counter
argument_list|)
expr_stmt|;
name|phys_name
operator|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|tmp_name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|phys_name
argument_list|,
name|tmp_name
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|tmp_name
argument_list|)
expr_stmt|;
block|}
else|else
name|phys_name
operator|=
name|TYPE_FN_FIELD_PHYSNAME
argument_list|(
name|f
argument_list|,
name|field_counter
argument_list|)
expr_stmt|;
comment|/* Destructor is handled by caller, don't add it to 	 the list.  */
if|if
condition|(
name|is_destructor_name
argument_list|(
name|phys_name
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
name|sym_arr
index|[
name|i1
index|]
operator|=
name|lookup_symbol
argument_list|(
name|phys_name
argument_list|,
name|NULL
argument_list|,
name|VAR_DOMAIN
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
operator|(
expr|struct
name|symtab
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym_arr
index|[
name|i1
index|]
condition|)
name|i1
operator|++
expr_stmt|;
else|else
block|{
comment|/* This error message gets printed, but the method 	     still seems to be found 	     fputs_filtered("(Cannot find method ", gdb_stdout); 	     fprintf_symbol_filtered (gdb_stdout, phys_name, 	     language_cplus, 	     DMGL_PARAMS | DMGL_ANSI); 	     fputs_filtered(" - possibly inlined.)\n", gdb_stdout); 	  */
block|}
block|}
return|return
name|i1
return|;
block|}
end_function

begin_comment
comment|/* Add the symbols associated to constructors of the class whose type    is CLASS_TYPE and which are indexed by by METHOD_COUNTER to the    array SYM_ARR.  Return the number of methods added.  */
end_comment

begin_function
specifier|static
name|int
name|add_constructors
parameter_list|(
name|int
name|method_counter
parameter_list|,
name|struct
name|type
modifier|*
name|t
parameter_list|,
name|struct
name|symbol
modifier|*
modifier|*
name|sym_arr
parameter_list|)
block|{
name|int
name|field_counter
decl_stmt|;
name|int
name|i1
init|=
literal|0
decl_stmt|;
comment|/* For GCC 3.x and stabs, constructors and destructors      have names like __base_ctor and __complete_dtor.      Check the physname for now if we're looking for a      constructor.  */
for|for
control|(
name|field_counter
operator|=
name|TYPE_FN_FIELDLIST_LENGTH
argument_list|(
name|t
argument_list|,
name|method_counter
argument_list|)
operator|-
literal|1
init|;
name|field_counter
operator|>=
literal|0
condition|;
operator|--
name|field_counter
control|)
block|{
name|struct
name|fn_field
modifier|*
name|f
decl_stmt|;
name|char
modifier|*
name|phys_name
decl_stmt|;
name|f
operator|=
name|TYPE_FN_FIELDLIST1
argument_list|(
name|t
argument_list|,
name|method_counter
argument_list|)
expr_stmt|;
comment|/* GCC 3.x will never produce stabs stub methods, so 	 we don't need to handle this case.  */
if|if
condition|(
name|TYPE_FN_FIELD_STUB
argument_list|(
name|f
argument_list|,
name|field_counter
argument_list|)
condition|)
continue|continue;
name|phys_name
operator|=
name|TYPE_FN_FIELD_PHYSNAME
argument_list|(
name|f
argument_list|,
name|field_counter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_constructor_name
argument_list|(
name|phys_name
argument_list|)
condition|)
continue|continue;
comment|/* If this method is actually defined, include it in the 	 list.  */
name|sym_arr
index|[
name|i1
index|]
operator|=
name|lookup_symbol
argument_list|(
name|phys_name
argument_list|,
name|NULL
argument_list|,
name|VAR_DOMAIN
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
operator|(
expr|struct
name|symtab
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym_arr
index|[
name|i1
index|]
condition|)
name|i1
operator|++
expr_stmt|;
block|}
return|return
name|i1
return|;
block|}
end_function

begin_comment
comment|/* Helper function for decode_line_1.    Build a canonical line spec in CANONICAL if it is non-NULL and if    the SAL has a symtab.    If SYMNAME is non-NULL the canonical line spec is `filename:symname'.    If SYMNAME is NULL the line number from SAL is used and the canonical    line spec is `filename:linenum'.  */
end_comment

begin_function
specifier|static
name|void
name|build_canonical_line_spec
parameter_list|(
name|struct
name|symtab_and_line
modifier|*
name|sal
parameter_list|,
name|char
modifier|*
name|symname
parameter_list|,
name|char
modifier|*
modifier|*
modifier|*
name|canonical
parameter_list|)
block|{
name|char
modifier|*
modifier|*
name|canonical_arr
decl_stmt|;
name|char
modifier|*
name|canonical_name
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|struct
name|symtab
modifier|*
name|s
init|=
name|sal
operator|->
name|symtab
decl_stmt|;
if|if
condition|(
name|s
operator|==
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|NULL
operator|||
name|s
operator|->
name|filename
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
operator|||
name|canonical
operator|==
operator|(
name|char
operator|*
operator|*
operator|*
operator|)
name|NULL
condition|)
return|return;
name|canonical_arr
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|canonical
operator|=
name|canonical_arr
expr_stmt|;
name|filename
operator|=
name|s
operator|->
name|filename
expr_stmt|;
if|if
condition|(
name|symname
operator|!=
name|NULL
condition|)
block|{
name|canonical_name
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|filename
argument_list|)
operator|+
name|strlen
argument_list|(
name|symname
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|canonical_name
argument_list|,
literal|"%s:%s"
argument_list|,
name|filename
argument_list|,
name|symname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|canonical_name
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|filename
argument_list|)
operator|+
literal|30
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|canonical_name
argument_list|,
literal|"%s:%d"
argument_list|,
name|filename
argument_list|,
name|sal
operator|->
name|line
argument_list|)
expr_stmt|;
block|}
name|canonical_arr
index|[
literal|0
index|]
operator|=
name|canonical_name
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find an instance of the character C in the string S that is outside    of all parenthesis pairs, single-quoted strings, and double-quoted    strings.  Also, ignore the char within a template name, like a ','    within foo<int, int>.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|find_toplevel_char
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|char
name|c
parameter_list|)
block|{
name|int
name|quoted
init|=
literal|0
decl_stmt|;
comment|/* zero if we're not in quotes; 				   '"' if we're in a double-quoted string; 				   '\'' if we're in a single-quoted string.  */
name|int
name|depth
init|=
literal|0
decl_stmt|;
comment|/* Number of unclosed parens we've seen.  */
name|char
modifier|*
name|scan
decl_stmt|;
for|for
control|(
name|scan
operator|=
name|s
init|;
operator|*
name|scan
condition|;
name|scan
operator|++
control|)
block|{
if|if
condition|(
name|quoted
condition|)
block|{
if|if
condition|(
operator|*
name|scan
operator|==
name|quoted
condition|)
name|quoted
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|scan
operator|==
literal|'\\'
operator|&&
operator|*
operator|(
name|scan
operator|+
literal|1
operator|)
condition|)
name|scan
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|scan
operator|==
name|c
operator|&&
operator|!
name|quoted
operator|&&
name|depth
operator|==
literal|0
condition|)
return|return
name|scan
return|;
elseif|else
if|if
condition|(
operator|*
name|scan
operator|==
literal|'"'
operator|||
operator|*
name|scan
operator|==
literal|'\''
condition|)
name|quoted
operator|=
operator|*
name|scan
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|scan
operator|==
literal|'('
operator|||
operator|*
name|scan
operator|==
literal|'<'
condition|)
name|depth
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|*
name|scan
operator|==
literal|')'
operator|||
operator|*
name|scan
operator|==
literal|'>'
operator|)
operator|&&
name|depth
operator|>
literal|0
condition|)
name|depth
operator|--
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Determines if the gives string corresponds to an Objective-C method    representation, such as -[Foo bar:] or +[Foo bar]. Objective-C symbols    are allowed to have spaces and parentheses in them.  */
end_comment

begin_function
specifier|static
name|int
name|is_objc_method_format
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|*
name|s
operator|==
literal|'\0'
condition|)
return|return
literal|0
return|;
comment|/* Handle arguments with the format FILENAME:SYMBOL.  */
if|if
condition|(
operator|(
name|s
index|[
literal|0
index|]
operator|==
literal|':'
operator|)
operator|&&
operator|(
name|strchr
argument_list|(
literal|"+-"
argument_list|,
name|s
index|[
literal|1
index|]
argument_list|)
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|s
index|[
literal|2
index|]
operator|==
literal|'['
operator|)
operator|&&
name|strchr
argument_list|(
name|s
argument_list|,
literal|']'
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Handle arguments that are just SYMBOL.  */
elseif|else
if|if
condition|(
operator|(
name|strchr
argument_list|(
literal|"+-"
argument_list|,
name|s
index|[
literal|0
index|]
argument_list|)
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|s
index|[
literal|1
index|]
operator|==
literal|'['
operator|)
operator|&&
name|strchr
argument_list|(
name|s
argument_list|,
literal|']'
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Given a list of NELTS symbols in SYM_ARR, return a list of lines to    operate on (ask user if necessary).    If CANONICAL is non-NULL return a corresponding array of mangled names    as canonical line specs there.  */
end_comment

begin_function
specifier|static
name|struct
name|symtabs_and_lines
name|decode_line_2
parameter_list|(
name|struct
name|symbol
modifier|*
name|sym_arr
index|[]
parameter_list|,
name|int
name|nelts
parameter_list|,
name|int
name|funfirstline
parameter_list|,
name|char
modifier|*
modifier|*
modifier|*
name|canonical
parameter_list|)
block|{
name|struct
name|symtabs_and_lines
name|values
decl_stmt|,
name|return_values
decl_stmt|;
name|char
modifier|*
name|args
decl_stmt|,
modifier|*
name|arg1
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|prompt
decl_stmt|;
name|char
modifier|*
name|symname
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|char
modifier|*
modifier|*
name|canonical_arr
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
name|values
operator|.
name|sals
operator|=
operator|(
expr|struct
name|symtab_and_line
operator|*
operator|)
name|alloca
argument_list|(
name|nelts
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|symtab_and_line
argument_list|)
argument_list|)
expr_stmt|;
name|return_values
operator|.
name|sals
operator|=
operator|(
expr|struct
name|symtab_and_line
operator|*
operator|)
name|xmalloc
argument_list|(
name|nelts
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|symtab_and_line
argument_list|)
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|return_values
operator|.
name|sals
argument_list|)
expr_stmt|;
if|if
condition|(
name|canonical
condition|)
block|{
name|canonical_arr
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|nelts
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|canonical_arr
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|canonical_arr
argument_list|,
literal|0
argument_list|,
name|nelts
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|canonical
operator|=
name|canonical_arr
expr_stmt|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"[0] cancel\n[1] all\n"
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|nelts
condition|)
block|{
name|init_sal
argument_list|(
operator|&
name|return_values
operator|.
name|sals
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Initialize to zeroes.  */
name|init_sal
argument_list|(
operator|&
name|values
operator|.
name|sals
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym_arr
index|[
name|i
index|]
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|sym_arr
index|[
name|i
index|]
argument_list|)
operator|==
name|LOC_BLOCK
condition|)
block|{
name|values
operator|.
name|sals
index|[
name|i
index|]
operator|=
name|find_function_start_sal
argument_list|(
name|sym_arr
index|[
name|i
index|]
argument_list|,
name|funfirstline
argument_list|)
expr_stmt|;
if|if
condition|(
name|values
operator|.
name|sals
index|[
name|i
index|]
operator|.
name|symtab
condition|)
name|printf_unfiltered
argument_list|(
literal|"[%d] %s at %s:%d\n"
argument_list|,
operator|(
name|i
operator|+
literal|2
operator|)
argument_list|,
name|SYMBOL_PRINT_NAME
argument_list|(
name|sym_arr
index|[
name|i
index|]
argument_list|)
argument_list|,
name|values
operator|.
name|sals
index|[
name|i
index|]
operator|.
name|symtab
operator|->
name|filename
argument_list|,
name|values
operator|.
name|sals
index|[
name|i
index|]
operator|.
name|line
argument_list|)
expr_stmt|;
else|else
name|printf_unfiltered
argument_list|(
literal|"[%d] %s at ?FILE:%d [No symtab? Probably broken debug info...]\n"
argument_list|,
operator|(
name|i
operator|+
literal|2
operator|)
argument_list|,
name|SYMBOL_PRINT_NAME
argument_list|(
name|sym_arr
index|[
name|i
index|]
argument_list|)
argument_list|,
name|values
operator|.
name|sals
index|[
name|i
index|]
operator|.
name|line
argument_list|)
expr_stmt|;
block|}
else|else
name|printf_unfiltered
argument_list|(
literal|"?HERE\n"
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|prompt
operator|=
name|getenv
argument_list|(
literal|"PS2"
argument_list|)
expr_stmt|;
if|if
condition|(
name|prompt
operator|==
name|NULL
condition|)
block|{
name|prompt
operator|=
literal|"> "
expr_stmt|;
block|}
name|args
operator|=
name|command_line_input
argument_list|(
name|prompt
argument_list|,
literal|0
argument_list|,
literal|"overload-choice"
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|==
literal|0
operator|||
operator|*
name|args
operator|==
literal|0
condition|)
name|error_no_arg
argument_list|(
literal|"one or more choice numbers"
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|args
condition|)
block|{
name|int
name|num
decl_stmt|;
name|arg1
operator|=
name|args
expr_stmt|;
while|while
condition|(
operator|*
name|arg1
operator|>=
literal|'0'
operator|&&
operator|*
name|arg1
operator|<=
literal|'9'
condition|)
name|arg1
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|arg1
operator|&&
operator|*
name|arg1
operator|!=
literal|' '
operator|&&
operator|*
name|arg1
operator|!=
literal|'\t'
condition|)
name|error
argument_list|(
literal|"Arguments must be choice numbers."
argument_list|)
expr_stmt|;
name|num
operator|=
name|atoi
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|num
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"canceled"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|num
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|canonical_arr
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nelts
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|canonical_arr
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
name|symname
operator|=
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|sym_arr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|canonical_arr
index|[
name|i
index|]
operator|=
name|savestring
argument_list|(
name|symname
argument_list|,
name|strlen
argument_list|(
name|symname
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|memcpy
argument_list|(
name|return_values
operator|.
name|sals
argument_list|,
name|values
operator|.
name|sals
argument_list|,
operator|(
name|nelts
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|symtab_and_line
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|return_values
operator|.
name|nelts
operator|=
name|nelts
expr_stmt|;
name|discard_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
name|return_values
return|;
block|}
if|if
condition|(
name|num
operator|>=
name|nelts
operator|+
literal|2
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"No choice number %d.\n"
argument_list|,
name|num
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|num
operator|-=
literal|2
expr_stmt|;
if|if
condition|(
name|values
operator|.
name|sals
index|[
name|num
index|]
operator|.
name|pc
condition|)
block|{
if|if
condition|(
name|canonical_arr
condition|)
block|{
name|symname
operator|=
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|sym_arr
index|[
name|num
index|]
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|symname
argument_list|)
expr_stmt|;
name|canonical_arr
index|[
name|i
index|]
operator|=
name|savestring
argument_list|(
name|symname
argument_list|,
name|strlen
argument_list|(
name|symname
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|return_values
operator|.
name|sals
index|[
name|i
operator|++
index|]
operator|=
name|values
operator|.
name|sals
index|[
name|num
index|]
expr_stmt|;
name|values
operator|.
name|sals
index|[
name|num
index|]
operator|.
name|pc
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|printf_unfiltered
argument_list|(
literal|"duplicate request for %d ignored.\n"
argument_list|,
name|num
argument_list|)
expr_stmt|;
block|}
block|}
name|args
operator|=
name|arg1
expr_stmt|;
while|while
condition|(
operator|*
name|args
operator|==
literal|' '
operator|||
operator|*
name|args
operator|==
literal|'\t'
condition|)
name|args
operator|++
expr_stmt|;
block|}
name|return_values
operator|.
name|nelts
operator|=
name|i
expr_stmt|;
name|discard_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
name|return_values
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The parser of linespec itself. */
end_comment

begin_comment
comment|/* Parse a string that specifies a line number.    Pass the address of a char * variable; that variable will be    advanced over the characters actually parsed.     The string can be:     LINENUM -- that line number in current file.  PC returned is 0.    FILE:LINENUM -- that line in that file.  PC returned is 0.    FUNCTION -- line number of openbrace of that function.    PC returned is the start of the function.    VARIABLE -- line number of definition of that variable.    PC returned is 0.    FILE:FUNCTION -- likewise, but prefer functions in that file.    *EXPR -- line in which address EXPR appears.     This may all be followed by an "if EXPR", which we ignore.     FUNCTION may be an undebuggable function found in minimal symbol table.     If the argument FUNFIRSTLINE is nonzero, we want the first line    of real code inside a function when a function is specified, and it is    not OK to specify a variable or type to get its line number.     DEFAULT_SYMTAB specifies the file to use if none is specified.    It defaults to current_source_symtab.    DEFAULT_LINE specifies the line number to use for relative    line numbers (that start with signs).  Defaults to current_source_line.    If CANONICAL is non-NULL, store an array of strings containing the canonical    line specs there if necessary. Currently overloaded member functions and    line numbers or static functions without a filename yield a canonical    line spec. The array and the line spec strings are allocated on the heap,    it is the callers responsibility to free them.     Note that it is possible to return zero for the symtab    if no file is validly specified.  Callers must check that.    Also, the line number returned may be invalid.        If NOT_FOUND_PTR is not null, store a boolean true/false value at the location, based    on whether or not failure occurs due to an unknown function or file.  In the case    where failure does occur due to an unknown function or file, do not issue an error    message.  */
end_comment

begin_comment
comment|/* We allow single quotes in various places.  This is a hideous    kludge, which exists because the completer can't yet deal with the    lack of single quotes.  FIXME: write a linespec_completer which we    can use as appropriate instead of make_symbol_completion_list.  */
end_comment

begin_function
name|struct
name|symtabs_and_lines
name|decode_line_1
parameter_list|(
name|char
modifier|*
modifier|*
name|argptr
parameter_list|,
name|int
name|funfirstline
parameter_list|,
name|struct
name|symtab
modifier|*
name|default_symtab
parameter_list|,
name|int
name|default_line
parameter_list|,
name|char
modifier|*
modifier|*
modifier|*
name|canonical
parameter_list|,
name|int
modifier|*
name|not_found_ptr
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|;
comment|/* If a file name is specified, this is its symtab.  */
name|struct
name|symtab
modifier|*
name|file_symtab
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|copy
decl_stmt|;
comment|/* This is NULL if there are no parens in *ARGPTR, or a pointer to      the closing parenthesis if there are parens.  */
name|char
modifier|*
name|paren_pointer
decl_stmt|;
comment|/* This says whether or not something in *ARGPTR is quoted with      completer_quotes (i.e. with single quotes).  */
name|int
name|is_quoted
decl_stmt|;
comment|/* Is part of *ARGPTR is enclosed in double quotes?  */
name|int
name|is_quote_enclosed
decl_stmt|;
name|int
name|is_objc_method
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|saved_arg
init|=
operator|*
name|argptr
decl_stmt|;
if|if
condition|(
name|not_found_ptr
condition|)
operator|*
name|not_found_ptr
operator|=
literal|0
expr_stmt|;
comment|/* Defaults have defaults.  */
name|initialize_defaults
argument_list|(
operator|&
name|default_symtab
argument_list|,
operator|&
name|default_line
argument_list|)
expr_stmt|;
comment|/* See if arg is *PC.  */
if|if
condition|(
operator|*
operator|*
name|argptr
operator|==
literal|'*'
condition|)
return|return
name|decode_indirect
argument_list|(
name|argptr
argument_list|)
return|;
comment|/* Set various flags.  'paren_pointer' is important for overload      checking, where we allow things like:         (gdb) break c::f(int)   */
name|set_flags
argument_list|(
operator|*
name|argptr
argument_list|,
operator|&
name|is_quoted
argument_list|,
operator|&
name|paren_pointer
argument_list|)
expr_stmt|;
comment|/* Check to see if it's a multipart linespec (with colons or      periods).  */
comment|/* Locate the end of the first half of the linespec.      After the call, for instance, if the argptr string is "foo.c:123"      p will point at "123".  If there is only one part, like "foo", p      will point to "". If this is a C++ name, like "A::B::foo", p will      point to "::B::foo". Argptr is not changed by this call.  */
name|p
operator|=
name|locate_first_half
argument_list|(
name|argptr
argument_list|,
operator|&
name|is_quote_enclosed
argument_list|)
expr_stmt|;
comment|/* Check if this is an Objective-C method (anything that starts with      a '+' or '-' and a '[').  */
if|if
condition|(
name|is_objc_method_format
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|is_objc_method
operator|=
literal|1
expr_stmt|;
name|paren_pointer
operator|=
name|NULL
expr_stmt|;
comment|/* Just a category name.  Ignore it.  */
block|}
comment|/* Check if the symbol could be an Objective-C selector.  */
block|{
name|struct
name|symtabs_and_lines
name|values
decl_stmt|;
name|values
operator|=
name|decode_objc
argument_list|(
name|argptr
argument_list|,
name|funfirstline
argument_list|,
name|NULL
argument_list|,
name|canonical
argument_list|,
name|saved_arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|values
operator|.
name|sals
operator|!=
name|NULL
condition|)
return|return
name|values
return|;
block|}
comment|/* Does it look like there actually were two parts?  */
if|if
condition|(
operator|(
name|p
index|[
literal|0
index|]
operator|==
literal|':'
operator|||
name|p
index|[
literal|0
index|]
operator|==
literal|'.'
operator|)
operator|&&
name|paren_pointer
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|is_quoted
condition|)
operator|*
name|argptr
operator|=
operator|*
name|argptr
operator|+
literal|1
expr_stmt|;
comment|/* Is it a C++ or Java compound data structure? 	 The check on p[1] == ':' is capturing the case of "::", 	 since p[0]==':' was checked above.   	 Note that the call to decode_compound does everything 	 for us, including the lookup on the symbol table, so we 	 can return now. */
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'.'
operator|||
name|p
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
return|return
name|decode_compound
argument_list|(
name|argptr
argument_list|,
name|funfirstline
argument_list|,
name|canonical
argument_list|,
name|saved_arg
argument_list|,
name|p
argument_list|)
return|;
comment|/* No, the first part is a filename; set s to be that file's 	 symtab.  Also, move argptr past the filename.  */
name|file_symtab
operator|=
name|symtab_from_filename
argument_list|(
name|argptr
argument_list|,
name|p
argument_list|,
name|is_quote_enclosed
argument_list|,
name|not_found_ptr
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* No one really seems to know why this was added. It certainly      breaks the command line, though, whenever the passed      name is of the form ClassName::Method. This bit of code      singles out the class name, and if funfirstline is set (for      example, you are setting a breakpoint at this function),      you get an error. This did not occur with earlier      verions, so I am ifdef'ing this out. 3/29/99 */
block|else     {
comment|/* Check if what we have till now is a symbol name */
comment|/* We may be looking at a template instantiation such          as "foo<int>".  Check here whether we know about it,          instead of falling through to the code below which          handles ordinary function names, because that code          doesn't like seeing '<' and '>' in a name -- the          skip_quoted call doesn't go past them.  So see if we          can figure it out right now. */
block|copy = (char *) alloca (p - *argptr + 1);       memcpy (copy, *argptr, p - *argptr);       copy[p - *argptr] = '\000';       sym = lookup_symbol (copy, 0, VAR_DOMAIN, 0,&sym_symtab);       if (sym) 	{ 	  *argptr = (*p == '\'') ? p + 1 : p; 	  return symbol_found (funfirstline, canonical, copy, sym, 			       NULL, sym_symtab); 	}
comment|/* Otherwise fall out from here and go to file/line spec          processing, etc. */
block|}
endif|#
directive|endif
comment|/* S is specified file's symtab, or 0 if no file specified.      arg no longer contains the file name.  */
comment|/* Check whether arg is all digits (and sign).  */
name|q
operator|=
operator|*
name|argptr
expr_stmt|;
if|if
condition|(
operator|*
name|q
operator|==
literal|'-'
operator|||
operator|*
name|q
operator|==
literal|'+'
condition|)
name|q
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|q
operator|>=
literal|'0'
operator|&&
operator|*
name|q
operator|<=
literal|'9'
condition|)
name|q
operator|++
expr_stmt|;
if|if
condition|(
name|q
operator|!=
operator|*
name|argptr
operator|&&
operator|(
operator|*
name|q
operator|==
literal|0
operator|||
operator|*
name|q
operator|==
literal|' '
operator|||
operator|*
name|q
operator|==
literal|'\t'
operator|||
operator|*
name|q
operator|==
literal|','
operator|)
condition|)
comment|/* We found a token consisting of all digits -- at least one digit.  */
return|return
name|decode_all_digits
argument_list|(
name|argptr
argument_list|,
name|default_symtab
argument_list|,
name|default_line
argument_list|,
name|canonical
argument_list|,
name|file_symtab
argument_list|,
name|q
argument_list|)
return|;
comment|/* Arg token is not digits => try it as a variable name      Find the next token (everything up to end or next whitespace).  */
if|if
condition|(
operator|*
operator|*
name|argptr
operator|==
literal|'$'
condition|)
comment|/* May be a convenience variable.  */
comment|/* One or two $ chars possible.  */
name|p
operator|=
name|skip_quoted
argument_list|(
operator|*
name|argptr
operator|+
operator|(
operator|(
operator|(
operator|*
name|argptr
operator|)
index|[
literal|1
index|]
operator|==
literal|'$'
operator|)
condition|?
literal|2
else|:
literal|1
operator|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|is_quoted
condition|)
block|{
name|p
operator|=
name|skip_quoted
argument_list|(
operator|*
name|argptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\''
condition|)
name|error
argument_list|(
literal|"Unmatched single quote."
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_objc_method
condition|)
block|{
comment|/* allow word separators in method names for Obj-C */
name|p
operator|=
name|skip_quoted_chars
argument_list|(
operator|*
name|argptr
argument_list|,
name|NULL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|paren_pointer
operator|!=
name|NULL
condition|)
block|{
name|p
operator|=
name|paren_pointer
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|skip_quoted
argument_list|(
operator|*
name|argptr
argument_list|)
expr_stmt|;
block|}
name|copy
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|p
operator|-
operator|*
name|argptr
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|copy
argument_list|,
operator|*
name|argptr
argument_list|,
name|p
operator|-
operator|*
name|argptr
argument_list|)
expr_stmt|;
name|copy
index|[
name|p
operator|-
operator|*
name|argptr
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|p
operator|!=
operator|*
name|argptr
operator|&&
name|copy
index|[
literal|0
index|]
operator|&&
name|copy
index|[
literal|0
index|]
operator|==
name|copy
index|[
name|p
operator|-
operator|*
name|argptr
operator|-
literal|1
index|]
operator|&&
name|strchr
argument_list|(
name|get_gdb_completer_quote_characters
argument_list|()
argument_list|,
name|copy
index|[
literal|0
index|]
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|copy
index|[
name|p
operator|-
operator|*
name|argptr
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|copy
operator|++
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
operator|*
name|argptr
operator|=
name|p
expr_stmt|;
comment|/* If it starts with $: may be a legitimate variable or routine name      (e.g. HP-UX millicode routines such as $$dyncall), or it may      be history value, or it may be a convenience variable.  */
if|if
condition|(
operator|*
name|copy
operator|==
literal|'$'
condition|)
return|return
name|decode_dollar
argument_list|(
name|copy
argument_list|,
name|funfirstline
argument_list|,
name|default_symtab
argument_list|,
name|canonical
argument_list|,
name|file_symtab
argument_list|)
return|;
comment|/* Look up that token as a variable.      If file specified, use that file's per-file block to start with.  */
return|return
name|decode_variable
argument_list|(
name|copy
argument_list|,
name|funfirstline
argument_list|,
name|canonical
argument_list|,
name|file_symtab
argument_list|,
name|not_found_ptr
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Now, more helper functions for decode_line_1.  Some conventions    that these functions follow:     Decode_line_1 typically passes along some of its arguments or local    variables to the subfunctions.  It passes the variables by    reference if they are modified by the subfunction, and by value    otherwise.     Some of the functions have side effects that don't arise from    variables that are passed by reference.  In particular, if a    function is passed ARGPTR as an argument, it modifies what ARGPTR    points to; typically, it advances *ARGPTR past whatever substring    it has just looked at.  (If it doesn't modify *ARGPTR, then the    function gets passed *ARGPTR instead, which is then called ARG: see    set_flags, for example.)  Also, functions that return a struct    symtabs_and_lines may modify CANONICAL, as in the description of    decode_line_1.     If a function returns a struct symtabs_and_lines, then that struct    will immediately make its way up the call chain to be returned by    decode_line_1.  In particular, all of the functions decode_XXX    calculate the appropriate struct symtabs_and_lines, under the    assumption that their argument is of the form XXX.  */
end_comment

begin_comment
comment|/* First, some functions to initialize stuff at the beggining of the    function.  */
end_comment

begin_function
specifier|static
name|void
name|initialize_defaults
parameter_list|(
name|struct
name|symtab
modifier|*
modifier|*
name|default_symtab
parameter_list|,
name|int
modifier|*
name|default_line
parameter_list|)
block|{
if|if
condition|(
operator|*
name|default_symtab
operator|==
literal|0
condition|)
block|{
comment|/* Use whatever we have for the default source line.  We don't use          get_current_or_default_symtab_and_line as it can recurse and call 	 us back! */
name|struct
name|symtab_and_line
name|cursal
init|=
name|get_current_source_symtab_and_line
argument_list|()
decl_stmt|;
operator|*
name|default_symtab
operator|=
name|cursal
operator|.
name|symtab
expr_stmt|;
operator|*
name|default_line
operator|=
name|cursal
operator|.
name|line
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|set_flags
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
modifier|*
name|is_quoted
parameter_list|,
name|char
modifier|*
modifier|*
name|paren_pointer
parameter_list|)
block|{
name|char
modifier|*
name|ii
decl_stmt|;
name|int
name|has_if
init|=
literal|0
decl_stmt|;
comment|/* 'has_if' is for the syntax:         (gdb) break foo if (a==b)   */
if|if
condition|(
operator|(
name|ii
operator|=
name|strstr
argument_list|(
name|arg
argument_list|,
literal|" if "
argument_list|)
operator|)
operator|!=
name|NULL
operator|||
operator|(
name|ii
operator|=
name|strstr
argument_list|(
name|arg
argument_list|,
literal|"\tif "
argument_list|)
operator|)
operator|!=
name|NULL
operator|||
operator|(
name|ii
operator|=
name|strstr
argument_list|(
name|arg
argument_list|,
literal|" if\t"
argument_list|)
operator|)
operator|!=
name|NULL
operator|||
operator|(
name|ii
operator|=
name|strstr
argument_list|(
name|arg
argument_list|,
literal|"\tif\t"
argument_list|)
operator|)
operator|!=
name|NULL
operator|||
operator|(
name|ii
operator|=
name|strstr
argument_list|(
name|arg
argument_list|,
literal|" if("
argument_list|)
operator|)
operator|!=
name|NULL
operator|||
operator|(
name|ii
operator|=
name|strstr
argument_list|(
name|arg
argument_list|,
literal|"\tif( "
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|has_if
operator|=
literal|1
expr_stmt|;
comment|/* Temporarily zap out "if (condition)" to not confuse the      parenthesis-checking code below.  This is undone below. Do not      change ii!!  */
if|if
condition|(
name|has_if
condition|)
block|{
operator|*
name|ii
operator|=
literal|'\0'
expr_stmt|;
block|}
operator|*
name|is_quoted
operator|=
operator|(
operator|*
name|arg
operator|&&
name|strchr
argument_list|(
name|get_gdb_completer_quote_characters
argument_list|()
argument_list|,
operator|*
name|arg
argument_list|)
operator|!=
name|NULL
operator|)
expr_stmt|;
operator|*
name|paren_pointer
operator|=
name|strchr
argument_list|(
name|arg
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|paren_pointer
operator|!=
name|NULL
condition|)
operator|*
name|paren_pointer
operator|=
name|strrchr
argument_list|(
operator|*
name|paren_pointer
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
comment|/* Now that we're safely past the paren_pointer check, put back " if      (condition)" so outer layers can see it.  */
if|if
condition|(
name|has_if
condition|)
operator|*
name|ii
operator|=
literal|' '
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Decode arg of the form *PC.  */
end_comment

begin_function
specifier|static
name|struct
name|symtabs_and_lines
name|decode_indirect
parameter_list|(
name|char
modifier|*
modifier|*
name|argptr
parameter_list|)
block|{
name|struct
name|symtabs_and_lines
name|values
decl_stmt|;
name|CORE_ADDR
name|pc
decl_stmt|;
operator|(
operator|*
name|argptr
operator|)
operator|++
expr_stmt|;
name|pc
operator|=
name|parse_and_eval_address_1
argument_list|(
name|argptr
argument_list|)
expr_stmt|;
name|values
operator|.
name|sals
operator|=
operator|(
expr|struct
name|symtab_and_line
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|symtab_and_line
argument_list|)
argument_list|)
expr_stmt|;
name|values
operator|.
name|nelts
operator|=
literal|1
expr_stmt|;
name|values
operator|.
name|sals
index|[
literal|0
index|]
operator|=
name|find_pc_line
argument_list|(
name|pc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|values
operator|.
name|sals
index|[
literal|0
index|]
operator|.
name|pc
operator|=
name|pc
expr_stmt|;
name|values
operator|.
name|sals
index|[
literal|0
index|]
operator|.
name|section
operator|=
name|find_pc_overlay
argument_list|(
name|pc
argument_list|)
expr_stmt|;
return|return
name|values
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Locate the first half of the linespec, ending in a colon, period,    or whitespace.  (More or less.)  Also, check to see if *ARGPTR is    enclosed in double quotes; if so, set is_quote_enclosed, advance    ARGPTR past that and zero out the trailing double quote.    If ARGPTR is just a simple name like "main", p will point to ""    at the end.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|locate_first_half
parameter_list|(
name|char
modifier|*
modifier|*
name|argptr
parameter_list|,
name|int
modifier|*
name|is_quote_enclosed
parameter_list|)
block|{
name|char
modifier|*
name|ii
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|p1
decl_stmt|;
name|int
name|has_comma
decl_stmt|;
comment|/* Maybe we were called with a line range FILENAME:LINENUM,FILENAME:LINENUM      and we must isolate the first half.  Outer layers will call again later      for the second half.       Don't count commas that appear in argument lists of overloaded      functions, or in quoted strings.  It's stupid to go to this much      trouble when the rest of the function is such an obvious roach hotel.  */
name|ii
operator|=
name|find_toplevel_char
argument_list|(
operator|*
name|argptr
argument_list|,
literal|','
argument_list|)
expr_stmt|;
name|has_comma
operator|=
operator|(
name|ii
operator|!=
literal|0
operator|)
expr_stmt|;
comment|/* Temporarily zap out second half to not confuse the code below.      This is undone below. Do not change ii!!  */
if|if
condition|(
name|has_comma
condition|)
block|{
operator|*
name|ii
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* Maybe arg is FILE : LINENUM or FILE : FUNCTION.  May also be      CLASS::MEMBER, or NAMESPACE::NAME.  Look for ':', but ignore      inside of<>.  */
name|p
operator|=
operator|*
name|argptr
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'"'
condition|)
block|{
operator|*
name|is_quote_enclosed
operator|=
literal|1
expr_stmt|;
operator|(
operator|*
name|argptr
operator|)
operator|++
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
else|else
operator|*
name|is_quote_enclosed
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'<'
condition|)
block|{
name|char
modifier|*
name|temp_end
init|=
name|find_template_name_end
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|temp_end
condition|)
name|error
argument_list|(
literal|"malformed template specification in command"
argument_list|)
expr_stmt|;
name|p
operator|=
name|temp_end
expr_stmt|;
block|}
comment|/* Check for a colon and a plus or minus and a [ (which          indicates an Objective-C method) */
if|if
condition|(
name|is_objc_method_format
argument_list|(
name|p
argument_list|)
condition|)
block|{
break|break;
block|}
comment|/* Check for the end of the first half of the linespec.  End of          line, a tab, a double colon or the last single colon, or a          space.  But if enclosed in double quotes we do not break on          enclosed spaces.  */
if|if
condition|(
operator|!
operator|*
name|p
operator|||
name|p
index|[
literal|0
index|]
operator|==
literal|'\t'
operator|||
operator|(
operator|(
name|p
index|[
literal|0
index|]
operator|==
literal|':'
operator|)
operator|&&
operator|(
operator|(
name|p
index|[
literal|1
index|]
operator|==
literal|':'
operator|)
operator|||
operator|(
name|strchr
argument_list|(
name|p
operator|+
literal|1
argument_list|,
literal|':'
argument_list|)
operator|==
name|NULL
operator|)
operator|)
operator|)
operator|||
operator|(
operator|(
name|p
index|[
literal|0
index|]
operator|==
literal|' '
operator|)
operator|&&
operator|!
operator|*
name|is_quote_enclosed
operator|)
condition|)
break|break;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|strchr
argument_list|(
name|p
argument_list|,
literal|':'
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* Java qualified method.  Find the *last* '.', since the 	     others are package qualifiers.  */
for|for
control|(
name|p1
operator|=
name|p
init|;
operator|*
name|p1
condition|;
name|p1
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p1
operator|==
literal|'.'
condition|)
name|p
operator|=
name|p1
expr_stmt|;
block|}
break|break;
block|}
block|}
while|while
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|' '
operator|||
name|p
index|[
literal|0
index|]
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
comment|/* If the closing double quote was left at the end, remove it.  */
if|if
condition|(
operator|*
name|is_quote_enclosed
condition|)
block|{
name|char
modifier|*
name|closing_quote
init|=
name|strchr
argument_list|(
name|p
operator|-
literal|1
argument_list|,
literal|'"'
argument_list|)
decl_stmt|;
if|if
condition|(
name|closing_quote
operator|&&
name|closing_quote
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
operator|*
name|closing_quote
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* Now that we've safely parsed the first half, put back ',' so      outer layers can see it.  */
if|if
condition|(
name|has_comma
condition|)
operator|*
name|ii
operator|=
literal|','
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Here's where we recognise an Objective-C Selector.  An Objective C    selector may be implemented by more than one class, therefore it    may represent more than one method/function.  This gives us a    situation somewhat analogous to C++ overloading.  If there's more    than one method that could represent the selector, then use some of    the existing C++ code to let the user choose one.  */
end_comment

begin_function
name|struct
name|symtabs_and_lines
name|decode_objc
parameter_list|(
name|char
modifier|*
modifier|*
name|argptr
parameter_list|,
name|int
name|funfirstline
parameter_list|,
name|struct
name|symtab
modifier|*
name|file_symtab
parameter_list|,
name|char
modifier|*
modifier|*
modifier|*
name|canonical
parameter_list|,
name|char
modifier|*
name|saved_arg
parameter_list|)
block|{
name|struct
name|symtabs_and_lines
name|values
decl_stmt|;
name|struct
name|symbol
modifier|*
modifier|*
name|sym_arr
init|=
name|NULL
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|copy
init|=
name|NULL
decl_stmt|;
name|struct
name|block
modifier|*
name|block
init|=
name|NULL
decl_stmt|;
name|int
name|i1
init|=
literal|0
decl_stmt|;
name|int
name|i2
init|=
literal|0
decl_stmt|;
name|values
operator|.
name|sals
operator|=
name|NULL
expr_stmt|;
name|values
operator|.
name|nelts
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|file_symtab
operator|!=
name|NULL
condition|)
name|block
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|BLOCKVECTOR
argument_list|(
name|file_symtab
argument_list|)
argument_list|,
name|STATIC_BLOCK
argument_list|)
expr_stmt|;
else|else
name|block
operator|=
name|get_selected_block
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|copy
operator|=
name|find_imps
argument_list|(
name|file_symtab
argument_list|,
name|block
argument_list|,
operator|*
name|argptr
argument_list|,
name|NULL
argument_list|,
operator|&
name|i1
argument_list|,
operator|&
name|i2
argument_list|)
expr_stmt|;
if|if
condition|(
name|i1
operator|>
literal|0
condition|)
block|{
name|sym_arr
operator|=
operator|(
expr|struct
name|symbol
operator|*
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|i1
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|sym_arr
index|[
name|i1
index|]
operator|=
literal|0
expr_stmt|;
name|copy
operator|=
name|find_imps
argument_list|(
name|file_symtab
argument_list|,
name|block
argument_list|,
operator|*
name|argptr
argument_list|,
name|sym_arr
argument_list|,
operator|&
name|i1
argument_list|,
operator|&
name|i2
argument_list|)
expr_stmt|;
operator|*
name|argptr
operator|=
name|copy
expr_stmt|;
block|}
comment|/* i1 now represents the TOTAL number of matches found.      i2 represents how many HIGH-LEVEL (struct symbol) matches,      which will come first in the sym_arr array.  Any low-level      (minimal_symbol) matches will follow those.  */
if|if
condition|(
name|i1
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|i2
operator|>
literal|0
condition|)
block|{
comment|/* Already a struct symbol.  */
name|sym
operator|=
name|sym_arr
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
block|{
name|sym
operator|=
name|find_pc_function
argument_list|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym_arr
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sym
operator|!=
name|NULL
operator|)
operator|&&
name|strcmp
argument_list|(
name|SYMBOL_LINKAGE_NAME
argument_list|(
name|sym_arr
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|SYMBOL_LINKAGE_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"debugging symbol \"%s\" does not match selector; ignoring"
argument_list|,
name|SYMBOL_LINKAGE_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|sym
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|values
operator|.
name|sals
operator|=
operator|(
expr|struct
name|symtab_and_line
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|symtab_and_line
argument_list|)
argument_list|)
expr_stmt|;
name|values
operator|.
name|nelts
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|sym
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_BLOCK
condition|)
block|{
comment|/* Canonicalize this, so it remains resolved for dylib loads.  */
name|values
operator|.
name|sals
index|[
literal|0
index|]
operator|=
name|find_function_start_sal
argument_list|(
name|sym
argument_list|,
name|funfirstline
argument_list|)
expr_stmt|;
name|build_canonical_line_spec
argument_list|(
name|values
operator|.
name|sals
argument_list|,
name|SYMBOL_NATURAL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|canonical
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The only match was a non-debuggable symbol.  */
name|values
operator|.
name|sals
index|[
literal|0
index|]
operator|.
name|symtab
operator|=
literal|0
expr_stmt|;
name|values
operator|.
name|sals
index|[
literal|0
index|]
operator|.
name|line
operator|=
literal|0
expr_stmt|;
name|values
operator|.
name|sals
index|[
literal|0
index|]
operator|.
name|end
operator|=
literal|0
expr_stmt|;
name|values
operator|.
name|sals
index|[
literal|0
index|]
operator|.
name|pc
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym_arr
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|values
return|;
block|}
if|if
condition|(
name|i1
operator|>
literal|1
condition|)
block|{
comment|/* More than one match. The user must choose one or more.  */
return|return
name|decode_line_2
argument_list|(
name|sym_arr
argument_list|,
name|i2
argument_list|,
name|funfirstline
argument_list|,
name|canonical
argument_list|)
return|;
block|}
return|return
name|values
return|;
block|}
end_function

begin_comment
comment|/* This handles C++ and Java compound data structures.  P should point    at the first component separator, i.e. double-colon or period.  As    an example, on entrance to this function we could have ARGPTR    pointing to "AAA::inA::fun" and P pointing to "::inA::fun".  */
end_comment

begin_function
specifier|static
name|struct
name|symtabs_and_lines
name|decode_compound
parameter_list|(
name|char
modifier|*
modifier|*
name|argptr
parameter_list|,
name|int
name|funfirstline
parameter_list|,
name|char
modifier|*
modifier|*
modifier|*
name|canonical
parameter_list|,
name|char
modifier|*
name|saved_arg
parameter_list|,
name|char
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|symtabs_and_lines
name|values
decl_stmt|;
name|char
modifier|*
name|p2
decl_stmt|;
name|char
modifier|*
name|saved_arg2
init|=
operator|*
name|argptr
decl_stmt|;
name|char
modifier|*
name|temp_end
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
comment|/* The symtab that SYM was found in.  */
name|struct
name|symtab
modifier|*
name|sym_symtab
decl_stmt|;
name|char
modifier|*
name|copy
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym_class
decl_stmt|;
name|struct
name|symbol
modifier|*
modifier|*
name|sym_arr
decl_stmt|;
name|struct
name|type
modifier|*
name|t
decl_stmt|;
comment|/* First check for "global" namespace specification, of the form      "::foo".  If found, skip over the colons and jump to normal      symbol processing.  I.e. the whole line specification starts with      "::" (note the condition that *argptr == p). */
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|':'
operator|&&
operator|(
operator|(
operator|*
name|argptr
operator|==
name|p
operator|)
operator|||
operator|(
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
operator|)
operator|||
operator|(
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'\t'
operator|)
operator|)
condition|)
name|saved_arg2
operator|+=
literal|2
expr_stmt|;
comment|/* Given our example "AAA::inA::fun", we have two cases to consider:       1) AAA::inA is the name of a class.  In that case, presumably it         has a method called "fun"; we then look up that method using         find_method.       2) AAA::inA isn't the name of a class.  In that case, either the         user made a typo or AAA::inA is the name of a namespace.         Either way, we just look up AAA::inA::fun with lookup_symbol.       Thus, our first task is to find everything before the last set of      double-colons and figure out if it's the name of a class.  So we      first loop through all of the double-colons.  */
name|p2
operator|=
name|p
expr_stmt|;
comment|/* Save for restart.  */
comment|/* This is very messy. Following the example above we have now the      following pointers:      p -> "::inA::fun"      argptr -> "AAA::inA::fun      saved_arg -> "AAA::inA::fun      saved_arg2 -> "AAA::inA::fun      p2 -> "::inA::fun". */
comment|/* In the loop below, with these strings, we'll make 2 passes, each      is marked in comments.*/
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Move pointer up to next possible class/namespace token.  */
name|p
operator|=
name|p2
operator|+
literal|1
expr_stmt|;
comment|/* Restart with old value +1.  */
comment|/* PASS1: at this point p2->"::inA::fun", so p->":inA::fun", 	 i.e. if there is a double-colon, p will now point to the 	 second colon. */
comment|/* PASS2: p2->"::fun", p->":fun" */
comment|/* Move pointer ahead to next double-colon.  */
while|while
condition|(
operator|*
name|p
operator|&&
operator|(
name|p
index|[
literal|0
index|]
operator|!=
literal|' '
operator|)
operator|&&
operator|(
name|p
index|[
literal|0
index|]
operator|!=
literal|'\t'
operator|)
operator|&&
operator|(
name|p
index|[
literal|0
index|]
operator|!=
literal|'\''
operator|)
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'<'
condition|)
block|{
name|temp_end
operator|=
name|find_template_name_end
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|temp_end
condition|)
name|error
argument_list|(
literal|"malformed template specification in command"
argument_list|)
expr_stmt|;
name|p
operator|=
name|temp_end
expr_stmt|;
block|}
comment|/* Note that, since, at the start of this loop, p would be 	     pointing to the second colon in a double-colon, we only 	     satisfy the condition below if there is another 	     double-colon to the right (after). I.e. there is another 	     component that can be a class or a namespace. I.e, if at 	     the beginning of this loop (PASS1), we had 	     p->":inA::fun", we'll trigger this when p has been 	     advanced to point to "::fun".  */
comment|/* PASS2: we will not trigger this. */
elseif|else
if|if
condition|(
operator|(
name|p
index|[
literal|0
index|]
operator|==
literal|':'
operator|)
operator|&&
operator|(
name|p
index|[
literal|1
index|]
operator|==
literal|':'
operator|)
condition|)
break|break;
comment|/* Found double-colon.  */
else|else
comment|/* PASS2: We'll keep getting here, until p->"", at which point 	       we exit this loop.  */
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
operator|!=
literal|':'
condition|)
break|break;
comment|/* Out of the while (1).  This would happen 			   for instance if we have looked up 			   unsuccessfully all the components of the 			   string, and p->""(PASS2)  */
comment|/* We get here if p points to ' ', '\t', '\'', "::" or ""(i.e 	 string ended). */
comment|/* Save restart for next time around.  */
name|p2
operator|=
name|p
expr_stmt|;
comment|/* Restore argptr as it was on entry to this function.  */
operator|*
name|argptr
operator|=
name|saved_arg2
expr_stmt|;
comment|/* PASS1: at this point p->"::fun" argptr->"AAA::inA::fun", 	 p2->"::fun".  */
comment|/* All ready for next pass through the loop.  */
block|}
comment|/* while (1) */
comment|/* Start of lookup in the symbol tables. */
comment|/* Lookup in the symbol table the substring between argptr and      p. Note, this call changes the value of argptr.  */
comment|/* Before the call, argptr->"AAA::inA::fun",      p->"", p2->"::fun".  After the call: argptr->"fun", p, p2      unchanged.  */
name|sym_class
operator|=
name|lookup_prefix_sym
argument_list|(
name|argptr
argument_list|,
name|p2
argument_list|)
expr_stmt|;
comment|/* If sym_class has been found, and if "AAA::inA" is a class, then      we're in case 1 above.  So we look up "fun" as a method of that      class.  */
if|if
condition|(
name|sym_class
operator|&&
operator|(
name|t
operator|=
name|check_typedef
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym_class
argument_list|)
argument_list|)
operator|,
operator|(
name|TYPE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
operator|||
name|TYPE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_CODE_UNION
operator|)
operator|)
condition|)
block|{
comment|/* Arg token is not digits => try it as a function name. 	 Find the next token (everything up to end or next 	 blank).  */
if|if
condition|(
operator|*
operator|*
name|argptr
operator|&&
name|strchr
argument_list|(
name|get_gdb_completer_quote_characters
argument_list|()
argument_list|,
operator|*
operator|*
name|argptr
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|p
operator|=
name|skip_quoted
argument_list|(
operator|*
name|argptr
argument_list|)
expr_stmt|;
operator|*
name|argptr
operator|=
operator|*
name|argptr
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* At this point argptr->"fun".  */
name|p
operator|=
operator|*
name|argptr
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|' '
operator|&&
operator|*
name|p
operator|!=
literal|'\t'
operator|&&
operator|*
name|p
operator|!=
literal|','
operator|&&
operator|*
name|p
operator|!=
literal|':'
condition|)
name|p
operator|++
expr_stmt|;
comment|/* At this point p->"".  String ended.  */
block|}
comment|/* Allocate our own copy of the substring between argptr and 	 p. */
name|copy
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|p
operator|-
operator|*
name|argptr
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|copy
argument_list|,
operator|*
name|argptr
argument_list|,
name|p
operator|-
operator|*
name|argptr
argument_list|)
expr_stmt|;
name|copy
index|[
name|p
operator|-
operator|*
name|argptr
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|p
operator|!=
operator|*
name|argptr
operator|&&
name|copy
index|[
name|p
operator|-
operator|*
name|argptr
operator|-
literal|1
index|]
operator|&&
name|strchr
argument_list|(
name|get_gdb_completer_quote_characters
argument_list|()
argument_list|,
name|copy
index|[
name|p
operator|-
operator|*
name|argptr
operator|-
literal|1
index|]
argument_list|)
operator|!=
name|NULL
condition|)
name|copy
index|[
name|p
operator|-
operator|*
name|argptr
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* At this point copy->"fun", p->"" */
comment|/* No line number may be specified.  */
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
operator|*
name|argptr
operator|=
name|p
expr_stmt|;
comment|/* At this point arptr->"".  */
comment|/* Look for copy as a method of sym_class. */
comment|/* At this point copy->"fun", sym_class is "AAA:inA", 	 saved_arg->"AAA::inA::fun".  This concludes the scanning of 	 the string for possible components matches.  If we find it 	 here, we return. If not, and we are at the and of the string, 	 we'll lookup the whole string in the symbol tables.  */
return|return
name|find_method
argument_list|(
name|funfirstline
argument_list|,
name|canonical
argument_list|,
name|saved_arg
argument_list|,
name|copy
argument_list|,
name|t
argument_list|,
name|sym_class
argument_list|)
return|;
block|}
comment|/* End if symbol found */
comment|/* We couldn't find a class, so we're in case 2 above.  We check the      entire name as a symbol instead.  */
name|copy
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|p
operator|-
name|saved_arg2
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|copy
argument_list|,
name|saved_arg2
argument_list|,
name|p
operator|-
name|saved_arg2
argument_list|)
expr_stmt|;
comment|/* Note: if is_quoted should be true, we snuff out quote here      anyway.  */
name|copy
index|[
name|p
operator|-
name|saved_arg2
index|]
operator|=
literal|'\000'
expr_stmt|;
comment|/* Set argptr to skip over the name.  */
operator|*
name|argptr
operator|=
operator|(
operator|*
name|p
operator|==
literal|'\''
operator|)
condition|?
name|p
operator|+
literal|1
else|:
name|p
expr_stmt|;
comment|/* Look up entire name */
name|sym
operator|=
name|lookup_symbol
argument_list|(
name|copy
argument_list|,
literal|0
argument_list|,
name|VAR_DOMAIN
argument_list|,
literal|0
argument_list|,
operator|&
name|sym_symtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
condition|)
return|return
name|symbol_found
argument_list|(
name|funfirstline
argument_list|,
name|canonical
argument_list|,
name|copy
argument_list|,
name|sym
argument_list|,
name|NULL
argument_list|,
name|sym_symtab
argument_list|)
return|;
comment|/* Couldn't find any interpretation as classes/namespaces, so give      up.  The quotes are important if copy is empty.  */
name|cplusplus_error
argument_list|(
name|saved_arg
argument_list|,
literal|"Can't find member of namespace, class, struct, or union named \"%s\"\n"
argument_list|,
name|copy
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Next come some helper functions for decode_compound.  */
end_comment

begin_comment
comment|/* Return the symbol corresponding to the substring of *ARGPTR ending    at P, allowing whitespace.  Also, advance *ARGPTR past the symbol    name in question, the compound object separator ("::" or "."), and    whitespace.  Note that *ARGPTR is changed whether or not the    lookup_symbol call finds anything (i.e we return NULL).  As an    example, say ARGPTR is "AAA::inA::fun" and P is "::inA::fun".  */
end_comment

begin_function
specifier|static
name|struct
name|symbol
modifier|*
name|lookup_prefix_sym
parameter_list|(
name|char
modifier|*
modifier|*
name|argptr
parameter_list|,
name|char
modifier|*
name|p
parameter_list|)
block|{
name|char
modifier|*
name|p1
decl_stmt|;
name|char
modifier|*
name|copy
decl_stmt|;
comment|/* Extract the class name.  */
name|p1
operator|=
name|p
expr_stmt|;
while|while
condition|(
name|p
operator|!=
operator|*
name|argptr
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
operator|--
name|p
expr_stmt|;
name|copy
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|p
operator|-
operator|*
name|argptr
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|copy
argument_list|,
operator|*
name|argptr
argument_list|,
name|p
operator|-
operator|*
name|argptr
argument_list|)
expr_stmt|;
name|copy
index|[
name|p
operator|-
operator|*
name|argptr
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Discard the class name from the argptr.  */
name|p
operator|=
name|p1
operator|+
operator|(
name|p1
index|[
literal|0
index|]
operator|==
literal|':'
condition|?
literal|2
else|:
literal|1
operator|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
operator|*
name|argptr
operator|=
name|p
expr_stmt|;
comment|/* At this point p1->"::inA::fun", p->"inA::fun" copy->"AAA",      argptr->"inA::fun" */
return|return
name|lookup_symbol
argument_list|(
name|copy
argument_list|,
literal|0
argument_list|,
name|STRUCT_DOMAIN
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|symtab
operator|*
operator|*
operator|)
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* This finds the method COPY in the class whose type is T and whose    symbol is SYM_CLASS.  */
end_comment

begin_function
specifier|static
name|struct
name|symtabs_and_lines
name|find_method
parameter_list|(
name|int
name|funfirstline
parameter_list|,
name|char
modifier|*
modifier|*
modifier|*
name|canonical
parameter_list|,
name|char
modifier|*
name|saved_arg
parameter_list|,
name|char
modifier|*
name|copy
parameter_list|,
name|struct
name|type
modifier|*
name|t
parameter_list|,
name|struct
name|symbol
modifier|*
name|sym_class
parameter_list|)
block|{
name|struct
name|symtabs_and_lines
name|values
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
init|=
literal|0
decl_stmt|;
name|int
name|i1
decl_stmt|;
comment|/*  Counter for the symbol array.  */
name|struct
name|symbol
modifier|*
modifier|*
name|sym_arr
init|=
name|alloca
argument_list|(
name|total_number_of_methods
argument_list|(
name|t
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
operator|*
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Find all methods with a matching name, and put them in      sym_arr.  */
name|i1
operator|=
name|collect_methods
argument_list|(
name|copy
argument_list|,
name|t
argument_list|,
name|sym_arr
argument_list|)
expr_stmt|;
if|if
condition|(
name|i1
operator|==
literal|1
condition|)
block|{
comment|/* There is exactly one field with that name.  */
name|sym
operator|=
name|sym_arr
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|sym
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_BLOCK
condition|)
block|{
name|values
operator|.
name|sals
operator|=
operator|(
expr|struct
name|symtab_and_line
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|symtab_and_line
argument_list|)
argument_list|)
expr_stmt|;
name|values
operator|.
name|nelts
operator|=
literal|1
expr_stmt|;
name|values
operator|.
name|sals
index|[
literal|0
index|]
operator|=
name|find_function_start_sal
argument_list|(
name|sym
argument_list|,
name|funfirstline
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|values
operator|.
name|nelts
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|values
return|;
block|}
if|if
condition|(
name|i1
operator|>
literal|0
condition|)
block|{
comment|/* There is more than one field with that name 	 (overloaded).  Ask the user which one to use.  */
return|return
name|decode_line_2
argument_list|(
name|sym_arr
argument_list|,
name|i1
argument_list|,
name|funfirstline
argument_list|,
name|canonical
argument_list|)
return|;
block|}
else|else
block|{
name|char
modifier|*
name|tmp
decl_stmt|;
if|if
condition|(
name|is_operator_name
argument_list|(
name|copy
argument_list|)
condition|)
block|{
name|tmp
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|copy
operator|+
literal|3
argument_list|)
operator|+
literal|9
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|tmp
argument_list|,
literal|"operator "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmp
argument_list|,
name|copy
operator|+
literal|3
argument_list|)
expr_stmt|;
block|}
else|else
name|tmp
operator|=
name|copy
expr_stmt|;
if|if
condition|(
name|tmp
index|[
literal|0
index|]
operator|==
literal|'~'
condition|)
name|cplusplus_error
argument_list|(
name|saved_arg
argument_list|,
literal|"the class `%s' does not have destructor defined\n"
argument_list|,
name|SYMBOL_PRINT_NAME
argument_list|(
name|sym_class
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|cplusplus_error
argument_list|(
name|saved_arg
argument_list|,
literal|"the class %s does not have any method named %s\n"
argument_list|,
name|SYMBOL_PRINT_NAME
argument_list|(
name|sym_class
argument_list|)
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Find all methods named COPY in the class whose type is T, and put    them in SYM_ARR.  Return the number of methods found.  */
end_comment

begin_function
specifier|static
name|int
name|collect_methods
parameter_list|(
name|char
modifier|*
name|copy
parameter_list|,
name|struct
name|type
modifier|*
name|t
parameter_list|,
name|struct
name|symbol
modifier|*
modifier|*
name|sym_arr
parameter_list|)
block|{
name|int
name|i1
init|=
literal|0
decl_stmt|;
comment|/*  Counter for the symbol array.  */
if|if
condition|(
name|destructor_name_p
argument_list|(
name|copy
argument_list|,
name|t
argument_list|)
condition|)
block|{
comment|/* Destructors are a special case.  */
name|int
name|m_index
decl_stmt|,
name|f_index
decl_stmt|;
if|if
condition|(
name|get_destructor_fn_field
argument_list|(
name|t
argument_list|,
operator|&
name|m_index
argument_list|,
operator|&
name|f_index
argument_list|)
condition|)
block|{
name|struct
name|fn_field
modifier|*
name|f
init|=
name|TYPE_FN_FIELDLIST1
argument_list|(
name|t
argument_list|,
name|m_index
argument_list|)
decl_stmt|;
name|sym_arr
index|[
name|i1
index|]
operator|=
name|lookup_symbol
argument_list|(
name|TYPE_FN_FIELD_PHYSNAME
argument_list|(
name|f
argument_list|,
name|f_index
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|VAR_DOMAIN
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
operator|(
expr|struct
name|symtab
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym_arr
index|[
name|i1
index|]
condition|)
name|i1
operator|++
expr_stmt|;
block|}
block|}
else|else
name|i1
operator|=
name|find_methods
argument_list|(
name|t
argument_list|,
name|copy
argument_list|,
name|sym_arr
argument_list|)
expr_stmt|;
return|return
name|i1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the symtab associated to the filename given by the substring    of *ARGPTR ending at P, and advance ARGPTR past that filename.  If    NOT_FOUND_PTR is not null and the source file is not found, store    boolean true at the location pointed to and do not issue an    error message.  */
end_comment

begin_function
specifier|static
name|struct
name|symtab
modifier|*
name|symtab_from_filename
parameter_list|(
name|char
modifier|*
modifier|*
name|argptr
parameter_list|,
name|char
modifier|*
name|p
parameter_list|,
name|int
name|is_quote_enclosed
parameter_list|,
name|int
modifier|*
name|not_found_ptr
parameter_list|)
block|{
name|char
modifier|*
name|p1
decl_stmt|;
name|char
modifier|*
name|copy
decl_stmt|;
name|struct
name|symtab
modifier|*
name|file_symtab
decl_stmt|;
name|p1
operator|=
name|p
expr_stmt|;
while|while
condition|(
name|p
operator|!=
operator|*
name|argptr
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
operator|--
name|p
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|p
operator|==
literal|'"'
operator|)
operator|&&
name|is_quote_enclosed
condition|)
operator|--
name|p
expr_stmt|;
name|copy
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|p
operator|-
operator|*
name|argptr
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|copy
argument_list|,
operator|*
name|argptr
argument_list|,
name|p
operator|-
operator|*
name|argptr
argument_list|)
expr_stmt|;
comment|/* It may have the ending quote right after the file name.  */
if|if
condition|(
name|is_quote_enclosed
operator|&&
name|copy
index|[
name|p
operator|-
operator|*
name|argptr
operator|-
literal|1
index|]
operator|==
literal|'"'
condition|)
name|copy
index|[
name|p
operator|-
operator|*
name|argptr
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
else|else
name|copy
index|[
name|p
operator|-
operator|*
name|argptr
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Find that file's data.  */
name|file_symtab
operator|=
name|lookup_symtab
argument_list|(
name|copy
argument_list|)
expr_stmt|;
if|if
condition|(
name|file_symtab
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|have_full_symbols
argument_list|()
operator|&&
operator|!
name|have_partial_symbols
argument_list|()
condition|)
name|error
argument_list|(
literal|"No symbol table is loaded.  Use the \"file\" command."
argument_list|)
expr_stmt|;
if|if
condition|(
name|not_found_ptr
condition|)
block|{
operator|*
name|not_found_ptr
operator|=
literal|1
expr_stmt|;
comment|/* The caller has indicated that it wishes quiet notification of any 	     error where the function or file is not found.  A call to  	     error_silent causes an error to occur, but it does not issue  	     the supplied message.  The message can be manually output by 	     the caller, if desired.  This is used, for example, when  	     attempting to set breakpoints for functions in shared libraries  	     that have not yet been loaded.  */
name|error_silent
argument_list|(
literal|"No source file named %s."
argument_list|,
name|copy
argument_list|)
expr_stmt|;
block|}
name|error
argument_list|(
literal|"No source file named %s."
argument_list|,
name|copy
argument_list|)
expr_stmt|;
block|}
comment|/* Discard the file name from the arg.  */
name|p
operator|=
name|p1
operator|+
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
operator|*
name|argptr
operator|=
name|p
expr_stmt|;
return|return
name|file_symtab
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This decodes a line where the argument is all digits (possibly    preceded by a sign).  Q should point to the end of those digits;    the other arguments are as usual.  */
end_comment

begin_function
specifier|static
name|struct
name|symtabs_and_lines
name|decode_all_digits
parameter_list|(
name|char
modifier|*
modifier|*
name|argptr
parameter_list|,
name|struct
name|symtab
modifier|*
name|default_symtab
parameter_list|,
name|int
name|default_line
parameter_list|,
name|char
modifier|*
modifier|*
modifier|*
name|canonical
parameter_list|,
name|struct
name|symtab
modifier|*
name|file_symtab
parameter_list|,
name|char
modifier|*
name|q
parameter_list|)
block|{
name|struct
name|symtabs_and_lines
name|values
decl_stmt|;
name|struct
name|symtab_and_line
name|val
decl_stmt|;
enum|enum
name|sign
block|{
name|none
block|,
name|plus
block|,
name|minus
block|}
name|sign
init|=
name|none
enum|;
comment|/* We might need a canonical line spec if no file was specified.  */
name|int
name|need_canonical
init|=
operator|(
name|file_symtab
operator|==
literal|0
operator|)
condition|?
literal|1
else|:
literal|0
decl_stmt|;
name|init_sal
argument_list|(
operator|&
name|val
argument_list|)
expr_stmt|;
comment|/* This is where we need to make sure that we have good defaults.      We must guarantee that this section of code is never executed      when we are called with just a function name, since      set_default_source_symtab_and_line uses      select_source_symtab that calls us with such an argument.  */
if|if
condition|(
name|file_symtab
operator|==
literal|0
operator|&&
name|default_symtab
operator|==
literal|0
condition|)
block|{
comment|/* Make sure we have at least a default source file.  */
name|set_default_source_symtab_and_line
argument_list|()
expr_stmt|;
name|initialize_defaults
argument_list|(
operator|&
name|default_symtab
argument_list|,
operator|&
name|default_line
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
operator|*
name|argptr
operator|==
literal|'+'
condition|)
name|sign
operator|=
name|plus
operator|,
operator|(
operator|*
name|argptr
operator|)
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
operator|*
name|argptr
operator|==
literal|'-'
condition|)
name|sign
operator|=
name|minus
operator|,
operator|(
operator|*
name|argptr
operator|)
operator|++
expr_stmt|;
name|val
operator|.
name|line
operator|=
name|atoi
argument_list|(
operator|*
name|argptr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sign
condition|)
block|{
case|case
name|plus
case|:
if|if
condition|(
name|q
operator|==
operator|*
name|argptr
condition|)
name|val
operator|.
name|line
operator|=
literal|5
expr_stmt|;
if|if
condition|(
name|file_symtab
operator|==
literal|0
condition|)
name|val
operator|.
name|line
operator|=
name|default_line
operator|+
name|val
operator|.
name|line
expr_stmt|;
break|break;
case|case
name|minus
case|:
if|if
condition|(
name|q
operator|==
operator|*
name|argptr
condition|)
name|val
operator|.
name|line
operator|=
literal|15
expr_stmt|;
if|if
condition|(
name|file_symtab
operator|==
literal|0
condition|)
name|val
operator|.
name|line
operator|=
name|default_line
operator|-
name|val
operator|.
name|line
expr_stmt|;
else|else
name|val
operator|.
name|line
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|none
case|:
break|break;
comment|/* No need to adjust val.line.  */
block|}
while|while
condition|(
operator|*
name|q
operator|==
literal|' '
operator|||
operator|*
name|q
operator|==
literal|'\t'
condition|)
name|q
operator|++
expr_stmt|;
operator|*
name|argptr
operator|=
name|q
expr_stmt|;
if|if
condition|(
name|file_symtab
operator|==
literal|0
condition|)
name|file_symtab
operator|=
name|default_symtab
expr_stmt|;
comment|/* It is possible that this source file has more than one symtab,       and that the new line number specification has moved us from the      default (in file_symtab) to a new one.  */
name|val
operator|.
name|symtab
operator|=
name|find_line_symtab
argument_list|(
name|file_symtab
argument_list|,
name|val
operator|.
name|line
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|.
name|symtab
operator|==
literal|0
condition|)
name|val
operator|.
name|symtab
operator|=
name|file_symtab
expr_stmt|;
name|val
operator|.
name|pc
operator|=
literal|0
expr_stmt|;
name|values
operator|.
name|sals
operator|=
operator|(
expr|struct
name|symtab_and_line
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|symtab_and_line
argument_list|)
argument_list|)
expr_stmt|;
name|values
operator|.
name|sals
index|[
literal|0
index|]
operator|=
name|val
expr_stmt|;
name|values
operator|.
name|nelts
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|need_canonical
condition|)
name|build_canonical_line_spec
argument_list|(
name|values
operator|.
name|sals
argument_list|,
name|NULL
argument_list|,
name|canonical
argument_list|)
expr_stmt|;
return|return
name|values
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Decode a linespec starting with a dollar sign.  */
end_comment

begin_function
specifier|static
name|struct
name|symtabs_and_lines
name|decode_dollar
parameter_list|(
name|char
modifier|*
name|copy
parameter_list|,
name|int
name|funfirstline
parameter_list|,
name|struct
name|symtab
modifier|*
name|default_symtab
parameter_list|,
name|char
modifier|*
modifier|*
modifier|*
name|canonical
parameter_list|,
name|struct
name|symtab
modifier|*
name|file_symtab
parameter_list|)
block|{
name|struct
name|value
modifier|*
name|valx
decl_stmt|;
name|int
name|index
init|=
literal|0
decl_stmt|;
name|int
name|need_canonical
init|=
literal|0
decl_stmt|;
name|struct
name|symtabs_and_lines
name|values
decl_stmt|;
name|struct
name|symtab_and_line
name|val
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
comment|/* The symtab that SYM was found in.  */
name|struct
name|symtab
modifier|*
name|sym_symtab
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
name|p
operator|=
operator|(
name|copy
index|[
literal|1
index|]
operator|==
literal|'$'
operator|)
condition|?
name|copy
operator|+
literal|2
else|:
name|copy
operator|+
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|>=
literal|'0'
operator|&&
operator|*
name|p
operator|<=
literal|'9'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|p
condition|)
comment|/* Reached end of token without hitting non-digit.  */
block|{
comment|/* We have a value history reference.  */
name|sscanf
argument_list|(
operator|(
name|copy
index|[
literal|1
index|]
operator|==
literal|'$'
operator|)
condition|?
name|copy
operator|+
literal|2
else|:
name|copy
operator|+
literal|1
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|index
argument_list|)
expr_stmt|;
name|valx
operator|=
name|access_value_history
argument_list|(
operator|(
name|copy
index|[
literal|1
index|]
operator|==
literal|'$'
operator|)
condition|?
operator|-
name|index
else|:
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|valx
argument_list|)
argument_list|)
operator|!=
name|TYPE_CODE_INT
condition|)
name|error
argument_list|(
literal|"History values used in line specs must have integer values."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Not all digits -- may be user variable/function or a 	 convenience variable.  */
comment|/* Look up entire name as a symbol first.  */
name|sym
operator|=
name|lookup_symbol
argument_list|(
name|copy
argument_list|,
literal|0
argument_list|,
name|VAR_DOMAIN
argument_list|,
literal|0
argument_list|,
operator|&
name|sym_symtab
argument_list|)
expr_stmt|;
name|file_symtab
operator|=
operator|(
expr|struct
name|symtab
operator|*
operator|)
literal|0
expr_stmt|;
name|need_canonical
operator|=
literal|1
expr_stmt|;
comment|/* Symbol was found --> jump to normal symbol processing.  */
if|if
condition|(
name|sym
condition|)
return|return
name|symbol_found
argument_list|(
name|funfirstline
argument_list|,
name|canonical
argument_list|,
name|copy
argument_list|,
name|sym
argument_list|,
name|NULL
argument_list|,
name|sym_symtab
argument_list|)
return|;
comment|/* If symbol was not found, look in minimal symbol tables.  */
name|msymbol
operator|=
name|lookup_minimal_symbol
argument_list|(
name|copy
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Min symbol was found --> jump to minsym processing.  */
if|if
condition|(
name|msymbol
condition|)
return|return
name|minsym_found
argument_list|(
name|funfirstline
argument_list|,
name|msymbol
argument_list|)
return|;
comment|/* Not a user variable or function -- must be convenience variable.  */
name|need_canonical
operator|=
operator|(
name|file_symtab
operator|==
literal|0
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|valx
operator|=
name|value_of_internalvar
argument_list|(
name|lookup_internalvar
argument_list|(
name|copy
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|valx
argument_list|)
argument_list|)
operator|!=
name|TYPE_CODE_INT
condition|)
name|error
argument_list|(
literal|"Convenience variables used in line specs must have integer values."
argument_list|)
expr_stmt|;
block|}
name|init_sal
argument_list|(
operator|&
name|val
argument_list|)
expr_stmt|;
comment|/* Either history value or convenience value from above, in valx.  */
name|val
operator|.
name|symtab
operator|=
name|file_symtab
condition|?
name|file_symtab
else|:
name|default_symtab
expr_stmt|;
name|val
operator|.
name|line
operator|=
name|value_as_long
argument_list|(
name|valx
argument_list|)
expr_stmt|;
name|val
operator|.
name|pc
operator|=
literal|0
expr_stmt|;
name|values
operator|.
name|sals
operator|=
operator|(
expr|struct
name|symtab_and_line
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
name|val
argument_list|)
expr_stmt|;
name|values
operator|.
name|sals
index|[
literal|0
index|]
operator|=
name|val
expr_stmt|;
name|values
operator|.
name|nelts
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|need_canonical
condition|)
name|build_canonical_line_spec
argument_list|(
name|values
operator|.
name|sals
argument_list|,
name|NULL
argument_list|,
name|canonical
argument_list|)
expr_stmt|;
return|return
name|values
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Decode a linespec that's a variable.  If FILE_SYMTAB is non-NULL,    look in that symtab's static variables first.  If NOT_FOUND_PTR is not NULL and    the function cannot be found, store boolean true in the location pointed to    and do not issue an error message.  */
end_comment

begin_function
specifier|static
name|struct
name|symtabs_and_lines
name|decode_variable
parameter_list|(
name|char
modifier|*
name|copy
parameter_list|,
name|int
name|funfirstline
parameter_list|,
name|char
modifier|*
modifier|*
modifier|*
name|canonical
parameter_list|,
name|struct
name|symtab
modifier|*
name|file_symtab
parameter_list|,
name|int
modifier|*
name|not_found_ptr
parameter_list|)
block|{
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
comment|/* The symtab that SYM was found in.  */
name|struct
name|symtab
modifier|*
name|sym_symtab
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
name|sym
operator|=
name|lookup_symbol
argument_list|(
name|copy
argument_list|,
operator|(
name|file_symtab
condition|?
name|BLOCKVECTOR_BLOCK
argument_list|(
name|BLOCKVECTOR
argument_list|(
name|file_symtab
argument_list|)
argument_list|,
name|STATIC_BLOCK
argument_list|)
else|:
name|get_selected_block
argument_list|(
literal|0
argument_list|)
operator|)
argument_list|,
name|VAR_DOMAIN
argument_list|,
literal|0
argument_list|,
operator|&
name|sym_symtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|!=
name|NULL
condition|)
return|return
name|symbol_found
argument_list|(
name|funfirstline
argument_list|,
name|canonical
argument_list|,
name|copy
argument_list|,
name|sym
argument_list|,
name|file_symtab
argument_list|,
name|sym_symtab
argument_list|)
return|;
name|msymbol
operator|=
name|lookup_minimal_symbol
argument_list|(
name|copy
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|msymbol
operator|!=
name|NULL
condition|)
return|return
name|minsym_found
argument_list|(
name|funfirstline
argument_list|,
name|msymbol
argument_list|)
return|;
if|if
condition|(
operator|!
name|have_full_symbols
argument_list|()
operator|&&
operator|!
name|have_partial_symbols
argument_list|()
operator|&&
operator|!
name|have_minimal_symbols
argument_list|()
condition|)
name|error
argument_list|(
literal|"No symbol table is loaded.  Use the \"file\" command."
argument_list|)
expr_stmt|;
if|if
condition|(
name|not_found_ptr
condition|)
block|{
operator|*
name|not_found_ptr
operator|=
literal|1
expr_stmt|;
comment|/* The caller has indicated that it wishes quiet notification of any 	 error where the function or file is not found.  A call to  	 error_silent causes an error to occur, but it does not issue  	 the supplied message.  The message can be manually output by 	 the caller, if desired.  This is used, for example, when  	 attempting to set breakpoints for functions in shared libraries  	 that have not yet been loaded.  */
name|error_silent
argument_list|(
literal|"Function \"%s\" not defined."
argument_list|,
name|copy
argument_list|)
expr_stmt|;
block|}
name|error
argument_list|(
literal|"Function \"%s\" not defined."
argument_list|,
name|copy
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Now come some functions that are called from multiple places within    decode_line_1.  */
end_comment

begin_comment
comment|/* We've found a symbol SYM to associate with our linespec; build a    corresponding struct symtabs_and_lines.  */
end_comment

begin_function
specifier|static
name|struct
name|symtabs_and_lines
name|symbol_found
parameter_list|(
name|int
name|funfirstline
parameter_list|,
name|char
modifier|*
modifier|*
modifier|*
name|canonical
parameter_list|,
name|char
modifier|*
name|copy
parameter_list|,
name|struct
name|symbol
modifier|*
name|sym
parameter_list|,
name|struct
name|symtab
modifier|*
name|file_symtab
parameter_list|,
name|struct
name|symtab
modifier|*
name|sym_symtab
parameter_list|)
block|{
name|struct
name|symtabs_and_lines
name|values
decl_stmt|;
if|if
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_BLOCK
condition|)
block|{
comment|/* Arg is the name of a function */
name|values
operator|.
name|sals
operator|=
operator|(
expr|struct
name|symtab_and_line
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|symtab_and_line
argument_list|)
argument_list|)
expr_stmt|;
name|values
operator|.
name|sals
index|[
literal|0
index|]
operator|=
name|find_function_start_sal
argument_list|(
name|sym
argument_list|,
name|funfirstline
argument_list|)
expr_stmt|;
name|values
operator|.
name|nelts
operator|=
literal|1
expr_stmt|;
comment|/* Don't use the SYMBOL_LINE; if used at all it points to 	 the line containing the parameters or thereabouts, not 	 the first line of code.  */
comment|/* We might need a canonical line spec if it is a static 	 function.  */
if|if
condition|(
name|file_symtab
operator|==
literal|0
condition|)
block|{
name|struct
name|blockvector
modifier|*
name|bv
init|=
name|BLOCKVECTOR
argument_list|(
name|sym_symtab
argument_list|)
decl_stmt|;
name|struct
name|block
modifier|*
name|b
init|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|STATIC_BLOCK
argument_list|)
decl_stmt|;
if|if
condition|(
name|lookup_block_symbol
argument_list|(
name|b
argument_list|,
name|copy
argument_list|,
name|NULL
argument_list|,
name|VAR_DOMAIN
argument_list|)
operator|!=
name|NULL
condition|)
name|build_canonical_line_spec
argument_list|(
name|values
operator|.
name|sals
argument_list|,
name|copy
argument_list|,
name|canonical
argument_list|)
expr_stmt|;
block|}
return|return
name|values
return|;
block|}
else|else
block|{
if|if
condition|(
name|funfirstline
condition|)
name|error
argument_list|(
literal|"\"%s\" is not a function"
argument_list|,
name|copy
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|SYMBOL_LINE
argument_list|(
name|sym
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* We know its line number.  */
name|values
operator|.
name|sals
operator|=
operator|(
expr|struct
name|symtab_and_line
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|symtab_and_line
argument_list|)
argument_list|)
expr_stmt|;
name|values
operator|.
name|nelts
operator|=
literal|1
expr_stmt|;
name|memset
argument_list|(
operator|&
name|values
operator|.
name|sals
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|values
operator|.
name|sals
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|values
operator|.
name|sals
index|[
literal|0
index|]
operator|.
name|symtab
operator|=
name|sym_symtab
expr_stmt|;
name|values
operator|.
name|sals
index|[
literal|0
index|]
operator|.
name|line
operator|=
name|SYMBOL_LINE
argument_list|(
name|sym
argument_list|)
expr_stmt|;
return|return
name|values
return|;
block|}
else|else
comment|/* This can happen if it is compiled with a compiler which doesn't 	   put out line numbers for variables.  */
comment|/* FIXME: Shouldn't we just set .line and .symtab to zero 	   and return?  For example, "info line foo" could print 	   the address.  */
name|error
argument_list|(
literal|"Line number not known for symbol \"%s\""
argument_list|,
name|copy
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* We've found a minimal symbol MSYMBOL to associate with our    linespec; build a corresponding struct symtabs_and_lines.  */
end_comment

begin_function
specifier|static
name|struct
name|symtabs_and_lines
name|minsym_found
parameter_list|(
name|int
name|funfirstline
parameter_list|,
name|struct
name|minimal_symbol
modifier|*
name|msymbol
parameter_list|)
block|{
name|struct
name|symtabs_and_lines
name|values
decl_stmt|;
name|values
operator|.
name|sals
operator|=
operator|(
expr|struct
name|symtab_and_line
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|symtab_and_line
argument_list|)
argument_list|)
expr_stmt|;
name|values
operator|.
name|sals
index|[
literal|0
index|]
operator|=
name|find_pc_sect_line
argument_list|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
argument_list|,
operator|(
expr|struct
name|bfd_section
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|values
operator|.
name|sals
index|[
literal|0
index|]
operator|.
name|section
operator|=
name|SYMBOL_BFD_SECTION
argument_list|(
name|msymbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|funfirstline
condition|)
block|{
name|values
operator|.
name|sals
index|[
literal|0
index|]
operator|.
name|pc
operator|+=
name|FUNCTION_START_OFFSET
expr_stmt|;
name|values
operator|.
name|sals
index|[
literal|0
index|]
operator|.
name|pc
operator|=
name|SKIP_PROLOGUE
argument_list|(
name|values
operator|.
name|sals
index|[
literal|0
index|]
operator|.
name|pc
argument_list|)
expr_stmt|;
block|}
name|values
operator|.
name|nelts
operator|=
literal|1
expr_stmt|;
return|return
name|values
return|;
block|}
end_function

end_unit

