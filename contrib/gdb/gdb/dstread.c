begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Read apollo DST symbol tables and convert to internal format, for GDB.    Contributed by Troy Rollo, University of NSW (troy@cbme.unsw.edu.au).    Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000    Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"breakpoint.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"buildsym.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"dst.h"
end_include

begin_decl_stmt
name|CORE_ADDR
name|cur_src_start_addr
decl_stmt|,
name|cur_src_end_addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|dst_sec
name|blocks_info
decl_stmt|,
name|lines_info
decl_stmt|,
name|symbols_info
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Vector of line number information.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|linetable
modifier|*
name|line_vector
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Index of next entry to go in line_vector_index.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|line_vector_index
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last line number recorded in the line vector.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|prev_line_number
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of elements allocated for line_vector currently.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|line_vector_length
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|init_dst_sections
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|read_dst_symtab
parameter_list|(
name|struct
name|objfile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|find_dst_sections
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|sec_ptr
parameter_list|,
name|PTR
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dst_symfile_init
parameter_list|(
name|struct
name|objfile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dst_new_init
parameter_list|(
name|struct
name|objfile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dst_symfile_read
parameter_list|(
name|struct
name|objfile
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dst_symfile_finish
parameter_list|(
name|struct
name|objfile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dst_end_symtab
parameter_list|(
name|struct
name|objfile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|complete_symtab
parameter_list|(
name|char
modifier|*
parameter_list|,
name|CORE_ADDR
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dst_start_symtab
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dst_record_line
parameter_list|(
name|int
parameter_list|,
name|CORE_ADDR
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Manage the vector of line numbers.  */
end_comment

begin_comment
comment|/* FIXME: Use record_line instead.  */
end_comment

begin_function
specifier|static
name|void
name|dst_record_line
parameter_list|(
name|int
name|line
parameter_list|,
name|CORE_ADDR
name|pc
parameter_list|)
block|{
name|struct
name|linetable_entry
modifier|*
name|e
decl_stmt|;
comment|/* Make sure line vector is big enough.  */
if|if
condition|(
name|line_vector_index
operator|+
literal|2
operator|>=
name|line_vector_length
condition|)
block|{
name|line_vector_length
operator|*=
literal|2
expr_stmt|;
name|line_vector
operator|=
operator|(
expr|struct
name|linetable
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|line_vector
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|linetable
argument_list|)
operator|+
operator|(
name|line_vector_length
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|linetable_entry
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
name|e
operator|=
name|line_vector
operator|->
name|item
operator|+
name|line_vector_index
operator|++
expr_stmt|;
name|e
operator|->
name|line
operator|=
name|line
expr_stmt|;
name|e
operator|->
name|pc
operator|=
name|pc
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Start a new symtab for a new source file.    It indicates the start of data for one original source file.  */
end_comment

begin_comment
comment|/* FIXME: use start_symtab, like coffread.c now does.  */
end_comment

begin_function
specifier|static
name|void
name|dst_start_symtab
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Initialize the source file line number information for this file.  */
if|if
condition|(
name|line_vector
condition|)
comment|/* Unlikely, but maybe possible? */
name|xfree
argument_list|(
name|line_vector
argument_list|)
expr_stmt|;
name|line_vector_index
operator|=
literal|0
expr_stmt|;
name|line_vector_length
operator|=
literal|1000
expr_stmt|;
name|prev_line_number
operator|=
operator|-
literal|2
expr_stmt|;
comment|/* Force first line number to be explicit */
name|line_vector
operator|=
operator|(
expr|struct
name|linetable
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|linetable
argument_list|)
operator|+
name|line_vector_length
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|linetable_entry
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Save the vital information from when starting to read a file,    for use when closing off the current file.    NAME is the file name the symbols came from, START_ADDR is the first    text address for the file, and SIZE is the number of bytes of text.  */
end_comment

begin_function
specifier|static
name|void
name|complete_symtab
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|CORE_ADDR
name|start_addr
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|)
block|{
name|last_source_file
operator|=
name|savestring
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|cur_src_start_addr
operator|=
name|start_addr
expr_stmt|;
name|cur_src_end_addr
operator|=
name|start_addr
operator|+
name|size
expr_stmt|;
if|if
condition|(
name|current_objfile
operator|->
name|ei
operator|.
name|entry_point
operator|>=
name|cur_src_start_addr
operator|&&
name|current_objfile
operator|->
name|ei
operator|.
name|entry_point
operator|<
name|cur_src_end_addr
condition|)
block|{
name|current_objfile
operator|->
name|ei
operator|.
name|entry_file_lowpc
operator|=
name|cur_src_start_addr
expr_stmt|;
name|current_objfile
operator|->
name|ei
operator|.
name|entry_file_highpc
operator|=
name|cur_src_end_addr
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Finish the symbol definitions for one main source file,    close off all the lexical contexts for that file    (creating struct block's for them), then make the    struct symtab for that file and put it in the list of all such. */
end_comment

begin_comment
comment|/* FIXME: Use end_symtab, like coffread.c now does.  */
end_comment

begin_function
specifier|static
name|void
name|dst_end_symtab
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
specifier|register
name|struct
name|symtab
modifier|*
name|symtab
decl_stmt|;
specifier|register
name|struct
name|blockvector
modifier|*
name|blockvector
decl_stmt|;
specifier|register
name|struct
name|linetable
modifier|*
name|lv
decl_stmt|;
comment|/* Create the blockvector that points to all the file's blocks.  */
name|blockvector
operator|=
name|make_blockvector
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
comment|/* Now create the symtab object for this source file.  */
name|symtab
operator|=
name|allocate_symtab
argument_list|(
name|last_source_file
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* Fill in its components.  */
name|symtab
operator|->
name|blockvector
operator|=
name|blockvector
expr_stmt|;
name|symtab
operator|->
name|free_code
operator|=
name|free_linetable
expr_stmt|;
name|symtab
operator|->
name|free_ptr
operator|=
literal|0
expr_stmt|;
name|symtab
operator|->
name|filename
operator|=
name|last_source_file
expr_stmt|;
name|symtab
operator|->
name|dirname
operator|=
name|NULL
expr_stmt|;
name|symtab
operator|->
name|debugformat
operator|=
name|obsavestring
argument_list|(
literal|"Apollo DST"
argument_list|,
literal|10
argument_list|,
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|)
expr_stmt|;
name|lv
operator|=
name|line_vector
expr_stmt|;
name|lv
operator|->
name|nitems
operator|=
name|line_vector_index
expr_stmt|;
name|symtab
operator|->
name|linetable
operator|=
operator|(
expr|struct
name|linetable
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|lv
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|linetable
argument_list|)
operator|+
name|lv
operator|->
name|nitems
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|linetable_entry
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|free_named_symtabs
argument_list|(
name|symtab
operator|->
name|filename
argument_list|)
expr_stmt|;
comment|/* Reinitialize for beginning of new file. */
name|line_vector
operator|=
literal|0
expr_stmt|;
name|line_vector_length
operator|=
operator|-
literal|1
expr_stmt|;
name|last_source_file
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* dst_symfile_init ()    is the dst-specific initialization routine for reading symbols.     We will only be called if this is a DST or DST-like file.    BFD handles figuring out the format of the file, and code in symtab.c    uses BFD's determination to vector to us.     The ultimate result is a new symtab (or, FIXME, eventually a psymtab).  */
end_comment

begin_function
specifier|static
name|void
name|dst_symfile_init
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|asection
modifier|*
name|section
decl_stmt|;
name|bfd
modifier|*
name|abfd
init|=
name|objfile
operator|->
name|obfd
decl_stmt|;
name|init_entry_point_info
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function is called for every section; it finds the outer limits    of the line table (minimum and maximum file offset) so that the    mainline code can read the whole thing for efficiency.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|find_dst_sections
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|sec_ptr
name|asect
parameter_list|,
name|PTR
name|vpinfo
parameter_list|)
block|{
name|int
name|size
decl_stmt|,
name|count
decl_stmt|;
name|long
name|base
decl_stmt|;
name|file_ptr
name|offset
decl_stmt|,
name|maxoff
decl_stmt|;
name|dst_sec
modifier|*
name|section
decl_stmt|;
comment|/* WARNING WILL ROBINSON!  ACCESSING BFD-PRIVATE DATA HERE!  FIXME!  */
name|size
operator|=
name|asect
operator|->
name|_raw_size
expr_stmt|;
name|offset
operator|=
name|asect
operator|->
name|filepos
expr_stmt|;
name|base
operator|=
name|asect
operator|->
name|vma
expr_stmt|;
comment|/* End of warning */
name|section
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|asect
operator|->
name|name
argument_list|,
literal|".blocks"
argument_list|)
condition|)
name|section
operator|=
operator|&
name|blocks_info
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|asect
operator|->
name|name
argument_list|,
literal|".lines"
argument_list|)
condition|)
name|section
operator|=
operator|&
name|lines_info
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|asect
operator|->
name|name
argument_list|,
literal|".symbols"
argument_list|)
condition|)
name|section
operator|=
operator|&
name|symbols_info
expr_stmt|;
if|if
condition|(
operator|!
name|section
condition|)
return|return;
name|section
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|section
operator|->
name|position
operator|=
name|offset
expr_stmt|;
name|section
operator|->
name|base
operator|=
name|base
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The BFD for this file -- only good while we're actively reading    symbols into a psymtab or a symtab.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd
modifier|*
name|symfile_bfd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Read a symbol file, after initialization by dst_symfile_init.  */
end_comment

begin_comment
comment|/* FIXME!  Addr and Mainline are not used yet -- this will not work for    shared libraries or add_file!  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|dst_symfile_read
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|,
name|int
name|mainline
parameter_list|)
block|{
name|bfd
modifier|*
name|abfd
init|=
name|objfile
operator|->
name|obfd
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|int
name|desc
decl_stmt|;
specifier|register
name|int
name|val
decl_stmt|;
name|int
name|num_symbols
decl_stmt|;
name|int
name|symtab_offset
decl_stmt|;
name|int
name|stringtab_offset
decl_stmt|;
name|symfile_bfd
operator|=
name|abfd
expr_stmt|;
comment|/* Kludge for swap routines */
comment|/* WARNING WILL ROBINSON!  ACCESSING BFD-PRIVATE DATA HERE!  FIXME!  */
name|desc
operator|=
name|fileno
argument_list|(
operator|(
name|FILE
operator|*
operator|)
operator|(
name|abfd
operator|->
name|iostream
operator|)
argument_list|)
expr_stmt|;
comment|/* File descriptor */
comment|/* Read the line number table, all at once.  */
name|bfd_map_over_sections
argument_list|(
name|abfd
argument_list|,
name|find_dst_sections
argument_list|,
operator|(
name|PTR
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|val
operator|=
name|init_dst_sections
argument_list|(
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"\"%s\": error reading debugging symbol tables\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|init_minimal_symbol_collection
argument_list|()
expr_stmt|;
name|make_cleanup_discard_minimal_symbols
argument_list|()
expr_stmt|;
comment|/* Now that the executable file is positioned at symbol table,      process it and define symbols accordingly.  */
name|read_dst_symtab
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
comment|/* Sort symbols alphabetically within each block.  */
block|{
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
name|objfile
operator|->
name|symtabs
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
name|sort_symtab_syms
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Install any minimal symbols that have been collected as the current      minimal symbols for this objfile. */
name|install_minimal_symbols
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dst_new_init
parameter_list|(
name|struct
name|objfile
modifier|*
name|ignore
parameter_list|)
block|{
comment|/* Nothin' to do */
block|}
end_function

begin_comment
comment|/* Perform any local cleanups required when we are done with a particular    objfile.  I.E, we are in the process of discarding all symbol information    for an objfile, freeing up all memory held for it, and unlinking the    objfile struct from the global list of known objfiles. */
end_comment

begin_function
specifier|static
name|void
name|dst_symfile_finish
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
comment|/* Nothing to do */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Get the next line number from the DST. Returns 0 when we hit an  * end directive or cannot continue for any other reason.  *  * Note that ordinary pc deltas are multiplied by two. Apparently  * this is what was really intended.  */
end_comment

begin_function
specifier|static
name|int
name|get_dst_line
parameter_list|(
name|signed
name|char
modifier|*
modifier|*
name|buffer
parameter_list|,
name|long
modifier|*
name|pc
parameter_list|)
block|{
specifier|static
name|last_pc
operator|=
literal|0
expr_stmt|;
specifier|static
name|long
name|last_line
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|last_file
init|=
literal|0
decl_stmt|;
name|dst_ln_entry_ptr_t
name|entry
decl_stmt|;
name|int
name|size
decl_stmt|;
name|dst_src_loc_t
modifier|*
name|src_loc
decl_stmt|;
if|if
condition|(
operator|*
name|pc
operator|!=
operator|-
literal|1
condition|)
block|{
name|last_pc
operator|=
operator|*
name|pc
expr_stmt|;
operator|*
name|pc
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|entry
operator|=
operator|(
name|dst_ln_entry_ptr_t
operator|)
operator|*
name|buffer
expr_stmt|;
while|while
condition|(
name|dst_ln_ln_delta
argument_list|(
operator|*
name|entry
argument_list|)
operator|==
name|dst_ln_escape_flag
condition|)
block|{
switch|switch
condition|(
name|entry
operator|->
name|esc
operator|.
name|esc_code
condition|)
block|{
case|case
name|dst_ln_pad
case|:
name|size
operator|=
literal|1
expr_stmt|;
comment|/* pad byte */
break|break;
case|case
name|dst_ln_file
case|:
comment|/* file escape.  Next 4 bytes are a dst_src_loc_t */
name|size
operator|=
literal|5
expr_stmt|;
name|src_loc
operator|=
operator|(
name|dst_src_loc_t
operator|*
operator|)
operator|(
operator|*
name|buffer
operator|+
literal|1
operator|)
expr_stmt|;
name|last_line
operator|=
name|src_loc
operator|->
name|line_number
expr_stmt|;
name|last_file
operator|=
name|src_loc
operator|->
name|file_index
expr_stmt|;
break|break;
case|case
name|dst_ln_dln1_dpc1
case|:
comment|/* 1 byte line delta, 1 byte pc delta */
name|last_line
operator|+=
operator|(
operator|*
name|buffer
operator|)
index|[
literal|1
index|]
expr_stmt|;
name|last_pc
operator|+=
literal|2
operator|*
call|(
name|unsigned
name|char
call|)
argument_list|(
operator|*
name|buffer
argument_list|)
index|[
literal|2
index|]
expr_stmt|;
name|dst_record_line
argument_list|(
name|last_line
argument_list|,
name|last_pc
argument_list|)
expr_stmt|;
name|size
operator|=
literal|3
expr_stmt|;
break|break;
case|case
name|dst_ln_dln2_dpc2
case|:
comment|/* 2 bytes line delta, 2 bytes pc delta */
name|last_line
operator|+=
operator|*
operator|(
name|short
operator|*
operator|)
operator|(
operator|*
name|buffer
operator|+
literal|1
operator|)
expr_stmt|;
name|last_pc
operator|+=
literal|2
operator|*
operator|(
operator|*
operator|(
name|short
operator|*
operator|)
operator|(
operator|*
name|buffer
operator|+
literal|3
operator|)
operator|)
expr_stmt|;
name|size
operator|=
literal|5
expr_stmt|;
name|dst_record_line
argument_list|(
name|last_line
argument_list|,
name|last_pc
argument_list|)
expr_stmt|;
break|break;
case|case
name|dst_ln_ln4_pc4
case|:
comment|/* 4 bytes ABSOLUTE line number, 4 bytes ABSOLUTE pc */
name|last_line
operator|=
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
operator|(
operator|*
name|buffer
operator|+
literal|1
operator|)
expr_stmt|;
name|last_pc
operator|=
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
operator|(
operator|*
name|buffer
operator|+
literal|5
operator|)
expr_stmt|;
name|size
operator|=
literal|9
expr_stmt|;
name|dst_record_line
argument_list|(
name|last_line
argument_list|,
name|last_pc
argument_list|)
expr_stmt|;
break|break;
case|case
name|dst_ln_dln1_dpc0
case|:
comment|/* 1 byte line delta, pc delta = 0 */
name|size
operator|=
literal|2
expr_stmt|;
name|last_line
operator|+=
operator|(
operator|*
name|buffer
operator|)
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|dst_ln_ln_off_1
case|:
comment|/* statement escape, stmt # = 1 (2nd stmt on line) */
name|size
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|dst_ln_ln_off
case|:
comment|/* statement escape, stmt # = next byte */
name|size
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|dst_ln_entry
case|:
comment|/* entry escape, next byte is entry number */
name|size
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|dst_ln_exit
case|:
comment|/* exit escape */
name|size
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|dst_ln_stmt_end
case|:
comment|/* gap escape, 4 bytes pc delta */
name|size
operator|=
literal|5
expr_stmt|;
comment|/* last_pc += 2 * (*(long *) (*buffer + 1)); */
comment|/* Apparently this isn't supposed to actually modify 	   * the pc value. Totally weird. 	   */
break|break;
case|case
name|dst_ln_escape_11
case|:
case|case
name|dst_ln_escape_12
case|:
case|case
name|dst_ln_escape_13
case|:
name|size
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|dst_ln_nxt_byte
case|:
comment|/* This shouldn't happen. If it does, we're SOL */
return|return
literal|0
return|;
break|break;
case|case
name|dst_ln_end
case|:
comment|/* end escape, final entry follows */
return|return
literal|0
return|;
block|}
operator|*
name|buffer
operator|+=
operator|(
name|size
operator|<
literal|0
operator|)
condition|?
operator|-
name|size
else|:
name|size
expr_stmt|;
name|entry
operator|=
operator|(
name|dst_ln_entry_ptr_t
operator|)
operator|*
name|buffer
expr_stmt|;
block|}
name|last_line
operator|+=
name|dst_ln_ln_delta
argument_list|(
operator|*
name|entry
argument_list|)
expr_stmt|;
name|last_pc
operator|+=
name|entry
operator|->
name|delta
operator|.
name|pc_delta
operator|*
literal|2
expr_stmt|;
operator|(
operator|*
name|buffer
operator|)
operator|++
expr_stmt|;
name|dst_record_line
argument_list|(
name|last_line
argument_list|,
name|last_pc
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|enter_all_lines
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|,
name|long
name|address
parameter_list|)
block|{
if|if
condition|(
name|buffer
condition|)
while|while
condition|(
name|get_dst_line
argument_list|(
operator|&
name|buffer
argument_list|,
operator|&
name|address
argument_list|)
condition|)
empty_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_dst_entry
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|,
name|dst_rec_ptr_t
modifier|*
name|ret_entry
parameter_list|)
block|{
name|int
name|size
decl_stmt|;
name|dst_rec_ptr_t
name|entry
decl_stmt|;
specifier|static
name|int
name|last_type
decl_stmt|;
name|int
name|ar_size
decl_stmt|;
specifier|static
name|unsigned
name|lu3
decl_stmt|;
name|entry
operator|=
operator|(
name|dst_rec_ptr_t
operator|)
name|buffer
expr_stmt|;
switch|switch
condition|(
name|entry
operator|->
name|rec_type
condition|)
block|{
case|case
name|dst_typ_pad
case|:
name|size
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|dst_typ_comp_unit
case|:
name|size
operator|=
sizeof|sizeof
argument_list|(
name|DST_comp_unit
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|dst_typ_section_tab
case|:
name|size
operator|=
sizeof|sizeof
argument_list|(
name|DST_section_tab
argument_list|(
name|entry
argument_list|)
argument_list|)
operator|+
operator|(
operator|(
name|int
operator|)
name|DST_section_tab
argument_list|(
name|entry
argument_list|)
operator|.
name|number_of_sections
operator|-
name|dst_dummy_array_size
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
break|break;
case|case
name|dst_typ_file_tab
case|:
name|size
operator|=
sizeof|sizeof
argument_list|(
name|DST_file_tab
argument_list|(
name|entry
argument_list|)
argument_list|)
operator|+
operator|(
operator|(
name|int
operator|)
name|DST_file_tab
argument_list|(
name|entry
argument_list|)
operator|.
name|number_of_files
operator|-
name|dst_dummy_array_size
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|dst_file_desc_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|dst_typ_block
case|:
name|size
operator|=
sizeof|sizeof
argument_list|(
name|DST_block
argument_list|(
name|entry
argument_list|)
argument_list|)
operator|+
operator|(
operator|(
name|int
operator|)
name|DST_block
argument_list|(
name|entry
argument_list|)
operator|.
name|n_of_code_ranges
operator|-
name|dst_dummy_array_size
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|dst_code_range_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|dst_typ_5
case|:
name|size
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|dst_typ_var
case|:
name|size
operator|=
sizeof|sizeof
argument_list|(
name|DST_var
argument_list|(
name|entry
argument_list|)
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|dst_var_loc_long_t
argument_list|)
operator|*
name|dst_dummy_array_size
operator|+
name|DST_var
argument_list|(
name|entry
argument_list|)
operator|.
name|no_of_locs
operator|*
operator|(
name|DST_var
argument_list|(
name|entry
argument_list|)
operator|.
name|short_locs
condition|?
sizeof|sizeof
argument_list|(
name|dst_var_loc_short_t
argument_list|)
else|:
sizeof|sizeof
argument_list|(
name|dst_var_loc_long_t
argument_list|)
operator|)
expr_stmt|;
break|break;
case|case
name|dst_typ_pointer
case|:
name|size
operator|=
sizeof|sizeof
argument_list|(
name|DST_pointer
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|dst_typ_array
case|:
name|size
operator|=
sizeof|sizeof
argument_list|(
name|DST_array
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|dst_typ_subrange
case|:
name|size
operator|=
sizeof|sizeof
argument_list|(
name|DST_subrange
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|dst_typ_set
case|:
name|size
operator|=
sizeof|sizeof
argument_list|(
name|DST_set
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|dst_typ_implicit_enum
case|:
name|size
operator|=
sizeof|sizeof
argument_list|(
name|DST_implicit_enum
argument_list|(
name|entry
argument_list|)
argument_list|)
operator|+
operator|(
operator|(
name|int
operator|)
name|DST_implicit_enum
argument_list|(
name|entry
argument_list|)
operator|.
name|nelems
operator|-
name|dst_dummy_array_size
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|dst_rel_offset_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|dst_typ_explicit_enum
case|:
name|size
operator|=
sizeof|sizeof
argument_list|(
name|DST_explicit_enum
argument_list|(
name|entry
argument_list|)
argument_list|)
operator|+
operator|(
operator|(
name|int
operator|)
name|DST_explicit_enum
argument_list|(
name|entry
argument_list|)
operator|.
name|nelems
operator|-
name|dst_dummy_array_size
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|dst_enum_elem_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|dst_typ_short_rec
case|:
name|size
operator|=
sizeof|sizeof
argument_list|(
name|DST_short_rec
argument_list|(
name|entry
argument_list|)
argument_list|)
operator|+
name|DST_short_rec
argument_list|(
name|entry
argument_list|)
operator|.
name|nfields
operator|*
sizeof|sizeof
argument_list|(
name|dst_short_field_t
argument_list|)
operator|-
name|dst_dummy_array_size
operator|*
sizeof|sizeof
argument_list|(
name|dst_field_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|dst_typ_short_union
case|:
name|size
operator|=
sizeof|sizeof
argument_list|(
name|DST_short_union
argument_list|(
name|entry
argument_list|)
argument_list|)
operator|+
name|DST_short_union
argument_list|(
name|entry
argument_list|)
operator|.
name|nfields
operator|*
sizeof|sizeof
argument_list|(
name|dst_short_field_t
argument_list|)
operator|-
name|dst_dummy_array_size
operator|*
sizeof|sizeof
argument_list|(
name|dst_field_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|dst_typ_file
case|:
name|size
operator|=
sizeof|sizeof
argument_list|(
name|DST_file
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|dst_typ_offset
case|:
name|size
operator|=
sizeof|sizeof
argument_list|(
name|DST_offset
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|dst_typ_alias
case|:
name|size
operator|=
sizeof|sizeof
argument_list|(
name|DST_alias
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|dst_typ_signature
case|:
name|size
operator|=
sizeof|sizeof
argument_list|(
name|DST_signature
argument_list|(
name|entry
argument_list|)
argument_list|)
operator|+
operator|(
operator|(
name|int
operator|)
name|DST_signature
argument_list|(
name|entry
argument_list|)
operator|.
name|nargs
operator|-
name|dst_dummy_array_size
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|dst_arg_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|dst_typ_21
case|:
name|size
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|dst_typ_old_label
case|:
name|size
operator|=
sizeof|sizeof
argument_list|(
name|DST_old_label
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|dst_typ_scope
case|:
name|size
operator|=
sizeof|sizeof
argument_list|(
name|DST_scope
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|dst_typ_end_scope
case|:
name|size
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|dst_typ_25
case|:
case|case
name|dst_typ_26
case|:
name|size
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|dst_typ_string_tab
case|:
case|case
name|dst_typ_global_name_tab
case|:
name|size
operator|=
sizeof|sizeof
argument_list|(
name|DST_string_tab
argument_list|(
name|entry
argument_list|)
argument_list|)
operator|+
name|DST_string_tab
argument_list|(
name|entry
argument_list|)
operator|.
name|length
operator|-
name|dst_dummy_array_size
expr_stmt|;
break|break;
case|case
name|dst_typ_forward
case|:
name|size
operator|=
sizeof|sizeof
argument_list|(
name|DST_forward
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|get_dst_entry
argument_list|(
operator|(
name|char
operator|*
operator|)
name|entry
operator|+
name|DST_forward
argument_list|(
name|entry
argument_list|)
operator|.
name|rec_off
argument_list|,
operator|&
name|entry
argument_list|)
expr_stmt|;
break|break;
case|case
name|dst_typ_aux_size
case|:
name|size
operator|=
sizeof|sizeof
argument_list|(
name|DST_aux_size
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|dst_typ_aux_align
case|:
name|size
operator|=
sizeof|sizeof
argument_list|(
name|DST_aux_align
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|dst_typ_aux_field_size
case|:
name|size
operator|=
sizeof|sizeof
argument_list|(
name|DST_aux_field_size
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|dst_typ_aux_field_off
case|:
name|size
operator|=
sizeof|sizeof
argument_list|(
name|DST_aux_field_off
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|dst_typ_aux_field_align
case|:
name|size
operator|=
sizeof|sizeof
argument_list|(
name|DST_aux_field_align
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|dst_typ_aux_qual
case|:
name|size
operator|=
sizeof|sizeof
argument_list|(
name|DST_aux_qual
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|dst_typ_aux_var_bound
case|:
name|size
operator|=
sizeof|sizeof
argument_list|(
name|DST_aux_var_bound
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|dst_typ_extension
case|:
name|size
operator|=
name|DST_extension
argument_list|(
name|entry
argument_list|)
operator|.
name|rec_size
expr_stmt|;
break|break;
case|case
name|dst_typ_string
case|:
name|size
operator|=
sizeof|sizeof
argument_list|(
name|DST_string
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|dst_typ_old_entry
case|:
name|size
operator|=
literal|48
expr_stmt|;
comment|/* Obsolete entry type */
break|break;
case|case
name|dst_typ_const
case|:
name|size
operator|=
sizeof|sizeof
argument_list|(
name|DST_const
argument_list|(
name|entry
argument_list|)
argument_list|)
operator|+
name|DST_const
argument_list|(
name|entry
argument_list|)
operator|.
name|value
operator|.
name|length
operator|-
sizeof|sizeof
argument_list|(
name|DST_const
argument_list|(
name|entry
argument_list|)
operator|.
name|value
operator|.
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
name|dst_typ_reference
case|:
name|size
operator|=
sizeof|sizeof
argument_list|(
name|DST_reference
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|dst_typ_old_record
case|:
case|case
name|dst_typ_old_union
case|:
case|case
name|dst_typ_record
case|:
case|case
name|dst_typ_union
case|:
name|size
operator|=
sizeof|sizeof
argument_list|(
name|DST_record
argument_list|(
name|entry
argument_list|)
argument_list|)
operator|+
operator|(
operator|(
name|int
operator|)
name|DST_record
argument_list|(
name|entry
argument_list|)
operator|.
name|nfields
operator|-
name|dst_dummy_array_size
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|dst_field_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|dst_typ_aux_type_deriv
case|:
name|size
operator|=
sizeof|sizeof
argument_list|(
name|DST_aux_type_deriv
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|dst_typ_locpool
case|:
name|size
operator|=
sizeof|sizeof
argument_list|(
name|DST_locpool
argument_list|(
name|entry
argument_list|)
argument_list|)
operator|+
operator|(
operator|(
name|int
operator|)
name|DST_locpool
argument_list|(
name|entry
argument_list|)
operator|.
name|length
operator|-
name|dst_dummy_array_size
operator|)
expr_stmt|;
break|break;
case|case
name|dst_typ_variable
case|:
name|size
operator|=
sizeof|sizeof
argument_list|(
name|DST_variable
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|dst_typ_label
case|:
name|size
operator|=
sizeof|sizeof
argument_list|(
name|DST_label
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|dst_typ_entry
case|:
name|size
operator|=
sizeof|sizeof
argument_list|(
name|DST_entry
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|dst_typ_aux_lifetime
case|:
name|size
operator|=
sizeof|sizeof
argument_list|(
name|DST_aux_lifetime
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|dst_typ_aux_ptr_base
case|:
name|size
operator|=
sizeof|sizeof
argument_list|(
name|DST_aux_ptr_base
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|dst_typ_aux_src_range
case|:
name|size
operator|=
sizeof|sizeof
argument_list|(
name|DST_aux_src_range
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|dst_typ_aux_reg_val
case|:
name|size
operator|=
sizeof|sizeof
argument_list|(
name|DST_aux_reg_val
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|dst_typ_aux_unit_names
case|:
name|size
operator|=
sizeof|sizeof
argument_list|(
name|DST_aux_unit_names
argument_list|(
name|entry
argument_list|)
argument_list|)
operator|+
operator|(
operator|(
name|int
operator|)
name|DST_aux_unit_names
argument_list|(
name|entry
argument_list|)
operator|.
name|number_of_names
operator|-
name|dst_dummy_array_size
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|dst_rel_offset_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|dst_typ_aux_sect_info
case|:
name|size
operator|=
sizeof|sizeof
argument_list|(
name|DST_aux_sect_info
argument_list|(
name|entry
argument_list|)
argument_list|)
operator|+
operator|(
operator|(
name|int
operator|)
name|DST_aux_sect_info
argument_list|(
name|entry
argument_list|)
operator|.
name|number_of_refs
operator|-
name|dst_dummy_array_size
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|dst_sect_ref_t
argument_list|)
expr_stmt|;
break|break;
default|default:
name|size
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|size
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Warning: unexpected DST entry type (%d) found\nLast valid entry was of type: %d\n"
argument_list|,
operator|(
name|int
operator|)
name|entry
operator|->
name|rec_type
argument_list|,
name|last_type
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Last unknown_3 value: %d\n"
argument_list|,
name|lu3
argument_list|)
expr_stmt|;
name|size
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|last_type
operator|=
name|entry
operator|->
name|rec_type
expr_stmt|;
if|if
condition|(
name|size
operator|&
literal|1
condition|)
comment|/* Align on a word boundary */
name|size
operator|++
expr_stmt|;
name|size
operator|+=
literal|2
expr_stmt|;
operator|*
name|ret_entry
operator|=
name|entry
expr_stmt|;
return|return
name|size
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|next_dst_entry
parameter_list|(
name|char
modifier|*
modifier|*
name|buffer
parameter_list|,
name|dst_rec_ptr_t
modifier|*
name|entry
parameter_list|,
name|dst_sec
modifier|*
name|table
parameter_list|)
block|{
if|if
condition|(
operator|*
name|buffer
operator|-
name|table
operator|->
name|buffer
operator|>=
name|table
operator|->
name|size
condition|)
block|{
operator|*
name|entry
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|buffer
operator|+=
name|get_dst_entry
argument_list|(
operator|*
name|buffer
argument_list|,
name|entry
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_define
define|#
directive|define
name|NEXT_BLK
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|next_dst_entry(a, b,&blocks_info)
end_define

begin_define
define|#
directive|define
name|NEXT_SYM
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|next_dst_entry(a, b,&symbols_info)
end_define

begin_define
define|#
directive|define
name|DST_OFFSET
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((char *) (a) + (b))
end_define

begin_decl_stmt
specifier|static
name|dst_rec_ptr_t
name|section_table
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|get_sec_ref
parameter_list|(
name|dst_sect_ref_t
modifier|*
name|ref
parameter_list|)
block|{
name|dst_sec
modifier|*
name|section
init|=
name|NULL
decl_stmt|;
name|long
name|offset
decl_stmt|;
if|if
condition|(
operator|!
name|section_table
operator|||
operator|!
name|ref
operator|->
name|sect_index
condition|)
return|return
name|NULL
return|;
name|offset
operator|=
name|DST_section_tab
argument_list|(
name|section_table
argument_list|)
operator|.
name|section_base
index|[
name|ref
operator|->
name|sect_index
operator|-
literal|1
index|]
operator|+
name|ref
operator|->
name|sect_offset
expr_stmt|;
if|if
condition|(
name|offset
operator|>=
name|blocks_info
operator|.
name|base
operator|&&
name|offset
operator|<
name|blocks_info
operator|.
name|base
operator|+
name|blocks_info
operator|.
name|size
condition|)
name|section
operator|=
operator|&
name|blocks_info
expr_stmt|;
elseif|else
if|if
condition|(
name|offset
operator|>=
name|symbols_info
operator|.
name|base
operator|&&
name|offset
operator|<
name|symbols_info
operator|.
name|base
operator|+
name|symbols_info
operator|.
name|size
condition|)
name|section
operator|=
operator|&
name|symbols_info
expr_stmt|;
elseif|else
if|if
condition|(
name|offset
operator|>=
name|lines_info
operator|.
name|base
operator|&&
name|offset
operator|<
name|lines_info
operator|.
name|base
operator|+
name|lines_info
operator|.
name|size
condition|)
name|section
operator|=
operator|&
name|lines_info
expr_stmt|;
if|if
condition|(
operator|!
name|section
condition|)
return|return
name|NULL
return|;
return|return
name|section
operator|->
name|buffer
operator|+
operator|(
name|offset
operator|-
name|section
operator|->
name|base
operator|)
return|;
block|}
end_function

begin_function
name|CORE_ADDR
name|dst_get_addr
parameter_list|(
name|int
name|section
parameter_list|,
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
name|section_table
operator|||
operator|!
name|section
condition|)
return|return
literal|0
return|;
return|return
name|DST_section_tab
argument_list|(
name|section_table
argument_list|)
operator|.
name|section_base
index|[
name|section
operator|-
literal|1
index|]
operator|+
name|offset
return|;
block|}
end_function

begin_function
name|CORE_ADDR
name|dst_sym_addr
parameter_list|(
name|dst_sect_ref_t
modifier|*
name|ref
parameter_list|)
block|{
if|if
condition|(
operator|!
name|section_table
operator|||
operator|!
name|ref
operator|->
name|sect_index
condition|)
return|return
literal|0
return|;
return|return
name|DST_section_tab
argument_list|(
name|section_table
argument_list|)
operator|.
name|section_base
index|[
name|ref
operator|->
name|sect_index
operator|-
literal|1
index|]
operator|+
name|ref
operator|->
name|sect_offset
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|type
modifier|*
name|create_new_type
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|type
operator|=
operator|(
expr|struct
name|type
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|symbol
modifier|*
name|create_new_symbol
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|symbol
modifier|*
name|sym
init|=
operator|(
expr|struct
name|symbol
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
decl_stmt|;
name|memset
argument_list|(
name|sym
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|=
name|obsavestring
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|)
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_BLOCK
expr_stmt|;
return|return
name|sym
return|;
block|}
end_function

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|static
name|struct
name|type
modifier|*
name|decode_dst_type
parameter_list|(
name|struct
name|objfile
modifier|*
parameter_list|,
name|dst_rec_ptr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|struct
name|type
modifier|*
name|decode_type_desc
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|,
name|dst_type_t
modifier|*
name|type_desc
parameter_list|,
name|dst_rec_ptr_t
name|base
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|dst_rec_ptr_t
name|entry
decl_stmt|;
if|if
condition|(
name|type_desc
operator|->
name|std_type
operator|.
name|user_defined_type
condition|)
block|{
name|entry
operator|=
operator|(
name|dst_rec_ptr_t
operator|)
name|DST_OFFSET
argument_list|(
name|base
argument_list|,
name|dst_user_type_offset
argument_list|(
operator|*
name|type_desc
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|decode_dst_type
argument_list|(
name|objfile
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|type_desc
operator|->
name|std_type
operator|.
name|dtc
condition|)
block|{
case|case
name|dst_int8_type
case|:
name|type
operator|=
name|builtin_type_signed_char
expr_stmt|;
break|break;
case|case
name|dst_int16_type
case|:
name|type
operator|=
name|builtin_type_short
expr_stmt|;
break|break;
case|case
name|dst_int32_type
case|:
name|type
operator|=
name|builtin_type_long
expr_stmt|;
break|break;
case|case
name|dst_uint8_type
case|:
name|type
operator|=
name|builtin_type_unsigned_char
expr_stmt|;
break|break;
case|case
name|dst_uint16_type
case|:
name|type
operator|=
name|builtin_type_unsigned_short
expr_stmt|;
break|break;
case|case
name|dst_uint32_type
case|:
name|type
operator|=
name|builtin_type_unsigned_long
expr_stmt|;
break|break;
case|case
name|dst_real32_type
case|:
name|type
operator|=
name|builtin_type_float
expr_stmt|;
break|break;
case|case
name|dst_real64_type
case|:
name|type
operator|=
name|builtin_type_double
expr_stmt|;
break|break;
case|case
name|dst_complex_type
case|:
name|type
operator|=
name|builtin_type_complex
expr_stmt|;
break|break;
case|case
name|dst_dcomplex_type
case|:
name|type
operator|=
name|builtin_type_double_complex
expr_stmt|;
break|break;
case|case
name|dst_bool8_type
case|:
name|type
operator|=
name|builtin_type_char
expr_stmt|;
break|break;
case|case
name|dst_bool16_type
case|:
name|type
operator|=
name|builtin_type_short
expr_stmt|;
break|break;
case|case
name|dst_bool32_type
case|:
name|type
operator|=
name|builtin_type_long
expr_stmt|;
break|break;
case|case
name|dst_char_type
case|:
name|type
operator|=
name|builtin_type_char
expr_stmt|;
break|break;
comment|/* The next few are more complex. I will take care 	   * of them properly at a later point. 	   */
case|case
name|dst_string_type
case|:
name|type
operator|=
name|builtin_type_void
expr_stmt|;
break|break;
case|case
name|dst_ptr_type
case|:
name|type
operator|=
name|builtin_type_void
expr_stmt|;
break|break;
case|case
name|dst_set_type
case|:
name|type
operator|=
name|builtin_type_void
expr_stmt|;
break|break;
case|case
name|dst_proc_type
case|:
name|type
operator|=
name|builtin_type_void
expr_stmt|;
break|break;
case|case
name|dst_func_type
case|:
name|type
operator|=
name|builtin_type_void
expr_stmt|;
break|break;
comment|/* Back tto some ordinary ones */
case|case
name|dst_void_type
case|:
name|type
operator|=
name|builtin_type_void
expr_stmt|;
break|break;
case|case
name|dst_uchar_type
case|:
name|type
operator|=
name|builtin_type_unsigned_char
expr_stmt|;
break|break;
default|default:
name|type
operator|=
name|builtin_type_void
expr_stmt|;
break|break;
block|}
block|}
return|return
name|type
return|;
block|}
end_function

begin_struct
struct|struct
name|structure_list
block|{
name|struct
name|structure_list
modifier|*
name|next
decl_stmt|;
name|struct
name|type
modifier|*
name|type
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|structure_list
modifier|*
name|struct_list
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|struct
name|type
modifier|*
name|find_dst_structure
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|structure_list
modifier|*
name|element
decl_stmt|;
for|for
control|(
name|element
operator|=
name|struct_list
init|;
name|element
condition|;
name|element
operator|=
name|element
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|TYPE_NAME
argument_list|(
name|element
operator|->
name|type
argument_list|)
argument_list|)
condition|)
return|return
name|element
operator|->
name|type
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|type
modifier|*
name|decode_dst_structure
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|,
name|dst_rec_ptr_t
name|entry
parameter_list|,
name|int
name|code
parameter_list|,
name|int
name|version
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|type
decl_stmt|,
modifier|*
name|child_type
decl_stmt|;
name|char
modifier|*
name|struct_name
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|field_name
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|fieldoffset
decl_stmt|,
name|fieldsize
decl_stmt|;
name|dst_type_t
name|type_desc
decl_stmt|;
name|struct
name|structure_list
modifier|*
name|element
decl_stmt|;
name|struct_name
operator|=
name|DST_OFFSET
argument_list|(
name|entry
argument_list|,
name|DST_record
argument_list|(
name|entry
argument_list|)
operator|.
name|noffset
argument_list|)
expr_stmt|;
name|name
operator|=
name|concat
argument_list|(
operator|(
name|code
operator|==
name|TYPE_CODE_UNION
operator|)
condition|?
literal|"union "
else|:
literal|"struct "
argument_list|,
name|struct_name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|type
operator|=
name|find_dst_structure
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
condition|)
block|{
name|xfree
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
name|type
operator|=
name|create_new_type
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|=
name|obstack_copy0
argument_list|(
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|,
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|code
expr_stmt|;
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
name|DST_record
argument_list|(
name|entry
argument_list|)
operator|.
name|size
expr_stmt|;
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|=
name|DST_record
argument_list|(
name|entry
argument_list|)
operator|.
name|nfields
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
expr|struct
name|field
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
operator|*
name|DST_record
argument_list|(
name|entry
argument_list|)
operator|.
name|nfields
argument_list|)
expr_stmt|;
name|fieldoffset
operator|=
name|fieldsize
operator|=
literal|0
expr_stmt|;
name|INIT_CPLUS_SPECIFIC
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|element
operator|=
operator|(
expr|struct
name|structure_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|structure_list
argument_list|)
argument_list|)
expr_stmt|;
name|element
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|element
operator|->
name|next
operator|=
name|struct_list
expr_stmt|;
name|struct_list
operator|=
name|element
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DST_record
argument_list|(
name|entry
argument_list|)
operator|.
name|nfields
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|version
condition|)
block|{
case|case
literal|2
case|:
name|field_name
operator|=
name|DST_OFFSET
argument_list|(
name|entry
argument_list|,
name|DST_record
argument_list|(
name|entry
argument_list|)
operator|.
name|f
operator|.
name|ofields
index|[
name|i
index|]
operator|.
name|noffset
argument_list|)
expr_stmt|;
name|fieldoffset
operator|=
name|DST_record
argument_list|(
name|entry
argument_list|)
operator|.
name|f
operator|.
name|ofields
index|[
name|i
index|]
operator|.
name|foffset
operator|*
literal|8
operator|+
name|DST_record
argument_list|(
name|entry
argument_list|)
operator|.
name|f
operator|.
name|ofields
index|[
name|i
index|]
operator|.
name|bit_offset
expr_stmt|;
name|fieldsize
operator|=
name|DST_record
argument_list|(
name|entry
argument_list|)
operator|.
name|f
operator|.
name|ofields
index|[
name|i
index|]
operator|.
name|size
expr_stmt|;
name|type_desc
operator|=
name|DST_record
argument_list|(
name|entry
argument_list|)
operator|.
name|f
operator|.
name|ofields
index|[
name|i
index|]
operator|.
name|type_desc
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|field_name
operator|=
name|DST_OFFSET
argument_list|(
name|entry
argument_list|,
name|DST_record
argument_list|(
name|entry
argument_list|)
operator|.
name|f
operator|.
name|fields
index|[
name|i
index|]
operator|.
name|noffset
argument_list|)
expr_stmt|;
name|type_desc
operator|=
name|DST_record
argument_list|(
name|entry
argument_list|)
operator|.
name|f
operator|.
name|fields
index|[
name|i
index|]
operator|.
name|type_desc
expr_stmt|;
switch|switch
condition|(
name|DST_record
argument_list|(
name|entry
argument_list|)
operator|.
name|f
operator|.
name|fields
index|[
name|i
index|]
operator|.
name|f
operator|.
name|field_loc
operator|.
name|format_tag
condition|)
block|{
case|case
name|dst_field_byte
case|:
name|fieldoffset
operator|=
name|DST_record
argument_list|(
name|entry
argument_list|)
operator|.
name|f
operator|.
name|fields
index|[
name|i
index|]
operator|.
name|f
operator|.
name|field_byte
operator|.
name|offset
operator|*
literal|8
expr_stmt|;
name|fieldsize
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|dst_field_bit
case|:
name|fieldoffset
operator|=
name|DST_record
argument_list|(
name|entry
argument_list|)
operator|.
name|f
operator|.
name|fields
index|[
name|i
index|]
operator|.
name|f
operator|.
name|field_bit
operator|.
name|byte_offset
operator|*
literal|8
operator|+
name|DST_record
argument_list|(
name|entry
argument_list|)
operator|.
name|f
operator|.
name|fields
index|[
name|i
index|]
operator|.
name|f
operator|.
name|field_bit
operator|.
name|bit_offset
expr_stmt|;
name|fieldsize
operator|=
name|DST_record
argument_list|(
name|entry
argument_list|)
operator|.
name|f
operator|.
name|fields
index|[
name|i
index|]
operator|.
name|f
operator|.
name|field_bit
operator|.
name|nbits
expr_stmt|;
break|break;
case|case
name|dst_field_loc
case|:
name|fieldoffset
operator|+=
name|fieldsize
expr_stmt|;
name|fieldsize
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|0
case|:
name|field_name
operator|=
name|DST_OFFSET
argument_list|(
name|entry
argument_list|,
name|DST_record
argument_list|(
name|entry
argument_list|)
operator|.
name|f
operator|.
name|sfields
index|[
name|i
index|]
operator|.
name|noffset
argument_list|)
expr_stmt|;
name|fieldoffset
operator|=
name|DST_record
argument_list|(
name|entry
argument_list|)
operator|.
name|f
operator|.
name|sfields
index|[
name|i
index|]
operator|.
name|foffset
expr_stmt|;
name|type_desc
operator|=
name|DST_record
argument_list|(
name|entry
argument_list|)
operator|.
name|f
operator|.
name|sfields
index|[
name|i
index|]
operator|.
name|type_desc
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|DST_record
argument_list|(
name|entry
argument_list|)
operator|.
name|nfields
operator|-
literal|1
condition|)
name|fieldsize
operator|=
name|DST_record
argument_list|(
name|entry
argument_list|)
operator|.
name|f
operator|.
name|sfields
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|foffset
expr_stmt|;
else|else
name|fieldsize
operator|=
name|DST_record
argument_list|(
name|entry
argument_list|)
operator|.
name|size
expr_stmt|;
name|fieldsize
operator|-=
name|fieldoffset
expr_stmt|;
name|fieldoffset
operator|*=
literal|8
expr_stmt|;
name|fieldsize
operator|*=
literal|8
expr_stmt|;
block|}
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
index|[
name|i
index|]
operator|.
name|name
operator|=
name|obstack_copy0
argument_list|(
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|,
name|field_name
argument_list|,
name|strlen
argument_list|(
name|field_name
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
index|[
name|i
index|]
operator|.
name|type
operator|=
name|decode_type_desc
argument_list|(
name|objfile
argument_list|,
operator|&
name|type_desc
argument_list|,
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|fieldsize
operator|==
operator|-
literal|1
condition|)
name|fieldsize
operator|=
name|TYPE_LENGTH
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
index|[
name|i
index|]
operator|.
name|type
argument_list|)
operator|*
literal|8
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
index|[
name|i
index|]
operator|.
name|bitsize
operator|=
name|fieldsize
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
index|[
name|i
index|]
operator|.
name|bitpos
operator|=
name|fieldoffset
expr_stmt|;
block|}
return|return
name|type
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|type
modifier|*
name|decode_dst_type
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|,
name|dst_rec_ptr_t
name|entry
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|child_type
decl_stmt|,
modifier|*
name|type
decl_stmt|,
modifier|*
name|range_type
decl_stmt|,
modifier|*
name|index_type
decl_stmt|;
switch|switch
condition|(
name|entry
operator|->
name|rec_type
condition|)
block|{
case|case
name|dst_typ_var
case|:
return|return
name|decode_type_desc
argument_list|(
name|objfile
argument_list|,
operator|&
name|DST_var
argument_list|(
name|entry
argument_list|)
operator|.
name|type_desc
argument_list|,
name|entry
argument_list|)
return|;
break|break;
case|case
name|dst_typ_variable
case|:
return|return
name|decode_type_desc
argument_list|(
name|objfile
argument_list|,
operator|&
name|DST_variable
argument_list|(
name|entry
argument_list|)
operator|.
name|type_desc
argument_list|,
name|entry
argument_list|)
return|;
break|break;
case|case
name|dst_typ_short_rec
case|:
return|return
name|decode_dst_structure
argument_list|(
name|objfile
argument_list|,
name|entry
argument_list|,
name|TYPE_CODE_STRUCT
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|dst_typ_short_union
case|:
return|return
name|decode_dst_structure
argument_list|(
name|objfile
argument_list|,
name|entry
argument_list|,
name|TYPE_CODE_UNION
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|dst_typ_union
case|:
return|return
name|decode_dst_structure
argument_list|(
name|objfile
argument_list|,
name|entry
argument_list|,
name|TYPE_CODE_UNION
argument_list|,
literal|1
argument_list|)
return|;
case|case
name|dst_typ_record
case|:
return|return
name|decode_dst_structure
argument_list|(
name|objfile
argument_list|,
name|entry
argument_list|,
name|TYPE_CODE_STRUCT
argument_list|,
literal|1
argument_list|)
return|;
case|case
name|dst_typ_old_union
case|:
return|return
name|decode_dst_structure
argument_list|(
name|objfile
argument_list|,
name|entry
argument_list|,
name|TYPE_CODE_UNION
argument_list|,
literal|2
argument_list|)
return|;
case|case
name|dst_typ_old_record
case|:
return|return
name|decode_dst_structure
argument_list|(
name|objfile
argument_list|,
name|entry
argument_list|,
name|TYPE_CODE_STRUCT
argument_list|,
literal|2
argument_list|)
return|;
case|case
name|dst_typ_pointer
case|:
return|return
name|make_pointer_type
argument_list|(
name|decode_type_desc
argument_list|(
name|objfile
argument_list|,
operator|&
name|DST_pointer
argument_list|(
name|entry
argument_list|)
operator|.
name|type_desc
argument_list|,
name|entry
argument_list|)
argument_list|,
name|NULL
argument_list|)
return|;
case|case
name|dst_typ_array
case|:
name|child_type
operator|=
name|decode_type_desc
argument_list|(
name|objfile
argument_list|,
operator|&
name|DST_pointer
argument_list|(
name|entry
argument_list|)
operator|.
name|type_desc
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|index_type
operator|=
name|lookup_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_INTEGER
argument_list|)
expr_stmt|;
name|range_type
operator|=
name|create_range_type
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|)
name|NULL
argument_list|,
name|index_type
argument_list|,
name|DST_array
argument_list|(
name|entry
argument_list|)
operator|.
name|lo_bound
argument_list|,
name|DST_array
argument_list|(
name|entry
argument_list|)
operator|.
name|hi_bound
argument_list|)
expr_stmt|;
return|return
name|create_array_type
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|)
name|NULL
argument_list|,
name|child_type
argument_list|,
name|range_type
argument_list|)
return|;
case|case
name|dst_typ_alias
case|:
return|return
name|decode_type_desc
argument_list|(
name|objfile
argument_list|,
operator|&
name|DST_alias
argument_list|(
name|entry
argument_list|)
operator|.
name|type_desc
argument_list|,
name|entry
argument_list|)
return|;
default|default:
return|return
name|builtin_type_int
return|;
block|}
block|}
end_function

begin_struct
struct|struct
name|symbol_list
block|{
name|struct
name|symbol_list
modifier|*
name|next
decl_stmt|;
name|struct
name|symbol
modifier|*
name|symbol
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|symbol_list
modifier|*
name|dst_global_symbols
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|total_globals
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|decode_dst_locstring
parameter_list|(
name|char
modifier|*
name|locstr
parameter_list|,
name|struct
name|symbol
modifier|*
name|sym
parameter_list|)
block|{
name|dst_loc_entry_t
modifier|*
name|entry
decl_stmt|,
modifier|*
name|next_entry
decl_stmt|;
name|CORE_ADDR
name|temp
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|count
operator|++
operator|==
literal|100
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Error reading locstring\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|entry
operator|=
operator|(
name|dst_loc_entry_t
operator|*
operator|)
name|locstr
expr_stmt|;
name|next_entry
operator|=
operator|(
name|dst_loc_entry_t
operator|*
operator|)
operator|(
name|locstr
operator|+
literal|1
operator|)
expr_stmt|;
switch|switch
condition|(
name|entry
operator|->
name|header
operator|.
name|code
condition|)
block|{
case|case
name|dst_lsc_end
case|:
comment|/* End of string */
return|return;
case|case
name|dst_lsc_indirect
case|:
comment|/* Indirect through previous. Arg == 6 */
comment|/* Or register ax x == arg */
if|if
condition|(
name|entry
operator|->
name|header
operator|.
name|arg
operator|<
literal|6
condition|)
block|{
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_REGISTER
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|entry
operator|->
name|header
operator|.
name|arg
operator|+
literal|8
expr_stmt|;
block|}
comment|/* We predict indirects */
name|locstr
operator|++
expr_stmt|;
break|break;
case|case
name|dst_lsc_dreg
case|:
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_REGISTER
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|entry
operator|->
name|header
operator|.
name|arg
expr_stmt|;
name|locstr
operator|++
expr_stmt|;
break|break;
case|case
name|dst_lsc_section
case|:
comment|/* Section (arg+1) */
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|dst_get_addr
argument_list|(
name|entry
operator|->
name|header
operator|.
name|arg
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|locstr
operator|++
expr_stmt|;
break|break;
case|case
name|dst_lsc_sec_byte
case|:
comment|/* Section (next_byte+1) */
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|dst_get_addr
argument_list|(
name|locstr
index|[
literal|1
index|]
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|locstr
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|dst_lsc_add
case|:
comment|/* Add (arg+1)*2 */
case|case
name|dst_lsc_sub
case|:
comment|/* Subtract (arg+1)*2 */
name|temp
operator|=
operator|(
name|entry
operator|->
name|header
operator|.
name|arg
operator|+
literal|1
operator|)
operator|*
literal|2
expr_stmt|;
name|locstr
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|locstr
operator|==
name|dst_multiply_256
condition|)
block|{
name|temp
operator|<<=
literal|8
expr_stmt|;
name|locstr
operator|++
expr_stmt|;
block|}
switch|switch
condition|(
name|entry
operator|->
name|header
operator|.
name|code
condition|)
block|{
case|case
name|dst_lsc_add
case|:
if|if
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_LOCAL
condition|)
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_ARG
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|+=
name|temp
expr_stmt|;
break|break;
case|case
name|dst_lsc_sub
case|:
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|-=
name|temp
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|dst_lsc_add_byte
case|:
case|case
name|dst_lsc_sub_byte
case|:
switch|switch
condition|(
name|entry
operator|->
name|header
operator|.
name|arg
operator|&
literal|0x03
condition|)
block|{
case|case
literal|1
case|:
name|temp
operator|=
operator|(
name|unsigned
name|char
operator|)
name|locstr
index|[
literal|1
index|]
expr_stmt|;
name|locstr
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|temp
operator|=
operator|*
operator|(
name|unsigned
name|short
operator|*
operator|)
operator|(
name|locstr
operator|+
literal|1
operator|)
expr_stmt|;
name|locstr
operator|+=
literal|3
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|temp
operator|=
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
operator|(
name|locstr
operator|+
literal|1
operator|)
expr_stmt|;
name|locstr
operator|+=
literal|5
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
name|locstr
operator|==
name|dst_multiply_256
condition|)
block|{
name|temp
operator|<<=
literal|8
expr_stmt|;
name|locstr
operator|++
expr_stmt|;
block|}
switch|switch
condition|(
name|entry
operator|->
name|header
operator|.
name|code
condition|)
block|{
case|case
name|dst_lsc_add_byte
case|:
if|if
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_LOCAL
condition|)
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_ARG
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|+=
name|temp
expr_stmt|;
break|break;
case|case
name|dst_lsc_sub_byte
case|:
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|-=
name|temp
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|dst_lsc_sbreg
case|:
comment|/* Stack base register (frame pointer). Arg==0 */
if|if
condition|(
name|next_entry
operator|->
name|header
operator|.
name|code
operator|!=
name|dst_lsc_indirect
condition|)
block|{
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_STATIC
expr_stmt|;
return|return;
block|}
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_LOCAL
expr_stmt|;
name|locstr
operator|++
expr_stmt|;
break|break;
default|default:
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_STATIC
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|symbol_list
modifier|*
name|process_dst_symbols
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|,
name|dst_rec_ptr_t
name|entry
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
modifier|*
name|nsyms_ret
parameter_list|)
block|{
name|struct
name|symbol_list
modifier|*
name|list
init|=
name|NULL
decl_stmt|,
modifier|*
name|element
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|char
modifier|*
name|symname
decl_stmt|;
name|int
name|nsyms
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|location
decl_stmt|;
name|long
name|line
decl_stmt|;
name|dst_type_t
name|symtype
decl_stmt|;
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|dst_var_attr_t
name|attr
decl_stmt|;
name|dst_var_loc_t
name|loc_type
decl_stmt|;
name|unsigned
name|loc_index
decl_stmt|;
name|long
name|loc_value
decl_stmt|;
if|if
condition|(
operator|!
name|entry
condition|)
block|{
operator|*
name|nsyms_ret
operator|=
literal|0
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|location
operator|=
operator|(
name|char
operator|*
operator|)
name|entry
expr_stmt|;
while|while
condition|(
name|NEXT_SYM
argument_list|(
operator|&
name|location
argument_list|,
operator|&
name|entry
argument_list|)
operator|&&
name|entry
operator|->
name|rec_type
operator|!=
name|dst_typ_end_scope
condition|)
block|{
if|if
condition|(
name|entry
operator|->
name|rec_type
operator|==
name|dst_typ_var
condition|)
block|{
if|if
condition|(
name|DST_var
argument_list|(
name|entry
argument_list|)
operator|.
name|short_locs
condition|)
block|{
name|loc_type
operator|=
name|DST_var
argument_list|(
name|entry
argument_list|)
operator|.
name|locs
operator|.
name|shorts
index|[
literal|0
index|]
operator|.
name|loc_type
expr_stmt|;
name|loc_index
operator|=
name|DST_var
argument_list|(
name|entry
argument_list|)
operator|.
name|locs
operator|.
name|shorts
index|[
literal|0
index|]
operator|.
name|loc_index
expr_stmt|;
name|loc_value
operator|=
name|DST_var
argument_list|(
name|entry
argument_list|)
operator|.
name|locs
operator|.
name|shorts
index|[
literal|0
index|]
operator|.
name|location
expr_stmt|;
block|}
else|else
block|{
name|loc_type
operator|=
name|DST_var
argument_list|(
name|entry
argument_list|)
operator|.
name|locs
operator|.
name|longs
index|[
literal|0
index|]
operator|.
name|loc_type
expr_stmt|;
name|loc_index
operator|=
name|DST_var
argument_list|(
name|entry
argument_list|)
operator|.
name|locs
operator|.
name|longs
index|[
literal|0
index|]
operator|.
name|loc_index
expr_stmt|;
name|loc_value
operator|=
name|DST_var
argument_list|(
name|entry
argument_list|)
operator|.
name|locs
operator|.
name|longs
index|[
literal|0
index|]
operator|.
name|location
expr_stmt|;
block|}
if|if
condition|(
name|loc_type
operator|==
name|dst_var_loc_external
condition|)
continue|continue;
name|symname
operator|=
name|DST_OFFSET
argument_list|(
name|entry
argument_list|,
name|DST_var
argument_list|(
name|entry
argument_list|)
operator|.
name|noffset
argument_list|)
expr_stmt|;
name|line
operator|=
name|DST_var
argument_list|(
name|entry
argument_list|)
operator|.
name|src_loc
operator|.
name|line_number
expr_stmt|;
name|symtype
operator|=
name|DST_var
argument_list|(
name|entry
argument_list|)
operator|.
name|type_desc
expr_stmt|;
name|attr
operator|=
name|DST_var
argument_list|(
name|entry
argument_list|)
operator|.
name|attributes
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|entry
operator|->
name|rec_type
operator|==
name|dst_typ_variable
condition|)
block|{
name|symname
operator|=
name|DST_OFFSET
argument_list|(
name|entry
argument_list|,
name|DST_variable
argument_list|(
name|entry
argument_list|)
operator|.
name|noffset
argument_list|)
expr_stmt|;
name|line
operator|=
name|DST_variable
argument_list|(
name|entry
argument_list|)
operator|.
name|src_loc
operator|.
name|line_number
expr_stmt|;
name|symtype
operator|=
name|DST_variable
argument_list|(
name|entry
argument_list|)
operator|.
name|type_desc
expr_stmt|;
name|attr
operator|=
name|DST_variable
argument_list|(
name|entry
argument_list|)
operator|.
name|attributes
expr_stmt|;
block|}
else|else
block|{
continue|continue;
block|}
if|if
condition|(
name|symname
operator|&&
name|name
operator|&&
operator|!
name|strcmp
argument_list|(
name|symname
argument_list|,
name|name
argument_list|)
condition|)
comment|/* It's the function return value */
continue|continue;
name|sym
operator|=
name|create_new_symbol
argument_list|(
name|objfile
argument_list|,
name|symname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|attr
operator|&
operator|(
literal|1
operator|<<
name|dst_var_attr_global
operator|)
operator|)
operator|||
operator|(
name|attr
operator|&
operator|(
literal|1
operator|<<
name|dst_var_attr_static
operator|)
operator|)
condition|)
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_STATIC
expr_stmt|;
else|else
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_LOCAL
expr_stmt|;
name|SYMBOL_LINE
argument_list|(
name|sym
argument_list|)
operator|=
name|line
expr_stmt|;
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|decode_type_desc
argument_list|(
name|objfile
argument_list|,
operator|&
name|symtype
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|entry
operator|->
name|rec_type
condition|)
block|{
case|case
name|dst_typ_var
case|:
switch|switch
condition|(
name|loc_type
condition|)
block|{
case|case
name|dst_var_loc_abs
case|:
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym
argument_list|)
operator|=
name|loc_value
expr_stmt|;
break|break;
case|case
name|dst_var_loc_sect_off
case|:
case|case
name|dst_var_loc_ind_sect_off
case|:
comment|/* What is this? */
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym
argument_list|)
operator|=
name|dst_get_addr
argument_list|(
name|loc_index
argument_list|,
name|loc_value
argument_list|)
expr_stmt|;
break|break;
case|case
name|dst_var_loc_ind_reg_rel
case|:
comment|/* What is this? */
case|case
name|dst_var_loc_reg_rel
case|:
comment|/* If it isn't fp relative, specify the 	       * register it's relative to. 	       */
if|if
condition|(
name|loc_index
condition|)
block|{
name|sym
operator|->
name|aux_value
operator|.
name|basereg
operator|=
name|loc_index
expr_stmt|;
block|}
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|loc_value
expr_stmt|;
if|if
condition|(
name|loc_value
operator|>
literal|0
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_BASEREG
condition|)
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_BASEREG_ARG
expr_stmt|;
break|break;
case|case
name|dst_var_loc_reg
case|:
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|loc_index
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_REGISTER
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|dst_typ_variable
case|:
comment|/* External variable..... don't try to interpret 	   * its nonexistant locstring. 	   */
if|if
condition|(
name|DST_variable
argument_list|(
name|entry
argument_list|)
operator|.
name|loffset
operator|==
operator|-
literal|1
condition|)
continue|continue;
name|decode_dst_locstring
argument_list|(
name|DST_OFFSET
argument_list|(
name|entry
argument_list|,
name|DST_variable
argument_list|(
name|entry
argument_list|)
operator|.
name|loffset
argument_list|)
argument_list|,
name|sym
argument_list|)
expr_stmt|;
block|}
name|element
operator|=
operator|(
expr|struct
name|symbol_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|symbol_list
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
operator|&
operator|(
literal|1
operator|<<
name|dst_var_attr_global
operator|)
condition|)
block|{
name|element
operator|->
name|next
operator|=
name|dst_global_symbols
expr_stmt|;
name|dst_global_symbols
operator|=
name|element
expr_stmt|;
name|total_globals
operator|++
expr_stmt|;
block|}
else|else
block|{
name|element
operator|->
name|next
operator|=
name|list
expr_stmt|;
name|list
operator|=
name|element
expr_stmt|;
name|nsyms
operator|++
expr_stmt|;
block|}
name|element
operator|->
name|symbol
operator|=
name|sym
expr_stmt|;
block|}
operator|*
name|nsyms_ret
operator|=
name|nsyms
expr_stmt|;
return|return
name|list
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|symbol
modifier|*
name|process_dst_function
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|,
name|dst_rec_ptr_t
name|entry
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|CORE_ADDR
name|address
parameter_list|)
block|{
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|struct
name|type
modifier|*
name|type
decl_stmt|,
modifier|*
name|ftype
decl_stmt|;
name|dst_rec_ptr_t
name|sym_entry
decl_stmt|,
name|typ_entry
decl_stmt|;
name|char
modifier|*
name|location
decl_stmt|;
name|struct
name|symbol_list
modifier|*
name|element
decl_stmt|;
name|type
operator|=
name|builtin_type_int
expr_stmt|;
name|sym
operator|=
name|create_new_symbol
argument_list|(
name|objfile
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_BLOCK
expr_stmt|;
if|if
condition|(
name|entry
condition|)
block|{
name|location
operator|=
operator|(
name|char
operator|*
operator|)
name|entry
expr_stmt|;
do|do
block|{
name|NEXT_SYM
argument_list|(
operator|&
name|location
argument_list|,
operator|&
name|sym_entry
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|sym_entry
operator|&&
name|sym_entry
operator|->
name|rec_type
operator|!=
name|dst_typ_signature
condition|)
do|;
if|if
condition|(
name|sym_entry
condition|)
block|{
name|SYMBOL_LINE
argument_list|(
name|sym
argument_list|)
operator|=
name|DST_signature
argument_list|(
name|sym_entry
argument_list|)
operator|.
name|src_loc
operator|.
name|line_number
expr_stmt|;
if|if
condition|(
name|DST_signature
argument_list|(
name|sym_entry
argument_list|)
operator|.
name|result
condition|)
block|{
name|typ_entry
operator|=
operator|(
name|dst_rec_ptr_t
operator|)
name|DST_OFFSET
argument_list|(
name|sym_entry
argument_list|,
name|DST_signature
argument_list|(
name|sym_entry
argument_list|)
operator|.
name|result
argument_list|)
expr_stmt|;
name|type
operator|=
name|decode_dst_type
argument_list|(
name|objfile
argument_list|,
name|typ_entry
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|type
operator|->
name|function_type
condition|)
block|{
name|ftype
operator|=
name|create_new_type
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
name|type
operator|->
name|function_type
operator|=
name|ftype
expr_stmt|;
name|ftype
operator|->
name|target_type
operator|=
name|type
expr_stmt|;
name|ftype
operator|->
name|code
operator|=
name|TYPE_CODE_FUNC
expr_stmt|;
block|}
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|type
operator|->
name|function_type
expr_stmt|;
comment|/* Now add ourselves to the global symbols list */
name|element
operator|=
operator|(
expr|struct
name|symbol_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|symbol_list
argument_list|)
argument_list|)
expr_stmt|;
name|element
operator|->
name|next
operator|=
name|dst_global_symbols
expr_stmt|;
name|dst_global_symbols
operator|=
name|element
expr_stmt|;
name|total_globals
operator|++
expr_stmt|;
name|element
operator|->
name|symbol
operator|=
name|sym
expr_stmt|;
return|return
name|sym
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|block
modifier|*
name|process_dst_block
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|,
name|dst_rec_ptr_t
name|entry
parameter_list|)
block|{
name|struct
name|block
modifier|*
name|block
decl_stmt|;
name|struct
name|symbol
modifier|*
name|function
init|=
name|NULL
decl_stmt|;
name|CORE_ADDR
name|address
decl_stmt|;
name|long
name|size
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|dst_rec_ptr_t
name|child_entry
decl_stmt|,
name|symbol_entry
decl_stmt|;
name|struct
name|block
modifier|*
name|child_block
decl_stmt|;
name|int
name|total_symbols
init|=
literal|0
decl_stmt|;
name|char
name|fake_name
index|[
literal|20
index|]
decl_stmt|;
specifier|static
name|long
name|fake_seq
init|=
literal|0
decl_stmt|;
name|struct
name|symbol_list
modifier|*
name|symlist
decl_stmt|,
modifier|*
name|nextsym
decl_stmt|;
name|int
name|symnum
decl_stmt|;
if|if
condition|(
name|DST_block
argument_list|(
name|entry
argument_list|)
operator|.
name|noffset
condition|)
name|name
operator|=
name|DST_OFFSET
argument_list|(
name|entry
argument_list|,
name|DST_block
argument_list|(
name|entry
argument_list|)
operator|.
name|noffset
argument_list|)
expr_stmt|;
else|else
name|name
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|DST_block
argument_list|(
name|entry
argument_list|)
operator|.
name|n_of_code_ranges
condition|)
block|{
name|address
operator|=
name|dst_sym_addr
argument_list|(
operator|&
name|DST_block
argument_list|(
name|entry
argument_list|)
operator|.
name|code_ranges
index|[
literal|0
index|]
operator|.
name|code_start
argument_list|)
expr_stmt|;
name|size
operator|=
name|DST_block
argument_list|(
name|entry
argument_list|)
operator|.
name|code_ranges
index|[
literal|0
index|]
operator|.
name|code_size
expr_stmt|;
block|}
else|else
block|{
name|address
operator|=
operator|-
literal|1
expr_stmt|;
name|size
operator|=
literal|0
expr_stmt|;
block|}
name|symbol_entry
operator|=
operator|(
name|dst_rec_ptr_t
operator|)
name|get_sec_ref
argument_list|(
operator|&
name|DST_block
argument_list|(
name|entry
argument_list|)
operator|.
name|symbols_start
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|DST_block
argument_list|(
name|entry
argument_list|)
operator|.
name|block_type
condition|)
block|{
comment|/* These are all really functions. Even the "program" type.        * This is because the Apollo OS was written in Pascal, and        * in Pascal, the main procedure is described as the Program.        * Cute, huh?        */
case|case
name|dst_block_procedure
case|:
case|case
name|dst_block_function
case|:
case|case
name|dst_block_subroutine
case|:
case|case
name|dst_block_program
case|:
name|prim_record_minimal_symbol
argument_list|(
name|name
argument_list|,
name|address
argument_list|,
name|mst_text
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|function
operator|=
name|process_dst_function
argument_list|(
name|objfile
argument_list|,
name|symbol_entry
argument_list|,
name|name
argument_list|,
name|address
argument_list|)
expr_stmt|;
name|enter_all_lines
argument_list|(
name|get_sec_ref
argument_list|(
operator|&
name|DST_block
argument_list|(
name|entry
argument_list|)
operator|.
name|code_ranges
index|[
literal|0
index|]
operator|.
name|lines_start
argument_list|)
argument_list|,
name|address
argument_list|)
expr_stmt|;
break|break;
case|case
name|dst_block_block_data
case|:
break|break;
default|default:
comment|/* GDB has to call it something, and the module name        * won't cut it        */
name|sprintf
argument_list|(
name|fake_name
argument_list|,
literal|"block_%08lx"
argument_list|,
name|fake_seq
operator|++
argument_list|)
expr_stmt|;
name|function
operator|=
name|process_dst_function
argument_list|(
name|objfile
argument_list|,
name|NULL
argument_list|,
name|fake_name
argument_list|,
name|address
argument_list|)
expr_stmt|;
break|break;
block|}
name|symlist
operator|=
name|process_dst_symbols
argument_list|(
name|objfile
argument_list|,
name|symbol_entry
argument_list|,
name|name
argument_list|,
operator|&
name|total_symbols
argument_list|)
expr_stmt|;
name|block
operator|=
operator|(
expr|struct
name|block
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|block
argument_list|)
operator|+
operator|(
name|total_symbols
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|symnum
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|symlist
condition|)
block|{
name|nextsym
operator|=
name|symlist
operator|->
name|next
expr_stmt|;
name|block
operator|->
name|sym
index|[
name|symnum
index|]
operator|=
name|symlist
operator|->
name|symbol
expr_stmt|;
name|xfree
argument_list|(
name|symlist
argument_list|)
expr_stmt|;
name|symlist
operator|=
name|nextsym
expr_stmt|;
name|symnum
operator|++
expr_stmt|;
block|}
name|BLOCK_NSYMS
argument_list|(
name|block
argument_list|)
operator|=
name|total_symbols
expr_stmt|;
name|BLOCK_START
argument_list|(
name|block
argument_list|)
operator|=
name|address
expr_stmt|;
name|BLOCK_END
argument_list|(
name|block
argument_list|)
operator|=
name|address
operator|+
name|size
expr_stmt|;
name|BLOCK_SUPERBLOCK
argument_list|(
name|block
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|function
condition|)
block|{
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|function
argument_list|)
operator|=
name|block
expr_stmt|;
name|BLOCK_FUNCTION
argument_list|(
name|block
argument_list|)
operator|=
name|function
expr_stmt|;
block|}
else|else
name|BLOCK_FUNCTION
argument_list|(
name|block
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|DST_block
argument_list|(
name|entry
argument_list|)
operator|.
name|child_block_off
condition|)
block|{
name|child_entry
operator|=
operator|(
name|dst_rec_ptr_t
operator|)
name|DST_OFFSET
argument_list|(
name|entry
argument_list|,
name|DST_block
argument_list|(
name|entry
argument_list|)
operator|.
name|child_block_off
argument_list|)
expr_stmt|;
while|while
condition|(
name|child_entry
condition|)
block|{
name|child_block
operator|=
name|process_dst_block
argument_list|(
name|objfile
argument_list|,
name|child_entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|child_block
condition|)
block|{
if|if
condition|(
name|BLOCK_START
argument_list|(
name|child_block
argument_list|)
operator|<
name|BLOCK_START
argument_list|(
name|block
argument_list|)
operator|||
name|BLOCK_START
argument_list|(
name|block
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|BLOCK_START
argument_list|(
name|block
argument_list|)
operator|=
name|BLOCK_START
argument_list|(
name|child_block
argument_list|)
expr_stmt|;
if|if
condition|(
name|BLOCK_END
argument_list|(
name|child_block
argument_list|)
operator|>
name|BLOCK_END
argument_list|(
name|block
argument_list|)
operator|||
name|BLOCK_END
argument_list|(
name|block
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|BLOCK_END
argument_list|(
name|block
argument_list|)
operator|=
name|BLOCK_END
argument_list|(
name|child_block
argument_list|)
expr_stmt|;
name|BLOCK_SUPERBLOCK
argument_list|(
name|child_block
argument_list|)
operator|=
name|block
expr_stmt|;
block|}
if|if
condition|(
name|DST_block
argument_list|(
name|child_entry
argument_list|)
operator|.
name|sibling_block_off
condition|)
name|child_entry
operator|=
operator|(
name|dst_rec_ptr_t
operator|)
name|DST_OFFSET
argument_list|(
name|child_entry
argument_list|,
name|DST_block
argument_list|(
name|child_entry
argument_list|)
operator|.
name|sibling_block_off
argument_list|)
expr_stmt|;
else|else
name|child_entry
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|record_pending_block
argument_list|(
name|objfile
argument_list|,
name|block
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|block
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|read_dst_symtab
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|char
modifier|*
name|buffer
decl_stmt|;
name|dst_rec_ptr_t
name|entry
decl_stmt|,
name|file_table
decl_stmt|,
name|root_block
decl_stmt|;
name|char
modifier|*
name|source_file
decl_stmt|;
name|struct
name|block
modifier|*
name|block
decl_stmt|,
modifier|*
name|global_block
decl_stmt|;
name|int
name|symnum
decl_stmt|;
name|struct
name|symbol_list
modifier|*
name|nextsym
decl_stmt|;
name|int
name|module_num
init|=
literal|0
decl_stmt|;
name|struct
name|structure_list
modifier|*
name|element
decl_stmt|;
name|current_objfile
operator|=
name|objfile
expr_stmt|;
name|buffer
operator|=
name|blocks_info
operator|.
name|buffer
expr_stmt|;
while|while
condition|(
name|NEXT_BLK
argument_list|(
operator|&
name|buffer
argument_list|,
operator|&
name|entry
argument_list|)
condition|)
block|{
if|if
condition|(
name|entry
operator|->
name|rec_type
operator|==
name|dst_typ_comp_unit
condition|)
block|{
name|file_table
operator|=
operator|(
name|dst_rec_ptr_t
operator|)
name|DST_OFFSET
argument_list|(
name|entry
argument_list|,
name|DST_comp_unit
argument_list|(
name|entry
argument_list|)
operator|.
name|file_table
argument_list|)
expr_stmt|;
name|section_table
operator|=
operator|(
name|dst_rec_ptr_t
operator|)
name|DST_OFFSET
argument_list|(
name|entry
argument_list|,
name|DST_comp_unit
argument_list|(
name|entry
argument_list|)
operator|.
name|section_table
argument_list|)
expr_stmt|;
name|root_block
operator|=
operator|(
name|dst_rec_ptr_t
operator|)
name|DST_OFFSET
argument_list|(
name|entry
argument_list|,
name|DST_comp_unit
argument_list|(
name|entry
argument_list|)
operator|.
name|root_block_offset
argument_list|)
expr_stmt|;
name|source_file
operator|=
name|DST_OFFSET
argument_list|(
name|file_table
argument_list|,
name|DST_file_tab
argument_list|(
name|file_table
argument_list|)
operator|.
name|files
index|[
literal|0
index|]
operator|.
name|noffset
argument_list|)
expr_stmt|;
comment|/* Point buffer to the start of the next comp_unit */
name|buffer
operator|=
name|DST_OFFSET
argument_list|(
name|entry
argument_list|,
name|DST_comp_unit
argument_list|(
name|entry
argument_list|)
operator|.
name|data_size
argument_list|)
expr_stmt|;
name|dst_start_symtab
argument_list|()
expr_stmt|;
name|block
operator|=
name|process_dst_block
argument_list|(
name|objfile
argument_list|,
name|root_block
argument_list|)
expr_stmt|;
name|global_block
operator|=
operator|(
expr|struct
name|block
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|block
argument_list|)
operator|+
operator|(
name|total_globals
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|BLOCK_NSYMS
argument_list|(
name|global_block
argument_list|)
operator|=
name|total_globals
expr_stmt|;
for|for
control|(
name|symnum
operator|=
literal|0
init|;
name|symnum
operator|<
name|total_globals
condition|;
name|symnum
operator|++
control|)
block|{
name|nextsym
operator|=
name|dst_global_symbols
operator|->
name|next
expr_stmt|;
name|global_block
operator|->
name|sym
index|[
name|symnum
index|]
operator|=
name|dst_global_symbols
operator|->
name|symbol
expr_stmt|;
name|xfree
argument_list|(
name|dst_global_symbols
argument_list|)
expr_stmt|;
name|dst_global_symbols
operator|=
name|nextsym
expr_stmt|;
block|}
name|dst_global_symbols
operator|=
name|NULL
expr_stmt|;
name|total_globals
operator|=
literal|0
expr_stmt|;
name|BLOCK_FUNCTION
argument_list|(
name|global_block
argument_list|)
operator|=
literal|0
expr_stmt|;
name|BLOCK_START
argument_list|(
name|global_block
argument_list|)
operator|=
name|BLOCK_START
argument_list|(
name|block
argument_list|)
expr_stmt|;
name|BLOCK_END
argument_list|(
name|global_block
argument_list|)
operator|=
name|BLOCK_END
argument_list|(
name|block
argument_list|)
expr_stmt|;
name|BLOCK_SUPERBLOCK
argument_list|(
name|global_block
argument_list|)
operator|=
literal|0
expr_stmt|;
name|BLOCK_SUPERBLOCK
argument_list|(
name|block
argument_list|)
operator|=
name|global_block
expr_stmt|;
name|record_pending_block
argument_list|(
name|objfile
argument_list|,
name|global_block
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|complete_symtab
argument_list|(
name|source_file
argument_list|,
name|BLOCK_START
argument_list|(
name|block
argument_list|)
argument_list|,
name|BLOCK_END
argument_list|(
name|block
argument_list|)
operator|-
name|BLOCK_START
argument_list|(
name|block
argument_list|)
argument_list|)
expr_stmt|;
name|module_num
operator|++
expr_stmt|;
name|dst_end_symtab
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|module_num
condition|)
name|prim_record_minimal_symbol
argument_list|(
literal|"<end_of_program>"
argument_list|,
name|BLOCK_END
argument_list|(
name|block
argument_list|)
argument_list|,
name|mst_text
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* One more faked symbol to make sure nothing can ever run off the    * end of the symbol table. This one represents the end of the    * text space. It used to be (CORE_ADDR) -1 (effectively the highest    * int possible), but some parts of gdb treated it as a signed    * number and failed comparisons. We could equally use 7fffffff,    * but no functions are ever mapped to an address higher than    * 40000000    */
name|prim_record_minimal_symbol
argument_list|(
literal|"<end_of_text>"
argument_list|,
operator|(
name|CORE_ADDR
operator|)
literal|0x40000000
argument_list|,
name|mst_text
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
while|while
condition|(
name|struct_list
condition|)
block|{
name|element
operator|=
name|struct_list
expr_stmt|;
name|struct_list
operator|=
name|element
operator|->
name|next
expr_stmt|;
name|xfree
argument_list|(
name|element
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Support for line number handling */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|linetab
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|linetab_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|linetab_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Read in all the line numbers for fast lookups later.  Leave them in    external (unswapped) format in memory; we'll swap them as we enter    them into GDB's data structures.  */
end_comment

begin_function
specifier|static
name|int
name|init_one_section
parameter_list|(
name|int
name|chan
parameter_list|,
name|dst_sec
modifier|*
name|secinfo
parameter_list|)
block|{
if|if
condition|(
name|secinfo
operator|->
name|size
operator|==
literal|0
operator|||
name|lseek
argument_list|(
name|chan
argument_list|,
name|secinfo
operator|->
name|position
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
operator|||
operator|(
name|secinfo
operator|->
name|buffer
operator|=
name|xmalloc
argument_list|(
name|secinfo
operator|->
name|size
argument_list|)
operator|)
operator|==
name|NULL
operator|||
name|myread
argument_list|(
name|chan
argument_list|,
name|secinfo
operator|->
name|buffer
argument_list|,
name|secinfo
operator|->
name|size
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
literal|0
return|;
else|else
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|init_dst_sections
parameter_list|(
name|int
name|chan
parameter_list|)
block|{
if|if
condition|(
operator|!
name|init_one_section
argument_list|(
name|chan
argument_list|,
operator|&
name|blocks_info
argument_list|)
operator|||
operator|!
name|init_one_section
argument_list|(
name|chan
argument_list|,
operator|&
name|lines_info
argument_list|)
operator|||
operator|!
name|init_one_section
argument_list|(
name|chan
argument_list|,
operator|&
name|symbols_info
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Fake up support for relocating symbol addresses.  FIXME.  */
end_comment

begin_decl_stmt
name|struct
name|section_offsets
name|dst_symfile_faker
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|dst_symfile_offsets
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|,
name|struct
name|section_addr_info
modifier|*
name|addrs
parameter_list|)
block|{
name|objfile
operator|->
name|num_sections
operator|=
literal|1
expr_stmt|;
name|objfile
operator|->
name|section_offsets
operator|=
operator|&
name|dst_symfile_faker
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Register our ability to parse symbols for DST BFD files */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sym_fns
name|dst_sym_fns
init|=
block|{
comment|/* FIXME: Can this be integrated with coffread.c?  If not, should it be      a separate flavour like ecoff?  */
operator|(
expr|enum
name|bfd_flavour
operator|)
operator|-
literal|2
block|,
name|dst_new_init
block|,
comment|/* sym_new_init: init anything gbl to entire symtab */
name|dst_symfile_init
block|,
comment|/* sym_init: read initial info, setup for sym_read() */
name|dst_symfile_read
block|,
comment|/* sym_read: read a symbol file into symtab */
name|dst_symfile_finish
block|,
comment|/* sym_finish: finished with file, cleanup */
name|dst_symfile_offsets
block|,
comment|/* sym_offsets:  xlate external to internal form */
name|NULL
comment|/* next: pointer to next struct sym_fns */
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|_initialize_dstread
parameter_list|(
name|void
parameter_list|)
block|{
name|add_symtab_fns
argument_list|(
operator|&
name|dst_sym_fns
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

