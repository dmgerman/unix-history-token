begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Target-dependent code for the NEC V850 for GDB, the GNU debugger.    Copyright 1996, Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_decl_stmt
specifier|static
name|char
modifier|*
name|v850_generic_reg_names
index|[]
init|=
name|REGISTER_NAMES
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|v850e_reg_names
index|[]
init|=
block|{
literal|"r0"
block|,
literal|"r1"
block|,
literal|"r2"
block|,
literal|"r3"
block|,
literal|"r4"
block|,
literal|"r5"
block|,
literal|"r6"
block|,
literal|"r7"
block|,
literal|"r8"
block|,
literal|"r9"
block|,
literal|"r10"
block|,
literal|"r11"
block|,
literal|"r12"
block|,
literal|"r13"
block|,
literal|"r14"
block|,
literal|"r15"
block|,
literal|"r16"
block|,
literal|"r17"
block|,
literal|"r18"
block|,
literal|"r19"
block|,
literal|"r20"
block|,
literal|"r21"
block|,
literal|"r22"
block|,
literal|"r23"
block|,
literal|"r24"
block|,
literal|"r25"
block|,
literal|"r26"
block|,
literal|"r27"
block|,
literal|"r28"
block|,
literal|"r29"
block|,
literal|"r30"
block|,
literal|"r31"
block|,
literal|"eipc"
block|,
literal|"eipsw"
block|,
literal|"fepc"
block|,
literal|"fepsw"
block|,
literal|"ecr"
block|,
literal|"psw"
block|,
literal|"sr6"
block|,
literal|"sr7"
block|,
literal|"sr8"
block|,
literal|"sr9"
block|,
literal|"sr10"
block|,
literal|"sr11"
block|,
literal|"sr12"
block|,
literal|"sr13"
block|,
literal|"sr14"
block|,
literal|"sr15"
block|,
literal|"ctpc"
block|,
literal|"ctpsw"
block|,
literal|"dbpc"
block|,
literal|"dbpsw"
block|,
literal|"ctbp"
block|,
literal|"sr21"
block|,
literal|"sr22"
block|,
literal|"sr23"
block|,
literal|"sr24"
block|,
literal|"sr25"
block|,
literal|"sr26"
block|,
literal|"sr27"
block|,
literal|"sr28"
block|,
literal|"sr29"
block|,
literal|"sr30"
block|,
literal|"sr31"
block|,
literal|"pc"
block|,
literal|"fp"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|v850_register_names
init|=
name|v850_generic_reg_names
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
block|{
name|char
modifier|*
modifier|*
name|regnames
decl_stmt|;
name|int
name|mach
decl_stmt|;
block|}
name|v850_processor_type_table
index|[]
init|=
block|{
block|{
name|v850_generic_reg_names
block|,
name|bfd_mach_v850
block|}
block|,
block|{
name|v850e_reg_names
block|,
name|bfd_mach_v850e
block|}
block|,
block|{
name|v850e_reg_names
block|,
name|bfd_mach_v850ea
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_comment
comment|/* Info gleaned from scanning a function's prologue.  */
end_comment

begin_struct
struct|struct
name|pifsr
comment|/* Info about one saved reg */
block|{
name|int
name|framereg
decl_stmt|;
comment|/* Frame reg (SP or FP) */
name|int
name|offset
decl_stmt|;
comment|/* Offset from framereg */
name|int
name|cur_frameoffset
decl_stmt|;
comment|/* Current frameoffset */
name|int
name|reg
decl_stmt|;
comment|/* Saved register number */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|prologue_info
block|{
name|int
name|framereg
decl_stmt|;
name|int
name|frameoffset
decl_stmt|;
name|int
name|start_function
decl_stmt|;
name|struct
name|pifsr
modifier|*
name|pifsrs
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|v850_scan_prologue
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
name|pc
operator|,
expr|struct
name|prologue_info
operator|*
name|fs
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Should call_function allocate stack space for a struct return?  */
end_comment

begin_function
name|int
name|v850_use_struct_convention
parameter_list|(
name|gcc_p
parameter_list|,
name|type
parameter_list|)
name|int
name|gcc_p
decl_stmt|;
name|struct
name|type
modifier|*
name|type
decl_stmt|;
block|{
return|return
operator|(
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|>
literal|1
operator|||
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|>
literal|4
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Structure for mapping bits in register lists to register numbers. */
end_comment

begin_struct
struct|struct
name|reg_list
block|{
name|long
name|mask
decl_stmt|;
name|int
name|regno
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Helper function for v850_scan_prologue to handle prepare instruction. */
end_comment

begin_function
specifier|static
name|void
name|handle_prepare
parameter_list|(
name|int
name|insn
parameter_list|,
name|int
name|insn2
parameter_list|,
name|CORE_ADDR
modifier|*
name|current_pc_ptr
parameter_list|,
name|struct
name|prologue_info
modifier|*
name|pi
parameter_list|,
name|struct
name|pifsr
modifier|*
modifier|*
name|pifsr_ptr
parameter_list|)
block|{
name|CORE_ADDR
name|current_pc
init|=
operator|*
name|current_pc_ptr
decl_stmt|;
name|struct
name|pifsr
modifier|*
name|pifsr
init|=
operator|*
name|pifsr_ptr
decl_stmt|;
name|long
name|next
init|=
name|insn2
operator|&
literal|0xffff
decl_stmt|;
name|long
name|list12
init|=
operator|(
operator|(
name|insn
operator|&
literal|1
operator|)
operator|<<
literal|16
operator|)
operator|+
operator|(
name|next
operator|&
literal|0xffe0
operator|)
decl_stmt|;
name|long
name|offset
init|=
operator|(
name|insn
operator|&
literal|0x3e
operator|)
operator|<<
literal|1
decl_stmt|;
specifier|static
name|struct
name|reg_list
name|reg_table
index|[]
init|=
block|{
block|{
literal|0x00800
block|,
literal|20
block|}
block|,
comment|/* r20 */
block|{
literal|0x00400
block|,
literal|21
block|}
block|,
comment|/* r21 */
block|{
literal|0x00200
block|,
literal|22
block|}
block|,
comment|/* r22 */
block|{
literal|0x00100
block|,
literal|23
block|}
block|,
comment|/* r23 */
block|{
literal|0x08000
block|,
literal|24
block|}
block|,
comment|/* r24 */
block|{
literal|0x04000
block|,
literal|25
block|}
block|,
comment|/* r25 */
block|{
literal|0x02000
block|,
literal|26
block|}
block|,
comment|/* r26 */
block|{
literal|0x01000
block|,
literal|27
block|}
block|,
comment|/* r27 */
block|{
literal|0x00080
block|,
literal|28
block|}
block|,
comment|/* r28 */
block|{
literal|0x00040
block|,
literal|29
block|}
block|,
comment|/* r29 */
block|{
literal|0x10000
block|,
literal|30
block|}
block|,
comment|/* ep */
block|{
literal|0x00020
block|,
literal|31
block|}
block|,
comment|/* lp */
block|{
literal|0
block|,
literal|0
block|}
comment|/* end of table */
block|}
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|next
operator|&
literal|0x1f
operator|)
operator|==
literal|0x0b
condition|)
comment|/* skip imm16 argument */
name|current_pc
operator|+=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|next
operator|&
literal|0x1f
operator|)
operator|==
literal|0x13
condition|)
comment|/* skip imm16 argument */
name|current_pc
operator|+=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|next
operator|&
literal|0x1f
operator|)
operator|==
literal|0x1b
condition|)
comment|/* skip imm32 argument */
name|current_pc
operator|+=
literal|4
expr_stmt|;
comment|/* Calculate the total size of the saved registers, and add it      it to the immediate value used to adjust SP. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|reg_table
index|[
name|i
index|]
operator|.
name|mask
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|list12
operator|&
name|reg_table
index|[
name|i
index|]
operator|.
name|mask
condition|)
name|offset
operator|+=
name|REGISTER_RAW_SIZE
argument_list|(
name|regtable
index|[
name|i
index|]
operator|.
name|regno
argument_list|)
expr_stmt|;
name|pi
operator|->
name|frameoffset
operator|-=
name|offset
expr_stmt|;
comment|/* Calculate the offsets of the registers relative to the value      the SP will have after the registers have been pushed and the      imm5 value has been subtracted from it. */
if|if
condition|(
name|pifsr
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|reg_table
index|[
name|i
index|]
operator|.
name|mask
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|list12
operator|&
name|reg_table
index|[
name|i
index|]
operator|.
name|mask
condition|)
block|{
name|int
name|reg
init|=
name|reg_table
index|[
name|i
index|]
operator|.
name|regno
decl_stmt|;
name|offset
operator|-=
name|REGISTER_RAW_SIZE
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|pifsr
operator|->
name|reg
operator|=
name|reg
expr_stmt|;
name|pifsr
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
name|pifsr
operator|->
name|cur_frameoffset
operator|=
name|pi
operator|->
name|frameoffset
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf_filtered
argument_list|(
literal|"\tSaved register r%d, offset %d"
argument_list|,
name|reg
argument_list|,
name|pifsr
operator|->
name|offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pifsr
operator|++
expr_stmt|;
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|printf_filtered
argument_list|(
literal|"\tfound ctret after regsave func"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Set result parameters. */
operator|*
name|current_pc_ptr
operator|=
name|current_pc
expr_stmt|;
operator|*
name|pifsr_ptr
operator|=
name|pifsr
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Helper function for v850_scan_prologue to handle pushm/pushl instructions.    FIXME: the SR bit of the register list is not supported; must check    that the compiler does not ever generate this bit. */
end_comment

begin_function
specifier|static
name|void
name|handle_pushm
parameter_list|(
name|int
name|insn
parameter_list|,
name|int
name|insn2
parameter_list|,
name|struct
name|prologue_info
modifier|*
name|pi
parameter_list|,
name|struct
name|pifsr
modifier|*
modifier|*
name|pifsr_ptr
parameter_list|)
block|{
name|struct
name|pifsr
modifier|*
name|pifsr
init|=
operator|*
name|pifsr_ptr
decl_stmt|;
name|long
name|list12
init|=
operator|(
operator|(
name|insn
operator|&
literal|0x0f
operator|)
operator|<<
literal|16
operator|)
operator|+
operator|(
name|insn2
operator|&
literal|0xfff0
operator|)
decl_stmt|;
name|long
name|offset
init|=
literal|0
decl_stmt|;
specifier|static
name|struct
name|reg_list
name|pushml_reg_table
index|[]
init|=
block|{
block|{
literal|0x80000
block|,
name|PS_REGNUM
block|}
block|,
comment|/* PSW */
block|{
literal|0x40000
block|,
literal|1
block|}
block|,
comment|/* r1 */
block|{
literal|0x20000
block|,
literal|2
block|}
block|,
comment|/* r2 */
block|{
literal|0x10000
block|,
literal|3
block|}
block|,
comment|/* r3 */
block|{
literal|0x00800
block|,
literal|4
block|}
block|,
comment|/* r4 */
block|{
literal|0x00400
block|,
literal|5
block|}
block|,
comment|/* r5 */
block|{
literal|0x00200
block|,
literal|6
block|}
block|,
comment|/* r6 */
block|{
literal|0x00100
block|,
literal|7
block|}
block|,
comment|/* r7 */
block|{
literal|0x08000
block|,
literal|8
block|}
block|,
comment|/* r8 */
block|{
literal|0x04000
block|,
literal|9
block|}
block|,
comment|/* r9 */
block|{
literal|0x02000
block|,
literal|10
block|}
block|,
comment|/* r10 */
block|{
literal|0x01000
block|,
literal|11
block|}
block|,
comment|/* r11 */
block|{
literal|0x00080
block|,
literal|12
block|}
block|,
comment|/* r12 */
block|{
literal|0x00040
block|,
literal|13
block|}
block|,
comment|/* r13 */
block|{
literal|0x00020
block|,
literal|14
block|}
block|,
comment|/* r14 */
block|{
literal|0x00010
block|,
literal|15
block|}
block|,
comment|/* r15 */
block|{
literal|0
block|,
literal|0
block|}
comment|/* end of table */
block|}
decl_stmt|;
specifier|static
name|struct
name|reg_list
name|pushmh_reg_table
index|[]
init|=
block|{
block|{
literal|0x80000
block|,
literal|16
block|}
block|,
comment|/* r16 */
block|{
literal|0x40000
block|,
literal|17
block|}
block|,
comment|/* r17 */
block|{
literal|0x20000
block|,
literal|18
block|}
block|,
comment|/* r18 */
block|{
literal|0x10000
block|,
literal|19
block|}
block|,
comment|/* r19 */
block|{
literal|0x00800
block|,
literal|20
block|}
block|,
comment|/* r20 */
block|{
literal|0x00400
block|,
literal|21
block|}
block|,
comment|/* r21 */
block|{
literal|0x00200
block|,
literal|22
block|}
block|,
comment|/* r22 */
block|{
literal|0x00100
block|,
literal|23
block|}
block|,
comment|/* r23 */
block|{
literal|0x08000
block|,
literal|24
block|}
block|,
comment|/* r24 */
block|{
literal|0x04000
block|,
literal|25
block|}
block|,
comment|/* r25 */
block|{
literal|0x02000
block|,
literal|26
block|}
block|,
comment|/* r26 */
block|{
literal|0x01000
block|,
literal|27
block|}
block|,
comment|/* r27 */
block|{
literal|0x00080
block|,
literal|28
block|}
block|,
comment|/* r28 */
block|{
literal|0x00040
block|,
literal|29
block|}
block|,
comment|/* r29 */
block|{
literal|0x00010
block|,
literal|30
block|}
block|,
comment|/* r30 */
block|{
literal|0x00020
block|,
literal|31
block|}
block|,
comment|/* r31 */
block|{
literal|0
block|,
literal|0
block|}
comment|/* end of table */
block|}
decl_stmt|;
name|struct
name|reg_list
modifier|*
name|reg_table
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Is this a pushml or a pushmh? */
if|if
condition|(
operator|(
name|insn2
operator|&
literal|7
operator|)
operator|==
literal|1
condition|)
name|reg_table
operator|=
name|pushml_reg_table
expr_stmt|;
else|else
name|reg_table
operator|=
name|pushmh_reg_table
expr_stmt|;
comment|/* Calculate the total size of the saved registers, and add it      it to the immediate value used to adjust SP. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|reg_table
index|[
name|i
index|]
operator|.
name|mask
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|list12
operator|&
name|reg_table
index|[
name|i
index|]
operator|.
name|mask
condition|)
name|offset
operator|+=
name|REGISTER_RAW_SIZE
argument_list|(
name|regtable
index|[
name|i
index|]
operator|.
name|regno
argument_list|)
expr_stmt|;
name|pi
operator|->
name|frameoffset
operator|-=
name|offset
expr_stmt|;
comment|/* Calculate the offsets of the registers relative to the value      the SP will have after the registers have been pushed and the      imm5 value is subtracted from it. */
if|if
condition|(
name|pifsr
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|reg_table
index|[
name|i
index|]
operator|.
name|mask
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|list12
operator|&
name|reg_table
index|[
name|i
index|]
operator|.
name|mask
condition|)
block|{
name|int
name|reg
init|=
name|reg_table
index|[
name|i
index|]
operator|.
name|regno
decl_stmt|;
name|offset
operator|-=
name|REGISTER_RAW_SIZE
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|pifsr
operator|->
name|reg
operator|=
name|reg
expr_stmt|;
name|pifsr
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
name|pifsr
operator|->
name|cur_frameoffset
operator|=
name|pi
operator|->
name|frameoffset
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf_filtered
argument_list|(
literal|"\tSaved register r%d, offset %d"
argument_list|,
name|reg
argument_list|,
name|pifsr
operator|->
name|offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pifsr
operator|++
expr_stmt|;
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|printf_filtered
argument_list|(
literal|"\tfound ctret after regsave func"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Set result parameters. */
operator|*
name|pifsr_ptr
operator|=
name|pifsr
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Function: scan_prologue    Scan the prologue of the function that contains PC, and record what    we find in PI.  PI->fsr must be zeroed by the called.  Returns the    pc after the prologue.  Note that the addresses saved in pi->fsr    are actually just frame relative (negative offsets from the frame    pointer).  This is because we don't know the actual value of the    frame pointer yet.  In some circumstances, the frame pointer can't    be determined till after we have scanned the prologue.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|v850_scan_prologue
parameter_list|(
name|pc
parameter_list|,
name|pi
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
name|struct
name|prologue_info
modifier|*
name|pi
decl_stmt|;
block|{
name|CORE_ADDR
name|func_addr
decl_stmt|,
name|prologue_end
decl_stmt|,
name|current_pc
decl_stmt|;
name|struct
name|pifsr
modifier|*
name|pifsr
decl_stmt|,
modifier|*
name|pifsr_tmp
decl_stmt|;
name|int
name|fp_used
decl_stmt|;
name|int
name|ep_used
decl_stmt|;
name|int
name|reg
decl_stmt|;
name|CORE_ADDR
name|save_pc
decl_stmt|,
name|save_end
decl_stmt|;
name|int
name|regsave_func_p
decl_stmt|;
name|int
name|r12_tmp
decl_stmt|;
comment|/* First, figure out the bounds of the prologue so that we can limit the      search to something reasonable.  */
if|if
condition|(
name|find_pc_partial_function
argument_list|(
name|pc
argument_list|,
name|NULL
argument_list|,
operator|&
name|func_addr
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|sal
operator|=
name|find_pc_line
argument_list|(
name|func_addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|func_addr
operator|==
name|entry_point_address
argument_list|()
condition|)
name|pi
operator|->
name|start_function
operator|=
literal|1
expr_stmt|;
else|else
name|pi
operator|->
name|start_function
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|0
block|if (sal.line == 0) 	prologue_end = pc;       else 	prologue_end = sal.end;
else|#
directive|else
name|prologue_end
operator|=
name|pc
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* We're in the boondocks */
name|func_addr
operator|=
name|pc
operator|-
literal|100
expr_stmt|;
name|prologue_end
operator|=
name|pc
expr_stmt|;
block|}
name|prologue_end
operator|=
name|min
argument_list|(
name|prologue_end
argument_list|,
name|pc
argument_list|)
expr_stmt|;
comment|/* Now, search the prologue looking for instructions that setup fp, save      rp, adjust sp and such.  We also record the frame offset of any saved      registers. */
name|pi
operator|->
name|frameoffset
operator|=
literal|0
expr_stmt|;
name|pi
operator|->
name|framereg
operator|=
name|SP_REGNUM
expr_stmt|;
name|fp_used
operator|=
literal|0
expr_stmt|;
name|ep_used
operator|=
literal|0
expr_stmt|;
name|pifsr
operator|=
name|pi
operator|->
name|pifsrs
expr_stmt|;
name|regsave_func_p
operator|=
literal|0
expr_stmt|;
name|save_pc
operator|=
literal|0
expr_stmt|;
name|save_end
operator|=
literal|0
expr_stmt|;
name|r12_tmp
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf_filtered
argument_list|(
literal|"Current_pc = 0x%.8lx, prologue_end = 0x%.8lx\n"
argument_list|,
operator|(
name|long
operator|)
name|func_addr
argument_list|,
operator|(
name|long
operator|)
name|prologue_end
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|current_pc
operator|=
name|func_addr
init|;
name|current_pc
operator|<
name|prologue_end
condition|;
control|)
block|{
name|int
name|insn
decl_stmt|,
name|insn2
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf_filtered
argument_list|(
literal|"0x%.8lx "
argument_list|,
operator|(
name|long
operator|)
name|current_pc
argument_list|)
expr_stmt|;
call|(
modifier|*
name|tm_print_insn
call|)
argument_list|(
name|current_pc
argument_list|,
operator|&
name|tm_print_insn_info
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|insn
operator|=
name|read_memory_unsigned_integer
argument_list|(
name|current_pc
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|current_pc
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|insn
operator|&
literal|0x0780
operator|)
operator|>=
literal|0x0600
condition|)
comment|/* Four byte instruction? */
block|{
name|insn2
operator|=
name|read_memory_unsigned_integer
argument_list|(
name|current_pc
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|current_pc
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xffc0
operator|)
operator|==
operator|(
operator|(
literal|10
operator|<<
literal|11
operator|)
operator||
literal|0x0780
operator|)
operator|&&
operator|!
name|regsave_func_p
condition|)
block|{
comment|/* jarl<func>,10 */
name|long
name|low_disp
init|=
name|insn2
operator|&
operator|~
operator|(
name|long
operator|)
literal|1
decl_stmt|;
name|long
name|disp
init|=
operator|(
operator|(
operator|(
operator|(
operator|(
name|insn
operator|&
literal|0x3f
operator|)
operator|<<
literal|16
operator|)
operator|+
name|low_disp
operator|)
operator|&
operator|~
operator|(
name|long
operator|)
literal|1
operator|)
operator|^
literal|0x00200000
operator|)
operator|-
literal|0x00200000
decl_stmt|;
name|save_pc
operator|=
name|current_pc
expr_stmt|;
name|save_end
operator|=
name|prologue_end
expr_stmt|;
name|regsave_func_p
operator|=
literal|1
expr_stmt|;
name|current_pc
operator|+=
name|disp
operator|-
literal|4
expr_stmt|;
name|prologue_end
operator|=
operator|(
name|current_pc
operator|+
operator|(
literal|2
operator|*
literal|3
operator|)
comment|/* moves to/from ep */
operator|+
literal|4
comment|/* addi<const>,sp,sp */
operator|+
literal|2
comment|/* jmp [r10] */
operator|+
operator|(
literal|2
operator|*
literal|12
operator|)
comment|/* sst.w to save r2, r20-r29, r31 */
operator|+
literal|20
operator|)
expr_stmt|;
comment|/* slop area */
ifdef|#
directive|ifdef
name|DEBUG
name|printf_filtered
argument_list|(
literal|"\tfound jarl<func>,r10, disp = %ld, low_disp = %ld, new pc = 0x%.8lx\n"
argument_list|,
name|disp
argument_list|,
name|low_disp
argument_list|,
operator|(
name|long
operator|)
name|current_pc
operator|+
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xffc0
operator|)
operator|==
literal|0x0200
operator|&&
operator|!
name|regsave_func_p
condition|)
block|{
comment|/* callt<imm6> */
name|long
name|ctbp
init|=
name|read_register
argument_list|(
name|CTBP_REGNUM
argument_list|)
decl_stmt|;
name|long
name|adr
init|=
name|ctbp
operator|+
operator|(
operator|(
name|insn
operator|&
literal|0x3f
operator|)
operator|<<
literal|1
operator|)
decl_stmt|;
name|save_pc
operator|=
name|current_pc
expr_stmt|;
name|save_end
operator|=
name|prologue_end
expr_stmt|;
name|regsave_func_p
operator|=
literal|1
expr_stmt|;
name|current_pc
operator|=
name|ctbp
operator|+
operator|(
name|read_memory_unsigned_integer
argument_list|(
name|adr
argument_list|,
literal|2
argument_list|)
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|prologue_end
operator|=
operator|(
name|current_pc
operator|+
operator|(
literal|2
operator|*
literal|3
operator|)
comment|/* prepare list2,imm5,sp/imm */
operator|+
literal|4
comment|/* ctret */
operator|+
literal|20
operator|)
expr_stmt|;
comment|/* slop area */
ifdef|#
directive|ifdef
name|DEBUG
name|printf_filtered
argument_list|(
literal|"\tfound callt,  ctbp = 0x%.8lx, adr = %.8lx, new pc = 0x%.8lx\n"
argument_list|,
name|ctbp
argument_list|,
name|adr
argument_list|,
operator|(
name|long
operator|)
name|current_pc
argument_list|)
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xffc0
operator|)
operator|==
literal|0x0780
condition|)
comment|/* prepare list2,imm5 */
block|{
name|handle_prepare
argument_list|(
name|insn
argument_list|,
name|insn2
argument_list|,
operator|&
name|current_pc
argument_list|,
name|pi
argument_list|,
operator|&
name|pifsr
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|insn
operator|==
literal|0x07e0
operator|&&
name|regsave_func_p
operator|&&
name|insn2
operator|==
literal|0x0144
condition|)
block|{
comment|/* ctret after processing register save function */
name|current_pc
operator|=
name|save_pc
expr_stmt|;
name|prologue_end
operator|=
name|save_end
expr_stmt|;
name|regsave_func_p
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf_filtered
argument_list|(
literal|"\tfound ctret after regsave func"
argument_list|)
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xfff0
operator|)
operator|==
literal|0x07e0
operator|&&
operator|(
name|insn2
operator|&
literal|5
operator|)
operator|==
literal|1
condition|)
block|{
comment|/* pushml, pushmh */
name|handle_pushm
argument_list|(
name|insn
argument_list|,
name|insn2
argument_list|,
name|pi
argument_list|,
operator|&
name|pifsr
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xffe0
operator|)
operator|==
literal|0x0060
operator|&&
name|regsave_func_p
condition|)
block|{
comment|/* jmp after processing register save function */
name|current_pc
operator|=
name|save_pc
expr_stmt|;
name|prologue_end
operator|=
name|save_end
expr_stmt|;
name|regsave_func_p
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf_filtered
argument_list|(
literal|"\tfound jmp after regsave func"
argument_list|)
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
literal|0x07c0
operator|)
operator|==
literal|0x0780
comment|/* jarl or jr */
operator|||
operator|(
name|insn
operator|&
literal|0xffe0
operator|)
operator|==
literal|0x0060
comment|/* jmp */
operator|||
operator|(
name|insn
operator|&
literal|0x0780
operator|)
operator|==
literal|0x0580
condition|)
comment|/* branch */
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
comment|/* Ran into end of prologue */
block|}
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xffe0
operator|)
operator|==
operator|(
operator|(
name|SP_REGNUM
operator|<<
literal|11
operator|)
operator||
literal|0x0240
operator|)
condition|)
comment|/* add<imm>,sp */
name|pi
operator|->
name|frameoffset
operator|+=
operator|(
operator|(
name|insn
operator|&
literal|0x1f
operator|)
operator|^
literal|0x10
operator|)
operator|-
literal|0x10
expr_stmt|;
elseif|else
if|if
condition|(
name|insn
operator|==
operator|(
operator|(
name|SP_REGNUM
operator|<<
literal|11
operator|)
operator||
literal|0x0600
operator||
name|SP_REGNUM
operator|)
condition|)
comment|/* addi<imm>,sp,sp */
name|pi
operator|->
name|frameoffset
operator|+=
name|insn2
expr_stmt|;
elseif|else
if|if
condition|(
name|insn
operator|==
operator|(
operator|(
name|FP_RAW_REGNUM
operator|<<
literal|11
operator|)
operator||
literal|0x0000
operator||
name|SP_REGNUM
operator|)
condition|)
comment|/* mov sp,fp */
block|{
name|fp_used
operator|=
literal|1
expr_stmt|;
name|pi
operator|->
name|framereg
operator|=
name|FP_RAW_REGNUM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|insn
operator|==
operator|(
operator|(
name|R12_REGNUM
operator|<<
literal|11
operator|)
operator||
literal|0x0640
operator||
name|R0_REGNUM
operator|)
condition|)
comment|/* movhi hi(const),r0,r12 */
name|r12_tmp
operator|=
name|insn2
operator|<<
literal|16
expr_stmt|;
elseif|else
if|if
condition|(
name|insn
operator|==
operator|(
operator|(
name|R12_REGNUM
operator|<<
literal|11
operator|)
operator||
literal|0x0620
operator||
name|R12_REGNUM
operator|)
condition|)
comment|/* movea lo(const),r12,r12 */
name|r12_tmp
operator|+=
name|insn2
expr_stmt|;
elseif|else
if|if
condition|(
name|insn
operator|==
operator|(
operator|(
name|SP_REGNUM
operator|<<
literal|11
operator|)
operator||
literal|0x01c0
operator||
name|R12_REGNUM
operator|)
operator|&&
name|r12_tmp
condition|)
comment|/* add r12,sp */
name|pi
operator|->
name|frameoffset
operator|=
name|r12_tmp
expr_stmt|;
elseif|else
if|if
condition|(
name|insn
operator|==
operator|(
operator|(
name|EP_REGNUM
operator|<<
literal|11
operator|)
operator||
literal|0x0000
operator||
name|SP_REGNUM
operator|)
condition|)
comment|/* mov sp,ep */
name|ep_used
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|insn
operator|==
operator|(
operator|(
name|EP_REGNUM
operator|<<
literal|11
operator|)
operator||
literal|0x0000
operator||
name|R1_REGNUM
operator|)
condition|)
comment|/* mov r1,ep */
name|ep_used
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|(
name|insn
operator|&
literal|0x07ff
operator|)
operator|==
operator|(
literal|0x0760
operator||
name|SP_REGNUM
operator|)
comment|/* st.w<reg>,<offset>[sp] */
operator|||
operator|(
name|fp_used
operator|&&
operator|(
name|insn
operator|&
literal|0x07ff
operator|)
operator|==
operator|(
literal|0x0760
operator||
name|FP_RAW_REGNUM
operator|)
operator|)
operator|)
comment|/* st.w<reg>,<offset>[fp] */
operator|&&
name|pifsr
operator|&&
operator|(
operator|(
operator|(
name|reg
operator|=
operator|(
name|insn
operator|>>
literal|11
operator|)
operator|&
literal|0x1f
operator|)
operator|>=
name|SAVE1_START_REGNUM
operator|&&
name|reg
operator|<=
name|SAVE1_END_REGNUM
operator|)
operator|||
operator|(
name|reg
operator|>=
name|SAVE2_START_REGNUM
operator|&&
name|reg
operator|<=
name|SAVE2_END_REGNUM
operator|)
operator|||
operator|(
name|reg
operator|>=
name|SAVE3_START_REGNUM
operator|&&
name|reg
operator|<=
name|SAVE3_END_REGNUM
operator|)
operator|)
condition|)
block|{
name|pifsr
operator|->
name|reg
operator|=
name|reg
expr_stmt|;
name|pifsr
operator|->
name|offset
operator|=
name|insn2
operator|&
operator|~
literal|1
expr_stmt|;
name|pifsr
operator|->
name|cur_frameoffset
operator|=
name|pi
operator|->
name|frameoffset
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf_filtered
argument_list|(
literal|"\tSaved register r%d, offset %d"
argument_list|,
name|reg
argument_list|,
name|pifsr
operator|->
name|offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pifsr
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ep_used
comment|/* sst.w<reg>,<offset>[ep] */
operator|&&
operator|(
operator|(
name|insn
operator|&
literal|0x0781
operator|)
operator|==
literal|0x0501
operator|)
operator|&&
name|pifsr
operator|&&
operator|(
operator|(
operator|(
name|reg
operator|=
operator|(
name|insn
operator|>>
literal|11
operator|)
operator|&
literal|0x1f
operator|)
operator|>=
name|SAVE1_START_REGNUM
operator|&&
name|reg
operator|<=
name|SAVE1_END_REGNUM
operator|)
operator|||
operator|(
name|reg
operator|>=
name|SAVE2_START_REGNUM
operator|&&
name|reg
operator|<=
name|SAVE2_END_REGNUM
operator|)
operator|||
operator|(
name|reg
operator|>=
name|SAVE3_START_REGNUM
operator|&&
name|reg
operator|<=
name|SAVE3_END_REGNUM
operator|)
operator|)
condition|)
block|{
name|pifsr
operator|->
name|reg
operator|=
name|reg
expr_stmt|;
name|pifsr
operator|->
name|offset
operator|=
operator|(
name|insn
operator|&
literal|0x007e
operator|)
operator|<<
literal|1
expr_stmt|;
name|pifsr
operator|->
name|cur_frameoffset
operator|=
name|pi
operator|->
name|frameoffset
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf_filtered
argument_list|(
literal|"\tSaved register r%d, offset %d"
argument_list|,
name|reg
argument_list|,
name|pifsr
operator|->
name|offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pifsr
operator|++
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|pifsr
condition|)
name|pifsr
operator|->
name|framereg
operator|=
literal|0
expr_stmt|;
comment|/* Tie off last entry */
comment|/* Fix up any offsets to the final offset.  If a frame pointer was created, use it      instead of the stack pointer.  */
for|for
control|(
name|pifsr_tmp
operator|=
name|pi
operator|->
name|pifsrs
init|;
name|pifsr_tmp
operator|&&
name|pifsr_tmp
operator|!=
name|pifsr
condition|;
name|pifsr_tmp
operator|++
control|)
block|{
name|pifsr_tmp
operator|->
name|offset
operator|-=
name|pi
operator|->
name|frameoffset
operator|-
name|pifsr_tmp
operator|->
name|cur_frameoffset
expr_stmt|;
name|pifsr_tmp
operator|->
name|framereg
operator|=
name|pi
operator|->
name|framereg
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf_filtered
argument_list|(
literal|"Saved register r%d, offset = %d, framereg = r%d\n"
argument_list|,
name|pifsr_tmp
operator|->
name|reg
argument_list|,
name|pifsr_tmp
operator|->
name|offset
argument_list|,
name|pifsr_tmp
operator|->
name|framereg
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|printf_filtered
argument_list|(
literal|"Framereg = r%d, frameoffset = %d\n"
argument_list|,
name|pi
operator|->
name|framereg
argument_list|,
name|pi
operator|->
name|frameoffset
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|current_pc
return|;
block|}
end_function

begin_comment
comment|/* Function: init_extra_frame_info    Setup the frame's frame pointer, pc, and frame addresses for saved    registers.  Most of the work is done in scan_prologue().     Note that when we are called for the last frame (currently active frame),    that fi->pc and fi->frame will already be setup.  However, fi->frame will    be valid only if this routine uses FP.  For previous frames, fi-frame will    always be correct (since that is derived from v850_frame_chain ()).     We can be called with the PC in the call dummy under two circumstances.    First, during normal backtracing, second, while figuring out the frame    pointer just prior to calling the target function (see run_stack_dummy).  */
end_comment

begin_function
name|void
name|v850_init_extra_frame_info
parameter_list|(
name|fi
parameter_list|)
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
block|{
name|struct
name|prologue_info
name|pi
decl_stmt|;
name|struct
name|pifsr
name|pifsrs
index|[
name|NUM_REGS
operator|+
literal|1
index|]
decl_stmt|,
modifier|*
name|pifsr
decl_stmt|;
if|if
condition|(
name|fi
operator|->
name|next
condition|)
name|fi
operator|->
name|pc
operator|=
name|FRAME_SAVED_PC
argument_list|(
name|fi
operator|->
name|next
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|fi
operator|->
name|fsr
operator|.
name|regs
argument_list|,
literal|'\000'
argument_list|,
sizeof|sizeof
name|fi
operator|->
name|fsr
operator|.
name|regs
argument_list|)
expr_stmt|;
comment|/* The call dummy doesn't save any registers on the stack, so we can return      now.  */
if|if
condition|(
name|PC_IN_CALL_DUMMY
argument_list|(
name|fi
operator|->
name|pc
argument_list|,
name|fi
operator|->
name|frame
argument_list|,
name|fi
operator|->
name|frame
argument_list|)
condition|)
return|return;
name|pi
operator|.
name|pifsrs
operator|=
name|pifsrs
expr_stmt|;
name|v850_scan_prologue
argument_list|(
name|fi
operator|->
name|pc
argument_list|,
operator|&
name|pi
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fi
operator|->
name|next
operator|&&
name|pi
operator|.
name|framereg
operator|==
name|SP_REGNUM
condition|)
name|fi
operator|->
name|frame
operator|=
name|read_register
argument_list|(
name|pi
operator|.
name|framereg
argument_list|)
operator|-
name|pi
operator|.
name|frameoffset
expr_stmt|;
for|for
control|(
name|pifsr
operator|=
name|pifsrs
init|;
name|pifsr
operator|->
name|framereg
condition|;
name|pifsr
operator|++
control|)
block|{
name|fi
operator|->
name|fsr
operator|.
name|regs
index|[
name|pifsr
operator|->
name|reg
index|]
operator|=
name|pifsr
operator|->
name|offset
operator|+
name|fi
operator|->
name|frame
expr_stmt|;
if|if
condition|(
name|pifsr
operator|->
name|framereg
operator|==
name|SP_REGNUM
condition|)
name|fi
operator|->
name|fsr
operator|.
name|regs
index|[
name|pifsr
operator|->
name|reg
index|]
operator|+=
name|pi
operator|.
name|frameoffset
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Function: frame_chain    Figure out the frame prior to FI.  Unfortunately, this involves    scanning the prologue of the caller, which will also be done    shortly by v850_init_extra_frame_info.  For the dummy frame, we    just return the stack pointer that was in use at the time the    function call was made.  */
end_comment

begin_function
name|CORE_ADDR
name|v850_frame_chain
parameter_list|(
name|fi
parameter_list|)
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
block|{
name|struct
name|prologue_info
name|pi
decl_stmt|;
name|CORE_ADDR
name|callers_pc
decl_stmt|,
name|fp
decl_stmt|;
comment|/* First, find out who called us */
name|callers_pc
operator|=
name|FRAME_SAVED_PC
argument_list|(
name|fi
argument_list|)
expr_stmt|;
comment|/* If caller is a call-dummy, then our FP bears no relation to his FP! */
name|fp
operator|=
name|v850_find_callers_reg
argument_list|(
name|fi
argument_list|,
name|FP_RAW_REGNUM
argument_list|)
expr_stmt|;
if|if
condition|(
name|PC_IN_CALL_DUMMY
argument_list|(
name|callers_pc
argument_list|,
name|fp
argument_list|,
name|fp
argument_list|)
condition|)
return|return
name|fp
return|;
comment|/* caller is call-dummy: return oldest value of FP */
comment|/* Caller is NOT a call-dummy, so everything else should just work.      Even if THIS frame is a call-dummy! */
name|pi
operator|.
name|pifsrs
operator|=
name|NULL
expr_stmt|;
name|v850_scan_prologue
argument_list|(
name|callers_pc
argument_list|,
operator|&
name|pi
argument_list|)
expr_stmt|;
if|if
condition|(
name|pi
operator|.
name|start_function
condition|)
return|return
literal|0
return|;
comment|/* Don't chain beyond the start function */
if|if
condition|(
name|pi
operator|.
name|framereg
operator|==
name|FP_RAW_REGNUM
condition|)
return|return
name|v850_find_callers_reg
argument_list|(
name|fi
argument_list|,
name|pi
operator|.
name|framereg
argument_list|)
return|;
return|return
name|fi
operator|->
name|frame
operator|-
name|pi
operator|.
name|frameoffset
return|;
block|}
end_function

begin_comment
comment|/* Function: find_callers_reg    Find REGNUM on the stack.  Otherwise, it's in an active register.    One thing we might want to do here is to check REGNUM against the    clobber mask, and somehow flag it as invalid if it isn't saved on    the stack somewhere.  This would provide a graceful failure mode    when trying to get the value of caller-saves registers for an inner    frame.  */
end_comment

begin_function
name|CORE_ADDR
name|v850_find_callers_reg
parameter_list|(
name|fi
parameter_list|,
name|regnum
parameter_list|)
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
name|int
name|regnum
decl_stmt|;
block|{
for|for
control|(
init|;
name|fi
condition|;
name|fi
operator|=
name|fi
operator|->
name|next
control|)
if|if
condition|(
name|PC_IN_CALL_DUMMY
argument_list|(
name|fi
operator|->
name|pc
argument_list|,
name|fi
operator|->
name|frame
argument_list|,
name|fi
operator|->
name|frame
argument_list|)
condition|)
return|return
name|generic_read_register_dummy
argument_list|(
name|fi
operator|->
name|pc
argument_list|,
name|fi
operator|->
name|frame
argument_list|,
name|regnum
argument_list|)
return|;
elseif|else
if|if
condition|(
name|fi
operator|->
name|fsr
operator|.
name|regs
index|[
name|regnum
index|]
operator|!=
literal|0
condition|)
return|return
name|read_memory_unsigned_integer
argument_list|(
name|fi
operator|->
name|fsr
operator|.
name|regs
index|[
name|regnum
index|]
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|)
return|;
return|return
name|read_register
argument_list|(
name|regnum
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Function: skip_prologue    Return the address of the first code past the prologue of the function.  */
end_comment

begin_function
name|CORE_ADDR
name|v850_skip_prologue
parameter_list|(
name|pc
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
block|{
name|CORE_ADDR
name|func_addr
decl_stmt|,
name|func_end
decl_stmt|;
comment|/* See what the symbol table says */
if|if
condition|(
name|find_pc_partial_function
argument_list|(
name|pc
argument_list|,
name|NULL
argument_list|,
operator|&
name|func_addr
argument_list|,
operator|&
name|func_end
argument_list|)
condition|)
block|{
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|sal
operator|=
name|find_pc_line
argument_list|(
name|func_addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sal
operator|.
name|line
operator|!=
literal|0
operator|&&
name|sal
operator|.
name|end
operator|<
name|func_end
condition|)
return|return
name|sal
operator|.
name|end
return|;
else|else
comment|/* Either there's no line info, or the line after the prologue is after 	   the end of the function.  In this case, there probably isn't a 	   prologue.  */
return|return
name|pc
return|;
block|}
comment|/* We can't find the start of this function, so there's nothing we can do. */
return|return
name|pc
return|;
block|}
end_function

begin_comment
comment|/* Function: pop_frame    This routine gets called when either the user uses the `return'    command, or the call dummy breakpoint gets hit.  */
end_comment

begin_function
name|void
name|v850_pop_frame
parameter_list|(
name|frame
parameter_list|)
name|struct
name|frame_info
modifier|*
name|frame
decl_stmt|;
block|{
name|int
name|regnum
decl_stmt|;
if|if
condition|(
name|PC_IN_CALL_DUMMY
argument_list|(
name|frame
operator|->
name|pc
argument_list|,
name|frame
operator|->
name|frame
argument_list|,
name|frame
operator|->
name|frame
argument_list|)
condition|)
name|generic_pop_dummy_frame
argument_list|()
expr_stmt|;
else|else
block|{
name|write_register
argument_list|(
name|PC_REGNUM
argument_list|,
name|FRAME_SAVED_PC
argument_list|(
name|frame
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|regnum
operator|=
literal|0
init|;
name|regnum
operator|<
name|NUM_REGS
condition|;
name|regnum
operator|++
control|)
if|if
condition|(
name|frame
operator|->
name|fsr
operator|.
name|regs
index|[
name|regnum
index|]
operator|!=
literal|0
condition|)
name|write_register
argument_list|(
name|regnum
argument_list|,
name|read_memory_unsigned_integer
argument_list|(
name|frame
operator|->
name|fsr
operator|.
name|regs
index|[
name|regnum
index|]
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|SP_REGNUM
argument_list|,
name|FRAME_FP
argument_list|(
name|frame
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|flush_cached_frames
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Function: push_arguments    Setup arguments and RP for a call to the target.  First four args    go in R6->R9, subsequent args go into sp + 16 -> sp + ...  Structs    are passed by reference.  64 bit quantities (doubles and long    longs) may be split between the regs and the stack.  When calling a    function that returns a struct, a pointer to the struct is passed    in as a secret first argument (always in R6).     Stack space for the args has NOT been allocated: that job is up to us.    */
end_comment

begin_function
name|CORE_ADDR
name|v850_push_arguments
parameter_list|(
name|nargs
parameter_list|,
name|args
parameter_list|,
name|sp
parameter_list|,
name|struct_return
parameter_list|,
name|struct_addr
parameter_list|)
name|int
name|nargs
decl_stmt|;
name|value_ptr
modifier|*
name|args
decl_stmt|;
name|CORE_ADDR
name|sp
decl_stmt|;
name|unsigned
name|char
name|struct_return
decl_stmt|;
name|CORE_ADDR
name|struct_addr
decl_stmt|;
block|{
name|int
name|argreg
decl_stmt|;
name|int
name|argnum
decl_stmt|;
name|int
name|len
init|=
literal|0
decl_stmt|;
name|int
name|stack_offset
decl_stmt|;
comment|/* First, just for safety, make sure stack is aligned */
name|sp
operator|&=
operator|~
literal|3
expr_stmt|;
comment|/* Now make space on the stack for the args. */
for|for
control|(
name|argnum
operator|=
literal|0
init|;
name|argnum
operator|<
name|nargs
condition|;
name|argnum
operator|++
control|)
name|len
operator|+=
operator|(
operator|(
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|args
index|[
name|argnum
index|]
argument_list|)
argument_list|)
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
operator|)
expr_stmt|;
name|sp
operator|-=
name|len
expr_stmt|;
comment|/* possibly over-allocating, but it works... */
comment|/* (you might think we could allocate 16 bytes */
comment|/* less, but the ABI seems to use it all! )  */
name|argreg
operator|=
name|ARG0_REGNUM
expr_stmt|;
comment|/* the struct_return pointer occupies the first parameter-passing reg */
if|if
condition|(
name|struct_return
condition|)
name|write_register
argument_list|(
name|argreg
operator|++
argument_list|,
name|struct_addr
argument_list|)
expr_stmt|;
name|stack_offset
operator|=
literal|16
expr_stmt|;
comment|/* The offset onto the stack at which we will start copying parameters      (after the registers are used up) begins at 16 rather than at zero.      I don't really know why, that's just the way it seems to work.  */
comment|/* Now load as many as possible of the first arguments into      registers, and push the rest onto the stack.  There are 16 bytes      in four registers available.  Loop thru args from first to last.  */
for|for
control|(
name|argnum
operator|=
literal|0
init|;
name|argnum
operator|<
name|nargs
condition|;
name|argnum
operator|++
control|)
block|{
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
name|char
name|valbuf
index|[
name|REGISTER_RAW_SIZE
argument_list|(
name|ARG0_REGNUM
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
operator|*
name|args
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
operator|&&
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
operator|*
name|args
argument_list|)
argument_list|)
operator|>
literal|8
condition|)
block|{
name|store_address
argument_list|(
name|valbuf
argument_list|,
literal|4
argument_list|,
name|VALUE_ADDRESS
argument_list|(
operator|*
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
literal|4
expr_stmt|;
name|val
operator|=
name|valbuf
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
operator|*
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
name|char
operator|*
operator|)
name|VALUE_CONTENTS
argument_list|(
operator|*
name|args
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|len
operator|>
literal|0
condition|)
if|if
condition|(
name|argreg
operator|<=
name|ARGLAST_REGNUM
condition|)
block|{
name|CORE_ADDR
name|regval
decl_stmt|;
name|regval
operator|=
name|extract_address
argument_list|(
name|val
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|argreg
argument_list|)
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|argreg
argument_list|,
name|regval
argument_list|)
expr_stmt|;
name|len
operator|-=
name|REGISTER_RAW_SIZE
argument_list|(
name|argreg
argument_list|)
expr_stmt|;
name|val
operator|+=
name|REGISTER_RAW_SIZE
argument_list|(
name|argreg
argument_list|)
expr_stmt|;
name|argreg
operator|++
expr_stmt|;
block|}
else|else
block|{
name|write_memory
argument_list|(
name|sp
operator|+
name|stack_offset
argument_list|,
name|val
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|len
operator|-=
literal|4
expr_stmt|;
name|val
operator|+=
literal|4
expr_stmt|;
name|stack_offset
operator|+=
literal|4
expr_stmt|;
block|}
name|args
operator|++
expr_stmt|;
block|}
return|return
name|sp
return|;
block|}
end_function

begin_comment
comment|/* Function: push_return_address (pc)    Set up the return address for the inferior function call.    Needed for targets where we don't actually execute a JSR/BSR instruction */
end_comment

begin_function
name|CORE_ADDR
name|v850_push_return_address
parameter_list|(
name|pc
parameter_list|,
name|sp
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
name|CORE_ADDR
name|sp
decl_stmt|;
block|{
name|write_register
argument_list|(
name|RP_REGNUM
argument_list|,
name|CALL_DUMMY_ADDRESS
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|sp
return|;
block|}
end_function

begin_comment
comment|/* Function: frame_saved_pc     Find the caller of this frame.  We do this by seeing if RP_REGNUM    is saved in the stack anywhere, otherwise we get it from the    registers.  If the inner frame is a dummy frame, return its PC    instead of RP, because that's where "caller" of the dummy-frame    will be found.  */
end_comment

begin_function
name|CORE_ADDR
name|v850_frame_saved_pc
parameter_list|(
name|fi
parameter_list|)
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
block|{
if|if
condition|(
name|PC_IN_CALL_DUMMY
argument_list|(
name|fi
operator|->
name|pc
argument_list|,
name|fi
operator|->
name|frame
argument_list|,
name|fi
operator|->
name|frame
argument_list|)
condition|)
return|return
name|generic_read_register_dummy
argument_list|(
name|fi
operator|->
name|pc
argument_list|,
name|fi
operator|->
name|frame
argument_list|,
name|PC_REGNUM
argument_list|)
return|;
else|else
return|return
name|v850_find_callers_reg
argument_list|(
name|fi
argument_list|,
name|RP_REGNUM
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|get_saved_register
parameter_list|(
name|raw_buffer
parameter_list|,
name|optimized
parameter_list|,
name|addrp
parameter_list|,
name|frame
parameter_list|,
name|regnum
parameter_list|,
name|lval
parameter_list|)
name|char
modifier|*
name|raw_buffer
decl_stmt|;
name|int
modifier|*
name|optimized
decl_stmt|;
name|CORE_ADDR
modifier|*
name|addrp
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|frame
decl_stmt|;
name|int
name|regnum
decl_stmt|;
name|enum
name|lval_type
modifier|*
name|lval
decl_stmt|;
block|{
name|generic_get_saved_register
argument_list|(
name|raw_buffer
argument_list|,
name|optimized
argument_list|,
name|addrp
argument_list|,
name|frame
argument_list|,
name|regnum
argument_list|,
name|lval
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Function: fix_call_dummy    Pokes the callee function's address into the CALL_DUMMY assembly stub.    Assumes that the CALL_DUMMY looks like this: 	jarl<offset24>, r31 	trap    */
end_comment

begin_function
name|int
name|v850_fix_call_dummy
parameter_list|(
name|dummy
parameter_list|,
name|sp
parameter_list|,
name|fun
parameter_list|,
name|nargs
parameter_list|,
name|args
parameter_list|,
name|type
parameter_list|,
name|gcc_p
parameter_list|)
name|char
modifier|*
name|dummy
decl_stmt|;
name|CORE_ADDR
name|sp
decl_stmt|;
name|CORE_ADDR
name|fun
decl_stmt|;
name|int
name|nargs
decl_stmt|;
name|value_ptr
modifier|*
name|args
decl_stmt|;
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|int
name|gcc_p
decl_stmt|;
block|{
name|long
name|offset24
decl_stmt|;
name|offset24
operator|=
operator|(
name|long
operator|)
name|fun
operator|-
operator|(
name|long
operator|)
name|entry_point_address
argument_list|()
expr_stmt|;
name|offset24
operator|&=
literal|0x3fffff
expr_stmt|;
name|offset24
operator||=
literal|0xff800000
expr_stmt|;
comment|/* jarl<offset24>, r31 */
name|store_unsigned_integer
argument_list|(
operator|(
name|unsigned
name|int
operator|*
operator|)
operator|&
name|dummy
index|[
literal|2
index|]
argument_list|,
literal|2
argument_list|,
name|offset24
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
name|store_unsigned_integer
argument_list|(
operator|(
name|unsigned
name|int
operator|*
operator|)
operator|&
name|dummy
index|[
literal|0
index|]
argument_list|,
literal|2
argument_list|,
name|offset24
operator|>>
literal|16
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Change the register names based on the current machine type. */
end_comment

begin_function
specifier|static
name|int
name|v850_target_architecture_hook
parameter_list|(
name|ap
parameter_list|)
specifier|const
name|bfd_arch_info_type
modifier|*
name|ap
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|ap
operator|->
name|arch
operator|!=
name|bfd_arch_v850
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|v850_processor_type_table
index|[
name|i
index|]
operator|.
name|regnames
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|v850_processor_type_table
index|[
name|i
index|]
operator|.
name|mach
operator|==
name|ap
operator|->
name|mach
condition|)
block|{
name|v850_register_names
operator|=
name|v850_processor_type_table
index|[
name|i
index|]
operator|.
name|regnames
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
name|fatal
argument_list|(
literal|"Architecture `%s' unreconized"
argument_list|,
name|ap
operator|->
name|printable_name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_initialize_v850_tdep
parameter_list|()
block|{
name|tm_print_insn
operator|=
name|print_insn_v850
expr_stmt|;
name|target_architecture_hook
operator|=
name|v850_target_architecture_hook
expr_stmt|;
block|}
end_function

end_unit

