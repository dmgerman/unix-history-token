begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Remote serial interface using Renesas E7000 PC ISA card in a PC    Copyright 1994, 1996, 1997, 1998, 1999, 2000    Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_if
if|#
directive|if
name|defined
name|__GO32__
operator|||
name|defined
name|_WIN32
end_if

begin_include
include|#
directive|include
file|"serial.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32
end_ifdef

begin_define
define|#
directive|define
name|WIN32_LEAN_AND_MEAN
end_define

begin_include
include|#
directive|include
file|<windows.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__GO32__
end_ifdef

begin_include
include|#
directive|include
file|<sys/dos.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|e7000pc_open
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|e7000pc_raw
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|e7000pc_readchar
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|,
name|int
name|timeout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|e7000pc_setbaudrate
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|,
name|int
name|rate
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|e7000pc_write
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|e7000pc_close
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|serial_ttystate
name|e7000pc_get_tty_state
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|e7000pc_set_tty_state
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|,
name|serial_ttystate
name|state
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|OFF_DPD
value|0x0000
end_define

begin_define
define|#
directive|define
name|OFF_DDP
value|0x1000
end_define

begin_define
define|#
directive|define
name|OFF_CPD
value|0x2000
end_define

begin_define
define|#
directive|define
name|OFF_CDP
value|0x2400
end_define

begin_define
define|#
directive|define
name|OFF_FA
value|0x3000
end_define

begin_define
define|#
directive|define
name|OFF_FB
value|0x3002
end_define

begin_define
define|#
directive|define
name|OFF_FC
value|0x3004
end_define

begin_define
define|#
directive|define
name|OFF_IRQTOD
value|0x3008
end_define

begin_define
define|#
directive|define
name|OFF_IRQTOP
value|0x300a
end_define

begin_define
define|#
directive|define
name|OFF_READY
value|0x300c
end_define

begin_define
define|#
directive|define
name|OFF_PON
value|0x300e
end_define

begin_define
define|#
directive|define
name|IDLE
value|0x0000
end_define

begin_define
define|#
directive|define
name|CMD_CI
value|0x4349
end_define

begin_define
define|#
directive|define
name|CMD_CO
value|0x434f
end_define

begin_define
define|#
directive|define
name|CMD_LO
value|0x4c4f
end_define

begin_define
define|#
directive|define
name|CMD_LS
value|0x4c53
end_define

begin_define
define|#
directive|define
name|CMD_SV
value|0x5356
end_define

begin_define
define|#
directive|define
name|CMD_SS
value|0x5353
end_define

begin_define
define|#
directive|define
name|CMD_OK
value|0x4f4b
end_define

begin_define
define|#
directive|define
name|CMD_ER
value|0x4552
end_define

begin_define
define|#
directive|define
name|CMD_NF
value|0x4e46
end_define

begin_define
define|#
directive|define
name|CMD_AB
value|0x4142
end_define

begin_define
define|#
directive|define
name|CMD_ED
value|0x4544
end_define

begin_define
define|#
directive|define
name|CMD_CE
value|0x4345
end_define

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|fa
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|irqtod
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|ready
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|fb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|cpd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|cdp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|ready
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|pon
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|irqtop
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|board_at
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|__GO32__
end_ifdef

begin_define
define|#
directive|define
name|SET_BYTE
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|{ char _buf = y;dosmemput(&_buf,1, x);}
end_define

begin_define
define|#
directive|define
name|SET_WORD
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|{ short _buf = y;dosmemput(&_buf,2, x);}
end_define

begin_define
define|#
directive|define
name|GET_BYTE
parameter_list|(
name|x
parameter_list|)
value|( dosmemget(x,1,&bb), bb)
end_define

begin_define
define|#
directive|define
name|GET_WORD
parameter_list|(
name|x
parameter_list|)
value|( dosmemget(x,2,&sb), sb)
end_define

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|bb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|short
name|sb
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* win32 */
end_comment

begin_define
define|#
directive|define
name|SET_BYTE
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|*(volatile unsigned char *)(x) = (y)
end_define

begin_define
define|#
directive|define
name|SET_WORD
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|*(volatile unsigned short *)(x) = (y)
end_define

begin_define
define|#
directive|define
name|GET_BYTE
parameter_list|(
name|x
parameter_list|)
value|(*(volatile unsigned char *)(x))
end_define

begin_define
define|#
directive|define
name|GET_WORD
parameter_list|(
name|x
parameter_list|)
value|(*(volatile unsigned short *)(x))
end_define

begin_define
define|#
directive|define
name|dosmemget
parameter_list|(
name|FROM
parameter_list|,
name|LEN
parameter_list|,
name|TO
parameter_list|)
value|memcpy ((void *)(TO), (void *)(FROM), (LEN))
end_define

begin_define
define|#
directive|define
name|dosmemput
parameter_list|(
name|FROM
parameter_list|,
name|LEN
parameter_list|,
name|TO
parameter_list|)
value|memcpy ((void *)(TO), (void *)(FROM), (LEN))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_struct
specifier|static
struct|struct
name|sw
block|{
name|int
name|sw
decl_stmt|;
name|int
name|addr
decl_stmt|;
block|}
name|sigs
index|[]
init|=
block|{
block|{
literal|0x14
block|,
literal|0xd0000
block|}
block|,
block|{
literal|0x15
block|,
literal|0xd4000
block|}
block|,
block|{
literal|0x16
block|,
literal|0xd8000
block|}
block|,
block|{
literal|0x17
block|,
literal|0xdc000
block|}
block|,
literal|0
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|get_ds_base
parameter_list|()
value|0
end_define

begin_function
specifier|static
name|int
name|e7000pc_init
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|try
decl_stmt|;
name|unsigned
name|long
name|dsbase
decl_stmt|;
name|dsbase
operator|=
name|get_ds_base
argument_list|()
expr_stmt|;
comment|/* Look around in memory for the board's signature */
for|for
control|(
name|try
operator|=
literal|0
init|;
name|sigs
index|[
name|try
index|]
operator|.
name|sw
condition|;
name|try
operator|++
control|)
block|{
name|int
name|val
decl_stmt|;
name|board_at
operator|=
name|sigs
index|[
name|try
index|]
operator|.
name|addr
operator|-
name|dsbase
expr_stmt|;
name|fa
operator|=
name|board_at
operator|+
name|OFF_FA
expr_stmt|;
name|fb
operator|=
name|board_at
operator|+
name|OFF_FB
expr_stmt|;
name|cpd
operator|=
name|board_at
operator|+
name|OFF_CPD
expr_stmt|;
name|cdp
operator|=
name|board_at
operator|+
name|OFF_CDP
expr_stmt|;
name|ready
operator|=
name|board_at
operator|+
name|OFF_READY
expr_stmt|;
name|pon
operator|=
name|board_at
operator|+
name|OFF_PON
expr_stmt|;
name|irqtop
operator|=
name|board_at
operator|+
name|OFF_IRQTOP
expr_stmt|;
name|irqtod
operator|=
name|board_at
operator|+
name|OFF_IRQTOD
expr_stmt|;
name|val
operator|=
name|GET_WORD
argument_list|(
name|ready
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
operator|(
literal|0xaaa0
operator||
name|sigs
index|[
name|try
index|]
operator|.
name|sw
operator|)
condition|)
block|{
if|if
condition|(
name|GET_WORD
argument_list|(
name|pon
argument_list|)
operator|&
literal|0xf
condition|)
block|{
name|SET_WORD
argument_list|(
name|fa
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SET_WORD
argument_list|(
name|fb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SET_WORD
argument_list|(
name|irqtop
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Disable interrupts from e7000 */
name|SET_WORD
argument_list|(
name|ready
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\nConnected to the E7000PC at address 0x%x\n"
argument_list|,
name|sigs
index|[
name|try
index|]
operator|.
name|addr
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|error
argument_list|(
literal|"The E7000 PC board is working, but the E7000 is turned off.\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|error
argument_list|(
literal|"GDB cannot connect to the E7000 PC board, check that it is installed\n\ and that the switch settings are correct.  Some other DOS programs can \n\ stop the board from working.  Try starting from a very minimal boot, \n\ perhaps you need to disable EMM386 over the region where the board has\n\ its I/O space, remove other unneeded cards, etc etc\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|pbuf_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pbuf_index
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return next byte from cdp.  If no more, then return -1.  */
end_comment

begin_function
specifier|static
name|int
name|e7000_get
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|char
name|pbuf
index|[
literal|1000
index|]
decl_stmt|;
name|char
name|tmp
index|[
literal|1000
index|]
decl_stmt|;
name|int
name|x
decl_stmt|;
if|if
condition|(
name|pbuf_index
operator|<
name|pbuf_size
condition|)
block|{
name|x
operator|=
name|pbuf
index|[
name|pbuf_index
operator|++
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|GET_WORD
argument_list|(
name|fb
argument_list|)
operator|&
literal|1
operator|)
condition|)
block|{
name|int
name|i
decl_stmt|;
name|pbuf_size
operator|=
name|GET_WORD
argument_list|(
name|cdp
operator|+
literal|2
argument_list|)
expr_stmt|;
name|dosmemget
argument_list|(
name|cdp
operator|+
literal|8
argument_list|,
name|pbuf_size
operator|+
literal|1
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* Tell the E7000 we've eaten */
name|SET_WORD
argument_list|(
name|fb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Swap it around */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pbuf_size
condition|;
name|i
operator|++
control|)
block|{
name|pbuf
index|[
name|i
index|]
operator|=
name|tmp
index|[
name|i
operator|^
literal|1
index|]
expr_stmt|;
block|}
name|pbuf_index
operator|=
literal|0
expr_stmt|;
name|x
operator|=
name|pbuf
index|[
name|pbuf_index
operator|++
index|]
expr_stmt|;
block|}
else|else
block|{
name|x
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* Works just like read(), except that it takes a TIMEOUT in seconds.  Note    that TIMEOUT == 0 is a poll, and TIMEOUT == -1 means wait forever. */
end_comment

begin_function
specifier|static
name|int
name|dosasync_read
parameter_list|(
name|int
name|fd
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|long
name|now
decl_stmt|;
name|long
name|then
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
comment|/* Then look for some more if we're still hungry */
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|then
operator|=
name|now
operator|+
name|timeout
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|len
condition|)
block|{
name|int
name|ch
init|=
name|e7000_get
argument_list|()
decl_stmt|;
comment|/* While there's room in the buffer, and we've already          read the stuff in, suck it over */
if|if
condition|(
name|ch
operator|!=
operator|-
literal|1
condition|)
block|{
name|buf
index|[
name|i
operator|++
index|]
operator|=
name|ch
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|len
operator|&&
name|pbuf_index
operator|<
name|pbuf_size
condition|)
block|{
name|ch
operator|=
name|e7000_get
argument_list|()
expr_stmt|;
if|if
condition|(
name|ch
operator|==
operator|-
literal|1
condition|)
break|break;
name|buf
index|[
name|i
operator|++
index|]
operator|=
name|ch
expr_stmt|;
block|}
block|}
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|timeout
operator|==
literal|0
condition|)
return|return
name|i
return|;
if|if
condition|(
name|now
operator|>=
name|then
operator|&&
name|timeout
operator|>
literal|0
condition|)
block|{
return|return
name|i
return|;
block|}
block|}
return|return
name|len
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dosasync_write
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
name|dummy
index|[
literal|1000
index|]
decl_stmt|;
comment|/* Construct copy locally */
operator|(
operator|(
name|short
operator|*
operator|)
name|dummy
operator|)
index|[
literal|0
index|]
operator|=
name|CMD_CI
expr_stmt|;
operator|(
operator|(
name|short
operator|*
operator|)
name|dummy
operator|)
index|[
literal|1
index|]
operator|=
name|len
expr_stmt|;
operator|(
operator|(
name|short
operator|*
operator|)
name|dummy
operator|)
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
operator|(
operator|(
name|short
operator|*
operator|)
name|dummy
operator|)
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|dummy
index|[
operator|(
literal|8
operator|+
name|i
operator|)
operator|^
literal|1
index|]
operator|=
name|buf
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/* Wait for the card to get ready */
while|while
condition|(
name|GET_WORD
argument_list|(
name|fa
argument_list|)
operator|&
literal|1
condition|)
empty_stmt|;
comment|/* Blast onto the ISA card */
name|dosmemput
argument_list|(
name|dummy
argument_list|,
literal|8
operator|+
name|len
operator|+
literal|1
argument_list|,
name|cpd
argument_list|)
expr_stmt|;
name|SET_WORD
argument_list|(
name|fa
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SET_WORD
argument_list|(
name|irqtod
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Interrupt the E7000 */
return|return
name|len
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|e7000pc_open
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|strncasecmp
argument_list|(
name|name
argument_list|,
literal|"pc"
argument_list|,
literal|2
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|errno
operator|=
name|ENOENT
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|scb
operator|->
name|fd
operator|=
name|e7000pc_init
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|scb
operator|->
name|fd
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|e7000pc_noop
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|e7000pc_raw
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|)
block|{
comment|/* Always in raw mode */
block|}
end_function

begin_function
specifier|static
name|int
name|e7000pc_readchar
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|char
name|buf
decl_stmt|;
name|top
label|:
if|if
condition|(
name|dosasync_read
argument_list|(
name|scb
operator|->
name|fd
argument_list|,
operator|&
name|buf
argument_list|,
literal|1
argument_list|,
name|timeout
argument_list|)
condition|)
block|{
if|if
condition|(
name|buf
operator|==
literal|0
condition|)
goto|goto
name|top
goto|;
return|return
name|buf
return|;
block|}
else|else
return|return
name|SERIAL_TIMEOUT
return|;
block|}
end_function

begin_struct
struct|struct
name|e7000pc_ttystate
block|{
name|int
name|dummy
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* e7000pc_{get set}_tty_state() are both dummys to fill out the function    vector.  Someday, they may do something real... */
end_comment

begin_function
specifier|static
name|serial_ttystate
name|e7000pc_get_tty_state
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|)
block|{
name|struct
name|e7000pc_ttystate
modifier|*
name|state
decl_stmt|;
name|state
operator|=
operator|(
expr|struct
name|e7000pc_ttystate
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|state
argument_list|)
expr_stmt|;
return|return
operator|(
name|serial_ttystate
operator|)
name|state
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|e7000pc_set_tty_state
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|,
name|serial_ttystate
name|ttystate
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|e7000pc_noflush_set_tty_state
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|,
name|serial_ttystate
name|new_ttystate
parameter_list|,
name|serial_ttystate
name|old_ttystate
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|e7000pc_print_tty_state
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|,
name|serial_ttystate
name|ttystate
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|)
block|{
comment|/* Nothing to print.  */
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|e7000pc_setbaudrate
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|,
name|int
name|rate
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|e7000pc_setstopbits
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|,
name|int
name|rate
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|e7000pc_write
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|dosasync_write
argument_list|(
name|scb
operator|->
name|fd
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|e7000pc_close
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|)
block|{ }
end_function

begin_decl_stmt
specifier|static
name|struct
name|serial_ops
name|e7000pc_ops
init|=
block|{
literal|"pc"
block|,
literal|0
block|,
name|e7000pc_open
block|,
name|e7000pc_close
block|,
name|e7000pc_readchar
block|,
name|e7000pc_write
block|,
name|e7000pc_noop
block|,
comment|/* flush output */
name|e7000pc_noop
block|,
comment|/* flush input */
name|e7000pc_noop
block|,
comment|/* send break -- currently used only for nindy */
name|e7000pc_raw
block|,
name|e7000pc_get_tty_state
block|,
name|e7000pc_set_tty_state
block|,
name|e7000pc_print_tty_state
block|,
name|e7000pc_noflush_set_tty_state
block|,
name|e7000pc_setbaudrate
block|,
name|e7000pc_setstopbits
block|,
name|e7000pc_noop
block|,
comment|/* wait for output to drain */
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*_WIN32 or __GO32__*/
end_comment

begin_decl_stmt
specifier|extern
name|initialize_file_ftype
name|_initialize_ser_e7000pc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -Wmissing-prototypes */
end_comment

begin_function
name|void
name|_initialize_ser_e7000pc
parameter_list|(
name|void
parameter_list|)
block|{
if|#
directive|if
name|defined
name|__GO32__
operator|||
name|defined
name|_WIN32
name|serial_add_interface
argument_list|(
operator|&
name|e7000pc_ops
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

end_unit

