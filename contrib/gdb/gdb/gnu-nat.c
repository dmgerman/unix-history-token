begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Interface GDB to the GNU Hurd    Copyright (C) 1992, 1995, 1996 Free Software Foundation, Inc.     This file is part of GDB.     Written by Miles Bader<miles@gnu.ai.mit.edu>     Some code and ideas from m3-nat.c by Jukka Virtanen<jtv@hut.fi>     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/ptrace.h>
end_include

begin_comment
comment|/* We include this because we don't need the access macros and they conflict    with gdb's definitions (ick).  This is very non standard!  */
end_comment

begin_include
include|#
directive|include
file|<waitflags.h>
end_include

begin_include
include|#
directive|include
file|<mach.h>
end_include

begin_include
include|#
directive|include
file|<mach/message.h>
end_include

begin_include
include|#
directive|include
file|<mach/notify.h>
end_include

begin_include
include|#
directive|include
file|<mach_error.h>
end_include

begin_include
include|#
directive|include
file|<mach/exception.h>
end_include

begin_include
include|#
directive|include
file|<mach/vm_attributes.h>
end_include

begin_include
include|#
directive|include
file|<hurd/process.h>
end_include

begin_include
include|#
directive|include
file|<hurd/process_request.h>
end_include

begin_include
include|#
directive|include
file|<hurd/msg.h>
end_include

begin_include
include|#
directive|include
file|<hurd/msg_request.h>
end_include

begin_include
include|#
directive|include
file|<hurd/signal.h>
end_include

begin_include
include|#
directive|include
file|<hurd/interrupt.h>
end_include

begin_include
include|#
directive|include
file|<hurd/sigpreempt.h>
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"wait.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"gnu-nat.h"
end_include

begin_include
include|#
directive|include
file|"exc_request_S.h"
end_include

begin_include
include|#
directive|include
file|"notify_S.h"
end_include

begin_include
include|#
directive|include
file|"process_reply_S.h"
end_include

begin_include
include|#
directive|include
file|"msg_reply_S.h"
end_include

begin_include
include|#
directive|include
file|"exc_request_U.h"
end_include

begin_include
include|#
directive|include
file|"msg_U.h"
end_include

begin_decl_stmt
specifier|static
name|process_t
name|proc_server
init|=
name|MACH_PORT_NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If we've sent a proc_wait_request to the proc server, the pid of the    process we asked about.  We can only ever have one outstanding.  */
end_comment

begin_decl_stmt
name|int
name|proc_wait_pid
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of wait requests we've sent, and expect replies from.  */
end_comment

begin_decl_stmt
name|int
name|proc_waits_pending
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|gnu_debug_flag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward decls */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|target_ops
name|gnu_ops
decl_stmt|;
end_decl_stmt

begin_function_decl
name|struct
name|inf
modifier|*
name|make_inf
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|inf_clear_wait
parameter_list|(
name|struct
name|inf
modifier|*
name|inf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|inf_cleanup
parameter_list|(
name|struct
name|inf
modifier|*
name|inf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|inf_startup
parameter_list|(
name|struct
name|inf
modifier|*
name|inf
parameter_list|,
name|int
name|pid
parameter_list|,
name|task_t
name|task
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|inf_update_suspends
parameter_list|(
name|struct
name|inf
modifier|*
name|inf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|inf_set_task
parameter_list|(
name|struct
name|inf
modifier|*
name|inf
parameter_list|,
name|task_t
name|port
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|inf_validate_procs
parameter_list|(
name|struct
name|inf
modifier|*
name|inf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|inf_steal_exc_ports
parameter_list|(
name|struct
name|inf
modifier|*
name|inf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|inf_restore_exc_ports
parameter_list|(
name|struct
name|inf
modifier|*
name|inf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|inf_update_procs
parameter_list|(
name|struct
name|inf
modifier|*
name|inf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|proc
modifier|*
name|inf_tid_to_proc
parameter_list|(
name|struct
name|inf
modifier|*
name|inf
parameter_list|,
name|int
name|tid
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|inline
name|void
name|inf_set_threads_resume_sc
parameter_list|(
name|struct
name|inf
modifier|*
name|inf
parameter_list|,
name|struct
name|proc
modifier|*
name|run_thread
parameter_list|,
name|int
name|run_others
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|inline
name|int
name|inf_set_threads_resume_sc_for_signal_thread
parameter_list|(
name|struct
name|inf
modifier|*
name|inf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|inline
name|void
name|inf_suspend
parameter_list|(
name|struct
name|inf
modifier|*
name|inf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|inline
name|void
name|inf_resume
parameter_list|(
name|struct
name|inf
modifier|*
name|inf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|inf_set_step_thread
parameter_list|(
name|struct
name|inf
modifier|*
name|inf
parameter_list|,
name|struct
name|proc
modifier|*
name|proc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|inf_detach
parameter_list|(
name|struct
name|inf
modifier|*
name|inf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|inf_attach
parameter_list|(
name|struct
name|inf
modifier|*
name|inf
parameter_list|,
name|int
name|pid
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|inf_signal
parameter_list|(
name|struct
name|inf
modifier|*
name|inf
parameter_list|,
name|enum
name|target_signal
name|sig
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|inf_debug
parameter_list|(
name|_inf
parameter_list|,
name|msg
parameter_list|,
name|args
modifier|...
parameter_list|)
define|\
value|do { struct inf *__inf = (_inf); \        debug ("{inf %d %p}: " msg, __inf->pid, __inf , ##args); } while (0)
end_define

begin_function_decl
name|struct
name|proc
modifier|*
name|make_proc
parameter_list|(
name|struct
name|inf
modifier|*
name|inf
parameter_list|,
name|mach_port_t
name|port
parameter_list|,
name|int
name|tid
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|proc
modifier|*
name|_proc_free
parameter_list|(
name|struct
name|proc
modifier|*
name|proc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|proc_update_sc
parameter_list|(
name|struct
name|proc
modifier|*
name|proc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|proc_abort
parameter_list|(
name|struct
name|proc
modifier|*
name|proc
parameter_list|,
name|int
name|force
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|thread_state_t
name|proc_get_state
parameter_list|(
name|struct
name|proc
modifier|*
name|proc
parameter_list|,
name|int
name|force
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|error_t
name|proc_get_exception_port
parameter_list|(
name|struct
name|proc
modifier|*
name|proc
parameter_list|,
name|mach_port_t
modifier|*
name|port
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|error_t
name|proc_set_exception_port
parameter_list|(
name|struct
name|proc
modifier|*
name|proc
parameter_list|,
name|mach_port_t
name|port
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|mach_port_t
name|_proc_get_exc_port
parameter_list|(
name|struct
name|proc
modifier|*
name|proc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|proc_steal_exc_port
parameter_list|(
name|struct
name|proc
modifier|*
name|proc
parameter_list|,
name|mach_port_t
name|exc_port
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|proc_restore_exc_port
parameter_list|(
name|struct
name|proc
modifier|*
name|proc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|proc_trace
parameter_list|(
name|struct
name|proc
modifier|*
name|proc
parameter_list|,
name|int
name|set
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|proc_string
parameter_list|(
name|struct
name|proc
modifier|*
name|proc
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Evaluate RPC_EXPR in a scope with the variables MSGPORT and REFPORT bound    to INF's msg port and task port respectively.  If it has no msg port,    EIEIO is returned.  INF must refer to a running process!  */
end_comment

begin_define
define|#
directive|define
name|INF_MSGPORT_RPC
parameter_list|(
name|inf
parameter_list|,
name|rpc_expr
parameter_list|)
define|\
value|HURD_MSGPORT_RPC (proc_getmsgport (proc_server, inf->pid,&msgport), \ 		    (refport = inf->task->port, 0), 0, \ 		    msgport ? (rpc_expr) : EIEIO)
end_define

begin_comment
comment|/* Like INF_MSGPORT_RPC, but will also resume the signal thread to ensure    there's someone around to deal with the RPC (and resuspend things    afterwards).  This effects INF's threads' resume_sc count.  */
end_comment

begin_define
define|#
directive|define
name|INF_RESUME_MSGPORT_RPC
parameter_list|(
name|inf
parameter_list|,
name|rpc_expr
parameter_list|)
define|\
value|(inf_set_threads_resume_sc_for_signal_thread (inf) \    ? ({ error_t __e; \ 	inf_resume (inf); \ 	__e = INF_MSGPORT_RPC (inf, rpc_expr); \ 	inf_suspend (inf); \ 	__e; }) \    : EIEIO)
end_define

begin_define
define|#
directive|define
name|MIG_SERVER_DIED
value|EMIG_SERVER_DIED
end_define

begin_comment
comment|/* XXX */
end_comment

begin_escape
end_escape

begin_comment
comment|/* The state passed by an exception message.  */
end_comment

begin_struct
struct|struct
name|exc_state
block|{
name|int
name|exception
decl_stmt|;
comment|/* The exception code */
name|int
name|code
decl_stmt|,
name|subcode
decl_stmt|;
name|mach_port_t
name|handler
decl_stmt|;
comment|/* The real exception port to handle this. */
name|mach_port_t
name|reply
decl_stmt|;
comment|/* The reply port from the exception call. */
block|}
struct|;
end_struct

begin_comment
comment|/* The results of the last wait an inf did. */
end_comment

begin_struct
struct|struct
name|inf_wait
block|{
name|struct
name|target_waitstatus
name|status
decl_stmt|;
comment|/* The status returned to gdb.  */
name|struct
name|exc_state
name|exc
decl_stmt|;
comment|/* The exception that caused us to return. */
name|struct
name|proc
modifier|*
name|thread
decl_stmt|;
comment|/* The thread in question.  */
name|int
name|suppress
decl_stmt|;
comment|/* Something trivial happened.  */
block|}
struct|;
end_struct

begin_comment
comment|/* The state of an inferior.  */
end_comment

begin_struct
struct|struct
name|inf
block|{
comment|/* Fields describing the current inferior.  */
name|struct
name|proc
modifier|*
name|task
decl_stmt|;
comment|/* The mach task.   */
name|struct
name|proc
modifier|*
name|threads
decl_stmt|;
comment|/* A linked list of all threads in TASK.  */
comment|/* True if THREADS needn't be validated by querying the task.  We assume that      we and the task in question are the only ones frobbing the thread list,      so as long as we don't let any code run, we don't have to worry about      THREADS changing.  */
name|int
name|threads_up_to_date
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
comment|/* The real system PID. */
name|struct
name|inf_wait
name|wait
decl_stmt|;
comment|/* What to return from target_wait.  */
comment|/* One thread proc in INF may be in `single-stepping mode'.  This is it.  */
name|struct
name|proc
modifier|*
name|step_thread
decl_stmt|;
comment|/* The thread we think is the signal thread.  */
name|struct
name|proc
modifier|*
name|signal_thread
decl_stmt|;
name|mach_port_t
name|event_port
decl_stmt|;
comment|/* Where we receive various msgs.  */
comment|/* True if we think at least one thread in the inferior could currently be      running.  */
name|int
name|running
range|:
literal|1
decl_stmt|;
comment|/* True if the process has stopped (in the proc server sense).  Note that      since a proc server `stop' leaves the signal thread running, the inf can      be RUNNING&& STOPPED...  */
name|int
name|stopped
range|:
literal|1
decl_stmt|;
comment|/* True if the inferior is traced.  */
name|int
name|traced
range|:
literal|1
decl_stmt|;
comment|/* True if we shouldn't try waiting for the inferior, usually because we      can't for some reason.  */
name|int
name|no_wait
range|:
literal|1
decl_stmt|;
comment|/* When starting a new inferior, we don't try to validate threads until all      the proper execs have been done.  This is a count of how many execs we      expect to happen.  */
name|unsigned
name|pending_execs
decl_stmt|;
comment|/* Fields describing global state */
comment|/* The task suspend count used when gdb has control.  This is normally 1 to      make things easier for us, but sometimes (like when attaching to vital      system servers) it may be desirable to let the task continue to run      (pausing individual threads as necessary).  */
name|int
name|pause_sc
decl_stmt|;
comment|/* The initial values used for the run_sc and pause_sc of newly discovered      threads -- see the definition of those fields in struct proc.  */
name|int
name|default_thread_run_sc
decl_stmt|;
name|int
name|default_thread_pause_sc
decl_stmt|;
comment|/* True if the process should be traced when started/attached.  Newly      started processes *must* be traced at first to exec them properly, but      if this is false, tracing is turned off as soon it has done so.  */
name|int
name|want_signals
decl_stmt|;
comment|/* True if exceptions from the inferior process should be trapped.  This      must be on to use breakpoints.  */
name|int
name|want_exceptions
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|int
name|__proc_pid
parameter_list|(
name|struct
name|proc
modifier|*
name|proc
parameter_list|)
block|{
return|return
name|proc
operator|->
name|inf
operator|->
name|pid
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Update PROC's real suspend count to match it's desired one.  Returns true    if we think PROC is now in a runnable state.  */
end_comment

begin_function
name|int
name|proc_update_sc
parameter_list|(
name|struct
name|proc
modifier|*
name|proc
parameter_list|)
block|{
name|int
name|running
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|int
name|delta
init|=
name|proc
operator|->
name|sc
operator|-
name|proc
operator|->
name|cur_sc
decl_stmt|;
if|if
condition|(
name|delta
condition|)
name|proc_debug
argument_list|(
name|proc
argument_list|,
literal|"sc: %d --> %d"
argument_list|,
name|proc
operator|->
name|cur_sc
argument_list|,
name|proc
operator|->
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|proc
operator|->
name|sc
operator|==
literal|0
operator|&&
name|proc
operator|->
name|state_changed
condition|)
comment|/* Since PROC may start running, we must write back any state changes. */
block|{
name|assert
argument_list|(
name|proc_is_thread
argument_list|(
name|proc
argument_list|)
argument_list|)
expr_stmt|;
name|proc_debug
argument_list|(
name|proc
argument_list|,
literal|"storing back changed thread state"
argument_list|)
expr_stmt|;
name|err
operator|=
name|thread_set_state
argument_list|(
name|proc
operator|->
name|port
argument_list|,
name|THREAD_STATE_FLAVOR
argument_list|,
operator|&
name|proc
operator|->
name|state
argument_list|,
name|THREAD_STATE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
name|proc
operator|->
name|state_changed
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|delta
operator|>
literal|0
condition|)
while|while
condition|(
name|delta
operator|--
operator|>
literal|0
operator|&&
operator|!
name|err
condition|)
if|if
condition|(
name|proc_is_task
argument_list|(
name|proc
argument_list|)
condition|)
name|err
operator|=
name|task_suspend
argument_list|(
name|proc
operator|->
name|port
argument_list|)
expr_stmt|;
else|else
name|err
operator|=
name|thread_suspend
argument_list|(
name|proc
operator|->
name|port
argument_list|)
expr_stmt|;
else|else
while|while
condition|(
name|delta
operator|++
operator|<
literal|0
operator|&&
operator|!
name|err
condition|)
if|if
condition|(
name|proc_is_task
argument_list|(
name|proc
argument_list|)
condition|)
name|err
operator|=
name|task_resume
argument_list|(
name|proc
operator|->
name|port
argument_list|)
expr_stmt|;
else|else
name|err
operator|=
name|thread_resume
argument_list|(
name|proc
operator|->
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
name|proc
operator|->
name|cur_sc
operator|=
name|proc
operator|->
name|sc
expr_stmt|;
comment|/* If we got an error, then the task/thread has disappeared.  */
name|running
operator|=
operator|!
name|err
operator|&&
name|proc
operator|->
name|sc
operator|==
literal|0
expr_stmt|;
name|proc_debug
argument_list|(
name|proc
argument_list|,
literal|"is %s"
argument_list|,
name|err
condition|?
literal|"dead"
else|:
name|running
condition|?
literal|"running"
else|:
literal|"suspended"
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|proc_debug
argument_list|(
name|proc
argument_list|,
literal|"err = %s"
argument_list|,
name|strerror
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|running
condition|)
block|{
name|proc
operator|->
name|aborted
operator|=
literal|0
expr_stmt|;
name|proc
operator|->
name|state_valid
operator|=
name|proc
operator|->
name|state_changed
operator|=
literal|0
expr_stmt|;
name|proc
operator|->
name|fetched_regs
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|running
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Thread_abort is called on PROC if needed.  PROC must be a thread proc.    If PROC is deemed `precious', then nothing is done unless FORCE is true.    In particular, a thread is precious if it's running (in which case forcing    it includes suspending it first), or if it has an exception pending.  */
end_comment

begin_function
name|void
name|proc_abort
parameter_list|(
name|struct
name|proc
modifier|*
name|proc
parameter_list|,
name|int
name|force
parameter_list|)
block|{
name|assert
argument_list|(
name|proc_is_thread
argument_list|(
name|proc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|proc
operator|->
name|aborted
condition|)
block|{
name|struct
name|inf
modifier|*
name|inf
init|=
name|proc
operator|->
name|inf
decl_stmt|;
name|int
name|running
init|=
operator|(
name|proc
operator|->
name|cur_sc
operator|==
literal|0
operator|&&
name|inf
operator|->
name|task
operator|->
name|cur_sc
operator|==
literal|0
operator|)
decl_stmt|;
if|if
condition|(
name|running
operator|&&
name|force
condition|)
block|{
name|proc
operator|->
name|sc
operator|=
literal|1
expr_stmt|;
name|inf_update_suspends
argument_list|(
name|proc
operator|->
name|inf
argument_list|)
expr_stmt|;
name|running
operator|=
literal|0
expr_stmt|;
name|warning
argument_list|(
literal|"Stopped %s."
argument_list|,
name|proc_string
argument_list|(
name|proc
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|proc
operator|==
name|inf
operator|->
name|wait
operator|.
name|thread
operator|&&
name|inf
operator|->
name|wait
operator|.
name|exc
operator|.
name|reply
operator|&&
operator|!
name|force
condition|)
comment|/* An exception is pending on PROC, which don't mess with.  */
name|running
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|running
condition|)
comment|/* We only abort the thread if it's not actually running.  */
block|{
name|thread_abort
argument_list|(
name|proc
operator|->
name|port
argument_list|)
expr_stmt|;
name|proc_debug
argument_list|(
name|proc
argument_list|,
literal|"aborted"
argument_list|)
expr_stmt|;
name|proc
operator|->
name|aborted
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|proc_debug
argument_list|(
name|proc
argument_list|,
literal|"not aborting"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Make sure that the state field in PROC is up to date, and return a pointer    to it, or 0 if something is wrong.  If WILL_MODIFY is true, makes sure    that the thread is stopped and aborted first, and sets the state_changed    field in PROC to true.  */
end_comment

begin_function
name|thread_state_t
name|proc_get_state
parameter_list|(
name|struct
name|proc
modifier|*
name|proc
parameter_list|,
name|int
name|will_modify
parameter_list|)
block|{
name|int
name|was_aborted
init|=
name|proc
operator|->
name|aborted
decl_stmt|;
name|proc_debug
argument_list|(
name|proc
argument_list|,
literal|"updating state info%s"
argument_list|,
name|will_modify
condition|?
literal|" (with intention to modify)"
else|:
literal|""
argument_list|)
expr_stmt|;
name|proc_abort
argument_list|(
name|proc
argument_list|,
name|will_modify
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|was_aborted
operator|&&
name|proc
operator|->
name|aborted
condition|)
comment|/* PROC's state may have changed since we last fetched it.  */
name|proc
operator|->
name|state_valid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|proc
operator|->
name|state_valid
condition|)
block|{
name|mach_msg_type_number_t
name|state_size
init|=
name|THREAD_STATE_SIZE
decl_stmt|;
name|error_t
name|err
init|=
name|thread_get_state
argument_list|(
name|proc
operator|->
name|port
argument_list|,
name|THREAD_STATE_FLAVOR
argument_list|,
operator|&
name|proc
operator|->
name|state
argument_list|,
operator|&
name|state_size
argument_list|)
decl_stmt|;
name|proc_debug
argument_list|(
name|proc
argument_list|,
literal|"getting thread state"
argument_list|)
expr_stmt|;
name|proc
operator|->
name|state_valid
operator|=
operator|!
name|err
expr_stmt|;
block|}
if|if
condition|(
name|proc
operator|->
name|state_valid
condition|)
block|{
if|if
condition|(
name|will_modify
condition|)
name|proc
operator|->
name|state_changed
operator|=
literal|1
expr_stmt|;
return|return
operator|&
name|proc
operator|->
name|state
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|error_t
name|proc_get_exception_port
parameter_list|(
name|struct
name|proc
modifier|*
name|proc
parameter_list|,
name|mach_port_t
modifier|*
name|port
parameter_list|)
block|{
if|if
condition|(
name|proc_is_task
argument_list|(
name|proc
argument_list|)
condition|)
return|return
name|task_get_exception_port
argument_list|(
name|proc
operator|->
name|port
argument_list|,
name|port
argument_list|)
return|;
else|else
return|return
name|thread_get_exception_port
argument_list|(
name|proc
operator|->
name|port
argument_list|,
name|port
argument_list|)
return|;
block|}
end_function

begin_function
name|error_t
name|proc_set_exception_port
parameter_list|(
name|struct
name|proc
modifier|*
name|proc
parameter_list|,
name|mach_port_t
name|port
parameter_list|)
block|{
name|proc_debug
argument_list|(
name|proc
argument_list|,
literal|"setting exception port: %d"
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|proc_is_task
argument_list|(
name|proc
argument_list|)
condition|)
return|return
name|task_set_exception_port
argument_list|(
name|proc
operator|->
name|port
argument_list|,
name|port
argument_list|)
return|;
else|else
return|return
name|thread_set_exception_port
argument_list|(
name|proc
operator|->
name|port
argument_list|,
name|port
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Get PROC's exception port, cleaning up a bit if proc has died.  */
end_comment

begin_function
specifier|static
name|mach_port_t
name|_proc_get_exc_port
parameter_list|(
name|struct
name|proc
modifier|*
name|proc
parameter_list|)
block|{
name|mach_port_t
name|exc_port
decl_stmt|;
name|error_t
name|err
init|=
name|proc_get_exception_port
argument_list|(
name|proc
argument_list|,
operator|&
name|exc_port
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
condition|)
comment|/* PROC must be dead.  */
block|{
if|if
condition|(
name|proc
operator|->
name|exc_port
condition|)
name|mach_port_deallocate
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
name|proc
operator|->
name|exc_port
argument_list|)
expr_stmt|;
name|proc
operator|->
name|exc_port
operator|=
name|MACH_PORT_NULL
expr_stmt|;
if|if
condition|(
name|proc
operator|->
name|saved_exc_port
condition|)
name|mach_port_deallocate
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
name|proc
operator|->
name|saved_exc_port
argument_list|)
expr_stmt|;
name|proc
operator|->
name|saved_exc_port
operator|=
name|MACH_PORT_NULL
expr_stmt|;
block|}
return|return
name|exc_port
return|;
block|}
end_function

begin_comment
comment|/* Replace PROC's exception port with EXC_PORT, unless it's already been    done.  Stash away any existing exception port so we can restore it later. */
end_comment

begin_function
name|void
name|proc_steal_exc_port
parameter_list|(
name|struct
name|proc
modifier|*
name|proc
parameter_list|,
name|mach_port_t
name|exc_port
parameter_list|)
block|{
name|mach_port_t
name|cur_exc_port
init|=
name|_proc_get_exc_port
argument_list|(
name|proc
argument_list|)
decl_stmt|;
if|if
condition|(
name|cur_exc_port
condition|)
block|{
name|error_t
name|err
decl_stmt|;
name|proc_debug
argument_list|(
name|proc
argument_list|,
literal|"inserting exception port: %d"
argument_list|,
name|exc_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_exc_port
operator|!=
name|exc_port
condition|)
comment|/* Put in our exception port.  */
name|err
operator|=
name|proc_set_exception_port
argument_list|(
name|proc
argument_list|,
name|exc_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|||
name|cur_exc_port
operator|==
name|proc
operator|->
name|exc_port
condition|)
comment|/* We previously set the exception port, and it's still set.  So we 	   just keep the old saved port which is what the proc set.  */
block|{
if|if
condition|(
name|cur_exc_port
condition|)
name|mach_port_deallocate
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
name|cur_exc_port
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Keep a copy of PROC's old exception port so it can be restored. */
block|{
if|if
condition|(
name|proc
operator|->
name|saved_exc_port
condition|)
name|mach_port_deallocate
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
name|proc
operator|->
name|saved_exc_port
argument_list|)
expr_stmt|;
name|proc
operator|->
name|saved_exc_port
operator|=
name|cur_exc_port
expr_stmt|;
block|}
name|proc_debug
argument_list|(
name|proc
argument_list|,
literal|"saved exception port: %d"
argument_list|,
name|proc
operator|->
name|saved_exc_port
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
name|proc
operator|->
name|exc_port
operator|=
name|exc_port
expr_stmt|;
else|else
name|warning
argument_list|(
literal|"Error setting exception port for %s: %s"
argument_list|,
name|proc_string
argument_list|(
name|proc
argument_list|)
argument_list|,
name|strerror
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* If we previously replaced PROC's exception port, put back what we found    there at the time, unless *our* exception port has since be overwritten,    in which case who knows what's going on.  */
end_comment

begin_function
name|void
name|proc_restore_exc_port
parameter_list|(
name|struct
name|proc
modifier|*
name|proc
parameter_list|)
block|{
name|mach_port_t
name|cur_exc_port
init|=
name|_proc_get_exc_port
argument_list|(
name|proc
argument_list|)
decl_stmt|;
if|if
condition|(
name|cur_exc_port
condition|)
block|{
name|error_t
name|err
init|=
literal|0
decl_stmt|;
name|proc_debug
argument_list|(
name|proc
argument_list|,
literal|"restoring real exception port"
argument_list|)
expr_stmt|;
if|if
condition|(
name|proc
operator|->
name|exc_port
operator|==
name|cur_exc_port
condition|)
comment|/* Our's is still there.  */
name|err
operator|=
name|proc_set_exception_port
argument_list|(
name|proc
argument_list|,
name|proc
operator|->
name|saved_exc_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|proc
operator|->
name|saved_exc_port
condition|)
name|mach_port_deallocate
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
name|proc
operator|->
name|saved_exc_port
argument_list|)
expr_stmt|;
name|proc
operator|->
name|saved_exc_port
operator|=
name|MACH_PORT_NULL
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
name|proc
operator|->
name|exc_port
operator|=
name|MACH_PORT_NULL
expr_stmt|;
else|else
name|warning
argument_list|(
literal|"Error setting exception port for %s: %s"
argument_list|,
name|proc_string
argument_list|(
name|proc
argument_list|)
argument_list|,
name|strerror
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Turns hardware tracing in PROC on or off when SET is true or fals,    respectively.  Returns true on success.  */
end_comment

begin_function
name|int
name|proc_trace
parameter_list|(
name|struct
name|proc
modifier|*
name|proc
parameter_list|,
name|int
name|set
parameter_list|)
block|{
name|thread_state_t
name|state
init|=
name|proc_get_state
argument_list|(
name|proc
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|state
condition|)
return|return
literal|0
return|;
comment|/* the thread must be dead.  */
name|proc_debug
argument_list|(
name|proc
argument_list|,
literal|"tracing %s"
argument_list|,
name|set
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
condition|)
block|{
comment|/* XXX We don't get the exception unless the thread has its own 	 exception port???? */
if|if
condition|(
name|proc
operator|->
name|exc_port
operator|==
name|MACH_PORT_NULL
condition|)
name|proc_steal_exc_port
argument_list|(
name|proc
argument_list|,
name|proc
operator|->
name|inf
operator|->
name|event_port
argument_list|)
expr_stmt|;
name|THREAD_STATE_SET_TRACED
argument_list|(
name|state
argument_list|)
expr_stmt|;
block|}
else|else
name|THREAD_STATE_CLEAR_TRACED
argument_list|(
name|state
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A variable from which to assign new TIDs.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|next_thread_id
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Returns a new proc structure with the given fields.  Also adds a    notification for PORT becoming dead to be sent to INF's notify port.  */
end_comment

begin_function
name|struct
name|proc
modifier|*
name|make_proc
parameter_list|(
name|struct
name|inf
modifier|*
name|inf
parameter_list|,
name|mach_port_t
name|port
parameter_list|,
name|int
name|tid
parameter_list|)
block|{
name|error_t
name|err
decl_stmt|;
name|mach_port_t
name|prev_port
init|=
name|MACH_PORT_NULL
decl_stmt|;
name|struct
name|proc
modifier|*
name|proc
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|proc
argument_list|)
argument_list|)
decl_stmt|;
name|proc
operator|->
name|port
operator|=
name|port
expr_stmt|;
name|proc
operator|->
name|tid
operator|=
name|tid
expr_stmt|;
name|proc
operator|->
name|inf
operator|=
name|inf
expr_stmt|;
name|proc
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|proc
operator|->
name|saved_exc_port
operator|=
name|MACH_PORT_NULL
expr_stmt|;
name|proc
operator|->
name|exc_port
operator|=
name|MACH_PORT_NULL
expr_stmt|;
name|proc
operator|->
name|sc
operator|=
literal|0
expr_stmt|;
name|proc
operator|->
name|cur_sc
operator|=
literal|0
expr_stmt|;
name|proc
operator|->
name|run_sc
operator|=
name|inf
operator|->
name|default_thread_run_sc
expr_stmt|;
name|proc
operator|->
name|pause_sc
operator|=
name|inf
operator|->
name|default_thread_pause_sc
expr_stmt|;
name|proc
operator|->
name|resume_sc
operator|=
name|proc
operator|->
name|run_sc
expr_stmt|;
name|proc
operator|->
name|aborted
operator|=
literal|0
expr_stmt|;
name|proc
operator|->
name|state_valid
operator|=
literal|0
expr_stmt|;
name|proc
operator|->
name|state_changed
operator|=
literal|0
expr_stmt|;
name|proc_debug
argument_list|(
name|proc
argument_list|,
literal|"is new"
argument_list|)
expr_stmt|;
comment|/* Get notified when things die.  */
name|err
operator|=
name|mach_port_request_notification
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
name|port
argument_list|,
name|MACH_NOTIFY_DEAD_NAME
argument_list|,
literal|1
argument_list|,
name|inf
operator|->
name|event_port
argument_list|,
name|MACH_MSG_TYPE_MAKE_SEND_ONCE
argument_list|,
operator|&
name|prev_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|warning
argument_list|(
literal|"Couldn't request notification for port %d: %s"
argument_list|,
name|port
argument_list|,
name|strerror
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|proc_debug
argument_list|(
name|proc
argument_list|,
literal|"notifications to: %d"
argument_list|,
name|inf
operator|->
name|event_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev_port
operator|!=
name|MACH_PORT_NULL
condition|)
name|mach_port_deallocate
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
name|prev_port
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|inf
operator|->
name|want_exceptions
condition|)
if|if
condition|(
name|proc_is_task
argument_list|(
name|proc
argument_list|)
condition|)
comment|/* Make the task exception port point to us.  */
name|proc_steal_exc_port
argument_list|(
name|proc
argument_list|,
name|inf
operator|->
name|event_port
argument_list|)
expr_stmt|;
else|else
comment|/* Just clear thread exception ports -- they default to the task one.  */
name|proc_steal_exc_port
argument_list|(
name|proc
argument_list|,
name|MACH_PORT_NULL
argument_list|)
expr_stmt|;
return|return
name|proc
return|;
block|}
end_function

begin_comment
comment|/* Frees PROC and any resources it uses, and returns the value of PROC's next    field.  */
end_comment

begin_function
name|struct
name|proc
modifier|*
name|_proc_free
parameter_list|(
name|struct
name|proc
modifier|*
name|proc
parameter_list|)
block|{
name|struct
name|inf
modifier|*
name|inf
init|=
name|proc
operator|->
name|inf
decl_stmt|;
name|struct
name|proc
modifier|*
name|next
init|=
name|proc
operator|->
name|next
decl_stmt|;
name|proc_debug
argument_list|(
name|proc
argument_list|,
literal|"freeing..."
argument_list|)
expr_stmt|;
if|if
condition|(
name|proc
operator|==
name|inf
operator|->
name|step_thread
condition|)
comment|/* Turn off single stepping.  */
name|inf_set_step_thread
argument_list|(
name|inf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|proc
operator|==
name|inf
operator|->
name|wait
operator|.
name|thread
condition|)
name|inf_clear_wait
argument_list|(
name|inf
argument_list|)
expr_stmt|;
if|if
condition|(
name|proc
operator|==
name|inf
operator|->
name|signal_thread
condition|)
name|inf
operator|->
name|signal_thread
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|proc
operator|->
name|port
operator|!=
name|MACH_PORT_NULL
condition|)
block|{
if|if
condition|(
name|proc
operator|->
name|exc_port
operator|!=
name|MACH_PORT_NULL
condition|)
comment|/* Restore the original exception port.  */
name|proc_restore_exc_port
argument_list|(
name|proc
argument_list|)
expr_stmt|;
if|if
condition|(
name|proc
operator|->
name|cur_sc
operator|!=
literal|0
condition|)
comment|/* Resume the thread/task.  */
block|{
name|proc
operator|->
name|sc
operator|=
literal|0
expr_stmt|;
name|proc_update_sc
argument_list|(
name|proc
argument_list|)
expr_stmt|;
block|}
name|mach_port_deallocate
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
name|proc
operator|->
name|port
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|proc
argument_list|)
expr_stmt|;
return|return
name|next
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|struct
name|inf
modifier|*
name|make_inf
parameter_list|()
block|{
name|struct
name|inf
modifier|*
name|inf
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|inf
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|inf
condition|)
return|return
literal|0
return|;
name|inf
operator|->
name|task
operator|=
literal|0
expr_stmt|;
name|inf
operator|->
name|threads
operator|=
literal|0
expr_stmt|;
name|inf
operator|->
name|threads_up_to_date
operator|=
literal|0
expr_stmt|;
name|inf
operator|->
name|pid
operator|=
literal|0
expr_stmt|;
name|inf
operator|->
name|wait
operator|.
name|status
operator|.
name|kind
operator|=
name|TARGET_WAITKIND_SPURIOUS
expr_stmt|;
name|inf
operator|->
name|wait
operator|.
name|thread
operator|=
literal|0
expr_stmt|;
name|inf
operator|->
name|wait
operator|.
name|exc
operator|.
name|handler
operator|=
name|MACH_PORT_NULL
expr_stmt|;
name|inf
operator|->
name|wait
operator|.
name|exc
operator|.
name|reply
operator|=
name|MACH_PORT_NULL
expr_stmt|;
name|inf
operator|->
name|step_thread
operator|=
literal|0
expr_stmt|;
name|inf
operator|->
name|signal_thread
operator|=
literal|0
expr_stmt|;
name|inf
operator|->
name|event_port
operator|=
name|MACH_PORT_NULL
expr_stmt|;
name|inf
operator|->
name|stopped
operator|=
literal|0
expr_stmt|;
name|inf
operator|->
name|running
operator|=
literal|0
expr_stmt|;
name|inf
operator|->
name|traced
operator|=
literal|0
expr_stmt|;
name|inf
operator|->
name|no_wait
operator|=
literal|0
expr_stmt|;
name|inf
operator|->
name|pending_execs
operator|=
literal|0
expr_stmt|;
name|inf
operator|->
name|pause_sc
operator|=
literal|1
expr_stmt|;
name|inf
operator|->
name|default_thread_run_sc
operator|=
literal|0
expr_stmt|;
name|inf
operator|->
name|default_thread_pause_sc
operator|=
literal|0
expr_stmt|;
name|inf
operator|->
name|want_signals
operator|=
literal|1
expr_stmt|;
comment|/* By default */
name|inf
operator|->
name|want_exceptions
operator|=
literal|1
expr_stmt|;
comment|/* By default */
return|return
name|inf
return|;
block|}
end_function

begin_function
name|void
name|inf_clear_wait
parameter_list|(
name|struct
name|inf
modifier|*
name|inf
parameter_list|)
block|{
name|inf_debug
argument_list|(
name|inf
argument_list|,
literal|"clearing wait"
argument_list|)
expr_stmt|;
name|inf
operator|->
name|wait
operator|.
name|status
operator|.
name|kind
operator|=
name|TARGET_WAITKIND_SPURIOUS
expr_stmt|;
name|inf
operator|->
name|wait
operator|.
name|thread
operator|=
literal|0
expr_stmt|;
name|inf
operator|->
name|wait
operator|.
name|suppress
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|inf
operator|->
name|wait
operator|.
name|exc
operator|.
name|handler
operator|!=
name|MACH_PORT_NULL
condition|)
block|{
name|mach_port_deallocate
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
name|inf
operator|->
name|wait
operator|.
name|exc
operator|.
name|handler
argument_list|)
expr_stmt|;
name|inf
operator|->
name|wait
operator|.
name|exc
operator|.
name|handler
operator|=
name|MACH_PORT_NULL
expr_stmt|;
block|}
if|if
condition|(
name|inf
operator|->
name|wait
operator|.
name|exc
operator|.
name|reply
operator|!=
name|MACH_PORT_NULL
condition|)
block|{
name|mach_port_deallocate
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
name|inf
operator|->
name|wait
operator|.
name|exc
operator|.
name|reply
argument_list|)
expr_stmt|;
name|inf
operator|->
name|wait
operator|.
name|exc
operator|.
name|reply
operator|=
name|MACH_PORT_NULL
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|inf_cleanup
parameter_list|(
name|struct
name|inf
modifier|*
name|inf
parameter_list|)
block|{
name|inf_debug
argument_list|(
name|inf
argument_list|,
literal|"cleanup"
argument_list|)
expr_stmt|;
name|inf_clear_wait
argument_list|(
name|inf
argument_list|)
expr_stmt|;
name|inf_set_task
argument_list|(
name|inf
argument_list|,
name|MACH_PORT_NULL
argument_list|)
expr_stmt|;
name|inf
operator|->
name|pid
operator|=
literal|0
expr_stmt|;
name|inf
operator|->
name|traced
operator|=
literal|0
expr_stmt|;
name|inf
operator|->
name|no_wait
operator|=
literal|0
expr_stmt|;
name|inf
operator|->
name|stopped
operator|=
literal|0
expr_stmt|;
name|inf
operator|->
name|running
operator|=
literal|0
expr_stmt|;
name|inf
operator|->
name|pending_execs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|inf
operator|->
name|event_port
condition|)
block|{
name|mach_port_destroy
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
name|inf
operator|->
name|event_port
argument_list|)
expr_stmt|;
name|inf
operator|->
name|event_port
operator|=
name|MACH_PORT_NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|inf_startup
parameter_list|(
name|struct
name|inf
modifier|*
name|inf
parameter_list|,
name|int
name|pid
parameter_list|,
name|task_t
name|task
parameter_list|)
block|{
name|error_t
name|err
decl_stmt|;
name|inf_debug
argument_list|(
name|inf
argument_list|,
literal|"startup: pid = %d, task = %d"
argument_list|,
name|pid
argument_list|,
name|task
argument_list|)
expr_stmt|;
name|inf_cleanup
argument_list|(
name|inf
argument_list|)
expr_stmt|;
comment|/* Make the port on which we receive all events.  */
name|err
operator|=
name|mach_port_allocate
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
name|MACH_PORT_RIGHT_RECEIVE
argument_list|,
operator|&
name|inf
operator|->
name|event_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|error
argument_list|(
literal|"Error allocating event port: %s"
argument_list|,
name|strerror
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make a send right for it, so we can easily copy it for other people.  */
name|mach_port_insert_right
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
name|inf
operator|->
name|event_port
argument_list|,
name|inf
operator|->
name|event_port
argument_list|,
name|MACH_MSG_TYPE_MAKE_SEND
argument_list|)
expr_stmt|;
if|if
condition|(
name|inf
operator|->
name|pause_sc
condition|)
name|task_suspend
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|inf_set_task
argument_list|(
name|inf
argument_list|,
name|task
argument_list|)
expr_stmt|;
if|if
condition|(
name|inf
operator|->
name|task
condition|)
block|{
name|inf
operator|->
name|pid
operator|=
name|pid
expr_stmt|;
if|if
condition|(
name|inf
operator|->
name|pause_sc
condition|)
name|inf
operator|->
name|task
operator|->
name|sc
operator|=
name|inf
operator|->
name|task
operator|->
name|cur_sc
operator|=
literal|1
expr_stmt|;
comment|/* Reflect task_suspend above */
block|}
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|inf_set_task
parameter_list|(
name|struct
name|inf
modifier|*
name|inf
parameter_list|,
name|mach_port_t
name|port
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|task
init|=
name|inf
operator|->
name|task
decl_stmt|;
name|inf_debug
argument_list|(
name|inf
argument_list|,
literal|"setting task: %d"
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|task
operator|&&
name|task
operator|->
name|port
operator|!=
name|port
condition|)
block|{
name|inf
operator|->
name|task
operator|=
literal|0
expr_stmt|;
name|inf_validate_procs
argument_list|(
name|inf
argument_list|)
expr_stmt|;
comment|/* Trash all the threads. */
name|_proc_free
argument_list|(
name|task
argument_list|)
expr_stmt|;
comment|/* And the task. */
block|}
if|if
condition|(
name|port
operator|!=
name|MACH_PORT_NULL
condition|)
block|{
name|inf
operator|->
name|task
operator|=
name|make_proc
argument_list|(
name|inf
argument_list|,
name|port
argument_list|,
name|PROC_TID_TASK
argument_list|)
expr_stmt|;
name|inf
operator|->
name|threads_up_to_date
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Validates INF's stopped field from the actual proc server state.  */
end_comment

begin_function
specifier|static
name|void
name|inf_validate_stopped
parameter_list|(
name|struct
name|inf
modifier|*
name|inf
parameter_list|)
block|{
name|char
modifier|*
name|noise
decl_stmt|;
name|mach_msg_type_number_t
name|noise_len
init|=
literal|0
decl_stmt|;
name|struct
name|procinfo
modifier|*
name|pi
decl_stmt|;
name|mach_msg_type_number_t
name|pi_len
init|=
literal|0
decl_stmt|;
name|error_t
name|err
init|=
name|proc_getprocinfo
argument_list|(
name|proc_server
argument_list|,
name|inf
operator|->
name|pid
argument_list|,
literal|0
argument_list|,
operator|(
name|procinfo_t
operator|*
operator|)
operator|&
name|pi
argument_list|,
operator|&
name|pi_len
argument_list|,
operator|&
name|noise
argument_list|,
operator|&
name|noise_len
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
block|{
name|inf
operator|->
name|stopped
operator|=
operator|!
operator|!
operator|(
name|pi
operator|->
name|state
operator|&
name|PI_STOPPED
operator|)
expr_stmt|;
name|vm_deallocate
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
operator|(
name|vm_address_t
operator|)
name|pi
argument_list|,
name|pi_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|noise_len
operator|>
literal|0
condition|)
name|vm_deallocate
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
operator|(
name|vm_address_t
operator|)
name|noise
argument_list|,
name|noise_len
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Validates INF's task suspend count.  */
end_comment

begin_function
specifier|static
name|void
name|inf_validate_task_sc
parameter_list|(
name|struct
name|inf
modifier|*
name|inf
parameter_list|)
block|{
name|struct
name|task_basic_info
name|info
decl_stmt|;
name|mach_msg_type_number_t
name|info_len
init|=
name|TASK_BASIC_INFO_COUNT
decl_stmt|;
name|error_t
name|err
init|=
name|task_info
argument_list|(
name|inf
operator|->
name|task
operator|->
name|port
argument_list|,
name|TASK_BASIC_INFO
argument_list|,
operator|&
name|info
argument_list|,
operator|&
name|info_len
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
block|{
if|if
condition|(
name|inf
operator|->
name|task
operator|->
name|cur_sc
operator|<
name|info
operator|.
name|suspend_count
condition|)
name|warning
argument_list|(
literal|"Pid %d is suspended; continuing will clear existing suspend count."
argument_list|,
name|inf
operator|->
name|pid
argument_list|)
expr_stmt|;
name|inf
operator|->
name|task
operator|->
name|cur_sc
operator|=
name|info
operator|.
name|suspend_count
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Turns tracing for INF on or off, depending on ON, unless it already is.    If INF is running, the resume_sc count of INF's threads will be modified,    and the signal thread will briefly be run to change the trace state.  */
end_comment

begin_function
name|void
name|inf_set_traced
parameter_list|(
name|struct
name|inf
modifier|*
name|inf
parameter_list|,
name|int
name|on
parameter_list|)
block|{
if|if
condition|(
name|on
operator|!=
name|inf
operator|->
name|traced
condition|)
if|if
condition|(
name|inf
operator|->
name|task
condition|)
comment|/* Make it take effect immediately.  */
block|{
name|error_t
function_decl|(
modifier|*
name|f
function_decl|)
parameter_list|(
name|mach_port_t
parameter_list|,
name|mach_port_t
parameter_list|,
name|int
parameter_list|)
init|=
name|on
condition|?
name|msg_set_some_exec_flags
operator|:
name|msg_clear_some_exec_flags
function_decl|;
name|error_t
name|err
init|=
name|INF_RESUME_MSGPORT_RPC
argument_list|(
name|inf
argument_list|,
call|(
modifier|*
name|f
call|)
argument_list|(
name|msgport
argument_list|,
name|refport
argument_list|,
name|EXEC_TRACED
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
operator|==
name|EIEIO
condition|)
name|warning
argument_list|(
literal|"Can't modify tracing state for pid %d: No signal thread"
argument_list|,
name|inf
operator|->
name|pid
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|err
condition|)
name|warning
argument_list|(
literal|"Can't modify tracing state for pid %d: %s"
argument_list|,
name|inf
operator|->
name|pid
argument_list|,
name|strerror
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|inf
operator|->
name|traced
operator|=
name|on
expr_stmt|;
block|}
else|else
name|inf
operator|->
name|traced
operator|=
name|on
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Makes all the real suspend count deltas of all the procs in INF match the    desired values.  Careful to always do thread/task suspend counts in the    safe order.  Returns true if at least one thread is thought to be running.*/
end_comment

begin_function
name|int
name|inf_update_suspends
parameter_list|(
name|struct
name|inf
modifier|*
name|inf
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|task
init|=
name|inf
operator|->
name|task
decl_stmt|;
comment|/* We don't have to update INF->threads even though we're iterating over it      because we'll change a thread only if it already has an existing proc      entry.  */
name|inf_debug
argument_list|(
name|inf
argument_list|,
literal|"updating suspend counts"
argument_list|)
expr_stmt|;
if|if
condition|(
name|task
condition|)
block|{
name|struct
name|proc
modifier|*
name|thread
decl_stmt|;
name|int
name|task_running
init|=
operator|(
name|task
operator|->
name|sc
operator|==
literal|0
operator|)
decl_stmt|,
name|thread_running
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|task
operator|->
name|sc
operator|>
name|task
operator|->
name|cur_sc
condition|)
comment|/* The task is becoming _more_ suspended; do before any threads.  */
name|task_running
operator|=
name|proc_update_sc
argument_list|(
name|task
argument_list|)
expr_stmt|;
if|if
condition|(
name|inf
operator|->
name|pending_execs
condition|)
comment|/* When we're waiting for an exec, things may be happening behind our 	   back, so be conservative.  */
name|thread_running
operator|=
literal|1
expr_stmt|;
comment|/* Do all the thread suspend counts.  */
for|for
control|(
name|thread
operator|=
name|inf
operator|->
name|threads
init|;
name|thread
condition|;
name|thread
operator|=
name|thread
operator|->
name|next
control|)
name|thread_running
operator||=
name|proc_update_sc
argument_list|(
name|thread
argument_list|)
expr_stmt|;
if|if
condition|(
name|task
operator|->
name|sc
operator|!=
name|task
operator|->
name|cur_sc
condition|)
comment|/* We didn't do the task first, because we wanted to wait for the 	   threads; do it now.  */
name|task_running
operator|=
name|proc_update_sc
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|inf_debug
argument_list|(
name|inf
argument_list|,
literal|"%srunning..."
argument_list|,
operator|(
name|thread_running
operator|&&
name|task_running
operator|)
condition|?
literal|""
else|:
literal|"not "
argument_list|)
expr_stmt|;
name|inf
operator|->
name|running
operator|=
name|thread_running
operator|&&
name|task_running
expr_stmt|;
comment|/* Once any thread has executed some code, we can't depend on the 	 threads list any more.  */
if|if
condition|(
name|inf
operator|->
name|running
condition|)
name|inf
operator|->
name|threads_up_to_date
operator|=
literal|0
expr_stmt|;
return|return
name|inf
operator|->
name|running
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Converts a GDB pid to a struct proc.  */
end_comment

begin_function
name|struct
name|proc
modifier|*
name|inf_tid_to_thread
parameter_list|(
name|struct
name|inf
modifier|*
name|inf
parameter_list|,
name|int
name|tid
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|thread
init|=
name|inf
operator|->
name|threads
decl_stmt|;
while|while
condition|(
name|thread
condition|)
if|if
condition|(
name|thread
operator|->
name|tid
operator|==
name|tid
condition|)
return|return
name|thread
return|;
else|else
name|thread
operator|=
name|thread
operator|->
name|next
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Converts a thread port to a struct proc.  */
end_comment

begin_function
name|struct
name|proc
modifier|*
name|inf_port_to_thread
parameter_list|(
name|struct
name|inf
modifier|*
name|inf
parameter_list|,
name|mach_port_t
name|port
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|thread
init|=
name|inf
operator|->
name|threads
decl_stmt|;
while|while
condition|(
name|thread
condition|)
if|if
condition|(
name|thread
operator|->
name|port
operator|==
name|port
condition|)
return|return
name|thread
return|;
else|else
name|thread
operator|=
name|thread
operator|->
name|next
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Make INF's list of threads be consistent with reality of TASK.  */
end_comment

begin_function
name|void
name|inf_validate_procs
parameter_list|(
name|struct
name|inf
modifier|*
name|inf
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|thread_array_t
name|threads
decl_stmt|;
name|unsigned
name|num_threads
decl_stmt|;
name|struct
name|proc
modifier|*
name|task
init|=
name|inf
operator|->
name|task
decl_stmt|;
name|inf
operator|->
name|threads_up_to_date
operator|=
operator|!
name|inf
operator|->
name|running
expr_stmt|;
if|if
condition|(
name|task
condition|)
block|{
name|error_t
name|err
init|=
name|task_threads
argument_list|(
name|task
operator|->
name|port
argument_list|,
operator|&
name|threads
argument_list|,
operator|&
name|num_threads
argument_list|)
decl_stmt|;
name|inf_debug
argument_list|(
name|inf
argument_list|,
literal|"fetching threads"
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
comment|/* TASK must be dead.  */
block|{
name|task
operator|->
name|port
operator|=
name|MACH_PORT_NULL
expr_stmt|;
name|_proc_free
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|task
operator|=
name|inf
operator|->
name|task
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|task
condition|)
block|{
name|num_threads
operator|=
literal|0
expr_stmt|;
name|inf_debug
argument_list|(
name|inf
argument_list|,
literal|"no task"
argument_list|)
expr_stmt|;
block|}
block|{
name|unsigned
name|search_start
init|=
literal|0
decl_stmt|;
comment|/* Make things normally linear.  */
comment|/* Which thread in PROCS corresponds to each task thread,& the task.  */
name|struct
name|proc
modifier|*
name|matched
index|[
name|num_threads
operator|+
literal|1
index|]
decl_stmt|;
comment|/* The last thread in INF->threads, so we can add to the end.  */
name|struct
name|proc
modifier|*
name|last
init|=
literal|0
decl_stmt|;
comment|/* The current thread we're considering. */
name|struct
name|proc
modifier|*
name|thread
init|=
name|inf
operator|->
name|threads
decl_stmt|;
name|bzero
argument_list|(
name|matched
argument_list|,
sizeof|sizeof
argument_list|(
name|matched
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|thread
condition|)
block|{
name|unsigned
name|left
decl_stmt|;
for|for
control|(
name|i
operator|=
name|search_start
operator|,
name|left
operator|=
name|num_threads
init|;
name|left
condition|;
name|i
operator|++
operator|,
name|left
operator|--
control|)
block|{
if|if
condition|(
name|i
operator|>=
name|num_threads
condition|)
name|i
operator|-=
name|num_threads
expr_stmt|;
comment|/* I wrapped around.  */
if|if
condition|(
name|thread
operator|->
name|port
operator|==
name|threads
index|[
name|i
index|]
condition|)
comment|/* We already know about this thread.  */
block|{
name|matched
index|[
name|i
index|]
operator|=
name|thread
expr_stmt|;
name|last
operator|=
name|thread
expr_stmt|;
name|thread
operator|=
name|thread
operator|->
name|next
expr_stmt|;
name|search_start
operator|++
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|left
condition|)
block|{
name|proc_debug
argument_list|(
name|thread
argument_list|,
literal|"died!"
argument_list|)
expr_stmt|;
name|thread
operator|->
name|port
operator|=
name|MACH_PORT_NULL
expr_stmt|;
name|thread
operator|=
name|_proc_free
argument_list|(
name|thread
argument_list|)
expr_stmt|;
comment|/* THREAD is dead.  */
operator|(
name|last
condition|?
name|last
operator|->
name|next
else|:
name|inf
operator|->
name|threads
operator|)
operator|=
name|thread
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_threads
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|matched
index|[
name|i
index|]
condition|)
comment|/* Throw away the duplicate send right.  */
name|mach_port_deallocate
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
name|threads
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
comment|/* THREADS[I] is a thread we don't know about yet!  */
block|{
name|thread
operator|=
name|make_proc
argument_list|(
name|inf
argument_list|,
name|threads
index|[
name|i
index|]
argument_list|,
name|next_thread_id
operator|++
argument_list|)
expr_stmt|;
operator|(
name|last
condition|?
name|last
operator|->
name|next
else|:
name|inf
operator|->
name|threads
operator|)
operator|=
name|thread
expr_stmt|;
name|last
operator|=
name|thread
expr_stmt|;
name|proc_debug
argument_list|(
name|thread
argument_list|,
literal|"new thread: %d"
argument_list|,
name|threads
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|add_thread
argument_list|(
name|thread
operator|->
name|tid
argument_list|)
expr_stmt|;
comment|/* Tell GDB's generic thread code.  */
block|}
name|vm_deallocate
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
operator|(
name|vm_address_t
operator|)
name|threads
argument_list|,
operator|(
name|num_threads
operator|*
sizeof|sizeof
argument_list|(
name|thread_t
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Makes sure that INF's thread list is synced with the actual process.  */
end_comment

begin_function
specifier|inline
name|int
name|inf_update_procs
parameter_list|(
name|struct
name|inf
modifier|*
name|inf
parameter_list|)
block|{
if|if
condition|(
operator|!
name|inf
operator|->
name|task
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|inf
operator|->
name|threads_up_to_date
condition|)
name|inf_validate_procs
argument_list|(
name|inf
argument_list|)
expr_stmt|;
return|return
operator|!
operator|!
name|inf
operator|->
name|task
return|;
block|}
end_function

begin_comment
comment|/* Sets the resume_sc of each thread in inf.  That of RUN_THREAD is set to 0,    and others are set to their run_sc if RUN_OTHERS is true, and otherwise    their pause_sc.  */
end_comment

begin_function
specifier|inline
name|void
name|inf_set_threads_resume_sc
parameter_list|(
name|struct
name|inf
modifier|*
name|inf
parameter_list|,
name|struct
name|proc
modifier|*
name|run_thread
parameter_list|,
name|int
name|run_others
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|thread
decl_stmt|;
name|inf_update_procs
argument_list|(
name|inf
argument_list|)
expr_stmt|;
for|for
control|(
name|thread
operator|=
name|inf
operator|->
name|threads
init|;
name|thread
condition|;
name|thread
operator|=
name|thread
operator|->
name|next
control|)
if|if
condition|(
name|thread
operator|==
name|run_thread
condition|)
name|thread
operator|->
name|resume_sc
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|run_others
condition|)
name|thread
operator|->
name|resume_sc
operator|=
name|thread
operator|->
name|run_sc
expr_stmt|;
else|else
name|thread
operator|->
name|resume_sc
operator|=
name|thread
operator|->
name|pause_sc
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Cause INF to continue execution immediately; individual threads may still    be suspended (but their suspend counts will be updated).  */
end_comment

begin_function
specifier|inline
name|void
name|inf_resume
parameter_list|(
name|struct
name|inf
modifier|*
name|inf
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|thread
decl_stmt|;
name|inf_update_procs
argument_list|(
name|inf
argument_list|)
expr_stmt|;
for|for
control|(
name|thread
operator|=
name|inf
operator|->
name|threads
init|;
name|thread
condition|;
name|thread
operator|=
name|thread
operator|->
name|next
control|)
name|thread
operator|->
name|sc
operator|=
name|thread
operator|->
name|resume_sc
expr_stmt|;
if|if
condition|(
name|inf
operator|->
name|task
condition|)
name|inf
operator|->
name|task
operator|->
name|sc
operator|=
literal|0
expr_stmt|;
name|inf_update_suspends
argument_list|(
name|inf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Cause INF to stop execution immediately; individual threads may still    be running.  */
end_comment

begin_function
specifier|inline
name|void
name|inf_suspend
parameter_list|(
name|struct
name|inf
modifier|*
name|inf
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|thread
decl_stmt|;
name|inf_update_procs
argument_list|(
name|inf
argument_list|)
expr_stmt|;
for|for
control|(
name|thread
operator|=
name|inf
operator|->
name|threads
init|;
name|thread
condition|;
name|thread
operator|=
name|thread
operator|->
name|next
control|)
name|thread
operator|->
name|sc
operator|=
name|thread
operator|->
name|pause_sc
expr_stmt|;
if|if
condition|(
name|inf
operator|->
name|task
condition|)
name|inf
operator|->
name|task
operator|->
name|sc
operator|=
name|inf
operator|->
name|pause_sc
expr_stmt|;
name|inf_update_suspends
argument_list|(
name|inf
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* INF has one thread PROC that is in single-stepping mode.  This functions    changes it to be PROC, changing any old step_thread to be a normal one.  A    PROC of 0 clears an any existing value.  */
end_comment

begin_function
name|void
name|inf_set_step_thread
parameter_list|(
name|struct
name|inf
modifier|*
name|inf
parameter_list|,
name|struct
name|proc
modifier|*
name|thread
parameter_list|)
block|{
name|assert
argument_list|(
operator|!
name|thread
operator|||
name|proc_is_thread
argument_list|(
name|thread
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|thread
condition|)
name|inf_debug
argument_list|(
name|inf
argument_list|,
literal|"setting step thread: %d/%d"
argument_list|,
name|inf
operator|->
name|pid
argument_list|,
name|thread
operator|->
name|tid
argument_list|)
expr_stmt|;
else|else
name|inf_debug
argument_list|(
name|inf
argument_list|,
literal|"clearing step thread"
argument_list|)
expr_stmt|;
if|if
condition|(
name|inf
operator|->
name|step_thread
operator|!=
name|thread
condition|)
block|{
if|if
condition|(
name|inf
operator|->
name|step_thread
operator|&&
name|inf
operator|->
name|step_thread
operator|->
name|port
operator|!=
name|MACH_PORT_NULL
condition|)
if|if
condition|(
operator|!
name|proc_trace
argument_list|(
name|inf
operator|->
name|step_thread
argument_list|,
literal|0
argument_list|)
condition|)
return|return;
if|if
condition|(
name|thread
operator|&&
name|proc_trace
argument_list|(
name|thread
argument_list|,
literal|1
argument_list|)
condition|)
name|inf
operator|->
name|step_thread
operator|=
name|thread
expr_stmt|;
else|else
name|inf
operator|->
name|step_thread
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Set up the thread resume_sc's so that only the signal thread is running    (plus whatever other thread are set to always run).  Returns true if we    did so, or false if we can't find a signal thread.  */
end_comment

begin_function
specifier|inline
name|int
name|inf_set_threads_resume_sc_for_signal_thread
parameter_list|(
name|struct
name|inf
modifier|*
name|inf
parameter_list|)
block|{
if|if
condition|(
name|inf
operator|->
name|signal_thread
condition|)
block|{
name|inf_set_threads_resume_sc
argument_list|(
name|inf
argument_list|,
name|inf
operator|->
name|signal_thread
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|inf_update_signal_thread
parameter_list|(
name|struct
name|inf
modifier|*
name|inf
parameter_list|)
block|{
comment|/* XXX for now we assume that if there's a msgport, the 2nd thread is      the signal thread.  */
name|inf
operator|->
name|signal_thread
operator|=
name|inf
operator|->
name|threads
condition|?
name|inf
operator|->
name|threads
operator|->
name|next
else|:
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Detachs from INF's inferior task, letting it run once again...  */
end_comment

begin_function
name|void
name|inf_detach
parameter_list|(
name|struct
name|inf
modifier|*
name|inf
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|task
init|=
name|inf
operator|->
name|task
decl_stmt|;
name|inf_debug
argument_list|(
name|inf
argument_list|,
literal|"detaching..."
argument_list|)
expr_stmt|;
name|inf_clear_wait
argument_list|(
name|inf
argument_list|)
expr_stmt|;
name|inf_set_step_thread
argument_list|(
name|inf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|task
condition|)
block|{
name|struct
name|proc
modifier|*
name|thread
decl_stmt|;
name|inf_set_traced
argument_list|(
name|inf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|inf
operator|->
name|stopped
condition|)
name|inf_signal
argument_list|(
name|inf
argument_list|,
name|TARGET_SIGNAL_0
argument_list|)
expr_stmt|;
name|proc_restore_exc_port
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|task
operator|->
name|sc
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|thread
operator|=
name|inf
operator|->
name|threads
init|;
name|thread
condition|;
name|thread
operator|=
name|thread
operator|->
name|next
control|)
block|{
name|proc_restore_exc_port
argument_list|(
name|thread
argument_list|)
expr_stmt|;
name|thread
operator|->
name|sc
operator|=
literal|0
expr_stmt|;
block|}
name|inf_update_suspends
argument_list|(
name|inf
argument_list|)
expr_stmt|;
block|}
name|inf_cleanup
argument_list|(
name|inf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Attaches INF to the process with process id PID, returning it in a suspended    state suitable for debugging.  */
end_comment

begin_function
name|void
name|inf_attach
parameter_list|(
name|struct
name|inf
modifier|*
name|inf
parameter_list|,
name|int
name|pid
parameter_list|)
block|{
name|error_t
name|err
decl_stmt|;
name|task_t
name|task
decl_stmt|;
name|inf_debug
argument_list|(
name|inf
argument_list|,
literal|"attaching: %d"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
name|err
operator|=
name|proc_pid2task
argument_list|(
name|proc_server
argument_list|,
name|pid
argument_list|,
operator|&
name|task
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|error
argument_list|(
literal|"Error getting task for pid %d: %s"
argument_list|,
name|pid
argument_list|,
name|strerror
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|inf
operator|->
name|pid
condition|)
name|inf_detach
argument_list|(
name|inf
argument_list|)
expr_stmt|;
name|inf_startup
argument_list|(
name|inf
argument_list|,
name|pid
argument_list|,
name|task
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Makes sure that we've got our exception ports entrenched in the process. */
end_comment

begin_function
name|void
name|inf_steal_exc_ports
parameter_list|(
name|struct
name|inf
modifier|*
name|inf
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|thread
decl_stmt|;
name|inf_debug
argument_list|(
name|inf
argument_list|,
literal|"stealing exception ports"
argument_list|)
expr_stmt|;
name|inf_set_step_thread
argument_list|(
name|inf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* The step thread is special. */
name|proc_steal_exc_port
argument_list|(
name|inf
operator|->
name|task
argument_list|,
name|inf
operator|->
name|event_port
argument_list|)
expr_stmt|;
for|for
control|(
name|thread
operator|=
name|inf
operator|->
name|threads
init|;
name|thread
condition|;
name|thread
operator|=
name|thread
operator|->
name|next
control|)
name|proc_steal_exc_port
argument_list|(
name|thread
argument_list|,
name|MACH_PORT_NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Makes sure the process has its own exception ports.  */
end_comment

begin_function
name|void
name|inf_restore_exc_ports
parameter_list|(
name|struct
name|inf
modifier|*
name|inf
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|thread
decl_stmt|;
name|inf_debug
argument_list|(
name|inf
argument_list|,
literal|"restoring exception ports"
argument_list|)
expr_stmt|;
name|inf_set_step_thread
argument_list|(
name|inf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* The step thread is special. */
name|proc_restore_exc_port
argument_list|(
name|inf
operator|->
name|task
argument_list|)
expr_stmt|;
for|for
control|(
name|thread
operator|=
name|inf
operator|->
name|threads
init|;
name|thread
condition|;
name|thread
operator|=
name|thread
operator|->
name|next
control|)
name|proc_restore_exc_port
argument_list|(
name|thread
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Deliver signal SIG to INF.  If INF is stopped, delivering a signal, even    signal 0, will continue it.  INF is assumed to be in a paused state, and    the resume_sc's of INF's threads may be affected.  */
end_comment

begin_function
name|void
name|inf_signal
parameter_list|(
name|struct
name|inf
modifier|*
name|inf
parameter_list|,
name|enum
name|target_signal
name|sig
parameter_list|)
block|{
name|error_t
name|err
init|=
literal|0
decl_stmt|;
name|int
name|host_sig
init|=
name|target_signal_to_host
argument_list|(
name|sig
argument_list|)
decl_stmt|;
define|#
directive|define
name|NAME
value|target_signal_to_name (sig)
if|if
condition|(
name|host_sig
operator|>=
name|_NSIG
condition|)
comment|/* A mach exception.  Exceptions are encoded in the signal space by        putting them after _NSIG; this assumes they're positive (and not        extremely large)!  */
block|{
name|struct
name|inf_wait
modifier|*
name|w
init|=
operator|&
name|inf
operator|->
name|wait
decl_stmt|;
if|if
condition|(
name|w
operator|->
name|status
operator|.
name|kind
operator|==
name|TARGET_WAITKIND_STOPPED
operator|&&
name|w
operator|->
name|status
operator|.
name|value
operator|.
name|sig
operator|==
name|sig
operator|&&
name|w
operator|->
name|thread
operator|&&
operator|!
name|w
operator|->
name|thread
operator|->
name|aborted
condition|)
comment|/* We're passing through the last exception we received.  This is 	   kind of bogus, because exceptions are per-thread whereas gdb 	   treats signals as per-process.  We just forward the exception to 	   the correct handler, even it's not for the same thread as TID -- 	   i.e., we pretend it's global.  */
block|{
name|struct
name|exc_state
modifier|*
name|e
init|=
operator|&
name|w
operator|->
name|exc
decl_stmt|;
name|inf_debug
argument_list|(
name|inf
argument_list|,
literal|"passing through exception:"
literal|" task = %d, thread = %d, exc = %d"
literal|", code = %d, subcode = %d"
argument_list|,
name|w
operator|->
name|thread
operator|->
name|port
argument_list|,
name|inf
operator|->
name|task
operator|->
name|port
argument_list|,
name|e
operator|->
name|exception
argument_list|,
name|e
operator|->
name|code
argument_list|,
name|e
operator|->
name|subcode
argument_list|)
expr_stmt|;
name|err
operator|=
name|exception_raise_request
argument_list|(
name|e
operator|->
name|handler
argument_list|,
name|e
operator|->
name|reply
argument_list|,
name|MACH_MSG_TYPE_MOVE_SEND_ONCE
argument_list|,
name|w
operator|->
name|thread
operator|->
name|port
argument_list|,
name|inf
operator|->
name|task
operator|->
name|port
argument_list|,
name|e
operator|->
name|exception
argument_list|,
name|e
operator|->
name|code
argument_list|,
name|e
operator|->
name|subcode
argument_list|)
expr_stmt|;
block|}
else|else
name|warning
argument_list|(
literal|"Can't forward spontaneous exception (%s)."
argument_list|,
name|NAME
argument_list|)
expr_stmt|;
block|}
elseif|else
comment|/* A Unix signal.  */
if|if
condition|(
name|inf
operator|->
name|stopped
condition|)
comment|/* The process is stopped an expecting a signal.  Just send off a 	 request and let it get handled when we resume everything.  */
block|{
name|inf_debug
argument_list|(
name|inf
argument_list|,
literal|"sending %s to stopped process"
argument_list|,
name|NAME
argument_list|)
expr_stmt|;
name|err
operator|=
name|INF_MSGPORT_RPC
argument_list|(
name|inf
argument_list|,
name|msg_sig_post_untraced_request
argument_list|(
name|msgport
argument_list|,
name|inf
operator|->
name|event_port
argument_list|,
name|MACH_MSG_TYPE_MAKE_SEND_ONCE
argument_list|,
name|host_sig
argument_list|,
name|refport
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
comment|/* Posting an untraced signal automatically continues it. 	     We clear this here rather than when we get the reply 	     because we'd rather assume it's not stopped when it 	     actually is, than the reverse.  */
name|inf
operator|->
name|stopped
operator|=
literal|0
expr_stmt|;
block|}
else|else
comment|/* It's not expecting it.  We have to let just the signal thread 	 run, and wait for it to get into a reasonable state before we 	 can continue the rest of the process.  When we finally resume the 	 process the signal we request will be the very first thing that 	 happens. */
block|{
name|inf_debug
argument_list|(
name|inf
argument_list|,
literal|"sending %s to unstopped process (so resuming signal thread)"
argument_list|,
name|NAME
argument_list|)
expr_stmt|;
name|err
operator|=
name|INF_RESUME_MSGPORT_RPC
argument_list|(
name|inf
argument_list|,
name|msg_sig_post_untraced
argument_list|(
name|msgport
argument_list|,
name|host_sig
argument_list|,
name|refport
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|==
name|EIEIO
condition|)
comment|/* Can't do too much... */
name|warning
argument_list|(
literal|"Can't deliver signal %s: No signal thread."
argument_list|,
name|NAME
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|err
condition|)
name|warning
argument_list|(
literal|"Delivering signal %s: %s"
argument_list|,
name|NAME
argument_list|,
name|strerror
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|NAME
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The inferior used for all gdb target ops.  */
end_comment

begin_decl_stmt
name|struct
name|inf
modifier|*
name|current_inferior
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The inferior being waited for by gnu_wait.  Since GDB is decidely not    multi-threaded, we don't bother to lock this.  */
end_comment

begin_decl_stmt
name|struct
name|inf
modifier|*
name|waiting_inf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Wait for something to happen in the inferior, returning what in STATUS. */
end_comment

begin_function
specifier|static
name|int
name|gnu_wait
parameter_list|(
name|int
name|tid
parameter_list|,
name|struct
name|target_waitstatus
modifier|*
name|status
parameter_list|)
block|{
struct|struct
name|msg
block|{
name|mach_msg_header_t
name|hdr
decl_stmt|;
name|mach_msg_type_t
name|type
decl_stmt|;
name|int
name|data
index|[
literal|8000
index|]
decl_stmt|;
block|}
name|msg
struct|;
name|error_t
name|err
decl_stmt|;
name|struct
name|proc
modifier|*
name|thread
decl_stmt|;
name|struct
name|inf
modifier|*
name|inf
init|=
name|current_inferior
decl_stmt|;
name|waiting_inf
operator|=
name|inf
expr_stmt|;
name|inf_debug
argument_list|(
name|inf
argument_list|,
literal|"waiting for: %d"
argument_list|,
name|tid
argument_list|)
expr_stmt|;
name|rewait
label|:
if|if
condition|(
name|proc_wait_pid
operator|!=
name|inf
operator|->
name|pid
operator|&&
operator|!
name|inf
operator|->
name|no_wait
condition|)
comment|/* Always get information on events from the proc server.  */
block|{
name|inf_debug
argument_list|(
name|inf
argument_list|,
literal|"requesting wait on pid %d"
argument_list|,
name|inf
operator|->
name|pid
argument_list|)
expr_stmt|;
if|if
condition|(
name|proc_wait_pid
condition|)
comment|/* The proc server is single-threaded, and only allows a single 	   outstanding wait request, so we have to cancel the previous one. */
block|{
name|inf_debug
argument_list|(
name|inf
argument_list|,
literal|"cancelling previous wait on pid %d"
argument_list|,
name|proc_wait_pid
argument_list|)
expr_stmt|;
name|interrupt_operation
argument_list|(
name|proc_server
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
name|proc_wait_request
argument_list|(
name|proc_server
argument_list|,
name|inf
operator|->
name|event_port
argument_list|,
name|inf
operator|->
name|pid
argument_list|,
name|WUNTRACED
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|warning
argument_list|(
literal|"wait request failed: %s"
argument_list|,
name|strerror
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|inf_debug
argument_list|(
name|inf
argument_list|,
literal|"waits pending: %d"
argument_list|,
name|proc_waits_pending
argument_list|)
expr_stmt|;
name|proc_wait_pid
operator|=
name|inf
operator|->
name|pid
expr_stmt|;
comment|/* Even if proc_waits_pending was> 0 before, we still won't get 	     any other replies, because it was either from a different INF, 	     or a different process attached to INF -- and the event port, 	     which is the wait reply port, changes when you switch processes.*/
name|proc_waits_pending
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|inf_clear_wait
argument_list|(
name|inf
argument_list|)
expr_stmt|;
comment|/* What can happen? (1) Dead name notification; (2) Exceptions arrive;      (3) wait reply from the proc server.  */
name|inf_debug
argument_list|(
name|inf
argument_list|,
literal|"waiting for an event..."
argument_list|)
expr_stmt|;
name|err
operator|=
name|_hurd_intr_rpc_mach_msg
argument_list|(
operator|&
name|msg
operator|.
name|hdr
argument_list|,
name|MACH_RCV_MSG
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|msg
argument_list|)
argument_list|,
name|inf
operator|->
name|event_port
argument_list|,
name|MACH_PORT_NULL
argument_list|)
expr_stmt|;
comment|/* Re-suspend the task.  */
name|inf_suspend
argument_list|(
name|inf
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|EINTR
condition|)
name|inf_debug
argument_list|(
name|inf
argument_list|,
literal|"interrupted"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|err
condition|)
name|error
argument_list|(
literal|"Couldn't wait for an event: %s"
argument_list|,
name|strerror
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
struct|struct
block|{
name|mach_msg_header_t
name|hdr
decl_stmt|;
name|mach_msg_type_t
name|err_type
decl_stmt|;
name|kern_return_t
name|err
decl_stmt|;
name|char
name|noise
index|[
literal|200
index|]
decl_stmt|;
block|}
name|reply
struct|;
name|inf_debug
argument_list|(
name|inf
argument_list|,
literal|"event: msgid = %d"
argument_list|,
name|msg
operator|.
name|hdr
operator|.
name|msgh_id
argument_list|)
expr_stmt|;
comment|/* Handle what we got.  */
if|if
condition|(
operator|!
name|notify_server
argument_list|(
operator|&
name|msg
operator|.
name|hdr
argument_list|,
operator|&
name|reply
operator|.
name|hdr
argument_list|)
operator|&&
operator|!
name|exc_server
argument_list|(
operator|&
name|msg
operator|.
name|hdr
argument_list|,
operator|&
name|reply
operator|.
name|hdr
argument_list|)
operator|&&
operator|!
name|process_reply_server
argument_list|(
operator|&
name|msg
operator|.
name|hdr
argument_list|,
operator|&
name|reply
operator|.
name|hdr
argument_list|)
operator|&&
operator|!
name|msg_reply_server
argument_list|(
operator|&
name|msg
operator|.
name|hdr
argument_list|,
operator|&
name|reply
operator|.
name|hdr
argument_list|)
condition|)
comment|/* Whatever it is, it's something strange.  */
name|error
argument_list|(
literal|"Got a strange event, msg id = %d."
argument_list|,
name|msg
operator|.
name|hdr
operator|.
name|msgh_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|reply
operator|.
name|err
condition|)
name|error
argument_list|(
literal|"Handling event, msgid = %d: %s"
argument_list|,
name|msg
operator|.
name|hdr
operator|.
name|msgh_id
argument_list|,
name|strerror
argument_list|(
name|reply
operator|.
name|err
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|inf
operator|->
name|pending_execs
condition|)
comment|/* We're waiting for the inferior to finish execing.  */
block|{
name|struct
name|inf_wait
modifier|*
name|w
init|=
operator|&
name|inf
operator|->
name|wait
decl_stmt|;
name|enum
name|target_waitkind
name|kind
init|=
name|w
operator|->
name|status
operator|.
name|kind
decl_stmt|;
if|if
condition|(
name|kind
operator|==
name|TARGET_WAITKIND_SPURIOUS
condition|)
comment|/* Since gdb is actually counting the number of times the inferior 	   stops, expecting one stop per exec, we only return major events 	   while execing.  */
name|w
operator|->
name|suppress
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|kind
operator|==
name|TARGET_WAITKIND_STOPPED
operator|&&
name|w
operator|->
name|status
operator|.
name|value
operator|.
name|sig
operator|==
name|TARGET_SIGNAL_TRAP
condition|)
comment|/* Ah hah!  A SIGTRAP from the inferior while starting up probably 	   means we've succesfully completed an exec!  */
if|if
condition|(
operator|--
name|inf
operator|->
name|pending_execs
operator|==
literal|0
condition|)
comment|/* We're done!  */
block|{
name|prune_threads
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Get rid of the old shell threads */
name|renumber_threads
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Give our threads reasonable names. */
block|}
block|}
if|if
condition|(
name|inf
operator|->
name|wait
operator|.
name|suppress
condition|)
comment|/* Some totally spurious event happened that we don't consider        worth returning to gdb.  Just keep waiting.  */
block|{
name|inf_debug
argument_list|(
name|inf
argument_list|,
literal|"suppressing return, rewaiting..."
argument_list|)
expr_stmt|;
name|inf_resume
argument_list|(
name|inf
argument_list|)
expr_stmt|;
goto|goto
name|rewait
goto|;
block|}
comment|/* Pass back out our results.  */
name|bcopy
argument_list|(
operator|&
name|inf
operator|->
name|wait
operator|.
name|status
argument_list|,
name|status
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|thread
operator|=
name|inf
operator|->
name|wait
operator|.
name|thread
expr_stmt|;
if|if
condition|(
name|thread
condition|)
name|tid
operator|=
name|thread
operator|->
name|tid
expr_stmt|;
else|else
name|thread
operator|=
name|inf_tid_to_thread
argument_list|(
name|inf
argument_list|,
name|tid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|thread
operator|||
name|thread
operator|->
name|port
operator|==
name|MACH_PORT_NULL
condition|)
comment|/* TID is dead; try and find a new thread.  */
if|if
condition|(
name|inf_update_procs
argument_list|(
name|inf
argument_list|)
operator|&&
name|inf
operator|->
name|threads
condition|)
name|tid
operator|=
name|inf
operator|->
name|threads
operator|->
name|tid
expr_stmt|;
comment|/* The first available thread.  */
else|else
name|tid
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|thread
operator|&&
name|tid
operator|>=
literal|0
operator|&&
name|status
operator|->
name|kind
operator|!=
name|TARGET_WAITKIND_SPURIOUS
operator|&&
name|inf
operator|->
name|pause_sc
operator|==
literal|0
operator|&&
name|thread
operator|->
name|pause_sc
operator|==
literal|0
condition|)
comment|/* If something actually happened to THREAD, make sure we suspend it.  */
block|{
name|thread
operator|->
name|sc
operator|=
literal|1
expr_stmt|;
name|inf_update_suspends
argument_list|(
name|inf
argument_list|)
expr_stmt|;
block|}
name|inf_debug
argument_list|(
name|inf
argument_list|,
literal|"returning tid = %d, status = %s (%d)"
argument_list|,
name|tid
argument_list|,
name|status
operator|->
name|kind
operator|==
name|TARGET_WAITKIND_EXITED
condition|?
literal|"EXITED"
else|:
name|status
operator|->
name|kind
operator|==
name|TARGET_WAITKIND_STOPPED
condition|?
literal|"STOPPED"
else|:
name|status
operator|->
name|kind
operator|==
name|TARGET_WAITKIND_SIGNALLED
condition|?
literal|"SIGNALLED"
else|:
name|status
operator|->
name|kind
operator|==
name|TARGET_WAITKIND_LOADED
condition|?
literal|"LOADED"
else|:
name|status
operator|->
name|kind
operator|==
name|TARGET_WAITKIND_SPURIOUS
condition|?
literal|"SPURIOUS"
else|:
literal|"?"
argument_list|,
name|status
operator|->
name|value
operator|.
name|integer
argument_list|)
expr_stmt|;
return|return
name|tid
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The rpc handler called by exc_server.  */
end_comment

begin_function
name|error_t
name|S_exception_raise_request
parameter_list|(
name|mach_port_t
name|port
parameter_list|,
name|mach_port_t
name|reply_port
parameter_list|,
name|thread_t
name|thread_port
parameter_list|,
name|task_t
name|task_port
parameter_list|,
name|int
name|exception
parameter_list|,
name|int
name|code
parameter_list|,
name|int
name|subcode
parameter_list|)
block|{
name|struct
name|inf
modifier|*
name|inf
init|=
name|waiting_inf
decl_stmt|;
name|struct
name|proc
modifier|*
name|thread
init|=
name|inf_port_to_thread
argument_list|(
name|inf
argument_list|,
name|thread_port
argument_list|)
decl_stmt|;
name|inf_debug
argument_list|(
name|waiting_inf
argument_list|,
literal|"thread = %d, task = %d, exc = %d, code = %d, subcode = %d"
argument_list|,
name|thread_port
argument_list|,
name|task_port
argument_list|,
name|exception
argument_list|,
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|thread
condition|)
comment|/* We don't know about thread?  */
block|{
name|inf_update_procs
argument_list|(
name|inf
argument_list|)
expr_stmt|;
name|thread
operator|=
name|inf_port_to_thread
argument_list|(
name|inf
argument_list|,
name|thread_port
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|thread
condition|)
comment|/* Give up, the generating thread is gone.  */
return|return
literal|0
return|;
block|}
name|mach_port_deallocate
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
name|thread_port
argument_list|)
expr_stmt|;
name|mach_port_deallocate
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
name|task_port
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|thread
operator|->
name|aborted
condition|)
comment|/* THREAD hasn't been aborted since this exception happened (abortion        clears any exception state), so it must be real.  */
block|{
comment|/* Store away the details; this will destroy any previous info.  */
name|inf
operator|->
name|wait
operator|.
name|thread
operator|=
name|thread
expr_stmt|;
name|inf
operator|->
name|wait
operator|.
name|status
operator|.
name|kind
operator|=
name|TARGET_WAITKIND_STOPPED
expr_stmt|;
if|if
condition|(
name|exception
operator|==
name|EXC_BREAKPOINT
condition|)
comment|/* GDB likes to get SIGTRAP for breakpoints.  */
block|{
name|inf
operator|->
name|wait
operator|.
name|status
operator|.
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_TRAP
expr_stmt|;
name|mach_port_deallocate
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
name|reply_port
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Record the exception so that we can forward it later.  */
block|{
if|if
condition|(
name|thread
operator|->
name|exc_port
operator|==
name|port
condition|)
name|inf
operator|->
name|wait
operator|.
name|exc
operator|.
name|handler
operator|=
name|thread
operator|->
name|saved_exc_port
expr_stmt|;
else|else
block|{
name|inf
operator|->
name|wait
operator|.
name|exc
operator|.
name|handler
operator|=
name|inf
operator|->
name|task
operator|->
name|saved_exc_port
expr_stmt|;
name|assert
argument_list|(
name|inf
operator|->
name|task
operator|->
name|exc_port
operator|==
name|port
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|inf
operator|->
name|wait
operator|.
name|exc
operator|.
name|handler
operator|!=
name|MACH_PORT_NULL
condition|)
comment|/* Add a reference to the exception handler. */
name|mach_port_mod_refs
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
name|inf
operator|->
name|wait
operator|.
name|exc
operator|.
name|handler
argument_list|,
name|MACH_PORT_RIGHT_SEND
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|inf
operator|->
name|wait
operator|.
name|exc
operator|.
name|exception
operator|=
name|exception
expr_stmt|;
name|inf
operator|->
name|wait
operator|.
name|exc
operator|.
name|code
operator|=
name|code
expr_stmt|;
name|inf
operator|->
name|wait
operator|.
name|exc
operator|.
name|subcode
operator|=
name|subcode
expr_stmt|;
name|inf
operator|->
name|wait
operator|.
name|exc
operator|.
name|reply
operator|=
name|reply_port
expr_stmt|;
comment|/* Exceptions are encoded in the signal space by putting them after 	     _NSIG; this assumes they're positive (and not extremely large)! */
name|inf
operator|->
name|wait
operator|.
name|status
operator|.
name|value
operator|.
name|sig
operator|=
name|target_signal_from_host
argument_list|(
name|_NSIG
operator|+
name|exception
argument_list|)
expr_stmt|;
block|}
block|}
else|else
comment|/* A supppressed exception, which ignore.  */
block|{
name|inf
operator|->
name|wait
operator|.
name|suppress
operator|=
literal|1
expr_stmt|;
name|mach_port_deallocate
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
name|reply_port
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Fill in INF's wait field after a task has died without giving us more    detailed information.  */
end_comment

begin_function
name|void
name|inf_task_died_status
parameter_list|(
name|struct
name|inf
modifier|*
name|inf
parameter_list|)
block|{
name|warning
argument_list|(
literal|"Pid %d died with unknown exit status, using SIGKILL."
argument_list|,
name|inf
operator|->
name|pid
argument_list|)
expr_stmt|;
name|inf
operator|->
name|wait
operator|.
name|status
operator|.
name|kind
operator|=
name|TARGET_WAITKIND_SIGNALLED
expr_stmt|;
name|inf
operator|->
name|wait
operator|.
name|status
operator|.
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_KILL
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Notify server routines.  The only real one is dead name notification.  */
end_comment

begin_function
name|error_t
name|do_mach_notify_dead_name
parameter_list|(
name|mach_port_t
name|notify
parameter_list|,
name|mach_port_t
name|dead_port
parameter_list|)
block|{
name|struct
name|inf
modifier|*
name|inf
init|=
name|waiting_inf
decl_stmt|;
name|inf_debug
argument_list|(
name|waiting_inf
argument_list|,
literal|"port = %d"
argument_list|,
name|dead_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|inf
operator|->
name|task
operator|&&
name|inf
operator|->
name|task
operator|->
name|port
operator|==
name|dead_port
condition|)
block|{
name|proc_debug
argument_list|(
name|inf
operator|->
name|task
argument_list|,
literal|"is dead"
argument_list|)
expr_stmt|;
name|inf
operator|->
name|task
operator|->
name|port
operator|=
name|MACH_PORT_NULL
expr_stmt|;
if|if
condition|(
name|proc_wait_pid
operator|==
name|inf
operator|->
name|pid
condition|)
comment|/* We have a wait outstanding on the process, which will return more 	   detailed information, so delay until we get that.  */
name|inf
operator|->
name|wait
operator|.
name|suppress
operator|=
literal|1
expr_stmt|;
else|else
comment|/* We never waited for the process (maybe it wasn't a child), so just 	   pretend it got a SIGKILL.  */
name|inf_task_died_status
argument_list|(
name|inf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|proc
modifier|*
name|thread
init|=
name|inf_port_to_thread
argument_list|(
name|inf
argument_list|,
name|dead_port
argument_list|)
decl_stmt|;
if|if
condition|(
name|thread
condition|)
block|{
name|proc_debug
argument_list|(
name|thread
argument_list|,
literal|"is dead"
argument_list|)
expr_stmt|;
name|thread
operator|->
name|port
operator|=
name|MACH_PORT_NULL
expr_stmt|;
block|}
block|}
name|mach_port_deallocate
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
name|dead_port
argument_list|)
expr_stmt|;
name|inf
operator|->
name|threads_up_to_date
operator|=
literal|0
expr_stmt|;
comment|/* Just in case */
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|error_t
name|ill_rpc
parameter_list|(
name|char
modifier|*
name|fun
parameter_list|)
block|{
name|warning
argument_list|(
literal|"illegal rpc: %s"
argument_list|,
name|fun
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|error_t
name|do_mach_notify_no_senders
parameter_list|(
name|mach_port_t
name|notify
parameter_list|,
name|mach_port_mscount_t
name|count
parameter_list|)
block|{
return|return
name|ill_rpc
argument_list|(
name|__FUNCTION__
argument_list|)
return|;
block|}
end_function

begin_function
name|error_t
name|do_mach_notify_port_deleted
parameter_list|(
name|mach_port_t
name|notify
parameter_list|,
name|mach_port_t
name|name
parameter_list|)
block|{
return|return
name|ill_rpc
argument_list|(
name|__FUNCTION__
argument_list|)
return|;
block|}
end_function

begin_function
name|error_t
name|do_mach_notify_msg_accepted
parameter_list|(
name|mach_port_t
name|notify
parameter_list|,
name|mach_port_t
name|name
parameter_list|)
block|{
return|return
name|ill_rpc
argument_list|(
name|__FUNCTION__
argument_list|)
return|;
block|}
end_function

begin_function
name|error_t
name|do_mach_notify_port_destroyed
parameter_list|(
name|mach_port_t
name|notify
parameter_list|,
name|mach_port_t
name|name
parameter_list|)
block|{
return|return
name|ill_rpc
argument_list|(
name|__FUNCTION__
argument_list|)
return|;
block|}
end_function

begin_function
name|error_t
name|do_mach_notify_send_once
parameter_list|(
name|mach_port_t
name|notify
parameter_list|)
block|{
return|return
name|ill_rpc
argument_list|(
name|__FUNCTION__
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Process_reply server routines.  We only use process_wait_reply.  */
end_comment

begin_function
name|error_t
name|S_proc_wait_reply
parameter_list|(
name|mach_port_t
name|reply
parameter_list|,
name|error_t
name|err
parameter_list|,
name|int
name|status
parameter_list|,
name|rusage_t
name|rusage
parameter_list|,
name|pid_t
name|pid
parameter_list|)
block|{
name|struct
name|inf
modifier|*
name|inf
init|=
name|waiting_inf
decl_stmt|;
name|inf_debug
argument_list|(
name|inf
argument_list|,
literal|"err = %s, pid = %d, status = 0x%x"
argument_list|,
name|err
condition|?
name|strerror
argument_list|(
name|err
argument_list|)
else|:
literal|"0"
argument_list|,
name|pid
argument_list|,
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|proc_wait_pid
operator|&&
operator|(
operator|!
name|inf
operator|->
name|task
operator|||
operator|!
name|inf
operator|->
name|task
operator|->
name|port
operator|)
condition|)
comment|/* Ack.  The task has died, but the task-died notification code didn't        tell anyone because it thought a more detailed reply from the        procserver was forthcoming.  However, we now learn that won't        happen...  So we have to act like the task just died, and this time,        tell the world.  */
name|inf_task_died_status
argument_list|(
name|inf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|proc_waits_pending
operator|==
literal|0
condition|)
comment|/* PROC_WAIT_PID represents the most recent wait.  We will always get        replies in order because the proc server is single threaded.  */
name|proc_wait_pid
operator|=
literal|0
expr_stmt|;
name|inf_debug
argument_list|(
name|inf
argument_list|,
literal|"waits pending now: %d"
argument_list|,
name|proc_waits_pending
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|!=
name|EINTR
condition|)
block|{
name|warning
argument_list|(
literal|"Can't wait for pid %d: %s"
argument_list|,
name|inf
operator|->
name|pid
argument_list|,
name|strerror
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
name|inf
operator|->
name|no_wait
operator|=
literal|1
expr_stmt|;
comment|/* Since we can't see the inferior's signals, don't trap them.  */
name|inf_set_traced
argument_list|(
name|inf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|pid
operator|==
name|inf
operator|->
name|pid
condition|)
block|{
name|store_waitstatus
argument_list|(
operator|&
name|inf
operator|->
name|wait
operator|.
name|status
argument_list|,
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|inf
operator|->
name|wait
operator|.
name|status
operator|.
name|kind
operator|==
name|TARGET_WAITKIND_STOPPED
condition|)
comment|/* The process has sent us a signal, and stopped itself in a sane 	   state pending our actions.  */
block|{
name|inf_debug
argument_list|(
name|inf
argument_list|,
literal|"process has stopped itself"
argument_list|)
expr_stmt|;
name|inf
operator|->
name|stopped
operator|=
literal|1
expr_stmt|;
comment|/* We recheck the task suspend count here because the crash server 	     messes with it in an unfriendly way, right before `stopping'.  */
name|inf_validate_task_sc
argument_list|(
name|inf
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|inf
operator|->
name|wait
operator|.
name|suppress
operator|=
literal|1
expr_stmt|;
comment|/* Something odd happened.  Ignore.  */
return|return
literal|0
return|;
block|}
end_function

begin_function
name|error_t
name|S_proc_setmsgport_reply
parameter_list|(
name|mach_port_t
name|reply
parameter_list|,
name|error_t
name|err
parameter_list|,
name|mach_port_t
name|old_msg_port
parameter_list|)
block|{
return|return
name|ill_rpc
argument_list|(
name|__FUNCTION__
argument_list|)
return|;
block|}
end_function

begin_function
name|error_t
name|S_proc_getmsgport_reply
parameter_list|(
name|mach_port_t
name|reply
parameter_list|,
name|error_t
name|err
parameter_list|,
name|mach_port_t
name|msg_port
parameter_list|)
block|{
return|return
name|ill_rpc
argument_list|(
name|__FUNCTION__
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Msg_reply server routines.  We only use msg_sig_post_untraced_reply.  */
end_comment

begin_function
name|error_t
name|S_msg_sig_post_untraced_reply
parameter_list|(
name|mach_port_t
name|reply
parameter_list|,
name|error_t
name|err
parameter_list|)
block|{
name|struct
name|inf
modifier|*
name|inf
init|=
name|waiting_inf
decl_stmt|;
if|if
condition|(
name|err
operator|==
name|EBUSY
condition|)
comment|/* EBUSY is what we get when the crash server has grabbed control of the        process and doesn't like what signal we tried to send it.  Just act        like the process stopped (using a signal of 0 should mean that the        *next* time the user continues, it will pass signal 0, which the crash        server should like).  */
block|{
name|inf
operator|->
name|wait
operator|.
name|status
operator|.
name|kind
operator|=
name|TARGET_WAITKIND_STOPPED
expr_stmt|;
name|inf
operator|->
name|wait
operator|.
name|status
operator|.
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|err
condition|)
name|warning
argument_list|(
literal|"Signal delivery failed: %s"
argument_list|,
name|strerror
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
comment|/* We only get this reply when we've posted a signal to a process which we        thought was stopped, and which we expected to continue after the signal.        Given that the signal has failed for some reason, it's reasonable to        assume it's still stopped.  */
name|inf
operator|->
name|stopped
operator|=
literal|1
expr_stmt|;
else|else
name|inf
operator|->
name|wait
operator|.
name|suppress
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|error_t
name|S_msg_sig_post_reply
parameter_list|(
name|mach_port_t
name|reply
parameter_list|,
name|error_t
name|err
parameter_list|)
block|{
return|return
name|ill_rpc
argument_list|(
name|__FUNCTION__
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Returns the number of messages queued for the receive right PORT.  */
end_comment

begin_function
specifier|static
name|mach_port_msgcount_t
name|port_msgs_queued
parameter_list|(
name|mach_port_t
name|port
parameter_list|)
block|{
name|struct
name|mach_port_status
name|status
decl_stmt|;
name|error_t
name|err
init|=
name|mach_port_get_receive_status
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
name|port
argument_list|,
operator|&
name|status
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
condition|)
return|return
literal|0
return|;
else|else
return|return
name|status
operator|.
name|mps_msgcount
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Resume execution of the inferior process.     If STEP is nonzero, single-step it.    If SIGNAL is nonzero, give it that signal.     TID  STEP:    -1   true   Single step the current thread allowing other threads to run.    -1   false  Continue the current thread allowing other threads to run.    X    true   Single step the given thread, don't allow any others to run.    X    false  Continue the given thread, do not allow any others to run.    (Where X, of course, is anything except -1)     Note that a resume may not `take' if there are pending exceptions/&c    still unprocessed from the last resume we did (any given resume may result    in multiple events returned by wait). */
end_comment

begin_function
specifier|static
name|void
name|gnu_resume
parameter_list|(
name|int
name|tid
parameter_list|,
name|int
name|step
parameter_list|,
name|enum
name|target_signal
name|sig
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|step_thread
init|=
literal|0
decl_stmt|;
name|struct
name|inf
modifier|*
name|inf
init|=
name|current_inferior
decl_stmt|;
name|inf_debug
argument_list|(
name|inf
argument_list|,
literal|"tid = %d, step = %d, sig = %d"
argument_list|,
name|tid
argument_list|,
name|step
argument_list|,
name|sig
argument_list|)
expr_stmt|;
if|if
condition|(
name|sig
operator|!=
name|TARGET_SIGNAL_0
operator|||
name|inf
operator|->
name|stopped
condition|)
name|inf_signal
argument_list|(
name|inf
argument_list|,
name|sig
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|inf
operator|->
name|wait
operator|.
name|exc
operator|.
name|reply
operator|!=
name|MACH_PORT_NULL
condition|)
comment|/* We received an exception to which we have chosen not to forward, so        abort the faulting thread, which will perhaps retake it.  */
block|{
name|proc_abort
argument_list|(
name|inf
operator|->
name|wait
operator|.
name|thread
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"Aborting %s with unforwarded exception %s."
argument_list|,
name|proc_string
argument_list|(
name|inf
operator|->
name|wait
operator|.
name|thread
argument_list|)
argument_list|,
name|target_signal_to_name
argument_list|(
name|inf
operator|->
name|wait
operator|.
name|status
operator|.
name|value
operator|.
name|sig
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|port_msgs_queued
argument_list|(
name|inf
operator|->
name|event_port
argument_list|)
condition|)
comment|/* If there are still messages in our event queue, don't bother resuming        the process, as we're just going to stop it right away anyway. */
return|return;
if|if
condition|(
name|tid
operator|<
literal|0
condition|)
comment|/* Allow all threads to run, except perhaps single-stepping one.  */
block|{
name|inf_debug
argument_list|(
name|inf
argument_list|,
literal|"running all threads; tid = %d"
argument_list|,
name|inferior_pid
argument_list|)
expr_stmt|;
name|tid
operator|=
name|inferior_pid
expr_stmt|;
comment|/* What to step. */
name|inf_set_threads_resume_sc
argument_list|(
name|inf
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Just allow a single thread to run.  */
block|{
name|struct
name|proc
modifier|*
name|thread
init|=
name|inf_tid_to_thread
argument_list|(
name|inf
argument_list|,
name|tid
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|thread
argument_list|)
expr_stmt|;
name|inf_debug
argument_list|(
name|inf
argument_list|,
literal|"running one thread: %d/%d"
argument_list|,
name|inf
operator|->
name|pid
argument_list|,
name|thread
operator|->
name|tid
argument_list|)
expr_stmt|;
name|inf_set_threads_resume_sc
argument_list|(
name|inf
argument_list|,
name|thread
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|step
condition|)
block|{
name|step_thread
operator|=
name|inf_tid_to_thread
argument_list|(
name|inf
argument_list|,
name|tid
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|step_thread
argument_list|)
expr_stmt|;
name|inf_debug
argument_list|(
name|inf
argument_list|,
literal|"stepping thread: %d/%d"
argument_list|,
name|inf
operator|->
name|pid
argument_list|,
name|step_thread
operator|->
name|tid
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|step_thread
operator|!=
name|inf
operator|->
name|step_thread
condition|)
name|inf_set_step_thread
argument_list|(
name|inf
argument_list|,
name|step_thread
argument_list|)
expr_stmt|;
name|inf_debug
argument_list|(
name|inf
argument_list|,
literal|"here we go..."
argument_list|)
expr_stmt|;
name|inf_resume
argument_list|(
name|inf
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|gnu_kill_inferior
parameter_list|()
block|{
name|struct
name|proc
modifier|*
name|task
init|=
name|current_inferior
operator|->
name|task
decl_stmt|;
if|if
condition|(
name|task
condition|)
block|{
name|proc_debug
argument_list|(
name|task
argument_list|,
literal|"terminating..."
argument_list|)
expr_stmt|;
name|task_terminate
argument_list|(
name|task
operator|->
name|port
argument_list|)
expr_stmt|;
name|task
operator|->
name|port
operator|=
name|MACH_PORT_NULL
expr_stmt|;
name|inf_validate_procs
argument_list|(
name|current_inferior
argument_list|)
expr_stmt|;
comment|/* Clear out the thread list&c */
block|}
name|target_mourn_inferior
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clean up after the inferior dies.  */
end_comment

begin_function
specifier|static
name|void
name|gnu_mourn_inferior
parameter_list|()
block|{
name|inf_debug
argument_list|(
name|current_inferior
argument_list|,
literal|"rip"
argument_list|)
expr_stmt|;
name|inf_detach
argument_list|(
name|current_inferior
argument_list|)
expr_stmt|;
name|unpush_target
argument_list|(
operator|&
name|gnu_ops
argument_list|)
expr_stmt|;
name|generic_mourn_inferior
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Fork an inferior process, and start debugging it.  */
end_comment

begin_comment
comment|/* Set INFERIOR_PID to the first thread available in the child, if any.  */
end_comment

begin_function
specifier|static
name|void
name|pick_first_thread
parameter_list|()
block|{
if|if
condition|(
name|current_inferior
operator|->
name|task
operator|&&
name|current_inferior
operator|->
name|threads
condition|)
comment|/* The first thread.  */
name|inferior_pid
operator|=
name|current_inferior
operator|->
name|threads
operator|->
name|tid
expr_stmt|;
else|else
comment|/* What may be the next thread.  */
name|inferior_pid
operator|=
name|next_thread_id
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|inf
modifier|*
name|cur_inf
parameter_list|()
block|{
if|if
condition|(
operator|!
name|current_inferior
condition|)
name|current_inferior
operator|=
name|make_inf
argument_list|()
expr_stmt|;
return|return
name|current_inferior
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|gnu_create_inferior
parameter_list|(
name|exec_file
parameter_list|,
name|allargs
parameter_list|,
name|env
parameter_list|)
name|char
modifier|*
name|exec_file
decl_stmt|;
name|char
modifier|*
name|allargs
decl_stmt|;
name|char
modifier|*
modifier|*
name|env
decl_stmt|;
block|{
name|struct
name|inf
modifier|*
name|inf
init|=
name|cur_inf
argument_list|()
decl_stmt|;
name|void
name|trace_me
parameter_list|()
block|{
comment|/* We're in the child; make this process stop as soon as it execs.  */
name|inf_debug
argument_list|(
name|inf
argument_list|,
literal|"tracing self"
argument_list|)
expr_stmt|;
name|ptrace
argument_list|(
name|PTRACE_TRACEME
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|void
name|attach_to_child
parameter_list|(
name|int
name|pid
parameter_list|)
block|{
comment|/* Attach to the now stopped child, which is actually a shell...  */
name|inf_debug
argument_list|(
name|inf
argument_list|,
literal|"attaching to child: %d"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
name|inf_attach
argument_list|(
name|inf
argument_list|,
name|pid
argument_list|)
expr_stmt|;
name|pick_first_thread
argument_list|()
expr_stmt|;
name|attach_flag
operator|=
literal|0
expr_stmt|;
name|push_target
argument_list|(
operator|&
name|gnu_ops
argument_list|)
expr_stmt|;
name|inf
operator|->
name|pending_execs
operator|=
literal|2
expr_stmt|;
name|inf
operator|->
name|traced
operator|=
literal|1
expr_stmt|;
comment|/* Now let the child run again, knowing that it will stop immediately 	 because of the ptrace. */
name|inf_resume
argument_list|(
name|inf
argument_list|)
expr_stmt|;
name|startup_inferior
argument_list|(
name|pid
argument_list|,
name|inf
operator|->
name|pending_execs
argument_list|)
expr_stmt|;
block|}
name|inf_debug
argument_list|(
name|inf
argument_list|,
literal|"creating inferior"
argument_list|)
expr_stmt|;
name|fork_inferior
argument_list|(
name|exec_file
argument_list|,
name|allargs
argument_list|,
name|env
argument_list|,
name|trace_me
argument_list|,
name|attach_to_child
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|inf_update_signal_thread
argument_list|(
name|inf
argument_list|)
expr_stmt|;
name|inf_set_traced
argument_list|(
name|inf
argument_list|,
name|inf
operator|->
name|want_signals
argument_list|)
expr_stmt|;
comment|/* Execing the process will have trashed our exception ports; steal them      back (or make sure they're restored if the user wants that).  */
if|if
condition|(
name|inf
operator|->
name|want_exceptions
condition|)
name|inf_steal_exc_ports
argument_list|(
name|inf
argument_list|)
expr_stmt|;
else|else
name|inf_restore_exc_ports
argument_list|(
name|inf
argument_list|)
expr_stmt|;
comment|/* Here we go!  */
name|proceed
argument_list|(
operator|(
name|CORE_ADDR
operator|)
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Mark our target-struct as eligible for stray "run" and "attach"    commands.  */
end_comment

begin_function
specifier|static
name|int
name|gnu_can_run
parameter_list|()
block|{
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|ATTACH_DETACH
end_ifdef

begin_comment
comment|/* Attach to process PID, then initialize for debugging it    and wait for the trace-trap that results from attaching.  */
end_comment

begin_function
specifier|static
name|void
name|gnu_attach
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|int
name|pid
decl_stmt|;
name|char
modifier|*
name|exec_file
decl_stmt|;
name|struct
name|inf
modifier|*
name|inf
init|=
name|cur_inf
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|args
condition|)
name|error_no_arg
argument_list|(
literal|"PID to attach"
argument_list|)
expr_stmt|;
name|pid
operator|=
name|atoi
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|==
name|getpid
argument_list|()
condition|)
comment|/* Trying to masturbate? */
name|error
argument_list|(
literal|"I refuse to debug myself!"
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
block|{
name|exec_file
operator|=
operator|(
name|char
operator|*
operator|)
name|get_exec_file
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|exec_file
condition|)
name|printf_unfiltered
argument_list|(
literal|"Attaching to program `%s', pid %d\n"
argument_list|,
name|exec_file
argument_list|,
name|pid
argument_list|)
expr_stmt|;
else|else
name|printf_unfiltered
argument_list|(
literal|"Attaching to pid %d\n"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
name|inf_debug
argument_list|(
name|inf
argument_list|,
literal|"attaching to pid: %d"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
name|inf_attach
argument_list|(
name|inf
argument_list|,
name|pid
argument_list|)
expr_stmt|;
name|inf_update_procs
argument_list|(
name|inf
argument_list|)
expr_stmt|;
name|pick_first_thread
argument_list|()
expr_stmt|;
name|attach_flag
operator|=
literal|1
expr_stmt|;
name|push_target
argument_list|(
operator|&
name|gnu_ops
argument_list|)
expr_stmt|;
name|inf_update_signal_thread
argument_list|(
name|inf
argument_list|)
expr_stmt|;
name|inf_set_traced
argument_list|(
name|inf
argument_list|,
name|inf
operator|->
name|want_signals
argument_list|)
expr_stmt|;
comment|/* If the process was stopped before we attached, make it continue the next      time the user does a continue.  */
name|inf_validate_stopped
argument_list|(
name|inf
argument_list|)
expr_stmt|;
name|inf_validate_task_sc
argument_list|(
name|inf
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Take a program previously attached to and detaches it.    The program resumes execution and will no longer stop    on signals, etc.  We'd better not have left any breakpoints    in the program or it'll die when it hits one.  For this    to work, it may be necessary for the process to have been    previously attached.  It *might* work if the program was    started via fork.  */
end_comment

begin_function
specifier|static
name|void
name|gnu_detach
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
if|if
condition|(
name|from_tty
condition|)
block|{
name|char
modifier|*
name|exec_file
init|=
name|get_exec_file
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|exec_file
condition|)
name|printf_unfiltered
argument_list|(
literal|"Detaching from program `%s' pid %d\n"
argument_list|,
name|exec_file
argument_list|,
name|current_inferior
operator|->
name|pid
argument_list|)
expr_stmt|;
else|else
name|printf_unfiltered
argument_list|(
literal|"Detaching from pid %d\n"
argument_list|,
name|current_inferior
operator|->
name|pid
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
name|inf_detach
argument_list|(
name|current_inferior
argument_list|)
expr_stmt|;
name|inferior_pid
operator|=
literal|0
expr_stmt|;
name|unpush_target
argument_list|(
operator|&
name|gnu_ops
argument_list|)
expr_stmt|;
comment|/* Pop out of handling an inferior */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ATTACH_DETACH */
end_comment

begin_function
specifier|static
name|void
name|gnu_terminal_init_inferior
parameter_list|()
block|{
name|assert
argument_list|(
name|current_inferior
argument_list|)
expr_stmt|;
name|terminal_init_inferior_with_pgrp
argument_list|(
name|current_inferior
operator|->
name|pid
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get ready to modify the registers array.  On machines which store    individual registers, this doesn't need to do anything.  On machines    which store all the registers in one fell swoop, this makes sure    that registers contains all the registers from the program being    debugged.  */
end_comment

begin_function
specifier|static
name|void
name|gnu_prepare_to_store
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|CHILD_PREPARE_TO_STORE
name|CHILD_PREPARE_TO_STORE
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|gnu_open
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|error
argument_list|(
literal|"Use the \"run\" command to start a Unix child process."
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gnu_stop
parameter_list|()
block|{
name|error
argument_list|(
literal|"to_stop target function not implemented"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|gnu_thread_alive
parameter_list|(
name|int
name|tid
parameter_list|)
block|{
name|inf_update_procs
argument_list|(
name|current_inferior
argument_list|)
expr_stmt|;
return|return
operator|!
operator|!
name|inf_tid_to_thread
argument_list|(
name|current_inferior
argument_list|,
name|tid
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Read inferior task's LEN bytes from ADDR and copy it to MYADDR  * in gdb's address space.  *  * Return 0 on failure; number of bytes read otherwise.  */
end_comment

begin_function
name|int
name|gnu_read_inferior
parameter_list|(
name|task
parameter_list|,
name|addr
parameter_list|,
name|myaddr
parameter_list|,
name|length
parameter_list|)
name|task_t
name|task
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|length
decl_stmt|;
block|{
name|error_t
name|err
decl_stmt|;
name|vm_address_t
name|low_address
init|=
operator|(
name|vm_address_t
operator|)
name|trunc_page
argument_list|(
name|addr
argument_list|)
decl_stmt|;
name|vm_size_t
name|aligned_length
init|=
operator|(
name|vm_size_t
operator|)
name|round_page
argument_list|(
name|addr
operator|+
name|length
argument_list|)
operator|-
name|low_address
decl_stmt|;
name|pointer_t
name|copied
decl_stmt|;
name|int
name|copy_count
decl_stmt|;
comment|/* Get memory from inferior with page aligned addresses */
name|err
operator|=
name|vm_read
argument_list|(
name|task
argument_list|,
name|low_address
argument_list|,
name|aligned_length
argument_list|,
operator|&
name|copied
argument_list|,
operator|&
name|copy_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
literal|0
return|;
name|err
operator|=
name|hurd_safe_copyin
argument_list|(
name|myaddr
argument_list|,
operator|(
name|void
operator|*
operator|)
name|addr
operator|-
name|low_address
operator|+
name|copied
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|warning
argument_list|(
literal|"Read from inferior faulted: %s"
argument_list|,
name|strerror
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
name|length
operator|=
literal|0
expr_stmt|;
block|}
name|err
operator|=
name|vm_deallocate
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
name|copied
argument_list|,
name|copy_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|warning
argument_list|(
literal|"gnu_read_inferior vm_deallocate failed: %s"
argument_list|,
name|strerror
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|length
return|;
block|}
end_function

begin_define
define|#
directive|define
name|CHK_GOTO_OUT
parameter_list|(
name|str
parameter_list|,
name|ret
parameter_list|)
define|\
value|do if (ret != KERN_SUCCESS) { errstr = #str; goto out; } while(0)
end_define

begin_struct
struct|struct
name|vm_region_list
block|{
name|struct
name|vm_region_list
modifier|*
name|next
decl_stmt|;
name|vm_prot_t
name|protection
decl_stmt|;
name|vm_address_t
name|start
decl_stmt|;
name|vm_size_t
name|length
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|obstack
name|region_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Write inferior task's LEN bytes from ADDR and copy it to MYADDR  * in gdb's address space.  */
end_comment

begin_function
name|int
name|gnu_write_inferior
parameter_list|(
name|task
parameter_list|,
name|addr
parameter_list|,
name|myaddr
parameter_list|,
name|length
parameter_list|)
name|task_t
name|task
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|length
decl_stmt|;
block|{
name|error_t
name|err
init|=
literal|0
decl_stmt|;
name|vm_address_t
name|low_address
init|=
operator|(
name|vm_address_t
operator|)
name|trunc_page
argument_list|(
name|addr
argument_list|)
decl_stmt|;
name|vm_size_t
name|aligned_length
init|=
operator|(
name|vm_size_t
operator|)
name|round_page
argument_list|(
name|addr
operator|+
name|length
argument_list|)
operator|-
name|low_address
decl_stmt|;
name|pointer_t
name|copied
decl_stmt|;
name|int
name|copy_count
decl_stmt|;
name|int
name|deallocate
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|errstr
init|=
literal|"Bug in gnu_write_inferior"
decl_stmt|;
name|struct
name|vm_region_list
modifier|*
name|region_element
decl_stmt|;
name|struct
name|vm_region_list
modifier|*
name|region_head
init|=
operator|(
expr|struct
name|vm_region_list
operator|*
operator|)
name|NULL
decl_stmt|;
comment|/* Get memory from inferior with page aligned addresses */
name|err
operator|=
name|vm_read
argument_list|(
name|task
argument_list|,
name|low_address
argument_list|,
name|aligned_length
argument_list|,
operator|&
name|copied
argument_list|,
operator|&
name|copy_count
argument_list|)
expr_stmt|;
name|CHK_GOTO_OUT
argument_list|(
literal|"gnu_write_inferior vm_read failed"
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|deallocate
operator|++
expr_stmt|;
name|err
operator|=
name|hurd_safe_copyout
argument_list|(
operator|(
name|void
operator|*
operator|)
name|addr
operator|-
name|low_address
operator|+
name|copied
argument_list|,
name|myaddr
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|CHK_GOTO_OUT
argument_list|(
literal|"Write to inferior faulted"
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|obstack_init
argument_list|(
operator|&
name|region_obstack
argument_list|)
expr_stmt|;
comment|/* Do writes atomically.    * First check for holes and unwritable memory.    */
block|{
name|vm_size_t
name|remaining_length
init|=
name|aligned_length
decl_stmt|;
name|vm_address_t
name|region_address
init|=
name|low_address
decl_stmt|;
name|struct
name|vm_region_list
modifier|*
name|scan
decl_stmt|;
while|while
condition|(
name|region_address
operator|<
name|low_address
operator|+
name|aligned_length
condition|)
block|{
name|vm_prot_t
name|protection
decl_stmt|;
name|vm_prot_t
name|max_protection
decl_stmt|;
name|vm_inherit_t
name|inheritance
decl_stmt|;
name|boolean_t
name|shared
decl_stmt|;
name|mach_port_t
name|object_name
decl_stmt|;
name|vm_offset_t
name|offset
decl_stmt|;
name|vm_size_t
name|region_length
init|=
name|remaining_length
decl_stmt|;
name|vm_address_t
name|old_address
init|=
name|region_address
decl_stmt|;
name|err
operator|=
name|vm_region
argument_list|(
name|task
argument_list|,
operator|&
name|region_address
argument_list|,
operator|&
name|region_length
argument_list|,
operator|&
name|protection
argument_list|,
operator|&
name|max_protection
argument_list|,
operator|&
name|inheritance
argument_list|,
operator|&
name|shared
argument_list|,
operator|&
name|object_name
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
name|CHK_GOTO_OUT
argument_list|(
literal|"vm_region failed"
argument_list|,
name|err
argument_list|)
expr_stmt|;
comment|/* Check for holes in memory */
if|if
condition|(
name|old_address
operator|!=
name|region_address
condition|)
block|{
name|warning
argument_list|(
literal|"No memory at 0x%x. Nothing written"
argument_list|,
name|old_address
argument_list|)
expr_stmt|;
name|err
operator|=
name|KERN_SUCCESS
expr_stmt|;
name|length
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|!
operator|(
name|max_protection
operator|&
name|VM_PROT_WRITE
operator|)
condition|)
block|{
name|warning
argument_list|(
literal|"Memory at address 0x%x is unwritable. Nothing written"
argument_list|,
name|old_address
argument_list|)
expr_stmt|;
name|err
operator|=
name|KERN_SUCCESS
expr_stmt|;
name|length
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Chain the regions for later use */
name|region_element
operator|=
operator|(
expr|struct
name|vm_region_list
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|region_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|vm_region_list
argument_list|)
argument_list|)
expr_stmt|;
name|region_element
operator|->
name|protection
operator|=
name|protection
expr_stmt|;
name|region_element
operator|->
name|start
operator|=
name|region_address
expr_stmt|;
name|region_element
operator|->
name|length
operator|=
name|region_length
expr_stmt|;
comment|/* Chain the regions along with protections */
name|region_element
operator|->
name|next
operator|=
name|region_head
expr_stmt|;
name|region_head
operator|=
name|region_element
expr_stmt|;
name|region_address
operator|+=
name|region_length
expr_stmt|;
name|remaining_length
operator|=
name|remaining_length
operator|-
name|region_length
expr_stmt|;
block|}
comment|/* If things fail after this, we give up.      * Somebody is messing up inferior_task's mappings.      */
comment|/* Enable writes to the chained vm regions */
for|for
control|(
name|scan
operator|=
name|region_head
init|;
name|scan
condition|;
name|scan
operator|=
name|scan
operator|->
name|next
control|)
block|{
name|boolean_t
name|protection_changed
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|scan
operator|->
name|protection
operator|&
name|VM_PROT_WRITE
operator|)
condition|)
block|{
name|err
operator|=
name|vm_protect
argument_list|(
name|task
argument_list|,
name|scan
operator|->
name|start
argument_list|,
name|scan
operator|->
name|length
argument_list|,
name|FALSE
argument_list|,
name|scan
operator|->
name|protection
operator||
name|VM_PROT_WRITE
argument_list|)
expr_stmt|;
name|CHK_GOTO_OUT
argument_list|(
literal|"vm_protect: enable write failed"
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
block|}
name|err
operator|=
name|vm_write
argument_list|(
name|task
argument_list|,
name|low_address
argument_list|,
name|copied
argument_list|,
name|aligned_length
argument_list|)
expr_stmt|;
name|CHK_GOTO_OUT
argument_list|(
literal|"vm_write failed"
argument_list|,
name|err
argument_list|)
expr_stmt|;
comment|/* Set up the original region protections, if they were changed */
for|for
control|(
name|scan
operator|=
name|region_head
init|;
name|scan
condition|;
name|scan
operator|=
name|scan
operator|->
name|next
control|)
block|{
name|boolean_t
name|protection_changed
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|scan
operator|->
name|protection
operator|&
name|VM_PROT_WRITE
operator|)
condition|)
block|{
name|err
operator|=
name|vm_protect
argument_list|(
name|task
argument_list|,
name|scan
operator|->
name|start
argument_list|,
name|scan
operator|->
name|length
argument_list|,
name|FALSE
argument_list|,
name|scan
operator|->
name|protection
argument_list|)
expr_stmt|;
name|CHK_GOTO_OUT
argument_list|(
literal|"vm_protect: enable write failed"
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|out
label|:
if|if
condition|(
name|deallocate
condition|)
block|{
name|obstack_free
argument_list|(
operator|&
name|region_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vm_deallocate
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
name|copied
argument_list|,
name|copy_count
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|!=
name|KERN_SUCCESS
condition|)
block|{
name|warning
argument_list|(
literal|"%s: %s"
argument_list|,
name|errstr
argument_list|,
name|mach_error_string
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|length
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 0 on failure, number of bytes handled otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|gnu_xfer_memory
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|,
name|write
parameter_list|,
name|target
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|write
decl_stmt|;
name|struct
name|target_ops
modifier|*
name|target
decl_stmt|;
comment|/* IGNORED */
block|{
name|int
name|result
decl_stmt|;
name|task_t
name|task
init|=
name|current_inferior
condition|?
operator|(
name|current_inferior
operator|->
name|task
condition|?
name|current_inferior
operator|->
name|task
operator|->
name|port
else|:
literal|0
operator|)
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|task
operator|==
name|MACH_PORT_NULL
condition|)
return|return
literal|0
return|;
else|else
block|{
name|inf_debug
argument_list|(
name|current_inferior
argument_list|,
literal|"%s %p[%d] %s %p"
argument_list|,
name|write
condition|?
literal|"writing"
else|:
literal|"reading"
argument_list|,
name|memaddr
argument_list|,
name|len
argument_list|,
name|write
condition|?
literal|"<--"
else|:
literal|"-->"
argument_list|,
name|myaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
condition|)
return|return
name|gnu_write_inferior
argument_list|(
name|task
argument_list|,
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
return|;
else|else
return|return
name|gnu_read_inferior
argument_list|(
name|task
argument_list|,
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function_decl
specifier|extern
name|void
name|gnu_store_registers
parameter_list|(
name|int
name|regno
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|gnu_fetch_registers
parameter_list|(
name|int
name|regno
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|target_ops
name|gnu_ops
init|=
block|{
literal|"GNU"
block|,
comment|/* to_shortname */
literal|"GNU Hurd process"
block|,
comment|/* to_longname */
literal|"GNU Hurd process"
block|,
comment|/* to_doc */
name|gnu_open
block|,
comment|/* to_open */
literal|0
block|,
comment|/* to_close */
name|gnu_attach
block|,
comment|/* to_attach */
name|gnu_detach
block|,
comment|/* to_detach */
name|gnu_resume
block|,
comment|/* to_resume */
name|gnu_wait
block|,
comment|/* to_wait */
name|gnu_fetch_registers
block|,
comment|/* to_fetch_registers */
name|gnu_store_registers
block|,
comment|/* to_store_registers */
name|gnu_prepare_to_store
block|,
comment|/* to_prepare_to_store */
name|gnu_xfer_memory
block|,
comment|/* to_xfer_memory */
literal|0
block|,
comment|/* to_files_info */
name|memory_insert_breakpoint
block|,
comment|/* to_insert_breakpoint */
name|memory_remove_breakpoint
block|,
comment|/* to_remove_breakpoint */
name|gnu_terminal_init_inferior
block|,
comment|/* to_terminal_init */
name|terminal_inferior
block|,
comment|/* to_terminal_inferior */
name|terminal_ours_for_output
block|,
comment|/* to_terminal_ours_for_output */
name|terminal_ours
block|,
comment|/* to_terminal_ours */
name|child_terminal_info
block|,
comment|/* to_terminal_info */
name|gnu_kill_inferior
block|,
comment|/* to_kill */
literal|0
block|,
comment|/* to_load */
literal|0
block|,
comment|/* to_lookup_symbol */
name|gnu_create_inferior
block|,
comment|/* to_create_inferior */
name|gnu_mourn_inferior
block|,
comment|/* to_mourn_inferior */
name|gnu_can_run
block|,
comment|/* to_can_run */
literal|0
block|,
comment|/* to_notice_signals */
name|gnu_thread_alive
block|,
comment|/* to_thread_alive */
name|gnu_stop
block|,
comment|/* to_stop */
name|process_stratum
block|,
comment|/* to_stratum */
literal|0
block|,
comment|/* to_next */
literal|1
block|,
comment|/* to_has_all_memory */
literal|1
block|,
comment|/* to_has_memory */
literal|1
block|,
comment|/* to_has_stack */
literal|1
block|,
comment|/* to_has_registers */
literal|1
block|,
comment|/* to_has_execution */
literal|0
block|,
comment|/* sections */
literal|0
block|,
comment|/* sections_end */
name|OPS_MAGIC
comment|/* to_magic */
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
name|char
modifier|*
name|proc_string
parameter_list|(
name|struct
name|proc
modifier|*
name|proc
parameter_list|)
block|{
specifier|static
name|char
name|tid_str
index|[
literal|80
index|]
decl_stmt|;
if|if
condition|(
name|proc_is_task
argument_list|(
name|proc
argument_list|)
condition|)
name|sprintf
argument_list|(
name|tid_str
argument_list|,
literal|"process %d"
argument_list|,
name|proc
operator|->
name|inf
operator|->
name|pid
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|tid_str
argument_list|,
literal|"thread %d.%d"
argument_list|,
name|proc
operator|->
name|inf
operator|->
name|pid
argument_list|,
name|pid_to_thread_id
argument_list|(
name|proc
operator|->
name|tid
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|tid_str
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|gnu_target_pid_to_str
parameter_list|(
name|int
name|tid
parameter_list|)
block|{
name|struct
name|inf
modifier|*
name|inf
init|=
name|current_inferior
decl_stmt|;
name|struct
name|proc
modifier|*
name|thread
init|=
name|inf_tid_to_thread
argument_list|(
name|inf
argument_list|,
name|tid
argument_list|)
decl_stmt|;
if|if
condition|(
name|thread
condition|)
return|return
name|proc_string
argument_list|(
name|thread
argument_list|)
return|;
else|else
block|{
specifier|static
name|char
name|tid_str
index|[
literal|80
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|tid_str
argument_list|,
literal|"bogus thread id %d"
argument_list|,
name|tid
argument_list|)
expr_stmt|;
return|return
name|tid_str
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* User task commands.  */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|set_task_cmd_list
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|show_task_cmd_list
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|cmd_list_element
modifier|*
name|set_thread_default_cmd_list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|cmd_list_element
modifier|*
name|show_thread_default_cmd_list
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|_parse_bool_arg
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|char
modifier|*
name|t_val
parameter_list|,
name|char
modifier|*
name|f_val
parameter_list|,
name|char
modifier|*
name|cmd_prefix
parameter_list|)
block|{
if|if
condition|(
operator|!
name|args
operator|||
name|strcmp
argument_list|(
name|args
argument_list|,
name|t_val
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|args
argument_list|,
name|f_val
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
else|else
name|error
argument_list|(
literal|"Illegal argument for \"%s\" command, should be \"%s\" or \"%s\"."
argument_list|,
name|cmd_prefix
argument_list|,
name|t_val
argument_list|,
name|f_val
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|parse_bool_arg
parameter_list|(
name|args
parameter_list|,
name|cmd_prefix
parameter_list|)
define|\
value|_parse_bool_arg (args, "on", "off", cmd_prefix)
end_define

begin_function
specifier|static
name|void
name|check_empty
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|char
modifier|*
name|cmd_prefix
parameter_list|)
block|{
if|if
condition|(
name|args
condition|)
name|error
argument_list|(
literal|"Garbage after \"%s\" command: `%s'"
argument_list|,
name|cmd_prefix
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns the alive thread named by INFERIOR_PID, or signals an error.  */
end_comment

begin_function
specifier|static
name|struct
name|proc
modifier|*
name|cur_thread
parameter_list|()
block|{
name|struct
name|inf
modifier|*
name|inf
init|=
name|cur_inf
argument_list|()
decl_stmt|;
name|struct
name|proc
modifier|*
name|thread
init|=
name|inf_tid_to_thread
argument_list|(
name|inf
argument_list|,
name|inferior_pid
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|thread
condition|)
name|error
argument_list|(
literal|"No current thread."
argument_list|)
expr_stmt|;
return|return
name|thread
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_task_pause_cmd
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|inf
modifier|*
name|inf
init|=
name|cur_inf
argument_list|()
decl_stmt|;
name|int
name|old_sc
init|=
name|inf
operator|->
name|pause_sc
decl_stmt|;
name|inf
operator|->
name|pause_sc
operator|=
name|parse_bool_arg
argument_list|(
name|args
argument_list|,
literal|"set task pause"
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_sc
operator|==
literal|0
operator|&&
name|inf
operator|->
name|pause_sc
operator|!=
literal|0
condition|)
comment|/* If the task is currently unsuspended, immediately suspend it,        otherwise wait until the next time it gets control.  */
name|inf_suspend
argument_list|(
name|inf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|show_task_pause_cmd
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|inf
modifier|*
name|inf
init|=
name|cur_inf
argument_list|()
decl_stmt|;
name|check_empty
argument_list|(
name|args
argument_list|,
literal|"show task pause"
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"The inferior task %s suspended while gdb has control.\n"
argument_list|,
name|inf
operator|->
name|task
condition|?
operator|(
name|inf
operator|->
name|pause_sc
operator|==
literal|0
condition|?
literal|"isn't"
else|:
literal|"is"
operator|)
else|:
operator|(
name|inf
operator|->
name|pause_sc
operator|==
literal|0
condition|?
literal|"won't be"
else|:
literal|"will be"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_thread_default_pause_cmd
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|inf
modifier|*
name|inf
init|=
name|cur_inf
argument_list|()
decl_stmt|;
name|inf
operator|->
name|default_thread_pause_sc
operator|=
name|parse_bool_arg
argument_list|(
name|args
argument_list|,
literal|"set thread default pause"
argument_list|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|show_thread_default_pause_cmd
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|inf
modifier|*
name|inf
init|=
name|cur_inf
argument_list|()
decl_stmt|;
name|int
name|sc
init|=
name|inf
operator|->
name|default_thread_pause_sc
decl_stmt|;
name|check_empty
argument_list|(
name|args
argument_list|,
literal|"show thread default pause"
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"New threads %s suspended while gdb has control%s.\n"
argument_list|,
name|sc
condition|?
literal|"are"
else|:
literal|"aren't"
argument_list|,
operator|!
name|sc
operator|&&
name|inf
operator|->
name|pause_sc
condition|?
literal|"(but the task is)"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_thread_default_run_cmd
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|inf
modifier|*
name|inf
init|=
name|cur_inf
argument_list|()
decl_stmt|;
name|inf
operator|->
name|default_thread_run_sc
operator|=
name|parse_bool_arg
argument_list|(
name|args
argument_list|,
literal|"set thread default run"
argument_list|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|show_thread_default_run_cmd
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|inf
modifier|*
name|inf
init|=
name|cur_inf
argument_list|()
decl_stmt|;
name|check_empty
argument_list|(
name|args
argument_list|,
literal|"show thread default run"
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"New threads %s allowed to run.\n"
argument_list|,
name|inf
operator|->
name|default_thread_run_sc
operator|==
literal|0
condition|?
literal|"are"
else|:
literal|"aren't"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Steal a send right called NAME in the inferior task, and make it PROC's    saved exception port.  */
end_comment

begin_function
specifier|static
name|void
name|steal_exc_port
parameter_list|(
name|struct
name|proc
modifier|*
name|proc
parameter_list|,
name|mach_port_t
name|name
parameter_list|)
block|{
name|error_t
name|err
decl_stmt|;
name|mach_port_t
name|port
decl_stmt|;
name|mach_msg_type_name_t
name|port_type
decl_stmt|;
if|if
condition|(
operator|!
name|proc
operator|||
operator|!
name|proc
operator|->
name|inf
operator|->
name|task
condition|)
name|error
argument_list|(
literal|"No inferior task."
argument_list|)
expr_stmt|;
name|err
operator|=
name|mach_port_extract_right
argument_list|(
name|proc
operator|->
name|inf
operator|->
name|task
operator|->
name|port
argument_list|,
name|name
argument_list|,
name|MACH_MSG_TYPE_COPY_SEND
argument_list|,
operator|&
name|port
argument_list|,
operator|&
name|port_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|error
argument_list|(
literal|"Couldn't extract send right %d from inferior: %s"
argument_list|,
name|name
argument_list|,
name|strerror
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|proc
operator|->
name|saved_exc_port
condition|)
comment|/* Get rid of our reference to the old one.  */
name|mach_port_deallocate
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
name|proc
operator|->
name|saved_exc_port
argument_list|)
expr_stmt|;
name|proc
operator|->
name|saved_exc_port
operator|=
name|port
expr_stmt|;
if|if
condition|(
operator|!
name|proc
operator|->
name|exc_port
condition|)
comment|/* If PROC is a thread, we may not have set its exception port before.        We can't use proc_steal_exc_port because it also sets saved_exc_port. */
block|{
name|proc
operator|->
name|exc_port
operator|=
name|proc
operator|->
name|inf
operator|->
name|event_port
expr_stmt|;
name|err
operator|=
name|proc_set_exception_port
argument_list|(
name|proc
argument_list|,
name|proc
operator|->
name|exc_port
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Can't set exception port for %s: %s"
argument_list|,
name|proc_string
argument_list|(
name|proc
argument_list|)
argument_list|,
name|strerror
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|set_task_exc_port_cmd
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|inf
modifier|*
name|inf
init|=
name|cur_inf
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|args
condition|)
name|error
argument_list|(
literal|"No argument to \"set task exception-port\" command."
argument_list|)
expr_stmt|;
name|steal_exc_port
argument_list|(
name|inf
operator|->
name|task
argument_list|,
name|parse_and_eval_address
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_signals_cmd
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|int
name|trace
decl_stmt|;
name|struct
name|inf
modifier|*
name|inf
init|=
name|cur_inf
argument_list|()
decl_stmt|;
name|inf
operator|->
name|want_signals
operator|=
name|parse_bool_arg
argument_list|(
name|args
argument_list|,
literal|"set signals"
argument_list|)
expr_stmt|;
if|if
condition|(
name|inf
operator|->
name|task
operator|&&
name|inf
operator|->
name|want_signals
operator|!=
name|inf
operator|->
name|traced
condition|)
comment|/* Make this take effect immediately in a running process.  */
name|inf_set_traced
argument_list|(
name|inf
argument_list|,
name|inf
operator|->
name|want_signals
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|show_signals_cmd
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|inf
modifier|*
name|inf
init|=
name|cur_inf
argument_list|()
decl_stmt|;
name|check_empty
argument_list|(
name|args
argument_list|,
literal|"show signals"
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"The inferior process's signals %s intercepted.\n"
argument_list|,
name|inf
operator|->
name|task
condition|?
operator|(
name|inf
operator|->
name|traced
condition|?
literal|"are"
else|:
literal|"aren't"
operator|)
else|:
operator|(
name|inf
operator|->
name|want_signals
condition|?
literal|"will be"
else|:
literal|"won't be"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_stopped_cmd
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|cur_inf
argument_list|()
operator|->
name|stopped
operator|=
name|_parse_bool_arg
argument_list|(
name|args
argument_list|,
literal|"yes"
argument_list|,
literal|"no"
argument_list|,
literal|"set stopped"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|show_stopped_cmd
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|inf
modifier|*
name|inf
init|=
name|cur_inf
argument_list|()
decl_stmt|;
name|check_empty
argument_list|(
name|args
argument_list|,
literal|"show stopped"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|inf
operator|->
name|task
condition|)
name|error
argument_list|(
literal|"No current process."
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"The inferior process %s stopped.\n"
argument_list|,
name|inf
operator|->
name|stopped
condition|?
literal|"is"
else|:
literal|"isn't"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_sig_thread_cmd
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|int
name|tid
decl_stmt|;
name|struct
name|inf
modifier|*
name|inf
init|=
name|cur_inf
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|args
operator|||
operator|(
operator|!
name|isdigit
argument_list|(
operator|*
name|args
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|args
argument_list|,
literal|"none"
argument_list|)
operator|!=
literal|0
operator|)
condition|)
name|error
argument_list|(
literal|"Illegal argument to \"set signal-thread\" command.\n"
literal|"Should be an integer thread ID, or `none'."
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|args
argument_list|,
literal|"none"
argument_list|)
operator|==
literal|0
condition|)
name|inf
operator|->
name|signal_thread
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|int
name|tid
init|=
name|thread_id_to_pid
argument_list|(
name|atoi
argument_list|(
name|args
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|tid
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"Thread ID %s not known.  Use the \"info threads\" command to\n"
literal|"see the IDs of currently known threads."
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|inf
operator|->
name|signal_thread
operator|=
name|inf_tid_to_thread
argument_list|(
name|inf
argument_list|,
name|tid
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|show_sig_thread_cmd
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|inf
modifier|*
name|inf
init|=
name|cur_inf
argument_list|()
decl_stmt|;
name|check_empty
argument_list|(
name|args
argument_list|,
literal|"show signal-thread"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|inf
operator|->
name|task
condition|)
name|error
argument_list|(
literal|"No current process."
argument_list|)
expr_stmt|;
if|if
condition|(
name|inf
operator|->
name|signal_thread
condition|)
name|printf_unfiltered
argument_list|(
literal|"The signal thread is %s.\n"
argument_list|,
name|proc_string
argument_list|(
name|inf
operator|->
name|signal_thread
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf_unfiltered
argument_list|(
literal|"There is no signal thread.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_exceptions_cmd
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|inf
modifier|*
name|inf
init|=
name|cur_inf
argument_list|()
decl_stmt|;
name|int
name|val
init|=
name|parse_bool_arg
argument_list|(
name|args
argument_list|,
literal|"set exceptions"
argument_list|)
decl_stmt|;
if|if
condition|(
name|inf
operator|->
name|task
operator|&&
name|inf
operator|->
name|want_exceptions
operator|!=
name|val
condition|)
comment|/* Make this take effect immediately in a running process.  */
comment|/* XXX */
empty_stmt|;
name|inf
operator|->
name|want_exceptions
operator|=
name|val
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|show_exceptions_cmd
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|inf
modifier|*
name|inf
init|=
name|cur_inf
argument_list|()
decl_stmt|;
name|check_empty
argument_list|(
name|args
argument_list|,
literal|"show exceptions"
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"Exceptions in the inferior %s trapped.\n"
argument_list|,
name|inf
operator|->
name|task
condition|?
operator|(
name|inf
operator|->
name|want_exceptions
condition|?
literal|"are"
else|:
literal|"aren't"
operator|)
else|:
operator|(
name|inf
operator|->
name|want_exceptions
condition|?
literal|"will be"
else|:
literal|"won't be"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_task_cmd
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|printf_unfiltered
argument_list|(
literal|"\"set task\" must be followed by the name of a task property.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|show_task_cmd
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|inf
modifier|*
name|inf
init|=
name|cur_inf
argument_list|()
decl_stmt|;
name|check_empty
argument_list|(
name|args
argument_list|,
literal|"show task"
argument_list|)
expr_stmt|;
name|show_signals_cmd
argument_list|(
literal|0
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
name|show_exceptions_cmd
argument_list|(
literal|0
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
name|show_task_pause_cmd
argument_list|(
literal|0
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
if|if
condition|(
name|inf
operator|->
name|pause_sc
operator|==
literal|0
condition|)
name|show_thread_default_pause_cmd
argument_list|(
literal|0
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
name|show_thread_default_run_cmd
argument_list|(
literal|0
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
if|if
condition|(
name|inf
operator|->
name|task
condition|)
block|{
name|show_stopped_cmd
argument_list|(
literal|0
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
name|show_sig_thread_cmd
argument_list|(
literal|0
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|add_task_commands
parameter_list|()
block|{
name|add_cmd
argument_list|(
literal|"pause"
argument_list|,
name|class_run
argument_list|,
name|set_thread_default_pause_cmd
argument_list|,
literal|"Set whether the new threads are suspended while gdb has control.\n"
literal|"This property normally has no effect because the whole task is\n"
literal|"suspended, however, that may be disabled with \"set task pause off\".\n"
literal|"The default value is \"off\"."
argument_list|,
operator|&
name|set_thread_default_cmd_list
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"pause"
argument_list|,
name|no_class
argument_list|,
name|show_thread_default_pause_cmd
argument_list|,
literal|"Show whether new threads are suspended while gdb has control."
argument_list|,
operator|&
name|show_thread_default_cmd_list
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"run"
argument_list|,
name|class_run
argument_list|,
name|set_thread_default_run_cmd
argument_list|,
literal|"Set whether new threads are allowed to run (once gdb has noticed them)."
argument_list|,
operator|&
name|set_thread_default_cmd_list
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"run"
argument_list|,
name|no_class
argument_list|,
name|show_thread_default_run_cmd
argument_list|,
literal|"Show whether new threads are allowed to run (once gdb has noticed them)."
argument_list|,
operator|&
name|show_thread_default_cmd_list
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"signals"
argument_list|,
name|class_run
argument_list|,
name|set_signals_cmd
argument_list|,
literal|"Set whether the inferior process's signals will be intercepted.\n"
literal|"Mach exceptions (such as breakpoint traps) are not affected."
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|add_alias_cmd
argument_list|(
literal|"sigs"
argument_list|,
literal|"signals"
argument_list|,
name|class_run
argument_list|,
literal|1
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"signals"
argument_list|,
name|no_class
argument_list|,
name|show_signals_cmd
argument_list|,
literal|"Show whether the inferior process's signals will be intercepted."
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_alias_cmd
argument_list|(
literal|"sigs"
argument_list|,
literal|"signals"
argument_list|,
name|no_class
argument_list|,
literal|1
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"signal-thread"
argument_list|,
name|class_run
argument_list|,
name|set_sig_thread_cmd
argument_list|,
literal|"Set the thread that gdb thinks is the libc signal thread.\n"
literal|"This thread is run when delivering a signal to a non-stopped process."
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|add_alias_cmd
argument_list|(
literal|"sigthread"
argument_list|,
literal|"signal-thread"
argument_list|,
name|class_run
argument_list|,
literal|1
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"signal-thread"
argument_list|,
name|no_class
argument_list|,
name|show_sig_thread_cmd
argument_list|,
literal|"Set the thread that gdb thinks is the libc signal thread."
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_alias_cmd
argument_list|(
literal|"sigthread"
argument_list|,
literal|"signal-thread"
argument_list|,
name|no_class
argument_list|,
literal|1
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"stopped"
argument_list|,
name|class_run
argument_list|,
name|set_stopped_cmd
argument_list|,
literal|"Set whether gdb thinks the inferior process is stopped as with SIGSTOP.\n"
literal|"Stopped process will be continued by sending them a signal."
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"stopped"
argument_list|,
name|no_class
argument_list|,
name|show_signals_cmd
argument_list|,
literal|"Show whether gdb thinks the inferior process is stopped as with SIGSTOP."
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"exceptions"
argument_list|,
name|class_run
argument_list|,
name|set_exceptions_cmd
argument_list|,
literal|"Set whether exceptions in the inferior process will be trapped.\n"
literal|"When exceptions are turned off, neither breakpoints nor single-stepping\n"
literal|"will work."
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
comment|/* Allow `set exc' despite conflict with `set exception-port'.  */
name|add_alias_cmd
argument_list|(
literal|"exc"
argument_list|,
literal|"exceptions"
argument_list|,
name|class_run
argument_list|,
literal|1
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"exceptions"
argument_list|,
name|no_class
argument_list|,
name|show_exceptions_cmd
argument_list|,
literal|"Show whether exceptions in the inferior process will be trapped."
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"task"
argument_list|,
name|no_class
argument_list|,
name|set_task_cmd
argument_list|,
literal|"Command prefix for setting task attributes."
argument_list|,
operator|&
name|set_task_cmd_list
argument_list|,
literal|"set task "
argument_list|,
literal|0
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"task"
argument_list|,
name|no_class
argument_list|,
name|show_task_cmd
argument_list|,
literal|"Command prefix for showing task attributes."
argument_list|,
operator|&
name|show_task_cmd_list
argument_list|,
literal|"show task "
argument_list|,
literal|0
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"pause"
argument_list|,
name|class_run
argument_list|,
name|set_task_pause_cmd
argument_list|,
literal|"Set whether the task is suspended while gdb has control.\n"
literal|"A value of \"on\" takes effect immediately, otherwise nothing\n"
literal|"happens until the next time the program is continued.\n"
literal|"When setting this to \"off\", \"set thread default pause on\"\n"
literal|"can be used to pause individual threads by default instead."
argument_list|,
operator|&
name|set_task_cmd_list
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"pause"
argument_list|,
name|no_class
argument_list|,
name|show_task_pause_cmd
argument_list|,
literal|"Show whether the task is suspended while gdb has control."
argument_list|,
operator|&
name|show_task_cmd_list
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"exception-port"
argument_list|,
name|no_class
argument_list|,
name|set_task_exc_port_cmd
argument_list|,
literal|"Set the task exception port to which we forward exceptions.\n"
literal|"The argument should be the value of the send right in the task."
argument_list|,
operator|&
name|set_task_cmd_list
argument_list|)
expr_stmt|;
name|add_alias_cmd
argument_list|(
literal|"excp"
argument_list|,
literal|"exception-port"
argument_list|,
name|no_class
argument_list|,
literal|1
argument_list|,
operator|&
name|set_task_cmd_list
argument_list|)
expr_stmt|;
name|add_alias_cmd
argument_list|(
literal|"exc-port"
argument_list|,
literal|"exception-port"
argument_list|,
name|no_class
argument_list|,
literal|1
argument_list|,
operator|&
name|set_task_cmd_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* User thread commands.  */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|cmd_list_element
modifier|*
name|set_thread_cmd_list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|cmd_list_element
modifier|*
name|show_thread_cmd_list
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|set_thread_pause_cmd
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|thread
init|=
name|cur_thread
argument_list|()
decl_stmt|;
name|int
name|old_sc
init|=
name|thread
operator|->
name|pause_sc
decl_stmt|;
name|thread
operator|->
name|pause_sc
operator|=
name|parse_bool_arg
argument_list|(
name|args
argument_list|,
literal|"set thread pause"
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_sc
operator|==
literal|0
operator|&&
name|thread
operator|->
name|pause_sc
operator|!=
literal|0
operator|&&
name|thread
operator|->
name|inf
operator|->
name|pause_sc
operator|==
literal|0
condition|)
comment|/* If the task is currently unsuspended, immediately suspend it,        otherwise wait until the next time it gets control.  */
name|inf_suspend
argument_list|(
name|thread
operator|->
name|inf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|show_thread_pause_cmd
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|thread
init|=
name|cur_thread
argument_list|()
decl_stmt|;
name|int
name|sc
init|=
name|thread
operator|->
name|pause_sc
decl_stmt|;
name|check_empty
argument_list|(
name|args
argument_list|,
literal|"show task pause"
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"Thread %s %s suspended while gdb has control%s.\n"
argument_list|,
name|proc_string
argument_list|(
name|thread
argument_list|)
argument_list|,
name|sc
condition|?
literal|"is"
else|:
literal|"isn't"
argument_list|,
operator|!
name|sc
operator|&&
name|thread
operator|->
name|inf
operator|->
name|pause_sc
condition|?
literal|"(but the task is)"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_thread_run_cmd
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|thread
init|=
name|cur_thread
argument_list|()
decl_stmt|;
name|thread
operator|->
name|run_sc
operator|=
name|parse_bool_arg
argument_list|(
name|args
argument_list|,
literal|"set thread run"
argument_list|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|show_thread_run_cmd
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|thread
init|=
name|cur_thread
argument_list|()
decl_stmt|;
name|check_empty
argument_list|(
name|args
argument_list|,
literal|"show thread run"
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"Thread %s allowed to run."
argument_list|,
name|proc_string
argument_list|(
name|thread
argument_list|)
argument_list|,
name|thread
operator|->
name|run_sc
operator|==
literal|0
condition|?
literal|"is"
else|:
literal|"isn't"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_thread_exc_port_cmd
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|thread
init|=
name|cur_thread
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|args
condition|)
name|error
argument_list|(
literal|"No argument to \"set thread exception-port\" command."
argument_list|)
expr_stmt|;
name|steal_exc_port
argument_list|(
name|thread
argument_list|,
name|parse_and_eval_address
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_thread_cmd
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|printf_unfiltered
argument_list|(
literal|"\"set thread\" must be followed by the name of a thread property.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|show_thread_cmd
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|check_empty
argument_list|(
name|args
argument_list|,
literal|"show thread"
argument_list|)
expr_stmt|;
name|show_thread_run_cmd
argument_list|(
literal|0
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
name|show_thread_pause_cmd
argument_list|(
literal|0
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|add_thread_commands
argument_list|()
end_macro

begin_block
block|{
name|add_cmd
argument_list|(
literal|"pause"
argument_list|,
name|class_run
argument_list|,
name|set_thread_pause_cmd
argument_list|,
literal|"Set whether the current thread is suspended while gdb has control.\n"
literal|"A value of \"on\" takes effect immediately, otherwise nothing\n"
literal|"happens until the next time the program is continued.  This\n"
literal|"property normally has no effect because the whole task is suspended,\n"
literal|"however, that may be disabled with \"set task pause off\".\n"
literal|"The default value is \"off\"."
argument_list|,
operator|&
name|set_thread_cmd_list
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"pause"
argument_list|,
name|no_class
argument_list|,
name|show_thread_pause_cmd
argument_list|,
literal|"Show whether the current thread is suspended while gdb has control."
argument_list|,
operator|&
name|show_thread_cmd_list
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"run"
argument_list|,
name|class_run
argument_list|,
name|set_thread_run_cmd
argument_list|,
literal|"Set whether the current thread is allowed to run."
argument_list|,
operator|&
name|set_thread_cmd_list
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"run"
argument_list|,
name|no_class
argument_list|,
name|show_thread_run_cmd
argument_list|,
literal|"Show whether the current thread is allowed to run."
argument_list|,
operator|&
name|show_thread_cmd_list
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"exception-port"
argument_list|,
name|no_class
argument_list|,
name|set_thread_exc_port_cmd
argument_list|,
literal|"Set the exception port to which we forward exceptions for the\n"
literal|"current thread, overriding the task exception port.\n"
literal|"The argument should be the value of the send right in the task."
argument_list|,
operator|&
name|set_thread_cmd_list
argument_list|)
expr_stmt|;
name|add_alias_cmd
argument_list|(
literal|"excp"
argument_list|,
literal|"exception-port"
argument_list|,
name|no_class
argument_list|,
literal|1
argument_list|,
operator|&
name|set_thread_cmd_list
argument_list|)
expr_stmt|;
name|add_alias_cmd
argument_list|(
literal|"exc-port"
argument_list|,
literal|"exception-port"
argument_list|,
name|no_class
argument_list|,
literal|1
argument_list|,
operator|&
name|set_thread_cmd_list
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_function
name|void
name|_initialize_gnu_nat
parameter_list|()
block|{
name|proc_server
operator|=
name|getproc
argument_list|()
expr_stmt|;
name|add_target
argument_list|(
operator|&
name|gnu_ops
argument_list|)
expr_stmt|;
name|add_task_commands
argument_list|()
expr_stmt|;
name|add_thread_commands
argument_list|()
expr_stmt|;
if|#
directive|if
name|MAINTENANCE_CMDS
name|add_set_cmd
argument_list|(
literal|"gnu-debug"
argument_list|,
name|class_maintenance
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|gnu_debug_flag
argument_list|,
literal|"Set debugging output for the gnu backend."
argument_list|,
operator|&
name|maintenancelist
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|FLUSH_INFERIOR_CACHE
end_ifdef

begin_comment
comment|/* When over-writing code on some machines the I-Cache must be flushed    explicitly, because it is not kept coherent by the lazy hardware.    This definitely includes breakpoints, for instance, or else we    end up looping in mysterious Bpt traps */
end_comment

begin_function
name|void
name|flush_inferior_icache
parameter_list|(
name|pc
parameter_list|,
name|amount
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
block|{
name|vm_machine_attribute_val_t
name|flush
init|=
name|MATTR_VAL_ICACHE_FLUSH
decl_stmt|;
name|error_t
name|ret
decl_stmt|;
name|ret
operator|=
name|vm_machine_attribute
argument_list|(
name|current_inferior
operator|->
name|task
operator|->
name|port
argument_list|,
name|pc
argument_list|,
name|amount
argument_list|,
name|MATTR_CACHE
argument_list|,
operator|&
name|flush
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|KERN_SUCCESS
condition|)
name|warning
argument_list|(
literal|"Error flushing inferior's cache : %s"
argument_list|,
name|strerror
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
endif|FLUSH_INFERIOR_CACHE
end_endif

end_unit

