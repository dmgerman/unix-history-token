begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Read HP PA/Risc object files for GDB.    Copyright 1991, 1992, 1994, 1995, 1996, 1998, 1999, 2000, 2001, 2002,    2004 Free Software Foundation, Inc.    Written by Fred Fish at Cygnus Support.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|<syms.h>
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"buildsym.h"
end_include

begin_include
include|#
directive|include
file|"stabsread.h"
end_include

begin_include
include|#
directive|include
file|"gdb-stabs.h"
end_include

begin_include
include|#
directive|include
file|"complaints.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_include
include|#
directive|include
file|"som.h"
end_include

begin_include
include|#
directive|include
file|"libhppa.h"
end_include

begin_comment
comment|/* Various things we might complain about... */
end_comment

begin_function_decl
specifier|static
name|int
name|init_import_symbols
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|som_symfile_init
parameter_list|(
name|struct
name|objfile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|som_new_init
parameter_list|(
name|struct
name|objfile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|som_symfile_read
parameter_list|(
name|struct
name|objfile
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|som_symfile_finish
parameter_list|(
name|struct
name|objfile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|som_symtab_read
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|struct
name|objfile
modifier|*
parameter_list|,
name|struct
name|section_offsets
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|som_symfile_offsets
parameter_list|(
name|struct
name|objfile
modifier|*
parameter_list|,
name|struct
name|section_addr_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* FIXME: These should really be in a common header somewhere */
end_comment

begin_function_decl
specifier|extern
name|void
name|hpread_build_psymtabs
parameter_list|(
name|struct
name|objfile
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|hpread_symfile_finish
parameter_list|(
name|struct
name|objfile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|hpread_symfile_init
parameter_list|(
name|struct
name|objfile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|do_pxdb
parameter_list|(
name|bfd
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*     LOCAL FUNCTION     som_symtab_read -- read the symbol table of a SOM file     SYNOPSIS     void som_symtab_read (bfd *abfd, struct objfile *objfile,    struct section_offsets *section_offsets)     DESCRIPTION     Given an open bfd, a base address to relocate symbols to, and a    flag that specifies whether or not this bfd is for an executable    or not (may be shared library for example), add all the global    function and data symbols to the minimal symbol table.  */
end_comment

begin_function
specifier|static
name|void
name|som_symtab_read
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|,
name|struct
name|section_offsets
modifier|*
name|section_offsets
parameter_list|)
block|{
name|unsigned
name|int
name|number_of_symbols
decl_stmt|;
name|int
name|val
decl_stmt|,
name|dynamic
decl_stmt|;
name|char
modifier|*
name|stringtab
decl_stmt|;
name|asection
modifier|*
name|shlib_info
decl_stmt|;
name|struct
name|symbol_dictionary_record
modifier|*
name|buf
decl_stmt|,
modifier|*
name|bufp
decl_stmt|,
modifier|*
name|endbufp
decl_stmt|;
name|char
modifier|*
name|symname
decl_stmt|;
name|CONST
name|int
name|symsize
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|symbol_dictionary_record
argument_list|)
decl_stmt|;
name|CORE_ADDR
name|text_offset
decl_stmt|,
name|data_offset
decl_stmt|;
name|text_offset
operator|=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|data_offset
operator|=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|number_of_symbols
operator|=
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* FIXME (alloca): could be quite large. */
name|buf
operator|=
name|alloca
argument_list|(
name|symsize
operator|*
name|number_of_symbols
argument_list|)
expr_stmt|;
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|obj_som_sym_filepos
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|val
operator|=
name|bfd_bread
argument_list|(
name|buf
argument_list|,
name|symsize
operator|*
name|number_of_symbols
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|symsize
operator|*
name|number_of_symbols
condition|)
name|error
argument_list|(
literal|"Couldn't read symbol dictionary!"
argument_list|)
expr_stmt|;
comment|/* FIXME (alloca): could be quite large. */
name|stringtab
operator|=
name|alloca
argument_list|(
name|obj_som_stringtab_size
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|obj_som_str_filepos
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|val
operator|=
name|bfd_bread
argument_list|(
name|stringtab
argument_list|,
name|obj_som_stringtab_size
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|obj_som_stringtab_size
argument_list|(
name|abfd
argument_list|)
condition|)
name|error
argument_list|(
literal|"Can't read in HP string table."
argument_list|)
expr_stmt|;
comment|/* We need to determine if objfile is a dynamic executable (so we      can do the right thing for ST_ENTRY vs ST_CODE symbols).       There's nothing in the header which easily allows us to do      this.       This code used to rely upon the existence of a $SHLIB_INFO$      section to make this determination.  HP claims that it is      more accurate to check for a nonzero text offset, but they      have not provided any information about why that test is      more accurate.  */
name|dynamic
operator|=
operator|(
name|text_offset
operator|!=
literal|0
operator|)
expr_stmt|;
name|endbufp
operator|=
name|buf
operator|+
name|number_of_symbols
expr_stmt|;
for|for
control|(
name|bufp
operator|=
name|buf
init|;
name|bufp
operator|<
name|endbufp
condition|;
operator|++
name|bufp
control|)
block|{
name|enum
name|minimal_symbol_type
name|ms_type
decl_stmt|;
name|QUIT
expr_stmt|;
switch|switch
condition|(
name|bufp
operator|->
name|symbol_scope
condition|)
block|{
case|case
name|SS_UNIVERSAL
case|:
case|case
name|SS_EXTERNAL
case|:
switch|switch
condition|(
name|bufp
operator|->
name|symbol_type
condition|)
block|{
case|case
name|ST_SYM_EXT
case|:
case|case
name|ST_ARG_EXT
case|:
continue|continue;
case|case
name|ST_CODE
case|:
case|case
name|ST_PRI_PROG
case|:
case|case
name|ST_SEC_PROG
case|:
case|case
name|ST_MILLICODE
case|:
name|symname
operator|=
name|bufp
operator|->
name|name
operator|.
name|n_strx
operator|+
name|stringtab
expr_stmt|;
name|ms_type
operator|=
name|mst_text
expr_stmt|;
name|bufp
operator|->
name|symbol_value
operator|+=
name|text_offset
expr_stmt|;
name|bufp
operator|->
name|symbol_value
operator|=
name|SMASH_TEXT_ADDRESS
argument_list|(
name|bufp
operator|->
name|symbol_value
argument_list|)
expr_stmt|;
break|break;
case|case
name|ST_ENTRY
case|:
name|symname
operator|=
name|bufp
operator|->
name|name
operator|.
name|n_strx
operator|+
name|stringtab
expr_stmt|;
comment|/* For a dynamic executable, ST_ENTRY symbols are 	         the stubs, while the ST_CODE symbol is the real 	         function.  */
if|if
condition|(
name|dynamic
condition|)
name|ms_type
operator|=
name|mst_solib_trampoline
expr_stmt|;
else|else
name|ms_type
operator|=
name|mst_text
expr_stmt|;
name|bufp
operator|->
name|symbol_value
operator|+=
name|text_offset
expr_stmt|;
name|bufp
operator|->
name|symbol_value
operator|=
name|SMASH_TEXT_ADDRESS
argument_list|(
name|bufp
operator|->
name|symbol_value
argument_list|)
expr_stmt|;
break|break;
case|case
name|ST_STUB
case|:
name|symname
operator|=
name|bufp
operator|->
name|name
operator|.
name|n_strx
operator|+
name|stringtab
expr_stmt|;
name|ms_type
operator|=
name|mst_solib_trampoline
expr_stmt|;
name|bufp
operator|->
name|symbol_value
operator|+=
name|text_offset
expr_stmt|;
name|bufp
operator|->
name|symbol_value
operator|=
name|SMASH_TEXT_ADDRESS
argument_list|(
name|bufp
operator|->
name|symbol_value
argument_list|)
expr_stmt|;
break|break;
case|case
name|ST_DATA
case|:
name|symname
operator|=
name|bufp
operator|->
name|name
operator|.
name|n_strx
operator|+
name|stringtab
expr_stmt|;
name|bufp
operator|->
name|symbol_value
operator|+=
name|data_offset
expr_stmt|;
name|ms_type
operator|=
name|mst_data
expr_stmt|;
break|break;
default|default:
continue|continue;
block|}
break|break;
if|#
directive|if
literal|0
comment|/* SS_GLOBAL and SS_LOCAL are two names for the same thing (!).  */
block|case SS_GLOBAL:
endif|#
directive|endif
case|case
name|SS_LOCAL
case|:
switch|switch
condition|(
name|bufp
operator|->
name|symbol_type
condition|)
block|{
case|case
name|ST_SYM_EXT
case|:
case|case
name|ST_ARG_EXT
case|:
continue|continue;
case|case
name|ST_CODE
case|:
name|symname
operator|=
name|bufp
operator|->
name|name
operator|.
name|n_strx
operator|+
name|stringtab
expr_stmt|;
name|ms_type
operator|=
name|mst_file_text
expr_stmt|;
name|bufp
operator|->
name|symbol_value
operator|+=
name|text_offset
expr_stmt|;
name|bufp
operator|->
name|symbol_value
operator|=
name|SMASH_TEXT_ADDRESS
argument_list|(
name|bufp
operator|->
name|symbol_value
argument_list|)
expr_stmt|;
name|check_strange_names
label|:
comment|/* Utah GCC 2.5, FSF GCC 2.6 and later generate correct local 	         label prefixes for stabs, constant data, etc.  So we need 	         only filter out L$ symbols which are left in due to 	         limitations in how GAS generates SOM relocations.  	         When linking in the HPUX C-library the HP linker has 	         the nasty habit of placing section symbols from the literal 	         subspaces in the middle of the program's text.  Filter 	         those out as best we can.  Check for first and last character 	         being '$'.   	         And finally, the newer HP compilers emit crud like $PIC_foo$N 	         in some circumstance (PIC code I guess).  It's also claimed 	         that they emit D$ symbols too.  What stupidity.  */
if|if
condition|(
operator|(
name|symname
index|[
literal|0
index|]
operator|==
literal|'L'
operator|&&
name|symname
index|[
literal|1
index|]
operator|==
literal|'$'
operator|)
operator|||
operator|(
name|symname
index|[
literal|0
index|]
operator|==
literal|'$'
operator|&&
name|symname
index|[
name|strlen
argument_list|(
name|symname
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'$'
operator|)
operator|||
operator|(
name|symname
index|[
literal|0
index|]
operator|==
literal|'D'
operator|&&
name|symname
index|[
literal|1
index|]
operator|==
literal|'$'
operator|)
operator|||
operator|(
name|strncmp
argument_list|(
name|symname
argument_list|,
literal|"$PIC"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
operator|)
condition|)
continue|continue;
break|break;
case|case
name|ST_PRI_PROG
case|:
case|case
name|ST_SEC_PROG
case|:
case|case
name|ST_MILLICODE
case|:
name|symname
operator|=
name|bufp
operator|->
name|name
operator|.
name|n_strx
operator|+
name|stringtab
expr_stmt|;
name|ms_type
operator|=
name|mst_file_text
expr_stmt|;
name|bufp
operator|->
name|symbol_value
operator|+=
name|text_offset
expr_stmt|;
name|bufp
operator|->
name|symbol_value
operator|=
name|SMASH_TEXT_ADDRESS
argument_list|(
name|bufp
operator|->
name|symbol_value
argument_list|)
expr_stmt|;
break|break;
case|case
name|ST_ENTRY
case|:
name|symname
operator|=
name|bufp
operator|->
name|name
operator|.
name|n_strx
operator|+
name|stringtab
expr_stmt|;
comment|/* SS_LOCAL symbols in a shared library do not have 		 export stubs, so we do not have to worry about 		 using mst_file_text vs mst_solib_trampoline here like 		 we do for SS_UNIVERSAL and SS_EXTERNAL symbols above.  */
name|ms_type
operator|=
name|mst_file_text
expr_stmt|;
name|bufp
operator|->
name|symbol_value
operator|+=
name|text_offset
expr_stmt|;
name|bufp
operator|->
name|symbol_value
operator|=
name|SMASH_TEXT_ADDRESS
argument_list|(
name|bufp
operator|->
name|symbol_value
argument_list|)
expr_stmt|;
break|break;
case|case
name|ST_STUB
case|:
name|symname
operator|=
name|bufp
operator|->
name|name
operator|.
name|n_strx
operator|+
name|stringtab
expr_stmt|;
name|ms_type
operator|=
name|mst_solib_trampoline
expr_stmt|;
name|bufp
operator|->
name|symbol_value
operator|+=
name|text_offset
expr_stmt|;
name|bufp
operator|->
name|symbol_value
operator|=
name|SMASH_TEXT_ADDRESS
argument_list|(
name|bufp
operator|->
name|symbol_value
argument_list|)
expr_stmt|;
break|break;
case|case
name|ST_DATA
case|:
name|symname
operator|=
name|bufp
operator|->
name|name
operator|.
name|n_strx
operator|+
name|stringtab
expr_stmt|;
name|bufp
operator|->
name|symbol_value
operator|+=
name|data_offset
expr_stmt|;
name|ms_type
operator|=
name|mst_file_data
expr_stmt|;
goto|goto
name|check_strange_names
goto|;
default|default:
continue|continue;
block|}
break|break;
comment|/* This can happen for common symbols when -E is passed to the 	     final link.  No idea _why_ that would make the linker force 	     common symbols to have an SS_UNSAT scope, but it does.  	     This also happens for weak symbols, but their type is 	     ST_DATA.  */
case|case
name|SS_UNSAT
case|:
switch|switch
condition|(
name|bufp
operator|->
name|symbol_type
condition|)
block|{
case|case
name|ST_STORAGE
case|:
case|case
name|ST_DATA
case|:
name|symname
operator|=
name|bufp
operator|->
name|name
operator|.
name|n_strx
operator|+
name|stringtab
expr_stmt|;
name|bufp
operator|->
name|symbol_value
operator|+=
name|data_offset
expr_stmt|;
name|ms_type
operator|=
name|mst_data
expr_stmt|;
break|break;
default|default:
continue|continue;
block|}
break|break;
default|default:
continue|continue;
block|}
if|if
condition|(
name|bufp
operator|->
name|name
operator|.
name|n_strx
operator|>
name|obj_som_stringtab_size
argument_list|(
name|abfd
argument_list|)
condition|)
name|error
argument_list|(
literal|"Invalid symbol data; bad HP string table offset: %d"
argument_list|,
name|bufp
operator|->
name|name
operator|.
name|n_strx
argument_list|)
expr_stmt|;
name|prim_record_minimal_symbol
argument_list|(
name|symname
argument_list|,
name|bufp
operator|->
name|symbol_value
argument_list|,
name|ms_type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Scan and build partial symbols for a symbol file.    We have been initialized by a call to som_symfile_init, which     currently does nothing.     SECTION_OFFSETS is a set of offsets to apply to relocate the symbols    in each section.  This is ignored, as it isn't needed for SOM.     MAINLINE is true if we are reading the main symbol    table (as opposed to a shared lib or dynamically loaded file).     This function only does the minimum work necessary for letting the    user "name" things symbolically; it does not read the entire symtab.    Instead, it reads the external and static symbols and puts them in partial    symbol tables.  When more extensive information is requested of a    file, the corresponding partial symbol table is mutated into a full    fledged symbol table by going back and reading the symbols    for real.     We look for sections with specific names, to tell us what debug    format to look for:  FIXME!!!     somstab_build_psymtabs() handles STABS symbols.     Note that SOM files have a "minimal" symbol table, which is vaguely    reminiscent of a COFF symbol table, but has only the minimal information    necessary for linking.  We process this also, and use the information to    build gdb's minimal symbol table.  This gives us some minimal debugging    capability even for files compiled without -g.  */
end_comment

begin_function
specifier|static
name|void
name|som_symfile_read
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|,
name|int
name|mainline
parameter_list|)
block|{
name|bfd
modifier|*
name|abfd
init|=
name|objfile
operator|->
name|obfd
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|back_to
decl_stmt|;
name|do_pxdb
argument_list|(
name|symfile_bfd_open
argument_list|(
name|objfile
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|init_minimal_symbol_collection
argument_list|()
expr_stmt|;
name|back_to
operator|=
name|make_cleanup_discard_minimal_symbols
argument_list|()
expr_stmt|;
comment|/* Read in the import list and the export list.  Currently      the export list isn't used; the import list is used in      hp-symtab-read.c to handle static vars declared in other      shared libraries. */
name|init_import_symbols
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Export symbols not used today 1997-08-05 */
block|init_export_symbols (objfile);
else|#
directive|else
name|objfile
operator|->
name|export_list
operator|=
name|NULL
expr_stmt|;
name|objfile
operator|->
name|export_list_size
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* Process the normal SOM symbol table first.       This reads in the DNTT and string table, but doesn't      actually scan the DNTT. It does scan the linker symbol      table and thus build up a "minimal symbol table". */
name|som_symtab_read
argument_list|(
name|abfd
argument_list|,
name|objfile
argument_list|,
name|objfile
operator|->
name|section_offsets
argument_list|)
expr_stmt|;
comment|/* Install any minimal symbols that have been collected as the current      minimal symbols for this objfile.       Further symbol-reading is done incrementally, file-by-file,      in a step known as "psymtab-to-symtab" expansion. hp-symtab-read.c      contains the code to do the actual DNTT scanning and symtab building. */
name|install_minimal_symbols
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|back_to
argument_list|)
expr_stmt|;
comment|/* Now read information from the stabs debug sections.      This is a no-op for SOM.      Perhaps it is intended for some kind of mixed STABS/SOM      situation? */
name|stabsect_build_psymtabs
argument_list|(
name|objfile
argument_list|,
name|mainline
argument_list|,
literal|"$GDB_SYMBOLS$"
argument_list|,
literal|"$GDB_STRINGS$"
argument_list|,
literal|"$TEXT$"
argument_list|)
expr_stmt|;
comment|/* Now read the native debug information.       This builds the psymtab. This used to be done via a scan of      the DNTT, but is now done via the PXDB-built quick-lookup tables      together with a scan of the GNTT. See hp-psymtab-read.c. */
name|hpread_build_psymtabs
argument_list|(
name|objfile
argument_list|,
name|mainline
argument_list|)
expr_stmt|;
comment|/* Force hppa-tdep.c to re-read the unwind descriptors.  */
name|objfile
operator|->
name|obj_private
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize anything that needs initializing when a completely new symbol    file is specified (not just adding some symbols from another file, e.g. a    shared library).     We reinitialize buildsym, since we may be reading stabs from a SOM file.  */
end_comment

begin_function
specifier|static
name|void
name|som_new_init
parameter_list|(
name|struct
name|objfile
modifier|*
name|ignore
parameter_list|)
block|{
name|stabsread_new_init
argument_list|()
expr_stmt|;
name|buildsym_new_init
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Perform any local cleanups required when we are done with a particular    objfile.  I.E, we are in the process of discarding all symbol information    for an objfile, freeing up all memory held for it, and unlinking the    objfile struct from the global list of known objfiles. */
end_comment

begin_function
specifier|static
name|void
name|som_symfile_finish
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
if|if
condition|(
name|objfile
operator|->
name|sym_stab_info
operator|!=
name|NULL
condition|)
block|{
name|xmfree
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
name|objfile
operator|->
name|sym_stab_info
argument_list|)
expr_stmt|;
block|}
name|hpread_symfile_finish
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* SOM specific initialization routine for reading symbols.  */
end_comment

begin_function
specifier|static
name|void
name|som_symfile_init
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
comment|/* SOM objects may be reordered, so set OBJF_REORDERED.  If we      find this causes a significant slowdown in gdb then we could      set it in the debug symbol readers only when necessary.  */
name|objfile
operator|->
name|flags
operator||=
name|OBJF_REORDERED
expr_stmt|;
name|hpread_symfile_init
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* SOM specific parsing routine for section offsets.     Plain and simple for now.  */
end_comment

begin_function
specifier|static
name|void
name|som_symfile_offsets
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|,
name|struct
name|section_addr_info
modifier|*
name|addrs
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|CORE_ADDR
name|text_addr
decl_stmt|;
name|objfile
operator|->
name|num_sections
operator|=
name|bfd_count_sections
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|)
expr_stmt|;
name|objfile
operator|->
name|section_offsets
operator|=
operator|(
expr|struct
name|section_offsets
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
name|SIZEOF_N_SECTION_OFFSETS
argument_list|(
name|objfile
operator|->
name|num_sections
argument_list|)
argument_list|)
expr_stmt|;
comment|/* FIXME: ezannoni 2000-04-20 The section names in SOM are not      .text, .data, etc, but $TEXT$, $DATA$,... We should initialize      SET_OFF_* from bfd. (See default_symfile_offsets()). But I don't      know the correspondence between SOM sections and GDB's idea of      section names. So for now we default to what is was before these      changes.*/
name|objfile
operator|->
name|sect_index_text
operator|=
literal|0
expr_stmt|;
name|objfile
operator|->
name|sect_index_data
operator|=
literal|1
expr_stmt|;
name|objfile
operator|->
name|sect_index_bss
operator|=
literal|2
expr_stmt|;
name|objfile
operator|->
name|sect_index_rodata
operator|=
literal|3
expr_stmt|;
comment|/* First see if we're a shared library.  If so, get the section      offsets from the library, else get them from addrs.  */
if|if
condition|(
operator|!
name|som_solib_section_offsets
argument_list|(
name|objfile
argument_list|,
name|objfile
operator|->
name|section_offsets
argument_list|)
condition|)
block|{
comment|/* Note: Here is OK to compare with ".text" because this is the          name that gdb itself gives to that section, not the SOM          name. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|objfile
operator|->
name|num_sections
operator|&&
name|addrs
operator|->
name|other
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|addrs
operator|->
name|other
index|[
name|i
index|]
operator|.
name|name
argument_list|,
literal|".text"
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|text_addr
operator|=
name|addrs
operator|->
name|other
index|[
name|i
index|]
operator|.
name|addr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|objfile
operator|->
name|num_sections
condition|;
name|i
operator|++
control|)
operator|(
name|objfile
operator|->
name|section_offsets
operator|)
operator|->
name|offsets
index|[
name|i
index|]
operator|=
name|text_addr
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Read in and initialize the SOM import list which is present    for all executables and shared libraries.  The import list    consists of the symbols that are referenced in OBJFILE but    not defined there.  (Variables that are imported are dealt    with as "loc_indirect" vars.)    Return value = number of import symbols read in. */
end_comment

begin_function
specifier|static
name|int
name|init_import_symbols
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|unsigned
name|int
name|import_list
decl_stmt|;
name|unsigned
name|int
name|import_list_size
decl_stmt|;
name|unsigned
name|int
name|string_table
decl_stmt|;
name|unsigned
name|int
name|string_table_size
decl_stmt|;
name|char
modifier|*
name|string_buffer
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
name|int
name|k
decl_stmt|;
name|asection
modifier|*
name|text_section
decl_stmt|;
comment|/* section handle */
name|unsigned
name|int
name|dl_header
index|[
literal|12
index|]
decl_stmt|;
comment|/* SOM executable header */
comment|/* A struct for an entry in the SOM import list */
typedef|typedef
struct|struct
block|{
name|int
name|name
decl_stmt|;
comment|/* index into the string table */
name|short
name|dont_care1
decl_stmt|;
comment|/* we don't use this */
name|unsigned
name|char
name|type
decl_stmt|;
comment|/* 0 = NULL, 2 = Data, 3 = Code, 7 = Storage, 13 = Plabel */
name|unsigned
name|int
name|reserved2
range|:
literal|8
decl_stmt|;
comment|/* not used */
block|}
name|SomImportEntry
typedef|;
comment|/* We read 100 entries in at a time from the disk file. */
define|#
directive|define
name|SOM_READ_IMPORTS_NUM
value|100
define|#
directive|define
name|SOM_READ_IMPORTS_CHUNK_SIZE
value|(sizeof (SomImportEntry) * SOM_READ_IMPORTS_NUM)
name|SomImportEntry
name|buffer
index|[
name|SOM_READ_IMPORTS_NUM
index|]
decl_stmt|;
comment|/* Initialize in case we error out */
name|objfile
operator|->
name|import_list
operator|=
name|NULL
expr_stmt|;
name|objfile
operator|->
name|import_list_size
operator|=
literal|0
expr_stmt|;
comment|/* It doesn't work, for some reason, to read in space $TEXT$;      the subspace $SHLIB_INFO$ has to be used.  Some BFD quirk? pai/1997-08-05 */
name|text_section
operator|=
name|bfd_get_section_by_name
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
literal|"$SHLIB_INFO$"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|text_section
condition|)
return|return
literal|0
return|;
comment|/* Get the SOM executable header */
name|bfd_get_section_contents
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|text_section
argument_list|,
name|dl_header
argument_list|,
literal|0
argument_list|,
literal|12
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check header version number for 10.x HP-UX */
comment|/* Currently we deal only with 10.x systems; on 9.x the version # is 89060912.      FIXME: Change for future HP-UX releases and mods to the SOM executable format */
if|if
condition|(
name|dl_header
index|[
literal|0
index|]
operator|!=
literal|93092112
condition|)
return|return
literal|0
return|;
name|import_list
operator|=
name|dl_header
index|[
literal|4
index|]
expr_stmt|;
name|import_list_size
operator|=
name|dl_header
index|[
literal|5
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|import_list_size
condition|)
return|return
literal|0
return|;
name|string_table
operator|=
name|dl_header
index|[
literal|10
index|]
expr_stmt|;
name|string_table_size
operator|=
name|dl_header
index|[
literal|11
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|string_table_size
condition|)
return|return
literal|0
return|;
comment|/* Suck in SOM string table */
name|string_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|string_table_size
argument_list|)
expr_stmt|;
name|bfd_get_section_contents
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|text_section
argument_list|,
name|string_buffer
argument_list|,
name|string_table
argument_list|,
name|string_table_size
argument_list|)
expr_stmt|;
comment|/* Allocate import list in the psymbol obstack; this has nothing      to do with psymbols, just a matter of convenience.  We want the      import list to be freed when the objfile is deallocated */
name|objfile
operator|->
name|import_list
operator|=
operator|(
name|ImportEntry
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
name|import_list_size
operator|*
sizeof|sizeof
argument_list|(
name|ImportEntry
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Read in the import entries, a bunch at a time */
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|k
operator|=
literal|0
init|;
name|j
operator|<
operator|(
name|import_list_size
operator|/
name|SOM_READ_IMPORTS_NUM
operator|)
condition|;
name|j
operator|++
control|)
block|{
name|bfd_get_section_contents
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|text_section
argument_list|,
name|buffer
argument_list|,
name|import_list
operator|+
name|j
operator|*
name|SOM_READ_IMPORTS_CHUNK_SIZE
argument_list|,
name|SOM_READ_IMPORTS_CHUNK_SIZE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SOM_READ_IMPORTS_NUM
condition|;
name|i
operator|++
operator|,
name|k
operator|++
control|)
block|{
if|if
condition|(
name|buffer
index|[
name|i
index|]
operator|.
name|type
operator|!=
operator|(
name|unsigned
name|char
operator|)
literal|0
condition|)
block|{
name|objfile
operator|->
name|import_list
index|[
name|k
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
name|strlen
argument_list|(
name|string_buffer
operator|+
name|buffer
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|objfile
operator|->
name|import_list
index|[
name|k
index|]
argument_list|,
name|string_buffer
operator|+
name|buffer
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
comment|/* Some day we might want to record the type and other information too */
block|}
else|else
comment|/* null type */
name|objfile
operator|->
name|import_list
index|[
name|k
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* Get the leftovers */
if|if
condition|(
name|k
operator|<
name|import_list_size
condition|)
name|bfd_get_section_contents
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|text_section
argument_list|,
name|buffer
argument_list|,
name|import_list
operator|+
name|k
operator|*
sizeof|sizeof
argument_list|(
name|SomImportEntry
argument_list|)
argument_list|,
operator|(
name|import_list_size
operator|-
name|k
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|SomImportEntry
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|k
operator|<
name|import_list_size
condition|;
name|i
operator|++
operator|,
name|k
operator|++
control|)
block|{
if|if
condition|(
name|buffer
index|[
name|i
index|]
operator|.
name|type
operator|!=
operator|(
name|unsigned
name|char
operator|)
literal|0
condition|)
block|{
name|objfile
operator|->
name|import_list
index|[
name|k
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
name|strlen
argument_list|(
name|string_buffer
operator|+
name|buffer
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|objfile
operator|->
name|import_list
index|[
name|k
index|]
argument_list|,
name|string_buffer
operator|+
name|buffer
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
comment|/* Some day we might want to record the type and other information too */
block|}
else|else
name|objfile
operator|->
name|import_list
index|[
name|k
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|objfile
operator|->
name|import_list_size
operator|=
name|import_list_size
expr_stmt|;
name|xfree
argument_list|(
name|string_buffer
argument_list|)
expr_stmt|;
return|return
name|import_list_size
return|;
block|}
end_function

begin_comment
comment|/* Read in and initialize the SOM export list which is present    for all executables and shared libraries.  The import list    consists of the symbols that are referenced in OBJFILE but    not defined there.  (Variables that are imported are dealt    with as "loc_indirect" vars.)    Return value = number of import symbols read in. */
end_comment

begin_function
name|int
name|init_export_symbols
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|unsigned
name|int
name|export_list
decl_stmt|;
name|unsigned
name|int
name|export_list_size
decl_stmt|;
name|unsigned
name|int
name|string_table
decl_stmt|;
name|unsigned
name|int
name|string_table_size
decl_stmt|;
name|char
modifier|*
name|string_buffer
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
name|int
name|k
decl_stmt|;
name|asection
modifier|*
name|text_section
decl_stmt|;
comment|/* section handle */
name|unsigned
name|int
name|dl_header
index|[
literal|12
index|]
decl_stmt|;
comment|/* SOM executable header */
comment|/* A struct for an entry in the SOM export list */
typedef|typedef
struct|struct
block|{
name|int
name|next
decl_stmt|;
comment|/* for hash table use -- we don't use this */
name|int
name|name
decl_stmt|;
comment|/* index into string table */
name|int
name|value
decl_stmt|;
comment|/* offset or plabel */
name|int
name|dont_care1
decl_stmt|;
comment|/* not used */
name|unsigned
name|char
name|type
decl_stmt|;
comment|/* 0 = NULL, 2 = Data, 3 = Code, 7 = Storage, 13 = Plabel */
name|char
name|dont_care2
decl_stmt|;
comment|/* not used */
name|short
name|dont_care3
decl_stmt|;
comment|/* not used */
block|}
name|SomExportEntry
typedef|;
comment|/* We read 100 entries in at a time from the disk file. */
define|#
directive|define
name|SOM_READ_EXPORTS_NUM
value|100
define|#
directive|define
name|SOM_READ_EXPORTS_CHUNK_SIZE
value|(sizeof (SomExportEntry) * SOM_READ_EXPORTS_NUM)
name|SomExportEntry
name|buffer
index|[
name|SOM_READ_EXPORTS_NUM
index|]
decl_stmt|;
comment|/* Initialize in case we error out */
name|objfile
operator|->
name|export_list
operator|=
name|NULL
expr_stmt|;
name|objfile
operator|->
name|export_list_size
operator|=
literal|0
expr_stmt|;
comment|/* It doesn't work, for some reason, to read in space $TEXT$;      the subspace $SHLIB_INFO$ has to be used.  Some BFD quirk? pai/1997-08-05 */
name|text_section
operator|=
name|bfd_get_section_by_name
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
literal|"$SHLIB_INFO$"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|text_section
condition|)
return|return
literal|0
return|;
comment|/* Get the SOM executable header */
name|bfd_get_section_contents
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|text_section
argument_list|,
name|dl_header
argument_list|,
literal|0
argument_list|,
literal|12
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check header version number for 10.x HP-UX */
comment|/* Currently we deal only with 10.x systems; on 9.x the version # is 89060912.      FIXME: Change for future HP-UX releases and mods to the SOM executable format */
if|if
condition|(
name|dl_header
index|[
literal|0
index|]
operator|!=
literal|93092112
condition|)
return|return
literal|0
return|;
name|export_list
operator|=
name|dl_header
index|[
literal|8
index|]
expr_stmt|;
name|export_list_size
operator|=
name|dl_header
index|[
literal|9
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|export_list_size
condition|)
return|return
literal|0
return|;
name|string_table
operator|=
name|dl_header
index|[
literal|10
index|]
expr_stmt|;
name|string_table_size
operator|=
name|dl_header
index|[
literal|11
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|string_table_size
condition|)
return|return
literal|0
return|;
comment|/* Suck in SOM string table */
name|string_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|string_table_size
argument_list|)
expr_stmt|;
name|bfd_get_section_contents
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|text_section
argument_list|,
name|string_buffer
argument_list|,
name|string_table
argument_list|,
name|string_table_size
argument_list|)
expr_stmt|;
comment|/* Allocate export list in the psymbol obstack; this has nothing      to do with psymbols, just a matter of convenience.  We want the      export list to be freed when the objfile is deallocated */
name|objfile
operator|->
name|export_list
operator|=
operator|(
name|ExportEntry
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
name|export_list_size
operator|*
sizeof|sizeof
argument_list|(
name|ExportEntry
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Read in the export entries, a bunch at a time */
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|k
operator|=
literal|0
init|;
name|j
operator|<
operator|(
name|export_list_size
operator|/
name|SOM_READ_EXPORTS_NUM
operator|)
condition|;
name|j
operator|++
control|)
block|{
name|bfd_get_section_contents
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|text_section
argument_list|,
name|buffer
argument_list|,
name|export_list
operator|+
name|j
operator|*
name|SOM_READ_EXPORTS_CHUNK_SIZE
argument_list|,
name|SOM_READ_EXPORTS_CHUNK_SIZE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SOM_READ_EXPORTS_NUM
condition|;
name|i
operator|++
operator|,
name|k
operator|++
control|)
block|{
if|if
condition|(
name|buffer
index|[
name|i
index|]
operator|.
name|type
operator|!=
operator|(
name|unsigned
name|char
operator|)
literal|0
condition|)
block|{
name|objfile
operator|->
name|export_list
index|[
name|k
index|]
operator|.
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
name|strlen
argument_list|(
name|string_buffer
operator|+
name|buffer
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|objfile
operator|->
name|export_list
index|[
name|k
index|]
operator|.
name|name
argument_list|,
name|string_buffer
operator|+
name|buffer
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|objfile
operator|->
name|export_list
index|[
name|k
index|]
operator|.
name|address
operator|=
name|buffer
index|[
name|i
index|]
operator|.
name|value
expr_stmt|;
comment|/* Some day we might want to record the type and other information too */
block|}
else|else
comment|/* null type */
block|{
name|objfile
operator|->
name|export_list
index|[
name|k
index|]
operator|.
name|name
operator|=
name|NULL
expr_stmt|;
name|objfile
operator|->
name|export_list
index|[
name|k
index|]
operator|.
name|address
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
comment|/* Get the leftovers */
if|if
condition|(
name|k
operator|<
name|export_list_size
condition|)
name|bfd_get_section_contents
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|text_section
argument_list|,
name|buffer
argument_list|,
name|export_list
operator|+
name|k
operator|*
sizeof|sizeof
argument_list|(
name|SomExportEntry
argument_list|)
argument_list|,
operator|(
name|export_list_size
operator|-
name|k
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|SomExportEntry
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|k
operator|<
name|export_list_size
condition|;
name|i
operator|++
operator|,
name|k
operator|++
control|)
block|{
if|if
condition|(
name|buffer
index|[
name|i
index|]
operator|.
name|type
operator|!=
operator|(
name|unsigned
name|char
operator|)
literal|0
condition|)
block|{
name|objfile
operator|->
name|export_list
index|[
name|k
index|]
operator|.
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
name|strlen
argument_list|(
name|string_buffer
operator|+
name|buffer
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|objfile
operator|->
name|export_list
index|[
name|k
index|]
operator|.
name|name
argument_list|,
name|string_buffer
operator|+
name|buffer
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
comment|/* Some day we might want to record the type and other information too */
name|objfile
operator|->
name|export_list
index|[
name|k
index|]
operator|.
name|address
operator|=
name|buffer
index|[
name|i
index|]
operator|.
name|value
expr_stmt|;
block|}
else|else
block|{
name|objfile
operator|->
name|export_list
index|[
name|k
index|]
operator|.
name|name
operator|=
name|NULL
expr_stmt|;
name|objfile
operator|->
name|export_list
index|[
name|k
index|]
operator|.
name|address
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|objfile
operator|->
name|export_list_size
operator|=
name|export_list_size
expr_stmt|;
name|xfree
argument_list|(
name|string_buffer
argument_list|)
expr_stmt|;
return|return
name|export_list_size
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Register that we are able to handle SOM object file formats.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sym_fns
name|som_sym_fns
init|=
block|{
name|bfd_target_som_flavour
block|,
name|som_new_init
block|,
comment|/* sym_new_init: init anything gbl to entire symtab */
name|som_symfile_init
block|,
comment|/* sym_init: read initial info, setup for sym_read() */
name|som_symfile_read
block|,
comment|/* sym_read: read a symbol file into symtab */
name|som_symfile_finish
block|,
comment|/* sym_finish: finished with file, cleanup */
name|som_symfile_offsets
block|,
comment|/* sym_offsets:  Translate ext. to int. relocation */
name|NULL
comment|/* next: pointer to next struct sym_fns */
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|_initialize_somread
parameter_list|(
name|void
parameter_list|)
block|{
name|add_symtab_fns
argument_list|(
operator|&
name|som_sym_fns
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

