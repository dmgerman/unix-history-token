begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Read HP PA/Risc object files for GDB.    Copyright 1991, 1992, 1996 Free Software Foundation, Inc.    Written by Fred Fish at Cygnus Support.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"som.h"
end_include

begin_include
include|#
directive|include
file|"libhppa.h"
end_include

begin_include
include|#
directive|include
file|<syms.h>
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"buildsym.h"
end_include

begin_include
include|#
directive|include
file|"stabsread.h"
end_include

begin_include
include|#
directive|include
file|"gdb-stabs.h"
end_include

begin_include
include|#
directive|include
file|"complaints.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_comment
comment|/* Various things we might complain about... */
end_comment

begin_decl_stmt
specifier|static
name|void
name|som_symfile_init
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|som_new_init
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|som_symfile_read
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|,
expr|struct
name|section_offsets
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|som_symfile_finish
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|som_symtab_read
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|objfile
operator|*
operator|,
expr|struct
name|section_offsets
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|section_offsets
modifier|*
name|som_symfile_offsets
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|,
name|CORE_ADDR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|record_minimal_symbol
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|CORE_ADDR
operator|,
expr|enum
name|minimal_symbol_type
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|record_minimal_symbol
parameter_list|(
name|name
parameter_list|,
name|address
parameter_list|,
name|ms_type
parameter_list|,
name|objfile
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|CORE_ADDR
name|address
decl_stmt|;
name|enum
name|minimal_symbol_type
name|ms_type
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|name
operator|=
name|obsavestring
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|)
expr_stmt|;
name|prim_record_minimal_symbol
argument_list|(
name|name
argument_list|,
name|address
argument_list|,
name|ms_type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	som_symtab_read -- read the symbol table of a SOM file  SYNOPSIS  	void som_symtab_read (bfd *abfd, struct objfile *objfile, 			      struct section_offsets *section_offsets)  DESCRIPTION  	Given an open bfd, a base address to relocate symbols to, and a 	flag that specifies whether or not this bfd is for an executable 	or not (may be shared library for example), add all the global 	function and data symbols to the minimal symbol table. */
end_comment

begin_function
specifier|static
name|void
name|som_symtab_read
parameter_list|(
name|abfd
parameter_list|,
name|objfile
parameter_list|,
name|section_offsets
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|section_offsets
modifier|*
name|section_offsets
decl_stmt|;
block|{
name|unsigned
name|int
name|number_of_symbols
decl_stmt|;
name|int
name|val
decl_stmt|,
name|dynamic
decl_stmt|;
name|char
modifier|*
name|stringtab
decl_stmt|;
name|asection
modifier|*
name|shlib_info
decl_stmt|;
name|struct
name|symbol_dictionary_record
modifier|*
name|buf
decl_stmt|,
modifier|*
name|bufp
decl_stmt|,
modifier|*
name|endbufp
decl_stmt|;
name|char
modifier|*
name|symname
decl_stmt|;
name|CONST
name|int
name|symsize
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|symbol_dictionary_record
argument_list|)
decl_stmt|;
name|CORE_ADDR
name|text_offset
decl_stmt|,
name|data_offset
decl_stmt|;
name|text_offset
operator|=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|data_offset
operator|=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|number_of_symbols
operator|=
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|buf
operator|=
name|alloca
argument_list|(
name|symsize
operator|*
name|number_of_symbols
argument_list|)
expr_stmt|;
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|obj_som_sym_filepos
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|val
operator|=
name|bfd_read
argument_list|(
name|buf
argument_list|,
name|symsize
operator|*
name|number_of_symbols
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|symsize
operator|*
name|number_of_symbols
condition|)
name|error
argument_list|(
literal|"Couldn't read symbol dictionary!"
argument_list|)
expr_stmt|;
name|stringtab
operator|=
name|alloca
argument_list|(
name|obj_som_stringtab_size
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|obj_som_str_filepos
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|val
operator|=
name|bfd_read
argument_list|(
name|stringtab
argument_list|,
name|obj_som_stringtab_size
argument_list|(
name|abfd
argument_list|)
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|obj_som_stringtab_size
argument_list|(
name|abfd
argument_list|)
condition|)
name|error
argument_list|(
literal|"Can't read in HP string table."
argument_list|)
expr_stmt|;
comment|/* We need to determine if objfile is a dynamic executable (so we      can do the right thing for ST_ENTRY vs ST_CODE symbols).       There's nothing in the header which easily allows us to do      this.  The only reliable way I know of is to check for the      existance of a $SHLIB_INFO$ section with a non-zero size.  */
name|shlib_info
operator|=
name|bfd_get_section_by_name
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
literal|"$SHLIB_INFO$"
argument_list|)
expr_stmt|;
if|if
condition|(
name|shlib_info
condition|)
name|dynamic
operator|=
operator|(
name|bfd_section_size
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|shlib_info
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
else|else
name|dynamic
operator|=
literal|0
expr_stmt|;
name|endbufp
operator|=
name|buf
operator|+
name|number_of_symbols
expr_stmt|;
for|for
control|(
name|bufp
operator|=
name|buf
init|;
name|bufp
operator|<
name|endbufp
condition|;
operator|++
name|bufp
control|)
block|{
name|enum
name|minimal_symbol_type
name|ms_type
decl_stmt|;
name|QUIT
expr_stmt|;
switch|switch
condition|(
name|bufp
operator|->
name|symbol_scope
condition|)
block|{
case|case
name|SS_UNIVERSAL
case|:
case|case
name|SS_EXTERNAL
case|:
switch|switch
condition|(
name|bufp
operator|->
name|symbol_type
condition|)
block|{
case|case
name|ST_SYM_EXT
case|:
case|case
name|ST_ARG_EXT
case|:
continue|continue;
case|case
name|ST_CODE
case|:
case|case
name|ST_PRI_PROG
case|:
case|case
name|ST_SEC_PROG
case|:
case|case
name|ST_MILLICODE
case|:
name|symname
operator|=
name|bufp
operator|->
name|name
operator|.
name|n_strx
operator|+
name|stringtab
expr_stmt|;
name|ms_type
operator|=
name|mst_text
expr_stmt|;
name|bufp
operator|->
name|symbol_value
operator|+=
name|text_offset
expr_stmt|;
ifdef|#
directive|ifdef
name|SMASH_TEXT_ADDRESS
name|SMASH_TEXT_ADDRESS
argument_list|(
name|bufp
operator|->
name|symbol_value
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|ST_ENTRY
case|:
name|symname
operator|=
name|bufp
operator|->
name|name
operator|.
name|n_strx
operator|+
name|stringtab
expr_stmt|;
comment|/* For a dynamic executable, ST_ENTRY symbols are 		 the stubs, while the ST_CODE symbol is the real 		 function.  */
if|if
condition|(
name|dynamic
condition|)
name|ms_type
operator|=
name|mst_solib_trampoline
expr_stmt|;
else|else
name|ms_type
operator|=
name|mst_text
expr_stmt|;
name|bufp
operator|->
name|symbol_value
operator|+=
name|text_offset
expr_stmt|;
ifdef|#
directive|ifdef
name|SMASH_TEXT_ADDRESS
name|SMASH_TEXT_ADDRESS
argument_list|(
name|bufp
operator|->
name|symbol_value
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|ST_STUB
case|:
name|symname
operator|=
name|bufp
operator|->
name|name
operator|.
name|n_strx
operator|+
name|stringtab
expr_stmt|;
name|ms_type
operator|=
name|mst_solib_trampoline
expr_stmt|;
name|bufp
operator|->
name|symbol_value
operator|+=
name|text_offset
expr_stmt|;
ifdef|#
directive|ifdef
name|SMASH_TEXT_ADDRESS
name|SMASH_TEXT_ADDRESS
argument_list|(
name|bufp
operator|->
name|symbol_value
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|ST_DATA
case|:
name|symname
operator|=
name|bufp
operator|->
name|name
operator|.
name|n_strx
operator|+
name|stringtab
expr_stmt|;
name|bufp
operator|->
name|symbol_value
operator|+=
name|data_offset
expr_stmt|;
name|ms_type
operator|=
name|mst_data
expr_stmt|;
break|break;
default|default:
continue|continue;
block|}
break|break;
if|#
directive|if
literal|0
comment|/* SS_GLOBAL and SS_LOCAL are two names for the same thing (!).  */
block|case SS_GLOBAL:
endif|#
directive|endif
case|case
name|SS_LOCAL
case|:
switch|switch
condition|(
name|bufp
operator|->
name|symbol_type
condition|)
block|{
case|case
name|ST_SYM_EXT
case|:
case|case
name|ST_ARG_EXT
case|:
continue|continue;
case|case
name|ST_CODE
case|:
name|symname
operator|=
name|bufp
operator|->
name|name
operator|.
name|n_strx
operator|+
name|stringtab
expr_stmt|;
name|ms_type
operator|=
name|mst_file_text
expr_stmt|;
name|bufp
operator|->
name|symbol_value
operator|+=
name|text_offset
expr_stmt|;
ifdef|#
directive|ifdef
name|SMASH_TEXT_ADDRESS
name|SMASH_TEXT_ADDRESS
argument_list|(
name|bufp
operator|->
name|symbol_value
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|check_strange_names
label|:
comment|/* Utah GCC 2.5, FSF GCC 2.6 and later generate correct local 		 label prefixes for stabs, constant data, etc.  So we need 		 only filter out L$ symbols which are left in due to 		 limitations in how GAS generates SOM relocations.  		 When linking in the HPUX C-library the HP linker has 		 the nasty habit of placing section symbols from the literal 		 subspaces in the middle of the program's text.  Filter 		 those out as best we can.  Check for first and last character 		 being '$'.   		 And finally, the newer HP compilers emit crud like $PIC_foo$N 		 in some circumstance (PIC code I guess).  It's also claimed 		 that they emit D$ symbols too.  What stupidity.  */
if|if
condition|(
operator|(
name|symname
index|[
literal|0
index|]
operator|==
literal|'L'
operator|&&
name|symname
index|[
literal|1
index|]
operator|==
literal|'$'
operator|)
operator|||
operator|(
name|symname
index|[
literal|0
index|]
operator|==
literal|'$'
operator|&&
name|symname
index|[
name|strlen
argument_list|(
name|symname
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'$'
operator|)
operator|||
operator|(
name|symname
index|[
literal|0
index|]
operator|==
literal|'D'
operator|&&
name|symname
index|[
literal|1
index|]
operator|==
literal|'$'
operator|)
operator|||
operator|(
name|strncmp
argument_list|(
name|symname
argument_list|,
literal|"$PIC"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
operator|)
condition|)
continue|continue;
break|break;
case|case
name|ST_PRI_PROG
case|:
case|case
name|ST_SEC_PROG
case|:
case|case
name|ST_MILLICODE
case|:
name|symname
operator|=
name|bufp
operator|->
name|name
operator|.
name|n_strx
operator|+
name|stringtab
expr_stmt|;
name|ms_type
operator|=
name|mst_file_text
expr_stmt|;
name|bufp
operator|->
name|symbol_value
operator|+=
name|text_offset
expr_stmt|;
ifdef|#
directive|ifdef
name|SMASH_TEXT_ADDRESS
name|SMASH_TEXT_ADDRESS
argument_list|(
name|bufp
operator|->
name|symbol_value
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|ST_ENTRY
case|:
name|symname
operator|=
name|bufp
operator|->
name|name
operator|.
name|n_strx
operator|+
name|stringtab
expr_stmt|;
comment|/* For a dynamic executable, ST_ENTRY symbols are 		 the stubs, while the ST_CODE symbol is the real 		 function.  */
if|if
condition|(
name|dynamic
condition|)
name|ms_type
operator|=
name|mst_solib_trampoline
expr_stmt|;
else|else
name|ms_type
operator|=
name|mst_file_text
expr_stmt|;
name|bufp
operator|->
name|symbol_value
operator|+=
name|text_offset
expr_stmt|;
ifdef|#
directive|ifdef
name|SMASH_TEXT_ADDRESS
name|SMASH_TEXT_ADDRESS
argument_list|(
name|bufp
operator|->
name|symbol_value
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|ST_STUB
case|:
name|symname
operator|=
name|bufp
operator|->
name|name
operator|.
name|n_strx
operator|+
name|stringtab
expr_stmt|;
name|ms_type
operator|=
name|mst_solib_trampoline
expr_stmt|;
name|bufp
operator|->
name|symbol_value
operator|+=
name|text_offset
expr_stmt|;
ifdef|#
directive|ifdef
name|SMASH_TEXT_ADDRESS
name|SMASH_TEXT_ADDRESS
argument_list|(
name|bufp
operator|->
name|symbol_value
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|ST_DATA
case|:
name|symname
operator|=
name|bufp
operator|->
name|name
operator|.
name|n_strx
operator|+
name|stringtab
expr_stmt|;
name|bufp
operator|->
name|symbol_value
operator|+=
name|data_offset
expr_stmt|;
name|ms_type
operator|=
name|mst_file_data
expr_stmt|;
goto|goto
name|check_strange_names
goto|;
default|default:
continue|continue;
block|}
break|break;
comment|/* This can happen for common symbols when -E is passed to the 	   final link.  No idea _why_ that would make the linker force 	   common symbols to have an SS_UNSAT scope, but it does.  */
case|case
name|SS_UNSAT
case|:
switch|switch
condition|(
name|bufp
operator|->
name|symbol_type
condition|)
block|{
case|case
name|ST_STORAGE
case|:
name|symname
operator|=
name|bufp
operator|->
name|name
operator|.
name|n_strx
operator|+
name|stringtab
expr_stmt|;
name|bufp
operator|->
name|symbol_value
operator|+=
name|data_offset
expr_stmt|;
name|ms_type
operator|=
name|mst_data
expr_stmt|;
break|break;
default|default:
continue|continue;
block|}
break|break;
default|default:
continue|continue;
block|}
if|if
condition|(
name|bufp
operator|->
name|name
operator|.
name|n_strx
operator|>
name|obj_som_stringtab_size
argument_list|(
name|abfd
argument_list|)
condition|)
name|error
argument_list|(
literal|"Invalid symbol data; bad HP string table offset: %d"
argument_list|,
name|bufp
operator|->
name|name
operator|.
name|n_strx
argument_list|)
expr_stmt|;
name|record_minimal_symbol
argument_list|(
name|symname
argument_list|,
name|bufp
operator|->
name|symbol_value
argument_list|,
name|ms_type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Scan and build partial symbols for a symbol file.    We have been initialized by a call to som_symfile_init, which     currently does nothing.     SECTION_OFFSETS is a set of offsets to apply to relocate the symbols    in each section.  This is ignored, as it isn't needed for SOM.     MAINLINE is true if we are reading the main symbol    table (as opposed to a shared lib or dynamically loaded file).     This function only does the minimum work necessary for letting the    user "name" things symbolically; it does not read the entire symtab.    Instead, it reads the external and static symbols and puts them in partial    symbol tables.  When more extensive information is requested of a    file, the corresponding partial symbol table is mutated into a full    fledged symbol table by going back and reading the symbols    for real.     We look for sections with specific names, to tell us what debug    format to look for:  FIXME!!!     somstab_build_psymtabs() handles STABS symbols.     Note that SOM files have a "minimal" symbol table, which is vaguely    reminiscent of a COFF symbol table, but has only the minimal information    necessary for linking.  We process this also, and use the information to    build gdb's minimal symbol table.  This gives us some minimal debugging    capability even for files compiled without -g.  */
end_comment

begin_function
specifier|static
name|void
name|som_symfile_read
parameter_list|(
name|objfile
parameter_list|,
name|section_offsets
parameter_list|,
name|mainline
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|section_offsets
modifier|*
name|section_offsets
decl_stmt|;
name|int
name|mainline
decl_stmt|;
block|{
name|bfd
modifier|*
name|abfd
init|=
name|objfile
operator|->
name|obfd
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|back_to
decl_stmt|;
name|init_minimal_symbol_collection
argument_list|()
expr_stmt|;
name|back_to
operator|=
name|make_cleanup
argument_list|(
name|discard_minimal_symbols
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Process the normal SOM symbol table first. */
name|som_symtab_read
argument_list|(
name|abfd
argument_list|,
name|objfile
argument_list|,
name|section_offsets
argument_list|)
expr_stmt|;
comment|/* Now read information from the stabs debug sections.  */
name|stabsect_build_psymtabs
argument_list|(
name|objfile
argument_list|,
name|section_offsets
argument_list|,
name|mainline
argument_list|,
literal|"$GDB_SYMBOLS$"
argument_list|,
literal|"$GDB_STRINGS$"
argument_list|,
literal|"$TEXT$"
argument_list|)
expr_stmt|;
comment|/* Now read the native debug information.  */
name|hpread_build_psymtabs
argument_list|(
name|objfile
argument_list|,
name|section_offsets
argument_list|,
name|mainline
argument_list|)
expr_stmt|;
comment|/* Install any minimal symbols that have been collected as the current      minimal symbols for this objfile.  */
name|install_minimal_symbols
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
comment|/* Force hppa-tdep.c to re-read the unwind descriptors.  */
name|objfile
operator|->
name|obj_private
operator|=
name|NULL
expr_stmt|;
name|do_cleanups
argument_list|(
name|back_to
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize anything that needs initializing when a completely new symbol    file is specified (not just adding some symbols from another file, e.g. a    shared library).     We reinitialize buildsym, since we may be reading stabs from a SOM file.  */
end_comment

begin_function
specifier|static
name|void
name|som_new_init
parameter_list|(
name|ignore
parameter_list|)
name|struct
name|objfile
modifier|*
name|ignore
decl_stmt|;
block|{
name|stabsread_new_init
argument_list|()
expr_stmt|;
name|buildsym_new_init
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Perform any local cleanups required when we are done with a particular    objfile.  I.E, we are in the process of discarding all symbol information    for an objfile, freeing up all memory held for it, and unlinking the    objfile struct from the global list of known objfiles. */
end_comment

begin_function
specifier|static
name|void
name|som_symfile_finish
parameter_list|(
name|objfile
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
if|if
condition|(
name|objfile
operator|->
name|sym_stab_info
operator|!=
name|NULL
condition|)
block|{
name|mfree
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
name|objfile
operator|->
name|sym_stab_info
argument_list|)
expr_stmt|;
block|}
name|hpread_symfile_finish
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* SOM specific initialization routine for reading symbols.  */
end_comment

begin_function
specifier|static
name|void
name|som_symfile_init
parameter_list|(
name|objfile
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
comment|/* SOM objects may be reordered, so set OBJF_REORDERED.  If we      find this causes a significant slowdown in gdb then we could      set it in the debug symbol readers only when necessary.  */
name|objfile
operator|->
name|flags
operator||=
name|OBJF_REORDERED
expr_stmt|;
name|hpread_symfile_init
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* SOM specific parsing routine for section offsets.     Plain and simple for now.  */
end_comment

begin_function
specifier|static
name|struct
name|section_offsets
modifier|*
name|som_symfile_offsets
parameter_list|(
name|objfile
parameter_list|,
name|addr
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
block|{
name|struct
name|section_offsets
modifier|*
name|section_offsets
decl_stmt|;
name|int
name|i
decl_stmt|;
name|objfile
operator|->
name|num_sections
operator|=
name|SECT_OFF_MAX
expr_stmt|;
name|section_offsets
operator|=
operator|(
expr|struct
name|section_offsets
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|psymbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|section_offsets
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|section_offsets
operator|->
name|offsets
argument_list|)
operator|*
operator|(
name|SECT_OFF_MAX
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
comment|/* First see if we're a shared library.  If so, get the section      offsets from the library, else get them from addr.  */
if|if
condition|(
operator|!
name|som_solib_section_offsets
argument_list|(
name|objfile
argument_list|,
name|section_offsets
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SECT_OFF_MAX
condition|;
name|i
operator|++
control|)
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|i
argument_list|)
operator|=
name|addr
expr_stmt|;
block|}
return|return
name|section_offsets
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Register that we are able to handle SOM object file formats.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sym_fns
name|som_sym_fns
init|=
block|{
name|bfd_target_som_flavour
block|,
name|som_new_init
block|,
comment|/* sym_new_init: init anything gbl to entire symtab */
name|som_symfile_init
block|,
comment|/* sym_init: read initial info, setup for sym_read() */
name|som_symfile_read
block|,
comment|/* sym_read: read a symbol file into symtab */
name|som_symfile_finish
block|,
comment|/* sym_finish: finished with file, cleanup */
name|som_symfile_offsets
block|,
comment|/* sym_offsets:  Translate ext. to int. relocation */
name|NULL
comment|/* next: pointer to next struct sym_fns */
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|_initialize_somread
parameter_list|()
block|{
name|add_symtab_fns
argument_list|(
operator|&
name|som_sym_fns
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

