begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Print values for GNU debugger GDB.    Copyright 1986, 87, 88, 89, 90, 91, 93, 94, 95, 1998    Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"breakpoint.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_include
include|#
directive|include
file|"valprint.h"
end_include

begin_include
include|#
directive|include
file|"annotate.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_comment
comment|/* for overlay functions */
end_comment

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_comment
comment|/* ditto */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|asm_demangle
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether to demangle syms in asm printouts */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|addressprint
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether to print hex addresses in HLL " */
end_comment

begin_struct
struct|struct
name|format_data
block|{
name|int
name|count
decl_stmt|;
name|char
name|format
decl_stmt|;
name|char
name|size
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Last specified output format.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|last_format
init|=
literal|'x'
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last specified examination size.  'b', 'h', 'w' or `q'.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|last_size
init|=
literal|'w'
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default address to examine next.  */
end_comment

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|next_address
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default section to examine next. */
end_comment

begin_decl_stmt
specifier|static
name|asection
modifier|*
name|next_section
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last address examined.  */
end_comment

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|last_examine_address
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Contents of last address examined.    This is not valid past the end of the `x' command!  */
end_comment

begin_decl_stmt
specifier|static
name|value_ptr
name|last_examine_value
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Largest offset between a symbolic value and an address, that will be    printed as `0x1234<symbol+offset>'.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|max_symbolic_offset
init|=
name|UINT_MAX
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Append the source filename and linenumber of the symbol when    printing a symbolic value as `<symbol at filename:linenum>' if set.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|print_symbol_filename
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of auto-display expression currently being displayed.    So that we can disable it if we get an error or a signal within it.    -1 when not doing one.  */
end_comment

begin_decl_stmt
name|int
name|current_display_number
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag to low-level print routines that this value is being printed    in an epoch window.  We'd like to pass this as a parameter, but    every routine would need to take it.  Perhaps we can encapsulate    this in the I/O stream once we have GNU stdio. */
end_comment

begin_decl_stmt
name|int
name|inspect_it
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|display
block|{
comment|/* Chain link to next auto-display item.  */
name|struct
name|display
modifier|*
name|next
decl_stmt|;
comment|/* Expression to be evaluated and displayed.  */
name|struct
name|expression
modifier|*
name|exp
decl_stmt|;
comment|/* Item number of this auto-display item.  */
name|int
name|number
decl_stmt|;
comment|/* Display format specified.  */
name|struct
name|format_data
name|format
decl_stmt|;
comment|/* Innermost block required by this expression when evaluated */
name|struct
name|block
modifier|*
name|block
decl_stmt|;
comment|/* Status of this display (enabled or disabled) */
name|enum
name|enable
name|status
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Chain of expressions whose values should be displayed    automatically each time the program stops.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|display
modifier|*
name|display_chain
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|display_number
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Prototypes for exported functions. */
end_comment

begin_decl_stmt
name|void
name|output_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|_initialize_printcmd
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Prototypes for local functions. */
end_comment

begin_decl_stmt
specifier|static
name|void
name|delete_display
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|enable_display
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|disable_display_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|disassemble_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|printf_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_frame_nameless_args
name|PARAMS
argument_list|(
operator|(
expr|struct
name|frame_info
operator|*
operator|,
name|long
operator|,
name|int
operator|,
name|int
operator|,
name|GDB_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|display_info
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_one_display
name|PARAMS
argument_list|(
operator|(
expr|struct
name|display
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|undisplay_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_display
name|PARAMS
argument_list|(
operator|(
expr|struct
name|display
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|display_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|x_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|address_info
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|call_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|inspect_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_command_1
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|validate_format
name|PARAMS
argument_list|(
operator|(
expr|struct
name|format_data
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_examine
name|PARAMS
argument_list|(
operator|(
expr|struct
name|format_data
operator|,
name|CORE_ADDR
name|addr
operator|,
name|asection
operator|*
name|section
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_formatted
name|PARAMS
argument_list|(
operator|(
name|value_ptr
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|format_data
name|decode_format
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|print_insn
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
operator|,
name|GDB_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sym_info
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Decode a format specification.  *STRING_PTR should point to it.    OFORMAT and OSIZE are used as defaults for the format and size    if none are given in the format specification.    If OSIZE is zero, then the size field of the returned value    should be set only if a size is explicitly specified by the    user.    The structure returned describes all the data    found in the specification.  In addition, *STRING_PTR is advanced    past the specification and past all whitespace following it.  */
end_comment

begin_function
specifier|static
name|struct
name|format_data
name|decode_format
parameter_list|(
name|string_ptr
parameter_list|,
name|oformat
parameter_list|,
name|osize
parameter_list|)
name|char
modifier|*
modifier|*
name|string_ptr
decl_stmt|;
name|int
name|oformat
decl_stmt|;
name|int
name|osize
decl_stmt|;
block|{
name|struct
name|format_data
name|val
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
init|=
operator|*
name|string_ptr
decl_stmt|;
name|val
operator|.
name|format
operator|=
literal|'?'
expr_stmt|;
name|val
operator|.
name|size
operator|=
literal|'?'
expr_stmt|;
name|val
operator|.
name|count
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|>=
literal|'0'
operator|&&
operator|*
name|p
operator|<=
literal|'9'
condition|)
name|val
operator|.
name|count
operator|=
name|atoi
argument_list|(
name|p
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|>=
literal|'0'
operator|&&
operator|*
name|p
operator|<=
literal|'9'
condition|)
name|p
operator|++
expr_stmt|;
comment|/* Now process size or format letters that follow.  */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'b'
operator|||
operator|*
name|p
operator|==
literal|'h'
operator|||
operator|*
name|p
operator|==
literal|'w'
operator|||
operator|*
name|p
operator|==
literal|'g'
condition|)
name|val
operator|.
name|size
operator|=
operator|*
name|p
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|>=
literal|'a'
operator|&&
operator|*
name|p
operator|<=
literal|'z'
condition|)
name|val
operator|.
name|format
operator|=
operator|*
name|p
operator|++
expr_stmt|;
else|else
break|break;
block|}
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
operator|*
name|string_ptr
operator|=
name|p
expr_stmt|;
comment|/* Set defaults for format and size if not specified.  */
if|if
condition|(
name|val
operator|.
name|format
operator|==
literal|'?'
condition|)
block|{
if|if
condition|(
name|val
operator|.
name|size
operator|==
literal|'?'
condition|)
block|{
comment|/* Neither has been specified.  */
name|val
operator|.
name|format
operator|=
name|oformat
expr_stmt|;
name|val
operator|.
name|size
operator|=
name|osize
expr_stmt|;
block|}
else|else
comment|/* If a size is specified, any format makes a reasonable 	   default except 'i'.  */
name|val
operator|.
name|format
operator|=
name|oformat
operator|==
literal|'i'
condition|?
literal|'x'
else|:
name|oformat
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|val
operator|.
name|size
operator|==
literal|'?'
condition|)
switch|switch
condition|(
name|val
operator|.
name|format
condition|)
block|{
case|case
literal|'a'
case|:
case|case
literal|'s'
case|:
comment|/* Pick the appropriate size for an address.  */
if|if
condition|(
name|TARGET_PTR_BIT
operator|==
literal|64
condition|)
name|val
operator|.
name|size
operator|=
name|osize
condition|?
literal|'g'
else|:
name|osize
expr_stmt|;
elseif|else
if|if
condition|(
name|TARGET_PTR_BIT
operator|==
literal|32
condition|)
name|val
operator|.
name|size
operator|=
name|osize
condition|?
literal|'w'
else|:
name|osize
expr_stmt|;
elseif|else
if|if
condition|(
name|TARGET_PTR_BIT
operator|==
literal|16
condition|)
name|val
operator|.
name|size
operator|=
name|osize
condition|?
literal|'h'
else|:
name|osize
expr_stmt|;
else|else
comment|/* Bad value for TARGET_PTR_BIT */
name|abort
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* Floating point has to be word or giantword.  */
if|if
condition|(
name|osize
operator|==
literal|'w'
operator|||
name|osize
operator|==
literal|'g'
condition|)
name|val
operator|.
name|size
operator|=
name|osize
expr_stmt|;
else|else
comment|/* Default it to giantword if the last used size is not 	     appropriate.  */
name|val
operator|.
name|size
operator|=
name|osize
condition|?
literal|'g'
else|:
name|osize
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/* Characters default to one byte.  */
name|val
operator|.
name|size
operator|=
name|osize
condition|?
literal|'b'
else|:
name|osize
expr_stmt|;
break|break;
default|default:
comment|/* The default is the size most recently specified.  */
name|val
operator|.
name|size
operator|=
name|osize
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print value VAL on gdb_stdout according to FORMAT, a letter or 0.    Do not end with a newline.    0 means print VAL according to its own type.    SIZE is the letter for the size of datum being printed.    This is used to pad hex numbers so they line up.  */
end_comment

begin_function
specifier|static
name|void
name|print_formatted
parameter_list|(
name|val
parameter_list|,
name|format
parameter_list|,
name|size
parameter_list|)
specifier|register
name|value_ptr
name|val
decl_stmt|;
specifier|register
name|int
name|format
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|struct
name|type
modifier|*
name|type
init|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|VALUE_LVAL
argument_list|(
name|val
argument_list|)
operator|==
name|lval_memory
condition|)
block|{
name|next_address
operator|=
name|VALUE_ADDRESS
argument_list|(
name|val
argument_list|)
operator|+
name|len
expr_stmt|;
name|next_section
operator|=
name|VALUE_BFD_SECTION
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|format
condition|)
block|{
case|case
literal|'s'
case|:
comment|/* FIXME: Need to handle wchar_t's here... */
name|next_address
operator|=
name|VALUE_ADDRESS
argument_list|(
name|val
argument_list|)
operator|+
name|val_print_string
argument_list|(
name|VALUE_ADDRESS
argument_list|(
name|val
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|next_section
operator|=
name|VALUE_BFD_SECTION
argument_list|(
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
comment|/* The old comment says 	 "Force output out, print_insn not using _filtered". 	 I'm not completely sure what that means, I suspect most print_insn 	 now do use _filtered, so I guess it's obsolete. 	   --Yes, it does filter now, and so this is obsolete.  -JB  */
comment|/* We often wrap here if there are long symbolic names.  */
name|wrap_here
argument_list|(
literal|"    "
argument_list|)
expr_stmt|;
name|next_address
operator|=
name|VALUE_ADDRESS
argument_list|(
name|val
argument_list|)
operator|+
name|print_insn
argument_list|(
name|VALUE_ADDRESS
argument_list|(
name|val
argument_list|)
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|next_section
operator|=
name|VALUE_BFD_SECTION
argument_list|(
name|val
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|format
operator|==
literal|0
operator|||
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_ARRAY
operator|||
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_STRING
operator|||
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
operator|||
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_UNION
condition|)
comment|/* If format is 0, use the 'natural' format for          * that type of value.  If the type is non-scalar,          * we have to use language rules to print it as          * a series of scalars.          */
name|value_print
argument_list|(
name|val
argument_list|,
name|gdb_stdout
argument_list|,
name|format
argument_list|,
name|Val_pretty_default
argument_list|)
expr_stmt|;
else|else
comment|/* User specified format, so don't look to the          * the type to tell us what to do.          */
name|print_scalar_formatted
argument_list|(
name|VALUE_CONTENTS
argument_list|(
name|val
argument_list|)
argument_list|,
name|type
argument_list|,
name|format
argument_list|,
name|size
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print a scalar of data of type TYPE, pointed to in GDB by VALADDR,    according to letters FORMAT and SIZE on STREAM.    FORMAT may not be zero.  Formats s and i are not supported at this level.     This is how the elements of an array or structure are printed    with a format.  */
end_comment

begin_function
name|void
name|print_scalar_formatted
parameter_list|(
name|valaddr
parameter_list|,
name|type
parameter_list|,
name|format
parameter_list|,
name|size
parameter_list|,
name|stream
parameter_list|)
name|char
modifier|*
name|valaddr
decl_stmt|;
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|int
name|format
decl_stmt|;
name|int
name|size
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|LONGEST
name|val_long
decl_stmt|;
name|unsigned
name|int
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|>
sizeof|sizeof
argument_list|(
name|LONGEST
argument_list|)
operator|&&
operator|(
name|format
operator|==
literal|'t'
operator|||
name|format
operator|==
literal|'c'
operator|||
name|format
operator|==
literal|'o'
operator|||
name|format
operator|==
literal|'u'
operator|||
name|format
operator|==
literal|'d'
operator|||
name|format
operator|==
literal|'x'
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|||
operator|!
name|extract_long_unsigned_integer
argument_list|(
name|valaddr
argument_list|,
name|len
argument_list|,
operator|&
name|val_long
argument_list|)
condition|)
block|{
comment|/* We can't print it normally, but we can print it in hex. 	     Printing it in the wrong radix is more useful than saying 	     "use /x, you dummy".  */
comment|/* FIXME:  we could also do octal or binary if that was the 	     desired format.  */
comment|/* FIXME:  we should be using the size field to give us a 	     minimum field width to print.  */
if|if
condition|(
name|format
operator|==
literal|'o'
condition|)
name|print_octal_chars
argument_list|(
name|stream
argument_list|,
name|valaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|format
operator|==
literal|'d'
condition|)
name|print_decimal_chars
argument_list|(
name|stream
argument_list|,
name|valaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|format
operator|==
literal|'t'
condition|)
name|print_binary_chars
argument_list|(
name|stream
argument_list|,
name|valaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|else
comment|/* replace with call to print_hex_chars? Looks                  like val_print_type_code_int is redoing                  work.  - edie */
name|val_print_type_code_int
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If we get here, extract_long_unsigned_integer set val_long.  */
block|}
elseif|else
if|if
condition|(
name|format
operator|!=
literal|'f'
condition|)
name|val_long
operator|=
name|unpack_long
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|)
expr_stmt|;
comment|/* If we are printing it as unsigned, truncate it in case it is actually      a negative signed value (e.g. "print/u (short)-1" should print 65535      (if shorts are 16 bits) instead of 4294967295).  */
if|if
condition|(
name|format
operator|!=
literal|'d'
condition|)
block|{
if|if
condition|(
name|len
operator|<
sizeof|sizeof
argument_list|(
name|LONGEST
argument_list|)
condition|)
name|val_long
operator|&=
operator|(
operator|(
name|LONGEST
operator|)
literal|1
operator|<<
name|HOST_CHAR_BIT
operator|*
name|len
operator|)
operator|-
literal|1
expr_stmt|;
block|}
switch|switch
condition|(
name|format
condition|)
block|{
case|case
literal|'x'
case|:
if|if
condition|(
operator|!
name|size
condition|)
block|{
comment|/* no size specified, like in print.  Print varying # of digits. */
name|print_longest
argument_list|(
name|stream
argument_list|,
literal|'x'
argument_list|,
literal|1
argument_list|,
name|val_long
argument_list|)
expr_stmt|;
block|}
else|else
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|'b'
case|:
case|case
literal|'h'
case|:
case|case
literal|'w'
case|:
case|case
literal|'g'
case|:
name|print_longest
argument_list|(
name|stream
argument_list|,
name|size
argument_list|,
literal|1
argument_list|,
name|val_long
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Undefined output size \"%c\"."
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'d'
case|:
name|print_longest
argument_list|(
name|stream
argument_list|,
literal|'d'
argument_list|,
literal|1
argument_list|,
name|val_long
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|print_longest
argument_list|(
name|stream
argument_list|,
literal|'u'
argument_list|,
literal|0
argument_list|,
name|val_long
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
if|if
condition|(
name|val_long
condition|)
name|print_longest
argument_list|(
name|stream
argument_list|,
literal|'o'
argument_list|,
literal|1
argument_list|,
name|val_long
argument_list|)
expr_stmt|;
else|else
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|print_address
argument_list|(
name|unpack_pointer
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|value_print
argument_list|(
name|value_from_longest
argument_list|(
name|builtin_type_char
argument_list|,
name|val_long
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
name|Val_pretty_default
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
if|if
condition|(
name|len
operator|==
sizeof|sizeof
argument_list|(
name|float
argument_list|)
condition|)
name|type
operator|=
name|builtin_type_float
expr_stmt|;
elseif|else
if|if
condition|(
name|len
operator|==
sizeof|sizeof
argument_list|(
name|double
argument_list|)
condition|)
name|type
operator|=
name|builtin_type_double
expr_stmt|;
name|print_floating
argument_list|(
name|valaddr
argument_list|,
name|type
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|abort
argument_list|()
expr_stmt|;
case|case
literal|'t'
case|:
comment|/* Binary; 't' stands for "two".  */
block|{
name|char
name|bits
index|[
literal|8
operator|*
operator|(
sizeof|sizeof
name|val_long
operator|)
operator|+
literal|1
index|]
decl_stmt|;
name|char
name|buf
index|[
literal|8
operator|*
operator|(
sizeof|sizeof
name|val_long
operator|)
operator|+
literal|32
index|]
decl_stmt|;
name|char
modifier|*
name|cp
init|=
name|bits
decl_stmt|;
name|int
name|width
decl_stmt|;
if|if
condition|(
operator|!
name|size
condition|)
name|width
operator|=
literal|8
operator|*
operator|(
sizeof|sizeof
name|val_long
operator|)
expr_stmt|;
else|else
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|'b'
case|:
name|width
operator|=
literal|8
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|width
operator|=
literal|16
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|width
operator|=
literal|32
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|width
operator|=
literal|64
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Undefined output size \"%c\"."
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
name|bits
index|[
name|width
index|]
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|width
operator|--
operator|>
literal|0
condition|)
block|{
name|bits
index|[
name|width
index|]
operator|=
operator|(
name|val_long
operator|&
literal|1
operator|)
condition|?
literal|'1'
else|:
literal|'0'
expr_stmt|;
name|val_long
operator|>>=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|size
condition|)
block|{
while|while
condition|(
operator|*
name|cp
operator|&&
operator|*
name|cp
operator|==
literal|'0'
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
name|cp
operator|--
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|buf
argument_list|,
name|local_binary_format_prefix
argument_list|()
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
name|local_binary_format_suffix
argument_list|()
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|error
argument_list|(
literal|"Undefined output format \"%c\"."
argument_list|,
name|format
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Specify default address for `x' command.    `info lines' uses this.  */
end_comment

begin_function
name|void
name|set_next_address
parameter_list|(
name|addr
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
block|{
name|next_address
operator|=
name|addr
expr_stmt|;
comment|/* Make address available to the user as $_.  */
name|set_internalvar
argument_list|(
name|lookup_internalvar
argument_list|(
literal|"_"
argument_list|)
argument_list|,
name|value_from_longest
argument_list|(
name|lookup_pointer_type
argument_list|(
name|builtin_type_void
argument_list|)
argument_list|,
operator|(
name|LONGEST
operator|)
name|addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Optionally print address ADDR symbolically as<SYMBOL+OFFSET> on STREAM,    after LEADIN.  Print nothing if no symbolic name is found nearby.    Optionally also print source file and line number, if available.    DO_DEMANGLE controls whether to print a symbol in its native "raw" form,    or to interpret it as a possible C++ name and convert it back to source    form.  However note that DO_DEMANGLE can be overridden by the specific    settings of the demangle and asm_demangle variables.  */
end_comment

begin_function
name|void
name|print_address_symbolic
parameter_list|(
name|addr
parameter_list|,
name|stream
parameter_list|,
name|do_demangle
parameter_list|,
name|leadin
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|do_demangle
decl_stmt|;
name|char
modifier|*
name|leadin
decl_stmt|;
block|{
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
name|struct
name|symbol
modifier|*
name|symbol
decl_stmt|;
name|struct
name|symtab
modifier|*
name|symtab
init|=
literal|0
decl_stmt|;
name|CORE_ADDR
name|name_location
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|name
init|=
literal|""
decl_stmt|;
name|asection
modifier|*
name|section
init|=
literal|0
decl_stmt|;
name|int
name|unmapped
init|=
literal|0
decl_stmt|;
comment|/* Determine if the address is in an overlay, and whether it is mapped. */
if|if
condition|(
name|overlay_debugging
condition|)
block|{
name|section
operator|=
name|find_pc_overlay
argument_list|(
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|pc_in_unmapped_range
argument_list|(
name|addr
argument_list|,
name|section
argument_list|)
condition|)
block|{
name|unmapped
operator|=
literal|1
expr_stmt|;
name|addr
operator|=
name|overlay_mapped_address
argument_list|(
name|addr
argument_list|,
name|section
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* On some targets, add in extra "flag" bits to PC for      disassembly.  This should ensure that "rounding errors" in      symbol addresses that are masked for disassembly favour the      the correct symbol. */
ifdef|#
directive|ifdef
name|GDB_TARGET_UNMASK_DISAS_PC
name|addr
operator|=
name|GDB_TARGET_UNMASK_DISAS_PC
argument_list|(
name|addr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* First try to find the address in the symbol table, then      in the minsyms.  Take the closest one.  */
comment|/* This is defective in the sense that it only finds text symbols.  So      really this is kind of pointless--we should make sure that the      minimal symbols have everything we need (by changing that we could      save some memory, but for many debug format--ELF/DWARF or      anything/stabs--it would be inconvenient to eliminate those minimal      symbols anyway).  */
name|msymbol
operator|=
name|lookup_minimal_symbol_by_pc_section
argument_list|(
name|addr
argument_list|,
name|section
argument_list|)
expr_stmt|;
name|symbol
operator|=
name|find_pc_sect_function
argument_list|(
name|addr
argument_list|,
name|section
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbol
condition|)
block|{
name|name_location
operator|=
name|BLOCK_START
argument_list|(
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_demangle
condition|)
name|name
operator|=
name|SYMBOL_SOURCE_NAME
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
else|else
name|name
operator|=
name|SYMBOL_LINKAGE_NAME
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|msymbol
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
operator|>
name|name_location
operator|||
name|symbol
operator|==
name|NULL
condition|)
block|{
comment|/* The msymbol is closer to the address than the symbol; 	     use the msymbol instead.  */
name|symbol
operator|=
literal|0
expr_stmt|;
name|symtab
operator|=
literal|0
expr_stmt|;
name|name_location
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_demangle
condition|)
name|name
operator|=
name|SYMBOL_SOURCE_NAME
argument_list|(
name|msymbol
argument_list|)
expr_stmt|;
else|else
name|name
operator|=
name|SYMBOL_LINKAGE_NAME
argument_list|(
name|msymbol
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|symbol
operator|==
name|NULL
operator|&&
name|msymbol
operator|==
name|NULL
condition|)
return|return;
comment|/* On some targets, mask out extra "flag" bits from PC for handsome      disassembly. */
ifdef|#
directive|ifdef
name|GDB_TARGET_MASK_DISAS_PC
name|name_location
operator|=
name|GDB_TARGET_MASK_DISAS_PC
argument_list|(
name|name_location
argument_list|)
expr_stmt|;
name|addr
operator|=
name|GDB_TARGET_MASK_DISAS_PC
argument_list|(
name|addr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If the nearest symbol is too far away, don't print anything symbolic.  */
comment|/* For when CORE_ADDR is larger than unsigned int, we do math in      CORE_ADDR.  But when we detect unsigned wraparound in the      CORE_ADDR math, we ignore this test and print the offset,      because addr+max_symbolic_offset has wrapped through the end      of the address space back to the beginning, giving bogus comparison.  */
if|if
condition|(
name|addr
operator|>
name|name_location
operator|+
name|max_symbolic_offset
operator|&&
name|name_location
operator|+
name|max_symbolic_offset
operator|>
name|name_location
condition|)
return|return;
name|fputs_filtered
argument_list|(
name|leadin
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|unmapped
condition|)
name|fputs_filtered
argument_list|(
literal|"<*"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
name|fputs_filtered
argument_list|(
literal|"<"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
name|name
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|!=
name|name_location
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"+%u"
argument_list|,
call|(
name|unsigned
name|int
call|)
argument_list|(
name|addr
operator|-
name|name_location
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Append source filename and line number if desired.  Give specific      line # of this addr, if we have it; else line # of the nearest symbol.  */
if|if
condition|(
name|print_symbol_filename
condition|)
block|{
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|sal
operator|=
name|find_pc_sect_line
argument_list|(
name|addr
argument_list|,
name|section
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sal
operator|.
name|symtab
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" at %s:%d"
argument_list|,
name|sal
operator|.
name|symtab
operator|->
name|filename
argument_list|,
name|sal
operator|.
name|line
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|symtab
operator|&&
name|symbol
operator|&&
name|symbol
operator|->
name|line
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" at %s:%d"
argument_list|,
name|symtab
operator|->
name|filename
argument_list|,
name|symbol
operator|->
name|line
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|symtab
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" in %s"
argument_list|,
name|symtab
operator|->
name|filename
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|unmapped
condition|)
name|fputs_filtered
argument_list|(
literal|"*>"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
name|fputs_filtered
argument_list|(
literal|">"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print address ADDR on STREAM.  USE_LOCAL means the same thing as for    print_longest.  */
end_comment

begin_function
name|void
name|print_address_numeric
parameter_list|(
name|addr
parameter_list|,
name|use_local
parameter_list|,
name|stream
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
name|int
name|use_local
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
block|{
comment|/* This assumes a CORE_ADDR can fit in a LONGEST.  Probably a safe      assumption.  */
name|print_longest
argument_list|(
name|stream
argument_list|,
literal|'x'
argument_list|,
name|use_local
argument_list|,
operator|(
name|ULONGEST
operator|)
name|addr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print address ADDR symbolically on STREAM.    First print it as a number.  Then perhaps print<SYMBOL + OFFSET> after the number.  */
end_comment

begin_function
name|void
name|print_address
parameter_list|(
name|addr
parameter_list|,
name|stream
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|print_address_numeric
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|print_address_symbolic
argument_list|(
name|addr
argument_list|,
name|stream
argument_list|,
name|asm_demangle
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print address ADDR symbolically on STREAM.  Parameter DEMANGLE    controls whether to print the symbolic name "raw" or demangled.    Global setting "addressprint" controls whether to print hex address    or not.  */
end_comment

begin_function
name|void
name|print_address_demangle
parameter_list|(
name|addr
parameter_list|,
name|stream
parameter_list|,
name|do_demangle
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|do_demangle
decl_stmt|;
block|{
if|if
condition|(
name|addr
operator|==
literal|0
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|addressprint
condition|)
block|{
name|print_address_numeric
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|print_address_symbolic
argument_list|(
name|addr
argument_list|,
name|stream
argument_list|,
name|do_demangle
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|print_address_symbolic
argument_list|(
name|addr
argument_list|,
name|stream
argument_list|,
name|do_demangle
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* These are the types that $__ will get after an examine command of one    of these sizes.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|examine_i_type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|examine_b_type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|examine_h_type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|examine_w_type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|examine_g_type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Examine data at address ADDR in format FMT.    Fetch it from memory and print on gdb_stdout.  */
end_comment

begin_function
specifier|static
name|void
name|do_examine
parameter_list|(
name|fmt
parameter_list|,
name|addr
parameter_list|,
name|sect
parameter_list|)
name|struct
name|format_data
name|fmt
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|asection
modifier|*
name|sect
decl_stmt|;
block|{
specifier|register
name|char
name|format
init|=
literal|0
decl_stmt|;
specifier|register
name|char
name|size
decl_stmt|;
specifier|register
name|int
name|count
init|=
literal|1
decl_stmt|;
name|struct
name|type
modifier|*
name|val_type
init|=
name|NULL
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|maxelts
decl_stmt|;
name|format
operator|=
name|fmt
operator|.
name|format
expr_stmt|;
name|size
operator|=
name|fmt
operator|.
name|size
expr_stmt|;
name|count
operator|=
name|fmt
operator|.
name|count
expr_stmt|;
name|next_address
operator|=
name|addr
expr_stmt|;
name|next_section
operator|=
name|sect
expr_stmt|;
comment|/* String or instruction format implies fetch single bytes      regardless of the specified size.  */
if|if
condition|(
name|format
operator|==
literal|'s'
operator|||
name|format
operator|==
literal|'i'
condition|)
name|size
operator|=
literal|'b'
expr_stmt|;
if|if
condition|(
name|format
operator|==
literal|'i'
condition|)
name|val_type
operator|=
name|examine_i_type
expr_stmt|;
elseif|else
if|if
condition|(
name|size
operator|==
literal|'b'
condition|)
name|val_type
operator|=
name|examine_b_type
expr_stmt|;
elseif|else
if|if
condition|(
name|size
operator|==
literal|'h'
condition|)
name|val_type
operator|=
name|examine_h_type
expr_stmt|;
elseif|else
if|if
condition|(
name|size
operator|==
literal|'w'
condition|)
name|val_type
operator|=
name|examine_w_type
expr_stmt|;
elseif|else
if|if
condition|(
name|size
operator|==
literal|'g'
condition|)
name|val_type
operator|=
name|examine_g_type
expr_stmt|;
name|maxelts
operator|=
literal|8
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|'w'
condition|)
name|maxelts
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|'g'
condition|)
name|maxelts
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|format
operator|==
literal|'s'
operator|||
name|format
operator|==
literal|'i'
condition|)
name|maxelts
operator|=
literal|1
expr_stmt|;
comment|/* Print as many objects as specified in COUNT, at most maxelts per line,      with the address of the next one at the start of each line.  */
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|QUIT
expr_stmt|;
name|print_address
argument_list|(
name|next_address
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|":"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|maxelts
init|;
name|i
operator|>
literal|0
operator|&&
name|count
operator|>
literal|0
condition|;
name|i
operator|--
operator|,
name|count
operator|--
control|)
block|{
name|printf_filtered
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
comment|/* Note that print_formatted sets next_address for the next 	     object.  */
name|last_examine_address
operator|=
name|next_address
expr_stmt|;
if|if
condition|(
name|last_examine_value
condition|)
name|value_free
argument_list|(
name|last_examine_value
argument_list|)
expr_stmt|;
comment|/* The value to be displayed is not fetched greedily.              Instead, to avoid the posibility of a fetched value not              being used, its retreval is delayed until the print code              uses it.  When examining an instruction stream, the              disassembler will perform its own memory fetch using just              the address stored in LAST_EXAMINE_VALUE.  FIXME: Should              the disassembler be modified so that LAST_EXAMINE_VALUE              is left with the byte sequence from the last complete              instruction fetched from memory? */
name|last_examine_value
operator|=
name|value_at_lazy
argument_list|(
name|val_type
argument_list|,
name|next_address
argument_list|,
name|sect
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_examine_value
condition|)
name|release_value
argument_list|(
name|last_examine_value
argument_list|)
expr_stmt|;
name|print_formatted
argument_list|(
name|last_examine_value
argument_list|,
name|format
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|validate_format
parameter_list|(
name|fmt
parameter_list|,
name|cmdname
parameter_list|)
name|struct
name|format_data
name|fmt
decl_stmt|;
name|char
modifier|*
name|cmdname
decl_stmt|;
block|{
if|if
condition|(
name|fmt
operator|.
name|size
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|"Size letters are meaningless in \"%s\" command."
argument_list|,
name|cmdname
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
operator|.
name|count
operator|!=
literal|1
condition|)
name|error
argument_list|(
literal|"Item count other than 1 is meaningless in \"%s\" command."
argument_list|,
name|cmdname
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
operator|.
name|format
operator|==
literal|'i'
operator|||
name|fmt
operator|.
name|format
operator|==
literal|'s'
condition|)
name|error
argument_list|(
literal|"Format letter \"%c\" is meaningless in \"%s\" command."
argument_list|,
name|fmt
operator|.
name|format
argument_list|,
name|cmdname
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  Evaluate string EXP as an expression in the current language and     print the resulting value.  EXP may contain a format specifier as the     first argument ("/x myvar" for example, to print myvar in hex).     */
end_comment

begin_function
specifier|static
name|void
name|print_command_1
parameter_list|(
name|exp
parameter_list|,
name|inspect
parameter_list|,
name|voidprint
parameter_list|)
name|char
modifier|*
name|exp
decl_stmt|;
name|int
name|inspect
decl_stmt|;
name|int
name|voidprint
decl_stmt|;
block|{
name|struct
name|expression
modifier|*
name|expr
decl_stmt|;
specifier|register
name|struct
name|cleanup
modifier|*
name|old_chain
init|=
literal|0
decl_stmt|;
specifier|register
name|char
name|format
init|=
literal|0
decl_stmt|;
specifier|register
name|value_ptr
name|val
decl_stmt|;
name|struct
name|format_data
name|fmt
decl_stmt|;
name|int
name|cleanup
init|=
literal|0
decl_stmt|;
comment|/* Pass inspect flag to the rest of the print routines in a global (sigh). */
name|inspect_it
operator|=
name|inspect
expr_stmt|;
if|if
condition|(
name|exp
operator|&&
operator|*
name|exp
operator|==
literal|'/'
condition|)
block|{
name|exp
operator|++
expr_stmt|;
name|fmt
operator|=
name|decode_format
argument_list|(
operator|&
name|exp
argument_list|,
name|last_format
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|validate_format
argument_list|(
name|fmt
argument_list|,
literal|"print"
argument_list|)
expr_stmt|;
name|last_format
operator|=
name|format
operator|=
name|fmt
operator|.
name|format
expr_stmt|;
block|}
else|else
block|{
name|fmt
operator|.
name|count
operator|=
literal|1
expr_stmt|;
name|fmt
operator|.
name|format
operator|=
literal|0
expr_stmt|;
name|fmt
operator|.
name|size
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|exp
operator|&&
operator|*
name|exp
condition|)
block|{
specifier|extern
name|int
name|objectprint
decl_stmt|;
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|expr
operator|=
name|parse_expression
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
operator|(
name|make_cleanup_func
operator|)
name|free_current_contents
argument_list|,
operator|&
name|expr
argument_list|)
expr_stmt|;
name|cleanup
operator|=
literal|1
expr_stmt|;
name|val
operator|=
name|evaluate_expression
argument_list|(
name|expr
argument_list|)
expr_stmt|;
comment|/* C++: figure out what type we actually want to print it as.  */
name|type
operator|=
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|objectprint
operator|&&
operator|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_PTR
operator|||
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_REF
operator|)
operator|&&
operator|(
name|TYPE_CODE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
operator|||
name|TYPE_CODE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_UNION
operator|)
condition|)
block|{
name|value_ptr
name|v
decl_stmt|;
name|v
operator|=
name|value_from_vtable_info
argument_list|(
name|val
argument_list|,
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|!=
literal|0
condition|)
block|{
name|val
operator|=
name|v
expr_stmt|;
name|type
operator|=
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
name|val
operator|=
name|access_value_history
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|voidprint
operator|||
operator|(
name|val
operator|&&
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
operator|&&
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|!=
name|TYPE_CODE_VOID
operator|)
condition|)
block|{
name|int
name|histindex
init|=
name|record_latest_value
argument_list|(
name|val
argument_list|)
decl_stmt|;
if|if
condition|(
name|histindex
operator|>=
literal|0
condition|)
name|annotate_value_history_begin
argument_list|(
name|histindex
argument_list|,
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|annotate_value_begin
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|inspect
condition|)
name|printf_unfiltered
argument_list|(
literal|"\031(gdb-makebuffer \"%s\"  %d '(\""
argument_list|,
name|exp
argument_list|,
name|histindex
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|histindex
operator|>=
literal|0
condition|)
name|printf_filtered
argument_list|(
literal|"$%d = "
argument_list|,
name|histindex
argument_list|)
expr_stmt|;
if|if
condition|(
name|histindex
operator|>=
literal|0
condition|)
name|annotate_value_history_value
argument_list|()
expr_stmt|;
name|print_formatted
argument_list|(
name|val
argument_list|,
name|format
argument_list|,
name|fmt
operator|.
name|size
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|histindex
operator|>=
literal|0
condition|)
name|annotate_value_history_end
argument_list|()
expr_stmt|;
else|else
name|annotate_value_end
argument_list|()
expr_stmt|;
if|if
condition|(
name|inspect
condition|)
name|printf_unfiltered
argument_list|(
literal|"\") )\030"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cleanup
condition|)
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
name|inspect_it
operator|=
literal|0
expr_stmt|;
comment|/* Reset print routines to normal */
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|print_command
parameter_list|(
name|exp
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|exp
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|print_command_1
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Same as print, except in epoch, it gets its own window */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|inspect_command
parameter_list|(
name|exp
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|exp
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
specifier|extern
name|int
name|epoch_interface
decl_stmt|;
name|print_command_1
argument_list|(
name|exp
argument_list|,
name|epoch_interface
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Same as print, except it doesn't print void results. */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|call_command
parameter_list|(
name|exp
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|exp
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|print_command_1
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|output_command
parameter_list|(
name|exp
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|exp
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|struct
name|expression
modifier|*
name|expr
decl_stmt|;
specifier|register
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
specifier|register
name|char
name|format
init|=
literal|0
decl_stmt|;
specifier|register
name|value_ptr
name|val
decl_stmt|;
name|struct
name|format_data
name|fmt
decl_stmt|;
if|if
condition|(
name|exp
operator|&&
operator|*
name|exp
operator|==
literal|'/'
condition|)
block|{
name|exp
operator|++
expr_stmt|;
name|fmt
operator|=
name|decode_format
argument_list|(
operator|&
name|exp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|validate_format
argument_list|(
name|fmt
argument_list|,
literal|"output"
argument_list|)
expr_stmt|;
name|format
operator|=
name|fmt
operator|.
name|format
expr_stmt|;
block|}
name|expr
operator|=
name|parse_expression
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
operator|(
name|make_cleanup_func
operator|)
name|free_current_contents
argument_list|,
operator|&
name|expr
argument_list|)
expr_stmt|;
name|val
operator|=
name|evaluate_expression
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|annotate_value_begin
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
name|print_formatted
argument_list|(
name|val
argument_list|,
name|format
argument_list|,
name|fmt
operator|.
name|size
argument_list|)
expr_stmt|;
name|annotate_value_end
argument_list|()
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|set_command
parameter_list|(
name|exp
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|exp
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|struct
name|expression
modifier|*
name|expr
init|=
name|parse_expression
argument_list|(
name|exp
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|cleanup
modifier|*
name|old_chain
init|=
name|make_cleanup
argument_list|(
operator|(
name|make_cleanup_func
operator|)
name|free_current_contents
argument_list|,
operator|&
name|expr
argument_list|)
decl_stmt|;
name|evaluate_expression
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|sym_info
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|obj_section
modifier|*
name|osect
decl_stmt|;
name|asection
modifier|*
name|sect
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|,
name|sect_addr
decl_stmt|;
name|int
name|matches
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|offset
decl_stmt|;
if|if
condition|(
operator|!
name|arg
condition|)
name|error_no_arg
argument_list|(
literal|"address"
argument_list|)
expr_stmt|;
name|addr
operator|=
name|parse_and_eval_address
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|ALL_OBJSECTIONS
argument_list|(
argument|objfile
argument_list|,
argument|osect
argument_list|)
block|{
name|sect
operator|=
name|osect
operator|->
name|the_bfd_section
expr_stmt|;
name|sect_addr
operator|=
name|overlay_mapped_address
argument_list|(
name|addr
argument_list|,
name|sect
argument_list|)
expr_stmt|;
if|if
condition|(
name|osect
operator|->
name|addr
operator|<=
name|sect_addr
operator|&&
name|sect_addr
operator|<
name|osect
operator|->
name|endaddr
operator|&&
operator|(
name|msymbol
operator|=
name|lookup_minimal_symbol_by_pc_section
argument_list|(
name|sect_addr
argument_list|,
name|sect
argument_list|)
operator|)
condition|)
block|{
name|matches
operator|=
literal|1
expr_stmt|;
name|offset
operator|=
name|sect_addr
operator|-
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
condition|)
name|printf_filtered
argument_list|(
literal|"%s + %u in "
argument_list|,
name|SYMBOL_SOURCE_NAME
argument_list|(
name|msymbol
argument_list|)
argument_list|,
name|offset
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|"%s in "
argument_list|,
name|SYMBOL_SOURCE_NAME
argument_list|(
name|msymbol
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pc_in_unmapped_range
argument_list|(
name|addr
argument_list|,
name|sect
argument_list|)
condition|)
name|printf_filtered
argument_list|(
literal|"load address range of "
argument_list|)
expr_stmt|;
if|if
condition|(
name|section_is_overlay
argument_list|(
name|sect
argument_list|)
condition|)
name|printf_filtered
argument_list|(
literal|"%s overlay "
argument_list|,
name|section_is_mapped
argument_list|(
name|sect
argument_list|)
condition|?
literal|"mapped"
else|:
literal|"unmapped"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"section %s"
argument_list|,
name|sect
operator|->
name|name
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|matches
operator|==
literal|0
condition|)
name|printf_filtered
argument_list|(
literal|"No symbol matches %s.\n"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|address_info
parameter_list|(
name|exp
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|exp
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
specifier|register
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
specifier|register
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
specifier|register
name|long
name|val
decl_stmt|;
specifier|register
name|long
name|basereg
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|CORE_ADDR
name|load_addr
decl_stmt|;
name|int
name|is_a_field_of_this
decl_stmt|;
comment|/* C++: lookup_symbol sets this to nonzero 				   if exp is a field of `this'. */
if|if
condition|(
name|exp
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Argument required."
argument_list|)
expr_stmt|;
name|sym
operator|=
name|lookup_symbol
argument_list|(
name|exp
argument_list|,
name|get_selected_block
argument_list|()
argument_list|,
name|VAR_NAMESPACE
argument_list|,
operator|&
name|is_a_field_of_this
argument_list|,
operator|(
expr|struct
name|symtab
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|is_a_field_of_this
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Symbol \""
argument_list|)
expr_stmt|;
name|fprintf_symbol_filtered
argument_list|(
name|gdb_stdout
argument_list|,
name|exp
argument_list|,
name|current_language
operator|->
name|la_language
argument_list|,
name|DMGL_ANSI
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\" is a field of the local class variable `this'\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|msymbol
operator|=
name|lookup_minimal_symbol
argument_list|(
name|exp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|msymbol
operator|!=
name|NULL
condition|)
block|{
name|load_addr
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Symbol \""
argument_list|)
expr_stmt|;
name|fprintf_symbol_filtered
argument_list|(
name|gdb_stdout
argument_list|,
name|exp
argument_list|,
name|current_language
operator|->
name|la_language
argument_list|,
name|DMGL_ANSI
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\" is at "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|load_addr
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" in a file compiled without debugging"
argument_list|)
expr_stmt|;
name|section
operator|=
name|SYMBOL_BFD_SECTION
argument_list|(
name|msymbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|section_is_overlay
argument_list|(
name|section
argument_list|)
condition|)
block|{
name|load_addr
operator|=
name|overlay_unmapped_address
argument_list|(
name|load_addr
argument_list|,
name|section
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|",\n -- loaded at "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|load_addr
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" in overlay section %s"
argument_list|,
name|section
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|".\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"No symbol \"%s\" in current context."
argument_list|,
name|exp
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf_filtered
argument_list|(
literal|"Symbol \""
argument_list|)
expr_stmt|;
name|fprintf_symbol_filtered
argument_list|(
name|gdb_stdout
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|current_language
operator|->
name|la_language
argument_list|,
name|DMGL_ANSI
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\" is "
argument_list|)
expr_stmt|;
name|val
operator|=
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|basereg
operator|=
name|SYMBOL_BASEREG
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|section
operator|=
name|SYMBOL_BFD_SECTION
argument_list|(
name|sym
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
condition|)
block|{
case|case
name|LOC_CONST
case|:
case|case
name|LOC_CONST_BYTES
case|:
name|printf_filtered
argument_list|(
literal|"constant"
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_LABEL
case|:
name|printf_filtered
argument_list|(
literal|"a label at address "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|load_addr
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym
argument_list|)
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|section_is_overlay
argument_list|(
name|section
argument_list|)
condition|)
block|{
name|load_addr
operator|=
name|overlay_unmapped_address
argument_list|(
name|load_addr
argument_list|,
name|section
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|",\n -- loaded at "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|load_addr
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" in overlay section %s"
argument_list|,
name|section
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LOC_REGISTER
case|:
name|printf_filtered
argument_list|(
literal|"a variable in register %s"
argument_list|,
name|REGISTER_NAME
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_STATIC
case|:
name|printf_filtered
argument_list|(
literal|"static storage at address "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|load_addr
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym
argument_list|)
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|section_is_overlay
argument_list|(
name|section
argument_list|)
condition|)
block|{
name|load_addr
operator|=
name|overlay_unmapped_address
argument_list|(
name|load_addr
argument_list|,
name|section
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|",\n -- loaded at "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|load_addr
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" in overlay section %s"
argument_list|,
name|section
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LOC_INDIRECT
case|:
name|printf_filtered
argument_list|(
literal|"external global (indirect addressing), at address *("
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|load_addr
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym
argument_list|)
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
if|if
condition|(
name|section_is_overlay
argument_list|(
name|section
argument_list|)
condition|)
block|{
name|load_addr
operator|=
name|overlay_unmapped_address
argument_list|(
name|load_addr
argument_list|,
name|section
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|",\n -- loaded at "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|load_addr
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" in overlay section %s"
argument_list|,
name|section
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LOC_REGPARM
case|:
name|printf_filtered
argument_list|(
literal|"an argument in register %s"
argument_list|,
name|REGISTER_NAME
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_REGPARM_ADDR
case|:
name|printf_filtered
argument_list|(
literal|"address of an argument in register %s"
argument_list|,
name|REGISTER_NAME
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_ARG
case|:
name|printf_filtered
argument_list|(
literal|"an argument at offset %ld"
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_LOCAL_ARG
case|:
name|printf_filtered
argument_list|(
literal|"an argument at frame offset %ld"
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_LOCAL
case|:
name|printf_filtered
argument_list|(
literal|"a local variable at frame offset %ld"
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_REF_ARG
case|:
name|printf_filtered
argument_list|(
literal|"a reference argument at offset %ld"
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_BASEREG
case|:
name|printf_filtered
argument_list|(
literal|"a variable at offset %ld from register %s"
argument_list|,
name|val
argument_list|,
name|REGISTER_NAME
argument_list|(
name|basereg
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_BASEREG_ARG
case|:
name|printf_filtered
argument_list|(
literal|"an argument at offset %ld from register %s"
argument_list|,
name|val
argument_list|,
name|REGISTER_NAME
argument_list|(
name|basereg
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_TYPEDEF
case|:
name|printf_filtered
argument_list|(
literal|"a typedef"
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_BLOCK
case|:
name|printf_filtered
argument_list|(
literal|"a function at address "
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GDB_TARGET_MASK_DISAS_PC
name|print_address_numeric
argument_list|(
name|load_addr
operator|=
name|GDB_TARGET_MASK_DISAS_PC
argument_list|(
name|BLOCK_START
argument_list|(
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|sym
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
else|#
directive|else
name|print_address_numeric
argument_list|(
name|load_addr
operator|=
name|BLOCK_START
argument_list|(
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|sym
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|section_is_overlay
argument_list|(
name|section
argument_list|)
condition|)
block|{
name|load_addr
operator|=
name|overlay_unmapped_address
argument_list|(
name|load_addr
argument_list|,
name|section
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|",\n -- loaded at "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|load_addr
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" in overlay section %s"
argument_list|,
name|section
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LOC_UNRESOLVED
case|:
block|{
name|struct
name|minimal_symbol
modifier|*
name|msym
decl_stmt|;
name|msym
operator|=
name|lookup_minimal_symbol
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|msym
operator|==
name|NULL
condition|)
name|printf_filtered
argument_list|(
literal|"unresolved"
argument_list|)
expr_stmt|;
else|else
block|{
name|section
operator|=
name|SYMBOL_BFD_SECTION
argument_list|(
name|msym
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"static storage at address "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|load_addr
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msym
argument_list|)
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|section_is_overlay
argument_list|(
name|section
argument_list|)
condition|)
block|{
name|load_addr
operator|=
name|overlay_unmapped_address
argument_list|(
name|load_addr
argument_list|,
name|section
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|",\n -- loaded at "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|load_addr
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" in overlay section %s"
argument_list|,
name|section
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|LOC_THREAD_LOCAL_STATIC
case|:
name|printf_filtered
argument_list|(
literal|"a thread-local variable at offset %ld from the thread base register %s"
argument_list|,
name|val
argument_list|,
name|REGISTER_NAME
argument_list|(
name|basereg
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_OPTIMIZED_OUT
case|:
name|printf_filtered
argument_list|(
literal|"optimized out"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf_filtered
argument_list|(
literal|"of unknown (botched) type"
argument_list|)
expr_stmt|;
break|break;
block|}
name|printf_filtered
argument_list|(
literal|".\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|x_command
parameter_list|(
name|exp
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|exp
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|struct
name|expression
modifier|*
name|expr
decl_stmt|;
name|struct
name|format_data
name|fmt
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|struct
name|value
modifier|*
name|val
decl_stmt|;
name|fmt
operator|.
name|format
operator|=
name|last_format
expr_stmt|;
name|fmt
operator|.
name|size
operator|=
name|last_size
expr_stmt|;
name|fmt
operator|.
name|count
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|exp
operator|&&
operator|*
name|exp
operator|==
literal|'/'
condition|)
block|{
name|exp
operator|++
expr_stmt|;
name|fmt
operator|=
name|decode_format
argument_list|(
operator|&
name|exp
argument_list|,
name|last_format
argument_list|,
name|last_size
argument_list|)
expr_stmt|;
block|}
comment|/* If we have an expression, evaluate it and use it as the address.  */
if|if
condition|(
name|exp
operator|!=
literal|0
operator|&&
operator|*
name|exp
operator|!=
literal|0
condition|)
block|{
name|expr
operator|=
name|parse_expression
argument_list|(
name|exp
argument_list|)
expr_stmt|;
comment|/* Cause expression not to be there any more 	 if this command is repeated with Newline. 	 But don't clobber a user-defined command's definition.  */
if|if
condition|(
name|from_tty
condition|)
operator|*
name|exp
operator|=
literal|0
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
operator|(
name|make_cleanup_func
operator|)
name|free_current_contents
argument_list|,
operator|&
name|expr
argument_list|)
expr_stmt|;
name|val
operator|=
name|evaluate_expression
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_REF
condition|)
name|val
operator|=
name|value_ind
argument_list|(
name|val
argument_list|)
expr_stmt|;
comment|/* In rvalue contexts, such as this, functions are coerced into 	 pointers to functions.  This makes "x/i main" work.  */
if|if
condition|(
comment|/* last_format == 'i'&& */
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_FUNC
operator|&&
name|VALUE_LVAL
argument_list|(
name|val
argument_list|)
operator|==
name|lval_memory
condition|)
name|next_address
operator|=
name|VALUE_ADDRESS
argument_list|(
name|val
argument_list|)
expr_stmt|;
else|else
name|next_address
operator|=
name|value_as_pointer
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|VALUE_BFD_SECTION
argument_list|(
name|val
argument_list|)
condition|)
name|next_section
operator|=
name|VALUE_BFD_SECTION
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
name|do_examine
argument_list|(
name|fmt
argument_list|,
name|next_address
argument_list|,
name|next_section
argument_list|)
expr_stmt|;
comment|/* If the examine succeeds, we remember its size and format for next time.  */
name|last_size
operator|=
name|fmt
operator|.
name|size
expr_stmt|;
name|last_format
operator|=
name|fmt
operator|.
name|format
expr_stmt|;
comment|/* Set a couple of internal variables if appropriate. */
if|if
condition|(
name|last_examine_value
condition|)
block|{
comment|/* Make last address examined available to the user as $_.  Use 	 the correct pointer type.  */
name|set_internalvar
argument_list|(
name|lookup_internalvar
argument_list|(
literal|"_"
argument_list|)
argument_list|,
name|value_from_longest
argument_list|(
name|lookup_pointer_type
argument_list|(
name|VALUE_TYPE
argument_list|(
name|last_examine_value
argument_list|)
argument_list|)
argument_list|,
operator|(
name|LONGEST
operator|)
name|last_examine_address
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make contents of last address examined available to the user as $__.*/
comment|/* If the last value has not been fetched from memory then don't          fetch it now - instead mark it by voiding the $__ variable. */
if|if
condition|(
name|VALUE_LAZY
argument_list|(
name|last_examine_value
argument_list|)
condition|)
name|set_internalvar
argument_list|(
name|lookup_internalvar
argument_list|(
literal|"__"
argument_list|)
argument_list|,
name|allocate_value
argument_list|(
name|builtin_type_void
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|set_internalvar
argument_list|(
name|lookup_internalvar
argument_list|(
literal|"__"
argument_list|)
argument_list|,
name|last_examine_value
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add an expression to the auto-display chain.    Specify the expression.  */
end_comment

begin_function
specifier|static
name|void
name|display_command
parameter_list|(
name|exp
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|exp
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|struct
name|format_data
name|fmt
decl_stmt|;
specifier|register
name|struct
name|expression
modifier|*
name|expr
decl_stmt|;
specifier|register
name|struct
name|display
modifier|*
name|new
decl_stmt|;
name|int
name|display_it
init|=
literal|1
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TUI
argument_list|)
if|if
condition|(
name|tui_version
operator|&&
operator|*
name|exp
operator|==
literal|'$'
condition|)
name|display_it
operator|=
operator|(
operator|(
name|TuiStatus
operator|)
name|tuiDo
argument_list|(
operator|(
name|TuiOpaqueFuncPtr
operator|)
name|tui_vSetLayoutTo
argument_list|,
name|exp
argument_list|)
operator|==
name|TUI_FAILURE
operator|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|display_it
condition|)
block|{
if|if
condition|(
name|exp
operator|==
literal|0
condition|)
block|{
name|do_displays
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|exp
operator|==
literal|'/'
condition|)
block|{
name|exp
operator|++
expr_stmt|;
name|fmt
operator|=
name|decode_format
argument_list|(
operator|&
name|exp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
operator|.
name|size
operator|&&
name|fmt
operator|.
name|format
operator|==
literal|0
condition|)
name|fmt
operator|.
name|format
operator|=
literal|'x'
expr_stmt|;
if|if
condition|(
name|fmt
operator|.
name|format
operator|==
literal|'i'
operator|||
name|fmt
operator|.
name|format
operator|==
literal|'s'
condition|)
name|fmt
operator|.
name|size
operator|=
literal|'b'
expr_stmt|;
block|}
else|else
block|{
name|fmt
operator|.
name|format
operator|=
literal|0
expr_stmt|;
name|fmt
operator|.
name|size
operator|=
literal|0
expr_stmt|;
name|fmt
operator|.
name|count
operator|=
literal|0
expr_stmt|;
block|}
name|innermost_block
operator|=
literal|0
expr_stmt|;
name|expr
operator|=
name|parse_expression
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|new
operator|=
operator|(
expr|struct
name|display
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|display
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|exp
operator|=
name|expr
expr_stmt|;
name|new
operator|->
name|block
operator|=
name|innermost_block
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|display_chain
expr_stmt|;
name|new
operator|->
name|number
operator|=
operator|++
name|display_number
expr_stmt|;
name|new
operator|->
name|format
operator|=
name|fmt
expr_stmt|;
name|new
operator|->
name|status
operator|=
name|enabled
expr_stmt|;
name|display_chain
operator|=
name|new
expr_stmt|;
if|if
condition|(
name|from_tty
operator|&&
name|target_has_execution
condition|)
name|do_one_display
argument_list|(
name|new
argument_list|)
expr_stmt|;
name|dont_repeat
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|free_display
parameter_list|(
name|d
parameter_list|)
name|struct
name|display
modifier|*
name|d
decl_stmt|;
block|{
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|d
operator|->
name|exp
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|d
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clear out the display_chain.    Done when new symtabs are loaded, since this invalidates    the types stored in many expressions.  */
end_comment

begin_function
name|void
name|clear_displays
parameter_list|()
block|{
specifier|register
name|struct
name|display
modifier|*
name|d
decl_stmt|;
while|while
condition|(
operator|(
name|d
operator|=
name|display_chain
operator|)
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|d
operator|->
name|exp
argument_list|)
expr_stmt|;
name|display_chain
operator|=
name|d
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|d
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Delete the auto-display number NUM.  */
end_comment

begin_function
specifier|static
name|void
name|delete_display
parameter_list|(
name|num
parameter_list|)
name|int
name|num
decl_stmt|;
block|{
specifier|register
name|struct
name|display
modifier|*
name|d1
decl_stmt|,
modifier|*
name|d
decl_stmt|;
if|if
condition|(
operator|!
name|display_chain
condition|)
name|error
argument_list|(
literal|"No display number %d."
argument_list|,
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
name|display_chain
operator|->
name|number
operator|==
name|num
condition|)
block|{
name|d1
operator|=
name|display_chain
expr_stmt|;
name|display_chain
operator|=
name|d1
operator|->
name|next
expr_stmt|;
name|free_display
argument_list|(
name|d1
argument_list|)
expr_stmt|;
block|}
else|else
for|for
control|(
name|d
operator|=
name|display_chain
init|;
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
block|{
if|if
condition|(
name|d
operator|->
name|next
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No display number %d."
argument_list|,
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|next
operator|->
name|number
operator|==
name|num
condition|)
block|{
name|d1
operator|=
name|d
operator|->
name|next
expr_stmt|;
name|d
operator|->
name|next
operator|=
name|d1
operator|->
name|next
expr_stmt|;
name|free_display
argument_list|(
name|d1
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Delete some values from the auto-display chain.    Specify the element numbers.  */
end_comment

begin_function
specifier|static
name|void
name|undisplay_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|args
decl_stmt|;
specifier|register
name|char
modifier|*
name|p1
decl_stmt|;
specifier|register
name|int
name|num
decl_stmt|;
if|if
condition|(
name|args
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|query
argument_list|(
literal|"Delete all auto-display expressions? "
argument_list|)
condition|)
name|clear_displays
argument_list|()
expr_stmt|;
name|dont_repeat
argument_list|()
expr_stmt|;
return|return;
block|}
while|while
condition|(
operator|*
name|p
condition|)
block|{
name|p1
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p1
operator|>=
literal|'0'
operator|&&
operator|*
name|p1
operator|<=
literal|'9'
condition|)
name|p1
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p1
operator|&&
operator|*
name|p1
operator|!=
literal|' '
operator|&&
operator|*
name|p1
operator|!=
literal|'\t'
condition|)
name|error
argument_list|(
literal|"Arguments must be display numbers."
argument_list|)
expr_stmt|;
name|num
operator|=
name|atoi
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|delete_display
argument_list|(
name|num
argument_list|)
expr_stmt|;
name|p
operator|=
name|p1
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
block|}
name|dont_repeat
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Display a single auto-display.      Do nothing if the display cannot be printed in the current context,    or if the display is disabled. */
end_comment

begin_function
specifier|static
name|void
name|do_one_display
parameter_list|(
name|d
parameter_list|)
name|struct
name|display
modifier|*
name|d
decl_stmt|;
block|{
name|int
name|within_current_scope
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|status
operator|==
name|disabled
condition|)
return|return;
if|if
condition|(
name|d
operator|->
name|block
condition|)
name|within_current_scope
operator|=
name|contained_in
argument_list|(
name|get_selected_block
argument_list|()
argument_list|,
name|d
operator|->
name|block
argument_list|)
expr_stmt|;
else|else
name|within_current_scope
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|within_current_scope
condition|)
return|return;
name|current_display_number
operator|=
name|d
operator|->
name|number
expr_stmt|;
name|annotate_display_begin
argument_list|()
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%d"
argument_list|,
name|d
operator|->
name|number
argument_list|)
expr_stmt|;
name|annotate_display_number_end
argument_list|()
expr_stmt|;
name|printf_filtered
argument_list|(
literal|": "
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|format
operator|.
name|size
condition|)
block|{
name|CORE_ADDR
name|addr
decl_stmt|;
name|value_ptr
name|val
decl_stmt|;
name|annotate_display_format
argument_list|()
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"x/"
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|format
operator|.
name|count
operator|!=
literal|1
condition|)
name|printf_filtered
argument_list|(
literal|"%d"
argument_list|,
name|d
operator|->
name|format
operator|.
name|count
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%c"
argument_list|,
name|d
operator|->
name|format
operator|.
name|format
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|format
operator|.
name|format
operator|!=
literal|'i'
operator|&&
name|d
operator|->
name|format
operator|.
name|format
operator|!=
literal|'s'
condition|)
name|printf_filtered
argument_list|(
literal|"%c"
argument_list|,
name|d
operator|->
name|format
operator|.
name|size
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|annotate_display_expression
argument_list|()
expr_stmt|;
name|print_expression
argument_list|(
name|d
operator|->
name|exp
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|annotate_display_expression_end
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|format
operator|.
name|count
operator|!=
literal|1
condition|)
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
name|val
operator|=
name|evaluate_expression
argument_list|(
name|d
operator|->
name|exp
argument_list|)
expr_stmt|;
name|addr
operator|=
name|value_as_pointer
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|format
operator|.
name|format
operator|==
literal|'i'
condition|)
name|addr
operator|=
name|ADDR_BITS_REMOVE
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|annotate_display_value
argument_list|()
expr_stmt|;
name|do_examine
argument_list|(
name|d
operator|->
name|format
argument_list|,
name|addr
argument_list|,
name|VALUE_BFD_SECTION
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|annotate_display_format
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|format
operator|.
name|format
condition|)
name|printf_filtered
argument_list|(
literal|"/%c "
argument_list|,
name|d
operator|->
name|format
operator|.
name|format
argument_list|)
expr_stmt|;
name|annotate_display_expression
argument_list|()
expr_stmt|;
name|print_expression
argument_list|(
name|d
operator|->
name|exp
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|annotate_display_expression_end
argument_list|()
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" = "
argument_list|)
expr_stmt|;
name|annotate_display_expression
argument_list|()
expr_stmt|;
name|print_formatted
argument_list|(
name|evaluate_expression
argument_list|(
name|d
operator|->
name|exp
argument_list|)
argument_list|,
name|d
operator|->
name|format
operator|.
name|format
argument_list|,
name|d
operator|->
name|format
operator|.
name|size
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|annotate_display_end
argument_list|()
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
name|current_display_number
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Display all of the values on the auto-display chain which can be    evaluated in the current scope.  */
end_comment

begin_function
name|void
name|do_displays
parameter_list|()
block|{
specifier|register
name|struct
name|display
modifier|*
name|d
decl_stmt|;
for|for
control|(
name|d
operator|=
name|display_chain
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
name|do_one_display
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Delete the auto-display which we were in the process of displaying.    This is done when there is an error or a signal.  */
end_comment

begin_function
name|void
name|disable_display
parameter_list|(
name|num
parameter_list|)
name|int
name|num
decl_stmt|;
block|{
specifier|register
name|struct
name|display
modifier|*
name|d
decl_stmt|;
for|for
control|(
name|d
operator|=
name|display_chain
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
if|if
condition|(
name|d
operator|->
name|number
operator|==
name|num
condition|)
block|{
name|d
operator|->
name|status
operator|=
name|disabled
expr_stmt|;
return|return;
block|}
name|printf_unfiltered
argument_list|(
literal|"No display number %d.\n"
argument_list|,
name|num
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|disable_current_display
parameter_list|()
block|{
if|if
condition|(
name|current_display_number
operator|>=
literal|0
condition|)
block|{
name|disable_display
argument_list|(
name|current_display_number
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Disabling display %d to avoid infinite recursion.\n"
argument_list|,
name|current_display_number
argument_list|)
expr_stmt|;
block|}
name|current_display_number
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|display_info
parameter_list|(
name|ignore
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|ignore
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
specifier|register
name|struct
name|display
modifier|*
name|d
decl_stmt|;
if|if
condition|(
operator|!
name|display_chain
condition|)
name|printf_unfiltered
argument_list|(
literal|"There are no auto-display expressions now.\n"
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|"Auto-display expressions now in effect:\n\ Num Enb Expression\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|d
operator|=
name|display_chain
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
block|{
name|printf_filtered
argument_list|(
literal|"%d:   %c  "
argument_list|,
name|d
operator|->
name|number
argument_list|,
literal|"ny"
index|[
operator|(
name|int
operator|)
name|d
operator|->
name|status
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|format
operator|.
name|size
condition|)
name|printf_filtered
argument_list|(
literal|"/%d%c%c "
argument_list|,
name|d
operator|->
name|format
operator|.
name|count
argument_list|,
name|d
operator|->
name|format
operator|.
name|size
argument_list|,
name|d
operator|->
name|format
operator|.
name|format
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|d
operator|->
name|format
operator|.
name|format
condition|)
name|printf_filtered
argument_list|(
literal|"/%c "
argument_list|,
name|d
operator|->
name|format
operator|.
name|format
argument_list|)
expr_stmt|;
name|print_expression
argument_list|(
name|d
operator|->
name|exp
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|block
operator|&&
operator|!
name|contained_in
argument_list|(
name|get_selected_block
argument_list|()
argument_list|,
name|d
operator|->
name|block
argument_list|)
condition|)
name|printf_filtered
argument_list|(
literal|" (cannot be evaluated in the current context)"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|enable_display
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|args
decl_stmt|;
specifier|register
name|char
modifier|*
name|p1
decl_stmt|;
specifier|register
name|int
name|num
decl_stmt|;
specifier|register
name|struct
name|display
modifier|*
name|d
decl_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|d
operator|=
name|display_chain
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
name|d
operator|->
name|status
operator|=
name|enabled
expr_stmt|;
block|}
else|else
while|while
condition|(
operator|*
name|p
condition|)
block|{
name|p1
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p1
operator|>=
literal|'0'
operator|&&
operator|*
name|p1
operator|<=
literal|'9'
condition|)
name|p1
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p1
operator|&&
operator|*
name|p1
operator|!=
literal|' '
operator|&&
operator|*
name|p1
operator|!=
literal|'\t'
condition|)
name|error
argument_list|(
literal|"Arguments must be display numbers."
argument_list|)
expr_stmt|;
name|num
operator|=
name|atoi
argument_list|(
name|p
argument_list|)
expr_stmt|;
for|for
control|(
name|d
operator|=
name|display_chain
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
if|if
condition|(
name|d
operator|->
name|number
operator|==
name|num
condition|)
block|{
name|d
operator|->
name|status
operator|=
name|enabled
expr_stmt|;
goto|goto
name|win
goto|;
block|}
name|printf_unfiltered
argument_list|(
literal|"No display number %d.\n"
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|win
label|:
name|p
operator|=
name|p1
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|disable_display_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|args
decl_stmt|;
specifier|register
name|char
modifier|*
name|p1
decl_stmt|;
specifier|register
name|struct
name|display
modifier|*
name|d
decl_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|d
operator|=
name|display_chain
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
name|d
operator|->
name|status
operator|=
name|disabled
expr_stmt|;
block|}
else|else
while|while
condition|(
operator|*
name|p
condition|)
block|{
name|p1
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p1
operator|>=
literal|'0'
operator|&&
operator|*
name|p1
operator|<=
literal|'9'
condition|)
name|p1
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p1
operator|&&
operator|*
name|p1
operator|!=
literal|' '
operator|&&
operator|*
name|p1
operator|!=
literal|'\t'
condition|)
name|error
argument_list|(
literal|"Arguments must be display numbers."
argument_list|)
expr_stmt|;
name|disable_display
argument_list|(
name|atoi
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|p1
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print the value in stack frame FRAME of a variable    specified by a struct symbol.  */
end_comment

begin_function
name|void
name|print_variable_value
parameter_list|(
name|var
parameter_list|,
name|frame
parameter_list|,
name|stream
parameter_list|)
name|struct
name|symbol
modifier|*
name|var
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|frame
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|value_ptr
name|val
init|=
name|read_var_value
argument_list|(
name|var
argument_list|,
name|frame
argument_list|)
decl_stmt|;
name|value_print
argument_list|(
name|val
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
name|Val_pretty_default
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print the arguments of a stack frame, given the function FUNC    running in that frame (as a symbol), the info on the frame,    and the number of args according to the stack frame (or -1 if unknown).  */
end_comment

begin_comment
comment|/* References here and elsewhere to "number of args according to the    stack frame" appear in all cases to refer to "number of ints of args    according to the stack frame".  At least for VAX, i386, isi.  */
end_comment

begin_function
name|void
name|print_frame_args
parameter_list|(
name|func
parameter_list|,
name|fi
parameter_list|,
name|num
parameter_list|,
name|stream
parameter_list|)
name|struct
name|symbol
modifier|*
name|func
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
name|int
name|num
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|struct
name|block
modifier|*
name|b
init|=
name|NULL
decl_stmt|;
name|int
name|nsyms
init|=
literal|0
decl_stmt|;
name|int
name|first
init|=
literal|1
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
specifier|register
name|value_ptr
name|val
decl_stmt|;
comment|/* Offset of next stack argument beyond the one we have seen that is      at the highest offset.      -1 if we haven't come to a stack argument yet.  */
name|long
name|highest_offset
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|arg_size
decl_stmt|;
comment|/* Number of ints of arguments that we have printed so far.  */
name|int
name|args_printed
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|func
condition|)
block|{
name|b
operator|=
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|func
argument_list|)
expr_stmt|;
name|nsyms
operator|=
name|BLOCK_NSYMS
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsyms
condition|;
name|i
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
name|sym
operator|=
name|BLOCK_SYM
argument_list|(
name|b
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Keep track of the highest stack argument offset seen, and 	 skip over any kinds of symbols we don't care about.  */
switch|switch
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
condition|)
block|{
case|case
name|LOC_ARG
case|:
case|case
name|LOC_REF_ARG
case|:
block|{
name|long
name|current_offset
init|=
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
decl_stmt|;
name|arg_size
operator|=
name|TYPE_LENGTH
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Compute address of next argument by adding the size of 	     this argument and rounding to an int boundary.  */
name|current_offset
operator|=
operator|(
operator|(
name|current_offset
operator|+
name|arg_size
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
comment|/* If this is the highest offset seen yet, set highest_offset.  */
if|if
condition|(
name|highest_offset
operator|==
operator|-
literal|1
operator|||
operator|(
name|current_offset
operator|>
name|highest_offset
operator|)
condition|)
name|highest_offset
operator|=
name|current_offset
expr_stmt|;
comment|/* Add the number of ints we're about to print to args_printed.  */
name|args_printed
operator|+=
operator|(
name|arg_size
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
block|}
comment|/* We care about types of symbols, but don't need to keep track of 	 stack offsets in them.  */
case|case
name|LOC_REGPARM
case|:
case|case
name|LOC_REGPARM_ADDR
case|:
case|case
name|LOC_LOCAL_ARG
case|:
case|case
name|LOC_BASEREG_ARG
case|:
break|break;
comment|/* Other types of symbols we just skip over.  */
default|default:
continue|continue;
block|}
comment|/* We have to look up the symbol because arguments can have 	 two entries (one a parameter, one a local) and the one we 	 want is the local, which lookup_symbol will find for us. 	 This includes gcc1 (not gcc2) on the sparc when passing a 	 small structure and gcc2 when the argument type is float 	 and it is passed as a double and converted to float by 	 the prologue (in the latter case the type of the LOC_ARG 	 symbol is double and the type of the LOC_LOCAL symbol is 	 float).  */
comment|/* But if the parameter name is null, don't try it. 	 Null parameter names occur on the RS/6000, for traceback tables. 	 FIXME, should we even print them?  */
if|if
condition|(
operator|*
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
condition|)
block|{
name|struct
name|symbol
modifier|*
name|nsym
decl_stmt|;
name|nsym
operator|=
name|lookup_symbol
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|b
argument_list|,
name|VAR_NAMESPACE
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
operator|(
expr|struct
name|symtab
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|SYMBOL_CLASS
argument_list|(
name|nsym
argument_list|)
operator|==
name|LOC_REGISTER
condition|)
block|{
comment|/* There is a LOC_ARG/LOC_REGISTER pair.  This means that 		 it was passed on the stack and loaded into a register, 		 or passed in a register and stored in a stack slot. 		 GDB 3.x used the LOC_ARG; GDB 4.0-4.11 used the LOC_REGISTER.  		 Reasons for using the LOC_ARG: 		 (1) because find_saved_registers may be slow for remote 		 debugging, 		 (2) because registers are often re-used and stack slots 		 rarely (never?) are.  Therefore using the stack slot is 		 much less likely to print garbage.  		 Reasons why we might want to use the LOC_REGISTER: 		 (1) So that the backtrace prints the same value as 		 "print foo".  I see no compelling reason why this needs 		 to be the case; having the backtrace print the value which 		 was passed in, and "print foo" print the value as modified 		 within the called function, makes perfect sense to me.  		 Additional note:  It might be nice if "info args" displayed 		 both values. 		 One more note:  There is a case with sparc structure passing 		 where we need to use the LOC_REGISTER, but this is dealt with 		 by creating a single LOC_REGPARM in symbol reading.  */
comment|/* Leave sym (the LOC_ARG) alone.  */
empty_stmt|;
block|}
else|else
name|sym
operator|=
name|nsym
expr_stmt|;
block|}
comment|/* Print the current arg.  */
if|if
condition|(
operator|!
name|first
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|"    "
argument_list|)
expr_stmt|;
name|annotate_arg_begin
argument_list|()
expr_stmt|;
name|fprintf_symbol_filtered
argument_list|(
name|stream
argument_list|,
name|SYMBOL_SOURCE_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|SYMBOL_LANGUAGE
argument_list|(
name|sym
argument_list|)
argument_list|,
name|DMGL_PARAMS
operator||
name|DMGL_ANSI
argument_list|)
expr_stmt|;
name|annotate_arg_name_end
argument_list|()
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"="
argument_list|,
name|stream
argument_list|)
expr_stmt|;
comment|/* Avoid value_print because it will deref ref parameters.  We just 	 want to print their addresses.  Print ??? for args whose address 	 we do not know.  We pass 2 as "recurse" to val_print because our 	 standard indentation here is 4 spaces, and val_print indents 	 2 for each recurse.  */
name|val
operator|=
name|read_var_value
argument_list|(
name|sym
argument_list|,
name|fi
argument_list|)
expr_stmt|;
name|annotate_arg_value
argument_list|(
name|val
operator|==
name|NULL
condition|?
name|NULL
else|:
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|)
block|{
ifdef|#
directive|ifdef
name|GDB_TARGET_IS_D10V
if|if
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_REGPARM
operator|&&
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_PTR
condition|)
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|=
literal|2
expr_stmt|;
endif|#
directive|endif
name|val_print
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|val
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VALUE_ADDRESS
argument_list|(
name|val
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
name|Val_no_prettyprint
argument_list|)
expr_stmt|;
block|}
else|else
name|fputs_filtered
argument_list|(
literal|"???"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|annotate_arg_end
argument_list|()
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Don't print nameless args in situations where we don't know      enough about the stack to find them.  */
if|if
condition|(
name|num
operator|!=
operator|-
literal|1
condition|)
block|{
name|long
name|start
decl_stmt|;
if|if
condition|(
name|highest_offset
operator|==
operator|-
literal|1
condition|)
name|start
operator|=
name|FRAME_ARGS_SKIP
expr_stmt|;
else|else
name|start
operator|=
name|highest_offset
expr_stmt|;
name|print_frame_nameless_args
argument_list|(
name|fi
argument_list|,
name|start
argument_list|,
name|num
operator|-
name|args_printed
argument_list|,
name|first
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print nameless args on STREAM.    FI is the frameinfo for this frame, START is the offset    of the first nameless arg, and NUM is the number of nameless args to    print.  FIRST is nonzero if this is the first argument (not just    the first nameless arg).  */
end_comment

begin_function
specifier|static
name|void
name|print_frame_nameless_args
parameter_list|(
name|fi
parameter_list|,
name|start
parameter_list|,
name|num
parameter_list|,
name|first
parameter_list|,
name|stream
parameter_list|)
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
name|long
name|start
decl_stmt|;
name|int
name|num
decl_stmt|;
name|int
name|first
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|CORE_ADDR
name|argsaddr
decl_stmt|;
name|long
name|arg_value
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
ifdef|#
directive|ifdef
name|NAMELESS_ARG_VALUE
name|NAMELESS_ARG_VALUE
argument_list|(
name|fi
argument_list|,
name|start
argument_list|,
operator|&
name|arg_value
argument_list|)
expr_stmt|;
else|#
directive|else
name|argsaddr
operator|=
name|FRAME_ARGS_ADDRESS
argument_list|(
name|fi
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|argsaddr
condition|)
return|return;
name|arg_value
operator|=
name|read_memory_integer
argument_list|(
name|argsaddr
operator|+
name|start
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|first
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PRINT_NAMELESS_INTEGER
name|PRINT_NAMELESS_INTEGER
argument_list|(
name|stream
argument_list|,
name|arg_value
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|PRINT_TYPELESS_INTEGER
name|PRINT_TYPELESS_INTEGER
argument_list|(
name|stream
argument_list|,
name|builtin_type_int
argument_list|,
operator|(
name|LONGEST
operator|)
name|arg_value
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%ld"
argument_list|,
name|arg_value
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PRINT_TYPELESS_INTEGER */
endif|#
directive|endif
comment|/* PRINT_NAMELESS_INTEGER */
name|first
operator|=
literal|0
expr_stmt|;
name|start
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|printf_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|f
init|=
name|NULL
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
init|=
name|arg
decl_stmt|;
name|char
modifier|*
name|string
init|=
name|NULL
decl_stmt|;
name|value_ptr
modifier|*
name|val_args
decl_stmt|;
name|char
modifier|*
name|substrings
decl_stmt|;
name|char
modifier|*
name|current_substring
decl_stmt|;
name|int
name|nargs
init|=
literal|0
decl_stmt|;
name|int
name|allocated_args
init|=
literal|20
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_cleanups
decl_stmt|;
name|val_args
operator|=
operator|(
name|value_ptr
operator|*
operator|)
name|xmalloc
argument_list|(
name|allocated_args
operator|*
sizeof|sizeof
argument_list|(
name|value_ptr
argument_list|)
argument_list|)
expr_stmt|;
name|old_cleanups
operator|=
name|make_cleanup
argument_list|(
operator|(
name|make_cleanup_func
operator|)
name|free_current_contents
argument_list|,
operator|&
name|val_args
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
literal|0
condition|)
name|error_no_arg
argument_list|(
literal|"format-control string and values to print"
argument_list|)
expr_stmt|;
comment|/* Skip white space before format string */
while|while
condition|(
operator|*
name|s
operator|==
literal|' '
operator|||
operator|*
name|s
operator|==
literal|'\t'
condition|)
name|s
operator|++
expr_stmt|;
comment|/* A format string should follow, enveloped in double quotes */
if|if
condition|(
operator|*
name|s
operator|++
operator|!=
literal|'"'
condition|)
name|error
argument_list|(
literal|"Bad format string, missing '\"'."
argument_list|)
expr_stmt|;
comment|/* Parse the format-control string and copy it into the string STRING,      processing some kinds of escape sequence.  */
name|f
operator|=
name|string
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|!=
literal|'"'
condition|)
block|{
name|int
name|c
init|=
operator|*
name|s
operator|++
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\0'
case|:
name|error
argument_list|(
literal|"Bad format string, non-terminated '\"'."
argument_list|)
expr_stmt|;
case|case
literal|'\\'
case|:
switch|switch
condition|(
name|c
operator|=
operator|*
name|s
operator|++
condition|)
block|{
case|case
literal|'\\'
case|:
operator|*
name|f
operator|++
operator|=
literal|'\\'
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
ifdef|#
directive|ifdef
name|__STDC__
operator|*
name|f
operator|++
operator|=
literal|'\a'
expr_stmt|;
else|#
directive|else
operator|*
name|f
operator|++
operator|=
literal|'\007'
expr_stmt|;
comment|/* Bell */
endif|#
directive|endif
break|break;
case|case
literal|'b'
case|:
operator|*
name|f
operator|++
operator|=
literal|'\b'
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
operator|*
name|f
operator|++
operator|=
literal|'\f'
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
operator|*
name|f
operator|++
operator|=
literal|'\n'
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
operator|*
name|f
operator|++
operator|=
literal|'\r'
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
operator|*
name|f
operator|++
operator|=
literal|'\t'
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
operator|*
name|f
operator|++
operator|=
literal|'\v'
expr_stmt|;
break|break;
case|case
literal|'"'
case|:
operator|*
name|f
operator|++
operator|=
literal|'"'
expr_stmt|;
break|break;
default|default:
comment|/* ??? TODO: handle other escape sequences */
name|error
argument_list|(
literal|"Unrecognized escape character \\%c in format string."
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
operator|*
name|f
operator|++
operator|=
name|c
expr_stmt|;
block|}
block|}
comment|/* Skip over " and following space and comma.  */
name|s
operator|++
expr_stmt|;
operator|*
name|f
operator|++
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|==
literal|' '
operator|||
operator|*
name|s
operator|==
literal|'\t'
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|','
operator|&&
operator|*
name|s
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|"Invalid argument syntax"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|','
condition|)
name|s
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|==
literal|' '
operator|||
operator|*
name|s
operator|==
literal|'\t'
condition|)
name|s
operator|++
expr_stmt|;
comment|/* Need extra space for the '\0's.  Doubling the size is sufficient.  */
name|substrings
operator|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|string
argument_list|)
operator|*
literal|2
argument_list|)
expr_stmt|;
name|current_substring
operator|=
name|substrings
expr_stmt|;
block|{
comment|/* Now scan the string for %-specs and see what kinds of args they want.        argclass[I] classifies the %-specs so we can give printf_filtered        something of the right size.  */
enum|enum
name|argclass
block|{
name|no_arg
block|,
name|int_arg
block|,
name|string_arg
block|,
name|double_arg
block|,
name|long_long_arg
block|}
enum|;
name|enum
name|argclass
modifier|*
name|argclass
decl_stmt|;
name|enum
name|argclass
name|this_argclass
decl_stmt|;
name|char
modifier|*
name|last_arg
decl_stmt|;
name|int
name|nargs_wanted
decl_stmt|;
name|int
name|lcount
decl_stmt|;
name|int
name|i
decl_stmt|;
name|argclass
operator|=
operator|(
expr|enum
name|argclass
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|*
sizeof|sizeof
expr|*
name|argclass
argument_list|)
expr_stmt|;
name|nargs_wanted
operator|=
literal|0
expr_stmt|;
name|f
operator|=
name|string
expr_stmt|;
name|last_arg
operator|=
name|string
expr_stmt|;
while|while
condition|(
operator|*
name|f
condition|)
if|if
condition|(
operator|*
name|f
operator|++
operator|==
literal|'%'
condition|)
block|{
name|lcount
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|strchr
argument_list|(
literal|"0123456789.hlL-+ #"
argument_list|,
operator|*
name|f
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|f
operator|==
literal|'l'
operator|||
operator|*
name|f
operator|==
literal|'L'
condition|)
name|lcount
operator|++
expr_stmt|;
name|f
operator|++
expr_stmt|;
block|}
switch|switch
condition|(
operator|*
name|f
condition|)
block|{
case|case
literal|'s'
case|:
name|this_argclass
operator|=
name|string_arg
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
case|case
literal|'f'
case|:
case|case
literal|'g'
case|:
name|this_argclass
operator|=
name|double_arg
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
name|error
argument_list|(
literal|"`*' not supported for precision or width in printf"
argument_list|)
expr_stmt|;
case|case
literal|'n'
case|:
name|error
argument_list|(
literal|"Format specifier `n' not supported in printf"
argument_list|)
expr_stmt|;
case|case
literal|'%'
case|:
name|this_argclass
operator|=
name|no_arg
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|lcount
operator|>
literal|1
condition|)
name|this_argclass
operator|=
name|long_long_arg
expr_stmt|;
else|else
name|this_argclass
operator|=
name|int_arg
expr_stmt|;
break|break;
block|}
name|f
operator|++
expr_stmt|;
if|if
condition|(
name|this_argclass
operator|!=
name|no_arg
condition|)
block|{
name|strncpy
argument_list|(
name|current_substring
argument_list|,
name|last_arg
argument_list|,
name|f
operator|-
name|last_arg
argument_list|)
expr_stmt|;
name|current_substring
operator|+=
name|f
operator|-
name|last_arg
expr_stmt|;
operator|*
name|current_substring
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|last_arg
operator|=
name|f
expr_stmt|;
name|argclass
index|[
name|nargs_wanted
operator|++
index|]
operator|=
name|this_argclass
expr_stmt|;
block|}
block|}
comment|/* Now, parse all arguments and evaluate them.        Store the VALUEs in VAL_ARGS.  */
while|while
condition|(
operator|*
name|s
operator|!=
literal|'\0'
condition|)
block|{
name|char
modifier|*
name|s1
decl_stmt|;
if|if
condition|(
name|nargs
operator|==
name|allocated_args
condition|)
name|val_args
operator|=
operator|(
name|value_ptr
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|val_args
argument_list|,
operator|(
name|allocated_args
operator|*=
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|value_ptr
argument_list|)
argument_list|)
expr_stmt|;
name|s1
operator|=
name|s
expr_stmt|;
name|val_args
index|[
name|nargs
index|]
operator|=
name|parse_to_comma_and_eval
argument_list|(
operator|&
name|s1
argument_list|)
expr_stmt|;
comment|/* If format string wants a float, unchecked-convert the value to 	   floating point of the same size */
if|if
condition|(
name|argclass
index|[
name|nargs
index|]
operator|==
name|double_arg
condition|)
block|{
name|struct
name|type
modifier|*
name|type
init|=
name|VALUE_TYPE
argument_list|(
name|val_args
index|[
name|nargs
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|float
argument_list|)
condition|)
name|VALUE_TYPE
argument_list|(
name|val_args
index|[
name|nargs
index|]
argument_list|)
operator|=
name|builtin_type_float
expr_stmt|;
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|double
argument_list|)
condition|)
name|VALUE_TYPE
argument_list|(
name|val_args
index|[
name|nargs
index|]
argument_list|)
operator|=
name|builtin_type_double
expr_stmt|;
block|}
name|nargs
operator|++
expr_stmt|;
name|s
operator|=
name|s1
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|','
condition|)
name|s
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|nargs
operator|!=
name|nargs_wanted
condition|)
name|error
argument_list|(
literal|"Wrong number of arguments for specified format-string"
argument_list|)
expr_stmt|;
comment|/* Now actually print them.  */
name|current_substring
operator|=
name|substrings
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nargs
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|argclass
index|[
name|i
index|]
condition|)
block|{
case|case
name|string_arg
case|:
block|{
name|char
modifier|*
name|str
decl_stmt|;
name|CORE_ADDR
name|tem
decl_stmt|;
name|int
name|j
decl_stmt|;
name|tem
operator|=
name|value_as_pointer
argument_list|(
name|val_args
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* This is a %s argument.  Find the length of the string.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
condition|;
name|j
operator|++
control|)
block|{
name|char
name|c
decl_stmt|;
name|QUIT
expr_stmt|;
name|read_memory_section
argument_list|(
name|tem
operator|+
name|j
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|,
name|VALUE_BFD_SECTION
argument_list|(
name|val_args
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
break|break;
block|}
comment|/* Copy the string contents into a string inside GDB.  */
name|str
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|j
operator|+
literal|1
argument_list|)
expr_stmt|;
name|read_memory_section
argument_list|(
name|tem
argument_list|,
name|str
argument_list|,
name|j
argument_list|,
name|VALUE_BFD_SECTION
argument_list|(
name|val_args
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|str
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
name|printf_filtered
argument_list|(
name|current_substring
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|double_arg
case|:
block|{
name|double
name|val
init|=
name|value_as_double
argument_list|(
name|val_args
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|printf_filtered
argument_list|(
name|current_substring
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|long_long_arg
case|:
if|#
directive|if
name|defined
argument_list|(
name|CC_HAS_LONG_LONG
argument_list|)
operator|&&
name|defined
argument_list|(
name|PRINTF_HAS_LONG_LONG
argument_list|)
block|{
name|long
name|long
name|val
init|=
name|value_as_long
argument_list|(
name|val_args
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|printf_filtered
argument_list|(
name|current_substring
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
block|}
else|#
directive|else
name|error
argument_list|(
literal|"long long not supported in printf"
argument_list|)
expr_stmt|;
endif|#
directive|endif
case|case
name|int_arg
case|:
block|{
comment|/* FIXME: there should be separate int_arg and long_arg.  */
name|long
name|val
init|=
name|value_as_long
argument_list|(
name|val_args
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|printf_filtered
argument_list|(
name|current_substring
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
comment|/* purecov: deadcode */
name|error
argument_list|(
literal|"internal error in printf_command"
argument_list|)
expr_stmt|;
comment|/* purecov: deadcode */
block|}
comment|/* Skip to the next substring.  */
name|current_substring
operator|+=
name|strlen
argument_list|(
name|current_substring
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
comment|/* Print the portion of the format string after the last argument.  */
name|printf_filtered
argument_list|(
name|last_arg
argument_list|)
expr_stmt|;
block|}
name|do_cleanups
argument_list|(
name|old_cleanups
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Dump a specified section of assembly code.  With no command line    arguments, this command will dump the assembly code for the    function surrounding the pc value in the selected frame.  With one    argument, it will dump the assembly code surrounding that pc value.    Two arguments are interpeted as bounds within which to dump    assembly.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|disassemble_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|CORE_ADDR
name|low
decl_stmt|,
name|high
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|CORE_ADDR
name|pc
decl_stmt|,
name|pc_masked
decl_stmt|;
name|char
modifier|*
name|space_index
decl_stmt|;
if|#
directive|if
literal|0
block|asection *section;
endif|#
directive|endif
name|name
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|arg
condition|)
block|{
if|if
condition|(
operator|!
name|selected_frame
condition|)
name|error
argument_list|(
literal|"No frame selected.\n"
argument_list|)
expr_stmt|;
name|pc
operator|=
name|get_frame_pc
argument_list|(
name|selected_frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|find_pc_partial_function
argument_list|(
name|pc
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|low
argument_list|,
operator|&
name|high
argument_list|)
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No function contains program counter for selected frame.\n"
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TUI
argument_list|)
elseif|else
if|if
condition|(
name|tui_version
condition|)
name|low
operator|=
operator|(
name|CORE_ADDR
operator|)
name|tuiDo
argument_list|(
operator|(
name|TuiOpaqueFuncPtr
operator|)
name|tui_vGetLowDisassemblyAddress
argument_list|,
operator|(
name|Opaque
operator|)
name|low
argument_list|,
operator|(
name|Opaque
operator|)
name|pc
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|low
operator|+=
name|FUNCTION_START_OFFSET
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|space_index
operator|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|arg
argument_list|,
literal|' '
argument_list|)
operator|)
condition|)
block|{
comment|/* One argument.  */
name|pc
operator|=
name|parse_and_eval_address
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|find_pc_partial_function
argument_list|(
name|pc
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|low
argument_list|,
operator|&
name|high
argument_list|)
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No function contains specified address.\n"
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TUI
argument_list|)
elseif|else
if|if
condition|(
name|tui_version
condition|)
name|low
operator|=
operator|(
name|CORE_ADDR
operator|)
name|tuiDo
argument_list|(
operator|(
name|TuiOpaqueFuncPtr
operator|)
name|tui_vGetLowDisassemblyAddress
argument_list|,
operator|(
name|Opaque
operator|)
name|low
argument_list|,
operator|(
name|Opaque
operator|)
name|pc
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
literal|0
block|if (overlay_debugging) 	{ 	  section = find_pc_overlay (pc); 	  if (pc_in_unmapped_range (pc, section)) 	    {
comment|/* find_pc_partial_function will have returned low and high 		 relative to the symbolic (mapped) address range.  Need to 		 translate them back to the unmapped range where PC is.  */
block|low  = overlay_unmapped_address (low, section); 	      high = overlay_unmapped_address (high, section); 	    } 	}
endif|#
directive|endif
name|low
operator|+=
name|FUNCTION_START_OFFSET
expr_stmt|;
block|}
else|else
block|{
comment|/* Two arguments.  */
operator|*
name|space_index
operator|=
literal|'\0'
expr_stmt|;
name|low
operator|=
name|parse_and_eval_address
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|high
operator|=
name|parse_and_eval_address
argument_list|(
name|space_index
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|TUI
argument_list|)
if|if
condition|(
operator|!
name|tui_version
operator|||
name|m_winPtrIsNull
argument_list|(
name|disassemWin
argument_list|)
operator|||
operator|!
name|disassemWin
operator|->
name|generic
operator|.
name|isVisible
condition|)
endif|#
directive|endif
block|{
name|printf_filtered
argument_list|(
literal|"Dump of assembler code "
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"for function %s:\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf_filtered
argument_list|(
literal|"from "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|low
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" to "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|high
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|":\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Dump the specified range.  */
name|pc
operator|=
name|low
expr_stmt|;
ifdef|#
directive|ifdef
name|GDB_TARGET_MASK_DISAS_PC
name|pc_masked
operator|=
name|GDB_TARGET_MASK_DISAS_PC
argument_list|(
name|pc
argument_list|)
expr_stmt|;
else|#
directive|else
name|pc_masked
operator|=
name|pc
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|pc_masked
operator|<
name|high
condition|)
block|{
name|QUIT
expr_stmt|;
name|print_address
argument_list|(
name|pc_masked
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|":\t"
argument_list|)
expr_stmt|;
comment|/* We often wrap here if there are long symbolic names.  */
name|wrap_here
argument_list|(
literal|"    "
argument_list|)
expr_stmt|;
name|pc
operator|+=
name|print_insn
argument_list|(
name|pc
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GDB_TARGET_MASK_DISAS_PC
name|pc_masked
operator|=
name|GDB_TARGET_MASK_DISAS_PC
argument_list|(
name|pc
argument_list|)
expr_stmt|;
else|#
directive|else
name|pc_masked
operator|=
name|pc
expr_stmt|;
endif|#
directive|endif
block|}
name|printf_filtered
argument_list|(
literal|"End of assembler dump.\n"
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|TUI
argument_list|)
else|else
block|{
name|tuiDo
argument_list|(
operator|(
name|TuiOpaqueFuncPtr
operator|)
name|tui_vAddWinToLayout
argument_list|,
name|DISASSEM_WIN
argument_list|)
expr_stmt|;
name|tuiDo
argument_list|(
operator|(
name|TuiOpaqueFuncPtr
operator|)
name|tui_vUpdateSourceWindowsWithAddr
argument_list|,
name|low
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Print the instruction at address MEMADDR in debugged memory,    on STREAM.  Returns length of the instruction, in bytes.  */
end_comment

begin_function
specifier|static
name|int
name|print_insn
parameter_list|(
name|memaddr
parameter_list|,
name|stream
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
block|{
if|if
condition|(
name|TARGET_BYTE_ORDER
operator|==
name|BIG_ENDIAN
condition|)
name|TARGET_PRINT_INSN_INFO
operator|->
name|endian
operator|=
name|BFD_ENDIAN_BIG
expr_stmt|;
else|else
name|TARGET_PRINT_INSN_INFO
operator|->
name|endian
operator|=
name|BFD_ENDIAN_LITTLE
expr_stmt|;
if|if
condition|(
name|TARGET_ARCHITECTURE
operator|!=
name|NULL
condition|)
name|TARGET_PRINT_INSN_INFO
operator|->
name|mach
operator|=
name|TARGET_ARCHITECTURE
operator|->
name|mach
expr_stmt|;
comment|/* else: should set .mach=0 but some disassemblers don't grok this */
return|return
name|TARGET_PRINT_INSN
argument_list|(
name|memaddr
argument_list|,
name|TARGET_PRINT_INSN_INFO
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|_initialize_printcmd
parameter_list|()
block|{
name|current_display_number
operator|=
operator|-
literal|1
expr_stmt|;
name|add_info
argument_list|(
literal|"address"
argument_list|,
name|address_info
argument_list|,
literal|"Describe where symbol SYM is stored."
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"symbol"
argument_list|,
name|sym_info
argument_list|,
literal|"Describe what symbol is at location ADDR.\n\ Only for symbols with fixed locations (global or static scope)."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"x"
argument_list|,
name|class_vars
argument_list|,
name|x_command
argument_list|,
name|concat
argument_list|(
literal|"Examine memory: x/FMT ADDRESS.\n\ ADDRESS is an expression for the memory address to examine.\n\ FMT is a repeat count followed by a format letter and a size letter.\n\ Format letters are o(octal), x(hex), d(decimal), u(unsigned decimal),\n\   t(binary), f(float), a(address), i(instruction), c(char) and s(string).\n"
argument_list|,
literal|"Size letters are b(byte), h(halfword), w(word), g(giant, 8 bytes).\n\ The specified number of objects of the specified size are printed\n\ according to the format.\n\n\ Defaults for format and size letters are those previously used.\n\ Default count is 1.  Default address is following last thing printed\n\ with this command or \"print\"."
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"disassemble"
argument_list|,
name|class_vars
argument_list|,
name|disassemble_command
argument_list|,
literal|"Disassemble a specified section of memory.\n\ Default is the function surrounding the pc of the selected frame.\n\ With a single argument, the function surrounding that address is dumped.\n\ Two arguments are taken as a range of memory to dump."
argument_list|)
expr_stmt|;
if|if
condition|(
name|xdb_commands
condition|)
name|add_com_alias
argument_list|(
literal|"va"
argument_list|,
literal|"disassemble"
argument_list|,
name|class_xdb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|add_com ("whereis", class_vars, whereis_command, 	   "Print line number and file of definition of variable.");
endif|#
directive|endif
name|add_info
argument_list|(
literal|"display"
argument_list|,
name|display_info
argument_list|,
literal|"Expressions to display when program stops, with code numbers."
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"undisplay"
argument_list|,
name|class_vars
argument_list|,
name|undisplay_command
argument_list|,
literal|"Cancel some expressions to be displayed when program stops.\n\ Arguments are the code numbers of the expressions to stop displaying.\n\ No argument means cancel all automatic-display expressions.\n\ \"delete display\" has the same effect as this command.\n\ Do \"info display\" to see current list of code numbers."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"display"
argument_list|,
name|class_vars
argument_list|,
name|display_command
argument_list|,
literal|"Print value of expression EXP each time the program stops.\n\ /FMT may be used before EXP as in the \"print\" command.\n\ /FMT \"i\" or \"s\" or including a size-letter is allowed,\n\ as in the \"x\" command, and then EXP is used to get the address to examine\n\ and examining is done as in the \"x\" command.\n\n\ With no argument, display all currently requested auto-display expressions.\n\ Use \"undisplay\" to cancel display requests previously made."
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"display"
argument_list|,
name|class_vars
argument_list|,
name|enable_display
argument_list|,
literal|"Enable some expressions to be displayed when program stops.\n\ Arguments are the code numbers of the expressions to resume displaying.\n\ No argument means enable all automatic-display expressions.\n\ Do \"info display\" to see current list of code numbers."
argument_list|,
operator|&
name|enablelist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"display"
argument_list|,
name|class_vars
argument_list|,
name|disable_display_command
argument_list|,
literal|"Disable some expressions to be displayed when program stops.\n\ Arguments are the code numbers of the expressions to stop displaying.\n\ No argument means disable all automatic-display expressions.\n\ Do \"info display\" to see current list of code numbers."
argument_list|,
operator|&
name|disablelist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"display"
argument_list|,
name|class_vars
argument_list|,
name|undisplay_command
argument_list|,
literal|"Cancel some expressions to be displayed when program stops.\n\ Arguments are the code numbers of the expressions to stop displaying.\n\ No argument means cancel all automatic-display expressions.\n\ Do \"info display\" to see current list of code numbers."
argument_list|,
operator|&
name|deletelist
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"printf"
argument_list|,
name|class_vars
argument_list|,
name|printf_command
argument_list|,
literal|"printf \"printf format string\", arg1, arg2, arg3, ..., argn\n\ This is useful for formatted output in user-defined commands."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"output"
argument_list|,
name|class_vars
argument_list|,
name|output_command
argument_list|,
literal|"Like \"print\" but don't put in value history and don't print newline.\n\ This is useful in user-defined commands."
argument_list|)
expr_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"set"
argument_list|,
name|class_vars
argument_list|,
name|set_command
argument_list|,
name|concat
argument_list|(
literal|"Evaluate expression EXP and assign result to variable VAR, using assignment\n\ syntax appropriate for the current language (VAR = EXP or VAR := EXP for\n\ example).  VAR may be a debugger \"convenience\" variable (names starting\n\ with $), a register (a few standard names starting with $), or an actual\n\ variable in the program being debugged.  EXP is any valid expression.\n"
argument_list|,
literal|"Use \"set variable\" for variables with names identical to set subcommands.\n\ \nWith a subcommand, this command modifies parts of the gdb environment.\n\ You can see these environment settings with the \"show\" command."
argument_list|,
name|NULL
argument_list|)
argument_list|,
operator|&
name|setlist
argument_list|,
literal|"set "
argument_list|,
literal|1
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbx_commands
condition|)
name|add_com
argument_list|(
literal|"assign"
argument_list|,
name|class_vars
argument_list|,
name|set_command
argument_list|,
name|concat
argument_list|(
literal|"Evaluate expression \ EXP and assign result to variable VAR, using assignment\n\ syntax appropriate for the current language (VAR = EXP or VAR := EXP for\n\ example).  VAR may be a debugger \"convenience\" variable (names starting\n\ with $), a register (a few standard names starting with $), or an actual\n\ variable in the program being debugged.  EXP is any valid expression.\n"
argument_list|,
literal|"Use \"set variable\" for variables with names identical to set subcommands.\n\ \nWith a subcommand, this command modifies parts of the gdb environment.\n\ You can see these environment settings with the \"show\" command."
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
comment|/* "call" is the same as "set", but handy for dbx users to call fns. */
name|add_com
argument_list|(
literal|"call"
argument_list|,
name|class_vars
argument_list|,
name|call_command
argument_list|,
literal|"Call a function in the program.\n\ The argument is the function name and arguments, in the notation of the\n\ current working language.  The result is printed and saved in the value\n\ history, if it is not void."
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"variable"
argument_list|,
name|class_vars
argument_list|,
name|set_command
argument_list|,
literal|"Evaluate expression EXP and assign result to variable VAR, using assignment\n\ syntax appropriate for the current language (VAR = EXP or VAR := EXP for\n\ example).  VAR may be a debugger \"convenience\" variable (names starting\n\ with $), a register (a few standard names starting with $), or an actual\n\ variable in the program being debugged.  EXP is any valid expression.\n\ This may usually be abbreviated to simply \"set\"."
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"print"
argument_list|,
name|class_vars
argument_list|,
name|print_command
argument_list|,
name|concat
argument_list|(
literal|"Print value of expression EXP.\n\ Variables accessible are those of the lexical environment of the selected\n\ stack frame, plus all those whose scope is global or an entire file.\n\ \n\ $NUM gets previous value number NUM.  $ and $$ are the last two values.\n\ $$NUM refers to NUM'th value back from the last one.\n\ Names starting with $ refer to registers (with the values they would have\n"
argument_list|,
literal|"if the program were to return to the stack frame now selected, restoring\n\ all registers saved by frames farther in) or else to debugger\n\ \"convenience\" variables (any such name not a known register).\n\ Use assignment expressions to give values to convenience variables.\n"
argument_list|,
literal|"\n\ {TYPE}ADREXP refers to a datum of data type TYPE, located at address ADREXP.\n\ @ is a binary operator for treating consecutive data objects\n\ anywhere in memory as an array.  FOO@NUM gives an array whose first\n\ element is FOO, whose second element is stored in the space following\n\ where FOO is stored, etc.  FOO must be an expression whose value\n\ resides in memory.\n"
argument_list|,
literal|"\n\ EXP may be preceded with /FMT, where FMT is a format letter\n\ but no count or size letter (see \"x\" command)."
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"p"
argument_list|,
literal|"print"
argument_list|,
name|class_vars
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"inspect"
argument_list|,
name|class_vars
argument_list|,
name|inspect_command
argument_list|,
literal|"Same as \"print\" command, except that if you are running in the epoch\n\ environment, the value is printed in its own window."
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"max-symbolic-offset"
argument_list|,
name|no_class
argument_list|,
name|var_uinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|max_symbolic_offset
argument_list|,
literal|"Set the largest offset that will be printed in<symbol+1234> form."
argument_list|,
operator|&
name|setprintlist
argument_list|)
argument_list|,
operator|&
name|showprintlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"symbol-filename"
argument_list|,
name|no_class
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|print_symbol_filename
argument_list|,
literal|"Set printing of source filename and line number with<symbol>."
argument_list|,
operator|&
name|setprintlist
argument_list|)
argument_list|,
operator|&
name|showprintlist
argument_list|)
expr_stmt|;
comment|/* For examine/instruction a single byte quantity is specified as      the data.  This avoids problems with value_at_lazy() requiring a      valid data type (and rejecting VOID). */
name|examine_i_type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"examine_i_type"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|examine_b_type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"examine_b_type"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|examine_h_type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"examine_h_type"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|examine_w_type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
literal|"examine_w_type"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|examine_g_type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|8
argument_list|,
literal|0
argument_list|,
literal|"examine_g_type"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

