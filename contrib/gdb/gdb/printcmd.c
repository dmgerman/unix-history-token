begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Print values for GNU debugger GDB.     Copyright 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994,    1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004 Free Software    Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"breakpoint.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_include
include|#
directive|include
file|"valprint.h"
end_include

begin_include
include|#
directive|include
file|"annotate.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_comment
comment|/* for overlay functions */
end_comment

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_comment
comment|/* ditto */
end_comment

begin_include
include|#
directive|include
file|"completer.h"
end_include

begin_comment
comment|/* for completion functions */
end_comment

begin_include
include|#
directive|include
file|"ui-out.h"
end_include

begin_include
include|#
directive|include
file|"gdb_assert.h"
end_include

begin_include
include|#
directive|include
file|"block.h"
end_include

begin_include
include|#
directive|include
file|"disasm.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|TUI
end_ifdef

begin_include
include|#
directive|include
file|"tui/tui.h"
end_include

begin_comment
comment|/* For tui_active et.al.   */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|int
name|asm_demangle
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether to demangle syms in asm printouts */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|addressprint
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether to print hex addresses in HLL " */
end_comment

begin_struct
struct|struct
name|format_data
block|{
name|int
name|count
decl_stmt|;
name|char
name|format
decl_stmt|;
name|char
name|size
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Last specified output format.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|last_format
init|=
literal|'x'
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last specified examination size.  'b', 'h', 'w' or `q'.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|last_size
init|=
literal|'w'
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default address to examine next.  */
end_comment

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|next_address
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default section to examine next. */
end_comment

begin_decl_stmt
specifier|static
name|asection
modifier|*
name|next_section
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last address examined.  */
end_comment

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|last_examine_address
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Contents of last address examined.    This is not valid past the end of the `x' command!  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|value
modifier|*
name|last_examine_value
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Largest offset between a symbolic value and an address, that will be    printed as `0x1234<symbol+offset>'.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|max_symbolic_offset
init|=
name|UINT_MAX
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Append the source filename and linenumber of the symbol when    printing a symbolic value as `<symbol at filename:linenum>' if set.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|print_symbol_filename
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of auto-display expression currently being displayed.    So that we can disable it if we get an error or a signal within it.    -1 when not doing one.  */
end_comment

begin_decl_stmt
name|int
name|current_display_number
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag to low-level print routines that this value is being printed    in an epoch window.  We'd like to pass this as a parameter, but    every routine would need to take it.  Perhaps we can encapsulate    this in the I/O stream once we have GNU stdio. */
end_comment

begin_decl_stmt
name|int
name|inspect_it
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|display
block|{
comment|/* Chain link to next auto-display item.  */
name|struct
name|display
modifier|*
name|next
decl_stmt|;
comment|/* Expression to be evaluated and displayed.  */
name|struct
name|expression
modifier|*
name|exp
decl_stmt|;
comment|/* Item number of this auto-display item.  */
name|int
name|number
decl_stmt|;
comment|/* Display format specified.  */
name|struct
name|format_data
name|format
decl_stmt|;
comment|/* Innermost block required by this expression when evaluated */
name|struct
name|block
modifier|*
name|block
decl_stmt|;
comment|/* Status of this display (enabled or disabled) */
name|int
name|enabled_p
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Chain of expressions whose values should be displayed    automatically each time the program stops.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|display
modifier|*
name|display_chain
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|display_number
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Prototypes for exported functions. */
end_comment

begin_function_decl
name|void
name|output_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|_initialize_printcmd
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Prototypes for local functions. */
end_comment

begin_function_decl
specifier|static
name|void
name|delete_display
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|enable_display
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|disable_display_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|printf_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|display_info
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_one_display
parameter_list|(
name|struct
name|display
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|undisplay_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_display
parameter_list|(
name|struct
name|display
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|display_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|x_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|address_info
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|call_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|inspect_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_command_1
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|validate_format
parameter_list|(
name|struct
name|format_data
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_examine
parameter_list|(
name|struct
name|format_data
parameter_list|,
name|CORE_ADDR
name|addr
parameter_list|,
name|asection
modifier|*
name|section
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_formatted
parameter_list|(
name|struct
name|value
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|struct
name|ui_file
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|format_data
name|decode_format
parameter_list|(
name|char
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_info
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Decode a format specification.  *STRING_PTR should point to it.    OFORMAT and OSIZE are used as defaults for the format and size    if none are given in the format specification.    If OSIZE is zero, then the size field of the returned value    should be set only if a size is explicitly specified by the    user.    The structure returned describes all the data    found in the specification.  In addition, *STRING_PTR is advanced    past the specification and past all whitespace following it.  */
end_comment

begin_function
specifier|static
name|struct
name|format_data
name|decode_format
parameter_list|(
name|char
modifier|*
modifier|*
name|string_ptr
parameter_list|,
name|int
name|oformat
parameter_list|,
name|int
name|osize
parameter_list|)
block|{
name|struct
name|format_data
name|val
decl_stmt|;
name|char
modifier|*
name|p
init|=
operator|*
name|string_ptr
decl_stmt|;
name|val
operator|.
name|format
operator|=
literal|'?'
expr_stmt|;
name|val
operator|.
name|size
operator|=
literal|'?'
expr_stmt|;
name|val
operator|.
name|count
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|>=
literal|'0'
operator|&&
operator|*
name|p
operator|<=
literal|'9'
condition|)
name|val
operator|.
name|count
operator|=
name|atoi
argument_list|(
name|p
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|>=
literal|'0'
operator|&&
operator|*
name|p
operator|<=
literal|'9'
condition|)
name|p
operator|++
expr_stmt|;
comment|/* Now process size or format letters that follow.  */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'b'
operator|||
operator|*
name|p
operator|==
literal|'h'
operator|||
operator|*
name|p
operator|==
literal|'w'
operator|||
operator|*
name|p
operator|==
literal|'g'
condition|)
name|val
operator|.
name|size
operator|=
operator|*
name|p
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|>=
literal|'a'
operator|&&
operator|*
name|p
operator|<=
literal|'z'
condition|)
name|val
operator|.
name|format
operator|=
operator|*
name|p
operator|++
expr_stmt|;
else|else
break|break;
block|}
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
operator|*
name|string_ptr
operator|=
name|p
expr_stmt|;
comment|/* Set defaults for format and size if not specified.  */
if|if
condition|(
name|val
operator|.
name|format
operator|==
literal|'?'
condition|)
block|{
if|if
condition|(
name|val
operator|.
name|size
operator|==
literal|'?'
condition|)
block|{
comment|/* Neither has been specified.  */
name|val
operator|.
name|format
operator|=
name|oformat
expr_stmt|;
name|val
operator|.
name|size
operator|=
name|osize
expr_stmt|;
block|}
else|else
comment|/* If a size is specified, any format makes a reasonable 	   default except 'i'.  */
name|val
operator|.
name|format
operator|=
name|oformat
operator|==
literal|'i'
condition|?
literal|'x'
else|:
name|oformat
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|val
operator|.
name|size
operator|==
literal|'?'
condition|)
switch|switch
condition|(
name|val
operator|.
name|format
condition|)
block|{
case|case
literal|'a'
case|:
case|case
literal|'s'
case|:
comment|/* Pick the appropriate size for an address.  */
if|if
condition|(
name|TARGET_PTR_BIT
operator|==
literal|64
condition|)
name|val
operator|.
name|size
operator|=
name|osize
condition|?
literal|'g'
else|:
name|osize
expr_stmt|;
elseif|else
if|if
condition|(
name|TARGET_PTR_BIT
operator|==
literal|32
condition|)
name|val
operator|.
name|size
operator|=
name|osize
condition|?
literal|'w'
else|:
name|osize
expr_stmt|;
elseif|else
if|if
condition|(
name|TARGET_PTR_BIT
operator|==
literal|16
condition|)
name|val
operator|.
name|size
operator|=
name|osize
condition|?
literal|'h'
else|:
name|osize
expr_stmt|;
else|else
comment|/* Bad value for TARGET_PTR_BIT */
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"failed internal consistency check"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* Floating point has to be word or giantword.  */
if|if
condition|(
name|osize
operator|==
literal|'w'
operator|||
name|osize
operator|==
literal|'g'
condition|)
name|val
operator|.
name|size
operator|=
name|osize
expr_stmt|;
else|else
comment|/* Default it to giantword if the last used size is not 	     appropriate.  */
name|val
operator|.
name|size
operator|=
name|osize
condition|?
literal|'g'
else|:
name|osize
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/* Characters default to one byte.  */
name|val
operator|.
name|size
operator|=
name|osize
condition|?
literal|'b'
else|:
name|osize
expr_stmt|;
break|break;
default|default:
comment|/* The default is the size most recently specified.  */
name|val
operator|.
name|size
operator|=
name|osize
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print value VAL on stream according to FORMAT, a letter or 0.    Do not end with a newline.    0 means print VAL according to its own type.    SIZE is the letter for the size of datum being printed.    This is used to pad hex numbers so they line up.  */
end_comment

begin_function
specifier|static
name|void
name|print_formatted
parameter_list|(
name|struct
name|value
modifier|*
name|val
parameter_list|,
name|int
name|format
parameter_list|,
name|int
name|size
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|type
init|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|VALUE_LVAL
argument_list|(
name|val
argument_list|)
operator|==
name|lval_memory
condition|)
block|{
name|next_address
operator|=
name|VALUE_ADDRESS
argument_list|(
name|val
argument_list|)
operator|+
name|len
expr_stmt|;
name|next_section
operator|=
name|VALUE_BFD_SECTION
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|format
condition|)
block|{
case|case
literal|'s'
case|:
comment|/* FIXME: Need to handle wchar_t's here... */
name|next_address
operator|=
name|VALUE_ADDRESS
argument_list|(
name|val
argument_list|)
operator|+
name|val_print_string
argument_list|(
name|VALUE_ADDRESS
argument_list|(
name|val
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|next_section
operator|=
name|VALUE_BFD_SECTION
argument_list|(
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
comment|/* The old comment says          "Force output out, print_insn not using _filtered".          I'm not completely sure what that means, I suspect most print_insn          now do use _filtered, so I guess it's obsolete.          --Yes, it does filter now, and so this is obsolete.  -JB  */
comment|/* We often wrap here if there are long symbolic names.  */
name|wrap_here
argument_list|(
literal|"    "
argument_list|)
expr_stmt|;
name|next_address
operator|=
name|VALUE_ADDRESS
argument_list|(
name|val
argument_list|)
operator|+
name|gdb_print_insn
argument_list|(
name|VALUE_ADDRESS
argument_list|(
name|val
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|next_section
operator|=
name|VALUE_BFD_SECTION
argument_list|(
name|val
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|format
operator|==
literal|0
operator|||
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_ARRAY
operator|||
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_STRING
operator|||
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
operator|||
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_UNION
operator|||
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_NAMESPACE
condition|)
comment|/* If format is 0, use the 'natural' format for 	 * that type of value.  If the type is non-scalar, 	 * we have to use language rules to print it as 	 * a series of scalars. 	 */
name|value_print
argument_list|(
name|val
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|Val_pretty_default
argument_list|)
expr_stmt|;
else|else
comment|/* User specified format, so don't look to the 	 * the type to tell us what to do. 	 */
name|print_scalar_formatted
argument_list|(
name|VALUE_CONTENTS
argument_list|(
name|val
argument_list|)
argument_list|,
name|type
argument_list|,
name|format
argument_list|,
name|size
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print a scalar of data of type TYPE, pointed to in GDB by VALADDR,    according to letters FORMAT and SIZE on STREAM.    FORMAT may not be zero.  Formats s and i are not supported at this level.     This is how the elements of an array or structure are printed    with a format.  */
end_comment

begin_function
name|void
name|print_scalar_formatted
parameter_list|(
name|void
modifier|*
name|valaddr
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|int
name|format
parameter_list|,
name|int
name|size
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|)
block|{
name|LONGEST
name|val_long
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|>
sizeof|sizeof
argument_list|(
name|LONGEST
argument_list|)
operator|&&
operator|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_INT
operator|||
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_ENUM
operator|)
condition|)
block|{
switch|switch
condition|(
name|format
condition|)
block|{
case|case
literal|'o'
case|:
name|print_octal_chars
argument_list|(
name|stream
argument_list|,
name|valaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'u'
case|:
case|case
literal|'d'
case|:
name|print_decimal_chars
argument_list|(
name|stream
argument_list|,
name|valaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'t'
case|:
name|print_binary_chars
argument_list|(
name|stream
argument_list|,
name|valaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'x'
case|:
name|print_hex_chars
argument_list|(
name|stream
argument_list|,
name|valaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'c'
case|:
name|print_char_chars
argument_list|(
name|stream
argument_list|,
name|valaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return;
default|default:
break|break;
block|}
empty_stmt|;
block|}
if|if
condition|(
name|format
operator|!=
literal|'f'
condition|)
name|val_long
operator|=
name|unpack_long
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|)
expr_stmt|;
comment|/* If the value is a pointer, and pointers and addresses are not the      same, then at this point, the value's length (in target bytes) is      TARGET_ADDR_BIT/TARGET_CHAR_BIT, not TYPE_LENGTH (type).  */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_PTR
condition|)
name|len
operator|=
name|TARGET_ADDR_BIT
operator|/
name|TARGET_CHAR_BIT
expr_stmt|;
comment|/* If we are printing it as unsigned, truncate it in case it is actually      a negative signed value (e.g. "print/u (short)-1" should print 65535      (if shorts are 16 bits) instead of 4294967295).  */
if|if
condition|(
name|format
operator|!=
literal|'d'
condition|)
block|{
if|if
condition|(
name|len
operator|<
sizeof|sizeof
argument_list|(
name|LONGEST
argument_list|)
condition|)
name|val_long
operator|&=
operator|(
operator|(
name|LONGEST
operator|)
literal|1
operator|<<
name|HOST_CHAR_BIT
operator|*
name|len
operator|)
operator|-
literal|1
expr_stmt|;
block|}
switch|switch
condition|(
name|format
condition|)
block|{
case|case
literal|'x'
case|:
if|if
condition|(
operator|!
name|size
condition|)
block|{
comment|/* no size specified, like in print.  Print varying # of digits. */
name|print_longest
argument_list|(
name|stream
argument_list|,
literal|'x'
argument_list|,
literal|1
argument_list|,
name|val_long
argument_list|)
expr_stmt|;
block|}
else|else
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|'b'
case|:
case|case
literal|'h'
case|:
case|case
literal|'w'
case|:
case|case
literal|'g'
case|:
name|print_longest
argument_list|(
name|stream
argument_list|,
name|size
argument_list|,
literal|1
argument_list|,
name|val_long
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Undefined output size \"%c\"."
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'d'
case|:
name|print_longest
argument_list|(
name|stream
argument_list|,
literal|'d'
argument_list|,
literal|1
argument_list|,
name|val_long
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|print_longest
argument_list|(
name|stream
argument_list|,
literal|'u'
argument_list|,
literal|0
argument_list|,
name|val_long
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
if|if
condition|(
name|val_long
condition|)
name|print_longest
argument_list|(
name|stream
argument_list|,
literal|'o'
argument_list|,
literal|1
argument_list|,
name|val_long
argument_list|)
expr_stmt|;
else|else
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
block|{
name|CORE_ADDR
name|addr
init|=
name|unpack_pointer
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|)
decl_stmt|;
name|print_address
argument_list|(
name|addr
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'c'
case|:
name|value_print
argument_list|(
name|value_from_longest
argument_list|(
name|builtin_type_true_char
argument_list|,
name|val_long
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
name|Val_pretty_default
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
if|if
condition|(
name|len
operator|==
name|TYPE_LENGTH
argument_list|(
name|builtin_type_float
argument_list|)
condition|)
name|type
operator|=
name|builtin_type_float
expr_stmt|;
elseif|else
if|if
condition|(
name|len
operator|==
name|TYPE_LENGTH
argument_list|(
name|builtin_type_double
argument_list|)
condition|)
name|type
operator|=
name|builtin_type_double
expr_stmt|;
elseif|else
if|if
condition|(
name|len
operator|==
name|TYPE_LENGTH
argument_list|(
name|builtin_type_long_double
argument_list|)
condition|)
name|type
operator|=
name|builtin_type_long_double
expr_stmt|;
name|print_floating
argument_list|(
name|valaddr
argument_list|,
name|type
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"failed internal consistency check"
argument_list|)
expr_stmt|;
case|case
literal|'t'
case|:
comment|/* Binary; 't' stands for "two".  */
block|{
name|char
name|bits
index|[
literal|8
operator|*
operator|(
sizeof|sizeof
name|val_long
operator|)
operator|+
literal|1
index|]
decl_stmt|;
name|char
name|buf
index|[
literal|8
operator|*
operator|(
sizeof|sizeof
name|val_long
operator|)
operator|+
literal|32
index|]
decl_stmt|;
name|char
modifier|*
name|cp
init|=
name|bits
decl_stmt|;
name|int
name|width
decl_stmt|;
if|if
condition|(
operator|!
name|size
condition|)
name|width
operator|=
literal|8
operator|*
operator|(
sizeof|sizeof
name|val_long
operator|)
expr_stmt|;
else|else
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|'b'
case|:
name|width
operator|=
literal|8
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|width
operator|=
literal|16
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|width
operator|=
literal|32
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|width
operator|=
literal|64
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Undefined output size \"%c\"."
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
name|bits
index|[
name|width
index|]
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|width
operator|--
operator|>
literal|0
condition|)
block|{
name|bits
index|[
name|width
index|]
operator|=
operator|(
name|val_long
operator|&
literal|1
operator|)
condition|?
literal|'1'
else|:
literal|'0'
expr_stmt|;
name|val_long
operator|>>=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|size
condition|)
block|{
while|while
condition|(
operator|*
name|cp
operator|&&
operator|*
name|cp
operator|==
literal|'0'
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
name|cp
operator|--
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|buf
argument_list|,
name|local_binary_format_prefix
argument_list|()
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
name|local_binary_format_suffix
argument_list|()
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
name|buf
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|error
argument_list|(
literal|"Undefined output format \"%c\"."
argument_list|,
name|format
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Specify default address for `x' command.    `info lines' uses this.  */
end_comment

begin_function
name|void
name|set_next_address
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|)
block|{
name|next_address
operator|=
name|addr
expr_stmt|;
comment|/* Make address available to the user as $_.  */
name|set_internalvar
argument_list|(
name|lookup_internalvar
argument_list|(
literal|"_"
argument_list|)
argument_list|,
name|value_from_pointer
argument_list|(
name|lookup_pointer_type
argument_list|(
name|builtin_type_void
argument_list|)
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Optionally print address ADDR symbolically as<SYMBOL+OFFSET> on STREAM,    after LEADIN.  Print nothing if no symbolic name is found nearby.    Optionally also print source file and line number, if available.    DO_DEMANGLE controls whether to print a symbol in its native "raw" form,    or to interpret it as a possible C++ name and convert it back to source    form.  However note that DO_DEMANGLE can be overridden by the specific    settings of the demangle and asm_demangle variables.  */
end_comment

begin_function
name|void
name|print_address_symbolic
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|int
name|do_demangle
parameter_list|,
name|char
modifier|*
name|leadin
parameter_list|)
block|{
name|char
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|filename
init|=
name|NULL
decl_stmt|;
name|int
name|unmapped
init|=
literal|0
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|int
name|line
init|=
literal|0
decl_stmt|;
comment|/* throw away both name and filename */
name|struct
name|cleanup
modifier|*
name|cleanup_chain
init|=
name|make_cleanup
argument_list|(
name|free_current_contents
argument_list|,
operator|&
name|name
argument_list|)
decl_stmt|;
name|make_cleanup
argument_list|(
name|free_current_contents
argument_list|,
operator|&
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|build_address_symbolic
argument_list|(
name|addr
argument_list|,
name|do_demangle
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|offset
argument_list|,
operator|&
name|filename
argument_list|,
operator|&
name|line
argument_list|,
operator|&
name|unmapped
argument_list|)
condition|)
block|{
name|do_cleanups
argument_list|(
name|cleanup_chain
argument_list|)
expr_stmt|;
return|return;
block|}
name|fputs_filtered
argument_list|(
name|leadin
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|unmapped
condition|)
name|fputs_filtered
argument_list|(
literal|"<*"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
name|fputs_filtered
argument_list|(
literal|"<"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
name|name
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|!=
literal|0
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"+%u"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|offset
argument_list|)
expr_stmt|;
comment|/* Append source filename and line number if desired.  Give specific      line # of this addr, if we have it; else line # of the nearest symbol.  */
if|if
condition|(
name|print_symbol_filename
operator|&&
name|filename
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|line
operator|!=
operator|-
literal|1
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" at %s:%d"
argument_list|,
name|filename
argument_list|,
name|line
argument_list|)
expr_stmt|;
else|else
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" in %s"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|unmapped
condition|)
name|fputs_filtered
argument_list|(
literal|"*>"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
name|fputs_filtered
argument_list|(
literal|">"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|cleanup_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given an address ADDR return all the elements needed to print the    address in a symbolic form. NAME can be mangled or not depending    on DO_DEMANGLE (and also on the asm_demangle global variable,    manipulated via ''set print asm-demangle''). Return 0 in case of    success, when all the info in the OUT paramters is valid. Return 1    otherwise. */
end_comment

begin_function
name|int
name|build_address_symbolic
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
comment|/* IN */
name|int
name|do_demangle
parameter_list|,
comment|/* IN */
name|char
modifier|*
modifier|*
name|name
parameter_list|,
comment|/* OUT */
name|int
modifier|*
name|offset
parameter_list|,
comment|/* OUT */
name|char
modifier|*
modifier|*
name|filename
parameter_list|,
comment|/* OUT */
name|int
modifier|*
name|line
parameter_list|,
comment|/* OUT */
name|int
modifier|*
name|unmapped
parameter_list|)
comment|/* OUT */
block|{
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
name|struct
name|symbol
modifier|*
name|symbol
decl_stmt|;
name|struct
name|symtab
modifier|*
name|symtab
init|=
literal|0
decl_stmt|;
name|CORE_ADDR
name|name_location
init|=
literal|0
decl_stmt|;
name|asection
modifier|*
name|section
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|name_temp
init|=
literal|""
decl_stmt|;
comment|/* Let's say it is unmapped. */
operator|*
name|unmapped
operator|=
literal|0
expr_stmt|;
comment|/* Determine if the address is in an overlay, and whether it is      mapped. */
if|if
condition|(
name|overlay_debugging
condition|)
block|{
name|section
operator|=
name|find_pc_overlay
argument_list|(
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|pc_in_unmapped_range
argument_list|(
name|addr
argument_list|,
name|section
argument_list|)
condition|)
block|{
operator|*
name|unmapped
operator|=
literal|1
expr_stmt|;
name|addr
operator|=
name|overlay_mapped_address
argument_list|(
name|addr
argument_list|,
name|section
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* First try to find the address in the symbol table, then      in the minsyms.  Take the closest one.  */
comment|/* This is defective in the sense that it only finds text symbols.  So      really this is kind of pointless--we should make sure that the      minimal symbols have everything we need (by changing that we could      save some memory, but for many debug format--ELF/DWARF or      anything/stabs--it would be inconvenient to eliminate those minimal      symbols anyway).  */
name|msymbol
operator|=
name|lookup_minimal_symbol_by_pc_section
argument_list|(
name|addr
argument_list|,
name|section
argument_list|)
expr_stmt|;
name|symbol
operator|=
name|find_pc_sect_function
argument_list|(
name|addr
argument_list|,
name|section
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbol
condition|)
block|{
name|name_location
operator|=
name|BLOCK_START
argument_list|(
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_demangle
operator|||
name|asm_demangle
condition|)
name|name_temp
operator|=
name|SYMBOL_PRINT_NAME
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
else|else
name|name_temp
operator|=
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|msymbol
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
operator|>
name|name_location
operator|||
name|symbol
operator|==
name|NULL
condition|)
block|{
comment|/* The msymbol is closer to the address than the symbol; 	     use the msymbol instead.  */
name|symbol
operator|=
literal|0
expr_stmt|;
name|symtab
operator|=
literal|0
expr_stmt|;
name|name_location
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_demangle
operator|||
name|asm_demangle
condition|)
name|name_temp
operator|=
name|SYMBOL_PRINT_NAME
argument_list|(
name|msymbol
argument_list|)
expr_stmt|;
else|else
name|name_temp
operator|=
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|msymbol
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|symbol
operator|==
name|NULL
operator|&&
name|msymbol
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
comment|/* If the nearest symbol is too far away, don't print anything symbolic.  */
comment|/* For when CORE_ADDR is larger than unsigned int, we do math in      CORE_ADDR.  But when we detect unsigned wraparound in the      CORE_ADDR math, we ignore this test and print the offset,      because addr+max_symbolic_offset has wrapped through the end      of the address space back to the beginning, giving bogus comparison.  */
if|if
condition|(
name|addr
operator|>
name|name_location
operator|+
name|max_symbolic_offset
operator|&&
name|name_location
operator|+
name|max_symbolic_offset
operator|>
name|name_location
condition|)
return|return
literal|1
return|;
operator|*
name|offset
operator|=
name|addr
operator|-
name|name_location
expr_stmt|;
operator|*
name|name
operator|=
name|xstrdup
argument_list|(
name|name_temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|print_symbol_filename
condition|)
block|{
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|sal
operator|=
name|find_pc_sect_line
argument_list|(
name|addr
argument_list|,
name|section
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sal
operator|.
name|symtab
condition|)
block|{
operator|*
name|filename
operator|=
name|xstrdup
argument_list|(
name|sal
operator|.
name|symtab
operator|->
name|filename
argument_list|)
expr_stmt|;
operator|*
name|line
operator|=
name|sal
operator|.
name|line
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|symtab
operator|&&
name|symbol
operator|&&
name|symbol
operator|->
name|line
condition|)
block|{
operator|*
name|filename
operator|=
name|xstrdup
argument_list|(
name|symtab
operator|->
name|filename
argument_list|)
expr_stmt|;
operator|*
name|line
operator|=
name|symbol
operator|->
name|line
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|symtab
condition|)
block|{
operator|*
name|filename
operator|=
name|xstrdup
argument_list|(
name|symtab
operator|->
name|filename
argument_list|)
expr_stmt|;
operator|*
name|line
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Print address ADDR on STREAM.  USE_LOCAL means the same thing as for    print_longest.  */
end_comment

begin_function
name|void
name|print_address_numeric
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|int
name|use_local
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|)
block|{
comment|/* Truncate address to the size of a target address, avoiding shifts      larger or equal than the width of a CORE_ADDR.  The local      variable ADDR_BIT stops the compiler reporting a shift overflow      when it won't occur. */
comment|/* NOTE: This assumes that the significant address information is      kept in the least significant bits of ADDR - the upper bits were      either zero or sign extended.  Should ADDRESS_TO_POINTER() or      some ADDRESS_TO_PRINTABLE() be used to do the conversion?  */
name|int
name|addr_bit
init|=
name|TARGET_ADDR_BIT
decl_stmt|;
if|if
condition|(
name|addr_bit
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|CORE_ADDR
argument_list|)
operator|*
name|HOST_CHAR_BIT
operator|)
condition|)
name|addr
operator|&=
operator|(
operator|(
name|CORE_ADDR
operator|)
literal|1
operator|<<
name|addr_bit
operator|)
operator|-
literal|1
expr_stmt|;
name|print_longest
argument_list|(
name|stream
argument_list|,
literal|'x'
argument_list|,
name|use_local
argument_list|,
operator|(
name|ULONGEST
operator|)
name|addr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print address ADDR symbolically on STREAM.    First print it as a number.  Then perhaps print<SYMBOL + OFFSET> after the number.  */
end_comment

begin_function
name|void
name|print_address
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|)
block|{
name|print_address_numeric
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|print_address_symbolic
argument_list|(
name|addr
argument_list|,
name|stream
argument_list|,
name|asm_demangle
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print address ADDR symbolically on STREAM.  Parameter DEMANGLE    controls whether to print the symbolic name "raw" or demangled.    Global setting "addressprint" controls whether to print hex address    or not.  */
end_comment

begin_function
name|void
name|print_address_demangle
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|int
name|do_demangle
parameter_list|)
block|{
if|if
condition|(
name|addr
operator|==
literal|0
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|addressprint
condition|)
block|{
name|print_address_numeric
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|print_address_symbolic
argument_list|(
name|addr
argument_list|,
name|stream
argument_list|,
name|do_demangle
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|print_address_symbolic
argument_list|(
name|addr
argument_list|,
name|stream
argument_list|,
name|do_demangle
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* These are the types that $__ will get after an examine command of one    of these sizes.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|examine_i_type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|examine_b_type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|examine_h_type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|examine_w_type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|examine_g_type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Examine data at address ADDR in format FMT.    Fetch it from memory and print on gdb_stdout.  */
end_comment

begin_function
specifier|static
name|void
name|do_examine
parameter_list|(
name|struct
name|format_data
name|fmt
parameter_list|,
name|CORE_ADDR
name|addr
parameter_list|,
name|asection
modifier|*
name|sect
parameter_list|)
block|{
name|char
name|format
init|=
literal|0
decl_stmt|;
name|char
name|size
decl_stmt|;
name|int
name|count
init|=
literal|1
decl_stmt|;
name|struct
name|type
modifier|*
name|val_type
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|maxelts
decl_stmt|;
name|format
operator|=
name|fmt
operator|.
name|format
expr_stmt|;
name|size
operator|=
name|fmt
operator|.
name|size
expr_stmt|;
name|count
operator|=
name|fmt
operator|.
name|count
expr_stmt|;
name|next_address
operator|=
name|addr
expr_stmt|;
name|next_section
operator|=
name|sect
expr_stmt|;
comment|/* String or instruction format implies fetch single bytes      regardless of the specified size.  */
if|if
condition|(
name|format
operator|==
literal|'s'
operator|||
name|format
operator|==
literal|'i'
condition|)
name|size
operator|=
literal|'b'
expr_stmt|;
if|if
condition|(
name|format
operator|==
literal|'i'
condition|)
name|val_type
operator|=
name|examine_i_type
expr_stmt|;
elseif|else
if|if
condition|(
name|size
operator|==
literal|'b'
condition|)
name|val_type
operator|=
name|examine_b_type
expr_stmt|;
elseif|else
if|if
condition|(
name|size
operator|==
literal|'h'
condition|)
name|val_type
operator|=
name|examine_h_type
expr_stmt|;
elseif|else
if|if
condition|(
name|size
operator|==
literal|'w'
condition|)
name|val_type
operator|=
name|examine_w_type
expr_stmt|;
elseif|else
if|if
condition|(
name|size
operator|==
literal|'g'
condition|)
name|val_type
operator|=
name|examine_g_type
expr_stmt|;
name|maxelts
operator|=
literal|8
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|'w'
condition|)
name|maxelts
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|'g'
condition|)
name|maxelts
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|format
operator|==
literal|'s'
operator|||
name|format
operator|==
literal|'i'
condition|)
name|maxelts
operator|=
literal|1
expr_stmt|;
comment|/* Print as many objects as specified in COUNT, at most maxelts per line,      with the address of the next one at the start of each line.  */
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|QUIT
expr_stmt|;
name|print_address
argument_list|(
name|next_address
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|":"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|maxelts
init|;
name|i
operator|>
literal|0
operator|&&
name|count
operator|>
literal|0
condition|;
name|i
operator|--
operator|,
name|count
operator|--
control|)
block|{
name|printf_filtered
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
comment|/* Note that print_formatted sets next_address for the next 	     object.  */
name|last_examine_address
operator|=
name|next_address
expr_stmt|;
if|if
condition|(
name|last_examine_value
condition|)
name|value_free
argument_list|(
name|last_examine_value
argument_list|)
expr_stmt|;
comment|/* The value to be displayed is not fetched greedily. 	     Instead, to avoid the posibility of a fetched value not 	     being used, its retreval is delayed until the print code 	     uses it.  When examining an instruction stream, the 	     disassembler will perform its own memory fetch using just 	     the address stored in LAST_EXAMINE_VALUE.  FIXME: Should 	     the disassembler be modified so that LAST_EXAMINE_VALUE 	     is left with the byte sequence from the last complete 	     instruction fetched from memory? */
name|last_examine_value
operator|=
name|value_at_lazy
argument_list|(
name|val_type
argument_list|,
name|next_address
argument_list|,
name|sect
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_examine_value
condition|)
name|release_value
argument_list|(
name|last_examine_value
argument_list|)
expr_stmt|;
name|print_formatted
argument_list|(
name|last_examine_value
argument_list|,
name|format
argument_list|,
name|size
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|validate_format
parameter_list|(
name|struct
name|format_data
name|fmt
parameter_list|,
name|char
modifier|*
name|cmdname
parameter_list|)
block|{
if|if
condition|(
name|fmt
operator|.
name|size
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|"Size letters are meaningless in \"%s\" command."
argument_list|,
name|cmdname
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
operator|.
name|count
operator|!=
literal|1
condition|)
name|error
argument_list|(
literal|"Item count other than 1 is meaningless in \"%s\" command."
argument_list|,
name|cmdname
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
operator|.
name|format
operator|==
literal|'i'
operator|||
name|fmt
operator|.
name|format
operator|==
literal|'s'
condition|)
name|error
argument_list|(
literal|"Format letter \"%c\" is meaningless in \"%s\" command."
argument_list|,
name|fmt
operator|.
name|format
argument_list|,
name|cmdname
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  Evaluate string EXP as an expression in the current language and    print the resulting value.  EXP may contain a format specifier as the    first argument ("/x myvar" for example, to print myvar in hex).  */
end_comment

begin_function
specifier|static
name|void
name|print_command_1
parameter_list|(
name|char
modifier|*
name|exp
parameter_list|,
name|int
name|inspect
parameter_list|,
name|int
name|voidprint
parameter_list|)
block|{
name|struct
name|expression
modifier|*
name|expr
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
init|=
literal|0
decl_stmt|;
name|char
name|format
init|=
literal|0
decl_stmt|;
name|struct
name|value
modifier|*
name|val
decl_stmt|;
name|struct
name|format_data
name|fmt
decl_stmt|;
name|int
name|cleanup
init|=
literal|0
decl_stmt|;
comment|/* Pass inspect flag to the rest of the print routines in a global (sigh). */
name|inspect_it
operator|=
name|inspect
expr_stmt|;
if|if
condition|(
name|exp
operator|&&
operator|*
name|exp
operator|==
literal|'/'
condition|)
block|{
name|exp
operator|++
expr_stmt|;
name|fmt
operator|=
name|decode_format
argument_list|(
operator|&
name|exp
argument_list|,
name|last_format
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|validate_format
argument_list|(
name|fmt
argument_list|,
literal|"print"
argument_list|)
expr_stmt|;
name|last_format
operator|=
name|format
operator|=
name|fmt
operator|.
name|format
expr_stmt|;
block|}
else|else
block|{
name|fmt
operator|.
name|count
operator|=
literal|1
expr_stmt|;
name|fmt
operator|.
name|format
operator|=
literal|0
expr_stmt|;
name|fmt
operator|.
name|size
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|exp
operator|&&
operator|*
name|exp
condition|)
block|{
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|expr
operator|=
name|parse_expression
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|free_current_contents
argument_list|,
operator|&
name|expr
argument_list|)
expr_stmt|;
name|cleanup
operator|=
literal|1
expr_stmt|;
name|val
operator|=
name|evaluate_expression
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
else|else
name|val
operator|=
name|access_value_history
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|voidprint
operator|||
operator|(
name|val
operator|&&
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
operator|&&
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|!=
name|TYPE_CODE_VOID
operator|)
condition|)
block|{
name|int
name|histindex
init|=
name|record_latest_value
argument_list|(
name|val
argument_list|)
decl_stmt|;
if|if
condition|(
name|histindex
operator|>=
literal|0
condition|)
name|annotate_value_history_begin
argument_list|(
name|histindex
argument_list|,
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|annotate_value_begin
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|inspect
condition|)
name|printf_unfiltered
argument_list|(
literal|"\031(gdb-makebuffer \"%s\"  %d '(\""
argument_list|,
name|exp
argument_list|,
name|histindex
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|histindex
operator|>=
literal|0
condition|)
name|printf_filtered
argument_list|(
literal|"$%d = "
argument_list|,
name|histindex
argument_list|)
expr_stmt|;
if|if
condition|(
name|histindex
operator|>=
literal|0
condition|)
name|annotate_value_history_value
argument_list|()
expr_stmt|;
name|print_formatted
argument_list|(
name|val
argument_list|,
name|format
argument_list|,
name|fmt
operator|.
name|size
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|histindex
operator|>=
literal|0
condition|)
name|annotate_value_history_end
argument_list|()
expr_stmt|;
else|else
name|annotate_value_end
argument_list|()
expr_stmt|;
if|if
condition|(
name|inspect
condition|)
name|printf_unfiltered
argument_list|(
literal|"\") )\030"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cleanup
condition|)
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
name|inspect_it
operator|=
literal|0
expr_stmt|;
comment|/* Reset print routines to normal */
block|}
end_function

begin_function
specifier|static
name|void
name|print_command
parameter_list|(
name|char
modifier|*
name|exp
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|print_command_1
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Same as print, except in epoch, it gets its own window */
end_comment

begin_function
specifier|static
name|void
name|inspect_command
parameter_list|(
name|char
modifier|*
name|exp
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
specifier|extern
name|int
name|epoch_interface
decl_stmt|;
name|print_command_1
argument_list|(
name|exp
argument_list|,
name|epoch_interface
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Same as print, except it doesn't print void results. */
end_comment

begin_function
specifier|static
name|void
name|call_command
parameter_list|(
name|char
modifier|*
name|exp
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|print_command_1
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|output_command
parameter_list|(
name|char
modifier|*
name|exp
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|expression
modifier|*
name|expr
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|char
name|format
init|=
literal|0
decl_stmt|;
name|struct
name|value
modifier|*
name|val
decl_stmt|;
name|struct
name|format_data
name|fmt
decl_stmt|;
if|if
condition|(
name|exp
operator|&&
operator|*
name|exp
operator|==
literal|'/'
condition|)
block|{
name|exp
operator|++
expr_stmt|;
name|fmt
operator|=
name|decode_format
argument_list|(
operator|&
name|exp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|validate_format
argument_list|(
name|fmt
argument_list|,
literal|"output"
argument_list|)
expr_stmt|;
name|format
operator|=
name|fmt
operator|.
name|format
expr_stmt|;
block|}
name|expr
operator|=
name|parse_expression
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|free_current_contents
argument_list|,
operator|&
name|expr
argument_list|)
expr_stmt|;
name|val
operator|=
name|evaluate_expression
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|annotate_value_begin
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
name|print_formatted
argument_list|(
name|val
argument_list|,
name|format
argument_list|,
name|fmt
operator|.
name|size
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|annotate_value_end
argument_list|()
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_command
parameter_list|(
name|char
modifier|*
name|exp
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|expression
modifier|*
name|expr
init|=
name|parse_expression
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
init|=
name|make_cleanup
argument_list|(
name|free_current_contents
argument_list|,
operator|&
name|expr
argument_list|)
decl_stmt|;
name|evaluate_expression
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sym_info
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|obj_section
modifier|*
name|osect
decl_stmt|;
name|asection
modifier|*
name|sect
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|,
name|sect_addr
decl_stmt|;
name|int
name|matches
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|offset
decl_stmt|;
if|if
condition|(
operator|!
name|arg
condition|)
name|error_no_arg
argument_list|(
literal|"address"
argument_list|)
expr_stmt|;
name|addr
operator|=
name|parse_and_eval_address
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|ALL_OBJSECTIONS
argument_list|(
argument|objfile
argument_list|,
argument|osect
argument_list|)
block|{
name|sect
operator|=
name|osect
operator|->
name|the_bfd_section
expr_stmt|;
name|sect_addr
operator|=
name|overlay_mapped_address
argument_list|(
name|addr
argument_list|,
name|sect
argument_list|)
expr_stmt|;
if|if
condition|(
name|osect
operator|->
name|addr
operator|<=
name|sect_addr
operator|&&
name|sect_addr
operator|<
name|osect
operator|->
name|endaddr
operator|&&
operator|(
name|msymbol
operator|=
name|lookup_minimal_symbol_by_pc_section
argument_list|(
name|sect_addr
argument_list|,
name|sect
argument_list|)
operator|)
condition|)
block|{
name|matches
operator|=
literal|1
expr_stmt|;
name|offset
operator|=
name|sect_addr
operator|-
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
condition|)
name|printf_filtered
argument_list|(
literal|"%s + %u in "
argument_list|,
name|SYMBOL_PRINT_NAME
argument_list|(
name|msymbol
argument_list|)
argument_list|,
name|offset
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|"%s in "
argument_list|,
name|SYMBOL_PRINT_NAME
argument_list|(
name|msymbol
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pc_in_unmapped_range
argument_list|(
name|addr
argument_list|,
name|sect
argument_list|)
condition|)
name|printf_filtered
argument_list|(
literal|"load address range of "
argument_list|)
expr_stmt|;
if|if
condition|(
name|section_is_overlay
argument_list|(
name|sect
argument_list|)
condition|)
name|printf_filtered
argument_list|(
literal|"%s overlay "
argument_list|,
name|section_is_mapped
argument_list|(
name|sect
argument_list|)
condition|?
literal|"mapped"
else|:
literal|"unmapped"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"section %s"
argument_list|,
name|sect
operator|->
name|name
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|matches
operator|==
literal|0
condition|)
name|printf_filtered
argument_list|(
literal|"No symbol matches %s.\n"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|address_info
parameter_list|(
name|char
modifier|*
name|exp
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
name|long
name|val
decl_stmt|;
name|long
name|basereg
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|CORE_ADDR
name|load_addr
decl_stmt|;
name|int
name|is_a_field_of_this
decl_stmt|;
comment|/* C++: lookup_symbol sets this to nonzero 				   if exp is a field of `this'. */
if|if
condition|(
name|exp
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Argument required."
argument_list|)
expr_stmt|;
name|sym
operator|=
name|lookup_symbol
argument_list|(
name|exp
argument_list|,
name|get_selected_block
argument_list|(
literal|0
argument_list|)
argument_list|,
name|VAR_DOMAIN
argument_list|,
operator|&
name|is_a_field_of_this
argument_list|,
operator|(
expr|struct
name|symtab
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|is_a_field_of_this
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Symbol \""
argument_list|)
expr_stmt|;
name|fprintf_symbol_filtered
argument_list|(
name|gdb_stdout
argument_list|,
name|exp
argument_list|,
name|current_language
operator|->
name|la_language
argument_list|,
name|DMGL_ANSI
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\" is a field of the local class variable "
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_language
operator|->
name|la_language
operator|==
name|language_objc
condition|)
name|printf_filtered
argument_list|(
literal|"`self'\n"
argument_list|)
expr_stmt|;
comment|/* ObjC equivalent of "this" */
else|else
name|printf_filtered
argument_list|(
literal|"`this'\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|msymbol
operator|=
name|lookup_minimal_symbol
argument_list|(
name|exp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|msymbol
operator|!=
name|NULL
condition|)
block|{
name|load_addr
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Symbol \""
argument_list|)
expr_stmt|;
name|fprintf_symbol_filtered
argument_list|(
name|gdb_stdout
argument_list|,
name|exp
argument_list|,
name|current_language
operator|->
name|la_language
argument_list|,
name|DMGL_ANSI
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\" is at "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|load_addr
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" in a file compiled without debugging"
argument_list|)
expr_stmt|;
name|section
operator|=
name|SYMBOL_BFD_SECTION
argument_list|(
name|msymbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|section_is_overlay
argument_list|(
name|section
argument_list|)
condition|)
block|{
name|load_addr
operator|=
name|overlay_unmapped_address
argument_list|(
name|load_addr
argument_list|,
name|section
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|",\n -- loaded at "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|load_addr
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" in overlay section %s"
argument_list|,
name|section
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|".\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"No symbol \"%s\" in current context."
argument_list|,
name|exp
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf_filtered
argument_list|(
literal|"Symbol \""
argument_list|)
expr_stmt|;
name|fprintf_symbol_filtered
argument_list|(
name|gdb_stdout
argument_list|,
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|current_language
operator|->
name|la_language
argument_list|,
name|DMGL_ANSI
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\" is "
argument_list|)
expr_stmt|;
name|val
operator|=
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|basereg
operator|=
name|SYMBOL_BASEREG
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|section
operator|=
name|SYMBOL_BFD_SECTION
argument_list|(
name|sym
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
condition|)
block|{
case|case
name|LOC_CONST
case|:
case|case
name|LOC_CONST_BYTES
case|:
name|printf_filtered
argument_list|(
literal|"constant"
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_LABEL
case|:
name|printf_filtered
argument_list|(
literal|"a label at address "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|load_addr
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym
argument_list|)
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|section_is_overlay
argument_list|(
name|section
argument_list|)
condition|)
block|{
name|load_addr
operator|=
name|overlay_unmapped_address
argument_list|(
name|load_addr
argument_list|,
name|section
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|",\n -- loaded at "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|load_addr
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" in overlay section %s"
argument_list|,
name|section
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LOC_COMPUTED
case|:
case|case
name|LOC_COMPUTED_ARG
case|:
comment|/* FIXME: cagney/2004-01-26: It should be possible to 	 unconditionally call the SYMBOL_OPS method when available. 	 Unfortunately DWARF 2 stores the frame-base (instead of the 	 function) location in a function's symbol.  Oops!  For the 	 moment enable this when/where applicable.  */
name|SYMBOL_OPS
argument_list|(
name|sym
argument_list|)
operator|->
name|describe_location
argument_list|(
name|sym
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_REGISTER
case|:
name|printf_filtered
argument_list|(
literal|"a variable in register %s"
argument_list|,
name|REGISTER_NAME
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_STATIC
case|:
name|printf_filtered
argument_list|(
literal|"static storage at address "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|load_addr
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym
argument_list|)
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|section_is_overlay
argument_list|(
name|section
argument_list|)
condition|)
block|{
name|load_addr
operator|=
name|overlay_unmapped_address
argument_list|(
name|load_addr
argument_list|,
name|section
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|",\n -- loaded at "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|load_addr
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" in overlay section %s"
argument_list|,
name|section
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LOC_INDIRECT
case|:
name|printf_filtered
argument_list|(
literal|"external global (indirect addressing), at address *("
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|load_addr
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym
argument_list|)
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
if|if
condition|(
name|section_is_overlay
argument_list|(
name|section
argument_list|)
condition|)
block|{
name|load_addr
operator|=
name|overlay_unmapped_address
argument_list|(
name|load_addr
argument_list|,
name|section
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|",\n -- loaded at "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|load_addr
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" in overlay section %s"
argument_list|,
name|section
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LOC_REGPARM
case|:
name|printf_filtered
argument_list|(
literal|"an argument in register %s"
argument_list|,
name|REGISTER_NAME
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_REGPARM_ADDR
case|:
name|printf_filtered
argument_list|(
literal|"address of an argument in register %s"
argument_list|,
name|REGISTER_NAME
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_ARG
case|:
name|printf_filtered
argument_list|(
literal|"an argument at offset %ld"
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_LOCAL_ARG
case|:
name|printf_filtered
argument_list|(
literal|"an argument at frame offset %ld"
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_LOCAL
case|:
name|printf_filtered
argument_list|(
literal|"a local variable at frame offset %ld"
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_REF_ARG
case|:
name|printf_filtered
argument_list|(
literal|"a reference argument at offset %ld"
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_BASEREG
case|:
name|printf_filtered
argument_list|(
literal|"a variable at offset %ld from register %s"
argument_list|,
name|val
argument_list|,
name|REGISTER_NAME
argument_list|(
name|basereg
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_BASEREG_ARG
case|:
name|printf_filtered
argument_list|(
literal|"an argument at offset %ld from register %s"
argument_list|,
name|val
argument_list|,
name|REGISTER_NAME
argument_list|(
name|basereg
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_TYPEDEF
case|:
name|printf_filtered
argument_list|(
literal|"a typedef"
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_BLOCK
case|:
name|printf_filtered
argument_list|(
literal|"a function at address "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|load_addr
operator|=
name|BLOCK_START
argument_list|(
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|sym
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|section_is_overlay
argument_list|(
name|section
argument_list|)
condition|)
block|{
name|load_addr
operator|=
name|overlay_unmapped_address
argument_list|(
name|load_addr
argument_list|,
name|section
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|",\n -- loaded at "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|load_addr
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" in overlay section %s"
argument_list|,
name|section
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LOC_UNRESOLVED
case|:
block|{
name|struct
name|minimal_symbol
modifier|*
name|msym
decl_stmt|;
name|msym
operator|=
name|lookup_minimal_symbol
argument_list|(
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|msym
operator|==
name|NULL
condition|)
name|printf_filtered
argument_list|(
literal|"unresolved"
argument_list|)
expr_stmt|;
else|else
block|{
name|section
operator|=
name|SYMBOL_BFD_SECTION
argument_list|(
name|msym
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"static storage at address "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|load_addr
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msym
argument_list|)
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|section_is_overlay
argument_list|(
name|section
argument_list|)
condition|)
block|{
name|load_addr
operator|=
name|overlay_unmapped_address
argument_list|(
name|load_addr
argument_list|,
name|section
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|",\n -- loaded at "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|load_addr
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" in overlay section %s"
argument_list|,
name|section
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|LOC_HP_THREAD_LOCAL_STATIC
case|:
name|printf_filtered
argument_list|(
literal|"a thread-local variable at offset %ld from the thread base register %s"
argument_list|,
name|val
argument_list|,
name|REGISTER_NAME
argument_list|(
name|basereg
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_OPTIMIZED_OUT
case|:
name|printf_filtered
argument_list|(
literal|"optimized out"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf_filtered
argument_list|(
literal|"of unknown (botched) type"
argument_list|)
expr_stmt|;
break|break;
block|}
name|printf_filtered
argument_list|(
literal|".\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|x_command
parameter_list|(
name|char
modifier|*
name|exp
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|expression
modifier|*
name|expr
decl_stmt|;
name|struct
name|format_data
name|fmt
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|struct
name|value
modifier|*
name|val
decl_stmt|;
name|fmt
operator|.
name|format
operator|=
name|last_format
expr_stmt|;
name|fmt
operator|.
name|size
operator|=
name|last_size
expr_stmt|;
name|fmt
operator|.
name|count
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|exp
operator|&&
operator|*
name|exp
operator|==
literal|'/'
condition|)
block|{
name|exp
operator|++
expr_stmt|;
name|fmt
operator|=
name|decode_format
argument_list|(
operator|&
name|exp
argument_list|,
name|last_format
argument_list|,
name|last_size
argument_list|)
expr_stmt|;
block|}
comment|/* If we have an expression, evaluate it and use it as the address.  */
if|if
condition|(
name|exp
operator|!=
literal|0
operator|&&
operator|*
name|exp
operator|!=
literal|0
condition|)
block|{
name|expr
operator|=
name|parse_expression
argument_list|(
name|exp
argument_list|)
expr_stmt|;
comment|/* Cause expression not to be there any more          if this command is repeated with Newline.          But don't clobber a user-defined command's definition.  */
if|if
condition|(
name|from_tty
condition|)
operator|*
name|exp
operator|=
literal|0
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|free_current_contents
argument_list|,
operator|&
name|expr
argument_list|)
expr_stmt|;
name|val
operator|=
name|evaluate_expression
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_REF
condition|)
name|val
operator|=
name|value_ind
argument_list|(
name|val
argument_list|)
expr_stmt|;
comment|/* In rvalue contexts, such as this, functions are coerced into          pointers to functions.  This makes "x/i main" work.  */
if|if
condition|(
comment|/* last_format == 'i'&& */
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_FUNC
operator|&&
name|VALUE_LVAL
argument_list|(
name|val
argument_list|)
operator|==
name|lval_memory
condition|)
name|next_address
operator|=
name|VALUE_ADDRESS
argument_list|(
name|val
argument_list|)
expr_stmt|;
else|else
name|next_address
operator|=
name|value_as_address
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|VALUE_BFD_SECTION
argument_list|(
name|val
argument_list|)
condition|)
name|next_section
operator|=
name|VALUE_BFD_SECTION
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
name|do_examine
argument_list|(
name|fmt
argument_list|,
name|next_address
argument_list|,
name|next_section
argument_list|)
expr_stmt|;
comment|/* If the examine succeeds, we remember its size and format for next time.  */
name|last_size
operator|=
name|fmt
operator|.
name|size
expr_stmt|;
name|last_format
operator|=
name|fmt
operator|.
name|format
expr_stmt|;
comment|/* Set a couple of internal variables if appropriate. */
if|if
condition|(
name|last_examine_value
condition|)
block|{
comment|/* Make last address examined available to the user as $_.  Use          the correct pointer type.  */
name|struct
name|type
modifier|*
name|pointer_type
init|=
name|lookup_pointer_type
argument_list|(
name|VALUE_TYPE
argument_list|(
name|last_examine_value
argument_list|)
argument_list|)
decl_stmt|;
name|set_internalvar
argument_list|(
name|lookup_internalvar
argument_list|(
literal|"_"
argument_list|)
argument_list|,
name|value_from_pointer
argument_list|(
name|pointer_type
argument_list|,
name|last_examine_address
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make contents of last address examined available to the user as $__. */
comment|/* If the last value has not been fetched from memory then don't          fetch it now - instead mark it by voiding the $__ variable. */
if|if
condition|(
name|VALUE_LAZY
argument_list|(
name|last_examine_value
argument_list|)
condition|)
name|set_internalvar
argument_list|(
name|lookup_internalvar
argument_list|(
literal|"__"
argument_list|)
argument_list|,
name|allocate_value
argument_list|(
name|builtin_type_void
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|set_internalvar
argument_list|(
name|lookup_internalvar
argument_list|(
literal|"__"
argument_list|)
argument_list|,
name|last_examine_value
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add an expression to the auto-display chain.    Specify the expression.  */
end_comment

begin_function
specifier|static
name|void
name|display_command
parameter_list|(
name|char
modifier|*
name|exp
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|format_data
name|fmt
decl_stmt|;
name|struct
name|expression
modifier|*
name|expr
decl_stmt|;
name|struct
name|display
modifier|*
name|new
decl_stmt|;
name|int
name|display_it
init|=
literal|1
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TUI
argument_list|)
comment|/* NOTE: cagney/2003-02-13 The `tui_active' was previously      `tui_version'.  */
if|if
condition|(
name|tui_active
operator|&&
name|exp
operator|!=
name|NULL
operator|&&
operator|*
name|exp
operator|==
literal|'$'
condition|)
name|display_it
operator|=
operator|(
name|tui_set_layout_for_display_command
argument_list|(
name|exp
argument_list|)
operator|==
name|TUI_FAILURE
operator|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|display_it
condition|)
block|{
if|if
condition|(
name|exp
operator|==
literal|0
condition|)
block|{
name|do_displays
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|exp
operator|==
literal|'/'
condition|)
block|{
name|exp
operator|++
expr_stmt|;
name|fmt
operator|=
name|decode_format
argument_list|(
operator|&
name|exp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
operator|.
name|size
operator|&&
name|fmt
operator|.
name|format
operator|==
literal|0
condition|)
name|fmt
operator|.
name|format
operator|=
literal|'x'
expr_stmt|;
if|if
condition|(
name|fmt
operator|.
name|format
operator|==
literal|'i'
operator|||
name|fmt
operator|.
name|format
operator|==
literal|'s'
condition|)
name|fmt
operator|.
name|size
operator|=
literal|'b'
expr_stmt|;
block|}
else|else
block|{
name|fmt
operator|.
name|format
operator|=
literal|0
expr_stmt|;
name|fmt
operator|.
name|size
operator|=
literal|0
expr_stmt|;
name|fmt
operator|.
name|count
operator|=
literal|0
expr_stmt|;
block|}
name|innermost_block
operator|=
literal|0
expr_stmt|;
name|expr
operator|=
name|parse_expression
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|new
operator|=
operator|(
expr|struct
name|display
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|display
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|exp
operator|=
name|expr
expr_stmt|;
name|new
operator|->
name|block
operator|=
name|innermost_block
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|display_chain
expr_stmt|;
name|new
operator|->
name|number
operator|=
operator|++
name|display_number
expr_stmt|;
name|new
operator|->
name|format
operator|=
name|fmt
expr_stmt|;
name|new
operator|->
name|enabled_p
operator|=
literal|1
expr_stmt|;
name|display_chain
operator|=
name|new
expr_stmt|;
if|if
condition|(
name|from_tty
operator|&&
name|target_has_execution
condition|)
name|do_one_display
argument_list|(
name|new
argument_list|)
expr_stmt|;
name|dont_repeat
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|free_display
parameter_list|(
name|struct
name|display
modifier|*
name|d
parameter_list|)
block|{
name|xfree
argument_list|(
name|d
operator|->
name|exp
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clear out the display_chain.    Done when new symtabs are loaded, since this invalidates    the types stored in many expressions.  */
end_comment

begin_function
name|void
name|clear_displays
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|display
modifier|*
name|d
decl_stmt|;
while|while
condition|(
operator|(
name|d
operator|=
name|display_chain
operator|)
operator|!=
name|NULL
condition|)
block|{
name|xfree
argument_list|(
name|d
operator|->
name|exp
argument_list|)
expr_stmt|;
name|display_chain
operator|=
name|d
operator|->
name|next
expr_stmt|;
name|xfree
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Delete the auto-display number NUM.  */
end_comment

begin_function
specifier|static
name|void
name|delete_display
parameter_list|(
name|int
name|num
parameter_list|)
block|{
name|struct
name|display
modifier|*
name|d1
decl_stmt|,
modifier|*
name|d
decl_stmt|;
if|if
condition|(
operator|!
name|display_chain
condition|)
name|error
argument_list|(
literal|"No display number %d."
argument_list|,
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
name|display_chain
operator|->
name|number
operator|==
name|num
condition|)
block|{
name|d1
operator|=
name|display_chain
expr_stmt|;
name|display_chain
operator|=
name|d1
operator|->
name|next
expr_stmt|;
name|free_display
argument_list|(
name|d1
argument_list|)
expr_stmt|;
block|}
else|else
for|for
control|(
name|d
operator|=
name|display_chain
init|;
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
block|{
if|if
condition|(
name|d
operator|->
name|next
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No display number %d."
argument_list|,
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|next
operator|->
name|number
operator|==
name|num
condition|)
block|{
name|d1
operator|=
name|d
operator|->
name|next
expr_stmt|;
name|d
operator|->
name|next
operator|=
name|d1
operator|->
name|next
expr_stmt|;
name|free_display
argument_list|(
name|d1
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Delete some values from the auto-display chain.    Specify the element numbers.  */
end_comment

begin_function
specifier|static
name|void
name|undisplay_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|char
modifier|*
name|p
init|=
name|args
decl_stmt|;
name|char
modifier|*
name|p1
decl_stmt|;
name|int
name|num
decl_stmt|;
if|if
condition|(
name|args
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|query
argument_list|(
literal|"Delete all auto-display expressions? "
argument_list|)
condition|)
name|clear_displays
argument_list|()
expr_stmt|;
name|dont_repeat
argument_list|()
expr_stmt|;
return|return;
block|}
while|while
condition|(
operator|*
name|p
condition|)
block|{
name|p1
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p1
operator|>=
literal|'0'
operator|&&
operator|*
name|p1
operator|<=
literal|'9'
condition|)
name|p1
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p1
operator|&&
operator|*
name|p1
operator|!=
literal|' '
operator|&&
operator|*
name|p1
operator|!=
literal|'\t'
condition|)
name|error
argument_list|(
literal|"Arguments must be display numbers."
argument_list|)
expr_stmt|;
name|num
operator|=
name|atoi
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|delete_display
argument_list|(
name|num
argument_list|)
expr_stmt|;
name|p
operator|=
name|p1
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
block|}
name|dont_repeat
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Display a single auto-display.      Do nothing if the display cannot be printed in the current context,    or if the display is disabled. */
end_comment

begin_function
specifier|static
name|void
name|do_one_display
parameter_list|(
name|struct
name|display
modifier|*
name|d
parameter_list|)
block|{
name|int
name|within_current_scope
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|enabled_p
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|d
operator|->
name|block
condition|)
name|within_current_scope
operator|=
name|contained_in
argument_list|(
name|get_selected_block
argument_list|(
literal|0
argument_list|)
argument_list|,
name|d
operator|->
name|block
argument_list|)
expr_stmt|;
else|else
name|within_current_scope
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|within_current_scope
condition|)
return|return;
name|current_display_number
operator|=
name|d
operator|->
name|number
expr_stmt|;
name|annotate_display_begin
argument_list|()
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%d"
argument_list|,
name|d
operator|->
name|number
argument_list|)
expr_stmt|;
name|annotate_display_number_end
argument_list|()
expr_stmt|;
name|printf_filtered
argument_list|(
literal|": "
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|format
operator|.
name|size
condition|)
block|{
name|CORE_ADDR
name|addr
decl_stmt|;
name|struct
name|value
modifier|*
name|val
decl_stmt|;
name|annotate_display_format
argument_list|()
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"x/"
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|format
operator|.
name|count
operator|!=
literal|1
condition|)
name|printf_filtered
argument_list|(
literal|"%d"
argument_list|,
name|d
operator|->
name|format
operator|.
name|count
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%c"
argument_list|,
name|d
operator|->
name|format
operator|.
name|format
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|format
operator|.
name|format
operator|!=
literal|'i'
operator|&&
name|d
operator|->
name|format
operator|.
name|format
operator|!=
literal|'s'
condition|)
name|printf_filtered
argument_list|(
literal|"%c"
argument_list|,
name|d
operator|->
name|format
operator|.
name|size
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|annotate_display_expression
argument_list|()
expr_stmt|;
name|print_expression
argument_list|(
name|d
operator|->
name|exp
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|annotate_display_expression_end
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|format
operator|.
name|count
operator|!=
literal|1
condition|)
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
name|val
operator|=
name|evaluate_expression
argument_list|(
name|d
operator|->
name|exp
argument_list|)
expr_stmt|;
name|addr
operator|=
name|value_as_address
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|format
operator|.
name|format
operator|==
literal|'i'
condition|)
name|addr
operator|=
name|ADDR_BITS_REMOVE
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|annotate_display_value
argument_list|()
expr_stmt|;
name|do_examine
argument_list|(
name|d
operator|->
name|format
argument_list|,
name|addr
argument_list|,
name|VALUE_BFD_SECTION
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|annotate_display_format
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|format
operator|.
name|format
condition|)
name|printf_filtered
argument_list|(
literal|"/%c "
argument_list|,
name|d
operator|->
name|format
operator|.
name|format
argument_list|)
expr_stmt|;
name|annotate_display_expression
argument_list|()
expr_stmt|;
name|print_expression
argument_list|(
name|d
operator|->
name|exp
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|annotate_display_expression_end
argument_list|()
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" = "
argument_list|)
expr_stmt|;
name|annotate_display_expression
argument_list|()
expr_stmt|;
name|print_formatted
argument_list|(
name|evaluate_expression
argument_list|(
name|d
operator|->
name|exp
argument_list|)
argument_list|,
name|d
operator|->
name|format
operator|.
name|format
argument_list|,
name|d
operator|->
name|format
operator|.
name|size
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|annotate_display_end
argument_list|()
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
name|current_display_number
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Display all of the values on the auto-display chain which can be    evaluated in the current scope.  */
end_comment

begin_function
name|void
name|do_displays
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|display
modifier|*
name|d
decl_stmt|;
for|for
control|(
name|d
operator|=
name|display_chain
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
name|do_one_display
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Delete the auto-display which we were in the process of displaying.    This is done when there is an error or a signal.  */
end_comment

begin_function
name|void
name|disable_display
parameter_list|(
name|int
name|num
parameter_list|)
block|{
name|struct
name|display
modifier|*
name|d
decl_stmt|;
for|for
control|(
name|d
operator|=
name|display_chain
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
if|if
condition|(
name|d
operator|->
name|number
operator|==
name|num
condition|)
block|{
name|d
operator|->
name|enabled_p
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|printf_unfiltered
argument_list|(
literal|"No display number %d.\n"
argument_list|,
name|num
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|disable_current_display
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|current_display_number
operator|>=
literal|0
condition|)
block|{
name|disable_display
argument_list|(
name|current_display_number
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Disabling display %d to avoid infinite recursion.\n"
argument_list|,
name|current_display_number
argument_list|)
expr_stmt|;
block|}
name|current_display_number
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|display_info
parameter_list|(
name|char
modifier|*
name|ignore
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|display
modifier|*
name|d
decl_stmt|;
if|if
condition|(
operator|!
name|display_chain
condition|)
name|printf_unfiltered
argument_list|(
literal|"There are no auto-display expressions now.\n"
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|"Auto-display expressions now in effect:\n\ Num Enb Expression\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|d
operator|=
name|display_chain
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
block|{
name|printf_filtered
argument_list|(
literal|"%d:   %c  "
argument_list|,
name|d
operator|->
name|number
argument_list|,
literal|"ny"
index|[
operator|(
name|int
operator|)
name|d
operator|->
name|enabled_p
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|format
operator|.
name|size
condition|)
name|printf_filtered
argument_list|(
literal|"/%d%c%c "
argument_list|,
name|d
operator|->
name|format
operator|.
name|count
argument_list|,
name|d
operator|->
name|format
operator|.
name|size
argument_list|,
name|d
operator|->
name|format
operator|.
name|format
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|d
operator|->
name|format
operator|.
name|format
condition|)
name|printf_filtered
argument_list|(
literal|"/%c "
argument_list|,
name|d
operator|->
name|format
operator|.
name|format
argument_list|)
expr_stmt|;
name|print_expression
argument_list|(
name|d
operator|->
name|exp
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|block
operator|&&
operator|!
name|contained_in
argument_list|(
name|get_selected_block
argument_list|(
literal|0
argument_list|)
argument_list|,
name|d
operator|->
name|block
argument_list|)
condition|)
name|printf_filtered
argument_list|(
literal|" (cannot be evaluated in the current context)"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|enable_display
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|char
modifier|*
name|p
init|=
name|args
decl_stmt|;
name|char
modifier|*
name|p1
decl_stmt|;
name|int
name|num
decl_stmt|;
name|struct
name|display
modifier|*
name|d
decl_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|d
operator|=
name|display_chain
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
name|d
operator|->
name|enabled_p
operator|=
literal|1
expr_stmt|;
block|}
else|else
while|while
condition|(
operator|*
name|p
condition|)
block|{
name|p1
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p1
operator|>=
literal|'0'
operator|&&
operator|*
name|p1
operator|<=
literal|'9'
condition|)
name|p1
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p1
operator|&&
operator|*
name|p1
operator|!=
literal|' '
operator|&&
operator|*
name|p1
operator|!=
literal|'\t'
condition|)
name|error
argument_list|(
literal|"Arguments must be display numbers."
argument_list|)
expr_stmt|;
name|num
operator|=
name|atoi
argument_list|(
name|p
argument_list|)
expr_stmt|;
for|for
control|(
name|d
operator|=
name|display_chain
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
if|if
condition|(
name|d
operator|->
name|number
operator|==
name|num
condition|)
block|{
name|d
operator|->
name|enabled_p
operator|=
literal|1
expr_stmt|;
goto|goto
name|win
goto|;
block|}
name|printf_unfiltered
argument_list|(
literal|"No display number %d.\n"
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|win
label|:
name|p
operator|=
name|p1
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|disable_display_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|char
modifier|*
name|p
init|=
name|args
decl_stmt|;
name|char
modifier|*
name|p1
decl_stmt|;
name|struct
name|display
modifier|*
name|d
decl_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|d
operator|=
name|display_chain
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
name|d
operator|->
name|enabled_p
operator|=
literal|0
expr_stmt|;
block|}
else|else
while|while
condition|(
operator|*
name|p
condition|)
block|{
name|p1
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p1
operator|>=
literal|'0'
operator|&&
operator|*
name|p1
operator|<=
literal|'9'
condition|)
name|p1
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p1
operator|&&
operator|*
name|p1
operator|!=
literal|' '
operator|&&
operator|*
name|p1
operator|!=
literal|'\t'
condition|)
name|error
argument_list|(
literal|"Arguments must be display numbers."
argument_list|)
expr_stmt|;
name|disable_display
argument_list|(
name|atoi
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|p1
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print the value in stack frame FRAME of a variable    specified by a struct symbol.  */
end_comment

begin_function
name|void
name|print_variable_value
parameter_list|(
name|struct
name|symbol
modifier|*
name|var
parameter_list|,
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|)
block|{
name|struct
name|value
modifier|*
name|val
init|=
name|read_var_value
argument_list|(
name|var
argument_list|,
name|frame
argument_list|)
decl_stmt|;
name|value_print
argument_list|(
name|val
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
name|Val_pretty_default
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|printf_command
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|char
modifier|*
name|f
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|s
init|=
name|arg
decl_stmt|;
name|char
modifier|*
name|string
init|=
name|NULL
decl_stmt|;
name|struct
name|value
modifier|*
modifier|*
name|val_args
decl_stmt|;
name|char
modifier|*
name|substrings
decl_stmt|;
name|char
modifier|*
name|current_substring
decl_stmt|;
name|int
name|nargs
init|=
literal|0
decl_stmt|;
name|int
name|allocated_args
init|=
literal|20
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_cleanups
decl_stmt|;
name|val_args
operator|=
operator|(
expr|struct
name|value
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|allocated_args
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|value
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|old_cleanups
operator|=
name|make_cleanup
argument_list|(
name|free_current_contents
argument_list|,
operator|&
name|val_args
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
literal|0
condition|)
name|error_no_arg
argument_list|(
literal|"format-control string and values to print"
argument_list|)
expr_stmt|;
comment|/* Skip white space before format string */
while|while
condition|(
operator|*
name|s
operator|==
literal|' '
operator|||
operator|*
name|s
operator|==
literal|'\t'
condition|)
name|s
operator|++
expr_stmt|;
comment|/* A format string should follow, enveloped in double quotes */
if|if
condition|(
operator|*
name|s
operator|++
operator|!=
literal|'"'
condition|)
name|error
argument_list|(
literal|"Bad format string, missing '\"'."
argument_list|)
expr_stmt|;
comment|/* Parse the format-control string and copy it into the string STRING,      processing some kinds of escape sequence.  */
name|f
operator|=
name|string
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|!=
literal|'"'
condition|)
block|{
name|int
name|c
init|=
operator|*
name|s
operator|++
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\0'
case|:
name|error
argument_list|(
literal|"Bad format string, non-terminated '\"'."
argument_list|)
expr_stmt|;
case|case
literal|'\\'
case|:
switch|switch
condition|(
name|c
operator|=
operator|*
name|s
operator|++
condition|)
block|{
case|case
literal|'\\'
case|:
operator|*
name|f
operator|++
operator|=
literal|'\\'
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
operator|*
name|f
operator|++
operator|=
literal|'\a'
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
operator|*
name|f
operator|++
operator|=
literal|'\b'
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
operator|*
name|f
operator|++
operator|=
literal|'\f'
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
operator|*
name|f
operator|++
operator|=
literal|'\n'
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
operator|*
name|f
operator|++
operator|=
literal|'\r'
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
operator|*
name|f
operator|++
operator|=
literal|'\t'
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
operator|*
name|f
operator|++
operator|=
literal|'\v'
expr_stmt|;
break|break;
case|case
literal|'"'
case|:
operator|*
name|f
operator|++
operator|=
literal|'"'
expr_stmt|;
break|break;
default|default:
comment|/* ??? TODO: handle other escape sequences */
name|error
argument_list|(
literal|"Unrecognized escape character \\%c in format string."
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
operator|*
name|f
operator|++
operator|=
name|c
expr_stmt|;
block|}
block|}
comment|/* Skip over " and following space and comma.  */
name|s
operator|++
expr_stmt|;
operator|*
name|f
operator|++
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|==
literal|' '
operator|||
operator|*
name|s
operator|==
literal|'\t'
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|','
operator|&&
operator|*
name|s
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|"Invalid argument syntax"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|','
condition|)
name|s
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|==
literal|' '
operator|||
operator|*
name|s
operator|==
literal|'\t'
condition|)
name|s
operator|++
expr_stmt|;
comment|/* Need extra space for the '\0's.  Doubling the size is sufficient.  */
name|substrings
operator|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|string
argument_list|)
operator|*
literal|2
argument_list|)
expr_stmt|;
name|current_substring
operator|=
name|substrings
expr_stmt|;
block|{
comment|/* Now scan the string for %-specs and see what kinds of args they want.        argclass[I] classifies the %-specs so we can give printf_filtered        something of the right size.  */
enum|enum
name|argclass
block|{
name|no_arg
block|,
name|int_arg
block|,
name|string_arg
block|,
name|double_arg
block|,
name|long_long_arg
block|}
enum|;
name|enum
name|argclass
modifier|*
name|argclass
decl_stmt|;
name|enum
name|argclass
name|this_argclass
decl_stmt|;
name|char
modifier|*
name|last_arg
decl_stmt|;
name|int
name|nargs_wanted
decl_stmt|;
name|int
name|lcount
decl_stmt|;
name|int
name|i
decl_stmt|;
name|argclass
operator|=
operator|(
expr|enum
name|argclass
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|*
sizeof|sizeof
expr|*
name|argclass
argument_list|)
expr_stmt|;
name|nargs_wanted
operator|=
literal|0
expr_stmt|;
name|f
operator|=
name|string
expr_stmt|;
name|last_arg
operator|=
name|string
expr_stmt|;
while|while
condition|(
operator|*
name|f
condition|)
if|if
condition|(
operator|*
name|f
operator|++
operator|==
literal|'%'
condition|)
block|{
name|lcount
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|strchr
argument_list|(
literal|"0123456789.hlL-+ #"
argument_list|,
operator|*
name|f
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|f
operator|==
literal|'l'
operator|||
operator|*
name|f
operator|==
literal|'L'
condition|)
name|lcount
operator|++
expr_stmt|;
name|f
operator|++
expr_stmt|;
block|}
switch|switch
condition|(
operator|*
name|f
condition|)
block|{
case|case
literal|'s'
case|:
name|this_argclass
operator|=
name|string_arg
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
case|case
literal|'f'
case|:
case|case
literal|'g'
case|:
name|this_argclass
operator|=
name|double_arg
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
name|error
argument_list|(
literal|"`*' not supported for precision or width in printf"
argument_list|)
expr_stmt|;
case|case
literal|'n'
case|:
name|error
argument_list|(
literal|"Format specifier `n' not supported in printf"
argument_list|)
expr_stmt|;
case|case
literal|'%'
case|:
name|this_argclass
operator|=
name|no_arg
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|lcount
operator|>
literal|1
condition|)
name|this_argclass
operator|=
name|long_long_arg
expr_stmt|;
else|else
name|this_argclass
operator|=
name|int_arg
expr_stmt|;
break|break;
block|}
name|f
operator|++
expr_stmt|;
if|if
condition|(
name|this_argclass
operator|!=
name|no_arg
condition|)
block|{
name|strncpy
argument_list|(
name|current_substring
argument_list|,
name|last_arg
argument_list|,
name|f
operator|-
name|last_arg
argument_list|)
expr_stmt|;
name|current_substring
operator|+=
name|f
operator|-
name|last_arg
expr_stmt|;
operator|*
name|current_substring
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|last_arg
operator|=
name|f
expr_stmt|;
name|argclass
index|[
name|nargs_wanted
operator|++
index|]
operator|=
name|this_argclass
expr_stmt|;
block|}
block|}
comment|/* Now, parse all arguments and evaluate them.        Store the VALUEs in VAL_ARGS.  */
while|while
condition|(
operator|*
name|s
operator|!=
literal|'\0'
condition|)
block|{
name|char
modifier|*
name|s1
decl_stmt|;
if|if
condition|(
name|nargs
operator|==
name|allocated_args
condition|)
name|val_args
operator|=
operator|(
expr|struct
name|value
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|val_args
argument_list|,
operator|(
name|allocated_args
operator|*=
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|value
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|s1
operator|=
name|s
expr_stmt|;
name|val_args
index|[
name|nargs
index|]
operator|=
name|parse_to_comma_and_eval
argument_list|(
operator|&
name|s1
argument_list|)
expr_stmt|;
comment|/* If format string wants a float, unchecked-convert the value to 	   floating point of the same size */
if|if
condition|(
name|argclass
index|[
name|nargs
index|]
operator|==
name|double_arg
condition|)
block|{
name|struct
name|type
modifier|*
name|type
init|=
name|VALUE_TYPE
argument_list|(
name|val_args
index|[
name|nargs
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|float
argument_list|)
condition|)
name|VALUE_TYPE
argument_list|(
name|val_args
index|[
name|nargs
index|]
argument_list|)
operator|=
name|builtin_type_float
expr_stmt|;
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|double
argument_list|)
condition|)
name|VALUE_TYPE
argument_list|(
name|val_args
index|[
name|nargs
index|]
argument_list|)
operator|=
name|builtin_type_double
expr_stmt|;
block|}
name|nargs
operator|++
expr_stmt|;
name|s
operator|=
name|s1
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|','
condition|)
name|s
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|nargs
operator|!=
name|nargs_wanted
condition|)
name|error
argument_list|(
literal|"Wrong number of arguments for specified format-string"
argument_list|)
expr_stmt|;
comment|/* Now actually print them.  */
name|current_substring
operator|=
name|substrings
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nargs
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|argclass
index|[
name|i
index|]
condition|)
block|{
case|case
name|string_arg
case|:
block|{
name|char
modifier|*
name|str
decl_stmt|;
name|CORE_ADDR
name|tem
decl_stmt|;
name|int
name|j
decl_stmt|;
name|tem
operator|=
name|value_as_address
argument_list|(
name|val_args
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* This is a %s argument.  Find the length of the string.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
condition|;
name|j
operator|++
control|)
block|{
name|char
name|c
decl_stmt|;
name|QUIT
expr_stmt|;
name|read_memory
argument_list|(
name|tem
operator|+
name|j
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
break|break;
block|}
comment|/* Copy the string contents into a string inside GDB.  */
name|str
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|j
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|!=
literal|0
condition|)
name|read_memory
argument_list|(
name|tem
argument_list|,
name|str
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|str
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
name|printf_filtered
argument_list|(
name|current_substring
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|double_arg
case|:
block|{
name|double
name|val
init|=
name|value_as_double
argument_list|(
name|val_args
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|printf_filtered
argument_list|(
name|current_substring
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|long_long_arg
case|:
if|#
directive|if
name|defined
argument_list|(
name|CC_HAS_LONG_LONG
argument_list|)
operator|&&
name|defined
argument_list|(
name|PRINTF_HAS_LONG_LONG
argument_list|)
block|{
name|long
name|long
name|val
init|=
name|value_as_long
argument_list|(
name|val_args
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|printf_filtered
argument_list|(
name|current_substring
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
block|}
else|#
directive|else
name|error
argument_list|(
literal|"long long not supported in printf"
argument_list|)
expr_stmt|;
endif|#
directive|endif
case|case
name|int_arg
case|:
block|{
comment|/* FIXME: there should be separate int_arg and long_arg.  */
name|long
name|val
init|=
name|value_as_long
argument_list|(
name|val_args
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|printf_filtered
argument_list|(
name|current_substring
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
comment|/* purecov: deadcode */
name|error
argument_list|(
literal|"internal error in printf_command"
argument_list|)
expr_stmt|;
comment|/* purecov: deadcode */
block|}
comment|/* Skip to the next substring.  */
name|current_substring
operator|+=
name|strlen
argument_list|(
name|current_substring
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
comment|/* Print the portion of the format string after the last argument.  */
name|puts_filtered
argument_list|(
name|last_arg
argument_list|)
expr_stmt|;
block|}
name|do_cleanups
argument_list|(
name|old_cleanups
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_initialize_printcmd
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
name|current_display_number
operator|=
operator|-
literal|1
expr_stmt|;
name|add_info
argument_list|(
literal|"address"
argument_list|,
name|address_info
argument_list|,
literal|"Describe where symbol SYM is stored."
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"symbol"
argument_list|,
name|sym_info
argument_list|,
literal|"Describe what symbol is at location ADDR.\n\ Only for symbols with fixed locations (global or static scope)."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"x"
argument_list|,
name|class_vars
argument_list|,
name|x_command
argument_list|,
name|concat
argument_list|(
literal|"Examine memory: x/FMT ADDRESS.\n\ ADDRESS is an expression for the memory address to examine.\n\ FMT is a repeat count followed by a format letter and a size letter.\n\ Format letters are o(octal), x(hex), d(decimal), u(unsigned decimal),\n\   t(binary), f(float), a(address), i(instruction), c(char) and s(string).\n"
argument_list|,
literal|"Size letters are b(byte), h(halfword), w(word), g(giant, 8 bytes).\n\ The specified number of objects of the specified size are printed\n\ according to the format.\n\n\ Defaults for format and size letters are those previously used.\n\ Default count is 1.  Default address is following last thing printed\n\ with this command or \"print\"."
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|add_com ("whereis", class_vars, whereis_command, 	   "Print line number and file of definition of variable.");
endif|#
directive|endif
name|add_info
argument_list|(
literal|"display"
argument_list|,
name|display_info
argument_list|,
literal|"Expressions to display when program stops, with code numbers."
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"undisplay"
argument_list|,
name|class_vars
argument_list|,
name|undisplay_command
argument_list|,
literal|"Cancel some expressions to be displayed when program stops.\n\ Arguments are the code numbers of the expressions to stop displaying.\n\ No argument means cancel all automatic-display expressions.\n\ \"delete display\" has the same effect as this command.\n\ Do \"info display\" to see current list of code numbers."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"display"
argument_list|,
name|class_vars
argument_list|,
name|display_command
argument_list|,
literal|"Print value of expression EXP each time the program stops.\n\ /FMT may be used before EXP as in the \"print\" command.\n\ /FMT \"i\" or \"s\" or including a size-letter is allowed,\n\ as in the \"x\" command, and then EXP is used to get the address to examine\n\ and examining is done as in the \"x\" command.\n\n\ With no argument, display all currently requested auto-display expressions.\n\ Use \"undisplay\" to cancel display requests previously made."
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"display"
argument_list|,
name|class_vars
argument_list|,
name|enable_display
argument_list|,
literal|"Enable some expressions to be displayed when program stops.\n\ Arguments are the code numbers of the expressions to resume displaying.\n\ No argument means enable all automatic-display expressions.\n\ Do \"info display\" to see current list of code numbers."
argument_list|,
operator|&
name|enablelist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"display"
argument_list|,
name|class_vars
argument_list|,
name|disable_display_command
argument_list|,
literal|"Disable some expressions to be displayed when program stops.\n\ Arguments are the code numbers of the expressions to stop displaying.\n\ No argument means disable all automatic-display expressions.\n\ Do \"info display\" to see current list of code numbers."
argument_list|,
operator|&
name|disablelist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"display"
argument_list|,
name|class_vars
argument_list|,
name|undisplay_command
argument_list|,
literal|"Cancel some expressions to be displayed when program stops.\n\ Arguments are the code numbers of the expressions to stop displaying.\n\ No argument means cancel all automatic-display expressions.\n\ Do \"info display\" to see current list of code numbers."
argument_list|,
operator|&
name|deletelist
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"printf"
argument_list|,
name|class_vars
argument_list|,
name|printf_command
argument_list|,
literal|"printf \"printf format string\", arg1, arg2, arg3, ..., argn\n\ This is useful for formatted output in user-defined commands."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"output"
argument_list|,
name|class_vars
argument_list|,
name|output_command
argument_list|,
literal|"Like \"print\" but don't put in value history and don't print newline.\n\ This is useful in user-defined commands."
argument_list|)
expr_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"set"
argument_list|,
name|class_vars
argument_list|,
name|set_command
argument_list|,
name|concat
argument_list|(
literal|"Evaluate expression EXP and assign result to variable VAR, using assignment\n\ syntax appropriate for the current language (VAR = EXP or VAR := EXP for\n\ example).  VAR may be a debugger \"convenience\" variable (names starting\n\ with $), a register (a few standard names starting with $), or an actual\n\ variable in the program being debugged.  EXP is any valid expression.\n"
argument_list|,
literal|"Use \"set variable\" for variables with names identical to set subcommands.\n\ \nWith a subcommand, this command modifies parts of the gdb environment.\n\ You can see these environment settings with the \"show\" command."
argument_list|,
name|NULL
argument_list|)
argument_list|,
operator|&
name|setlist
argument_list|,
literal|"set "
argument_list|,
literal|1
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbx_commands
condition|)
name|add_com
argument_list|(
literal|"assign"
argument_list|,
name|class_vars
argument_list|,
name|set_command
argument_list|,
name|concat
argument_list|(
literal|"Evaluate expression \ EXP and assign result to variable VAR, using assignment\n\ syntax appropriate for the current language (VAR = EXP or VAR := EXP for\n\ example).  VAR may be a debugger \"convenience\" variable (names starting\n\ with $), a register (a few standard names starting with $), or an actual\n\ variable in the program being debugged.  EXP is any valid expression.\n"
argument_list|,
literal|"Use \"set variable\" for variables with names identical to set subcommands.\n\ \nWith a subcommand, this command modifies parts of the gdb environment.\n\ You can see these environment settings with the \"show\" command."
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
comment|/* "call" is the same as "set", but handy for dbx users to call fns. */
name|c
operator|=
name|add_com
argument_list|(
literal|"call"
argument_list|,
name|class_vars
argument_list|,
name|call_command
argument_list|,
literal|"Call a function in the program.\n\ The argument is the function name and arguments, in the notation of the\n\ current working language.  The result is printed and saved in the value\n\ history, if it is not void."
argument_list|)
expr_stmt|;
name|set_cmd_completer
argument_list|(
name|c
argument_list|,
name|location_completer
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"variable"
argument_list|,
name|class_vars
argument_list|,
name|set_command
argument_list|,
literal|"Evaluate expression EXP and assign result to variable VAR, using assignment\n\ syntax appropriate for the current language (VAR = EXP or VAR := EXP for\n\ example).  VAR may be a debugger \"convenience\" variable (names starting\n\ with $), a register (a few standard names starting with $), or an actual\n\ variable in the program being debugged.  EXP is any valid expression.\n\ This may usually be abbreviated to simply \"set\"."
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|c
operator|=
name|add_com
argument_list|(
literal|"print"
argument_list|,
name|class_vars
argument_list|,
name|print_command
argument_list|,
name|concat
argument_list|(
literal|"Print value of expression EXP.\n\ Variables accessible are those of the lexical environment of the selected\n\ stack frame, plus all those whose scope is global or an entire file.\n\ \n\ $NUM gets previous value number NUM.  $ and $$ are the last two values.\n\ $$NUM refers to NUM'th value back from the last one.\n\ Names starting with $ refer to registers (with the values they would have\n"
argument_list|,
literal|"if the program were to return to the stack frame now selected, restoring\n\ all registers saved by frames farther in) or else to debugger\n\ \"convenience\" variables (any such name not a known register).\n\ Use assignment expressions to give values to convenience variables.\n"
argument_list|,
literal|"\n\ {TYPE}ADREXP refers to a datum of data type TYPE, located at address ADREXP.\n\ @ is a binary operator for treating consecutive data objects\n\ anywhere in memory as an array.  FOO@NUM gives an array whose first\n\ element is FOO, whose second element is stored in the space following\n\ where FOO is stored, etc.  FOO must be an expression whose value\n\ resides in memory.\n"
argument_list|,
literal|"\n\ EXP may be preceded with /FMT, where FMT is a format letter\n\ but no count or size letter (see \"x\" command)."
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|set_cmd_completer
argument_list|(
name|c
argument_list|,
name|location_completer
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"p"
argument_list|,
literal|"print"
argument_list|,
name|class_vars
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|c
operator|=
name|add_com
argument_list|(
literal|"inspect"
argument_list|,
name|class_vars
argument_list|,
name|inspect_command
argument_list|,
literal|"Same as \"print\" command, except that if you are running in the epoch\n\ environment, the value is printed in its own window."
argument_list|)
expr_stmt|;
name|set_cmd_completer
argument_list|(
name|c
argument_list|,
name|location_completer
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"max-symbolic-offset"
argument_list|,
name|no_class
argument_list|,
name|var_uinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|max_symbolic_offset
argument_list|,
literal|"Set the largest offset that will be printed in<symbol+1234> form."
argument_list|,
operator|&
name|setprintlist
argument_list|)
argument_list|,
operator|&
name|showprintlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"symbol-filename"
argument_list|,
name|no_class
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|print_symbol_filename
argument_list|,
literal|"Set printing of source filename and line number with<symbol>."
argument_list|,
operator|&
name|setprintlist
argument_list|)
argument_list|,
operator|&
name|showprintlist
argument_list|)
expr_stmt|;
comment|/* For examine/instruction a single byte quantity is specified as      the data.  This avoids problems with value_at_lazy() requiring a      valid data type (and rejecting VOID). */
name|examine_i_type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"examine_i_type"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|examine_b_type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"examine_b_type"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|examine_h_type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"examine_h_type"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|examine_w_type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
literal|"examine_w_type"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|examine_g_type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|8
argument_list|,
literal|0
argument_list|,
literal|"examine_g_type"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

