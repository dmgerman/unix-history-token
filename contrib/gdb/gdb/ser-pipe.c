begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Serial interface for a pipe to a separate program    Copyright 1999, 2000, 2001 Free Software Foundation, Inc.     Contributed by Cygnus Solutions.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"serial.h"
end_include

begin_include
include|#
directive|include
file|"ser-unix.h"
end_include

begin_include
include|#
directive|include
file|"gdb_vfork.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_function_decl
specifier|static
name|int
name|pipe_open
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pipe_close
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|_initialize_ser_pipe
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_struct
struct|struct
name|pipe_state
block|{
name|int
name|pid
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Open up a raw pipe */
end_comment

begin_function
specifier|static
name|int
name|pipe_open
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|#
directive|if
operator|!
name|HAVE_SOCKETPAIR
return|return
operator|-
literal|1
return|;
else|#
directive|else
name|struct
name|pipe_state
modifier|*
name|state
decl_stmt|;
comment|/* This chunk: */
comment|/* Copyright (c) 1988, 1993    *      The Regents of the University of California.  All rights reserved.    *    * This code is derived from software written by Ken Arnold and    * published in UNIX Review, Vol. 6, No. 8.    */
name|int
name|pdes
index|[
literal|2
index|]
decl_stmt|;
name|int
name|pid
decl_stmt|;
if|if
condition|(
name|socketpair
argument_list|(
name|AF_UNIX
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|,
name|pdes
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Create the child process to run the command in.  Note that the      apparent call to vfork() below *might* actually be a call to      fork() due to the fact that autoconf will ``#define vfork fork''      on certain platforms.  */
name|pid
operator|=
name|vfork
argument_list|()
expr_stmt|;
comment|/* Error. */
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
block|{
name|close
argument_list|(
name|pdes
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pdes
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Child. */
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
comment|/* re-wire pdes[1] to stdin/stdout */
name|close
argument_list|(
name|pdes
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|pdes
index|[
literal|1
index|]
operator|!=
name|STDOUT_FILENO
condition|)
block|{
name|dup2
argument_list|(
name|pdes
index|[
literal|1
index|]
argument_list|,
name|STDOUT_FILENO
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pdes
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|dup2
argument_list|(
name|STDOUT_FILENO
argument_list|,
name|STDIN_FILENO
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* close any stray FD's - FIXME - how? */
comment|/* POSIX.2 B.3.2.2 "popen() shall ensure that any streams          from previous popen() calls that remain open in the           parent process are closed in the new child process. */
block|for (old = pidlist; old; old = old->next) 	close (fileno (old->fp));
comment|/* don't allow a flush */
endif|#
directive|endif
name|execl
argument_list|(
literal|"/bin/sh"
argument_list|,
literal|"sh"
argument_list|,
literal|"-c"
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|127
argument_list|)
expr_stmt|;
block|}
comment|/* Parent. */
name|close
argument_list|(
name|pdes
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* :end chunk */
name|state
operator|=
name|XMALLOC
argument_list|(
expr|struct
name|pipe_state
argument_list|)
expr_stmt|;
name|state
operator|->
name|pid
operator|=
name|pid
expr_stmt|;
name|scb
operator|->
name|fd
operator|=
name|pdes
index|[
literal|0
index|]
expr_stmt|;
name|scb
operator|->
name|state
operator|=
name|state
expr_stmt|;
comment|/* If we don't do this, GDB simply exits when the remote side dies.  */
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|pipe_close
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|)
block|{
name|struct
name|pipe_state
modifier|*
name|state
init|=
name|scb
operator|->
name|state
decl_stmt|;
if|if
condition|(
name|state
operator|!=
name|NULL
condition|)
block|{
name|int
name|pid
init|=
name|state
operator|->
name|pid
decl_stmt|;
name|close
argument_list|(
name|scb
operator|->
name|fd
argument_list|)
expr_stmt|;
name|scb
operator|->
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
name|xfree
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|scb
operator|->
name|state
operator|=
name|NULL
expr_stmt|;
name|kill
argument_list|(
name|pid
argument_list|,
name|SIGTERM
argument_list|)
expr_stmt|;
comment|/* Might be useful to check that the child does die. */
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|serial_ops
name|pipe_ops
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|_initialize_ser_pipe
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|serial_ops
modifier|*
name|ops
init|=
name|XMALLOC
argument_list|(
expr|struct
name|serial_ops
argument_list|)
decl_stmt|;
name|memset
argument_list|(
name|ops
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|serial_ops
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ops
operator|->
name|name
operator|=
literal|"pipe"
expr_stmt|;
name|ops
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|ops
operator|->
name|open
operator|=
name|pipe_open
expr_stmt|;
name|ops
operator|->
name|close
operator|=
name|pipe_close
expr_stmt|;
name|ops
operator|->
name|readchar
operator|=
name|ser_unix_readchar
expr_stmt|;
name|ops
operator|->
name|write
operator|=
name|ser_unix_write
expr_stmt|;
name|ops
operator|->
name|flush_output
operator|=
name|ser_unix_nop_flush_output
expr_stmt|;
name|ops
operator|->
name|flush_input
operator|=
name|ser_unix_flush_input
expr_stmt|;
name|ops
operator|->
name|send_break
operator|=
name|ser_unix_nop_send_break
expr_stmt|;
name|ops
operator|->
name|go_raw
operator|=
name|ser_unix_nop_raw
expr_stmt|;
name|ops
operator|->
name|get_tty_state
operator|=
name|ser_unix_nop_get_tty_state
expr_stmt|;
name|ops
operator|->
name|set_tty_state
operator|=
name|ser_unix_nop_set_tty_state
expr_stmt|;
name|ops
operator|->
name|print_tty_state
operator|=
name|ser_unix_nop_print_tty_state
expr_stmt|;
name|ops
operator|->
name|noflush_set_tty_state
operator|=
name|ser_unix_nop_noflush_set_tty_state
expr_stmt|;
name|ops
operator|->
name|setbaudrate
operator|=
name|ser_unix_nop_setbaudrate
expr_stmt|;
name|ops
operator|->
name|setstopbits
operator|=
name|ser_unix_nop_setstopbits
expr_stmt|;
name|ops
operator|->
name|drain_output
operator|=
name|ser_unix_nop_drain_output
expr_stmt|;
name|ops
operator|->
name|async
operator|=
name|ser_unix_async
expr_stmt|;
name|serial_add_interface
argument_list|(
name|ops
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

