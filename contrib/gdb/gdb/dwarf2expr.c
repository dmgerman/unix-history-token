begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Dwarf2 Expression Evaluator    Copyright 2001, 2002, 2003 Free Software Foundation, Inc.    Contributed by Daniel Berlin (dan@dberlin.org)     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"elf/dwarf2.h"
end_include

begin_include
include|#
directive|include
file|"dwarf2expr.h"
end_include

begin_comment
comment|/* Local prototypes.  */
end_comment

begin_function_decl
specifier|static
name|void
name|execute_stack_op
parameter_list|(
name|struct
name|dwarf_expr_context
modifier|*
parameter_list|,
name|unsigned
name|char
modifier|*
parameter_list|,
name|unsigned
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Create a new context for the expression evaluator.  */
end_comment

begin_function
name|struct
name|dwarf_expr_context
modifier|*
name|new_dwarf_expr_context
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|dwarf_expr_context
modifier|*
name|retval
decl_stmt|;
name|retval
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dwarf_expr_context
argument_list|)
argument_list|)
expr_stmt|;
name|retval
operator|->
name|stack_len
operator|=
literal|0
expr_stmt|;
name|retval
operator|->
name|stack_allocated
operator|=
literal|10
expr_stmt|;
name|retval
operator|->
name|stack
operator|=
name|xmalloc
argument_list|(
name|retval
operator|->
name|stack_allocated
operator|*
sizeof|sizeof
argument_list|(
name|CORE_ADDR
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Release the memory allocated to CTX.  */
end_comment

begin_function
name|void
name|free_dwarf_expr_context
parameter_list|(
name|struct
name|dwarf_expr_context
modifier|*
name|ctx
parameter_list|)
block|{
name|xfree
argument_list|(
name|ctx
operator|->
name|stack
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Expand the memory allocated to CTX's stack to contain at least    NEED more elements than are currently used.  */
end_comment

begin_function
specifier|static
name|void
name|dwarf_expr_grow_stack
parameter_list|(
name|struct
name|dwarf_expr_context
modifier|*
name|ctx
parameter_list|,
name|size_t
name|need
parameter_list|)
block|{
if|if
condition|(
name|ctx
operator|->
name|stack_len
operator|+
name|need
operator|>
name|ctx
operator|->
name|stack_allocated
condition|)
block|{
name|size_t
name|newlen
init|=
name|ctx
operator|->
name|stack_len
operator|+
name|need
operator|+
literal|10
decl_stmt|;
name|ctx
operator|->
name|stack
operator|=
name|xrealloc
argument_list|(
name|ctx
operator|->
name|stack
argument_list|,
name|newlen
operator|*
sizeof|sizeof
argument_list|(
name|CORE_ADDR
argument_list|)
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|stack_allocated
operator|=
name|newlen
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Push VALUE onto CTX's stack.  */
end_comment

begin_function
name|void
name|dwarf_expr_push
parameter_list|(
name|struct
name|dwarf_expr_context
modifier|*
name|ctx
parameter_list|,
name|CORE_ADDR
name|value
parameter_list|)
block|{
name|dwarf_expr_grow_stack
argument_list|(
name|ctx
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|stack
index|[
name|ctx
operator|->
name|stack_len
operator|++
index|]
operator|=
name|value
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pop the top item off of CTX's stack.  */
end_comment

begin_function
name|void
name|dwarf_expr_pop
parameter_list|(
name|struct
name|dwarf_expr_context
modifier|*
name|ctx
parameter_list|)
block|{
if|if
condition|(
name|ctx
operator|->
name|stack_len
operator|<=
literal|0
condition|)
name|error
argument_list|(
literal|"dwarf expression stack underflow"
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|stack_len
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Retrieve the N'th item on CTX's stack.  */
end_comment

begin_function
name|CORE_ADDR
name|dwarf_expr_fetch
parameter_list|(
name|struct
name|dwarf_expr_context
modifier|*
name|ctx
parameter_list|,
name|int
name|n
parameter_list|)
block|{
if|if
condition|(
name|ctx
operator|->
name|stack_len
operator|<
name|n
condition|)
name|error
argument_list|(
literal|"Asked for position %d of stack, stack only has %d elements on it\n"
argument_list|,
name|n
argument_list|,
name|ctx
operator|->
name|stack_len
argument_list|)
expr_stmt|;
return|return
name|ctx
operator|->
name|stack
index|[
name|ctx
operator|->
name|stack_len
operator|-
operator|(
literal|1
operator|+
name|n
operator|)
index|]
return|;
block|}
end_function

begin_comment
comment|/* Evaluate the expression at ADDR (LEN bytes long) using the context    CTX.  */
end_comment

begin_function
name|void
name|dwarf_expr_eval
parameter_list|(
name|struct
name|dwarf_expr_context
modifier|*
name|ctx
parameter_list|,
name|unsigned
name|char
modifier|*
name|addr
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|execute_stack_op
argument_list|(
name|ctx
argument_list|,
name|addr
argument_list|,
name|addr
operator|+
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Decode the unsigned LEB128 constant at BUF into the variable pointed to    by R, and return the new value of BUF.  Verify that it doesn't extend    past BUF_END.  */
end_comment

begin_function
name|unsigned
name|char
modifier|*
name|read_uleb128
parameter_list|(
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|unsigned
name|char
modifier|*
name|buf_end
parameter_list|,
name|ULONGEST
modifier|*
name|r
parameter_list|)
block|{
name|unsigned
name|shift
init|=
literal|0
decl_stmt|;
name|ULONGEST
name|result
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
name|byte
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|buf
operator|>=
name|buf_end
condition|)
name|error
argument_list|(
literal|"read_uleb128: Corrupted DWARF expression."
argument_list|)
expr_stmt|;
name|byte
operator|=
operator|*
name|buf
operator|++
expr_stmt|;
name|result
operator||=
operator|(
name|byte
operator|&
literal|0x7f
operator|)
operator|<<
name|shift
expr_stmt|;
if|if
condition|(
operator|(
name|byte
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
break|break;
name|shift
operator|+=
literal|7
expr_stmt|;
block|}
operator|*
name|r
operator|=
name|result
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/* Decode the signed LEB128 constant at BUF into the variable pointed to    by R, and return the new value of BUF.  Verify that it doesn't extend    past BUF_END.  */
end_comment

begin_function
name|unsigned
name|char
modifier|*
name|read_sleb128
parameter_list|(
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|unsigned
name|char
modifier|*
name|buf_end
parameter_list|,
name|LONGEST
modifier|*
name|r
parameter_list|)
block|{
name|unsigned
name|shift
init|=
literal|0
decl_stmt|;
name|LONGEST
name|result
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
name|byte
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|buf
operator|>=
name|buf_end
condition|)
name|error
argument_list|(
literal|"read_sleb128: Corrupted DWARF expression."
argument_list|)
expr_stmt|;
name|byte
operator|=
operator|*
name|buf
operator|++
expr_stmt|;
name|result
operator||=
operator|(
name|byte
operator|&
literal|0x7f
operator|)
operator|<<
name|shift
expr_stmt|;
name|shift
operator|+=
literal|7
expr_stmt|;
if|if
condition|(
operator|(
name|byte
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|shift
operator|<
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|r
argument_list|)
operator|*
literal|8
operator|)
operator|&&
operator|(
name|byte
operator|&
literal|0x40
operator|)
operator|!=
literal|0
condition|)
name|result
operator||=
operator|-
operator|(
literal|1
operator|<<
name|shift
operator|)
expr_stmt|;
operator|*
name|r
operator|=
name|result
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/* Read an address from BUF, and verify that it doesn't extend past    BUF_END.  The address is returned, and *BYTES_READ is set to the    number of bytes read from BUF.  */
end_comment

begin_function
name|CORE_ADDR
name|dwarf2_read_address
parameter_list|(
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|unsigned
name|char
modifier|*
name|buf_end
parameter_list|,
name|int
modifier|*
name|bytes_read
parameter_list|)
block|{
name|CORE_ADDR
name|result
decl_stmt|;
if|if
condition|(
name|buf_end
operator|-
name|buf
operator|<
name|TARGET_ADDR_BIT
operator|/
name|TARGET_CHAR_BIT
condition|)
name|error
argument_list|(
literal|"dwarf2_read_address: Corrupted DWARF expression."
argument_list|)
expr_stmt|;
operator|*
name|bytes_read
operator|=
name|TARGET_ADDR_BIT
operator|/
name|TARGET_CHAR_BIT
expr_stmt|;
comment|/* NOTE: cagney/2003-05-22: This extract is assuming that a DWARF 2      address is always unsigned.  That may or may not be true.  */
name|result
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
name|TARGET_ADDR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Return the type of an address, for unsigned arithmetic.  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|unsigned_address_type
parameter_list|(
name|void
parameter_list|)
block|{
switch|switch
condition|(
name|TARGET_ADDR_BIT
operator|/
name|TARGET_CHAR_BIT
condition|)
block|{
case|case
literal|2
case|:
return|return
name|builtin_type_uint16
return|;
case|case
literal|4
case|:
return|return
name|builtin_type_uint32
return|;
case|case
literal|8
case|:
return|return
name|builtin_type_uint64
return|;
default|default:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"Unsupported address size.\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return the type of an address, for signed arithmetic.  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|signed_address_type
parameter_list|(
name|void
parameter_list|)
block|{
switch|switch
condition|(
name|TARGET_ADDR_BIT
operator|/
name|TARGET_CHAR_BIT
condition|)
block|{
case|case
literal|2
case|:
return|return
name|builtin_type_int16
return|;
case|case
literal|4
case|:
return|return
name|builtin_type_int32
return|;
case|case
literal|8
case|:
return|return
name|builtin_type_int64
return|;
default|default:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"Unsupported address size.\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The engine for the expression evaluator.  Using the context in CTX,    evaluate the expression between OP_PTR and OP_END.  */
end_comment

begin_function
specifier|static
name|void
name|execute_stack_op
parameter_list|(
name|struct
name|dwarf_expr_context
modifier|*
name|ctx
parameter_list|,
name|unsigned
name|char
modifier|*
name|op_ptr
parameter_list|,
name|unsigned
name|char
modifier|*
name|op_end
parameter_list|)
block|{
name|ctx
operator|->
name|in_reg
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|op_ptr
operator|<
name|op_end
condition|)
block|{
name|enum
name|dwarf_location_atom
name|op
init|=
operator|*
name|op_ptr
operator|++
decl_stmt|;
name|CORE_ADDR
name|result
decl_stmt|;
name|ULONGEST
name|uoffset
decl_stmt|,
name|reg
decl_stmt|;
name|LONGEST
name|offset
decl_stmt|;
name|int
name|bytes_read
decl_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|DW_OP_lit0
case|:
case|case
name|DW_OP_lit1
case|:
case|case
name|DW_OP_lit2
case|:
case|case
name|DW_OP_lit3
case|:
case|case
name|DW_OP_lit4
case|:
case|case
name|DW_OP_lit5
case|:
case|case
name|DW_OP_lit6
case|:
case|case
name|DW_OP_lit7
case|:
case|case
name|DW_OP_lit8
case|:
case|case
name|DW_OP_lit9
case|:
case|case
name|DW_OP_lit10
case|:
case|case
name|DW_OP_lit11
case|:
case|case
name|DW_OP_lit12
case|:
case|case
name|DW_OP_lit13
case|:
case|case
name|DW_OP_lit14
case|:
case|case
name|DW_OP_lit15
case|:
case|case
name|DW_OP_lit16
case|:
case|case
name|DW_OP_lit17
case|:
case|case
name|DW_OP_lit18
case|:
case|case
name|DW_OP_lit19
case|:
case|case
name|DW_OP_lit20
case|:
case|case
name|DW_OP_lit21
case|:
case|case
name|DW_OP_lit22
case|:
case|case
name|DW_OP_lit23
case|:
case|case
name|DW_OP_lit24
case|:
case|case
name|DW_OP_lit25
case|:
case|case
name|DW_OP_lit26
case|:
case|case
name|DW_OP_lit27
case|:
case|case
name|DW_OP_lit28
case|:
case|case
name|DW_OP_lit29
case|:
case|case
name|DW_OP_lit30
case|:
case|case
name|DW_OP_lit31
case|:
name|result
operator|=
name|op
operator|-
name|DW_OP_lit0
expr_stmt|;
break|break;
case|case
name|DW_OP_addr
case|:
name|result
operator|=
name|dwarf2_read_address
argument_list|(
name|op_ptr
argument_list|,
name|op_end
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|op_ptr
operator|+=
name|bytes_read
expr_stmt|;
break|break;
case|case
name|DW_OP_const1u
case|:
name|result
operator|=
name|extract_unsigned_integer
argument_list|(
name|op_ptr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|op_ptr
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|DW_OP_const1s
case|:
name|result
operator|=
name|extract_signed_integer
argument_list|(
name|op_ptr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|op_ptr
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|DW_OP_const2u
case|:
name|result
operator|=
name|extract_unsigned_integer
argument_list|(
name|op_ptr
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|op_ptr
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|DW_OP_const2s
case|:
name|result
operator|=
name|extract_signed_integer
argument_list|(
name|op_ptr
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|op_ptr
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|DW_OP_const4u
case|:
name|result
operator|=
name|extract_unsigned_integer
argument_list|(
name|op_ptr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|op_ptr
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|DW_OP_const4s
case|:
name|result
operator|=
name|extract_signed_integer
argument_list|(
name|op_ptr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|op_ptr
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|DW_OP_const8u
case|:
name|result
operator|=
name|extract_unsigned_integer
argument_list|(
name|op_ptr
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|op_ptr
operator|+=
literal|8
expr_stmt|;
break|break;
case|case
name|DW_OP_const8s
case|:
name|result
operator|=
name|extract_signed_integer
argument_list|(
name|op_ptr
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|op_ptr
operator|+=
literal|8
expr_stmt|;
break|break;
case|case
name|DW_OP_constu
case|:
name|op_ptr
operator|=
name|read_uleb128
argument_list|(
name|op_ptr
argument_list|,
name|op_end
argument_list|,
operator|&
name|uoffset
argument_list|)
expr_stmt|;
name|result
operator|=
name|uoffset
expr_stmt|;
break|break;
case|case
name|DW_OP_consts
case|:
name|op_ptr
operator|=
name|read_sleb128
argument_list|(
name|op_ptr
argument_list|,
name|op_end
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
name|result
operator|=
name|offset
expr_stmt|;
break|break;
comment|/* The DW_OP_reg operations are required to occur alone in 	   location expressions.  */
case|case
name|DW_OP_reg0
case|:
case|case
name|DW_OP_reg1
case|:
case|case
name|DW_OP_reg2
case|:
case|case
name|DW_OP_reg3
case|:
case|case
name|DW_OP_reg4
case|:
case|case
name|DW_OP_reg5
case|:
case|case
name|DW_OP_reg6
case|:
case|case
name|DW_OP_reg7
case|:
case|case
name|DW_OP_reg8
case|:
case|case
name|DW_OP_reg9
case|:
case|case
name|DW_OP_reg10
case|:
case|case
name|DW_OP_reg11
case|:
case|case
name|DW_OP_reg12
case|:
case|case
name|DW_OP_reg13
case|:
case|case
name|DW_OP_reg14
case|:
case|case
name|DW_OP_reg15
case|:
case|case
name|DW_OP_reg16
case|:
case|case
name|DW_OP_reg17
case|:
case|case
name|DW_OP_reg18
case|:
case|case
name|DW_OP_reg19
case|:
case|case
name|DW_OP_reg20
case|:
case|case
name|DW_OP_reg21
case|:
case|case
name|DW_OP_reg22
case|:
case|case
name|DW_OP_reg23
case|:
case|case
name|DW_OP_reg24
case|:
case|case
name|DW_OP_reg25
case|:
case|case
name|DW_OP_reg26
case|:
case|case
name|DW_OP_reg27
case|:
case|case
name|DW_OP_reg28
case|:
case|case
name|DW_OP_reg29
case|:
case|case
name|DW_OP_reg30
case|:
case|case
name|DW_OP_reg31
case|:
if|if
condition|(
name|op_ptr
operator|!=
name|op_end
operator|&&
operator|*
name|op_ptr
operator|!=
name|DW_OP_piece
condition|)
name|error
argument_list|(
literal|"DWARF-2 expression error: DW_OP_reg operations must be "
literal|"used either alone or in conjuction with DW_OP_piece."
argument_list|)
expr_stmt|;
name|result
operator|=
name|op
operator|-
name|DW_OP_reg0
expr_stmt|;
name|ctx
operator|->
name|in_reg
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|DW_OP_regx
case|:
name|op_ptr
operator|=
name|read_uleb128
argument_list|(
name|op_ptr
argument_list|,
name|op_end
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|op_ptr
operator|!=
name|op_end
operator|&&
operator|*
name|op_ptr
operator|!=
name|DW_OP_piece
condition|)
name|error
argument_list|(
literal|"DWARF-2 expression error: DW_OP_reg operations must be "
literal|"used either alone or in conjuction with DW_OP_piece."
argument_list|)
expr_stmt|;
name|result
operator|=
name|reg
expr_stmt|;
name|ctx
operator|->
name|in_reg
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|DW_OP_breg0
case|:
case|case
name|DW_OP_breg1
case|:
case|case
name|DW_OP_breg2
case|:
case|case
name|DW_OP_breg3
case|:
case|case
name|DW_OP_breg4
case|:
case|case
name|DW_OP_breg5
case|:
case|case
name|DW_OP_breg6
case|:
case|case
name|DW_OP_breg7
case|:
case|case
name|DW_OP_breg8
case|:
case|case
name|DW_OP_breg9
case|:
case|case
name|DW_OP_breg10
case|:
case|case
name|DW_OP_breg11
case|:
case|case
name|DW_OP_breg12
case|:
case|case
name|DW_OP_breg13
case|:
case|case
name|DW_OP_breg14
case|:
case|case
name|DW_OP_breg15
case|:
case|case
name|DW_OP_breg16
case|:
case|case
name|DW_OP_breg17
case|:
case|case
name|DW_OP_breg18
case|:
case|case
name|DW_OP_breg19
case|:
case|case
name|DW_OP_breg20
case|:
case|case
name|DW_OP_breg21
case|:
case|case
name|DW_OP_breg22
case|:
case|case
name|DW_OP_breg23
case|:
case|case
name|DW_OP_breg24
case|:
case|case
name|DW_OP_breg25
case|:
case|case
name|DW_OP_breg26
case|:
case|case
name|DW_OP_breg27
case|:
case|case
name|DW_OP_breg28
case|:
case|case
name|DW_OP_breg29
case|:
case|case
name|DW_OP_breg30
case|:
case|case
name|DW_OP_breg31
case|:
block|{
name|op_ptr
operator|=
name|read_sleb128
argument_list|(
name|op_ptr
argument_list|,
name|op_end
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
name|result
operator|=
call|(
name|ctx
operator|->
name|read_reg
call|)
argument_list|(
name|ctx
operator|->
name|baton
argument_list|,
name|op
operator|-
name|DW_OP_breg0
argument_list|)
expr_stmt|;
name|result
operator|+=
name|offset
expr_stmt|;
block|}
break|break;
case|case
name|DW_OP_bregx
case|:
block|{
name|op_ptr
operator|=
name|read_uleb128
argument_list|(
name|op_ptr
argument_list|,
name|op_end
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|op_ptr
operator|=
name|read_sleb128
argument_list|(
name|op_ptr
argument_list|,
name|op_end
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
name|result
operator|=
call|(
name|ctx
operator|->
name|read_reg
call|)
argument_list|(
name|ctx
operator|->
name|baton
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|result
operator|+=
name|offset
expr_stmt|;
block|}
break|break;
case|case
name|DW_OP_fbreg
case|:
block|{
name|unsigned
name|char
modifier|*
name|datastart
decl_stmt|;
name|size_t
name|datalen
decl_stmt|;
name|unsigned
name|int
name|before_stack_len
decl_stmt|;
name|op_ptr
operator|=
name|read_sleb128
argument_list|(
name|op_ptr
argument_list|,
name|op_end
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
comment|/* Rather than create a whole new context, we simply 	       record the stack length before execution, then reset it 	       afterwards, effectively erasing whatever the recursive 	       call put there.  */
name|before_stack_len
operator|=
name|ctx
operator|->
name|stack_len
expr_stmt|;
comment|/* FIXME: cagney/2003-03-26: This code should be using                get_frame_base_address(), and then implement a dwarf2                specific this_base method.  */
call|(
name|ctx
operator|->
name|get_frame_base
call|)
argument_list|(
name|ctx
operator|->
name|baton
argument_list|,
operator|&
name|datastart
argument_list|,
operator|&
name|datalen
argument_list|)
expr_stmt|;
name|dwarf_expr_eval
argument_list|(
name|ctx
argument_list|,
name|datastart
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
name|result
operator|=
name|dwarf_expr_fetch
argument_list|(
name|ctx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|in_reg
condition|)
name|result
operator|=
call|(
name|ctx
operator|->
name|read_reg
call|)
argument_list|(
name|ctx
operator|->
name|baton
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|result
operator|=
name|result
operator|+
name|offset
expr_stmt|;
name|ctx
operator|->
name|stack_len
operator|=
name|before_stack_len
expr_stmt|;
name|ctx
operator|->
name|in_reg
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|DW_OP_dup
case|:
name|result
operator|=
name|dwarf_expr_fetch
argument_list|(
name|ctx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_drop
case|:
name|dwarf_expr_pop
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
goto|goto
name|no_push
goto|;
case|case
name|DW_OP_pick
case|:
name|offset
operator|=
operator|*
name|op_ptr
operator|++
expr_stmt|;
name|result
operator|=
name|dwarf_expr_fetch
argument_list|(
name|ctx
argument_list|,
name|offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_over
case|:
name|result
operator|=
name|dwarf_expr_fetch
argument_list|(
name|ctx
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_rot
case|:
block|{
name|CORE_ADDR
name|t1
decl_stmt|,
name|t2
decl_stmt|,
name|t3
decl_stmt|;
if|if
condition|(
name|ctx
operator|->
name|stack_len
operator|<
literal|3
condition|)
name|error
argument_list|(
literal|"Not enough elements for DW_OP_rot. Need 3, have %d\n"
argument_list|,
name|ctx
operator|->
name|stack_len
argument_list|)
expr_stmt|;
name|t1
operator|=
name|ctx
operator|->
name|stack
index|[
name|ctx
operator|->
name|stack_len
operator|-
literal|1
index|]
expr_stmt|;
name|t2
operator|=
name|ctx
operator|->
name|stack
index|[
name|ctx
operator|->
name|stack_len
operator|-
literal|2
index|]
expr_stmt|;
name|t3
operator|=
name|ctx
operator|->
name|stack
index|[
name|ctx
operator|->
name|stack_len
operator|-
literal|3
index|]
expr_stmt|;
name|ctx
operator|->
name|stack
index|[
name|ctx
operator|->
name|stack_len
operator|-
literal|1
index|]
operator|=
name|t2
expr_stmt|;
name|ctx
operator|->
name|stack
index|[
name|ctx
operator|->
name|stack_len
operator|-
literal|2
index|]
operator|=
name|t3
expr_stmt|;
name|ctx
operator|->
name|stack
index|[
name|ctx
operator|->
name|stack_len
operator|-
literal|3
index|]
operator|=
name|t1
expr_stmt|;
goto|goto
name|no_push
goto|;
block|}
case|case
name|DW_OP_deref
case|:
case|case
name|DW_OP_deref_size
case|:
case|case
name|DW_OP_abs
case|:
case|case
name|DW_OP_neg
case|:
case|case
name|DW_OP_not
case|:
case|case
name|DW_OP_plus_uconst
case|:
comment|/* Unary operations.  */
name|result
operator|=
name|dwarf_expr_fetch
argument_list|(
name|ctx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dwarf_expr_pop
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|DW_OP_deref
case|:
block|{
name|char
modifier|*
name|buf
init|=
name|alloca
argument_list|(
name|TARGET_ADDR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|)
decl_stmt|;
name|int
name|bytes_read
decl_stmt|;
call|(
name|ctx
operator|->
name|read_mem
call|)
argument_list|(
name|ctx
operator|->
name|baton
argument_list|,
name|buf
argument_list|,
name|result
argument_list|,
name|TARGET_ADDR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|)
expr_stmt|;
name|result
operator|=
name|dwarf2_read_address
argument_list|(
name|buf
argument_list|,
name|buf
operator|+
operator|(
name|TARGET_ADDR_BIT
operator|/
name|TARGET_CHAR_BIT
operator|)
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DW_OP_deref_size
case|:
block|{
name|char
modifier|*
name|buf
init|=
name|alloca
argument_list|(
name|TARGET_ADDR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|)
decl_stmt|;
name|int
name|bytes_read
decl_stmt|;
call|(
name|ctx
operator|->
name|read_mem
call|)
argument_list|(
name|ctx
operator|->
name|baton
argument_list|,
name|buf
argument_list|,
name|result
argument_list|,
operator|*
name|op_ptr
operator|++
argument_list|)
expr_stmt|;
name|result
operator|=
name|dwarf2_read_address
argument_list|(
name|buf
argument_list|,
name|buf
operator|+
operator|(
name|TARGET_ADDR_BIT
operator|/
name|TARGET_CHAR_BIT
operator|)
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DW_OP_abs
case|:
if|if
condition|(
operator|(
name|signed
name|int
operator|)
name|result
operator|<
literal|0
condition|)
name|result
operator|=
operator|-
name|result
expr_stmt|;
break|break;
case|case
name|DW_OP_neg
case|:
name|result
operator|=
operator|-
name|result
expr_stmt|;
break|break;
case|case
name|DW_OP_not
case|:
name|result
operator|=
operator|~
name|result
expr_stmt|;
break|break;
case|case
name|DW_OP_plus_uconst
case|:
name|op_ptr
operator|=
name|read_uleb128
argument_list|(
name|op_ptr
argument_list|,
name|op_end
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|result
operator|+=
name|reg
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|DW_OP_and
case|:
case|case
name|DW_OP_div
case|:
case|case
name|DW_OP_minus
case|:
case|case
name|DW_OP_mod
case|:
case|case
name|DW_OP_mul
case|:
case|case
name|DW_OP_or
case|:
case|case
name|DW_OP_plus
case|:
case|case
name|DW_OP_shl
case|:
case|case
name|DW_OP_shr
case|:
case|case
name|DW_OP_shra
case|:
case|case
name|DW_OP_xor
case|:
case|case
name|DW_OP_le
case|:
case|case
name|DW_OP_ge
case|:
case|case
name|DW_OP_eq
case|:
case|case
name|DW_OP_lt
case|:
case|case
name|DW_OP_gt
case|:
case|case
name|DW_OP_ne
case|:
block|{
comment|/* Binary operations.  Use the value engine to do computations in 	       the right width.  */
name|CORE_ADDR
name|first
decl_stmt|,
name|second
decl_stmt|;
name|enum
name|exp_opcode
name|binop
decl_stmt|;
name|struct
name|value
modifier|*
name|val1
decl_stmt|,
modifier|*
name|val2
decl_stmt|;
name|second
operator|=
name|dwarf_expr_fetch
argument_list|(
name|ctx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dwarf_expr_pop
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|first
operator|=
name|dwarf_expr_fetch
argument_list|(
name|ctx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dwarf_expr_pop
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|val1
operator|=
name|value_from_longest
argument_list|(
name|unsigned_address_type
argument_list|()
argument_list|,
name|first
argument_list|)
expr_stmt|;
name|val2
operator|=
name|value_from_longest
argument_list|(
name|unsigned_address_type
argument_list|()
argument_list|,
name|second
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|DW_OP_and
case|:
name|binop
operator|=
name|BINOP_BITWISE_AND
expr_stmt|;
break|break;
case|case
name|DW_OP_div
case|:
name|binop
operator|=
name|BINOP_DIV
expr_stmt|;
case|case
name|DW_OP_minus
case|:
name|binop
operator|=
name|BINOP_SUB
expr_stmt|;
break|break;
case|case
name|DW_OP_mod
case|:
name|binop
operator|=
name|BINOP_MOD
expr_stmt|;
break|break;
case|case
name|DW_OP_mul
case|:
name|binop
operator|=
name|BINOP_MUL
expr_stmt|;
break|break;
case|case
name|DW_OP_or
case|:
name|binop
operator|=
name|BINOP_BITWISE_IOR
expr_stmt|;
break|break;
case|case
name|DW_OP_plus
case|:
name|binop
operator|=
name|BINOP_ADD
expr_stmt|;
break|break;
case|case
name|DW_OP_shl
case|:
name|binop
operator|=
name|BINOP_LSH
expr_stmt|;
break|break;
case|case
name|DW_OP_shr
case|:
name|binop
operator|=
name|BINOP_RSH
expr_stmt|;
case|case
name|DW_OP_shra
case|:
name|binop
operator|=
name|BINOP_RSH
expr_stmt|;
name|val1
operator|=
name|value_from_longest
argument_list|(
name|signed_address_type
argument_list|()
argument_list|,
name|first
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_xor
case|:
name|binop
operator|=
name|BINOP_BITWISE_XOR
expr_stmt|;
break|break;
case|case
name|DW_OP_le
case|:
name|binop
operator|=
name|BINOP_LEQ
expr_stmt|;
break|break;
case|case
name|DW_OP_ge
case|:
name|binop
operator|=
name|BINOP_GEQ
expr_stmt|;
break|break;
case|case
name|DW_OP_eq
case|:
name|binop
operator|=
name|BINOP_EQUAL
expr_stmt|;
break|break;
case|case
name|DW_OP_lt
case|:
name|binop
operator|=
name|BINOP_LESS
expr_stmt|;
break|break;
case|case
name|DW_OP_gt
case|:
name|binop
operator|=
name|BINOP_GTR
expr_stmt|;
break|break;
case|case
name|DW_OP_ne
case|:
name|binop
operator|=
name|BINOP_NOTEQUAL
expr_stmt|;
break|break;
default|default:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"Can't be reached."
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|value_as_long
argument_list|(
name|value_binop
argument_list|(
name|val1
argument_list|,
name|val2
argument_list|,
name|binop
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DW_OP_GNU_push_tls_address
case|:
comment|/* Variable is at a constant offset in the thread-local 	  storage block into the objfile for the current thread and 	  the dynamic linker module containing this expression. Here 	  we return returns the offset from that base.  The top of the 	  stack has the offset from the beginning of the thread 	  control block at which the variable is located.  Nothing 	  should follow this operator, so the top of stack would be 	  returned.  */
name|result
operator|=
name|dwarf_expr_fetch
argument_list|(
name|ctx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dwarf_expr_pop
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|result
operator|=
call|(
name|ctx
operator|->
name|get_tls_address
call|)
argument_list|(
name|ctx
operator|->
name|baton
argument_list|,
name|result
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_skip
case|:
name|offset
operator|=
name|extract_signed_integer
argument_list|(
name|op_ptr
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|op_ptr
operator|+=
literal|2
expr_stmt|;
name|op_ptr
operator|+=
name|offset
expr_stmt|;
goto|goto
name|no_push
goto|;
case|case
name|DW_OP_bra
case|:
name|offset
operator|=
name|extract_signed_integer
argument_list|(
name|op_ptr
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|op_ptr
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|dwarf_expr_fetch
argument_list|(
name|ctx
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
name|op_ptr
operator|+=
name|offset
expr_stmt|;
name|dwarf_expr_pop
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
goto|goto
name|no_push
goto|;
case|case
name|DW_OP_nop
case|:
goto|goto
name|no_push
goto|;
default|default:
name|error
argument_list|(
literal|"Unhandled dwarf expression opcode 0x%x"
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
comment|/* Most things push a result value.  */
name|dwarf_expr_push
argument_list|(
name|ctx
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|no_push
label|:
empty_stmt|;
block|}
block|}
end_function

end_unit

