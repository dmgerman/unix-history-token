begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* GDB CLI commands.     Copyright 2000, 2001, 2002 Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"completer.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_comment
comment|/* For baud_rate, remote_debug and remote_timeout */
end_comment

begin_include
include|#
directive|include
file|"gdb_wait.h"
end_include

begin_comment
comment|/* For shell escape implementation */
end_comment

begin_include
include|#
directive|include
file|"gdb_regex.h"
end_include

begin_comment
comment|/* Used by apropos_command */
end_comment

begin_include
include|#
directive|include
file|"filenames.h"
end_include

begin_comment
comment|/* for DOSish file names */
end_comment

begin_include
include|#
directive|include
file|"ui-out.h"
end_include

begin_include
include|#
directive|include
file|"top.h"
end_include

begin_include
include|#
directive|include
file|"cli/cli-decode.h"
end_include

begin_include
include|#
directive|include
file|"cli/cli-script.h"
end_include

begin_include
include|#
directive|include
file|"cli/cli-setshow.h"
end_include

begin_include
include|#
directive|include
file|"cli/cli-cmds.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|GDBINIT_FILENAME
end_ifndef

begin_define
define|#
directive|define
name|GDBINIT_FILENAME
value|".gdbinit"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* From gdb/top.c */
end_comment

begin_function_decl
specifier|extern
name|void
name|dont_repeat
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|set_verbose
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|show_history
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|set_history
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|show_commands
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Prototypes for local functions */
end_comment

begin_function_decl
specifier|static
name|void
name|complete_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|echo_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pwd_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|show_version
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|validate_comname
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|help_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|show_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|info_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|show_debug
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_debug
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|show_user
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|make_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|shell_escape
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|apropos_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Define all cmd_list_elements.  */
end_comment

begin_comment
comment|/* Chain containing all defined commands.  */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|cmdlist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain containing all defined info subcommands.  */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|infolist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain containing all defined enable subcommands. */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|enablelist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain containing all defined disable subcommands. */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|disablelist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain containing all defined toggle subcommands. */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|togglelist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain containing all defined stop subcommands. */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|stoplist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain containing all defined delete subcommands. */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|deletelist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain containing all defined "enable breakpoint" subcommands. */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|enablebreaklist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain containing all defined set subcommands */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|setlist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain containing all defined unset subcommands */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|unsetlist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain containing all defined show subcommands.  */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|showlist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain containing all defined \"set history\".  */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|sethistlist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain containing all defined \"show history\".  */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|showhistlist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain containing all defined \"unset history\".  */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|unsethistlist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain containing all defined maintenance subcommands. */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|maintenancelist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain containing all defined "maintenance info" subcommands. */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|maintenanceinfolist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain containing all defined "maintenance print" subcommands. */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|maintenanceprintlist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|setprintlist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|showprintlist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|setdebuglist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|showdebuglist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|setchecklist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|showchecklist
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Utility used everywhere when at least one argument is needed and    none is supplied. */
end_comment

begin_function
name|void
name|error_no_arg
parameter_list|(
name|char
modifier|*
name|why
parameter_list|)
block|{
name|error
argument_list|(
literal|"Argument required (%s)."
argument_list|,
name|why
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The "info" command is defined as a prefix, with allow_unknown = 0.    Therefore, its own definition is called only for "info" with no args.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|info_command
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|printf_unfiltered
argument_list|(
literal|"\"info\" must be followed by the name of an info command.\n"
argument_list|)
expr_stmt|;
name|help_list
argument_list|(
name|infolist
argument_list|,
literal|"info "
argument_list|,
operator|-
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The "show" command with no arguments shows all the settings.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|show_command
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|cmd_show_list
argument_list|(
name|showlist
argument_list|,
name|from_tty
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Provide documentation on command or list given by COMMAND.  FROM_TTY    is ignored.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|help_command
parameter_list|(
name|char
modifier|*
name|command
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|help_cmd
argument_list|(
name|command
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* String compare function for qsort.  */
end_comment

begin_function
specifier|static
name|int
name|compare_strings
parameter_list|(
specifier|const
name|void
modifier|*
name|arg1
parameter_list|,
specifier|const
name|void
modifier|*
name|arg2
parameter_list|)
block|{
specifier|const
name|char
modifier|*
modifier|*
name|s1
init|=
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|arg1
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|s2
init|=
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|arg2
decl_stmt|;
return|return
name|strcmp
argument_list|(
operator|*
name|s1
argument_list|,
operator|*
name|s2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The "complete" command is used by Emacs to implement completion.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|complete_command
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|argpoint
decl_stmt|;
name|char
modifier|*
modifier|*
name|completions
decl_stmt|;
name|dont_repeat
argument_list|()
expr_stmt|;
if|if
condition|(
name|arg
operator|==
name|NULL
condition|)
name|arg
operator|=
literal|""
expr_stmt|;
name|argpoint
operator|=
name|strlen
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|completions
operator|=
name|complete_line
argument_list|(
name|arg
argument_list|,
name|arg
argument_list|,
name|argpoint
argument_list|)
expr_stmt|;
if|if
condition|(
name|completions
condition|)
block|{
name|int
name|item
decl_stmt|,
name|size
decl_stmt|;
for|for
control|(
name|size
operator|=
literal|0
init|;
name|completions
index|[
name|size
index|]
condition|;
operator|++
name|size
control|)
empty_stmt|;
name|qsort
argument_list|(
name|completions
argument_list|,
name|size
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|,
name|compare_strings
argument_list|)
expr_stmt|;
comment|/* We do extra processing here since we only want to print each 	 unique item once.  */
name|item
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|item
operator|<
name|size
condition|)
block|{
name|int
name|next_item
decl_stmt|;
name|printf_unfiltered
argument_list|(
literal|"%s\n"
argument_list|,
name|completions
index|[
name|item
index|]
argument_list|)
expr_stmt|;
name|next_item
operator|=
name|item
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|next_item
operator|<
name|size
operator|&&
operator|!
name|strcmp
argument_list|(
name|completions
index|[
name|item
index|]
argument_list|,
name|completions
index|[
name|next_item
index|]
argument_list|)
condition|)
block|{
name|xfree
argument_list|(
name|completions
index|[
name|next_item
index|]
argument_list|)
expr_stmt|;
operator|++
name|next_item
expr_stmt|;
block|}
name|xfree
argument_list|(
name|completions
index|[
name|item
index|]
argument_list|)
expr_stmt|;
name|item
operator|=
name|next_item
expr_stmt|;
block|}
name|xfree
argument_list|(
name|completions
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|is_complete_command
parameter_list|(
name|struct
name|cmd_list_element
modifier|*
name|c
parameter_list|)
block|{
return|return
name|cmd_cfunc_eq
argument_list|(
name|c
argument_list|,
name|complete_command
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|show_version
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|immediate_quit
operator|++
expr_stmt|;
name|print_gdb_version
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|immediate_quit
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the quit command.  */
end_comment

begin_function
name|void
name|quit_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
if|if
condition|(
operator|!
name|quit_confirm
argument_list|()
condition|)
name|error
argument_list|(
literal|"Not confirmed."
argument_list|)
expr_stmt|;
name|quit_force
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|pwd_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
if|if
condition|(
name|args
condition|)
name|error
argument_list|(
literal|"The \"pwd\" command does not take an argument: %s"
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|getcwd
argument_list|(
name|gdb_dirbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|gdb_dirbuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|STREQ
argument_list|(
name|gdb_dirbuf
argument_list|,
name|current_directory
argument_list|)
condition|)
name|printf_unfiltered
argument_list|(
literal|"Working directory %s\n (canonically %s).\n"
argument_list|,
name|current_directory
argument_list|,
name|gdb_dirbuf
argument_list|)
expr_stmt|;
else|else
name|printf_unfiltered
argument_list|(
literal|"Working directory %s.\n"
argument_list|,
name|current_directory
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cd_command
parameter_list|(
name|char
modifier|*
name|dir
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
comment|/* Found something other than leading repetitions of "/..".  */
name|int
name|found_real_path
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
comment|/* If the new directory is absolute, repeat is a no-op; if relative,      repeat might be useful but is more likely to be a mistake.  */
name|dont_repeat
argument_list|()
expr_stmt|;
if|if
condition|(
name|dir
operator|==
literal|0
condition|)
name|error_no_arg
argument_list|(
literal|"new working directory"
argument_list|)
expr_stmt|;
name|dir
operator|=
name|tilde_expand
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|chdir
argument_list|(
name|dir
argument_list|)
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|dir
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_DOS_BASED_FILE_SYSTEM
comment|/* There's too much mess with DOSish names like "d:", "d:.",      "d:./foo" etc.  Instead of having lots of special #ifdef'ed code,      simply get the canonicalized name of the current directory.  */
name|dir
operator|=
name|getcwd
argument_list|(
name|gdb_dirbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|gdb_dirbuf
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|len
operator|=
name|strlen
argument_list|(
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_DIR_SEPARATOR
argument_list|(
name|dir
index|[
name|len
operator|-
literal|1
index|]
argument_list|)
condition|)
block|{
comment|/* Remove the trailing slash unless this is a root directory          (including a drive letter on non-Unix systems).  */
if|if
condition|(
operator|!
operator|(
name|len
operator|==
literal|1
operator|)
comment|/* "/" */
ifdef|#
directive|ifdef
name|HAVE_DOS_BASED_FILE_SYSTEM
operator|&&
operator|!
operator|(
name|len
operator|==
literal|3
operator|&&
name|dir
index|[
literal|1
index|]
operator|==
literal|':'
operator|)
comment|/* "d:/" */
endif|#
directive|endif
condition|)
name|len
operator|--
expr_stmt|;
block|}
name|dir
operator|=
name|savestring
argument_list|(
name|dir
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ABSOLUTE_PATH
argument_list|(
name|dir
argument_list|)
condition|)
name|current_directory
operator|=
name|dir
expr_stmt|;
else|else
block|{
if|if
condition|(
name|IS_DIR_SEPARATOR
argument_list|(
name|current_directory
index|[
name|strlen
argument_list|(
name|current_directory
argument_list|)
operator|-
literal|1
index|]
argument_list|)
condition|)
name|current_directory
operator|=
name|concat
argument_list|(
name|current_directory
argument_list|,
name|dir
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|current_directory
operator|=
name|concat
argument_list|(
name|current_directory
argument_list|,
name|SLASH_STRING
argument_list|,
name|dir
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|dir
argument_list|)
expr_stmt|;
block|}
comment|/* Now simplify any occurrences of `.' and `..' in the pathname.  */
name|found_real_path
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|current_directory
init|;
operator|*
name|p
condition|;
control|)
block|{
if|if
condition|(
name|IS_DIR_SEPARATOR
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
operator|(
name|p
index|[
literal|2
index|]
operator|==
literal|0
operator|||
name|IS_DIR_SEPARATOR
argument_list|(
name|p
index|[
literal|2
index|]
argument_list|)
operator|)
condition|)
name|strcpy
argument_list|(
name|p
argument_list|,
name|p
operator|+
literal|2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_DIR_SEPARATOR
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|p
index|[
literal|2
index|]
operator|==
literal|'.'
operator|&&
operator|(
name|p
index|[
literal|3
index|]
operator|==
literal|0
operator|||
name|IS_DIR_SEPARATOR
argument_list|(
name|p
index|[
literal|3
index|]
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|found_real_path
condition|)
block|{
comment|/* Search backwards for the directory just before the "/.." 	         and obliterate it and the "/..".  */
name|char
modifier|*
name|q
init|=
name|p
decl_stmt|;
while|while
condition|(
name|q
operator|!=
name|current_directory
operator|&&
operator|!
name|IS_DIR_SEPARATOR
argument_list|(
name|q
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
operator|--
name|q
expr_stmt|;
if|if
condition|(
name|q
operator|==
name|current_directory
condition|)
comment|/* current_directory is 		   a relative pathname ("can't happen"--leave it alone).  */
operator|++
name|p
expr_stmt|;
else|else
block|{
name|strcpy
argument_list|(
name|q
operator|-
literal|1
argument_list|,
name|p
operator|+
literal|3
argument_list|)
expr_stmt|;
name|p
operator|=
name|q
operator|-
literal|1
expr_stmt|;
block|}
block|}
else|else
comment|/* We are dealing with leading repetitions of "/..", for example 	       "/../..", which is the Mach super-root.  */
name|p
operator|+=
literal|3
expr_stmt|;
block|}
else|else
block|{
name|found_real_path
operator|=
literal|1
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
block|}
name|forget_cached_source_info
argument_list|()
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
name|pwd_command
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|source_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|FILE
modifier|*
name|stream
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_cleanups
decl_stmt|;
name|char
modifier|*
name|file
init|=
name|args
decl_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"source command requires pathname of file to source."
argument_list|)
expr_stmt|;
block|}
name|file
operator|=
name|tilde_expand
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|old_cleanups
operator|=
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|stream
operator|=
name|fopen
argument_list|(
name|file
argument_list|,
name|FOPEN_RT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stream
condition|)
block|{
if|if
condition|(
name|from_tty
condition|)
name|perror_with_name
argument_list|(
name|file
argument_list|)
expr_stmt|;
else|else
return|return;
block|}
name|script_from_file
argument_list|(
name|stream
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_cleanups
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|echo_command
parameter_list|(
name|char
modifier|*
name|text
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|char
modifier|*
name|p
init|=
name|text
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
if|if
condition|(
name|text
condition|)
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
comment|/* \ at end of argument is used after spaces 	       so they won't be lost.  */
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
return|return;
name|c
operator|=
name|parse_escape
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|0
condition|)
name|printf_filtered
argument_list|(
literal|"%c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
else|else
name|printf_filtered
argument_list|(
literal|"%c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
comment|/* Force this output to appear now.  */
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|shell_escape
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|CANT_FORK
comment|/* If ARG is NULL, they want an inferior shell, but `system' just      reports if the shell is available when passed a NULL arg.  */
name|int
name|rc
init|=
name|system
argument_list|(
name|arg
condition|?
name|arg
else|:
literal|""
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|arg
condition|)
name|arg
operator|=
literal|"inferior shell"
expr_stmt|;
if|if
condition|(
name|rc
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Cannot execute %s: %s\n"
argument_list|,
name|arg
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stderr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rc
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"%s exited with status %d\n"
argument_list|,
name|arg
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stderr
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|GLOBAL_CURDIR
comment|/* Make sure to return to the directory GDB thinks it is, in case the      shell command we just ran changed it.  */
name|chdir
argument_list|(
name|current_directory
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
comment|/* Can fork.  */
name|int
name|rc
decl_stmt|,
name|status
decl_stmt|,
name|pid
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|user_shell
decl_stmt|;
if|if
condition|(
operator|(
name|user_shell
operator|=
operator|(
name|char
operator|*
operator|)
name|getenv
argument_list|(
literal|"SHELL"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|user_shell
operator|=
literal|"/bin/sh"
expr_stmt|;
comment|/* Get the name of the shell for arg0 */
if|if
condition|(
operator|(
name|p
operator|=
name|strrchr
argument_list|(
name|user_shell
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|p
operator|=
name|user_shell
expr_stmt|;
else|else
name|p
operator|++
expr_stmt|;
comment|/* Get past '/' */
if|if
condition|(
operator|(
name|pid
operator|=
name|fork
argument_list|()
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|arg
condition|)
name|execl
argument_list|(
name|user_shell
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|execl
argument_list|(
name|user_shell
argument_list|,
name|p
argument_list|,
literal|"-c"
argument_list|,
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Cannot execute %s: %s\n"
argument_list|,
name|user_shell
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stderr
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|0177
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pid
operator|!=
operator|-
literal|1
condition|)
while|while
condition|(
operator|(
name|rc
operator|=
name|wait
argument_list|(
operator|&
name|status
argument_list|)
operator|)
operator|!=
name|pid
operator|&&
name|rc
operator|!=
operator|-
literal|1
condition|)
empty_stmt|;
else|else
name|error
argument_list|(
literal|"Fork failed"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Can fork.  */
block|}
end_function

begin_function
specifier|static
name|void
name|make_command
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|arg
operator|==
literal|0
condition|)
name|p
operator|=
literal|"make"
expr_stmt|;
else|else
block|{
name|p
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
literal|"make "
argument_list|)
operator|+
name|strlen
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
literal|"make "
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p
operator|+
sizeof|sizeof
argument_list|(
literal|"make "
argument_list|)
operator|-
literal|1
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
name|shell_escape
argument_list|(
name|p
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|show_user
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
specifier|extern
name|struct
name|cmd_list_element
modifier|*
name|cmdlist
decl_stmt|;
if|if
condition|(
name|args
condition|)
block|{
name|c
operator|=
name|lookup_cmd
argument_list|(
operator|&
name|args
argument_list|,
name|cmdlist
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|class
operator|!=
name|class_user
condition|)
name|error
argument_list|(
literal|"Not a user command."
argument_list|)
expr_stmt|;
name|show_user_1
argument_list|(
name|c
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|c
operator|=
name|cmdlist
init|;
name|c
condition|;
name|c
operator|=
name|c
operator|->
name|next
control|)
block|{
if|if
condition|(
name|c
operator|->
name|class
operator|==
name|class_user
condition|)
name|show_user_1
argument_list|(
name|c
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Search through names of commands and documentations for a certain    regular expression. */
end_comment

begin_function
name|void
name|apropos_command
parameter_list|(
name|char
modifier|*
name|searchstr
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
specifier|extern
name|struct
name|cmd_list_element
modifier|*
name|cmdlist
decl_stmt|;
comment|/*This is the main command list*/
name|regex_t
name|pattern
decl_stmt|;
name|char
modifier|*
name|pattern_fastmap
decl_stmt|;
name|char
name|errorbuffer
index|[
literal|512
index|]
decl_stmt|;
name|pattern_fastmap
operator|=
name|xcalloc
argument_list|(
literal|256
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|searchstr
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"REGEXP string is empty"
argument_list|)
expr_stmt|;
if|if
condition|(
name|regcomp
argument_list|(
operator|&
name|pattern
argument_list|,
name|searchstr
argument_list|,
name|REG_ICASE
argument_list|)
operator|==
literal|0
condition|)
block|{
name|pattern
operator|.
name|fastmap
operator|=
name|pattern_fastmap
expr_stmt|;
name|re_compile_fastmap
argument_list|(
operator|&
name|pattern
argument_list|)
expr_stmt|;
name|apropos_cmd
argument_list|(
name|gdb_stdout
argument_list|,
name|cmdlist
argument_list|,
operator|&
name|pattern
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|regerror
argument_list|(
name|regcomp
argument_list|(
operator|&
name|pattern
argument_list|,
name|searchstr
argument_list|,
name|REG_ICASE
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|errorbuffer
argument_list|,
literal|512
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Error in regular expression:%s"
argument_list|,
name|errorbuffer
argument_list|)
expr_stmt|;
block|}
name|xfree
argument_list|(
name|pattern_fastmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|set_debug
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|printf_unfiltered
argument_list|(
literal|"\"set debug\" must be followed by the name of a print subcommand.\n"
argument_list|)
expr_stmt|;
name|help_list
argument_list|(
name|setdebuglist
argument_list|,
literal|"set debug "
argument_list|,
operator|-
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|show_debug
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|cmd_show_list
argument_list|(
name|showdebuglist
argument_list|,
name|from_tty
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|init_cmd_lists
parameter_list|(
name|void
parameter_list|)
block|{
name|cmdlist
operator|=
name|NULL
expr_stmt|;
name|infolist
operator|=
name|NULL
expr_stmt|;
name|enablelist
operator|=
name|NULL
expr_stmt|;
name|disablelist
operator|=
name|NULL
expr_stmt|;
name|togglelist
operator|=
name|NULL
expr_stmt|;
name|stoplist
operator|=
name|NULL
expr_stmt|;
name|deletelist
operator|=
name|NULL
expr_stmt|;
name|enablebreaklist
operator|=
name|NULL
expr_stmt|;
name|setlist
operator|=
name|NULL
expr_stmt|;
name|unsetlist
operator|=
name|NULL
expr_stmt|;
name|showlist
operator|=
name|NULL
expr_stmt|;
name|sethistlist
operator|=
name|NULL
expr_stmt|;
name|showhistlist
operator|=
name|NULL
expr_stmt|;
name|unsethistlist
operator|=
name|NULL
expr_stmt|;
name|maintenancelist
operator|=
name|NULL
expr_stmt|;
name|maintenanceinfolist
operator|=
name|NULL
expr_stmt|;
name|maintenanceprintlist
operator|=
name|NULL
expr_stmt|;
name|setprintlist
operator|=
name|NULL
expr_stmt|;
name|showprintlist
operator|=
name|NULL
expr_stmt|;
name|setchecklist
operator|=
name|NULL
expr_stmt|;
name|showchecklist
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|init_cli_cmds
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
comment|/* Define the classes of commands.      They will appear in the help list in the reverse of this order.  */
name|add_cmd
argument_list|(
literal|"internals"
argument_list|,
name|class_maintenance
argument_list|,
name|NULL
argument_list|,
literal|"Maintenance commands.\n\ Some gdb commands are provided just for use by gdb maintainers.\n\ These commands are subject to frequent change, and may not be as\n\ well documented as user commands."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"obscure"
argument_list|,
name|class_obscure
argument_list|,
name|NULL
argument_list|,
literal|"Obscure features."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"aliases"
argument_list|,
name|class_alias
argument_list|,
name|NULL
argument_list|,
literal|"Aliases of other commands."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"user-defined"
argument_list|,
name|class_user
argument_list|,
name|NULL
argument_list|,
literal|"User-defined commands.\n\ The commands in this class are those defined by the user.\n\ Use the \"define\" command to define a command."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"support"
argument_list|,
name|class_support
argument_list|,
name|NULL
argument_list|,
literal|"Support facilities."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dbx_commands
condition|)
name|add_cmd
argument_list|(
literal|"status"
argument_list|,
name|class_info
argument_list|,
name|NULL
argument_list|,
literal|"Status inquiries."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"files"
argument_list|,
name|class_files
argument_list|,
name|NULL
argument_list|,
literal|"Specifying and examining files."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"breakpoints"
argument_list|,
name|class_breakpoint
argument_list|,
name|NULL
argument_list|,
literal|"Making program stop at certain points."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"data"
argument_list|,
name|class_vars
argument_list|,
name|NULL
argument_list|,
literal|"Examining data."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"stack"
argument_list|,
name|class_stack
argument_list|,
name|NULL
argument_list|,
literal|"Examining the stack.\n\ The stack is made up of stack frames.  Gdb assigns numbers to stack frames\n\ counting from zero for the innermost (currently executing) frame.\n\n\ At any time gdb identifies one frame as the \"selected\" frame.\n\ Variable lookups are done with respect to the selected frame.\n\ When the program being debugged stops, gdb selects the innermost frame.\n\ The commands below can be used to select other frames by number or address."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"running"
argument_list|,
name|class_run
argument_list|,
name|NULL
argument_list|,
literal|"Running the program."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
comment|/* Define general commands. */
name|add_com
argument_list|(
literal|"pwd"
argument_list|,
name|class_files
argument_list|,
name|pwd_command
argument_list|,
literal|"Print working directory.  This is used for your program as well."
argument_list|)
expr_stmt|;
name|c
operator|=
name|add_cmd
argument_list|(
literal|"cd"
argument_list|,
name|class_files
argument_list|,
name|cd_command
argument_list|,
literal|"Set working directory to DIR for debugger and program being debugged.\n\ The change does not take effect for the program being debugged\n\ until the next time it is started."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|c
operator|->
name|completer
operator|=
name|filename_completer
expr_stmt|;
name|add_com
argument_list|(
literal|"echo"
argument_list|,
name|class_support
argument_list|,
name|echo_command
argument_list|,
literal|"Print a constant string.  Give string as argument.\n\ C escape sequences may be used in the argument.\n\ No newline is added at the end of the argument;\n\ use \"\\n\" if you want a newline to be printed.\n\ Since leading and trailing whitespace are ignored in command arguments,\n\ if you want to print some you must use \"\\\" before leading whitespace\n\ to be printed or after trailing whitespace."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"document"
argument_list|,
name|class_support
argument_list|,
name|document_command
argument_list|,
literal|"Document a user-defined command.\n\ Give command name as argument.  Give documentation on following lines.\n\ End with a line of just \"end\"."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"define"
argument_list|,
name|class_support
argument_list|,
name|define_command
argument_list|,
literal|"Define a new command name.  Command name is argument.\n\ Definition appears on following lines, one command per line.\n\ End with a line of just \"end\".\n\ Use the \"document\" command to give documentation for the new command.\n\ Commands defined in this way may have up to ten arguments."
argument_list|)
expr_stmt|;
name|c
operator|=
name|add_cmd
argument_list|(
literal|"source"
argument_list|,
name|class_support
argument_list|,
name|source_command
argument_list|,
literal|"Read commands from a file named FILE.\n\ Note that the file \""
name|GDBINIT_FILENAME
literal|"\" is read automatically in this way\n\ when gdb is started."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|c
operator|->
name|completer
operator|=
name|filename_completer
expr_stmt|;
name|add_com
argument_list|(
literal|"quit"
argument_list|,
name|class_support
argument_list|,
name|quit_command
argument_list|,
literal|"Exit gdb."
argument_list|)
expr_stmt|;
name|c
operator|=
name|add_com
argument_list|(
literal|"help"
argument_list|,
name|class_support
argument_list|,
name|help_command
argument_list|,
literal|"Print list of commands."
argument_list|)
expr_stmt|;
name|c
operator|->
name|completer
operator|=
name|command_completer
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"q"
argument_list|,
literal|"quit"
argument_list|,
name|class_support
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"h"
argument_list|,
literal|"help"
argument_list|,
name|class_support
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|c
operator|=
name|add_set_cmd
argument_list|(
literal|"verbose"
argument_list|,
name|class_support
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|info_verbose
argument_list|,
literal|"Set "
argument_list|,
operator|&
name|setlist
argument_list|)
operator|,
name|add_show_from_set
argument_list|(
name|c
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|set_cmd_sfunc
argument_list|(
name|c
argument_list|,
name|set_verbose
argument_list|)
expr_stmt|;
name|set_verbose
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"history"
argument_list|,
name|class_support
argument_list|,
name|set_history
argument_list|,
literal|"Generic command for setting command history parameters."
argument_list|,
operator|&
name|sethistlist
argument_list|,
literal|"set history "
argument_list|,
literal|0
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"history"
argument_list|,
name|class_support
argument_list|,
name|show_history
argument_list|,
literal|"Generic command for showing command history parameters."
argument_list|,
operator|&
name|showhistlist
argument_list|,
literal|"show history "
argument_list|,
literal|0
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"expansion"
argument_list|,
name|no_class
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|history_expansion_p
argument_list|,
literal|"Set history expansion on command input.\n\ Without an argument, history expansion is enabled."
argument_list|,
operator|&
name|sethistlist
argument_list|)
argument_list|,
operator|&
name|showhistlist
argument_list|)
expr_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"info"
argument_list|,
name|class_info
argument_list|,
name|info_command
argument_list|,
literal|"Generic command for showing things about the program being debugged."
argument_list|,
operator|&
name|infolist
argument_list|,
literal|"info "
argument_list|,
literal|0
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"i"
argument_list|,
literal|"info"
argument_list|,
name|class_info
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"complete"
argument_list|,
name|class_obscure
argument_list|,
name|complete_command
argument_list|,
literal|"List the completions for the rest of the line as a command."
argument_list|)
expr_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"show"
argument_list|,
name|class_info
argument_list|,
name|show_command
argument_list|,
literal|"Generic command for showing things about the debugger."
argument_list|,
operator|&
name|showlist
argument_list|,
literal|"show "
argument_list|,
literal|0
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
comment|/* Another way to get at the same thing.  */
name|add_info
argument_list|(
literal|"set"
argument_list|,
name|show_command
argument_list|,
literal|"Show all GDB settings."
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"commands"
argument_list|,
name|no_class
argument_list|,
name|show_commands
argument_list|,
literal|"Show the history of commands you typed.\n\ You can supply a command number to start with, or a `+' to start after\n\ the previous command number shown."
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"version"
argument_list|,
name|no_class
argument_list|,
name|show_version
argument_list|,
literal|"Show what version of GDB this is."
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"while"
argument_list|,
name|class_support
argument_list|,
name|while_command
argument_list|,
literal|"Execute nested commands WHILE the conditional expression is non zero.\n\ The conditional expression must follow the word `while' and must in turn be\n\ followed by a new line.  The nested commands must be entered one per line,\n\ and should be terminated by the word `end'."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"if"
argument_list|,
name|class_support
argument_list|,
name|if_command
argument_list|,
literal|"Execute nested commands once IF the conditional expression is non zero.\n\ The conditional expression must follow the word `if' and must in turn be\n\ followed by a new line.  The nested commands must be entered one per line,\n\ and should be terminated by the word 'else' or `end'.  If an else clause\n\ is used, the same rules apply to its nested commands as to the first ones."
argument_list|)
expr_stmt|;
comment|/* If target is open when baud changes, it doesn't take effect until the      next open (I think, not sure).  */
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"remotebaud"
argument_list|,
name|no_class
argument_list|,
name|var_zinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|baud_rate
argument_list|,
literal|"Set baud rate for remote serial I/O.\n\ This value is used to set the speed of the serial port when debugging\n\ using remote targets."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|c
operator|=
name|add_set_cmd
argument_list|(
literal|"remotedebug"
argument_list|,
name|no_class
argument_list|,
name|var_zinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|remote_debug
argument_list|,
literal|"Set debugging of remote protocol.\n\ When enabled, each packet sent or received with the remote target\n\ is displayed."
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|deprecate_cmd
argument_list|(
name|c
argument_list|,
literal|"set debug remote"
argument_list|)
expr_stmt|;
name|deprecate_cmd
argument_list|(
name|add_show_from_set
argument_list|(
name|c
argument_list|,
operator|&
name|showlist
argument_list|)
argument_list|,
literal|"show debug remote"
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"remote"
argument_list|,
name|no_class
argument_list|,
name|var_zinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|remote_debug
argument_list|,
literal|"Set debugging of remote protocol.\n\ When enabled, each packet sent or received with the remote target\n\ is displayed."
argument_list|,
operator|&
name|setdebuglist
argument_list|)
argument_list|,
operator|&
name|showdebuglist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"remotetimeout"
argument_list|,
name|no_class
argument_list|,
name|var_integer
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|remote_timeout
argument_list|,
literal|"Set timeout limit to wait for target to respond.\n\ This value is used to set the time limit for gdb to wait for a response\n\ from the target."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"debug"
argument_list|,
name|no_class
argument_list|,
name|set_debug
argument_list|,
literal|"Generic command for setting gdb debugging flags"
argument_list|,
operator|&
name|setdebuglist
argument_list|,
literal|"set debug "
argument_list|,
literal|0
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"debug"
argument_list|,
name|no_class
argument_list|,
name|show_debug
argument_list|,
literal|"Generic command for showing gdb debugging flags"
argument_list|,
operator|&
name|showdebuglist
argument_list|,
literal|"show debug "
argument_list|,
literal|0
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|c
operator|=
name|add_com
argument_list|(
literal|"shell"
argument_list|,
name|class_support
argument_list|,
name|shell_escape
argument_list|,
literal|"Execute the rest of the line as a shell command.  \n\ With no arguments, run an inferior shell."
argument_list|)
expr_stmt|;
name|c
operator|->
name|completer
operator|=
name|filename_completer
expr_stmt|;
comment|/* NOTE: cagney/2000-03-20: Being able to enter ``(gdb) !ls'' would      be a really useful feature.  Unfortunately, the below wont do      this.  Instead it adds support for the form ``(gdb) ! ls''      (i.e. the space is required).  If the ``!'' command below is      added the complains about no ``!'' command would be replaced by      complains about how the ``!'' command is broken :-) */
if|if
condition|(
name|xdb_commands
condition|)
name|add_com_alias
argument_list|(
literal|"!"
argument_list|,
literal|"shell"
argument_list|,
name|class_support
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|c
operator|=
name|add_com
argument_list|(
literal|"make"
argument_list|,
name|class_support
argument_list|,
name|make_command
argument_list|,
literal|"Run the ``make'' program using the rest of the line as arguments."
argument_list|)
expr_stmt|;
name|c
operator|->
name|completer
operator|=
name|filename_completer
expr_stmt|;
name|add_cmd
argument_list|(
literal|"user"
argument_list|,
name|no_class
argument_list|,
name|show_user
argument_list|,
literal|"Show definitions of user defined commands.\n\ Argument is the name of the user defined command.\n\ With no argument, show definitions of all user defined commands."
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"apropos"
argument_list|,
name|class_support
argument_list|,
name|apropos_command
argument_list|,
literal|"Search for commands matching a REGEXP"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

