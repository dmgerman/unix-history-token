begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Header file for GDB command decoding library.    Copyright 2000 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CLI_DECODE_H
argument_list|)
end_if

begin_define
define|#
directive|define
name|CLI_DECODE_H
value|1
end_define

begin_include
include|#
directive|include
file|"gdb_regex.h"
end_include

begin_comment
comment|/* Needed by apropos_cmd.  */
end_comment

begin_comment
comment|/* Command classes are top-level categories into which commands are broken    down for "help" purposes.      Notes on classes: class_alias is for alias commands which are not    abbreviations of the original command.  class-pseudo is for    commands which are not really commands nor help topics ("stop").  */
end_comment

begin_enum
enum|enum
name|command_class
block|{
comment|/* Special args to help_list */
name|class_deprecated
block|,
name|all_classes
init|=
operator|-
literal|2
block|,
name|all_commands
init|=
operator|-
literal|1
block|,
comment|/* Classes of commands */
name|no_class
init|=
operator|-
literal|1
block|,
name|class_run
init|=
literal|0
block|,
name|class_vars
block|,
name|class_stack
block|,
name|class_files
block|,
name|class_support
block|,
name|class_info
block|,
name|class_breakpoint
block|,
name|class_trace
block|,
name|class_alias
block|,
name|class_obscure
block|,
name|class_user
block|,
name|class_maintenance
block|,
name|class_pseudo
block|,
name|class_tui
block|,
name|class_xdb
block|}
enum|;
end_enum

begin_comment
comment|/* Not a set/show command.  Note that some commands which begin with    "set" or "show" might be in this category, if their syntax does    not fall into one of the following categories.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
name|cmd_types
block|{
name|not_set_cmd
block|,
name|set_cmd
block|,
name|show_cmd
block|}
name|cmd_types
typedef|;
end_typedef

begin_comment
comment|/* Reasonable values for an AUTO_BOOLEAN variable. */
end_comment

begin_enum
enum|enum
name|cmd_auto_boolean
block|{
name|CMD_AUTO_BOOLEAN_TRUE
block|,
name|CMD_AUTO_BOOLEAN_FALSE
block|,
name|CMD_AUTO_BOOLEAN_AUTO
block|}
enum|;
end_enum

begin_comment
comment|/* Types of "set" or "show" command.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
name|var_types
block|{
comment|/* "on" or "off".  *VAR is an integer which is nonzero for on,        zero for off.  */
name|var_boolean
block|,
comment|/* "on" / "true" / "enable" or "off" / "false" / "disable" or        "auto.  *VAR is an ``enum cmd_auto_boolean''.  NOTE: In general        a custom show command will need to be implemented - one that        for "auto" prints both the "auto" and the current auto-selected        value. */
name|var_auto_boolean
block|,
comment|/* Unsigned Integer.  *VAR is an unsigned int.  The user can type 0        to mean "unlimited", which is stored in *VAR as UINT_MAX.  */
name|var_uinteger
block|,
comment|/* Like var_uinteger but signed.  *VAR is an int.  The user can type 0        to mean "unlimited", which is stored in *VAR as INT_MAX.  */
name|var_integer
block|,
comment|/* String which the user enters with escapes (e.g. the user types \n and        it is a real newline in the stored string).        *VAR is a malloc'd string, or NULL if the string is empty.  */
name|var_string
block|,
comment|/* String which stores what the user types verbatim.        *VAR is a malloc'd string, or NULL if the string is empty.  */
name|var_string_noescape
block|,
comment|/* String which stores a filename.        *VAR is a malloc'd string, or NULL if the string is empty.  */
name|var_filename
block|,
comment|/* ZeroableInteger.  *VAR is an int.  Like Unsigned Integer except        that zero really means zero.  */
name|var_zinteger
block|,
comment|/* Enumerated type.  Can only have one of the specified values.  *VAR is a        char pointer to the name of the element that we find.  */
name|var_enum
block|}
name|var_types
typedef|;
end_typedef

begin_comment
comment|/* This structure records one command'd definition.  */
end_comment

begin_comment
comment|/* This flag is used by the code executing commands to warn the user     the first time a deprecated command is used, see the 'flags' field in    the following struct. */
end_comment

begin_define
define|#
directive|define
name|CMD_DEPRECATED
value|0x1
end_define

begin_define
define|#
directive|define
name|DEPRECATED_WARN_USER
value|0x2
end_define

begin_define
define|#
directive|define
name|MALLOCED_REPLACEMENT
value|0x4
end_define

begin_struct
struct|struct
name|cmd_list_element
block|{
comment|/* Points to next command in this list.  */
name|struct
name|cmd_list_element
modifier|*
name|next
decl_stmt|;
comment|/* Name of this command.  */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Command class; class values are chosen by application program.  */
name|enum
name|command_class
name|class
decl_stmt|;
comment|/* Function definition of this command.  NULL for command class        names and for help topics that are not really commands.  NOTE:        cagney/2002-02-02: This function signature is evolving.  For        the moment suggest sticking with either set_cmd_cfunc() or        set_cmd_sfunc().  */
name|void
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|struct
name|cmd_list_element
modifier|*
name|c
parameter_list|,
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
function_decl|;
comment|/* The command's real callback.  At present func() bounces through        to one of the below.  */
union|union
block|{
comment|/* If type is not_set_cmd, call it like this:  */
name|void
function_decl|(
modifier|*
name|cfunc
function_decl|)
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
function_decl|;
comment|/* If type is set_cmd or show_cmd, first set the variables, and 	   then call this.  */
name|void
function_decl|(
modifier|*
name|sfunc
function_decl|)
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
name|c
parameter_list|)
function_decl|;
block|}
name|function
union|;
comment|/* Documentation of this command (or help topic).        First line is brief documentation; remaining lines form, with it,        the full documentation.  First line should end with a period.        Entire string should also end with a period, not a newline.  */
name|char
modifier|*
name|doc
decl_stmt|;
comment|/* flags : a bitfield                 bit 0: (LSB) CMD_DEPRECATED, when 1 indicated that this command        is deprecated. It may be removed from gdb's command set in the        future.         bit 1: DEPRECATED_WARN_USER, the user needs to be warned that        this is a deprecated command.  The user should only be warned        the first time a command is used.                 bit 2: MALLOCED_REPLACEMENT, when functions are deprecated at        compile time (this is the way it should, in general, be done)        the memory containing the replacement string is statically        allocated.  In some cases it makes sense to deprecate commands        at runtime (the testsuite is one example).  In this case the        memory for replacement is malloc'ed.  When a command is        undeprecated or re-deprecated at runtime we don't want to risk        calling free on statically allocated memory, so we check this        flag.        */
name|int
name|flags
decl_stmt|;
comment|/* if this command is deprecated, this is the replacement name */
name|char
modifier|*
name|replacement
decl_stmt|;
comment|/* If this command represents a show command, then this function        is called before the variable's value is examined.  */
name|void
function_decl|(
modifier|*
name|pre_show_hook
function_decl|)
parameter_list|(
name|struct
name|cmd_list_element
modifier|*
name|c
parameter_list|)
function_decl|;
comment|/* Hook for another command to be executed before this command.  */
name|struct
name|cmd_list_element
modifier|*
name|hook_pre
decl_stmt|;
comment|/* Hook for another command to be executed after this command.  */
name|struct
name|cmd_list_element
modifier|*
name|hook_post
decl_stmt|;
comment|/* Flag that specifies if this command is already running it's hook. */
comment|/* Prevents the possibility of hook recursion. */
name|int
name|hook_in
decl_stmt|;
comment|/* Nonzero identifies a prefix command.  For them, the address        of the variable containing the list of subcommands.  */
name|struct
name|cmd_list_element
modifier|*
modifier|*
name|prefixlist
decl_stmt|;
comment|/* For prefix commands only:        String containing prefix commands to get here: this one        plus any others needed to get to it.  Should end in a space.        It is used before the word "command" in describing the        commands reached through this prefix.  */
name|char
modifier|*
name|prefixname
decl_stmt|;
comment|/* For prefix commands only:        nonzero means do not get an error if subcommand is not        recognized; call the prefix's own function in that case.  */
name|char
name|allow_unknown
decl_stmt|;
comment|/* Nonzero says this is an abbreviation, and should not        be mentioned in lists of commands.        This allows "br<tab>" to complete to "break", which it        otherwise wouldn't.  */
name|char
name|abbrev_flag
decl_stmt|;
comment|/* Completion routine for this command.  TEXT is the text beyond        what was matched for the command itself (leading whitespace is        skipped).  It stops where we are supposed to stop completing        (rl_point) and is '\0' terminated.         Return value is a malloc'd vector of pointers to possible completions        terminated with NULL.  If there are no completions, returning a pointer        to a NULL would work but returning NULL itself is also valid.        WORD points in the same buffer as TEXT, and completions should be        returned relative to this position.  For example, suppose TEXT is "foo"        and we want to complete to "foobar".  If WORD is "oo", return        "oobar"; if WORD is "baz/foo", return "baz/foobar".  */
name|char
modifier|*
modifier|*
function_decl|(
modifier|*
name|completer
function_decl|)
parameter_list|(
name|char
modifier|*
name|text
parameter_list|,
name|char
modifier|*
name|word
parameter_list|)
function_decl|;
comment|/* Type of "set" or "show" command (or SET_NOT_SET if not "set"        or "show").  */
name|cmd_types
name|type
decl_stmt|;
comment|/* Pointer to variable affected by "set" and "show".  Doesn't matter        if type is not_set.  */
name|void
modifier|*
name|var
decl_stmt|;
comment|/* What kind of variable is *VAR?  */
name|var_types
name|var_type
decl_stmt|;
comment|/* Pointer to NULL terminated list of enumerated values (like argv).  */
specifier|const
name|char
modifier|*
modifier|*
name|enums
decl_stmt|;
comment|/* Pointer to command strings of user-defined commands */
name|struct
name|command_line
modifier|*
name|user_commands
decl_stmt|;
comment|/* Pointer to command that is hooked by this one, (by hook_pre)        so the hook can be removed when this one is deleted.  */
name|struct
name|cmd_list_element
modifier|*
name|hookee_pre
decl_stmt|;
comment|/* Pointer to command that is hooked by this one, (by hook_post)        so the hook can be removed when this one is deleted.  */
name|struct
name|cmd_list_element
modifier|*
name|hookee_post
decl_stmt|;
comment|/* Pointer to command that is aliased by this one, so the        aliased command can be located in case it has been hooked.  */
name|struct
name|cmd_list_element
modifier|*
name|cmd_pointer
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* API to the manipulation of command lists.  */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|cmd_list_element
modifier|*
name|add_cmd
argument_list|(
name|char
operator|*
argument_list|,
expr|enum
name|command_class
argument_list|,
name|void
argument_list|(
operator|*
name|fun
argument_list|)
argument_list|(
name|char
operator|*
argument_list|,
name|int
argument_list|)
argument_list|,
name|char
operator|*
argument_list|,
expr|struct
name|cmd_list_element
operator|*
operator|*
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|struct
name|cmd_list_element
modifier|*
name|add_alias_cmd
parameter_list|(
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|enum
name|command_class
parameter_list|,
name|int
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|struct
name|cmd_list_element
modifier|*
name|add_prefix_cmd
argument_list|(
name|char
operator|*
argument_list|,
expr|enum
name|command_class
argument_list|,
name|void
argument_list|(
operator|*
name|fun
argument_list|)
argument_list|(
name|char
operator|*
argument_list|,
name|int
argument_list|)
argument_list|,
name|char
operator|*
argument_list|,
expr|struct
name|cmd_list_element
operator|*
operator|*
argument_list|,
name|char
operator|*
argument_list|,
name|int
argument_list|,
expr|struct
name|cmd_list_element
operator|*
operator|*
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|cmd_list_element
modifier|*
name|add_abbrev_prefix_cmd
argument_list|(
name|char
operator|*
argument_list|,
expr|enum
name|command_class
argument_list|,
name|void
argument_list|(
operator|*
name|fun
argument_list|)
argument_list|(
name|char
operator|*
argument_list|,
name|int
argument_list|)
argument_list|,
name|char
operator|*
argument_list|,
expr|struct
name|cmd_list_element
operator|*
operator|*
argument_list|,
name|char
operator|*
argument_list|,
name|int
argument_list|,
expr|struct
name|cmd_list_element
operator|*
operator|*
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set the commands corresponding callback.  */
end_comment

begin_function_decl
specifier|extern
name|void
name|set_cmd_cfunc
parameter_list|(
name|struct
name|cmd_list_element
modifier|*
name|cmd
parameter_list|,
name|void
function_decl|(
modifier|*
name|cfunc
function_decl|)
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|set_cmd_sfunc
parameter_list|(
name|struct
name|cmd_list_element
modifier|*
name|cmd
parameter_list|,
name|void
function_decl|(
modifier|*
name|sfunc
function_decl|)
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
name|c
parameter_list|)
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* HACK: cagney/2002-02-23: Code, mostly in tracepoints.c, grubs    around in cmd objects to test the value of the commands sfunc().  */
end_comment

begin_function_decl
specifier|extern
name|int
name|cmd_cfunc_eq
parameter_list|(
name|struct
name|cmd_list_element
modifier|*
name|cmd
parameter_list|,
name|void
function_decl|(
modifier|*
name|cfunc
function_decl|)
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|struct
name|cmd_list_element
modifier|*
name|lookup_cmd
parameter_list|(
name|char
modifier|*
modifier|*
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|struct
name|cmd_list_element
modifier|*
name|lookup_cmd_1
parameter_list|(
name|char
modifier|*
modifier|*
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|struct
name|cmd_list_element
modifier|*
name|deprecate_cmd
parameter_list|(
name|struct
name|cmd_list_element
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|deprecated_cmd_warning
parameter_list|(
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|lookup_cmd_composition
parameter_list|(
name|char
modifier|*
name|text
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
modifier|*
name|alias
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
modifier|*
name|prefix_cmd
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
modifier|*
name|cmd
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|struct
name|cmd_list_element
modifier|*
name|add_com
argument_list|(
name|char
operator|*
argument_list|,
expr|enum
name|command_class
argument_list|,
name|void
argument_list|(
operator|*
name|fun
argument_list|)
argument_list|(
name|char
operator|*
argument_list|,
name|int
argument_list|)
argument_list|,
name|char
operator|*
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|struct
name|cmd_list_element
modifier|*
name|add_com_alias
parameter_list|(
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|enum
name|command_class
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|struct
name|cmd_list_element
modifier|*
name|add_info
parameter_list|(
name|char
modifier|*
parameter_list|,
name|void
function_decl|(
modifier|*
name|fun
function_decl|)
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|struct
name|cmd_list_element
modifier|*
name|add_info_alias
parameter_list|(
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
modifier|*
name|complete_on_cmdlist
parameter_list|(
name|struct
name|cmd_list_element
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
modifier|*
name|complete_on_enum
parameter_list|(
specifier|const
name|char
modifier|*
name|enumlist
index|[]
parameter_list|,
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|delete_cmd
parameter_list|(
name|char
modifier|*
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|help_cmd_list
parameter_list|(
name|struct
name|cmd_list_element
modifier|*
parameter_list|,
name|enum
name|command_class
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|ui_file
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|struct
name|cmd_list_element
modifier|*
name|add_set_cmd
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|enum
name|command_class
name|class
parameter_list|,
name|var_types
name|var_type
parameter_list|,
name|void
modifier|*
name|var
parameter_list|,
name|char
modifier|*
name|doc
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
modifier|*
name|list
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|struct
name|cmd_list_element
modifier|*
name|add_set_enum_cmd
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|enum
name|command_class
name|class
parameter_list|,
specifier|const
name|char
modifier|*
name|enumlist
index|[]
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|var
parameter_list|,
name|char
modifier|*
name|doc
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
modifier|*
name|list
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|struct
name|cmd_list_element
modifier|*
name|add_set_auto_boolean_cmd
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|enum
name|command_class
name|class
parameter_list|,
name|enum
name|cmd_auto_boolean
modifier|*
name|var
parameter_list|,
name|char
modifier|*
name|doc
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
modifier|*
name|list
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|struct
name|cmd_list_element
modifier|*
name|add_set_boolean_cmd
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|enum
name|command_class
name|class
parameter_list|,
name|int
modifier|*
name|var
parameter_list|,
name|char
modifier|*
name|doc
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
modifier|*
name|list
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|struct
name|cmd_list_element
modifier|*
name|add_show_from_set
parameter_list|(
name|struct
name|cmd_list_element
modifier|*
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Functions that implement commands about CLI commands. */
end_comment

begin_function_decl
specifier|extern
name|void
name|help_cmd
parameter_list|(
name|char
modifier|*
parameter_list|,
name|struct
name|ui_file
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|help_list
parameter_list|(
name|struct
name|cmd_list_element
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|enum
name|command_class
parameter_list|,
name|struct
name|ui_file
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|apropos_cmd
parameter_list|(
name|struct
name|ui_file
modifier|*
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
parameter_list|,
name|struct
name|re_pattern_buffer
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Used to mark commands that don't do anything.  If we just leave the    function field NULL, the command is interpreted as a help topic, or    as a class of commands.  */
end_comment

begin_function_decl
specifier|extern
name|void
name|not_just_help_class_command
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Exported to cli/cli-setshow.c */
end_comment

begin_function_decl
specifier|extern
name|void
name|print_doc_line
parameter_list|(
name|struct
name|ui_file
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined (CLI_DECODE_H) */
end_comment

end_unit

