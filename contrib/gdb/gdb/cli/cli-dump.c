begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Dump-to-file commands, for GDB, the GNU debugger.     Copyright 2002 Free Software Foundation, Inc.     Contributed by Red Hat.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"cli/cli-decode.h"
end_include

begin_include
include|#
directive|include
file|"cli/cli-cmds.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"completer.h"
end_include

begin_include
include|#
directive|include
file|"cli/cli-dump.h"
end_include

begin_include
include|#
directive|include
file|"gdb_assert.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"readline/readline.h"
end_include

begin_define
define|#
directive|define
name|XMALLOC
parameter_list|(
name|TYPE
parameter_list|)
value|((TYPE*) xmalloc (sizeof (TYPE)))
end_define

begin_function
name|char
modifier|*
name|skip_spaces
parameter_list|(
name|char
modifier|*
name|chp
parameter_list|)
block|{
if|if
condition|(
name|chp
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|chp
argument_list|)
condition|)
name|chp
operator|++
expr_stmt|;
return|return
name|chp
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|scan_expression_with_cleanup
parameter_list|(
name|char
modifier|*
modifier|*
name|cmd
parameter_list|,
specifier|const
name|char
modifier|*
name|def
parameter_list|)
block|{
if|if
condition|(
operator|(
operator|*
name|cmd
operator|)
operator|==
name|NULL
operator|||
operator|(
operator|*
operator|*
name|cmd
operator|)
operator|==
literal|'\0'
condition|)
block|{
name|char
modifier|*
name|exp
init|=
name|xstrdup
argument_list|(
name|def
argument_list|)
decl_stmt|;
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|exp
argument_list|)
expr_stmt|;
return|return
name|exp
return|;
block|}
else|else
block|{
name|char
modifier|*
name|exp
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
name|end
operator|=
operator|(
operator|*
name|cmd
operator|)
operator|+
name|strcspn
argument_list|(
operator|*
name|cmd
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
name|exp
operator|=
name|savestring
argument_list|(
operator|(
operator|*
name|cmd
operator|)
argument_list|,
name|end
operator|-
operator|(
operator|*
name|cmd
operator|)
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|exp
argument_list|)
expr_stmt|;
operator|(
operator|*
name|cmd
operator|)
operator|=
name|skip_spaces
argument_list|(
name|end
argument_list|)
expr_stmt|;
return|return
name|exp
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|do_fclose_cleanup
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|FILE
modifier|*
name|file
init|=
name|arg
decl_stmt|;
name|fclose
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|cleanup
modifier|*
name|make_cleanup_fclose
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
return|return
name|make_cleanup
argument_list|(
name|do_fclose_cleanup
argument_list|,
name|file
argument_list|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|scan_filename_with_cleanup
parameter_list|(
name|char
modifier|*
modifier|*
name|cmd
parameter_list|,
specifier|const
name|char
modifier|*
name|defname
parameter_list|)
block|{
name|char
modifier|*
name|filename
decl_stmt|;
name|char
modifier|*
name|fullname
decl_stmt|;
comment|/* FIXME: Need to get the ``/a(ppend)'' flag from somewhere.  */
comment|/* File.  */
if|if
condition|(
operator|(
operator|*
name|cmd
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|defname
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Missing filename."
argument_list|)
expr_stmt|;
name|filename
operator|=
name|xstrdup
argument_list|(
name|defname
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* FIXME: should parse a possibly quoted string.  */
name|char
modifier|*
name|end
decl_stmt|;
operator|(
operator|*
name|cmd
operator|)
operator|=
name|skip_spaces
argument_list|(
operator|*
name|cmd
argument_list|)
expr_stmt|;
name|end
operator|=
operator|*
name|cmd
operator|+
name|strcspn
argument_list|(
operator|*
name|cmd
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
name|filename
operator|=
name|savestring
argument_list|(
operator|(
operator|*
name|cmd
operator|)
argument_list|,
name|end
operator|-
operator|(
operator|*
name|cmd
operator|)
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|filename
argument_list|)
expr_stmt|;
operator|(
operator|*
name|cmd
operator|)
operator|=
name|skip_spaces
argument_list|(
name|end
argument_list|)
expr_stmt|;
block|}
name|gdb_assert
argument_list|(
name|filename
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|fullname
operator|=
name|tilde_expand
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|fullname
argument_list|)
expr_stmt|;
return|return
name|fullname
return|;
block|}
end_function

begin_function
name|FILE
modifier|*
name|fopen_with_cleanup
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|,
specifier|const
name|char
modifier|*
name|mode
parameter_list|)
block|{
name|FILE
modifier|*
name|file
init|=
name|fopen
argument_list|(
name|filename
argument_list|,
name|mode
argument_list|)
decl_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|make_cleanup_fclose
argument_list|(
name|file
argument_list|)
expr_stmt|;
return|return
name|file
return|;
block|}
end_function

begin_function
specifier|static
name|bfd
modifier|*
name|bfd_openr_with_cleanup
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
specifier|const
name|char
modifier|*
name|target
parameter_list|)
block|{
name|bfd
modifier|*
name|ibfd
decl_stmt|;
name|ibfd
operator|=
name|bfd_openr
argument_list|(
name|filename
argument_list|,
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|ibfd
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Failed to open %s: %s."
argument_list|,
name|filename
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|make_cleanup_bfd_close
argument_list|(
name|ibfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_check_format
argument_list|(
name|ibfd
argument_list|,
name|bfd_object
argument_list|)
condition|)
name|error
argument_list|(
literal|"'%s' is not a recognized file format."
argument_list|,
name|filename
argument_list|)
expr_stmt|;
return|return
name|ibfd
return|;
block|}
end_function

begin_function
specifier|static
name|bfd
modifier|*
name|bfd_openw_with_cleanup
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|,
specifier|const
name|char
modifier|*
name|target
parameter_list|,
name|char
modifier|*
name|mode
parameter_list|)
block|{
name|bfd
modifier|*
name|obfd
decl_stmt|;
if|if
condition|(
operator|*
name|mode
operator|==
literal|'w'
condition|)
comment|/* Write: create new file */
block|{
name|obfd
operator|=
name|bfd_openw
argument_list|(
name|filename
argument_list|,
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|obfd
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Failed to open %s: %s."
argument_list|,
name|filename
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|make_cleanup_bfd_close
argument_list|(
name|obfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_format
argument_list|(
name|obfd
argument_list|,
name|bfd_object
argument_list|)
condition|)
name|error
argument_list|(
literal|"bfd_openw_with_cleanup: %s."
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|mode
operator|==
literal|'a'
condition|)
comment|/* Append to existing file */
block|{
comment|/* FIXME -- doesn't work... */
name|error
argument_list|(
literal|"bfd_openw does not work with append."
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"bfd_openw_with_cleanup: unknown mode %s."
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
name|obfd
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|dump_cmdlist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|append_cmdlist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|srec_cmdlist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|ihex_cmdlist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|tekhex_cmdlist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|binary_dump_cmdlist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|binary_append_cmdlist
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|dump_command
parameter_list|(
name|char
modifier|*
name|cmd
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|printf_unfiltered
argument_list|(
literal|"\"dump\" must be followed by a subcommand.\n\n"
argument_list|)
expr_stmt|;
name|help_list
argument_list|(
name|dump_cmdlist
argument_list|,
literal|"dump "
argument_list|,
operator|-
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|append_command
parameter_list|(
name|char
modifier|*
name|cmd
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|printf_unfiltered
argument_list|(
literal|"\"append\" must be followed by a subcommand.\n\n"
argument_list|)
expr_stmt|;
name|help_list
argument_list|(
name|dump_cmdlist
argument_list|,
literal|"append "
argument_list|,
operator|-
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_binary_file
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|,
name|char
modifier|*
name|mode
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|status
decl_stmt|;
name|file
operator|=
name|fopen_with_cleanup
argument_list|(
name|filename
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|status
operator|=
name|fwrite
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|1
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|1
condition|)
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_bfd_file
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|,
name|char
modifier|*
name|mode
parameter_list|,
name|char
modifier|*
name|target
parameter_list|,
name|CORE_ADDR
name|vaddr
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|bfd
modifier|*
name|obfd
decl_stmt|;
name|asection
modifier|*
name|osection
decl_stmt|;
name|obfd
operator|=
name|bfd_openw_with_cleanup
argument_list|(
name|filename
argument_list|,
name|target
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|osection
operator|=
name|bfd_make_section_anyway
argument_list|(
name|obfd
argument_list|,
literal|".newsec"
argument_list|)
expr_stmt|;
name|bfd_set_section_size
argument_list|(
name|obfd
argument_list|,
name|osection
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|bfd_set_section_vma
argument_list|(
name|obfd
argument_list|,
name|osection
argument_list|,
name|vaddr
argument_list|)
expr_stmt|;
name|bfd_set_section_alignment
argument_list|(
name|obfd
argument_list|,
name|osection
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bfd_set_section_flags
argument_list|(
name|obfd
argument_list|,
name|osection
argument_list|,
literal|0x203
argument_list|)
expr_stmt|;
name|osection
operator|->
name|entsize
operator|=
literal|0
expr_stmt|;
name|bfd_set_section_contents
argument_list|(
name|obfd
argument_list|,
name|osection
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_memory_to_file
parameter_list|(
name|char
modifier|*
name|cmd
parameter_list|,
name|char
modifier|*
name|mode
parameter_list|,
name|char
modifier|*
name|file_format
parameter_list|)
block|{
name|struct
name|cleanup
modifier|*
name|old_cleanups
init|=
name|make_cleanup
argument_list|(
name|null_cleanup
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|CORE_ADDR
name|lo
decl_stmt|;
name|CORE_ADDR
name|hi
decl_stmt|;
name|ULONGEST
name|count
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|void
modifier|*
name|buf
decl_stmt|;
name|char
modifier|*
name|lo_exp
decl_stmt|;
name|char
modifier|*
name|hi_exp
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/* Open the file.  */
name|filename
operator|=
name|scan_filename_with_cleanup
argument_list|(
operator|&
name|cmd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Find the low address.  */
if|if
condition|(
name|cmd
operator|==
name|NULL
operator|||
operator|*
name|cmd
operator|==
literal|'\0'
condition|)
name|error
argument_list|(
literal|"Missing start address."
argument_list|)
expr_stmt|;
name|lo_exp
operator|=
name|scan_expression_with_cleanup
argument_list|(
operator|&
name|cmd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Find the second address - rest of line.  */
if|if
condition|(
name|cmd
operator|==
name|NULL
operator|||
operator|*
name|cmd
operator|==
literal|'\0'
condition|)
name|error
argument_list|(
literal|"Missing stop address."
argument_list|)
expr_stmt|;
name|hi_exp
operator|=
name|cmd
expr_stmt|;
name|lo
operator|=
name|parse_and_eval_address
argument_list|(
name|lo_exp
argument_list|)
expr_stmt|;
name|hi
operator|=
name|parse_and_eval_address
argument_list|(
name|hi_exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|hi
operator|<=
name|lo
condition|)
name|error
argument_list|(
literal|"Invalid memory address range (start>= end)."
argument_list|)
expr_stmt|;
name|count
operator|=
name|hi
operator|-
name|lo
expr_stmt|;
comment|/* FIXME: Should use read_memory_partial() and a magic blocking      value.  */
name|buf
operator|=
name|xmalloc
argument_list|(
name|count
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|target_read_memory
argument_list|(
name|lo
argument_list|,
name|buf
argument_list|,
name|count
argument_list|)
expr_stmt|;
comment|/* Have everything.  Open/write the data.  */
if|if
condition|(
name|file_format
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|file_format
argument_list|,
literal|"binary"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dump_binary_file
argument_list|(
name|filename
argument_list|,
name|mode
argument_list|,
name|buf
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dump_bfd_file
argument_list|(
name|filename
argument_list|,
name|mode
argument_list|,
name|file_format
argument_list|,
name|lo
argument_list|,
name|buf
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
name|do_cleanups
argument_list|(
name|old_cleanups
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_memory_command
parameter_list|(
name|char
modifier|*
name|cmd
parameter_list|,
name|char
modifier|*
name|mode
parameter_list|)
block|{
name|dump_memory_to_file
argument_list|(
name|cmd
argument_list|,
name|mode
argument_list|,
literal|"binary"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_value_to_file
parameter_list|(
name|char
modifier|*
name|cmd
parameter_list|,
name|char
modifier|*
name|mode
parameter_list|,
name|char
modifier|*
name|file_format
parameter_list|)
block|{
name|struct
name|cleanup
modifier|*
name|old_cleanups
init|=
name|make_cleanup
argument_list|(
name|null_cleanup
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|struct
name|value
modifier|*
name|val
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
comment|/* Open the file.  */
name|filename
operator|=
name|scan_filename_with_cleanup
argument_list|(
operator|&
name|cmd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Find the value.  */
if|if
condition|(
name|cmd
operator|==
name|NULL
operator|||
operator|*
name|cmd
operator|==
literal|'\0'
condition|)
name|error
argument_list|(
literal|"No value to %s."
argument_list|,
operator|*
name|mode
operator|==
literal|'a'
condition|?
literal|"append"
else|:
literal|"dump"
argument_list|)
expr_stmt|;
name|val
operator|=
name|parse_and_eval
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Invalid expression."
argument_list|)
expr_stmt|;
comment|/* Have everything.  Open/write the data.  */
if|if
condition|(
name|file_format
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|file_format
argument_list|,
literal|"binary"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dump_binary_file
argument_list|(
name|filename
argument_list|,
name|mode
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|val
argument_list|)
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CORE_ADDR
name|vaddr
decl_stmt|;
if|if
condition|(
name|VALUE_LVAL
argument_list|(
name|val
argument_list|)
condition|)
block|{
name|vaddr
operator|=
name|VALUE_ADDRESS
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vaddr
operator|=
literal|0
expr_stmt|;
name|warning
argument_list|(
literal|"value is not an lval: address assumed to be zero"
argument_list|)
expr_stmt|;
block|}
name|dump_bfd_file
argument_list|(
name|filename
argument_list|,
name|mode
argument_list|,
name|file_format
argument_list|,
name|vaddr
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|val
argument_list|)
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|do_cleanups
argument_list|(
name|old_cleanups
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_value_command
parameter_list|(
name|char
modifier|*
name|cmd
parameter_list|,
name|char
modifier|*
name|mode
parameter_list|)
block|{
name|dump_value_to_file
argument_list|(
name|cmd
argument_list|,
name|mode
argument_list|,
literal|"binary"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_srec_memory
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|dump_memory_to_file
argument_list|(
name|args
argument_list|,
name|FOPEN_WB
argument_list|,
literal|"srec"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_srec_value
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|dump_value_to_file
argument_list|(
name|args
argument_list|,
name|FOPEN_WB
argument_list|,
literal|"srec"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_ihex_memory
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|dump_memory_to_file
argument_list|(
name|args
argument_list|,
name|FOPEN_WB
argument_list|,
literal|"ihex"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_ihex_value
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|dump_value_to_file
argument_list|(
name|args
argument_list|,
name|FOPEN_WB
argument_list|,
literal|"ihex"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_tekhex_memory
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|dump_memory_to_file
argument_list|(
name|args
argument_list|,
name|FOPEN_WB
argument_list|,
literal|"tekhex"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_tekhex_value
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|dump_value_to_file
argument_list|(
name|args
argument_list|,
name|FOPEN_WB
argument_list|,
literal|"tekhex"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_binary_memory
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|dump_memory_to_file
argument_list|(
name|args
argument_list|,
name|FOPEN_WB
argument_list|,
literal|"binary"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_binary_value
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|dump_value_to_file
argument_list|(
name|args
argument_list|,
name|FOPEN_WB
argument_list|,
literal|"binary"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|append_binary_memory
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|dump_memory_to_file
argument_list|(
name|args
argument_list|,
name|FOPEN_AB
argument_list|,
literal|"binary"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|append_binary_value
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|dump_value_to_file
argument_list|(
name|args
argument_list|,
name|FOPEN_AB
argument_list|,
literal|"binary"
argument_list|)
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|dump_context
block|{
name|void
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|char
modifier|*
name|cmd
parameter_list|,
name|char
modifier|*
name|mode
parameter_list|)
function_decl|;
name|char
modifier|*
name|mode
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|call_dump_func
parameter_list|(
name|struct
name|cmd_list_element
modifier|*
name|c
parameter_list|,
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|dump_context
modifier|*
name|d
init|=
name|get_cmd_context
argument_list|(
name|c
argument_list|)
decl_stmt|;
name|d
operator|->
name|func
argument_list|(
name|args
argument_list|,
name|d
operator|->
name|mode
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|add_dump_command
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|void
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|char
modifier|*
name|mode
parameter_list|)
parameter_list|,
name|char
modifier|*
name|descr
parameter_list|)
block|{
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
name|struct
name|dump_context
modifier|*
name|d
decl_stmt|;
name|c
operator|=
name|add_cmd
argument_list|(
name|name
argument_list|,
name|all_commands
argument_list|,
name|NULL
argument_list|,
name|descr
argument_list|,
operator|&
name|dump_cmdlist
argument_list|)
expr_stmt|;
name|c
operator|->
name|completer
operator|=
name|filename_completer
expr_stmt|;
name|d
operator|=
name|XMALLOC
argument_list|(
expr|struct
name|dump_context
argument_list|)
expr_stmt|;
name|d
operator|->
name|func
operator|=
name|func
expr_stmt|;
name|d
operator|->
name|mode
operator|=
name|FOPEN_WB
expr_stmt|;
name|set_cmd_context
argument_list|(
name|c
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|c
operator|->
name|func
operator|=
name|call_dump_func
expr_stmt|;
name|c
operator|=
name|add_cmd
argument_list|(
name|name
argument_list|,
name|all_commands
argument_list|,
name|NULL
argument_list|,
name|descr
argument_list|,
operator|&
name|append_cmdlist
argument_list|)
expr_stmt|;
name|c
operator|->
name|completer
operator|=
name|filename_completer
expr_stmt|;
name|d
operator|=
name|XMALLOC
argument_list|(
expr|struct
name|dump_context
argument_list|)
expr_stmt|;
name|d
operator|->
name|func
operator|=
name|func
expr_stmt|;
name|d
operator|->
name|mode
operator|=
name|FOPEN_AB
expr_stmt|;
name|set_cmd_context
argument_list|(
name|c
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|c
operator|->
name|func
operator|=
name|call_dump_func
expr_stmt|;
comment|/* Replace "Dump " at start of docstring with "Append "      (borrowed from add_show_from_set).  */
if|if
condition|(
name|c
operator|->
name|doc
index|[
literal|0
index|]
operator|==
literal|'W'
operator|&&
name|c
operator|->
name|doc
index|[
literal|1
index|]
operator|==
literal|'r'
operator|&&
name|c
operator|->
name|doc
index|[
literal|2
index|]
operator|==
literal|'i'
operator|&&
name|c
operator|->
name|doc
index|[
literal|3
index|]
operator|==
literal|'t'
operator|&&
name|c
operator|->
name|doc
index|[
literal|4
index|]
operator|==
literal|'e'
operator|&&
name|c
operator|->
name|doc
index|[
literal|5
index|]
operator|==
literal|' '
condition|)
name|c
operator|->
name|doc
operator|=
name|concat
argument_list|(
literal|"Append "
argument_list|,
name|c
operator|->
name|doc
operator|+
literal|6
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Opaque data for restore_section_callback. */
end_comment

begin_struct
struct|struct
name|callback_data
block|{
name|unsigned
name|long
name|load_offset
decl_stmt|;
name|CORE_ADDR
name|load_start
decl_stmt|;
name|CORE_ADDR
name|load_end
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Function: restore_section_callback.     Callback function for bfd_map_over_sections.    Selectively loads the sections into memory.  */
end_comment

begin_function
specifier|static
name|void
name|restore_section_callback
parameter_list|(
name|bfd
modifier|*
name|ibfd
parameter_list|,
name|asection
modifier|*
name|isec
parameter_list|,
name|void
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|callback_data
modifier|*
name|data
init|=
name|args
decl_stmt|;
name|bfd_vma
name|sec_start
init|=
name|bfd_section_vma
argument_list|(
name|ibfd
argument_list|,
name|isec
argument_list|)
decl_stmt|;
name|bfd_size_type
name|size
init|=
name|bfd_section_size
argument_list|(
name|ibfd
argument_list|,
name|isec
argument_list|)
decl_stmt|;
name|bfd_vma
name|sec_end
init|=
name|sec_start
operator|+
name|size
decl_stmt|;
name|bfd_size_type
name|sec_offset
init|=
literal|0
decl_stmt|;
name|bfd_size_type
name|sec_load_count
init|=
name|size
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* Ignore non-loadable sections, eg. from elf files. */
if|if
condition|(
operator|!
operator|(
name|bfd_get_section_flags
argument_list|(
name|ibfd
argument_list|,
name|isec
argument_list|)
operator|&
name|SEC_LOAD
operator|)
condition|)
return|return;
comment|/* Does the section overlap with the desired restore range? */
if|if
condition|(
name|sec_end
operator|<=
name|data
operator|->
name|load_start
operator|||
operator|(
name|data
operator|->
name|load_end
operator|>
literal|0
operator|&&
name|sec_start
operator|>=
name|data
operator|->
name|load_end
operator|)
condition|)
block|{
comment|/* No, no useable data in this section. */
name|printf_filtered
argument_list|(
literal|"skipping section %s...\n"
argument_list|,
name|bfd_section_name
argument_list|(
name|ibfd
argument_list|,
name|isec
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Compare section address range with user-requested      address range (if any).  Compute where the actual      transfer should start and end.  */
if|if
condition|(
name|sec_start
operator|<
name|data
operator|->
name|load_start
condition|)
name|sec_offset
operator|=
name|data
operator|->
name|load_start
operator|-
name|sec_start
expr_stmt|;
comment|/* Size of a partial transfer: */
name|sec_load_count
operator|-=
name|sec_offset
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|load_end
operator|>
literal|0
operator|&&
name|sec_end
operator|>
name|data
operator|->
name|load_end
condition|)
name|sec_load_count
operator|-=
name|sec_end
operator|-
name|data
operator|->
name|load_end
expr_stmt|;
comment|/* Get the data.  */
name|buf
operator|=
name|xmalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|ibfd
argument_list|,
name|isec
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
condition|)
name|error
argument_list|(
literal|"Failed to read bfd file %s: '%s'."
argument_list|,
name|bfd_get_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Restoring section %s (0x%lx to 0x%lx)"
argument_list|,
name|bfd_section_name
argument_list|(
name|ibfd
argument_list|,
name|isec
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|sec_start
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|sec_end
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|load_offset
operator|!=
literal|0
operator|||
name|data
operator|->
name|load_start
operator|!=
literal|0
operator|||
name|data
operator|->
name|load_end
operator|!=
literal|0
condition|)
name|printf_filtered
argument_list|(
literal|" into memory (0x%s to 0x%s)\n"
argument_list|,
name|paddr_nz
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|sec_start
operator|+
name|sec_offset
operator|+
name|data
operator|->
name|load_offset
argument_list|)
argument_list|,
name|paddr_nz
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|sec_start
operator|+
name|sec_offset
operator|+
name|data
operator|->
name|load_offset
operator|+
name|sec_load_count
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|puts_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* Write the data.  */
name|ret
operator|=
name|target_write_memory
argument_list|(
name|sec_start
operator|+
name|sec_offset
operator|+
name|data
operator|->
name|load_offset
argument_list|,
name|buf
operator|+
name|sec_offset
argument_list|,
name|sec_load_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
name|warning
argument_list|(
literal|"restore: memory write failed (%s)."
argument_list|,
name|safe_strerror
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|restore_binary_file
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|,
name|struct
name|callback_data
modifier|*
name|data
parameter_list|)
block|{
name|FILE
modifier|*
name|file
init|=
name|fopen_with_cleanup
argument_list|(
name|filename
argument_list|,
name|FOPEN_RB
argument_list|)
decl_stmt|;
name|int
name|status
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|long
name|len
decl_stmt|;
comment|/* Get the file size for reading.  */
if|if
condition|(
name|fseek
argument_list|(
name|file
argument_list|,
literal|0
argument_list|,
name|SEEK_END
argument_list|)
operator|==
literal|0
condition|)
name|len
operator|=
name|ftell
argument_list|(
name|file
argument_list|)
expr_stmt|;
else|else
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
name|data
operator|->
name|load_start
condition|)
name|error
argument_list|(
literal|"Start address is greater than length of binary file %s."
argument_list|,
name|filename
argument_list|)
expr_stmt|;
comment|/* Chop off "len" if it exceeds the requested load_end addr. */
if|if
condition|(
name|data
operator|->
name|load_end
operator|!=
literal|0
operator|&&
name|data
operator|->
name|load_end
operator|<
name|len
condition|)
name|len
operator|=
name|data
operator|->
name|load_end
expr_stmt|;
comment|/* Chop off "len" if the requested load_start addr skips some bytes. */
if|if
condition|(
name|data
operator|->
name|load_start
operator|>
literal|0
condition|)
name|len
operator|-=
name|data
operator|->
name|load_start
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Restoring binary file %s into memory (0x%lx to 0x%lx)\n"
argument_list|,
name|filename
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|data
operator|->
name|load_start
operator|+
name|data
operator|->
name|load_offset
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|data
operator|->
name|load_start
operator|+
name|data
operator|->
name|load_offset
operator|+
name|len
argument_list|)
expr_stmt|;
comment|/* Now set the file pos to the requested load start pos.  */
if|if
condition|(
name|fseek
argument_list|(
name|file
argument_list|,
name|data
operator|->
name|load_start
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
comment|/* Now allocate a buffer and read the file contents.  */
name|buf
operator|=
name|xmalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|fread
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
name|len
argument_list|,
name|file
argument_list|)
operator|!=
name|len
condition|)
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
comment|/* Now write the buffer into target memory. */
name|len
operator|=
name|target_write_memory
argument_list|(
name|data
operator|->
name|load_start
operator|+
name|data
operator|->
name|load_offset
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
name|warning
argument_list|(
literal|"restore: memory write failed (%s)."
argument_list|,
name|safe_strerror
argument_list|(
name|len
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|restore_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|char
modifier|*
name|filename
decl_stmt|;
name|struct
name|callback_data
name|data
decl_stmt|;
name|bfd
modifier|*
name|ibfd
decl_stmt|;
name|int
name|binary_flag
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|target_has_execution
condition|)
name|noprocess
argument_list|()
expr_stmt|;
name|data
operator|.
name|load_offset
operator|=
literal|0
expr_stmt|;
name|data
operator|.
name|load_start
operator|=
literal|0
expr_stmt|;
name|data
operator|.
name|load_end
operator|=
literal|0
expr_stmt|;
comment|/* Parse the input arguments.  First is filename (required). */
name|filename
operator|=
name|scan_filename_with_cleanup
argument_list|(
operator|&
name|args
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|!=
name|NULL
operator|&&
operator|*
name|args
operator|!=
literal|'\0'
condition|)
block|{
name|char
modifier|*
name|binary_string
init|=
literal|"binary"
decl_stmt|;
comment|/* Look for optional "binary" flag.  */
if|if
condition|(
name|strncmp
argument_list|(
name|args
argument_list|,
name|binary_string
argument_list|,
name|strlen
argument_list|(
name|binary_string
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|binary_flag
operator|=
literal|1
expr_stmt|;
name|args
operator|+=
name|strlen
argument_list|(
name|binary_string
argument_list|)
expr_stmt|;
name|args
operator|=
name|skip_spaces
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
comment|/* Parse offset (optional). */
if|if
condition|(
name|args
operator|!=
name|NULL
operator|&&
operator|*
name|args
operator|!=
literal|'\0'
condition|)
name|data
operator|.
name|load_offset
operator|=
name|parse_and_eval_long
argument_list|(
name|scan_expression_with_cleanup
argument_list|(
operator|&
name|args
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|!=
name|NULL
operator|&&
operator|*
name|args
operator|!=
literal|'\0'
condition|)
block|{
comment|/* Parse start address (optional). */
name|data
operator|.
name|load_start
operator|=
name|parse_and_eval_long
argument_list|(
name|scan_expression_with_cleanup
argument_list|(
operator|&
name|args
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|!=
name|NULL
operator|&&
operator|*
name|args
operator|!=
literal|'\0'
condition|)
block|{
comment|/* Parse end address (optional). */
name|data
operator|.
name|load_end
operator|=
name|parse_and_eval_long
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|.
name|load_end
operator|<=
name|data
operator|.
name|load_start
condition|)
name|error
argument_list|(
literal|"Start must be less than end."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|info_verbose
condition|)
name|printf_filtered
argument_list|(
literal|"Restore file %s offset 0x%lx start 0x%lx end 0x%lx\n"
argument_list|,
name|filename
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|data
operator|.
name|load_offset
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|data
operator|.
name|load_start
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|data
operator|.
name|load_end
argument_list|)
expr_stmt|;
if|if
condition|(
name|binary_flag
condition|)
block|{
name|restore_binary_file
argument_list|(
name|filename
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Open the file for loading. */
name|ibfd
operator|=
name|bfd_openr_with_cleanup
argument_list|(
name|filename
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Process the sections. */
name|bfd_map_over_sections
argument_list|(
name|ibfd
argument_list|,
name|restore_section_callback
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|srec_dump_command
parameter_list|(
name|char
modifier|*
name|cmd
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|printf_unfiltered
argument_list|(
literal|"\"dump srec\" must be followed by a subcommand.\n"
argument_list|)
expr_stmt|;
name|help_list
argument_list|(
name|srec_cmdlist
argument_list|,
literal|"dump srec "
argument_list|,
operator|-
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ihex_dump_command
parameter_list|(
name|char
modifier|*
name|cmd
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|printf_unfiltered
argument_list|(
literal|"\"dump ihex\" must be followed by a subcommand.\n"
argument_list|)
expr_stmt|;
name|help_list
argument_list|(
name|ihex_cmdlist
argument_list|,
literal|"dump ihex "
argument_list|,
operator|-
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tekhex_dump_command
parameter_list|(
name|char
modifier|*
name|cmd
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|printf_unfiltered
argument_list|(
literal|"\"dump tekhex\" must be followed by a subcommand.\n"
argument_list|)
expr_stmt|;
name|help_list
argument_list|(
name|tekhex_cmdlist
argument_list|,
literal|"dump tekhex "
argument_list|,
operator|-
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|binary_dump_command
parameter_list|(
name|char
modifier|*
name|cmd
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|printf_unfiltered
argument_list|(
literal|"\"dump binary\" must be followed by a subcommand.\n"
argument_list|)
expr_stmt|;
name|help_list
argument_list|(
name|binary_dump_cmdlist
argument_list|,
literal|"dump binary "
argument_list|,
operator|-
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|binary_append_command
parameter_list|(
name|char
modifier|*
name|cmd
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|printf_unfiltered
argument_list|(
literal|"\"append binary\" must be followed by a subcommand.\n"
argument_list|)
expr_stmt|;
name|help_list
argument_list|(
name|binary_append_cmdlist
argument_list|,
literal|"append binary "
argument_list|,
operator|-
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|extern
name|initialize_file_ftype
name|_initialize_cli_dump
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -Wmissing-prototypes */
end_comment

begin_function
name|void
name|_initialize_cli_dump
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"dump"
argument_list|,
name|class_vars
argument_list|,
name|dump_command
argument_list|,
literal|"\ Dump target code/data to a local file."
argument_list|,
operator|&
name|dump_cmdlist
argument_list|,
literal|"dump "
argument_list|,
literal|0
comment|/*allow-unknown*/
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"append"
argument_list|,
name|class_vars
argument_list|,
name|append_command
argument_list|,
literal|"\ Append target code/data to a local file."
argument_list|,
operator|&
name|append_cmdlist
argument_list|,
literal|"append "
argument_list|,
literal|0
comment|/*allow-unknown*/
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_dump_command
argument_list|(
literal|"memory"
argument_list|,
name|dump_memory_command
argument_list|,
literal|"\ Write contents of memory to a raw binary file.\n\ Arguments are FILE START STOP.  Writes the contents of memory within the\n\ range [START .. STOP) to the specifed FILE in raw target ordered bytes."
argument_list|)
expr_stmt|;
name|add_dump_command
argument_list|(
literal|"value"
argument_list|,
name|dump_value_command
argument_list|,
literal|"\ Write the value of an expression to a raw binary file.\n\ Arguments are FILE EXPRESSION.  Writes the value of EXPRESSION to\n\ the specified FILE in raw target ordered bytes."
argument_list|)
expr_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"srec"
argument_list|,
name|all_commands
argument_list|,
name|srec_dump_command
argument_list|,
literal|"\ Write target code/data to an srec file."
argument_list|,
operator|&
name|srec_cmdlist
argument_list|,
literal|"dump srec "
argument_list|,
literal|0
comment|/*allow-unknown*/
argument_list|,
operator|&
name|dump_cmdlist
argument_list|)
expr_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"ihex"
argument_list|,
name|all_commands
argument_list|,
name|ihex_dump_command
argument_list|,
literal|"\ Write target code/data to an intel hex file."
argument_list|,
operator|&
name|ihex_cmdlist
argument_list|,
literal|"dump ihex "
argument_list|,
literal|0
comment|/*allow-unknown*/
argument_list|,
operator|&
name|dump_cmdlist
argument_list|)
expr_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"tekhex"
argument_list|,
name|all_commands
argument_list|,
name|tekhex_dump_command
argument_list|,
literal|"\ Write target code/data to a tekhex file."
argument_list|,
operator|&
name|tekhex_cmdlist
argument_list|,
literal|"dump tekhex "
argument_list|,
literal|0
comment|/*allow-unknown*/
argument_list|,
operator|&
name|dump_cmdlist
argument_list|)
expr_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"binary"
argument_list|,
name|all_commands
argument_list|,
name|binary_dump_command
argument_list|,
literal|"\ Write target code/data to a raw binary file."
argument_list|,
operator|&
name|binary_dump_cmdlist
argument_list|,
literal|"dump binary "
argument_list|,
literal|0
comment|/*allow-unknown*/
argument_list|,
operator|&
name|dump_cmdlist
argument_list|)
expr_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"binary"
argument_list|,
name|all_commands
argument_list|,
name|binary_append_command
argument_list|,
literal|"\ Append target code/data to a raw binary file."
argument_list|,
operator|&
name|binary_append_cmdlist
argument_list|,
literal|"append binary "
argument_list|,
literal|0
comment|/*allow-unknown*/
argument_list|,
operator|&
name|append_cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"memory"
argument_list|,
name|all_commands
argument_list|,
name|dump_srec_memory
argument_list|,
literal|"\ Write contents of memory to an srec file.\n\ Arguments are FILE START STOP.  Writes the contents of memory\n\ within the range [START .. STOP) to the specifed FILE in srec format."
argument_list|,
operator|&
name|srec_cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"value"
argument_list|,
name|all_commands
argument_list|,
name|dump_srec_value
argument_list|,
literal|"\ Write the value of an expression to an srec file.\n\ Arguments are FILE EXPRESSION.  Writes the value of EXPRESSION\n\ to the specified FILE in srec format."
argument_list|,
operator|&
name|srec_cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"memory"
argument_list|,
name|all_commands
argument_list|,
name|dump_ihex_memory
argument_list|,
literal|"\ Write contents of memory to an ihex file.\n\ Arguments are FILE START STOP.  Writes the contents of memory within\n\ the range [START .. STOP) to the specifed FILE in intel hex format."
argument_list|,
operator|&
name|ihex_cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"value"
argument_list|,
name|all_commands
argument_list|,
name|dump_ihex_value
argument_list|,
literal|"\ Write the value of an expression to an ihex file.\n\ Arguments are FILE EXPRESSION.  Writes the value of EXPRESSION\n\ to the specified FILE in intel hex format."
argument_list|,
operator|&
name|ihex_cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"memory"
argument_list|,
name|all_commands
argument_list|,
name|dump_tekhex_memory
argument_list|,
literal|"\ Write contents of memory to a tekhex file.\n\ Arguments are FILE START STOP.  Writes the contents of memory\n\ within the range [START .. STOP) to the specifed FILE in tekhex format."
argument_list|,
operator|&
name|tekhex_cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"value"
argument_list|,
name|all_commands
argument_list|,
name|dump_tekhex_value
argument_list|,
literal|"\ Write the value of an expression to a tekhex file.\n\ Arguments are FILE EXPRESSION.  Writes the value of EXPRESSION\n\ to the specified FILE in tekhex format."
argument_list|,
operator|&
name|tekhex_cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"memory"
argument_list|,
name|all_commands
argument_list|,
name|dump_binary_memory
argument_list|,
literal|"\ Write contents of memory to a raw binary file.\n\ Arguments are FILE START STOP.  Writes the contents of memory\n\ within the range [START .. STOP) to the specifed FILE in binary format."
argument_list|,
operator|&
name|binary_dump_cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"value"
argument_list|,
name|all_commands
argument_list|,
name|dump_binary_value
argument_list|,
literal|"\ Write the value of an expression to a raw binary file.\n\ Arguments are FILE EXPRESSION.  Writes the value of EXPRESSION\n\ to the specified FILE in raw target ordered bytes."
argument_list|,
operator|&
name|binary_dump_cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"memory"
argument_list|,
name|all_commands
argument_list|,
name|append_binary_memory
argument_list|,
literal|"\ Append contents of memory to a raw binary file.\n\ Arguments are FILE START STOP.  Writes the contents of memory within the\n\ range [START .. STOP) to the specifed FILE in raw target ordered bytes."
argument_list|,
operator|&
name|binary_append_cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"value"
argument_list|,
name|all_commands
argument_list|,
name|append_binary_value
argument_list|,
literal|"\ Append the value of an expression to a raw binary file.\n\ Arguments are FILE EXPRESSION.  Writes the value of EXPRESSION\n\ to the specified FILE in raw target ordered bytes."
argument_list|,
operator|&
name|binary_append_cmdlist
argument_list|)
expr_stmt|;
name|c
operator|=
name|add_com
argument_list|(
literal|"restore"
argument_list|,
name|class_vars
argument_list|,
name|restore_command
argument_list|,
literal|"Restore the contents of FILE to target memory.\n\ Arguments are FILE OFFSET START END where all except FILE are optional.\n\ OFFSET will be added to the base address of the file (default zero).\n\ If START and END are given, only the file contents within that range\n\ (file relative) will be restored to target memory."
argument_list|)
expr_stmt|;
name|c
operator|->
name|completer
operator|=
name|filename_completer
expr_stmt|;
comment|/* FIXME: completers for other commands. */
block|}
end_function

end_unit

