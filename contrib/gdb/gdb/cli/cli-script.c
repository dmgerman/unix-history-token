begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* GDB CLI command scripting.     Copyright 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994,    1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002 Free Software    Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_comment
comment|/* For value_true */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"ui-out.h"
end_include

begin_include
include|#
directive|include
file|"top.h"
end_include

begin_include
include|#
directive|include
file|"cli/cli-cmds.h"
end_include

begin_include
include|#
directive|include
file|"cli/cli-decode.h"
end_include

begin_include
include|#
directive|include
file|"cli/cli-script.h"
end_include

begin_comment
comment|/* From gdb/top.c */
end_comment

begin_function_decl
specifier|extern
name|void
name|dont_repeat
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|do_restore_instream_cleanup
parameter_list|(
name|void
modifier|*
name|stream
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Prototypes for local functions */
end_comment

begin_function_decl
specifier|static
name|struct
name|cleanup
modifier|*
name|make_cleanup_free_command_lines
parameter_list|(
name|struct
name|command_line
modifier|*
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|command_control_type
name|recurse_read_control_structure
parameter_list|(
name|struct
name|command_line
modifier|*
name|current_cmd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|insert_args
parameter_list|(
name|char
modifier|*
name|line
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|cleanup
modifier|*
name|setup_user_args
parameter_list|(
name|char
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|validate_comname
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Level of control structure.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|control_level
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Source command state variable. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|source_error_allocated
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Structure for arguments to user defined functions.  */
end_comment

begin_define
define|#
directive|define
name|MAXUSERARGS
value|10
end_define

begin_struct
struct|struct
name|user_args
block|{
name|struct
name|user_args
modifier|*
name|next
decl_stmt|;
struct|struct
block|{
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|len
decl_stmt|;
block|}
name|a
index|[
name|MAXUSERARGS
index|]
struct|;
name|int
name|count
decl_stmt|;
block|}
modifier|*
name|user_args
struct|;
end_struct

begin_escape
end_escape

begin_comment
comment|/* Allocate, initialize a new command line structure for one of the    control commands (if/while).  */
end_comment

begin_function
specifier|static
name|struct
name|command_line
modifier|*
name|build_command_line
parameter_list|(
name|enum
name|command_control_type
name|type
parameter_list|,
name|char
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|command_line
modifier|*
name|cmd
decl_stmt|;
if|if
condition|(
name|args
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"if/while commands require arguments.\n"
argument_list|)
expr_stmt|;
name|cmd
operator|=
operator|(
expr|struct
name|command_line
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|command_line
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|cmd
operator|->
name|control_type
operator|=
name|type
expr_stmt|;
name|cmd
operator|->
name|body_count
operator|=
literal|1
expr_stmt|;
name|cmd
operator|->
name|body_list
operator|=
operator|(
expr|struct
name|command_line
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|command_line
operator|*
argument_list|)
operator|*
name|cmd
operator|->
name|body_count
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|cmd
operator|->
name|body_list
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|command_line
operator|*
argument_list|)
operator|*
name|cmd
operator|->
name|body_count
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|line
operator|=
name|savestring
argument_list|(
name|args
argument_list|,
name|strlen
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|cmd
return|;
block|}
end_function

begin_comment
comment|/* Build and return a new command structure for the control commands    such as "if" and "while".  */
end_comment

begin_function
specifier|static
name|struct
name|command_line
modifier|*
name|get_command_line
parameter_list|(
name|enum
name|command_control_type
name|type
parameter_list|,
name|char
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|command_line
modifier|*
name|cmd
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
init|=
name|NULL
decl_stmt|;
comment|/* Allocate and build a new command line structure.  */
name|cmd
operator|=
name|build_command_line
argument_list|(
name|type
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup_free_command_lines
argument_list|(
operator|&
name|cmd
argument_list|)
expr_stmt|;
comment|/* Read in the body of this command.  */
if|if
condition|(
name|recurse_read_control_structure
argument_list|(
name|cmd
argument_list|)
operator|==
name|invalid_control
condition|)
block|{
name|warning
argument_list|(
literal|"error reading in control structure\n"
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|discard_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
name|cmd
return|;
block|}
end_function

begin_comment
comment|/* Recursively print a command (including full control structures).  */
end_comment

begin_function
name|void
name|print_command_lines
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
name|struct
name|command_line
modifier|*
name|cmd
parameter_list|,
name|unsigned
name|int
name|depth
parameter_list|)
block|{
name|struct
name|command_line
modifier|*
name|list
decl_stmt|;
name|list
operator|=
name|cmd
expr_stmt|;
while|while
condition|(
name|list
condition|)
block|{
if|if
condition|(
name|depth
condition|)
name|ui_out_spaces
argument_list|(
name|uiout
argument_list|,
literal|2
operator|*
name|depth
argument_list|)
expr_stmt|;
comment|/* A simple command, print it and continue.  */
if|if
condition|(
name|list
operator|->
name|control_type
operator|==
name|simple_control
condition|)
block|{
name|ui_out_field_string
argument_list|(
name|uiout
argument_list|,
name|NULL
argument_list|,
name|list
operator|->
name|line
argument_list|)
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
continue|continue;
block|}
comment|/* loop_continue to jump to the start of a while loop, print it          and continue. */
if|if
condition|(
name|list
operator|->
name|control_type
operator|==
name|continue_control
condition|)
block|{
name|ui_out_field_string
argument_list|(
name|uiout
argument_list|,
name|NULL
argument_list|,
literal|"loop_continue"
argument_list|)
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
continue|continue;
block|}
comment|/* loop_break to break out of a while loop, print it and continue.  */
if|if
condition|(
name|list
operator|->
name|control_type
operator|==
name|break_control
condition|)
block|{
name|ui_out_field_string
argument_list|(
name|uiout
argument_list|,
name|NULL
argument_list|,
literal|"loop_break"
argument_list|)
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
continue|continue;
block|}
comment|/* A while command.  Recursively print its subcommands and continue.  */
if|if
condition|(
name|list
operator|->
name|control_type
operator|==
name|while_control
condition|)
block|{
name|ui_out_field_fmt
argument_list|(
name|uiout
argument_list|,
name|NULL
argument_list|,
literal|"while %s"
argument_list|,
name|list
operator|->
name|line
argument_list|)
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|print_command_lines
argument_list|(
name|uiout
argument_list|,
operator|*
name|list
operator|->
name|body_list
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|depth
condition|)
name|ui_out_spaces
argument_list|(
name|uiout
argument_list|,
literal|2
operator|*
name|depth
argument_list|)
expr_stmt|;
name|ui_out_field_string
argument_list|(
name|uiout
argument_list|,
name|NULL
argument_list|,
literal|"end"
argument_list|)
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
continue|continue;
block|}
comment|/* An if command.  Recursively print both arms before continueing.  */
if|if
condition|(
name|list
operator|->
name|control_type
operator|==
name|if_control
condition|)
block|{
name|ui_out_field_fmt
argument_list|(
name|uiout
argument_list|,
name|NULL
argument_list|,
literal|"if %s"
argument_list|,
name|list
operator|->
name|line
argument_list|)
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* The true arm. */
name|print_command_lines
argument_list|(
name|uiout
argument_list|,
name|list
operator|->
name|body_list
index|[
literal|0
index|]
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Show the false arm if it exists.  */
if|if
condition|(
name|list
operator|->
name|body_count
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|depth
condition|)
name|ui_out_spaces
argument_list|(
name|uiout
argument_list|,
literal|2
operator|*
name|depth
argument_list|)
expr_stmt|;
name|ui_out_field_string
argument_list|(
name|uiout
argument_list|,
name|NULL
argument_list|,
literal|"else"
argument_list|)
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|print_command_lines
argument_list|(
name|uiout
argument_list|,
name|list
operator|->
name|body_list
index|[
literal|1
index|]
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|depth
condition|)
name|ui_out_spaces
argument_list|(
name|uiout
argument_list|,
literal|2
operator|*
name|depth
argument_list|)
expr_stmt|;
name|ui_out_field_string
argument_list|(
name|uiout
argument_list|,
name|NULL
argument_list|,
literal|"end"
argument_list|)
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
continue|continue;
block|}
comment|/* ignore illegal command type and try next */
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
block|}
comment|/* while (list) */
block|}
end_function

begin_comment
comment|/* Execute the command in CMD.  */
end_comment

begin_function
name|void
name|execute_user_command
parameter_list|(
name|struct
name|cmd_list_element
modifier|*
name|c
parameter_list|,
name|char
modifier|*
name|args
parameter_list|)
block|{
specifier|register
name|struct
name|command_line
modifier|*
name|cmdlines
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|enum
name|command_control_type
name|ret
decl_stmt|;
name|old_chain
operator|=
name|setup_user_args
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|cmdlines
operator|=
name|c
operator|->
name|user_commands
expr_stmt|;
if|if
condition|(
name|cmdlines
operator|==
literal|0
condition|)
comment|/* Null command */
return|return;
comment|/* Set the instream to 0, indicating execution of a      user-defined function.  */
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|do_restore_instream_cleanup
argument_list|,
name|instream
argument_list|)
expr_stmt|;
name|instream
operator|=
operator|(
name|FILE
operator|*
operator|)
literal|0
expr_stmt|;
while|while
condition|(
name|cmdlines
condition|)
block|{
name|ret
operator|=
name|execute_control_command
argument_list|(
name|cmdlines
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|simple_control
operator|&&
name|ret
operator|!=
name|break_control
condition|)
block|{
name|warning
argument_list|(
literal|"Error in control structure.\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|cmdlines
operator|=
name|cmdlines
operator|->
name|next
expr_stmt|;
block|}
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|enum
name|command_control_type
name|execute_control_command
parameter_list|(
name|struct
name|command_line
modifier|*
name|cmd
parameter_list|)
block|{
name|struct
name|expression
modifier|*
name|expr
decl_stmt|;
name|struct
name|command_line
modifier|*
name|current
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
init|=
literal|0
decl_stmt|;
name|struct
name|value
modifier|*
name|val
decl_stmt|;
name|struct
name|value
modifier|*
name|val_mark
decl_stmt|;
name|int
name|loop
decl_stmt|;
name|enum
name|command_control_type
name|ret
decl_stmt|;
name|char
modifier|*
name|new_line
decl_stmt|;
switch|switch
condition|(
name|cmd
operator|->
name|control_type
condition|)
block|{
case|case
name|simple_control
case|:
comment|/* A simple command, execute it and return.  */
name|new_line
operator|=
name|insert_args
argument_list|(
name|cmd
operator|->
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new_line
condition|)
return|return
name|invalid_control
return|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|free_current_contents
argument_list|,
operator|&
name|new_line
argument_list|)
expr_stmt|;
name|execute_command
argument_list|(
name|new_line
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ret
operator|=
name|cmd
operator|->
name|control_type
expr_stmt|;
break|break;
case|case
name|continue_control
case|:
case|case
name|break_control
case|:
comment|/* Return for "continue", and "break" so we can either          continue the loop at the top, or break out.  */
name|ret
operator|=
name|cmd
operator|->
name|control_type
expr_stmt|;
break|break;
case|case
name|while_control
case|:
block|{
comment|/* Parse the loop control expression for the while statement.  */
name|new_line
operator|=
name|insert_args
argument_list|(
name|cmd
operator|->
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new_line
condition|)
return|return
name|invalid_control
return|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|free_current_contents
argument_list|,
operator|&
name|new_line
argument_list|)
expr_stmt|;
name|expr
operator|=
name|parse_expression
argument_list|(
name|new_line
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|free_current_contents
argument_list|,
operator|&
name|expr
argument_list|)
expr_stmt|;
name|ret
operator|=
name|simple_control
expr_stmt|;
name|loop
operator|=
literal|1
expr_stmt|;
comment|/* Keep iterating so long as the expression is true.  */
while|while
condition|(
name|loop
operator|==
literal|1
condition|)
block|{
name|int
name|cond_result
decl_stmt|;
name|QUIT
expr_stmt|;
comment|/* Evaluate the expression.  */
name|val_mark
operator|=
name|value_mark
argument_list|()
expr_stmt|;
name|val
operator|=
name|evaluate_expression
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|cond_result
operator|=
name|value_true
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|value_free_to_mark
argument_list|(
name|val_mark
argument_list|)
expr_stmt|;
comment|/* If the value is false, then break out of the loop.  */
if|if
condition|(
operator|!
name|cond_result
condition|)
break|break;
comment|/* Execute the body of the while statement.  */
name|current
operator|=
operator|*
name|cmd
operator|->
name|body_list
expr_stmt|;
while|while
condition|(
name|current
condition|)
block|{
name|ret
operator|=
name|execute_control_command
argument_list|(
name|current
argument_list|)
expr_stmt|;
comment|/* If we got an error, or a "break" command, then stop 		   looping.  */
if|if
condition|(
name|ret
operator|==
name|invalid_control
operator|||
name|ret
operator|==
name|break_control
condition|)
block|{
name|loop
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* If we got a "continue" command, then restart the loop 		   at this point.  */
if|if
condition|(
name|ret
operator|==
name|continue_control
condition|)
break|break;
comment|/* Get the next statement.  */
name|current
operator|=
name|current
operator|->
name|next
expr_stmt|;
block|}
block|}
comment|/* Reset RET so that we don't recurse the break all the way down.  */
if|if
condition|(
name|ret
operator|==
name|break_control
condition|)
name|ret
operator|=
name|simple_control
expr_stmt|;
break|break;
block|}
case|case
name|if_control
case|:
block|{
name|new_line
operator|=
name|insert_args
argument_list|(
name|cmd
operator|->
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new_line
condition|)
return|return
name|invalid_control
return|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|free_current_contents
argument_list|,
operator|&
name|new_line
argument_list|)
expr_stmt|;
comment|/* Parse the conditional for the if statement.  */
name|expr
operator|=
name|parse_expression
argument_list|(
name|new_line
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|free_current_contents
argument_list|,
operator|&
name|expr
argument_list|)
expr_stmt|;
name|current
operator|=
name|NULL
expr_stmt|;
name|ret
operator|=
name|simple_control
expr_stmt|;
comment|/* Evaluate the conditional.  */
name|val_mark
operator|=
name|value_mark
argument_list|()
expr_stmt|;
name|val
operator|=
name|evaluate_expression
argument_list|(
name|expr
argument_list|)
expr_stmt|;
comment|/* Choose which arm to take commands from based on the value of the 	   conditional expression.  */
if|if
condition|(
name|value_true
argument_list|(
name|val
argument_list|)
condition|)
name|current
operator|=
operator|*
name|cmd
operator|->
name|body_list
expr_stmt|;
elseif|else
if|if
condition|(
name|cmd
operator|->
name|body_count
operator|==
literal|2
condition|)
name|current
operator|=
operator|*
operator|(
name|cmd
operator|->
name|body_list
operator|+
literal|1
operator|)
expr_stmt|;
name|value_free_to_mark
argument_list|(
name|val_mark
argument_list|)
expr_stmt|;
comment|/* Execute commands in the given arm.  */
while|while
condition|(
name|current
condition|)
block|{
name|ret
operator|=
name|execute_control_command
argument_list|(
name|current
argument_list|)
expr_stmt|;
comment|/* If we got an error, get out.  */
if|if
condition|(
name|ret
operator|!=
name|simple_control
condition|)
break|break;
comment|/* Get the next statement in the body.  */
name|current
operator|=
name|current
operator|->
name|next
expr_stmt|;
block|}
break|break;
block|}
default|default:
name|warning
argument_list|(
literal|"Invalid control type in command structure."
argument_list|)
expr_stmt|;
return|return
name|invalid_control
return|;
block|}
if|if
condition|(
name|old_chain
condition|)
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* "while" command support.  Executes a body of statements while the    loop condition is nonzero.  */
end_comment

begin_function
name|void
name|while_command
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|command_line
modifier|*
name|command
init|=
name|NULL
decl_stmt|;
name|control_level
operator|=
literal|1
expr_stmt|;
name|command
operator|=
name|get_command_line
argument_list|(
name|while_control
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|command
operator|==
name|NULL
condition|)
return|return;
name|execute_control_command
argument_list|(
name|command
argument_list|)
expr_stmt|;
name|free_command_lines
argument_list|(
operator|&
name|command
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* "if" command support.  Execute either the true or false arm depending    on the value of the if conditional.  */
end_comment

begin_function
name|void
name|if_command
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|command_line
modifier|*
name|command
init|=
name|NULL
decl_stmt|;
name|control_level
operator|=
literal|1
expr_stmt|;
name|command
operator|=
name|get_command_line
argument_list|(
name|if_control
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|command
operator|==
name|NULL
condition|)
return|return;
name|execute_control_command
argument_list|(
name|command
argument_list|)
expr_stmt|;
name|free_command_lines
argument_list|(
operator|&
name|command
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Cleanup */
end_comment

begin_function
specifier|static
name|void
name|arg_cleanup
parameter_list|(
name|void
modifier|*
name|ignore
parameter_list|)
block|{
name|struct
name|user_args
modifier|*
name|oargs
init|=
name|user_args
decl_stmt|;
if|if
condition|(
operator|!
name|user_args
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"arg_cleanup called with no user args.\n"
argument_list|)
expr_stmt|;
name|user_args
operator|=
name|user_args
operator|->
name|next
expr_stmt|;
name|xfree
argument_list|(
name|oargs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Bind the incomming arguments for a user defined command to    $arg0, $arg1 ... $argMAXUSERARGS.  */
end_comment

begin_function
specifier|static
name|struct
name|cleanup
modifier|*
name|setup_user_args
parameter_list|(
name|char
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|user_args
modifier|*
name|args
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|unsigned
name|int
name|arg_count
init|=
literal|0
decl_stmt|;
name|args
operator|=
operator|(
expr|struct
name|user_args
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|user_args
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|args
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|user_args
argument_list|)
argument_list|)
expr_stmt|;
name|args
operator|->
name|next
operator|=
name|user_args
expr_stmt|;
name|user_args
operator|=
name|args
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|arg_cleanup
argument_list|,
literal|0
comment|/*ignored*/
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
name|old_chain
return|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
name|char
modifier|*
name|start_arg
decl_stmt|;
name|int
name|squote
init|=
literal|0
decl_stmt|;
name|int
name|dquote
init|=
literal|0
decl_stmt|;
name|int
name|bsquote
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|arg_count
operator|>=
name|MAXUSERARGS
condition|)
block|{
name|error
argument_list|(
literal|"user defined function may only have %d arguments.\n"
argument_list|,
name|MAXUSERARGS
argument_list|)
expr_stmt|;
return|return
name|old_chain
return|;
block|}
comment|/* Strip whitespace.  */
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
comment|/* P now points to an argument.  */
name|start_arg
operator|=
name|p
expr_stmt|;
name|user_args
operator|->
name|a
index|[
name|arg_count
index|]
operator|.
name|arg
operator|=
name|p
expr_stmt|;
comment|/* Get to the end of this argument.  */
while|while
condition|(
operator|*
name|p
condition|)
block|{
if|if
condition|(
operator|(
operator|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
operator|)
operator|)
operator|&&
operator|!
name|squote
operator|&&
operator|!
name|dquote
operator|&&
operator|!
name|bsquote
condition|)
break|break;
else|else
block|{
if|if
condition|(
name|bsquote
condition|)
name|bsquote
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'\\'
condition|)
name|bsquote
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|squote
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\''
condition|)
name|squote
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dquote
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'"'
condition|)
name|dquote
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\''
condition|)
name|squote
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'"'
condition|)
name|dquote
operator|=
literal|1
expr_stmt|;
block|}
name|p
operator|++
expr_stmt|;
block|}
block|}
name|user_args
operator|->
name|a
index|[
name|arg_count
index|]
operator|.
name|len
operator|=
name|p
operator|-
name|start_arg
expr_stmt|;
name|arg_count
operator|++
expr_stmt|;
name|user_args
operator|->
name|count
operator|++
expr_stmt|;
block|}
return|return
name|old_chain
return|;
block|}
end_function

begin_comment
comment|/* Given character string P, return a point to the first argument ($arg),    or NULL if P contains no arguments.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|locate_arg
parameter_list|(
name|char
modifier|*
name|p
parameter_list|)
block|{
while|while
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'$'
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"$arg"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
operator|&&
name|isdigit
argument_list|(
name|p
index|[
literal|4
index|]
argument_list|)
condition|)
return|return
name|p
return|;
name|p
operator|++
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Insert the user defined arguments stored in user_arg into the $arg    arguments found in line, with the updated copy being placed into nline.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|insert_args
parameter_list|(
name|char
modifier|*
name|line
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|save_line
decl_stmt|,
modifier|*
name|new_line
decl_stmt|;
name|unsigned
name|len
decl_stmt|,
name|i
decl_stmt|;
comment|/* First we need to know how much memory to allocate for the new line.  */
name|save_line
operator|=
name|line
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
name|locate_arg
argument_list|(
name|line
argument_list|)
operator|)
condition|)
block|{
name|len
operator|+=
name|p
operator|-
name|line
expr_stmt|;
name|i
operator|=
name|p
index|[
literal|4
index|]
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|user_args
operator|->
name|count
condition|)
block|{
name|error
argument_list|(
literal|"Missing argument %d in user function.\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|len
operator|+=
name|user_args
operator|->
name|a
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
name|line
operator|=
name|p
operator|+
literal|5
expr_stmt|;
block|}
comment|/* Don't forget the tail.  */
name|len
operator|+=
name|strlen
argument_list|(
name|line
argument_list|)
expr_stmt|;
comment|/* Allocate space for the new line and fill it in.  */
name|new_line
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_line
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* Restore pointer to beginning of old line.  */
name|line
operator|=
name|save_line
expr_stmt|;
comment|/* Save pointer to beginning of new line.  */
name|save_line
operator|=
name|new_line
expr_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
name|locate_arg
argument_list|(
name|line
argument_list|)
operator|)
condition|)
block|{
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
name|memcpy
argument_list|(
name|new_line
argument_list|,
name|line
argument_list|,
name|p
operator|-
name|line
argument_list|)
expr_stmt|;
name|new_line
operator|+=
name|p
operator|-
name|line
expr_stmt|;
name|i
operator|=
name|p
index|[
literal|4
index|]
operator|-
literal|'0'
expr_stmt|;
name|len
operator|=
name|user_args
operator|->
name|a
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
if|if
condition|(
name|len
condition|)
block|{
name|memcpy
argument_list|(
name|new_line
argument_list|,
name|user_args
operator|->
name|a
index|[
name|i
index|]
operator|.
name|arg
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|new_line
operator|+=
name|len
expr_stmt|;
block|}
name|line
operator|=
name|p
operator|+
literal|5
expr_stmt|;
block|}
comment|/* Don't forget the tail.  */
name|strcpy
argument_list|(
name|new_line
argument_list|,
name|line
argument_list|)
expr_stmt|;
comment|/* Return a pointer to the beginning of the new line.  */
return|return
name|save_line
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Expand the body_list of COMMAND so that it can hold NEW_LENGTH    code bodies.  This is typically used when we encounter an "else"    clause for an "if" command.  */
end_comment

begin_function
specifier|static
name|void
name|realloc_body_list
parameter_list|(
name|struct
name|command_line
modifier|*
name|command
parameter_list|,
name|int
name|new_length
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
name|struct
name|command_line
modifier|*
modifier|*
name|body_list
decl_stmt|;
name|n
operator|=
name|command
operator|->
name|body_count
expr_stmt|;
comment|/* Nothing to do?  */
if|if
condition|(
name|new_length
operator|<=
name|n
condition|)
return|return;
name|body_list
operator|=
operator|(
expr|struct
name|command_line
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|command_line
operator|*
argument_list|)
operator|*
name|new_length
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|body_list
argument_list|,
name|command
operator|->
name|body_list
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|command_line
operator|*
argument_list|)
operator|*
name|n
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|command
operator|->
name|body_list
argument_list|)
expr_stmt|;
name|command
operator|->
name|body_list
operator|=
name|body_list
expr_stmt|;
name|command
operator|->
name|body_count
operator|=
name|new_length
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read one line from the input stream.  If the command is an "else" or    "end", return such an indication to the caller.  */
end_comment

begin_function
specifier|static
name|enum
name|misc_command_type
name|read_next_line
parameter_list|(
name|struct
name|command_line
modifier|*
modifier|*
name|command
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|p1
decl_stmt|,
modifier|*
name|prompt_ptr
decl_stmt|,
name|control_prompt
index|[
literal|256
index|]
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|control_level
operator|>=
literal|254
condition|)
name|error
argument_list|(
literal|"Control nesting too deep!\n"
argument_list|)
expr_stmt|;
comment|/* Set a prompt based on the nesting of the control commands.  */
if|if
condition|(
name|instream
operator|==
name|stdin
operator|||
operator|(
name|instream
operator|==
literal|0
operator|&&
name|readline_hook
operator|!=
name|NULL
operator|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|control_level
condition|;
name|i
operator|++
control|)
name|control_prompt
index|[
name|i
index|]
operator|=
literal|' '
expr_stmt|;
name|control_prompt
index|[
name|i
index|]
operator|=
literal|'>'
expr_stmt|;
name|control_prompt
index|[
name|i
operator|+
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|prompt_ptr
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|control_prompt
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
name|prompt_ptr
operator|=
name|NULL
expr_stmt|;
name|p
operator|=
name|command_line_input
argument_list|(
name|prompt_ptr
argument_list|,
name|instream
operator|==
name|stdin
argument_list|,
literal|"commands"
argument_list|)
expr_stmt|;
comment|/* Not sure what to do here.  */
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
name|end_command
return|;
comment|/* Strip leading and trailing whitespace.  */
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
name|p1
operator|=
name|p
operator|+
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
while|while
condition|(
name|p1
operator|!=
name|p
operator|&&
operator|(
name|p1
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
operator|||
name|p1
index|[
operator|-
literal|1
index|]
operator|==
literal|'\t'
operator|)
condition|)
name|p1
operator|--
expr_stmt|;
comment|/* Blanks and comments don't really do anything, but we need to      distinguish them from else, end and other commands which can be      executed.  */
if|if
condition|(
name|p1
operator|==
name|p
operator|||
name|p
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
return|return
name|nop_command
return|;
comment|/* Is this the end of a simple, while, or if control structure?  */
if|if
condition|(
name|p1
operator|-
name|p
operator|==
literal|3
operator|&&
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"end"
argument_list|,
literal|3
argument_list|)
condition|)
return|return
name|end_command
return|;
comment|/* Is the else clause of an if control structure?  */
if|if
condition|(
name|p1
operator|-
name|p
operator|==
literal|4
operator|&&
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"else"
argument_list|,
literal|4
argument_list|)
condition|)
return|return
name|else_command
return|;
comment|/* Check for while, if, break, continue, etc and build a new command      line structure for them.  */
if|if
condition|(
name|p1
operator|-
name|p
operator|>
literal|5
operator|&&
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"while"
argument_list|,
literal|5
argument_list|)
condition|)
operator|*
name|command
operator|=
name|build_command_line
argument_list|(
name|while_control
argument_list|,
name|p
operator|+
literal|6
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p1
operator|-
name|p
operator|>
literal|2
operator|&&
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"if"
argument_list|,
literal|2
argument_list|)
condition|)
operator|*
name|command
operator|=
name|build_command_line
argument_list|(
name|if_control
argument_list|,
name|p
operator|+
literal|3
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p1
operator|-
name|p
operator|==
literal|10
operator|&&
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"loop_break"
argument_list|,
literal|10
argument_list|)
condition|)
block|{
operator|*
name|command
operator|=
operator|(
expr|struct
name|command_line
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|command_line
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|command
operator|)
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
operator|(
operator|*
name|command
operator|)
operator|->
name|line
operator|=
name|NULL
expr_stmt|;
operator|(
operator|*
name|command
operator|)
operator|->
name|control_type
operator|=
name|break_control
expr_stmt|;
operator|(
operator|*
name|command
operator|)
operator|->
name|body_count
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|command
operator|)
operator|->
name|body_list
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p1
operator|-
name|p
operator|==
literal|13
operator|&&
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"loop_continue"
argument_list|,
literal|13
argument_list|)
condition|)
block|{
operator|*
name|command
operator|=
operator|(
expr|struct
name|command_line
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|command_line
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|command
operator|)
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
operator|(
operator|*
name|command
operator|)
operator|->
name|line
operator|=
name|NULL
expr_stmt|;
operator|(
operator|*
name|command
operator|)
operator|->
name|control_type
operator|=
name|continue_control
expr_stmt|;
operator|(
operator|*
name|command
operator|)
operator|->
name|body_count
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|command
operator|)
operator|->
name|body_list
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* A normal command.  */
operator|*
name|command
operator|=
operator|(
expr|struct
name|command_line
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|command_line
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|command
operator|)
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
operator|(
operator|*
name|command
operator|)
operator|->
name|line
operator|=
name|savestring
argument_list|(
name|p
argument_list|,
name|p1
operator|-
name|p
argument_list|)
expr_stmt|;
operator|(
operator|*
name|command
operator|)
operator|->
name|control_type
operator|=
name|simple_control
expr_stmt|;
operator|(
operator|*
name|command
operator|)
operator|->
name|body_count
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|command
operator|)
operator|->
name|body_list
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Nothing special.  */
return|return
name|ok_command
return|;
block|}
end_function

begin_comment
comment|/* Recursively read in the control structures and create a command_line     structure from them.     The parent_control parameter is the control structure in which the    following commands are nested.  */
end_comment

begin_function
specifier|static
name|enum
name|command_control_type
name|recurse_read_control_structure
parameter_list|(
name|struct
name|command_line
modifier|*
name|current_cmd
parameter_list|)
block|{
name|int
name|current_body
decl_stmt|,
name|i
decl_stmt|;
name|enum
name|misc_command_type
name|val
decl_stmt|;
name|enum
name|command_control_type
name|ret
decl_stmt|;
name|struct
name|command_line
modifier|*
modifier|*
name|body_ptr
decl_stmt|,
modifier|*
name|child_tail
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|child_tail
operator|=
name|NULL
expr_stmt|;
name|current_body
operator|=
literal|1
expr_stmt|;
comment|/* Sanity checks.  */
if|if
condition|(
name|current_cmd
operator|->
name|control_type
operator|==
name|simple_control
condition|)
block|{
name|error
argument_list|(
literal|"Recursed on a simple control type\n"
argument_list|)
expr_stmt|;
return|return
name|invalid_control
return|;
block|}
if|if
condition|(
name|current_body
operator|>
name|current_cmd
operator|->
name|body_count
condition|)
block|{
name|error
argument_list|(
literal|"Allocated body is smaller than this command type needs\n"
argument_list|)
expr_stmt|;
return|return
name|invalid_control
return|;
block|}
comment|/* Read lines from the input stream and build control structures.  */
while|while
condition|(
literal|1
condition|)
block|{
name|dont_repeat
argument_list|()
expr_stmt|;
name|next
operator|=
name|NULL
expr_stmt|;
name|val
operator|=
name|read_next_line
argument_list|(
operator|&
name|next
argument_list|)
expr_stmt|;
comment|/* Just skip blanks and comments.  */
if|if
condition|(
name|val
operator|==
name|nop_command
condition|)
continue|continue;
if|if
condition|(
name|val
operator|==
name|end_command
condition|)
block|{
if|if
condition|(
name|current_cmd
operator|->
name|control_type
operator|==
name|while_control
operator|||
name|current_cmd
operator|->
name|control_type
operator|==
name|if_control
condition|)
block|{
comment|/* Success reading an entire control structure.  */
name|ret
operator|=
name|simple_control
expr_stmt|;
break|break;
block|}
else|else
block|{
name|ret
operator|=
name|invalid_control
expr_stmt|;
break|break;
block|}
block|}
comment|/* Not the end of a control structure.  */
if|if
condition|(
name|val
operator|==
name|else_command
condition|)
block|{
if|if
condition|(
name|current_cmd
operator|->
name|control_type
operator|==
name|if_control
operator|&&
name|current_body
operator|==
literal|1
condition|)
block|{
name|realloc_body_list
argument_list|(
name|current_cmd
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|current_body
operator|=
literal|2
expr_stmt|;
name|child_tail
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|ret
operator|=
name|invalid_control
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|child_tail
condition|)
block|{
name|child_tail
operator|->
name|next
operator|=
name|next
expr_stmt|;
block|}
else|else
block|{
name|body_ptr
operator|=
name|current_cmd
operator|->
name|body_list
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|current_body
condition|;
name|i
operator|++
control|)
name|body_ptr
operator|++
expr_stmt|;
operator|*
name|body_ptr
operator|=
name|next
expr_stmt|;
block|}
name|child_tail
operator|=
name|next
expr_stmt|;
comment|/* If the latest line is another control structure, then recurse          on it.  */
if|if
condition|(
name|next
operator|->
name|control_type
operator|==
name|while_control
operator|||
name|next
operator|->
name|control_type
operator|==
name|if_control
condition|)
block|{
name|control_level
operator|++
expr_stmt|;
name|ret
operator|=
name|recurse_read_control_structure
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|control_level
operator|--
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|simple_control
condition|)
break|break;
block|}
block|}
name|dont_repeat
argument_list|()
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Read lines from the input stream and accumulate them in a chain of    struct command_line's, which is then returned.  For input from a    terminal, the special command "end" is used to mark the end of the    input, and is not included in the returned chain of commands. */
end_comment

begin_define
define|#
directive|define
name|END_MESSAGE
value|"End with a line saying just \"end\"."
end_define

begin_function
name|struct
name|command_line
modifier|*
name|read_command_lines
parameter_list|(
name|char
modifier|*
name|prompt_arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|command_line
modifier|*
name|head
decl_stmt|,
modifier|*
name|tail
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|enum
name|command_control_type
name|ret
decl_stmt|;
name|enum
name|misc_command_type
name|val
decl_stmt|;
name|control_level
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|readline_begin_hook
condition|)
block|{
comment|/* Note - intentional to merge messages with no newline */
call|(
modifier|*
name|readline_begin_hook
call|)
argument_list|(
literal|"%s  %s\n"
argument_list|,
name|prompt_arg
argument_list|,
name|END_MESSAGE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|from_tty
operator|&&
name|input_from_terminal_p
argument_list|()
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"%s\n%s\n"
argument_list|,
name|prompt_arg
argument_list|,
name|END_MESSAGE
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
name|head
operator|=
name|tail
operator|=
name|NULL
expr_stmt|;
name|old_chain
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|val
operator|=
name|read_next_line
argument_list|(
operator|&
name|next
argument_list|)
expr_stmt|;
comment|/* Ignore blank lines or comments.  */
if|if
condition|(
name|val
operator|==
name|nop_command
condition|)
continue|continue;
if|if
condition|(
name|val
operator|==
name|end_command
condition|)
block|{
name|ret
operator|=
name|simple_control
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|val
operator|!=
name|ok_command
condition|)
block|{
name|ret
operator|=
name|invalid_control
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|next
operator|->
name|control_type
operator|==
name|while_control
operator|||
name|next
operator|->
name|control_type
operator|==
name|if_control
condition|)
block|{
name|control_level
operator|++
expr_stmt|;
name|ret
operator|=
name|recurse_read_control_structure
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|control_level
operator|--
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|invalid_control
condition|)
break|break;
block|}
if|if
condition|(
name|tail
condition|)
block|{
name|tail
operator|->
name|next
operator|=
name|next
expr_stmt|;
block|}
else|else
block|{
name|head
operator|=
name|next
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup_free_command_lines
argument_list|(
operator|&
name|head
argument_list|)
expr_stmt|;
block|}
name|tail
operator|=
name|next
expr_stmt|;
block|}
name|dont_repeat
argument_list|()
expr_stmt|;
if|if
condition|(
name|head
condition|)
block|{
if|if
condition|(
name|ret
operator|!=
name|invalid_control
condition|)
block|{
name|discard_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
else|else
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|readline_end_hook
condition|)
block|{
call|(
modifier|*
name|readline_end_hook
call|)
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|head
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Free a chain of struct command_line's.  */
end_comment

begin_function
name|void
name|free_command_lines
parameter_list|(
name|struct
name|command_line
modifier|*
modifier|*
name|lptr
parameter_list|)
block|{
specifier|register
name|struct
name|command_line
modifier|*
name|l
init|=
operator|*
name|lptr
decl_stmt|;
specifier|register
name|struct
name|command_line
modifier|*
name|next
decl_stmt|;
name|struct
name|command_line
modifier|*
modifier|*
name|blist
decl_stmt|;
name|int
name|i
decl_stmt|;
while|while
condition|(
name|l
condition|)
block|{
if|if
condition|(
name|l
operator|->
name|body_count
operator|>
literal|0
condition|)
block|{
name|blist
operator|=
name|l
operator|->
name|body_list
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|l
operator|->
name|body_count
condition|;
name|i
operator|++
operator|,
name|blist
operator|++
control|)
name|free_command_lines
argument_list|(
name|blist
argument_list|)
expr_stmt|;
block|}
name|next
operator|=
name|l
operator|->
name|next
expr_stmt|;
name|xfree
argument_list|(
name|l
operator|->
name|line
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|l
operator|=
name|next
expr_stmt|;
block|}
operator|*
name|lptr
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_free_command_lines_cleanup
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|free_command_lines
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|cleanup
modifier|*
name|make_cleanup_free_command_lines
parameter_list|(
name|struct
name|command_line
modifier|*
modifier|*
name|arg
parameter_list|)
block|{
return|return
name|make_cleanup
argument_list|(
name|do_free_command_lines_cleanup
argument_list|,
name|arg
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|validate_comname
parameter_list|(
name|char
modifier|*
name|comname
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|comname
operator|==
literal|0
condition|)
name|error_no_arg
argument_list|(
literal|"name of command to define"
argument_list|)
expr_stmt|;
name|p
operator|=
name|comname
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
if|if
condition|(
operator|!
name|isalnum
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
operator|*
name|p
operator|!=
literal|'-'
operator|&&
operator|*
name|p
operator|!=
literal|'_'
condition|)
name|error
argument_list|(
literal|"Junk in argument list: \"%s\""
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This is just a placeholder in the command data structures.  */
end_comment

begin_function
specifier|static
name|void
name|user_defined_command
parameter_list|(
name|char
modifier|*
name|ignore
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{ }
end_function

begin_function
name|void
name|define_command
parameter_list|(
name|char
modifier|*
name|comname
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
define|#
directive|define
name|MAX_TMPBUF
value|128
enum|enum
name|cmd_hook_type
block|{
name|CMD_NO_HOOK
init|=
literal|0
block|,
name|CMD_PRE_HOOK
block|,
name|CMD_POST_HOOK
block|}
enum|;
specifier|register
name|struct
name|command_line
modifier|*
name|cmds
decl_stmt|;
specifier|register
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|,
modifier|*
name|newc
decl_stmt|,
modifier|*
name|oldc
decl_stmt|,
modifier|*
name|hookc
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|tem
init|=
name|comname
decl_stmt|;
name|char
modifier|*
name|tem2
decl_stmt|;
name|char
name|tmpbuf
index|[
name|MAX_TMPBUF
index|]
decl_stmt|;
name|int
name|hook_type
init|=
name|CMD_NO_HOOK
decl_stmt|;
name|int
name|hook_name_size
init|=
literal|0
decl_stmt|;
define|#
directive|define
name|HOOK_STRING
value|"hook-"
define|#
directive|define
name|HOOK_LEN
value|5
define|#
directive|define
name|HOOK_POST_STRING
value|"hookpost-"
define|#
directive|define
name|HOOK_POST_LEN
value|9
name|validate_comname
argument_list|(
name|comname
argument_list|)
expr_stmt|;
comment|/* Look it up, and verify that we got an exact match.  */
name|c
operator|=
name|lookup_cmd
argument_list|(
operator|&
name|tem
argument_list|,
name|cmdlist
argument_list|,
literal|""
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|&&
operator|!
name|STREQ
argument_list|(
name|comname
argument_list|,
name|c
operator|->
name|name
argument_list|)
condition|)
name|c
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|class
operator|==
name|class_user
operator|||
name|c
operator|->
name|class
operator|==
name|class_alias
condition|)
name|tem
operator|=
literal|"Redefine command \"%s\"? "
expr_stmt|;
else|else
name|tem
operator|=
literal|"Really redefine built-in command \"%s\"? "
expr_stmt|;
if|if
condition|(
operator|!
name|query
argument_list|(
name|tem
argument_list|,
name|c
operator|->
name|name
argument_list|)
condition|)
name|error
argument_list|(
literal|"Command \"%s\" not redefined."
argument_list|,
name|c
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
comment|/* If this new command is a hook, then mark the command which it      is hooking.  Note that we allow hooking `help' commands, so that      we can hook the `stop' pseudo-command.  */
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|comname
argument_list|,
name|HOOK_STRING
argument_list|,
name|HOOK_LEN
argument_list|)
condition|)
block|{
name|hook_type
operator|=
name|CMD_PRE_HOOK
expr_stmt|;
name|hook_name_size
operator|=
name|HOOK_LEN
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|comname
argument_list|,
name|HOOK_POST_STRING
argument_list|,
name|HOOK_POST_LEN
argument_list|)
condition|)
block|{
name|hook_type
operator|=
name|CMD_POST_HOOK
expr_stmt|;
name|hook_name_size
operator|=
name|HOOK_POST_LEN
expr_stmt|;
block|}
if|if
condition|(
name|hook_type
operator|!=
name|CMD_NO_HOOK
condition|)
block|{
comment|/* Look up cmd it hooks, and verify that we got an exact match.  */
name|tem
operator|=
name|comname
operator|+
name|hook_name_size
expr_stmt|;
name|hookc
operator|=
name|lookup_cmd
argument_list|(
operator|&
name|tem
argument_list|,
name|cmdlist
argument_list|,
literal|""
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|hookc
operator|&&
operator|!
name|STREQ
argument_list|(
name|comname
operator|+
name|hook_name_size
argument_list|,
name|hookc
operator|->
name|name
argument_list|)
condition|)
name|hookc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|hookc
condition|)
block|{
name|warning
argument_list|(
literal|"Your new `%s' command does not hook any existing command."
argument_list|,
name|comname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|query
argument_list|(
literal|"Proceed? "
argument_list|)
condition|)
name|error
argument_list|(
literal|"Not confirmed."
argument_list|)
expr_stmt|;
block|}
block|}
name|comname
operator|=
name|savestring
argument_list|(
name|comname
argument_list|,
name|strlen
argument_list|(
name|comname
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the rest of the commands will be case insensitive, this one      should behave in the same manner. */
for|for
control|(
name|tem
operator|=
name|comname
init|;
operator|*
name|tem
condition|;
name|tem
operator|++
control|)
if|if
condition|(
name|isupper
argument_list|(
operator|*
name|tem
argument_list|)
condition|)
operator|*
name|tem
operator|=
name|tolower
argument_list|(
operator|*
name|tem
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tmpbuf
argument_list|,
literal|"Type commands for definition of \"%s\"."
argument_list|,
name|comname
argument_list|)
expr_stmt|;
name|cmds
operator|=
name|read_command_lines
argument_list|(
name|tmpbuf
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|&&
name|c
operator|->
name|class
operator|==
name|class_user
condition|)
name|free_command_lines
argument_list|(
operator|&
name|c
operator|->
name|user_commands
argument_list|)
expr_stmt|;
name|newc
operator|=
name|add_cmd
argument_list|(
name|comname
argument_list|,
name|class_user
argument_list|,
name|user_defined_command
argument_list|,
operator|(
name|c
operator|&&
name|c
operator|->
name|class
operator|==
name|class_user
operator|)
condition|?
name|c
operator|->
name|doc
else|:
name|savestring
argument_list|(
literal|"User-defined."
argument_list|,
literal|13
argument_list|)
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|newc
operator|->
name|user_commands
operator|=
name|cmds
expr_stmt|;
comment|/* If this new command is a hook, then mark both commands as being      tied.  */
if|if
condition|(
name|hookc
condition|)
block|{
switch|switch
condition|(
name|hook_type
condition|)
block|{
case|case
name|CMD_PRE_HOOK
case|:
name|hookc
operator|->
name|hook_pre
operator|=
name|newc
expr_stmt|;
comment|/* Target gets hooked.  */
name|newc
operator|->
name|hookee_pre
operator|=
name|hookc
expr_stmt|;
comment|/* We are marked as hooking target cmd. */
break|break;
case|case
name|CMD_POST_HOOK
case|:
name|hookc
operator|->
name|hook_post
operator|=
name|newc
expr_stmt|;
comment|/* Target gets hooked.  */
name|newc
operator|->
name|hookee_post
operator|=
name|hookc
expr_stmt|;
comment|/* We are marked as hooking target cmd. */
break|break;
default|default:
comment|/* Should never come here as hookc would be 0. */
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"bad switch"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|document_command
parameter_list|(
name|char
modifier|*
name|comname
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|command_line
modifier|*
name|doclines
decl_stmt|;
specifier|register
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
name|char
modifier|*
name|tem
init|=
name|comname
decl_stmt|;
name|char
name|tmpbuf
index|[
literal|128
index|]
decl_stmt|;
name|validate_comname
argument_list|(
name|comname
argument_list|)
expr_stmt|;
name|c
operator|=
name|lookup_cmd
argument_list|(
operator|&
name|tem
argument_list|,
name|cmdlist
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|class
operator|!=
name|class_user
condition|)
name|error
argument_list|(
literal|"Command \"%s\" is built-in."
argument_list|,
name|comname
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tmpbuf
argument_list|,
literal|"Type documentation for \"%s\"."
argument_list|,
name|comname
argument_list|)
expr_stmt|;
name|doclines
operator|=
name|read_command_lines
argument_list|(
name|tmpbuf
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|doc
condition|)
name|xfree
argument_list|(
name|c
operator|->
name|doc
argument_list|)
expr_stmt|;
block|{
specifier|register
name|struct
name|command_line
modifier|*
name|cl1
decl_stmt|;
specifier|register
name|int
name|len
init|=
literal|0
decl_stmt|;
for|for
control|(
name|cl1
operator|=
name|doclines
init|;
name|cl1
condition|;
name|cl1
operator|=
name|cl1
operator|->
name|next
control|)
name|len
operator|+=
name|strlen
argument_list|(
name|cl1
operator|->
name|line
argument_list|)
operator|+
literal|1
expr_stmt|;
name|c
operator|->
name|doc
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|*
name|c
operator|->
name|doc
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|cl1
operator|=
name|doclines
init|;
name|cl1
condition|;
name|cl1
operator|=
name|cl1
operator|->
name|next
control|)
block|{
name|strcat
argument_list|(
name|c
operator|->
name|doc
argument_list|,
name|cl1
operator|->
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|cl1
operator|->
name|next
condition|)
name|strcat
argument_list|(
name|c
operator|->
name|doc
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|free_command_lines
argument_list|(
operator|&
name|doclines
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_struct
struct|struct
name|source_cleanup_lines_args
block|{
name|int
name|old_line
decl_stmt|;
name|char
modifier|*
name|old_file
decl_stmt|;
name|char
modifier|*
name|old_pre_error
decl_stmt|;
name|char
modifier|*
name|old_error_pre_print
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|source_cleanup_lines
parameter_list|(
name|PTR
name|args
parameter_list|)
block|{
name|struct
name|source_cleanup_lines_args
modifier|*
name|p
init|=
operator|(
expr|struct
name|source_cleanup_lines_args
operator|*
operator|)
name|args
decl_stmt|;
name|source_line_number
operator|=
name|p
operator|->
name|old_line
expr_stmt|;
name|source_file_name
operator|=
name|p
operator|->
name|old_file
expr_stmt|;
name|source_pre_error
operator|=
name|p
operator|->
name|old_pre_error
expr_stmt|;
name|error_pre_print
operator|=
name|p
operator|->
name|old_error_pre_print
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|do_fclose_cleanup
parameter_list|(
name|void
modifier|*
name|stream
parameter_list|)
block|{
name|fclose
argument_list|(
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Used to implement source_command */
end_comment

begin_function
name|void
name|script_from_file
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
name|char
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|cleanup
modifier|*
name|old_cleanups
decl_stmt|;
name|struct
name|source_cleanup_lines_args
name|old_lines
decl_stmt|;
name|int
name|needed_length
decl_stmt|;
if|if
condition|(
name|stream
operator|==
name|NULL
condition|)
block|{
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"called with NULL file pointer!"
argument_list|)
expr_stmt|;
block|}
name|old_cleanups
operator|=
name|make_cleanup
argument_list|(
name|do_fclose_cleanup
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|old_lines
operator|.
name|old_line
operator|=
name|source_line_number
expr_stmt|;
name|old_lines
operator|.
name|old_file
operator|=
name|source_file_name
expr_stmt|;
name|old_lines
operator|.
name|old_pre_error
operator|=
name|source_pre_error
expr_stmt|;
name|old_lines
operator|.
name|old_error_pre_print
operator|=
name|error_pre_print
expr_stmt|;
name|make_cleanup
argument_list|(
name|source_cleanup_lines
argument_list|,
operator|&
name|old_lines
argument_list|)
expr_stmt|;
name|source_line_number
operator|=
literal|0
expr_stmt|;
name|source_file_name
operator|=
name|file
expr_stmt|;
name|source_pre_error
operator|=
name|error_pre_print
operator|==
name|NULL
condition|?
literal|""
else|:
name|error_pre_print
expr_stmt|;
name|source_pre_error
operator|=
name|savestring
argument_list|(
name|source_pre_error
argument_list|,
name|strlen
argument_list|(
name|source_pre_error
argument_list|)
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|source_pre_error
argument_list|)
expr_stmt|;
comment|/* This will get set every time we read a line.  So it won't stay "" for      long.  */
name|error_pre_print
operator|=
literal|""
expr_stmt|;
name|needed_length
operator|=
name|strlen
argument_list|(
name|source_file_name
argument_list|)
operator|+
name|strlen
argument_list|(
name|source_pre_error
argument_list|)
operator|+
literal|80
expr_stmt|;
if|if
condition|(
name|source_error_allocated
operator|<
name|needed_length
condition|)
block|{
name|source_error_allocated
operator|*=
literal|2
expr_stmt|;
if|if
condition|(
name|source_error_allocated
operator|<
name|needed_length
condition|)
name|source_error_allocated
operator|=
name|needed_length
expr_stmt|;
if|if
condition|(
name|source_error
operator|==
name|NULL
condition|)
name|source_error
operator|=
name|xmalloc
argument_list|(
name|source_error_allocated
argument_list|)
expr_stmt|;
else|else
name|source_error
operator|=
name|xrealloc
argument_list|(
name|source_error
argument_list|,
name|source_error_allocated
argument_list|)
expr_stmt|;
block|}
name|read_command_file
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_cleanups
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|show_user_1
parameter_list|(
name|struct
name|cmd_list_element
modifier|*
name|c
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|)
block|{
specifier|register
name|struct
name|command_line
modifier|*
name|cmdlines
decl_stmt|;
name|cmdlines
operator|=
name|c
operator|->
name|user_commands
expr_stmt|;
if|if
condition|(
operator|!
name|cmdlines
condition|)
return|return;
name|fputs_filtered
argument_list|(
literal|"User command "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
name|c
operator|->
name|name
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|":\n"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|print_command_lines
argument_list|(
name|uiout
argument_list|,
name|cmdlines
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"\n"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

