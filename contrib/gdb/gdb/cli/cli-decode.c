begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Handle lists of commands, their decoding and documentation, for GDB.     Copyright 1986, 1989, 1990, 1991, 1998, 2000, 2001, 2002 Free    Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"gdb_regex.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"ui-out.h"
end_include

begin_include
include|#
directive|include
file|"cli/cli-cmds.h"
end_include

begin_include
include|#
directive|include
file|"cli/cli-decode.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|TUI
end_ifdef

begin_include
include|#
directive|include
file|"tui/tui.h"
end_include

begin_comment
comment|/* For tui_active et.al.   */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"gdb_assert.h"
end_include

begin_comment
comment|/* Prototypes for local functions */
end_comment

begin_function_decl
specifier|static
name|void
name|undef_cmd_error
parameter_list|(
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|cmd_list_element
modifier|*
name|find_cmd
parameter_list|(
name|char
modifier|*
name|command
parameter_list|,
name|int
name|len
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
name|clist
parameter_list|,
name|int
name|ignore_help_classes
parameter_list|,
name|int
modifier|*
name|nfound
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|help_all
parameter_list|(
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Set the callback function for the specified command.  For each both    the commands callback and func() are set.  The latter set to a    bounce function (unless cfunc / sfunc is NULL that is).  */
end_comment

begin_function
specifier|static
name|void
name|do_cfunc
parameter_list|(
name|struct
name|cmd_list_element
modifier|*
name|c
parameter_list|,
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|c
operator|->
name|function
operator|.
name|cfunc
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
comment|/* Ok.  */
block|}
end_function

begin_function
name|void
name|set_cmd_cfunc
parameter_list|(
name|struct
name|cmd_list_element
modifier|*
name|cmd
parameter_list|,
name|cmd_cfunc_ftype
modifier|*
name|cfunc
parameter_list|)
block|{
if|if
condition|(
name|cfunc
operator|==
name|NULL
condition|)
name|cmd
operator|->
name|func
operator|=
name|NULL
expr_stmt|;
else|else
name|cmd
operator|->
name|func
operator|=
name|do_cfunc
expr_stmt|;
name|cmd
operator|->
name|function
operator|.
name|cfunc
operator|=
name|cfunc
expr_stmt|;
comment|/* Ok.  */
block|}
end_function

begin_function
specifier|static
name|void
name|do_sfunc
parameter_list|(
name|struct
name|cmd_list_element
modifier|*
name|c
parameter_list|,
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|c
operator|->
name|function
operator|.
name|sfunc
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|,
name|c
argument_list|)
expr_stmt|;
comment|/* Ok.  */
block|}
end_function

begin_function
name|void
name|set_cmd_sfunc
parameter_list|(
name|struct
name|cmd_list_element
modifier|*
name|cmd
parameter_list|,
name|cmd_sfunc_ftype
modifier|*
name|sfunc
parameter_list|)
block|{
if|if
condition|(
name|sfunc
operator|==
name|NULL
condition|)
name|cmd
operator|->
name|func
operator|=
name|NULL
expr_stmt|;
else|else
name|cmd
operator|->
name|func
operator|=
name|do_sfunc
expr_stmt|;
name|cmd
operator|->
name|function
operator|.
name|sfunc
operator|=
name|sfunc
expr_stmt|;
comment|/* Ok.  */
block|}
end_function

begin_function
name|int
name|cmd_cfunc_eq
parameter_list|(
name|struct
name|cmd_list_element
modifier|*
name|cmd
parameter_list|,
name|void
function_decl|(
modifier|*
name|cfunc
function_decl|)
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
parameter_list|)
block|{
return|return
name|cmd
operator|->
name|func
operator|==
name|do_cfunc
operator|&&
name|cmd
operator|->
name|function
operator|.
name|cfunc
operator|==
name|cfunc
return|;
block|}
end_function

begin_function
name|void
name|set_cmd_context
parameter_list|(
name|struct
name|cmd_list_element
modifier|*
name|cmd
parameter_list|,
name|void
modifier|*
name|context
parameter_list|)
block|{
name|cmd
operator|->
name|context
operator|=
name|context
expr_stmt|;
block|}
end_function

begin_function
name|void
modifier|*
name|get_cmd_context
parameter_list|(
name|struct
name|cmd_list_element
modifier|*
name|cmd
parameter_list|)
block|{
return|return
name|cmd
operator|->
name|context
return|;
block|}
end_function

begin_function
name|enum
name|cmd_types
name|cmd_type
parameter_list|(
name|struct
name|cmd_list_element
modifier|*
name|cmd
parameter_list|)
block|{
return|return
name|cmd
operator|->
name|type
return|;
block|}
end_function

begin_function
name|void
name|set_cmd_completer
parameter_list|(
name|struct
name|cmd_list_element
modifier|*
name|cmd
parameter_list|,
name|char
modifier|*
modifier|*
function_decl|(
modifier|*
name|completer
function_decl|)
parameter_list|(
name|char
modifier|*
name|text
parameter_list|,
name|char
modifier|*
name|word
parameter_list|)
parameter_list|)
block|{
name|cmd
operator|->
name|completer
operator|=
name|completer
expr_stmt|;
comment|/* Ok.  */
block|}
end_function

begin_comment
comment|/* Add element named NAME.    CLASS is the top level category into which commands are broken down    for "help" purposes.    FUN should be the function to execute the command;    it will get a character string as argument, with leading    and trailing blanks already eliminated.     DOC is a documentation string for the command.    Its first line should be a complete sentence.    It should start with ? for a command that is an abbreviation    or with * for a command that most users don't need to know about.     Add this command to command list *LIST.       Returns a pointer to the added command (not necessarily the head     of *LIST). */
end_comment

begin_function
name|struct
name|cmd_list_element
modifier|*
name|add_cmd
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|enum
name|command_class
name|class
parameter_list|,
name|void
function_decl|(
modifier|*
name|fun
function_decl|)
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
parameter_list|,
name|char
modifier|*
name|doc
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
modifier|*
name|list
parameter_list|)
block|{
name|struct
name|cmd_list_element
modifier|*
name|c
init|=
operator|(
expr|struct
name|cmd_list_element
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|cmd_list_element
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|cmd_list_element
modifier|*
name|p
decl_stmt|;
name|delete_cmd
argument_list|(
name|name
argument_list|,
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|list
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
operator|(
operator|*
name|list
operator|)
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|c
operator|->
name|next
operator|=
operator|*
name|list
expr_stmt|;
operator|*
name|list
operator|=
name|c
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
operator|*
name|list
expr_stmt|;
while|while
condition|(
name|p
operator|->
name|next
operator|&&
name|strcmp
argument_list|(
name|p
operator|->
name|next
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
block|}
name|c
operator|->
name|next
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|c
expr_stmt|;
block|}
name|c
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|c
operator|->
name|class
operator|=
name|class
expr_stmt|;
name|set_cmd_cfunc
argument_list|(
name|c
argument_list|,
name|fun
argument_list|)
expr_stmt|;
name|set_cmd_context
argument_list|(
name|c
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|c
operator|->
name|doc
operator|=
name|doc
expr_stmt|;
name|c
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|replacement
operator|=
name|NULL
expr_stmt|;
name|c
operator|->
name|pre_show_hook
operator|=
name|NULL
expr_stmt|;
name|c
operator|->
name|hook_pre
operator|=
name|NULL
expr_stmt|;
name|c
operator|->
name|hook_post
operator|=
name|NULL
expr_stmt|;
name|c
operator|->
name|hook_in
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|prefixlist
operator|=
name|NULL
expr_stmt|;
name|c
operator|->
name|prefixname
operator|=
name|NULL
expr_stmt|;
name|c
operator|->
name|allow_unknown
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|abbrev_flag
operator|=
literal|0
expr_stmt|;
name|set_cmd_completer
argument_list|(
name|c
argument_list|,
name|make_symbol_completion_list
argument_list|)
expr_stmt|;
name|c
operator|->
name|type
operator|=
name|not_set_cmd
expr_stmt|;
name|c
operator|->
name|var
operator|=
name|NULL
expr_stmt|;
name|c
operator|->
name|var_type
operator|=
name|var_boolean
expr_stmt|;
name|c
operator|->
name|enums
operator|=
name|NULL
expr_stmt|;
name|c
operator|->
name|user_commands
operator|=
name|NULL
expr_stmt|;
name|c
operator|->
name|hookee_pre
operator|=
name|NULL
expr_stmt|;
name|c
operator|->
name|hookee_post
operator|=
name|NULL
expr_stmt|;
name|c
operator|->
name|cmd_pointer
operator|=
name|NULL
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_comment
comment|/* Deprecates a command CMD.    REPLACEMENT is the name of the command which should be used in place    of this command, or NULL if no such command exists.     This function does not check to see if command REPLACEMENT exists    since gdb may not have gotten around to adding REPLACEMENT when this    function is called.     Returns a pointer to the deprecated command.  */
end_comment

begin_function
name|struct
name|cmd_list_element
modifier|*
name|deprecate_cmd
parameter_list|(
name|struct
name|cmd_list_element
modifier|*
name|cmd
parameter_list|,
name|char
modifier|*
name|replacement
parameter_list|)
block|{
name|cmd
operator|->
name|flags
operator||=
operator|(
name|CMD_DEPRECATED
operator||
name|DEPRECATED_WARN_USER
operator|)
expr_stmt|;
if|if
condition|(
name|replacement
operator|!=
name|NULL
condition|)
name|cmd
operator|->
name|replacement
operator|=
name|replacement
expr_stmt|;
else|else
name|cmd
operator|->
name|replacement
operator|=
name|NULL
expr_stmt|;
return|return
name|cmd
return|;
block|}
end_function

begin_function
name|struct
name|cmd_list_element
modifier|*
name|add_alias_cmd
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|oldname
parameter_list|,
name|enum
name|command_class
name|class
parameter_list|,
name|int
name|abbrev_flag
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
modifier|*
name|list
parameter_list|)
block|{
comment|/* Must do this since lookup_cmd tries to side-effect its first arg */
name|char
modifier|*
name|copied_name
decl_stmt|;
name|struct
name|cmd_list_element
modifier|*
name|old
decl_stmt|;
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
name|copied_name
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|oldname
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|copied_name
argument_list|,
name|oldname
argument_list|)
expr_stmt|;
name|old
operator|=
name|lookup_cmd
argument_list|(
operator|&
name|copied_name
argument_list|,
operator|*
name|list
argument_list|,
literal|""
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
operator|==
literal|0
condition|)
block|{
name|delete_cmd
argument_list|(
name|name
argument_list|,
name|list
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|c
operator|=
name|add_cmd
argument_list|(
name|name
argument_list|,
name|class
argument_list|,
name|NULL
argument_list|,
name|old
operator|->
name|doc
argument_list|,
name|list
argument_list|)
expr_stmt|;
comment|/* NOTE: Both FUNC and all the FUNCTIONs need to be copied.  */
name|c
operator|->
name|func
operator|=
name|old
operator|->
name|func
expr_stmt|;
name|c
operator|->
name|function
operator|=
name|old
operator|->
name|function
expr_stmt|;
name|c
operator|->
name|prefixlist
operator|=
name|old
operator|->
name|prefixlist
expr_stmt|;
name|c
operator|->
name|prefixname
operator|=
name|old
operator|->
name|prefixname
expr_stmt|;
name|c
operator|->
name|allow_unknown
operator|=
name|old
operator|->
name|allow_unknown
expr_stmt|;
name|c
operator|->
name|abbrev_flag
operator|=
name|abbrev_flag
expr_stmt|;
name|c
operator|->
name|cmd_pointer
operator|=
name|old
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_comment
comment|/* Like add_cmd but adds an element for a command prefix:    a name that should be followed by a subcommand to be looked up    in another command list.  PREFIXLIST should be the address    of the variable containing that list.  */
end_comment

begin_function
name|struct
name|cmd_list_element
modifier|*
name|add_prefix_cmd
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|enum
name|command_class
name|class
parameter_list|,
name|void
function_decl|(
modifier|*
name|fun
function_decl|)
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
parameter_list|,
name|char
modifier|*
name|doc
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
modifier|*
name|prefixlist
parameter_list|,
name|char
modifier|*
name|prefixname
parameter_list|,
name|int
name|allow_unknown
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
modifier|*
name|list
parameter_list|)
block|{
name|struct
name|cmd_list_element
modifier|*
name|c
init|=
name|add_cmd
argument_list|(
name|name
argument_list|,
name|class
argument_list|,
name|fun
argument_list|,
name|doc
argument_list|,
name|list
argument_list|)
decl_stmt|;
name|c
operator|->
name|prefixlist
operator|=
name|prefixlist
expr_stmt|;
name|c
operator|->
name|prefixname
operator|=
name|prefixname
expr_stmt|;
name|c
operator|->
name|allow_unknown
operator|=
name|allow_unknown
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_comment
comment|/* Like add_prefix_cmd but sets the abbrev_flag on the new command. */
end_comment

begin_function
name|struct
name|cmd_list_element
modifier|*
name|add_abbrev_prefix_cmd
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|enum
name|command_class
name|class
parameter_list|,
name|void
function_decl|(
modifier|*
name|fun
function_decl|)
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
parameter_list|,
name|char
modifier|*
name|doc
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
modifier|*
name|prefixlist
parameter_list|,
name|char
modifier|*
name|prefixname
parameter_list|,
name|int
name|allow_unknown
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
modifier|*
name|list
parameter_list|)
block|{
name|struct
name|cmd_list_element
modifier|*
name|c
init|=
name|add_cmd
argument_list|(
name|name
argument_list|,
name|class
argument_list|,
name|fun
argument_list|,
name|doc
argument_list|,
name|list
argument_list|)
decl_stmt|;
name|c
operator|->
name|prefixlist
operator|=
name|prefixlist
expr_stmt|;
name|c
operator|->
name|prefixname
operator|=
name|prefixname
expr_stmt|;
name|c
operator|->
name|allow_unknown
operator|=
name|allow_unknown
expr_stmt|;
name|c
operator|->
name|abbrev_flag
operator|=
literal|1
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_comment
comment|/* This is an empty "cfunc".  */
end_comment

begin_function
name|void
name|not_just_help_class_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{ }
end_function

begin_comment
comment|/* This is an empty "sfunc".  */
end_comment

begin_function_decl
specifier|static
name|void
name|empty_sfunc
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|empty_sfunc
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
name|c
parameter_list|)
block|{ }
end_function

begin_comment
comment|/* Add element named NAME to command list LIST (the list for set/show    or some sublist thereof).    TYPE is set_cmd or show_cmd.    CLASS is as in add_cmd.    VAR_TYPE is the kind of thing we are setting.    VAR is address of the variable being controlled by this command.    DOC is the documentation string.  */
end_comment

begin_function
specifier|static
name|struct
name|cmd_list_element
modifier|*
name|add_set_or_show_cmd
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|enum
name|cmd_types
name|type
parameter_list|,
name|enum
name|command_class
name|class
parameter_list|,
name|var_types
name|var_type
parameter_list|,
name|void
modifier|*
name|var
parameter_list|,
name|char
modifier|*
name|doc
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
modifier|*
name|list
parameter_list|)
block|{
name|struct
name|cmd_list_element
modifier|*
name|c
init|=
name|add_cmd
argument_list|(
name|name
argument_list|,
name|class
argument_list|,
name|NULL
argument_list|,
name|doc
argument_list|,
name|list
argument_list|)
decl_stmt|;
name|gdb_assert
argument_list|(
name|type
operator|==
name|set_cmd
operator|||
name|type
operator|==
name|show_cmd
argument_list|)
expr_stmt|;
name|c
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|c
operator|->
name|var_type
operator|=
name|var_type
expr_stmt|;
name|c
operator|->
name|var
operator|=
name|var
expr_stmt|;
comment|/* This needs to be something besides NULL so that this isn't      treated as a help class.  */
name|set_cmd_sfunc
argument_list|(
name|c
argument_list|,
name|empty_sfunc
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_comment
comment|/* Add element named NAME to both the command SET_LIST and SHOW_LIST.    CLASS is as in add_cmd.  VAR_TYPE is the kind of thing we are    setting.  VAR is address of the variable being controlled by this    command.  SET_FUNC and SHOW_FUNC are the callback functions (if    non-NULL).  SET_DOC and SHOW_DOC are the documentation strings.    SET_RESULT and SHOW_RESULT, if not NULL, are set to the resulting    command structures.  */
end_comment

begin_function
name|void
name|add_setshow_cmd_full
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|enum
name|command_class
name|class
parameter_list|,
name|var_types
name|var_type
parameter_list|,
name|void
modifier|*
name|var
parameter_list|,
name|char
modifier|*
name|set_doc
parameter_list|,
name|char
modifier|*
name|show_doc
parameter_list|,
name|cmd_sfunc_ftype
modifier|*
name|set_func
parameter_list|,
name|cmd_sfunc_ftype
modifier|*
name|show_func
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
modifier|*
name|set_list
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
modifier|*
name|show_list
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
modifier|*
name|set_result
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
modifier|*
name|show_result
parameter_list|)
block|{
name|struct
name|cmd_list_element
modifier|*
name|set
decl_stmt|;
name|struct
name|cmd_list_element
modifier|*
name|show
decl_stmt|;
name|set
operator|=
name|add_set_or_show_cmd
argument_list|(
name|name
argument_list|,
name|set_cmd
argument_list|,
name|class
argument_list|,
name|var_type
argument_list|,
name|var
argument_list|,
name|set_doc
argument_list|,
name|set_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|set_func
operator|!=
name|NULL
condition|)
name|set_cmd_sfunc
argument_list|(
name|set
argument_list|,
name|set_func
argument_list|)
expr_stmt|;
name|show
operator|=
name|add_set_or_show_cmd
argument_list|(
name|name
argument_list|,
name|show_cmd
argument_list|,
name|class
argument_list|,
name|var_type
argument_list|,
name|var
argument_list|,
name|show_doc
argument_list|,
name|show_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|show_func
operator|!=
name|NULL
condition|)
name|set_cmd_sfunc
argument_list|(
name|show
argument_list|,
name|show_func
argument_list|)
expr_stmt|;
if|if
condition|(
name|set_result
operator|!=
name|NULL
condition|)
operator|*
name|set_result
operator|=
name|set
expr_stmt|;
if|if
condition|(
name|show_result
operator|!=
name|NULL
condition|)
operator|*
name|show_result
operator|=
name|show
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add element named NAME to both the command SET_LIST and SHOW_LIST.    CLASS is as in add_cmd.  VAR_TYPE is the kind of thing we are    setting.  VAR is address of the variable being controlled by this    command.  SET_FUNC and SHOW_FUNC are the callback functions (if    non-NULL).  SET_DOC and SHOW_DOC are the documentation strings.  */
end_comment

begin_function
name|void
name|add_setshow_cmd
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|enum
name|command_class
name|class
parameter_list|,
name|var_types
name|var_type
parameter_list|,
name|void
modifier|*
name|var
parameter_list|,
name|char
modifier|*
name|set_doc
parameter_list|,
name|char
modifier|*
name|show_doc
parameter_list|,
name|cmd_sfunc_ftype
modifier|*
name|set_func
parameter_list|,
name|cmd_sfunc_ftype
modifier|*
name|show_func
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
modifier|*
name|set_list
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
modifier|*
name|show_list
parameter_list|)
block|{
name|add_setshow_cmd_full
argument_list|(
name|name
argument_list|,
name|class
argument_list|,
name|var_type
argument_list|,
name|var
argument_list|,
name|set_doc
argument_list|,
name|show_doc
argument_list|,
name|set_func
argument_list|,
name|show_func
argument_list|,
name|set_list
argument_list|,
name|show_list
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|cmd_list_element
modifier|*
name|add_set_cmd
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|enum
name|command_class
name|class
parameter_list|,
name|var_types
name|var_type
parameter_list|,
name|void
modifier|*
name|var
parameter_list|,
name|char
modifier|*
name|doc
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
modifier|*
name|list
parameter_list|)
block|{
return|return
name|add_set_or_show_cmd
argument_list|(
name|name
argument_list|,
name|set_cmd
argument_list|,
name|class
argument_list|,
name|var_type
argument_list|,
name|var
argument_list|,
name|doc
argument_list|,
name|list
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Add element named NAME to command list LIST (the list for set    or some sublist thereof).    CLASS is as in add_cmd.    ENUMLIST is a list of strings which may follow NAME.    VAR is address of the variable which will contain the matching string    (from ENUMLIST).    DOC is the documentation string.  */
end_comment

begin_function
name|struct
name|cmd_list_element
modifier|*
name|add_set_enum_cmd
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|enum
name|command_class
name|class
parameter_list|,
specifier|const
name|char
modifier|*
name|enumlist
index|[]
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|var
parameter_list|,
name|char
modifier|*
name|doc
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
modifier|*
name|list
parameter_list|)
block|{
name|struct
name|cmd_list_element
modifier|*
name|c
init|=
name|add_set_cmd
argument_list|(
name|name
argument_list|,
name|class
argument_list|,
name|var_enum
argument_list|,
name|var
argument_list|,
name|doc
argument_list|,
name|list
argument_list|)
decl_stmt|;
name|c
operator|->
name|enums
operator|=
name|enumlist
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_comment
comment|/* Add an auto-boolean command named NAME to both the set and show    command list lists.  CLASS is as in add_cmd.  VAR is address of the    variable which will contain the value.  DOC is the documentation    string.  FUNC is the corresponding callback.  */
end_comment

begin_function
name|void
name|add_setshow_auto_boolean_cmd
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|enum
name|command_class
name|class
parameter_list|,
name|enum
name|auto_boolean
modifier|*
name|var
parameter_list|,
name|char
modifier|*
name|set_doc
parameter_list|,
name|char
modifier|*
name|show_doc
parameter_list|,
name|cmd_sfunc_ftype
modifier|*
name|set_func
parameter_list|,
name|cmd_sfunc_ftype
modifier|*
name|show_func
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
modifier|*
name|set_list
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
modifier|*
name|show_list
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|auto_boolean_enums
index|[]
init|=
block|{
literal|"on"
block|,
literal|"off"
block|,
literal|"auto"
block|,
name|NULL
block|}
decl_stmt|;
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
name|add_setshow_cmd_full
argument_list|(
name|name
argument_list|,
name|class
argument_list|,
name|var_auto_boolean
argument_list|,
name|var
argument_list|,
name|set_doc
argument_list|,
name|show_doc
argument_list|,
name|set_func
argument_list|,
name|show_func
argument_list|,
name|set_list
argument_list|,
name|show_list
argument_list|,
operator|&
name|c
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|c
operator|->
name|enums
operator|=
name|auto_boolean_enums
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add element named NAME to both the set and show command LISTs (the    list for set/show or some sublist thereof).  CLASS is as in    add_cmd.  VAR is address of the variable which will contain the    value.  SET_DOC and SHOW_DOR are the documentation strings.  */
end_comment

begin_function
name|void
name|add_setshow_boolean_cmd
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|enum
name|command_class
name|class
parameter_list|,
name|int
modifier|*
name|var
parameter_list|,
name|char
modifier|*
name|set_doc
parameter_list|,
name|char
modifier|*
name|show_doc
parameter_list|,
name|cmd_sfunc_ftype
modifier|*
name|set_func
parameter_list|,
name|cmd_sfunc_ftype
modifier|*
name|show_func
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
modifier|*
name|set_list
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
modifier|*
name|show_list
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|boolean_enums
index|[]
init|=
block|{
literal|"on"
block|,
literal|"off"
block|,
name|NULL
block|}
decl_stmt|;
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
name|add_setshow_cmd_full
argument_list|(
name|name
argument_list|,
name|class
argument_list|,
name|var_boolean
argument_list|,
name|var
argument_list|,
name|set_doc
argument_list|,
name|show_doc
argument_list|,
name|set_func
argument_list|,
name|show_func
argument_list|,
name|set_list
argument_list|,
name|show_list
argument_list|,
operator|&
name|c
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|c
operator|->
name|enums
operator|=
name|boolean_enums
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add element named NAME to both the set and show command LISTs (the    list for set/show or some sublist thereof).  CLASS is as in    add_cmd.  VAR is address of the variable which will contain the    value.  SET_DOC and SHOW_DOR are the documentation strings.  */
end_comment

begin_function
name|void
name|add_setshow_uinteger_cmd
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|enum
name|command_class
name|class
parameter_list|,
name|unsigned
name|int
modifier|*
name|var
parameter_list|,
name|char
modifier|*
name|set_doc
parameter_list|,
name|char
modifier|*
name|show_doc
parameter_list|,
name|cmd_sfunc_ftype
modifier|*
name|set_func
parameter_list|,
name|cmd_sfunc_ftype
modifier|*
name|show_func
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
modifier|*
name|set_list
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
modifier|*
name|show_list
parameter_list|)
block|{
name|add_setshow_cmd_full
argument_list|(
name|name
argument_list|,
name|class
argument_list|,
name|var_uinteger
argument_list|,
name|var
argument_list|,
name|set_doc
argument_list|,
name|show_doc
argument_list|,
name|set_func
argument_list|,
name|show_func
argument_list|,
name|set_list
argument_list|,
name|show_list
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Where SETCMD has already been added, add the corresponding show    command to LIST and return a pointer to the added command (not    necessarily the head of LIST).  */
end_comment

begin_comment
comment|/* NOTE: cagney/2002-03-17: The original version of add_show_from_set    used memcpy() to clone `set' into `show'.  This meant that in    addition to all the needed fields (var, name, et.al.) some    unnecessary fields were copied (namely the callback function).  The    function explictly copies relevant fields.  For a `set' and `show'    command to share the same callback, the caller must set both    explicitly.  */
end_comment

begin_function
name|struct
name|cmd_list_element
modifier|*
name|add_show_from_set
parameter_list|(
name|struct
name|cmd_list_element
modifier|*
name|setcmd
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
modifier|*
name|list
parameter_list|)
block|{
name|char
modifier|*
name|doc
decl_stmt|;
specifier|const
specifier|static
name|char
name|setstring
index|[]
init|=
literal|"Set "
decl_stmt|;
comment|/* Create a doc string by replacing "Set " at the start of the      `set'' command's doco with "Show ".  */
name|gdb_assert
argument_list|(
name|strncmp
argument_list|(
name|setcmd
operator|->
name|doc
argument_list|,
name|setstring
argument_list|,
sizeof|sizeof
argument_list|(
name|setstring
argument_list|)
operator|-
literal|1
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|doc
operator|=
name|concat
argument_list|(
literal|"Show "
argument_list|,
name|setcmd
operator|->
name|doc
operator|+
sizeof|sizeof
argument_list|(
name|setstring
argument_list|)
operator|-
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Insert the basic command.  */
return|return
name|add_set_or_show_cmd
argument_list|(
name|setcmd
operator|->
name|name
argument_list|,
name|show_cmd
argument_list|,
name|setcmd
operator|->
name|class
argument_list|,
name|setcmd
operator|->
name|var_type
argument_list|,
name|setcmd
operator|->
name|var
argument_list|,
name|doc
argument_list|,
name|list
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Remove the command named NAME from the command list.  */
end_comment

begin_function
name|void
name|delete_cmd
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
modifier|*
name|list
parameter_list|)
block|{
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
name|struct
name|cmd_list_element
modifier|*
name|p
decl_stmt|;
while|while
condition|(
operator|*
name|list
operator|&&
name|strcmp
argument_list|(
operator|(
operator|*
name|list
operator|)
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|list
operator|)
operator|->
name|hookee_pre
condition|)
operator|(
operator|*
name|list
operator|)
operator|->
name|hookee_pre
operator|->
name|hook_pre
operator|=
literal|0
expr_stmt|;
comment|/* Hook slips out of its mouth */
if|if
condition|(
operator|(
operator|*
name|list
operator|)
operator|->
name|hookee_post
condition|)
operator|(
operator|*
name|list
operator|)
operator|->
name|hookee_post
operator|->
name|hook_post
operator|=
literal|0
expr_stmt|;
comment|/* Hook slips out of its bottom  */
name|p
operator|=
operator|(
operator|*
name|list
operator|)
operator|->
name|next
expr_stmt|;
name|xfree
argument_list|(
operator|*
name|list
argument_list|)
expr_stmt|;
operator|*
name|list
operator|=
name|p
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|list
condition|)
for|for
control|(
name|c
operator|=
operator|*
name|list
init|;
name|c
operator|->
name|next
condition|;
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|c
operator|->
name|next
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|next
operator|->
name|hookee_pre
condition|)
name|c
operator|->
name|next
operator|->
name|hookee_pre
operator|->
name|hook_pre
operator|=
literal|0
expr_stmt|;
comment|/* hooked cmd gets away.  */
if|if
condition|(
name|c
operator|->
name|next
operator|->
name|hookee_post
condition|)
name|c
operator|->
name|next
operator|->
name|hookee_post
operator|->
name|hook_post
operator|=
literal|0
expr_stmt|;
comment|/* remove post hook */
comment|/* :( no fishing metaphore */
name|p
operator|=
name|c
operator|->
name|next
operator|->
name|next
expr_stmt|;
name|xfree
argument_list|(
name|c
operator|->
name|next
argument_list|)
expr_stmt|;
name|c
operator|->
name|next
operator|=
name|p
expr_stmt|;
block|}
else|else
name|c
operator|=
name|c
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Shorthands to the commands above. */
end_comment

begin_comment
comment|/* Add an element to the list of info subcommands.  */
end_comment

begin_function
name|struct
name|cmd_list_element
modifier|*
name|add_info
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|void
function_decl|(
modifier|*
name|fun
function_decl|)
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
parameter_list|,
name|char
modifier|*
name|doc
parameter_list|)
block|{
return|return
name|add_cmd
argument_list|(
name|name
argument_list|,
name|no_class
argument_list|,
name|fun
argument_list|,
name|doc
argument_list|,
operator|&
name|infolist
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Add an alias to the list of info subcommands.  */
end_comment

begin_function
name|struct
name|cmd_list_element
modifier|*
name|add_info_alias
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|oldname
parameter_list|,
name|int
name|abbrev_flag
parameter_list|)
block|{
return|return
name|add_alias_cmd
argument_list|(
name|name
argument_list|,
name|oldname
argument_list|,
literal|0
argument_list|,
name|abbrev_flag
argument_list|,
operator|&
name|infolist
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Add an element to the list of commands.  */
end_comment

begin_function
name|struct
name|cmd_list_element
modifier|*
name|add_com
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|enum
name|command_class
name|class
parameter_list|,
name|void
function_decl|(
modifier|*
name|fun
function_decl|)
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
parameter_list|,
name|char
modifier|*
name|doc
parameter_list|)
block|{
return|return
name|add_cmd
argument_list|(
name|name
argument_list|,
name|class
argument_list|,
name|fun
argument_list|,
name|doc
argument_list|,
operator|&
name|cmdlist
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Add an alias or abbreviation command to the list of commands.  */
end_comment

begin_function
name|struct
name|cmd_list_element
modifier|*
name|add_com_alias
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|oldname
parameter_list|,
name|enum
name|command_class
name|class
parameter_list|,
name|int
name|abbrev_flag
parameter_list|)
block|{
return|return
name|add_alias_cmd
argument_list|(
name|name
argument_list|,
name|oldname
argument_list|,
name|class
argument_list|,
name|abbrev_flag
argument_list|,
operator|&
name|cmdlist
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Recursively walk the commandlist structures, and print out the    documentation of commands that match our regex in either their    name, or their documentation. */
end_comment

begin_function
name|void
name|apropos_cmd
parameter_list|(
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
name|commandlist
parameter_list|,
name|struct
name|re_pattern_buffer
modifier|*
name|regex
parameter_list|,
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
name|int
name|returnvalue
init|=
literal|1
decl_stmt|;
comment|/*Needed to avoid double printing*/
comment|/* Walk through the commands */
for|for
control|(
name|c
operator|=
name|commandlist
init|;
name|c
condition|;
name|c
operator|=
name|c
operator|->
name|next
control|)
block|{
if|if
condition|(
name|c
operator|->
name|name
operator|!=
name|NULL
condition|)
block|{
comment|/* Try to match against the name*/
name|returnvalue
operator|=
name|re_search
argument_list|(
name|regex
argument_list|,
name|c
operator|->
name|name
argument_list|,
name|strlen
argument_list|(
name|c
operator|->
name|name
argument_list|)
argument_list|,
literal|0
argument_list|,
name|strlen
argument_list|(
name|c
operator|->
name|name
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|returnvalue
operator|>=
literal|0
condition|)
block|{
comment|/* Stolen from help_cmd_list. We don't directly use 	       * help_cmd_list because it doesn't let us print out 	       * single commands 	       */
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%s%s -- "
argument_list|,
name|prefix
argument_list|,
name|c
operator|->
name|name
argument_list|)
expr_stmt|;
name|print_doc_line
argument_list|(
name|stream
argument_list|,
name|c
operator|->
name|doc
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"\n"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|returnvalue
operator|=
literal|0
expr_stmt|;
comment|/*Set this so we don't print it again.*/
block|}
block|}
if|if
condition|(
name|c
operator|->
name|doc
operator|!=
name|NULL
operator|&&
name|returnvalue
operator|!=
literal|0
condition|)
block|{
comment|/* Try to match against documentation */
if|if
condition|(
name|re_search
argument_list|(
name|regex
argument_list|,
name|c
operator|->
name|doc
argument_list|,
name|strlen
argument_list|(
name|c
operator|->
name|doc
argument_list|)
argument_list|,
literal|0
argument_list|,
name|strlen
argument_list|(
name|c
operator|->
name|doc
argument_list|)
argument_list|,
name|NULL
argument_list|)
operator|>=
literal|0
condition|)
block|{
comment|/* Stolen from help_cmd_list. We don't directly use 	       * help_cmd_list because it doesn't let us print out 	       * single commands 	       */
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%s%s -- "
argument_list|,
name|prefix
argument_list|,
name|c
operator|->
name|name
argument_list|)
expr_stmt|;
name|print_doc_line
argument_list|(
name|stream
argument_list|,
name|c
operator|->
name|doc
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"\n"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Check if this command has subcommands */
if|if
condition|(
name|c
operator|->
name|prefixlist
operator|!=
name|NULL
condition|)
block|{
comment|/* Recursively call ourselves on the subcommand list, 	     passing the right prefix in. 	  */
name|apropos_cmd
argument_list|(
name|stream
argument_list|,
operator|*
name|c
operator|->
name|prefixlist
argument_list|,
name|regex
argument_list|,
name|c
operator|->
name|prefixname
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* This command really has to deal with two things:  *     1) I want documentation on *this string* (usually called by  * "help commandname").  *     2) I want documentation on *this list* (usually called by  * giving a command that requires subcommands.  Also called by saying  * just "help".)  *  *   I am going to split this into two seperate comamnds, help_cmd and  * help_list.   */
end_comment

begin_function
name|void
name|help_cmd
parameter_list|(
name|char
modifier|*
name|command
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|)
block|{
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
specifier|extern
name|struct
name|cmd_list_element
modifier|*
name|cmdlist
decl_stmt|;
if|if
condition|(
operator|!
name|command
condition|)
block|{
name|help_list
argument_list|(
name|cmdlist
argument_list|,
literal|""
argument_list|,
name|all_classes
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|command
argument_list|,
literal|"all"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|help_all
argument_list|(
name|stream
argument_list|)
expr_stmt|;
return|return;
block|}
name|c
operator|=
name|lookup_cmd
argument_list|(
operator|&
name|command
argument_list|,
name|cmdlist
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
return|return;
comment|/* There are three cases here.      If c->prefixlist is nonzero, we have a prefix command.      Print its documentation, then list its subcommands.       If c->func is non NULL, we really have a command.  Print its      documentation and return.       If c->func is NULL, we have a class name.  Print its      documentation (as if it were a command) and then set class to the      number of this class so that the commands in the class will be      listed.  */
name|fputs_filtered
argument_list|(
name|c
operator|->
name|doc
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"\n"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|prefixlist
operator|==
literal|0
operator|&&
name|c
operator|->
name|func
operator|!=
name|NULL
condition|)
return|return;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* If this is a prefix command, print it's subcommands */
if|if
condition|(
name|c
operator|->
name|prefixlist
condition|)
name|help_list
argument_list|(
operator|*
name|c
operator|->
name|prefixlist
argument_list|,
name|c
operator|->
name|prefixname
argument_list|,
name|all_commands
argument_list|,
name|stream
argument_list|)
expr_stmt|;
comment|/* If this is a class name, print all of the commands in the class */
if|if
condition|(
name|c
operator|->
name|func
operator|==
name|NULL
condition|)
name|help_list
argument_list|(
name|cmdlist
argument_list|,
literal|""
argument_list|,
name|c
operator|->
name|class
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|hook_pre
operator|||
name|c
operator|->
name|hook_post
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\nThis command has a hook (or hooks) defined:\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|hook_pre
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\tThis command is run after  : %s (pre hook)\n"
argument_list|,
name|c
operator|->
name|hook_pre
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|hook_post
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\tThis command is run before : %s (post hook)\n"
argument_list|,
name|c
operator|->
name|hook_post
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get a specific kind of help on a command list.  *  * LIST is the list.  * CMDTYPE is the prefix to use in the title string.  * CLASS is the class with which to list the nodes of this list (see  * documentation for help_cmd_list below),  As usual, ALL_COMMANDS for  * everything, ALL_CLASSES for just classes, and non-negative for only things  * in a specific class.  * and STREAM is the output stream on which to print things.  * If you call this routine with a class>= 0, it recurses.  */
end_comment

begin_function
name|void
name|help_list
parameter_list|(
name|struct
name|cmd_list_element
modifier|*
name|list
parameter_list|,
name|char
modifier|*
name|cmdtype
parameter_list|,
name|enum
name|command_class
name|class
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|cmdtype1
decl_stmt|,
modifier|*
name|cmdtype2
decl_stmt|;
comment|/* If CMDTYPE is "foo ", CMDTYPE1 gets " foo" and CMDTYPE2 gets "foo sub"  */
name|len
operator|=
name|strlen
argument_list|(
name|cmdtype
argument_list|)
expr_stmt|;
name|cmdtype1
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|cmdtype1
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|cmdtype2
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|len
operator|+
literal|4
argument_list|)
expr_stmt|;
name|cmdtype2
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|len
condition|)
block|{
name|cmdtype1
index|[
literal|0
index|]
operator|=
literal|' '
expr_stmt|;
name|strncpy
argument_list|(
name|cmdtype1
operator|+
literal|1
argument_list|,
name|cmdtype
argument_list|,
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|cmdtype1
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
name|strncpy
argument_list|(
name|cmdtype2
argument_list|,
name|cmdtype
argument_list|,
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|cmdtype2
operator|+
name|len
operator|-
literal|1
argument_list|,
literal|" sub"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|class
operator|==
name|all_classes
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"List of classes of %scommands:\n\n"
argument_list|,
name|cmdtype2
argument_list|)
expr_stmt|;
else|else
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"List of %scommands:\n\n"
argument_list|,
name|cmdtype2
argument_list|)
expr_stmt|;
name|help_cmd_list
argument_list|(
name|list
argument_list|,
name|class
argument_list|,
name|cmdtype
argument_list|,
operator|(
name|int
operator|)
name|class
operator|>=
literal|0
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|class
operator|==
name|all_classes
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\n\ Type \"help%s\" followed by a class name for a list of commands in "
argument_list|,
name|cmdtype1
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"that class."
argument_list|)
expr_stmt|;
block|}
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\nType \"help%s\" followed by %scommand name "
argument_list|,
name|cmdtype1
argument_list|,
name|cmdtype2
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"for "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"full "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"documentation.\n"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"Command name abbreviations are allowed if unambiguous.\n"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|help_all
parameter_list|(
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|)
block|{
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
specifier|extern
name|struct
name|cmd_list_element
modifier|*
name|cmdlist
decl_stmt|;
for|for
control|(
name|c
operator|=
name|cmdlist
init|;
name|c
condition|;
name|c
operator|=
name|c
operator|->
name|next
control|)
block|{
if|if
condition|(
name|c
operator|->
name|abbrev_flag
condition|)
continue|continue;
comment|/* If this is a prefix command, print it's subcommands */
if|if
condition|(
name|c
operator|->
name|prefixlist
condition|)
name|help_cmd_list
argument_list|(
operator|*
name|c
operator|->
name|prefixlist
argument_list|,
name|all_commands
argument_list|,
name|c
operator|->
name|prefixname
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|)
expr_stmt|;
comment|/* If this is a class name, print all of the commands in the class */
elseif|else
if|if
condition|(
name|c
operator|->
name|func
operator|==
name|NULL
condition|)
name|help_cmd_list
argument_list|(
name|cmdlist
argument_list|,
name|c
operator|->
name|class
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print only the first line of STR on STREAM.  */
end_comment

begin_function
name|void
name|print_doc_line
parameter_list|(
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|char
modifier|*
name|str
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|line_buffer
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|line_size
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|!
name|line_buffer
condition|)
block|{
name|line_size
operator|=
literal|80
expr_stmt|;
name|line_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|line_size
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|str
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|'\n'
operator|&&
operator|*
name|p
operator|!=
literal|'.'
operator|&&
operator|*
name|p
operator|!=
literal|','
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|p
operator|-
name|str
operator|>
name|line_size
operator|-
literal|1
condition|)
block|{
name|line_size
operator|=
name|p
operator|-
name|str
operator|+
literal|1
expr_stmt|;
name|xfree
argument_list|(
name|line_buffer
argument_list|)
expr_stmt|;
name|line_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|line_size
argument_list|)
expr_stmt|;
block|}
name|strncpy
argument_list|(
name|line_buffer
argument_list|,
name|str
argument_list|,
name|p
operator|-
name|str
argument_list|)
expr_stmt|;
name|line_buffer
index|[
name|p
operator|-
name|str
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|islower
argument_list|(
name|line_buffer
index|[
literal|0
index|]
argument_list|)
condition|)
name|line_buffer
index|[
literal|0
index|]
operator|=
name|toupper
argument_list|(
name|line_buffer
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
name|line_buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Implement a help command on command list LIST.  * RECURSE should be non-zero if this should be done recursively on  * all sublists of LIST.  * PREFIX is the prefix to print before each command name.  * STREAM is the stream upon which the output should be written.  * CLASS should be:  *      A non-negative class number to list only commands in that  * class.  *      ALL_COMMANDS to list all commands in list.  *      ALL_CLASSES  to list all classes in list.  *  *   Note that RECURSE will be active on *all* sublists, not just the  * ones selected by the criteria above (ie. the selection mechanism  * is at the low level, not the high-level).  */
end_comment

begin_function
name|void
name|help_cmd_list
parameter_list|(
name|struct
name|cmd_list_element
modifier|*
name|list
parameter_list|,
name|enum
name|command_class
name|class
parameter_list|,
name|char
modifier|*
name|prefix
parameter_list|,
name|int
name|recurse
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|)
block|{
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
name|list
init|;
name|c
condition|;
name|c
operator|=
name|c
operator|->
name|next
control|)
block|{
if|if
condition|(
name|c
operator|->
name|abbrev_flag
operator|==
literal|0
operator|&&
operator|(
name|class
operator|==
name|all_commands
operator|||
operator|(
name|class
operator|==
name|all_classes
operator|&&
name|c
operator|->
name|func
operator|==
name|NULL
operator|)
operator|||
operator|(
name|class
operator|==
name|c
operator|->
name|class
operator|&&
name|c
operator|->
name|func
operator|!=
name|NULL
operator|)
operator|)
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%s%s -- "
argument_list|,
name|prefix
argument_list|,
name|c
operator|->
name|name
argument_list|)
expr_stmt|;
name|print_doc_line
argument_list|(
name|stream
argument_list|,
name|c
operator|->
name|doc
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"\n"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|recurse
operator|&&
name|c
operator|->
name|prefixlist
operator|!=
literal|0
operator|&&
name|c
operator|->
name|abbrev_flag
operator|==
literal|0
condition|)
name|help_cmd_list
argument_list|(
operator|*
name|c
operator|->
name|prefixlist
argument_list|,
name|class
argument_list|,
name|c
operator|->
name|prefixname
argument_list|,
literal|1
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Search the input clist for 'command'.  Return the command if    found (or NULL if not), and return the number of commands    found in nfound */
end_comment

begin_function
specifier|static
name|struct
name|cmd_list_element
modifier|*
name|find_cmd
parameter_list|(
name|char
modifier|*
name|command
parameter_list|,
name|int
name|len
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
name|clist
parameter_list|,
name|int
name|ignore_help_classes
parameter_list|,
name|int
modifier|*
name|nfound
parameter_list|)
block|{
name|struct
name|cmd_list_element
modifier|*
name|found
decl_stmt|,
modifier|*
name|c
decl_stmt|;
name|found
operator|=
operator|(
expr|struct
name|cmd_list_element
operator|*
operator|)
name|NULL
expr_stmt|;
operator|*
name|nfound
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|c
operator|=
name|clist
init|;
name|c
condition|;
name|c
operator|=
name|c
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|command
argument_list|,
name|c
operator|->
name|name
argument_list|,
name|len
argument_list|)
operator|&&
operator|(
operator|!
name|ignore_help_classes
operator|||
name|c
operator|->
name|func
operator|)
condition|)
block|{
name|found
operator|=
name|c
expr_stmt|;
operator|(
operator|*
name|nfound
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|name
index|[
name|len
index|]
operator|==
literal|'\0'
condition|)
block|{
operator|*
name|nfound
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
return|return
name|found
return|;
block|}
end_function

begin_comment
comment|/* This routine takes a line of TEXT and a CLIST in which to start the    lookup.  When it returns it will have incremented the text pointer past    the section of text it matched, set *RESULT_LIST to point to the list in    which the last word was matched, and will return a pointer to the cmd    list element which the text matches.  It will return NULL if no match at    all was possible.  It will return -1 (cast appropriately, ick) if ambigous    matches are possible; in this case *RESULT_LIST will be set to point to    the list in which there are ambiguous choices (and *TEXT will be set to    the ambiguous text string).     If the located command was an abbreviation, this routine returns the base    command of the abbreviation.     It does no error reporting whatsoever; control will always return    to the superior routine.     In the case of an ambiguous return (-1), *RESULT_LIST will be set to point    at the prefix_command (ie. the best match) *or* (special case) will be NULL    if no prefix command was ever found.  For example, in the case of "info a",    "info" matches without ambiguity, but "a" could be "args" or "address", so    *RESULT_LIST is set to the cmd_list_element for "info".  So in this case    RESULT_LIST should not be interpeted as a pointer to the beginning of a    list; it simply points to a specific command.  In the case of an ambiguous    return *TEXT is advanced past the last non-ambiguous prefix (e.g.    "info t" can be "info types" or "info target"; upon return *TEXT has been    advanced past "info ").     If RESULT_LIST is NULL, don't set *RESULT_LIST (but don't otherwise    affect the operation).     This routine does *not* modify the text pointed to by TEXT.     If IGNORE_HELP_CLASSES is nonzero, ignore any command list elements which    are actually help classes rather than commands (i.e. the function field of    the struct cmd_list_element is NULL).  */
end_comment

begin_function
name|struct
name|cmd_list_element
modifier|*
name|lookup_cmd_1
parameter_list|(
name|char
modifier|*
modifier|*
name|text
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
name|clist
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
modifier|*
name|result_list
parameter_list|,
name|int
name|ignore_help_classes
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|command
decl_stmt|;
name|int
name|len
decl_stmt|,
name|tmp
decl_stmt|,
name|nfound
decl_stmt|;
name|struct
name|cmd_list_element
modifier|*
name|found
decl_stmt|,
modifier|*
name|c
decl_stmt|;
name|char
modifier|*
name|line
init|=
operator|*
name|text
decl_stmt|;
while|while
condition|(
operator|*
operator|*
name|text
operator|==
literal|' '
operator|||
operator|*
operator|*
name|text
operator|==
literal|'\t'
condition|)
operator|(
operator|*
name|text
operator|)
operator|++
expr_stmt|;
comment|/* Treating underscores as part of command words is important      so that "set args_foo()" doesn't get interpreted as      "set args _foo()".  */
comment|/* NOTE: cagney/2003-02-13 The `tui_active' was previously      `tui_version'.  */
for|for
control|(
name|p
operator|=
operator|*
name|text
init|;
operator|*
name|p
operator|&&
operator|(
name|isalnum
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|'-'
operator|||
operator|*
name|p
operator|==
literal|'_'
operator|||
if|#
directive|if
name|defined
argument_list|(
name|TUI
argument_list|)
operator|(
name|tui_active
operator|&&
operator|(
operator|*
name|p
operator|==
literal|'+'
operator|||
operator|*
name|p
operator|==
literal|'<'
operator|||
operator|*
name|p
operator|==
literal|'>'
operator|||
operator|*
name|p
operator|==
literal|'$'
operator|)
operator|)
operator|||
endif|#
directive|endif
operator|(
name|xdb_commands
operator|&&
operator|(
operator|*
name|p
operator|==
literal|'!'
operator|||
operator|*
name|p
operator|==
literal|'/'
operator|||
operator|*
name|p
operator|==
literal|'?'
operator|)
operator|)
operator|)
condition|;
name|p
operator|++
control|)
empty_stmt|;
comment|/* If nothing but whitespace, return 0.  */
if|if
condition|(
name|p
operator|==
operator|*
name|text
condition|)
return|return
literal|0
return|;
name|len
operator|=
name|p
operator|-
operator|*
name|text
expr_stmt|;
comment|/* *text and p now bracket the first command word to lookup (and      it's length is len).  We copy this into a local temporary */
name|command
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|tmp
operator|=
literal|0
init|;
name|tmp
operator|<
name|len
condition|;
name|tmp
operator|++
control|)
block|{
name|char
name|x
init|=
operator|(
operator|*
name|text
operator|)
index|[
name|tmp
index|]
decl_stmt|;
name|command
index|[
name|tmp
index|]
operator|=
name|x
expr_stmt|;
block|}
name|command
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Look it up.  */
name|found
operator|=
literal|0
expr_stmt|;
name|nfound
operator|=
literal|0
expr_stmt|;
name|found
operator|=
name|find_cmd
argument_list|(
name|command
argument_list|,
name|len
argument_list|,
name|clist
argument_list|,
name|ignore_help_classes
argument_list|,
operator|&
name|nfound
argument_list|)
expr_stmt|;
comment|/*       ** We didn't find the command in the entered case, so lower case it      ** and search again.    */
if|if
condition|(
operator|!
name|found
operator|||
name|nfound
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|tmp
operator|=
literal|0
init|;
name|tmp
operator|<
name|len
condition|;
name|tmp
operator|++
control|)
block|{
name|char
name|x
init|=
name|command
index|[
name|tmp
index|]
decl_stmt|;
name|command
index|[
name|tmp
index|]
operator|=
name|isupper
argument_list|(
name|x
argument_list|)
condition|?
name|tolower
argument_list|(
name|x
argument_list|)
else|:
name|x
expr_stmt|;
block|}
name|found
operator|=
name|find_cmd
argument_list|(
name|command
argument_list|,
name|len
argument_list|,
name|clist
argument_list|,
name|ignore_help_classes
argument_list|,
operator|&
name|nfound
argument_list|)
expr_stmt|;
block|}
comment|/* If nothing matches, we have a simple failure.  */
if|if
condition|(
name|nfound
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|nfound
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|result_list
operator|!=
name|NULL
condition|)
comment|/* Will be modified in calling routine 	   if we know what the prefix command is.  */
operator|*
name|result_list
operator|=
literal|0
expr_stmt|;
return|return
operator|(
expr|struct
name|cmd_list_element
operator|*
operator|)
operator|-
literal|1
return|;
comment|/* Ambiguous.  */
block|}
comment|/* We've matched something on this list.  Move text pointer forward. */
operator|*
name|text
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|found
operator|->
name|cmd_pointer
condition|)
block|{
comment|/* We drop the alias (abbreviation) in favor of the command it is        pointing to.  If the alias is deprecated, though, we need to        warn the user about it before we drop it.  Note that while we        are warning about the alias, we may also warn about the command        itself and we will adjust the appropriate DEPRECATED_WARN_USER        flags */
if|if
condition|(
name|found
operator|->
name|flags
operator|&
name|DEPRECATED_WARN_USER
condition|)
name|deprecated_cmd_warning
argument_list|(
operator|&
name|line
argument_list|)
expr_stmt|;
name|found
operator|=
name|found
operator|->
name|cmd_pointer
expr_stmt|;
block|}
comment|/* If we found a prefix command, keep looking.  */
if|if
condition|(
name|found
operator|->
name|prefixlist
condition|)
block|{
name|c
operator|=
name|lookup_cmd_1
argument_list|(
name|text
argument_list|,
operator|*
name|found
operator|->
name|prefixlist
argument_list|,
name|result_list
argument_list|,
name|ignore_help_classes
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|c
condition|)
block|{
comment|/* Didn't find anything; this is as far as we got.  */
if|if
condition|(
name|result_list
operator|!=
name|NULL
condition|)
operator|*
name|result_list
operator|=
name|clist
expr_stmt|;
return|return
name|found
return|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
operator|(
expr|struct
name|cmd_list_element
operator|*
operator|)
operator|-
literal|1
condition|)
block|{
comment|/* We've gotten this far properly, but the next step 	     is ambiguous.  We need to set the result list to the best 	     we've found (if an inferior hasn't already set it).  */
if|if
condition|(
name|result_list
operator|!=
name|NULL
condition|)
if|if
condition|(
operator|!
operator|*
name|result_list
condition|)
comment|/* This used to say *result_list = *found->prefixlist 	         If that was correct, need to modify the documentation 	         at the top of this function to clarify what is supposed 	         to be going on.  */
operator|*
name|result_list
operator|=
name|found
expr_stmt|;
return|return
name|c
return|;
block|}
else|else
block|{
comment|/* We matched!  */
return|return
name|c
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|result_list
operator|!=
name|NULL
condition|)
operator|*
name|result_list
operator|=
name|clist
expr_stmt|;
return|return
name|found
return|;
block|}
block|}
end_function

begin_comment
comment|/* All this hair to move the space to the front of cmdtype */
end_comment

begin_function
specifier|static
name|void
name|undef_cmd_error
parameter_list|(
name|char
modifier|*
name|cmdtype
parameter_list|,
name|char
modifier|*
name|q
parameter_list|)
block|{
name|error
argument_list|(
literal|"Undefined %scommand: \"%s\".  Try \"help%s%.*s\"."
argument_list|,
name|cmdtype
argument_list|,
name|q
argument_list|,
operator|*
name|cmdtype
condition|?
literal|" "
else|:
literal|""
argument_list|,
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|cmdtype
argument_list|)
operator|-
literal|1
argument_list|,
name|cmdtype
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Look up the contents of *LINE as a command in the command list LIST.    LIST is a chain of struct cmd_list_element's.    If it is found, return the struct cmd_list_element for that command    and update *LINE to point after the command name, at the first argument.    If not found, call error if ALLOW_UNKNOWN is zero    otherwise (or if error returns) return zero.    Call error if specified command is ambiguous,    unless ALLOW_UNKNOWN is negative.    CMDTYPE precedes the word "command" in the error message.     If INGNORE_HELP_CLASSES is nonzero, ignore any command list    elements which are actually help classes rather than commands (i.e.    the function field of the struct cmd_list_element is 0).  */
end_comment

begin_function
name|struct
name|cmd_list_element
modifier|*
name|lookup_cmd
parameter_list|(
name|char
modifier|*
modifier|*
name|line
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
name|list
parameter_list|,
name|char
modifier|*
name|cmdtype
parameter_list|,
name|int
name|allow_unknown
parameter_list|,
name|int
name|ignore_help_classes
parameter_list|)
block|{
name|struct
name|cmd_list_element
modifier|*
name|last_list
init|=
literal|0
decl_stmt|;
name|struct
name|cmd_list_element
modifier|*
name|c
init|=
name|lookup_cmd_1
argument_list|(
name|line
argument_list|,
name|list
argument_list|,
operator|&
name|last_list
argument_list|,
name|ignore_help_classes
argument_list|)
decl_stmt|;
comment|/* Note: Do not remove trailing whitespace here because this      would be wrong for complete_command.  Jim Kingdon  */
if|if
condition|(
operator|!
name|c
condition|)
block|{
if|if
condition|(
operator|!
name|allow_unknown
condition|)
block|{
if|if
condition|(
operator|!
operator|*
name|line
condition|)
name|error
argument_list|(
literal|"Lack of needed %scommand"
argument_list|,
name|cmdtype
argument_list|)
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|p
init|=
operator|*
name|line
decl_stmt|,
modifier|*
name|q
decl_stmt|;
while|while
condition|(
name|isalnum
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|'-'
condition|)
name|p
operator|++
expr_stmt|;
name|q
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|p
operator|-
operator|*
name|line
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|q
argument_list|,
operator|*
name|line
argument_list|,
name|p
operator|-
operator|*
name|line
argument_list|)
expr_stmt|;
name|q
index|[
name|p
operator|-
operator|*
name|line
index|]
operator|=
literal|'\0'
expr_stmt|;
name|undef_cmd_error
argument_list|(
name|cmdtype
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
block|}
else|else
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
operator|(
expr|struct
name|cmd_list_element
operator|*
operator|)
operator|-
literal|1
condition|)
block|{
comment|/* Ambigous.  Local values should be off prefixlist or called          values.  */
name|int
name|local_allow_unknown
init|=
operator|(
name|last_list
condition|?
name|last_list
operator|->
name|allow_unknown
else|:
name|allow_unknown
operator|)
decl_stmt|;
name|char
modifier|*
name|local_cmdtype
init|=
name|last_list
condition|?
name|last_list
operator|->
name|prefixname
else|:
name|cmdtype
decl_stmt|;
name|struct
name|cmd_list_element
modifier|*
name|local_list
init|=
operator|(
name|last_list
condition|?
operator|*
operator|(
name|last_list
operator|->
name|prefixlist
operator|)
else|:
name|list
operator|)
decl_stmt|;
if|if
condition|(
name|local_allow_unknown
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|last_list
condition|)
return|return
name|last_list
return|;
comment|/* Found something.  */
else|else
return|return
literal|0
return|;
comment|/* Found nothing.  */
block|}
else|else
block|{
comment|/* Report as error.  */
name|int
name|amb_len
decl_stmt|;
name|char
name|ambbuf
index|[
literal|100
index|]
decl_stmt|;
for|for
control|(
name|amb_len
operator|=
literal|0
init|;
operator|(
operator|(
operator|*
name|line
operator|)
index|[
name|amb_len
index|]
operator|&&
operator|(
operator|*
name|line
operator|)
index|[
name|amb_len
index|]
operator|!=
literal|' '
operator|&&
operator|(
operator|*
name|line
operator|)
index|[
name|amb_len
index|]
operator|!=
literal|'\t'
operator|)
condition|;
name|amb_len
operator|++
control|)
empty_stmt|;
name|ambbuf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|c
operator|=
name|local_list
init|;
name|c
condition|;
name|c
operator|=
name|c
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|strncmp
argument_list|(
operator|*
name|line
argument_list|,
name|c
operator|->
name|name
argument_list|,
name|amb_len
argument_list|)
condition|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|ambbuf
argument_list|)
operator|+
name|strlen
argument_list|(
name|c
operator|->
name|name
argument_list|)
operator|+
literal|6
operator|<
operator|(
name|int
operator|)
sizeof|sizeof
name|ambbuf
condition|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|ambbuf
argument_list|)
condition|)
name|strcat
argument_list|(
name|ambbuf
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|ambbuf
argument_list|,
name|c
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strcat
argument_list|(
name|ambbuf
argument_list|,
literal|".."
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|error
argument_list|(
literal|"Ambiguous %scommand \"%s\": %s."
argument_list|,
name|local_cmdtype
argument_list|,
operator|*
name|line
argument_list|,
name|ambbuf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* lint */
block|}
block|}
else|else
block|{
comment|/* We've got something.  It may still not be what the caller          wants (if this command *needs* a subcommand).  */
while|while
condition|(
operator|*
operator|*
name|line
operator|==
literal|' '
operator|||
operator|*
operator|*
name|line
operator|==
literal|'\t'
condition|)
operator|(
operator|*
name|line
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|prefixlist
operator|&&
operator|*
operator|*
name|line
operator|&&
operator|!
name|c
operator|->
name|allow_unknown
condition|)
name|undef_cmd_error
argument_list|(
name|c
operator|->
name|prefixname
argument_list|,
operator|*
name|line
argument_list|)
expr_stmt|;
comment|/* Seems to be what he wants.  Return it.  */
return|return
name|c
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* We are here presumably because an alias or command in *TEXT is     deprecated and a warning message should be generated.  This function    decodes *TEXT and potentially generates a warning message as outlined    below.        Example for 'set endian big' which has a fictitious alias 'seb'.        If alias wasn't used in *TEXT, and the command is deprecated:    "warning: 'set endian big' is deprecated."         If alias was used, and only the alias is deprecated:    "warning: 'seb' an alias for the command 'set endian big' is deprecated."        If alias was used and command is deprecated (regardless of whether the    alias itself is deprecated:        "warning: 'set endian big' (seb) is deprecated."     After the message has been sent, clear the appropriate flags in the    command and/or the alias so the user is no longer bothered.     */
end_comment

begin_function
name|void
name|deprecated_cmd_warning
parameter_list|(
name|char
modifier|*
modifier|*
name|text
parameter_list|)
block|{
name|struct
name|cmd_list_element
modifier|*
name|alias
init|=
name|NULL
decl_stmt|;
name|struct
name|cmd_list_element
modifier|*
name|prefix_cmd
init|=
name|NULL
decl_stmt|;
name|struct
name|cmd_list_element
modifier|*
name|cmd
init|=
name|NULL
decl_stmt|;
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
name|char
modifier|*
name|type
decl_stmt|;
if|if
condition|(
operator|!
name|lookup_cmd_composition
argument_list|(
operator|*
name|text
argument_list|,
operator|&
name|alias
argument_list|,
operator|&
name|prefix_cmd
argument_list|,
operator|&
name|cmd
argument_list|)
condition|)
comment|/* return if text doesn't evaluate to a command */
return|return;
if|if
condition|(
operator|!
operator|(
operator|(
name|alias
condition|?
operator|(
name|alias
operator|->
name|flags
operator|&
name|DEPRECATED_WARN_USER
operator|)
else|:
literal|0
operator|)
operator|||
operator|(
name|cmd
operator|->
name|flags
operator|&
name|DEPRECATED_WARN_USER
operator|)
operator|)
condition|)
comment|/* return if nothing is deprecated */
return|return;
name|printf_filtered
argument_list|(
literal|"Warning:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|alias
operator|&&
operator|!
operator|(
name|cmd
operator|->
name|flags
operator|&
name|CMD_DEPRECATED
operator|)
condition|)
name|printf_filtered
argument_list|(
literal|" '%s', an alias for the"
argument_list|,
name|alias
operator|->
name|name
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" command '"
argument_list|)
expr_stmt|;
if|if
condition|(
name|prefix_cmd
condition|)
name|printf_filtered
argument_list|(
literal|"%s"
argument_list|,
name|prefix_cmd
operator|->
name|prefixname
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%s"
argument_list|,
name|cmd
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|alias
operator|&&
operator|(
name|cmd
operator|->
name|flags
operator|&
name|CMD_DEPRECATED
operator|)
condition|)
name|printf_filtered
argument_list|(
literal|"' (%s) is deprecated.\n"
argument_list|,
name|alias
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|"' is deprecated.\n"
argument_list|)
expr_stmt|;
comment|/* if it is only the alias that is deprecated, we want to indicate the      new alias, otherwise we'll indicate the new command */
if|if
condition|(
name|alias
operator|&&
operator|!
operator|(
name|cmd
operator|->
name|flags
operator|&
name|CMD_DEPRECATED
operator|)
condition|)
block|{
if|if
condition|(
name|alias
operator|->
name|replacement
condition|)
name|printf_filtered
argument_list|(
literal|"Use '%s'.\n\n"
argument_list|,
name|alias
operator|->
name|replacement
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|"No alternative known.\n\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|cmd
operator|->
name|replacement
condition|)
name|printf_filtered
argument_list|(
literal|"Use '%s'.\n\n"
argument_list|,
name|cmd
operator|->
name|replacement
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|"No alternative known.\n\n"
argument_list|)
expr_stmt|;
block|}
comment|/* We've warned you, now we'll keep quiet */
if|if
condition|(
name|alias
condition|)
name|alias
operator|->
name|flags
operator|&=
operator|~
name|DEPRECATED_WARN_USER
expr_stmt|;
name|cmd
operator|->
name|flags
operator|&=
operator|~
name|DEPRECATED_WARN_USER
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Look up the contents of LINE as a command in the command list 'cmdlist'.     Return 1 on success, 0 on failure.        If LINE refers to an alias, *alias will point to that alias.        If LINE is a postfix command (i.e. one that is preceeded by a prefix    command) set *prefix_cmd.        Set *cmd to point to the command LINE indicates.        If any of *alias, *prefix_cmd, or *cmd cannot be determined or do not     exist, they are NULL when we return.     */
end_comment

begin_function
name|int
name|lookup_cmd_composition
parameter_list|(
name|char
modifier|*
name|text
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
modifier|*
name|alias
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
modifier|*
name|prefix_cmd
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
modifier|*
name|cmd
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|command
decl_stmt|;
name|int
name|len
decl_stmt|,
name|tmp
decl_stmt|,
name|nfound
decl_stmt|;
name|struct
name|cmd_list_element
modifier|*
name|cur_list
decl_stmt|;
name|struct
name|cmd_list_element
modifier|*
name|prev_cmd
decl_stmt|;
operator|*
name|alias
operator|=
name|NULL
expr_stmt|;
operator|*
name|prefix_cmd
operator|=
name|NULL
expr_stmt|;
operator|*
name|cmd
operator|=
name|NULL
expr_stmt|;
name|cur_list
operator|=
name|cmdlist
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Go through as many command lists as we need to         to find the command TEXT refers to. */
name|prev_cmd
operator|=
operator|*
name|cmd
expr_stmt|;
while|while
condition|(
operator|*
name|text
operator|==
literal|' '
operator|||
operator|*
name|text
operator|==
literal|'\t'
condition|)
operator|(
name|text
operator|)
operator|++
expr_stmt|;
comment|/* Treating underscores as part of command words is important        so that "set args_foo()" doesn't get interpreted as        "set args _foo()".  */
comment|/* NOTE: cagney/2003-02-13 The `tui_active' was previously 	 `tui_version'.  */
for|for
control|(
name|p
operator|=
name|text
init|;
operator|*
name|p
operator|&&
operator|(
name|isalnum
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|'-'
operator|||
operator|*
name|p
operator|==
literal|'_'
operator|||
if|#
directive|if
name|defined
argument_list|(
name|TUI
argument_list|)
operator|(
name|tui_active
operator|&&
operator|(
operator|*
name|p
operator|==
literal|'+'
operator|||
operator|*
name|p
operator|==
literal|'<'
operator|||
operator|*
name|p
operator|==
literal|'>'
operator|||
operator|*
name|p
operator|==
literal|'$'
operator|)
operator|)
operator|||
endif|#
directive|endif
operator|(
name|xdb_commands
operator|&&
operator|(
operator|*
name|p
operator|==
literal|'!'
operator|||
operator|*
name|p
operator|==
literal|'/'
operator|||
operator|*
name|p
operator|==
literal|'?'
operator|)
operator|)
operator|)
condition|;
name|p
operator|++
control|)
empty_stmt|;
comment|/* If nothing but whitespace, return.  */
if|if
condition|(
name|p
operator|==
name|text
condition|)
return|return
literal|0
return|;
name|len
operator|=
name|p
operator|-
name|text
expr_stmt|;
comment|/* text and p now bracket the first command word to lookup (and        it's length is len).  We copy this into a local temporary */
name|command
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|tmp
operator|=
literal|0
init|;
name|tmp
operator|<
name|len
condition|;
name|tmp
operator|++
control|)
block|{
name|char
name|x
init|=
name|text
index|[
name|tmp
index|]
decl_stmt|;
name|command
index|[
name|tmp
index|]
operator|=
name|x
expr_stmt|;
block|}
name|command
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Look it up.  */
operator|*
name|cmd
operator|=
literal|0
expr_stmt|;
name|nfound
operator|=
literal|0
expr_stmt|;
operator|*
name|cmd
operator|=
name|find_cmd
argument_list|(
name|command
argument_list|,
name|len
argument_list|,
name|cur_list
argument_list|,
literal|1
argument_list|,
operator|&
name|nfound
argument_list|)
expr_stmt|;
comment|/* We didn't find the command in the entered case, so lower case it        and search again.       */
if|if
condition|(
operator|!
operator|*
name|cmd
operator|||
name|nfound
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|tmp
operator|=
literal|0
init|;
name|tmp
operator|<
name|len
condition|;
name|tmp
operator|++
control|)
block|{
name|char
name|x
init|=
name|command
index|[
name|tmp
index|]
decl_stmt|;
name|command
index|[
name|tmp
index|]
operator|=
name|isupper
argument_list|(
name|x
argument_list|)
condition|?
name|tolower
argument_list|(
name|x
argument_list|)
else|:
name|x
expr_stmt|;
block|}
operator|*
name|cmd
operator|=
name|find_cmd
argument_list|(
name|command
argument_list|,
name|len
argument_list|,
name|cur_list
argument_list|,
literal|1
argument_list|,
operator|&
name|nfound
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|cmd
operator|==
operator|(
expr|struct
name|cmd_list_element
operator|*
operator|)
operator|-
literal|1
condition|)
block|{
return|return
literal|0
return|;
comment|/* ambiguous */
block|}
if|if
condition|(
operator|*
name|cmd
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* nothing found */
else|else
block|{
if|if
condition|(
operator|(
operator|*
name|cmd
operator|)
operator|->
name|cmd_pointer
condition|)
block|{
comment|/* cmd was actually an alias, we note that an alias was used                 (by assigning *alais) and we set *cmd.               */
operator|*
name|alias
operator|=
operator|*
name|cmd
expr_stmt|;
operator|*
name|cmd
operator|=
operator|(
operator|*
name|cmd
operator|)
operator|->
name|cmd_pointer
expr_stmt|;
block|}
operator|*
name|prefix_cmd
operator|=
name|prev_cmd
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|*
name|cmd
operator|)
operator|->
name|prefixlist
condition|)
name|cur_list
operator|=
operator|*
operator|(
operator|*
name|cmd
operator|)
operator|->
name|prefixlist
expr_stmt|;
else|else
return|return
literal|1
return|;
name|text
operator|=
name|p
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Helper function for SYMBOL_COMPLETION_FUNCTION.  */
end_comment

begin_comment
comment|/* Return a vector of char pointers which point to the different    possible completions in LIST of TEXT.       WORD points in the same buffer as TEXT, and completions should be    returned relative to this position.  For example, suppose TEXT is "foo"    and we want to complete to "foobar".  If WORD is "oo", return    "oobar"; if WORD is "baz/foo", return "baz/foobar".  */
end_comment

begin_function
name|char
modifier|*
modifier|*
name|complete_on_cmdlist
parameter_list|(
name|struct
name|cmd_list_element
modifier|*
name|list
parameter_list|,
name|char
modifier|*
name|text
parameter_list|,
name|char
modifier|*
name|word
parameter_list|)
block|{
name|struct
name|cmd_list_element
modifier|*
name|ptr
decl_stmt|;
name|char
modifier|*
modifier|*
name|matchlist
decl_stmt|;
name|int
name|sizeof_matchlist
decl_stmt|;
name|int
name|matches
decl_stmt|;
name|int
name|textlen
init|=
name|strlen
argument_list|(
name|text
argument_list|)
decl_stmt|;
name|sizeof_matchlist
operator|=
literal|10
expr_stmt|;
name|matchlist
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|sizeof_matchlist
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|matches
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ptr
operator|=
name|list
init|;
name|ptr
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|ptr
operator|->
name|name
argument_list|,
name|text
argument_list|,
name|textlen
argument_list|)
operator|&&
operator|!
name|ptr
operator|->
name|abbrev_flag
operator|&&
operator|(
name|ptr
operator|->
name|func
operator|||
name|ptr
operator|->
name|prefixlist
operator|)
condition|)
block|{
if|if
condition|(
name|matches
operator|==
name|sizeof_matchlist
condition|)
block|{
name|sizeof_matchlist
operator|*=
literal|2
expr_stmt|;
name|matchlist
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|matchlist
argument_list|,
operator|(
name|sizeof_matchlist
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
name|matchlist
index|[
name|matches
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|word
argument_list|)
operator|+
name|strlen
argument_list|(
name|ptr
operator|->
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|word
operator|==
name|text
condition|)
name|strcpy
argument_list|(
name|matchlist
index|[
name|matches
index|]
argument_list|,
name|ptr
operator|->
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|word
operator|>
name|text
condition|)
block|{
comment|/* Return some portion of ptr->name.  */
name|strcpy
argument_list|(
name|matchlist
index|[
name|matches
index|]
argument_list|,
name|ptr
operator|->
name|name
operator|+
operator|(
name|word
operator|-
name|text
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Return some of text plus ptr->name.  */
name|strncpy
argument_list|(
name|matchlist
index|[
name|matches
index|]
argument_list|,
name|word
argument_list|,
name|text
operator|-
name|word
argument_list|)
expr_stmt|;
name|matchlist
index|[
name|matches
index|]
index|[
name|text
operator|-
name|word
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strcat
argument_list|(
name|matchlist
index|[
name|matches
index|]
argument_list|,
name|ptr
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
operator|++
name|matches
expr_stmt|;
block|}
if|if
condition|(
name|matches
operator|==
literal|0
condition|)
block|{
name|xfree
argument_list|(
name|matchlist
argument_list|)
expr_stmt|;
name|matchlist
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|matchlist
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|matchlist
argument_list|,
operator|(
operator|(
name|matches
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|matchlist
index|[
name|matches
index|]
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
block|}
return|return
name|matchlist
return|;
block|}
end_function

begin_comment
comment|/* Helper function for SYMBOL_COMPLETION_FUNCTION.  */
end_comment

begin_comment
comment|/* Return a vector of char pointers which point to the different    possible completions in CMD of TEXT.       WORD points in the same buffer as TEXT, and completions should be    returned relative to this position.  For example, suppose TEXT is "foo"    and we want to complete to "foobar".  If WORD is "oo", return    "oobar"; if WORD is "baz/foo", return "baz/foobar".  */
end_comment

begin_function
name|char
modifier|*
modifier|*
name|complete_on_enum
parameter_list|(
specifier|const
name|char
modifier|*
name|enumlist
index|[]
parameter_list|,
name|char
modifier|*
name|text
parameter_list|,
name|char
modifier|*
name|word
parameter_list|)
block|{
name|char
modifier|*
modifier|*
name|matchlist
decl_stmt|;
name|int
name|sizeof_matchlist
decl_stmt|;
name|int
name|matches
decl_stmt|;
name|int
name|textlen
init|=
name|strlen
argument_list|(
name|text
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|sizeof_matchlist
operator|=
literal|10
expr_stmt|;
name|matchlist
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|sizeof_matchlist
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|matches
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|name
operator|=
name|enumlist
index|[
name|i
index|]
operator|)
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
name|text
argument_list|,
name|textlen
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|matches
operator|==
name|sizeof_matchlist
condition|)
block|{
name|sizeof_matchlist
operator|*=
literal|2
expr_stmt|;
name|matchlist
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|matchlist
argument_list|,
operator|(
name|sizeof_matchlist
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
name|matchlist
index|[
name|matches
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|word
argument_list|)
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|word
operator|==
name|text
condition|)
name|strcpy
argument_list|(
name|matchlist
index|[
name|matches
index|]
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|word
operator|>
name|text
condition|)
block|{
comment|/* Return some portion of name.  */
name|strcpy
argument_list|(
name|matchlist
index|[
name|matches
index|]
argument_list|,
name|name
operator|+
operator|(
name|word
operator|-
name|text
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Return some of text plus name.  */
name|strncpy
argument_list|(
name|matchlist
index|[
name|matches
index|]
argument_list|,
name|word
argument_list|,
name|text
operator|-
name|word
argument_list|)
expr_stmt|;
name|matchlist
index|[
name|matches
index|]
index|[
name|text
operator|-
name|word
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strcat
argument_list|(
name|matchlist
index|[
name|matches
index|]
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
operator|++
name|matches
expr_stmt|;
block|}
if|if
condition|(
name|matches
operator|==
literal|0
condition|)
block|{
name|xfree
argument_list|(
name|matchlist
argument_list|)
expr_stmt|;
name|matchlist
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|matchlist
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|matchlist
argument_list|,
operator|(
operator|(
name|matches
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|matchlist
index|[
name|matches
index|]
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
block|}
return|return
name|matchlist
return|;
block|}
end_function

begin_comment
comment|/* check function pointer */
end_comment

begin_function
name|int
name|cmd_func_p
parameter_list|(
name|struct
name|cmd_list_element
modifier|*
name|cmd
parameter_list|)
block|{
return|return
operator|(
name|cmd
operator|->
name|func
operator|!=
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* call the command function */
end_comment

begin_function
name|void
name|cmd_func
parameter_list|(
name|struct
name|cmd_list_element
modifier|*
name|cmd
parameter_list|,
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
if|if
condition|(
name|cmd_func_p
argument_list|(
name|cmd
argument_list|)
condition|)
call|(
modifier|*
name|cmd
operator|->
name|func
call|)
argument_list|(
name|cmd
argument_list|,
name|args
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"Invalid command"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

