begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Symbol table lookup for the GNU debugger, GDB.    Copyright 1986, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 1998              Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"call-cmds.h"
end_include

begin_include
include|#
directive|include
file|"gnu-regex.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"gdb_stat.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_comment
comment|/* Prototype for one function in parser-defs.h,    instead of including that entire file. */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|find_template_name_end
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Prototypes for local functions */
end_comment

begin_decl_stmt
specifier|static
name|int
name|find_methods
name|PARAMS
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|,
name|char
operator|*
operator|,
expr|struct
name|symbol
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|completion_list_add_name
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|build_canonical_line_spec
name|PARAMS
argument_list|(
operator|(
expr|struct
name|symtab_and_line
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|symtabs_and_lines
name|decode_line_2
name|PARAMS
argument_list|(
operator|(
expr|struct
name|symbol
operator|*
index|[]
operator|,
name|int
operator|,
name|int
operator|,
name|char
operator|*
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|rbreak_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|types_info
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|functions_info
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|variables_info
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sources_info
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_source_filename
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|operator_chars
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|find_line_common
name|PARAMS
argument_list|(
operator|(
expr|struct
name|linetable
operator|*
operator|,
name|int
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|partial_symbol
modifier|*
name|lookup_partial_symbol
name|PARAMS
argument_list|(
operator|(
expr|struct
name|partial_symtab
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|,
name|namespace_enum
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|partial_symbol
modifier|*
name|fixup_psymbol_section
name|PARAMS
argument_list|(
operator|(
expr|struct
name|partial_symbol
operator|*
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|symtab
modifier|*
name|lookup_symtab_1
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cplusplus_hint
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|symbol
modifier|*
name|find_active_alias
name|PARAMS
argument_list|(
operator|(
expr|struct
name|symbol
operator|*
name|sym
operator|,
name|CORE_ADDR
name|addr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This flag is used in hppa-tdep.c, and set in hp-symtab-read.c */
end_comment

begin_comment
comment|/* Signals the presence of objects compiled by HP compilers */
end_comment

begin_decl_stmt
name|int
name|hp_som_som_object_present
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fixup_section
name|PARAMS
argument_list|(
operator|(
expr|struct
name|general_symbol_info
operator|*
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|file_matches
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_symbol_info
name|PARAMS
argument_list|(
operator|(
name|namespace_enum
operator|,
expr|struct
name|symtab
operator|*
operator|,
expr|struct
name|symbol
operator|*
operator|,
name|int
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_msymbol_info
name|PARAMS
argument_list|(
operator|(
expr|struct
name|minimal_symbol
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|symtab_symbol_info
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|namespace_enum
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|_initialize_symtab
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* */
end_comment

begin_comment
comment|/* The single non-language-specific builtin type */
end_comment

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_error
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Block in which the most recently searched-for symbol was found.    Might be better to make this a parameter to lookup_symbol and     value_of_this. */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|block
modifier|*
name|block_found
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|no_symtab_msg
index|[]
init|=
literal|"No symbol table is loaded.  Use the \"file\" command."
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* While the C++ support is still in flux, issue a possibly helpful hint on    using the new command completion feature on single quoted demangled C++    symbols.  Remove when loose ends are cleaned up.   FIXME -fnf */
end_comment

begin_function
specifier|static
name|void
name|cplusplus_hint
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
while|while
condition|(
operator|*
name|name
operator|==
literal|'\''
condition|)
name|name
operator|++
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Hint: try '%s<TAB> or '%s<ESC-?>\n"
argument_list|,
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"(Note leading single quote.)\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check for a symtab of a specific name; first in symtabs, then in    psymtabs.  *If* there is no '/' in the name, a match after a '/'    in the symtab filename will also work.  */
end_comment

begin_function
specifier|static
name|struct
name|symtab
modifier|*
name|lookup_symtab_1
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
specifier|register
name|struct
name|partial_symtab
modifier|*
name|ps
decl_stmt|;
specifier|register
name|char
modifier|*
name|slash
decl_stmt|;
specifier|register
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|got_symtab
label|:
comment|/* First, search for an exact match */
name|ALL_SYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
if|if
condition|(
name|STREQ
argument_list|(
name|name
argument_list|,
name|s
operator|->
name|filename
argument_list|)
condition|)
return|return
name|s
return|;
name|slash
operator|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
comment|/* Now, search for a matching tail (only if name doesn't have any dirs) */
if|if
condition|(
operator|!
name|slash
condition|)
name|ALL_SYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
block|{
name|char
modifier|*
name|p
init|=
name|s
operator|->
name|filename
decl_stmt|;
name|char
modifier|*
name|tail
init|=
name|strrchr
argument_list|(
name|p
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
if|if
condition|(
name|tail
condition|)
name|p
operator|=
name|tail
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|STREQ
argument_list|(
name|p
argument_list|,
name|name
argument_list|)
condition|)
return|return
name|s
return|;
block|}
comment|/* Same search rules as above apply here, but now we look thru the      psymtabs.  */
name|ps
operator|=
name|lookup_partial_symtab
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ps
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|ps
operator|->
name|readin
condition|)
name|error
argument_list|(
literal|"Internal: readin %s pst for `%s' found when no symtab found."
argument_list|,
name|ps
operator|->
name|filename
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|s
operator|=
name|PSYMTAB_TO_SYMTAB
argument_list|(
name|ps
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
condition|)
return|return
name|s
return|;
comment|/* At this point, we have located the psymtab for this file, but      the conversion to a symtab has failed.  This usually happens      when we are looking up an include file.  In this case,      PSYMTAB_TO_SYMTAB doesn't return a symtab, even though one has      been created.  So, we need to run through the symtabs again in      order to find the file.      XXX - This is a crock, and should be fixed inside of the the      symbol parsing routines. */
goto|goto
name|got_symtab
goto|;
block|}
end_function

begin_comment
comment|/* Lookup the symbol table of a source file named NAME.  Try a couple    of variations if the first lookup doesn't work.  */
end_comment

begin_function
name|struct
name|symtab
modifier|*
name|lookup_symtab
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
if|#
directive|if
literal|0
block|register char *copy;
endif|#
directive|endif
name|s
operator|=
name|lookup_symtab_1
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
condition|)
return|return
name|s
return|;
if|#
directive|if
literal|0
comment|/* This screws c-exp.y:yylex if there is both a type "tree" and a symtab      "tree.c".  */
comment|/* If name not found as specified, see if adding ".c" helps.  */
comment|/* Why is this?  Is it just a user convenience?  (If so, it's pretty      questionable in the presence of C++, FORTRAN, etc.).  It's not in      the GDB manual.  */
block|copy = (char *) alloca (strlen (name) + 3);   strcpy (copy, name);   strcat (copy, ".c");   s = lookup_symtab_1 (copy);   if (s) return s;
endif|#
directive|endif
comment|/* 0 */
comment|/* We didn't find anything; die.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Lookup the partial symbol table of a source file named NAME.    *If* there is no '/' in the name, a match after a '/'    in the psymtab filename will also work.  */
end_comment

begin_function
name|struct
name|partial_symtab
modifier|*
name|lookup_partial_symtab
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
specifier|register
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|ALL_PSYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|pst
argument_list|)
block|{
if|if
condition|(
name|STREQ
argument_list|(
name|name
argument_list|,
name|pst
operator|->
name|filename
argument_list|)
condition|)
block|{
return|return
operator|(
name|pst
operator|)
return|;
block|}
block|}
comment|/* Now, search for a matching tail (only if name doesn't have any dirs) */
if|if
condition|(
operator|!
name|strchr
argument_list|(
name|name
argument_list|,
literal|'/'
argument_list|)
condition|)
name|ALL_PSYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|pst
argument_list|)
block|{
name|char
modifier|*
name|p
init|=
name|pst
operator|->
name|filename
decl_stmt|;
name|char
modifier|*
name|tail
init|=
name|strrchr
argument_list|(
name|p
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
if|if
condition|(
name|tail
condition|)
name|p
operator|=
name|tail
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|STREQ
argument_list|(
name|p
argument_list|,
name|name
argument_list|)
condition|)
return|return
operator|(
name|pst
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Mangle a GDB method stub type.  This actually reassembles the pieces of the    full method name, which consist of the class name (from T), the unadorned    method name from METHOD_ID, and the signature for the specific overload,    specified by SIGNATURE_ID.  Note that this function is g++ specific. */
end_comment

begin_function
name|char
modifier|*
name|gdb_mangle_name
parameter_list|(
name|type
parameter_list|,
name|method_id
parameter_list|,
name|signature_id
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|int
name|method_id
decl_stmt|,
name|signature_id
decl_stmt|;
block|{
name|int
name|mangled_name_len
decl_stmt|;
name|char
modifier|*
name|mangled_name
decl_stmt|;
name|struct
name|fn_field
modifier|*
name|f
init|=
name|TYPE_FN_FIELDLIST1
argument_list|(
name|type
argument_list|,
name|method_id
argument_list|)
decl_stmt|;
name|struct
name|fn_field
modifier|*
name|method
init|=
operator|&
name|f
index|[
name|signature_id
index|]
decl_stmt|;
name|char
modifier|*
name|field_name
init|=
name|TYPE_FN_FIELDLIST_NAME
argument_list|(
name|type
argument_list|,
name|method_id
argument_list|)
decl_stmt|;
name|char
modifier|*
name|physname
init|=
name|TYPE_FN_FIELD_PHYSNAME
argument_list|(
name|f
argument_list|,
name|signature_id
argument_list|)
decl_stmt|;
name|char
modifier|*
name|newname
init|=
name|type_name_no_tag
argument_list|(
name|type
argument_list|)
decl_stmt|;
comment|/* Does the form of physname indicate that it is the full mangled name      of a constructor (not just the args)?  */
name|int
name|is_full_physname_constructor
decl_stmt|;
name|int
name|is_constructor
decl_stmt|;
name|int
name|is_destructor
init|=
name|DESTRUCTOR_PREFIX_P
argument_list|(
name|physname
argument_list|)
decl_stmt|;
comment|/* Need a new type prefix.  */
name|char
modifier|*
name|const_prefix
init|=
name|method
operator|->
name|is_const
condition|?
literal|"C"
else|:
literal|""
decl_stmt|;
name|char
modifier|*
name|volatile_prefix
init|=
name|method
operator|->
name|is_volatile
condition|?
literal|"V"
else|:
literal|""
decl_stmt|;
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
name|int
name|len
init|=
operator|(
name|newname
operator|==
name|NULL
condition|?
literal|0
else|:
name|strlen
argument_list|(
name|newname
argument_list|)
operator|)
decl_stmt|;
name|is_full_physname_constructor
operator|=
operator|(
operator|(
name|physname
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|physname
index|[
literal|1
index|]
operator|==
literal|'_'
operator|&&
operator|(
name|isdigit
argument_list|(
name|physname
index|[
literal|2
index|]
argument_list|)
operator|||
name|physname
index|[
literal|2
index|]
operator|==
literal|'Q'
operator|||
name|physname
index|[
literal|2
index|]
operator|==
literal|'t'
operator|)
operator|)
operator|||
operator|(
name|strncmp
argument_list|(
name|physname
argument_list|,
literal|"__ct"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
operator|)
operator|)
expr_stmt|;
name|is_constructor
operator|=
name|is_full_physname_constructor
operator|||
operator|(
name|newname
operator|&&
name|STREQ
argument_list|(
name|field_name
argument_list|,
name|newname
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_destructor
condition|)
name|is_destructor
operator|=
operator|(
name|strncmp
argument_list|(
name|physname
argument_list|,
literal|"__dt"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|is_destructor
operator|||
name|is_full_physname_constructor
condition|)
block|{
name|mangled_name
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|physname
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|mangled_name
argument_list|,
name|physname
argument_list|)
expr_stmt|;
return|return
name|mangled_name
return|;
block|}
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"__%s%s"
argument_list|,
name|const_prefix
argument_list|,
name|volatile_prefix
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|physname
index|[
literal|0
index|]
operator|==
literal|'t'
operator|||
name|physname
index|[
literal|0
index|]
operator|==
literal|'Q'
condition|)
block|{
comment|/* The physname for template and qualified methods already includes 	 the class name.  */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"__%s%s"
argument_list|,
name|const_prefix
argument_list|,
name|volatile_prefix
argument_list|)
expr_stmt|;
name|newname
operator|=
name|NULL
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"__%s%s%d"
argument_list|,
name|const_prefix
argument_list|,
name|volatile_prefix
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
name|mangled_name_len
operator|=
operator|(
operator|(
name|is_constructor
condition|?
literal|0
else|:
name|strlen
argument_list|(
name|field_name
argument_list|)
operator|)
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
operator|+
name|len
operator|+
name|strlen
argument_list|(
name|physname
argument_list|)
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* Only needed for GNU-mangled names.  ANSI-mangled names      work with the normal mechanisms.  */
if|if
condition|(
name|OPNAME_PREFIX_P
argument_list|(
name|field_name
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|opname
init|=
name|cplus_mangle_opname
argument_list|(
name|field_name
operator|+
literal|3
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|opname
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"No mangling for \"%s\""
argument_list|,
name|field_name
argument_list|)
expr_stmt|;
name|mangled_name_len
operator|+=
name|strlen
argument_list|(
name|opname
argument_list|)
expr_stmt|;
name|mangled_name
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|mangled_name_len
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|mangled_name
argument_list|,
name|field_name
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|mangled_name
index|[
literal|3
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strcat
argument_list|(
name|mangled_name
argument_list|,
name|opname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mangled_name
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|mangled_name_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_constructor
condition|)
name|mangled_name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|mangled_name
argument_list|,
name|field_name
argument_list|)
expr_stmt|;
block|}
name|strcat
argument_list|(
name|mangled_name
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* If the class doesn't have a name, i.e. newname NULL, then we just      mangle it using 0 for the length of the class.  Thus it gets mangled      as something starting with `::' rather than `classname::'. */
if|if
condition|(
name|newname
operator|!=
name|NULL
condition|)
name|strcat
argument_list|(
name|mangled_name
argument_list|,
name|newname
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|mangled_name
argument_list|,
name|physname
argument_list|)
expr_stmt|;
return|return
operator|(
name|mangled_name
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find which partial symtab on contains PC and SECTION.  Return 0 if none.  */
end_comment

begin_function
name|struct
name|partial_symtab
modifier|*
name|find_pc_sect_psymtab
parameter_list|(
name|pc
parameter_list|,
name|section
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
block|{
specifier|register
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
specifier|register
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|ALL_PSYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|pst
argument_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|HPUXHPPA
argument_list|)
if|if
condition|(
name|pc
operator|>=
name|pst
operator|->
name|textlow
operator|&&
name|pc
operator|<=
name|pst
operator|->
name|texthigh
condition|)
else|#
directive|else
if|if
condition|(
name|pc
operator|>=
name|pst
operator|->
name|textlow
operator|&&
name|pc
operator|<
name|pst
operator|->
name|texthigh
condition|)
endif|#
directive|endif
block|{
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
name|struct
name|partial_symtab
modifier|*
name|tpst
decl_stmt|;
comment|/* An objfile that has its functions reordered might have 	     many partial symbol tables containing the PC, but 	     we want the partial symbol table that contains the 	     function containing the PC.  */
if|if
condition|(
operator|!
operator|(
name|objfile
operator|->
name|flags
operator|&
name|OBJF_REORDERED
operator|)
operator|&&
name|section
operator|==
literal|0
condition|)
comment|/* can't validate section this way */
return|return
operator|(
name|pst
operator|)
return|;
name|msymbol
operator|=
name|lookup_minimal_symbol_by_pc_section
argument_list|(
name|pc
argument_list|,
name|section
argument_list|)
expr_stmt|;
if|if
condition|(
name|msymbol
operator|==
name|NULL
condition|)
return|return
operator|(
name|pst
operator|)
return|;
for|for
control|(
name|tpst
operator|=
name|pst
init|;
name|tpst
operator|!=
name|NULL
condition|;
name|tpst
operator|=
name|tpst
operator|->
name|next
control|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|HPUXHPPA
argument_list|)
if|if
condition|(
name|pc
operator|>=
name|tpst
operator|->
name|textlow
operator|&&
name|pc
operator|<=
name|tpst
operator|->
name|texthigh
condition|)
else|#
directive|else
if|if
condition|(
name|pc
operator|>=
name|tpst
operator|->
name|textlow
operator|&&
name|pc
operator|<
name|tpst
operator|->
name|texthigh
condition|)
endif|#
directive|endif
block|{
name|struct
name|partial_symbol
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|find_pc_sect_psymbol
argument_list|(
name|tpst
argument_list|,
name|pc
argument_list|,
name|section
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
operator|&&
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|p
argument_list|)
operator|==
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
condition|)
return|return
operator|(
name|tpst
operator|)
return|;
block|}
block|}
return|return
operator|(
name|pst
operator|)
return|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Find which partial symtab contains PC.  Return 0 if none.     Backward compatibility, no section */
end_comment

begin_function
name|struct
name|partial_symtab
modifier|*
name|find_pc_psymtab
parameter_list|(
name|pc
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
block|{
return|return
name|find_pc_sect_psymtab
argument_list|(
name|pc
argument_list|,
name|find_pc_mapped_section
argument_list|(
name|pc
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Find which partial symbol within a psymtab matches PC and SECTION.      Return 0 if none.  Check all psymtabs if PSYMTAB is 0.  */
end_comment

begin_function
name|struct
name|partial_symbol
modifier|*
name|find_pc_sect_psymbol
parameter_list|(
name|psymtab
parameter_list|,
name|pc
parameter_list|,
name|section
parameter_list|)
name|struct
name|partial_symtab
modifier|*
name|psymtab
decl_stmt|;
name|CORE_ADDR
name|pc
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
block|{
name|struct
name|partial_symbol
modifier|*
name|best
init|=
name|NULL
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
modifier|*
name|pp
decl_stmt|;
name|CORE_ADDR
name|best_pc
decl_stmt|;
if|if
condition|(
operator|!
name|psymtab
condition|)
name|psymtab
operator|=
name|find_pc_sect_psymtab
argument_list|(
name|pc
argument_list|,
name|section
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|psymtab
condition|)
return|return
literal|0
return|;
comment|/* Cope with programs that start at address 0 */
name|best_pc
operator|=
operator|(
name|psymtab
operator|->
name|textlow
operator|!=
literal|0
operator|)
condition|?
name|psymtab
operator|->
name|textlow
operator|-
literal|1
else|:
literal|0
expr_stmt|;
comment|/* Search the global symbols as well as the static symbols, so that      find_pc_partial_function doesn't use a minimal symbol and thus      cache a bad endaddr.  */
for|for
control|(
name|pp
operator|=
name|psymtab
operator|->
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
operator|+
name|psymtab
operator|->
name|globals_offset
init|;
operator|(
name|pp
operator|-
operator|(
name|psymtab
operator|->
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
operator|+
name|psymtab
operator|->
name|globals_offset
operator|)
operator|<
name|psymtab
operator|->
name|n_global_syms
operator|)
condition|;
name|pp
operator|++
control|)
block|{
name|p
operator|=
operator|*
name|pp
expr_stmt|;
if|if
condition|(
name|SYMBOL_NAMESPACE
argument_list|(
name|p
argument_list|)
operator|==
name|VAR_NAMESPACE
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|p
argument_list|)
operator|==
name|LOC_BLOCK
operator|&&
name|pc
operator|>=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|p
argument_list|)
operator|&&
operator|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|p
argument_list|)
operator|>
name|best_pc
operator|||
operator|(
name|psymtab
operator|->
name|textlow
operator|==
literal|0
operator|&&
name|best_pc
operator|==
literal|0
operator|&&
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|p
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|section
condition|)
comment|/* match on a specific section */
block|{
name|fixup_psymbol_section
argument_list|(
name|p
argument_list|,
name|psymtab
operator|->
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|SYMBOL_BFD_SECTION
argument_list|(
name|p
argument_list|)
operator|!=
name|section
condition|)
continue|continue;
block|}
name|best_pc
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|best
operator|=
name|p
expr_stmt|;
block|}
block|}
for|for
control|(
name|pp
operator|=
name|psymtab
operator|->
name|objfile
operator|->
name|static_psymbols
operator|.
name|list
operator|+
name|psymtab
operator|->
name|statics_offset
init|;
operator|(
name|pp
operator|-
operator|(
name|psymtab
operator|->
name|objfile
operator|->
name|static_psymbols
operator|.
name|list
operator|+
name|psymtab
operator|->
name|statics_offset
operator|)
operator|<
name|psymtab
operator|->
name|n_static_syms
operator|)
condition|;
name|pp
operator|++
control|)
block|{
name|p
operator|=
operator|*
name|pp
expr_stmt|;
if|if
condition|(
name|SYMBOL_NAMESPACE
argument_list|(
name|p
argument_list|)
operator|==
name|VAR_NAMESPACE
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|p
argument_list|)
operator|==
name|LOC_BLOCK
operator|&&
name|pc
operator|>=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|p
argument_list|)
operator|&&
operator|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|p
argument_list|)
operator|>
name|best_pc
operator|||
operator|(
name|psymtab
operator|->
name|textlow
operator|==
literal|0
operator|&&
name|best_pc
operator|==
literal|0
operator|&&
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|p
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|section
condition|)
comment|/* match on a specific section */
block|{
name|fixup_psymbol_section
argument_list|(
name|p
argument_list|,
name|psymtab
operator|->
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|SYMBOL_BFD_SECTION
argument_list|(
name|p
argument_list|)
operator|!=
name|section
condition|)
continue|continue;
block|}
name|best_pc
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|best
operator|=
name|p
expr_stmt|;
block|}
block|}
return|return
name|best
return|;
block|}
end_function

begin_comment
comment|/* Find which partial symbol within a psymtab matches PC.  Return 0 if none.      Check all psymtabs if PSYMTAB is 0.  Backwards compatibility, no section. */
end_comment

begin_function
name|struct
name|partial_symbol
modifier|*
name|find_pc_psymbol
parameter_list|(
name|psymtab
parameter_list|,
name|pc
parameter_list|)
name|struct
name|partial_symtab
modifier|*
name|psymtab
decl_stmt|;
name|CORE_ADDR
name|pc
decl_stmt|;
block|{
return|return
name|find_pc_sect_psymbol
argument_list|(
name|psymtab
argument_list|,
name|pc
argument_list|,
name|find_pc_mapped_section
argument_list|(
name|pc
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Debug symbols usually don't have section information.  We need to dig that    out of the minimal symbols and stash that in the debug symbol.  */
end_comment

begin_function
specifier|static
name|void
name|fixup_section
parameter_list|(
name|ginfo
parameter_list|,
name|objfile
parameter_list|)
name|struct
name|general_symbol_info
modifier|*
name|ginfo
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|struct
name|minimal_symbol
modifier|*
name|msym
decl_stmt|;
name|msym
operator|=
name|lookup_minimal_symbol
argument_list|(
name|ginfo
operator|->
name|name
argument_list|,
name|NULL
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|msym
condition|)
name|ginfo
operator|->
name|bfd_section
operator|=
name|SYMBOL_BFD_SECTION
argument_list|(
name|msym
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|symbol
modifier|*
name|fixup_symbol_section
parameter_list|(
name|sym
parameter_list|,
name|objfile
parameter_list|)
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|sym
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|SYMBOL_BFD_SECTION
argument_list|(
name|sym
argument_list|)
condition|)
return|return
name|sym
return|;
name|fixup_section
argument_list|(
operator|&
name|sym
operator|->
name|ginfo
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
return|return
name|sym
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|partial_symbol
modifier|*
name|fixup_psymbol_section
parameter_list|(
name|psym
parameter_list|,
name|objfile
parameter_list|)
name|struct
name|partial_symbol
modifier|*
name|psym
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|psym
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|SYMBOL_BFD_SECTION
argument_list|(
name|psym
argument_list|)
condition|)
return|return
name|psym
return|;
name|fixup_section
argument_list|(
operator|&
name|psym
operator|->
name|ginfo
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
return|return
name|psym
return|;
block|}
end_function

begin_comment
comment|/* Find the definition for a specified symbol name NAME    in namespace NAMESPACE, visible from lexical block BLOCK.    Returns the struct symbol pointer, or zero if no symbol is found.    If SYMTAB is non-NULL, store the symbol table in which the    symbol was found there, or NULL if not found.    C++: if IS_A_FIELD_OF_THIS is nonzero on entry, check to see if    NAME is a field of the current implied argument `this'.  If so set    *IS_A_FIELD_OF_THIS to 1, otherwise set it to zero.     BLOCK_FOUND is set to the block in which NAME is found (in the case of    a field of `this', value_of_this sets BLOCK_FOUND to the proper value.) */
end_comment

begin_comment
comment|/* This function has a bunch of loops in it and it would seem to be    attractive to put in some QUIT's (though I'm not really sure    whether it can run long enough to be really important).  But there    are a few calls for which it would appear to be bad news to quit    out of here: find_proc_desc in alpha-tdep.c and mips-tdep.c, and    nindy_frame_chain_valid in nindy-tdep.c.  (Note that there is C++    code below which can error(), but that probably doesn't affect    these calls since they are looking for a known variable and thus    can probably assume it will never hit the C++ code).  */
end_comment

begin_function
name|struct
name|symbol
modifier|*
name|lookup_symbol
parameter_list|(
name|name
parameter_list|,
name|block
parameter_list|,
name|namespace
parameter_list|,
name|is_a_field_of_this
parameter_list|,
name|symtab
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
specifier|const
name|struct
name|block
modifier|*
name|block
decl_stmt|;
specifier|const
name|namespace_enum
name|namespace
decl_stmt|;
name|int
modifier|*
name|is_a_field_of_this
decl_stmt|;
name|struct
name|symtab
modifier|*
modifier|*
name|symtab
decl_stmt|;
block|{
specifier|register
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
specifier|register
name|struct
name|symtab
modifier|*
name|s
init|=
name|NULL
decl_stmt|;
specifier|register
name|struct
name|partial_symtab
modifier|*
name|ps
decl_stmt|;
name|struct
name|blockvector
modifier|*
name|bv
decl_stmt|;
specifier|register
name|struct
name|objfile
modifier|*
name|objfile
init|=
name|NULL
decl_stmt|;
specifier|register
name|struct
name|block
modifier|*
name|b
decl_stmt|;
specifier|register
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
comment|/* Search specified block and its superiors.  */
while|while
condition|(
name|block
operator|!=
literal|0
condition|)
block|{
name|sym
operator|=
name|lookup_block_symbol
argument_list|(
name|block
argument_list|,
name|name
argument_list|,
name|namespace
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
condition|)
block|{
name|block_found
operator|=
name|block
expr_stmt|;
if|if
condition|(
name|symtab
operator|!=
name|NULL
condition|)
block|{
comment|/* Search the list of symtabs for one which contains the 		 address of the start of this block.  */
name|ALL_SYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
block|{
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|b
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|BLOCK_START
argument_list|(
name|b
argument_list|)
operator|<=
name|BLOCK_START
argument_list|(
name|block
argument_list|)
operator|&&
name|BLOCK_END
argument_list|(
name|b
argument_list|)
operator|>
name|BLOCK_START
argument_list|(
name|block
argument_list|)
condition|)
goto|goto
name|found
goto|;
block|}
name|found
label|:
operator|*
name|symtab
operator|=
name|s
expr_stmt|;
block|}
return|return
name|fixup_symbol_section
argument_list|(
name|sym
argument_list|,
name|objfile
argument_list|)
return|;
block|}
name|block
operator|=
name|BLOCK_SUPERBLOCK
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
comment|/* FIXME: this code is never executed--block is always NULL at this      point.  What is it trying to do, anyway?  We already should have      checked the STATIC_BLOCK above (it is the superblock of top-level      blocks).  Why is VAR_NAMESPACE special-cased?  */
comment|/* Don't need to mess with the psymtabs; if we have a block,      that file is read in.  If we don't, then we deal later with      all the psymtab stuff that needs checking.  */
comment|/* Note (RT): The following never-executed code looks unnecessary to me also.    * If we change the code to use the original (passed-in)    * value of 'block', we could cause it to execute, but then what    * would it do? The STATIC_BLOCK of the symtab containing the passed-in    * 'block' was already searched by the above code. And the STATIC_BLOCK's    * of *other* symtabs (those files not containing 'block' lexically)    * should not contain 'block' address-wise. So we wouldn't expect this    * code to find any 'sym''s that were not found above. I vote for     * deleting the following paragraph of code.    */
if|if
condition|(
name|namespace
operator|==
name|VAR_NAMESPACE
operator|&&
name|block
operator|!=
name|NULL
condition|)
block|{
name|struct
name|block
modifier|*
name|b
decl_stmt|;
comment|/* Find the right symtab.  */
name|ALL_SYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
block|{
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|b
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|STATIC_BLOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|BLOCK_START
argument_list|(
name|b
argument_list|)
operator|<=
name|BLOCK_START
argument_list|(
name|block
argument_list|)
operator|&&
name|BLOCK_END
argument_list|(
name|b
argument_list|)
operator|>
name|BLOCK_START
argument_list|(
name|block
argument_list|)
condition|)
block|{
name|sym
operator|=
name|lookup_block_symbol
argument_list|(
name|b
argument_list|,
name|name
argument_list|,
name|VAR_NAMESPACE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
condition|)
block|{
name|block_found
operator|=
name|b
expr_stmt|;
if|if
condition|(
name|symtab
operator|!=
name|NULL
condition|)
operator|*
name|symtab
operator|=
name|s
expr_stmt|;
return|return
name|fixup_symbol_section
argument_list|(
name|sym
argument_list|,
name|objfile
argument_list|)
return|;
block|}
block|}
block|}
block|}
comment|/* C++: If requested to do so by the caller,       check to see if NAME is a field of `this'. */
if|if
condition|(
name|is_a_field_of_this
condition|)
block|{
name|struct
name|value
modifier|*
name|v
init|=
name|value_of_this
argument_list|(
literal|0
argument_list|)
decl_stmt|;
operator|*
name|is_a_field_of_this
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|v
operator|&&
name|check_field
argument_list|(
name|v
argument_list|,
name|name
argument_list|)
condition|)
block|{
operator|*
name|is_a_field_of_this
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|symtab
operator|!=
name|NULL
condition|)
operator|*
name|symtab
operator|=
name|NULL
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
comment|/* Now search all global blocks.  Do the symtab's first, then      check the psymtab's. If a psymtab indicates the existence      of the desired name as a global, then do psymtab-to-symtab      conversion on the fly and return the found symbol. */
name|ALL_SYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
block|{
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|block
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
expr_stmt|;
name|sym
operator|=
name|lookup_block_symbol
argument_list|(
name|block
argument_list|,
name|name
argument_list|,
name|namespace
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
condition|)
block|{
name|block_found
operator|=
name|block
expr_stmt|;
if|if
condition|(
name|symtab
operator|!=
name|NULL
condition|)
operator|*
name|symtab
operator|=
name|s
expr_stmt|;
return|return
name|fixup_symbol_section
argument_list|(
name|sym
argument_list|,
name|objfile
argument_list|)
return|;
block|}
block|}
ifndef|#
directive|ifndef
name|HPUXHPPA
comment|/* Check for the possibility of the symbol being a function or      a mangled variable that is stored in one of the minimal symbol tables.      Eventually, all global symbols might be resolved in this way.  */
if|if
condition|(
name|namespace
operator|==
name|VAR_NAMESPACE
condition|)
block|{
name|msymbol
operator|=
name|lookup_minimal_symbol
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|msymbol
operator|!=
name|NULL
condition|)
block|{
name|s
operator|=
name|find_pc_sect_symtab
argument_list|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
argument_list|,
name|SYMBOL_BFD_SECTION
argument_list|(
name|msymbol
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
comment|/* This is a function which has a symtab for its address.  */
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|block
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
expr_stmt|;
name|sym
operator|=
name|lookup_block_symbol
argument_list|(
name|block
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|msymbol
argument_list|)
argument_list|,
name|namespace
argument_list|)
expr_stmt|;
comment|/* We kept static functions in minimal symbol table as well as 		 in static scope. We want to find them in the symbol table. */
if|if
condition|(
operator|!
name|sym
condition|)
block|{
name|block
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|STATIC_BLOCK
argument_list|)
expr_stmt|;
name|sym
operator|=
name|lookup_block_symbol
argument_list|(
name|block
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|msymbol
argument_list|)
argument_list|,
name|namespace
argument_list|)
expr_stmt|;
block|}
comment|/* sym == 0 if symbol was found in the minimal symbol table 		 but not in the symtab. 		 Return 0 to use the msymbol definition of "foo_".  		 This happens for Fortran  "foo_" symbols, 		 which are "foo" in the symtab.  		 This can also happen if "asm" is used to make a 		 regular symbol but not a debugging symbol, e.g. 		 asm(".globl _main"); 		 asm("_main:"); 		 */
if|if
condition|(
name|symtab
operator|!=
name|NULL
condition|)
operator|*
name|symtab
operator|=
name|s
expr_stmt|;
return|return
name|fixup_symbol_section
argument_list|(
name|sym
argument_list|,
name|objfile
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|MSYMBOL_TYPE
argument_list|(
name|msymbol
argument_list|)
operator|!=
name|mst_text
operator|&&
name|MSYMBOL_TYPE
argument_list|(
name|msymbol
argument_list|)
operator|!=
name|mst_file_text
operator|&&
operator|!
name|STREQ
argument_list|(
name|name
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|msymbol
argument_list|)
argument_list|)
condition|)
block|{
comment|/* This is a mangled variable, look it up by its 		 mangled name.  */
return|return
name|lookup_symbol
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|msymbol
argument_list|)
argument_list|,
name|block
argument_list|,
name|namespace
argument_list|,
name|is_a_field_of_this
argument_list|,
name|symtab
argument_list|)
return|;
block|}
comment|/* There are no debug symbols for this file, or we are looking 	     for an unmangled variable. 	     Try to find a matching static symbol below. */
block|}
block|}
endif|#
directive|endif
name|ALL_PSYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|ps
argument_list|)
block|{
if|if
condition|(
operator|!
name|ps
operator|->
name|readin
operator|&&
name|lookup_partial_symbol
argument_list|(
name|ps
argument_list|,
name|name
argument_list|,
literal|1
argument_list|,
name|namespace
argument_list|)
condition|)
block|{
name|s
operator|=
name|PSYMTAB_TO_SYMTAB
argument_list|(
name|ps
argument_list|)
expr_stmt|;
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|block
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
expr_stmt|;
name|sym
operator|=
name|lookup_block_symbol
argument_list|(
name|block
argument_list|,
name|name
argument_list|,
name|namespace
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sym
condition|)
block|{
comment|/* This shouldn't be necessary, but as a last resort                * try looking in the statics even though the psymtab                * claimed the symbol was global. It's possible that                * the psymtab gets it wrong in some cases.                */
name|block
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|STATIC_BLOCK
argument_list|)
expr_stmt|;
name|sym
operator|=
name|lookup_block_symbol
argument_list|(
name|block
argument_list|,
name|name
argument_list|,
name|namespace
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sym
condition|)
name|error
argument_list|(
literal|"Internal: global symbol `%s' found in %s psymtab but not in symtab.\n\ %s may be an inlined function, or may be a template function\n\ (if a template, try specifying an instantiation: %s<type>)."
argument_list|,
name|name
argument_list|,
name|ps
operator|->
name|filename
argument_list|,
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|symtab
operator|!=
name|NULL
condition|)
operator|*
name|symtab
operator|=
name|s
expr_stmt|;
return|return
name|fixup_symbol_section
argument_list|(
name|sym
argument_list|,
name|objfile
argument_list|)
return|;
block|}
block|}
comment|/* Now search all static file-level symbols.      Not strictly correct, but more useful than an error.      Do the symtabs first, then check the psymtabs.      If a psymtab indicates the existence      of the desired name as a file-level static, then do psymtab-to-symtab      conversion on the fly and return the found symbol. */
name|ALL_SYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
block|{
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|block
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|STATIC_BLOCK
argument_list|)
expr_stmt|;
name|sym
operator|=
name|lookup_block_symbol
argument_list|(
name|block
argument_list|,
name|name
argument_list|,
name|namespace
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
condition|)
block|{
name|block_found
operator|=
name|block
expr_stmt|;
if|if
condition|(
name|symtab
operator|!=
name|NULL
condition|)
operator|*
name|symtab
operator|=
name|s
expr_stmt|;
return|return
name|fixup_symbol_section
argument_list|(
name|sym
argument_list|,
name|objfile
argument_list|)
return|;
block|}
block|}
name|ALL_PSYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|ps
argument_list|)
block|{
if|if
condition|(
operator|!
name|ps
operator|->
name|readin
operator|&&
name|lookup_partial_symbol
argument_list|(
name|ps
argument_list|,
name|name
argument_list|,
literal|0
argument_list|,
name|namespace
argument_list|)
condition|)
block|{
name|s
operator|=
name|PSYMTAB_TO_SYMTAB
argument_list|(
name|ps
argument_list|)
expr_stmt|;
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|block
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|STATIC_BLOCK
argument_list|)
expr_stmt|;
name|sym
operator|=
name|lookup_block_symbol
argument_list|(
name|block
argument_list|,
name|name
argument_list|,
name|namespace
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sym
condition|)
block|{
comment|/* This shouldn't be necessary, but as a last resort                * try looking in the globals even though the psymtab                * claimed the symbol was static. It's possible that                * the psymtab gets it wrong in some cases.                */
name|block
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
expr_stmt|;
name|sym
operator|=
name|lookup_block_symbol
argument_list|(
name|block
argument_list|,
name|name
argument_list|,
name|namespace
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sym
condition|)
name|error
argument_list|(
literal|"Internal: static symbol `%s' found in %s psymtab but not in symtab.\n\ %s may be an inlined function, or may be a template function\n\ (if a template, try specifying an instantiation: %s<type>)."
argument_list|,
name|name
argument_list|,
name|ps
operator|->
name|filename
argument_list|,
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|symtab
operator|!=
name|NULL
condition|)
operator|*
name|symtab
operator|=
name|s
expr_stmt|;
return|return
name|fixup_symbol_section
argument_list|(
name|sym
argument_list|,
name|objfile
argument_list|)
return|;
block|}
block|}
ifdef|#
directive|ifdef
name|HPUXHPPA
comment|/* Check for the possibility of the symbol being a function or      a global variable that is stored in one of the minimal symbol tables.      The "minimal symbol table" is built from linker-supplied info.       RT: I moved this check to last, after the complete search of      the global (p)symtab's and static (p)symtab's. For HP-generated      symbol tables, this check was causing a premature exit from      lookup_symbol with NULL return, and thus messing up symbol lookups      of things like "c::f". It seems to me a check of the minimal      symbol table ought to be a last resort in any case. I'm vaguely      worried about the comment below which talks about FORTRAN routines "foo_"      though... is it saying we need to do the "minsym" check before      the static check in this case?     */
if|if
condition|(
name|namespace
operator|==
name|VAR_NAMESPACE
condition|)
block|{
name|msymbol
operator|=
name|lookup_minimal_symbol
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|msymbol
operator|!=
name|NULL
condition|)
block|{
comment|/* OK, we found a minimal symbol in spite of not            * finding any symbol. There are various possible            * explanations for this. One possibility is the symbol            * exists in code not compiled -g. Another possibility            * is that the 'psymtab' isn't doing its job.            * A third possibility, related to #2, is that we were confused             * by name-mangling. For instance, maybe the psymtab isn't            * doing its job because it only know about demangled            * names, but we were given a mangled name...            */
comment|/* We first use the address in the msymbol to try to            * locate the appropriate symtab. Note that find_pc_symtab()            * has a side-effect of doing psymtab-to-symtab expansion,            * for the found symtab.            */
name|s
operator|=
name|find_pc_symtab
argument_list|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|block
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
expr_stmt|;
name|sym
operator|=
name|lookup_block_symbol
argument_list|(
name|block
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|msymbol
argument_list|)
argument_list|,
name|namespace
argument_list|)
expr_stmt|;
comment|/* We kept static functions in minimal symbol table as well as 		 in static scope. We want to find them in the symbol table. */
if|if
condition|(
operator|!
name|sym
condition|)
block|{
name|block
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|STATIC_BLOCK
argument_list|)
expr_stmt|;
name|sym
operator|=
name|lookup_block_symbol
argument_list|(
name|block
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|msymbol
argument_list|)
argument_list|,
name|namespace
argument_list|)
expr_stmt|;
block|}
comment|/* If we found one, return it */
if|if
condition|(
name|sym
condition|)
block|{
if|if
condition|(
name|symtab
operator|!=
name|NULL
condition|)
operator|*
name|symtab
operator|=
name|s
expr_stmt|;
return|return
name|sym
return|;
block|}
comment|/* If we get here with sym == 0, the symbol was                   found in the minimal symbol table 		 but not in the symtab. 		 Fall through and return 0 to use the msymbol                   definition of "foo_".                  (Note that outer code generally follows up a call                   to this routine with a call to lookup_minimal_symbol(),                   so a 0 return means we'll just flow into that other routine).  		 This happens for Fortran  "foo_" symbols, 		 which are "foo" in the symtab.  		 This can also happen if "asm" is used to make a 		 regular symbol but not a debugging symbol, e.g. 		 asm(".globl _main"); 		 asm("_main:"); 		 */
block|}
comment|/* If the lookup-by-address fails, try repeating the            * entire lookup process with the symbol name from            * the msymbol (if different from the original symbol name).            */
elseif|else
if|if
condition|(
name|MSYMBOL_TYPE
argument_list|(
name|msymbol
argument_list|)
operator|!=
name|mst_text
operator|&&
name|MSYMBOL_TYPE
argument_list|(
name|msymbol
argument_list|)
operator|!=
name|mst_file_text
operator|&&
operator|!
name|STREQ
argument_list|(
name|name
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|msymbol
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|lookup_symbol
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|msymbol
argument_list|)
argument_list|,
name|block
argument_list|,
name|namespace
argument_list|,
name|is_a_field_of_this
argument_list|,
name|symtab
argument_list|)
return|;
block|}
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|symtab
operator|!=
name|NULL
condition|)
operator|*
name|symtab
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Look, in partial_symtab PST, for symbol NAME.  Check the global    symbols if GLOBAL, the static symbols if not */
end_comment

begin_function
specifier|static
name|struct
name|partial_symbol
modifier|*
name|lookup_partial_symbol
parameter_list|(
name|pst
parameter_list|,
name|name
parameter_list|,
name|global
parameter_list|,
name|namespace
parameter_list|)
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|global
decl_stmt|;
name|namespace_enum
name|namespace
decl_stmt|;
block|{
name|struct
name|partial_symbol
modifier|*
modifier|*
name|start
decl_stmt|,
modifier|*
modifier|*
name|psym
decl_stmt|;
name|struct
name|partial_symbol
modifier|*
modifier|*
name|top
decl_stmt|,
modifier|*
modifier|*
name|bottom
decl_stmt|,
modifier|*
modifier|*
name|center
decl_stmt|;
name|int
name|length
init|=
operator|(
name|global
condition|?
name|pst
operator|->
name|n_global_syms
else|:
name|pst
operator|->
name|n_static_syms
operator|)
decl_stmt|;
name|int
name|do_linear_search
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|length
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|start
operator|=
operator|(
name|global
condition|?
name|pst
operator|->
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
operator|+
name|pst
operator|->
name|globals_offset
else|:
name|pst
operator|->
name|objfile
operator|->
name|static_psymbols
operator|.
name|list
operator|+
name|pst
operator|->
name|statics_offset
operator|)
expr_stmt|;
if|if
condition|(
name|global
condition|)
comment|/* This means we can use a binary search. */
block|{
name|do_linear_search
operator|=
literal|0
expr_stmt|;
comment|/* Binary search.  This search is guaranteed to end with center          pointing at the earliest partial symbol with the correct 	 name.  At that point *all* partial symbols with that name 	 will be checked against the correct namespace. */
name|bottom
operator|=
name|start
expr_stmt|;
name|top
operator|=
name|start
operator|+
name|length
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|top
operator|>
name|bottom
condition|)
block|{
name|center
operator|=
name|bottom
operator|+
operator|(
name|top
operator|-
name|bottom
operator|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|center
operator|<
name|top
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|do_linear_search
operator|&&
operator|(
name|SYMBOL_LANGUAGE
argument_list|(
operator|*
name|center
argument_list|)
operator|==
name|language_cplus
operator|||
name|SYMBOL_LANGUAGE
argument_list|(
operator|*
name|center
argument_list|)
operator|==
name|language_java
operator|)
condition|)
block|{
name|do_linear_search
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|STRCMP
argument_list|(
name|SYMBOL_NAME
argument_list|(
operator|*
name|center
argument_list|)
argument_list|,
name|name
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|top
operator|=
name|center
expr_stmt|;
block|}
else|else
block|{
name|bottom
operator|=
name|center
operator|+
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|top
operator|==
name|bottom
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
while|while
condition|(
name|STREQ
argument_list|(
name|SYMBOL_NAME
argument_list|(
operator|*
name|top
argument_list|)
argument_list|,
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
name|SYMBOL_NAMESPACE
argument_list|(
operator|*
name|top
argument_list|)
operator|==
name|namespace
condition|)
block|{
return|return
operator|(
operator|*
name|top
operator|)
return|;
block|}
name|top
operator|++
expr_stmt|;
block|}
block|}
comment|/* Can't use a binary search or else we found during the binary search that      we should also do a linear search. */
if|if
condition|(
name|do_linear_search
condition|)
block|{
for|for
control|(
name|psym
operator|=
name|start
init|;
name|psym
operator|<
name|start
operator|+
name|length
condition|;
name|psym
operator|++
control|)
block|{
if|if
condition|(
name|namespace
operator|==
name|SYMBOL_NAMESPACE
argument_list|(
operator|*
name|psym
argument_list|)
condition|)
block|{
if|if
condition|(
name|SYMBOL_MATCHES_NAME
argument_list|(
operator|*
name|psym
argument_list|,
name|name
argument_list|)
condition|)
block|{
return|return
operator|(
operator|*
name|psym
operator|)
return|;
block|}
block|}
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Look up a type named NAME in the struct_namespace.  The type returned    must not be opaque -- i.e., must have at least one field defined     This code was modelled on lookup_symbol -- the parts not relevant to looking    up types were just left out.  In particular it's assumed here that types    are available in struct_namespace and only at file-static or global blocks. */
end_comment

begin_function
name|struct
name|type
modifier|*
name|lookup_transparent_type
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
specifier|register
name|struct
name|symtab
modifier|*
name|s
init|=
name|NULL
decl_stmt|;
specifier|register
name|struct
name|partial_symtab
modifier|*
name|ps
decl_stmt|;
name|struct
name|blockvector
modifier|*
name|bv
decl_stmt|;
specifier|register
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
specifier|register
name|struct
name|block
modifier|*
name|block
decl_stmt|;
specifier|register
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
comment|/* Now search all the global symbols.  Do the symtab's first, then      check the psymtab's. If a psymtab indicates the existence      of the desired name as a global, then do psymtab-to-symtab      conversion on the fly and return the found symbol.  */
name|ALL_SYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
block|{
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|block
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
expr_stmt|;
name|sym
operator|=
name|lookup_block_symbol
argument_list|(
name|block
argument_list|,
name|name
argument_list|,
name|STRUCT_NAMESPACE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|&&
operator|!
name|TYPE_IS_OPAQUE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
return|;
block|}
block|}
name|ALL_PSYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|ps
argument_list|)
block|{
if|if
condition|(
operator|!
name|ps
operator|->
name|readin
operator|&&
name|lookup_partial_symbol
argument_list|(
name|ps
argument_list|,
name|name
argument_list|,
literal|1
argument_list|,
name|STRUCT_NAMESPACE
argument_list|)
condition|)
block|{
name|s
operator|=
name|PSYMTAB_TO_SYMTAB
argument_list|(
name|ps
argument_list|)
expr_stmt|;
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|block
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
expr_stmt|;
name|sym
operator|=
name|lookup_block_symbol
argument_list|(
name|block
argument_list|,
name|name
argument_list|,
name|STRUCT_NAMESPACE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sym
condition|)
block|{
comment|/* This shouldn't be necessary, but as a last resort                * try looking in the statics even though the psymtab                * claimed the symbol was global. It's possible that                * the psymtab gets it wrong in some cases.                */
name|block
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|STATIC_BLOCK
argument_list|)
expr_stmt|;
name|sym
operator|=
name|lookup_block_symbol
argument_list|(
name|block
argument_list|,
name|name
argument_list|,
name|STRUCT_NAMESPACE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sym
condition|)
name|error
argument_list|(
literal|"Internal: global symbol `%s' found in %s psymtab but not in symtab.\n\ %s may be an inlined function, or may be a template function\n\ (if a template, try specifying an instantiation: %s<type>)."
argument_list|,
name|name
argument_list|,
name|ps
operator|->
name|filename
argument_list|,
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|TYPE_IS_OPAQUE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
condition|)
return|return
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
return|;
block|}
block|}
comment|/* Now search the static file-level symbols.      Not strictly correct, but more useful than an error.      Do the symtab's first, then      check the psymtab's. If a psymtab indicates the existence      of the desired name as a file-level static, then do psymtab-to-symtab      conversion on the fly and return the found symbol.    */
name|ALL_SYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
block|{
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|block
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|STATIC_BLOCK
argument_list|)
expr_stmt|;
name|sym
operator|=
name|lookup_block_symbol
argument_list|(
name|block
argument_list|,
name|name
argument_list|,
name|STRUCT_NAMESPACE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|&&
operator|!
name|TYPE_IS_OPAQUE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
return|;
block|}
block|}
name|ALL_PSYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|ps
argument_list|)
block|{
if|if
condition|(
operator|!
name|ps
operator|->
name|readin
operator|&&
name|lookup_partial_symbol
argument_list|(
name|ps
argument_list|,
name|name
argument_list|,
literal|0
argument_list|,
name|STRUCT_NAMESPACE
argument_list|)
condition|)
block|{
name|s
operator|=
name|PSYMTAB_TO_SYMTAB
argument_list|(
name|ps
argument_list|)
expr_stmt|;
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|block
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|STATIC_BLOCK
argument_list|)
expr_stmt|;
name|sym
operator|=
name|lookup_block_symbol
argument_list|(
name|block
argument_list|,
name|name
argument_list|,
name|STRUCT_NAMESPACE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sym
condition|)
block|{
comment|/* This shouldn't be necessary, but as a last resort                * try looking in the globals even though the psymtab                * claimed the symbol was static. It's possible that                * the psymtab gets it wrong in some cases.                */
name|block
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
expr_stmt|;
name|sym
operator|=
name|lookup_block_symbol
argument_list|(
name|block
argument_list|,
name|name
argument_list|,
name|STRUCT_NAMESPACE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sym
condition|)
name|error
argument_list|(
literal|"Internal: static symbol `%s' found in %s psymtab but not in symtab.\n\ %s may be an inlined function, or may be a template function\n\ (if a template, try specifying an instantiation: %s<type>)."
argument_list|,
name|name
argument_list|,
name|ps
operator|->
name|filename
argument_list|,
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|TYPE_IS_OPAQUE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
condition|)
return|return
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
return|;
block|}
block|}
return|return
operator|(
expr|struct
name|type
operator|*
operator|)
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Find the psymtab containing main(). */
end_comment

begin_comment
comment|/* FIXME:  What about languages without main() or specially linked    executables that have no main() ? */
end_comment

begin_function
name|struct
name|partial_symtab
modifier|*
name|find_main_psymtab
parameter_list|()
block|{
specifier|register
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
specifier|register
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|ALL_PSYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|pst
argument_list|)
block|{
if|if
condition|(
name|lookup_partial_symbol
argument_list|(
name|pst
argument_list|,
literal|"main"
argument_list|,
literal|1
argument_list|,
name|VAR_NAMESPACE
argument_list|)
condition|)
block|{
return|return
operator|(
name|pst
operator|)
return|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Search BLOCK for symbol NAME in NAMESPACE.     Note that if NAME is the demangled form of a C++ symbol, we will fail    to find a match during the binary search of the non-encoded names, but    for now we don't worry about the slight inefficiency of looking for    a match we'll never find, since it will go pretty quick.  Once the    binary search terminates, we drop through and do a straight linear    search on the symbols.  Each symbol which is marked as being a C++    symbol (language_cplus set) has both the encoded and non-encoded names    tested for a match. */
end_comment

begin_function
name|struct
name|symbol
modifier|*
name|lookup_block_symbol
parameter_list|(
name|block
parameter_list|,
name|name
parameter_list|,
name|namespace
parameter_list|)
specifier|register
specifier|const
name|struct
name|block
modifier|*
name|block
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|namespace_enum
name|namespace
decl_stmt|;
block|{
specifier|register
name|int
name|bot
decl_stmt|,
name|top
decl_stmt|,
name|inc
decl_stmt|;
specifier|register
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
specifier|register
name|struct
name|symbol
modifier|*
name|sym_found
init|=
name|NULL
decl_stmt|;
specifier|register
name|int
name|do_linear_search
init|=
literal|1
decl_stmt|;
comment|/* If the blocks's symbols were sorted, start with a binary search.  */
if|if
condition|(
name|BLOCK_SHOULD_SORT
argument_list|(
name|block
argument_list|)
condition|)
block|{
comment|/* Reset the linear search flag so if the binary search fails, we 	 won't do the linear search once unless we find some reason to 	 do so, such as finding a C++ symbol during the binary search. 	 Note that for C++ modules, ALL the symbols in a block should 	 end up marked as C++ symbols. */
name|do_linear_search
operator|=
literal|0
expr_stmt|;
name|top
operator|=
name|BLOCK_NSYMS
argument_list|(
name|block
argument_list|)
expr_stmt|;
name|bot
operator|=
literal|0
expr_stmt|;
comment|/* Advance BOT to not far before the first symbol whose name is NAME. */
while|while
condition|(
literal|1
condition|)
block|{
name|inc
operator|=
operator|(
name|top
operator|-
name|bot
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* No need to keep binary searching for the last few bits worth.  */
if|if
condition|(
name|inc
operator|<
literal|4
condition|)
block|{
break|break;
block|}
name|inc
operator|=
operator|(
name|inc
operator|>>
literal|1
operator|)
operator|+
name|bot
expr_stmt|;
name|sym
operator|=
name|BLOCK_SYM
argument_list|(
name|block
argument_list|,
name|inc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|do_linear_search
operator|&&
operator|(
name|SYMBOL_LANGUAGE
argument_list|(
name|sym
argument_list|)
operator|==
name|language_cplus
operator|||
name|SYMBOL_LANGUAGE
argument_list|(
name|sym
argument_list|)
operator|==
name|language_java
operator|)
condition|)
block|{
name|do_linear_search
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
index|[
literal|0
index|]
operator|<
name|name
index|[
literal|0
index|]
condition|)
block|{
name|bot
operator|=
name|inc
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
index|[
literal|0
index|]
operator|>
name|name
index|[
literal|0
index|]
condition|)
block|{
name|top
operator|=
name|inc
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|STRCMP
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|name
argument_list|)
operator|<
literal|0
condition|)
block|{
name|bot
operator|=
name|inc
expr_stmt|;
block|}
else|else
block|{
name|top
operator|=
name|inc
expr_stmt|;
block|}
block|}
comment|/* Now scan forward until we run out of symbols, find one whose 	 name is greater than NAME, or find one we want.  If there is 	 more than one symbol with the right name and namespace, we 	 return the first one; I believe it is now impossible for us 	 to encounter two symbols with the same name and namespace 	 here, because blocks containing argument symbols are no 	 longer sorted.  */
name|top
operator|=
name|BLOCK_NSYMS
argument_list|(
name|block
argument_list|)
expr_stmt|;
while|while
condition|(
name|bot
operator|<
name|top
condition|)
block|{
name|sym
operator|=
name|BLOCK_SYM
argument_list|(
name|block
argument_list|,
name|bot
argument_list|)
expr_stmt|;
name|inc
operator|=
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
index|[
literal|0
index|]
operator|-
name|name
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|inc
operator|==
literal|0
condition|)
block|{
name|inc
operator|=
name|STRCMP
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|inc
operator|==
literal|0
operator|&&
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|==
name|namespace
condition|)
block|{
return|return
operator|(
name|sym
operator|)
return|;
block|}
if|if
condition|(
name|inc
operator|>
literal|0
condition|)
block|{
break|break;
block|}
name|bot
operator|++
expr_stmt|;
block|}
block|}
comment|/* Here if block isn't sorted, or we fail to find a match during the      binary search above.  If during the binary search above, we find a      symbol which is a C++ symbol, then we have re-enabled the linear      search flag which was reset when starting the binary search.       This loop is equivalent to the loop above, but hacked greatly for speed.       Note that parameter symbols do not always show up last in the      list; this loop makes sure to take anything else other than      parameter symbols first; it only uses parameter symbols as a      last resort.  Note that this only takes up extra computation      time on a match.  */
if|if
condition|(
name|do_linear_search
condition|)
block|{
name|top
operator|=
name|BLOCK_NSYMS
argument_list|(
name|block
argument_list|)
expr_stmt|;
name|bot
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|bot
operator|<
name|top
condition|)
block|{
name|sym
operator|=
name|BLOCK_SYM
argument_list|(
name|block
argument_list|,
name|bot
argument_list|)
expr_stmt|;
if|if
condition|(
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|==
name|namespace
operator|&&
name|SYMBOL_MATCHES_NAME
argument_list|(
name|sym
argument_list|,
name|name
argument_list|)
condition|)
block|{
comment|/* If SYM has aliases, then use any alias that is active 		 at the current PC.  If no alias is active at the current 		 PC, then use the main symbol.  		 ?!? Is checking the current pc correct?  Is this routine 		 ever called to look up a symbol from another context?  */
if|if
condition|(
name|SYMBOL_ALIASES
argument_list|(
name|sym
argument_list|)
condition|)
name|sym
operator|=
name|find_active_alias
argument_list|(
name|sym
argument_list|,
name|read_pc
argument_list|()
argument_list|)
expr_stmt|;
name|sym_found
operator|=
name|sym
expr_stmt|;
if|if
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|!=
name|LOC_ARG
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|!=
name|LOC_LOCAL_ARG
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|!=
name|LOC_REF_ARG
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|!=
name|LOC_REGPARM
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|!=
name|LOC_REGPARM_ADDR
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|!=
name|LOC_BASEREG_ARG
condition|)
block|{
break|break;
block|}
block|}
name|bot
operator|++
expr_stmt|;
block|}
block|}
return|return
operator|(
name|sym_found
operator|)
return|;
comment|/* Will be NULL if not found. */
block|}
end_function

begin_comment
comment|/* Given a main symbol SYM and ADDR, search through the alias    list to determine if an alias is active at ADDR and return    the active alias.     If no alias is active, then return SYM.  */
end_comment

begin_function
specifier|static
name|struct
name|symbol
modifier|*
name|find_active_alias
parameter_list|(
name|sym
parameter_list|,
name|addr
parameter_list|)
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
block|{
name|struct
name|range_list
modifier|*
name|r
decl_stmt|;
name|struct
name|alias_list
modifier|*
name|aliases
decl_stmt|;
comment|/* If we have aliases, check them first.  */
name|aliases
operator|=
name|SYMBOL_ALIASES
argument_list|(
name|sym
argument_list|)
expr_stmt|;
while|while
condition|(
name|aliases
condition|)
block|{
if|if
condition|(
operator|!
name|SYMBOL_RANGES
argument_list|(
name|aliases
operator|->
name|sym
argument_list|)
condition|)
return|return
name|aliases
operator|->
name|sym
return|;
for|for
control|(
name|r
operator|=
name|SYMBOL_RANGES
argument_list|(
name|aliases
operator|->
name|sym
argument_list|)
init|;
name|r
condition|;
name|r
operator|=
name|r
operator|->
name|next
control|)
block|{
if|if
condition|(
name|r
operator|->
name|start
operator|<=
name|addr
operator|&&
name|r
operator|->
name|end
operator|>
name|addr
condition|)
return|return
name|aliases
operator|->
name|sym
return|;
block|}
name|aliases
operator|=
name|aliases
operator|->
name|next
expr_stmt|;
block|}
comment|/* Nothing found, return the main symbol.  */
return|return
name|sym
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the symbol for the function which contains a specified    lexical block, described by a struct block BL.  */
end_comment

begin_function
name|struct
name|symbol
modifier|*
name|block_function
parameter_list|(
name|bl
parameter_list|)
name|struct
name|block
modifier|*
name|bl
decl_stmt|;
block|{
while|while
condition|(
name|BLOCK_FUNCTION
argument_list|(
name|bl
argument_list|)
operator|==
literal|0
operator|&&
name|BLOCK_SUPERBLOCK
argument_list|(
name|bl
argument_list|)
operator|!=
literal|0
condition|)
name|bl
operator|=
name|BLOCK_SUPERBLOCK
argument_list|(
name|bl
argument_list|)
expr_stmt|;
return|return
name|BLOCK_FUNCTION
argument_list|(
name|bl
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Find the symtab associated with PC and SECTION.  Look through the    psymtabs and read in another symtab if necessary. */
end_comment

begin_function
name|struct
name|symtab
modifier|*
name|find_pc_sect_symtab
parameter_list|(
name|pc
parameter_list|,
name|section
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
block|{
specifier|register
name|struct
name|block
modifier|*
name|b
decl_stmt|;
name|struct
name|blockvector
modifier|*
name|bv
decl_stmt|;
specifier|register
name|struct
name|symtab
modifier|*
name|s
init|=
name|NULL
decl_stmt|;
specifier|register
name|struct
name|symtab
modifier|*
name|best_s
init|=
name|NULL
decl_stmt|;
specifier|register
name|struct
name|partial_symtab
modifier|*
name|ps
decl_stmt|;
specifier|register
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|CORE_ADDR
name|distance
init|=
literal|0
decl_stmt|;
comment|/* Search all symtabs for the one whose file contains our address, and which      is the smallest of all the ones containing the address.  This is designed      to deal with a case like symtab a is at 0x1000-0x2000 and 0x3000-0x4000      and symtab b is at 0x2000-0x3000.  So the GLOBAL_BLOCK for a is from      0x1000-0x4000, but for address 0x2345 we want to return symtab b.       This happens for native ecoff format, where code from included files      gets its own symtab. The symtab for the included file should have      been read in already via the dependency mechanism.      It might be swifter to create several symtabs with the same name      like xcoff does (I'm not sure).       It also happens for objfiles that have their functions reordered.      For these, the symtab we are looking for is not necessarily read in.  */
name|ALL_SYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
block|{
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|b
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|BLOCK_START
argument_list|(
name|b
argument_list|)
operator|<=
name|pc
if|#
directive|if
name|defined
argument_list|(
name|HPUXHPPA
argument_list|)
operator|&&
name|BLOCK_END
argument_list|(
name|b
argument_list|)
operator|>=
name|pc
else|#
directive|else
operator|&&
name|BLOCK_END
argument_list|(
name|b
argument_list|)
operator|>
name|pc
endif|#
directive|endif
operator|&&
operator|(
name|distance
operator|==
literal|0
operator|||
name|BLOCK_END
argument_list|(
name|b
argument_list|)
operator|-
name|BLOCK_START
argument_list|(
name|b
argument_list|)
operator|<
name|distance
operator|)
condition|)
block|{
comment|/* For an objfile that has its functions reordered, 	     find_pc_psymtab will find the proper partial symbol table 	     and we simply return its corresponding symtab.  */
comment|/* In order to better support objfiles that contain both 	     stabs and coff debugging info, we continue on if a psymtab 	     can't be found. */
if|if
condition|(
operator|(
name|objfile
operator|->
name|flags
operator|&
name|OBJF_REORDERED
operator|)
operator|&&
name|objfile
operator|->
name|psymtabs
condition|)
block|{
name|ps
operator|=
name|find_pc_sect_psymtab
argument_list|(
name|pc
argument_list|,
name|section
argument_list|)
expr_stmt|;
if|if
condition|(
name|ps
condition|)
return|return
name|PSYMTAB_TO_SYMTAB
argument_list|(
name|ps
argument_list|)
return|;
block|}
if|if
condition|(
name|section
operator|!=
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|b
operator|->
name|nsyms
condition|;
name|i
operator|++
control|)
block|{
name|fixup_symbol_section
argument_list|(
name|b
operator|->
name|sym
index|[
name|i
index|]
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|section
operator|==
name|SYMBOL_BFD_SECTION
argument_list|(
name|b
operator|->
name|sym
index|[
name|i
index|]
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|>=
name|b
operator|->
name|nsyms
condition|)
continue|continue;
comment|/* no symbol in this symtab matches section */
block|}
name|distance
operator|=
name|BLOCK_END
argument_list|(
name|b
argument_list|)
operator|-
name|BLOCK_START
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|best_s
operator|=
name|s
expr_stmt|;
block|}
block|}
if|if
condition|(
name|best_s
operator|!=
name|NULL
condition|)
return|return
operator|(
name|best_s
operator|)
return|;
name|s
operator|=
name|NULL
expr_stmt|;
name|ps
operator|=
name|find_pc_sect_psymtab
argument_list|(
name|pc
argument_list|,
name|section
argument_list|)
expr_stmt|;
if|if
condition|(
name|ps
condition|)
block|{
if|if
condition|(
name|ps
operator|->
name|readin
condition|)
comment|/* Might want to error() here (in case symtab is corrupt and 	   will cause a core dump), but maybe we can successfully 	   continue, so let's not.  */
comment|/* FIXME-32x64: assumes pc fits in a long */
name|warning
argument_list|(
literal|"\ (Internal error: pc 0x%lx in read in psymtab, but not in symtab.)\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|pc
argument_list|)
expr_stmt|;
name|s
operator|=
name|PSYMTAB_TO_SYMTAB
argument_list|(
name|ps
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Find the symtab associated with PC.  Look through the psymtabs and    read in another symtab if necessary.  Backward compatibility, no section */
end_comment

begin_function
name|struct
name|symtab
modifier|*
name|find_pc_symtab
parameter_list|(
name|pc
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
block|{
return|return
name|find_pc_sect_symtab
argument_list|(
name|pc
argument_list|,
name|find_pc_mapped_section
argument_list|(
name|pc
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Find the closest symbol value (of any sort -- function or variable)    for a given address value.  Slow but complete.  (currently unused,    mainly because it is too slow.  We could fix it if each symtab and    psymtab had contained in it the addresses ranges of each of its    sections, which also would be required to make things like "info    line *0x2345" cause psymtabs to be converted to symtabs).  */
end_comment

begin_comment
unit|struct symbol * find_addr_symbol (addr, symtabp, symaddrp)      CORE_ADDR addr;      struct symtab **symtabp;      CORE_ADDR *symaddrp; {   struct symtab *symtab, *best_symtab;   struct objfile *objfile;   register int bot, top;   register struct symbol *sym;   register CORE_ADDR sym_addr;   struct block *block;   int blocknum;
comment|/* Info on best symbol seen so far */
end_comment

begin_comment
unit|register CORE_ADDR best_sym_addr = 0;   struct symbol *best_sym = 0;
comment|/* FIXME -- we should pull in all the psymtabs, too!  */
end_comment

begin_comment
unit|ALL_SYMTABS (objfile, symtab)     {
comment|/* Search the global and static blocks in this symtab for 	 the closest symbol-address to the desired address.  */
end_comment

begin_comment
unit|for (blocknum = GLOBAL_BLOCK; blocknum<= STATIC_BLOCK; blocknum++) 	{ 	  QUIT; 	  block = BLOCKVECTOR_BLOCK (BLOCKVECTOR (symtab), blocknum); 	  top = BLOCK_NSYMS (block); 	  for (bot = 0; bot< top; bot++) 	    { 	      sym = BLOCK_SYM (block, bot); 	      switch (SYMBOL_CLASS (sym)) 		{ 		case LOC_STATIC:	 		case LOC_LABEL:	 		  sym_addr = SYMBOL_VALUE_ADDRESS (sym); 		  break;                  case LOC_INDIRECT: 		  sym_addr = SYMBOL_VALUE_ADDRESS (sym);
comment|/* An indirect symbol really lives at *sym_addr,                    * so an indirection needs to be done.                    * However, I am leaving this commented out because it's                    * expensive, and it's possible that symbolization                    * could be done without an active process (in                    * case this read_memory will fail). RT                   sym_addr = read_memory_unsigned_integer                       (sym_addr, TARGET_PTR_BIT / TARGET_CHAR_BIT);                    */
end_comment

begin_comment
unit|break;  		case LOC_BLOCK: 		  sym_addr = BLOCK_START (SYMBOL_BLOCK_VALUE (sym)); 		  break;  		default: 		  continue; 		}  		if (sym_addr<= addr) 		  if (sym_addr> best_sym_addr) 		    {
comment|/* Quit if we found an exact match.  */
end_comment

begin_endif
unit|best_sym = sym; 		      best_sym_addr = sym_addr; 		      best_symtab = symtab; 		      if (sym_addr == addr) 			goto done; 		    } 	    } 	}     }   done:   if (symtabp)     *symtabp = best_symtab;   if (symaddrp)     *symaddrp = best_sym_addr;   return best_sym; }
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_comment
comment|/* Find the source file and line number for a given PC value and section.    Return a structure containing a symtab pointer, a line number,    and a pc range for the entire source line.    The value's .pc field is NOT the specified pc.    NOTCURRENT nonzero means, if specified pc is on a line boundary,    use the line that ends there.  Otherwise, in that case, the line    that begins there is used.  */
end_comment

begin_comment
comment|/* The big complication here is that a line may start in one file, and end just    before the start of another file.  This usually occurs when you #include    code in the middle of a subroutine.  To properly find the end of a line's PC    range, we must search all symtabs associated with this compilation unit, and    find the one whose first PC is closer than that of the next line in this    symtab.  */
end_comment

begin_comment
comment|/* If it's worth the effort, we could be using a binary search.  */
end_comment

begin_function
name|struct
name|symtab_and_line
name|find_pc_sect_line
parameter_list|(
name|pc
parameter_list|,
name|section
parameter_list|,
name|notcurrent
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
name|struct
name|sec
modifier|*
name|section
decl_stmt|;
name|int
name|notcurrent
decl_stmt|;
block|{
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
specifier|register
name|struct
name|linetable
modifier|*
name|l
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|linetable_entry
modifier|*
name|item
decl_stmt|;
name|struct
name|symtab_and_line
name|val
decl_stmt|;
name|struct
name|blockvector
modifier|*
name|bv
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|mfunsym
decl_stmt|;
comment|/* Info on best line seen so far, and where it starts, and its file.  */
name|struct
name|linetable_entry
modifier|*
name|best
init|=
name|NULL
decl_stmt|;
name|CORE_ADDR
name|best_end
init|=
literal|0
decl_stmt|;
name|struct
name|symtab
modifier|*
name|best_symtab
init|=
literal|0
decl_stmt|;
comment|/* Store here the first line number      of a file which contains the line at the smallest pc after PC.      If we don't find a line whose range contains PC,      we will use a line one less than this,      with a range from the start of that file to the first line's pc.  */
name|struct
name|linetable_entry
modifier|*
name|alt
init|=
name|NULL
decl_stmt|;
name|struct
name|symtab
modifier|*
name|alt_symtab
init|=
literal|0
decl_stmt|;
comment|/* Info on best line seen in this file.  */
name|struct
name|linetable_entry
modifier|*
name|prev
decl_stmt|;
comment|/* If this pc is not from the current frame,      it is the address of the end of a call instruction.      Quite likely that is the start of the following statement.      But what we want is the statement containing the instruction.      Fudge the pc to make sure we get that.  */
name|INIT_SAL
argument_list|(
operator|&
name|val
argument_list|)
expr_stmt|;
comment|/* initialize to zeroes */
if|if
condition|(
name|notcurrent
condition|)
name|pc
operator|-=
literal|1
expr_stmt|;
comment|/* elz: added this because this function returned the wrong      information if the pc belongs to a stub (import/export)      to call a shlib function. This stub would be anywhere between      two functions in the target, and the line info was erroneously       taken to be the one of the line before the pc.    */
comment|/* RT: Further explanation:    *    * We have stubs (trampolines) inserted between procedures.    *    * Example: "shr1" exists in a shared library, and a "shr1" stub also    * exists in the main image.    *    * In the minimal symbol table, we have a bunch of symbols    * sorted by start address. The stubs are marked as "trampoline",    * the others appear as text. E.g.:    *    *  Minimal symbol table for main image     *     main:  code for main (text symbol)    *     shr1: stub  (trampoline symbol)    *     foo:   code for foo (text symbol)    *     ...    *  Minimal symbol table for "shr1" image:    *     ...    *     shr1: code for shr1 (text symbol)    *     ...    *    * So the code below is trying to detect if we are in the stub    * ("shr1" stub), and if so, find the real code ("shr1" trampoline),    * and if found,  do the symbolization from the real-code address    * rather than the stub address.    *    * Assumptions being made about the minimal symbol table:    *   1. lookup_minimal_symbol_by_pc() will return a trampoline only    *      if we're really in the trampoline. If we're beyond it (say    *      we're in "foo" in the above example), it'll have a closer     *      symbol (the "foo" text symbol for example) and will not    *      return the trampoline.    *   2. lookup_minimal_symbol_text() will find a real text symbol    *      corresponding to the trampoline, and whose address will    *      be different than the trampoline address. I put in a sanity    *      check for the address being the same, to avoid an    *      infinite recursion.    */
name|msymbol
operator|=
name|lookup_minimal_symbol_by_pc
argument_list|(
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|msymbol
operator|!=
name|NULL
condition|)
if|if
condition|(
name|MSYMBOL_TYPE
argument_list|(
name|msymbol
argument_list|)
operator|==
name|mst_solib_trampoline
condition|)
block|{
name|mfunsym
operator|=
name|lookup_minimal_symbol_text
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|msymbol
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mfunsym
operator|==
name|NULL
condition|)
comment|/* I eliminated this warning since it is coming out          * in the following situation:          * gdb shmain // test program with shared libraries          * (gdb) break shr1  // function in shared lib          * Warning: In stub for ...          * In the above situation, the shared lib is not loaded yet,           * so of course we can't find the real func/line info,          * but the "break" still works, and the warning is annoying.          * So I commented out the warning. RT */
comment|/* warning ("In stub for %s; unable to find real function/line info", SYMBOL_NAME(msymbol)) */
empty_stmt|;
comment|/* fall through */
elseif|else
if|if
condition|(
name|SYMBOL_VALUE
argument_list|(
name|mfunsym
argument_list|)
operator|==
name|SYMBOL_VALUE
argument_list|(
name|msymbol
argument_list|)
condition|)
comment|/* Avoid infinite recursion */
comment|/* See above comment about why warning is commented out */
comment|/* warning ("In stub for %s; unable to find real function/line info", SYMBOL_NAME(msymbol)) */
empty_stmt|;
comment|/* fall through */
else|else
return|return
name|find_pc_line
argument_list|(
name|SYMBOL_VALUE
argument_list|(
name|mfunsym
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|s
operator|=
name|find_pc_sect_symtab
argument_list|(
name|pc
argument_list|,
name|section
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
block|{
comment|/* if no symbol information, return previous pc */
if|if
condition|(
name|notcurrent
condition|)
name|pc
operator|++
expr_stmt|;
name|val
operator|.
name|pc
operator|=
name|pc
expr_stmt|;
return|return
name|val
return|;
block|}
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Look at all the symtabs that share this blockvector.      They all have the same apriori range, that we found was right;      but they have different line tables.  */
for|for
control|(
init|;
name|s
operator|&&
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
operator|==
name|bv
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
comment|/* Find the best line in this symtab.  */
name|l
operator|=
name|LINETABLE
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|l
condition|)
continue|continue;
name|len
operator|=
name|l
operator|->
name|nitems
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
block|{
comment|/* I think len can be zero if the symtab lacks line numbers 	     (e.g. gcc -g1).  (Either that or the LINETABLE is NULL; 	     I'm not sure which, and maybe it depends on the symbol 	     reader).  */
continue|continue;
block|}
name|prev
operator|=
name|NULL
expr_stmt|;
name|item
operator|=
name|l
operator|->
name|item
expr_stmt|;
comment|/* Get first line info */
comment|/* Is this file's first line closer than the first lines of other files? 	 If so, record this file, and its first line, as best alternate.  */
if|if
condition|(
name|item
operator|->
name|pc
operator|>
name|pc
operator|&&
operator|(
operator|!
name|alt
operator|||
name|item
operator|->
name|pc
operator|<
name|alt
operator|->
name|pc
operator|)
condition|)
block|{
name|alt
operator|=
name|item
expr_stmt|;
name|alt_symtab
operator|=
name|s
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
operator|,
name|item
operator|++
control|)
block|{
comment|/* Leave prev pointing to the linetable entry for the last line 	     that started at or before PC.  */
if|if
condition|(
name|item
operator|->
name|pc
operator|>
name|pc
condition|)
break|break;
name|prev
operator|=
name|item
expr_stmt|;
block|}
comment|/* At this point, prev points at the line whose start addr is<= pc, and 	 item points at the next line.  If we ran off the end of the linetable 	 (pc>= start of the last line), then prev == item.  If pc< start of 	 the first line, prev will not be set.  */
comment|/* Is this file's best line closer than the best in the other files? 	 If so, record this file, and its best line, as best so far.  */
if|if
condition|(
name|prev
operator|&&
operator|(
operator|!
name|best
operator|||
name|prev
operator|->
name|pc
operator|>
name|best
operator|->
name|pc
operator|)
condition|)
block|{
name|best
operator|=
name|prev
expr_stmt|;
name|best_symtab
operator|=
name|s
expr_stmt|;
comment|/* If another line is in the linetable, and its PC is closer 	     than the best_end we currently have, take it as best_end.  */
if|if
condition|(
name|i
operator|<
name|len
operator|&&
operator|(
name|best_end
operator|==
literal|0
operator|||
name|best_end
operator|>
name|item
operator|->
name|pc
operator|)
condition|)
name|best_end
operator|=
name|item
operator|->
name|pc
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|best_symtab
condition|)
block|{
if|if
condition|(
operator|!
name|alt_symtab
condition|)
block|{
comment|/* If we didn't find any line # info, just 				   return zeros.  */
name|val
operator|.
name|pc
operator|=
name|pc
expr_stmt|;
block|}
else|else
block|{
name|val
operator|.
name|symtab
operator|=
name|alt_symtab
expr_stmt|;
name|val
operator|.
name|line
operator|=
name|alt
operator|->
name|line
operator|-
literal|1
expr_stmt|;
comment|/* Don't return line 0, that means that we didn't find the line.  */
if|if
condition|(
name|val
operator|.
name|line
operator|==
literal|0
condition|)
operator|++
name|val
operator|.
name|line
expr_stmt|;
name|val
operator|.
name|pc
operator|=
name|BLOCK_END
argument_list|(
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
argument_list|)
expr_stmt|;
name|val
operator|.
name|end
operator|=
name|alt
operator|->
name|pc
expr_stmt|;
block|}
block|}
else|else
block|{
name|val
operator|.
name|symtab
operator|=
name|best_symtab
expr_stmt|;
name|val
operator|.
name|line
operator|=
name|best
operator|->
name|line
expr_stmt|;
name|val
operator|.
name|pc
operator|=
name|best
operator|->
name|pc
expr_stmt|;
if|if
condition|(
name|best_end
operator|&&
operator|(
operator|!
name|alt
operator|||
name|best_end
operator|<
name|alt
operator|->
name|pc
operator|)
condition|)
name|val
operator|.
name|end
operator|=
name|best_end
expr_stmt|;
elseif|else
if|if
condition|(
name|alt
condition|)
name|val
operator|.
name|end
operator|=
name|alt
operator|->
name|pc
expr_stmt|;
else|else
name|val
operator|.
name|end
operator|=
name|BLOCK_END
argument_list|(
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|val
operator|.
name|section
operator|=
name|section
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Backward compatibility (no section) */
end_comment

begin_function
name|struct
name|symtab_and_line
name|find_pc_line
parameter_list|(
name|pc
parameter_list|,
name|notcurrent
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
name|int
name|notcurrent
decl_stmt|;
block|{
name|asection
modifier|*
name|section
decl_stmt|;
name|section
operator|=
name|find_pc_overlay
argument_list|(
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|pc_in_unmapped_range
argument_list|(
name|pc
argument_list|,
name|section
argument_list|)
condition|)
name|pc
operator|=
name|overlay_mapped_address
argument_list|(
name|pc
argument_list|,
name|section
argument_list|)
expr_stmt|;
return|return
name|find_pc_sect_line
argument_list|(
name|pc
argument_list|,
name|section
argument_list|,
name|notcurrent
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|struct
name|symtab
modifier|*
name|find_line_symtab
name|PARAMS
argument_list|(
operator|(
expr|struct
name|symtab
operator|*
operator|,
name|int
operator|,
name|int
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Find line number LINE in any symtab whose name is the same as    SYMTAB.     If found, return the symtab that contains the linetable in which it was    found, set *INDEX to the index in the linetable of the best entry    found, and set *EXACT_MATCH nonzero if the value returned is an    exact match.     If not found, return NULL.  */
end_comment

begin_function
specifier|static
name|struct
name|symtab
modifier|*
name|find_line_symtab
parameter_list|(
name|symtab
parameter_list|,
name|line
parameter_list|,
name|index
parameter_list|,
name|exact_match
parameter_list|)
name|struct
name|symtab
modifier|*
name|symtab
decl_stmt|;
name|int
name|line
decl_stmt|;
name|int
modifier|*
name|index
decl_stmt|;
name|int
modifier|*
name|exact_match
decl_stmt|;
block|{
name|int
name|exact
decl_stmt|;
comment|/* BEST_INDEX and BEST_LINETABLE identify the smallest linenumber> LINE      so far seen.  */
name|int
name|best_index
decl_stmt|;
name|struct
name|linetable
modifier|*
name|best_linetable
decl_stmt|;
name|struct
name|symtab
modifier|*
name|best_symtab
decl_stmt|;
comment|/* First try looking it up in the given symtab.  */
name|best_linetable
operator|=
name|LINETABLE
argument_list|(
name|symtab
argument_list|)
expr_stmt|;
name|best_symtab
operator|=
name|symtab
expr_stmt|;
name|best_index
operator|=
name|find_line_common
argument_list|(
name|best_linetable
argument_list|,
name|line
argument_list|,
operator|&
name|exact
argument_list|)
expr_stmt|;
if|if
condition|(
name|best_index
operator|<
literal|0
operator|||
operator|!
name|exact
condition|)
block|{
comment|/* Didn't find an exact match.  So we better keep looking for 	 another symtab with the same name.  In the case of xcoff, 	 multiple csects for one source file (produced by IBM's FORTRAN 	 compiler) produce multiple symtabs (this is unavoidable 	 assuming csects can be at arbitrary places in memory and that 	 the GLOBAL_BLOCK of a symtab has a begin and end address).  */
comment|/* BEST is the smallest linenumber> LINE so far seen, 	 or 0 if none has been seen so far. 	 BEST_INDEX and BEST_LINETABLE identify the item for it.  */
name|int
name|best
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|best_index
operator|>=
literal|0
condition|)
name|best
operator|=
name|best_linetable
operator|->
name|item
index|[
name|best_index
index|]
operator|.
name|line
expr_stmt|;
else|else
name|best
operator|=
literal|0
expr_stmt|;
name|ALL_SYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
block|{
name|struct
name|linetable
modifier|*
name|l
decl_stmt|;
name|int
name|ind
decl_stmt|;
if|if
condition|(
operator|!
name|STREQ
argument_list|(
name|symtab
operator|->
name|filename
argument_list|,
name|s
operator|->
name|filename
argument_list|)
condition|)
continue|continue;
name|l
operator|=
name|LINETABLE
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ind
operator|=
name|find_line_common
argument_list|(
name|l
argument_list|,
name|line
argument_list|,
operator|&
name|exact
argument_list|)
expr_stmt|;
if|if
condition|(
name|ind
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|exact
condition|)
block|{
name|best_index
operator|=
name|ind
expr_stmt|;
name|best_linetable
operator|=
name|l
expr_stmt|;
name|best_symtab
operator|=
name|s
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|best
operator|==
literal|0
operator|||
name|l
operator|->
name|item
index|[
name|ind
index|]
operator|.
name|line
operator|<
name|best
condition|)
block|{
name|best
operator|=
name|l
operator|->
name|item
index|[
name|ind
index|]
operator|.
name|line
expr_stmt|;
name|best_index
operator|=
name|ind
expr_stmt|;
name|best_linetable
operator|=
name|l
expr_stmt|;
name|best_symtab
operator|=
name|s
expr_stmt|;
block|}
block|}
block|}
block|}
name|done
label|:
if|if
condition|(
name|best_index
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|index
condition|)
operator|*
name|index
operator|=
name|best_index
expr_stmt|;
if|if
condition|(
name|exact_match
condition|)
operator|*
name|exact_match
operator|=
name|exact
expr_stmt|;
return|return
name|best_symtab
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Set the PC value for a given source file and line number and return true.    Returns zero for invalid line number (and sets the PC to 0).    The source file is specified with a struct symtab.  */
end_comment

begin_function
name|int
name|find_line_pc
parameter_list|(
name|symtab
parameter_list|,
name|line
parameter_list|,
name|pc
parameter_list|)
name|struct
name|symtab
modifier|*
name|symtab
decl_stmt|;
name|int
name|line
decl_stmt|;
name|CORE_ADDR
modifier|*
name|pc
decl_stmt|;
block|{
name|struct
name|linetable
modifier|*
name|l
decl_stmt|;
name|int
name|ind
decl_stmt|;
operator|*
name|pc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|symtab
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|symtab
operator|=
name|find_line_symtab
argument_list|(
name|symtab
argument_list|,
name|line
argument_list|,
operator|&
name|ind
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|symtab
operator|!=
name|NULL
condition|)
block|{
name|l
operator|=
name|LINETABLE
argument_list|(
name|symtab
argument_list|)
expr_stmt|;
operator|*
name|pc
operator|=
name|l
operator|->
name|item
index|[
name|ind
index|]
operator|.
name|pc
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Find the range of pc values in a line.    Store the starting pc of the line into *STARTPTR    and the ending pc (start of next line) into *ENDPTR.    Returns 1 to indicate success.    Returns 0 if could not find the specified line.  */
end_comment

begin_function
name|int
name|find_line_pc_range
parameter_list|(
name|sal
parameter_list|,
name|startptr
parameter_list|,
name|endptr
parameter_list|)
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|CORE_ADDR
modifier|*
name|startptr
decl_stmt|,
decl|*
name|endptr
decl_stmt|;
end_function

begin_block
block|{
name|CORE_ADDR
name|startaddr
decl_stmt|;
name|struct
name|symtab_and_line
name|found_sal
decl_stmt|;
name|startaddr
operator|=
name|sal
operator|.
name|pc
expr_stmt|;
if|if
condition|(
name|startaddr
operator|==
literal|0
operator|&&
operator|!
name|find_line_pc
argument_list|(
name|sal
operator|.
name|symtab
argument_list|,
name|sal
operator|.
name|line
argument_list|,
operator|&
name|startaddr
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* This whole function is based on address.  For example, if line 10 has      two parts, one from 0x100 to 0x200 and one from 0x300 to 0x400, then      "info line *0x123" should say the line goes from 0x100 to 0x200      and "info line *0x355" should say the line goes from 0x300 to 0x400.      This also insures that we never give a range like "starts at 0x134      and ends at 0x12c".  */
name|found_sal
operator|=
name|find_pc_sect_line
argument_list|(
name|startaddr
argument_list|,
name|sal
operator|.
name|section
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|found_sal
operator|.
name|line
operator|!=
name|sal
operator|.
name|line
condition|)
block|{
comment|/* The specified line (sal) has zero bytes.  */
operator|*
name|startptr
operator|=
name|found_sal
operator|.
name|pc
expr_stmt|;
operator|*
name|endptr
operator|=
name|found_sal
operator|.
name|pc
expr_stmt|;
block|}
else|else
block|{
operator|*
name|startptr
operator|=
name|found_sal
operator|.
name|pc
expr_stmt|;
operator|*
name|endptr
operator|=
name|found_sal
operator|.
name|end
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_block

begin_comment
comment|/* Given a line table and a line number, return the index into the line    table for the pc of the nearest line whose number is>= the specified one.    Return -1 if none is found.  The value is>= 0 if it is an index.     Set *EXACT_MATCH nonzero if the value returned is an exact match.  */
end_comment

begin_function
specifier|static
name|int
name|find_line_common
parameter_list|(
name|l
parameter_list|,
name|lineno
parameter_list|,
name|exact_match
parameter_list|)
specifier|register
name|struct
name|linetable
modifier|*
name|l
decl_stmt|;
specifier|register
name|int
name|lineno
decl_stmt|;
name|int
modifier|*
name|exact_match
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
comment|/* BEST is the smallest linenumber> LINENO so far seen,      or 0 if none has been seen so far.      BEST_INDEX identifies the item for it.  */
name|int
name|best_index
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|best
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|lineno
operator|<=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|l
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|len
operator|=
name|l
operator|->
name|nitems
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|struct
name|linetable_entry
modifier|*
name|item
init|=
operator|&
operator|(
name|l
operator|->
name|item
index|[
name|i
index|]
operator|)
decl_stmt|;
if|if
condition|(
name|item
operator|->
name|line
operator|==
name|lineno
condition|)
block|{
comment|/* Return the first (lowest address) entry which matches.  */
operator|*
name|exact_match
operator|=
literal|1
expr_stmt|;
return|return
name|i
return|;
block|}
if|if
condition|(
name|item
operator|->
name|line
operator|>
name|lineno
operator|&&
operator|(
name|best
operator|==
literal|0
operator|||
name|item
operator|->
name|line
operator|<
name|best
operator|)
condition|)
block|{
name|best
operator|=
name|item
operator|->
name|line
expr_stmt|;
name|best_index
operator|=
name|i
expr_stmt|;
block|}
block|}
comment|/* If we got here, we didn't get an exact match.  */
operator|*
name|exact_match
operator|=
literal|0
expr_stmt|;
return|return
name|best_index
return|;
block|}
end_function

begin_function
name|int
name|find_pc_line_pc_range
parameter_list|(
name|pc
parameter_list|,
name|startptr
parameter_list|,
name|endptr
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
name|CORE_ADDR
modifier|*
name|startptr
decl_stmt|,
decl|*
name|endptr
decl_stmt|;
end_function

begin_block
block|{
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|sal
operator|=
name|find_pc_line
argument_list|(
name|pc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|startptr
operator|=
name|sal
operator|.
name|pc
expr_stmt|;
operator|*
name|endptr
operator|=
name|sal
operator|.
name|end
expr_stmt|;
return|return
name|sal
operator|.
name|symtab
operator|!=
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Given a function symbol SYM, find the symtab and line for the start    of the function.    If the argument FUNFIRSTLINE is nonzero, we want the first line    of real code inside the function.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|symtab_and_line
name|find_function_start_sal
name|PARAMS
argument_list|(
operator|(
expr|struct
name|symbol
operator|*
name|sym
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|struct
name|symtab_and_line
name|find_function_start_sal
parameter_list|(
name|sym
parameter_list|,
name|funfirstline
parameter_list|)
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|int
name|funfirstline
decl_stmt|;
block|{
name|CORE_ADDR
name|pc
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|pc
operator|=
name|BLOCK_START
argument_list|(
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|fixup_symbol_section
argument_list|(
name|sym
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|funfirstline
condition|)
block|{
comment|/* skip "first line" of function (which is actually its prologue) */
name|asection
modifier|*
name|section
init|=
name|SYMBOL_BFD_SECTION
argument_list|(
name|sym
argument_list|)
decl_stmt|;
comment|/* If function is in an unmapped overlay, use its unmapped LMA 	 address, so that SKIP_PROLOGUE has something unique to work on */
if|if
condition|(
name|section_is_overlay
argument_list|(
name|section
argument_list|)
operator|&&
operator|!
name|section_is_mapped
argument_list|(
name|section
argument_list|)
condition|)
name|pc
operator|=
name|overlay_unmapped_address
argument_list|(
name|pc
argument_list|,
name|section
argument_list|)
expr_stmt|;
name|pc
operator|+=
name|FUNCTION_START_OFFSET
expr_stmt|;
name|SKIP_PROLOGUE
argument_list|(
name|pc
argument_list|)
expr_stmt|;
comment|/* For overlays, map pc back into its mapped VMA range */
name|pc
operator|=
name|overlay_mapped_address
argument_list|(
name|pc
argument_list|,
name|section
argument_list|)
expr_stmt|;
block|}
name|sal
operator|=
name|find_pc_sect_line
argument_list|(
name|pc
argument_list|,
name|SYMBOL_BFD_SECTION
argument_list|(
name|sym
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PROLOGUE_FIRSTLINE_OVERLAP
comment|/* Convex: no need to suppress code on first line, if any */
name|sal
operator|.
name|pc
operator|=
name|pc
expr_stmt|;
else|#
directive|else
comment|/* Check if SKIP_PROLOGUE left us in mid-line, and the next      line is still part of the same function.  */
if|if
condition|(
name|sal
operator|.
name|pc
operator|!=
name|pc
operator|&&
name|BLOCK_START
argument_list|(
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|<=
name|sal
operator|.
name|end
operator|&&
name|sal
operator|.
name|end
operator|<
name|BLOCK_END
argument_list|(
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|sym
argument_list|)
argument_list|)
condition|)
block|{
comment|/* First pc of next line */
name|pc
operator|=
name|sal
operator|.
name|end
expr_stmt|;
comment|/* Recalculate the line number (might not be N+1).  */
name|sal
operator|=
name|find_pc_sect_line
argument_list|(
name|pc
argument_list|,
name|SYMBOL_BFD_SECTION
argument_list|(
name|sym
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|sal
operator|.
name|pc
operator|=
name|pc
expr_stmt|;
endif|#
directive|endif
return|return
name|sal
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If P is of the form "operator[ \t]+..." where `...' is    some legitimate operator text, return a pointer to the    beginning of the substring of the operator text.    Otherwise, return "".  */
end_comment

begin_function
name|char
modifier|*
name|operator_chars
parameter_list|(
name|p
parameter_list|,
name|end
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
modifier|*
name|end
decl_stmt|;
block|{
operator|*
name|end
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"operator"
argument_list|,
literal|8
argument_list|)
condition|)
return|return
operator|*
name|end
return|;
name|p
operator|+=
literal|8
expr_stmt|;
comment|/* Don't get faked out by `operator' being part of a longer      identifier.  */
if|if
condition|(
name|isalpha
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|'_'
operator|||
operator|*
name|p
operator|==
literal|'$'
operator|||
operator|*
name|p
operator|==
literal|'\0'
condition|)
return|return
operator|*
name|end
return|;
comment|/* Allow some whitespace between `operator' and the operator symbol.  */
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
comment|/* Recognize 'operator TYPENAME'. */
if|if
condition|(
name|isalpha
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|'_'
operator|||
operator|*
name|p
operator|==
literal|'$'
condition|)
block|{
specifier|register
name|char
modifier|*
name|q
init|=
name|p
operator|+
literal|1
decl_stmt|;
while|while
condition|(
name|isalnum
argument_list|(
operator|*
name|q
argument_list|)
operator|||
operator|*
name|q
operator|==
literal|'_'
operator|||
operator|*
name|q
operator|==
literal|'$'
condition|)
name|q
operator|++
expr_stmt|;
operator|*
name|end
operator|=
name|q
expr_stmt|;
return|return
name|p
return|;
block|}
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'!'
case|:
case|case
literal|'='
case|:
case|case
literal|'*'
case|:
case|case
literal|'/'
case|:
case|case
literal|'%'
case|:
case|case
literal|'^'
case|:
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'='
condition|)
operator|*
name|end
operator|=
name|p
operator|+
literal|2
expr_stmt|;
else|else
operator|*
name|end
operator|=
name|p
operator|+
literal|1
expr_stmt|;
return|return
name|p
return|;
case|case
literal|'<'
case|:
case|case
literal|'>'
case|:
case|case
literal|'+'
case|:
case|case
literal|'-'
case|:
case|case
literal|'&'
case|:
case|case
literal|'|'
case|:
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'='
operator|||
name|p
index|[
literal|1
index|]
operator|==
name|p
index|[
literal|0
index|]
condition|)
operator|*
name|end
operator|=
name|p
operator|+
literal|2
expr_stmt|;
else|else
operator|*
name|end
operator|=
name|p
operator|+
literal|1
expr_stmt|;
return|return
name|p
return|;
case|case
literal|'~'
case|:
case|case
literal|','
case|:
operator|*
name|end
operator|=
name|p
operator|+
literal|1
expr_stmt|;
return|return
name|p
return|;
case|case
literal|'('
case|:
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|!=
literal|')'
condition|)
name|error
argument_list|(
literal|"`operator ()' must be specified without whitespace in `()'"
argument_list|)
expr_stmt|;
operator|*
name|end
operator|=
name|p
operator|+
literal|2
expr_stmt|;
return|return
name|p
return|;
case|case
literal|'?'
case|:
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|!=
literal|':'
condition|)
name|error
argument_list|(
literal|"`operator ?:' must be specified without whitespace in `?:'"
argument_list|)
expr_stmt|;
operator|*
name|end
operator|=
name|p
operator|+
literal|2
expr_stmt|;
return|return
name|p
return|;
case|case
literal|'['
case|:
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|!=
literal|']'
condition|)
name|error
argument_list|(
literal|"`operator []' must be specified without whitespace in `[]'"
argument_list|)
expr_stmt|;
operator|*
name|end
operator|=
name|p
operator|+
literal|2
expr_stmt|;
return|return
name|p
return|;
default|default:
name|error
argument_list|(
literal|"`operator %s' not supported"
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
operator|*
name|end
operator|=
literal|""
expr_stmt|;
return|return
operator|*
name|end
return|;
block|}
end_function

begin_comment
comment|/* Return the number of methods described for TYPE, including the    methods from types it derives from. This can't be done in the symbol    reader because the type of the baseclass might still be stubbed    when the definition of the derived class is parsed.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|total_number_of_methods
name|PARAMS
argument_list|(
operator|(
expr|struct
name|type
operator|*
name|type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|total_number_of_methods
parameter_list|(
name|type
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
name|int
name|count
decl_stmt|;
name|CHECK_TYPEDEF
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CPLUS_SPECIFIC
argument_list|(
name|type
argument_list|)
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|count
operator|=
name|TYPE_NFN_FIELDS_TOTAL
argument_list|(
name|type
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
condition|;
name|n
operator|++
control|)
name|count
operator|+=
name|total_number_of_methods
argument_list|(
name|TYPE_BASECLASS
argument_list|(
name|type
argument_list|,
name|n
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|count
return|;
block|}
end_function

begin_comment
comment|/* Recursive helper function for decode_line_1.    Look for methods named NAME in type T.    Return number of matches.    Put matches in SYM_ARR, which should have been allocated with    a size of total_number_of_methods (T) * sizeof (struct symbol *).    Note that this function is g++ specific.  */
end_comment

begin_function
specifier|static
name|int
name|find_methods
parameter_list|(
name|t
parameter_list|,
name|name
parameter_list|,
name|sym_arr
parameter_list|)
name|struct
name|type
modifier|*
name|t
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|symbol
modifier|*
modifier|*
name|sym_arr
decl_stmt|;
block|{
name|int
name|i1
init|=
literal|0
decl_stmt|;
name|int
name|ibase
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym_class
decl_stmt|;
name|char
modifier|*
name|class_name
init|=
name|type_name_no_tag
argument_list|(
name|t
argument_list|)
decl_stmt|;
comment|/* Ignore this class if it doesn't have a name.  This is ugly, but      unless we figure out how to get the physname without the name of      the class, then the loop can't do any good.  */
if|if
condition|(
name|class_name
operator|&&
operator|(
name|sym_class
operator|=
name|lookup_symbol
argument_list|(
name|class_name
argument_list|,
operator|(
expr|struct
name|block
operator|*
operator|)
name|NULL
argument_list|,
name|STRUCT_NAMESPACE
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
operator|(
expr|struct
name|symtab
operator|*
operator|*
operator|)
name|NULL
argument_list|)
operator|)
condition|)
block|{
name|int
name|method_counter
decl_stmt|;
comment|/* FIXME: Shouldn't this just be CHECK_TYPEDEF (t)?  */
name|t
operator|=
name|SYMBOL_TYPE
argument_list|(
name|sym_class
argument_list|)
expr_stmt|;
comment|/* Loop over each method name.  At this level, all overloads of a name 	 are counted as a single name.  There is an inner loop which loops over 	 each overload.  */
for|for
control|(
name|method_counter
operator|=
name|TYPE_NFN_FIELDS
argument_list|(
name|t
argument_list|)
operator|-
literal|1
init|;
name|method_counter
operator|>=
literal|0
condition|;
operator|--
name|method_counter
control|)
block|{
name|int
name|field_counter
decl_stmt|;
name|char
modifier|*
name|method_name
init|=
name|TYPE_FN_FIELDLIST_NAME
argument_list|(
name|t
argument_list|,
name|method_counter
argument_list|)
decl_stmt|;
name|char
name|dem_opname
index|[
literal|64
index|]
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|method_name
argument_list|,
literal|"__"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|method_name
argument_list|,
literal|"op"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|method_name
argument_list|,
literal|"type"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|cplus_demangle_opname
argument_list|(
name|method_name
argument_list|,
name|dem_opname
argument_list|,
name|DMGL_ANSI
argument_list|)
condition|)
name|method_name
operator|=
name|dem_opname
expr_stmt|;
elseif|else
if|if
condition|(
name|cplus_demangle_opname
argument_list|(
name|method_name
argument_list|,
name|dem_opname
argument_list|,
literal|0
argument_list|)
condition|)
name|method_name
operator|=
name|dem_opname
expr_stmt|;
block|}
if|if
condition|(
name|STREQ
argument_list|(
name|name
argument_list|,
name|method_name
argument_list|)
condition|)
comment|/* Find all the overloaded methods with that name.  */
for|for
control|(
name|field_counter
operator|=
name|TYPE_FN_FIELDLIST_LENGTH
argument_list|(
name|t
argument_list|,
name|method_counter
argument_list|)
operator|-
literal|1
init|;
name|field_counter
operator|>=
literal|0
condition|;
operator|--
name|field_counter
control|)
block|{
name|struct
name|fn_field
modifier|*
name|f
decl_stmt|;
name|char
modifier|*
name|phys_name
decl_stmt|;
name|f
operator|=
name|TYPE_FN_FIELDLIST1
argument_list|(
name|t
argument_list|,
name|method_counter
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_FN_FIELD_STUB
argument_list|(
name|f
argument_list|,
name|field_counter
argument_list|)
condition|)
block|{
name|char
modifier|*
name|tmp_name
decl_stmt|;
name|tmp_name
operator|=
name|gdb_mangle_name
argument_list|(
name|t
argument_list|,
name|method_counter
argument_list|,
name|field_counter
argument_list|)
expr_stmt|;
name|phys_name
operator|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|tmp_name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|phys_name
argument_list|,
name|tmp_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp_name
argument_list|)
expr_stmt|;
block|}
else|else
name|phys_name
operator|=
name|TYPE_FN_FIELD_PHYSNAME
argument_list|(
name|f
argument_list|,
name|field_counter
argument_list|)
expr_stmt|;
comment|/* Destructor is handled by caller, dont add it to the list */
if|if
condition|(
name|DESTRUCTOR_PREFIX_P
argument_list|(
name|phys_name
argument_list|)
condition|)
continue|continue;
name|sym_arr
index|[
name|i1
index|]
operator|=
name|lookup_symbol
argument_list|(
name|phys_name
argument_list|,
name|NULL
argument_list|,
name|VAR_NAMESPACE
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
operator|(
expr|struct
name|symtab
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym_arr
index|[
name|i1
index|]
condition|)
name|i1
operator|++
expr_stmt|;
else|else
block|{
comment|/* This error message gets printed, but the method 		       still seems to be found 		       fputs_filtered("(Cannot find method ", gdb_stdout); 		       fprintf_symbol_filtered (gdb_stdout, phys_name, 		       language_cplus, 		       DMGL_PARAMS | DMGL_ANSI); 		       fputs_filtered(" - possibly inlined.)\n", gdb_stdout); 		       */
block|}
block|}
block|}
block|}
comment|/* Only search baseclasses if there is no match yet, since names in      derived classes override those in baseclasses.       FIXME: The above is not true; it is only true of member functions      if they have the same number of arguments (??? - section 13.1 of the      ARM says the function members are not in the same scope but doesn't      really spell out the rules in a way I understand.  In any case, if      the number of arguments differ this is a case in which we can overload      rather than hiding without any problem, and gcc 2.4.5 does overload      rather than hiding in this case).  */
if|if
condition|(
name|i1
operator|==
literal|0
condition|)
for|for
control|(
name|ibase
operator|=
literal|0
init|;
name|ibase
operator|<
name|TYPE_N_BASECLASSES
argument_list|(
name|t
argument_list|)
condition|;
name|ibase
operator|++
control|)
name|i1
operator|+=
name|find_methods
argument_list|(
name|TYPE_BASECLASS
argument_list|(
name|t
argument_list|,
name|ibase
argument_list|)
argument_list|,
name|name
argument_list|,
name|sym_arr
operator|+
name|i1
argument_list|)
expr_stmt|;
return|return
name|i1
return|;
block|}
end_function

begin_comment
comment|/* Helper function for decode_line_1.    Build a canonical line spec in CANONICAL if it is non-NULL and if    the SAL has a symtab.    If SYMNAME is non-NULL the canonical line spec is `filename:symname'.    If SYMNAME is NULL the line number from SAL is used and the canonical    line spec is `filename:linenum'.  */
end_comment

begin_function
specifier|static
name|void
name|build_canonical_line_spec
parameter_list|(
name|sal
parameter_list|,
name|symname
parameter_list|,
name|canonical
parameter_list|)
name|struct
name|symtab_and_line
modifier|*
name|sal
decl_stmt|;
name|char
modifier|*
name|symname
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|canonical
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|canonical_arr
decl_stmt|;
name|char
modifier|*
name|canonical_name
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|struct
name|symtab
modifier|*
name|s
init|=
name|sal
operator|->
name|symtab
decl_stmt|;
if|if
condition|(
name|s
operator|==
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|NULL
operator|||
name|s
operator|->
name|filename
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
operator|||
name|canonical
operator|==
operator|(
name|char
operator|*
operator|*
operator|*
operator|)
name|NULL
condition|)
return|return;
name|canonical_arr
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|canonical
operator|=
name|canonical_arr
expr_stmt|;
name|filename
operator|=
name|s
operator|->
name|filename
expr_stmt|;
if|if
condition|(
name|symname
operator|!=
name|NULL
condition|)
block|{
name|canonical_name
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|filename
argument_list|)
operator|+
name|strlen
argument_list|(
name|symname
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|canonical_name
argument_list|,
literal|"%s:%s"
argument_list|,
name|filename
argument_list|,
name|symname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|canonical_name
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|filename
argument_list|)
operator|+
literal|30
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|canonical_name
argument_list|,
literal|"%s:%d"
argument_list|,
name|filename
argument_list|,
name|sal
operator|->
name|line
argument_list|)
expr_stmt|;
block|}
name|canonical_arr
index|[
literal|0
index|]
operator|=
name|canonical_name
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse a string that specifies a line number.    Pass the address of a char * variable; that variable will be    advanced over the characters actually parsed.     The string can be:     LINENUM -- that line number in current file.  PC returned is 0.    FILE:LINENUM -- that line in that file.  PC returned is 0.    FUNCTION -- line number of openbrace of that function.       PC returned is the start of the function.    VARIABLE -- line number of definition of that variable.       PC returned is 0.    FILE:FUNCTION -- likewise, but prefer functions in that file.    *EXPR -- line in which address EXPR appears.     FUNCTION may be an undebuggable function found in minimal symbol table.     If the argument FUNFIRSTLINE is nonzero, we want the first line    of real code inside a function when a function is specified, and it is    not OK to specify a variable or type to get its line number.     DEFAULT_SYMTAB specifies the file to use if none is specified.    It defaults to current_source_symtab.    DEFAULT_LINE specifies the line number to use for relative    line numbers (that start with signs).  Defaults to current_source_line.    If CANONICAL is non-NULL, store an array of strings containing the canonical    line specs there if necessary. Currently overloaded member functions and    line numbers or static functions without a filename yield a canonical    line spec. The array and the line spec strings are allocated on the heap,    it is the callers responsibility to free them.     Note that it is possible to return zero for the symtab    if no file is validly specified.  Callers must check that.    Also, the line number returned may be invalid.  */
end_comment

begin_comment
comment|/* We allow single quotes in various places.  This is a hideous    kludge, which exists because the completer can't yet deal with the    lack of single quotes.  FIXME: write a linespec_completer which we    can use as appropriate instead of make_symbol_completion_list.  */
end_comment

begin_function
name|struct
name|symtabs_and_lines
name|decode_line_1
parameter_list|(
name|argptr
parameter_list|,
name|funfirstline
parameter_list|,
name|default_symtab
parameter_list|,
name|default_line
parameter_list|,
name|canonical
parameter_list|)
name|char
modifier|*
modifier|*
name|argptr
decl_stmt|;
name|int
name|funfirstline
decl_stmt|;
name|struct
name|symtab
modifier|*
name|default_symtab
decl_stmt|;
name|int
name|default_line
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|canonical
decl_stmt|;
block|{
name|struct
name|symtabs_and_lines
name|values
decl_stmt|;
ifdef|#
directive|ifdef
name|HPPA_COMPILER_BUG
comment|/* FIXME: The native HP 9000/700 compiler has a bug which appears      when optimizing this file with target i960-vxworks.  I haven't      been able to construct a simple test case.  The problem is that      in the second call to SKIP_PROLOGUE below, the compiler somehow      does not realize that the statement val = find_pc_line (...) will      change the values of the fields of val.  It extracts the elements      into registers at the top of the block, and does not update the      registers after the call to find_pc_line.  You can check this by      inserting a printf at the end of find_pc_line to show what values      it is returning for val.pc and val.end and another printf after      the call to see what values the function actually got (remember,      this is compiling with cc -O, with this patch removed).  You can      also examine the assembly listing: search for the second call to      skip_prologue; the LDO statement before the next call to      find_pc_line loads the address of the structure which      find_pc_line will return; if there is a LDW just before the LDO,      which fetches an element of the structure, then the compiler      still has the bug.       Setting val to volatile avoids the problem.  We must undef      volatile, because the HPPA native compiler does not define      __STDC__, although it does understand volatile, and so volatile      will have been defined away in defs.h.  */
undef|#
directive|undef
name|volatile
specifier|volatile
name|struct
name|symtab_and_line
name|val
decl_stmt|;
define|#
directive|define
name|volatile
comment|/*nothing*/
else|#
directive|else
name|struct
name|symtab_and_line
name|val
decl_stmt|;
endif|#
directive|endif
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|p1
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|,
modifier|*
name|pp
decl_stmt|,
modifier|*
name|ii
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
if|#
directive|if
literal|0
block|char *q1;
endif|#
directive|endif
specifier|register
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
specifier|register
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
comment|/* The symtab that SYM was found in.  */
name|struct
name|symtab
modifier|*
name|sym_symtab
decl_stmt|;
specifier|register
name|CORE_ADDR
name|pc
decl_stmt|;
specifier|register
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
name|char
modifier|*
name|copy
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym_class
decl_stmt|;
name|int
name|i1
decl_stmt|;
name|int
name|is_quoted
decl_stmt|;
name|int
name|has_parens
decl_stmt|;
name|int
name|has_if
init|=
literal|0
decl_stmt|;
name|struct
name|symbol
modifier|*
modifier|*
name|sym_arr
decl_stmt|;
name|struct
name|type
modifier|*
name|t
decl_stmt|;
name|char
modifier|*
name|saved_arg
init|=
operator|*
name|argptr
decl_stmt|;
specifier|extern
name|char
modifier|*
name|gdb_completer_quote_characters
decl_stmt|;
name|INIT_SAL
argument_list|(
operator|&
name|val
argument_list|)
expr_stmt|;
comment|/* initialize to zeroes */
comment|/* Defaults have defaults.  */
if|if
condition|(
name|default_symtab
operator|==
literal|0
condition|)
block|{
name|default_symtab
operator|=
name|current_source_symtab
expr_stmt|;
name|default_line
operator|=
name|current_source_line
expr_stmt|;
block|}
comment|/* See if arg is *PC */
if|if
condition|(
operator|*
operator|*
name|argptr
operator|==
literal|'*'
condition|)
block|{
operator|(
operator|*
name|argptr
operator|)
operator|++
expr_stmt|;
name|pc
operator|=
name|parse_and_eval_address_1
argument_list|(
name|argptr
argument_list|)
expr_stmt|;
name|values
operator|.
name|sals
operator|=
operator|(
expr|struct
name|symtab_and_line
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|symtab_and_line
argument_list|)
argument_list|)
expr_stmt|;
name|values
operator|.
name|nelts
operator|=
literal|1
expr_stmt|;
name|values
operator|.
name|sals
index|[
literal|0
index|]
operator|=
name|find_pc_line
argument_list|(
name|pc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|values
operator|.
name|sals
index|[
literal|0
index|]
operator|.
name|pc
operator|=
name|pc
expr_stmt|;
name|values
operator|.
name|sals
index|[
literal|0
index|]
operator|.
name|section
operator|=
name|find_pc_overlay
argument_list|(
name|pc
argument_list|)
expr_stmt|;
return|return
name|values
return|;
block|}
comment|/* 'has_if' is for the syntax:    *     (gdb) break foo if (a==b)    */
if|if
condition|(
operator|(
name|ii
operator|=
name|strstr
argument_list|(
operator|*
name|argptr
argument_list|,
literal|" if "
argument_list|)
operator|)
operator|!=
name|NULL
operator|||
operator|(
name|ii
operator|=
name|strstr
argument_list|(
operator|*
name|argptr
argument_list|,
literal|"\tif "
argument_list|)
operator|)
operator|!=
name|NULL
operator|||
operator|(
name|ii
operator|=
name|strstr
argument_list|(
operator|*
name|argptr
argument_list|,
literal|" if\t"
argument_list|)
operator|)
operator|!=
name|NULL
operator|||
operator|(
name|ii
operator|=
name|strstr
argument_list|(
operator|*
name|argptr
argument_list|,
literal|"\tif\t"
argument_list|)
operator|)
operator|!=
name|NULL
operator|||
operator|(
name|ii
operator|=
name|strstr
argument_list|(
operator|*
name|argptr
argument_list|,
literal|" if("
argument_list|)
operator|)
operator|!=
name|NULL
operator|||
operator|(
name|ii
operator|=
name|strstr
argument_list|(
operator|*
name|argptr
argument_list|,
literal|"\tif( "
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|has_if
operator|=
literal|1
expr_stmt|;
comment|/* Temporarily zap out "if (condition)" to not    * confuse the parenthesis-checking code below.    * This is undone below. Do not change ii!!    */
if|if
condition|(
name|has_if
condition|)
block|{
operator|*
name|ii
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* Set various flags.    * 'has_parens' is important for overload checking, where    * we allow things like:     *     (gdb) break c::f(int)    */
comment|/* Maybe arg is FILE : LINENUM or FILE : FUNCTION */
name|is_quoted
operator|=
operator|(
operator|*
operator|*
name|argptr
operator|&&
name|strchr
argument_list|(
name|gdb_completer_quote_characters
argument_list|,
operator|*
operator|*
name|argptr
argument_list|)
operator|!=
name|NULL
operator|)
expr_stmt|;
name|has_parens
operator|=
operator|(
operator|(
name|pp
operator|=
name|strchr
argument_list|(
operator|*
name|argptr
argument_list|,
literal|'('
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|(
name|pp
operator|=
name|strchr
argument_list|(
name|pp
argument_list|,
literal|')'
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
expr_stmt|;
comment|/* Now that we're safely past the has_parens check,    * put back " if (condition)" so outer layers can see it     */
if|if
condition|(
name|has_if
condition|)
operator|*
name|ii
operator|=
literal|' '
expr_stmt|;
comment|/* Maybe arg is FILE : LINENUM or FILE : FUNCTION */
comment|/* May also be CLASS::MEMBER, or NAMESPACE::NAME */
comment|/* Look for ':', but ignore inside of<> */
name|s
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|*
name|argptr
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'<'
condition|)
block|{
name|char
modifier|*
name|temp_end
init|=
name|find_template_name_end
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|temp_end
condition|)
name|error
argument_list|(
literal|"malformed template specification in command"
argument_list|)
expr_stmt|;
name|p
operator|=
name|temp_end
expr_stmt|;
block|}
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|':'
operator|||
name|p
index|[
literal|0
index|]
operator|==
literal|' '
operator|||
name|p
index|[
literal|0
index|]
operator|==
literal|'\t'
operator|||
operator|!
operator|*
name|p
condition|)
break|break;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|strchr
argument_list|(
name|p
argument_list|,
literal|':'
argument_list|)
operator|==
name|NULL
condition|)
comment|/* Java qualified method. */
block|{
comment|/* Find the *last* '.', since the others are package qualifiers. */
for|for
control|(
name|p1
operator|=
name|p
init|;
operator|*
name|p1
condition|;
name|p1
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p1
operator|==
literal|'.'
condition|)
name|p
operator|=
name|p1
expr_stmt|;
block|}
break|break;
block|}
block|}
while|while
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|' '
operator|||
name|p
index|[
literal|0
index|]
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|p
index|[
literal|0
index|]
operator|==
literal|':'
operator|||
name|p
index|[
literal|0
index|]
operator|==
literal|'.'
operator|)
operator|&&
operator|!
name|has_parens
condition|)
block|{
comment|/*  C++ */
comment|/*  ... or Java */
if|if
condition|(
name|is_quoted
condition|)
operator|*
name|argptr
operator|=
operator|*
name|argptr
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'.'
operator|||
name|p
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
block|{
name|int
name|ix
decl_stmt|;
name|char
modifier|*
name|saved_arg2
init|=
operator|*
name|argptr
decl_stmt|;
name|char
modifier|*
name|temp_end
decl_stmt|;
comment|/* First check for "global" namespace specification,              of the form "::foo". If found, skip over the colons              and jump to normal symbol processing */
if|if
condition|(
operator|(
operator|*
name|argptr
operator|==
name|p
operator|)
operator|||
operator|(
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
operator|)
operator|||
operator|(
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'\t'
operator|)
condition|)
name|saved_arg2
operator|+=
literal|2
expr_stmt|;
comment|/* We have what looks like a class or namespace              scope specification (A::B), possibly with many              levels of namespaces or classes (A::B::C::D).               Some versions of the HP ANSI C++ compiler (as also possibly              other compilers) generate class/function/member names with              embedded double-colons if they are inside namespaces. To              handle this, we loop a few times, considering larger and              larger prefixes of the string as though they were single              symbols.  So, if the initially supplied string is              A::B::C::D::foo, we have to look up "A", then "A::B",              then "A::B::C", then "A::B::C::D", and finally              "A::B::C::D::foo" as single, monolithic symbols, because              A, B, C or D may be namespaces.               Note that namespaces can nest only inside other              namespaces, and not inside classes.  So we need only              consider *prefixes* of the string; there is no need to look up              "B::C" separately as a symbol in the previous example. */
name|p2
operator|=
name|p
expr_stmt|;
comment|/* save for restart */
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Extract the class name.  */
name|p1
operator|=
name|p
expr_stmt|;
while|while
condition|(
name|p
operator|!=
operator|*
name|argptr
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
operator|--
name|p
expr_stmt|;
name|copy
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|p
operator|-
operator|*
name|argptr
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|copy
argument_list|,
operator|*
name|argptr
argument_list|,
name|p
operator|-
operator|*
name|argptr
argument_list|)
expr_stmt|;
name|copy
index|[
name|p
operator|-
operator|*
name|argptr
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Discard the class name from the arg.  */
name|p
operator|=
name|p1
operator|+
operator|(
name|p1
index|[
literal|0
index|]
operator|==
literal|':'
condition|?
literal|2
else|:
literal|1
operator|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
operator|*
name|argptr
operator|=
name|p
expr_stmt|;
name|sym_class
operator|=
name|lookup_symbol
argument_list|(
name|copy
argument_list|,
literal|0
argument_list|,
name|STRUCT_NAMESPACE
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|symtab
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym_class
operator|&&
operator|(
name|t
operator|=
name|check_typedef
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym_class
argument_list|)
argument_list|)
operator|,
operator|(
name|TYPE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
operator|||
name|TYPE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_CODE_UNION
operator|)
operator|)
condition|)
block|{
comment|/* Arg token is not digits => try it as a function name 		    Find the next token(everything up to end or next blank). */
if|if
condition|(
operator|*
operator|*
name|argptr
operator|&&
name|strchr
argument_list|(
name|gdb_completer_quote_characters
argument_list|,
operator|*
operator|*
name|argptr
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|p
operator|=
name|skip_quoted
argument_list|(
operator|*
name|argptr
argument_list|)
expr_stmt|;
operator|*
name|argptr
operator|=
operator|*
name|argptr
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
operator|*
name|argptr
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|' '
operator|&&
operator|*
name|p
operator|!=
literal|'\t'
operator|&&
operator|*
name|p
operator|!=
literal|','
operator|&&
operator|*
name|p
operator|!=
literal|':'
condition|)
name|p
operator|++
expr_stmt|;
block|}
comment|/* 	      q = operator_chars (*argptr,&q1); 	      if (q1 - q) 		{ 		  char *opname; 		  char *tmp = alloca (q1 - q + 1); 		  memcpy (tmp, q, q1 - q); 		  tmp[q1 - q] = '\0'; 		  opname = cplus_mangle_opname (tmp, DMGL_ANSI); 		  if (opname == NULL) 		    { 		      error_begin (); 		      printf_filtered ("no mangling for \"%s\"\n", tmp); 		      cplusplus_hint (saved_arg); 		      return_to_top_level (RETURN_ERROR); 		    } 		  copy = (char*) alloca (3 + strlen(opname)); 		  sprintf (copy, "__%s", opname); 		  p = q1; 		} 	      else */
block|{
name|copy
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|p
operator|-
operator|*
name|argptr
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|copy
argument_list|,
operator|*
name|argptr
argument_list|,
name|p
operator|-
operator|*
name|argptr
argument_list|)
expr_stmt|;
name|copy
index|[
name|p
operator|-
operator|*
name|argptr
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|p
operator|!=
operator|*
name|argptr
operator|&&
name|copy
index|[
name|p
operator|-
operator|*
name|argptr
operator|-
literal|1
index|]
operator|&&
name|strchr
argument_list|(
name|gdb_completer_quote_characters
argument_list|,
name|copy
index|[
name|p
operator|-
operator|*
name|argptr
operator|-
literal|1
index|]
argument_list|)
operator|!=
name|NULL
condition|)
name|copy
index|[
name|p
operator|-
operator|*
name|argptr
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* no line number may be specified */
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
operator|*
name|argptr
operator|=
name|p
expr_stmt|;
name|sym
operator|=
literal|0
expr_stmt|;
name|i1
operator|=
literal|0
expr_stmt|;
comment|/*  counter for the symbol array */
name|sym_arr
operator|=
operator|(
expr|struct
name|symbol
operator|*
operator|*
operator|)
name|alloca
argument_list|(
name|total_number_of_methods
argument_list|(
name|t
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|destructor_name_p
argument_list|(
name|copy
argument_list|,
name|t
argument_list|)
condition|)
block|{
comment|/* Destructors are a special case.  */
name|int
name|m_index
decl_stmt|,
name|f_index
decl_stmt|;
if|if
condition|(
name|get_destructor_fn_field
argument_list|(
name|t
argument_list|,
operator|&
name|m_index
argument_list|,
operator|&
name|f_index
argument_list|)
condition|)
block|{
name|struct
name|fn_field
modifier|*
name|f
init|=
name|TYPE_FN_FIELDLIST1
argument_list|(
name|t
argument_list|,
name|m_index
argument_list|)
decl_stmt|;
name|sym_arr
index|[
name|i1
index|]
operator|=
name|lookup_symbol
argument_list|(
name|TYPE_FN_FIELD_PHYSNAME
argument_list|(
name|f
argument_list|,
name|f_index
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|VAR_NAMESPACE
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
operator|(
expr|struct
name|symtab
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym_arr
index|[
name|i1
index|]
condition|)
name|i1
operator|++
expr_stmt|;
block|}
block|}
else|else
name|i1
operator|=
name|find_methods
argument_list|(
name|t
argument_list|,
name|copy
argument_list|,
name|sym_arr
argument_list|)
expr_stmt|;
if|if
condition|(
name|i1
operator|==
literal|1
condition|)
block|{
comment|/* There is exactly one field with that name.  */
name|sym
operator|=
name|sym_arr
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|sym
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_BLOCK
condition|)
block|{
name|values
operator|.
name|sals
operator|=
operator|(
expr|struct
name|symtab_and_line
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|symtab_and_line
argument_list|)
argument_list|)
expr_stmt|;
name|values
operator|.
name|nelts
operator|=
literal|1
expr_stmt|;
name|values
operator|.
name|sals
index|[
literal|0
index|]
operator|=
name|find_function_start_sal
argument_list|(
name|sym
argument_list|,
name|funfirstline
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|values
operator|.
name|nelts
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|values
return|;
block|}
if|if
condition|(
name|i1
operator|>
literal|0
condition|)
block|{
comment|/* There is more than one field with that name 		        (overloaded).  Ask the user which one to use.  */
return|return
name|decode_line_2
argument_list|(
name|sym_arr
argument_list|,
name|i1
argument_list|,
name|funfirstline
argument_list|,
name|canonical
argument_list|)
return|;
block|}
else|else
block|{
name|char
modifier|*
name|tmp
decl_stmt|;
if|if
condition|(
name|OPNAME_PREFIX_P
argument_list|(
name|copy
argument_list|)
condition|)
block|{
name|tmp
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|copy
operator|+
literal|3
argument_list|)
operator|+
literal|9
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|tmp
argument_list|,
literal|"operator "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmp
argument_list|,
name|copy
operator|+
literal|3
argument_list|)
expr_stmt|;
block|}
else|else
name|tmp
operator|=
name|copy
expr_stmt|;
name|error_begin
argument_list|()
expr_stmt|;
if|if
condition|(
name|tmp
index|[
literal|0
index|]
operator|==
literal|'~'
condition|)
name|printf_filtered
argument_list|(
literal|"the class `%s' does not have destructor defined\n"
argument_list|,
name|SYMBOL_SOURCE_NAME
argument_list|(
name|sym_class
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|"the class %s does not have any method named %s\n"
argument_list|,
name|SYMBOL_SOURCE_NAME
argument_list|(
name|sym_class
argument_list|)
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|cplusplus_hint
argument_list|(
name|saved_arg
argument_list|)
expr_stmt|;
name|return_to_top_level
argument_list|(
name|RETURN_ERROR
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Move pointer up to next possible class/namespace token */
name|p
operator|=
name|p2
operator|+
literal|1
expr_stmt|;
comment|/* restart with old value +1 */
comment|/* Move pointer ahead to next double-colon */
while|while
condition|(
operator|*
name|p
operator|&&
operator|(
name|p
index|[
literal|0
index|]
operator|!=
literal|' '
operator|)
operator|&&
operator|(
name|p
index|[
literal|0
index|]
operator|!=
literal|'\t'
operator|)
operator|&&
operator|(
name|p
index|[
literal|0
index|]
operator|!=
literal|'\''
operator|)
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'<'
condition|)
block|{
name|temp_end
operator|=
name|find_template_name_end
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|temp_end
condition|)
name|error
argument_list|(
literal|"malformed template specification in command"
argument_list|)
expr_stmt|;
name|p
operator|=
name|temp_end
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|p
index|[
literal|0
index|]
operator|==
literal|':'
operator|)
operator|&&
operator|(
name|p
index|[
literal|1
index|]
operator|==
literal|':'
operator|)
condition|)
break|break;
comment|/* found double-colon */
else|else
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
operator|!=
literal|':'
condition|)
break|break;
comment|/* out of the while (1) */
name|p2
operator|=
name|p
expr_stmt|;
comment|/* save restart for next time around */
operator|*
name|argptr
operator|=
name|saved_arg2
expr_stmt|;
comment|/* restore argptr */
block|}
comment|/* while (1) */
comment|/* Last chance attempt -- check entire name as a symbol */
comment|/* Use "copy" in preparation for jumping out of this block,              to be consistent with usage following the jump target */
name|copy
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|p
operator|-
name|saved_arg2
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|copy
argument_list|,
name|saved_arg2
argument_list|,
name|p
operator|-
name|saved_arg2
argument_list|)
expr_stmt|;
comment|/* Note: if is_quoted should be true, we snuff out quote here anyway */
name|copy
index|[
name|p
operator|-
name|saved_arg2
index|]
operator|=
literal|'\000'
expr_stmt|;
comment|/* Set argptr to skip over the name */
operator|*
name|argptr
operator|=
operator|(
operator|*
name|p
operator|==
literal|'\''
operator|)
condition|?
name|p
operator|+
literal|1
else|:
name|p
expr_stmt|;
comment|/* Look up entire name */
name|sym
operator|=
name|lookup_symbol
argument_list|(
name|copy
argument_list|,
literal|0
argument_list|,
name|VAR_NAMESPACE
argument_list|,
literal|0
argument_list|,
operator|&
name|sym_symtab
argument_list|)
expr_stmt|;
name|s
operator|=
operator|(
expr|struct
name|symtab
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* Prepare to jump: restore the " if (condition)" so outer layers see it */
if|if
condition|(
name|has_if
condition|)
operator|*
name|ii
operator|=
literal|' '
expr_stmt|;
comment|/* Symbol was found --> jump to normal symbol processing.              Code following "symbol_found" expects "copy" to have the              symbol name, "sym" to have the symbol pointer, "s" to be              a specified file's symtab, and sym_symtab to be the symbol's              symtab. */
comment|/* By jumping there we avoid falling through the FILE:LINE and              FILE:FUNC processing stuff below */
if|if
condition|(
name|sym
condition|)
goto|goto
name|symbol_found
goto|;
comment|/* Couldn't find any interpretation as classes/namespaces, so give up */
name|error_begin
argument_list|()
expr_stmt|;
comment|/* The quotes are important if copy is empty.  */
name|printf_filtered
argument_list|(
literal|"Can't find member of namespace, class, struct, or union named \"%s\"\n"
argument_list|,
name|copy
argument_list|)
expr_stmt|;
name|cplusplus_hint
argument_list|(
name|saved_arg
argument_list|)
expr_stmt|;
name|return_to_top_level
argument_list|(
name|RETURN_ERROR
argument_list|)
expr_stmt|;
block|}
comment|/*  end of C++  */
comment|/* Extract the file name.  */
name|p1
operator|=
name|p
expr_stmt|;
while|while
condition|(
name|p
operator|!=
operator|*
name|argptr
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
operator|--
name|p
expr_stmt|;
name|copy
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|p
operator|-
operator|*
name|argptr
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|copy
argument_list|,
operator|*
name|argptr
argument_list|,
name|p
operator|-
operator|*
name|argptr
argument_list|)
expr_stmt|;
name|copy
index|[
name|p
operator|-
operator|*
name|argptr
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Find that file's data.  */
name|s
operator|=
name|lookup_symtab
argument_list|(
name|copy
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|have_full_symbols
argument_list|()
operator|&&
operator|!
name|have_partial_symbols
argument_list|()
condition|)
name|error
argument_list|(
name|no_symtab_msg
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"No source file named %s."
argument_list|,
name|copy
argument_list|)
expr_stmt|;
block|}
comment|/* Discard the file name from the arg.  */
name|p
operator|=
name|p1
operator|+
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
operator|*
name|argptr
operator|=
name|p
expr_stmt|;
block|}
else|else
block|{
comment|/* Check if what we have till now is a symbol name */
comment|/* We may be looking at a template instantiation such        as "foo<int>".  Check here whether we know about it,        instead of falling through to the code below which        handles ordinary function names, because that code        doesn't like seeing '<' and '>' in a name -- the        skip_quoted call doesn't go past them.  So see if we        can figure it out right now. */
name|copy
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|p
operator|-
operator|*
name|argptr
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|copy
argument_list|,
operator|*
name|argptr
argument_list|,
name|p
operator|-
operator|*
name|argptr
argument_list|)
expr_stmt|;
name|copy
index|[
name|p
operator|-
operator|*
name|argptr
index|]
operator|=
literal|'\000'
expr_stmt|;
name|sym
operator|=
name|lookup_symbol
argument_list|(
name|copy
argument_list|,
literal|0
argument_list|,
name|VAR_NAMESPACE
argument_list|,
literal|0
argument_list|,
operator|&
name|sym_symtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
condition|)
block|{
comment|/* Yes, we have a symbol; jump to symbol processing */
comment|/* Code after symbol_found expects S, SYM_SYMTAB, SYM,           and COPY to be set correctly */
if|if
condition|(
name|has_if
condition|)
operator|*
name|ii
operator|=
literal|' '
expr_stmt|;
operator|*
name|argptr
operator|=
operator|(
operator|*
name|p
operator|==
literal|'\''
operator|)
condition|?
name|p
operator|+
literal|1
else|:
name|p
expr_stmt|;
name|s
operator|=
operator|(
expr|struct
name|symtab
operator|*
operator|)
literal|0
expr_stmt|;
goto|goto
name|symbol_found
goto|;
block|}
comment|/* Otherwise fall out from here and go to file/line spec        processing, etc. */
block|}
comment|/* S is specified file's symtab, or 0 if no file specified.      arg no longer contains the file name.  */
comment|/* Check whether arg is all digits (and sign) */
name|q
operator|=
operator|*
name|argptr
expr_stmt|;
if|if
condition|(
operator|*
name|q
operator|==
literal|'-'
operator|||
operator|*
name|q
operator|==
literal|'+'
condition|)
name|q
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|q
operator|>=
literal|'0'
operator|&&
operator|*
name|q
operator|<=
literal|'9'
condition|)
name|q
operator|++
expr_stmt|;
if|if
condition|(
name|q
operator|!=
operator|*
name|argptr
operator|&&
operator|(
operator|*
name|q
operator|==
literal|0
operator|||
operator|*
name|q
operator|==
literal|' '
operator|||
operator|*
name|q
operator|==
literal|'\t'
operator|||
operator|*
name|q
operator|==
literal|','
operator|)
condition|)
block|{
comment|/* We found a token consisting of all digits -- at least one digit.  */
enum|enum
name|sign
block|{
name|none
block|,
name|plus
block|,
name|minus
block|}
name|sign
init|=
name|none
enum|;
comment|/* We might need a canonical line spec if no file was specified.  */
name|int
name|need_canonical
init|=
operator|(
name|s
operator|==
literal|0
operator|)
condition|?
literal|1
else|:
literal|0
decl_stmt|;
comment|/* This is where we need to make sure that we have good defaults. 	 We must guarantee that this section of code is never executed 	 when we are called with just a function name, since 	 select_source_symtab calls us with such an argument  */
if|if
condition|(
name|s
operator|==
literal|0
operator|&&
name|default_symtab
operator|==
literal|0
condition|)
block|{
name|select_source_symtab
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|default_symtab
operator|=
name|current_source_symtab
expr_stmt|;
name|default_line
operator|=
name|current_source_line
expr_stmt|;
block|}
if|if
condition|(
operator|*
operator|*
name|argptr
operator|==
literal|'+'
condition|)
name|sign
operator|=
name|plus
operator|,
operator|(
operator|*
name|argptr
operator|)
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
operator|*
name|argptr
operator|==
literal|'-'
condition|)
name|sign
operator|=
name|minus
operator|,
operator|(
operator|*
name|argptr
operator|)
operator|++
expr_stmt|;
name|val
operator|.
name|line
operator|=
name|atoi
argument_list|(
operator|*
name|argptr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sign
condition|)
block|{
case|case
name|plus
case|:
if|if
condition|(
name|q
operator|==
operator|*
name|argptr
condition|)
name|val
operator|.
name|line
operator|=
literal|5
expr_stmt|;
if|if
condition|(
name|s
operator|==
literal|0
condition|)
name|val
operator|.
name|line
operator|=
name|default_line
operator|+
name|val
operator|.
name|line
expr_stmt|;
break|break;
case|case
name|minus
case|:
if|if
condition|(
name|q
operator|==
operator|*
name|argptr
condition|)
name|val
operator|.
name|line
operator|=
literal|15
expr_stmt|;
if|if
condition|(
name|s
operator|==
literal|0
condition|)
name|val
operator|.
name|line
operator|=
name|default_line
operator|-
name|val
operator|.
name|line
expr_stmt|;
else|else
name|val
operator|.
name|line
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|none
case|:
break|break;
comment|/* No need to adjust val.line.  */
block|}
while|while
condition|(
operator|*
name|q
operator|==
literal|' '
operator|||
operator|*
name|q
operator|==
literal|'\t'
condition|)
name|q
operator|++
expr_stmt|;
operator|*
name|argptr
operator|=
name|q
expr_stmt|;
if|if
condition|(
name|s
operator|==
literal|0
condition|)
name|s
operator|=
name|default_symtab
expr_stmt|;
comment|/* It is possible that this source file has more than one symtab,  	 and that the new line number specification has moved us from the 	 default (in s) to a new one.  */
name|val
operator|.
name|symtab
operator|=
name|find_line_symtab
argument_list|(
name|s
argument_list|,
name|val
operator|.
name|line
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|.
name|symtab
operator|==
literal|0
condition|)
name|val
operator|.
name|symtab
operator|=
name|s
expr_stmt|;
name|val
operator|.
name|pc
operator|=
literal|0
expr_stmt|;
name|values
operator|.
name|sals
operator|=
operator|(
expr|struct
name|symtab_and_line
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|symtab_and_line
argument_list|)
argument_list|)
expr_stmt|;
name|values
operator|.
name|sals
index|[
literal|0
index|]
operator|=
name|val
expr_stmt|;
name|values
operator|.
name|nelts
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|need_canonical
condition|)
name|build_canonical_line_spec
argument_list|(
name|values
operator|.
name|sals
argument_list|,
name|NULL
argument_list|,
name|canonical
argument_list|)
expr_stmt|;
return|return
name|values
return|;
block|}
comment|/* Arg token is not digits => try it as a variable name      Find the next token (everything up to end or next whitespace).  */
if|if
condition|(
operator|*
operator|*
name|argptr
operator|==
literal|'$'
condition|)
comment|/* May be a convenience variable */
name|p
operator|=
name|skip_quoted
argument_list|(
operator|*
name|argptr
operator|+
operator|(
operator|(
operator|(
operator|*
name|argptr
operator|)
index|[
literal|1
index|]
operator|==
literal|'$'
operator|)
condition|?
literal|2
else|:
literal|1
operator|)
argument_list|)
expr_stmt|;
comment|/* One or two $ chars possible */
elseif|else
if|if
condition|(
name|is_quoted
condition|)
block|{
name|p
operator|=
name|skip_quoted
argument_list|(
operator|*
name|argptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\''
condition|)
name|error
argument_list|(
literal|"Unmatched single quote."
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|has_parens
condition|)
block|{
name|p
operator|=
name|pp
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|skip_quoted
argument_list|(
operator|*
name|argptr
argument_list|)
expr_stmt|;
block|}
name|copy
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|p
operator|-
operator|*
name|argptr
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|copy
argument_list|,
operator|*
name|argptr
argument_list|,
name|p
operator|-
operator|*
name|argptr
argument_list|)
expr_stmt|;
name|copy
index|[
name|p
operator|-
operator|*
name|argptr
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|p
operator|!=
operator|*
name|argptr
operator|&&
name|copy
index|[
literal|0
index|]
operator|&&
name|copy
index|[
literal|0
index|]
operator|==
name|copy
index|[
name|p
operator|-
operator|*
name|argptr
operator|-
literal|1
index|]
operator|&&
name|strchr
argument_list|(
name|gdb_completer_quote_characters
argument_list|,
name|copy
index|[
literal|0
index|]
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|copy
index|[
name|p
operator|-
operator|*
name|argptr
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|copy
operator|++
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
operator|*
name|argptr
operator|=
name|p
expr_stmt|;
comment|/* If it starts with $: may be a legitimate variable or routine name      (e.g. HP-UX millicode routines such as $$dyncall), or it may      be history value, or it may be a convenience variable */
if|if
condition|(
operator|*
name|copy
operator|==
literal|'$'
condition|)
block|{
name|value_ptr
name|valx
decl_stmt|;
name|int
name|index
init|=
literal|0
decl_stmt|;
name|int
name|need_canonical
init|=
literal|0
decl_stmt|;
name|p
operator|=
operator|(
name|copy
index|[
literal|1
index|]
operator|==
literal|'$'
operator|)
condition|?
name|copy
operator|+
literal|2
else|:
name|copy
operator|+
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|>=
literal|'0'
operator|&&
operator|*
name|p
operator|<=
literal|'9'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|p
condition|)
comment|/* reached end of token without hitting non-digit */
block|{
comment|/* We have a value history reference */
name|sscanf
argument_list|(
operator|(
name|copy
index|[
literal|1
index|]
operator|==
literal|'$'
operator|)
condition|?
name|copy
operator|+
literal|2
else|:
name|copy
operator|+
literal|1
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|index
argument_list|)
expr_stmt|;
name|valx
operator|=
name|access_value_history
argument_list|(
operator|(
name|copy
index|[
literal|1
index|]
operator|==
literal|'$'
operator|)
condition|?
operator|-
name|index
else|:
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|valx
argument_list|)
argument_list|)
operator|!=
name|TYPE_CODE_INT
condition|)
name|error
argument_list|(
literal|"History values used in line specs must have integer values."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Not all digits -- may be user variable/function or a               convenience variable */
comment|/* Look up entire name as a symbol first */
name|sym
operator|=
name|lookup_symbol
argument_list|(
name|copy
argument_list|,
literal|0
argument_list|,
name|VAR_NAMESPACE
argument_list|,
literal|0
argument_list|,
operator|&
name|sym_symtab
argument_list|)
expr_stmt|;
name|s
operator|=
operator|(
expr|struct
name|symtab
operator|*
operator|)
literal|0
expr_stmt|;
name|need_canonical
operator|=
literal|1
expr_stmt|;
comment|/* Symbol was found --> jump to normal symbol processing.              Code following "symbol_found" expects "copy" to have the              symbol name, "sym" to have the symbol pointer, "s" to be              a specified file's symtab, and sym_symtab to be the symbol's              symtab. */
if|if
condition|(
name|sym
condition|)
goto|goto
name|symbol_found
goto|;
comment|/* If symbol was not found, look in minimal symbol tables */
name|msymbol
operator|=
name|lookup_minimal_symbol
argument_list|(
name|copy
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Min symbol was found --> jump to minsym processing. */
if|if
condition|(
name|msymbol
condition|)
goto|goto
name|minimal_symbol_found
goto|;
comment|/* Not a user variable or function -- must be convenience variable */
name|need_canonical
operator|=
operator|(
name|s
operator|==
literal|0
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|valx
operator|=
name|value_of_internalvar
argument_list|(
name|lookup_internalvar
argument_list|(
name|copy
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|valx
argument_list|)
argument_list|)
operator|!=
name|TYPE_CODE_INT
condition|)
name|error
argument_list|(
literal|"Convenience variables used in line specs must have integer values."
argument_list|)
expr_stmt|;
block|}
comment|/* Either history value or convenience value from above, in valx */
name|val
operator|.
name|symtab
operator|=
name|s
condition|?
name|s
else|:
name|default_symtab
expr_stmt|;
name|val
operator|.
name|line
operator|=
name|value_as_long
argument_list|(
name|valx
argument_list|)
expr_stmt|;
name|val
operator|.
name|pc
operator|=
literal|0
expr_stmt|;
name|values
operator|.
name|sals
operator|=
operator|(
expr|struct
name|symtab_and_line
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
name|val
argument_list|)
expr_stmt|;
name|values
operator|.
name|sals
index|[
literal|0
index|]
operator|=
name|val
expr_stmt|;
name|values
operator|.
name|nelts
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|need_canonical
condition|)
name|build_canonical_line_spec
argument_list|(
name|values
operator|.
name|sals
argument_list|,
name|NULL
argument_list|,
name|canonical
argument_list|)
expr_stmt|;
return|return
name|values
return|;
block|}
comment|/* Look up that token as a variable.      If file specified, use that file's per-file block to start with.  */
name|sym
operator|=
name|lookup_symbol
argument_list|(
name|copy
argument_list|,
operator|(
name|s
condition|?
name|BLOCKVECTOR_BLOCK
argument_list|(
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
argument_list|,
name|STATIC_BLOCK
argument_list|)
else|:
name|get_selected_block
argument_list|()
operator|)
argument_list|,
name|VAR_NAMESPACE
argument_list|,
literal|0
argument_list|,
operator|&
name|sym_symtab
argument_list|)
expr_stmt|;
name|symbol_found
label|:
comment|/* We also jump here from inside the C++ class/namespace                     code on finding a symbol of the form "A::B::C" */
if|if
condition|(
name|sym
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_BLOCK
condition|)
block|{
comment|/* Arg is the name of a function */
name|values
operator|.
name|sals
operator|=
operator|(
expr|struct
name|symtab_and_line
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|symtab_and_line
argument_list|)
argument_list|)
expr_stmt|;
name|values
operator|.
name|sals
index|[
literal|0
index|]
operator|=
name|find_function_start_sal
argument_list|(
name|sym
argument_list|,
name|funfirstline
argument_list|)
expr_stmt|;
name|values
operator|.
name|nelts
operator|=
literal|1
expr_stmt|;
comment|/* Don't use the SYMBOL_LINE; if used at all it points to 	     the line containing the parameters or thereabouts, not 	     the first line of code.  */
comment|/* We might need a canonical line spec if it is a static 	     function.  */
if|if
condition|(
name|s
operator|==
literal|0
condition|)
block|{
name|struct
name|blockvector
modifier|*
name|bv
init|=
name|BLOCKVECTOR
argument_list|(
name|sym_symtab
argument_list|)
decl_stmt|;
name|struct
name|block
modifier|*
name|b
init|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|STATIC_BLOCK
argument_list|)
decl_stmt|;
if|if
condition|(
name|lookup_block_symbol
argument_list|(
name|b
argument_list|,
name|copy
argument_list|,
name|VAR_NAMESPACE
argument_list|)
operator|!=
name|NULL
condition|)
name|build_canonical_line_spec
argument_list|(
name|values
operator|.
name|sals
argument_list|,
name|copy
argument_list|,
name|canonical
argument_list|)
expr_stmt|;
block|}
return|return
name|values
return|;
block|}
else|else
block|{
if|if
condition|(
name|funfirstline
condition|)
name|error
argument_list|(
literal|"\"%s\" is not a function"
argument_list|,
name|copy
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|SYMBOL_LINE
argument_list|(
name|sym
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* We know its line number.  */
name|values
operator|.
name|sals
operator|=
operator|(
expr|struct
name|symtab_and_line
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|symtab_and_line
argument_list|)
argument_list|)
expr_stmt|;
name|values
operator|.
name|nelts
operator|=
literal|1
expr_stmt|;
name|memset
argument_list|(
operator|&
name|values
operator|.
name|sals
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|values
operator|.
name|sals
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|values
operator|.
name|sals
index|[
literal|0
index|]
operator|.
name|symtab
operator|=
name|sym_symtab
expr_stmt|;
name|values
operator|.
name|sals
index|[
literal|0
index|]
operator|.
name|line
operator|=
name|SYMBOL_LINE
argument_list|(
name|sym
argument_list|)
expr_stmt|;
return|return
name|values
return|;
block|}
else|else
comment|/* This can happen if it is compiled with a compiler which doesn't 	       put out line numbers for variables.  */
comment|/* FIXME: Shouldn't we just set .line and .symtab to zero 	       and return?  For example, "info line foo" could print 	       the address.  */
name|error
argument_list|(
literal|"Line number not known for symbol \"%s\""
argument_list|,
name|copy
argument_list|)
expr_stmt|;
block|}
block|}
name|msymbol
operator|=
name|lookup_minimal_symbol
argument_list|(
name|copy
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|minimal_symbol_found
label|:
comment|/* We also jump here from the case for variables                          that begin with '$' */
if|if
condition|(
name|msymbol
operator|!=
name|NULL
condition|)
block|{
name|values
operator|.
name|sals
operator|=
operator|(
expr|struct
name|symtab_and_line
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|symtab_and_line
argument_list|)
argument_list|)
expr_stmt|;
name|values
operator|.
name|sals
index|[
literal|0
index|]
operator|=
name|find_pc_sect_line
argument_list|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
argument_list|,
operator|(
expr|struct
name|sec
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|values
operator|.
name|sals
index|[
literal|0
index|]
operator|.
name|section
operator|=
name|SYMBOL_BFD_SECTION
argument_list|(
name|msymbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|funfirstline
condition|)
block|{
name|values
operator|.
name|sals
index|[
literal|0
index|]
operator|.
name|pc
operator|+=
name|FUNCTION_START_OFFSET
expr_stmt|;
name|SKIP_PROLOGUE
argument_list|(
name|values
operator|.
name|sals
index|[
literal|0
index|]
operator|.
name|pc
argument_list|)
expr_stmt|;
block|}
name|values
operator|.
name|nelts
operator|=
literal|1
expr_stmt|;
return|return
name|values
return|;
block|}
if|if
condition|(
operator|!
name|have_full_symbols
argument_list|()
operator|&&
operator|!
name|have_partial_symbols
argument_list|()
operator|&&
operator|!
name|have_minimal_symbols
argument_list|()
condition|)
name|error
argument_list|(
name|no_symtab_msg
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Function \"%s\" not defined."
argument_list|,
name|copy
argument_list|)
expr_stmt|;
return|return
name|values
return|;
comment|/* for lint */
block|}
end_function

begin_function
name|struct
name|symtabs_and_lines
name|decode_line_spec
parameter_list|(
name|string
parameter_list|,
name|funfirstline
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|funfirstline
decl_stmt|;
block|{
name|struct
name|symtabs_and_lines
name|sals
decl_stmt|;
if|if
condition|(
name|string
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Empty line specification."
argument_list|)
expr_stmt|;
name|sals
operator|=
name|decode_line_1
argument_list|(
operator|&
name|string
argument_list|,
name|funfirstline
argument_list|,
name|current_source_symtab
argument_list|,
name|current_source_line
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|string
condition|)
name|error
argument_list|(
literal|"Junk at end of line specification: %s"
argument_list|,
name|string
argument_list|)
expr_stmt|;
return|return
name|sals
return|;
block|}
end_function

begin_comment
comment|/* Given a list of NELTS symbols in SYM_ARR, return a list of lines to    operate on (ask user if necessary).    If CANONICAL is non-NULL return a corresponding array of mangled names    as canonical line specs there.  */
end_comment

begin_function
specifier|static
name|struct
name|symtabs_and_lines
name|decode_line_2
parameter_list|(
name|sym_arr
parameter_list|,
name|nelts
parameter_list|,
name|funfirstline
parameter_list|,
name|canonical
parameter_list|)
name|struct
name|symbol
modifier|*
name|sym_arr
index|[]
decl_stmt|;
name|int
name|nelts
decl_stmt|;
name|int
name|funfirstline
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|canonical
decl_stmt|;
block|{
name|struct
name|symtabs_and_lines
name|values
decl_stmt|,
name|return_values
decl_stmt|;
name|char
modifier|*
name|args
decl_stmt|,
modifier|*
name|arg1
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|prompt
decl_stmt|;
name|char
modifier|*
name|symname
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|char
modifier|*
modifier|*
name|canonical_arr
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
name|values
operator|.
name|sals
operator|=
operator|(
expr|struct
name|symtab_and_line
operator|*
operator|)
name|alloca
argument_list|(
name|nelts
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|symtab_and_line
argument_list|)
argument_list|)
expr_stmt|;
name|return_values
operator|.
name|sals
operator|=
operator|(
expr|struct
name|symtab_and_line
operator|*
operator|)
name|xmalloc
argument_list|(
name|nelts
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|symtab_and_line
argument_list|)
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|return_values
operator|.
name|sals
argument_list|)
expr_stmt|;
if|if
condition|(
name|canonical
condition|)
block|{
name|canonical_arr
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|nelts
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|canonical_arr
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|canonical_arr
argument_list|,
literal|0
argument_list|,
name|nelts
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|canonical
operator|=
name|canonical_arr
expr_stmt|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"[0] cancel\n[1] all\n"
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|nelts
condition|)
block|{
name|INIT_SAL
argument_list|(
operator|&
name|return_values
operator|.
name|sals
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* initialize to zeroes */
name|INIT_SAL
argument_list|(
operator|&
name|values
operator|.
name|sals
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym_arr
index|[
name|i
index|]
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|sym_arr
index|[
name|i
index|]
argument_list|)
operator|==
name|LOC_BLOCK
condition|)
block|{
name|values
operator|.
name|sals
index|[
name|i
index|]
operator|=
name|find_function_start_sal
argument_list|(
name|sym_arr
index|[
name|i
index|]
argument_list|,
name|funfirstline
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"[%d] %s at %s:%d\n"
argument_list|,
operator|(
name|i
operator|+
literal|2
operator|)
argument_list|,
name|SYMBOL_SOURCE_NAME
argument_list|(
name|sym_arr
index|[
name|i
index|]
argument_list|)
argument_list|,
name|values
operator|.
name|sals
index|[
name|i
index|]
operator|.
name|symtab
operator|->
name|filename
argument_list|,
name|values
operator|.
name|sals
index|[
name|i
index|]
operator|.
name|line
argument_list|)
expr_stmt|;
block|}
else|else
name|printf_unfiltered
argument_list|(
literal|"?HERE\n"
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|prompt
operator|=
name|getenv
argument_list|(
literal|"PS2"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|prompt
operator|=
literal|"> "
expr_stmt|;
block|}
name|args
operator|=
name|command_line_input
argument_list|(
name|prompt
argument_list|,
literal|0
argument_list|,
literal|"overload-choice"
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|==
literal|0
operator|||
operator|*
name|args
operator|==
literal|0
condition|)
name|error_no_arg
argument_list|(
literal|"one or more choice numbers"
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|args
condition|)
block|{
name|int
name|num
decl_stmt|;
name|arg1
operator|=
name|args
expr_stmt|;
while|while
condition|(
operator|*
name|arg1
operator|>=
literal|'0'
operator|&&
operator|*
name|arg1
operator|<=
literal|'9'
condition|)
name|arg1
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|arg1
operator|&&
operator|*
name|arg1
operator|!=
literal|' '
operator|&&
operator|*
name|arg1
operator|!=
literal|'\t'
condition|)
name|error
argument_list|(
literal|"Arguments must be choice numbers."
argument_list|)
expr_stmt|;
name|num
operator|=
name|atoi
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|num
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"cancelled"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|num
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|canonical_arr
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nelts
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|canonical_arr
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
name|symname
operator|=
name|SYMBOL_NAME
argument_list|(
name|sym_arr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|canonical_arr
index|[
name|i
index|]
operator|=
name|savestring
argument_list|(
name|symname
argument_list|,
name|strlen
argument_list|(
name|symname
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|memcpy
argument_list|(
name|return_values
operator|.
name|sals
argument_list|,
name|values
operator|.
name|sals
argument_list|,
operator|(
name|nelts
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|symtab_and_line
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|return_values
operator|.
name|nelts
operator|=
name|nelts
expr_stmt|;
name|discard_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
name|return_values
return|;
block|}
if|if
condition|(
name|num
operator|>=
name|nelts
operator|+
literal|2
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"No choice number %d.\n"
argument_list|,
name|num
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|num
operator|-=
literal|2
expr_stmt|;
if|if
condition|(
name|values
operator|.
name|sals
index|[
name|num
index|]
operator|.
name|pc
condition|)
block|{
if|if
condition|(
name|canonical_arr
condition|)
block|{
name|symname
operator|=
name|SYMBOL_NAME
argument_list|(
name|sym_arr
index|[
name|num
index|]
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|symname
argument_list|)
expr_stmt|;
name|canonical_arr
index|[
name|i
index|]
operator|=
name|savestring
argument_list|(
name|symname
argument_list|,
name|strlen
argument_list|(
name|symname
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|return_values
operator|.
name|sals
index|[
name|i
operator|++
index|]
operator|=
name|values
operator|.
name|sals
index|[
name|num
index|]
expr_stmt|;
name|values
operator|.
name|sals
index|[
name|num
index|]
operator|.
name|pc
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|printf_unfiltered
argument_list|(
literal|"duplicate request for %d ignored.\n"
argument_list|,
name|num
argument_list|)
expr_stmt|;
block|}
block|}
name|args
operator|=
name|arg1
expr_stmt|;
while|while
condition|(
operator|*
name|args
operator|==
literal|' '
operator|||
operator|*
name|args
operator|==
literal|'\t'
condition|)
name|args
operator|++
expr_stmt|;
block|}
name|return_values
operator|.
name|nelts
operator|=
name|i
expr_stmt|;
name|discard_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
name|return_values
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Slave routine for sources_info.  Force line breaks at ,'s.    NAME is the name to print and *FIRST is nonzero if this is the first    name printed.  Set *FIRST to zero.  */
end_comment

begin_function
specifier|static
name|void
name|output_source_filename
parameter_list|(
name|name
parameter_list|,
name|first
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
modifier|*
name|first
decl_stmt|;
block|{
comment|/* Table of files printed so far.  Since a single source file can      result in several partial symbol tables, we need to avoid printing      it more than once.  Note: if some of the psymtabs are read in and      some are not, it gets printed both under "Source files for which      symbols have been read" and "Source files for which symbols will      be read in on demand".  I consider this a reasonable way to deal      with the situation.  I'm not sure whether this can also happen for      symtabs; it doesn't hurt to check.  */
specifier|static
name|char
modifier|*
modifier|*
name|tab
init|=
name|NULL
decl_stmt|;
comment|/* Allocated size of tab in elements.      Start with one 256-byte block (when using GNU malloc.c).      24 is the malloc overhead when range checking is in effect.  */
specifier|static
name|int
name|tab_alloc_size
init|=
operator|(
literal|256
operator|-
literal|24
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
decl_stmt|;
comment|/* Current size of tab in elements.  */
specifier|static
name|int
name|tab_cur_size
decl_stmt|;
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|*
name|first
condition|)
block|{
if|if
condition|(
name|tab
operator|==
name|NULL
condition|)
name|tab
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|tab_alloc_size
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|tab
argument_list|)
argument_list|)
expr_stmt|;
name|tab_cur_size
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Is NAME in tab?  */
for|for
control|(
name|p
operator|=
name|tab
init|;
name|p
operator|<
name|tab
operator|+
name|tab_cur_size
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|STREQ
argument_list|(
operator|*
name|p
argument_list|,
name|name
argument_list|)
condition|)
comment|/* Yes; don't print it again.  */
return|return;
comment|/* No; add it to tab.  */
if|if
condition|(
name|tab_cur_size
operator|==
name|tab_alloc_size
condition|)
block|{
name|tab_alloc_size
operator|*=
literal|2
expr_stmt|;
name|tab
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tab
argument_list|,
name|tab_alloc_size
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|tab
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|tab
index|[
name|tab_cur_size
operator|++
index|]
operator|=
name|name
expr_stmt|;
if|if
condition|(
operator|*
name|first
condition|)
block|{
operator|*
name|first
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|printf_filtered
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
name|name
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sources_info
parameter_list|(
name|ignore
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|ignore
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
specifier|register
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
specifier|register
name|struct
name|partial_symtab
modifier|*
name|ps
decl_stmt|;
specifier|register
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|int
name|first
decl_stmt|;
if|if
condition|(
operator|!
name|have_full_symbols
argument_list|()
operator|&&
operator|!
name|have_partial_symbols
argument_list|()
condition|)
block|{
name|error
argument_list|(
name|no_symtab_msg
argument_list|)
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|"Source files for which symbols have been read in:\n\n"
argument_list|)
expr_stmt|;
name|first
operator|=
literal|1
expr_stmt|;
name|ALL_SYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
block|{
name|output_source_filename
argument_list|(
name|s
operator|->
name|filename
argument_list|,
operator|&
name|first
argument_list|)
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Source files for which symbols will be read in on demand:\n\n"
argument_list|)
expr_stmt|;
name|first
operator|=
literal|1
expr_stmt|;
name|ALL_PSYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|ps
argument_list|)
block|{
if|if
condition|(
operator|!
name|ps
operator|->
name|readin
condition|)
block|{
name|output_source_filename
argument_list|(
name|ps
operator|->
name|filename
argument_list|,
operator|&
name|first
argument_list|)
expr_stmt|;
block|}
block|}
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|file_matches
parameter_list|(
name|file
parameter_list|,
name|files
parameter_list|,
name|nfiles
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|files
index|[]
decl_stmt|;
name|int
name|nfiles
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|file
operator|!=
name|NULL
operator|&&
name|nfiles
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfiles
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|files
index|[
name|i
index|]
argument_list|,
name|basename
argument_list|(
name|file
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|nfiles
operator|==
literal|0
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Free any memory associated with a search. */
end_comment

begin_function
name|void
name|free_search_symbols
parameter_list|(
name|symbols
parameter_list|)
name|struct
name|symbol_search
modifier|*
name|symbols
decl_stmt|;
block|{
name|struct
name|symbol_search
modifier|*
name|p
decl_stmt|;
name|struct
name|symbol_search
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|p
operator|=
name|symbols
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|next
control|)
block|{
name|next
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Search the symbol table for matches to the regular expression REGEXP,    returning the results in *MATCHES.     Only symbols of KIND are searched:      FUNCTIONS_NAMESPACE - search all functions      TYPES_NAMESPACE     - search all type names      METHODS_NAMESPACE   - search all methods NOT IMPLEMENTED      VARIABLES_NAMESPACE - search all symbols, excluding functions, type names,                          and constants (enums)     free_search_symbols should be called when *MATCHES is no longer needed. */
end_comment

begin_function
name|void
name|search_symbols
parameter_list|(
name|regexp
parameter_list|,
name|kind
parameter_list|,
name|nfiles
parameter_list|,
name|files
parameter_list|,
name|matches
parameter_list|)
name|char
modifier|*
name|regexp
decl_stmt|;
name|namespace_enum
name|kind
decl_stmt|;
name|int
name|nfiles
decl_stmt|;
name|char
modifier|*
name|files
index|[]
decl_stmt|;
name|struct
name|symbol_search
modifier|*
modifier|*
name|matches
decl_stmt|;
block|{
specifier|register
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
specifier|register
name|struct
name|partial_symtab
modifier|*
name|ps
decl_stmt|;
specifier|register
name|struct
name|blockvector
modifier|*
name|bv
decl_stmt|;
name|struct
name|blockvector
modifier|*
name|prev_bv
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|block
modifier|*
name|b
decl_stmt|;
specifier|register
name|int
name|i
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|struct
name|partial_symbol
modifier|*
modifier|*
name|psym
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
name|int
name|found_misc
init|=
literal|0
decl_stmt|;
specifier|static
name|enum
name|minimal_symbol_type
name|types
index|[]
init|=
block|{
name|mst_data
block|,
name|mst_text
block|,
name|mst_abs
block|,
name|mst_unknown
block|}
decl_stmt|;
specifier|static
name|enum
name|minimal_symbol_type
name|types2
index|[]
init|=
block|{
name|mst_bss
block|,
name|mst_file_text
block|,
name|mst_abs
block|,
name|mst_unknown
block|}
decl_stmt|;
specifier|static
name|enum
name|minimal_symbol_type
name|types3
index|[]
init|=
block|{
name|mst_file_data
block|,
name|mst_solib_trampoline
block|,
name|mst_abs
block|,
name|mst_unknown
block|}
decl_stmt|;
specifier|static
name|enum
name|minimal_symbol_type
name|types4
index|[]
init|=
block|{
name|mst_file_bss
block|,
name|mst_text
block|,
name|mst_abs
block|,
name|mst_unknown
block|}
decl_stmt|;
name|enum
name|minimal_symbol_type
name|ourtype
decl_stmt|;
name|enum
name|minimal_symbol_type
name|ourtype2
decl_stmt|;
name|enum
name|minimal_symbol_type
name|ourtype3
decl_stmt|;
name|enum
name|minimal_symbol_type
name|ourtype4
decl_stmt|;
name|struct
name|symbol_search
modifier|*
name|sr
decl_stmt|;
name|struct
name|symbol_search
modifier|*
name|psr
decl_stmt|;
name|struct
name|symbol_search
modifier|*
name|tail
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|kind
operator|<
name|LABEL_NAMESPACE
condition|)
name|error
argument_list|(
literal|"must search on specific namespace"
argument_list|)
expr_stmt|;
name|ourtype
operator|=
name|types
index|[
call|(
name|int
call|)
argument_list|(
name|kind
operator|-
name|LABEL_NAMESPACE
argument_list|)
index|]
expr_stmt|;
name|ourtype2
operator|=
name|types2
index|[
call|(
name|int
call|)
argument_list|(
name|kind
operator|-
name|LABEL_NAMESPACE
argument_list|)
index|]
expr_stmt|;
name|ourtype3
operator|=
name|types3
index|[
call|(
name|int
call|)
argument_list|(
name|kind
operator|-
name|LABEL_NAMESPACE
argument_list|)
index|]
expr_stmt|;
name|ourtype4
operator|=
name|types4
index|[
call|(
name|int
call|)
argument_list|(
name|kind
operator|-
name|LABEL_NAMESPACE
argument_list|)
index|]
expr_stmt|;
name|sr
operator|=
operator|*
name|matches
operator|=
name|NULL
expr_stmt|;
name|tail
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|regexp
operator|!=
name|NULL
condition|)
block|{
comment|/* Make sure spacing is right for C++ operators.          This is just a courtesy to make the matching less sensitive          to how many spaces the user leaves between 'operator'          and<TYPENAME> or<OPERATOR>. */
name|char
modifier|*
name|opend
decl_stmt|;
name|char
modifier|*
name|opname
init|=
name|operator_chars
argument_list|(
name|regexp
argument_list|,
operator|&
name|opend
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|opname
condition|)
block|{
name|int
name|fix
init|=
operator|-
literal|1
decl_stmt|;
comment|/* -1 means ok; otherwise number of spaces needed. */
if|if
condition|(
name|isalpha
argument_list|(
operator|*
name|opname
argument_list|)
operator|||
operator|*
name|opname
operator|==
literal|'_'
operator|||
operator|*
name|opname
operator|==
literal|'$'
condition|)
block|{
comment|/* There should 1 space between 'operator' and 'TYPENAME'. */
if|if
condition|(
name|opname
index|[
operator|-
literal|1
index|]
operator|!=
literal|' '
operator|||
name|opname
index|[
operator|-
literal|2
index|]
operator|==
literal|' '
condition|)
name|fix
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* There should 0 spaces between 'operator' and 'OPERATOR'. */
if|if
condition|(
name|opname
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
name|fix
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If wrong number of spaces, fix it. */
if|if
condition|(
name|fix
operator|>=
literal|0
condition|)
block|{
name|char
modifier|*
name|tmp
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|opend
operator|-
name|opname
operator|+
literal|10
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"operator%.*s%s"
argument_list|,
name|fix
argument_list|,
literal|" "
argument_list|,
name|opname
argument_list|)
expr_stmt|;
name|regexp
operator|=
name|tmp
expr_stmt|;
block|}
block|}
if|if
condition|(
literal|0
operator|!=
operator|(
name|val
operator|=
name|re_comp
argument_list|(
name|regexp
argument_list|)
operator|)
condition|)
name|error
argument_list|(
literal|"Invalid regexp (%s): %s"
argument_list|,
name|val
argument_list|,
name|regexp
argument_list|)
expr_stmt|;
block|}
comment|/* Search through the partial symtabs *first* for all symbols      matching the regexp.  That way we don't have to reproduce all of      the machinery below. */
name|ALL_PSYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|ps
argument_list|)
block|{
name|struct
name|partial_symbol
modifier|*
modifier|*
name|bound
decl_stmt|,
modifier|*
modifier|*
name|gbound
decl_stmt|,
modifier|*
modifier|*
name|sbound
decl_stmt|;
name|int
name|keep_going
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|ps
operator|->
name|readin
condition|)
continue|continue;
name|gbound
operator|=
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
operator|+
name|ps
operator|->
name|globals_offset
operator|+
name|ps
operator|->
name|n_global_syms
expr_stmt|;
name|sbound
operator|=
name|objfile
operator|->
name|static_psymbols
operator|.
name|list
operator|+
name|ps
operator|->
name|statics_offset
operator|+
name|ps
operator|->
name|n_static_syms
expr_stmt|;
name|bound
operator|=
name|gbound
expr_stmt|;
comment|/* Go through all of the symbols stored in a partial          symtab in one loop. */
name|psym
operator|=
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
operator|+
name|ps
operator|->
name|globals_offset
expr_stmt|;
while|while
condition|(
name|keep_going
condition|)
block|{
if|if
condition|(
name|psym
operator|>=
name|bound
condition|)
block|{
if|if
condition|(
name|bound
operator|==
name|gbound
operator|&&
name|ps
operator|->
name|n_static_syms
operator|!=
literal|0
condition|)
block|{
name|psym
operator|=
name|objfile
operator|->
name|static_psymbols
operator|.
name|list
operator|+
name|ps
operator|->
name|statics_offset
expr_stmt|;
name|bound
operator|=
name|sbound
expr_stmt|;
block|}
else|else
name|keep_going
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|QUIT
expr_stmt|;
comment|/* If it would match (logic taken from loop below)                  load the file and go on to the next one */
if|if
condition|(
name|file_matches
argument_list|(
name|ps
operator|->
name|filename
argument_list|,
name|files
argument_list|,
name|nfiles
argument_list|)
operator|&&
operator|(
operator|(
name|regexp
operator|==
name|NULL
operator|||
name|SYMBOL_MATCHES_REGEXP
argument_list|(
operator|*
name|psym
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|kind
operator|==
name|VARIABLES_NAMESPACE
operator|&&
name|SYMBOL_CLASS
argument_list|(
operator|*
name|psym
argument_list|)
operator|!=
name|LOC_TYPEDEF
operator|&&
name|SYMBOL_CLASS
argument_list|(
operator|*
name|psym
argument_list|)
operator|!=
name|LOC_BLOCK
operator|)
operator|||
operator|(
name|kind
operator|==
name|FUNCTIONS_NAMESPACE
operator|&&
name|SYMBOL_CLASS
argument_list|(
operator|*
name|psym
argument_list|)
operator|==
name|LOC_BLOCK
operator|)
operator|||
operator|(
name|kind
operator|==
name|TYPES_NAMESPACE
operator|&&
name|SYMBOL_CLASS
argument_list|(
operator|*
name|psym
argument_list|)
operator|==
name|LOC_TYPEDEF
operator|)
operator|||
operator|(
name|kind
operator|==
name|METHODS_NAMESPACE
operator|&&
name|SYMBOL_CLASS
argument_list|(
operator|*
name|psym
argument_list|)
operator|==
name|LOC_BLOCK
operator|)
operator|)
operator|)
condition|)
block|{
name|PSYMTAB_TO_SYMTAB
argument_list|(
name|ps
argument_list|)
expr_stmt|;
name|keep_going
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|psym
operator|++
expr_stmt|;
block|}
block|}
comment|/* Here, we search through the minimal symbol tables for functions      and variables that match, and force their symbols to be read.      This is in particular necessary for demangled variable names,      which are no longer put into the partial symbol tables.      The symbol will then be found during the scan of symtabs below.       For functions, find_pc_symtab should succeed if we have debug info      for the function, for variables we have to call lookup_symbol      to determine if the variable has debug info.      If the lookup fails, set found_misc so that we will rescan to print      any matching symbols without debug info.   */
if|if
condition|(
name|nfiles
operator|==
literal|0
operator|&&
operator|(
name|kind
operator|==
name|VARIABLES_NAMESPACE
operator|||
name|kind
operator|==
name|FUNCTIONS_NAMESPACE
operator|)
condition|)
block|{
name|ALL_MSYMBOLS
argument_list|(
argument|objfile
argument_list|,
argument|msymbol
argument_list|)
block|{
if|if
condition|(
name|MSYMBOL_TYPE
argument_list|(
name|msymbol
argument_list|)
operator|==
name|ourtype
operator|||
name|MSYMBOL_TYPE
argument_list|(
name|msymbol
argument_list|)
operator|==
name|ourtype2
operator|||
name|MSYMBOL_TYPE
argument_list|(
name|msymbol
argument_list|)
operator|==
name|ourtype3
operator|||
name|MSYMBOL_TYPE
argument_list|(
name|msymbol
argument_list|)
operator|==
name|ourtype4
condition|)
block|{
if|if
condition|(
name|regexp
operator|==
name|NULL
operator|||
name|SYMBOL_MATCHES_REGEXP
argument_list|(
name|msymbol
argument_list|)
condition|)
block|{
if|if
condition|(
literal|0
operator|==
name|find_pc_symtab
argument_list|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|kind
operator|==
name|FUNCTIONS_NAMESPACE
operator|||
name|lookup_symbol
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|msymbol
argument_list|)
argument_list|,
operator|(
expr|struct
name|block
operator|*
operator|)
name|NULL
argument_list|,
name|VAR_NAMESPACE
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|symtab
operator|*
operator|*
operator|)
name|NULL
argument_list|)
operator|==
name|NULL
condition|)
name|found_misc
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
name|ALL_SYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
block|{
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Often many files share a blockvector.          Scan each blockvector only once so that          we don't get every symbol many times.          It happens that the first symtab in the list          for any given blockvector is the main file.  */
if|if
condition|(
name|bv
operator|!=
name|prev_bv
condition|)
for|for
control|(
name|i
operator|=
name|GLOBAL_BLOCK
init|;
name|i
operator|<=
name|STATIC_BLOCK
condition|;
name|i
operator|++
control|)
block|{
name|b
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Skip the sort if this block is always sorted.  */
if|if
condition|(
operator|!
name|BLOCK_SHOULD_SORT
argument_list|(
name|b
argument_list|)
condition|)
name|sort_block_syms
argument_list|(
name|b
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|BLOCK_NSYMS
argument_list|(
name|b
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
name|sym
operator|=
name|BLOCK_SYM
argument_list|(
name|b
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|file_matches
argument_list|(
name|s
operator|->
name|filename
argument_list|,
name|files
argument_list|,
name|nfiles
argument_list|)
operator|&&
operator|(
operator|(
name|regexp
operator|==
name|NULL
operator|||
name|SYMBOL_MATCHES_REGEXP
argument_list|(
name|sym
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|kind
operator|==
name|VARIABLES_NAMESPACE
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|!=
name|LOC_TYPEDEF
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|!=
name|LOC_BLOCK
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|!=
name|LOC_CONST
operator|)
operator|||
operator|(
name|kind
operator|==
name|FUNCTIONS_NAMESPACE
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_BLOCK
operator|)
operator|||
operator|(
name|kind
operator|==
name|TYPES_NAMESPACE
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_TYPEDEF
operator|)
operator|||
operator|(
name|kind
operator|==
name|METHODS_NAMESPACE
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_BLOCK
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* match */
name|psr
operator|=
operator|(
expr|struct
name|symbol_search
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|symbol_search
argument_list|)
argument_list|)
expr_stmt|;
name|psr
operator|->
name|block
operator|=
name|i
expr_stmt|;
name|psr
operator|->
name|symtab
operator|=
name|s
expr_stmt|;
name|psr
operator|->
name|symbol
operator|=
name|sym
expr_stmt|;
name|psr
operator|->
name|msymbol
operator|=
name|NULL
expr_stmt|;
name|psr
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|tail
operator|==
name|NULL
condition|)
block|{
name|sr
operator|=
name|psr
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
operator|(
name|make_cleanup_func
operator|)
name|free_search_symbols
argument_list|,
name|sr
argument_list|)
expr_stmt|;
block|}
else|else
name|tail
operator|->
name|next
operator|=
name|psr
expr_stmt|;
name|tail
operator|=
name|psr
expr_stmt|;
block|}
block|}
block|}
name|prev_bv
operator|=
name|bv
expr_stmt|;
block|}
comment|/* If there are no eyes, avoid all contact.  I mean, if there are      no debug symbols, then print directly from the msymbol_vector.  */
if|if
condition|(
name|found_misc
operator|||
name|kind
operator|!=
name|FUNCTIONS_NAMESPACE
condition|)
block|{
name|ALL_MSYMBOLS
argument_list|(
argument|objfile
argument_list|,
argument|msymbol
argument_list|)
block|{
if|if
condition|(
name|MSYMBOL_TYPE
argument_list|(
name|msymbol
argument_list|)
operator|==
name|ourtype
operator|||
name|MSYMBOL_TYPE
argument_list|(
name|msymbol
argument_list|)
operator|==
name|ourtype2
operator|||
name|MSYMBOL_TYPE
argument_list|(
name|msymbol
argument_list|)
operator|==
name|ourtype3
operator|||
name|MSYMBOL_TYPE
argument_list|(
name|msymbol
argument_list|)
operator|==
name|ourtype4
condition|)
block|{
if|if
condition|(
name|regexp
operator|==
name|NULL
operator|||
name|SYMBOL_MATCHES_REGEXP
argument_list|(
name|msymbol
argument_list|)
condition|)
block|{
comment|/* Functions:  Look up by address. */
if|if
condition|(
name|kind
operator|!=
name|FUNCTIONS_NAMESPACE
operator|||
operator|(
literal|0
operator|==
name|find_pc_symtab
argument_list|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
argument_list|)
operator|)
condition|)
block|{
comment|/* Variables/Absolutes:  Look up by name */
if|if
condition|(
name|lookup_symbol
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|msymbol
argument_list|)
argument_list|,
operator|(
expr|struct
name|block
operator|*
operator|)
name|NULL
argument_list|,
name|VAR_NAMESPACE
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|symtab
operator|*
operator|*
operator|)
name|NULL
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* match */
name|psr
operator|=
operator|(
expr|struct
name|symbol_search
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|symbol_search
argument_list|)
argument_list|)
expr_stmt|;
name|psr
operator|->
name|block
operator|=
name|i
expr_stmt|;
name|psr
operator|->
name|msymbol
operator|=
name|msymbol
expr_stmt|;
name|psr
operator|->
name|symtab
operator|=
name|NULL
expr_stmt|;
name|psr
operator|->
name|symbol
operator|=
name|NULL
expr_stmt|;
name|psr
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|tail
operator|==
name|NULL
condition|)
block|{
name|sr
operator|=
name|psr
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
operator|(
name|make_cleanup_func
operator|)
name|free_search_symbols
argument_list|,
operator|&
name|sr
argument_list|)
expr_stmt|;
block|}
else|else
name|tail
operator|->
name|next
operator|=
name|psr
expr_stmt|;
name|tail
operator|=
name|psr
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
operator|*
name|matches
operator|=
name|sr
expr_stmt|;
if|if
condition|(
name|sr
operator|!=
name|NULL
condition|)
name|discard_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Helper function for symtab_symbol_info, this function uses    the data returned from search_symbols() to print information    regarding the match to gdb_stdout. */
end_comment

begin_function
specifier|static
name|void
name|print_symbol_info
parameter_list|(
name|kind
parameter_list|,
name|s
parameter_list|,
name|sym
parameter_list|,
name|block
parameter_list|,
name|last
parameter_list|)
name|namespace_enum
name|kind
decl_stmt|;
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|int
name|block
decl_stmt|;
name|char
modifier|*
name|last
decl_stmt|;
block|{
if|if
condition|(
name|last
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|last
argument_list|,
name|s
operator|->
name|filename
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|"\nFile "
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
name|s
operator|->
name|filename
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|":\n"
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|kind
operator|!=
name|TYPES_NAMESPACE
operator|&&
name|block
operator|==
name|STATIC_BLOCK
condition|)
name|printf_filtered
argument_list|(
literal|"static "
argument_list|)
expr_stmt|;
comment|/* Typedef that is not a C++ class */
if|if
condition|(
name|kind
operator|==
name|TYPES_NAMESPACE
operator|&&
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|!=
name|STRUCT_NAMESPACE
condition|)
name|c_typedef_print
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|,
name|sym
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
comment|/* variable, func, or typedef-that-is-c++-class */
elseif|else
if|if
condition|(
name|kind
operator|<
name|TYPES_NAMESPACE
operator|||
operator|(
name|kind
operator|==
name|TYPES_NAMESPACE
operator|&&
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|==
name|STRUCT_NAMESPACE
operator|)
condition|)
block|{
name|type_print
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|,
operator|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_TYPEDEF
condition|?
literal|""
else|:
name|SYMBOL_SOURCE_NAME
argument_list|(
name|sym
argument_list|)
operator|)
argument_list|,
name|gdb_stdout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|";\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
literal|0
comment|/* Tiemann says: "info methods was never implemented."  */
block|char *demangled_name;       c_type_print_base (TYPE_FN_FIELD_TYPE(t, block),                          gdb_stdout, 0, 0);        c_type_print_varspec_prefix (TYPE_FN_FIELD_TYPE(t, block),                                    gdb_stdout, 0);        if (TYPE_FN_FIELD_STUB (t, block))         check_stub_method (TYPE_DOMAIN_TYPE (type), j, block);       demangled_name =         cplus_demangle (TYPE_FN_FIELD_PHYSNAME (t, block),                         DMGL_ANSI | DMGL_PARAMS);       if (demangled_name == NULL)         fprintf_filtered (stream, "<badly mangled name %s>",                           TYPE_FN_FIELD_PHYSNAME (t, block));       else         {           fputs_filtered (demangled_name, stream);           free (demangled_name);         }
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/* This help function for symtab_symbol_info() prints information    for non-debugging symbols to gdb_stdout. */
end_comment

begin_function
specifier|static
name|void
name|print_msymbol_info
parameter_list|(
name|msymbol
parameter_list|)
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
block|{
name|printf_filtered
argument_list|(
literal|"	%08lx  %s\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
argument_list|,
name|SYMBOL_SOURCE_NAME
argument_list|(
name|msymbol
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is the guts of the commands "info functions", "info types", and    "info variables". It calls search_symbols to find all matches and then    print_[m]symbol_info to print out some useful information about the    matches. */
end_comment

begin_function
specifier|static
name|void
name|symtab_symbol_info
parameter_list|(
name|regexp
parameter_list|,
name|kind
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|regexp
decl_stmt|;
name|namespace_enum
name|kind
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|classnames
index|[]
init|=
block|{
literal|"variable"
block|,
literal|"function"
block|,
literal|"type"
block|,
literal|"method"
block|}
decl_stmt|;
name|struct
name|symbol_search
modifier|*
name|symbols
decl_stmt|;
name|struct
name|symbol_search
modifier|*
name|p
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|char
modifier|*
name|last_filename
init|=
name|NULL
decl_stmt|;
name|int
name|first
init|=
literal|1
decl_stmt|;
comment|/* must make sure that if we're interrupted, symbols gets freed */
name|search_symbols
argument_list|(
name|regexp
argument_list|,
name|kind
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|symbols
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
operator|(
name|make_cleanup_func
operator|)
name|free_search_symbols
argument_list|,
name|symbols
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
name|regexp
condition|?
literal|"All %ss matching regular expression \"%s\":\n"
else|:
literal|"All defined %ss:\n"
argument_list|,
name|classnames
index|[
call|(
name|int
call|)
argument_list|(
name|kind
operator|-
name|LABEL_NAMESPACE
operator|-
literal|1
argument_list|)
index|]
argument_list|,
name|regexp
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|symbols
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|QUIT
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|msymbol
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|first
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"\nNon-debugging symbols:\n"
argument_list|)
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
name|print_msymbol_info
argument_list|(
name|p
operator|->
name|msymbol
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|print_symbol_info
argument_list|(
name|kind
argument_list|,
name|p
operator|->
name|symtab
argument_list|,
name|p
operator|->
name|symbol
argument_list|,
name|p
operator|->
name|block
argument_list|,
name|last_filename
argument_list|)
expr_stmt|;
name|last_filename
operator|=
name|p
operator|->
name|symtab
operator|->
name|filename
expr_stmt|;
block|}
block|}
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|variables_info
parameter_list|(
name|regexp
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|regexp
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|symtab_symbol_info
argument_list|(
name|regexp
argument_list|,
name|VARIABLES_NAMESPACE
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|functions_info
parameter_list|(
name|regexp
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|regexp
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|symtab_symbol_info
argument_list|(
name|regexp
argument_list|,
name|FUNCTIONS_NAMESPACE
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|types_info
parameter_list|(
name|regexp
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|regexp
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|symtab_symbol_info
argument_list|(
name|regexp
argument_list|,
name|TYPES_NAMESPACE
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Tiemann says: "info methods was never implemented."  */
end_comment

begin_endif
unit|static void methods_info (regexp)      char *regexp; {   symtab_symbol_info (regexp, METHODS_NAMESPACE, 0, from_tty); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_comment
comment|/* Breakpoint all functions matching regular expression. */
end_comment

begin_function
specifier|static
name|void
name|rbreak_command
parameter_list|(
name|regexp
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|regexp
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|struct
name|symbol_search
modifier|*
name|ss
decl_stmt|;
name|struct
name|symbol_search
modifier|*
name|p
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|search_symbols
argument_list|(
name|regexp
argument_list|,
name|FUNCTIONS_NAMESPACE
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|ss
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
operator|(
name|make_cleanup_func
operator|)
name|free_search_symbols
argument_list|,
name|ss
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|ss
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|p
operator|->
name|msymbol
operator|==
name|NULL
condition|)
block|{
name|char
modifier|*
name|string
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|p
operator|->
name|symtab
operator|->
name|filename
argument_list|)
operator|+
name|strlen
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|p
operator|->
name|symbol
argument_list|)
argument_list|)
operator|+
literal|4
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|string
argument_list|,
name|p
operator|->
name|symtab
operator|->
name|filename
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|string
argument_list|,
literal|":'"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|string
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|p
operator|->
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|string
argument_list|,
literal|"'"
argument_list|)
expr_stmt|;
name|break_command
argument_list|(
name|string
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
name|print_symbol_info
argument_list|(
name|FUNCTIONS_NAMESPACE
argument_list|,
name|p
operator|->
name|symtab
argument_list|,
name|p
operator|->
name|symbol
argument_list|,
name|p
operator|->
name|block
argument_list|,
name|p
operator|->
name|symtab
operator|->
name|filename
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|break_command
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|p
operator|->
name|msymbol
argument_list|)
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"<function, no debug info> %s;\n"
argument_list|,
name|SYMBOL_SOURCE_NAME
argument_list|(
name|p
operator|->
name|msymbol
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return Nonzero if block a is lexically nested within block b,    or if a and b have the same pc range.    Return zero otherwise. */
end_comment

begin_function
name|int
name|contained_in
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|struct
name|block
modifier|*
name|a
decl_stmt|,
decl|*
name|b
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
operator|!
name|a
operator|||
operator|!
name|b
condition|)
return|return
literal|0
return|;
return|return
name|BLOCK_START
argument_list|(
name|a
argument_list|)
operator|>=
name|BLOCK_START
argument_list|(
name|b
argument_list|)
operator|&&
name|BLOCK_END
argument_list|(
name|a
argument_list|)
operator|<=
name|BLOCK_END
argument_list|(
name|b
argument_list|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Helper routine for make_symbol_completion_list.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|return_val_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|return_val_index
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|return_val
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|COMPLETION_LIST_ADD_SYMBOL
parameter_list|(
name|symbol
parameter_list|,
name|sym_text
parameter_list|,
name|len
parameter_list|,
name|text
parameter_list|,
name|word
parameter_list|)
define|\
value|do { \     if (SYMBOL_DEMANGLED_NAME (symbol) != NULL) \
comment|/* Put only the mangled name on the list.  */
value|\
comment|/* Advantage:  "b foo<TAB>" completes to "b foo(int, int)" */
value|\
comment|/* Disadvantage:  "b foo__i<TAB>" doesn't complete.  */
value|\       completion_list_add_name \ 	(SYMBOL_DEMANGLED_NAME (symbol), (sym_text), (len), (text), (word)); \     else \       completion_list_add_name \ 	(SYMBOL_NAME (symbol), (sym_text), (len), (text), (word)); \   } while (0)
end_define

begin_comment
comment|/*  Test to see if the symbol specified by SYMNAME (which is already     demangled for C++ symbols) matches SYM_TEXT in the first SYM_TEXT_LEN     characters.  If so, add it to the current completion list. */
end_comment

begin_function
specifier|static
name|void
name|completion_list_add_name
parameter_list|(
name|symname
parameter_list|,
name|sym_text
parameter_list|,
name|sym_text_len
parameter_list|,
name|text
parameter_list|,
name|word
parameter_list|)
name|char
modifier|*
name|symname
decl_stmt|;
name|char
modifier|*
name|sym_text
decl_stmt|;
name|int
name|sym_text_len
decl_stmt|;
name|char
modifier|*
name|text
decl_stmt|;
name|char
modifier|*
name|word
decl_stmt|;
block|{
name|int
name|newsize
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* clip symbols that cannot match */
if|if
condition|(
name|strncmp
argument_list|(
name|symname
argument_list|,
name|sym_text
argument_list|,
name|sym_text_len
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return;
block|}
comment|/* Clip any symbol names that we've already considered.  (This is a      time optimization)  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|return_val_index
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|STREQ
argument_list|(
name|symname
argument_list|,
name|return_val
index|[
name|i
index|]
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
comment|/* We have a match for a completion, so add SYMNAME to the current list      of matches. Note that the name is moved to freshly malloc'd space. */
block|{
name|char
modifier|*
name|new
decl_stmt|;
if|if
condition|(
name|word
operator|==
name|sym_text
condition|)
block|{
name|new
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|symname
argument_list|)
operator|+
literal|5
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|new
argument_list|,
name|symname
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|word
operator|>
name|sym_text
condition|)
block|{
comment|/* Return some portion of symname.  */
name|new
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|symname
argument_list|)
operator|+
literal|5
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|new
argument_list|,
name|symname
operator|+
operator|(
name|word
operator|-
name|sym_text
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Return some of SYM_TEXT plus symname.  */
name|new
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|symname
argument_list|)
operator|+
operator|(
name|sym_text
operator|-
name|word
operator|)
operator|+
literal|5
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|new
argument_list|,
name|word
argument_list|,
name|sym_text
operator|-
name|word
argument_list|)
expr_stmt|;
name|new
index|[
name|sym_text
operator|-
name|word
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strcat
argument_list|(
name|new
argument_list|,
name|symname
argument_list|)
expr_stmt|;
block|}
comment|/* Recheck for duplicates if we intend to add a modified symbol.  */
if|if
condition|(
name|word
operator|!=
name|sym_text
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|return_val_index
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|STREQ
argument_list|(
name|new
argument_list|,
name|return_val
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|new
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
if|if
condition|(
name|return_val_index
operator|+
literal|3
operator|>
name|return_val_size
condition|)
block|{
name|newsize
operator|=
operator|(
name|return_val_size
operator|*=
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
expr_stmt|;
name|return_val
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|return_val
argument_list|,
name|newsize
argument_list|)
expr_stmt|;
block|}
name|return_val
index|[
name|return_val_index
operator|++
index|]
operator|=
name|new
expr_stmt|;
name|return_val
index|[
name|return_val_index
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return a NULL terminated array of all symbols (regardless of class) which    begin by matching TEXT.  If the answer is no symbols, then the return value    is an array which contains only a NULL pointer.     Problem: All of the symbols have to be copied because readline frees them.    I'm not going to worry about this; hopefully there won't be that many.  */
end_comment

begin_function
name|char
modifier|*
modifier|*
name|make_symbol_completion_list
parameter_list|(
name|text
parameter_list|,
name|word
parameter_list|)
name|char
modifier|*
name|text
decl_stmt|;
name|char
modifier|*
name|word
decl_stmt|;
block|{
specifier|register
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
specifier|register
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
specifier|register
name|struct
name|partial_symtab
modifier|*
name|ps
decl_stmt|;
specifier|register
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
specifier|register
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
specifier|register
name|struct
name|block
modifier|*
name|b
decl_stmt|,
modifier|*
name|surrounding_static_block
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|struct
name|partial_symbol
modifier|*
modifier|*
name|psym
decl_stmt|;
comment|/* The symbol we are completing on.  Points in same buffer as text.  */
name|char
modifier|*
name|sym_text
decl_stmt|;
comment|/* Length of sym_text.  */
name|int
name|sym_text_len
decl_stmt|;
comment|/* Now look for the symbol we are supposed to complete on.      FIXME: This should be language-specific.  */
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|quote_found
decl_stmt|;
name|char
modifier|*
name|quote_pos
init|=
name|NULL
decl_stmt|;
comment|/* First see if this is a quoted string.  */
name|quote_found
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|p
operator|=
name|text
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
operator|++
name|p
control|)
block|{
if|if
condition|(
name|quote_found
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
name|quote_found
condition|)
comment|/* Found close quote.  */
name|quote_found
operator|=
literal|'\0'
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'\\'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
name|quote_found
condition|)
comment|/* A backslash followed by the quote character 		 doesn't end the string.  */
operator|++
name|p
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'\''
operator|||
operator|*
name|p
operator|==
literal|'"'
condition|)
block|{
name|quote_found
operator|=
operator|*
name|p
expr_stmt|;
name|quote_pos
operator|=
name|p
expr_stmt|;
block|}
block|}
if|if
condition|(
name|quote_found
operator|==
literal|'\''
condition|)
comment|/* A string within single quotes can be a symbol, so complete on it.  */
name|sym_text
operator|=
name|quote_pos
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|quote_found
operator|==
literal|'"'
condition|)
comment|/* A double-quoted string is never a symbol, nor does it make sense 	 to complete it any other way.  */
return|return
name|NULL
return|;
else|else
block|{
comment|/* It is not a quoted string.  Break it based on the characters 	   which are in symbols.  */
while|while
condition|(
name|p
operator|>
name|text
condition|)
block|{
if|if
condition|(
name|isalnum
argument_list|(
name|p
index|[
operator|-
literal|1
index|]
argument_list|)
operator|||
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'_'
operator|||
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'\0'
condition|)
operator|--
name|p
expr_stmt|;
else|else
break|break;
block|}
name|sym_text
operator|=
name|p
expr_stmt|;
block|}
block|}
name|sym_text_len
operator|=
name|strlen
argument_list|(
name|sym_text
argument_list|)
expr_stmt|;
name|return_val_size
operator|=
literal|100
expr_stmt|;
name|return_val_index
operator|=
literal|0
expr_stmt|;
name|return_val
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|return_val_size
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|return_val
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* Look through the partial symtabs for all symbols which begin      by matching SYM_TEXT.  Add each one that you find to the list.  */
name|ALL_PSYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|ps
argument_list|)
block|{
comment|/* If the psymtab's been read in we'll get it when we search 	 through the blockvector.  */
if|if
condition|(
name|ps
operator|->
name|readin
condition|)
continue|continue;
for|for
control|(
name|psym
operator|=
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
operator|+
name|ps
operator|->
name|globals_offset
init|;
name|psym
operator|<
operator|(
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
operator|+
name|ps
operator|->
name|globals_offset
operator|+
name|ps
operator|->
name|n_global_syms
operator|)
condition|;
name|psym
operator|++
control|)
block|{
comment|/* If interrupted, then quit. */
name|QUIT
expr_stmt|;
name|COMPLETION_LIST_ADD_SYMBOL
argument_list|(
operator|*
name|psym
argument_list|,
name|sym_text
argument_list|,
name|sym_text_len
argument_list|,
name|text
argument_list|,
name|word
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|psym
operator|=
name|objfile
operator|->
name|static_psymbols
operator|.
name|list
operator|+
name|ps
operator|->
name|statics_offset
init|;
name|psym
operator|<
operator|(
name|objfile
operator|->
name|static_psymbols
operator|.
name|list
operator|+
name|ps
operator|->
name|statics_offset
operator|+
name|ps
operator|->
name|n_static_syms
operator|)
condition|;
name|psym
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
name|COMPLETION_LIST_ADD_SYMBOL
argument_list|(
operator|*
name|psym
argument_list|,
name|sym_text
argument_list|,
name|sym_text_len
argument_list|,
name|text
argument_list|,
name|word
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* At this point scan through the misc symbol vectors and add each      symbol you find to the list.  Eventually we want to ignore      anything that isn't a text symbol (everything else will be      handled by the psymtab code above).  */
name|ALL_MSYMBOLS
argument_list|(
argument|objfile
argument_list|,
argument|msymbol
argument_list|)
block|{
name|QUIT
expr_stmt|;
name|COMPLETION_LIST_ADD_SYMBOL
argument_list|(
name|msymbol
argument_list|,
name|sym_text
argument_list|,
name|sym_text_len
argument_list|,
name|text
argument_list|,
name|word
argument_list|)
expr_stmt|;
block|}
comment|/* Search upwards from currently selected frame (so that we can      complete on local vars.  */
for|for
control|(
name|b
operator|=
name|get_selected_block
argument_list|()
init|;
name|b
operator|!=
name|NULL
condition|;
name|b
operator|=
name|BLOCK_SUPERBLOCK
argument_list|(
name|b
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|BLOCK_SUPERBLOCK
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|surrounding_static_block
operator|=
name|b
expr_stmt|;
comment|/* For elmin of dups */
block|}
comment|/* Also catch fields of types defined in this places which match our 	 text string.  Only complete on types visible from current context. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BLOCK_NSYMS
argument_list|(
name|b
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|sym
operator|=
name|BLOCK_SYM
argument_list|(
name|b
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|COMPLETION_LIST_ADD_SYMBOL
argument_list|(
name|sym
argument_list|,
name|sym_text
argument_list|,
name|sym_text_len
argument_list|,
name|text
argument_list|,
name|word
argument_list|)
expr_stmt|;
if|if
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_TYPEDEF
condition|)
block|{
name|struct
name|type
modifier|*
name|t
init|=
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
decl_stmt|;
name|enum
name|type_code
name|c
init|=
name|TYPE_CODE
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|TYPE_CODE_UNION
operator|||
name|c
operator|==
name|TYPE_CODE_STRUCT
condition|)
block|{
for|for
control|(
name|j
operator|=
name|TYPE_N_BASECLASSES
argument_list|(
name|t
argument_list|)
init|;
name|j
operator|<
name|TYPE_NFIELDS
argument_list|(
name|t
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|TYPE_FIELD_NAME
argument_list|(
name|t
argument_list|,
name|j
argument_list|)
condition|)
block|{
name|completion_list_add_name
argument_list|(
name|TYPE_FIELD_NAME
argument_list|(
name|t
argument_list|,
name|j
argument_list|)
argument_list|,
name|sym_text
argument_list|,
name|sym_text_len
argument_list|,
name|text
argument_list|,
name|word
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
comment|/* Go through the symtabs and check the externs and statics for      symbols which match.  */
name|ALL_SYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
block|{
name|QUIT
expr_stmt|;
name|b
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BLOCK_NSYMS
argument_list|(
name|b
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|sym
operator|=
name|BLOCK_SYM
argument_list|(
name|b
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|COMPLETION_LIST_ADD_SYMBOL
argument_list|(
name|sym
argument_list|,
name|sym_text
argument_list|,
name|sym_text_len
argument_list|,
name|text
argument_list|,
name|word
argument_list|)
expr_stmt|;
block|}
block|}
name|ALL_SYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
block|{
name|QUIT
expr_stmt|;
name|b
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
argument_list|,
name|STATIC_BLOCK
argument_list|)
expr_stmt|;
comment|/* Don't do this block twice.  */
if|if
condition|(
name|b
operator|==
name|surrounding_static_block
condition|)
continue|continue;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BLOCK_NSYMS
argument_list|(
name|b
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|sym
operator|=
name|BLOCK_SYM
argument_list|(
name|b
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|COMPLETION_LIST_ADD_SYMBOL
argument_list|(
name|sym
argument_list|,
name|sym_text
argument_list|,
name|sym_text_len
argument_list|,
name|text
argument_list|,
name|word
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|return_val
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Determine if PC is in the prologue of a function.  The prologue is the area    between the first instruction of a function, and the first executable line.    Returns 1 if PC *might* be in prologue, 0 if definately *not* in prologue.     If non-zero, func_start is where we think the prologue starts, possibly    by previous examination of symbol table information.  */
end_comment

begin_function
name|int
name|in_prologue
parameter_list|(
name|pc
parameter_list|,
name|func_start
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
name|CORE_ADDR
name|func_start
decl_stmt|;
block|{
if|#
directive|if
literal|0
block|struct symtab_and_line sal;   CORE_ADDR func_addr, func_end;    if (!find_pc_partial_function (pc, NULL,&func_addr,&func_end))     goto nosyms;
comment|/* Might be in prologue */
block|sal = find_pc_line (func_addr, 0);    if (sal.line == 0)     goto nosyms;
comment|/* sal.end is the address of the first instruction past sal.line. */
block|if (sal.end> func_addr&& sal.end<= func_end)
comment|/* Is prologue in function? */
block|return pc< sal.end;
comment|/* Yes, is pc in prologue? */
comment|/* The line after the prologue seems to be outside the function.  In this      case, tell the caller to find the prologue the hard way.  */
block|return 1;
comment|/* Come here when symtabs don't contain line # info.  In this case, it is    likely that the user has stepped into a library function w/o symbols, or    is doing a stepi/nexti through code without symbols.  */
block|nosyms:
endif|#
directive|endif
comment|/* If func_start is zero (meaning unknown) then we don't know whether pc is    in the prologue or not.  I.E. it might be. */
if|if
condition|(
operator|!
name|func_start
condition|)
return|return
literal|1
return|;
comment|/* We need to call the target-specific prologue skipping functions with the    function's start address because PC may be pointing at an instruction that    could be mistakenly considered part of the prologue.  */
name|SKIP_PROLOGUE
argument_list|(
name|func_start
argument_list|)
expr_stmt|;
return|return
name|pc
operator|<
name|func_start
return|;
block|}
end_function

begin_comment
comment|/* Begin overload resolution functions */
end_comment

begin_comment
comment|/* Helper routine for make_symbol_completion_list.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sym_return_val_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sym_return_val_index
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|symbol
modifier|*
modifier|*
name|sym_return_val
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  Test to see if the symbol specified by SYMNAME (which is already     demangled for C++ symbols) matches SYM_TEXT in the first SYM_TEXT_LEN     characters.  If so, add it to the current completion list. */
end_comment

begin_function
specifier|static
name|void
name|overload_list_add_symbol
parameter_list|(
name|sym
parameter_list|,
name|oload_name
parameter_list|)
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|char
modifier|*
name|oload_name
decl_stmt|;
block|{
name|int
name|newsize
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Get the demangled name without parameters */
name|char
modifier|*
name|sym_name
init|=
name|cplus_demangle
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|DMGL_ARM
operator||
name|DMGL_ANSI
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|sym_name
condition|)
block|{
name|sym_name
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|sym_name
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* skip symbols that cannot match */
if|if
condition|(
name|strcmp
argument_list|(
name|sym_name
argument_list|,
name|oload_name
argument_list|)
operator|!=
literal|0
condition|)
return|return;
comment|/* If there is no type information, we can't do anything, so skip */
if|if
condition|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|==
name|NULL
condition|)
return|return;
comment|/* skip any symbols that we've already considered. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sym_return_val_index
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|sym_return_val
index|[
name|i
index|]
argument_list|)
argument_list|)
condition|)
return|return;
comment|/* We have a match for an overload instance, so add SYM to the current list    * of overload instances */
if|if
condition|(
name|sym_return_val_index
operator|+
literal|3
operator|>
name|sym_return_val_size
condition|)
block|{
name|newsize
operator|=
operator|(
name|sym_return_val_size
operator|*=
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
operator|*
argument_list|)
expr_stmt|;
name|sym_return_val
operator|=
operator|(
expr|struct
name|symbol
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sym_return_val
argument_list|,
name|newsize
argument_list|)
expr_stmt|;
block|}
name|sym_return_val
index|[
name|sym_return_val_index
operator|++
index|]
operator|=
name|sym
expr_stmt|;
name|sym_return_val
index|[
name|sym_return_val_index
index|]
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|sym_name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a null-terminated list of pointers to function symbols that  * match name of the supplied symbol FSYM.  * This is used in finding all overloaded instances of a function name.  * This has been modified from make_symbol_completion_list.  */
end_comment

begin_function
name|struct
name|symbol
modifier|*
modifier|*
name|make_symbol_overload_list
parameter_list|(
name|fsym
parameter_list|)
name|struct
name|symbol
modifier|*
name|fsym
decl_stmt|;
block|{
specifier|register
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
specifier|register
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
specifier|register
name|struct
name|partial_symtab
modifier|*
name|ps
decl_stmt|;
specifier|register
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
specifier|register
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
specifier|register
name|struct
name|block
modifier|*
name|b
decl_stmt|,
modifier|*
name|surrounding_static_block
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|struct
name|partial_symbol
modifier|*
modifier|*
name|psym
decl_stmt|;
comment|/* The name we are completing on. */
name|char
modifier|*
name|oload_name
init|=
name|NULL
decl_stmt|;
comment|/* Length of name.  */
name|int
name|oload_name_len
init|=
literal|0
decl_stmt|;
comment|/* Look for the symbol we are supposed to complete on.    * FIXME: This should be language-specific.  */
name|oload_name
operator|=
name|cplus_demangle
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|fsym
argument_list|)
argument_list|,
name|DMGL_ARM
operator||
name|DMGL_ANSI
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|oload_name
condition|)
block|{
name|oload_name
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|fsym
argument_list|)
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|oload_name
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|fsym
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|oload_name_len
operator|=
name|strlen
argument_list|(
name|oload_name
argument_list|)
expr_stmt|;
name|sym_return_val_size
operator|=
literal|100
expr_stmt|;
name|sym_return_val_index
operator|=
literal|0
expr_stmt|;
name|sym_return_val
operator|=
operator|(
expr|struct
name|symbol
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|sym_return_val_size
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|sym_return_val
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* Look through the partial symtabs for all symbols which begin      by matching OLOAD_NAME.  Add each one that you find to the list.  */
name|ALL_PSYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|ps
argument_list|)
block|{
comment|/* If the psymtab's been read in we'll get it when we search 	 through the blockvector.  */
if|if
condition|(
name|ps
operator|->
name|readin
condition|)
continue|continue;
for|for
control|(
name|psym
operator|=
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
operator|+
name|ps
operator|->
name|globals_offset
init|;
name|psym
operator|<
operator|(
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
operator|+
name|ps
operator|->
name|globals_offset
operator|+
name|ps
operator|->
name|n_global_syms
operator|)
condition|;
name|psym
operator|++
control|)
block|{
comment|/* If interrupted, then quit. */
name|QUIT
expr_stmt|;
name|overload_list_add_symbol
argument_list|(
operator|*
name|psym
argument_list|,
name|oload_name
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|psym
operator|=
name|objfile
operator|->
name|static_psymbols
operator|.
name|list
operator|+
name|ps
operator|->
name|statics_offset
init|;
name|psym
operator|<
operator|(
name|objfile
operator|->
name|static_psymbols
operator|.
name|list
operator|+
name|ps
operator|->
name|statics_offset
operator|+
name|ps
operator|->
name|n_static_syms
operator|)
condition|;
name|psym
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
name|overload_list_add_symbol
argument_list|(
operator|*
name|psym
argument_list|,
name|oload_name
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* At this point scan through the misc symbol vectors and add each      symbol you find to the list.  Eventually we want to ignore      anything that isn't a text symbol (everything else will be      handled by the psymtab code above).  */
name|ALL_MSYMBOLS
argument_list|(
argument|objfile
argument_list|,
argument|msymbol
argument_list|)
block|{
name|QUIT
expr_stmt|;
name|overload_list_add_symbol
argument_list|(
name|msymbol
argument_list|,
name|oload_name
argument_list|)
expr_stmt|;
block|}
comment|/* Search upwards from currently selected frame (so that we can      complete on local vars.  */
for|for
control|(
name|b
operator|=
name|get_selected_block
argument_list|()
init|;
name|b
operator|!=
name|NULL
condition|;
name|b
operator|=
name|BLOCK_SUPERBLOCK
argument_list|(
name|b
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|BLOCK_SUPERBLOCK
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|surrounding_static_block
operator|=
name|b
expr_stmt|;
comment|/* For elimination of dups */
block|}
comment|/* Also catch fields of types defined in this places which match our 	 text string.  Only complete on types visible from current context. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BLOCK_NSYMS
argument_list|(
name|b
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|sym
operator|=
name|BLOCK_SYM
argument_list|(
name|b
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|overload_list_add_symbol
argument_list|(
name|sym
argument_list|,
name|oload_name
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Go through the symtabs and check the externs and statics for      symbols which match.  */
name|ALL_SYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
block|{
name|QUIT
expr_stmt|;
name|b
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BLOCK_NSYMS
argument_list|(
name|b
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|sym
operator|=
name|BLOCK_SYM
argument_list|(
name|b
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|overload_list_add_symbol
argument_list|(
name|sym
argument_list|,
name|oload_name
argument_list|)
expr_stmt|;
block|}
block|}
name|ALL_SYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
block|{
name|QUIT
expr_stmt|;
name|b
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
argument_list|,
name|STATIC_BLOCK
argument_list|)
expr_stmt|;
comment|/* Don't do this block twice.  */
if|if
condition|(
name|b
operator|==
name|surrounding_static_block
condition|)
continue|continue;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BLOCK_NSYMS
argument_list|(
name|b
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|sym
operator|=
name|BLOCK_SYM
argument_list|(
name|b
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|overload_list_add_symbol
argument_list|(
name|sym
argument_list|,
name|oload_name
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|oload_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|sym_return_val
operator|)
return|;
block|}
end_function

begin_comment
comment|/* End of overload resolution functions */
end_comment

begin_escape
end_escape

begin_function
name|void
name|_initialize_symtab
parameter_list|()
block|{
name|add_info
argument_list|(
literal|"variables"
argument_list|,
name|variables_info
argument_list|,
literal|"All global and static variable names, or those matching REGEXP."
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbx_commands
condition|)
name|add_com
argument_list|(
literal|"whereis"
argument_list|,
name|class_info
argument_list|,
name|variables_info
argument_list|,
literal|"All global and static variable names, or those matching REGEXP."
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"functions"
argument_list|,
name|functions_info
argument_list|,
literal|"All function names, or those matching REGEXP."
argument_list|)
expr_stmt|;
comment|/* FIXME:  This command has at least the following problems:      1.  It prints builtin types (in a very strange and confusing fashion).      2.  It doesn't print right, e.g. with          typedef struct foo *FOO 	 type_print prints "FOO" when we want to make it (in this situation) 	 print "struct foo *".      I also think "ptype" or "whatis" is more likely to be useful (but if      there is much disagreement "info types" can be fixed).  */
name|add_info
argument_list|(
literal|"types"
argument_list|,
name|types_info
argument_list|,
literal|"All type names, or those matching REGEXP."
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|add_info ("methods", methods_info, 	    "All method names, or those matching REGEXP::REGEXP.\n\ If the class qualifier is omitted, it is assumed to be the current scope.\n\ If the first REGEXP is omitted, then all methods matching the second REGEXP\n\ are listed.");
endif|#
directive|endif
name|add_info
argument_list|(
literal|"sources"
argument_list|,
name|sources_info
argument_list|,
literal|"Source files in the program."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"rbreak"
argument_list|,
name|class_breakpoint
argument_list|,
name|rbreak_command
argument_list|,
literal|"Set a breakpoint for all functions matching REGEXP."
argument_list|)
expr_stmt|;
if|if
condition|(
name|xdb_commands
condition|)
block|{
name|add_com
argument_list|(
literal|"lf"
argument_list|,
name|class_info
argument_list|,
name|sources_info
argument_list|,
literal|"Source files in the program"
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"lg"
argument_list|,
name|class_info
argument_list|,
name|variables_info
argument_list|,
literal|"All global and static variable names, or those matching REGEXP."
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize the one built-in type that isn't language dependent... */
name|builtin_type_error
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_ERROR
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"<unknown type>"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

