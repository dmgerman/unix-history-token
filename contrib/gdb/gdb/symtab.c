begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Symbol table lookup for the GNU debugger, GDB.     Copyright 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994,    1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004    Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"call-cmds.h"
end_include

begin_include
include|#
directive|include
file|"gdb_regex.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"linespec.h"
end_include

begin_include
include|#
directive|include
file|"source.h"
end_include

begin_include
include|#
directive|include
file|"filenames.h"
end_include

begin_comment
comment|/* for FILENAME_CMP */
end_comment

begin_include
include|#
directive|include
file|"objc-lang.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_include
include|#
directive|include
file|"gdb_obstack.h"
end_include

begin_include
include|#
directive|include
file|"block.h"
end_include

begin_include
include|#
directive|include
file|"dictionary.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"gdb_stat.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"cp-abi.h"
end_include

begin_comment
comment|/* Prototypes for local functions */
end_comment

begin_function_decl
specifier|static
name|void
name|completion_list_add_name
parameter_list|(
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rbreak_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|types_info
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|functions_info
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|variables_info
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sources_info
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|output_source_filename
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|find_line_common
parameter_list|(
name|struct
name|linetable
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* This one is used by linespec.c */
end_comment

begin_function_decl
name|char
modifier|*
name|operator_chars
parameter_list|(
name|char
modifier|*
name|p
parameter_list|,
name|char
modifier|*
modifier|*
name|end
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|symbol
modifier|*
name|lookup_symbol_aux
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|linkage_name
parameter_list|,
specifier|const
name|struct
name|block
modifier|*
name|block
parameter_list|,
specifier|const
name|domain_enum
name|domain
parameter_list|,
name|int
modifier|*
name|is_a_field_of_this
parameter_list|,
name|struct
name|symtab
modifier|*
modifier|*
name|symtab
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|symbol
modifier|*
name|lookup_symbol_aux_local
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|linkage_name
parameter_list|,
specifier|const
name|struct
name|block
modifier|*
name|block
parameter_list|,
specifier|const
name|domain_enum
name|domain
parameter_list|,
name|struct
name|symtab
modifier|*
modifier|*
name|symtab
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|symbol
modifier|*
name|lookup_symbol_aux_symtabs
parameter_list|(
name|int
name|block_index
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|linkage_name
parameter_list|,
specifier|const
name|domain_enum
name|domain
parameter_list|,
name|struct
name|symtab
modifier|*
modifier|*
name|symtab
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|symbol
modifier|*
name|lookup_symbol_aux_psymtabs
parameter_list|(
name|int
name|block_index
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|linkage_name
parameter_list|,
specifier|const
name|domain_enum
name|domain
parameter_list|,
name|struct
name|symtab
modifier|*
modifier|*
name|symtab
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static struct symbol *lookup_symbol_aux_minsyms (const char *name, 					  const char *linkage_name, 					  const domain_enum domain, 					  int *is_a_field_of_this, 					  struct symtab **symtab);
endif|#
directive|endif
end_endif

begin_comment
comment|/* This flag is used in hppa-tdep.c, and set in hp-symtab-read.c */
end_comment

begin_comment
comment|/* Signals the presence of objects compiled by HP compilers */
end_comment

begin_decl_stmt
name|int
name|hp_som_som_object_present
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|fixup_section
parameter_list|(
name|struct
name|general_symbol_info
modifier|*
parameter_list|,
name|struct
name|objfile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|file_matches
parameter_list|(
name|char
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_symbol_info
parameter_list|(
name|domain_enum
parameter_list|,
name|struct
name|symtab
modifier|*
parameter_list|,
name|struct
name|symbol
modifier|*
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_msymbol_info
parameter_list|(
name|struct
name|minimal_symbol
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|symtab_symbol_info
parameter_list|(
name|char
modifier|*
parameter_list|,
name|domain_enum
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|_initialize_symtab
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* */
end_comment

begin_comment
comment|/* The single non-language-specific builtin type */
end_comment

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_error
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Block in which the most recently searched-for symbol was found.    Might be better to make this a parameter to lookup_symbol and     value_of_this. */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|block
modifier|*
name|block_found
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Check for a symtab of a specific name; first in symtabs, then in    psymtabs.  *If* there is no '/' in the name, a match after a '/'    in the symtab filename will also work.  */
end_comment

begin_function
name|struct
name|symtab
modifier|*
name|lookup_symtab
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
name|struct
name|partial_symtab
modifier|*
name|ps
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|char
modifier|*
name|real_path
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|full_path
init|=
name|NULL
decl_stmt|;
comment|/* Here we are interested in canonicalizing an absolute path, not      absolutizing a relative path.  */
if|if
condition|(
name|IS_ABSOLUTE_PATH
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|full_path
operator|=
name|xfullpath
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|full_path
argument_list|)
expr_stmt|;
name|real_path
operator|=
name|gdb_realpath
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|real_path
argument_list|)
expr_stmt|;
block|}
name|got_symtab
label|:
comment|/* First, search for an exact match */
name|ALL_SYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
block|{
if|if
condition|(
name|FILENAME_CMP
argument_list|(
name|name
argument_list|,
name|s
operator|->
name|filename
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|s
return|;
block|}
comment|/* If the user gave us an absolute path, try to find the file in        this symtab and use its absolute path.  */
if|if
condition|(
name|full_path
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|fp
init|=
name|symtab_to_filename
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|FILENAME_CMP
argument_list|(
name|full_path
argument_list|,
name|fp
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|s
return|;
block|}
block|}
if|if
condition|(
name|real_path
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|rp
init|=
name|gdb_realpath
argument_list|(
name|symtab_to_filename
argument_list|(
name|s
argument_list|)
argument_list|)
decl_stmt|;
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|rp
argument_list|)
expr_stmt|;
if|if
condition|(
name|FILENAME_CMP
argument_list|(
name|real_path
argument_list|,
name|rp
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|s
return|;
block|}
block|}
block|}
comment|/* Now, search for a matching tail (only if name doesn't have any dirs) */
if|if
condition|(
name|lbasename
argument_list|(
name|name
argument_list|)
operator|==
name|name
condition|)
name|ALL_SYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
block|{
if|if
condition|(
name|FILENAME_CMP
argument_list|(
name|lbasename
argument_list|(
name|s
operator|->
name|filename
argument_list|)
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|s
return|;
block|}
comment|/* Same search rules as above apply here, but now we look thru the      psymtabs.  */
name|ps
operator|=
name|lookup_partial_symtab
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ps
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|ps
operator|->
name|readin
condition|)
name|error
argument_list|(
literal|"Internal: readin %s pst for `%s' found when no symtab found."
argument_list|,
name|ps
operator|->
name|filename
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|s
operator|=
name|PSYMTAB_TO_SYMTAB
argument_list|(
name|ps
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
condition|)
return|return
name|s
return|;
comment|/* At this point, we have located the psymtab for this file, but      the conversion to a symtab has failed.  This usually happens      when we are looking up an include file.  In this case,      PSYMTAB_TO_SYMTAB doesn't return a symtab, even though one has      been created.  So, we need to run through the symtabs again in      order to find the file.      XXX - This is a crock, and should be fixed inside of the the      symbol parsing routines. */
goto|goto
name|got_symtab
goto|;
block|}
end_function

begin_comment
comment|/* Lookup the partial symbol table of a source file named NAME.    *If* there is no '/' in the name, a match after a '/'    in the psymtab filename will also work.  */
end_comment

begin_function
name|struct
name|partial_symtab
modifier|*
name|lookup_partial_symtab
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|char
modifier|*
name|full_path
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|real_path
init|=
name|NULL
decl_stmt|;
comment|/* Here we are interested in canonicalizing an absolute path, not      absolutizing a relative path.  */
if|if
condition|(
name|IS_ABSOLUTE_PATH
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|full_path
operator|=
name|xfullpath
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|full_path
argument_list|)
expr_stmt|;
name|real_path
operator|=
name|gdb_realpath
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|real_path
argument_list|)
expr_stmt|;
block|}
name|ALL_PSYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|pst
argument_list|)
block|{
if|if
condition|(
name|FILENAME_CMP
argument_list|(
name|name
argument_list|,
name|pst
operator|->
name|filename
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|pst
operator|)
return|;
block|}
comment|/* If the user gave us an absolute path, try to find the file in        this symtab and use its absolute path.  */
if|if
condition|(
name|full_path
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|pst
operator|->
name|fullname
operator|==
name|NULL
condition|)
name|source_full_path_of
argument_list|(
name|pst
operator|->
name|filename
argument_list|,
operator|&
name|pst
operator|->
name|fullname
argument_list|)
expr_stmt|;
if|if
condition|(
name|pst
operator|->
name|fullname
operator|!=
name|NULL
operator|&&
name|FILENAME_CMP
argument_list|(
name|full_path
argument_list|,
name|pst
operator|->
name|fullname
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|pst
return|;
block|}
block|}
if|if
condition|(
name|real_path
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|rp
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|pst
operator|->
name|fullname
operator|==
name|NULL
condition|)
name|source_full_path_of
argument_list|(
name|pst
operator|->
name|filename
argument_list|,
operator|&
name|pst
operator|->
name|fullname
argument_list|)
expr_stmt|;
if|if
condition|(
name|pst
operator|->
name|fullname
operator|!=
name|NULL
condition|)
block|{
name|rp
operator|=
name|gdb_realpath
argument_list|(
name|pst
operator|->
name|fullname
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|rp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rp
operator|!=
name|NULL
operator|&&
name|FILENAME_CMP
argument_list|(
name|real_path
argument_list|,
name|rp
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|pst
return|;
block|}
block|}
block|}
comment|/* Now, search for a matching tail (only if name doesn't have any dirs) */
if|if
condition|(
name|lbasename
argument_list|(
name|name
argument_list|)
operator|==
name|name
condition|)
name|ALL_PSYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|pst
argument_list|)
block|{
if|if
condition|(
name|FILENAME_CMP
argument_list|(
name|lbasename
argument_list|(
name|pst
operator|->
name|filename
argument_list|)
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|pst
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Mangle a GDB method stub type.  This actually reassembles the pieces of the    full method name, which consist of the class name (from T), the unadorned    method name from METHOD_ID, and the signature for the specific overload,    specified by SIGNATURE_ID.  Note that this function is g++ specific. */
end_comment

begin_function
name|char
modifier|*
name|gdb_mangle_name
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|int
name|method_id
parameter_list|,
name|int
name|signature_id
parameter_list|)
block|{
name|int
name|mangled_name_len
decl_stmt|;
name|char
modifier|*
name|mangled_name
decl_stmt|;
name|struct
name|fn_field
modifier|*
name|f
init|=
name|TYPE_FN_FIELDLIST1
argument_list|(
name|type
argument_list|,
name|method_id
argument_list|)
decl_stmt|;
name|struct
name|fn_field
modifier|*
name|method
init|=
operator|&
name|f
index|[
name|signature_id
index|]
decl_stmt|;
name|char
modifier|*
name|field_name
init|=
name|TYPE_FN_FIELDLIST_NAME
argument_list|(
name|type
argument_list|,
name|method_id
argument_list|)
decl_stmt|;
name|char
modifier|*
name|physname
init|=
name|TYPE_FN_FIELD_PHYSNAME
argument_list|(
name|f
argument_list|,
name|signature_id
argument_list|)
decl_stmt|;
name|char
modifier|*
name|newname
init|=
name|type_name_no_tag
argument_list|(
name|type
argument_list|)
decl_stmt|;
comment|/* Does the form of physname indicate that it is the full mangled name      of a constructor (not just the args)?  */
name|int
name|is_full_physname_constructor
decl_stmt|;
name|int
name|is_constructor
decl_stmt|;
name|int
name|is_destructor
init|=
name|is_destructor_name
argument_list|(
name|physname
argument_list|)
decl_stmt|;
comment|/* Need a new type prefix.  */
name|char
modifier|*
name|const_prefix
init|=
name|method
operator|->
name|is_const
condition|?
literal|"C"
else|:
literal|""
decl_stmt|;
name|char
modifier|*
name|volatile_prefix
init|=
name|method
operator|->
name|is_volatile
condition|?
literal|"V"
else|:
literal|""
decl_stmt|;
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
name|int
name|len
init|=
operator|(
name|newname
operator|==
name|NULL
condition|?
literal|0
else|:
name|strlen
argument_list|(
name|newname
argument_list|)
operator|)
decl_stmt|;
comment|/* Nothing to do if physname already contains a fully mangled v3 abi name      or an operator name.  */
if|if
condition|(
operator|(
name|physname
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|physname
index|[
literal|1
index|]
operator|==
literal|'Z'
operator|)
operator|||
name|is_operator_name
argument_list|(
name|field_name
argument_list|)
condition|)
return|return
name|xstrdup
argument_list|(
name|physname
argument_list|)
return|;
name|is_full_physname_constructor
operator|=
name|is_constructor_name
argument_list|(
name|physname
argument_list|)
expr_stmt|;
name|is_constructor
operator|=
name|is_full_physname_constructor
operator|||
operator|(
name|newname
operator|&&
name|strcmp
argument_list|(
name|field_name
argument_list|,
name|newname
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_destructor
condition|)
name|is_destructor
operator|=
operator|(
name|strncmp
argument_list|(
name|physname
argument_list|,
literal|"__dt"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|is_destructor
operator|||
name|is_full_physname_constructor
condition|)
block|{
name|mangled_name
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|physname
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|mangled_name
argument_list|,
name|physname
argument_list|)
expr_stmt|;
return|return
name|mangled_name
return|;
block|}
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"__%s%s"
argument_list|,
name|const_prefix
argument_list|,
name|volatile_prefix
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|physname
index|[
literal|0
index|]
operator|==
literal|'t'
operator|||
name|physname
index|[
literal|0
index|]
operator|==
literal|'Q'
condition|)
block|{
comment|/* The physname for template and qualified methods already includes          the class name.  */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"__%s%s"
argument_list|,
name|const_prefix
argument_list|,
name|volatile_prefix
argument_list|)
expr_stmt|;
name|newname
operator|=
name|NULL
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"__%s%s%d"
argument_list|,
name|const_prefix
argument_list|,
name|volatile_prefix
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
name|mangled_name_len
operator|=
operator|(
operator|(
name|is_constructor
condition|?
literal|0
else|:
name|strlen
argument_list|(
name|field_name
argument_list|)
operator|)
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
operator|+
name|len
operator|+
name|strlen
argument_list|(
name|physname
argument_list|)
operator|+
literal|1
operator|)
expr_stmt|;
block|{
name|mangled_name
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|mangled_name_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_constructor
condition|)
name|mangled_name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|mangled_name
argument_list|,
name|field_name
argument_list|)
expr_stmt|;
block|}
name|strcat
argument_list|(
name|mangled_name
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* If the class doesn't have a name, i.e. newname NULL, then we just      mangle it using 0 for the length of the class.  Thus it gets mangled      as something starting with `::' rather than `classname::'. */
if|if
condition|(
name|newname
operator|!=
name|NULL
condition|)
name|strcat
argument_list|(
name|mangled_name
argument_list|,
name|newname
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|mangled_name
argument_list|,
name|physname
argument_list|)
expr_stmt|;
return|return
operator|(
name|mangled_name
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Initialize the language dependent portion of a symbol    depending upon the language for the symbol. */
end_comment

begin_function
name|void
name|symbol_init_language_specific
parameter_list|(
name|struct
name|general_symbol_info
modifier|*
name|gsymbol
parameter_list|,
name|enum
name|language
name|language
parameter_list|)
block|{
name|gsymbol
operator|->
name|language
operator|=
name|language
expr_stmt|;
if|if
condition|(
name|gsymbol
operator|->
name|language
operator|==
name|language_cplus
operator|||
name|gsymbol
operator|->
name|language
operator|==
name|language_java
operator|||
name|gsymbol
operator|->
name|language
operator|==
name|language_objc
condition|)
block|{
name|gsymbol
operator|->
name|language_specific
operator|.
name|cplus_specific
operator|.
name|demangled_name
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|memset
argument_list|(
operator|&
name|gsymbol
operator|->
name|language_specific
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|gsymbol
operator|->
name|language_specific
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Functions to initialize a symbol's mangled name.  */
end_comment

begin_comment
comment|/* Create the hash table used for demangled names.  Each hash entry is    a pair of strings; one for the mangled name and one for the demangled    name.  The entry is hashed via just the mangled name.  */
end_comment

begin_function
specifier|static
name|void
name|create_demangled_names_hash
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
comment|/* Choose 256 as the starting size of the hash table, somewhat arbitrarily.      The hash table code will round this up to the next prime number.       Choosing a much larger table size wastes memory, and saves only about      1% in symbol reading.  */
name|objfile
operator|->
name|demangled_names_hash
operator|=
name|htab_create_alloc_ex
argument_list|(
literal|256
argument_list|,
name|htab_hash_string
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
specifier|const
name|void
operator|*
argument_list|,
specifier|const
name|void
operator|*
argument_list|)
operator|)
name|streq
argument_list|,
name|NULL
argument_list|,
name|objfile
operator|->
name|md
argument_list|,
name|xmcalloc
argument_list|,
name|xmfree
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Try to determine the demangled name for a symbol, based on the    language of that symbol.  If the language is set to language_auto,    it will attempt to find any demangling algorithm that works and    then set the language appropriately.  The returned name is allocated    by the demangler and should be xfree'd.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|symbol_find_demangled_name
parameter_list|(
name|struct
name|general_symbol_info
modifier|*
name|gsymbol
parameter_list|,
specifier|const
name|char
modifier|*
name|mangled
parameter_list|)
block|{
name|char
modifier|*
name|demangled
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|gsymbol
operator|->
name|language
operator|==
name|language_unknown
condition|)
name|gsymbol
operator|->
name|language
operator|=
name|language_auto
expr_stmt|;
if|if
condition|(
name|gsymbol
operator|->
name|language
operator|==
name|language_objc
operator|||
name|gsymbol
operator|->
name|language
operator|==
name|language_auto
condition|)
block|{
name|demangled
operator|=
name|objc_demangle
argument_list|(
name|mangled
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|demangled
operator|!=
name|NULL
condition|)
block|{
name|gsymbol
operator|->
name|language
operator|=
name|language_objc
expr_stmt|;
return|return
name|demangled
return|;
block|}
block|}
if|if
condition|(
name|gsymbol
operator|->
name|language
operator|==
name|language_cplus
operator|||
name|gsymbol
operator|->
name|language
operator|==
name|language_auto
condition|)
block|{
name|demangled
operator|=
name|cplus_demangle
argument_list|(
name|mangled
argument_list|,
name|DMGL_PARAMS
operator||
name|DMGL_ANSI
argument_list|)
expr_stmt|;
if|if
condition|(
name|demangled
operator|!=
name|NULL
condition|)
block|{
name|gsymbol
operator|->
name|language
operator|=
name|language_cplus
expr_stmt|;
return|return
name|demangled
return|;
block|}
block|}
if|if
condition|(
name|gsymbol
operator|->
name|language
operator|==
name|language_java
condition|)
block|{
name|demangled
operator|=
name|cplus_demangle
argument_list|(
name|mangled
argument_list|,
name|DMGL_PARAMS
operator||
name|DMGL_ANSI
operator||
name|DMGL_JAVA
argument_list|)
expr_stmt|;
if|if
condition|(
name|demangled
operator|!=
name|NULL
condition|)
block|{
name|gsymbol
operator|->
name|language
operator|=
name|language_java
expr_stmt|;
return|return
name|demangled
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Set both the mangled and demangled (if any) names for GSYMBOL based    on LINKAGE_NAME and LEN.  The hash table corresponding to OBJFILE    is used, and the memory comes from that objfile's objfile_obstack.    LINKAGE_NAME is copied, so the pointer can be discarded after    calling this function.  */
end_comment

begin_comment
comment|/* We have to be careful when dealing with Java names: when we run    into a Java minimal symbol, we don't know it's a Java symbol, so it    gets demangled as a C++ name.  This is unfortunate, but there's not    much we can do about it: but when demangling partial symbols and    regular symbols, we'd better not reuse the wrong demangled name.    (See PR gdb/1039.)  We solve this by putting a distinctive prefix    on Java names when storing them in the hash table.  */
end_comment

begin_comment
comment|/* FIXME: carlton/2003-03-13: This is an unfortunate situation.  I    don't mind the Java prefix so much: different languages have    different demangling requirements, so it's only natural that we    need to keep language data around in our demangling cache.  But    it's not good that the minimal symbol has the wrong demangled name.    Unfortunately, I can't think of any easy solution to that    problem.  */
end_comment

begin_define
define|#
directive|define
name|JAVA_PREFIX
value|"##JAVA$$"
end_define

begin_define
define|#
directive|define
name|JAVA_PREFIX_LEN
value|8
end_define

begin_function
name|void
name|symbol_set_names
parameter_list|(
name|struct
name|general_symbol_info
modifier|*
name|gsymbol
parameter_list|,
specifier|const
name|char
modifier|*
name|linkage_name
parameter_list|,
name|int
name|len
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|char
modifier|*
modifier|*
name|slot
decl_stmt|;
comment|/* A 0-terminated copy of the linkage name.  */
specifier|const
name|char
modifier|*
name|linkage_name_copy
decl_stmt|;
comment|/* A copy of the linkage name that might have a special Java prefix      added to it, for use when looking names up in the hash table.  */
specifier|const
name|char
modifier|*
name|lookup_name
decl_stmt|;
comment|/* The length of lookup_name.  */
name|int
name|lookup_len
decl_stmt|;
if|if
condition|(
name|objfile
operator|->
name|demangled_names_hash
operator|==
name|NULL
condition|)
name|create_demangled_names_hash
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
comment|/* The stabs reader generally provides names that are not      NUL-terminated; most of the other readers don't do this, so we      can just use the given copy, unless we're in the Java case.  */
if|if
condition|(
name|gsymbol
operator|->
name|language
operator|==
name|language_java
condition|)
block|{
name|char
modifier|*
name|alloc_name
decl_stmt|;
name|lookup_len
operator|=
name|len
operator|+
name|JAVA_PREFIX_LEN
expr_stmt|;
name|alloc_name
operator|=
name|alloca
argument_list|(
name|lookup_len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|alloc_name
argument_list|,
name|JAVA_PREFIX
argument_list|,
name|JAVA_PREFIX_LEN
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|alloc_name
operator|+
name|JAVA_PREFIX_LEN
argument_list|,
name|linkage_name
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|alloc_name
index|[
name|lookup_len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|lookup_name
operator|=
name|alloc_name
expr_stmt|;
name|linkage_name_copy
operator|=
name|alloc_name
operator|+
name|JAVA_PREFIX_LEN
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|linkage_name
index|[
name|len
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|char
modifier|*
name|alloc_name
decl_stmt|;
name|lookup_len
operator|=
name|len
expr_stmt|;
name|alloc_name
operator|=
name|alloca
argument_list|(
name|lookup_len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|alloc_name
argument_list|,
name|linkage_name
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|alloc_name
index|[
name|lookup_len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|lookup_name
operator|=
name|alloc_name
expr_stmt|;
name|linkage_name_copy
operator|=
name|alloc_name
expr_stmt|;
block|}
else|else
block|{
name|lookup_len
operator|=
name|len
expr_stmt|;
name|lookup_name
operator|=
name|linkage_name
expr_stmt|;
name|linkage_name_copy
operator|=
name|linkage_name
expr_stmt|;
block|}
name|slot
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|htab_find_slot
argument_list|(
name|objfile
operator|->
name|demangled_names_hash
argument_list|,
name|lookup_name
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
comment|/* If this name is not in the hash table, add it.  */
if|if
condition|(
operator|*
name|slot
operator|==
name|NULL
condition|)
block|{
name|char
modifier|*
name|demangled_name
init|=
name|symbol_find_demangled_name
argument_list|(
name|gsymbol
argument_list|,
name|linkage_name_copy
argument_list|)
decl_stmt|;
name|int
name|demangled_len
init|=
name|demangled_name
condition|?
name|strlen
argument_list|(
name|demangled_name
argument_list|)
else|:
literal|0
decl_stmt|;
comment|/* If there is a demangled name, place it right after the mangled name. 	 Otherwise, just place a second zero byte after the end of the mangled 	 name.  */
operator|*
name|slot
operator|=
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
name|lookup_len
operator|+
name|demangled_len
operator|+
literal|2
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|*
name|slot
argument_list|,
name|lookup_name
argument_list|,
name|lookup_len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|demangled_name
operator|!=
name|NULL
condition|)
block|{
name|memcpy
argument_list|(
operator|*
name|slot
operator|+
name|lookup_len
operator|+
literal|1
argument_list|,
name|demangled_name
argument_list|,
name|demangled_len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|demangled_name
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
operator|*
name|slot
operator|)
index|[
name|lookup_len
operator|+
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|gsymbol
operator|->
name|name
operator|=
operator|*
name|slot
operator|+
name|lookup_len
operator|-
name|len
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|slot
operator|)
index|[
name|lookup_len
operator|+
literal|1
index|]
operator|!=
literal|'\0'
condition|)
name|gsymbol
operator|->
name|language_specific
operator|.
name|cplus_specific
operator|.
name|demangled_name
operator|=
operator|&
operator|(
operator|*
name|slot
operator|)
index|[
name|lookup_len
operator|+
literal|1
index|]
expr_stmt|;
else|else
name|gsymbol
operator|->
name|language_specific
operator|.
name|cplus_specific
operator|.
name|demangled_name
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize the demangled name of GSYMBOL if possible.  Any required space    to store the name is obtained from the specified obstack.  The function    symbol_set_names, above, should be used instead where possible for more    efficient memory usage.  */
end_comment

begin_function
name|void
name|symbol_init_demangled_name
parameter_list|(
name|struct
name|general_symbol_info
modifier|*
name|gsymbol
parameter_list|,
name|struct
name|obstack
modifier|*
name|obstack
parameter_list|)
block|{
name|char
modifier|*
name|mangled
init|=
name|gsymbol
operator|->
name|name
decl_stmt|;
name|char
modifier|*
name|demangled
init|=
name|NULL
decl_stmt|;
name|demangled
operator|=
name|symbol_find_demangled_name
argument_list|(
name|gsymbol
argument_list|,
name|mangled
argument_list|)
expr_stmt|;
if|if
condition|(
name|gsymbol
operator|->
name|language
operator|==
name|language_cplus
operator|||
name|gsymbol
operator|->
name|language
operator|==
name|language_java
operator|||
name|gsymbol
operator|->
name|language
operator|==
name|language_objc
condition|)
block|{
if|if
condition|(
name|demangled
condition|)
block|{
name|gsymbol
operator|->
name|language_specific
operator|.
name|cplus_specific
operator|.
name|demangled_name
operator|=
name|obsavestring
argument_list|(
name|demangled
argument_list|,
name|strlen
argument_list|(
name|demangled
argument_list|)
argument_list|,
name|obstack
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|demangled
argument_list|)
expr_stmt|;
block|}
else|else
name|gsymbol
operator|->
name|language_specific
operator|.
name|cplus_specific
operator|.
name|demangled_name
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* Unknown language; just clean up quietly.  */
if|if
condition|(
name|demangled
condition|)
name|xfree
argument_list|(
name|demangled
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return the source code name of a symbol.  In languages where    demangling is necessary, this is the demangled name.  */
end_comment

begin_function
name|char
modifier|*
name|symbol_natural_name
parameter_list|(
specifier|const
name|struct
name|general_symbol_info
modifier|*
name|gsymbol
parameter_list|)
block|{
if|if
condition|(
operator|(
name|gsymbol
operator|->
name|language
operator|==
name|language_cplus
operator|||
name|gsymbol
operator|->
name|language
operator|==
name|language_java
operator|||
name|gsymbol
operator|->
name|language
operator|==
name|language_objc
operator|)
operator|&&
operator|(
name|gsymbol
operator|->
name|language_specific
operator|.
name|cplus_specific
operator|.
name|demangled_name
operator|!=
name|NULL
operator|)
condition|)
block|{
return|return
name|gsymbol
operator|->
name|language_specific
operator|.
name|cplus_specific
operator|.
name|demangled_name
return|;
block|}
else|else
block|{
return|return
name|gsymbol
operator|->
name|name
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return the demangled name for a symbol based on the language for    that symbol.  If no demangled name exists, return NULL. */
end_comment

begin_function
name|char
modifier|*
name|symbol_demangled_name
parameter_list|(
name|struct
name|general_symbol_info
modifier|*
name|gsymbol
parameter_list|)
block|{
if|if
condition|(
name|gsymbol
operator|->
name|language
operator|==
name|language_cplus
operator|||
name|gsymbol
operator|->
name|language
operator|==
name|language_java
operator|||
name|gsymbol
operator|->
name|language
operator|==
name|language_objc
condition|)
return|return
name|gsymbol
operator|->
name|language_specific
operator|.
name|cplus_specific
operator|.
name|demangled_name
return|;
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Initialize the structure fields to zero values.  */
end_comment

begin_function
name|void
name|init_sal
parameter_list|(
name|struct
name|symtab_and_line
modifier|*
name|sal
parameter_list|)
block|{
name|sal
operator|->
name|symtab
operator|=
literal|0
expr_stmt|;
name|sal
operator|->
name|section
operator|=
literal|0
expr_stmt|;
name|sal
operator|->
name|line
operator|=
literal|0
expr_stmt|;
name|sal
operator|->
name|pc
operator|=
literal|0
expr_stmt|;
name|sal
operator|->
name|end
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find which partial symtab contains PC and SECTION.  Return 0 if    none.  We return the psymtab that contains a symbol whose address    exactly matches PC, or, if we cannot find an exact match, the    psymtab that contains a symbol whose address is closest to PC.  */
end_comment

begin_function
name|struct
name|partial_symtab
modifier|*
name|find_pc_sect_psymtab
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|asection
modifier|*
name|section
parameter_list|)
block|{
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
comment|/* If we know that this is not a text address, return failure.  This is      necessary because we loop based on texthigh and textlow, which do      not include the data ranges.  */
name|msymbol
operator|=
name|lookup_minimal_symbol_by_pc_section
argument_list|(
name|pc
argument_list|,
name|section
argument_list|)
expr_stmt|;
if|if
condition|(
name|msymbol
operator|&&
operator|(
name|msymbol
operator|->
name|type
operator|==
name|mst_data
operator|||
name|msymbol
operator|->
name|type
operator|==
name|mst_bss
operator|||
name|msymbol
operator|->
name|type
operator|==
name|mst_abs
operator|||
name|msymbol
operator|->
name|type
operator|==
name|mst_file_data
operator|||
name|msymbol
operator|->
name|type
operator|==
name|mst_file_bss
operator|)
condition|)
return|return
name|NULL
return|;
name|ALL_PSYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|pst
argument_list|)
block|{
if|if
condition|(
name|pc
operator|>=
name|pst
operator|->
name|textlow
operator|&&
name|pc
operator|<
name|pst
operator|->
name|texthigh
condition|)
block|{
name|struct
name|partial_symtab
modifier|*
name|tpst
decl_stmt|;
name|struct
name|partial_symtab
modifier|*
name|best_pst
init|=
name|pst
decl_stmt|;
name|struct
name|partial_symbol
modifier|*
name|best_psym
init|=
name|NULL
decl_stmt|;
comment|/* An objfile that has its functions reordered might have 	   many partial symbol tables containing the PC, but 	   we want the partial symbol table that contains the 	   function containing the PC.  */
if|if
condition|(
operator|!
operator|(
name|objfile
operator|->
name|flags
operator|&
name|OBJF_REORDERED
operator|)
operator|&&
name|section
operator|==
literal|0
condition|)
comment|/* can't validate section this way */
return|return
operator|(
name|pst
operator|)
return|;
if|if
condition|(
name|msymbol
operator|==
name|NULL
condition|)
return|return
operator|(
name|pst
operator|)
return|;
comment|/* The code range of partial symtabs sometimes overlap, so, in 	   the loop below, we need to check all partial symtabs and 	   find the one that fits better for the given PC address. We 	   select the partial symtab that contains a symbol whose 	   address is closest to the PC address.  By closest we mean 	   that find_pc_sect_symbol returns the symbol with address 	   that is closest and still less than the given PC.  */
for|for
control|(
name|tpst
operator|=
name|pst
init|;
name|tpst
operator|!=
name|NULL
condition|;
name|tpst
operator|=
name|tpst
operator|->
name|next
control|)
block|{
if|if
condition|(
name|pc
operator|>=
name|tpst
operator|->
name|textlow
operator|&&
name|pc
operator|<
name|tpst
operator|->
name|texthigh
condition|)
block|{
name|struct
name|partial_symbol
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|find_pc_sect_psymbol
argument_list|(
name|tpst
argument_list|,
name|pc
argument_list|,
name|section
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
operator|&&
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|p
argument_list|)
operator|==
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
condition|)
return|return
operator|(
name|tpst
operator|)
return|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
comment|/* We found a symbol in this partial symtab which 		       matches (or is closest to) PC, check whether it 		       is closer than our current BEST_PSYM.  Since 		       this symbol address is necessarily lower or 		       equal to PC, the symbol closer to PC is the 		       symbol which address is the highest.  */
comment|/* This way we return the psymtab which contains 		       such best match symbol. This can help in cases 		       where the symbol information/debuginfo is not 		       complete, like for instance on IRIX6 with gcc, 		       where no debug info is emitted for 		       statics. (See also the nodebug.exp 		       testcase.)  */
if|if
condition|(
name|best_psym
operator|==
name|NULL
operator|||
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|p
argument_list|)
operator|>
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|best_psym
argument_list|)
condition|)
block|{
name|best_psym
operator|=
name|p
expr_stmt|;
name|best_pst
operator|=
name|tpst
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
operator|(
name|best_pst
operator|)
return|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Find which partial symtab contains PC.  Return 0 if none.     Backward compatibility, no section */
end_comment

begin_function
name|struct
name|partial_symtab
modifier|*
name|find_pc_psymtab
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
return|return
name|find_pc_sect_psymtab
argument_list|(
name|pc
argument_list|,
name|find_pc_mapped_section
argument_list|(
name|pc
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Find which partial symbol within a psymtab matches PC and SECTION.      Return 0 if none.  Check all psymtabs if PSYMTAB is 0.  */
end_comment

begin_function
name|struct
name|partial_symbol
modifier|*
name|find_pc_sect_psymbol
parameter_list|(
name|struct
name|partial_symtab
modifier|*
name|psymtab
parameter_list|,
name|CORE_ADDR
name|pc
parameter_list|,
name|asection
modifier|*
name|section
parameter_list|)
block|{
name|struct
name|partial_symbol
modifier|*
name|best
init|=
name|NULL
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
modifier|*
name|pp
decl_stmt|;
name|CORE_ADDR
name|best_pc
decl_stmt|;
if|if
condition|(
operator|!
name|psymtab
condition|)
name|psymtab
operator|=
name|find_pc_sect_psymtab
argument_list|(
name|pc
argument_list|,
name|section
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|psymtab
condition|)
return|return
literal|0
return|;
comment|/* Cope with programs that start at address 0 */
name|best_pc
operator|=
operator|(
name|psymtab
operator|->
name|textlow
operator|!=
literal|0
operator|)
condition|?
name|psymtab
operator|->
name|textlow
operator|-
literal|1
else|:
literal|0
expr_stmt|;
comment|/* Search the global symbols as well as the static symbols, so that      find_pc_partial_function doesn't use a minimal symbol and thus      cache a bad endaddr.  */
for|for
control|(
name|pp
operator|=
name|psymtab
operator|->
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
operator|+
name|psymtab
operator|->
name|globals_offset
init|;
operator|(
name|pp
operator|-
operator|(
name|psymtab
operator|->
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
operator|+
name|psymtab
operator|->
name|globals_offset
operator|)
operator|<
name|psymtab
operator|->
name|n_global_syms
operator|)
condition|;
name|pp
operator|++
control|)
block|{
name|p
operator|=
operator|*
name|pp
expr_stmt|;
if|if
condition|(
name|SYMBOL_DOMAIN
argument_list|(
name|p
argument_list|)
operator|==
name|VAR_DOMAIN
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|p
argument_list|)
operator|==
name|LOC_BLOCK
operator|&&
name|pc
operator|>=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|p
argument_list|)
operator|&&
operator|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|p
argument_list|)
operator|>
name|best_pc
operator|||
operator|(
name|psymtab
operator|->
name|textlow
operator|==
literal|0
operator|&&
name|best_pc
operator|==
literal|0
operator|&&
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|p
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|section
condition|)
comment|/* match on a specific section */
block|{
name|fixup_psymbol_section
argument_list|(
name|p
argument_list|,
name|psymtab
operator|->
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|SYMBOL_BFD_SECTION
argument_list|(
name|p
argument_list|)
operator|!=
name|section
condition|)
continue|continue;
block|}
name|best_pc
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|best
operator|=
name|p
expr_stmt|;
block|}
block|}
for|for
control|(
name|pp
operator|=
name|psymtab
operator|->
name|objfile
operator|->
name|static_psymbols
operator|.
name|list
operator|+
name|psymtab
operator|->
name|statics_offset
init|;
operator|(
name|pp
operator|-
operator|(
name|psymtab
operator|->
name|objfile
operator|->
name|static_psymbols
operator|.
name|list
operator|+
name|psymtab
operator|->
name|statics_offset
operator|)
operator|<
name|psymtab
operator|->
name|n_static_syms
operator|)
condition|;
name|pp
operator|++
control|)
block|{
name|p
operator|=
operator|*
name|pp
expr_stmt|;
if|if
condition|(
name|SYMBOL_DOMAIN
argument_list|(
name|p
argument_list|)
operator|==
name|VAR_DOMAIN
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|p
argument_list|)
operator|==
name|LOC_BLOCK
operator|&&
name|pc
operator|>=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|p
argument_list|)
operator|&&
operator|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|p
argument_list|)
operator|>
name|best_pc
operator|||
operator|(
name|psymtab
operator|->
name|textlow
operator|==
literal|0
operator|&&
name|best_pc
operator|==
literal|0
operator|&&
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|p
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|section
condition|)
comment|/* match on a specific section */
block|{
name|fixup_psymbol_section
argument_list|(
name|p
argument_list|,
name|psymtab
operator|->
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|SYMBOL_BFD_SECTION
argument_list|(
name|p
argument_list|)
operator|!=
name|section
condition|)
continue|continue;
block|}
name|best_pc
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|best
operator|=
name|p
expr_stmt|;
block|}
block|}
return|return
name|best
return|;
block|}
end_function

begin_comment
comment|/* Find which partial symbol within a psymtab matches PC.  Return 0 if none.      Check all psymtabs if PSYMTAB is 0.  Backwards compatibility, no section. */
end_comment

begin_function
name|struct
name|partial_symbol
modifier|*
name|find_pc_psymbol
parameter_list|(
name|struct
name|partial_symtab
modifier|*
name|psymtab
parameter_list|,
name|CORE_ADDR
name|pc
parameter_list|)
block|{
return|return
name|find_pc_sect_psymbol
argument_list|(
name|psymtab
argument_list|,
name|pc
argument_list|,
name|find_pc_mapped_section
argument_list|(
name|pc
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Debug symbols usually don't have section information.  We need to dig that    out of the minimal symbols and stash that in the debug symbol.  */
end_comment

begin_function
specifier|static
name|void
name|fixup_section
parameter_list|(
name|struct
name|general_symbol_info
modifier|*
name|ginfo
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|struct
name|minimal_symbol
modifier|*
name|msym
decl_stmt|;
name|msym
operator|=
name|lookup_minimal_symbol
argument_list|(
name|ginfo
operator|->
name|name
argument_list|,
name|NULL
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|msym
condition|)
block|{
name|ginfo
operator|->
name|bfd_section
operator|=
name|SYMBOL_BFD_SECTION
argument_list|(
name|msym
argument_list|)
expr_stmt|;
name|ginfo
operator|->
name|section
operator|=
name|SYMBOL_SECTION
argument_list|(
name|msym
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|struct
name|symbol
modifier|*
name|fixup_symbol_section
parameter_list|(
name|struct
name|symbol
modifier|*
name|sym
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
if|if
condition|(
operator|!
name|sym
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|SYMBOL_BFD_SECTION
argument_list|(
name|sym
argument_list|)
condition|)
return|return
name|sym
return|;
name|fixup_section
argument_list|(
operator|&
name|sym
operator|->
name|ginfo
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
return|return
name|sym
return|;
block|}
end_function

begin_function
name|struct
name|partial_symbol
modifier|*
name|fixup_psymbol_section
parameter_list|(
name|struct
name|partial_symbol
modifier|*
name|psym
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
if|if
condition|(
operator|!
name|psym
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|SYMBOL_BFD_SECTION
argument_list|(
name|psym
argument_list|)
condition|)
return|return
name|psym
return|;
name|fixup_section
argument_list|(
operator|&
name|psym
operator|->
name|ginfo
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
return|return
name|psym
return|;
block|}
end_function

begin_comment
comment|/* Find the definition for a specified symbol name NAME    in domain DOMAIN, visible from lexical block BLOCK.    Returns the struct symbol pointer, or zero if no symbol is found.    If SYMTAB is non-NULL, store the symbol table in which the    symbol was found there, or NULL if not found.    C++: if IS_A_FIELD_OF_THIS is nonzero on entry, check to see if    NAME is a field of the current implied argument `this'.  If so set    *IS_A_FIELD_OF_THIS to 1, otherwise set it to zero.     BLOCK_FOUND is set to the block in which NAME is found (in the case of    a field of `this', value_of_this sets BLOCK_FOUND to the proper value.) */
end_comment

begin_comment
comment|/* This function has a bunch of loops in it and it would seem to be    attractive to put in some QUIT's (though I'm not really sure    whether it can run long enough to be really important).  But there    are a few calls for which it would appear to be bad news to quit    out of here: find_proc_desc in alpha-tdep.c and mips-tdep.c.  (Note    that there is C++ code below which can error(), but that probably    doesn't affect these calls since they are looking for a known    variable and thus can probably assume it will never hit the C++    code).  */
end_comment

begin_function
name|struct
name|symbol
modifier|*
name|lookup_symbol
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|struct
name|block
modifier|*
name|block
parameter_list|,
specifier|const
name|domain_enum
name|domain
parameter_list|,
name|int
modifier|*
name|is_a_field_of_this
parameter_list|,
name|struct
name|symtab
modifier|*
modifier|*
name|symtab
parameter_list|)
block|{
name|char
modifier|*
name|demangled_name
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|modified_name
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|mangled_name
init|=
name|NULL
decl_stmt|;
name|int
name|needtofreename
init|=
literal|0
decl_stmt|;
name|struct
name|symbol
modifier|*
name|returnval
decl_stmt|;
name|modified_name
operator|=
name|name
expr_stmt|;
comment|/* If we are using C++ language, demangle the name before doing a lookup, so      we can always binary search. */
if|if
condition|(
name|current_language
operator|->
name|la_language
operator|==
name|language_cplus
condition|)
block|{
name|demangled_name
operator|=
name|cplus_demangle
argument_list|(
name|name
argument_list|,
name|DMGL_ANSI
operator||
name|DMGL_PARAMS
argument_list|)
expr_stmt|;
if|if
condition|(
name|demangled_name
condition|)
block|{
name|mangled_name
operator|=
name|name
expr_stmt|;
name|modified_name
operator|=
name|demangled_name
expr_stmt|;
name|needtofreename
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|case_sensitivity
operator|==
name|case_sensitive_off
condition|)
block|{
name|char
modifier|*
name|copy
decl_stmt|;
name|int
name|len
decl_stmt|,
name|i
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|copy
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|copy
index|[
name|i
index|]
operator|=
name|tolower
argument_list|(
name|name
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|copy
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
name|modified_name
operator|=
name|copy
expr_stmt|;
block|}
name|returnval
operator|=
name|lookup_symbol_aux
argument_list|(
name|modified_name
argument_list|,
name|mangled_name
argument_list|,
name|block
argument_list|,
name|domain
argument_list|,
name|is_a_field_of_this
argument_list|,
name|symtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|needtofreename
condition|)
name|xfree
argument_list|(
name|demangled_name
argument_list|)
expr_stmt|;
return|return
name|returnval
return|;
block|}
end_function

begin_comment
comment|/* Behave like lookup_symbol_aux except that NAME is the natural name    of the symbol that we're looking for and, if LINKAGE_NAME is    non-NULL, ensure that the symbol's linkage name matches as    well.  */
end_comment

begin_function
specifier|static
name|struct
name|symbol
modifier|*
name|lookup_symbol_aux
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|linkage_name
parameter_list|,
specifier|const
name|struct
name|block
modifier|*
name|block
parameter_list|,
specifier|const
name|domain_enum
name|domain
parameter_list|,
name|int
modifier|*
name|is_a_field_of_this
parameter_list|,
name|struct
name|symtab
modifier|*
modifier|*
name|symtab
parameter_list|)
block|{
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
comment|/* Make sure we do something sensible with is_a_field_of_this, since      the callers that set this parameter to some non-null value will      certainly use it later and expect it to be either 0 or 1.      If we don't set it, the contents of is_a_field_of_this are      undefined.  */
if|if
condition|(
name|is_a_field_of_this
operator|!=
name|NULL
condition|)
operator|*
name|is_a_field_of_this
operator|=
literal|0
expr_stmt|;
comment|/* Search specified block and its superiors.  Don't search      STATIC_BLOCK or GLOBAL_BLOCK.  */
name|sym
operator|=
name|lookup_symbol_aux_local
argument_list|(
name|name
argument_list|,
name|linkage_name
argument_list|,
name|block
argument_list|,
name|domain
argument_list|,
name|symtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|!=
name|NULL
condition|)
return|return
name|sym
return|;
comment|/* If requested to do so by the caller and if appropriate for the      current language, check to see if NAME is a field of `this'. */
if|if
condition|(
name|current_language
operator|->
name|la_value_of_this
operator|!=
name|NULL
operator|&&
name|is_a_field_of_this
operator|!=
name|NULL
condition|)
block|{
name|struct
name|value
modifier|*
name|v
init|=
name|current_language
operator|->
name|la_value_of_this
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|v
operator|&&
name|check_field
argument_list|(
name|v
argument_list|,
name|name
argument_list|)
condition|)
block|{
operator|*
name|is_a_field_of_this
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|symtab
operator|!=
name|NULL
condition|)
operator|*
name|symtab
operator|=
name|NULL
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
comment|/* Now do whatever is appropriate for the current language to look      up static and global variables.  */
name|sym
operator|=
name|current_language
operator|->
name|la_lookup_symbol_nonlocal
argument_list|(
name|name
argument_list|,
name|linkage_name
argument_list|,
name|block
argument_list|,
name|domain
argument_list|,
name|symtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|!=
name|NULL
condition|)
return|return
name|sym
return|;
comment|/* Now search all static file-level symbols.  Not strictly correct,      but more useful than an error.  Do the symtabs first, then check      the psymtabs.  If a psymtab indicates the existence of the      desired name as a file-level static, then do psymtab-to-symtab      conversion on the fly and return the found symbol. */
name|sym
operator|=
name|lookup_symbol_aux_symtabs
argument_list|(
name|STATIC_BLOCK
argument_list|,
name|name
argument_list|,
name|linkage_name
argument_list|,
name|domain
argument_list|,
name|symtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|!=
name|NULL
condition|)
return|return
name|sym
return|;
name|sym
operator|=
name|lookup_symbol_aux_psymtabs
argument_list|(
name|STATIC_BLOCK
argument_list|,
name|name
argument_list|,
name|linkage_name
argument_list|,
name|domain
argument_list|,
name|symtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|!=
name|NULL
condition|)
return|return
name|sym
return|;
if|if
condition|(
name|symtab
operator|!=
name|NULL
condition|)
operator|*
name|symtab
operator|=
name|NULL
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Check to see if the symbol is defined in BLOCK or its superiors.    Don't search STATIC_BLOCK or GLOBAL_BLOCK.  */
end_comment

begin_function
specifier|static
name|struct
name|symbol
modifier|*
name|lookup_symbol_aux_local
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|linkage_name
parameter_list|,
specifier|const
name|struct
name|block
modifier|*
name|block
parameter_list|,
specifier|const
name|domain_enum
name|domain
parameter_list|,
name|struct
name|symtab
modifier|*
modifier|*
name|symtab
parameter_list|)
block|{
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
specifier|const
name|struct
name|block
modifier|*
name|static_block
init|=
name|block_static_block
argument_list|(
name|block
argument_list|)
decl_stmt|;
comment|/* Check if either no block is specified or it's a global block.  */
if|if
condition|(
name|static_block
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
while|while
condition|(
name|block
operator|!=
name|static_block
condition|)
block|{
name|sym
operator|=
name|lookup_symbol_aux_block
argument_list|(
name|name
argument_list|,
name|linkage_name
argument_list|,
name|block
argument_list|,
name|domain
argument_list|,
name|symtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|!=
name|NULL
condition|)
return|return
name|sym
return|;
name|block
operator|=
name|BLOCK_SUPERBLOCK
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
comment|/* We've reached the static block without finding a result.  */
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Look up a symbol in a block; if found, locate its symtab, fixup the    symbol, and set block_found appropriately.  */
end_comment

begin_function
name|struct
name|symbol
modifier|*
name|lookup_symbol_aux_block
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|linkage_name
parameter_list|,
specifier|const
name|struct
name|block
modifier|*
name|block
parameter_list|,
specifier|const
name|domain_enum
name|domain
parameter_list|,
name|struct
name|symtab
modifier|*
modifier|*
name|symtab
parameter_list|)
block|{
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
init|=
name|NULL
decl_stmt|;
name|struct
name|blockvector
modifier|*
name|bv
decl_stmt|;
name|struct
name|block
modifier|*
name|b
decl_stmt|;
name|struct
name|symtab
modifier|*
name|s
init|=
name|NULL
decl_stmt|;
name|sym
operator|=
name|lookup_block_symbol
argument_list|(
name|block
argument_list|,
name|name
argument_list|,
name|linkage_name
argument_list|,
name|domain
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
condition|)
block|{
name|block_found
operator|=
name|block
expr_stmt|;
if|if
condition|(
name|symtab
operator|!=
name|NULL
condition|)
block|{
comment|/* Search the list of symtabs for one which contains the 	     address of the start of this block.  */
name|ALL_SYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
block|{
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|b
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|BLOCK_START
argument_list|(
name|b
argument_list|)
operator|<=
name|BLOCK_START
argument_list|(
name|block
argument_list|)
operator|&&
name|BLOCK_END
argument_list|(
name|b
argument_list|)
operator|>
name|BLOCK_START
argument_list|(
name|block
argument_list|)
condition|)
goto|goto
name|found
goto|;
block|}
name|found
label|:
operator|*
name|symtab
operator|=
name|s
expr_stmt|;
block|}
return|return
name|fixup_symbol_section
argument_list|(
name|sym
argument_list|,
name|objfile
argument_list|)
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Check to see if the symbol is defined in one of the symtabs.    BLOCK_INDEX should be either GLOBAL_BLOCK or STATIC_BLOCK,    depending on whether or not we want to search global symbols or    static symbols.  */
end_comment

begin_function
specifier|static
name|struct
name|symbol
modifier|*
name|lookup_symbol_aux_symtabs
parameter_list|(
name|int
name|block_index
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|linkage_name
parameter_list|,
specifier|const
name|domain_enum
name|domain
parameter_list|,
name|struct
name|symtab
modifier|*
modifier|*
name|symtab
parameter_list|)
block|{
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|blockvector
modifier|*
name|bv
decl_stmt|;
specifier|const
name|struct
name|block
modifier|*
name|block
decl_stmt|;
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
name|ALL_SYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
block|{
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|block
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|block_index
argument_list|)
expr_stmt|;
name|sym
operator|=
name|lookup_block_symbol
argument_list|(
name|block
argument_list|,
name|name
argument_list|,
name|linkage_name
argument_list|,
name|domain
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
condition|)
block|{
name|block_found
operator|=
name|block
expr_stmt|;
if|if
condition|(
name|symtab
operator|!=
name|NULL
condition|)
operator|*
name|symtab
operator|=
name|s
expr_stmt|;
return|return
name|fixup_symbol_section
argument_list|(
name|sym
argument_list|,
name|objfile
argument_list|)
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Check to see if the symbol is defined in one of the partial    symtabs.  BLOCK_INDEX should be either GLOBAL_BLOCK or    STATIC_BLOCK, depending on whether or not we want to search global    symbols or static symbols.  */
end_comment

begin_function
specifier|static
name|struct
name|symbol
modifier|*
name|lookup_symbol_aux_psymtabs
parameter_list|(
name|int
name|block_index
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|linkage_name
parameter_list|,
specifier|const
name|domain_enum
name|domain
parameter_list|,
name|struct
name|symtab
modifier|*
modifier|*
name|symtab
parameter_list|)
block|{
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|blockvector
modifier|*
name|bv
decl_stmt|;
specifier|const
name|struct
name|block
modifier|*
name|block
decl_stmt|;
name|struct
name|partial_symtab
modifier|*
name|ps
decl_stmt|;
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
specifier|const
name|int
name|psymtab_index
init|=
operator|(
name|block_index
operator|==
name|GLOBAL_BLOCK
condition|?
literal|1
else|:
literal|0
operator|)
decl_stmt|;
name|ALL_PSYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|ps
argument_list|)
block|{
if|if
condition|(
operator|!
name|ps
operator|->
name|readin
operator|&&
name|lookup_partial_symbol
argument_list|(
name|ps
argument_list|,
name|name
argument_list|,
name|linkage_name
argument_list|,
name|psymtab_index
argument_list|,
name|domain
argument_list|)
condition|)
block|{
name|s
operator|=
name|PSYMTAB_TO_SYMTAB
argument_list|(
name|ps
argument_list|)
expr_stmt|;
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|block
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|block_index
argument_list|)
expr_stmt|;
name|sym
operator|=
name|lookup_block_symbol
argument_list|(
name|block
argument_list|,
name|name
argument_list|,
name|linkage_name
argument_list|,
name|domain
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sym
condition|)
block|{
comment|/* This shouldn't be necessary, but as a last resort try 	       looking in the statics even though the psymtab claimed 	       the symbol was global, or vice-versa. It's possible 	       that the psymtab gets it wrong in some cases.  */
comment|/* FIXME: carlton/2002-09-30: Should we really do that? 	       If that happens, isn't it likely to be a GDB error, in 	       which case we should fix the GDB error rather than 	       silently dealing with it here?  So I'd vote for 	       removing the check for the symbol in the other 	       block.  */
name|block
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|block_index
operator|==
name|GLOBAL_BLOCK
condition|?
name|STATIC_BLOCK
else|:
name|GLOBAL_BLOCK
argument_list|)
expr_stmt|;
name|sym
operator|=
name|lookup_block_symbol
argument_list|(
name|block
argument_list|,
name|name
argument_list|,
name|linkage_name
argument_list|,
name|domain
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sym
condition|)
name|error
argument_list|(
literal|"Internal: %s symbol `%s' found in %s psymtab but not in symtab.\n%s may be an inlined function, or may be a template function\n(if a template, try specifying an instantiation: %s<type>)."
argument_list|,
name|block_index
operator|==
name|GLOBAL_BLOCK
condition|?
literal|"global"
else|:
literal|"static"
argument_list|,
name|name
argument_list|,
name|ps
operator|->
name|filename
argument_list|,
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|symtab
operator|!=
name|NULL
condition|)
operator|*
name|symtab
operator|=
name|s
expr_stmt|;
return|return
name|fixup_symbol_section
argument_list|(
name|sym
argument_list|,
name|objfile
argument_list|)
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Check for the possibility of the symbol being a function or a    mangled variable that is stored in one of the minimal symbol    tables.  Eventually, all global symbols might be resolved in this    way.  */
end_comment

begin_comment
comment|/* NOTE: carlton/2002-12-05: At one point, this function was part of    lookup_symbol_aux, and what are now 'return' statements within    lookup_symbol_aux_minsyms returned from lookup_symbol_aux, even if    sym was NULL.  As far as I can tell, this was basically accidental;    it didn't happen every time that msymbol was non-NULL, but only if    some additional conditions held as well, and it caused problems    with HP-generated symbol tables.  */
end_comment

begin_comment
comment|/* NOTE: carlton/2003-05-14: This function was once used as part of    lookup_symbol.  It is currently unnecessary for correctness    reasons, however, and using it doesn't seem to be any faster than    using lookup_symbol_aux_psymtabs, so I'm commenting it out.  */
end_comment

begin_comment
unit|static struct symbol * lookup_symbol_aux_minsyms (const char *name, 			   const char *linkage_name, 			   const domain_enum domain, 			   int *is_a_field_of_this, 			   struct symtab **symtab) {   struct symbol *sym;   struct blockvector *bv;   const struct block *block;   struct minimal_symbol *msymbol;   struct symtab *s;    if (domain == VAR_DOMAIN)     {       msymbol = lookup_minimal_symbol (name, NULL, NULL);        if (msymbol != NULL) 	{
comment|/* OK, we found a minimal symbol in spite of not finding any 	     symbol. There are various possible explanations for 	     this. One possibility is the symbol exists in code not 	     compiled -g. Another possibility is that the 'psymtab' 	     isn't doing its job.  A third possibility, related to #2, 	     is that we were confused by name-mangling. For instance, 	     maybe the psymtab isn't doing its job because it only 	     know about demangled names, but we were given a mangled 	     name...  */
end_comment

begin_comment
comment|/* We first use the address in the msymbol to try to locate 	     the appropriate symtab. Note that find_pc_sect_symtab() 	     has a side-effect of doing psymtab-to-symtab expansion, 	     for the found symtab.  */
end_comment

begin_comment
unit|s = find_pc_sect_symtab (SYMBOL_VALUE_ADDRESS (msymbol), 				   SYMBOL_BFD_SECTION (msymbol)); 	  if (s != NULL) 	    {
comment|/* This is a function which has a symtab for its address.  */
end_comment

begin_comment
unit|bv = BLOCKVECTOR (s); 	      block = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);
comment|/* This call used to pass `SYMBOL_LINKAGE_NAME (msymbol)' as the 	         `name' argument to lookup_block_symbol.  But the name 	         of a minimal symbol is always mangled, so that seems 	         to be clearly the wrong thing to pass as the 	         unmangled name.  */
end_comment

begin_comment
unit|sym = 		lookup_block_symbol (block, name, linkage_name, domain);
comment|/* We kept static functions in minimal symbol table as well as 	         in static scope. We want to find them in the symbol table. */
end_comment

begin_comment
unit|if (!sym) 		{ 		  block = BLOCKVECTOR_BLOCK (bv, STATIC_BLOCK); 		  sym = lookup_block_symbol (block, name, 					     linkage_name, domain); 		}
comment|/* NOTE: carlton/2002-12-04: The following comment was 		 taken from a time when two versions of this function 		 were part of the body of lookup_symbol_aux: this 		 comment was taken from the version of the function 		 that was #ifdef HPUXHPPA, and the comment was right 		 before the 'return NULL' part of lookup_symbol_aux. 		 (Hence the "Fall through and return 0" comment.) 		 Elena did some digging into the situation for 		 Fortran, and she reports:  		 "I asked around (thanks to Jeff Knaggs), and I think 		 the story for Fortran goes like this:  		 "Apparently, in older Fortrans, '_' was not part of 		 the user namespace.  g77 attached a final '_' to 		 procedure names as the exported symbols for linkage 		 (foo_) , but the symbols went in the debug info just 		 like 'foo'. The rationale behind this is not 		 completely clear, and maybe it was done to other 		 symbols as well, not just procedures."  */
end_comment

begin_comment
comment|/* If we get here with sym == 0, the symbol was  	         found in the minimal symbol table 	         but not in the symtab. 	         Fall through and return 0 to use the msymbol  	         definition of "foo_". 	         (Note that outer code generally follows up a call 	         to this routine with a call to lookup_minimal_symbol(), 	         so a 0 return means we'll just flow into that other routine).  	         This happens for Fortran  "foo_" symbols, 	         which are "foo" in the symtab.  	         This can also happen if "asm" is used to make a 	         regular symbol but not a debugging symbol, e.g. 	         asm(".globl _main"); 	         asm("_main:"); 	       */
end_comment

begin_endif
unit|if (symtab != NULL&& sym != NULL) 		*symtab = s; 	      return fixup_symbol_section (sym, s->objfile); 	    } 	}     }    return NULL; }
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_comment
comment|/* A default version of lookup_symbol_nonlocal for use by languages    that can't think of anything better to do.  This implements the C    lookup rules.  */
end_comment

begin_function
name|struct
name|symbol
modifier|*
name|basic_lookup_symbol_nonlocal
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|linkage_name
parameter_list|,
specifier|const
name|struct
name|block
modifier|*
name|block
parameter_list|,
specifier|const
name|domain_enum
name|domain
parameter_list|,
name|struct
name|symtab
modifier|*
modifier|*
name|symtab
parameter_list|)
block|{
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
comment|/* NOTE: carlton/2003-05-19: The comments below were written when      this (or what turned into this) was part of lookup_symbol_aux;      I'm much less worried about these questions now, since these      decisions have turned out well, but I leave these comments here      for posterity.  */
comment|/* NOTE: carlton/2002-12-05: There is a question as to whether or      not it would be appropriate to search the current global block      here as well.  (That's what this code used to do before the      is_a_field_of_this check was moved up.)  On the one hand, it's      redundant with the lookup_symbol_aux_symtabs search that happens      next.  On the other hand, if decode_line_1 is passed an argument      like filename:var, then the user presumably wants 'var' to be      searched for in filename.  On the third hand, there shouldn't be      multiple global variables all of which are named 'var', and it's      not like decode_line_1 has ever restricted its search to only      global variables in a single filename.  All in all, only      searching the static block here seems best: it's correct and it's      cleanest.  */
comment|/* NOTE: carlton/2002-12-05: There's also a possible performance      issue here: if you usually search for global symbols in the      current file, then it would be slightly better to search the      current global block before searching all the symtabs.  But there      are other factors that have a much greater effect on performance      than that one, so I don't think we should worry about that for      now.  */
name|sym
operator|=
name|lookup_symbol_static
argument_list|(
name|name
argument_list|,
name|linkage_name
argument_list|,
name|block
argument_list|,
name|domain
argument_list|,
name|symtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|!=
name|NULL
condition|)
return|return
name|sym
return|;
return|return
name|lookup_symbol_global
argument_list|(
name|name
argument_list|,
name|linkage_name
argument_list|,
name|domain
argument_list|,
name|symtab
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Lookup a symbol in the static block associated to BLOCK, if there    is one; do nothing if BLOCK is NULL or a global block.  */
end_comment

begin_function
name|struct
name|symbol
modifier|*
name|lookup_symbol_static
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|linkage_name
parameter_list|,
specifier|const
name|struct
name|block
modifier|*
name|block
parameter_list|,
specifier|const
name|domain_enum
name|domain
parameter_list|,
name|struct
name|symtab
modifier|*
modifier|*
name|symtab
parameter_list|)
block|{
specifier|const
name|struct
name|block
modifier|*
name|static_block
init|=
name|block_static_block
argument_list|(
name|block
argument_list|)
decl_stmt|;
if|if
condition|(
name|static_block
operator|!=
name|NULL
condition|)
return|return
name|lookup_symbol_aux_block
argument_list|(
name|name
argument_list|,
name|linkage_name
argument_list|,
name|static_block
argument_list|,
name|domain
argument_list|,
name|symtab
argument_list|)
return|;
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Lookup a symbol in all files' global blocks (searching psymtabs if    necessary).  */
end_comment

begin_function
name|struct
name|symbol
modifier|*
name|lookup_symbol_global
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|linkage_name
parameter_list|,
specifier|const
name|domain_enum
name|domain
parameter_list|,
name|struct
name|symtab
modifier|*
modifier|*
name|symtab
parameter_list|)
block|{
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|sym
operator|=
name|lookup_symbol_aux_symtabs
argument_list|(
name|GLOBAL_BLOCK
argument_list|,
name|name
argument_list|,
name|linkage_name
argument_list|,
name|domain
argument_list|,
name|symtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|!=
name|NULL
condition|)
return|return
name|sym
return|;
return|return
name|lookup_symbol_aux_psymtabs
argument_list|(
name|GLOBAL_BLOCK
argument_list|,
name|name
argument_list|,
name|linkage_name
argument_list|,
name|domain
argument_list|,
name|symtab
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Look, in partial_symtab PST, for symbol whose natural name is NAME.    If LINKAGE_NAME is non-NULL, check in addition that the symbol's    linkage name matches it.  Check the global symbols if GLOBAL, the    static symbols if not */
end_comment

begin_function
name|struct
name|partial_symbol
modifier|*
name|lookup_partial_symbol
parameter_list|(
name|struct
name|partial_symtab
modifier|*
name|pst
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|linkage_name
parameter_list|,
name|int
name|global
parameter_list|,
name|domain_enum
name|domain
parameter_list|)
block|{
name|struct
name|partial_symbol
modifier|*
name|temp
decl_stmt|;
name|struct
name|partial_symbol
modifier|*
modifier|*
name|start
decl_stmt|,
modifier|*
modifier|*
name|psym
decl_stmt|;
name|struct
name|partial_symbol
modifier|*
modifier|*
name|top
decl_stmt|,
modifier|*
modifier|*
name|real_top
decl_stmt|,
modifier|*
modifier|*
name|bottom
decl_stmt|,
modifier|*
modifier|*
name|center
decl_stmt|;
name|int
name|length
init|=
operator|(
name|global
condition|?
name|pst
operator|->
name|n_global_syms
else|:
name|pst
operator|->
name|n_static_syms
operator|)
decl_stmt|;
name|int
name|do_linear_search
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|length
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|start
operator|=
operator|(
name|global
condition|?
name|pst
operator|->
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
operator|+
name|pst
operator|->
name|globals_offset
else|:
name|pst
operator|->
name|objfile
operator|->
name|static_psymbols
operator|.
name|list
operator|+
name|pst
operator|->
name|statics_offset
operator|)
expr_stmt|;
if|if
condition|(
name|global
condition|)
comment|/* This means we can use a binary search. */
block|{
name|do_linear_search
operator|=
literal|0
expr_stmt|;
comment|/* Binary search.  This search is guaranteed to end with center          pointing at the earliest partial symbol whose name might be          correct.  At that point *all* partial symbols with an          appropriate name will be checked against the correct          domain.  */
name|bottom
operator|=
name|start
expr_stmt|;
name|top
operator|=
name|start
operator|+
name|length
operator|-
literal|1
expr_stmt|;
name|real_top
operator|=
name|top
expr_stmt|;
while|while
condition|(
name|top
operator|>
name|bottom
condition|)
block|{
name|center
operator|=
name|bottom
operator|+
operator|(
name|top
operator|-
name|bottom
operator|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|center
operator|<
name|top
operator|)
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"failed internal consistency check"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|do_linear_search
operator|&&
operator|(
name|SYMBOL_LANGUAGE
argument_list|(
operator|*
name|center
argument_list|)
operator|==
name|language_java
operator|)
condition|)
block|{
name|do_linear_search
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|strcmp_iw_ordered
argument_list|(
name|SYMBOL_NATURAL_NAME
argument_list|(
operator|*
name|center
argument_list|)
argument_list|,
name|name
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|top
operator|=
name|center
expr_stmt|;
block|}
else|else
block|{
name|bottom
operator|=
name|center
operator|+
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|top
operator|==
name|bottom
operator|)
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"failed internal consistency check"
argument_list|)
expr_stmt|;
while|while
condition|(
name|top
operator|<=
name|real_top
operator|&&
operator|(
name|linkage_name
operator|!=
name|NULL
condition|?
name|strcmp
argument_list|(
name|SYMBOL_LINKAGE_NAME
argument_list|(
operator|*
name|top
argument_list|)
argument_list|,
name|linkage_name
argument_list|)
operator|==
literal|0
else|:
name|SYMBOL_MATCHES_NATURAL_NAME
argument_list|(
operator|*
name|top
argument_list|,
name|name
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|SYMBOL_DOMAIN
argument_list|(
operator|*
name|top
argument_list|)
operator|==
name|domain
condition|)
block|{
return|return
operator|(
operator|*
name|top
operator|)
return|;
block|}
name|top
operator|++
expr_stmt|;
block|}
block|}
comment|/* Can't use a binary search or else we found during the binary search that      we should also do a linear search. */
if|if
condition|(
name|do_linear_search
condition|)
block|{
for|for
control|(
name|psym
operator|=
name|start
init|;
name|psym
operator|<
name|start
operator|+
name|length
condition|;
name|psym
operator|++
control|)
block|{
if|if
condition|(
name|domain
operator|==
name|SYMBOL_DOMAIN
argument_list|(
operator|*
name|psym
argument_list|)
condition|)
block|{
if|if
condition|(
name|linkage_name
operator|!=
name|NULL
condition|?
name|strcmp
argument_list|(
name|SYMBOL_LINKAGE_NAME
argument_list|(
operator|*
name|psym
argument_list|)
argument_list|,
name|linkage_name
argument_list|)
operator|==
literal|0
else|:
name|SYMBOL_MATCHES_NATURAL_NAME
argument_list|(
operator|*
name|psym
argument_list|,
name|name
argument_list|)
condition|)
block|{
return|return
operator|(
operator|*
name|psym
operator|)
return|;
block|}
block|}
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Look up a type named NAME in the struct_domain.  The type returned    must not be opaque -- i.e., must have at least one field    defined.  */
end_comment

begin_function
name|struct
name|type
modifier|*
name|lookup_transparent_type
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
name|current_language
operator|->
name|la_lookup_transparent_type
argument_list|(
name|name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The standard implementation of lookup_transparent_type.  This code    was modeled on lookup_symbol -- the parts not relevant to looking    up types were just left out.  In particular it's assumed here that    types are available in struct_domain and only at file-static or    global blocks.  */
end_comment

begin_function
name|struct
name|type
modifier|*
name|basic_lookup_transparent_type
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|struct
name|symtab
modifier|*
name|s
init|=
name|NULL
decl_stmt|;
name|struct
name|partial_symtab
modifier|*
name|ps
decl_stmt|;
name|struct
name|blockvector
modifier|*
name|bv
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|block
modifier|*
name|block
decl_stmt|;
comment|/* Now search all the global symbols.  Do the symtab's first, then      check the psymtab's. If a psymtab indicates the existence      of the desired name as a global, then do psymtab-to-symtab      conversion on the fly and return the found symbol.  */
name|ALL_SYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
block|{
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|block
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
expr_stmt|;
name|sym
operator|=
name|lookup_block_symbol
argument_list|(
name|block
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|,
name|STRUCT_DOMAIN
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|&&
operator|!
name|TYPE_IS_OPAQUE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
return|;
block|}
block|}
name|ALL_PSYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|ps
argument_list|)
block|{
if|if
condition|(
operator|!
name|ps
operator|->
name|readin
operator|&&
name|lookup_partial_symbol
argument_list|(
name|ps
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
name|STRUCT_DOMAIN
argument_list|)
condition|)
block|{
name|s
operator|=
name|PSYMTAB_TO_SYMTAB
argument_list|(
name|ps
argument_list|)
expr_stmt|;
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|block
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
expr_stmt|;
name|sym
operator|=
name|lookup_block_symbol
argument_list|(
name|block
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|,
name|STRUCT_DOMAIN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sym
condition|)
block|{
comment|/* This shouldn't be necessary, but as a last resort 	     * try looking in the statics even though the psymtab 	     * claimed the symbol was global. It's possible that 	     * the psymtab gets it wrong in some cases. 	     */
name|block
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|STATIC_BLOCK
argument_list|)
expr_stmt|;
name|sym
operator|=
name|lookup_block_symbol
argument_list|(
name|block
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|,
name|STRUCT_DOMAIN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sym
condition|)
name|error
argument_list|(
literal|"Internal: global symbol `%s' found in %s psymtab but not in symtab.\n\ %s may be an inlined function, or may be a template function\n\ (if a template, try specifying an instantiation: %s<type>)."
argument_list|,
name|name
argument_list|,
name|ps
operator|->
name|filename
argument_list|,
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|TYPE_IS_OPAQUE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
condition|)
return|return
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
return|;
block|}
block|}
comment|/* Now search the static file-level symbols.      Not strictly correct, but more useful than an error.      Do the symtab's first, then      check the psymtab's. If a psymtab indicates the existence      of the desired name as a file-level static, then do psymtab-to-symtab      conversion on the fly and return the found symbol.    */
name|ALL_SYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
block|{
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|block
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|STATIC_BLOCK
argument_list|)
expr_stmt|;
name|sym
operator|=
name|lookup_block_symbol
argument_list|(
name|block
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|,
name|STRUCT_DOMAIN
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|&&
operator|!
name|TYPE_IS_OPAQUE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
return|;
block|}
block|}
name|ALL_PSYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|ps
argument_list|)
block|{
if|if
condition|(
operator|!
name|ps
operator|->
name|readin
operator|&&
name|lookup_partial_symbol
argument_list|(
name|ps
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|STRUCT_DOMAIN
argument_list|)
condition|)
block|{
name|s
operator|=
name|PSYMTAB_TO_SYMTAB
argument_list|(
name|ps
argument_list|)
expr_stmt|;
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|block
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|STATIC_BLOCK
argument_list|)
expr_stmt|;
name|sym
operator|=
name|lookup_block_symbol
argument_list|(
name|block
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|,
name|STRUCT_DOMAIN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sym
condition|)
block|{
comment|/* This shouldn't be necessary, but as a last resort 	     * try looking in the globals even though the psymtab 	     * claimed the symbol was static. It's possible that 	     * the psymtab gets it wrong in some cases. 	     */
name|block
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
expr_stmt|;
name|sym
operator|=
name|lookup_block_symbol
argument_list|(
name|block
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|,
name|STRUCT_DOMAIN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sym
condition|)
name|error
argument_list|(
literal|"Internal: static symbol `%s' found in %s psymtab but not in symtab.\n\ %s may be an inlined function, or may be a template function\n\ (if a template, try specifying an instantiation: %s<type>)."
argument_list|,
name|name
argument_list|,
name|ps
operator|->
name|filename
argument_list|,
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|TYPE_IS_OPAQUE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
condition|)
return|return
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
return|;
block|}
block|}
return|return
operator|(
expr|struct
name|type
operator|*
operator|)
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Find the psymtab containing main(). */
end_comment

begin_comment
comment|/* FIXME:  What about languages without main() or specially linked    executables that have no main() ? */
end_comment

begin_function
name|struct
name|partial_symtab
modifier|*
name|find_main_psymtab
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|ALL_PSYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|pst
argument_list|)
block|{
if|if
condition|(
name|lookup_partial_symbol
argument_list|(
name|pst
argument_list|,
name|main_name
argument_list|()
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
name|VAR_DOMAIN
argument_list|)
condition|)
block|{
return|return
operator|(
name|pst
operator|)
return|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Search BLOCK for symbol NAME in DOMAIN.     Note that if NAME is the demangled form of a C++ symbol, we will fail    to find a match during the binary search of the non-encoded names, but    for now we don't worry about the slight inefficiency of looking for    a match we'll never find, since it will go pretty quick.  Once the    binary search terminates, we drop through and do a straight linear    search on the symbols.  Each symbol which is marked as being a ObjC/C++    symbol (language_cplus or language_objc set) has both the encoded and     non-encoded names tested for a match.     If LINKAGE_NAME is non-NULL, verify that any symbol we find has this    particular mangled name. */
end_comment

begin_function
name|struct
name|symbol
modifier|*
name|lookup_block_symbol
parameter_list|(
specifier|const
name|struct
name|block
modifier|*
name|block
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|linkage_name
parameter_list|,
specifier|const
name|domain_enum
name|domain
parameter_list|)
block|{
name|struct
name|dict_iterator
name|iter
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
if|if
condition|(
operator|!
name|BLOCK_FUNCTION
argument_list|(
name|block
argument_list|)
condition|)
block|{
for|for
control|(
name|sym
operator|=
name|dict_iter_name_first
argument_list|(
name|BLOCK_DICT
argument_list|(
name|block
argument_list|)
argument_list|,
name|name
argument_list|,
operator|&
name|iter
argument_list|)
init|;
name|sym
operator|!=
name|NULL
condition|;
name|sym
operator|=
name|dict_iter_name_next
argument_list|(
name|name
argument_list|,
operator|&
name|iter
argument_list|)
control|)
block|{
if|if
condition|(
name|SYMBOL_DOMAIN
argument_list|(
name|sym
argument_list|)
operator|==
name|domain
operator|&&
operator|(
name|linkage_name
operator|!=
name|NULL
condition|?
name|strcmp
argument_list|(
name|SYMBOL_LINKAGE_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|linkage_name
argument_list|)
operator|==
literal|0
else|:
literal|1
operator|)
condition|)
return|return
name|sym
return|;
block|}
return|return
name|NULL
return|;
block|}
else|else
block|{
comment|/* Note that parameter symbols do not always show up last in the 	 list; this loop makes sure to take anything else other than 	 parameter symbols first; it only uses parameter symbols as a 	 last resort.  Note that this only takes up extra computation 	 time on a match.  */
name|struct
name|symbol
modifier|*
name|sym_found
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|sym
operator|=
name|dict_iter_name_first
argument_list|(
name|BLOCK_DICT
argument_list|(
name|block
argument_list|)
argument_list|,
name|name
argument_list|,
operator|&
name|iter
argument_list|)
init|;
name|sym
operator|!=
name|NULL
condition|;
name|sym
operator|=
name|dict_iter_name_next
argument_list|(
name|name
argument_list|,
operator|&
name|iter
argument_list|)
control|)
block|{
if|if
condition|(
name|SYMBOL_DOMAIN
argument_list|(
name|sym
argument_list|)
operator|==
name|domain
operator|&&
operator|(
name|linkage_name
operator|!=
name|NULL
condition|?
name|strcmp
argument_list|(
name|SYMBOL_LINKAGE_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|linkage_name
argument_list|)
operator|==
literal|0
else|:
literal|1
operator|)
condition|)
block|{
name|sym_found
operator|=
name|sym
expr_stmt|;
if|if
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|!=
name|LOC_ARG
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|!=
name|LOC_LOCAL_ARG
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|!=
name|LOC_REF_ARG
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|!=
name|LOC_REGPARM
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|!=
name|LOC_REGPARM_ADDR
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|!=
name|LOC_BASEREG_ARG
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|!=
name|LOC_COMPUTED_ARG
condition|)
block|{
break|break;
block|}
block|}
block|}
return|return
operator|(
name|sym_found
operator|)
return|;
comment|/* Will be NULL if not found. */
block|}
block|}
end_function

begin_comment
comment|/* Find the symtab associated with PC and SECTION.  Look through the    psymtabs and read in another symtab if necessary. */
end_comment

begin_function
name|struct
name|symtab
modifier|*
name|find_pc_sect_symtab
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|asection
modifier|*
name|section
parameter_list|)
block|{
name|struct
name|block
modifier|*
name|b
decl_stmt|;
name|struct
name|blockvector
modifier|*
name|bv
decl_stmt|;
name|struct
name|symtab
modifier|*
name|s
init|=
name|NULL
decl_stmt|;
name|struct
name|symtab
modifier|*
name|best_s
init|=
name|NULL
decl_stmt|;
name|struct
name|partial_symtab
modifier|*
name|ps
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|CORE_ADDR
name|distance
init|=
literal|0
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
comment|/* If we know that this is not a text address, return failure.  This is      necessary because we loop based on the block's high and low code      addresses, which do not include the data ranges, and because      we call find_pc_sect_psymtab which has a similar restriction based      on the partial_symtab's texthigh and textlow.  */
name|msymbol
operator|=
name|lookup_minimal_symbol_by_pc_section
argument_list|(
name|pc
argument_list|,
name|section
argument_list|)
expr_stmt|;
if|if
condition|(
name|msymbol
operator|&&
operator|(
name|msymbol
operator|->
name|type
operator|==
name|mst_data
operator|||
name|msymbol
operator|->
name|type
operator|==
name|mst_bss
operator|||
name|msymbol
operator|->
name|type
operator|==
name|mst_abs
operator|||
name|msymbol
operator|->
name|type
operator|==
name|mst_file_data
operator|||
name|msymbol
operator|->
name|type
operator|==
name|mst_file_bss
operator|)
condition|)
return|return
name|NULL
return|;
comment|/* Search all symtabs for the one whose file contains our address, and which      is the smallest of all the ones containing the address.  This is designed      to deal with a case like symtab a is at 0x1000-0x2000 and 0x3000-0x4000      and symtab b is at 0x2000-0x3000.  So the GLOBAL_BLOCK for a is from      0x1000-0x4000, but for address 0x2345 we want to return symtab b.       This happens for native ecoff format, where code from included files      gets its own symtab. The symtab for the included file should have      been read in already via the dependency mechanism.      It might be swifter to create several symtabs with the same name      like xcoff does (I'm not sure).       It also happens for objfiles that have their functions reordered.      For these, the symtab we are looking for is not necessarily read in.  */
name|ALL_SYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
block|{
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|b
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|BLOCK_START
argument_list|(
name|b
argument_list|)
operator|<=
name|pc
operator|&&
name|BLOCK_END
argument_list|(
name|b
argument_list|)
operator|>
name|pc
operator|&&
operator|(
name|distance
operator|==
literal|0
operator|||
name|BLOCK_END
argument_list|(
name|b
argument_list|)
operator|-
name|BLOCK_START
argument_list|(
name|b
argument_list|)
operator|<
name|distance
operator|)
condition|)
block|{
comment|/* For an objfile that has its functions reordered, 	   find_pc_psymtab will find the proper partial symbol table 	   and we simply return its corresponding symtab.  */
comment|/* In order to better support objfiles that contain both 	   stabs and coff debugging info, we continue on if a psymtab 	   can't be found. */
if|if
condition|(
operator|(
name|objfile
operator|->
name|flags
operator|&
name|OBJF_REORDERED
operator|)
operator|&&
name|objfile
operator|->
name|psymtabs
condition|)
block|{
name|ps
operator|=
name|find_pc_sect_psymtab
argument_list|(
name|pc
argument_list|,
name|section
argument_list|)
expr_stmt|;
if|if
condition|(
name|ps
condition|)
return|return
name|PSYMTAB_TO_SYMTAB
argument_list|(
name|ps
argument_list|)
return|;
block|}
if|if
condition|(
name|section
operator|!=
literal|0
condition|)
block|{
name|struct
name|dict_iterator
name|iter
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
init|=
name|NULL
decl_stmt|;
name|ALL_BLOCK_SYMBOLS
argument_list|(
argument|b
argument_list|,
argument|iter
argument_list|,
argument|sym
argument_list|)
block|{
name|fixup_symbol_section
argument_list|(
name|sym
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|section
operator|==
name|SYMBOL_BFD_SECTION
argument_list|(
name|sym
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|sym
operator|==
name|NULL
condition|)
continue|continue;
comment|/* no symbol in this symtab matches section */
block|}
name|distance
operator|=
name|BLOCK_END
argument_list|(
name|b
argument_list|)
operator|-
name|BLOCK_START
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|best_s
operator|=
name|s
expr_stmt|;
block|}
block|}
if|if
condition|(
name|best_s
operator|!=
name|NULL
condition|)
return|return
operator|(
name|best_s
operator|)
return|;
name|s
operator|=
name|NULL
expr_stmt|;
name|ps
operator|=
name|find_pc_sect_psymtab
argument_list|(
name|pc
argument_list|,
name|section
argument_list|)
expr_stmt|;
if|if
condition|(
name|ps
condition|)
block|{
if|if
condition|(
name|ps
operator|->
name|readin
condition|)
comment|/* Might want to error() here (in case symtab is corrupt and 	   will cause a core dump), but maybe we can successfully 	   continue, so let's not.  */
name|warning
argument_list|(
literal|"\ (Internal error: pc 0x%s in read in psymtab, but not in symtab.)\n"
argument_list|,
name|paddr_nz
argument_list|(
name|pc
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|PSYMTAB_TO_SYMTAB
argument_list|(
name|ps
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Find the symtab associated with PC.  Look through the psymtabs and    read in another symtab if necessary.  Backward compatibility, no section */
end_comment

begin_function
name|struct
name|symtab
modifier|*
name|find_pc_symtab
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
return|return
name|find_pc_sect_symtab
argument_list|(
name|pc
argument_list|,
name|find_pc_mapped_section
argument_list|(
name|pc
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find the source file and line number for a given PC value and SECTION.    Return a structure containing a symtab pointer, a line number,    and a pc range for the entire source line.    The value's .pc field is NOT the specified pc.    NOTCURRENT nonzero means, if specified pc is on a line boundary,    use the line that ends there.  Otherwise, in that case, the line    that begins there is used.  */
end_comment

begin_comment
comment|/* The big complication here is that a line may start in one file, and end just    before the start of another file.  This usually occurs when you #include    code in the middle of a subroutine.  To properly find the end of a line's PC    range, we must search all symtabs associated with this compilation unit, and    find the one whose first PC is closer than that of the next line in this    symtab.  */
end_comment

begin_comment
comment|/* If it's worth the effort, we could be using a binary search.  */
end_comment

begin_function
name|struct
name|symtab_and_line
name|find_pc_sect_line
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|struct
name|bfd_section
modifier|*
name|section
parameter_list|,
name|int
name|notcurrent
parameter_list|)
block|{
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
name|struct
name|linetable
modifier|*
name|l
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|linetable_entry
modifier|*
name|item
decl_stmt|;
name|struct
name|symtab_and_line
name|val
decl_stmt|;
name|struct
name|blockvector
modifier|*
name|bv
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|mfunsym
decl_stmt|;
comment|/* Info on best line seen so far, and where it starts, and its file.  */
name|struct
name|linetable_entry
modifier|*
name|best
init|=
name|NULL
decl_stmt|;
name|CORE_ADDR
name|best_end
init|=
literal|0
decl_stmt|;
name|struct
name|symtab
modifier|*
name|best_symtab
init|=
literal|0
decl_stmt|;
comment|/* Store here the first line number      of a file which contains the line at the smallest pc after PC.      If we don't find a line whose range contains PC,      we will use a line one less than this,      with a range from the start of that file to the first line's pc.  */
name|struct
name|linetable_entry
modifier|*
name|alt
init|=
name|NULL
decl_stmt|;
name|struct
name|symtab
modifier|*
name|alt_symtab
init|=
literal|0
decl_stmt|;
comment|/* Info on best line seen in this file.  */
name|struct
name|linetable_entry
modifier|*
name|prev
decl_stmt|;
comment|/* If this pc is not from the current frame,      it is the address of the end of a call instruction.      Quite likely that is the start of the following statement.      But what we want is the statement containing the instruction.      Fudge the pc to make sure we get that.  */
name|init_sal
argument_list|(
operator|&
name|val
argument_list|)
expr_stmt|;
comment|/* initialize to zeroes */
comment|/* It's tempting to assume that, if we can't find debugging info for      any function enclosing PC, that we shouldn't search for line      number info, either.  However, GAS can emit line number info for      assembly files --- very helpful when debugging hand-written      assembly code.  In such a case, we'd have no debug info for the      function, but we would have line info.  */
if|if
condition|(
name|notcurrent
condition|)
name|pc
operator|-=
literal|1
expr_stmt|;
comment|/* elz: added this because this function returned the wrong      information if the pc belongs to a stub (import/export)      to call a shlib function. This stub would be anywhere between      two functions in the target, and the line info was erroneously       taken to be the one of the line before the pc.     */
comment|/* RT: Further explanation:     * We have stubs (trampolines) inserted between procedures.    *    * Example: "shr1" exists in a shared library, and a "shr1" stub also    * exists in the main image.    *    * In the minimal symbol table, we have a bunch of symbols    * sorted by start address. The stubs are marked as "trampoline",    * the others appear as text. E.g.:    *    *  Minimal symbol table for main image     *     main:  code for main (text symbol)    *     shr1: stub  (trampoline symbol)    *     foo:   code for foo (text symbol)    *     ...    *  Minimal symbol table for "shr1" image:    *     ...    *     shr1: code for shr1 (text symbol)    *     ...    *    * So the code below is trying to detect if we are in the stub    * ("shr1" stub), and if so, find the real code ("shr1" trampoline),    * and if found,  do the symbolization from the real-code address    * rather than the stub address.    *    * Assumptions being made about the minimal symbol table:    *   1. lookup_minimal_symbol_by_pc() will return a trampoline only    *      if we're really in the trampoline. If we're beyond it (say    *      we're in "foo" in the above example), it'll have a closer     *      symbol (the "foo" text symbol for example) and will not    *      return the trampoline.    *   2. lookup_minimal_symbol_text() will find a real text symbol    *      corresponding to the trampoline, and whose address will    *      be different than the trampoline address. I put in a sanity    *      check for the address being the same, to avoid an    *      infinite recursion.    */
name|msymbol
operator|=
name|lookup_minimal_symbol_by_pc
argument_list|(
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|msymbol
operator|!=
name|NULL
condition|)
if|if
condition|(
name|MSYMBOL_TYPE
argument_list|(
name|msymbol
argument_list|)
operator|==
name|mst_solib_trampoline
condition|)
block|{
name|mfunsym
operator|=
name|lookup_minimal_symbol_text
argument_list|(
name|SYMBOL_LINKAGE_NAME
argument_list|(
name|msymbol
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mfunsym
operator|==
name|NULL
condition|)
comment|/* I eliminated this warning since it is coming out 	   * in the following situation: 	   * gdb shmain // test program with shared libraries 	   * (gdb) break shr1  // function in shared lib 	   * Warning: In stub for ... 	   * In the above situation, the shared lib is not loaded yet,  	   * so of course we can't find the real func/line info, 	   * but the "break" still works, and the warning is annoying. 	   * So I commented out the warning. RT */
comment|/* warning ("In stub for %s; unable to find real function/line info", SYMBOL_LINKAGE_NAME (msymbol)) */
empty_stmt|;
comment|/* fall through */
elseif|else
if|if
condition|(
name|SYMBOL_VALUE
argument_list|(
name|mfunsym
argument_list|)
operator|==
name|SYMBOL_VALUE
argument_list|(
name|msymbol
argument_list|)
condition|)
comment|/* Avoid infinite recursion */
comment|/* See above comment about why warning is commented out */
comment|/* warning ("In stub for %s; unable to find real function/line info", SYMBOL_LINKAGE_NAME (msymbol)) */
empty_stmt|;
comment|/* fall through */
else|else
return|return
name|find_pc_line
argument_list|(
name|SYMBOL_VALUE
argument_list|(
name|mfunsym
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|s
operator|=
name|find_pc_sect_symtab
argument_list|(
name|pc
argument_list|,
name|section
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
block|{
comment|/* if no symbol information, return previous pc */
if|if
condition|(
name|notcurrent
condition|)
name|pc
operator|++
expr_stmt|;
name|val
operator|.
name|pc
operator|=
name|pc
expr_stmt|;
return|return
name|val
return|;
block|}
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Look at all the symtabs that share this blockvector.      They all have the same apriori range, that we found was right;      but they have different line tables.  */
for|for
control|(
init|;
name|s
operator|&&
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
operator|==
name|bv
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
comment|/* Find the best line in this symtab.  */
name|l
operator|=
name|LINETABLE
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|l
condition|)
continue|continue;
name|len
operator|=
name|l
operator|->
name|nitems
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
block|{
comment|/* I think len can be zero if the symtab lacks line numbers 	     (e.g. gcc -g1).  (Either that or the LINETABLE is NULL; 	     I'm not sure which, and maybe it depends on the symbol 	     reader).  */
continue|continue;
block|}
name|prev
operator|=
name|NULL
expr_stmt|;
name|item
operator|=
name|l
operator|->
name|item
expr_stmt|;
comment|/* Get first line info */
comment|/* Is this file's first line closer than the first lines of other files?          If so, record this file, and its first line, as best alternate.  */
if|if
condition|(
name|item
operator|->
name|pc
operator|>
name|pc
operator|&&
operator|(
operator|!
name|alt
operator|||
name|item
operator|->
name|pc
operator|<
name|alt
operator|->
name|pc
operator|)
condition|)
block|{
name|alt
operator|=
name|item
expr_stmt|;
name|alt_symtab
operator|=
name|s
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
operator|,
name|item
operator|++
control|)
block|{
comment|/* Leave prev pointing to the linetable entry for the last line 	     that started at or before PC.  */
if|if
condition|(
name|item
operator|->
name|pc
operator|>
name|pc
condition|)
break|break;
name|prev
operator|=
name|item
expr_stmt|;
block|}
comment|/* At this point, prev points at the line whose start addr is<= pc, and          item points at the next line.  If we ran off the end of the linetable          (pc>= start of the last line), then prev == item.  If pc< start of          the first line, prev will not be set.  */
comment|/* Is this file's best line closer than the best in the other files?          If so, record this file, and its best line, as best so far.  Don't          save prev if it represents the end of a function (i.e. line number          0) instead of a real line.  */
if|if
condition|(
name|prev
operator|&&
name|prev
operator|->
name|line
operator|&&
operator|(
operator|!
name|best
operator|||
name|prev
operator|->
name|pc
operator|>
name|best
operator|->
name|pc
operator|)
condition|)
block|{
name|best
operator|=
name|prev
expr_stmt|;
name|best_symtab
operator|=
name|s
expr_stmt|;
comment|/* Discard BEST_END if it's before the PC of the current BEST.  */
if|if
condition|(
name|best_end
operator|<=
name|best
operator|->
name|pc
condition|)
name|best_end
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If another line (denoted by ITEM) is in the linetable and its          PC is after BEST's PC, but before the current BEST_END, then 	 use ITEM's PC as the new best_end.  */
if|if
condition|(
name|best
operator|&&
name|i
operator|<
name|len
operator|&&
name|item
operator|->
name|pc
operator|>
name|best
operator|->
name|pc
operator|&&
operator|(
name|best_end
operator|==
literal|0
operator|||
name|best_end
operator|>
name|item
operator|->
name|pc
operator|)
condition|)
name|best_end
operator|=
name|item
operator|->
name|pc
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|best_symtab
condition|)
block|{
if|if
condition|(
operator|!
name|alt_symtab
condition|)
block|{
comment|/* If we didn't find any line # info, just 				   return zeros.  */
name|val
operator|.
name|pc
operator|=
name|pc
expr_stmt|;
block|}
else|else
block|{
name|val
operator|.
name|symtab
operator|=
name|alt_symtab
expr_stmt|;
name|val
operator|.
name|line
operator|=
name|alt
operator|->
name|line
operator|-
literal|1
expr_stmt|;
comment|/* Don't return line 0, that means that we didn't find the line.  */
if|if
condition|(
name|val
operator|.
name|line
operator|==
literal|0
condition|)
operator|++
name|val
operator|.
name|line
expr_stmt|;
name|val
operator|.
name|pc
operator|=
name|BLOCK_END
argument_list|(
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
argument_list|)
expr_stmt|;
name|val
operator|.
name|end
operator|=
name|alt
operator|->
name|pc
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|best
operator|->
name|line
operator|==
literal|0
condition|)
block|{
comment|/* If our best fit is in a range of PC's for which no line 	 number info is available (line number is zero) then we didn't 	 find any valid line information. */
name|val
operator|.
name|pc
operator|=
name|pc
expr_stmt|;
block|}
else|else
block|{
name|val
operator|.
name|symtab
operator|=
name|best_symtab
expr_stmt|;
name|val
operator|.
name|line
operator|=
name|best
operator|->
name|line
expr_stmt|;
name|val
operator|.
name|pc
operator|=
name|best
operator|->
name|pc
expr_stmt|;
if|if
condition|(
name|best_end
operator|&&
operator|(
operator|!
name|alt
operator|||
name|best_end
operator|<
name|alt
operator|->
name|pc
operator|)
condition|)
name|val
operator|.
name|end
operator|=
name|best_end
expr_stmt|;
elseif|else
if|if
condition|(
name|alt
condition|)
name|val
operator|.
name|end
operator|=
name|alt
operator|->
name|pc
expr_stmt|;
else|else
name|val
operator|.
name|end
operator|=
name|BLOCK_END
argument_list|(
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|val
operator|.
name|section
operator|=
name|section
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Backward compatibility (no section) */
end_comment

begin_function
name|struct
name|symtab_and_line
name|find_pc_line
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|int
name|notcurrent
parameter_list|)
block|{
name|asection
modifier|*
name|section
decl_stmt|;
name|section
operator|=
name|find_pc_overlay
argument_list|(
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|pc_in_unmapped_range
argument_list|(
name|pc
argument_list|,
name|section
argument_list|)
condition|)
name|pc
operator|=
name|overlay_mapped_address
argument_list|(
name|pc
argument_list|,
name|section
argument_list|)
expr_stmt|;
return|return
name|find_pc_sect_line
argument_list|(
name|pc
argument_list|,
name|section
argument_list|,
name|notcurrent
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find line number LINE in any symtab whose name is the same as    SYMTAB.     If found, return the symtab that contains the linetable in which it was    found, set *INDEX to the index in the linetable of the best entry    found, and set *EXACT_MATCH nonzero if the value returned is an    exact match.     If not found, return NULL.  */
end_comment

begin_function
name|struct
name|symtab
modifier|*
name|find_line_symtab
parameter_list|(
name|struct
name|symtab
modifier|*
name|symtab
parameter_list|,
name|int
name|line
parameter_list|,
name|int
modifier|*
name|index
parameter_list|,
name|int
modifier|*
name|exact_match
parameter_list|)
block|{
name|int
name|exact
decl_stmt|;
comment|/* BEST_INDEX and BEST_LINETABLE identify the smallest linenumber> LINE      so far seen.  */
name|int
name|best_index
decl_stmt|;
name|struct
name|linetable
modifier|*
name|best_linetable
decl_stmt|;
name|struct
name|symtab
modifier|*
name|best_symtab
decl_stmt|;
comment|/* First try looking it up in the given symtab.  */
name|best_linetable
operator|=
name|LINETABLE
argument_list|(
name|symtab
argument_list|)
expr_stmt|;
name|best_symtab
operator|=
name|symtab
expr_stmt|;
name|best_index
operator|=
name|find_line_common
argument_list|(
name|best_linetable
argument_list|,
name|line
argument_list|,
operator|&
name|exact
argument_list|)
expr_stmt|;
if|if
condition|(
name|best_index
operator|<
literal|0
operator|||
operator|!
name|exact
condition|)
block|{
comment|/* Didn't find an exact match.  So we better keep looking for          another symtab with the same name.  In the case of xcoff,          multiple csects for one source file (produced by IBM's FORTRAN          compiler) produce multiple symtabs (this is unavoidable          assuming csects can be at arbitrary places in memory and that          the GLOBAL_BLOCK of a symtab has a begin and end address).  */
comment|/* BEST is the smallest linenumber> LINE so far seen,          or 0 if none has been seen so far.          BEST_INDEX and BEST_LINETABLE identify the item for it.  */
name|int
name|best
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|best_index
operator|>=
literal|0
condition|)
name|best
operator|=
name|best_linetable
operator|->
name|item
index|[
name|best_index
index|]
operator|.
name|line
expr_stmt|;
else|else
name|best
operator|=
literal|0
expr_stmt|;
name|ALL_SYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
block|{
name|struct
name|linetable
modifier|*
name|l
decl_stmt|;
name|int
name|ind
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|symtab
operator|->
name|filename
argument_list|,
name|s
operator|->
name|filename
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
name|l
operator|=
name|LINETABLE
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ind
operator|=
name|find_line_common
argument_list|(
name|l
argument_list|,
name|line
argument_list|,
operator|&
name|exact
argument_list|)
expr_stmt|;
if|if
condition|(
name|ind
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|exact
condition|)
block|{
name|best_index
operator|=
name|ind
expr_stmt|;
name|best_linetable
operator|=
name|l
expr_stmt|;
name|best_symtab
operator|=
name|s
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|best
operator|==
literal|0
operator|||
name|l
operator|->
name|item
index|[
name|ind
index|]
operator|.
name|line
operator|<
name|best
condition|)
block|{
name|best
operator|=
name|l
operator|->
name|item
index|[
name|ind
index|]
operator|.
name|line
expr_stmt|;
name|best_index
operator|=
name|ind
expr_stmt|;
name|best_linetable
operator|=
name|l
expr_stmt|;
name|best_symtab
operator|=
name|s
expr_stmt|;
block|}
block|}
block|}
block|}
name|done
label|:
if|if
condition|(
name|best_index
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|index
condition|)
operator|*
name|index
operator|=
name|best_index
expr_stmt|;
if|if
condition|(
name|exact_match
condition|)
operator|*
name|exact_match
operator|=
name|exact
expr_stmt|;
return|return
name|best_symtab
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Set the PC value for a given source file and line number and return true.    Returns zero for invalid line number (and sets the PC to 0).    The source file is specified with a struct symtab.  */
end_comment

begin_function
name|int
name|find_line_pc
parameter_list|(
name|struct
name|symtab
modifier|*
name|symtab
parameter_list|,
name|int
name|line
parameter_list|,
name|CORE_ADDR
modifier|*
name|pc
parameter_list|)
block|{
name|struct
name|linetable
modifier|*
name|l
decl_stmt|;
name|int
name|ind
decl_stmt|;
operator|*
name|pc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|symtab
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|symtab
operator|=
name|find_line_symtab
argument_list|(
name|symtab
argument_list|,
name|line
argument_list|,
operator|&
name|ind
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|symtab
operator|!=
name|NULL
condition|)
block|{
name|l
operator|=
name|LINETABLE
argument_list|(
name|symtab
argument_list|)
expr_stmt|;
operator|*
name|pc
operator|=
name|l
operator|->
name|item
index|[
name|ind
index|]
operator|.
name|pc
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Find the range of pc values in a line.    Store the starting pc of the line into *STARTPTR    and the ending pc (start of next line) into *ENDPTR.    Returns 1 to indicate success.    Returns 0 if could not find the specified line.  */
end_comment

begin_function
name|int
name|find_line_pc_range
parameter_list|(
name|struct
name|symtab_and_line
name|sal
parameter_list|,
name|CORE_ADDR
modifier|*
name|startptr
parameter_list|,
name|CORE_ADDR
modifier|*
name|endptr
parameter_list|)
block|{
name|CORE_ADDR
name|startaddr
decl_stmt|;
name|struct
name|symtab_and_line
name|found_sal
decl_stmt|;
name|startaddr
operator|=
name|sal
operator|.
name|pc
expr_stmt|;
if|if
condition|(
name|startaddr
operator|==
literal|0
operator|&&
operator|!
name|find_line_pc
argument_list|(
name|sal
operator|.
name|symtab
argument_list|,
name|sal
operator|.
name|line
argument_list|,
operator|&
name|startaddr
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* This whole function is based on address.  For example, if line 10 has      two parts, one from 0x100 to 0x200 and one from 0x300 to 0x400, then      "info line *0x123" should say the line goes from 0x100 to 0x200      and "info line *0x355" should say the line goes from 0x300 to 0x400.      This also insures that we never give a range like "starts at 0x134      and ends at 0x12c".  */
name|found_sal
operator|=
name|find_pc_sect_line
argument_list|(
name|startaddr
argument_list|,
name|sal
operator|.
name|section
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|found_sal
operator|.
name|line
operator|!=
name|sal
operator|.
name|line
condition|)
block|{
comment|/* The specified line (sal) has zero bytes.  */
operator|*
name|startptr
operator|=
name|found_sal
operator|.
name|pc
expr_stmt|;
operator|*
name|endptr
operator|=
name|found_sal
operator|.
name|pc
expr_stmt|;
block|}
else|else
block|{
operator|*
name|startptr
operator|=
name|found_sal
operator|.
name|pc
expr_stmt|;
operator|*
name|endptr
operator|=
name|found_sal
operator|.
name|end
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Given a line table and a line number, return the index into the line    table for the pc of the nearest line whose number is>= the specified one.    Return -1 if none is found.  The value is>= 0 if it is an index.     Set *EXACT_MATCH nonzero if the value returned is an exact match.  */
end_comment

begin_function
specifier|static
name|int
name|find_line_common
parameter_list|(
name|struct
name|linetable
modifier|*
name|l
parameter_list|,
name|int
name|lineno
parameter_list|,
name|int
modifier|*
name|exact_match
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/* BEST is the smallest linenumber> LINENO so far seen,      or 0 if none has been seen so far.      BEST_INDEX identifies the item for it.  */
name|int
name|best_index
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|best
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|lineno
operator|<=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|l
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|len
operator|=
name|l
operator|->
name|nitems
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|linetable_entry
modifier|*
name|item
init|=
operator|&
operator|(
name|l
operator|->
name|item
index|[
name|i
index|]
operator|)
decl_stmt|;
if|if
condition|(
name|item
operator|->
name|line
operator|==
name|lineno
condition|)
block|{
comment|/* Return the first (lowest address) entry which matches.  */
operator|*
name|exact_match
operator|=
literal|1
expr_stmt|;
return|return
name|i
return|;
block|}
if|if
condition|(
name|item
operator|->
name|line
operator|>
name|lineno
operator|&&
operator|(
name|best
operator|==
literal|0
operator|||
name|item
operator|->
name|line
operator|<
name|best
operator|)
condition|)
block|{
name|best
operator|=
name|item
operator|->
name|line
expr_stmt|;
name|best_index
operator|=
name|i
expr_stmt|;
block|}
block|}
comment|/* If we got here, we didn't get an exact match.  */
operator|*
name|exact_match
operator|=
literal|0
expr_stmt|;
return|return
name|best_index
return|;
block|}
end_function

begin_function
name|int
name|find_pc_line_pc_range
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|CORE_ADDR
modifier|*
name|startptr
parameter_list|,
name|CORE_ADDR
modifier|*
name|endptr
parameter_list|)
block|{
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|sal
operator|=
name|find_pc_line
argument_list|(
name|pc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|startptr
operator|=
name|sal
operator|.
name|pc
expr_stmt|;
operator|*
name|endptr
operator|=
name|sal
operator|.
name|end
expr_stmt|;
return|return
name|sal
operator|.
name|symtab
operator|!=
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Given a function symbol SYM, find the symtab and line for the start    of the function.    If the argument FUNFIRSTLINE is nonzero, we want the first line    of real code inside the function.  */
end_comment

begin_function
name|struct
name|symtab_and_line
name|find_function_start_sal
parameter_list|(
name|struct
name|symbol
modifier|*
name|sym
parameter_list|,
name|int
name|funfirstline
parameter_list|)
block|{
name|CORE_ADDR
name|pc
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|pc
operator|=
name|BLOCK_START
argument_list|(
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|fixup_symbol_section
argument_list|(
name|sym
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|funfirstline
condition|)
block|{
comment|/* skip "first line" of function (which is actually its prologue) */
name|asection
modifier|*
name|section
init|=
name|SYMBOL_BFD_SECTION
argument_list|(
name|sym
argument_list|)
decl_stmt|;
comment|/* If function is in an unmapped overlay, use its unmapped LMA          address, so that SKIP_PROLOGUE has something unique to work on */
if|if
condition|(
name|section_is_overlay
argument_list|(
name|section
argument_list|)
operator|&&
operator|!
name|section_is_mapped
argument_list|(
name|section
argument_list|)
condition|)
name|pc
operator|=
name|overlay_unmapped_address
argument_list|(
name|pc
argument_list|,
name|section
argument_list|)
expr_stmt|;
name|pc
operator|+=
name|FUNCTION_START_OFFSET
expr_stmt|;
name|pc
operator|=
name|SKIP_PROLOGUE
argument_list|(
name|pc
argument_list|)
expr_stmt|;
comment|/* For overlays, map pc back into its mapped VMA range */
name|pc
operator|=
name|overlay_mapped_address
argument_list|(
name|pc
argument_list|,
name|section
argument_list|)
expr_stmt|;
block|}
name|sal
operator|=
name|find_pc_sect_line
argument_list|(
name|pc
argument_list|,
name|SYMBOL_BFD_SECTION
argument_list|(
name|sym
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Check if SKIP_PROLOGUE left us in mid-line, and the next      line is still part of the same function.  */
if|if
condition|(
name|sal
operator|.
name|pc
operator|!=
name|pc
operator|&&
name|BLOCK_START
argument_list|(
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|<=
name|sal
operator|.
name|end
operator|&&
name|sal
operator|.
name|end
operator|<
name|BLOCK_END
argument_list|(
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|sym
argument_list|)
argument_list|)
condition|)
block|{
comment|/* First pc of next line */
name|pc
operator|=
name|sal
operator|.
name|end
expr_stmt|;
comment|/* Recalculate the line number (might not be N+1).  */
name|sal
operator|=
name|find_pc_sect_line
argument_list|(
name|pc
argument_list|,
name|SYMBOL_BFD_SECTION
argument_list|(
name|sym
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|sal
operator|.
name|pc
operator|=
name|pc
expr_stmt|;
return|return
name|sal
return|;
block|}
end_function

begin_comment
comment|/* If P is of the form "operator[ \t]+..." where `...' is    some legitimate operator text, return a pointer to the    beginning of the substring of the operator text.    Otherwise, return "".  */
end_comment

begin_function
name|char
modifier|*
name|operator_chars
parameter_list|(
name|char
modifier|*
name|p
parameter_list|,
name|char
modifier|*
modifier|*
name|end
parameter_list|)
block|{
operator|*
name|end
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"operator"
argument_list|,
literal|8
argument_list|)
condition|)
return|return
operator|*
name|end
return|;
name|p
operator|+=
literal|8
expr_stmt|;
comment|/* Don't get faked out by `operator' being part of a longer      identifier.  */
if|if
condition|(
name|isalpha
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|'_'
operator|||
operator|*
name|p
operator|==
literal|'$'
operator|||
operator|*
name|p
operator|==
literal|'\0'
condition|)
return|return
operator|*
name|end
return|;
comment|/* Allow some whitespace between `operator' and the operator symbol.  */
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
comment|/* Recognize 'operator TYPENAME'. */
if|if
condition|(
name|isalpha
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|'_'
operator|||
operator|*
name|p
operator|==
literal|'$'
condition|)
block|{
name|char
modifier|*
name|q
init|=
name|p
operator|+
literal|1
decl_stmt|;
while|while
condition|(
name|isalnum
argument_list|(
operator|*
name|q
argument_list|)
operator|||
operator|*
name|q
operator|==
literal|'_'
operator|||
operator|*
name|q
operator|==
literal|'$'
condition|)
name|q
operator|++
expr_stmt|;
operator|*
name|end
operator|=
name|q
expr_stmt|;
return|return
name|p
return|;
block|}
while|while
condition|(
operator|*
name|p
condition|)
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'\\'
case|:
comment|/* regexp quoting */
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'*'
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|2
index|]
operator|==
literal|'='
condition|)
comment|/* 'operator\*=' */
operator|*
name|end
operator|=
name|p
operator|+
literal|3
expr_stmt|;
else|else
comment|/* 'operator\*'  */
operator|*
name|end
operator|=
name|p
operator|+
literal|2
expr_stmt|;
return|return
name|p
return|;
block|}
elseif|else
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'['
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|2
index|]
operator|==
literal|']'
condition|)
name|error
argument_list|(
literal|"mismatched quoting on brackets, try 'operator\\[\\]'"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p
index|[
literal|2
index|]
operator|==
literal|'\\'
operator|&&
name|p
index|[
literal|3
index|]
operator|==
literal|']'
condition|)
block|{
operator|*
name|end
operator|=
name|p
operator|+
literal|4
expr_stmt|;
comment|/* 'operator\[\]' */
return|return
name|p
return|;
block|}
else|else
name|error
argument_list|(
literal|"nothing is allowed between '[' and ']'"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Gratuitous qoute: skip it and move on. */
name|p
operator|++
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
literal|'!'
case|:
case|case
literal|'='
case|:
case|case
literal|'*'
case|:
case|case
literal|'/'
case|:
case|case
literal|'%'
case|:
case|case
literal|'^'
case|:
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'='
condition|)
operator|*
name|end
operator|=
name|p
operator|+
literal|2
expr_stmt|;
else|else
operator|*
name|end
operator|=
name|p
operator|+
literal|1
expr_stmt|;
return|return
name|p
return|;
case|case
literal|'<'
case|:
case|case
literal|'>'
case|:
case|case
literal|'+'
case|:
case|case
literal|'-'
case|:
case|case
literal|'&'
case|:
case|case
literal|'|'
case|:
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'>'
condition|)
block|{
comment|/* Struct pointer member operator 'operator->'. */
if|if
condition|(
name|p
index|[
literal|2
index|]
operator|==
literal|'*'
condition|)
block|{
operator|*
name|end
operator|=
name|p
operator|+
literal|3
expr_stmt|;
comment|/* 'operator->*' */
return|return
name|p
return|;
block|}
elseif|else
if|if
condition|(
name|p
index|[
literal|2
index|]
operator|==
literal|'\\'
condition|)
block|{
operator|*
name|end
operator|=
name|p
operator|+
literal|4
expr_stmt|;
comment|/* Hopefully 'operator->\*' */
return|return
name|p
return|;
block|}
else|else
block|{
operator|*
name|end
operator|=
name|p
operator|+
literal|2
expr_stmt|;
comment|/* 'operator->' */
return|return
name|p
return|;
block|}
block|}
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'='
operator|||
name|p
index|[
literal|1
index|]
operator|==
name|p
index|[
literal|0
index|]
condition|)
operator|*
name|end
operator|=
name|p
operator|+
literal|2
expr_stmt|;
else|else
operator|*
name|end
operator|=
name|p
operator|+
literal|1
expr_stmt|;
return|return
name|p
return|;
case|case
literal|'~'
case|:
case|case
literal|','
case|:
operator|*
name|end
operator|=
name|p
operator|+
literal|1
expr_stmt|;
return|return
name|p
return|;
case|case
literal|'('
case|:
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|!=
literal|')'
condition|)
name|error
argument_list|(
literal|"`operator ()' must be specified without whitespace in `()'"
argument_list|)
expr_stmt|;
operator|*
name|end
operator|=
name|p
operator|+
literal|2
expr_stmt|;
return|return
name|p
return|;
case|case
literal|'?'
case|:
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|!=
literal|':'
condition|)
name|error
argument_list|(
literal|"`operator ?:' must be specified without whitespace in `?:'"
argument_list|)
expr_stmt|;
operator|*
name|end
operator|=
name|p
operator|+
literal|2
expr_stmt|;
return|return
name|p
return|;
case|case
literal|'['
case|:
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|!=
literal|']'
condition|)
name|error
argument_list|(
literal|"`operator []' must be specified without whitespace in `[]'"
argument_list|)
expr_stmt|;
operator|*
name|end
operator|=
name|p
operator|+
literal|2
expr_stmt|;
return|return
name|p
return|;
default|default:
name|error
argument_list|(
literal|"`operator %s' not supported"
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
operator|*
name|end
operator|=
literal|""
expr_stmt|;
return|return
operator|*
name|end
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If FILE is not already in the table of files, return zero;    otherwise return non-zero.  Optionally add FILE to the table if ADD    is non-zero.  If *FIRST is non-zero, forget the old table    contents.  */
end_comment

begin_function
specifier|static
name|int
name|filename_seen
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|add
parameter_list|,
name|int
modifier|*
name|first
parameter_list|)
block|{
comment|/* Table of files seen so far.  */
specifier|static
specifier|const
name|char
modifier|*
modifier|*
name|tab
init|=
name|NULL
decl_stmt|;
comment|/* Allocated size of tab in elements.      Start with one 256-byte block (when using GNU malloc.c).      24 is the malloc overhead when range checking is in effect.  */
specifier|static
name|int
name|tab_alloc_size
init|=
operator|(
literal|256
operator|-
literal|24
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
decl_stmt|;
comment|/* Current size of tab in elements.  */
specifier|static
name|int
name|tab_cur_size
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|*
name|first
condition|)
block|{
if|if
condition|(
name|tab
operator|==
name|NULL
condition|)
name|tab
operator|=
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|tab_alloc_size
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|tab
argument_list|)
argument_list|)
expr_stmt|;
name|tab_cur_size
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Is FILE in tab?  */
for|for
control|(
name|p
operator|=
name|tab
init|;
name|p
operator|<
name|tab
operator|+
name|tab_cur_size
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|p
argument_list|,
name|file
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
comment|/* No; maybe add it to tab.  */
if|if
condition|(
name|add
condition|)
block|{
if|if
condition|(
name|tab_cur_size
operator|==
name|tab_alloc_size
condition|)
block|{
name|tab_alloc_size
operator|*=
literal|2
expr_stmt|;
name|tab
operator|=
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tab
argument_list|,
name|tab_alloc_size
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|tab
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|tab
index|[
name|tab_cur_size
operator|++
index|]
operator|=
name|file
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Slave routine for sources_info.  Force line breaks at ,'s.    NAME is the name to print and *FIRST is nonzero if this is the first    name printed.  Set *FIRST to zero.  */
end_comment

begin_function
specifier|static
name|void
name|output_source_filename
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
modifier|*
name|first
parameter_list|)
block|{
comment|/* Since a single source file can result in several partial symbol      tables, we need to avoid printing it more than once.  Note: if      some of the psymtabs are read in and some are not, it gets      printed both under "Source files for which symbols have been      read" and "Source files for which symbols will be read in on      demand".  I consider this a reasonable way to deal with the      situation.  I'm not sure whether this can also happen for      symtabs; it doesn't hurt to check.  */
comment|/* Was NAME already seen?  */
if|if
condition|(
name|filename_seen
argument_list|(
name|name
argument_list|,
literal|1
argument_list|,
name|first
argument_list|)
condition|)
block|{
comment|/* Yes; don't print it again.  */
return|return;
block|}
comment|/* No; print it and reset *FIRST.  */
if|if
condition|(
operator|*
name|first
condition|)
block|{
operator|*
name|first
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|printf_filtered
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
name|name
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sources_info
parameter_list|(
name|char
modifier|*
name|ignore
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
name|struct
name|partial_symtab
modifier|*
name|ps
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|int
name|first
decl_stmt|;
if|if
condition|(
operator|!
name|have_full_symbols
argument_list|()
operator|&&
operator|!
name|have_partial_symbols
argument_list|()
condition|)
block|{
name|error
argument_list|(
literal|"No symbol table is loaded.  Use the \"file\" command."
argument_list|)
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|"Source files for which symbols have been read in:\n\n"
argument_list|)
expr_stmt|;
name|first
operator|=
literal|1
expr_stmt|;
name|ALL_SYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
block|{
name|output_source_filename
argument_list|(
name|s
operator|->
name|filename
argument_list|,
operator|&
name|first
argument_list|)
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Source files for which symbols will be read in on demand:\n\n"
argument_list|)
expr_stmt|;
name|first
operator|=
literal|1
expr_stmt|;
name|ALL_PSYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|ps
argument_list|)
block|{
if|if
condition|(
operator|!
name|ps
operator|->
name|readin
condition|)
block|{
name|output_source_filename
argument_list|(
name|ps
operator|->
name|filename
argument_list|,
operator|&
name|first
argument_list|)
expr_stmt|;
block|}
block|}
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|file_matches
parameter_list|(
name|char
modifier|*
name|file
parameter_list|,
name|char
modifier|*
name|files
index|[]
parameter_list|,
name|int
name|nfiles
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|file
operator|!=
name|NULL
operator|&&
name|nfiles
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfiles
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|files
index|[
name|i
index|]
argument_list|,
name|lbasename
argument_list|(
name|file
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|nfiles
operator|==
literal|0
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Free any memory associated with a search. */
end_comment

begin_function
name|void
name|free_search_symbols
parameter_list|(
name|struct
name|symbol_search
modifier|*
name|symbols
parameter_list|)
block|{
name|struct
name|symbol_search
modifier|*
name|p
decl_stmt|;
name|struct
name|symbol_search
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|p
operator|=
name|symbols
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|next
control|)
block|{
name|next
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|xfree
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|do_free_search_symbols_cleanup
parameter_list|(
name|void
modifier|*
name|symbols
parameter_list|)
block|{
name|free_search_symbols
argument_list|(
name|symbols
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|cleanup
modifier|*
name|make_cleanup_free_search_symbols
parameter_list|(
name|struct
name|symbol_search
modifier|*
name|symbols
parameter_list|)
block|{
return|return
name|make_cleanup
argument_list|(
name|do_free_search_symbols_cleanup
argument_list|,
name|symbols
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Helper function for sort_search_symbols and qsort.  Can only    sort symbols, not minimal symbols.  */
end_comment

begin_function
specifier|static
name|int
name|compare_search_syms
parameter_list|(
specifier|const
name|void
modifier|*
name|sa
parameter_list|,
specifier|const
name|void
modifier|*
name|sb
parameter_list|)
block|{
name|struct
name|symbol_search
modifier|*
modifier|*
name|sym_a
init|=
operator|(
expr|struct
name|symbol_search
operator|*
operator|*
operator|)
name|sa
decl_stmt|;
name|struct
name|symbol_search
modifier|*
modifier|*
name|sym_b
init|=
operator|(
expr|struct
name|symbol_search
operator|*
operator|*
operator|)
name|sb
decl_stmt|;
return|return
name|strcmp
argument_list|(
name|SYMBOL_PRINT_NAME
argument_list|(
operator|(
operator|*
name|sym_a
operator|)
operator|->
name|symbol
argument_list|)
argument_list|,
name|SYMBOL_PRINT_NAME
argument_list|(
operator|(
operator|*
name|sym_b
operator|)
operator|->
name|symbol
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Sort the ``nfound'' symbols in the list after prevtail.  Leave    prevtail where it is, but update its next pointer to point to    the first of the sorted symbols.  */
end_comment

begin_function
specifier|static
name|struct
name|symbol_search
modifier|*
name|sort_search_symbols
parameter_list|(
name|struct
name|symbol_search
modifier|*
name|prevtail
parameter_list|,
name|int
name|nfound
parameter_list|)
block|{
name|struct
name|symbol_search
modifier|*
modifier|*
name|symbols
decl_stmt|,
modifier|*
name|symp
decl_stmt|,
modifier|*
name|old_next
decl_stmt|;
name|int
name|i
decl_stmt|;
name|symbols
operator|=
operator|(
expr|struct
name|symbol_search
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|symbol_search
operator|*
argument_list|)
operator|*
name|nfound
argument_list|)
expr_stmt|;
name|symp
operator|=
name|prevtail
operator|->
name|next
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfound
condition|;
name|i
operator|++
control|)
block|{
name|symbols
index|[
name|i
index|]
operator|=
name|symp
expr_stmt|;
name|symp
operator|=
name|symp
operator|->
name|next
expr_stmt|;
block|}
comment|/* Generally NULL.  */
name|old_next
operator|=
name|symp
expr_stmt|;
name|qsort
argument_list|(
name|symbols
argument_list|,
name|nfound
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol_search
operator|*
argument_list|)
argument_list|,
name|compare_search_syms
argument_list|)
expr_stmt|;
name|symp
operator|=
name|prevtail
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfound
condition|;
name|i
operator|++
control|)
block|{
name|symp
operator|->
name|next
operator|=
name|symbols
index|[
name|i
index|]
expr_stmt|;
name|symp
operator|=
name|symp
operator|->
name|next
expr_stmt|;
block|}
name|symp
operator|->
name|next
operator|=
name|old_next
expr_stmt|;
name|xfree
argument_list|(
name|symbols
argument_list|)
expr_stmt|;
return|return
name|symp
return|;
block|}
end_function

begin_comment
comment|/* Search the symbol table for matches to the regular expression REGEXP,    returning the results in *MATCHES.     Only symbols of KIND are searched:    FUNCTIONS_DOMAIN - search all functions    TYPES_DOMAIN     - search all type names    METHODS_DOMAIN   - search all methods NOT IMPLEMENTED    VARIABLES_DOMAIN - search all symbols, excluding functions, type names,    and constants (enums)     free_search_symbols should be called when *MATCHES is no longer needed.     The results are sorted locally; each symtab's global and static blocks are    separately alphabetized.  */
end_comment

begin_function
name|void
name|search_symbols
parameter_list|(
name|char
modifier|*
name|regexp
parameter_list|,
name|domain_enum
name|kind
parameter_list|,
name|int
name|nfiles
parameter_list|,
name|char
modifier|*
name|files
index|[]
parameter_list|,
name|struct
name|symbol_search
modifier|*
modifier|*
name|matches
parameter_list|)
block|{
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
name|struct
name|partial_symtab
modifier|*
name|ps
decl_stmt|;
name|struct
name|blockvector
modifier|*
name|bv
decl_stmt|;
name|struct
name|blockvector
modifier|*
name|prev_bv
init|=
literal|0
decl_stmt|;
name|struct
name|block
modifier|*
name|b
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|struct
name|dict_iterator
name|iter
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|struct
name|partial_symbol
modifier|*
modifier|*
name|psym
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
name|int
name|found_misc
init|=
literal|0
decl_stmt|;
specifier|static
name|enum
name|minimal_symbol_type
name|types
index|[]
init|=
block|{
name|mst_data
block|,
name|mst_text
block|,
name|mst_abs
block|,
name|mst_unknown
block|}
decl_stmt|;
specifier|static
name|enum
name|minimal_symbol_type
name|types2
index|[]
init|=
block|{
name|mst_bss
block|,
name|mst_file_text
block|,
name|mst_abs
block|,
name|mst_unknown
block|}
decl_stmt|;
specifier|static
name|enum
name|minimal_symbol_type
name|types3
index|[]
init|=
block|{
name|mst_file_data
block|,
name|mst_solib_trampoline
block|,
name|mst_abs
block|,
name|mst_unknown
block|}
decl_stmt|;
specifier|static
name|enum
name|minimal_symbol_type
name|types4
index|[]
init|=
block|{
name|mst_file_bss
block|,
name|mst_text
block|,
name|mst_abs
block|,
name|mst_unknown
block|}
decl_stmt|;
name|enum
name|minimal_symbol_type
name|ourtype
decl_stmt|;
name|enum
name|minimal_symbol_type
name|ourtype2
decl_stmt|;
name|enum
name|minimal_symbol_type
name|ourtype3
decl_stmt|;
name|enum
name|minimal_symbol_type
name|ourtype4
decl_stmt|;
name|struct
name|symbol_search
modifier|*
name|sr
decl_stmt|;
name|struct
name|symbol_search
modifier|*
name|psr
decl_stmt|;
name|struct
name|symbol_search
modifier|*
name|tail
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|kind
operator|<
name|VARIABLES_DOMAIN
condition|)
name|error
argument_list|(
literal|"must search on specific domain"
argument_list|)
expr_stmt|;
name|ourtype
operator|=
name|types
index|[
call|(
name|int
call|)
argument_list|(
name|kind
operator|-
name|VARIABLES_DOMAIN
argument_list|)
index|]
expr_stmt|;
name|ourtype2
operator|=
name|types2
index|[
call|(
name|int
call|)
argument_list|(
name|kind
operator|-
name|VARIABLES_DOMAIN
argument_list|)
index|]
expr_stmt|;
name|ourtype3
operator|=
name|types3
index|[
call|(
name|int
call|)
argument_list|(
name|kind
operator|-
name|VARIABLES_DOMAIN
argument_list|)
index|]
expr_stmt|;
name|ourtype4
operator|=
name|types4
index|[
call|(
name|int
call|)
argument_list|(
name|kind
operator|-
name|VARIABLES_DOMAIN
argument_list|)
index|]
expr_stmt|;
name|sr
operator|=
operator|*
name|matches
operator|=
name|NULL
expr_stmt|;
name|tail
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|regexp
operator|!=
name|NULL
condition|)
block|{
comment|/* Make sure spacing is right for C++ operators.          This is just a courtesy to make the matching less sensitive          to how many spaces the user leaves between 'operator'          and<TYPENAME> or<OPERATOR>. */
name|char
modifier|*
name|opend
decl_stmt|;
name|char
modifier|*
name|opname
init|=
name|operator_chars
argument_list|(
name|regexp
argument_list|,
operator|&
name|opend
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|opname
condition|)
block|{
name|int
name|fix
init|=
operator|-
literal|1
decl_stmt|;
comment|/* -1 means ok; otherwise number of spaces needed. */
if|if
condition|(
name|isalpha
argument_list|(
operator|*
name|opname
argument_list|)
operator|||
operator|*
name|opname
operator|==
literal|'_'
operator|||
operator|*
name|opname
operator|==
literal|'$'
condition|)
block|{
comment|/* There should 1 space between 'operator' and 'TYPENAME'. */
if|if
condition|(
name|opname
index|[
operator|-
literal|1
index|]
operator|!=
literal|' '
operator|||
name|opname
index|[
operator|-
literal|2
index|]
operator|==
literal|' '
condition|)
name|fix
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* There should 0 spaces between 'operator' and 'OPERATOR'. */
if|if
condition|(
name|opname
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
name|fix
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If wrong number of spaces, fix it. */
if|if
condition|(
name|fix
operator|>=
literal|0
condition|)
block|{
name|char
modifier|*
name|tmp
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|8
operator|+
name|fix
operator|+
name|strlen
argument_list|(
name|opname
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"operator%.*s%s"
argument_list|,
name|fix
argument_list|,
literal|" "
argument_list|,
name|opname
argument_list|)
expr_stmt|;
name|regexp
operator|=
name|tmp
expr_stmt|;
block|}
block|}
if|if
condition|(
literal|0
operator|!=
operator|(
name|val
operator|=
name|re_comp
argument_list|(
name|regexp
argument_list|)
operator|)
condition|)
name|error
argument_list|(
literal|"Invalid regexp (%s): %s"
argument_list|,
name|val
argument_list|,
name|regexp
argument_list|)
expr_stmt|;
block|}
comment|/* Search through the partial symtabs *first* for all symbols      matching the regexp.  That way we don't have to reproduce all of      the machinery below. */
name|ALL_PSYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|ps
argument_list|)
block|{
name|struct
name|partial_symbol
modifier|*
modifier|*
name|bound
decl_stmt|,
modifier|*
modifier|*
name|gbound
decl_stmt|,
modifier|*
modifier|*
name|sbound
decl_stmt|;
name|int
name|keep_going
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|ps
operator|->
name|readin
condition|)
continue|continue;
name|gbound
operator|=
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
operator|+
name|ps
operator|->
name|globals_offset
operator|+
name|ps
operator|->
name|n_global_syms
expr_stmt|;
name|sbound
operator|=
name|objfile
operator|->
name|static_psymbols
operator|.
name|list
operator|+
name|ps
operator|->
name|statics_offset
operator|+
name|ps
operator|->
name|n_static_syms
expr_stmt|;
name|bound
operator|=
name|gbound
expr_stmt|;
comment|/* Go through all of the symbols stored in a partial        symtab in one loop. */
name|psym
operator|=
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
operator|+
name|ps
operator|->
name|globals_offset
expr_stmt|;
while|while
condition|(
name|keep_going
condition|)
block|{
if|if
condition|(
name|psym
operator|>=
name|bound
condition|)
block|{
if|if
condition|(
name|bound
operator|==
name|gbound
operator|&&
name|ps
operator|->
name|n_static_syms
operator|!=
literal|0
condition|)
block|{
name|psym
operator|=
name|objfile
operator|->
name|static_psymbols
operator|.
name|list
operator|+
name|ps
operator|->
name|statics_offset
expr_stmt|;
name|bound
operator|=
name|sbound
expr_stmt|;
block|}
else|else
name|keep_going
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|QUIT
expr_stmt|;
comment|/* If it would match (logic taken from loop below) 	       load the file and go on to the next one */
if|if
condition|(
name|file_matches
argument_list|(
name|ps
operator|->
name|filename
argument_list|,
name|files
argument_list|,
name|nfiles
argument_list|)
operator|&&
operator|(
operator|(
name|regexp
operator|==
name|NULL
operator|||
name|re_exec
argument_list|(
name|SYMBOL_NATURAL_NAME
argument_list|(
operator|*
name|psym
argument_list|)
argument_list|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|kind
operator|==
name|VARIABLES_DOMAIN
operator|&&
name|SYMBOL_CLASS
argument_list|(
operator|*
name|psym
argument_list|)
operator|!=
name|LOC_TYPEDEF
operator|&&
name|SYMBOL_CLASS
argument_list|(
operator|*
name|psym
argument_list|)
operator|!=
name|LOC_BLOCK
operator|)
operator|||
operator|(
name|kind
operator|==
name|FUNCTIONS_DOMAIN
operator|&&
name|SYMBOL_CLASS
argument_list|(
operator|*
name|psym
argument_list|)
operator|==
name|LOC_BLOCK
operator|)
operator|||
operator|(
name|kind
operator|==
name|TYPES_DOMAIN
operator|&&
name|SYMBOL_CLASS
argument_list|(
operator|*
name|psym
argument_list|)
operator|==
name|LOC_TYPEDEF
operator|)
operator|||
operator|(
name|kind
operator|==
name|METHODS_DOMAIN
operator|&&
name|SYMBOL_CLASS
argument_list|(
operator|*
name|psym
argument_list|)
operator|==
name|LOC_BLOCK
operator|)
operator|)
operator|)
condition|)
block|{
name|PSYMTAB_TO_SYMTAB
argument_list|(
name|ps
argument_list|)
expr_stmt|;
name|keep_going
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|psym
operator|++
expr_stmt|;
block|}
block|}
comment|/* Here, we search through the minimal symbol tables for functions      and variables that match, and force their symbols to be read.      This is in particular necessary for demangled variable names,      which are no longer put into the partial symbol tables.      The symbol will then be found during the scan of symtabs below.       For functions, find_pc_symtab should succeed if we have debug info      for the function, for variables we have to call lookup_symbol      to determine if the variable has debug info.      If the lookup fails, set found_misc so that we will rescan to print      any matching symbols without debug info.    */
if|if
condition|(
name|nfiles
operator|==
literal|0
operator|&&
operator|(
name|kind
operator|==
name|VARIABLES_DOMAIN
operator|||
name|kind
operator|==
name|FUNCTIONS_DOMAIN
operator|)
condition|)
block|{
name|ALL_MSYMBOLS
argument_list|(
argument|objfile
argument_list|,
argument|msymbol
argument_list|)
block|{
if|if
condition|(
name|MSYMBOL_TYPE
argument_list|(
name|msymbol
argument_list|)
operator|==
name|ourtype
operator|||
name|MSYMBOL_TYPE
argument_list|(
name|msymbol
argument_list|)
operator|==
name|ourtype2
operator|||
name|MSYMBOL_TYPE
argument_list|(
name|msymbol
argument_list|)
operator|==
name|ourtype3
operator|||
name|MSYMBOL_TYPE
argument_list|(
name|msymbol
argument_list|)
operator|==
name|ourtype4
condition|)
block|{
if|if
condition|(
name|regexp
operator|==
name|NULL
operator|||
name|re_exec
argument_list|(
name|SYMBOL_NATURAL_NAME
argument_list|(
name|msymbol
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
literal|0
operator|==
name|find_pc_symtab
argument_list|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
argument_list|)
condition|)
block|{
comment|/* FIXME: carlton/2003-02-04: Given that the 		       semantics of lookup_symbol keeps on changing 		       slightly, it would be a nice idea if we had a 		       function lookup_symbol_minsym that found the 		       symbol associated to a given minimal symbol (if 		       any).  */
if|if
condition|(
name|kind
operator|==
name|FUNCTIONS_DOMAIN
operator|||
name|lookup_symbol
argument_list|(
name|SYMBOL_LINKAGE_NAME
argument_list|(
name|msymbol
argument_list|)
argument_list|,
operator|(
expr|struct
name|block
operator|*
operator|)
name|NULL
argument_list|,
name|VAR_DOMAIN
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|symtab
operator|*
operator|*
operator|)
name|NULL
argument_list|)
operator|==
name|NULL
condition|)
name|found_misc
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
name|ALL_SYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
block|{
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Often many files share a blockvector.        Scan each blockvector only once so that        we don't get every symbol many times.        It happens that the first symtab in the list        for any given blockvector is the main file.  */
if|if
condition|(
name|bv
operator|!=
name|prev_bv
condition|)
for|for
control|(
name|i
operator|=
name|GLOBAL_BLOCK
init|;
name|i
operator|<=
name|STATIC_BLOCK
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|symbol_search
modifier|*
name|prevtail
init|=
name|tail
decl_stmt|;
name|int
name|nfound
init|=
literal|0
decl_stmt|;
name|b
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ALL_BLOCK_SYMBOLS
argument_list|(
argument|b
argument_list|,
argument|iter
argument_list|,
argument|sym
argument_list|)
block|{
name|QUIT
expr_stmt|;
if|if
condition|(
name|file_matches
argument_list|(
name|s
operator|->
name|filename
argument_list|,
name|files
argument_list|,
name|nfiles
argument_list|)
operator|&&
operator|(
operator|(
name|regexp
operator|==
name|NULL
operator|||
name|re_exec
argument_list|(
name|SYMBOL_NATURAL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|kind
operator|==
name|VARIABLES_DOMAIN
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|!=
name|LOC_TYPEDEF
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|!=
name|LOC_BLOCK
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|!=
name|LOC_CONST
operator|)
operator|||
operator|(
name|kind
operator|==
name|FUNCTIONS_DOMAIN
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_BLOCK
operator|)
operator|||
operator|(
name|kind
operator|==
name|TYPES_DOMAIN
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_TYPEDEF
operator|)
operator|||
operator|(
name|kind
operator|==
name|METHODS_DOMAIN
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_BLOCK
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* match */
name|psr
operator|=
operator|(
expr|struct
name|symbol_search
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|symbol_search
argument_list|)
argument_list|)
expr_stmt|;
name|psr
operator|->
name|block
operator|=
name|i
expr_stmt|;
name|psr
operator|->
name|symtab
operator|=
name|s
expr_stmt|;
name|psr
operator|->
name|symbol
operator|=
name|sym
expr_stmt|;
name|psr
operator|->
name|msymbol
operator|=
name|NULL
expr_stmt|;
name|psr
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|tail
operator|==
name|NULL
condition|)
name|sr
operator|=
name|psr
expr_stmt|;
else|else
name|tail
operator|->
name|next
operator|=
name|psr
expr_stmt|;
name|tail
operator|=
name|psr
expr_stmt|;
name|nfound
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nfound
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|prevtail
operator|==
name|NULL
condition|)
block|{
name|struct
name|symbol_search
name|dummy
decl_stmt|;
name|dummy
operator|.
name|next
operator|=
name|sr
expr_stmt|;
name|tail
operator|=
name|sort_search_symbols
argument_list|(
operator|&
name|dummy
argument_list|,
name|nfound
argument_list|)
expr_stmt|;
name|sr
operator|=
name|dummy
operator|.
name|next
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup_free_search_symbols
argument_list|(
name|sr
argument_list|)
expr_stmt|;
block|}
else|else
name|tail
operator|=
name|sort_search_symbols
argument_list|(
name|prevtail
argument_list|,
name|nfound
argument_list|)
expr_stmt|;
block|}
block|}
name|prev_bv
operator|=
name|bv
expr_stmt|;
block|}
comment|/* If there are no eyes, avoid all contact.  I mean, if there are      no debug symbols, then print directly from the msymbol_vector.  */
if|if
condition|(
name|found_misc
operator|||
name|kind
operator|!=
name|FUNCTIONS_DOMAIN
condition|)
block|{
name|ALL_MSYMBOLS
argument_list|(
argument|objfile
argument_list|,
argument|msymbol
argument_list|)
block|{
if|if
condition|(
name|MSYMBOL_TYPE
argument_list|(
name|msymbol
argument_list|)
operator|==
name|ourtype
operator|||
name|MSYMBOL_TYPE
argument_list|(
name|msymbol
argument_list|)
operator|==
name|ourtype2
operator|||
name|MSYMBOL_TYPE
argument_list|(
name|msymbol
argument_list|)
operator|==
name|ourtype3
operator|||
name|MSYMBOL_TYPE
argument_list|(
name|msymbol
argument_list|)
operator|==
name|ourtype4
condition|)
block|{
if|if
condition|(
name|regexp
operator|==
name|NULL
operator|||
name|re_exec
argument_list|(
name|SYMBOL_NATURAL_NAME
argument_list|(
name|msymbol
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Functions:  Look up by address. */
if|if
condition|(
name|kind
operator|!=
name|FUNCTIONS_DOMAIN
operator|||
operator|(
literal|0
operator|==
name|find_pc_symtab
argument_list|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
argument_list|)
operator|)
condition|)
block|{
comment|/* Variables/Absolutes:  Look up by name */
if|if
condition|(
name|lookup_symbol
argument_list|(
name|SYMBOL_LINKAGE_NAME
argument_list|(
name|msymbol
argument_list|)
argument_list|,
operator|(
expr|struct
name|block
operator|*
operator|)
name|NULL
argument_list|,
name|VAR_DOMAIN
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|symtab
operator|*
operator|*
operator|)
name|NULL
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* match */
name|psr
operator|=
operator|(
expr|struct
name|symbol_search
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|symbol_search
argument_list|)
argument_list|)
expr_stmt|;
name|psr
operator|->
name|block
operator|=
name|i
expr_stmt|;
name|psr
operator|->
name|msymbol
operator|=
name|msymbol
expr_stmt|;
name|psr
operator|->
name|symtab
operator|=
name|NULL
expr_stmt|;
name|psr
operator|->
name|symbol
operator|=
name|NULL
expr_stmt|;
name|psr
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|tail
operator|==
name|NULL
condition|)
block|{
name|sr
operator|=
name|psr
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup_free_search_symbols
argument_list|(
name|sr
argument_list|)
expr_stmt|;
block|}
else|else
name|tail
operator|->
name|next
operator|=
name|psr
expr_stmt|;
name|tail
operator|=
name|psr
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
operator|*
name|matches
operator|=
name|sr
expr_stmt|;
if|if
condition|(
name|sr
operator|!=
name|NULL
condition|)
name|discard_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Helper function for symtab_symbol_info, this function uses    the data returned from search_symbols() to print information    regarding the match to gdb_stdout.  */
end_comment

begin_function
specifier|static
name|void
name|print_symbol_info
parameter_list|(
name|domain_enum
name|kind
parameter_list|,
name|struct
name|symtab
modifier|*
name|s
parameter_list|,
name|struct
name|symbol
modifier|*
name|sym
parameter_list|,
name|int
name|block
parameter_list|,
name|char
modifier|*
name|last
parameter_list|)
block|{
if|if
condition|(
name|last
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|last
argument_list|,
name|s
operator|->
name|filename
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|"\nFile "
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
name|s
operator|->
name|filename
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|":\n"
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|kind
operator|!=
name|TYPES_DOMAIN
operator|&&
name|block
operator|==
name|STATIC_BLOCK
condition|)
name|printf_filtered
argument_list|(
literal|"static "
argument_list|)
expr_stmt|;
comment|/* Typedef that is not a C++ class */
if|if
condition|(
name|kind
operator|==
name|TYPES_DOMAIN
operator|&&
name|SYMBOL_DOMAIN
argument_list|(
name|sym
argument_list|)
operator|!=
name|STRUCT_DOMAIN
condition|)
name|typedef_print
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|,
name|sym
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
comment|/* variable, func, or typedef-that-is-c++-class */
elseif|else
if|if
condition|(
name|kind
operator|<
name|TYPES_DOMAIN
operator|||
operator|(
name|kind
operator|==
name|TYPES_DOMAIN
operator|&&
name|SYMBOL_DOMAIN
argument_list|(
name|sym
argument_list|)
operator|==
name|STRUCT_DOMAIN
operator|)
condition|)
block|{
name|type_print
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|,
operator|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_TYPEDEF
condition|?
literal|""
else|:
name|SYMBOL_PRINT_NAME
argument_list|(
name|sym
argument_list|)
operator|)
argument_list|,
name|gdb_stdout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|";\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This help function for symtab_symbol_info() prints information    for non-debugging symbols to gdb_stdout.  */
end_comment

begin_function
specifier|static
name|void
name|print_msymbol_info
parameter_list|(
name|struct
name|minimal_symbol
modifier|*
name|msymbol
parameter_list|)
block|{
name|char
modifier|*
name|tmp
decl_stmt|;
if|if
condition|(
name|TARGET_ADDR_BIT
operator|<=
literal|32
condition|)
name|tmp
operator|=
name|local_hex_string_custom
argument_list|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
operator|&
operator|(
name|CORE_ADDR
operator|)
literal|0xffffffff
argument_list|,
literal|"08l"
argument_list|)
expr_stmt|;
else|else
name|tmp
operator|=
name|local_hex_string_custom
argument_list|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
argument_list|,
literal|"016l"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%s  %s\n"
argument_list|,
name|tmp
argument_list|,
name|SYMBOL_PRINT_NAME
argument_list|(
name|msymbol
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is the guts of the commands "info functions", "info types", and    "info variables". It calls search_symbols to find all matches and then    print_[m]symbol_info to print out some useful information about the    matches.  */
end_comment

begin_function
specifier|static
name|void
name|symtab_symbol_info
parameter_list|(
name|char
modifier|*
name|regexp
parameter_list|,
name|domain_enum
name|kind
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|classnames
index|[]
init|=
block|{
literal|"variable"
block|,
literal|"function"
block|,
literal|"type"
block|,
literal|"method"
block|}
decl_stmt|;
name|struct
name|symbol_search
modifier|*
name|symbols
decl_stmt|;
name|struct
name|symbol_search
modifier|*
name|p
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|char
modifier|*
name|last_filename
init|=
name|NULL
decl_stmt|;
name|int
name|first
init|=
literal|1
decl_stmt|;
comment|/* must make sure that if we're interrupted, symbols gets freed */
name|search_symbols
argument_list|(
name|regexp
argument_list|,
name|kind
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|symbols
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup_free_search_symbols
argument_list|(
name|symbols
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
name|regexp
condition|?
literal|"All %ss matching regular expression \"%s\":\n"
else|:
literal|"All defined %ss:\n"
argument_list|,
name|classnames
index|[
call|(
name|int
call|)
argument_list|(
name|kind
operator|-
name|VARIABLES_DOMAIN
argument_list|)
index|]
argument_list|,
name|regexp
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|symbols
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|QUIT
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|msymbol
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|first
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"\nNon-debugging symbols:\n"
argument_list|)
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
name|print_msymbol_info
argument_list|(
name|p
operator|->
name|msymbol
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|print_symbol_info
argument_list|(
name|kind
argument_list|,
name|p
operator|->
name|symtab
argument_list|,
name|p
operator|->
name|symbol
argument_list|,
name|p
operator|->
name|block
argument_list|,
name|last_filename
argument_list|)
expr_stmt|;
name|last_filename
operator|=
name|p
operator|->
name|symtab
operator|->
name|filename
expr_stmt|;
block|}
block|}
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|variables_info
parameter_list|(
name|char
modifier|*
name|regexp
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|symtab_symbol_info
argument_list|(
name|regexp
argument_list|,
name|VARIABLES_DOMAIN
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|functions_info
parameter_list|(
name|char
modifier|*
name|regexp
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|symtab_symbol_info
argument_list|(
name|regexp
argument_list|,
name|FUNCTIONS_DOMAIN
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|types_info
parameter_list|(
name|char
modifier|*
name|regexp
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|symtab_symbol_info
argument_list|(
name|regexp
argument_list|,
name|TYPES_DOMAIN
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Breakpoint all functions matching regular expression. */
end_comment

begin_function
name|void
name|rbreak_command_wrapper
parameter_list|(
name|char
modifier|*
name|regexp
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|rbreak_command
argument_list|(
name|regexp
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rbreak_command
parameter_list|(
name|char
modifier|*
name|regexp
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|symbol_search
modifier|*
name|ss
decl_stmt|;
name|struct
name|symbol_search
modifier|*
name|p
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|search_symbols
argument_list|(
name|regexp
argument_list|,
name|FUNCTIONS_DOMAIN
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|ss
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup_free_search_symbols
argument_list|(
name|ss
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|ss
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|p
operator|->
name|msymbol
operator|==
name|NULL
condition|)
block|{
name|char
modifier|*
name|string
init|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|p
operator|->
name|symtab
operator|->
name|filename
argument_list|)
operator|+
name|strlen
argument_list|(
name|SYMBOL_LINKAGE_NAME
argument_list|(
name|p
operator|->
name|symbol
argument_list|)
argument_list|)
operator|+
literal|4
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|string
argument_list|,
name|p
operator|->
name|symtab
operator|->
name|filename
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|string
argument_list|,
literal|":'"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|string
argument_list|,
name|SYMBOL_LINKAGE_NAME
argument_list|(
name|p
operator|->
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|string
argument_list|,
literal|"'"
argument_list|)
expr_stmt|;
name|break_command
argument_list|(
name|string
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
name|print_symbol_info
argument_list|(
name|FUNCTIONS_DOMAIN
argument_list|,
name|p
operator|->
name|symtab
argument_list|,
name|p
operator|->
name|symbol
argument_list|,
name|p
operator|->
name|block
argument_list|,
name|p
operator|->
name|symtab
operator|->
name|filename
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|break_command
argument_list|(
name|SYMBOL_LINKAGE_NAME
argument_list|(
name|p
operator|->
name|msymbol
argument_list|)
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"<function, no debug info> %s;\n"
argument_list|,
name|SYMBOL_PRINT_NAME
argument_list|(
name|p
operator|->
name|msymbol
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Helper routine for make_symbol_completion_list.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|return_val_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|return_val_index
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|return_val
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|COMPLETION_LIST_ADD_SYMBOL
parameter_list|(
name|symbol
parameter_list|,
name|sym_text
parameter_list|,
name|len
parameter_list|,
name|text
parameter_list|,
name|word
parameter_list|)
define|\
value|completion_list_add_name \ 	(SYMBOL_NATURAL_NAME (symbol), (sym_text), (len), (text), (word))
end_define

begin_comment
comment|/*  Test to see if the symbol specified by SYMNAME (which is already    demangled for C++ symbols) matches SYM_TEXT in the first SYM_TEXT_LEN    characters.  If so, add it to the current completion list. */
end_comment

begin_function
specifier|static
name|void
name|completion_list_add_name
parameter_list|(
name|char
modifier|*
name|symname
parameter_list|,
name|char
modifier|*
name|sym_text
parameter_list|,
name|int
name|sym_text_len
parameter_list|,
name|char
modifier|*
name|text
parameter_list|,
name|char
modifier|*
name|word
parameter_list|)
block|{
name|int
name|newsize
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* clip symbols that cannot match */
if|if
condition|(
name|strncmp
argument_list|(
name|symname
argument_list|,
name|sym_text
argument_list|,
name|sym_text_len
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return;
block|}
comment|/* We have a match for a completion, so add SYMNAME to the current list      of matches. Note that the name is moved to freshly malloc'd space. */
block|{
name|char
modifier|*
name|new
decl_stmt|;
if|if
condition|(
name|word
operator|==
name|sym_text
condition|)
block|{
name|new
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|symname
argument_list|)
operator|+
literal|5
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|new
argument_list|,
name|symname
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|word
operator|>
name|sym_text
condition|)
block|{
comment|/* Return some portion of symname.  */
name|new
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|symname
argument_list|)
operator|+
literal|5
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|new
argument_list|,
name|symname
operator|+
operator|(
name|word
operator|-
name|sym_text
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Return some of SYM_TEXT plus symname.  */
name|new
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|symname
argument_list|)
operator|+
operator|(
name|sym_text
operator|-
name|word
operator|)
operator|+
literal|5
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|new
argument_list|,
name|word
argument_list|,
name|sym_text
operator|-
name|word
argument_list|)
expr_stmt|;
name|new
index|[
name|sym_text
operator|-
name|word
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strcat
argument_list|(
name|new
argument_list|,
name|symname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|return_val_index
operator|+
literal|3
operator|>
name|return_val_size
condition|)
block|{
name|newsize
operator|=
operator|(
name|return_val_size
operator|*=
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
expr_stmt|;
name|return_val
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|return_val
argument_list|,
name|newsize
argument_list|)
expr_stmt|;
block|}
name|return_val
index|[
name|return_val_index
operator|++
index|]
operator|=
name|new
expr_stmt|;
name|return_val
index|[
name|return_val_index
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ObjC: In case we are completing on a selector, look as the msymbol    again and feed all the selectors into the mill.  */
end_comment

begin_function
specifier|static
name|void
name|completion_list_objc_symbol
parameter_list|(
name|struct
name|minimal_symbol
modifier|*
name|msymbol
parameter_list|,
name|char
modifier|*
name|sym_text
parameter_list|,
name|int
name|sym_text_len
parameter_list|,
name|char
modifier|*
name|text
parameter_list|,
name|char
modifier|*
name|word
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|tmp
init|=
name|NULL
decl_stmt|;
specifier|static
name|unsigned
name|int
name|tmplen
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|method
decl_stmt|,
modifier|*
name|category
decl_stmt|,
modifier|*
name|selector
decl_stmt|;
name|char
modifier|*
name|tmp2
init|=
name|NULL
decl_stmt|;
name|method
operator|=
name|SYMBOL_NATURAL_NAME
argument_list|(
name|msymbol
argument_list|)
expr_stmt|;
comment|/* Is it a method?  */
if|if
condition|(
operator|(
name|method
index|[
literal|0
index|]
operator|!=
literal|'-'
operator|)
operator|&&
operator|(
name|method
index|[
literal|0
index|]
operator|!=
literal|'+'
operator|)
condition|)
return|return;
if|if
condition|(
name|sym_text
index|[
literal|0
index|]
operator|==
literal|'['
condition|)
comment|/* Complete on shortened method method.  */
name|completion_list_add_name
argument_list|(
name|method
operator|+
literal|1
argument_list|,
name|sym_text
argument_list|,
name|sym_text_len
argument_list|,
name|text
argument_list|,
name|word
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|strlen
argument_list|(
name|method
argument_list|)
operator|+
literal|1
operator|)
operator|>=
name|tmplen
condition|)
block|{
if|if
condition|(
name|tmplen
operator|==
literal|0
condition|)
name|tmplen
operator|=
literal|1024
expr_stmt|;
else|else
name|tmplen
operator|*=
literal|2
expr_stmt|;
name|tmp
operator|=
name|xrealloc
argument_list|(
name|tmp
argument_list|,
name|tmplen
argument_list|)
expr_stmt|;
block|}
name|selector
operator|=
name|strchr
argument_list|(
name|method
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|selector
operator|!=
name|NULL
condition|)
name|selector
operator|++
expr_stmt|;
name|category
operator|=
name|strchr
argument_list|(
name|method
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|category
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|selector
operator|!=
name|NULL
operator|)
condition|)
block|{
name|memcpy
argument_list|(
name|tmp
argument_list|,
name|method
argument_list|,
operator|(
name|category
operator|-
name|method
operator|)
argument_list|)
expr_stmt|;
name|tmp
index|[
name|category
operator|-
name|method
index|]
operator|=
literal|' '
expr_stmt|;
name|memcpy
argument_list|(
name|tmp
operator|+
operator|(
name|category
operator|-
name|method
operator|)
operator|+
literal|1
argument_list|,
name|selector
argument_list|,
name|strlen
argument_list|(
name|selector
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|completion_list_add_name
argument_list|(
name|tmp
argument_list|,
name|sym_text
argument_list|,
name|sym_text_len
argument_list|,
name|text
argument_list|,
name|word
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym_text
index|[
literal|0
index|]
operator|==
literal|'['
condition|)
name|completion_list_add_name
argument_list|(
name|tmp
operator|+
literal|1
argument_list|,
name|sym_text
argument_list|,
name|sym_text_len
argument_list|,
name|text
argument_list|,
name|word
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|selector
operator|!=
name|NULL
condition|)
block|{
comment|/* Complete on selector only.  */
name|strcpy
argument_list|(
name|tmp
argument_list|,
name|selector
argument_list|)
expr_stmt|;
name|tmp2
operator|=
name|strchr
argument_list|(
name|tmp
argument_list|,
literal|']'
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp2
operator|!=
name|NULL
condition|)
operator|*
name|tmp2
operator|=
literal|'\0'
expr_stmt|;
name|completion_list_add_name
argument_list|(
name|tmp
argument_list|,
name|sym_text
argument_list|,
name|sym_text_len
argument_list|,
name|text
argument_list|,
name|word
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Break the non-quoted text based on the characters which are in    symbols. FIXME: This should probably be language-specific. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|language_search_unquoted_string
parameter_list|(
name|char
modifier|*
name|text
parameter_list|,
name|char
modifier|*
name|p
parameter_list|)
block|{
for|for
control|(
init|;
name|p
operator|>
name|text
condition|;
operator|--
name|p
control|)
block|{
if|if
condition|(
name|isalnum
argument_list|(
name|p
index|[
operator|-
literal|1
index|]
argument_list|)
operator|||
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'_'
operator|||
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'\0'
condition|)
continue|continue;
else|else
block|{
if|if
condition|(
operator|(
name|current_language
operator|->
name|la_language
operator|==
name|language_objc
operator|)
condition|)
block|{
if|if
condition|(
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|':'
condition|)
comment|/* might be part of a method name */
continue|continue;
elseif|else
if|if
condition|(
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'['
operator|&&
operator|(
name|p
index|[
operator|-
literal|2
index|]
operator|==
literal|'-'
operator|||
name|p
index|[
operator|-
literal|2
index|]
operator|==
literal|'+'
operator|)
condition|)
name|p
operator|-=
literal|2
expr_stmt|;
comment|/* beginning of a method name */
elseif|else
if|if
condition|(
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
operator|||
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'('
operator|||
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|')'
condition|)
block|{
comment|/* might be part of a method name */
name|char
modifier|*
name|t
init|=
name|p
decl_stmt|;
comment|/* Seeing a ' ' or a '(' is not conclusive evidence 		     that we are in the middle of a method name.  However, 		     finding "-[" or "+[" should be pretty un-ambiguous. 		     Unfortunately we have to find it now to decide.  */
while|while
condition|(
name|t
operator|>
name|text
condition|)
if|if
condition|(
name|isalnum
argument_list|(
name|t
index|[
operator|-
literal|1
index|]
argument_list|)
operator|||
name|t
index|[
operator|-
literal|1
index|]
operator|==
literal|'_'
operator|||
name|t
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
operator|||
name|t
index|[
operator|-
literal|1
index|]
operator|==
literal|':'
operator|||
name|t
index|[
operator|-
literal|1
index|]
operator|==
literal|'('
operator|||
name|t
index|[
operator|-
literal|1
index|]
operator|==
literal|')'
condition|)
operator|--
name|t
expr_stmt|;
else|else
break|break;
if|if
condition|(
name|t
index|[
operator|-
literal|1
index|]
operator|==
literal|'['
operator|&&
operator|(
name|t
index|[
operator|-
literal|2
index|]
operator|==
literal|'-'
operator|||
name|t
index|[
operator|-
literal|2
index|]
operator|==
literal|'+'
operator|)
condition|)
name|p
operator|=
name|t
operator|-
literal|2
expr_stmt|;
comment|/* method name detected */
comment|/* else we leave with p unchanged */
block|}
block|}
break|break;
block|}
block|}
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Return a NULL terminated array of all symbols (regardless of class)    which begin by matching TEXT.  If the answer is no symbols, then    the return value is an array which contains only a NULL pointer.     Problem: All of the symbols have to be copied because readline frees them.    I'm not going to worry about this; hopefully there won't be that many.  */
end_comment

begin_function
name|char
modifier|*
modifier|*
name|make_symbol_completion_list
parameter_list|(
name|char
modifier|*
name|text
parameter_list|,
name|char
modifier|*
name|word
parameter_list|)
block|{
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
name|struct
name|partial_symtab
modifier|*
name|ps
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|block
modifier|*
name|b
decl_stmt|,
modifier|*
name|surrounding_static_block
init|=
literal|0
decl_stmt|;
name|struct
name|dict_iterator
name|iter
decl_stmt|;
name|int
name|j
decl_stmt|;
name|struct
name|partial_symbol
modifier|*
modifier|*
name|psym
decl_stmt|;
comment|/* The symbol we are completing on.  Points in same buffer as text.  */
name|char
modifier|*
name|sym_text
decl_stmt|;
comment|/* Length of sym_text.  */
name|int
name|sym_text_len
decl_stmt|;
comment|/* Now look for the symbol we are supposed to complete on.      FIXME: This should be language-specific.  */
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|quote_found
decl_stmt|;
name|char
modifier|*
name|quote_pos
init|=
name|NULL
decl_stmt|;
comment|/* First see if this is a quoted string.  */
name|quote_found
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|p
operator|=
name|text
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
operator|++
name|p
control|)
block|{
if|if
condition|(
name|quote_found
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
name|quote_found
condition|)
comment|/* Found close quote.  */
name|quote_found
operator|=
literal|'\0'
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'\\'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
name|quote_found
condition|)
comment|/* A backslash followed by the quote character 	         doesn't end the string.  */
operator|++
name|p
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'\''
operator|||
operator|*
name|p
operator|==
literal|'"'
condition|)
block|{
name|quote_found
operator|=
operator|*
name|p
expr_stmt|;
name|quote_pos
operator|=
name|p
expr_stmt|;
block|}
block|}
if|if
condition|(
name|quote_found
operator|==
literal|'\''
condition|)
comment|/* A string within single quotes can be a symbol, so complete on it.  */
name|sym_text
operator|=
name|quote_pos
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|quote_found
operator|==
literal|'"'
condition|)
comment|/* A double-quoted string is never a symbol, nor does it make sense          to complete it any other way.  */
block|{
name|return_val
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|return_val
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
return|return
name|return_val
return|;
block|}
else|else
block|{
comment|/* It is not a quoted string.  Break it based on the characters 	   which are in symbols.  */
while|while
condition|(
name|p
operator|>
name|text
condition|)
block|{
if|if
condition|(
name|isalnum
argument_list|(
name|p
index|[
operator|-
literal|1
index|]
argument_list|)
operator|||
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'_'
operator|||
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'\0'
condition|)
operator|--
name|p
expr_stmt|;
else|else
break|break;
block|}
name|sym_text
operator|=
name|p
expr_stmt|;
block|}
block|}
name|sym_text_len
operator|=
name|strlen
argument_list|(
name|sym_text
argument_list|)
expr_stmt|;
name|return_val_size
operator|=
literal|100
expr_stmt|;
name|return_val_index
operator|=
literal|0
expr_stmt|;
name|return_val
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|return_val_size
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|return_val
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* Look through the partial symtabs for all symbols which begin      by matching SYM_TEXT.  Add each one that you find to the list.  */
name|ALL_PSYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|ps
argument_list|)
block|{
comment|/* If the psymtab's been read in we'll get it when we search        through the blockvector.  */
if|if
condition|(
name|ps
operator|->
name|readin
condition|)
continue|continue;
for|for
control|(
name|psym
operator|=
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
operator|+
name|ps
operator|->
name|globals_offset
init|;
name|psym
operator|<
operator|(
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
operator|+
name|ps
operator|->
name|globals_offset
operator|+
name|ps
operator|->
name|n_global_syms
operator|)
condition|;
name|psym
operator|++
control|)
block|{
comment|/* If interrupted, then quit. */
name|QUIT
expr_stmt|;
name|COMPLETION_LIST_ADD_SYMBOL
argument_list|(
operator|*
name|psym
argument_list|,
name|sym_text
argument_list|,
name|sym_text_len
argument_list|,
name|text
argument_list|,
name|word
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|psym
operator|=
name|objfile
operator|->
name|static_psymbols
operator|.
name|list
operator|+
name|ps
operator|->
name|statics_offset
init|;
name|psym
operator|<
operator|(
name|objfile
operator|->
name|static_psymbols
operator|.
name|list
operator|+
name|ps
operator|->
name|statics_offset
operator|+
name|ps
operator|->
name|n_static_syms
operator|)
condition|;
name|psym
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
name|COMPLETION_LIST_ADD_SYMBOL
argument_list|(
operator|*
name|psym
argument_list|,
name|sym_text
argument_list|,
name|sym_text_len
argument_list|,
name|text
argument_list|,
name|word
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* At this point scan through the misc symbol vectors and add each      symbol you find to the list.  Eventually we want to ignore      anything that isn't a text symbol (everything else will be      handled by the psymtab code above).  */
name|ALL_MSYMBOLS
argument_list|(
argument|objfile
argument_list|,
argument|msymbol
argument_list|)
block|{
name|QUIT
expr_stmt|;
name|COMPLETION_LIST_ADD_SYMBOL
argument_list|(
name|msymbol
argument_list|,
name|sym_text
argument_list|,
name|sym_text_len
argument_list|,
name|text
argument_list|,
name|word
argument_list|)
expr_stmt|;
name|completion_list_objc_symbol
argument_list|(
name|msymbol
argument_list|,
name|sym_text
argument_list|,
name|sym_text_len
argument_list|,
name|text
argument_list|,
name|word
argument_list|)
expr_stmt|;
block|}
comment|/* Search upwards from currently selected frame (so that we can      complete on local vars.  */
for|for
control|(
name|b
operator|=
name|get_selected_block
argument_list|(
literal|0
argument_list|)
init|;
name|b
operator|!=
name|NULL
condition|;
name|b
operator|=
name|BLOCK_SUPERBLOCK
argument_list|(
name|b
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|BLOCK_SUPERBLOCK
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|surrounding_static_block
operator|=
name|b
expr_stmt|;
comment|/* For elmin of dups */
block|}
comment|/* Also catch fields of types defined in this places which match our          text string.  Only complete on types visible from current context. */
name|ALL_BLOCK_SYMBOLS
argument_list|(
argument|b
argument_list|,
argument|iter
argument_list|,
argument|sym
argument_list|)
block|{
name|QUIT
expr_stmt|;
name|COMPLETION_LIST_ADD_SYMBOL
argument_list|(
name|sym
argument_list|,
name|sym_text
argument_list|,
name|sym_text_len
argument_list|,
name|text
argument_list|,
name|word
argument_list|)
expr_stmt|;
if|if
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_TYPEDEF
condition|)
block|{
name|struct
name|type
modifier|*
name|t
init|=
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
decl_stmt|;
name|enum
name|type_code
name|c
init|=
name|TYPE_CODE
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|TYPE_CODE_UNION
operator|||
name|c
operator|==
name|TYPE_CODE_STRUCT
condition|)
block|{
for|for
control|(
name|j
operator|=
name|TYPE_N_BASECLASSES
argument_list|(
name|t
argument_list|)
init|;
name|j
operator|<
name|TYPE_NFIELDS
argument_list|(
name|t
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|TYPE_FIELD_NAME
argument_list|(
name|t
argument_list|,
name|j
argument_list|)
condition|)
block|{
name|completion_list_add_name
argument_list|(
name|TYPE_FIELD_NAME
argument_list|(
name|t
argument_list|,
name|j
argument_list|)
argument_list|,
name|sym_text
argument_list|,
name|sym_text_len
argument_list|,
name|text
argument_list|,
name|word
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
comment|/* Go through the symtabs and check the externs and statics for      symbols which match.  */
name|ALL_SYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
block|{
name|QUIT
expr_stmt|;
name|b
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
expr_stmt|;
name|ALL_BLOCK_SYMBOLS
argument_list|(
argument|b
argument_list|,
argument|iter
argument_list|,
argument|sym
argument_list|)
block|{
name|COMPLETION_LIST_ADD_SYMBOL
argument_list|(
name|sym
argument_list|,
name|sym_text
argument_list|,
name|sym_text_len
argument_list|,
name|text
argument_list|,
name|word
argument_list|)
expr_stmt|;
block|}
block|}
name|ALL_SYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
block|{
name|QUIT
expr_stmt|;
name|b
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
argument_list|,
name|STATIC_BLOCK
argument_list|)
expr_stmt|;
comment|/* Don't do this block twice.  */
if|if
condition|(
name|b
operator|==
name|surrounding_static_block
condition|)
continue|continue;
name|ALL_BLOCK_SYMBOLS
argument_list|(
argument|b
argument_list|,
argument|iter
argument_list|,
argument|sym
argument_list|)
block|{
name|COMPLETION_LIST_ADD_SYMBOL
argument_list|(
name|sym
argument_list|,
name|sym_text
argument_list|,
name|sym_text_len
argument_list|,
name|text
argument_list|,
name|word
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|return_val
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Like make_symbol_completion_list, but returns a list of symbols    defined in a source file FILE.  */
end_comment

begin_function
name|char
modifier|*
modifier|*
name|make_file_symbol_completion_list
parameter_list|(
name|char
modifier|*
name|text
parameter_list|,
name|char
modifier|*
name|word
parameter_list|,
name|char
modifier|*
name|srcfile
parameter_list|)
block|{
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
name|struct
name|block
modifier|*
name|b
decl_stmt|;
name|struct
name|dict_iterator
name|iter
decl_stmt|;
comment|/* The symbol we are completing on.  Points in same buffer as text.  */
name|char
modifier|*
name|sym_text
decl_stmt|;
comment|/* Length of sym_text.  */
name|int
name|sym_text_len
decl_stmt|;
comment|/* Now look for the symbol we are supposed to complete on.      FIXME: This should be language-specific.  */
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|quote_found
decl_stmt|;
name|char
modifier|*
name|quote_pos
init|=
name|NULL
decl_stmt|;
comment|/* First see if this is a quoted string.  */
name|quote_found
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|p
operator|=
name|text
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
operator|++
name|p
control|)
block|{
if|if
condition|(
name|quote_found
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
name|quote_found
condition|)
comment|/* Found close quote.  */
name|quote_found
operator|=
literal|'\0'
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'\\'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
name|quote_found
condition|)
comment|/* A backslash followed by the quote character 	         doesn't end the string.  */
operator|++
name|p
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'\''
operator|||
operator|*
name|p
operator|==
literal|'"'
condition|)
block|{
name|quote_found
operator|=
operator|*
name|p
expr_stmt|;
name|quote_pos
operator|=
name|p
expr_stmt|;
block|}
block|}
if|if
condition|(
name|quote_found
operator|==
literal|'\''
condition|)
comment|/* A string within single quotes can be a symbol, so complete on it.  */
name|sym_text
operator|=
name|quote_pos
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|quote_found
operator|==
literal|'"'
condition|)
comment|/* A double-quoted string is never a symbol, nor does it make sense          to complete it any other way.  */
block|{
name|return_val
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|return_val
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
return|return
name|return_val
return|;
block|}
else|else
block|{
comment|/* Not a quoted string.  */
name|sym_text
operator|=
name|language_search_unquoted_string
argument_list|(
name|text
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
name|sym_text_len
operator|=
name|strlen
argument_list|(
name|sym_text
argument_list|)
expr_stmt|;
name|return_val_size
operator|=
literal|10
expr_stmt|;
name|return_val_index
operator|=
literal|0
expr_stmt|;
name|return_val
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|return_val_size
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|return_val
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* Find the symtab for SRCFILE (this loads it if it was not yet read      in).  */
name|s
operator|=
name|lookup_symtab
argument_list|(
name|srcfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
block|{
comment|/* Maybe they typed the file with leading directories, while the 	 symbol tables record only its basename.  */
specifier|const
name|char
modifier|*
name|tail
init|=
name|lbasename
argument_list|(
name|srcfile
argument_list|)
decl_stmt|;
if|if
condition|(
name|tail
operator|>
name|srcfile
condition|)
name|s
operator|=
name|lookup_symtab
argument_list|(
name|tail
argument_list|)
expr_stmt|;
block|}
comment|/* If we have no symtab for that file, return an empty list.  */
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return
operator|(
name|return_val
operator|)
return|;
comment|/* Go through this symtab and check the externs and statics for      symbols which match.  */
name|b
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
expr_stmt|;
name|ALL_BLOCK_SYMBOLS
argument_list|(
argument|b
argument_list|,
argument|iter
argument_list|,
argument|sym
argument_list|)
block|{
name|COMPLETION_LIST_ADD_SYMBOL
argument_list|(
name|sym
argument_list|,
name|sym_text
argument_list|,
name|sym_text_len
argument_list|,
name|text
argument_list|,
name|word
argument_list|)
expr_stmt|;
block|}
name|b
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
argument_list|,
name|STATIC_BLOCK
argument_list|)
expr_stmt|;
name|ALL_BLOCK_SYMBOLS
argument_list|(
argument|b
argument_list|,
argument|iter
argument_list|,
argument|sym
argument_list|)
block|{
name|COMPLETION_LIST_ADD_SYMBOL
argument_list|(
name|sym
argument_list|,
name|sym_text
argument_list|,
name|sym_text_len
argument_list|,
name|text
argument_list|,
name|word
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|return_val
operator|)
return|;
block|}
end_function

begin_comment
comment|/* A helper function for make_source_files_completion_list.  It adds    another file name to a list of possible completions, growing the    list as necessary.  */
end_comment

begin_function
specifier|static
name|void
name|add_filename_to_list
parameter_list|(
specifier|const
name|char
modifier|*
name|fname
parameter_list|,
name|char
modifier|*
name|text
parameter_list|,
name|char
modifier|*
name|word
parameter_list|,
name|char
modifier|*
modifier|*
modifier|*
name|list
parameter_list|,
name|int
modifier|*
name|list_used
parameter_list|,
name|int
modifier|*
name|list_alloced
parameter_list|)
block|{
name|char
modifier|*
name|new
decl_stmt|;
name|size_t
name|fnlen
init|=
name|strlen
argument_list|(
name|fname
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|list_used
operator|+
literal|1
operator|>=
operator|*
name|list_alloced
condition|)
block|{
operator|*
name|list_alloced
operator|*=
literal|2
expr_stmt|;
operator|*
name|list
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|*
name|list
argument_list|,
operator|*
name|list_alloced
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|word
operator|==
name|text
condition|)
block|{
comment|/* Return exactly fname.  */
name|new
operator|=
name|xmalloc
argument_list|(
name|fnlen
operator|+
literal|5
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|new
argument_list|,
name|fname
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|word
operator|>
name|text
condition|)
block|{
comment|/* Return some portion of fname.  */
name|new
operator|=
name|xmalloc
argument_list|(
name|fnlen
operator|+
literal|5
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|new
argument_list|,
name|fname
operator|+
operator|(
name|word
operator|-
name|text
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Return some of TEXT plus fname.  */
name|new
operator|=
name|xmalloc
argument_list|(
name|fnlen
operator|+
operator|(
name|text
operator|-
name|word
operator|)
operator|+
literal|5
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|new
argument_list|,
name|word
argument_list|,
name|text
operator|-
name|word
argument_list|)
expr_stmt|;
name|new
index|[
name|text
operator|-
name|word
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strcat
argument_list|(
name|new
argument_list|,
name|fname
argument_list|)
expr_stmt|;
block|}
operator|(
operator|*
name|list
operator|)
index|[
operator|*
name|list_used
index|]
operator|=
name|new
expr_stmt|;
operator|(
operator|*
name|list
operator|)
index|[
operator|++
operator|*
name|list_used
index|]
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|not_interesting_fname
parameter_list|(
specifier|const
name|char
modifier|*
name|fname
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|illegal_aliens
index|[]
init|=
block|{
literal|"_globals_"
block|,
comment|/* inserted by coff_symtab_read */
name|NULL
block|}
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|illegal_aliens
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|fname
argument_list|,
name|illegal_aliens
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return a NULL terminated array of all source files whose names    begin with matching TEXT.  The file names are looked up in the    symbol tables of this program.  If the answer is no matchess, then    the return value is an array which contains only a NULL pointer.  */
end_comment

begin_function
name|char
modifier|*
modifier|*
name|make_source_files_completion_list
parameter_list|(
name|char
modifier|*
name|text
parameter_list|,
name|char
modifier|*
name|word
parameter_list|)
block|{
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
name|struct
name|partial_symtab
modifier|*
name|ps
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|int
name|first
init|=
literal|1
decl_stmt|;
name|int
name|list_alloced
init|=
literal|1
decl_stmt|;
name|int
name|list_used
init|=
literal|0
decl_stmt|;
name|size_t
name|text_len
init|=
name|strlen
argument_list|(
name|text
argument_list|)
decl_stmt|;
name|char
modifier|*
modifier|*
name|list
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|list_alloced
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|base_name
decl_stmt|;
name|list
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|have_full_symbols
argument_list|()
operator|&&
operator|!
name|have_partial_symbols
argument_list|()
condition|)
return|return
name|list
return|;
name|ALL_SYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
block|{
if|if
condition|(
name|not_interesting_fname
argument_list|(
name|s
operator|->
name|filename
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|filename_seen
argument_list|(
name|s
operator|->
name|filename
argument_list|,
literal|1
argument_list|,
operator|&
name|first
argument_list|)
if|#
directive|if
name|HAVE_DOS_BASED_FILE_SYSTEM
operator|&&
name|strncasecmp
argument_list|(
name|s
operator|->
name|filename
argument_list|,
name|text
argument_list|,
name|text_len
argument_list|)
operator|==
literal|0
else|#
directive|else
operator|&&
name|strncmp
argument_list|(
name|s
operator|->
name|filename
argument_list|,
name|text
argument_list|,
name|text_len
argument_list|)
operator|==
literal|0
endif|#
directive|endif
condition|)
block|{
comment|/* This file matches for a completion; add it to the current 	     list of matches.  */
name|add_filename_to_list
argument_list|(
name|s
operator|->
name|filename
argument_list|,
name|text
argument_list|,
name|word
argument_list|,
operator|&
name|list
argument_list|,
operator|&
name|list_used
argument_list|,
operator|&
name|list_alloced
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* NOTE: We allow the user to type a base name when the 	     debug info records leading directories, but not the other 	     way around.  This is what subroutines of breakpoint 	     command do when they parse file names.  */
name|base_name
operator|=
name|lbasename
argument_list|(
name|s
operator|->
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|base_name
operator|!=
name|s
operator|->
name|filename
operator|&&
operator|!
name|filename_seen
argument_list|(
name|base_name
argument_list|,
literal|1
argument_list|,
operator|&
name|first
argument_list|)
if|#
directive|if
name|HAVE_DOS_BASED_FILE_SYSTEM
operator|&&
name|strncasecmp
argument_list|(
name|base_name
argument_list|,
name|text
argument_list|,
name|text_len
argument_list|)
operator|==
literal|0
else|#
directive|else
operator|&&
name|strncmp
argument_list|(
name|base_name
argument_list|,
name|text
argument_list|,
name|text_len
argument_list|)
operator|==
literal|0
endif|#
directive|endif
condition|)
name|add_filename_to_list
argument_list|(
name|base_name
argument_list|,
name|text
argument_list|,
name|word
argument_list|,
operator|&
name|list
argument_list|,
operator|&
name|list_used
argument_list|,
operator|&
name|list_alloced
argument_list|)
expr_stmt|;
block|}
block|}
name|ALL_PSYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|ps
argument_list|)
block|{
if|if
condition|(
name|not_interesting_fname
argument_list|(
name|ps
operator|->
name|filename
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|ps
operator|->
name|readin
condition|)
block|{
if|if
condition|(
operator|!
name|filename_seen
argument_list|(
name|ps
operator|->
name|filename
argument_list|,
literal|1
argument_list|,
operator|&
name|first
argument_list|)
if|#
directive|if
name|HAVE_DOS_BASED_FILE_SYSTEM
operator|&&
name|strncasecmp
argument_list|(
name|ps
operator|->
name|filename
argument_list|,
name|text
argument_list|,
name|text_len
argument_list|)
operator|==
literal|0
else|#
directive|else
operator|&&
name|strncmp
argument_list|(
name|ps
operator|->
name|filename
argument_list|,
name|text
argument_list|,
name|text_len
argument_list|)
operator|==
literal|0
endif|#
directive|endif
condition|)
block|{
comment|/* This file matches for a completion; add it to the 		 current list of matches.  */
name|add_filename_to_list
argument_list|(
name|ps
operator|->
name|filename
argument_list|,
name|text
argument_list|,
name|word
argument_list|,
operator|&
name|list
argument_list|,
operator|&
name|list_used
argument_list|,
operator|&
name|list_alloced
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|base_name
operator|=
name|lbasename
argument_list|(
name|ps
operator|->
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|base_name
operator|!=
name|ps
operator|->
name|filename
operator|&&
operator|!
name|filename_seen
argument_list|(
name|base_name
argument_list|,
literal|1
argument_list|,
operator|&
name|first
argument_list|)
if|#
directive|if
name|HAVE_DOS_BASED_FILE_SYSTEM
operator|&&
name|strncasecmp
argument_list|(
name|base_name
argument_list|,
name|text
argument_list|,
name|text_len
argument_list|)
operator|==
literal|0
else|#
directive|else
operator|&&
name|strncmp
argument_list|(
name|base_name
argument_list|,
name|text
argument_list|,
name|text_len
argument_list|)
operator|==
literal|0
endif|#
directive|endif
condition|)
name|add_filename_to_list
argument_list|(
name|base_name
argument_list|,
name|text
argument_list|,
name|word
argument_list|,
operator|&
name|list
argument_list|,
operator|&
name|list_used
argument_list|,
operator|&
name|list_alloced
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|list
return|;
block|}
end_function

begin_comment
comment|/* Determine if PC is in the prologue of a function.  The prologue is the area    between the first instruction of a function, and the first executable line.    Returns 1 if PC *might* be in prologue, 0 if definately *not* in prologue.     If non-zero, func_start is where we think the prologue starts, possibly    by previous examination of symbol table information.  */
end_comment

begin_function
name|int
name|in_prologue
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|CORE_ADDR
name|func_start
parameter_list|)
block|{
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|CORE_ADDR
name|func_addr
decl_stmt|,
name|func_end
decl_stmt|;
comment|/* We have several sources of information we can consult to figure      this out.      - Compilers usually emit line number info that marks the prologue        as its own "source line".  So the ending address of that "line"        is the end of the prologue.  If available, this is the most        reliable method.      - The minimal symbols and partial symbols, which can usually tell        us the starting and ending addresses of a function.      - If we know the function's start address, we can call the        architecture-defined SKIP_PROLOGUE function to analyze the        instruction stream and guess where the prologue ends.      - Our `func_start' argument; if non-zero, this is the caller's        best guess as to the function's entry point.  At the time of        this writing, handle_inferior_event doesn't get this right, so        it should be our last resort.  */
comment|/* Consult the partial symbol table, to find which function      the PC is in.  */
if|if
condition|(
operator|!
name|find_pc_partial_function
argument_list|(
name|pc
argument_list|,
name|NULL
argument_list|,
operator|&
name|func_addr
argument_list|,
operator|&
name|func_end
argument_list|)
condition|)
block|{
name|CORE_ADDR
name|prologue_end
decl_stmt|;
comment|/* We don't even have minsym information, so fall back to using          func_start, if given.  */
if|if
condition|(
operator|!
name|func_start
condition|)
return|return
literal|1
return|;
comment|/* We *might* be in a prologue.  */
name|prologue_end
operator|=
name|SKIP_PROLOGUE
argument_list|(
name|func_start
argument_list|)
expr_stmt|;
return|return
name|func_start
operator|<=
name|pc
operator|&&
name|pc
operator|<
name|prologue_end
return|;
block|}
comment|/* If we have line number information for the function, that's      usually pretty reliable.  */
name|sal
operator|=
name|find_pc_line
argument_list|(
name|func_addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Now sal describes the source line at the function's entry point,      which (by convention) is the prologue.  The end of that "line",      sal.end, is the end of the prologue.       Note that, for functions whose source code is all on a single      line, the line number information doesn't always end up this way.      So we must verify that our purported end-of-prologue address is      *within* the function, not at its start or end.  */
if|if
condition|(
name|sal
operator|.
name|line
operator|==
literal|0
operator|||
name|sal
operator|.
name|end
operator|<=
name|func_addr
operator|||
name|func_end
operator|<=
name|sal
operator|.
name|end
condition|)
block|{
comment|/* We don't have any good line number info, so use the minsym 	 information, together with the architecture-specific prologue 	 scanning code.  */
name|CORE_ADDR
name|prologue_end
init|=
name|SKIP_PROLOGUE
argument_list|(
name|func_addr
argument_list|)
decl_stmt|;
return|return
name|func_addr
operator|<=
name|pc
operator|&&
name|pc
operator|<
name|prologue_end
return|;
block|}
comment|/* We have line number info, and it looks good.  */
return|return
name|func_addr
operator|<=
name|pc
operator|&&
name|pc
operator|<
name|sal
operator|.
name|end
return|;
block|}
end_function

begin_comment
comment|/* Given PC at the function's start address, attempt to find the    prologue end using SAL information.  Return zero if the skip fails.     A non-optimized prologue traditionally has one SAL for the function    and a second for the function body.  A single line function has    them both pointing at the same line.     An optimized prologue is similar but the prologue may contain    instructions (SALs) from the instruction body.  Need to skip those    while not getting into the function body.     The functions end point and an increasing SAL line are used as    indicators of the prologue's endpoint.     This code is based on the function refine_prologue_limit (versions    found in both ia64 and ppc).  */
end_comment

begin_function
name|CORE_ADDR
name|skip_prologue_using_sal
parameter_list|(
name|CORE_ADDR
name|func_addr
parameter_list|)
block|{
name|struct
name|symtab_and_line
name|prologue_sal
decl_stmt|;
name|CORE_ADDR
name|start_pc
decl_stmt|;
name|CORE_ADDR
name|end_pc
decl_stmt|;
comment|/* Get an initial range for the function.  */
name|find_pc_partial_function
argument_list|(
name|func_addr
argument_list|,
name|NULL
argument_list|,
operator|&
name|start_pc
argument_list|,
operator|&
name|end_pc
argument_list|)
expr_stmt|;
name|start_pc
operator|+=
name|FUNCTION_START_OFFSET
expr_stmt|;
name|prologue_sal
operator|=
name|find_pc_line
argument_list|(
name|start_pc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|prologue_sal
operator|.
name|line
operator|!=
literal|0
condition|)
block|{
while|while
condition|(
name|prologue_sal
operator|.
name|end
operator|<
name|end_pc
condition|)
block|{
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|sal
operator|=
name|find_pc_line
argument_list|(
name|prologue_sal
operator|.
name|end
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sal
operator|.
name|line
operator|==
literal|0
condition|)
break|break;
comment|/* Assume that a consecutive SAL for the same (or larger) 	     line mark the prologue -> body transition.  */
if|if
condition|(
name|sal
operator|.
name|line
operator|>=
name|prologue_sal
operator|.
name|line
condition|)
break|break;
comment|/* The case in which compiler's optimizer/scheduler has 	     moved instructions into the prologue.  We look ahead in 	     the function looking for address ranges whose 	     corresponding line number is less the first one that we 	     found for the function.  This is more conservative then 	     refine_prologue_limit which scans a large number of SALs 	     looking for any in the prologue */
name|prologue_sal
operator|=
name|sal
expr_stmt|;
block|}
block|}
return|return
name|prologue_sal
operator|.
name|end
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|struct
name|symtabs_and_lines
name|decode_line_spec
parameter_list|(
name|char
modifier|*
name|string
parameter_list|,
name|int
name|funfirstline
parameter_list|)
block|{
name|struct
name|symtabs_and_lines
name|sals
decl_stmt|;
name|struct
name|symtab_and_line
name|cursal
decl_stmt|;
if|if
condition|(
name|string
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Empty line specification."
argument_list|)
expr_stmt|;
comment|/* We use whatever is set as the current source line. We do not try      and get a default  or it will recursively call us! */
name|cursal
operator|=
name|get_current_source_symtab_and_line
argument_list|()
expr_stmt|;
name|sals
operator|=
name|decode_line_1
argument_list|(
operator|&
name|string
argument_list|,
name|funfirstline
argument_list|,
name|cursal
operator|.
name|symtab
argument_list|,
name|cursal
operator|.
name|line
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|*
operator|)
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|string
condition|)
name|error
argument_list|(
literal|"Junk at end of line specification: %s"
argument_list|,
name|string
argument_list|)
expr_stmt|;
return|return
name|sals
return|;
block|}
end_function

begin_comment
comment|/* Track MAIN */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|name_of_main
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|set_main_name
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|name_of_main
operator|!=
name|NULL
condition|)
block|{
name|xfree
argument_list|(
name|name_of_main
argument_list|)
expr_stmt|;
name|name_of_main
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
block|{
name|name_of_main
operator|=
name|xstrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|char
modifier|*
name|main_name
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|name_of_main
operator|!=
name|NULL
condition|)
return|return
name|name_of_main
return|;
else|else
return|return
literal|"main"
return|;
block|}
end_function

begin_function
name|void
name|_initialize_symtab
parameter_list|(
name|void
parameter_list|)
block|{
name|add_info
argument_list|(
literal|"variables"
argument_list|,
name|variables_info
argument_list|,
literal|"All global and static variable names, or those matching REGEXP."
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbx_commands
condition|)
name|add_com
argument_list|(
literal|"whereis"
argument_list|,
name|class_info
argument_list|,
name|variables_info
argument_list|,
literal|"All global and static variable names, or those matching REGEXP."
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"functions"
argument_list|,
name|functions_info
argument_list|,
literal|"All function names, or those matching REGEXP."
argument_list|)
expr_stmt|;
comment|/* FIXME:  This command has at least the following problems:      1.  It prints builtin types (in a very strange and confusing fashion).      2.  It doesn't print right, e.g. with      typedef struct foo *FOO      type_print prints "FOO" when we want to make it (in this situation)      print "struct foo *".      I also think "ptype" or "whatis" is more likely to be useful (but if      there is much disagreement "info types" can be fixed).  */
name|add_info
argument_list|(
literal|"types"
argument_list|,
name|types_info
argument_list|,
literal|"All type names, or those matching REGEXP."
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"sources"
argument_list|,
name|sources_info
argument_list|,
literal|"Source files in the program."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"rbreak"
argument_list|,
name|class_breakpoint
argument_list|,
name|rbreak_command
argument_list|,
literal|"Set a breakpoint for all functions matching REGEXP."
argument_list|)
expr_stmt|;
if|if
condition|(
name|xdb_commands
condition|)
block|{
name|add_com
argument_list|(
literal|"lf"
argument_list|,
name|class_info
argument_list|,
name|sources_info
argument_list|,
literal|"Source files in the program"
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"lg"
argument_list|,
name|class_info
argument_list|,
name|variables_info
argument_list|,
literal|"All global and static variable names, or those matching REGEXP."
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize the one built-in type that isn't language dependent... */
name|builtin_type_error
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_ERROR
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"<unknown type>"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

