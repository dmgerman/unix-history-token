begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Symbol table lookup for the GNU debugger, GDB.     Copyright 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994,    1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002 Free Software    Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"call-cmds.h"
end_include

begin_include
include|#
directive|include
file|"gdb_regex.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"linespec.h"
end_include

begin_include
include|#
directive|include
file|"filenames.h"
end_include

begin_comment
comment|/* for FILENAME_CMP */
end_comment

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"gdb_stat.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"cp-abi.h"
end_include

begin_comment
comment|/* Prototype for one function in parser-defs.h,    instead of including that entire file. */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|find_template_name_end
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Prototypes for local functions */
end_comment

begin_function_decl
specifier|static
name|void
name|completion_list_add_name
parameter_list|(
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rbreak_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|types_info
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|functions_info
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|variables_info
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sources_info
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|output_source_filename
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|find_line_common
parameter_list|(
name|struct
name|linetable
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* This one is used by linespec.c */
end_comment

begin_function_decl
name|char
modifier|*
name|operator_chars
parameter_list|(
name|char
modifier|*
name|p
parameter_list|,
name|char
modifier|*
modifier|*
name|end
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|partial_symbol
modifier|*
name|lookup_partial_symbol
parameter_list|(
name|struct
name|partial_symtab
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|namespace_enum
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|symbol
modifier|*
name|lookup_symbol_aux
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|struct
name|block
modifier|*
name|block
parameter_list|,
specifier|const
name|namespace_enum
name|namespace
parameter_list|,
name|int
modifier|*
name|is_a_field_of_this
parameter_list|,
name|struct
name|symtab
modifier|*
modifier|*
name|symtab
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|symbol
modifier|*
name|find_active_alias
parameter_list|(
name|struct
name|symbol
modifier|*
name|sym
parameter_list|,
name|CORE_ADDR
name|addr
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* This flag is used in hppa-tdep.c, and set in hp-symtab-read.c */
end_comment

begin_comment
comment|/* Signals the presence of objects compiled by HP compilers */
end_comment

begin_decl_stmt
name|int
name|hp_som_som_object_present
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|fixup_section
parameter_list|(
name|struct
name|general_symbol_info
modifier|*
parameter_list|,
name|struct
name|objfile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|file_matches
parameter_list|(
name|char
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_symbol_info
parameter_list|(
name|namespace_enum
parameter_list|,
name|struct
name|symtab
modifier|*
parameter_list|,
name|struct
name|symbol
modifier|*
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_msymbol_info
parameter_list|(
name|struct
name|minimal_symbol
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|symtab_symbol_info
parameter_list|(
name|char
modifier|*
parameter_list|,
name|namespace_enum
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|overload_list_add_symbol
parameter_list|(
name|struct
name|symbol
modifier|*
name|sym
parameter_list|,
name|char
modifier|*
name|oload_name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|_initialize_symtab
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* */
end_comment

begin_comment
comment|/* The single non-language-specific builtin type */
end_comment

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_error
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Block in which the most recently searched-for symbol was found.    Might be better to make this a parameter to lookup_symbol and     value_of_this. */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|block
modifier|*
name|block_found
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* While the C++ support is still in flux, issue a possibly helpful hint on    using the new command completion feature on single quoted demangled C++    symbols.  Remove when loose ends are cleaned up.   FIXME -fnf */
end_comment

begin_function
specifier|static
name|void
name|cplusplus_hint
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
while|while
condition|(
operator|*
name|name
operator|==
literal|'\''
condition|)
name|name
operator|++
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Hint: try '%s<TAB> or '%s<ESC-?>\n"
argument_list|,
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"(Note leading single quote.)\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check for a symtab of a specific name; first in symtabs, then in    psymtabs.  *If* there is no '/' in the name, a match after a '/'    in the symtab filename will also work.  */
end_comment

begin_function
name|struct
name|symtab
modifier|*
name|lookup_symtab
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|register
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
specifier|register
name|struct
name|partial_symtab
modifier|*
name|ps
decl_stmt|;
specifier|register
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|char
modifier|*
name|real_path
init|=
name|NULL
decl_stmt|;
comment|/* Here we are interested in canonicalizing an absolute path, not      absolutizing a relative path.  */
if|if
condition|(
name|IS_ABSOLUTE_PATH
argument_list|(
name|name
argument_list|)
condition|)
name|real_path
operator|=
name|gdb_realpath
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|got_symtab
label|:
comment|/* First, search for an exact match */
name|ALL_SYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
block|{
if|if
condition|(
name|FILENAME_CMP
argument_list|(
name|name
argument_list|,
name|s
operator|->
name|filename
argument_list|)
operator|==
literal|0
condition|)
block|{
name|xfree
argument_list|(
name|real_path
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
comment|/* If the user gave us an absolute path, try to find the file in        this symtab and use its absolute path.  */
if|if
condition|(
name|real_path
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|rp
init|=
name|symtab_to_filename
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|FILENAME_CMP
argument_list|(
name|real_path
argument_list|,
name|rp
argument_list|)
operator|==
literal|0
condition|)
block|{
name|xfree
argument_list|(
name|real_path
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
block|}
block|}
name|xfree
argument_list|(
name|real_path
argument_list|)
expr_stmt|;
comment|/* Now, search for a matching tail (only if name doesn't have any dirs) */
if|if
condition|(
name|lbasename
argument_list|(
name|name
argument_list|)
operator|==
name|name
condition|)
name|ALL_SYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
block|{
if|if
condition|(
name|FILENAME_CMP
argument_list|(
name|lbasename
argument_list|(
name|s
operator|->
name|filename
argument_list|)
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|s
return|;
block|}
comment|/* Same search rules as above apply here, but now we look thru the      psymtabs.  */
name|ps
operator|=
name|lookup_partial_symtab
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ps
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|ps
operator|->
name|readin
condition|)
name|error
argument_list|(
literal|"Internal: readin %s pst for `%s' found when no symtab found."
argument_list|,
name|ps
operator|->
name|filename
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|s
operator|=
name|PSYMTAB_TO_SYMTAB
argument_list|(
name|ps
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
condition|)
return|return
name|s
return|;
comment|/* At this point, we have located the psymtab for this file, but      the conversion to a symtab has failed.  This usually happens      when we are looking up an include file.  In this case,      PSYMTAB_TO_SYMTAB doesn't return a symtab, even though one has      been created.  So, we need to run through the symtabs again in      order to find the file.      XXX - This is a crock, and should be fixed inside of the the      symbol parsing routines. */
goto|goto
name|got_symtab
goto|;
block|}
end_function

begin_comment
comment|/* Lookup the partial symbol table of a source file named NAME.    *If* there is no '/' in the name, a match after a '/'    in the psymtab filename will also work.  */
end_comment

begin_function
name|struct
name|partial_symtab
modifier|*
name|lookup_partial_symtab
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|register
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
specifier|register
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|char
modifier|*
name|real_path
init|=
name|NULL
decl_stmt|;
comment|/* Here we are interested in canonicalizing an absolute path, not      absolutizing a relative path.  */
if|if
condition|(
name|IS_ABSOLUTE_PATH
argument_list|(
name|name
argument_list|)
condition|)
name|real_path
operator|=
name|gdb_realpath
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|ALL_PSYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|pst
argument_list|)
block|{
if|if
condition|(
name|FILENAME_CMP
argument_list|(
name|name
argument_list|,
name|pst
operator|->
name|filename
argument_list|)
operator|==
literal|0
condition|)
block|{
name|xfree
argument_list|(
name|real_path
argument_list|)
expr_stmt|;
return|return
operator|(
name|pst
operator|)
return|;
block|}
comment|/* If the user gave us an absolute path, try to find the file in        this symtab and use its absolute path.  */
if|if
condition|(
name|real_path
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|pst
operator|->
name|fullname
operator|==
name|NULL
condition|)
name|source_full_path_of
argument_list|(
name|pst
operator|->
name|filename
argument_list|,
operator|&
name|pst
operator|->
name|fullname
argument_list|)
expr_stmt|;
if|if
condition|(
name|pst
operator|->
name|fullname
operator|!=
name|NULL
operator|&&
name|FILENAME_CMP
argument_list|(
name|real_path
argument_list|,
name|pst
operator|->
name|fullname
argument_list|)
operator|==
literal|0
condition|)
block|{
name|xfree
argument_list|(
name|real_path
argument_list|)
expr_stmt|;
return|return
name|pst
return|;
block|}
block|}
block|}
name|xfree
argument_list|(
name|real_path
argument_list|)
expr_stmt|;
comment|/* Now, search for a matching tail (only if name doesn't have any dirs) */
if|if
condition|(
name|lbasename
argument_list|(
name|name
argument_list|)
operator|==
name|name
condition|)
name|ALL_PSYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|pst
argument_list|)
block|{
if|if
condition|(
name|FILENAME_CMP
argument_list|(
name|lbasename
argument_list|(
name|pst
operator|->
name|filename
argument_list|)
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|pst
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Mangle a GDB method stub type.  This actually reassembles the pieces of the    full method name, which consist of the class name (from T), the unadorned    method name from METHOD_ID, and the signature for the specific overload,    specified by SIGNATURE_ID.  Note that this function is g++ specific. */
end_comment

begin_function
name|char
modifier|*
name|gdb_mangle_name
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|int
name|method_id
parameter_list|,
name|int
name|signature_id
parameter_list|)
block|{
name|int
name|mangled_name_len
decl_stmt|;
name|char
modifier|*
name|mangled_name
decl_stmt|;
name|struct
name|fn_field
modifier|*
name|f
init|=
name|TYPE_FN_FIELDLIST1
argument_list|(
name|type
argument_list|,
name|method_id
argument_list|)
decl_stmt|;
name|struct
name|fn_field
modifier|*
name|method
init|=
operator|&
name|f
index|[
name|signature_id
index|]
decl_stmt|;
name|char
modifier|*
name|field_name
init|=
name|TYPE_FN_FIELDLIST_NAME
argument_list|(
name|type
argument_list|,
name|method_id
argument_list|)
decl_stmt|;
name|char
modifier|*
name|physname
init|=
name|TYPE_FN_FIELD_PHYSNAME
argument_list|(
name|f
argument_list|,
name|signature_id
argument_list|)
decl_stmt|;
name|char
modifier|*
name|newname
init|=
name|type_name_no_tag
argument_list|(
name|type
argument_list|)
decl_stmt|;
comment|/* Does the form of physname indicate that it is the full mangled name      of a constructor (not just the args)?  */
name|int
name|is_full_physname_constructor
decl_stmt|;
name|int
name|is_constructor
decl_stmt|;
name|int
name|is_destructor
init|=
name|is_destructor_name
argument_list|(
name|physname
argument_list|)
decl_stmt|;
comment|/* Need a new type prefix.  */
name|char
modifier|*
name|const_prefix
init|=
name|method
operator|->
name|is_const
condition|?
literal|"C"
else|:
literal|""
decl_stmt|;
name|char
modifier|*
name|volatile_prefix
init|=
name|method
operator|->
name|is_volatile
condition|?
literal|"V"
else|:
literal|""
decl_stmt|;
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
name|int
name|len
init|=
operator|(
name|newname
operator|==
name|NULL
condition|?
literal|0
else|:
name|strlen
argument_list|(
name|newname
argument_list|)
operator|)
decl_stmt|;
comment|/* Nothing to do if physname already contains a fully mangled v3 abi name      or an operator name.  */
if|if
condition|(
operator|(
name|physname
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|physname
index|[
literal|1
index|]
operator|==
literal|'Z'
operator|)
operator|||
name|is_operator_name
argument_list|(
name|field_name
argument_list|)
condition|)
return|return
name|xstrdup
argument_list|(
name|physname
argument_list|)
return|;
name|is_full_physname_constructor
operator|=
name|is_constructor_name
argument_list|(
name|physname
argument_list|)
expr_stmt|;
name|is_constructor
operator|=
name|is_full_physname_constructor
operator|||
operator|(
name|newname
operator|&&
name|STREQ
argument_list|(
name|field_name
argument_list|,
name|newname
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_destructor
condition|)
name|is_destructor
operator|=
operator|(
name|strncmp
argument_list|(
name|physname
argument_list|,
literal|"__dt"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|is_destructor
operator|||
name|is_full_physname_constructor
condition|)
block|{
name|mangled_name
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|physname
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|mangled_name
argument_list|,
name|physname
argument_list|)
expr_stmt|;
return|return
name|mangled_name
return|;
block|}
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"__%s%s"
argument_list|,
name|const_prefix
argument_list|,
name|volatile_prefix
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|physname
index|[
literal|0
index|]
operator|==
literal|'t'
operator|||
name|physname
index|[
literal|0
index|]
operator|==
literal|'Q'
condition|)
block|{
comment|/* The physname for template and qualified methods already includes          the class name.  */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"__%s%s"
argument_list|,
name|const_prefix
argument_list|,
name|volatile_prefix
argument_list|)
expr_stmt|;
name|newname
operator|=
name|NULL
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"__%s%s%d"
argument_list|,
name|const_prefix
argument_list|,
name|volatile_prefix
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
name|mangled_name_len
operator|=
operator|(
operator|(
name|is_constructor
condition|?
literal|0
else|:
name|strlen
argument_list|(
name|field_name
argument_list|)
operator|)
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
operator|+
name|len
operator|+
name|strlen
argument_list|(
name|physname
argument_list|)
operator|+
literal|1
operator|)
expr_stmt|;
block|{
name|mangled_name
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|mangled_name_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_constructor
condition|)
name|mangled_name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|mangled_name
argument_list|,
name|field_name
argument_list|)
expr_stmt|;
block|}
name|strcat
argument_list|(
name|mangled_name
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* If the class doesn't have a name, i.e. newname NULL, then we just      mangle it using 0 for the length of the class.  Thus it gets mangled      as something starting with `::' rather than `classname::'. */
if|if
condition|(
name|newname
operator|!=
name|NULL
condition|)
name|strcat
argument_list|(
name|mangled_name
argument_list|,
name|newname
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|mangled_name
argument_list|,
name|physname
argument_list|)
expr_stmt|;
return|return
operator|(
name|mangled_name
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find which partial symtab on contains PC and SECTION.  Return 0 if none.  */
end_comment

begin_function
name|struct
name|partial_symtab
modifier|*
name|find_pc_sect_psymtab
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|asection
modifier|*
name|section
parameter_list|)
block|{
specifier|register
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
specifier|register
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
comment|/* If we know that this is not a text address, return failure.  This is      necessary because we loop based on texthigh and textlow, which do      not include the data ranges.  */
name|msymbol
operator|=
name|lookup_minimal_symbol_by_pc_section
argument_list|(
name|pc
argument_list|,
name|section
argument_list|)
expr_stmt|;
if|if
condition|(
name|msymbol
operator|&&
operator|(
name|msymbol
operator|->
name|type
operator|==
name|mst_data
operator|||
name|msymbol
operator|->
name|type
operator|==
name|mst_bss
operator|||
name|msymbol
operator|->
name|type
operator|==
name|mst_abs
operator|||
name|msymbol
operator|->
name|type
operator|==
name|mst_file_data
operator|||
name|msymbol
operator|->
name|type
operator|==
name|mst_file_bss
operator|)
condition|)
return|return
name|NULL
return|;
name|ALL_PSYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|pst
argument_list|)
block|{
if|if
condition|(
name|pc
operator|>=
name|pst
operator|->
name|textlow
operator|&&
name|pc
operator|<
name|pst
operator|->
name|texthigh
condition|)
block|{
name|struct
name|partial_symtab
modifier|*
name|tpst
decl_stmt|;
comment|/* An objfile that has its functions reordered might have 	   many partial symbol tables containing the PC, but 	   we want the partial symbol table that contains the 	   function containing the PC.  */
if|if
condition|(
operator|!
operator|(
name|objfile
operator|->
name|flags
operator|&
name|OBJF_REORDERED
operator|)
operator|&&
name|section
operator|==
literal|0
condition|)
comment|/* can't validate section this way */
return|return
operator|(
name|pst
operator|)
return|;
if|if
condition|(
name|msymbol
operator|==
name|NULL
condition|)
return|return
operator|(
name|pst
operator|)
return|;
for|for
control|(
name|tpst
operator|=
name|pst
init|;
name|tpst
operator|!=
name|NULL
condition|;
name|tpst
operator|=
name|tpst
operator|->
name|next
control|)
block|{
if|if
condition|(
name|pc
operator|>=
name|tpst
operator|->
name|textlow
operator|&&
name|pc
operator|<
name|tpst
operator|->
name|texthigh
condition|)
block|{
name|struct
name|partial_symbol
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|find_pc_sect_psymbol
argument_list|(
name|tpst
argument_list|,
name|pc
argument_list|,
name|section
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
operator|&&
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|p
argument_list|)
operator|==
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
condition|)
return|return
operator|(
name|tpst
operator|)
return|;
block|}
block|}
return|return
operator|(
name|pst
operator|)
return|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Find which partial symtab contains PC.  Return 0 if none.     Backward compatibility, no section */
end_comment

begin_function
name|struct
name|partial_symtab
modifier|*
name|find_pc_psymtab
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
return|return
name|find_pc_sect_psymtab
argument_list|(
name|pc
argument_list|,
name|find_pc_mapped_section
argument_list|(
name|pc
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Find which partial symbol within a psymtab matches PC and SECTION.      Return 0 if none.  Check all psymtabs if PSYMTAB is 0.  */
end_comment

begin_function
name|struct
name|partial_symbol
modifier|*
name|find_pc_sect_psymbol
parameter_list|(
name|struct
name|partial_symtab
modifier|*
name|psymtab
parameter_list|,
name|CORE_ADDR
name|pc
parameter_list|,
name|asection
modifier|*
name|section
parameter_list|)
block|{
name|struct
name|partial_symbol
modifier|*
name|best
init|=
name|NULL
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
modifier|*
name|pp
decl_stmt|;
name|CORE_ADDR
name|best_pc
decl_stmt|;
if|if
condition|(
operator|!
name|psymtab
condition|)
name|psymtab
operator|=
name|find_pc_sect_psymtab
argument_list|(
name|pc
argument_list|,
name|section
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|psymtab
condition|)
return|return
literal|0
return|;
comment|/* Cope with programs that start at address 0 */
name|best_pc
operator|=
operator|(
name|psymtab
operator|->
name|textlow
operator|!=
literal|0
operator|)
condition|?
name|psymtab
operator|->
name|textlow
operator|-
literal|1
else|:
literal|0
expr_stmt|;
comment|/* Search the global symbols as well as the static symbols, so that      find_pc_partial_function doesn't use a minimal symbol and thus      cache a bad endaddr.  */
for|for
control|(
name|pp
operator|=
name|psymtab
operator|->
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
operator|+
name|psymtab
operator|->
name|globals_offset
init|;
operator|(
name|pp
operator|-
operator|(
name|psymtab
operator|->
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
operator|+
name|psymtab
operator|->
name|globals_offset
operator|)
operator|<
name|psymtab
operator|->
name|n_global_syms
operator|)
condition|;
name|pp
operator|++
control|)
block|{
name|p
operator|=
operator|*
name|pp
expr_stmt|;
if|if
condition|(
name|SYMBOL_NAMESPACE
argument_list|(
name|p
argument_list|)
operator|==
name|VAR_NAMESPACE
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|p
argument_list|)
operator|==
name|LOC_BLOCK
operator|&&
name|pc
operator|>=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|p
argument_list|)
operator|&&
operator|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|p
argument_list|)
operator|>
name|best_pc
operator|||
operator|(
name|psymtab
operator|->
name|textlow
operator|==
literal|0
operator|&&
name|best_pc
operator|==
literal|0
operator|&&
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|p
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|section
condition|)
comment|/* match on a specific section */
block|{
name|fixup_psymbol_section
argument_list|(
name|p
argument_list|,
name|psymtab
operator|->
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|SYMBOL_BFD_SECTION
argument_list|(
name|p
argument_list|)
operator|!=
name|section
condition|)
continue|continue;
block|}
name|best_pc
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|best
operator|=
name|p
expr_stmt|;
block|}
block|}
for|for
control|(
name|pp
operator|=
name|psymtab
operator|->
name|objfile
operator|->
name|static_psymbols
operator|.
name|list
operator|+
name|psymtab
operator|->
name|statics_offset
init|;
operator|(
name|pp
operator|-
operator|(
name|psymtab
operator|->
name|objfile
operator|->
name|static_psymbols
operator|.
name|list
operator|+
name|psymtab
operator|->
name|statics_offset
operator|)
operator|<
name|psymtab
operator|->
name|n_static_syms
operator|)
condition|;
name|pp
operator|++
control|)
block|{
name|p
operator|=
operator|*
name|pp
expr_stmt|;
if|if
condition|(
name|SYMBOL_NAMESPACE
argument_list|(
name|p
argument_list|)
operator|==
name|VAR_NAMESPACE
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|p
argument_list|)
operator|==
name|LOC_BLOCK
operator|&&
name|pc
operator|>=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|p
argument_list|)
operator|&&
operator|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|p
argument_list|)
operator|>
name|best_pc
operator|||
operator|(
name|psymtab
operator|->
name|textlow
operator|==
literal|0
operator|&&
name|best_pc
operator|==
literal|0
operator|&&
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|p
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|section
condition|)
comment|/* match on a specific section */
block|{
name|fixup_psymbol_section
argument_list|(
name|p
argument_list|,
name|psymtab
operator|->
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|SYMBOL_BFD_SECTION
argument_list|(
name|p
argument_list|)
operator|!=
name|section
condition|)
continue|continue;
block|}
name|best_pc
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|best
operator|=
name|p
expr_stmt|;
block|}
block|}
return|return
name|best
return|;
block|}
end_function

begin_comment
comment|/* Find which partial symbol within a psymtab matches PC.  Return 0 if none.      Check all psymtabs if PSYMTAB is 0.  Backwards compatibility, no section. */
end_comment

begin_function
name|struct
name|partial_symbol
modifier|*
name|find_pc_psymbol
parameter_list|(
name|struct
name|partial_symtab
modifier|*
name|psymtab
parameter_list|,
name|CORE_ADDR
name|pc
parameter_list|)
block|{
return|return
name|find_pc_sect_psymbol
argument_list|(
name|psymtab
argument_list|,
name|pc
argument_list|,
name|find_pc_mapped_section
argument_list|(
name|pc
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Debug symbols usually don't have section information.  We need to dig that    out of the minimal symbols and stash that in the debug symbol.  */
end_comment

begin_function
specifier|static
name|void
name|fixup_section
parameter_list|(
name|struct
name|general_symbol_info
modifier|*
name|ginfo
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|struct
name|minimal_symbol
modifier|*
name|msym
decl_stmt|;
name|msym
operator|=
name|lookup_minimal_symbol
argument_list|(
name|ginfo
operator|->
name|name
argument_list|,
name|NULL
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|msym
condition|)
block|{
name|ginfo
operator|->
name|bfd_section
operator|=
name|SYMBOL_BFD_SECTION
argument_list|(
name|msym
argument_list|)
expr_stmt|;
name|ginfo
operator|->
name|section
operator|=
name|SYMBOL_SECTION
argument_list|(
name|msym
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|struct
name|symbol
modifier|*
name|fixup_symbol_section
parameter_list|(
name|struct
name|symbol
modifier|*
name|sym
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
if|if
condition|(
operator|!
name|sym
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|SYMBOL_BFD_SECTION
argument_list|(
name|sym
argument_list|)
condition|)
return|return
name|sym
return|;
name|fixup_section
argument_list|(
operator|&
name|sym
operator|->
name|ginfo
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
return|return
name|sym
return|;
block|}
end_function

begin_function
name|struct
name|partial_symbol
modifier|*
name|fixup_psymbol_section
parameter_list|(
name|struct
name|partial_symbol
modifier|*
name|psym
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
if|if
condition|(
operator|!
name|psym
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|SYMBOL_BFD_SECTION
argument_list|(
name|psym
argument_list|)
condition|)
return|return
name|psym
return|;
name|fixup_section
argument_list|(
operator|&
name|psym
operator|->
name|ginfo
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
return|return
name|psym
return|;
block|}
end_function

begin_comment
comment|/* Find the definition for a specified symbol name NAME    in namespace NAMESPACE, visible from lexical block BLOCK.    Returns the struct symbol pointer, or zero if no symbol is found.    If SYMTAB is non-NULL, store the symbol table in which the    symbol was found there, or NULL if not found.    C++: if IS_A_FIELD_OF_THIS is nonzero on entry, check to see if    NAME is a field of the current implied argument `this'.  If so set    *IS_A_FIELD_OF_THIS to 1, otherwise set it to zero.     BLOCK_FOUND is set to the block in which NAME is found (in the case of    a field of `this', value_of_this sets BLOCK_FOUND to the proper value.) */
end_comment

begin_comment
comment|/* This function has a bunch of loops in it and it would seem to be    attractive to put in some QUIT's (though I'm not really sure    whether it can run long enough to be really important).  But there    are a few calls for which it would appear to be bad news to quit    out of here: find_proc_desc in alpha-tdep.c and mips-tdep.c, and    nindy_frame_chain_valid in nindy-tdep.c.  (Note that there is C++    code below which can error(), but that probably doesn't affect    these calls since they are looking for a known variable and thus    can probably assume it will never hit the C++ code).  */
end_comment

begin_function
name|struct
name|symbol
modifier|*
name|lookup_symbol
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|struct
name|block
modifier|*
name|block
parameter_list|,
specifier|const
name|namespace_enum
name|namespace
parameter_list|,
name|int
modifier|*
name|is_a_field_of_this
parameter_list|,
name|struct
name|symtab
modifier|*
modifier|*
name|symtab
parameter_list|)
block|{
name|char
modifier|*
name|modified_name
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|modified_name2
init|=
name|NULL
decl_stmt|;
name|int
name|needtofreename
init|=
literal|0
decl_stmt|;
name|struct
name|symbol
modifier|*
name|returnval
decl_stmt|;
if|if
condition|(
name|case_sensitivity
operator|==
name|case_sensitive_off
condition|)
block|{
name|char
modifier|*
name|copy
decl_stmt|;
name|int
name|len
decl_stmt|,
name|i
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|copy
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|copy
index|[
name|i
index|]
operator|=
name|tolower
argument_list|(
name|name
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|copy
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
name|modified_name
operator|=
name|copy
expr_stmt|;
block|}
else|else
name|modified_name
operator|=
operator|(
name|char
operator|*
operator|)
name|name
expr_stmt|;
comment|/* If we are using C++ language, demangle the name before doing a lookup, so      we can always binary search. */
if|if
condition|(
name|current_language
operator|->
name|la_language
operator|==
name|language_cplus
condition|)
block|{
name|modified_name2
operator|=
name|cplus_demangle
argument_list|(
name|modified_name
argument_list|,
name|DMGL_ANSI
operator||
name|DMGL_PARAMS
argument_list|)
expr_stmt|;
if|if
condition|(
name|modified_name2
condition|)
block|{
name|modified_name
operator|=
name|modified_name2
expr_stmt|;
name|needtofreename
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|returnval
operator|=
name|lookup_symbol_aux
argument_list|(
name|modified_name
argument_list|,
name|block
argument_list|,
name|namespace
argument_list|,
name|is_a_field_of_this
argument_list|,
name|symtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|needtofreename
condition|)
name|xfree
argument_list|(
name|modified_name2
argument_list|)
expr_stmt|;
return|return
name|returnval
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|symbol
modifier|*
name|lookup_symbol_aux
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|struct
name|block
modifier|*
name|block
parameter_list|,
specifier|const
name|namespace_enum
name|namespace
parameter_list|,
name|int
modifier|*
name|is_a_field_of_this
parameter_list|,
name|struct
name|symtab
modifier|*
modifier|*
name|symtab
parameter_list|)
block|{
specifier|register
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
specifier|register
name|struct
name|symtab
modifier|*
name|s
init|=
name|NULL
decl_stmt|;
specifier|register
name|struct
name|partial_symtab
modifier|*
name|ps
decl_stmt|;
specifier|register
name|struct
name|blockvector
modifier|*
name|bv
decl_stmt|;
specifier|register
name|struct
name|objfile
modifier|*
name|objfile
init|=
name|NULL
decl_stmt|;
specifier|register
name|struct
name|block
modifier|*
name|b
decl_stmt|;
specifier|register
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
comment|/* Search specified block and its superiors.  */
while|while
condition|(
name|block
operator|!=
literal|0
condition|)
block|{
name|sym
operator|=
name|lookup_block_symbol
argument_list|(
name|block
argument_list|,
name|name
argument_list|,
name|namespace
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
condition|)
block|{
name|block_found
operator|=
name|block
expr_stmt|;
if|if
condition|(
name|symtab
operator|!=
name|NULL
condition|)
block|{
comment|/* Search the list of symtabs for one which contains the 	         address of the start of this block.  */
name|ALL_SYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
block|{
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|b
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|BLOCK_START
argument_list|(
name|b
argument_list|)
operator|<=
name|BLOCK_START
argument_list|(
name|block
argument_list|)
operator|&&
name|BLOCK_END
argument_list|(
name|b
argument_list|)
operator|>
name|BLOCK_START
argument_list|(
name|block
argument_list|)
condition|)
goto|goto
name|found
goto|;
block|}
name|found
label|:
operator|*
name|symtab
operator|=
name|s
expr_stmt|;
block|}
return|return
name|fixup_symbol_section
argument_list|(
name|sym
argument_list|,
name|objfile
argument_list|)
return|;
block|}
name|block
operator|=
name|BLOCK_SUPERBLOCK
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
comment|/* FIXME: this code is never executed--block is always NULL at this      point.  What is it trying to do, anyway?  We already should have      checked the STATIC_BLOCK above (it is the superblock of top-level      blocks).  Why is VAR_NAMESPACE special-cased?  */
comment|/* Don't need to mess with the psymtabs; if we have a block,      that file is read in.  If we don't, then we deal later with      all the psymtab stuff that needs checking.  */
comment|/* Note (RT): The following never-executed code looks unnecessary to me also.    * If we change the code to use the original (passed-in)    * value of 'block', we could cause it to execute, but then what    * would it do? The STATIC_BLOCK of the symtab containing the passed-in    * 'block' was already searched by the above code. And the STATIC_BLOCK's    * of *other* symtabs (those files not containing 'block' lexically)    * should not contain 'block' address-wise. So we wouldn't expect this    * code to find any 'sym''s that were not found above. I vote for     * deleting the following paragraph of code.    */
if|if
condition|(
name|namespace
operator|==
name|VAR_NAMESPACE
operator|&&
name|block
operator|!=
name|NULL
condition|)
block|{
name|struct
name|block
modifier|*
name|b
decl_stmt|;
comment|/* Find the right symtab.  */
name|ALL_SYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
block|{
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|b
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|STATIC_BLOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|BLOCK_START
argument_list|(
name|b
argument_list|)
operator|<=
name|BLOCK_START
argument_list|(
name|block
argument_list|)
operator|&&
name|BLOCK_END
argument_list|(
name|b
argument_list|)
operator|>
name|BLOCK_START
argument_list|(
name|block
argument_list|)
condition|)
block|{
name|sym
operator|=
name|lookup_block_symbol
argument_list|(
name|b
argument_list|,
name|name
argument_list|,
name|VAR_NAMESPACE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
condition|)
block|{
name|block_found
operator|=
name|b
expr_stmt|;
if|if
condition|(
name|symtab
operator|!=
name|NULL
condition|)
operator|*
name|symtab
operator|=
name|s
expr_stmt|;
return|return
name|fixup_symbol_section
argument_list|(
name|sym
argument_list|,
name|objfile
argument_list|)
return|;
block|}
block|}
block|}
block|}
comment|/* C++: If requested to do so by the caller,       check to see if NAME is a field of `this'. */
if|if
condition|(
name|is_a_field_of_this
condition|)
block|{
name|struct
name|value
modifier|*
name|v
init|=
name|value_of_this
argument_list|(
literal|0
argument_list|)
decl_stmt|;
operator|*
name|is_a_field_of_this
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|v
operator|&&
name|check_field
argument_list|(
name|v
argument_list|,
name|name
argument_list|)
condition|)
block|{
operator|*
name|is_a_field_of_this
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|symtab
operator|!=
name|NULL
condition|)
operator|*
name|symtab
operator|=
name|NULL
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
comment|/* Now search all global blocks.  Do the symtab's first, then      check the psymtab's. If a psymtab indicates the existence      of the desired name as a global, then do psymtab-to-symtab      conversion on the fly and return the found symbol. */
name|ALL_SYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
block|{
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|block
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
expr_stmt|;
name|sym
operator|=
name|lookup_block_symbol
argument_list|(
name|block
argument_list|,
name|name
argument_list|,
name|namespace
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
condition|)
block|{
name|block_found
operator|=
name|block
expr_stmt|;
if|if
condition|(
name|symtab
operator|!=
name|NULL
condition|)
operator|*
name|symtab
operator|=
name|s
expr_stmt|;
return|return
name|fixup_symbol_section
argument_list|(
name|sym
argument_list|,
name|objfile
argument_list|)
return|;
block|}
block|}
ifndef|#
directive|ifndef
name|HPUXHPPA
comment|/* Check for the possibility of the symbol being a function or      a mangled variable that is stored in one of the minimal symbol tables.      Eventually, all global symbols might be resolved in this way.  */
if|if
condition|(
name|namespace
operator|==
name|VAR_NAMESPACE
condition|)
block|{
name|msymbol
operator|=
name|lookup_minimal_symbol
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|msymbol
operator|!=
name|NULL
condition|)
block|{
name|s
operator|=
name|find_pc_sect_symtab
argument_list|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
argument_list|,
name|SYMBOL_BFD_SECTION
argument_list|(
name|msymbol
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
comment|/* This is a function which has a symtab for its address.  */
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|block
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
expr_stmt|;
name|sym
operator|=
name|lookup_block_symbol
argument_list|(
name|block
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|msymbol
argument_list|)
argument_list|,
name|namespace
argument_list|)
expr_stmt|;
comment|/* We kept static functions in minimal symbol table as well as 	         in static scope. We want to find them in the symbol table. */
if|if
condition|(
operator|!
name|sym
condition|)
block|{
name|block
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|STATIC_BLOCK
argument_list|)
expr_stmt|;
name|sym
operator|=
name|lookup_block_symbol
argument_list|(
name|block
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|msymbol
argument_list|)
argument_list|,
name|namespace
argument_list|)
expr_stmt|;
block|}
comment|/* sym == 0 if symbol was found in the minimal symbol table 	         but not in the symtab. 	         Return 0 to use the msymbol definition of "foo_".  	         This happens for Fortran  "foo_" symbols, 	         which are "foo" in the symtab.  	         This can also happen if "asm" is used to make a 	         regular symbol but not a debugging symbol, e.g. 	         asm(".globl _main"); 	         asm("_main:"); 	       */
if|if
condition|(
name|symtab
operator|!=
name|NULL
condition|)
operator|*
name|symtab
operator|=
name|s
expr_stmt|;
return|return
name|fixup_symbol_section
argument_list|(
name|sym
argument_list|,
name|objfile
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|MSYMBOL_TYPE
argument_list|(
name|msymbol
argument_list|)
operator|!=
name|mst_text
operator|&&
name|MSYMBOL_TYPE
argument_list|(
name|msymbol
argument_list|)
operator|!=
name|mst_file_text
operator|&&
operator|!
name|STREQ
argument_list|(
name|name
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|msymbol
argument_list|)
argument_list|)
condition|)
block|{
comment|/* This is a mangled variable, look it up by its 	         mangled name.  */
return|return
name|lookup_symbol_aux
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|msymbol
argument_list|)
argument_list|,
name|block
argument_list|,
name|namespace
argument_list|,
name|is_a_field_of_this
argument_list|,
name|symtab
argument_list|)
return|;
block|}
comment|/* There are no debug symbols for this file, or we are looking 	     for an unmangled variable. 	     Try to find a matching static symbol below. */
block|}
block|}
endif|#
directive|endif
name|ALL_PSYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|ps
argument_list|)
block|{
if|if
condition|(
operator|!
name|ps
operator|->
name|readin
operator|&&
name|lookup_partial_symbol
argument_list|(
name|ps
argument_list|,
name|name
argument_list|,
literal|1
argument_list|,
name|namespace
argument_list|)
condition|)
block|{
name|s
operator|=
name|PSYMTAB_TO_SYMTAB
argument_list|(
name|ps
argument_list|)
expr_stmt|;
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|block
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
expr_stmt|;
name|sym
operator|=
name|lookup_block_symbol
argument_list|(
name|block
argument_list|,
name|name
argument_list|,
name|namespace
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sym
condition|)
block|{
comment|/* This shouldn't be necessary, but as a last resort 	     * try looking in the statics even though the psymtab 	     * claimed the symbol was global. It's possible that 	     * the psymtab gets it wrong in some cases. 	     */
name|block
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|STATIC_BLOCK
argument_list|)
expr_stmt|;
name|sym
operator|=
name|lookup_block_symbol
argument_list|(
name|block
argument_list|,
name|name
argument_list|,
name|namespace
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sym
condition|)
name|error
argument_list|(
literal|"Internal: global symbol `%s' found in %s psymtab but not in symtab.\n\ %s may be an inlined function, or may be a template function\n\ (if a template, try specifying an instantiation: %s<type>)."
argument_list|,
name|name
argument_list|,
name|ps
operator|->
name|filename
argument_list|,
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|symtab
operator|!=
name|NULL
condition|)
operator|*
name|symtab
operator|=
name|s
expr_stmt|;
return|return
name|fixup_symbol_section
argument_list|(
name|sym
argument_list|,
name|objfile
argument_list|)
return|;
block|}
block|}
comment|/* Now search all static file-level symbols.      Not strictly correct, but more useful than an error.      Do the symtabs first, then check the psymtabs.      If a psymtab indicates the existence      of the desired name as a file-level static, then do psymtab-to-symtab      conversion on the fly and return the found symbol. */
name|ALL_SYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
block|{
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|block
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|STATIC_BLOCK
argument_list|)
expr_stmt|;
name|sym
operator|=
name|lookup_block_symbol
argument_list|(
name|block
argument_list|,
name|name
argument_list|,
name|namespace
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
condition|)
block|{
name|block_found
operator|=
name|block
expr_stmt|;
if|if
condition|(
name|symtab
operator|!=
name|NULL
condition|)
operator|*
name|symtab
operator|=
name|s
expr_stmt|;
return|return
name|fixup_symbol_section
argument_list|(
name|sym
argument_list|,
name|objfile
argument_list|)
return|;
block|}
block|}
name|ALL_PSYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|ps
argument_list|)
block|{
if|if
condition|(
operator|!
name|ps
operator|->
name|readin
operator|&&
name|lookup_partial_symbol
argument_list|(
name|ps
argument_list|,
name|name
argument_list|,
literal|0
argument_list|,
name|namespace
argument_list|)
condition|)
block|{
name|s
operator|=
name|PSYMTAB_TO_SYMTAB
argument_list|(
name|ps
argument_list|)
expr_stmt|;
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|block
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|STATIC_BLOCK
argument_list|)
expr_stmt|;
name|sym
operator|=
name|lookup_block_symbol
argument_list|(
name|block
argument_list|,
name|name
argument_list|,
name|namespace
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sym
condition|)
block|{
comment|/* This shouldn't be necessary, but as a last resort 	     * try looking in the globals even though the psymtab 	     * claimed the symbol was static. It's possible that 	     * the psymtab gets it wrong in some cases. 	     */
name|block
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
expr_stmt|;
name|sym
operator|=
name|lookup_block_symbol
argument_list|(
name|block
argument_list|,
name|name
argument_list|,
name|namespace
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sym
condition|)
name|error
argument_list|(
literal|"Internal: static symbol `%s' found in %s psymtab but not in symtab.\n\ %s may be an inlined function, or may be a template function\n\ (if a template, try specifying an instantiation: %s<type>)."
argument_list|,
name|name
argument_list|,
name|ps
operator|->
name|filename
argument_list|,
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|symtab
operator|!=
name|NULL
condition|)
operator|*
name|symtab
operator|=
name|s
expr_stmt|;
return|return
name|fixup_symbol_section
argument_list|(
name|sym
argument_list|,
name|objfile
argument_list|)
return|;
block|}
block|}
ifdef|#
directive|ifdef
name|HPUXHPPA
comment|/* Check for the possibility of the symbol being a function or      a global variable that is stored in one of the minimal symbol tables.      The "minimal symbol table" is built from linker-supplied info.       RT: I moved this check to last, after the complete search of      the global (p)symtab's and static (p)symtab's. For HP-generated      symbol tables, this check was causing a premature exit from      lookup_symbol with NULL return, and thus messing up symbol lookups      of things like "c::f". It seems to me a check of the minimal      symbol table ought to be a last resort in any case. I'm vaguely      worried about the comment below which talks about FORTRAN routines "foo_"      though... is it saying we need to do the "minsym" check before      the static check in this case?     */
if|if
condition|(
name|namespace
operator|==
name|VAR_NAMESPACE
condition|)
block|{
name|msymbol
operator|=
name|lookup_minimal_symbol
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|msymbol
operator|!=
name|NULL
condition|)
block|{
comment|/* OK, we found a minimal symbol in spite of not 	   * finding any symbol. There are various possible 	   * explanations for this. One possibility is the symbol 	   * exists in code not compiled -g. Another possibility 	   * is that the 'psymtab' isn't doing its job. 	   * A third possibility, related to #2, is that we were confused  	   * by name-mangling. For instance, maybe the psymtab isn't 	   * doing its job because it only know about demangled 	   * names, but we were given a mangled name... 	   */
comment|/* We first use the address in the msymbol to try to 	   * locate the appropriate symtab. Note that find_pc_symtab() 	   * has a side-effect of doing psymtab-to-symtab expansion, 	   * for the found symtab. 	   */
name|s
operator|=
name|find_pc_symtab
argument_list|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|block
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
expr_stmt|;
name|sym
operator|=
name|lookup_block_symbol
argument_list|(
name|block
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|msymbol
argument_list|)
argument_list|,
name|namespace
argument_list|)
expr_stmt|;
comment|/* We kept static functions in minimal symbol table as well as 	         in static scope. We want to find them in the symbol table. */
if|if
condition|(
operator|!
name|sym
condition|)
block|{
name|block
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|STATIC_BLOCK
argument_list|)
expr_stmt|;
name|sym
operator|=
name|lookup_block_symbol
argument_list|(
name|block
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|msymbol
argument_list|)
argument_list|,
name|namespace
argument_list|)
expr_stmt|;
block|}
comment|/* If we found one, return it */
if|if
condition|(
name|sym
condition|)
block|{
if|if
condition|(
name|symtab
operator|!=
name|NULL
condition|)
operator|*
name|symtab
operator|=
name|s
expr_stmt|;
return|return
name|sym
return|;
block|}
comment|/* If we get here with sym == 0, the symbol was  	         found in the minimal symbol table 	         but not in the symtab. 	         Fall through and return 0 to use the msymbol  	         definition of "foo_". 	         (Note that outer code generally follows up a call 	         to this routine with a call to lookup_minimal_symbol(), 	         so a 0 return means we'll just flow into that other routine).  	         This happens for Fortran  "foo_" symbols, 	         which are "foo" in the symtab.  	         This can also happen if "asm" is used to make a 	         regular symbol but not a debugging symbol, e.g. 	         asm(".globl _main"); 	         asm("_main:"); 	       */
block|}
comment|/* If the lookup-by-address fails, try repeating the 	   * entire lookup process with the symbol name from 	   * the msymbol (if different from the original symbol name). 	   */
elseif|else
if|if
condition|(
name|MSYMBOL_TYPE
argument_list|(
name|msymbol
argument_list|)
operator|!=
name|mst_text
operator|&&
name|MSYMBOL_TYPE
argument_list|(
name|msymbol
argument_list|)
operator|!=
name|mst_file_text
operator|&&
operator|!
name|STREQ
argument_list|(
name|name
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|msymbol
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|lookup_symbol_aux
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|msymbol
argument_list|)
argument_list|,
name|block
argument_list|,
name|namespace
argument_list|,
name|is_a_field_of_this
argument_list|,
name|symtab
argument_list|)
return|;
block|}
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|symtab
operator|!=
name|NULL
condition|)
operator|*
name|symtab
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Look, in partial_symtab PST, for symbol NAME.  Check the global    symbols if GLOBAL, the static symbols if not */
end_comment

begin_function
specifier|static
name|struct
name|partial_symbol
modifier|*
name|lookup_partial_symbol
parameter_list|(
name|struct
name|partial_symtab
modifier|*
name|pst
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|global
parameter_list|,
name|namespace_enum
name|namespace
parameter_list|)
block|{
name|struct
name|partial_symbol
modifier|*
name|temp
decl_stmt|;
name|struct
name|partial_symbol
modifier|*
modifier|*
name|start
decl_stmt|,
modifier|*
modifier|*
name|psym
decl_stmt|;
name|struct
name|partial_symbol
modifier|*
modifier|*
name|top
decl_stmt|,
modifier|*
modifier|*
name|bottom
decl_stmt|,
modifier|*
modifier|*
name|center
decl_stmt|;
name|int
name|length
init|=
operator|(
name|global
condition|?
name|pst
operator|->
name|n_global_syms
else|:
name|pst
operator|->
name|n_static_syms
operator|)
decl_stmt|;
name|int
name|do_linear_search
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|length
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|start
operator|=
operator|(
name|global
condition|?
name|pst
operator|->
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
operator|+
name|pst
operator|->
name|globals_offset
else|:
name|pst
operator|->
name|objfile
operator|->
name|static_psymbols
operator|.
name|list
operator|+
name|pst
operator|->
name|statics_offset
operator|)
expr_stmt|;
if|if
condition|(
name|global
condition|)
comment|/* This means we can use a binary search. */
block|{
name|do_linear_search
operator|=
literal|0
expr_stmt|;
comment|/* Binary search.  This search is guaranteed to end with center          pointing at the earliest partial symbol with the correct          name.  At that point *all* partial symbols with that name          will be checked against the correct namespace. */
name|bottom
operator|=
name|start
expr_stmt|;
name|top
operator|=
name|start
operator|+
name|length
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|top
operator|>
name|bottom
condition|)
block|{
name|center
operator|=
name|bottom
operator|+
operator|(
name|top
operator|-
name|bottom
operator|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|center
operator|<
name|top
operator|)
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"failed internal consistency check"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|do_linear_search
operator|&&
operator|(
name|SYMBOL_LANGUAGE
argument_list|(
operator|*
name|center
argument_list|)
operator|==
name|language_java
operator|)
condition|)
block|{
name|do_linear_search
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|SYMBOL_SOURCE_NAME
argument_list|(
operator|*
name|center
argument_list|)
argument_list|,
name|name
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|top
operator|=
name|center
expr_stmt|;
block|}
else|else
block|{
name|bottom
operator|=
name|center
operator|+
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|top
operator|==
name|bottom
operator|)
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"failed internal consistency check"
argument_list|)
expr_stmt|;
comment|/* djb - 2000-06-03 - Use SYMBOL_MATCHES_NAME, not a strcmp, so 	 we don't have to force a linear search on C++. Probably holds true 	 for JAVA as well, no way to check.*/
while|while
condition|(
name|SYMBOL_MATCHES_NAME
argument_list|(
operator|*
name|top
argument_list|,
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
name|SYMBOL_NAMESPACE
argument_list|(
operator|*
name|top
argument_list|)
operator|==
name|namespace
condition|)
block|{
return|return
operator|(
operator|*
name|top
operator|)
return|;
block|}
name|top
operator|++
expr_stmt|;
block|}
block|}
comment|/* Can't use a binary search or else we found during the binary search that      we should also do a linear search. */
if|if
condition|(
name|do_linear_search
condition|)
block|{
for|for
control|(
name|psym
operator|=
name|start
init|;
name|psym
operator|<
name|start
operator|+
name|length
condition|;
name|psym
operator|++
control|)
block|{
if|if
condition|(
name|namespace
operator|==
name|SYMBOL_NAMESPACE
argument_list|(
operator|*
name|psym
argument_list|)
condition|)
block|{
if|if
condition|(
name|SYMBOL_MATCHES_NAME
argument_list|(
operator|*
name|psym
argument_list|,
name|name
argument_list|)
condition|)
block|{
return|return
operator|(
operator|*
name|psym
operator|)
return|;
block|}
block|}
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Look up a type named NAME in the struct_namespace.  The type returned    must not be opaque -- i.e., must have at least one field defined     This code was modelled on lookup_symbol -- the parts not relevant to looking    up types were just left out.  In particular it's assumed here that types    are available in struct_namespace and only at file-static or global blocks. */
end_comment

begin_function
name|struct
name|type
modifier|*
name|lookup_transparent_type
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|register
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
specifier|register
name|struct
name|symtab
modifier|*
name|s
init|=
name|NULL
decl_stmt|;
specifier|register
name|struct
name|partial_symtab
modifier|*
name|ps
decl_stmt|;
name|struct
name|blockvector
modifier|*
name|bv
decl_stmt|;
specifier|register
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
specifier|register
name|struct
name|block
modifier|*
name|block
decl_stmt|;
comment|/* Now search all the global symbols.  Do the symtab's first, then      check the psymtab's. If a psymtab indicates the existence      of the desired name as a global, then do psymtab-to-symtab      conversion on the fly and return the found symbol.  */
name|ALL_SYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
block|{
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|block
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
expr_stmt|;
name|sym
operator|=
name|lookup_block_symbol
argument_list|(
name|block
argument_list|,
name|name
argument_list|,
name|STRUCT_NAMESPACE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|&&
operator|!
name|TYPE_IS_OPAQUE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
return|;
block|}
block|}
name|ALL_PSYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|ps
argument_list|)
block|{
if|if
condition|(
operator|!
name|ps
operator|->
name|readin
operator|&&
name|lookup_partial_symbol
argument_list|(
name|ps
argument_list|,
name|name
argument_list|,
literal|1
argument_list|,
name|STRUCT_NAMESPACE
argument_list|)
condition|)
block|{
name|s
operator|=
name|PSYMTAB_TO_SYMTAB
argument_list|(
name|ps
argument_list|)
expr_stmt|;
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|block
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
expr_stmt|;
name|sym
operator|=
name|lookup_block_symbol
argument_list|(
name|block
argument_list|,
name|name
argument_list|,
name|STRUCT_NAMESPACE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sym
condition|)
block|{
comment|/* This shouldn't be necessary, but as a last resort 	     * try looking in the statics even though the psymtab 	     * claimed the symbol was global. It's possible that 	     * the psymtab gets it wrong in some cases. 	     */
name|block
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|STATIC_BLOCK
argument_list|)
expr_stmt|;
name|sym
operator|=
name|lookup_block_symbol
argument_list|(
name|block
argument_list|,
name|name
argument_list|,
name|STRUCT_NAMESPACE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sym
condition|)
name|error
argument_list|(
literal|"Internal: global symbol `%s' found in %s psymtab but not in symtab.\n\ %s may be an inlined function, or may be a template function\n\ (if a template, try specifying an instantiation: %s<type>)."
argument_list|,
name|name
argument_list|,
name|ps
operator|->
name|filename
argument_list|,
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|TYPE_IS_OPAQUE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
condition|)
return|return
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
return|;
block|}
block|}
comment|/* Now search the static file-level symbols.      Not strictly correct, but more useful than an error.      Do the symtab's first, then      check the psymtab's. If a psymtab indicates the existence      of the desired name as a file-level static, then do psymtab-to-symtab      conversion on the fly and return the found symbol.    */
name|ALL_SYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
block|{
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|block
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|STATIC_BLOCK
argument_list|)
expr_stmt|;
name|sym
operator|=
name|lookup_block_symbol
argument_list|(
name|block
argument_list|,
name|name
argument_list|,
name|STRUCT_NAMESPACE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|&&
operator|!
name|TYPE_IS_OPAQUE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
return|;
block|}
block|}
name|ALL_PSYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|ps
argument_list|)
block|{
if|if
condition|(
operator|!
name|ps
operator|->
name|readin
operator|&&
name|lookup_partial_symbol
argument_list|(
name|ps
argument_list|,
name|name
argument_list|,
literal|0
argument_list|,
name|STRUCT_NAMESPACE
argument_list|)
condition|)
block|{
name|s
operator|=
name|PSYMTAB_TO_SYMTAB
argument_list|(
name|ps
argument_list|)
expr_stmt|;
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|block
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|STATIC_BLOCK
argument_list|)
expr_stmt|;
name|sym
operator|=
name|lookup_block_symbol
argument_list|(
name|block
argument_list|,
name|name
argument_list|,
name|STRUCT_NAMESPACE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sym
condition|)
block|{
comment|/* This shouldn't be necessary, but as a last resort 	     * try looking in the globals even though the psymtab 	     * claimed the symbol was static. It's possible that 	     * the psymtab gets it wrong in some cases. 	     */
name|block
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
expr_stmt|;
name|sym
operator|=
name|lookup_block_symbol
argument_list|(
name|block
argument_list|,
name|name
argument_list|,
name|STRUCT_NAMESPACE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sym
condition|)
name|error
argument_list|(
literal|"Internal: static symbol `%s' found in %s psymtab but not in symtab.\n\ %s may be an inlined function, or may be a template function\n\ (if a template, try specifying an instantiation: %s<type>)."
argument_list|,
name|name
argument_list|,
name|ps
operator|->
name|filename
argument_list|,
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|TYPE_IS_OPAQUE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
condition|)
return|return
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
return|;
block|}
block|}
return|return
operator|(
expr|struct
name|type
operator|*
operator|)
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Find the psymtab containing main(). */
end_comment

begin_comment
comment|/* FIXME:  What about languages without main() or specially linked    executables that have no main() ? */
end_comment

begin_function
name|struct
name|partial_symtab
modifier|*
name|find_main_psymtab
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
specifier|register
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|ALL_PSYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|pst
argument_list|)
block|{
if|if
condition|(
name|lookup_partial_symbol
argument_list|(
name|pst
argument_list|,
name|main_name
argument_list|()
argument_list|,
literal|1
argument_list|,
name|VAR_NAMESPACE
argument_list|)
condition|)
block|{
return|return
operator|(
name|pst
operator|)
return|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Search BLOCK for symbol NAME in NAMESPACE.     Note that if NAME is the demangled form of a C++ symbol, we will fail    to find a match during the binary search of the non-encoded names, but    for now we don't worry about the slight inefficiency of looking for    a match we'll never find, since it will go pretty quick.  Once the    binary search terminates, we drop through and do a straight linear    search on the symbols.  Each symbol which is marked as being a C++    symbol (language_cplus set) has both the encoded and non-encoded names    tested for a match. */
end_comment

begin_function
name|struct
name|symbol
modifier|*
name|lookup_block_symbol
parameter_list|(
specifier|register
specifier|const
name|struct
name|block
modifier|*
name|block
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|namespace_enum
name|namespace
parameter_list|)
block|{
specifier|register
name|int
name|bot
decl_stmt|,
name|top
decl_stmt|,
name|inc
decl_stmt|;
specifier|register
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
specifier|register
name|struct
name|symbol
modifier|*
name|sym_found
init|=
name|NULL
decl_stmt|;
specifier|register
name|int
name|do_linear_search
init|=
literal|1
decl_stmt|;
comment|/* If the blocks's symbols were sorted, start with a binary search.  */
if|if
condition|(
name|BLOCK_SHOULD_SORT
argument_list|(
name|block
argument_list|)
condition|)
block|{
comment|/* Reset the linear search flag so if the binary search fails, we          won't do the linear search once unless we find some reason to          do so */
name|do_linear_search
operator|=
literal|0
expr_stmt|;
name|top
operator|=
name|BLOCK_NSYMS
argument_list|(
name|block
argument_list|)
expr_stmt|;
name|bot
operator|=
literal|0
expr_stmt|;
comment|/* Advance BOT to not far before the first symbol whose name is NAME. */
while|while
condition|(
literal|1
condition|)
block|{
name|inc
operator|=
operator|(
name|top
operator|-
name|bot
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* No need to keep binary searching for the last few bits worth.  */
if|if
condition|(
name|inc
operator|<
literal|4
condition|)
block|{
break|break;
block|}
name|inc
operator|=
operator|(
name|inc
operator|>>
literal|1
operator|)
operator|+
name|bot
expr_stmt|;
name|sym
operator|=
name|BLOCK_SYM
argument_list|(
name|block
argument_list|,
name|inc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|do_linear_search
operator|&&
operator|(
name|SYMBOL_LANGUAGE
argument_list|(
name|sym
argument_list|)
operator|==
name|language_java
operator|)
condition|)
block|{
name|do_linear_search
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|SYMBOL_SOURCE_NAME
argument_list|(
name|sym
argument_list|)
index|[
literal|0
index|]
operator|<
name|name
index|[
literal|0
index|]
condition|)
block|{
name|bot
operator|=
name|inc
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SYMBOL_SOURCE_NAME
argument_list|(
name|sym
argument_list|)
index|[
literal|0
index|]
operator|>
name|name
index|[
literal|0
index|]
condition|)
block|{
name|top
operator|=
name|inc
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|SYMBOL_SOURCE_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|name
argument_list|)
operator|<
literal|0
condition|)
block|{
name|bot
operator|=
name|inc
expr_stmt|;
block|}
else|else
block|{
name|top
operator|=
name|inc
expr_stmt|;
block|}
block|}
comment|/* Now scan forward until we run out of symbols, find one whose          name is greater than NAME, or find one we want.  If there is          more than one symbol with the right name and namespace, we          return the first one; I believe it is now impossible for us          to encounter two symbols with the same name and namespace          here, because blocks containing argument symbols are no          longer sorted.  */
name|top
operator|=
name|BLOCK_NSYMS
argument_list|(
name|block
argument_list|)
expr_stmt|;
while|while
condition|(
name|bot
operator|<
name|top
condition|)
block|{
name|sym
operator|=
name|BLOCK_SYM
argument_list|(
name|block
argument_list|,
name|bot
argument_list|)
expr_stmt|;
if|if
condition|(
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|==
name|namespace
operator|&&
name|SYMBOL_MATCHES_NAME
argument_list|(
name|sym
argument_list|,
name|name
argument_list|)
condition|)
block|{
return|return
name|sym
return|;
block|}
if|if
condition|(
name|SYMBOL_SOURCE_NAME
argument_list|(
name|sym
argument_list|)
index|[
literal|0
index|]
operator|>
name|name
index|[
literal|0
index|]
condition|)
block|{
break|break;
block|}
name|bot
operator|++
expr_stmt|;
block|}
block|}
comment|/* Here if block isn't sorted, or we fail to find a match during the      binary search above.  If during the binary search above, we find a      symbol which is a Java symbol, then we have re-enabled the linear      search flag which was reset when starting the binary search.       This loop is equivalent to the loop above, but hacked greatly for speed.       Note that parameter symbols do not always show up last in the      list; this loop makes sure to take anything else other than      parameter symbols first; it only uses parameter symbols as a      last resort.  Note that this only takes up extra computation      time on a match.  */
if|if
condition|(
name|do_linear_search
condition|)
block|{
name|top
operator|=
name|BLOCK_NSYMS
argument_list|(
name|block
argument_list|)
expr_stmt|;
name|bot
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|bot
operator|<
name|top
condition|)
block|{
name|sym
operator|=
name|BLOCK_SYM
argument_list|(
name|block
argument_list|,
name|bot
argument_list|)
expr_stmt|;
if|if
condition|(
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|==
name|namespace
operator|&&
name|SYMBOL_MATCHES_NAME
argument_list|(
name|sym
argument_list|,
name|name
argument_list|)
condition|)
block|{
comment|/* If SYM has aliases, then use any alias that is active 	         at the current PC.  If no alias is active at the current 	         PC, then use the main symbol.  	         ?!? Is checking the current pc correct?  Is this routine 	         ever called to look up a symbol from another context?  		 FIXME: No, it's not correct.  If someone sets a 		 conditional breakpoint at an address, then the 		 breakpoint's `struct expression' should refer to the 		 `struct symbol' appropriate for the breakpoint's 		 address, which may not be the PC.  		 Even if it were never called from another context, 		 it's totally bizarre for lookup_symbol's behavior to 		 depend on the value of the inferior's current PC.  We 		 should pass in the appropriate PC as well as the 		 block.  The interface to lookup_symbol should change 		 to require the caller to provide a PC.  */
if|if
condition|(
name|SYMBOL_ALIASES
argument_list|(
name|sym
argument_list|)
condition|)
name|sym
operator|=
name|find_active_alias
argument_list|(
name|sym
argument_list|,
name|read_pc
argument_list|()
argument_list|)
expr_stmt|;
name|sym_found
operator|=
name|sym
expr_stmt|;
if|if
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|!=
name|LOC_ARG
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|!=
name|LOC_LOCAL_ARG
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|!=
name|LOC_REF_ARG
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|!=
name|LOC_REGPARM
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|!=
name|LOC_REGPARM_ADDR
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|!=
name|LOC_BASEREG_ARG
condition|)
block|{
break|break;
block|}
block|}
name|bot
operator|++
expr_stmt|;
block|}
block|}
return|return
operator|(
name|sym_found
operator|)
return|;
comment|/* Will be NULL if not found. */
block|}
end_function

begin_comment
comment|/* Given a main symbol SYM and ADDR, search through the alias    list to determine if an alias is active at ADDR and return    the active alias.     If no alias is active, then return SYM.  */
end_comment

begin_function
specifier|static
name|struct
name|symbol
modifier|*
name|find_active_alias
parameter_list|(
name|struct
name|symbol
modifier|*
name|sym
parameter_list|,
name|CORE_ADDR
name|addr
parameter_list|)
block|{
name|struct
name|range_list
modifier|*
name|r
decl_stmt|;
name|struct
name|alias_list
modifier|*
name|aliases
decl_stmt|;
comment|/* If we have aliases, check them first.  */
name|aliases
operator|=
name|SYMBOL_ALIASES
argument_list|(
name|sym
argument_list|)
expr_stmt|;
while|while
condition|(
name|aliases
condition|)
block|{
if|if
condition|(
operator|!
name|SYMBOL_RANGES
argument_list|(
name|aliases
operator|->
name|sym
argument_list|)
condition|)
return|return
name|aliases
operator|->
name|sym
return|;
for|for
control|(
name|r
operator|=
name|SYMBOL_RANGES
argument_list|(
name|aliases
operator|->
name|sym
argument_list|)
init|;
name|r
condition|;
name|r
operator|=
name|r
operator|->
name|next
control|)
block|{
if|if
condition|(
name|r
operator|->
name|start
operator|<=
name|addr
operator|&&
name|r
operator|->
name|end
operator|>
name|addr
condition|)
return|return
name|aliases
operator|->
name|sym
return|;
block|}
name|aliases
operator|=
name|aliases
operator|->
name|next
expr_stmt|;
block|}
comment|/* Nothing found, return the main symbol.  */
return|return
name|sym
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the symbol for the function which contains a specified    lexical block, described by a struct block BL.  */
end_comment

begin_function
name|struct
name|symbol
modifier|*
name|block_function
parameter_list|(
name|struct
name|block
modifier|*
name|bl
parameter_list|)
block|{
while|while
condition|(
name|BLOCK_FUNCTION
argument_list|(
name|bl
argument_list|)
operator|==
literal|0
operator|&&
name|BLOCK_SUPERBLOCK
argument_list|(
name|bl
argument_list|)
operator|!=
literal|0
condition|)
name|bl
operator|=
name|BLOCK_SUPERBLOCK
argument_list|(
name|bl
argument_list|)
expr_stmt|;
return|return
name|BLOCK_FUNCTION
argument_list|(
name|bl
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Find the symtab associated with PC and SECTION.  Look through the    psymtabs and read in another symtab if necessary. */
end_comment

begin_function
name|struct
name|symtab
modifier|*
name|find_pc_sect_symtab
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|asection
modifier|*
name|section
parameter_list|)
block|{
specifier|register
name|struct
name|block
modifier|*
name|b
decl_stmt|;
name|struct
name|blockvector
modifier|*
name|bv
decl_stmt|;
specifier|register
name|struct
name|symtab
modifier|*
name|s
init|=
name|NULL
decl_stmt|;
specifier|register
name|struct
name|symtab
modifier|*
name|best_s
init|=
name|NULL
decl_stmt|;
specifier|register
name|struct
name|partial_symtab
modifier|*
name|ps
decl_stmt|;
specifier|register
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|CORE_ADDR
name|distance
init|=
literal|0
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
comment|/* If we know that this is not a text address, return failure.  This is      necessary because we loop based on the block's high and low code      addresses, which do not include the data ranges, and because      we call find_pc_sect_psymtab which has a similar restriction based      on the partial_symtab's texthigh and textlow.  */
name|msymbol
operator|=
name|lookup_minimal_symbol_by_pc_section
argument_list|(
name|pc
argument_list|,
name|section
argument_list|)
expr_stmt|;
if|if
condition|(
name|msymbol
operator|&&
operator|(
name|msymbol
operator|->
name|type
operator|==
name|mst_data
operator|||
name|msymbol
operator|->
name|type
operator|==
name|mst_bss
operator|||
name|msymbol
operator|->
name|type
operator|==
name|mst_abs
operator|||
name|msymbol
operator|->
name|type
operator|==
name|mst_file_data
operator|||
name|msymbol
operator|->
name|type
operator|==
name|mst_file_bss
operator|)
condition|)
return|return
name|NULL
return|;
comment|/* Search all symtabs for the one whose file contains our address, and which      is the smallest of all the ones containing the address.  This is designed      to deal with a case like symtab a is at 0x1000-0x2000 and 0x3000-0x4000      and symtab b is at 0x2000-0x3000.  So the GLOBAL_BLOCK for a is from      0x1000-0x4000, but for address 0x2345 we want to return symtab b.       This happens for native ecoff format, where code from included files      gets its own symtab. The symtab for the included file should have      been read in already via the dependency mechanism.      It might be swifter to create several symtabs with the same name      like xcoff does (I'm not sure).       It also happens for objfiles that have their functions reordered.      For these, the symtab we are looking for is not necessarily read in.  */
name|ALL_SYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
block|{
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|b
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|BLOCK_START
argument_list|(
name|b
argument_list|)
operator|<=
name|pc
operator|&&
name|BLOCK_END
argument_list|(
name|b
argument_list|)
operator|>
name|pc
operator|&&
operator|(
name|distance
operator|==
literal|0
operator|||
name|BLOCK_END
argument_list|(
name|b
argument_list|)
operator|-
name|BLOCK_START
argument_list|(
name|b
argument_list|)
operator|<
name|distance
operator|)
condition|)
block|{
comment|/* For an objfile that has its functions reordered, 	   find_pc_psymtab will find the proper partial symbol table 	   and we simply return its corresponding symtab.  */
comment|/* In order to better support objfiles that contain both 	   stabs and coff debugging info, we continue on if a psymtab 	   can't be found. */
if|if
condition|(
operator|(
name|objfile
operator|->
name|flags
operator|&
name|OBJF_REORDERED
operator|)
operator|&&
name|objfile
operator|->
name|psymtabs
condition|)
block|{
name|ps
operator|=
name|find_pc_sect_psymtab
argument_list|(
name|pc
argument_list|,
name|section
argument_list|)
expr_stmt|;
if|if
condition|(
name|ps
condition|)
return|return
name|PSYMTAB_TO_SYMTAB
argument_list|(
name|ps
argument_list|)
return|;
block|}
if|if
condition|(
name|section
operator|!=
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|b
operator|->
name|nsyms
condition|;
name|i
operator|++
control|)
block|{
name|fixup_symbol_section
argument_list|(
name|b
operator|->
name|sym
index|[
name|i
index|]
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|section
operator|==
name|SYMBOL_BFD_SECTION
argument_list|(
name|b
operator|->
name|sym
index|[
name|i
index|]
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|>=
name|b
operator|->
name|nsyms
condition|)
continue|continue;
comment|/* no symbol in this symtab matches section */
block|}
name|distance
operator|=
name|BLOCK_END
argument_list|(
name|b
argument_list|)
operator|-
name|BLOCK_START
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|best_s
operator|=
name|s
expr_stmt|;
block|}
block|}
if|if
condition|(
name|best_s
operator|!=
name|NULL
condition|)
return|return
operator|(
name|best_s
operator|)
return|;
name|s
operator|=
name|NULL
expr_stmt|;
name|ps
operator|=
name|find_pc_sect_psymtab
argument_list|(
name|pc
argument_list|,
name|section
argument_list|)
expr_stmt|;
if|if
condition|(
name|ps
condition|)
block|{
if|if
condition|(
name|ps
operator|->
name|readin
condition|)
comment|/* Might want to error() here (in case symtab is corrupt and 	   will cause a core dump), but maybe we can successfully 	   continue, so let's not.  */
name|warning
argument_list|(
literal|"\ (Internal error: pc 0x%s in read in psymtab, but not in symtab.)\n"
argument_list|,
name|paddr_nz
argument_list|(
name|pc
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|PSYMTAB_TO_SYMTAB
argument_list|(
name|ps
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Find the symtab associated with PC.  Look through the psymtabs and    read in another symtab if necessary.  Backward compatibility, no section */
end_comment

begin_function
name|struct
name|symtab
modifier|*
name|find_pc_symtab
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
return|return
name|find_pc_sect_symtab
argument_list|(
name|pc
argument_list|,
name|find_pc_mapped_section
argument_list|(
name|pc
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Find the closest symbol value (of any sort -- function or variable)    for a given address value.  Slow but complete.  (currently unused,    mainly because it is too slow.  We could fix it if each symtab and    psymtab had contained in it the addresses ranges of each of its    sections, which also would be required to make things like "info    line *0x2345" cause psymtabs to be converted to symtabs).  */
end_comment

begin_comment
unit|struct symbol * find_addr_symbol (CORE_ADDR addr, struct symtab **symtabp, CORE_ADDR *symaddrp) {   struct symtab *symtab, *best_symtab;   struct objfile *objfile;   register int bot, top;   register struct symbol *sym;   register CORE_ADDR sym_addr;   struct block *block;   int blocknum;
comment|/* Info on best symbol seen so far */
end_comment

begin_comment
unit|register CORE_ADDR best_sym_addr = 0;   struct symbol *best_sym = 0;
comment|/* FIXME -- we should pull in all the psymtabs, too!  */
end_comment

begin_comment
unit|ALL_SYMTABS (objfile, symtab)   {
comment|/* Search the global and static blocks in this symtab for        the closest symbol-address to the desired address.  */
end_comment

begin_comment
unit|for (blocknum = GLOBAL_BLOCK; blocknum<= STATIC_BLOCK; blocknum++)       { 	QUIT; 	block = BLOCKVECTOR_BLOCK (BLOCKVECTOR (symtab), blocknum); 	top = BLOCK_NSYMS (block); 	for (bot = 0; bot< top; bot++) 	  { 	    sym = BLOCK_SYM (block, bot); 	    switch (SYMBOL_CLASS (sym)) 	      { 	      case LOC_STATIC: 	      case LOC_LABEL: 		sym_addr = SYMBOL_VALUE_ADDRESS (sym); 		break;  	      case LOC_INDIRECT: 		sym_addr = SYMBOL_VALUE_ADDRESS (sym);
comment|/* An indirect symbol really lives at *sym_addr, 		 * so an indirection needs to be done. 		 * However, I am leaving this commented out because it's 		 * expensive, and it's possible that symbolization 		 * could be done without an active process (in 		 * case this read_memory will fail). RT 		 sym_addr = read_memory_unsigned_integer 		 (sym_addr, TARGET_PTR_BIT / TARGET_CHAR_BIT); 		 */
end_comment

begin_comment
unit|break;  	      case LOC_BLOCK: 		sym_addr = BLOCK_START (SYMBOL_BLOCK_VALUE (sym)); 		break;  	      default: 		continue; 	      }  	    if (sym_addr<= addr) 	      if (sym_addr> best_sym_addr) 		{
comment|/* Quit if we found an exact match.  */
end_comment

begin_endif
unit|best_sym = sym; 		  best_sym_addr = sym_addr; 		  best_symtab = symtab; 		  if (sym_addr == addr) 		    goto done; 		} 	  }       }   }  done:   if (symtabp)     *symtabp = best_symtab;   if (symaddrp)     *symaddrp = best_sym_addr;   return best_sym; }
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_comment
comment|/* Find the source file and line number for a given PC value and SECTION.    Return a structure containing a symtab pointer, a line number,    and a pc range for the entire source line.    The value's .pc field is NOT the specified pc.    NOTCURRENT nonzero means, if specified pc is on a line boundary,    use the line that ends there.  Otherwise, in that case, the line    that begins there is used.  */
end_comment

begin_comment
comment|/* The big complication here is that a line may start in one file, and end just    before the start of another file.  This usually occurs when you #include    code in the middle of a subroutine.  To properly find the end of a line's PC    range, we must search all symtabs associated with this compilation unit, and    find the one whose first PC is closer than that of the next line in this    symtab.  */
end_comment

begin_comment
comment|/* If it's worth the effort, we could be using a binary search.  */
end_comment

begin_function
name|struct
name|symtab_and_line
name|find_pc_sect_line
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|struct
name|sec
modifier|*
name|section
parameter_list|,
name|int
name|notcurrent
parameter_list|)
block|{
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
specifier|register
name|struct
name|linetable
modifier|*
name|l
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|linetable_entry
modifier|*
name|item
decl_stmt|;
name|struct
name|symtab_and_line
name|val
decl_stmt|;
name|struct
name|blockvector
modifier|*
name|bv
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|mfunsym
decl_stmt|;
comment|/* Info on best line seen so far, and where it starts, and its file.  */
name|struct
name|linetable_entry
modifier|*
name|best
init|=
name|NULL
decl_stmt|;
name|CORE_ADDR
name|best_end
init|=
literal|0
decl_stmt|;
name|struct
name|symtab
modifier|*
name|best_symtab
init|=
literal|0
decl_stmt|;
comment|/* Store here the first line number      of a file which contains the line at the smallest pc after PC.      If we don't find a line whose range contains PC,      we will use a line one less than this,      with a range from the start of that file to the first line's pc.  */
name|struct
name|linetable_entry
modifier|*
name|alt
init|=
name|NULL
decl_stmt|;
name|struct
name|symtab
modifier|*
name|alt_symtab
init|=
literal|0
decl_stmt|;
comment|/* Info on best line seen in this file.  */
name|struct
name|linetable_entry
modifier|*
name|prev
decl_stmt|;
comment|/* If this pc is not from the current frame,      it is the address of the end of a call instruction.      Quite likely that is the start of the following statement.      But what we want is the statement containing the instruction.      Fudge the pc to make sure we get that.  */
name|INIT_SAL
argument_list|(
operator|&
name|val
argument_list|)
expr_stmt|;
comment|/* initialize to zeroes */
comment|/* It's tempting to assume that, if we can't find debugging info for      any function enclosing PC, that we shouldn't search for line      number info, either.  However, GAS can emit line number info for      assembly files --- very helpful when debugging hand-written      assembly code.  In such a case, we'd have no debug info for the      function, but we would have line info.  */
if|if
condition|(
name|notcurrent
condition|)
name|pc
operator|-=
literal|1
expr_stmt|;
comment|/* elz: added this because this function returned the wrong      information if the pc belongs to a stub (import/export)      to call a shlib function. This stub would be anywhere between      two functions in the target, and the line info was erroneously       taken to be the one of the line before the pc.     */
comment|/* RT: Further explanation:     * We have stubs (trampolines) inserted between procedures.    *    * Example: "shr1" exists in a shared library, and a "shr1" stub also    * exists in the main image.    *    * In the minimal symbol table, we have a bunch of symbols    * sorted by start address. The stubs are marked as "trampoline",    * the others appear as text. E.g.:    *    *  Minimal symbol table for main image     *     main:  code for main (text symbol)    *     shr1: stub  (trampoline symbol)    *     foo:   code for foo (text symbol)    *     ...    *  Minimal symbol table for "shr1" image:    *     ...    *     shr1: code for shr1 (text symbol)    *     ...    *    * So the code below is trying to detect if we are in the stub    * ("shr1" stub), and if so, find the real code ("shr1" trampoline),    * and if found,  do the symbolization from the real-code address    * rather than the stub address.    *    * Assumptions being made about the minimal symbol table:    *   1. lookup_minimal_symbol_by_pc() will return a trampoline only    *      if we're really in the trampoline. If we're beyond it (say    *      we're in "foo" in the above example), it'll have a closer     *      symbol (the "foo" text symbol for example) and will not    *      return the trampoline.    *   2. lookup_minimal_symbol_text() will find a real text symbol    *      corresponding to the trampoline, and whose address will    *      be different than the trampoline address. I put in a sanity    *      check for the address being the same, to avoid an    *      infinite recursion.    */
name|msymbol
operator|=
name|lookup_minimal_symbol_by_pc
argument_list|(
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|msymbol
operator|!=
name|NULL
condition|)
if|if
condition|(
name|MSYMBOL_TYPE
argument_list|(
name|msymbol
argument_list|)
operator|==
name|mst_solib_trampoline
condition|)
block|{
name|mfunsym
operator|=
name|lookup_minimal_symbol_text
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|msymbol
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mfunsym
operator|==
name|NULL
condition|)
comment|/* I eliminated this warning since it is coming out 	   * in the following situation: 	   * gdb shmain // test program with shared libraries 	   * (gdb) break shr1  // function in shared lib 	   * Warning: In stub for ... 	   * In the above situation, the shared lib is not loaded yet,  	   * so of course we can't find the real func/line info, 	   * but the "break" still works, and the warning is annoying. 	   * So I commented out the warning. RT */
comment|/* warning ("In stub for %s; unable to find real function/line info", SYMBOL_NAME(msymbol)) */
empty_stmt|;
comment|/* fall through */
elseif|else
if|if
condition|(
name|SYMBOL_VALUE
argument_list|(
name|mfunsym
argument_list|)
operator|==
name|SYMBOL_VALUE
argument_list|(
name|msymbol
argument_list|)
condition|)
comment|/* Avoid infinite recursion */
comment|/* See above comment about why warning is commented out */
comment|/* warning ("In stub for %s; unable to find real function/line info", SYMBOL_NAME(msymbol)) */
empty_stmt|;
comment|/* fall through */
else|else
return|return
name|find_pc_line
argument_list|(
name|SYMBOL_VALUE
argument_list|(
name|mfunsym
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|s
operator|=
name|find_pc_sect_symtab
argument_list|(
name|pc
argument_list|,
name|section
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
block|{
comment|/* if no symbol information, return previous pc */
if|if
condition|(
name|notcurrent
condition|)
name|pc
operator|++
expr_stmt|;
name|val
operator|.
name|pc
operator|=
name|pc
expr_stmt|;
return|return
name|val
return|;
block|}
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Look at all the symtabs that share this blockvector.      They all have the same apriori range, that we found was right;      but they have different line tables.  */
for|for
control|(
init|;
name|s
operator|&&
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
operator|==
name|bv
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
comment|/* Find the best line in this symtab.  */
name|l
operator|=
name|LINETABLE
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|l
condition|)
continue|continue;
name|len
operator|=
name|l
operator|->
name|nitems
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
block|{
comment|/* I think len can be zero if the symtab lacks line numbers 	     (e.g. gcc -g1).  (Either that or the LINETABLE is NULL; 	     I'm not sure which, and maybe it depends on the symbol 	     reader).  */
continue|continue;
block|}
name|prev
operator|=
name|NULL
expr_stmt|;
name|item
operator|=
name|l
operator|->
name|item
expr_stmt|;
comment|/* Get first line info */
comment|/* Is this file's first line closer than the first lines of other files?          If so, record this file, and its first line, as best alternate.  */
if|if
condition|(
name|item
operator|->
name|pc
operator|>
name|pc
operator|&&
operator|(
operator|!
name|alt
operator|||
name|item
operator|->
name|pc
operator|<
name|alt
operator|->
name|pc
operator|)
condition|)
block|{
name|alt
operator|=
name|item
expr_stmt|;
name|alt_symtab
operator|=
name|s
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
operator|,
name|item
operator|++
control|)
block|{
comment|/* Leave prev pointing to the linetable entry for the last line 	     that started at or before PC.  */
if|if
condition|(
name|item
operator|->
name|pc
operator|>
name|pc
condition|)
break|break;
name|prev
operator|=
name|item
expr_stmt|;
block|}
comment|/* At this point, prev points at the line whose start addr is<= pc, and          item points at the next line.  If we ran off the end of the linetable          (pc>= start of the last line), then prev == item.  If pc< start of          the first line, prev will not be set.  */
comment|/* Is this file's best line closer than the best in the other files?          If so, record this file, and its best line, as best so far.  */
if|if
condition|(
name|prev
operator|&&
operator|(
operator|!
name|best
operator|||
name|prev
operator|->
name|pc
operator|>
name|best
operator|->
name|pc
operator|)
condition|)
block|{
name|best
operator|=
name|prev
expr_stmt|;
name|best_symtab
operator|=
name|s
expr_stmt|;
comment|/* Discard BEST_END if it's before the PC of the current BEST.  */
if|if
condition|(
name|best_end
operator|<=
name|best
operator|->
name|pc
condition|)
name|best_end
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If another line (denoted by ITEM) is in the linetable and its          PC is after BEST's PC, but before the current BEST_END, then 	 use ITEM's PC as the new best_end.  */
if|if
condition|(
name|best
operator|&&
name|i
operator|<
name|len
operator|&&
name|item
operator|->
name|pc
operator|>
name|best
operator|->
name|pc
operator|&&
operator|(
name|best_end
operator|==
literal|0
operator|||
name|best_end
operator|>
name|item
operator|->
name|pc
operator|)
condition|)
name|best_end
operator|=
name|item
operator|->
name|pc
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|best_symtab
condition|)
block|{
if|if
condition|(
operator|!
name|alt_symtab
condition|)
block|{
comment|/* If we didn't find any line # info, just 				   return zeros.  */
name|val
operator|.
name|pc
operator|=
name|pc
expr_stmt|;
block|}
else|else
block|{
name|val
operator|.
name|symtab
operator|=
name|alt_symtab
expr_stmt|;
name|val
operator|.
name|line
operator|=
name|alt
operator|->
name|line
operator|-
literal|1
expr_stmt|;
comment|/* Don't return line 0, that means that we didn't find the line.  */
if|if
condition|(
name|val
operator|.
name|line
operator|==
literal|0
condition|)
operator|++
name|val
operator|.
name|line
expr_stmt|;
name|val
operator|.
name|pc
operator|=
name|BLOCK_END
argument_list|(
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
argument_list|)
expr_stmt|;
name|val
operator|.
name|end
operator|=
name|alt
operator|->
name|pc
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|best
operator|->
name|line
operator|==
literal|0
condition|)
block|{
comment|/* If our best fit is in a range of PC's for which no line 	 number info is available (line number is zero) then we didn't 	 find any valid line information. */
name|val
operator|.
name|pc
operator|=
name|pc
expr_stmt|;
block|}
else|else
block|{
name|val
operator|.
name|symtab
operator|=
name|best_symtab
expr_stmt|;
name|val
operator|.
name|line
operator|=
name|best
operator|->
name|line
expr_stmt|;
name|val
operator|.
name|pc
operator|=
name|best
operator|->
name|pc
expr_stmt|;
if|if
condition|(
name|best_end
operator|&&
operator|(
operator|!
name|alt
operator|||
name|best_end
operator|<
name|alt
operator|->
name|pc
operator|)
condition|)
name|val
operator|.
name|end
operator|=
name|best_end
expr_stmt|;
elseif|else
if|if
condition|(
name|alt
condition|)
name|val
operator|.
name|end
operator|=
name|alt
operator|->
name|pc
expr_stmt|;
else|else
name|val
operator|.
name|end
operator|=
name|BLOCK_END
argument_list|(
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|val
operator|.
name|section
operator|=
name|section
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Backward compatibility (no section) */
end_comment

begin_function
name|struct
name|symtab_and_line
name|find_pc_line
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|int
name|notcurrent
parameter_list|)
block|{
name|asection
modifier|*
name|section
decl_stmt|;
name|section
operator|=
name|find_pc_overlay
argument_list|(
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|pc_in_unmapped_range
argument_list|(
name|pc
argument_list|,
name|section
argument_list|)
condition|)
name|pc
operator|=
name|overlay_mapped_address
argument_list|(
name|pc
argument_list|,
name|section
argument_list|)
expr_stmt|;
return|return
name|find_pc_sect_line
argument_list|(
name|pc
argument_list|,
name|section
argument_list|,
name|notcurrent
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find line number LINE in any symtab whose name is the same as    SYMTAB.     If found, return the symtab that contains the linetable in which it was    found, set *INDEX to the index in the linetable of the best entry    found, and set *EXACT_MATCH nonzero if the value returned is an    exact match.     If not found, return NULL.  */
end_comment

begin_function
name|struct
name|symtab
modifier|*
name|find_line_symtab
parameter_list|(
name|struct
name|symtab
modifier|*
name|symtab
parameter_list|,
name|int
name|line
parameter_list|,
name|int
modifier|*
name|index
parameter_list|,
name|int
modifier|*
name|exact_match
parameter_list|)
block|{
name|int
name|exact
decl_stmt|;
comment|/* BEST_INDEX and BEST_LINETABLE identify the smallest linenumber> LINE      so far seen.  */
name|int
name|best_index
decl_stmt|;
name|struct
name|linetable
modifier|*
name|best_linetable
decl_stmt|;
name|struct
name|symtab
modifier|*
name|best_symtab
decl_stmt|;
comment|/* First try looking it up in the given symtab.  */
name|best_linetable
operator|=
name|LINETABLE
argument_list|(
name|symtab
argument_list|)
expr_stmt|;
name|best_symtab
operator|=
name|symtab
expr_stmt|;
name|best_index
operator|=
name|find_line_common
argument_list|(
name|best_linetable
argument_list|,
name|line
argument_list|,
operator|&
name|exact
argument_list|)
expr_stmt|;
if|if
condition|(
name|best_index
operator|<
literal|0
operator|||
operator|!
name|exact
condition|)
block|{
comment|/* Didn't find an exact match.  So we better keep looking for          another symtab with the same name.  In the case of xcoff,          multiple csects for one source file (produced by IBM's FORTRAN          compiler) produce multiple symtabs (this is unavoidable          assuming csects can be at arbitrary places in memory and that          the GLOBAL_BLOCK of a symtab has a begin and end address).  */
comment|/* BEST is the smallest linenumber> LINE so far seen,          or 0 if none has been seen so far.          BEST_INDEX and BEST_LINETABLE identify the item for it.  */
name|int
name|best
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|best_index
operator|>=
literal|0
condition|)
name|best
operator|=
name|best_linetable
operator|->
name|item
index|[
name|best_index
index|]
operator|.
name|line
expr_stmt|;
else|else
name|best
operator|=
literal|0
expr_stmt|;
name|ALL_SYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
block|{
name|struct
name|linetable
modifier|*
name|l
decl_stmt|;
name|int
name|ind
decl_stmt|;
if|if
condition|(
operator|!
name|STREQ
argument_list|(
name|symtab
operator|->
name|filename
argument_list|,
name|s
operator|->
name|filename
argument_list|)
condition|)
continue|continue;
name|l
operator|=
name|LINETABLE
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ind
operator|=
name|find_line_common
argument_list|(
name|l
argument_list|,
name|line
argument_list|,
operator|&
name|exact
argument_list|)
expr_stmt|;
if|if
condition|(
name|ind
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|exact
condition|)
block|{
name|best_index
operator|=
name|ind
expr_stmt|;
name|best_linetable
operator|=
name|l
expr_stmt|;
name|best_symtab
operator|=
name|s
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|best
operator|==
literal|0
operator|||
name|l
operator|->
name|item
index|[
name|ind
index|]
operator|.
name|line
operator|<
name|best
condition|)
block|{
name|best
operator|=
name|l
operator|->
name|item
index|[
name|ind
index|]
operator|.
name|line
expr_stmt|;
name|best_index
operator|=
name|ind
expr_stmt|;
name|best_linetable
operator|=
name|l
expr_stmt|;
name|best_symtab
operator|=
name|s
expr_stmt|;
block|}
block|}
block|}
block|}
name|done
label|:
if|if
condition|(
name|best_index
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|index
condition|)
operator|*
name|index
operator|=
name|best_index
expr_stmt|;
if|if
condition|(
name|exact_match
condition|)
operator|*
name|exact_match
operator|=
name|exact
expr_stmt|;
return|return
name|best_symtab
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Set the PC value for a given source file and line number and return true.    Returns zero for invalid line number (and sets the PC to 0).    The source file is specified with a struct symtab.  */
end_comment

begin_function
name|int
name|find_line_pc
parameter_list|(
name|struct
name|symtab
modifier|*
name|symtab
parameter_list|,
name|int
name|line
parameter_list|,
name|CORE_ADDR
modifier|*
name|pc
parameter_list|)
block|{
name|struct
name|linetable
modifier|*
name|l
decl_stmt|;
name|int
name|ind
decl_stmt|;
operator|*
name|pc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|symtab
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|symtab
operator|=
name|find_line_symtab
argument_list|(
name|symtab
argument_list|,
name|line
argument_list|,
operator|&
name|ind
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|symtab
operator|!=
name|NULL
condition|)
block|{
name|l
operator|=
name|LINETABLE
argument_list|(
name|symtab
argument_list|)
expr_stmt|;
operator|*
name|pc
operator|=
name|l
operator|->
name|item
index|[
name|ind
index|]
operator|.
name|pc
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Find the range of pc values in a line.    Store the starting pc of the line into *STARTPTR    and the ending pc (start of next line) into *ENDPTR.    Returns 1 to indicate success.    Returns 0 if could not find the specified line.  */
end_comment

begin_function
name|int
name|find_line_pc_range
parameter_list|(
name|struct
name|symtab_and_line
name|sal
parameter_list|,
name|CORE_ADDR
modifier|*
name|startptr
parameter_list|,
name|CORE_ADDR
modifier|*
name|endptr
parameter_list|)
block|{
name|CORE_ADDR
name|startaddr
decl_stmt|;
name|struct
name|symtab_and_line
name|found_sal
decl_stmt|;
name|startaddr
operator|=
name|sal
operator|.
name|pc
expr_stmt|;
if|if
condition|(
name|startaddr
operator|==
literal|0
operator|&&
operator|!
name|find_line_pc
argument_list|(
name|sal
operator|.
name|symtab
argument_list|,
name|sal
operator|.
name|line
argument_list|,
operator|&
name|startaddr
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* This whole function is based on address.  For example, if line 10 has      two parts, one from 0x100 to 0x200 and one from 0x300 to 0x400, then      "info line *0x123" should say the line goes from 0x100 to 0x200      and "info line *0x355" should say the line goes from 0x300 to 0x400.      This also insures that we never give a range like "starts at 0x134      and ends at 0x12c".  */
name|found_sal
operator|=
name|find_pc_sect_line
argument_list|(
name|startaddr
argument_list|,
name|sal
operator|.
name|section
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|found_sal
operator|.
name|line
operator|!=
name|sal
operator|.
name|line
condition|)
block|{
comment|/* The specified line (sal) has zero bytes.  */
operator|*
name|startptr
operator|=
name|found_sal
operator|.
name|pc
expr_stmt|;
operator|*
name|endptr
operator|=
name|found_sal
operator|.
name|pc
expr_stmt|;
block|}
else|else
block|{
operator|*
name|startptr
operator|=
name|found_sal
operator|.
name|pc
expr_stmt|;
operator|*
name|endptr
operator|=
name|found_sal
operator|.
name|end
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Given a line table and a line number, return the index into the line    table for the pc of the nearest line whose number is>= the specified one.    Return -1 if none is found.  The value is>= 0 if it is an index.     Set *EXACT_MATCH nonzero if the value returned is an exact match.  */
end_comment

begin_function
specifier|static
name|int
name|find_line_common
parameter_list|(
specifier|register
name|struct
name|linetable
modifier|*
name|l
parameter_list|,
specifier|register
name|int
name|lineno
parameter_list|,
name|int
modifier|*
name|exact_match
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
comment|/* BEST is the smallest linenumber> LINENO so far seen,      or 0 if none has been seen so far.      BEST_INDEX identifies the item for it.  */
name|int
name|best_index
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|best
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|lineno
operator|<=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|l
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|len
operator|=
name|l
operator|->
name|nitems
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|struct
name|linetable_entry
modifier|*
name|item
init|=
operator|&
operator|(
name|l
operator|->
name|item
index|[
name|i
index|]
operator|)
decl_stmt|;
if|if
condition|(
name|item
operator|->
name|line
operator|==
name|lineno
condition|)
block|{
comment|/* Return the first (lowest address) entry which matches.  */
operator|*
name|exact_match
operator|=
literal|1
expr_stmt|;
return|return
name|i
return|;
block|}
if|if
condition|(
name|item
operator|->
name|line
operator|>
name|lineno
operator|&&
operator|(
name|best
operator|==
literal|0
operator|||
name|item
operator|->
name|line
operator|<
name|best
operator|)
condition|)
block|{
name|best
operator|=
name|item
operator|->
name|line
expr_stmt|;
name|best_index
operator|=
name|i
expr_stmt|;
block|}
block|}
comment|/* If we got here, we didn't get an exact match.  */
operator|*
name|exact_match
operator|=
literal|0
expr_stmt|;
return|return
name|best_index
return|;
block|}
end_function

begin_function
name|int
name|find_pc_line_pc_range
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|CORE_ADDR
modifier|*
name|startptr
parameter_list|,
name|CORE_ADDR
modifier|*
name|endptr
parameter_list|)
block|{
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|sal
operator|=
name|find_pc_line
argument_list|(
name|pc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|startptr
operator|=
name|sal
operator|.
name|pc
expr_stmt|;
operator|*
name|endptr
operator|=
name|sal
operator|.
name|end
expr_stmt|;
return|return
name|sal
operator|.
name|symtab
operator|!=
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Given a function symbol SYM, find the symtab and line for the start    of the function.    If the argument FUNFIRSTLINE is nonzero, we want the first line    of real code inside the function.  */
end_comment

begin_function
name|struct
name|symtab_and_line
name|find_function_start_sal
parameter_list|(
name|struct
name|symbol
modifier|*
name|sym
parameter_list|,
name|int
name|funfirstline
parameter_list|)
block|{
name|CORE_ADDR
name|pc
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|pc
operator|=
name|BLOCK_START
argument_list|(
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|fixup_symbol_section
argument_list|(
name|sym
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|funfirstline
condition|)
block|{
comment|/* skip "first line" of function (which is actually its prologue) */
name|asection
modifier|*
name|section
init|=
name|SYMBOL_BFD_SECTION
argument_list|(
name|sym
argument_list|)
decl_stmt|;
comment|/* If function is in an unmapped overlay, use its unmapped LMA          address, so that SKIP_PROLOGUE has something unique to work on */
if|if
condition|(
name|section_is_overlay
argument_list|(
name|section
argument_list|)
operator|&&
operator|!
name|section_is_mapped
argument_list|(
name|section
argument_list|)
condition|)
name|pc
operator|=
name|overlay_unmapped_address
argument_list|(
name|pc
argument_list|,
name|section
argument_list|)
expr_stmt|;
name|pc
operator|+=
name|FUNCTION_START_OFFSET
expr_stmt|;
name|pc
operator|=
name|SKIP_PROLOGUE
argument_list|(
name|pc
argument_list|)
expr_stmt|;
comment|/* For overlays, map pc back into its mapped VMA range */
name|pc
operator|=
name|overlay_mapped_address
argument_list|(
name|pc
argument_list|,
name|section
argument_list|)
expr_stmt|;
block|}
name|sal
operator|=
name|find_pc_sect_line
argument_list|(
name|pc
argument_list|,
name|SYMBOL_BFD_SECTION
argument_list|(
name|sym
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PROLOGUE_FIRSTLINE_OVERLAP
comment|/* Convex: no need to suppress code on first line, if any */
name|sal
operator|.
name|pc
operator|=
name|pc
expr_stmt|;
else|#
directive|else
comment|/* Check if SKIP_PROLOGUE left us in mid-line, and the next      line is still part of the same function.  */
if|if
condition|(
name|sal
operator|.
name|pc
operator|!=
name|pc
operator|&&
name|BLOCK_START
argument_list|(
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|<=
name|sal
operator|.
name|end
operator|&&
name|sal
operator|.
name|end
operator|<
name|BLOCK_END
argument_list|(
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|sym
argument_list|)
argument_list|)
condition|)
block|{
comment|/* First pc of next line */
name|pc
operator|=
name|sal
operator|.
name|end
expr_stmt|;
comment|/* Recalculate the line number (might not be N+1).  */
name|sal
operator|=
name|find_pc_sect_line
argument_list|(
name|pc
argument_list|,
name|SYMBOL_BFD_SECTION
argument_list|(
name|sym
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|sal
operator|.
name|pc
operator|=
name|pc
expr_stmt|;
endif|#
directive|endif
return|return
name|sal
return|;
block|}
end_function

begin_comment
comment|/* If P is of the form "operator[ \t]+..." where `...' is    some legitimate operator text, return a pointer to the    beginning of the substring of the operator text.    Otherwise, return "".  */
end_comment

begin_function
name|char
modifier|*
name|operator_chars
parameter_list|(
name|char
modifier|*
name|p
parameter_list|,
name|char
modifier|*
modifier|*
name|end
parameter_list|)
block|{
operator|*
name|end
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"operator"
argument_list|,
literal|8
argument_list|)
condition|)
return|return
operator|*
name|end
return|;
name|p
operator|+=
literal|8
expr_stmt|;
comment|/* Don't get faked out by `operator' being part of a longer      identifier.  */
if|if
condition|(
name|isalpha
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|'_'
operator|||
operator|*
name|p
operator|==
literal|'$'
operator|||
operator|*
name|p
operator|==
literal|'\0'
condition|)
return|return
operator|*
name|end
return|;
comment|/* Allow some whitespace between `operator' and the operator symbol.  */
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
comment|/* Recognize 'operator TYPENAME'. */
if|if
condition|(
name|isalpha
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|'_'
operator|||
operator|*
name|p
operator|==
literal|'$'
condition|)
block|{
specifier|register
name|char
modifier|*
name|q
init|=
name|p
operator|+
literal|1
decl_stmt|;
while|while
condition|(
name|isalnum
argument_list|(
operator|*
name|q
argument_list|)
operator|||
operator|*
name|q
operator|==
literal|'_'
operator|||
operator|*
name|q
operator|==
literal|'$'
condition|)
name|q
operator|++
expr_stmt|;
operator|*
name|end
operator|=
name|q
expr_stmt|;
return|return
name|p
return|;
block|}
while|while
condition|(
operator|*
name|p
condition|)
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'\\'
case|:
comment|/* regexp quoting */
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'*'
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|2
index|]
operator|==
literal|'='
condition|)
comment|/* 'operator\*=' */
operator|*
name|end
operator|=
name|p
operator|+
literal|3
expr_stmt|;
else|else
comment|/* 'operator\*'  */
operator|*
name|end
operator|=
name|p
operator|+
literal|2
expr_stmt|;
return|return
name|p
return|;
block|}
elseif|else
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'['
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|2
index|]
operator|==
literal|']'
condition|)
name|error
argument_list|(
literal|"mismatched quoting on brackets, try 'operator\\[\\]'"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p
index|[
literal|2
index|]
operator|==
literal|'\\'
operator|&&
name|p
index|[
literal|3
index|]
operator|==
literal|']'
condition|)
block|{
operator|*
name|end
operator|=
name|p
operator|+
literal|4
expr_stmt|;
comment|/* 'operator\[\]' */
return|return
name|p
return|;
block|}
else|else
name|error
argument_list|(
literal|"nothing is allowed between '[' and ']'"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Gratuitous qoute: skip it and move on. */
name|p
operator|++
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
literal|'!'
case|:
case|case
literal|'='
case|:
case|case
literal|'*'
case|:
case|case
literal|'/'
case|:
case|case
literal|'%'
case|:
case|case
literal|'^'
case|:
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'='
condition|)
operator|*
name|end
operator|=
name|p
operator|+
literal|2
expr_stmt|;
else|else
operator|*
name|end
operator|=
name|p
operator|+
literal|1
expr_stmt|;
return|return
name|p
return|;
case|case
literal|'<'
case|:
case|case
literal|'>'
case|:
case|case
literal|'+'
case|:
case|case
literal|'-'
case|:
case|case
literal|'&'
case|:
case|case
literal|'|'
case|:
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'>'
condition|)
block|{
comment|/* Struct pointer member operator 'operator->'. */
if|if
condition|(
name|p
index|[
literal|2
index|]
operator|==
literal|'*'
condition|)
block|{
operator|*
name|end
operator|=
name|p
operator|+
literal|3
expr_stmt|;
comment|/* 'operator->*' */
return|return
name|p
return|;
block|}
elseif|else
if|if
condition|(
name|p
index|[
literal|2
index|]
operator|==
literal|'\\'
condition|)
block|{
operator|*
name|end
operator|=
name|p
operator|+
literal|4
expr_stmt|;
comment|/* Hopefully 'operator->\*' */
return|return
name|p
return|;
block|}
else|else
block|{
operator|*
name|end
operator|=
name|p
operator|+
literal|2
expr_stmt|;
comment|/* 'operator->' */
return|return
name|p
return|;
block|}
block|}
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'='
operator|||
name|p
index|[
literal|1
index|]
operator|==
name|p
index|[
literal|0
index|]
condition|)
operator|*
name|end
operator|=
name|p
operator|+
literal|2
expr_stmt|;
else|else
operator|*
name|end
operator|=
name|p
operator|+
literal|1
expr_stmt|;
return|return
name|p
return|;
case|case
literal|'~'
case|:
case|case
literal|','
case|:
operator|*
name|end
operator|=
name|p
operator|+
literal|1
expr_stmt|;
return|return
name|p
return|;
case|case
literal|'('
case|:
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|!=
literal|')'
condition|)
name|error
argument_list|(
literal|"`operator ()' must be specified without whitespace in `()'"
argument_list|)
expr_stmt|;
operator|*
name|end
operator|=
name|p
operator|+
literal|2
expr_stmt|;
return|return
name|p
return|;
case|case
literal|'?'
case|:
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|!=
literal|':'
condition|)
name|error
argument_list|(
literal|"`operator ?:' must be specified without whitespace in `?:'"
argument_list|)
expr_stmt|;
operator|*
name|end
operator|=
name|p
operator|+
literal|2
expr_stmt|;
return|return
name|p
return|;
case|case
literal|'['
case|:
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|!=
literal|']'
condition|)
name|error
argument_list|(
literal|"`operator []' must be specified without whitespace in `[]'"
argument_list|)
expr_stmt|;
operator|*
name|end
operator|=
name|p
operator|+
literal|2
expr_stmt|;
return|return
name|p
return|;
default|default:
name|error
argument_list|(
literal|"`operator %s' not supported"
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
operator|*
name|end
operator|=
literal|""
expr_stmt|;
return|return
operator|*
name|end
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If FILE is not already in the table of files, return zero;    otherwise return non-zero.  Optionally add FILE to the table if ADD    is non-zero.  If *FIRST is non-zero, forget the old table    contents.  */
end_comment

begin_function
specifier|static
name|int
name|filename_seen
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|add
parameter_list|,
name|int
modifier|*
name|first
parameter_list|)
block|{
comment|/* Table of files seen so far.  */
specifier|static
specifier|const
name|char
modifier|*
modifier|*
name|tab
init|=
name|NULL
decl_stmt|;
comment|/* Allocated size of tab in elements.      Start with one 256-byte block (when using GNU malloc.c).      24 is the malloc overhead when range checking is in effect.  */
specifier|static
name|int
name|tab_alloc_size
init|=
operator|(
literal|256
operator|-
literal|24
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
decl_stmt|;
comment|/* Current size of tab in elements.  */
specifier|static
name|int
name|tab_cur_size
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|*
name|first
condition|)
block|{
if|if
condition|(
name|tab
operator|==
name|NULL
condition|)
name|tab
operator|=
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|tab_alloc_size
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|tab
argument_list|)
argument_list|)
expr_stmt|;
name|tab_cur_size
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Is FILE in tab?  */
for|for
control|(
name|p
operator|=
name|tab
init|;
name|p
operator|<
name|tab
operator|+
name|tab_cur_size
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|p
argument_list|,
name|file
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
comment|/* No; maybe add it to tab.  */
if|if
condition|(
name|add
condition|)
block|{
if|if
condition|(
name|tab_cur_size
operator|==
name|tab_alloc_size
condition|)
block|{
name|tab_alloc_size
operator|*=
literal|2
expr_stmt|;
name|tab
operator|=
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tab
argument_list|,
name|tab_alloc_size
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|tab
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|tab
index|[
name|tab_cur_size
operator|++
index|]
operator|=
name|file
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Slave routine for sources_info.  Force line breaks at ,'s.    NAME is the name to print and *FIRST is nonzero if this is the first    name printed.  Set *FIRST to zero.  */
end_comment

begin_function
specifier|static
name|void
name|output_source_filename
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
modifier|*
name|first
parameter_list|)
block|{
comment|/* Since a single source file can result in several partial symbol      tables, we need to avoid printing it more than once.  Note: if      some of the psymtabs are read in and some are not, it gets      printed both under "Source files for which symbols have been      read" and "Source files for which symbols will be read in on      demand".  I consider this a reasonable way to deal with the      situation.  I'm not sure whether this can also happen for      symtabs; it doesn't hurt to check.  */
comment|/* Was NAME already seen?  */
if|if
condition|(
name|filename_seen
argument_list|(
name|name
argument_list|,
literal|1
argument_list|,
name|first
argument_list|)
condition|)
block|{
comment|/* Yes; don't print it again.  */
return|return;
block|}
comment|/* No; print it and reset *FIRST.  */
if|if
condition|(
operator|*
name|first
condition|)
block|{
operator|*
name|first
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|printf_filtered
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
name|name
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sources_info
parameter_list|(
name|char
modifier|*
name|ignore
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
specifier|register
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
specifier|register
name|struct
name|partial_symtab
modifier|*
name|ps
decl_stmt|;
specifier|register
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|int
name|first
decl_stmt|;
if|if
condition|(
operator|!
name|have_full_symbols
argument_list|()
operator|&&
operator|!
name|have_partial_symbols
argument_list|()
condition|)
block|{
name|error
argument_list|(
literal|"No symbol table is loaded.  Use the \"file\" command."
argument_list|)
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|"Source files for which symbols have been read in:\n\n"
argument_list|)
expr_stmt|;
name|first
operator|=
literal|1
expr_stmt|;
name|ALL_SYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
block|{
name|output_source_filename
argument_list|(
name|s
operator|->
name|filename
argument_list|,
operator|&
name|first
argument_list|)
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Source files for which symbols will be read in on demand:\n\n"
argument_list|)
expr_stmt|;
name|first
operator|=
literal|1
expr_stmt|;
name|ALL_PSYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|ps
argument_list|)
block|{
if|if
condition|(
operator|!
name|ps
operator|->
name|readin
condition|)
block|{
name|output_source_filename
argument_list|(
name|ps
operator|->
name|filename
argument_list|,
operator|&
name|first
argument_list|)
expr_stmt|;
block|}
block|}
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|file_matches
parameter_list|(
name|char
modifier|*
name|file
parameter_list|,
name|char
modifier|*
name|files
index|[]
parameter_list|,
name|int
name|nfiles
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|file
operator|!=
name|NULL
operator|&&
name|nfiles
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfiles
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|files
index|[
name|i
index|]
argument_list|,
name|lbasename
argument_list|(
name|file
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|nfiles
operator|==
literal|0
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Free any memory associated with a search. */
end_comment

begin_function
name|void
name|free_search_symbols
parameter_list|(
name|struct
name|symbol_search
modifier|*
name|symbols
parameter_list|)
block|{
name|struct
name|symbol_search
modifier|*
name|p
decl_stmt|;
name|struct
name|symbol_search
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|p
operator|=
name|symbols
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|next
control|)
block|{
name|next
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|xfree
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|do_free_search_symbols_cleanup
parameter_list|(
name|void
modifier|*
name|symbols
parameter_list|)
block|{
name|free_search_symbols
argument_list|(
name|symbols
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|cleanup
modifier|*
name|make_cleanup_free_search_symbols
parameter_list|(
name|struct
name|symbol_search
modifier|*
name|symbols
parameter_list|)
block|{
return|return
name|make_cleanup
argument_list|(
name|do_free_search_symbols_cleanup
argument_list|,
name|symbols
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Helper function for sort_search_symbols and qsort.  Can only    sort symbols, not minimal symbols.  */
end_comment

begin_function
specifier|static
name|int
name|compare_search_syms
parameter_list|(
specifier|const
name|void
modifier|*
name|sa
parameter_list|,
specifier|const
name|void
modifier|*
name|sb
parameter_list|)
block|{
name|struct
name|symbol_search
modifier|*
modifier|*
name|sym_a
init|=
operator|(
expr|struct
name|symbol_search
operator|*
operator|*
operator|)
name|sa
decl_stmt|;
name|struct
name|symbol_search
modifier|*
modifier|*
name|sym_b
init|=
operator|(
expr|struct
name|symbol_search
operator|*
operator|*
operator|)
name|sb
decl_stmt|;
return|return
name|strcmp
argument_list|(
name|SYMBOL_SOURCE_NAME
argument_list|(
operator|(
operator|*
name|sym_a
operator|)
operator|->
name|symbol
argument_list|)
argument_list|,
name|SYMBOL_SOURCE_NAME
argument_list|(
operator|(
operator|*
name|sym_b
operator|)
operator|->
name|symbol
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Sort the ``nfound'' symbols in the list after prevtail.  Leave    prevtail where it is, but update its next pointer to point to    the first of the sorted symbols.  */
end_comment

begin_function
specifier|static
name|struct
name|symbol_search
modifier|*
name|sort_search_symbols
parameter_list|(
name|struct
name|symbol_search
modifier|*
name|prevtail
parameter_list|,
name|int
name|nfound
parameter_list|)
block|{
name|struct
name|symbol_search
modifier|*
modifier|*
name|symbols
decl_stmt|,
modifier|*
name|symp
decl_stmt|,
modifier|*
name|old_next
decl_stmt|;
name|int
name|i
decl_stmt|;
name|symbols
operator|=
operator|(
expr|struct
name|symbol_search
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|symbol_search
operator|*
argument_list|)
operator|*
name|nfound
argument_list|)
expr_stmt|;
name|symp
operator|=
name|prevtail
operator|->
name|next
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfound
condition|;
name|i
operator|++
control|)
block|{
name|symbols
index|[
name|i
index|]
operator|=
name|symp
expr_stmt|;
name|symp
operator|=
name|symp
operator|->
name|next
expr_stmt|;
block|}
comment|/* Generally NULL.  */
name|old_next
operator|=
name|symp
expr_stmt|;
name|qsort
argument_list|(
name|symbols
argument_list|,
name|nfound
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol_search
operator|*
argument_list|)
argument_list|,
name|compare_search_syms
argument_list|)
expr_stmt|;
name|symp
operator|=
name|prevtail
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfound
condition|;
name|i
operator|++
control|)
block|{
name|symp
operator|->
name|next
operator|=
name|symbols
index|[
name|i
index|]
expr_stmt|;
name|symp
operator|=
name|symp
operator|->
name|next
expr_stmt|;
block|}
name|symp
operator|->
name|next
operator|=
name|old_next
expr_stmt|;
name|xfree
argument_list|(
name|symbols
argument_list|)
expr_stmt|;
return|return
name|symp
return|;
block|}
end_function

begin_comment
comment|/* Search the symbol table for matches to the regular expression REGEXP,    returning the results in *MATCHES.     Only symbols of KIND are searched:    FUNCTIONS_NAMESPACE - search all functions    TYPES_NAMESPACE     - search all type names    METHODS_NAMESPACE   - search all methods NOT IMPLEMENTED    VARIABLES_NAMESPACE - search all symbols, excluding functions, type names,    and constants (enums)     free_search_symbols should be called when *MATCHES is no longer needed.     The results are sorted locally; each symtab's global and static blocks are    separately alphabetized.  */
end_comment

begin_function
name|void
name|search_symbols
parameter_list|(
name|char
modifier|*
name|regexp
parameter_list|,
name|namespace_enum
name|kind
parameter_list|,
name|int
name|nfiles
parameter_list|,
name|char
modifier|*
name|files
index|[]
parameter_list|,
name|struct
name|symbol_search
modifier|*
modifier|*
name|matches
parameter_list|)
block|{
specifier|register
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
specifier|register
name|struct
name|partial_symtab
modifier|*
name|ps
decl_stmt|;
specifier|register
name|struct
name|blockvector
modifier|*
name|bv
decl_stmt|;
name|struct
name|blockvector
modifier|*
name|prev_bv
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|block
modifier|*
name|b
decl_stmt|;
specifier|register
name|int
name|i
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|struct
name|partial_symbol
modifier|*
modifier|*
name|psym
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
name|int
name|found_misc
init|=
literal|0
decl_stmt|;
specifier|static
name|enum
name|minimal_symbol_type
name|types
index|[]
init|=
block|{
name|mst_data
block|,
name|mst_text
block|,
name|mst_abs
block|,
name|mst_unknown
block|}
decl_stmt|;
specifier|static
name|enum
name|minimal_symbol_type
name|types2
index|[]
init|=
block|{
name|mst_bss
block|,
name|mst_file_text
block|,
name|mst_abs
block|,
name|mst_unknown
block|}
decl_stmt|;
specifier|static
name|enum
name|minimal_symbol_type
name|types3
index|[]
init|=
block|{
name|mst_file_data
block|,
name|mst_solib_trampoline
block|,
name|mst_abs
block|,
name|mst_unknown
block|}
decl_stmt|;
specifier|static
name|enum
name|minimal_symbol_type
name|types4
index|[]
init|=
block|{
name|mst_file_bss
block|,
name|mst_text
block|,
name|mst_abs
block|,
name|mst_unknown
block|}
decl_stmt|;
name|enum
name|minimal_symbol_type
name|ourtype
decl_stmt|;
name|enum
name|minimal_symbol_type
name|ourtype2
decl_stmt|;
name|enum
name|minimal_symbol_type
name|ourtype3
decl_stmt|;
name|enum
name|minimal_symbol_type
name|ourtype4
decl_stmt|;
name|struct
name|symbol_search
modifier|*
name|sr
decl_stmt|;
name|struct
name|symbol_search
modifier|*
name|psr
decl_stmt|;
name|struct
name|symbol_search
modifier|*
name|tail
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|kind
operator|<
name|VARIABLES_NAMESPACE
condition|)
name|error
argument_list|(
literal|"must search on specific namespace"
argument_list|)
expr_stmt|;
name|ourtype
operator|=
name|types
index|[
call|(
name|int
call|)
argument_list|(
name|kind
operator|-
name|VARIABLES_NAMESPACE
argument_list|)
index|]
expr_stmt|;
name|ourtype2
operator|=
name|types2
index|[
call|(
name|int
call|)
argument_list|(
name|kind
operator|-
name|VARIABLES_NAMESPACE
argument_list|)
index|]
expr_stmt|;
name|ourtype3
operator|=
name|types3
index|[
call|(
name|int
call|)
argument_list|(
name|kind
operator|-
name|VARIABLES_NAMESPACE
argument_list|)
index|]
expr_stmt|;
name|ourtype4
operator|=
name|types4
index|[
call|(
name|int
call|)
argument_list|(
name|kind
operator|-
name|VARIABLES_NAMESPACE
argument_list|)
index|]
expr_stmt|;
name|sr
operator|=
operator|*
name|matches
operator|=
name|NULL
expr_stmt|;
name|tail
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|regexp
operator|!=
name|NULL
condition|)
block|{
comment|/* Make sure spacing is right for C++ operators.          This is just a courtesy to make the matching less sensitive          to how many spaces the user leaves between 'operator'          and<TYPENAME> or<OPERATOR>. */
name|char
modifier|*
name|opend
decl_stmt|;
name|char
modifier|*
name|opname
init|=
name|operator_chars
argument_list|(
name|regexp
argument_list|,
operator|&
name|opend
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|opname
condition|)
block|{
name|int
name|fix
init|=
operator|-
literal|1
decl_stmt|;
comment|/* -1 means ok; otherwise number of spaces needed. */
if|if
condition|(
name|isalpha
argument_list|(
operator|*
name|opname
argument_list|)
operator|||
operator|*
name|opname
operator|==
literal|'_'
operator|||
operator|*
name|opname
operator|==
literal|'$'
condition|)
block|{
comment|/* There should 1 space between 'operator' and 'TYPENAME'. */
if|if
condition|(
name|opname
index|[
operator|-
literal|1
index|]
operator|!=
literal|' '
operator|||
name|opname
index|[
operator|-
literal|2
index|]
operator|==
literal|' '
condition|)
name|fix
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* There should 0 spaces between 'operator' and 'OPERATOR'. */
if|if
condition|(
name|opname
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
name|fix
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If wrong number of spaces, fix it. */
if|if
condition|(
name|fix
operator|>=
literal|0
condition|)
block|{
name|char
modifier|*
name|tmp
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|8
operator|+
name|fix
operator|+
name|strlen
argument_list|(
name|opname
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"operator%.*s%s"
argument_list|,
name|fix
argument_list|,
literal|" "
argument_list|,
name|opname
argument_list|)
expr_stmt|;
name|regexp
operator|=
name|tmp
expr_stmt|;
block|}
block|}
if|if
condition|(
literal|0
operator|!=
operator|(
name|val
operator|=
name|re_comp
argument_list|(
name|regexp
argument_list|)
operator|)
condition|)
name|error
argument_list|(
literal|"Invalid regexp (%s): %s"
argument_list|,
name|val
argument_list|,
name|regexp
argument_list|)
expr_stmt|;
block|}
comment|/* Search through the partial symtabs *first* for all symbols      matching the regexp.  That way we don't have to reproduce all of      the machinery below. */
name|ALL_PSYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|ps
argument_list|)
block|{
name|struct
name|partial_symbol
modifier|*
modifier|*
name|bound
decl_stmt|,
modifier|*
modifier|*
name|gbound
decl_stmt|,
modifier|*
modifier|*
name|sbound
decl_stmt|;
name|int
name|keep_going
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|ps
operator|->
name|readin
condition|)
continue|continue;
name|gbound
operator|=
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
operator|+
name|ps
operator|->
name|globals_offset
operator|+
name|ps
operator|->
name|n_global_syms
expr_stmt|;
name|sbound
operator|=
name|objfile
operator|->
name|static_psymbols
operator|.
name|list
operator|+
name|ps
operator|->
name|statics_offset
operator|+
name|ps
operator|->
name|n_static_syms
expr_stmt|;
name|bound
operator|=
name|gbound
expr_stmt|;
comment|/* Go through all of the symbols stored in a partial        symtab in one loop. */
name|psym
operator|=
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
operator|+
name|ps
operator|->
name|globals_offset
expr_stmt|;
while|while
condition|(
name|keep_going
condition|)
block|{
if|if
condition|(
name|psym
operator|>=
name|bound
condition|)
block|{
if|if
condition|(
name|bound
operator|==
name|gbound
operator|&&
name|ps
operator|->
name|n_static_syms
operator|!=
literal|0
condition|)
block|{
name|psym
operator|=
name|objfile
operator|->
name|static_psymbols
operator|.
name|list
operator|+
name|ps
operator|->
name|statics_offset
expr_stmt|;
name|bound
operator|=
name|sbound
expr_stmt|;
block|}
else|else
name|keep_going
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|QUIT
expr_stmt|;
comment|/* If it would match (logic taken from loop below) 	       load the file and go on to the next one */
if|if
condition|(
name|file_matches
argument_list|(
name|ps
operator|->
name|filename
argument_list|,
name|files
argument_list|,
name|nfiles
argument_list|)
operator|&&
operator|(
operator|(
name|regexp
operator|==
name|NULL
operator|||
name|SYMBOL_MATCHES_REGEXP
argument_list|(
operator|*
name|psym
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|kind
operator|==
name|VARIABLES_NAMESPACE
operator|&&
name|SYMBOL_CLASS
argument_list|(
operator|*
name|psym
argument_list|)
operator|!=
name|LOC_TYPEDEF
operator|&&
name|SYMBOL_CLASS
argument_list|(
operator|*
name|psym
argument_list|)
operator|!=
name|LOC_BLOCK
operator|)
operator|||
operator|(
name|kind
operator|==
name|FUNCTIONS_NAMESPACE
operator|&&
name|SYMBOL_CLASS
argument_list|(
operator|*
name|psym
argument_list|)
operator|==
name|LOC_BLOCK
operator|)
operator|||
operator|(
name|kind
operator|==
name|TYPES_NAMESPACE
operator|&&
name|SYMBOL_CLASS
argument_list|(
operator|*
name|psym
argument_list|)
operator|==
name|LOC_TYPEDEF
operator|)
operator|||
operator|(
name|kind
operator|==
name|METHODS_NAMESPACE
operator|&&
name|SYMBOL_CLASS
argument_list|(
operator|*
name|psym
argument_list|)
operator|==
name|LOC_BLOCK
operator|)
operator|)
operator|)
condition|)
block|{
name|PSYMTAB_TO_SYMTAB
argument_list|(
name|ps
argument_list|)
expr_stmt|;
name|keep_going
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|psym
operator|++
expr_stmt|;
block|}
block|}
comment|/* Here, we search through the minimal symbol tables for functions      and variables that match, and force their symbols to be read.      This is in particular necessary for demangled variable names,      which are no longer put into the partial symbol tables.      The symbol will then be found during the scan of symtabs below.       For functions, find_pc_symtab should succeed if we have debug info      for the function, for variables we have to call lookup_symbol      to determine if the variable has debug info.      If the lookup fails, set found_misc so that we will rescan to print      any matching symbols without debug info.    */
if|if
condition|(
name|nfiles
operator|==
literal|0
operator|&&
operator|(
name|kind
operator|==
name|VARIABLES_NAMESPACE
operator|||
name|kind
operator|==
name|FUNCTIONS_NAMESPACE
operator|)
condition|)
block|{
name|ALL_MSYMBOLS
argument_list|(
argument|objfile
argument_list|,
argument|msymbol
argument_list|)
block|{
if|if
condition|(
name|MSYMBOL_TYPE
argument_list|(
name|msymbol
argument_list|)
operator|==
name|ourtype
operator|||
name|MSYMBOL_TYPE
argument_list|(
name|msymbol
argument_list|)
operator|==
name|ourtype2
operator|||
name|MSYMBOL_TYPE
argument_list|(
name|msymbol
argument_list|)
operator|==
name|ourtype3
operator|||
name|MSYMBOL_TYPE
argument_list|(
name|msymbol
argument_list|)
operator|==
name|ourtype4
condition|)
block|{
if|if
condition|(
name|regexp
operator|==
name|NULL
operator|||
name|SYMBOL_MATCHES_REGEXP
argument_list|(
name|msymbol
argument_list|)
condition|)
block|{
if|if
condition|(
literal|0
operator|==
name|find_pc_symtab
argument_list|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|kind
operator|==
name|FUNCTIONS_NAMESPACE
operator|||
name|lookup_symbol
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|msymbol
argument_list|)
argument_list|,
operator|(
expr|struct
name|block
operator|*
operator|)
name|NULL
argument_list|,
name|VAR_NAMESPACE
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|symtab
operator|*
operator|*
operator|)
name|NULL
argument_list|)
operator|==
name|NULL
condition|)
name|found_misc
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
name|ALL_SYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
block|{
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Often many files share a blockvector.        Scan each blockvector only once so that        we don't get every symbol many times.        It happens that the first symtab in the list        for any given blockvector is the main file.  */
if|if
condition|(
name|bv
operator|!=
name|prev_bv
condition|)
for|for
control|(
name|i
operator|=
name|GLOBAL_BLOCK
init|;
name|i
operator|<=
name|STATIC_BLOCK
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|symbol_search
modifier|*
name|prevtail
init|=
name|tail
decl_stmt|;
name|int
name|nfound
init|=
literal|0
decl_stmt|;
name|b
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|BLOCK_NSYMS
argument_list|(
name|b
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
name|sym
operator|=
name|BLOCK_SYM
argument_list|(
name|b
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|file_matches
argument_list|(
name|s
operator|->
name|filename
argument_list|,
name|files
argument_list|,
name|nfiles
argument_list|)
operator|&&
operator|(
operator|(
name|regexp
operator|==
name|NULL
operator|||
name|SYMBOL_MATCHES_REGEXP
argument_list|(
name|sym
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|kind
operator|==
name|VARIABLES_NAMESPACE
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|!=
name|LOC_TYPEDEF
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|!=
name|LOC_BLOCK
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|!=
name|LOC_CONST
operator|)
operator|||
operator|(
name|kind
operator|==
name|FUNCTIONS_NAMESPACE
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_BLOCK
operator|)
operator|||
operator|(
name|kind
operator|==
name|TYPES_NAMESPACE
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_TYPEDEF
operator|)
operator|||
operator|(
name|kind
operator|==
name|METHODS_NAMESPACE
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_BLOCK
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* match */
name|psr
operator|=
operator|(
expr|struct
name|symbol_search
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|symbol_search
argument_list|)
argument_list|)
expr_stmt|;
name|psr
operator|->
name|block
operator|=
name|i
expr_stmt|;
name|psr
operator|->
name|symtab
operator|=
name|s
expr_stmt|;
name|psr
operator|->
name|symbol
operator|=
name|sym
expr_stmt|;
name|psr
operator|->
name|msymbol
operator|=
name|NULL
expr_stmt|;
name|psr
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|tail
operator|==
name|NULL
condition|)
name|sr
operator|=
name|psr
expr_stmt|;
else|else
name|tail
operator|->
name|next
operator|=
name|psr
expr_stmt|;
name|tail
operator|=
name|psr
expr_stmt|;
name|nfound
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nfound
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|prevtail
operator|==
name|NULL
condition|)
block|{
name|struct
name|symbol_search
name|dummy
decl_stmt|;
name|dummy
operator|.
name|next
operator|=
name|sr
expr_stmt|;
name|tail
operator|=
name|sort_search_symbols
argument_list|(
operator|&
name|dummy
argument_list|,
name|nfound
argument_list|)
expr_stmt|;
name|sr
operator|=
name|dummy
operator|.
name|next
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup_free_search_symbols
argument_list|(
name|sr
argument_list|)
expr_stmt|;
block|}
else|else
name|tail
operator|=
name|sort_search_symbols
argument_list|(
name|prevtail
argument_list|,
name|nfound
argument_list|)
expr_stmt|;
block|}
block|}
name|prev_bv
operator|=
name|bv
expr_stmt|;
block|}
comment|/* If there are no eyes, avoid all contact.  I mean, if there are      no debug symbols, then print directly from the msymbol_vector.  */
if|if
condition|(
name|found_misc
operator|||
name|kind
operator|!=
name|FUNCTIONS_NAMESPACE
condition|)
block|{
name|ALL_MSYMBOLS
argument_list|(
argument|objfile
argument_list|,
argument|msymbol
argument_list|)
block|{
if|if
condition|(
name|MSYMBOL_TYPE
argument_list|(
name|msymbol
argument_list|)
operator|==
name|ourtype
operator|||
name|MSYMBOL_TYPE
argument_list|(
name|msymbol
argument_list|)
operator|==
name|ourtype2
operator|||
name|MSYMBOL_TYPE
argument_list|(
name|msymbol
argument_list|)
operator|==
name|ourtype3
operator|||
name|MSYMBOL_TYPE
argument_list|(
name|msymbol
argument_list|)
operator|==
name|ourtype4
condition|)
block|{
if|if
condition|(
name|regexp
operator|==
name|NULL
operator|||
name|SYMBOL_MATCHES_REGEXP
argument_list|(
name|msymbol
argument_list|)
condition|)
block|{
comment|/* Functions:  Look up by address. */
if|if
condition|(
name|kind
operator|!=
name|FUNCTIONS_NAMESPACE
operator|||
operator|(
literal|0
operator|==
name|find_pc_symtab
argument_list|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
argument_list|)
operator|)
condition|)
block|{
comment|/* Variables/Absolutes:  Look up by name */
if|if
condition|(
name|lookup_symbol
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|msymbol
argument_list|)
argument_list|,
operator|(
expr|struct
name|block
operator|*
operator|)
name|NULL
argument_list|,
name|VAR_NAMESPACE
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|symtab
operator|*
operator|*
operator|)
name|NULL
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* match */
name|psr
operator|=
operator|(
expr|struct
name|symbol_search
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|symbol_search
argument_list|)
argument_list|)
expr_stmt|;
name|psr
operator|->
name|block
operator|=
name|i
expr_stmt|;
name|psr
operator|->
name|msymbol
operator|=
name|msymbol
expr_stmt|;
name|psr
operator|->
name|symtab
operator|=
name|NULL
expr_stmt|;
name|psr
operator|->
name|symbol
operator|=
name|NULL
expr_stmt|;
name|psr
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|tail
operator|==
name|NULL
condition|)
block|{
name|sr
operator|=
name|psr
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup_free_search_symbols
argument_list|(
name|sr
argument_list|)
expr_stmt|;
block|}
else|else
name|tail
operator|->
name|next
operator|=
name|psr
expr_stmt|;
name|tail
operator|=
name|psr
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
operator|*
name|matches
operator|=
name|sr
expr_stmt|;
if|if
condition|(
name|sr
operator|!=
name|NULL
condition|)
name|discard_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Helper function for symtab_symbol_info, this function uses    the data returned from search_symbols() to print information    regarding the match to gdb_stdout.  */
end_comment

begin_function
specifier|static
name|void
name|print_symbol_info
parameter_list|(
name|namespace_enum
name|kind
parameter_list|,
name|struct
name|symtab
modifier|*
name|s
parameter_list|,
name|struct
name|symbol
modifier|*
name|sym
parameter_list|,
name|int
name|block
parameter_list|,
name|char
modifier|*
name|last
parameter_list|)
block|{
if|if
condition|(
name|last
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|last
argument_list|,
name|s
operator|->
name|filename
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|"\nFile "
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
name|s
operator|->
name|filename
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|":\n"
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|kind
operator|!=
name|TYPES_NAMESPACE
operator|&&
name|block
operator|==
name|STATIC_BLOCK
condition|)
name|printf_filtered
argument_list|(
literal|"static "
argument_list|)
expr_stmt|;
comment|/* Typedef that is not a C++ class */
if|if
condition|(
name|kind
operator|==
name|TYPES_NAMESPACE
operator|&&
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|!=
name|STRUCT_NAMESPACE
condition|)
name|typedef_print
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|,
name|sym
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
comment|/* variable, func, or typedef-that-is-c++-class */
elseif|else
if|if
condition|(
name|kind
operator|<
name|TYPES_NAMESPACE
operator|||
operator|(
name|kind
operator|==
name|TYPES_NAMESPACE
operator|&&
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|==
name|STRUCT_NAMESPACE
operator|)
condition|)
block|{
name|type_print
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|,
operator|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_TYPEDEF
condition|?
literal|""
else|:
name|SYMBOL_SOURCE_NAME
argument_list|(
name|sym
argument_list|)
operator|)
argument_list|,
name|gdb_stdout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|";\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
literal|0
comment|/* Tiemann says: "info methods was never implemented."  */
block|char *demangled_name;       c_type_print_base (TYPE_FN_FIELD_TYPE (t, block), 			 gdb_stdout, 0, 0);       c_type_print_varspec_prefix (TYPE_FN_FIELD_TYPE (t, block), 				   gdb_stdout, 0);       if (TYPE_FN_FIELD_STUB (t, block)) 	check_stub_method (TYPE_DOMAIN_TYPE (type), j, block);       demangled_name = 	cplus_demangle (TYPE_FN_FIELD_PHYSNAME (t, block), 			DMGL_ANSI | DMGL_PARAMS);       if (demangled_name == NULL) 	fprintf_filtered (stream, "<badly mangled name %s>", 			  TYPE_FN_FIELD_PHYSNAME (t, block));       else 	{ 	  fputs_filtered (demangled_name, stream); 	  xfree (demangled_name); 	}
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/* This help function for symtab_symbol_info() prints information    for non-debugging symbols to gdb_stdout.  */
end_comment

begin_function
specifier|static
name|void
name|print_msymbol_info
parameter_list|(
name|struct
name|minimal_symbol
modifier|*
name|msymbol
parameter_list|)
block|{
name|char
modifier|*
name|tmp
decl_stmt|;
if|if
condition|(
name|TARGET_ADDR_BIT
operator|<=
literal|32
condition|)
name|tmp
operator|=
name|longest_local_hex_string_custom
argument_list|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
operator|&
operator|(
name|CORE_ADDR
operator|)
literal|0xffffffff
argument_list|,
literal|"08l"
argument_list|)
expr_stmt|;
else|else
name|tmp
operator|=
name|longest_local_hex_string_custom
argument_list|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
argument_list|,
literal|"016l"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%s  %s\n"
argument_list|,
name|tmp
argument_list|,
name|SYMBOL_SOURCE_NAME
argument_list|(
name|msymbol
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is the guts of the commands "info functions", "info types", and    "info variables". It calls search_symbols to find all matches and then    print_[m]symbol_info to print out some useful information about the    matches.  */
end_comment

begin_function
specifier|static
name|void
name|symtab_symbol_info
parameter_list|(
name|char
modifier|*
name|regexp
parameter_list|,
name|namespace_enum
name|kind
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|classnames
index|[]
init|=
block|{
literal|"variable"
block|,
literal|"function"
block|,
literal|"type"
block|,
literal|"method"
block|}
decl_stmt|;
name|struct
name|symbol_search
modifier|*
name|symbols
decl_stmt|;
name|struct
name|symbol_search
modifier|*
name|p
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|char
modifier|*
name|last_filename
init|=
name|NULL
decl_stmt|;
name|int
name|first
init|=
literal|1
decl_stmt|;
comment|/* must make sure that if we're interrupted, symbols gets freed */
name|search_symbols
argument_list|(
name|regexp
argument_list|,
name|kind
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|symbols
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup_free_search_symbols
argument_list|(
name|symbols
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
name|regexp
condition|?
literal|"All %ss matching regular expression \"%s\":\n"
else|:
literal|"All defined %ss:\n"
argument_list|,
name|classnames
index|[
call|(
name|int
call|)
argument_list|(
name|kind
operator|-
name|VARIABLES_NAMESPACE
argument_list|)
index|]
argument_list|,
name|regexp
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|symbols
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|QUIT
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|msymbol
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|first
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"\nNon-debugging symbols:\n"
argument_list|)
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
name|print_msymbol_info
argument_list|(
name|p
operator|->
name|msymbol
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|print_symbol_info
argument_list|(
name|kind
argument_list|,
name|p
operator|->
name|symtab
argument_list|,
name|p
operator|->
name|symbol
argument_list|,
name|p
operator|->
name|block
argument_list|,
name|last_filename
argument_list|)
expr_stmt|;
name|last_filename
operator|=
name|p
operator|->
name|symtab
operator|->
name|filename
expr_stmt|;
block|}
block|}
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|variables_info
parameter_list|(
name|char
modifier|*
name|regexp
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|symtab_symbol_info
argument_list|(
name|regexp
argument_list|,
name|VARIABLES_NAMESPACE
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|functions_info
parameter_list|(
name|char
modifier|*
name|regexp
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|symtab_symbol_info
argument_list|(
name|regexp
argument_list|,
name|FUNCTIONS_NAMESPACE
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|types_info
parameter_list|(
name|char
modifier|*
name|regexp
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|symtab_symbol_info
argument_list|(
name|regexp
argument_list|,
name|TYPES_NAMESPACE
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Tiemann says: "info methods was never implemented."  */
end_comment

begin_endif
unit|static void methods_info (char *regexp) {   symtab_symbol_info (regexp, METHODS_NAMESPACE, 0, from_tty); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_comment
comment|/* Breakpoint all functions matching regular expression. */
end_comment

begin_function
name|void
name|rbreak_command_wrapper
parameter_list|(
name|char
modifier|*
name|regexp
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|rbreak_command
argument_list|(
name|regexp
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rbreak_command
parameter_list|(
name|char
modifier|*
name|regexp
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|symbol_search
modifier|*
name|ss
decl_stmt|;
name|struct
name|symbol_search
modifier|*
name|p
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|search_symbols
argument_list|(
name|regexp
argument_list|,
name|FUNCTIONS_NAMESPACE
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|ss
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup_free_search_symbols
argument_list|(
name|ss
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|ss
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|p
operator|->
name|msymbol
operator|==
name|NULL
condition|)
block|{
name|char
modifier|*
name|string
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|p
operator|->
name|symtab
operator|->
name|filename
argument_list|)
operator|+
name|strlen
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|p
operator|->
name|symbol
argument_list|)
argument_list|)
operator|+
literal|4
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|string
argument_list|,
name|p
operator|->
name|symtab
operator|->
name|filename
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|string
argument_list|,
literal|":'"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|string
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|p
operator|->
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|string
argument_list|,
literal|"'"
argument_list|)
expr_stmt|;
name|break_command
argument_list|(
name|string
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
name|print_symbol_info
argument_list|(
name|FUNCTIONS_NAMESPACE
argument_list|,
name|p
operator|->
name|symtab
argument_list|,
name|p
operator|->
name|symbol
argument_list|,
name|p
operator|->
name|block
argument_list|,
name|p
operator|->
name|symtab
operator|->
name|filename
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|break_command
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|p
operator|->
name|msymbol
argument_list|)
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"<function, no debug info> %s;\n"
argument_list|,
name|SYMBOL_SOURCE_NAME
argument_list|(
name|p
operator|->
name|msymbol
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return Nonzero if block a is lexically nested within block b,    or if a and b have the same pc range.    Return zero otherwise. */
end_comment

begin_function
name|int
name|contained_in
parameter_list|(
name|struct
name|block
modifier|*
name|a
parameter_list|,
name|struct
name|block
modifier|*
name|b
parameter_list|)
block|{
if|if
condition|(
operator|!
name|a
operator|||
operator|!
name|b
condition|)
return|return
literal|0
return|;
return|return
name|BLOCK_START
argument_list|(
name|a
argument_list|)
operator|>=
name|BLOCK_START
argument_list|(
name|b
argument_list|)
operator|&&
name|BLOCK_END
argument_list|(
name|a
argument_list|)
operator|<=
name|BLOCK_END
argument_list|(
name|b
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Helper routine for make_symbol_completion_list.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|return_val_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|return_val_index
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|return_val
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|COMPLETION_LIST_ADD_SYMBOL
parameter_list|(
name|symbol
parameter_list|,
name|sym_text
parameter_list|,
name|len
parameter_list|,
name|text
parameter_list|,
name|word
parameter_list|)
define|\
value|do { \     if (SYMBOL_DEMANGLED_NAME (symbol) != NULL) \
comment|/* Put only the mangled name on the list.  */
value|\
comment|/* Advantage:  "b foo<TAB>" completes to "b foo(int, int)" */
value|\
comment|/* Disadvantage:  "b foo__i<TAB>" doesn't complete.  */
value|\       completion_list_add_name \ 	(SYMBOL_DEMANGLED_NAME (symbol), (sym_text), (len), (text), (word)); \     else \       completion_list_add_name \ 	(SYMBOL_NAME (symbol), (sym_text), (len), (text), (word)); \   } while (0)
end_define

begin_comment
comment|/*  Test to see if the symbol specified by SYMNAME (which is already    demangled for C++ symbols) matches SYM_TEXT in the first SYM_TEXT_LEN    characters.  If so, add it to the current completion list. */
end_comment

begin_function
specifier|static
name|void
name|completion_list_add_name
parameter_list|(
name|char
modifier|*
name|symname
parameter_list|,
name|char
modifier|*
name|sym_text
parameter_list|,
name|int
name|sym_text_len
parameter_list|,
name|char
modifier|*
name|text
parameter_list|,
name|char
modifier|*
name|word
parameter_list|)
block|{
name|int
name|newsize
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* clip symbols that cannot match */
if|if
condition|(
name|strncmp
argument_list|(
name|symname
argument_list|,
name|sym_text
argument_list|,
name|sym_text_len
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return;
block|}
comment|/* We have a match for a completion, so add SYMNAME to the current list      of matches. Note that the name is moved to freshly malloc'd space. */
block|{
name|char
modifier|*
name|new
decl_stmt|;
if|if
condition|(
name|word
operator|==
name|sym_text
condition|)
block|{
name|new
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|symname
argument_list|)
operator|+
literal|5
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|new
argument_list|,
name|symname
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|word
operator|>
name|sym_text
condition|)
block|{
comment|/* Return some portion of symname.  */
name|new
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|symname
argument_list|)
operator|+
literal|5
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|new
argument_list|,
name|symname
operator|+
operator|(
name|word
operator|-
name|sym_text
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Return some of SYM_TEXT plus symname.  */
name|new
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|symname
argument_list|)
operator|+
operator|(
name|sym_text
operator|-
name|word
operator|)
operator|+
literal|5
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|new
argument_list|,
name|word
argument_list|,
name|sym_text
operator|-
name|word
argument_list|)
expr_stmt|;
name|new
index|[
name|sym_text
operator|-
name|word
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strcat
argument_list|(
name|new
argument_list|,
name|symname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|return_val_index
operator|+
literal|3
operator|>
name|return_val_size
condition|)
block|{
name|newsize
operator|=
operator|(
name|return_val_size
operator|*=
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
expr_stmt|;
name|return_val
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|return_val
argument_list|,
name|newsize
argument_list|)
expr_stmt|;
block|}
name|return_val
index|[
name|return_val_index
operator|++
index|]
operator|=
name|new
expr_stmt|;
name|return_val
index|[
name|return_val_index
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return a NULL terminated array of all symbols (regardless of class)    which begin by matching TEXT.  If the answer is no symbols, then    the return value is an array which contains only a NULL pointer.     Problem: All of the symbols have to be copied because readline frees them.    I'm not going to worry about this; hopefully there won't be that many.  */
end_comment

begin_function
name|char
modifier|*
modifier|*
name|make_symbol_completion_list
parameter_list|(
name|char
modifier|*
name|text
parameter_list|,
name|char
modifier|*
name|word
parameter_list|)
block|{
specifier|register
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
specifier|register
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
specifier|register
name|struct
name|partial_symtab
modifier|*
name|ps
decl_stmt|;
specifier|register
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
specifier|register
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
specifier|register
name|struct
name|block
modifier|*
name|b
decl_stmt|,
modifier|*
name|surrounding_static_block
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|struct
name|partial_symbol
modifier|*
modifier|*
name|psym
decl_stmt|;
comment|/* The symbol we are completing on.  Points in same buffer as text.  */
name|char
modifier|*
name|sym_text
decl_stmt|;
comment|/* Length of sym_text.  */
name|int
name|sym_text_len
decl_stmt|;
comment|/* Now look for the symbol we are supposed to complete on.      FIXME: This should be language-specific.  */
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|quote_found
decl_stmt|;
name|char
modifier|*
name|quote_pos
init|=
name|NULL
decl_stmt|;
comment|/* First see if this is a quoted string.  */
name|quote_found
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|p
operator|=
name|text
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
operator|++
name|p
control|)
block|{
if|if
condition|(
name|quote_found
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
name|quote_found
condition|)
comment|/* Found close quote.  */
name|quote_found
operator|=
literal|'\0'
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'\\'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
name|quote_found
condition|)
comment|/* A backslash followed by the quote character 	         doesn't end the string.  */
operator|++
name|p
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'\''
operator|||
operator|*
name|p
operator|==
literal|'"'
condition|)
block|{
name|quote_found
operator|=
operator|*
name|p
expr_stmt|;
name|quote_pos
operator|=
name|p
expr_stmt|;
block|}
block|}
if|if
condition|(
name|quote_found
operator|==
literal|'\''
condition|)
comment|/* A string within single quotes can be a symbol, so complete on it.  */
name|sym_text
operator|=
name|quote_pos
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|quote_found
operator|==
literal|'"'
condition|)
comment|/* A double-quoted string is never a symbol, nor does it make sense          to complete it any other way.  */
block|{
name|return_val
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|return_val
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
return|return
name|return_val
return|;
block|}
else|else
block|{
comment|/* It is not a quoted string.  Break it based on the characters 	   which are in symbols.  */
while|while
condition|(
name|p
operator|>
name|text
condition|)
block|{
if|if
condition|(
name|isalnum
argument_list|(
name|p
index|[
operator|-
literal|1
index|]
argument_list|)
operator|||
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'_'
operator|||
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'\0'
condition|)
operator|--
name|p
expr_stmt|;
else|else
break|break;
block|}
name|sym_text
operator|=
name|p
expr_stmt|;
block|}
block|}
name|sym_text_len
operator|=
name|strlen
argument_list|(
name|sym_text
argument_list|)
expr_stmt|;
name|return_val_size
operator|=
literal|100
expr_stmt|;
name|return_val_index
operator|=
literal|0
expr_stmt|;
name|return_val
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|return_val_size
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|return_val
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* Look through the partial symtabs for all symbols which begin      by matching SYM_TEXT.  Add each one that you find to the list.  */
name|ALL_PSYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|ps
argument_list|)
block|{
comment|/* If the psymtab's been read in we'll get it when we search        through the blockvector.  */
if|if
condition|(
name|ps
operator|->
name|readin
condition|)
continue|continue;
for|for
control|(
name|psym
operator|=
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
operator|+
name|ps
operator|->
name|globals_offset
init|;
name|psym
operator|<
operator|(
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
operator|+
name|ps
operator|->
name|globals_offset
operator|+
name|ps
operator|->
name|n_global_syms
operator|)
condition|;
name|psym
operator|++
control|)
block|{
comment|/* If interrupted, then quit. */
name|QUIT
expr_stmt|;
name|COMPLETION_LIST_ADD_SYMBOL
argument_list|(
operator|*
name|psym
argument_list|,
name|sym_text
argument_list|,
name|sym_text_len
argument_list|,
name|text
argument_list|,
name|word
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|psym
operator|=
name|objfile
operator|->
name|static_psymbols
operator|.
name|list
operator|+
name|ps
operator|->
name|statics_offset
init|;
name|psym
operator|<
operator|(
name|objfile
operator|->
name|static_psymbols
operator|.
name|list
operator|+
name|ps
operator|->
name|statics_offset
operator|+
name|ps
operator|->
name|n_static_syms
operator|)
condition|;
name|psym
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
name|COMPLETION_LIST_ADD_SYMBOL
argument_list|(
operator|*
name|psym
argument_list|,
name|sym_text
argument_list|,
name|sym_text_len
argument_list|,
name|text
argument_list|,
name|word
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* At this point scan through the misc symbol vectors and add each      symbol you find to the list.  Eventually we want to ignore      anything that isn't a text symbol (everything else will be      handled by the psymtab code above).  */
name|ALL_MSYMBOLS
argument_list|(
argument|objfile
argument_list|,
argument|msymbol
argument_list|)
block|{
name|QUIT
expr_stmt|;
name|COMPLETION_LIST_ADD_SYMBOL
argument_list|(
name|msymbol
argument_list|,
name|sym_text
argument_list|,
name|sym_text_len
argument_list|,
name|text
argument_list|,
name|word
argument_list|)
expr_stmt|;
block|}
comment|/* Search upwards from currently selected frame (so that we can      complete on local vars.  */
for|for
control|(
name|b
operator|=
name|get_selected_block
argument_list|()
init|;
name|b
operator|!=
name|NULL
condition|;
name|b
operator|=
name|BLOCK_SUPERBLOCK
argument_list|(
name|b
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|BLOCK_SUPERBLOCK
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|surrounding_static_block
operator|=
name|b
expr_stmt|;
comment|/* For elmin of dups */
block|}
comment|/* Also catch fields of types defined in this places which match our          text string.  Only complete on types visible from current context. */
name|ALL_BLOCK_SYMBOLS
argument_list|(
argument|b
argument_list|,
argument|i
argument_list|,
argument|sym
argument_list|)
block|{
name|COMPLETION_LIST_ADD_SYMBOL
argument_list|(
name|sym
argument_list|,
name|sym_text
argument_list|,
name|sym_text_len
argument_list|,
name|text
argument_list|,
name|word
argument_list|)
expr_stmt|;
if|if
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_TYPEDEF
condition|)
block|{
name|struct
name|type
modifier|*
name|t
init|=
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
decl_stmt|;
name|enum
name|type_code
name|c
init|=
name|TYPE_CODE
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|TYPE_CODE_UNION
operator|||
name|c
operator|==
name|TYPE_CODE_STRUCT
condition|)
block|{
for|for
control|(
name|j
operator|=
name|TYPE_N_BASECLASSES
argument_list|(
name|t
argument_list|)
init|;
name|j
operator|<
name|TYPE_NFIELDS
argument_list|(
name|t
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|TYPE_FIELD_NAME
argument_list|(
name|t
argument_list|,
name|j
argument_list|)
condition|)
block|{
name|completion_list_add_name
argument_list|(
name|TYPE_FIELD_NAME
argument_list|(
name|t
argument_list|,
name|j
argument_list|)
argument_list|,
name|sym_text
argument_list|,
name|sym_text_len
argument_list|,
name|text
argument_list|,
name|word
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
comment|/* Go through the symtabs and check the externs and statics for      symbols which match.  */
name|ALL_SYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
block|{
name|QUIT
expr_stmt|;
name|b
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
expr_stmt|;
name|ALL_BLOCK_SYMBOLS
argument_list|(
argument|b
argument_list|,
argument|i
argument_list|,
argument|sym
argument_list|)
block|{
name|COMPLETION_LIST_ADD_SYMBOL
argument_list|(
name|sym
argument_list|,
name|sym_text
argument_list|,
name|sym_text_len
argument_list|,
name|text
argument_list|,
name|word
argument_list|)
expr_stmt|;
block|}
block|}
name|ALL_SYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
block|{
name|QUIT
expr_stmt|;
name|b
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
argument_list|,
name|STATIC_BLOCK
argument_list|)
expr_stmt|;
comment|/* Don't do this block twice.  */
if|if
condition|(
name|b
operator|==
name|surrounding_static_block
condition|)
continue|continue;
name|ALL_BLOCK_SYMBOLS
argument_list|(
argument|b
argument_list|,
argument|i
argument_list|,
argument|sym
argument_list|)
block|{
name|COMPLETION_LIST_ADD_SYMBOL
argument_list|(
name|sym
argument_list|,
name|sym_text
argument_list|,
name|sym_text_len
argument_list|,
name|text
argument_list|,
name|word
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|return_val
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Like make_symbol_completion_list, but returns a list of symbols    defined in a source file FILE.  */
end_comment

begin_function
name|char
modifier|*
modifier|*
name|make_file_symbol_completion_list
parameter_list|(
name|char
modifier|*
name|text
parameter_list|,
name|char
modifier|*
name|word
parameter_list|,
name|char
modifier|*
name|srcfile
parameter_list|)
block|{
specifier|register
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
specifier|register
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
specifier|register
name|struct
name|block
modifier|*
name|b
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* The symbol we are completing on.  Points in same buffer as text.  */
name|char
modifier|*
name|sym_text
decl_stmt|;
comment|/* Length of sym_text.  */
name|int
name|sym_text_len
decl_stmt|;
comment|/* Now look for the symbol we are supposed to complete on.      FIXME: This should be language-specific.  */
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|quote_found
decl_stmt|;
name|char
modifier|*
name|quote_pos
init|=
name|NULL
decl_stmt|;
comment|/* First see if this is a quoted string.  */
name|quote_found
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|p
operator|=
name|text
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
operator|++
name|p
control|)
block|{
if|if
condition|(
name|quote_found
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
name|quote_found
condition|)
comment|/* Found close quote.  */
name|quote_found
operator|=
literal|'\0'
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'\\'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
name|quote_found
condition|)
comment|/* A backslash followed by the quote character 	         doesn't end the string.  */
operator|++
name|p
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'\''
operator|||
operator|*
name|p
operator|==
literal|'"'
condition|)
block|{
name|quote_found
operator|=
operator|*
name|p
expr_stmt|;
name|quote_pos
operator|=
name|p
expr_stmt|;
block|}
block|}
if|if
condition|(
name|quote_found
operator|==
literal|'\''
condition|)
comment|/* A string within single quotes can be a symbol, so complete on it.  */
name|sym_text
operator|=
name|quote_pos
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|quote_found
operator|==
literal|'"'
condition|)
comment|/* A double-quoted string is never a symbol, nor does it make sense          to complete it any other way.  */
block|{
name|return_val
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|return_val
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
return|return
name|return_val
return|;
block|}
else|else
block|{
comment|/* It is not a quoted string.  Break it based on the characters 	   which are in symbols.  */
while|while
condition|(
name|p
operator|>
name|text
condition|)
block|{
if|if
condition|(
name|isalnum
argument_list|(
name|p
index|[
operator|-
literal|1
index|]
argument_list|)
operator|||
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'_'
operator|||
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'\0'
condition|)
operator|--
name|p
expr_stmt|;
else|else
break|break;
block|}
name|sym_text
operator|=
name|p
expr_stmt|;
block|}
block|}
name|sym_text_len
operator|=
name|strlen
argument_list|(
name|sym_text
argument_list|)
expr_stmt|;
name|return_val_size
operator|=
literal|10
expr_stmt|;
name|return_val_index
operator|=
literal|0
expr_stmt|;
name|return_val
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|return_val_size
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|return_val
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* Find the symtab for SRCFILE (this loads it if it was not yet read      in).  */
name|s
operator|=
name|lookup_symtab
argument_list|(
name|srcfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
block|{
comment|/* Maybe they typed the file with leading directories, while the 	 symbol tables record only its basename.  */
specifier|const
name|char
modifier|*
name|tail
init|=
name|lbasename
argument_list|(
name|srcfile
argument_list|)
decl_stmt|;
if|if
condition|(
name|tail
operator|>
name|srcfile
condition|)
name|s
operator|=
name|lookup_symtab
argument_list|(
name|tail
argument_list|)
expr_stmt|;
block|}
comment|/* If we have no symtab for that file, return an empty list.  */
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return
operator|(
name|return_val
operator|)
return|;
comment|/* Go through this symtab and check the externs and statics for      symbols which match.  */
name|b
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
expr_stmt|;
name|ALL_BLOCK_SYMBOLS
argument_list|(
argument|b
argument_list|,
argument|i
argument_list|,
argument|sym
argument_list|)
block|{
name|COMPLETION_LIST_ADD_SYMBOL
argument_list|(
name|sym
argument_list|,
name|sym_text
argument_list|,
name|sym_text_len
argument_list|,
name|text
argument_list|,
name|word
argument_list|)
expr_stmt|;
block|}
name|b
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
argument_list|,
name|STATIC_BLOCK
argument_list|)
expr_stmt|;
name|ALL_BLOCK_SYMBOLS
argument_list|(
argument|b
argument_list|,
argument|i
argument_list|,
argument|sym
argument_list|)
block|{
name|COMPLETION_LIST_ADD_SYMBOL
argument_list|(
name|sym
argument_list|,
name|sym_text
argument_list|,
name|sym_text_len
argument_list|,
name|text
argument_list|,
name|word
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|return_val
operator|)
return|;
block|}
end_function

begin_comment
comment|/* A helper function for make_source_files_completion_list.  It adds    another file name to a list of possible completions, growing the    list as necessary.  */
end_comment

begin_function
specifier|static
name|void
name|add_filename_to_list
parameter_list|(
specifier|const
name|char
modifier|*
name|fname
parameter_list|,
name|char
modifier|*
name|text
parameter_list|,
name|char
modifier|*
name|word
parameter_list|,
name|char
modifier|*
modifier|*
modifier|*
name|list
parameter_list|,
name|int
modifier|*
name|list_used
parameter_list|,
name|int
modifier|*
name|list_alloced
parameter_list|)
block|{
name|char
modifier|*
name|new
decl_stmt|;
name|size_t
name|fnlen
init|=
name|strlen
argument_list|(
name|fname
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|list_used
operator|+
literal|1
operator|>=
operator|*
name|list_alloced
condition|)
block|{
operator|*
name|list_alloced
operator|*=
literal|2
expr_stmt|;
operator|*
name|list
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|*
name|list
argument_list|,
operator|*
name|list_alloced
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|word
operator|==
name|text
condition|)
block|{
comment|/* Return exactly fname.  */
name|new
operator|=
name|xmalloc
argument_list|(
name|fnlen
operator|+
literal|5
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|new
argument_list|,
name|fname
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|word
operator|>
name|text
condition|)
block|{
comment|/* Return some portion of fname.  */
name|new
operator|=
name|xmalloc
argument_list|(
name|fnlen
operator|+
literal|5
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|new
argument_list|,
name|fname
operator|+
operator|(
name|word
operator|-
name|text
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Return some of TEXT plus fname.  */
name|new
operator|=
name|xmalloc
argument_list|(
name|fnlen
operator|+
operator|(
name|text
operator|-
name|word
operator|)
operator|+
literal|5
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|new
argument_list|,
name|word
argument_list|,
name|text
operator|-
name|word
argument_list|)
expr_stmt|;
name|new
index|[
name|text
operator|-
name|word
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strcat
argument_list|(
name|new
argument_list|,
name|fname
argument_list|)
expr_stmt|;
block|}
operator|(
operator|*
name|list
operator|)
index|[
operator|*
name|list_used
index|]
operator|=
name|new
expr_stmt|;
operator|(
operator|*
name|list
operator|)
index|[
operator|++
operator|*
name|list_used
index|]
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|not_interesting_fname
parameter_list|(
specifier|const
name|char
modifier|*
name|fname
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|illegal_aliens
index|[]
init|=
block|{
literal|"_globals_"
block|,
comment|/* inserted by coff_symtab_read */
name|NULL
block|}
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|illegal_aliens
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|fname
argument_list|,
name|illegal_aliens
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return a NULL terminated array of all source files whose names    begin with matching TEXT.  The file names are looked up in the    symbol tables of this program.  If the answer is no matchess, then    the return value is an array which contains only a NULL pointer.  */
end_comment

begin_function
name|char
modifier|*
modifier|*
name|make_source_files_completion_list
parameter_list|(
name|char
modifier|*
name|text
parameter_list|,
name|char
modifier|*
name|word
parameter_list|)
block|{
specifier|register
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
specifier|register
name|struct
name|partial_symtab
modifier|*
name|ps
decl_stmt|;
specifier|register
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|int
name|first
init|=
literal|1
decl_stmt|;
name|int
name|list_alloced
init|=
literal|1
decl_stmt|;
name|int
name|list_used
init|=
literal|0
decl_stmt|;
name|size_t
name|text_len
init|=
name|strlen
argument_list|(
name|text
argument_list|)
decl_stmt|;
name|char
modifier|*
modifier|*
name|list
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|list_alloced
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|base_name
decl_stmt|;
name|list
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|have_full_symbols
argument_list|()
operator|&&
operator|!
name|have_partial_symbols
argument_list|()
condition|)
return|return
name|list
return|;
name|ALL_SYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
block|{
if|if
condition|(
name|not_interesting_fname
argument_list|(
name|s
operator|->
name|filename
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|filename_seen
argument_list|(
name|s
operator|->
name|filename
argument_list|,
literal|1
argument_list|,
operator|&
name|first
argument_list|)
if|#
directive|if
name|HAVE_DOS_BASED_FILE_SYSTEM
operator|&&
name|strncasecmp
argument_list|(
name|s
operator|->
name|filename
argument_list|,
name|text
argument_list|,
name|text_len
argument_list|)
operator|==
literal|0
else|#
directive|else
operator|&&
name|strncmp
argument_list|(
name|s
operator|->
name|filename
argument_list|,
name|text
argument_list|,
name|text_len
argument_list|)
operator|==
literal|0
endif|#
directive|endif
condition|)
block|{
comment|/* This file matches for a completion; add it to the current 	     list of matches.  */
name|add_filename_to_list
argument_list|(
name|s
operator|->
name|filename
argument_list|,
name|text
argument_list|,
name|word
argument_list|,
operator|&
name|list
argument_list|,
operator|&
name|list_used
argument_list|,
operator|&
name|list_alloced
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* NOTE: We allow the user to type a base name when the 	     debug info records leading directories, but not the other 	     way around.  This is what subroutines of breakpoint 	     command do when they parse file names.  */
name|base_name
operator|=
name|lbasename
argument_list|(
name|s
operator|->
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|base_name
operator|!=
name|s
operator|->
name|filename
operator|&&
operator|!
name|filename_seen
argument_list|(
name|base_name
argument_list|,
literal|1
argument_list|,
operator|&
name|first
argument_list|)
if|#
directive|if
name|HAVE_DOS_BASED_FILE_SYSTEM
operator|&&
name|strncasecmp
argument_list|(
name|base_name
argument_list|,
name|text
argument_list|,
name|text_len
argument_list|)
operator|==
literal|0
else|#
directive|else
operator|&&
name|strncmp
argument_list|(
name|base_name
argument_list|,
name|text
argument_list|,
name|text_len
argument_list|)
operator|==
literal|0
endif|#
directive|endif
condition|)
name|add_filename_to_list
argument_list|(
name|base_name
argument_list|,
name|text
argument_list|,
name|word
argument_list|,
operator|&
name|list
argument_list|,
operator|&
name|list_used
argument_list|,
operator|&
name|list_alloced
argument_list|)
expr_stmt|;
block|}
block|}
name|ALL_PSYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|ps
argument_list|)
block|{
if|if
condition|(
name|not_interesting_fname
argument_list|(
name|ps
operator|->
name|filename
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|ps
operator|->
name|readin
condition|)
block|{
if|if
condition|(
operator|!
name|filename_seen
argument_list|(
name|ps
operator|->
name|filename
argument_list|,
literal|1
argument_list|,
operator|&
name|first
argument_list|)
if|#
directive|if
name|HAVE_DOS_BASED_FILE_SYSTEM
operator|&&
name|strncasecmp
argument_list|(
name|ps
operator|->
name|filename
argument_list|,
name|text
argument_list|,
name|text_len
argument_list|)
operator|==
literal|0
else|#
directive|else
operator|&&
name|strncmp
argument_list|(
name|ps
operator|->
name|filename
argument_list|,
name|text
argument_list|,
name|text_len
argument_list|)
operator|==
literal|0
endif|#
directive|endif
condition|)
block|{
comment|/* This file matches for a completion; add it to the 		 current list of matches.  */
name|add_filename_to_list
argument_list|(
name|ps
operator|->
name|filename
argument_list|,
name|text
argument_list|,
name|word
argument_list|,
operator|&
name|list
argument_list|,
operator|&
name|list_used
argument_list|,
operator|&
name|list_alloced
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|base_name
operator|=
name|lbasename
argument_list|(
name|ps
operator|->
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|base_name
operator|!=
name|ps
operator|->
name|filename
operator|&&
operator|!
name|filename_seen
argument_list|(
name|base_name
argument_list|,
literal|1
argument_list|,
operator|&
name|first
argument_list|)
if|#
directive|if
name|HAVE_DOS_BASED_FILE_SYSTEM
operator|&&
name|strncasecmp
argument_list|(
name|base_name
argument_list|,
name|text
argument_list|,
name|text_len
argument_list|)
operator|==
literal|0
else|#
directive|else
operator|&&
name|strncmp
argument_list|(
name|base_name
argument_list|,
name|text
argument_list|,
name|text_len
argument_list|)
operator|==
literal|0
endif|#
directive|endif
condition|)
name|add_filename_to_list
argument_list|(
name|base_name
argument_list|,
name|text
argument_list|,
name|word
argument_list|,
operator|&
name|list
argument_list|,
operator|&
name|list_used
argument_list|,
operator|&
name|list_alloced
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|list
return|;
block|}
end_function

begin_comment
comment|/* Determine if PC is in the prologue of a function.  The prologue is the area    between the first instruction of a function, and the first executable line.    Returns 1 if PC *might* be in prologue, 0 if definately *not* in prologue.     If non-zero, func_start is where we think the prologue starts, possibly    by previous examination of symbol table information.  */
end_comment

begin_function
name|int
name|in_prologue
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|CORE_ADDR
name|func_start
parameter_list|)
block|{
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|CORE_ADDR
name|func_addr
decl_stmt|,
name|func_end
decl_stmt|;
comment|/* We have several sources of information we can consult to figure      this out.      - Compilers usually emit line number info that marks the prologue        as its own "source line".  So the ending address of that "line"        is the end of the prologue.  If available, this is the most        reliable method.      - The minimal symbols and partial symbols, which can usually tell        us the starting and ending addresses of a function.      - If we know the function's start address, we can call the        architecture-defined SKIP_PROLOGUE function to analyze the        instruction stream and guess where the prologue ends.      - Our `func_start' argument; if non-zero, this is the caller's        best guess as to the function's entry point.  At the time of        this writing, handle_inferior_event doesn't get this right, so        it should be our last resort.  */
comment|/* Consult the partial symbol table, to find which function      the PC is in.  */
if|if
condition|(
operator|!
name|find_pc_partial_function
argument_list|(
name|pc
argument_list|,
name|NULL
argument_list|,
operator|&
name|func_addr
argument_list|,
operator|&
name|func_end
argument_list|)
condition|)
block|{
name|CORE_ADDR
name|prologue_end
decl_stmt|;
comment|/* We don't even have minsym information, so fall back to using          func_start, if given.  */
if|if
condition|(
operator|!
name|func_start
condition|)
return|return
literal|1
return|;
comment|/* We *might* be in a prologue.  */
name|prologue_end
operator|=
name|SKIP_PROLOGUE
argument_list|(
name|func_start
argument_list|)
expr_stmt|;
return|return
name|func_start
operator|<=
name|pc
operator|&&
name|pc
operator|<
name|prologue_end
return|;
block|}
comment|/* If we have line number information for the function, that's      usually pretty reliable.  */
name|sal
operator|=
name|find_pc_line
argument_list|(
name|func_addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Now sal describes the source line at the function's entry point,      which (by convention) is the prologue.  The end of that "line",      sal.end, is the end of the prologue.       Note that, for functions whose source code is all on a single      line, the line number information doesn't always end up this way.      So we must verify that our purported end-of-prologue address is      *within* the function, not at its start or end.  */
if|if
condition|(
name|sal
operator|.
name|line
operator|==
literal|0
operator|||
name|sal
operator|.
name|end
operator|<=
name|func_addr
operator|||
name|func_end
operator|<=
name|sal
operator|.
name|end
condition|)
block|{
comment|/* We don't have any good line number info, so use the minsym 	 information, together with the architecture-specific prologue 	 scanning code.  */
name|CORE_ADDR
name|prologue_end
init|=
name|SKIP_PROLOGUE
argument_list|(
name|func_addr
argument_list|)
decl_stmt|;
return|return
name|func_addr
operator|<=
name|pc
operator|&&
name|pc
operator|<
name|prologue_end
return|;
block|}
comment|/* We have line number info, and it looks good.  */
return|return
name|func_addr
operator|<=
name|pc
operator|&&
name|pc
operator|<
name|sal
operator|.
name|end
return|;
block|}
end_function

begin_comment
comment|/* Begin overload resolution functions */
end_comment

begin_comment
comment|/* Helper routine for make_symbol_completion_list.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sym_return_val_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sym_return_val_index
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|symbol
modifier|*
modifier|*
name|sym_return_val
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  Test to see if the symbol specified by SYMNAME (which is already    demangled for C++ symbols) matches SYM_TEXT in the first SYM_TEXT_LEN    characters.  If so, add it to the current completion list. */
end_comment

begin_function
specifier|static
name|void
name|overload_list_add_symbol
parameter_list|(
name|struct
name|symbol
modifier|*
name|sym
parameter_list|,
name|char
modifier|*
name|oload_name
parameter_list|)
block|{
name|int
name|newsize
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Get the demangled name without parameters */
name|char
modifier|*
name|sym_name
init|=
name|cplus_demangle
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|DMGL_ARM
operator||
name|DMGL_ANSI
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|sym_name
condition|)
block|{
name|sym_name
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|sym_name
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* skip symbols that cannot match */
if|if
condition|(
name|strcmp
argument_list|(
name|sym_name
argument_list|,
name|oload_name
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|xfree
argument_list|(
name|sym_name
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If there is no type information, we can't do anything, so skip */
if|if
condition|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|==
name|NULL
condition|)
return|return;
comment|/* skip any symbols that we've already considered. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sym_return_val_index
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|sym_return_val
index|[
name|i
index|]
argument_list|)
argument_list|)
condition|)
return|return;
comment|/* We have a match for an overload instance, so add SYM to the current list    * of overload instances */
if|if
condition|(
name|sym_return_val_index
operator|+
literal|3
operator|>
name|sym_return_val_size
condition|)
block|{
name|newsize
operator|=
operator|(
name|sym_return_val_size
operator|*=
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
operator|*
argument_list|)
expr_stmt|;
name|sym_return_val
operator|=
operator|(
expr|struct
name|symbol
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sym_return_val
argument_list|,
name|newsize
argument_list|)
expr_stmt|;
block|}
name|sym_return_val
index|[
name|sym_return_val_index
operator|++
index|]
operator|=
name|sym
expr_stmt|;
name|sym_return_val
index|[
name|sym_return_val_index
index|]
operator|=
name|NULL
expr_stmt|;
name|xfree
argument_list|(
name|sym_name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a null-terminated list of pointers to function symbols that  * match name of the supplied symbol FSYM.  * This is used in finding all overloaded instances of a function name.  * This has been modified from make_symbol_completion_list.  */
end_comment

begin_function
name|struct
name|symbol
modifier|*
modifier|*
name|make_symbol_overload_list
parameter_list|(
name|struct
name|symbol
modifier|*
name|fsym
parameter_list|)
block|{
specifier|register
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
specifier|register
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
specifier|register
name|struct
name|partial_symtab
modifier|*
name|ps
decl_stmt|;
specifier|register
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
specifier|register
name|struct
name|block
modifier|*
name|b
decl_stmt|,
modifier|*
name|surrounding_static_block
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* The name we are completing on. */
name|char
modifier|*
name|oload_name
init|=
name|NULL
decl_stmt|;
comment|/* Length of name.  */
name|int
name|oload_name_len
init|=
literal|0
decl_stmt|;
comment|/* Look for the symbol we are supposed to complete on.    * FIXME: This should be language-specific.  */
name|oload_name
operator|=
name|cplus_demangle
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|fsym
argument_list|)
argument_list|,
name|DMGL_ARM
operator||
name|DMGL_ANSI
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|oload_name
condition|)
block|{
name|oload_name
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|fsym
argument_list|)
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|oload_name
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|fsym
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|oload_name_len
operator|=
name|strlen
argument_list|(
name|oload_name
argument_list|)
expr_stmt|;
name|sym_return_val_size
operator|=
literal|100
expr_stmt|;
name|sym_return_val_index
operator|=
literal|0
expr_stmt|;
name|sym_return_val
operator|=
operator|(
expr|struct
name|symbol
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|sym_return_val_size
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|sym_return_val
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* Look through the partial symtabs for all symbols which begin      by matching OLOAD_NAME.  Make sure we read that symbol table in. */
name|ALL_PSYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|ps
argument_list|)
block|{
name|struct
name|partial_symbol
modifier|*
modifier|*
name|psym
decl_stmt|;
comment|/* If the psymtab's been read in we'll get it when we search        through the blockvector.  */
if|if
condition|(
name|ps
operator|->
name|readin
condition|)
continue|continue;
for|for
control|(
name|psym
operator|=
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
operator|+
name|ps
operator|->
name|globals_offset
init|;
name|psym
operator|<
operator|(
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
operator|+
name|ps
operator|->
name|globals_offset
operator|+
name|ps
operator|->
name|n_global_syms
operator|)
condition|;
name|psym
operator|++
control|)
block|{
comment|/* If interrupted, then quit. */
name|QUIT
expr_stmt|;
comment|/* This will cause the symbol table to be read if it has not yet been */
name|s
operator|=
name|PSYMTAB_TO_SYMTAB
argument_list|(
name|ps
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|psym
operator|=
name|objfile
operator|->
name|static_psymbols
operator|.
name|list
operator|+
name|ps
operator|->
name|statics_offset
init|;
name|psym
operator|<
operator|(
name|objfile
operator|->
name|static_psymbols
operator|.
name|list
operator|+
name|ps
operator|->
name|statics_offset
operator|+
name|ps
operator|->
name|n_static_syms
operator|)
condition|;
name|psym
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
comment|/* This will cause the symbol table to be read if it has not yet been */
name|s
operator|=
name|PSYMTAB_TO_SYMTAB
argument_list|(
name|ps
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Search upwards from currently selected frame (so that we can      complete on local vars.  */
for|for
control|(
name|b
operator|=
name|get_selected_block
argument_list|()
init|;
name|b
operator|!=
name|NULL
condition|;
name|b
operator|=
name|BLOCK_SUPERBLOCK
argument_list|(
name|b
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|BLOCK_SUPERBLOCK
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|surrounding_static_block
operator|=
name|b
expr_stmt|;
comment|/* For elimination of dups */
block|}
comment|/* Also catch fields of types defined in this places which match our          text string.  Only complete on types visible from current context. */
name|ALL_BLOCK_SYMBOLS
argument_list|(
argument|b
argument_list|,
argument|i
argument_list|,
argument|sym
argument_list|)
block|{
name|overload_list_add_symbol
argument_list|(
name|sym
argument_list|,
name|oload_name
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Go through the symtabs and check the externs and statics for      symbols which match.  */
name|ALL_SYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
block|{
name|QUIT
expr_stmt|;
name|b
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
expr_stmt|;
name|ALL_BLOCK_SYMBOLS
argument_list|(
argument|b
argument_list|,
argument|i
argument_list|,
argument|sym
argument_list|)
block|{
name|overload_list_add_symbol
argument_list|(
name|sym
argument_list|,
name|oload_name
argument_list|)
expr_stmt|;
block|}
block|}
name|ALL_SYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
block|{
name|QUIT
expr_stmt|;
name|b
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
argument_list|,
name|STATIC_BLOCK
argument_list|)
expr_stmt|;
comment|/* Don't do this block twice.  */
if|if
condition|(
name|b
operator|==
name|surrounding_static_block
condition|)
continue|continue;
name|ALL_BLOCK_SYMBOLS
argument_list|(
argument|b
argument_list|,
argument|i
argument_list|,
argument|sym
argument_list|)
block|{
name|overload_list_add_symbol
argument_list|(
name|sym
argument_list|,
name|oload_name
argument_list|)
expr_stmt|;
block|}
block|}
name|xfree
argument_list|(
name|oload_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|sym_return_val
operator|)
return|;
block|}
end_function

begin_comment
comment|/* End of overload resolution functions */
end_comment

begin_escape
end_escape

begin_function
name|struct
name|symtabs_and_lines
name|decode_line_spec
parameter_list|(
name|char
modifier|*
name|string
parameter_list|,
name|int
name|funfirstline
parameter_list|)
block|{
name|struct
name|symtabs_and_lines
name|sals
decl_stmt|;
if|if
condition|(
name|string
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Empty line specification."
argument_list|)
expr_stmt|;
name|sals
operator|=
name|decode_line_1
argument_list|(
operator|&
name|string
argument_list|,
name|funfirstline
argument_list|,
name|current_source_symtab
argument_list|,
name|current_source_line
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|string
condition|)
name|error
argument_list|(
literal|"Junk at end of line specification: %s"
argument_list|,
name|string
argument_list|)
expr_stmt|;
return|return
name|sals
return|;
block|}
end_function

begin_comment
comment|/* Track MAIN */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|name_of_main
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|set_main_name
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|name_of_main
operator|!=
name|NULL
condition|)
block|{
name|xfree
argument_list|(
name|name_of_main
argument_list|)
expr_stmt|;
name|name_of_main
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
block|{
name|name_of_main
operator|=
name|xstrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|char
modifier|*
name|main_name
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|name_of_main
operator|!=
name|NULL
condition|)
return|return
name|name_of_main
return|;
else|else
return|return
literal|"main"
return|;
block|}
end_function

begin_function
name|void
name|_initialize_symtab
parameter_list|(
name|void
parameter_list|)
block|{
name|add_info
argument_list|(
literal|"variables"
argument_list|,
name|variables_info
argument_list|,
literal|"All global and static variable names, or those matching REGEXP."
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbx_commands
condition|)
name|add_com
argument_list|(
literal|"whereis"
argument_list|,
name|class_info
argument_list|,
name|variables_info
argument_list|,
literal|"All global and static variable names, or those matching REGEXP."
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"functions"
argument_list|,
name|functions_info
argument_list|,
literal|"All function names, or those matching REGEXP."
argument_list|)
expr_stmt|;
comment|/* FIXME:  This command has at least the following problems:      1.  It prints builtin types (in a very strange and confusing fashion).      2.  It doesn't print right, e.g. with      typedef struct foo *FOO      type_print prints "FOO" when we want to make it (in this situation)      print "struct foo *".      I also think "ptype" or "whatis" is more likely to be useful (but if      there is much disagreement "info types" can be fixed).  */
name|add_info
argument_list|(
literal|"types"
argument_list|,
name|types_info
argument_list|,
literal|"All type names, or those matching REGEXP."
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|add_info ("methods", methods_info, 	    "All method names, or those matching REGEXP::REGEXP.\n\ If the class qualifier is omitted, it is assumed to be the current scope.\n\ If the first REGEXP is omitted, then all methods matching the second REGEXP\n\ are listed.");
endif|#
directive|endif
name|add_info
argument_list|(
literal|"sources"
argument_list|,
name|sources_info
argument_list|,
literal|"Source files in the program."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"rbreak"
argument_list|,
name|class_breakpoint
argument_list|,
name|rbreak_command
argument_list|,
literal|"Set a breakpoint for all functions matching REGEXP."
argument_list|)
expr_stmt|;
if|if
condition|(
name|xdb_commands
condition|)
block|{
name|add_com
argument_list|(
literal|"lf"
argument_list|,
name|class_info
argument_list|,
name|sources_info
argument_list|,
literal|"Source files in the program"
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"lg"
argument_list|,
name|class_info
argument_list|,
name|variables_info
argument_list|,
literal|"All global and static variable names, or those matching REGEXP."
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize the one built-in type that isn't language dependent... */
name|builtin_type_error
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_ERROR
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"<unknown type>"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

