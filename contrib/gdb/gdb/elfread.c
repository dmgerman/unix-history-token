begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Read ELF (Executable and Linking Format) object files for GDB.    Copyright 1991, 92, 93, 94, 95, 96, 1998 Free Software Foundation, Inc.    Written by Fred Fish at Cygnus Support.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_include
include|#
directive|include
file|"elf/mips.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"buildsym.h"
end_include

begin_include
include|#
directive|include
file|"stabsread.h"
end_include

begin_include
include|#
directive|include
file|"gdb-stabs.h"
end_include

begin_include
include|#
directive|include
file|"complaints.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_comment
comment|/* The struct elfinfo is available only during ELF symbol table and    psymtab reading.  It is destroyed at the complation of psymtab-reading.    It's local to elf_symfile_read.  */
end_comment

begin_struct
struct|struct
name|elfinfo
block|{
name|file_ptr
name|dboffset
decl_stmt|;
comment|/* Offset to dwarf debug section */
name|unsigned
name|int
name|dbsize
decl_stmt|;
comment|/* Size of dwarf debug section */
name|file_ptr
name|lnoffset
decl_stmt|;
comment|/* Offset to dwarf line number section */
name|unsigned
name|int
name|lnsize
decl_stmt|;
comment|/* Size of dwarf line number section */
name|asection
modifier|*
name|stabsect
decl_stmt|;
comment|/* Section pointer for .stab section */
name|asection
modifier|*
name|stabindexsect
decl_stmt|;
comment|/* Section pointer for .stab.index section */
name|asection
modifier|*
name|mdebugsect
decl_stmt|;
comment|/* Section pointer for .mdebug section */
block|}
struct|;
end_struct

begin_comment
comment|/* Various things we might complain about... */
end_comment

begin_decl_stmt
name|struct
name|complaint
name|section_info_complaint
init|=
block|{
literal|"elf/stab section information %s without a preceding file symbol"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|section_info_dup_complaint
init|=
block|{
literal|"duplicated elf/stab section information for %s"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|stab_info_mismatch_complaint
init|=
block|{
literal|"elf/stab section information missing for %s"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|stab_info_questionable_complaint
init|=
block|{
literal|"elf/stab section information questionable for %s"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|elf_symfile_init
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|elf_new_init
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|elf_symfile_read
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|,
expr|struct
name|section_offsets
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|elf_symfile_finish
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|elf_symtab_read
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|CORE_ADDR
operator|,
expr|struct
name|objfile
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_elfinfo
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|minimal_symbol
modifier|*
name|record_minimal_symbol_and_info
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|CORE_ADDR
operator|,
expr|enum
name|minimal_symbol_type
operator|,
name|char
operator|*
operator|,
name|asection
operator|*
name|bfd_section
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|elf_locate_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We are called once per section from elf_symfile_read.  We    need to examine each section we are passed, check to see    if it is something we are interested in processing, and    if so, stash away some access information for the section.     For now we recognize the dwarf debug information sections and    line number sections from matching their section names.  The    ELF definition is no real help here since it has no direct    knowledge of DWARF (by design, so any debugging format can be    used).     We also recognize the ".stab" sections used by the Sun compilers    released with Solaris 2.     FIXME: The section names should not be hardwired strings (what    should they be?  I don't think most object file formats have enough    section flags to specify what kind of debug section it is    -kingdon).  */
end_comment

begin_function
specifier|static
name|void
name|elf_locate_sections
parameter_list|(
name|ignore_abfd
parameter_list|,
name|sectp
parameter_list|,
name|eip
parameter_list|)
name|bfd
modifier|*
name|ignore_abfd
decl_stmt|;
name|asection
modifier|*
name|sectp
decl_stmt|;
name|PTR
name|eip
decl_stmt|;
block|{
specifier|register
name|struct
name|elfinfo
modifier|*
name|ei
decl_stmt|;
name|ei
operator|=
operator|(
expr|struct
name|elfinfo
operator|*
operator|)
name|eip
expr_stmt|;
if|if
condition|(
name|STREQ
argument_list|(
name|sectp
operator|->
name|name
argument_list|,
literal|".debug"
argument_list|)
condition|)
block|{
name|ei
operator|->
name|dboffset
operator|=
name|sectp
operator|->
name|filepos
expr_stmt|;
name|ei
operator|->
name|dbsize
operator|=
name|bfd_get_section_size_before_reloc
argument_list|(
name|sectp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|sectp
operator|->
name|name
argument_list|,
literal|".line"
argument_list|)
condition|)
block|{
name|ei
operator|->
name|lnoffset
operator|=
name|sectp
operator|->
name|filepos
expr_stmt|;
name|ei
operator|->
name|lnsize
operator|=
name|bfd_get_section_size_before_reloc
argument_list|(
name|sectp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|sectp
operator|->
name|name
argument_list|,
literal|".stab"
argument_list|)
condition|)
block|{
name|ei
operator|->
name|stabsect
operator|=
name|sectp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|sectp
operator|->
name|name
argument_list|,
literal|".stab.index"
argument_list|)
condition|)
block|{
name|ei
operator|->
name|stabindexsect
operator|=
name|sectp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|sectp
operator|->
name|name
argument_list|,
literal|".mdebug"
argument_list|)
condition|)
block|{
name|ei
operator|->
name|mdebugsect
operator|=
name|sectp
expr_stmt|;
block|}
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Currently unused */
end_comment

begin_endif
unit|char * elf_interpreter (abfd)      bfd *abfd; {   sec_ptr interp_sec;   unsigned size;   char *interp = NULL;    interp_sec = bfd_get_section_by_name (abfd, ".interp");   if (interp_sec)     {       size = bfd_section_size (abfd, interp_sec);       interp = alloca (size);       if (bfd_get_section_contents (abfd, interp_sec, interp, (file_ptr)0, 				    size)) 	{ 	  interp = savestring (interp, size - 1); 	}       else 	{ 	  interp = NULL; 	}     }   return (interp); }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|struct
name|minimal_symbol
modifier|*
name|record_minimal_symbol_and_info
parameter_list|(
name|name
parameter_list|,
name|address
parameter_list|,
name|ms_type
parameter_list|,
name|info
parameter_list|,
name|bfd_section
parameter_list|,
name|objfile
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|CORE_ADDR
name|address
decl_stmt|;
name|enum
name|minimal_symbol_type
name|ms_type
decl_stmt|;
name|char
modifier|*
name|info
decl_stmt|;
comment|/* FIXME, is this really char *? */
name|asection
modifier|*
name|bfd_section
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|int
name|section
decl_stmt|;
comment|/* Guess the section from the type.  This is likely to be wrong in      some cases.  */
switch|switch
condition|(
name|ms_type
condition|)
block|{
case|case
name|mst_text
case|:
case|case
name|mst_file_text
case|:
name|section
operator|=
name|SECT_OFF_TEXT
expr_stmt|;
ifdef|#
directive|ifdef
name|SMASH_TEXT_ADDRESS
name|SMASH_TEXT_ADDRESS
argument_list|(
name|address
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|mst_data
case|:
case|case
name|mst_file_data
case|:
name|section
operator|=
name|SECT_OFF_DATA
expr_stmt|;
break|break;
case|case
name|mst_bss
case|:
case|case
name|mst_file_bss
case|:
name|section
operator|=
name|SECT_OFF_BSS
expr_stmt|;
break|break;
default|default:
name|section
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
return|return
name|prim_record_minimal_symbol_and_info
argument_list|(
name|name
argument_list|,
name|address
argument_list|,
name|ms_type
argument_list|,
name|info
argument_list|,
name|section
argument_list|,
name|bfd_section
argument_list|,
name|objfile
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	elf_symtab_read -- read the symbol table of an ELF file  SYNOPSIS  	void elf_symtab_read (bfd *abfd, CORE_ADDR addr, 			      struct objfile *objfile, int dynamic)  DESCRIPTION  	Given an open bfd, a base address to relocate symbols to, and a 	flag that specifies whether or not this bfd is for an executable 	or not (may be shared library for example), add all the global 	function and data symbols to the minimal symbol table.  	In stabs-in-ELF, as implemented by Sun, there are some local symbols 	defined in the ELF symbol table, which can be used to locate 	the beginnings of sections from each ".o" file that was linked to 	form the executable objfile.  We gather any such info and record it 	in data structures hung off the objfile's private data.  */
end_comment

begin_function
specifier|static
name|void
name|elf_symtab_read
parameter_list|(
name|abfd
parameter_list|,
name|addr
parameter_list|,
name|objfile
parameter_list|,
name|dynamic
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|int
name|dynamic
decl_stmt|;
block|{
name|long
name|storage_needed
decl_stmt|;
name|asymbol
modifier|*
name|sym
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symbol_table
decl_stmt|;
name|long
name|number_of_symbols
decl_stmt|;
name|long
name|i
decl_stmt|;
name|int
name|index
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|back_to
decl_stmt|;
name|CORE_ADDR
name|symaddr
decl_stmt|;
name|enum
name|minimal_symbol_type
name|ms_type
decl_stmt|;
comment|/* If sectinfo is nonNULL, it contains section info that should end up      filed in the objfile.  */
name|struct
name|stab_section_info
modifier|*
name|sectinfo
init|=
name|NULL
decl_stmt|;
comment|/* If filesym is nonzero, it points to a file symbol, but we haven't      seen any section info for it yet.  */
name|asymbol
modifier|*
name|filesym
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|SOFUN_ADDRESS_MAYBE_MISSING
comment|/* Name of filesym, as saved on the symbol_obstack.  */
name|char
modifier|*
name|filesymname
init|=
name|obsavestring
argument_list|(
literal|""
argument_list|,
literal|0
argument_list|,
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|struct
name|dbx_symfile_info
modifier|*
name|dbx
init|=
name|objfile
operator|->
name|sym_stab_info
decl_stmt|;
name|unsigned
name|long
name|size
decl_stmt|;
name|int
name|stripped
init|=
operator|(
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|==
literal|0
operator|)
decl_stmt|;
if|if
condition|(
name|dynamic
condition|)
block|{
name|storage_needed
operator|=
name|bfd_get_dynamic_symtab_upper_bound
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* Nothing to be done if there is no dynamic symtab.  */
if|if
condition|(
name|storage_needed
operator|<
literal|0
condition|)
return|return;
block|}
else|else
block|{
name|storage_needed
operator|=
name|bfd_get_symtab_upper_bound
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|storage_needed
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"Can't read symbols from %s: %s"
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|storage_needed
operator|>
literal|0
condition|)
block|{
name|symbol_table
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|storage_needed
argument_list|)
expr_stmt|;
name|back_to
operator|=
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|symbol_table
argument_list|)
expr_stmt|;
if|if
condition|(
name|dynamic
condition|)
name|number_of_symbols
operator|=
name|bfd_canonicalize_dynamic_symtab
argument_list|(
name|abfd
argument_list|,
name|symbol_table
argument_list|)
expr_stmt|;
else|else
name|number_of_symbols
operator|=
name|bfd_canonicalize_symtab
argument_list|(
name|abfd
argument_list|,
name|symbol_table
argument_list|)
expr_stmt|;
if|if
condition|(
name|number_of_symbols
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"Can't read symbols from %s: %s"
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|number_of_symbols
condition|;
name|i
operator|++
control|)
block|{
name|sym
operator|=
name|symbol_table
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|sym
operator|->
name|name
operator|==
name|NULL
operator|||
operator|*
name|sym
operator|->
name|name
operator|==
literal|'\0'
condition|)
block|{
comment|/* Skip names that don't exist (shouldn't happen), or names 		 that are null strings (may happen). */
continue|continue;
block|}
if|if
condition|(
name|dynamic
operator|&&
name|sym
operator|->
name|section
operator|==
operator|&
name|bfd_und_section
operator|&&
operator|(
name|sym
operator|->
name|flags
operator|&
name|BSF_FUNCTION
operator|)
condition|)
block|{
name|struct
name|minimal_symbol
modifier|*
name|msym
decl_stmt|;
comment|/* Symbol is a reference to a function defined in 		 a shared library. 		 If its value is non zero then it is usually the address 		 of the corresponding entry in the procedure linkage table, 		 relative to the base address. 		 If its value is zero then the dynamic linker has to resolve 		 the symbol. We are unable to find any meaningful address 		 for this symbol in the executable file, so we skip it.  */
name|symaddr
operator|=
name|sym
operator|->
name|value
expr_stmt|;
if|if
condition|(
name|symaddr
operator|==
literal|0
condition|)
continue|continue;
name|symaddr
operator|+=
name|addr
expr_stmt|;
name|msym
operator|=
name|record_minimal_symbol_and_info
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sym
operator|->
name|name
argument_list|,
name|symaddr
argument_list|,
name|mst_solib_trampoline
argument_list|,
name|NULL
argument_list|,
name|sym
operator|->
name|section
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SOFUN_ADDRESS_MAYBE_MISSING
if|if
condition|(
name|msym
operator|!=
name|NULL
condition|)
name|msym
operator|->
name|filename
operator|=
name|filesymname
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
comment|/* If it is a nonstripped executable, do not enter dynamic 	     symbols, as the dynamic symbol table is usually a subset 	     of the main symbol table.  */
if|if
condition|(
name|dynamic
operator|&&
operator|!
name|stripped
condition|)
continue|continue;
if|if
condition|(
name|sym
operator|->
name|flags
operator|&
name|BSF_FILE
condition|)
block|{
comment|/* STT_FILE debugging symbol that helps stabs-in-elf debugging. 		 Chain any old one onto the objfile; remember new sym.  */
if|if
condition|(
name|sectinfo
operator|!=
name|NULL
condition|)
block|{
name|sectinfo
operator|->
name|next
operator|=
name|dbx
operator|->
name|stab_section_info
expr_stmt|;
name|dbx
operator|->
name|stab_section_info
operator|=
name|sectinfo
expr_stmt|;
name|sectinfo
operator|=
name|NULL
expr_stmt|;
block|}
name|filesym
operator|=
name|sym
expr_stmt|;
ifdef|#
directive|ifdef
name|SOFUN_ADDRESS_MAYBE_MISSING
name|filesymname
operator|=
name|obsavestring
argument_list|(
operator|(
name|char
operator|*
operator|)
name|filesym
operator|->
name|name
argument_list|,
name|strlen
argument_list|(
name|filesym
operator|->
name|name
argument_list|)
argument_list|,
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|sym
operator|->
name|flags
operator|&
operator|(
name|BSF_GLOBAL
operator||
name|BSF_LOCAL
operator||
name|BSF_WEAK
operator|)
condition|)
block|{
name|struct
name|minimal_symbol
modifier|*
name|msym
decl_stmt|;
comment|/* Select global/local/weak symbols.  Note that bfd puts abs 		 symbols in their own section, so all symbols we are 		 interested in will have a section. */
comment|/* Bfd symbols are section relative. */
name|symaddr
operator|=
name|sym
operator|->
name|value
operator|+
name|sym
operator|->
name|section
operator|->
name|vma
expr_stmt|;
comment|/* Relocate all non-absolute symbols by base address.  */
if|if
condition|(
name|sym
operator|->
name|section
operator|!=
operator|&
name|bfd_abs_section
condition|)
block|{
name|symaddr
operator|+=
name|addr
expr_stmt|;
block|}
comment|/* For non-absolute symbols, use the type of the section 		 they are relative to, to intuit text/data.  Bfd provides 		 no way of figuring this out for absolute symbols. */
if|if
condition|(
name|sym
operator|->
name|section
operator|==
operator|&
name|bfd_abs_section
condition|)
block|{
comment|/* This is a hack to get the minimal symbol type 		     right for Irix 5, which has absolute adresses 		     with special section indices for dynamic symbols. */
name|unsigned
name|short
name|shndx
init|=
operator|(
operator|(
name|elf_symbol_type
operator|*
operator|)
name|sym
operator|)
operator|->
name|internal_elf_sym
operator|.
name|st_shndx
decl_stmt|;
switch|switch
condition|(
name|shndx
condition|)
block|{
case|case
name|SHN_MIPS_TEXT
case|:
name|ms_type
operator|=
name|mst_text
expr_stmt|;
break|break;
case|case
name|SHN_MIPS_DATA
case|:
name|ms_type
operator|=
name|mst_data
expr_stmt|;
break|break;
case|case
name|SHN_MIPS_ACOMMON
case|:
name|ms_type
operator|=
name|mst_bss
expr_stmt|;
break|break;
default|default:
name|ms_type
operator|=
name|mst_abs
expr_stmt|;
block|}
comment|/* If it is an Irix dynamic symbol, skip section name 		     symbols, relocate all others. */
if|if
condition|(
name|ms_type
operator|!=
name|mst_abs
condition|)
block|{
if|if
condition|(
name|sym
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
continue|continue;
name|symaddr
operator|+=
name|addr
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|sym
operator|->
name|section
operator|->
name|flags
operator|&
name|SEC_CODE
condition|)
block|{
if|if
condition|(
name|sym
operator|->
name|flags
operator|&
name|BSF_GLOBAL
condition|)
block|{
name|ms_type
operator|=
name|mst_text
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|sym
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|sym
operator|->
name|name
index|[
literal|1
index|]
operator|==
literal|'L'
operator|)
operator|||
operator|(
operator|(
name|sym
operator|->
name|flags
operator|&
name|BSF_LOCAL
operator|)
operator|&&
name|sym
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'$'
operator|&&
name|sym
operator|->
name|name
index|[
literal|1
index|]
operator|==
literal|'L'
operator|)
condition|)
comment|/* Looks like a compiler-generated label.  Skip it. 		       The assembler should be skipping these (to keep 		       executables small), but apparently with gcc on the 		       delta m88k SVR4, it loses.  So to have us check too 		       should be harmless (but I encourage people to fix this 		       in the assembler instead of adding checks here).  */
continue|continue;
ifdef|#
directive|ifdef
name|HARRIS_TARGET
elseif|else
if|if
condition|(
name|sym
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|sym
operator|->
name|name
index|[
literal|1
index|]
operator|==
literal|'.'
condition|)
block|{
comment|/* Looks like a Harris compiler generated label for the 			 purpose of marking instructions that are relevant to 			 DWARF dies.  The assembler can't get rid of these  			 because they are relocatable addresses that the 			 linker needs to resolve. */
continue|continue;
block|}
endif|#
directive|endif
else|else
block|{
name|ms_type
operator|=
name|mst_file_text
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|sym
operator|->
name|section
operator|->
name|flags
operator|&
name|SEC_ALLOC
condition|)
block|{
if|if
condition|(
name|sym
operator|->
name|flags
operator|&
name|BSF_GLOBAL
condition|)
block|{
if|if
condition|(
name|sym
operator|->
name|section
operator|->
name|flags
operator|&
name|SEC_LOAD
condition|)
block|{
name|ms_type
operator|=
name|mst_data
expr_stmt|;
block|}
else|else
block|{
name|ms_type
operator|=
name|mst_bss
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|sym
operator|->
name|flags
operator|&
name|BSF_LOCAL
condition|)
block|{
comment|/* Named Local variable in a Data section.  Check its 			 name for stabs-in-elf.  The STREQ macro checks the 			 first character inline, so we only actually do a 			 strcmp function call on names that start with 'B' 			 or 'D' */
name|index
operator|=
name|SECT_OFF_MAX
expr_stmt|;
if|if
condition|(
name|STREQ
argument_list|(
literal|"Bbss.bss"
argument_list|,
name|sym
operator|->
name|name
argument_list|)
condition|)
block|{
name|index
operator|=
name|SECT_OFF_BSS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
literal|"Ddata.data"
argument_list|,
name|sym
operator|->
name|name
argument_list|)
condition|)
block|{
name|index
operator|=
name|SECT_OFF_DATA
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
literal|"Drodata.rodata"
argument_list|,
name|sym
operator|->
name|name
argument_list|)
condition|)
block|{
name|index
operator|=
name|SECT_OFF_RODATA
expr_stmt|;
block|}
if|if
condition|(
name|index
operator|!=
name|SECT_OFF_MAX
condition|)
block|{
comment|/* Found a special local symbol.  Allocate a 			     sectinfo, if needed, and fill it in.  */
if|if
condition|(
name|sectinfo
operator|==
name|NULL
condition|)
block|{
name|sectinfo
operator|=
operator|(
expr|struct
name|stab_section_info
operator|*
operator|)
name|xmmalloc
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sectinfo
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|PTR
operator|)
name|sectinfo
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sectinfo
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|filesym
operator|==
name|NULL
condition|)
block|{
name|complain
argument_list|(
operator|&
name|section_info_complaint
argument_list|,
name|sym
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sectinfo
operator|->
name|filename
operator|=
operator|(
name|char
operator|*
operator|)
name|filesym
operator|->
name|name
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sectinfo
operator|->
name|sections
index|[
name|index
index|]
operator|!=
literal|0
condition|)
block|{
name|complain
argument_list|(
operator|&
name|section_info_dup_complaint
argument_list|,
name|sectinfo
operator|->
name|filename
argument_list|)
expr_stmt|;
block|}
comment|/* Bfd symbols are section relative. */
name|symaddr
operator|=
name|sym
operator|->
name|value
operator|+
name|sym
operator|->
name|section
operator|->
name|vma
expr_stmt|;
comment|/* Relocate non-absolute symbols by base address.  */
if|if
condition|(
name|sym
operator|->
name|section
operator|!=
operator|&
name|bfd_abs_section
condition|)
block|{
name|symaddr
operator|+=
name|addr
expr_stmt|;
block|}
name|sectinfo
operator|->
name|sections
index|[
name|index
index|]
operator|=
name|symaddr
expr_stmt|;
comment|/* The special local symbols don't go in the 			     minimal symbol table, so ignore this one. */
continue|continue;
block|}
comment|/* Not a special stabs-in-elf symbol, do regular 			 symbol processing. */
if|if
condition|(
name|sym
operator|->
name|section
operator|->
name|flags
operator|&
name|SEC_LOAD
condition|)
block|{
name|ms_type
operator|=
name|mst_file_data
expr_stmt|;
block|}
else|else
block|{
name|ms_type
operator|=
name|mst_file_bss
expr_stmt|;
block|}
block|}
else|else
block|{
name|ms_type
operator|=
name|mst_unknown
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* FIXME:  Solaris2 shared libraries include lots of 		     odd "absolute" and "undefined" symbols, that play  		     hob with actions like finding what function the PC 		     is in.  Ignore them if they aren't text, data, or bss.  */
comment|/* ms_type = mst_unknown; */
continue|continue;
comment|/* Skip this symbol. */
block|}
comment|/* Pass symbol size field in via BFD.  FIXME!!!  */
name|size
operator|=
operator|(
operator|(
name|elf_symbol_type
operator|*
operator|)
name|sym
operator|)
operator|->
name|internal_elf_sym
operator|.
name|st_size
expr_stmt|;
name|msym
operator|=
name|record_minimal_symbol_and_info
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sym
operator|->
name|name
argument_list|,
name|symaddr
argument_list|,
name|ms_type
argument_list|,
operator|(
name|PTR
operator|)
name|size
argument_list|,
name|sym
operator|->
name|section
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SOFUN_ADDRESS_MAYBE_MISSING
if|if
condition|(
name|msym
operator|!=
name|NULL
condition|)
name|msym
operator|->
name|filename
operator|=
name|filesymname
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ELF_MAKE_MSYMBOL_SPECIAL
name|ELF_MAKE_MSYMBOL_SPECIAL
argument_list|(
name|sym
argument_list|,
name|msym
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
name|do_cleanups
argument_list|(
name|back_to
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Scan and build partial symbols for a symbol file.    We have been initialized by a call to elf_symfile_init, which     currently does nothing.     SECTION_OFFSETS is a set of offsets to apply to relocate the symbols    in each section.  We simplify it down to a single offset for all    symbols.  FIXME.     MAINLINE is true if we are reading the main symbol    table (as opposed to a shared lib or dynamically loaded file).     This function only does the minimum work necessary for letting the    user "name" things symbolically; it does not read the entire symtab.    Instead, it reads the external and static symbols and puts them in partial    symbol tables.  When more extensive information is requested of a    file, the corresponding partial symbol table is mutated into a full    fledged symbol table by going back and reading the symbols    for real.     We look for sections with specific names, to tell us what debug    format to look for:  FIXME!!!     dwarf_build_psymtabs() builds psymtabs for DWARF symbols;    elfstab_build_psymtabs() handles STABS symbols;    mdebug_build_psymtabs() handles ECOFF debugging information.     Note that ELF files have a "minimal" symbol table, which looks a lot    like a COFF symbol table, but has only the minimal information necessary    for linking.  We process this also, and use the information to    build gdb's minimal symbol table.  This gives us some minimal debugging    capability even for files compiled without -g.  */
end_comment

begin_function
specifier|static
name|void
name|elf_symfile_read
parameter_list|(
name|objfile
parameter_list|,
name|section_offsets
parameter_list|,
name|mainline
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|section_offsets
modifier|*
name|section_offsets
decl_stmt|;
name|int
name|mainline
decl_stmt|;
block|{
name|bfd
modifier|*
name|abfd
init|=
name|objfile
operator|->
name|obfd
decl_stmt|;
name|struct
name|elfinfo
name|ei
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|back_to
decl_stmt|;
name|CORE_ADDR
name|offset
decl_stmt|;
name|init_minimal_symbol_collection
argument_list|()
expr_stmt|;
name|back_to
operator|=
name|make_cleanup
argument_list|(
operator|(
name|make_cleanup_func
operator|)
name|discard_minimal_symbols
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ei
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ei
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Allocate struct to keep track of the symfile */
name|objfile
operator|->
name|sym_stab_info
operator|=
operator|(
expr|struct
name|dbx_symfile_info
operator|*
operator|)
name|xmmalloc
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dbx_symfile_info
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|objfile
operator|->
name|sym_stab_info
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dbx_symfile_info
argument_list|)
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|free_elfinfo
argument_list|,
operator|(
name|PTR
operator|)
name|objfile
argument_list|)
expr_stmt|;
comment|/* Process the normal ELF symbol table first.  This may write some       chain of info into the dbx_symfile_info in objfile->sym_stab_info,      which can later be used by elfstab_offset_sections.  */
comment|/* FIXME, should take a section_offsets param, not just an offset.  */
name|offset
operator|=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|elf_symtab_read
argument_list|(
name|abfd
argument_list|,
name|offset
argument_list|,
name|objfile
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Add the dynamic symbols.  */
name|elf_symtab_read
argument_list|(
name|abfd
argument_list|,
name|offset
argument_list|,
name|objfile
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Now process debugging information, which is contained in      special ELF sections. */
comment|/* If we are reinitializing, or if we have never loaded syms yet,      set table to empty.  MAINLINE is cleared so that *_read_psymtab      functions do not all also re-initialize the psymbol table. */
if|if
condition|(
name|mainline
condition|)
block|{
name|init_psymbol_list
argument_list|(
name|objfile
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mainline
operator|=
literal|0
expr_stmt|;
block|}
comment|/* We first have to find them... */
name|bfd_map_over_sections
argument_list|(
name|abfd
argument_list|,
name|elf_locate_sections
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|ei
argument_list|)
expr_stmt|;
comment|/* ELF debugging information is inserted into the psymtab in the      order of least informative first - most informative last.  Since      the psymtab table is searched `most recent insertion first' this      increases the probability that more detailed debug information      for a section is found.       For instance, an object file might contain both .mdebug (XCOFF)      and .debug_info (DWARF2) sections then .mdebug is inserted first      (searched last) and DWARF2 is inserted last (searched first).  If      we don't do this then the XCOFF info is found first - for code in      an included file XCOFF info is useless. */
if|if
condition|(
name|ei
operator|.
name|mdebugsect
condition|)
block|{
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
name|swap
decl_stmt|;
comment|/* .mdebug section, presumably holding ECOFF debugging 	 information.  */
name|swap
operator|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|elf_backend_ecoff_debug_swap
expr_stmt|;
if|if
condition|(
name|swap
condition|)
name|elfmdebug_build_psymtabs
argument_list|(
name|objfile
argument_list|,
name|swap
argument_list|,
name|ei
operator|.
name|mdebugsect
argument_list|,
name|section_offsets
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ei
operator|.
name|stabsect
condition|)
block|{
name|asection
modifier|*
name|str_sect
decl_stmt|;
comment|/* Stab sections have an associated string table that looks like 	 a separate section.  */
name|str_sect
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".stabstr"
argument_list|)
expr_stmt|;
comment|/* FIXME should probably warn about a stab section without a stabstr.  */
if|if
condition|(
name|str_sect
condition|)
name|elfstab_build_psymtabs
argument_list|(
name|objfile
argument_list|,
name|section_offsets
argument_list|,
name|mainline
argument_list|,
name|ei
operator|.
name|stabsect
operator|->
name|filepos
argument_list|,
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|ei
operator|.
name|stabsect
argument_list|)
argument_list|,
name|str_sect
operator|->
name|filepos
argument_list|,
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|str_sect
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dwarf2_has_info
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
comment|/* DWARF 2 sections */
name|dwarf2_build_psymtabs
argument_list|(
name|objfile
argument_list|,
name|section_offsets
argument_list|,
name|mainline
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ei
operator|.
name|dboffset
operator|&&
name|ei
operator|.
name|lnoffset
condition|)
block|{
comment|/* DWARF sections */
name|dwarf_build_psymtabs
argument_list|(
name|objfile
argument_list|,
name|section_offsets
argument_list|,
name|mainline
argument_list|,
name|ei
operator|.
name|dboffset
argument_list|,
name|ei
operator|.
name|dbsize
argument_list|,
name|ei
operator|.
name|lnoffset
argument_list|,
name|ei
operator|.
name|lnsize
argument_list|)
expr_stmt|;
block|}
comment|/* Install any minimal symbols that have been collected as the current      minimal symbols for this objfile. */
name|install_minimal_symbols
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|back_to
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This cleans up the objfile's sym_stab_info pointer, and the chain of    stab_section_info's, that might be dangling from it.  */
end_comment

begin_function
specifier|static
name|void
name|free_elfinfo
parameter_list|(
name|objp
parameter_list|)
name|PTR
name|objp
decl_stmt|;
block|{
name|struct
name|objfile
modifier|*
name|objfile
init|=
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|objp
decl_stmt|;
name|struct
name|dbx_symfile_info
modifier|*
name|dbxinfo
init|=
name|objfile
operator|->
name|sym_stab_info
decl_stmt|;
name|struct
name|stab_section_info
modifier|*
name|ssi
decl_stmt|,
modifier|*
name|nssi
decl_stmt|;
name|ssi
operator|=
name|dbxinfo
operator|->
name|stab_section_info
expr_stmt|;
while|while
condition|(
name|ssi
condition|)
block|{
name|nssi
operator|=
name|ssi
operator|->
name|next
expr_stmt|;
name|mfree
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
name|ssi
argument_list|)
expr_stmt|;
name|ssi
operator|=
name|nssi
expr_stmt|;
block|}
name|dbxinfo
operator|->
name|stab_section_info
operator|=
literal|0
expr_stmt|;
comment|/* Just say No mo info about this.  */
block|}
end_function

begin_comment
comment|/* Initialize anything that needs initializing when a completely new symbol    file is specified (not just adding some symbols from another file, e.g. a    shared library).     We reinitialize buildsym, since we may be reading stabs from an ELF file.  */
end_comment

begin_function
specifier|static
name|void
name|elf_new_init
parameter_list|(
name|ignore
parameter_list|)
name|struct
name|objfile
modifier|*
name|ignore
decl_stmt|;
block|{
name|stabsread_new_init
argument_list|()
expr_stmt|;
name|buildsym_new_init
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Perform any local cleanups required when we are done with a particular    objfile.  I.E, we are in the process of discarding all symbol information    for an objfile, freeing up all memory held for it, and unlinking the    objfile struct from the global list of known objfiles. */
end_comment

begin_function
specifier|static
name|void
name|elf_symfile_finish
parameter_list|(
name|objfile
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
if|if
condition|(
name|objfile
operator|->
name|sym_stab_info
operator|!=
name|NULL
condition|)
block|{
name|mfree
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
name|objfile
operator|->
name|sym_stab_info
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ELF specific initialization routine for reading symbols.     It is passed a pointer to a struct sym_fns which contains, among other    things, the BFD for the file whose symbols are being read, and a slot for    a pointer to "private data" which we can fill with goodies.     For now at least, we have nothing in particular to do, so this function is    just a stub. */
end_comment

begin_function
specifier|static
name|void
name|elf_symfile_init
parameter_list|(
name|objfile
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
comment|/* ELF objects may be reordered, so set OBJF_REORDERED.  If we      find this causes a significant slowdown in gdb then we could      set it in the debug symbol readers only when necessary.  */
name|objfile
operator|->
name|flags
operator||=
name|OBJF_REORDERED
expr_stmt|;
block|}
end_function

begin_comment
comment|/* When handling an ELF file that contains Sun STABS debug info,    some of the debug info is relative to the particular chunk of the    section that was generated in its individual .o file.  E.g.    offsets to static variables are relative to the start of the data    segment *for that module before linking*.  This information is    painfully squirreled away in the ELF symbol table as local symbols    with wierd names.  Go get 'em when needed.  */
end_comment

begin_function
name|void
name|elfstab_offset_sections
parameter_list|(
name|objfile
parameter_list|,
name|pst
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
block|{
name|char
modifier|*
name|filename
init|=
name|pst
operator|->
name|filename
decl_stmt|;
name|struct
name|dbx_symfile_info
modifier|*
name|dbx
init|=
name|objfile
operator|->
name|sym_stab_info
decl_stmt|;
name|struct
name|stab_section_info
modifier|*
name|maybe
init|=
name|dbx
operator|->
name|stab_section_info
decl_stmt|;
name|struct
name|stab_section_info
modifier|*
name|questionable
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
comment|/* The ELF symbol info doesn't include path names, so strip the path      (if any) from the psymtab filename.  */
while|while
condition|(
literal|0
operator|!=
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|filename
argument_list|,
literal|'/'
argument_list|)
operator|)
condition|)
name|filename
operator|=
name|p
operator|+
literal|1
expr_stmt|;
comment|/* FIXME:  This linear search could speed up significantly      if it was chained in the right order to match how we search it,      and if we unchained when we found a match. */
for|for
control|(
init|;
name|maybe
condition|;
name|maybe
operator|=
name|maybe
operator|->
name|next
control|)
block|{
if|if
condition|(
name|filename
index|[
literal|0
index|]
operator|==
name|maybe
operator|->
name|filename
index|[
literal|0
index|]
operator|&&
name|STREQ
argument_list|(
name|filename
argument_list|,
name|maybe
operator|->
name|filename
argument_list|)
condition|)
block|{
comment|/* We found a match.  But there might be several source files 	     (from different directories) with the same name.  */
if|if
condition|(
literal|0
operator|==
name|maybe
operator|->
name|found
condition|)
break|break;
name|questionable
operator|=
name|maybe
expr_stmt|;
comment|/* Might use it later.  */
block|}
block|}
if|if
condition|(
name|maybe
operator|==
literal|0
operator|&&
name|questionable
operator|!=
literal|0
condition|)
block|{
name|complain
argument_list|(
operator|&
name|stab_info_questionable_complaint
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|maybe
operator|=
name|questionable
expr_stmt|;
block|}
if|if
condition|(
name|maybe
condition|)
block|{
comment|/* Found it!  Allocate a new psymtab struct, and fill it in.  */
name|maybe
operator|->
name|found
operator|++
expr_stmt|;
name|pst
operator|->
name|section_offsets
operator|=
operator|(
expr|struct
name|section_offsets
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|psymbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|section_offsets
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|pst
operator|->
name|section_offsets
operator|->
name|offsets
argument_list|)
operator|*
operator|(
name|SECT_OFF_MAX
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SECT_OFF_MAX
condition|;
name|i
operator|++
control|)
name|ANOFFSET
argument_list|(
name|pst
operator|->
name|section_offsets
argument_list|,
name|i
argument_list|)
operator|=
name|maybe
operator|->
name|sections
index|[
name|i
index|]
expr_stmt|;
return|return;
block|}
comment|/* We were unable to find any offsets for this file.  Complain.  */
if|if
condition|(
name|dbx
operator|->
name|stab_section_info
condition|)
comment|/* If there *is* any info, */
name|complain
argument_list|(
operator|&
name|stab_info_mismatch_complaint
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Register that we are able to handle ELF object file formats.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sym_fns
name|elf_sym_fns
init|=
block|{
name|bfd_target_elf_flavour
block|,
name|elf_new_init
block|,
comment|/* sym_new_init: init anything gbl to entire symtab */
name|elf_symfile_init
block|,
comment|/* sym_init: read initial info, setup for sym_read() */
name|elf_symfile_read
block|,
comment|/* sym_read: read a symbol file into symtab */
name|elf_symfile_finish
block|,
comment|/* sym_finish: finished with file, cleanup */
name|default_symfile_offsets
block|,
comment|/* sym_offsets:  Translate ext. to int. relocation */
name|NULL
comment|/* next: pointer to next struct sym_fns */
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|_initialize_elfread
parameter_list|()
block|{
name|add_symtab_fns
argument_list|(
operator|&
name|elf_sym_fns
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

