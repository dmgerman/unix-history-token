begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Native support for Motorola 88k running Harris CX/UX.    Copyright 1988, 1990, 1991, 1992, 1993, 1994 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|USER
end_ifndef

begin_comment
comment|/* added to support BCS ptrace_user */
end_comment

begin_define
define|#
directive|define
name|USER
value|ptrace_user
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|"gdb_stat.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"setjmp.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|<sys/ptrace.h>
end_include

begin_comment
comment|/* CX/UX provides them already, but as word offsets instead of char offsets */
end_comment

begin_define
define|#
directive|define
name|SXIP_OFFSET
value|(PT_SXIP * 4)
end_define

begin_define
define|#
directive|define
name|SNIP_OFFSET
value|(PT_SNIP * 4)
end_define

begin_define
define|#
directive|define
name|SFIP_OFFSET
value|(PT_SFIP * 4)
end_define

begin_define
define|#
directive|define
name|PSR_OFFSET
value|(PT_PSR  * sizeof(int))
end_define

begin_define
define|#
directive|define
name|FPSR_OFFSET
value|(PT_FPSR * sizeof(int))
end_define

begin_define
define|#
directive|define
name|FPCR_OFFSET
value|(PT_FPCR * sizeof(int))
end_define

begin_define
define|#
directive|define
name|XREGADDR
parameter_list|(
name|r
parameter_list|)
value|(((char *)&u.pt_x0-(char *)&u) + \                      ((r)-X0_REGNUM)*sizeof(X_REGISTER_RAW_TYPE))
end_define

begin_function_decl
specifier|extern
name|int
name|have_symbol_file_p
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|jmp_buf
name|stack_jmp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|registers
index|[
name|REGISTER_BYTES
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|fetch_inferior_registers
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
comment|/* Original value discarded */
block|{
specifier|register
name|unsigned
name|int
name|regaddr
decl_stmt|;
name|char
name|buf
index|[
name|MAX_REGISTER_RAW_SIZE
index|]
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|struct
name|USER
name|u
decl_stmt|;
name|unsigned
name|int
name|offset
decl_stmt|;
name|offset
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|u
operator|.
name|pt_r0
operator|-
operator|(
name|char
operator|*
operator|)
operator|&
name|u
expr_stmt|;
name|regaddr
operator|=
name|offset
expr_stmt|;
comment|/* byte offset to r0;*/
comment|/*  offset = ptrace (3, inferior_pid, (PTRACE_ARG3_TYPE) offset, 0) - KERNEL_U_ADDR; */
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|PC_REGNUM
condition|;
name|regno
operator|++
control|)
block|{
comment|/*regaddr = register_addr (regno, offset);*/
comment|/* 88k enhancement  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
condition|;
name|i
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
control|)
block|{
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|buf
index|[
name|i
index|]
operator|=
name|ptrace
argument_list|(
literal|3
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|regaddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|regaddr
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
block|}
name|supply_register
argument_list|(
name|regno
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
comment|/* now load up registers 32-37; special pc registers */
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|buf
index|[
literal|0
index|]
operator|=
name|ptrace
argument_list|(
literal|3
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|PSR_OFFSET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|PSR_REGNUM
argument_list|,
name|buf
argument_list|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|buf
index|[
literal|0
index|]
operator|=
name|ptrace
argument_list|(
literal|3
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|FPSR_OFFSET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|FPSR_REGNUM
argument_list|,
name|buf
argument_list|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|buf
index|[
literal|0
index|]
operator|=
name|ptrace
argument_list|(
literal|3
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|FPCR_OFFSET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|FPCR_REGNUM
argument_list|,
name|buf
argument_list|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|buf
index|[
literal|0
index|]
operator|=
name|ptrace
argument_list|(
literal|3
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|SXIP_OFFSET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|SXIP_REGNUM
argument_list|,
name|buf
argument_list|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|buf
index|[
literal|0
index|]
operator|=
name|ptrace
argument_list|(
literal|3
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|SNIP_OFFSET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|SNIP_REGNUM
argument_list|,
name|buf
argument_list|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|buf
index|[
literal|0
index|]
operator|=
name|ptrace
argument_list|(
literal|3
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|SFIP_OFFSET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|SFIP_REGNUM
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_is_m88110
condition|)
block|{
for|for
control|(
name|regaddr
operator|=
name|XREGADDR
argument_list|(
name|X0_REGNUM
argument_list|)
operator|,
name|regno
operator|=
name|X0_REGNUM
init|;
name|regno
operator|<
name|NUM_REGS
condition|;
name|regno
operator|++
operator|,
name|regaddr
operator|+=
literal|16
control|)
block|{
name|X_REGISTER_RAW_TYPE
name|xval
decl_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|xval
operator|.
name|w1
operator|=
name|ptrace
argument_list|(
literal|3
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|regaddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|xval
operator|.
name|w2
operator|=
name|ptrace
argument_list|(
literal|3
argument_list|,
name|inferior_pid
argument_list|,
call|(
name|PTRACE_ARG3_TYPE
call|)
argument_list|(
name|regaddr
operator|+
literal|4
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|xval
operator|.
name|w3
operator|=
name|ptrace
argument_list|(
literal|3
argument_list|,
name|inferior_pid
argument_list|,
call|(
name|PTRACE_ARG3_TYPE
call|)
argument_list|(
name|regaddr
operator|+
literal|8
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|xval
operator|.
name|w4
operator|=
name|ptrace
argument_list|(
literal|3
argument_list|,
name|inferior_pid
argument_list|,
call|(
name|PTRACE_ARG3_TYPE
call|)
argument_list|(
name|regaddr
operator|+
literal|12
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|regno
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|xval
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Store our register values back into the inferior.    If REGNO is -1, do this for all registers.    Otherwise, REGNO specifies which register (so we can save time).  */
end_comment

begin_function
name|void
name|store_inferior_registers
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
specifier|register
name|unsigned
name|int
name|regaddr
decl_stmt|;
name|char
name|buf
index|[
literal|80
index|]
decl_stmt|;
name|struct
name|USER
name|u
decl_stmt|;
name|unsigned
name|int
name|offset
init|=
operator|(
name|char
operator|*
operator|)
operator|&
name|u
operator|.
name|pt_r0
operator|-
operator|(
name|char
operator|*
operator|)
operator|&
name|u
decl_stmt|;
name|regaddr
operator|=
name|offset
expr_stmt|;
comment|/* Don't try to deal with EXIP_REGNUM or ENIP_REGNUM, because I think either      svr3 doesn't run on an 88110, or the kernel isolates the different (not      completely sure this is true, but seems to be.  */
if|if
condition|(
name|regno
operator|>=
literal|0
condition|)
block|{
comment|/*      regaddr = register_addr (regno, offset); */
if|if
condition|(
name|regno
operator|<
name|PC_REGNUM
condition|)
block|{
name|regaddr
operator|=
name|offset
operator|+
name|regno
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|ptrace
argument_list|(
literal|6
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|regaddr
argument_list|,
name|read_register
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"writing register number %d"
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|perror_with_name
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|regno
operator|==
name|PSR_REGNUM
condition|)
name|ptrace
argument_list|(
literal|6
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|PSR_OFFSET
argument_list|,
name|read_register
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|regno
operator|==
name|FPSR_REGNUM
condition|)
name|ptrace
argument_list|(
literal|6
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|FPSR_OFFSET
argument_list|,
name|read_register
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|regno
operator|==
name|FPCR_REGNUM
condition|)
name|ptrace
argument_list|(
literal|6
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|FPCR_OFFSET
argument_list|,
name|read_register
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|regno
operator|==
name|SXIP_REGNUM
condition|)
name|ptrace
argument_list|(
literal|6
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|SXIP_OFFSET
argument_list|,
name|read_register
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|regno
operator|==
name|SNIP_REGNUM
condition|)
name|ptrace
argument_list|(
literal|6
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|SNIP_OFFSET
argument_list|,
name|read_register
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|regno
operator|==
name|SFIP_REGNUM
condition|)
name|ptrace
argument_list|(
literal|6
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|SFIP_OFFSET
argument_list|,
name|read_register
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|target_is_m88110
operator|&&
name|regno
operator|<
name|NUM_REGS
condition|)
block|{
name|X_REGISTER_RAW_TYPE
name|xval
decl_stmt|;
name|read_register_bytes
argument_list|(
name|REGISTER_BYTE
argument_list|(
name|regno
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|xval
argument_list|,
sizeof|sizeof
argument_list|(
name|X_REGISTER_RAW_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|regaddr
operator|=
name|XREGADDR
argument_list|(
name|regno
argument_list|)
expr_stmt|;
name|ptrace
argument_list|(
literal|6
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|regaddr
argument_list|,
name|xval
operator|.
name|w1
argument_list|)
expr_stmt|;
name|ptrace
argument_list|(
literal|6
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|regaddr
operator|+
literal|4
argument_list|,
name|xval
operator|.
name|w2
argument_list|)
expr_stmt|;
name|ptrace
argument_list|(
literal|6
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|regaddr
operator|+
literal|8
argument_list|,
name|xval
operator|.
name|w3
argument_list|)
expr_stmt|;
name|ptrace
argument_list|(
literal|6
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|regaddr
operator|+
literal|12
argument_list|,
name|xval
operator|.
name|w4
argument_list|)
expr_stmt|;
block|}
else|else
name|printf_unfiltered
argument_list|(
literal|"Bad register number for store_inferior routine\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|PC_REGNUM
condition|;
name|regno
operator|++
control|)
block|{
comment|/*      regaddr = register_addr (regno, offset); */
name|errno
operator|=
literal|0
expr_stmt|;
name|regaddr
operator|=
name|offset
operator|+
name|regno
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|ptrace
argument_list|(
literal|6
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|regaddr
argument_list|,
name|read_register
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"writing register number %d"
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|perror_with_name
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
name|ptrace
argument_list|(
literal|6
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|PSR_OFFSET
argument_list|,
name|read_register
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
name|ptrace
argument_list|(
literal|6
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|FPSR_OFFSET
argument_list|,
name|read_register
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
name|ptrace
argument_list|(
literal|6
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|FPCR_OFFSET
argument_list|,
name|read_register
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
name|ptrace
argument_list|(
literal|6
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|SXIP_OFFSET
argument_list|,
name|read_register
argument_list|(
name|SXIP_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
name|ptrace
argument_list|(
literal|6
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|SNIP_OFFSET
argument_list|,
name|read_register
argument_list|(
name|SNIP_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
name|ptrace
argument_list|(
literal|6
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|SFIP_OFFSET
argument_list|,
name|read_register
argument_list|(
name|SFIP_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_is_m88110
condition|)
block|{
for|for
control|(
name|regno
operator|=
name|X0_REGNUM
init|;
name|regno
operator|<
name|NUM_REGS
condition|;
name|regno
operator|++
control|)
block|{
name|X_REGISTER_RAW_TYPE
name|xval
decl_stmt|;
name|read_register_bytes
argument_list|(
name|REGISTER_BYTE
argument_list|(
name|regno
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|xval
argument_list|,
sizeof|sizeof
argument_list|(
name|X_REGISTER_RAW_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|regaddr
operator|=
name|XREGADDR
argument_list|(
name|regno
argument_list|)
expr_stmt|;
name|ptrace
argument_list|(
literal|6
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|regaddr
argument_list|,
name|xval
operator|.
name|w1
argument_list|)
expr_stmt|;
name|ptrace
argument_list|(
literal|6
argument_list|,
name|inferior_pid
argument_list|,
call|(
name|PTRACE_ARG3_TYPE
call|)
argument_list|(
name|regaddr
operator|+
literal|4
argument_list|)
argument_list|,
name|xval
operator|.
name|w2
argument_list|)
expr_stmt|;
name|ptrace
argument_list|(
literal|6
argument_list|,
name|inferior_pid
argument_list|,
call|(
name|PTRACE_ARG3_TYPE
call|)
argument_list|(
name|regaddr
operator|+
literal|8
argument_list|)
argument_list|,
name|xval
operator|.
name|w3
argument_list|)
expr_stmt|;
name|ptrace
argument_list|(
literal|6
argument_list|,
name|inferior_pid
argument_list|,
call|(
name|PTRACE_ARG3_TYPE
call|)
argument_list|(
name|regaddr
operator|+
literal|12
argument_list|)
argument_list|,
name|xval
operator|.
name|w4
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* blockend is the address of the end of the user structure */
end_comment

begin_macro
name|m88k_register_u_addr
argument_list|(
argument|blockend
argument_list|,
argument|regnum
argument_list|)
end_macro

begin_decl_stmt
name|int
name|blockend
decl_stmt|,
name|regnum
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|USER
name|u
decl_stmt|;
name|int
name|ustart
init|=
name|blockend
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|USER
argument_list|)
decl_stmt|;
if|if
condition|(
name|regnum
operator|<
name|PSR_REGNUM
condition|)
return|return
operator|(
name|ustart
operator|+
operator|(
operator|(
name|int
operator|)
operator|&
name|u
operator|.
name|pt_r0
operator|-
operator|(
name|int
operator|)
operator|&
name|u
operator|)
operator|+
name|REGISTER_SIZE
operator|*
name|regnum
operator|)
return|;
elseif|else
if|if
condition|(
name|regnum
operator|==
name|PSR_REGNUM
condition|)
return|return
operator|(
name|ustart
operator|+
operator|(
operator|(
name|int
operator|)
operator|&
name|u
operator|.
name|pt_psr
operator|)
operator|-
operator|(
name|int
operator|)
operator|&
name|u
operator|)
return|;
elseif|else
if|if
condition|(
name|regnum
operator|==
name|FPSR_REGNUM
condition|)
return|return
operator|(
name|ustart
operator|+
operator|(
operator|(
name|int
operator|)
operator|&
name|u
operator|.
name|pt_fpsr
operator|)
operator|-
operator|(
name|int
operator|)
operator|&
name|u
operator|)
return|;
elseif|else
if|if
condition|(
name|regnum
operator|==
name|FPCR_REGNUM
condition|)
return|return
operator|(
name|ustart
operator|+
operator|(
operator|(
name|int
operator|)
operator|&
name|u
operator|.
name|pt_fpcr
operator|)
operator|-
operator|(
name|int
operator|)
operator|&
name|u
operator|)
return|;
elseif|else
if|if
condition|(
name|regnum
operator|==
name|SXIP_REGNUM
condition|)
return|return
operator|(
name|ustart
operator|+
name|SXIP_OFFSET
operator|)
return|;
elseif|else
if|if
condition|(
name|regnum
operator|==
name|SNIP_REGNUM
condition|)
return|return
operator|(
name|ustart
operator|+
name|SNIP_OFFSET
operator|)
return|;
elseif|else
if|if
condition|(
name|regnum
operator|==
name|SFIP_REGNUM
condition|)
return|return
operator|(
name|ustart
operator|+
name|SFIP_OFFSET
operator|)
return|;
elseif|else
if|if
condition|(
name|target_is_m88110
condition|)
return|return
operator|(
name|ustart
operator|+
operator|(
operator|(
name|int
operator|)
operator|&
name|u
operator|.
name|pt_x0
operator|-
operator|(
name|int
operator|)
operator|&
name|u
operator|)
operator|+
comment|/* Must be X register */
sizeof|sizeof
argument_list|(
name|u
operator|.
name|pt_x0
argument_list|)
operator|*
operator|(
name|regnum
operator|-
name|X0_REGNUM
operator|)
operator|)
return|;
else|else
return|return
operator|(
name|blockend
operator|+
name|REGISTER_SIZE
operator|*
name|regnum
operator|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|USE_PROC_FS
end_ifdef

begin_include
include|#
directive|include
file|<sys/procfs.h>
end_include

begin_comment
comment|/*  Given a pointer to a general register set in /proc format (gregset_t *),     unpack the register contents and supply them as gdb's idea of the current     register values. */
end_comment

begin_function
name|void
name|supply_gregset
parameter_list|(
name|gregsetp
parameter_list|)
name|gregset_t
modifier|*
name|gregsetp
decl_stmt|;
block|{
specifier|register
name|int
name|regi
decl_stmt|;
specifier|register
name|greg_t
modifier|*
name|regp
init|=
operator|(
name|greg_t
operator|*
operator|)
name|gregsetp
decl_stmt|;
for|for
control|(
name|regi
operator|=
literal|0
init|;
name|regi
operator|<=
name|SP_REGNUM
condition|;
name|regi
operator|++
control|)
name|supply_register
argument_list|(
name|regi
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
name|regi
operator|)
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|SXIP_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
name|R_XIP
operator|)
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|SNIP_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
name|R_NIP
operator|)
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|SFIP_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
name|R_FIP
operator|)
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|PSR_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
name|R_PSR
operator|)
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|FPSR_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
name|R_FPSR
operator|)
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|FPCR_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
name|R_FPCR
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fill_gregset
parameter_list|(
name|gregsetp
parameter_list|,
name|regno
parameter_list|)
name|gregset_t
modifier|*
name|gregsetp
decl_stmt|;
name|int
name|regno
decl_stmt|;
block|{
name|int
name|regi
decl_stmt|;
specifier|register
name|greg_t
modifier|*
name|regp
init|=
operator|(
name|greg_t
operator|*
operator|)
name|gregsetp
decl_stmt|;
specifier|extern
name|char
name|registers
index|[]
decl_stmt|;
for|for
control|(
name|regi
operator|=
literal|0
init|;
name|regi
operator|<=
name|R_R31
condition|;
name|regi
operator|++
control|)
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|regno
operator|==
name|regi
operator|)
condition|)
operator|*
operator|(
name|regp
operator|+
name|regi
operator|)
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|regi
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|regno
operator|==
name|SXIP_REGNUM
operator|)
condition|)
operator|*
operator|(
name|regp
operator|+
name|R_XIP
operator|)
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|SXIP_REGNUM
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|regno
operator|==
name|SNIP_REGNUM
operator|)
condition|)
operator|*
operator|(
name|regp
operator|+
name|R_NIP
operator|)
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|SNIP_REGNUM
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|regno
operator|==
name|SFIP_REGNUM
operator|)
condition|)
operator|*
operator|(
name|regp
operator|+
name|R_FIP
operator|)
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|SFIP_REGNUM
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|regno
operator|==
name|PSR_REGNUM
operator|)
condition|)
operator|*
operator|(
name|regp
operator|+
name|R_PSR
operator|)
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|PSR_REGNUM
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|regno
operator|==
name|FPSR_REGNUM
operator|)
condition|)
operator|*
operator|(
name|regp
operator|+
name|R_FPSR
operator|)
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|FPSR_REGNUM
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|regno
operator|==
name|FPCR_REGNUM
operator|)
condition|)
operator|*
operator|(
name|regp
operator|+
name|R_FPCR
operator|)
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|FPCR_REGNUM
argument_list|)
index|]
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_PROC_FS */
end_comment

begin_comment
comment|/* This support adds the equivalent of adb's % command.  When    the `add-shared-symbol-files' command is given, this routine scans     the dynamic linker's link map and reads the minimal symbols    from each shared object file listed in the map. */
end_comment

begin_struct
struct|struct
name|link_map
block|{
name|unsigned
name|long
name|l_addr
decl_stmt|;
comment|/* address at which object is mapped */
name|char
modifier|*
name|l_name
decl_stmt|;
comment|/* full name of loaded object */
name|void
modifier|*
name|l_ld
decl_stmt|;
comment|/* dynamic structure of object */
name|struct
name|link_map
modifier|*
name|l_next
decl_stmt|;
comment|/* next link object */
name|struct
name|link_map
modifier|*
name|l_prev
decl_stmt|;
comment|/* previous link object */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|LINKS_MAP_POINTER
value|"_ld_tail"
end_define

begin_define
define|#
directive|define
name|LIBC_FILE
value|"/usr/lib/libc.so.1"
end_define

begin_define
define|#
directive|define
name|SHARED_OFFSET
value|0xf0001000
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|PATH_MAX
end_ifndef

begin_define
define|#
directive|define
name|PATH_MAX
value|1023
end_define

begin_comment
comment|/* maximum size of path name on OS */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|add_shared_symbol_files
parameter_list|()
block|{
name|void
modifier|*
name|desc
decl_stmt|;
name|struct
name|link_map
modifier|*
name|ld_map
decl_stmt|,
modifier|*
name|lm
decl_stmt|,
name|lms
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|minsym
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|char
modifier|*
name|path_name
decl_stmt|;
if|if
condition|(
operator|!
name|inferior_pid
condition|)
block|{
name|warning
argument_list|(
literal|"The program has not yet been started."
argument_list|)
expr_stmt|;
return|return;
block|}
name|objfile
operator|=
name|symbol_file_add
argument_list|(
name|LIBC_FILE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|minsym
operator|=
name|lookup_minimal_symbol
argument_list|(
name|LINKS_MAP_POINTER
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|ld_map
operator|=
operator|(
expr|struct
name|link_map
operator|*
operator|)
name|read_memory_integer
argument_list|(
operator|(
operator|(
name|int
operator|)
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|minsym
argument_list|)
operator|+
name|SHARED_OFFSET
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|lm
operator|=
name|ld_map
expr_stmt|;
while|while
condition|(
name|lm
condition|)
block|{
name|int
name|local_errno
init|=
literal|0
decl_stmt|;
name|read_memory
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|lm
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|lms
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|link_map
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lms
operator|.
name|l_name
condition|)
block|{
if|if
condition|(
name|target_read_string
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|lms
operator|.
name|l_name
argument_list|,
operator|&
name|path_name
argument_list|,
name|PATH_MAX
argument_list|,
operator|&
name|local_errno
argument_list|)
condition|)
block|{
name|symbol_file_add
argument_list|(
name|path_name
argument_list|,
literal|1
argument_list|,
name|lms
operator|.
name|l_addr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|path_name
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* traverse links in reverse order so that we get the 	 the symbols the user actually gets. */
name|lm
operator|=
name|lms
operator|.
name|l_prev
expr_stmt|;
block|}
comment|/* Getting new symbols may change our opinion about what is      frameless.  */
name|reinit_frame_cache
argument_list|()
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_ES_MP
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/regset.h>
end_include

begin_function
name|unsigned
name|int
name|m88k_harris_core_register_addr
parameter_list|(
name|regno
parameter_list|,
name|reg_ptr
parameter_list|)
name|int
name|regno
decl_stmt|,
name|reg_ptr
decl_stmt|;
block|{
name|unsigned
name|int
name|word_offset
decl_stmt|;
switch|switch
condition|(
name|regno
condition|)
block|{
case|case
name|PSR_REGNUM
case|:
name|word_offset
operator|=
name|R_EPSR
expr_stmt|;
break|break;
case|case
name|FPSR_REGNUM
case|:
name|word_offset
operator|=
name|R_FPSR
expr_stmt|;
break|break;
case|case
name|FPCR_REGNUM
case|:
name|word_offset
operator|=
name|R_FPCR
expr_stmt|;
break|break;
case|case
name|SXIP_REGNUM
case|:
name|word_offset
operator|=
name|R_EXIP
expr_stmt|;
break|break;
case|case
name|SNIP_REGNUM
case|:
name|word_offset
operator|=
name|R_ENIP
expr_stmt|;
break|break;
case|case
name|SFIP_REGNUM
case|:
name|word_offset
operator|=
name|R_EFIP
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|regno
operator|<=
name|FP_REGNUM
condition|)
name|word_offset
operator|=
name|regno
expr_stmt|;
else|else
name|word_offset
operator|=
operator|(
operator|(
name|regno
operator|-
name|X0_REGNUM
operator|)
operator|*
literal|4
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|word_offset
operator|*
literal|4
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _ES_MP */
end_comment

begin_function
name|void
name|_initialize_m88k_nat
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|_ES_MP
comment|/* Enable 88110 support, as we don't support the 88100 under ES/MP.  */
name|target_is_m88110
operator|=
literal|1
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|_CX_UX
argument_list|)
comment|/* Determine whether we're running on an 88100 or an 88110.  */
name|target_is_m88110
operator|=
operator|(
name|sinfo
argument_list|(
name|SYSMACHINE
argument_list|,
literal|0
argument_list|)
operator|==
name|SYS5800
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* _CX_UX */
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|_ES_MP
end_ifdef

begin_comment
comment|/* Given a pointer to a general register set in /proc format (gregset_t *),    unpack the register contents and supply them as gdb's idea of the current    register values. */
end_comment

begin_function
name|void
name|supply_gregset
parameter_list|(
name|gregsetp
parameter_list|)
name|gregset_t
modifier|*
name|gregsetp
decl_stmt|;
block|{
specifier|register
name|int
name|regi
decl_stmt|;
specifier|register
name|greg_t
modifier|*
name|regp
init|=
operator|(
name|greg_t
operator|*
operator|)
name|gregsetp
decl_stmt|;
for|for
control|(
name|regi
operator|=
literal|0
init|;
name|regi
operator|<
name|R_R31
condition|;
name|regi
operator|++
control|)
block|{
name|supply_register
argument_list|(
name|regi
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
name|regi
operator|)
argument_list|)
expr_stmt|;
block|}
name|supply_register
argument_list|(
name|PSR_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
name|R_EPSR
operator|)
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|FPSR_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
name|R_FPSR
operator|)
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|FPCR_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
name|R_FPCR
operator|)
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|SXIP_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
name|R_EXIP
operator|)
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|SNIP_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
name|R_ENIP
operator|)
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|SFIP_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
name|R_EFIP
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a pointer to a floating point register set in /proc format    (fpregset_t *), unpack the register contents and supply them as gdb's    idea of the current floating point register values.  */
end_comment

begin_function
name|void
name|supply_fpregset
parameter_list|(
name|fpregsetp
parameter_list|)
name|fpregset_t
modifier|*
name|fpregsetp
decl_stmt|;
block|{
specifier|register
name|int
name|regi
decl_stmt|;
name|char
modifier|*
name|from
decl_stmt|;
for|for
control|(
name|regi
operator|=
name|FP0_REGNUM
init|;
name|regi
operator|<=
name|FPLAST_REGNUM
condition|;
name|regi
operator|++
control|)
block|{
name|from
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
operator|(
operator|*
name|fpregsetp
operator|)
index|[
name|regi
operator|-
name|FP0_REGNUM
index|]
operator|)
expr_stmt|;
name|supply_register
argument_list|(
name|regi
argument_list|,
name|from
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _ES_MP */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_CX_UX
end_ifdef

begin_include
include|#
directive|include
file|<sys/regset.h>
end_include

begin_function
name|unsigned
name|int
name|m88k_harris_core_register_addr
parameter_list|(
name|int
name|regno
parameter_list|,
name|int
name|reg_ptr
parameter_list|)
block|{
name|unsigned
name|int
name|word_offset
decl_stmt|;
switch|switch
condition|(
name|regno
condition|)
block|{
case|case
name|PSR_REGNUM
case|:
name|word_offset
operator|=
name|R_PSR
expr_stmt|;
break|break;
case|case
name|FPSR_REGNUM
case|:
name|word_offset
operator|=
name|R_FPSR
expr_stmt|;
break|break;
case|case
name|FPCR_REGNUM
case|:
name|word_offset
operator|=
name|R_FPCR
expr_stmt|;
break|break;
case|case
name|SXIP_REGNUM
case|:
name|word_offset
operator|=
name|R_XIP
expr_stmt|;
break|break;
case|case
name|SNIP_REGNUM
case|:
name|word_offset
operator|=
name|R_NIP
expr_stmt|;
break|break;
case|case
name|SFIP_REGNUM
case|:
name|word_offset
operator|=
name|R_FIP
expr_stmt|;
break|break;
default|default :
if|if
condition|(
name|regno
operator|<=
name|FP_REGNUM
condition|)
name|word_offset
operator|=
name|regno
expr_stmt|;
else|else
name|word_offset
operator|=
operator|(
operator|(
name|regno
operator|-
name|X0_REGNUM
operator|)
operator|*
literal|4
operator|)
operator|+
name|R_X0
expr_stmt|;
block|}
return|return
operator|(
name|word_offset
operator|*
literal|4
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _CX_UX */
end_comment

end_unit

