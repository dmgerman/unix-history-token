begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Parse expressions for GDB.    Copyright (C) 1986, 89, 90, 91, 94, 1998 Free Software Foundation, Inc.    Modified from expread.y by the Department of Computer Science at the    State University of New York at Buffalo, 1991.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* Parse an expression from text in a string,    and return the result as a  struct expression  pointer.    That structure contains arithmetic operations in reverse polish,    with constants represented by operations that are followed by special data.    See expression.h for the details of the format.    What is important here is that it can be built up sequentially    during the process of parsing; the lower levels of the tree always    come first in the result.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"parser-defs.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_comment
comment|/* for overlay functions */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Global variables declared in parser-defs.h (and commented there).  */
end_comment

begin_decl_stmt
name|struct
name|expression
modifier|*
name|expout
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|expout_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|expout_ptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|block
modifier|*
name|expression_context_block
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|block
modifier|*
name|innermost_block
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|arglist_len
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|union
name|type_stack_elt
modifier|*
name|type_stack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|type_stack_depth
decl_stmt|,
name|type_stack_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|lexptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|namecopy
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|paren_depth
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|comma_terminates
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|MAINTENANCE_CMDS
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|expressiondebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|int
name|hp_som_som_object_present
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_funcalls
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|prefixify_expression
name|PARAMS
argument_list|(
operator|(
expr|struct
name|expression
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|prefixify_subexp
name|PARAMS
argument_list|(
operator|(
expr|struct
name|expression
operator|*
operator|,
expr|struct
name|expression
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Data structure for saving values of arglist_len for function calls whose    arguments contain other function calls.  */
end_comment

begin_struct
struct|struct
name|funcall
block|{
name|struct
name|funcall
modifier|*
name|next
decl_stmt|;
name|int
name|arglist_len
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|funcall
modifier|*
name|funcall_chain
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Assign machine-independent names to certain registers     (unless overridden by the REGISTER_NAMES table) */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|NO_STD_REGS
end_ifdef

begin_decl_stmt
name|unsigned
name|num_std_regs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|std_regs
name|std_regs
index|[
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|struct
name|std_regs
name|std_regs
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|PC_REGNUM
block|{
literal|"pc"
block|,
name|PC_REGNUM
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|FP_REGNUM
block|{
literal|"fp"
block|,
name|FP_REGNUM
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SP_REGNUM
block|{
literal|"sp"
block|,
name|SP_REGNUM
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PS_REGNUM
block|{
literal|"ps"
block|,
name|PS_REGNUM
block|}
block|,
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|num_std_regs
init|=
operator|(
sizeof|sizeof
name|std_regs
operator|/
sizeof|sizeof
name|std_regs
index|[
literal|0
index|]
operator|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The generic method for targets to specify how their registers are    named.  The mapping can be derived from three sources:    REGISTER_NAME; std_regs; or a target specific alias hook. */
end_comment

begin_function
name|int
name|target_map_name_to_register
parameter_list|(
name|str
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
comment|/* First try target specific aliases. We try these first because on some       systems standard names can be context dependent (eg. $pc on a       multiprocessor can be could be any of several PCs).  */
ifdef|#
directive|ifdef
name|REGISTER_NAME_ALIAS_HOOK
name|i
operator|=
name|REGISTER_NAME_ALIAS_HOOK
argument_list|(
name|str
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
return|return
name|i
return|;
endif|#
directive|endif
comment|/* Search architectural register name space. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_REGS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|REGISTER_NAME
argument_list|(
name|i
argument_list|)
operator|&&
name|len
operator|==
name|strlen
argument_list|(
name|REGISTER_NAME
argument_list|(
name|i
argument_list|)
argument_list|)
operator|&&
name|STREQN
argument_list|(
name|str
argument_list|,
name|REGISTER_NAME
argument_list|(
name|i
argument_list|)
argument_list|,
name|len
argument_list|)
condition|)
block|{
return|return
name|i
return|;
block|}
comment|/* Try standard aliases */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_std_regs
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|std_regs
index|[
name|i
index|]
operator|.
name|name
operator|&&
name|len
operator|==
name|strlen
argument_list|(
name|std_regs
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|&&
name|STREQN
argument_list|(
name|str
argument_list|,
name|std_regs
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|len
argument_list|)
condition|)
block|{
return|return
name|std_regs
index|[
name|i
index|]
operator|.
name|regnum
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Begin counting arguments for a function call,    saving the data about any containing call.  */
end_comment

begin_function
name|void
name|start_arglist
parameter_list|()
block|{
specifier|register
name|struct
name|funcall
modifier|*
name|new
decl_stmt|;
name|new
operator|=
operator|(
expr|struct
name|funcall
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|funcall
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|funcall_chain
expr_stmt|;
name|new
operator|->
name|arglist_len
operator|=
name|arglist_len
expr_stmt|;
name|arglist_len
operator|=
literal|0
expr_stmt|;
name|funcall_chain
operator|=
name|new
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the number of arguments in a function call just terminated,    and restore the data for the containing function call.  */
end_comment

begin_function
name|int
name|end_arglist
parameter_list|()
block|{
specifier|register
name|int
name|val
init|=
name|arglist_len
decl_stmt|;
specifier|register
name|struct
name|funcall
modifier|*
name|call
init|=
name|funcall_chain
decl_stmt|;
name|funcall_chain
operator|=
name|call
operator|->
name|next
expr_stmt|;
name|arglist_len
operator|=
name|call
operator|->
name|arglist_len
expr_stmt|;
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|call
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Free everything in the funcall chain.    Used when there is an error inside parsing.  */
end_comment

begin_function
specifier|static
name|void
name|free_funcalls
parameter_list|()
block|{
specifier|register
name|struct
name|funcall
modifier|*
name|call
decl_stmt|,
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|call
operator|=
name|funcall_chain
init|;
name|call
condition|;
name|call
operator|=
name|next
control|)
block|{
name|next
operator|=
name|call
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|call
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This page contains the functions for adding data to the  struct expression    being constructed.  */
end_comment

begin_comment
comment|/* Add one element to the end of the expression.  */
end_comment

begin_comment
comment|/* To avoid a bug in the Sun 4 compiler, we pass things that can fit into    a register through here */
end_comment

begin_function
name|void
name|write_exp_elt
parameter_list|(
name|expelt
parameter_list|)
name|union
name|exp_element
name|expelt
decl_stmt|;
block|{
if|if
condition|(
name|expout_ptr
operator|>=
name|expout_size
condition|)
block|{
name|expout_size
operator|*=
literal|2
expr_stmt|;
name|expout
operator|=
operator|(
expr|struct
name|expression
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|expout
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|expression
argument_list|)
operator|+
name|EXP_ELEM_TO_BYTES
argument_list|(
name|expout_size
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|expout
operator|->
name|elts
index|[
name|expout_ptr
operator|++
index|]
operator|=
name|expelt
expr_stmt|;
block|}
end_function

begin_function
name|void
name|write_exp_elt_opcode
parameter_list|(
name|expelt
parameter_list|)
name|enum
name|exp_opcode
name|expelt
decl_stmt|;
block|{
name|union
name|exp_element
name|tmp
decl_stmt|;
name|tmp
operator|.
name|opcode
operator|=
name|expelt
expr_stmt|;
name|write_exp_elt
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|write_exp_elt_sym
parameter_list|(
name|expelt
parameter_list|)
name|struct
name|symbol
modifier|*
name|expelt
decl_stmt|;
block|{
name|union
name|exp_element
name|tmp
decl_stmt|;
name|tmp
operator|.
name|symbol
operator|=
name|expelt
expr_stmt|;
name|write_exp_elt
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|write_exp_elt_block
parameter_list|(
name|b
parameter_list|)
name|struct
name|block
modifier|*
name|b
decl_stmt|;
block|{
name|union
name|exp_element
name|tmp
decl_stmt|;
name|tmp
operator|.
name|block
operator|=
name|b
expr_stmt|;
name|write_exp_elt
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|write_exp_elt_longcst
parameter_list|(
name|expelt
parameter_list|)
name|LONGEST
name|expelt
decl_stmt|;
block|{
name|union
name|exp_element
name|tmp
decl_stmt|;
name|tmp
operator|.
name|longconst
operator|=
name|expelt
expr_stmt|;
name|write_exp_elt
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|write_exp_elt_dblcst
parameter_list|(
name|expelt
parameter_list|)
name|DOUBLEST
name|expelt
decl_stmt|;
block|{
name|union
name|exp_element
name|tmp
decl_stmt|;
name|tmp
operator|.
name|doubleconst
operator|=
name|expelt
expr_stmt|;
name|write_exp_elt
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|write_exp_elt_type
parameter_list|(
name|expelt
parameter_list|)
name|struct
name|type
modifier|*
name|expelt
decl_stmt|;
block|{
name|union
name|exp_element
name|tmp
decl_stmt|;
name|tmp
operator|.
name|type
operator|=
name|expelt
expr_stmt|;
name|write_exp_elt
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|write_exp_elt_intern
parameter_list|(
name|expelt
parameter_list|)
name|struct
name|internalvar
modifier|*
name|expelt
decl_stmt|;
block|{
name|union
name|exp_element
name|tmp
decl_stmt|;
name|tmp
operator|.
name|internalvar
operator|=
name|expelt
expr_stmt|;
name|write_exp_elt
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a string constant to the end of the expression.     String constants are stored by first writing an expression element    that contains the length of the string, then stuffing the string    constant itself into however many expression elements are needed    to hold it, and then writing another expression element that contains    the length of the string.  I.E. an expression element at each end of    the string records the string length, so you can skip over the     expression elements containing the actual string bytes from either    end of the string.  Note that this also allows gdb to handle    strings with embedded null bytes, as is required for some languages.     Don't be fooled by the fact that the string is null byte terminated,    this is strictly for the convenience of debugging gdb itself.  Gdb    Gdb does not depend up the string being null terminated, since the    actual length is recorded in expression elements at each end of the    string.  The null byte is taken into consideration when computing how    many expression elements are required to hold the string constant, of    course. */
end_comment

begin_function
name|void
name|write_exp_string
parameter_list|(
name|str
parameter_list|)
name|struct
name|stoken
name|str
decl_stmt|;
block|{
specifier|register
name|int
name|len
init|=
name|str
operator|.
name|length
decl_stmt|;
specifier|register
name|int
name|lenelt
decl_stmt|;
specifier|register
name|char
modifier|*
name|strdata
decl_stmt|;
comment|/* Compute the number of expression elements required to hold the string      (including a null byte terminator), along with one expression element      at each end to record the actual string length (not including the      null byte terminator). */
name|lenelt
operator|=
literal|2
operator|+
name|BYTES_TO_EXP_ELEM
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Ensure that we have enough available expression elements to store      everything. */
if|if
condition|(
operator|(
name|expout_ptr
operator|+
name|lenelt
operator|)
operator|>=
name|expout_size
condition|)
block|{
name|expout_size
operator|=
name|max
argument_list|(
name|expout_size
operator|*
literal|2
argument_list|,
name|expout_ptr
operator|+
name|lenelt
operator|+
literal|10
argument_list|)
expr_stmt|;
name|expout
operator|=
operator|(
expr|struct
name|expression
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|expout
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|expression
argument_list|)
operator|+
name|EXP_ELEM_TO_BYTES
argument_list|(
name|expout_size
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Write the leading length expression element (which advances the current      expression element index), then write the string constant followed by a      terminating null byte, and then write the trailing length expression      element. */
name|write_exp_elt_longcst
argument_list|(
operator|(
name|LONGEST
operator|)
name|len
argument_list|)
expr_stmt|;
name|strdata
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|expout
operator|->
name|elts
index|[
name|expout_ptr
index|]
expr_stmt|;
name|memcpy
argument_list|(
name|strdata
argument_list|,
name|str
operator|.
name|ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|*
operator|(
name|strdata
operator|+
name|len
operator|)
operator|=
literal|'\0'
expr_stmt|;
name|expout_ptr
operator|+=
name|lenelt
operator|-
literal|2
expr_stmt|;
name|write_exp_elt_longcst
argument_list|(
operator|(
name|LONGEST
operator|)
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a bitstring constant to the end of the expression.     Bitstring constants are stored by first writing an expression element    that contains the length of the bitstring (in bits), then stuffing the    bitstring constant itself into however many expression elements are    needed to hold it, and then writing another expression element that    contains the length of the bitstring.  I.E. an expression element at    each end of the bitstring records the bitstring length, so you can skip    over the expression elements containing the actual bitstring bytes from    either end of the bitstring. */
end_comment

begin_function
name|void
name|write_exp_bitstring
parameter_list|(
name|str
parameter_list|)
name|struct
name|stoken
name|str
decl_stmt|;
block|{
specifier|register
name|int
name|bits
init|=
name|str
operator|.
name|length
decl_stmt|;
comment|/* length in bits */
specifier|register
name|int
name|len
init|=
operator|(
name|bits
operator|+
name|HOST_CHAR_BIT
operator|-
literal|1
operator|)
operator|/
name|HOST_CHAR_BIT
decl_stmt|;
specifier|register
name|int
name|lenelt
decl_stmt|;
specifier|register
name|char
modifier|*
name|strdata
decl_stmt|;
comment|/* Compute the number of expression elements required to hold the bitstring,      along with one expression element at each end to record the actual      bitstring length in bits. */
name|lenelt
operator|=
literal|2
operator|+
name|BYTES_TO_EXP_ELEM
argument_list|(
name|len
argument_list|)
expr_stmt|;
comment|/* Ensure that we have enough available expression elements to store      everything. */
if|if
condition|(
operator|(
name|expout_ptr
operator|+
name|lenelt
operator|)
operator|>=
name|expout_size
condition|)
block|{
name|expout_size
operator|=
name|max
argument_list|(
name|expout_size
operator|*
literal|2
argument_list|,
name|expout_ptr
operator|+
name|lenelt
operator|+
literal|10
argument_list|)
expr_stmt|;
name|expout
operator|=
operator|(
expr|struct
name|expression
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|expout
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|expression
argument_list|)
operator|+
name|EXP_ELEM_TO_BYTES
argument_list|(
name|expout_size
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Write the leading length expression element (which advances the current      expression element index), then write the bitstring constant, and then      write the trailing length expression element. */
name|write_exp_elt_longcst
argument_list|(
operator|(
name|LONGEST
operator|)
name|bits
argument_list|)
expr_stmt|;
name|strdata
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|expout
operator|->
name|elts
index|[
name|expout_ptr
index|]
expr_stmt|;
name|memcpy
argument_list|(
name|strdata
argument_list|,
name|str
operator|.
name|ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|expout_ptr
operator|+=
name|lenelt
operator|-
literal|2
expr_stmt|;
name|write_exp_elt_longcst
argument_list|(
operator|(
name|LONGEST
operator|)
name|bits
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add the appropriate elements for a minimal symbol to the end of    the expression.  The rationale behind passing in text_symbol_type and    data_symbol_type was so that Modula-2 could pass in WORD for    data_symbol_type.  Perhaps it still is useful to have those types vary    based on the language, but they no longer have names like "int", so    the initial rationale is gone.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|msym_text_symbol_type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|msym_data_symbol_type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|msym_unknown_symbol_type
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|write_exp_msymbol
parameter_list|(
name|msymbol
parameter_list|,
name|text_symbol_type
parameter_list|,
name|data_symbol_type
parameter_list|)
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
name|struct
name|type
modifier|*
name|text_symbol_type
decl_stmt|;
name|struct
name|type
modifier|*
name|data_symbol_type
decl_stmt|;
block|{
name|CORE_ADDR
name|addr
decl_stmt|;
name|write_exp_elt_opcode
argument_list|(
name|OP_LONG
argument_list|)
expr_stmt|;
name|write_exp_elt_type
argument_list|(
name|lookup_pointer_type
argument_list|(
name|builtin_type_void
argument_list|)
argument_list|)
expr_stmt|;
name|addr
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|overlay_debugging
condition|)
name|addr
operator|=
name|symbol_overlayed_address
argument_list|(
name|addr
argument_list|,
name|SYMBOL_BFD_SECTION
argument_list|(
name|msymbol
argument_list|)
argument_list|)
expr_stmt|;
name|write_exp_elt_longcst
argument_list|(
operator|(
name|LONGEST
operator|)
name|addr
argument_list|)
expr_stmt|;
name|write_exp_elt_opcode
argument_list|(
name|OP_LONG
argument_list|)
expr_stmt|;
name|write_exp_elt_opcode
argument_list|(
name|UNOP_MEMVAL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|msymbol
operator|->
name|type
condition|)
block|{
case|case
name|mst_text
case|:
case|case
name|mst_file_text
case|:
case|case
name|mst_solib_trampoline
case|:
name|write_exp_elt_type
argument_list|(
name|msym_text_symbol_type
argument_list|)
expr_stmt|;
break|break;
case|case
name|mst_data
case|:
case|case
name|mst_file_data
case|:
case|case
name|mst_bss
case|:
case|case
name|mst_file_bss
case|:
name|write_exp_elt_type
argument_list|(
name|msym_data_symbol_type
argument_list|)
expr_stmt|;
break|break;
default|default:
name|write_exp_elt_type
argument_list|(
name|msym_unknown_symbol_type
argument_list|)
expr_stmt|;
break|break;
block|}
name|write_exp_elt_opcode
argument_list|(
name|UNOP_MEMVAL
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Recognize tokens that start with '$'.  These include:  	$regname	A native register name or a "standard 			register name".  	$variable	A convenience variable with a name chosen 			by the user.  	$digits		Value history with index<digits>, starting 			from the first value which has index 1.  	$$digits	Value history with index<digits> relative 			to the last value.  I.E. $$0 is the last 			value, $$1 is the one previous to that, $$2 			is the one previous to $$1, etc.  	$ | $0 | $$0	The last value in the value history.  	$$		An abbreviation for the second to the last 			value in the value history, I.E. $$1     */
end_comment

begin_function
name|void
name|write_dollar_variable
parameter_list|(
name|str
parameter_list|)
name|struct
name|stoken
name|str
decl_stmt|;
block|{
comment|/* Handle the tokens $digits; also $ (short for $0) and $$ (short for $$1)      and $$digits (equivalent to $<-digits> if you could type that). */
name|struct
name|symbol
modifier|*
name|sym
init|=
name|NULL
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|msym
init|=
name|NULL
decl_stmt|;
name|int
name|negate
init|=
literal|0
decl_stmt|;
name|int
name|i
init|=
literal|1
decl_stmt|;
comment|/* Double dollar means negate the number and add -1 as well.      Thus $$ alone means -1.  */
if|if
condition|(
name|str
operator|.
name|length
operator|>=
literal|2
operator|&&
name|str
operator|.
name|ptr
index|[
literal|1
index|]
operator|==
literal|'$'
condition|)
block|{
name|negate
operator|=
literal|1
expr_stmt|;
name|i
operator|=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|str
operator|.
name|length
condition|)
block|{
comment|/* Just dollars (one or two) */
name|i
operator|=
operator|-
name|negate
expr_stmt|;
goto|goto
name|handle_last
goto|;
block|}
comment|/* Is the rest of the token digits?  */
for|for
control|(
init|;
name|i
operator|<
name|str
operator|.
name|length
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
operator|(
name|str
operator|.
name|ptr
index|[
name|i
index|]
operator|>=
literal|'0'
operator|&&
name|str
operator|.
name|ptr
index|[
name|i
index|]
operator|<=
literal|'9'
operator|)
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|str
operator|.
name|length
condition|)
block|{
name|i
operator|=
name|atoi
argument_list|(
name|str
operator|.
name|ptr
operator|+
literal|1
operator|+
name|negate
argument_list|)
expr_stmt|;
if|if
condition|(
name|negate
condition|)
name|i
operator|=
operator|-
name|i
expr_stmt|;
goto|goto
name|handle_last
goto|;
block|}
comment|/* Handle tokens that refer to machine registers:      $ followed by a register name.  */
name|i
operator|=
name|target_map_name_to_register
argument_list|(
name|str
operator|.
name|ptr
operator|+
literal|1
argument_list|,
name|str
operator|.
name|length
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
goto|goto
name|handle_register
goto|;
comment|/* On HP-UX, certain system routines (millicode) have names beginning      with $ or $$, e.g. $$dyncall, which handles inter-space procedure      calls on PA-RISC. Check for those, first. */
name|sym
operator|=
name|lookup_symbol
argument_list|(
name|copy_name
argument_list|(
name|str
argument_list|)
argument_list|,
operator|(
expr|struct
name|block
operator|*
operator|)
name|NULL
argument_list|,
name|VAR_NAMESPACE
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
operator|(
expr|struct
name|symtab
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
condition|)
block|{
name|write_exp_elt_opcode
argument_list|(
name|OP_VAR_VALUE
argument_list|)
expr_stmt|;
name|write_exp_elt_block
argument_list|(
name|block_found
argument_list|)
expr_stmt|;
comment|/* set by lookup_symbol */
name|write_exp_elt_sym
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|write_exp_elt_opcode
argument_list|(
name|OP_VAR_VALUE
argument_list|)
expr_stmt|;
return|return;
block|}
name|msym
operator|=
name|lookup_minimal_symbol
argument_list|(
name|copy_name
argument_list|(
name|str
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|msym
condition|)
block|{
name|write_exp_msymbol
argument_list|(
name|msym
argument_list|,
name|lookup_function_type
argument_list|(
name|builtin_type_int
argument_list|)
argument_list|,
name|builtin_type_int
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Any other names starting in $ are debugger internal variables.  */
name|write_exp_elt_opcode
argument_list|(
name|OP_INTERNALVAR
argument_list|)
expr_stmt|;
name|write_exp_elt_intern
argument_list|(
name|lookup_internalvar
argument_list|(
name|copy_name
argument_list|(
name|str
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|write_exp_elt_opcode
argument_list|(
name|OP_INTERNALVAR
argument_list|)
expr_stmt|;
return|return;
name|handle_last
label|:
name|write_exp_elt_opcode
argument_list|(
name|OP_LAST
argument_list|)
expr_stmt|;
name|write_exp_elt_longcst
argument_list|(
operator|(
name|LONGEST
operator|)
name|i
argument_list|)
expr_stmt|;
name|write_exp_elt_opcode
argument_list|(
name|OP_LAST
argument_list|)
expr_stmt|;
return|return;
name|handle_register
label|:
name|write_exp_elt_opcode
argument_list|(
name|OP_REGISTER
argument_list|)
expr_stmt|;
name|write_exp_elt_longcst
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|write_exp_elt_opcode
argument_list|(
name|OP_REGISTER
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Parse a string that is possibly a namespace / nested class    specification, i.e., something of the form A::B::C::x.  Input    (NAME) is the entire string; LEN is the current valid length; the    output is a string, TOKEN, which points to the largest recognized    prefix which is a series of namespaces or classes.  CLASS_PREFIX is    another output, which records whether a nested class spec was    recognized (= 1) or a fully qualified variable name was found (=    0).  ARGPTR is side-effected (if non-NULL) to point to beyond the    string recognized and consumed by this routine.     The return value is a pointer to the symbol for the base class or    variable if found, or NULL if not found.  Callers must check this    first -- if NULL, the outputs may not be correct.      This function is used c-exp.y.  This is used specifically to get    around HP aCC (and possibly other compilers), which insists on    generating names with embedded colons for namespace or nested class    members.     (Argument LEN is currently unused. 1997-08-27)     Callers must free memory allocated for the output string TOKEN.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|coloncolon
index|[
literal|2
index|]
init|=
block|{
literal|':'
block|,
literal|':'
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|struct
name|symbol
modifier|*
name|parse_nested_classes_for_hpacc
parameter_list|(
name|name
parameter_list|,
name|len
parameter_list|,
name|token
parameter_list|,
name|class_prefix
parameter_list|,
name|argptr
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|len
decl_stmt|;
name|char
modifier|*
modifier|*
name|token
decl_stmt|;
name|int
modifier|*
name|class_prefix
decl_stmt|;
name|char
modifier|*
modifier|*
name|argptr
decl_stmt|;
block|{
comment|/* Comment below comes from decode_line_1 which has very similar       code, which is called for "break" command parsing. */
comment|/* We have what looks like a class or namespace      scope specification (A::B), possibly with many      levels of namespaces or classes (A::B::C::D).       Some versions of the HP ANSI C++ compiler (as also possibly      other compilers) generate class/function/member names with      embedded double-colons if they are inside namespaces. To      handle this, we loop a few times, considering larger and      larger prefixes of the string as though they were single      symbols.  So, if the initially supplied string is      A::B::C::D::foo, we have to look up "A", then "A::B",      then "A::B::C", then "A::B::C::D", and finally      "A::B::C::D::foo" as single, monolithic symbols, because      A, B, C or D may be namespaces.       Note that namespaces can nest only inside other      namespaces, and not inside classes.  So we need only      consider *prefixes* of the string; there is no need to look up      "B::C" separately as a symbol in the previous example. */
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|start
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|char
modifier|*
name|prefix
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|tmp
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym_class
init|=
name|NULL
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym_var
init|=
name|NULL
decl_stmt|;
name|struct
name|type
modifier|*
name|t
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|colons_found
init|=
literal|0
decl_stmt|;
name|int
name|prefix_len
init|=
literal|0
decl_stmt|;
name|int
name|done
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|;
comment|/* Check for HP-compiled executable -- in other cases      return NULL, and caller must default to standard GDB      behaviour. */
if|if
condition|(
operator|!
name|hp_som_som_object_present
condition|)
return|return
operator|(
expr|struct
name|symbol
operator|*
operator|)
name|NULL
return|;
name|p
operator|=
name|name
expr_stmt|;
comment|/* Skip over whitespace and possible global "::" */
while|while
condition|(
operator|*
name|p
operator|&&
operator|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
operator|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|':'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
name|p
operator|+=
literal|2
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
operator|)
condition|)
name|p
operator|++
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Get to the end of the next namespace or class spec. */
comment|/* If we're looking at some non-token, fail immediately */
name|start
operator|=
name|p
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|isalpha
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|'$'
operator|||
operator|*
name|p
operator|==
literal|'_'
operator|)
condition|)
return|return
operator|(
expr|struct
name|symbol
operator|*
operator|)
name|NULL
return|;
name|p
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|(
name|isalnum
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|'$'
operator|||
operator|*
name|p
operator|==
literal|'_'
operator|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'<'
condition|)
block|{
comment|/* If we have the start of a template specification,              scan right ahead to its end */
name|q
operator|=
name|find_template_name_end
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
condition|)
name|p
operator|=
name|q
expr_stmt|;
block|}
name|end
operator|=
name|p
expr_stmt|;
comment|/* Skip over "::" and whitespace for next time around */
while|while
condition|(
operator|*
name|p
operator|&&
operator|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
operator|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|':'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
name|p
operator|+=
literal|2
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
operator|)
condition|)
name|p
operator|++
expr_stmt|;
comment|/* Done with tokens? */
if|if
condition|(
operator|!
operator|*
name|p
operator|||
operator|!
operator|(
name|isalpha
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|'$'
operator|||
operator|*
name|p
operator|==
literal|'_'
operator|)
condition|)
name|done
operator|=
literal|1
expr_stmt|;
name|tmp
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|prefix_len
operator|+
name|end
operator|-
name|start
operator|+
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|prefix
condition|)
block|{
name|memcpy
argument_list|(
name|tmp
argument_list|,
name|prefix
argument_list|,
name|prefix_len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|tmp
operator|+
name|prefix_len
argument_list|,
name|coloncolon
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|tmp
operator|+
name|prefix_len
operator|+
literal|2
argument_list|,
name|start
argument_list|,
name|end
operator|-
name|start
argument_list|)
expr_stmt|;
name|tmp
index|[
name|prefix_len
operator|+
literal|2
operator|+
name|end
operator|-
name|start
index|]
operator|=
literal|'\000'
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|tmp
argument_list|,
name|start
argument_list|,
name|end
operator|-
name|start
argument_list|)
expr_stmt|;
name|tmp
index|[
name|end
operator|-
name|start
index|]
operator|=
literal|'\000'
expr_stmt|;
block|}
name|prefix
operator|=
name|tmp
expr_stmt|;
name|prefix_len
operator|=
name|strlen
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* DEBUGGING */
block|printf ("Searching for nested class spec: Prefix is %s\n", prefix);
endif|#
directive|endif
comment|/* See if the prefix we have now is something we know about */
if|if
condition|(
operator|!
name|done
condition|)
block|{
comment|/* More tokens to process, so this must be a class/namespace */
name|sym_class
operator|=
name|lookup_symbol
argument_list|(
name|prefix
argument_list|,
literal|0
argument_list|,
name|STRUCT_NAMESPACE
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|symtab
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* No more tokens, so try as a variable first */
name|sym_var
operator|=
name|lookup_symbol
argument_list|(
name|prefix
argument_list|,
literal|0
argument_list|,
name|VAR_NAMESPACE
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|symtab
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/* If failed, try as class/namespace */
if|if
condition|(
operator|!
name|sym_var
condition|)
name|sym_class
operator|=
name|lookup_symbol
argument_list|(
name|prefix
argument_list|,
literal|0
argument_list|,
name|STRUCT_NAMESPACE
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|symtab
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sym_var
operator|||
operator|(
name|sym_class
operator|&&
operator|(
name|t
operator|=
name|check_typedef
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym_class
argument_list|)
argument_list|)
operator|,
operator|(
name|TYPE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
operator|||
name|TYPE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_CODE_UNION
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* We found a valid token */
operator|*
name|token
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|prefix_len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|*
name|token
argument_list|,
name|prefix
argument_list|,
name|prefix_len
argument_list|)
expr_stmt|;
operator|(
operator|*
name|token
operator|)
index|[
name|prefix_len
index|]
operator|=
literal|'\000'
expr_stmt|;
break|break;
block|}
comment|/* No variable or class/namespace found, no more tokens */
if|if
condition|(
name|done
condition|)
return|return
operator|(
expr|struct
name|symbol
operator|*
operator|)
name|NULL
return|;
block|}
comment|/* Out of loop, so we must have found a valid token */
if|if
condition|(
name|sym_var
condition|)
operator|*
name|class_prefix
operator|=
literal|0
expr_stmt|;
else|else
operator|*
name|class_prefix
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|argptr
condition|)
operator|*
name|argptr
operator|=
name|done
condition|?
name|p
else|:
name|end
expr_stmt|;
if|#
directive|if
literal|0
comment|/* DEBUGGING */
block|printf ("Searching for nested class spec: Token is %s, class_prefix %d\n", *token, *class_prefix);
endif|#
directive|endif
return|return
name|sym_var
condition|?
name|sym_var
else|:
name|sym_class
return|;
comment|/* found */
block|}
end_function

begin_function
name|char
modifier|*
name|find_template_name_end
parameter_list|(
name|p
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|depth
init|=
literal|1
decl_stmt|;
name|int
name|just_seen_right
init|=
literal|0
decl_stmt|;
name|int
name|just_seen_colon
init|=
literal|0
decl_stmt|;
name|int
name|just_seen_space
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|p
operator|||
operator|(
operator|*
name|p
operator|!=
literal|'<'
operator|)
condition|)
return|return
literal|0
return|;
while|while
condition|(
operator|*
operator|++
name|p
condition|)
block|{
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'\''
case|:
case|case
literal|'\"'
case|:
case|case
literal|'{'
case|:
case|case
literal|'}'
case|:
comment|/* In future, may want to allow these?? */
return|return
literal|0
return|;
case|case
literal|'<'
case|:
name|depth
operator|++
expr_stmt|;
comment|/* start nested template */
if|if
condition|(
name|just_seen_colon
operator|||
name|just_seen_right
operator|||
name|just_seen_space
condition|)
return|return
literal|0
return|;
comment|/* but not after : or :: or> or space */
break|break;
case|case
literal|'>'
case|:
if|if
condition|(
name|just_seen_colon
operator|||
name|just_seen_right
condition|)
return|return
literal|0
return|;
comment|/* end a (nested?) template */
name|just_seen_right
operator|=
literal|1
expr_stmt|;
comment|/* but not after : or :: */
if|if
condition|(
operator|--
name|depth
operator|==
literal|0
condition|)
comment|/* also disallow>>, insist on>> */
return|return
operator|++
name|p
return|;
comment|/* if outermost ended, return */
break|break;
case|case
literal|':'
case|:
if|if
condition|(
name|just_seen_space
operator|||
operator|(
name|just_seen_colon
operator|>
literal|1
operator|)
condition|)
return|return
literal|0
return|;
comment|/* nested class spec coming up */
name|just_seen_colon
operator|++
expr_stmt|;
comment|/* we allow :: but not :::: */
break|break;
case|case
literal|' '
case|:
break|break;
default|default:
if|if
condition|(
operator|!
operator|(
operator|(
operator|*
name|p
operator|>=
literal|'a'
operator|&&
operator|*
name|p
operator|<=
literal|'z'
operator|)
operator|||
comment|/* allow token chars */
operator|(
operator|*
name|p
operator|>=
literal|'A'
operator|&&
operator|*
name|p
operator|<=
literal|'Z'
operator|)
operator|||
operator|(
operator|*
name|p
operator|>=
literal|'0'
operator|&&
operator|*
name|p
operator|<=
literal|'9'
operator|)
operator|||
operator|(
operator|*
name|p
operator|==
literal|'_'
operator|)
operator|||
operator|(
operator|*
name|p
operator|==
literal|','
operator|)
operator|||
comment|/* commas for template args */
operator|(
operator|*
name|p
operator|==
literal|'&'
operator|)
operator|||
operator|(
operator|*
name|p
operator|==
literal|'*'
operator|)
operator|||
comment|/* pointer and ref types */
operator|(
operator|*
name|p
operator|==
literal|'('
operator|)
operator|||
operator|(
operator|*
name|p
operator|==
literal|')'
operator|)
operator|||
comment|/* function types */
operator|(
operator|*
name|p
operator|==
literal|'['
operator|)
operator|||
operator|(
operator|*
name|p
operator|==
literal|']'
operator|)
operator|)
condition|)
comment|/* array types */
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|*
name|p
operator|!=
literal|' '
condition|)
name|just_seen_space
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|':'
condition|)
name|just_seen_colon
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'>'
condition|)
name|just_seen_right
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a null-terminated temporary copy of the name    of a string token.  */
end_comment

begin_function
name|char
modifier|*
name|copy_name
parameter_list|(
name|token
parameter_list|)
name|struct
name|stoken
name|token
decl_stmt|;
block|{
name|memcpy
argument_list|(
name|namecopy
argument_list|,
name|token
operator|.
name|ptr
argument_list|,
name|token
operator|.
name|length
argument_list|)
expr_stmt|;
name|namecopy
index|[
name|token
operator|.
name|length
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|namecopy
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Reverse an expression from suffix form (in which it is constructed)    to prefix form (in which we can conveniently print or execute it).  */
end_comment

begin_function
specifier|static
name|void
name|prefixify_expression
parameter_list|(
name|expr
parameter_list|)
specifier|register
name|struct
name|expression
modifier|*
name|expr
decl_stmt|;
block|{
specifier|register
name|int
name|len
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|expression
argument_list|)
operator|+
name|EXP_ELEM_TO_BYTES
argument_list|(
name|expr
operator|->
name|nelts
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|expression
modifier|*
name|temp
decl_stmt|;
specifier|register
name|int
name|inpos
init|=
name|expr
operator|->
name|nelts
decl_stmt|,
name|outpos
init|=
literal|0
decl_stmt|;
name|temp
operator|=
operator|(
expr|struct
name|expression
operator|*
operator|)
name|alloca
argument_list|(
name|len
argument_list|)
expr_stmt|;
comment|/* Copy the original expression into temp.  */
name|memcpy
argument_list|(
name|temp
argument_list|,
name|expr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|prefixify_subexp
argument_list|(
name|temp
argument_list|,
name|expr
argument_list|,
name|inpos
argument_list|,
name|outpos
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the number of exp_elements in the subexpression of EXPR    whose last exp_element is at index ENDPOS - 1 in EXPR.  */
end_comment

begin_function
name|int
name|length_of_subexp
parameter_list|(
name|expr
parameter_list|,
name|endpos
parameter_list|)
specifier|register
name|struct
name|expression
modifier|*
name|expr
decl_stmt|;
specifier|register
name|int
name|endpos
decl_stmt|;
block|{
specifier|register
name|int
name|oplen
init|=
literal|1
decl_stmt|;
specifier|register
name|int
name|args
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|endpos
operator|<
literal|1
condition|)
name|error
argument_list|(
literal|"?error in length_of_subexp"
argument_list|)
expr_stmt|;
name|i
operator|=
operator|(
name|int
operator|)
name|expr
operator|->
name|elts
index|[
name|endpos
operator|-
literal|1
index|]
operator|.
name|opcode
expr_stmt|;
switch|switch
condition|(
name|i
condition|)
block|{
comment|/* C++  */
case|case
name|OP_SCOPE
case|:
name|oplen
operator|=
name|longest_to_int
argument_list|(
name|expr
operator|->
name|elts
index|[
name|endpos
operator|-
literal|2
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
name|oplen
operator|=
literal|5
operator|+
name|BYTES_TO_EXP_ELEM
argument_list|(
name|oplen
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_LONG
case|:
case|case
name|OP_DOUBLE
case|:
case|case
name|OP_VAR_VALUE
case|:
name|oplen
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|OP_TYPE
case|:
case|case
name|OP_BOOL
case|:
case|case
name|OP_LAST
case|:
case|case
name|OP_REGISTER
case|:
case|case
name|OP_INTERNALVAR
case|:
name|oplen
operator|=
literal|3
expr_stmt|;
break|break;
case|case
name|OP_COMPLEX
case|:
name|oplen
operator|=
literal|1
expr_stmt|;
name|args
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|OP_FUNCALL
case|:
case|case
name|OP_F77_UNDETERMINED_ARGLIST
case|:
name|oplen
operator|=
literal|3
expr_stmt|;
name|args
operator|=
literal|1
operator|+
name|longest_to_int
argument_list|(
name|expr
operator|->
name|elts
index|[
name|endpos
operator|-
literal|2
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNOP_MAX
case|:
case|case
name|UNOP_MIN
case|:
name|oplen
operator|=
literal|3
expr_stmt|;
break|break;
case|case
name|BINOP_VAL
case|:
case|case
name|UNOP_CAST
case|:
case|case
name|UNOP_MEMVAL
case|:
name|oplen
operator|=
literal|3
expr_stmt|;
name|args
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|UNOP_ABS
case|:
case|case
name|UNOP_CAP
case|:
case|case
name|UNOP_CHR
case|:
case|case
name|UNOP_FLOAT
case|:
case|case
name|UNOP_HIGH
case|:
case|case
name|UNOP_ODD
case|:
case|case
name|UNOP_ORD
case|:
case|case
name|UNOP_TRUNC
case|:
name|oplen
operator|=
literal|1
expr_stmt|;
name|args
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OP_LABELED
case|:
case|case
name|STRUCTOP_STRUCT
case|:
case|case
name|STRUCTOP_PTR
case|:
name|args
operator|=
literal|1
expr_stmt|;
comment|/* fall through */
case|case
name|OP_M2_STRING
case|:
case|case
name|OP_STRING
case|:
case|case
name|OP_NAME
case|:
case|case
name|OP_EXPRSTRING
case|:
name|oplen
operator|=
name|longest_to_int
argument_list|(
name|expr
operator|->
name|elts
index|[
name|endpos
operator|-
literal|2
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
name|oplen
operator|=
literal|4
operator|+
name|BYTES_TO_EXP_ELEM
argument_list|(
name|oplen
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_BITSTRING
case|:
name|oplen
operator|=
name|longest_to_int
argument_list|(
name|expr
operator|->
name|elts
index|[
name|endpos
operator|-
literal|2
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
name|oplen
operator|=
operator|(
name|oplen
operator|+
name|HOST_CHAR_BIT
operator|-
literal|1
operator|)
operator|/
name|HOST_CHAR_BIT
expr_stmt|;
name|oplen
operator|=
literal|4
operator|+
name|BYTES_TO_EXP_ELEM
argument_list|(
name|oplen
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_ARRAY
case|:
name|oplen
operator|=
literal|4
expr_stmt|;
name|args
operator|=
name|longest_to_int
argument_list|(
name|expr
operator|->
name|elts
index|[
name|endpos
operator|-
literal|2
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
name|args
operator|-=
name|longest_to_int
argument_list|(
name|expr
operator|->
name|elts
index|[
name|endpos
operator|-
literal|3
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
name|args
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|TERNOP_COND
case|:
case|case
name|TERNOP_SLICE
case|:
case|case
name|TERNOP_SLICE_COUNT
case|:
name|args
operator|=
literal|3
expr_stmt|;
break|break;
comment|/* Modula-2 */
case|case
name|MULTI_SUBSCRIPT
case|:
name|oplen
operator|=
literal|3
expr_stmt|;
name|args
operator|=
literal|1
operator|+
name|longest_to_int
argument_list|(
name|expr
operator|->
name|elts
index|[
name|endpos
operator|-
literal|2
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_ASSIGN_MODIFY
case|:
name|oplen
operator|=
literal|3
expr_stmt|;
name|args
operator|=
literal|2
expr_stmt|;
break|break;
comment|/* C++ */
case|case
name|OP_THIS
case|:
name|oplen
operator|=
literal|2
expr_stmt|;
break|break;
default|default:
name|args
operator|=
literal|1
operator|+
operator|(
name|i
operator|<
operator|(
name|int
operator|)
name|BINOP_END
operator|)
expr_stmt|;
block|}
while|while
condition|(
name|args
operator|>
literal|0
condition|)
block|{
name|oplen
operator|+=
name|length_of_subexp
argument_list|(
name|expr
argument_list|,
name|endpos
operator|-
name|oplen
argument_list|)
expr_stmt|;
name|args
operator|--
expr_stmt|;
block|}
return|return
name|oplen
return|;
block|}
end_function

begin_comment
comment|/* Copy the subexpression ending just before index INEND in INEXPR    into OUTEXPR, starting at index OUTBEG.    In the process, convert it from suffix to prefix form.  */
end_comment

begin_function
specifier|static
name|void
name|prefixify_subexp
parameter_list|(
name|inexpr
parameter_list|,
name|outexpr
parameter_list|,
name|inend
parameter_list|,
name|outbeg
parameter_list|)
specifier|register
name|struct
name|expression
modifier|*
name|inexpr
decl_stmt|;
name|struct
name|expression
modifier|*
name|outexpr
decl_stmt|;
specifier|register
name|int
name|inend
decl_stmt|;
name|int
name|outbeg
decl_stmt|;
block|{
specifier|register
name|int
name|oplen
init|=
literal|1
decl_stmt|;
specifier|register
name|int
name|args
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
modifier|*
name|arglens
decl_stmt|;
name|enum
name|exp_opcode
name|opcode
decl_stmt|;
comment|/* Compute how long the last operation is (in OPLEN),      and also how many preceding subexpressions serve as      arguments for it (in ARGS).  */
name|opcode
operator|=
name|inexpr
operator|->
name|elts
index|[
name|inend
operator|-
literal|1
index|]
operator|.
name|opcode
expr_stmt|;
switch|switch
condition|(
name|opcode
condition|)
block|{
comment|/* C++  */
case|case
name|OP_SCOPE
case|:
name|oplen
operator|=
name|longest_to_int
argument_list|(
name|inexpr
operator|->
name|elts
index|[
name|inend
operator|-
literal|2
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
name|oplen
operator|=
literal|5
operator|+
name|BYTES_TO_EXP_ELEM
argument_list|(
name|oplen
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_LONG
case|:
case|case
name|OP_DOUBLE
case|:
case|case
name|OP_VAR_VALUE
case|:
name|oplen
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|OP_TYPE
case|:
case|case
name|OP_BOOL
case|:
case|case
name|OP_LAST
case|:
case|case
name|OP_REGISTER
case|:
case|case
name|OP_INTERNALVAR
case|:
name|oplen
operator|=
literal|3
expr_stmt|;
break|break;
case|case
name|OP_COMPLEX
case|:
name|oplen
operator|=
literal|1
expr_stmt|;
name|args
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|OP_FUNCALL
case|:
case|case
name|OP_F77_UNDETERMINED_ARGLIST
case|:
name|oplen
operator|=
literal|3
expr_stmt|;
name|args
operator|=
literal|1
operator|+
name|longest_to_int
argument_list|(
name|inexpr
operator|->
name|elts
index|[
name|inend
operator|-
literal|2
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNOP_MIN
case|:
case|case
name|UNOP_MAX
case|:
name|oplen
operator|=
literal|3
expr_stmt|;
break|break;
case|case
name|UNOP_CAST
case|:
case|case
name|UNOP_MEMVAL
case|:
name|oplen
operator|=
literal|3
expr_stmt|;
name|args
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|UNOP_ABS
case|:
case|case
name|UNOP_CAP
case|:
case|case
name|UNOP_CHR
case|:
case|case
name|UNOP_FLOAT
case|:
case|case
name|UNOP_HIGH
case|:
case|case
name|UNOP_ODD
case|:
case|case
name|UNOP_ORD
case|:
case|case
name|UNOP_TRUNC
case|:
name|oplen
operator|=
literal|1
expr_stmt|;
name|args
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|STRUCTOP_STRUCT
case|:
case|case
name|STRUCTOP_PTR
case|:
case|case
name|OP_LABELED
case|:
name|args
operator|=
literal|1
expr_stmt|;
comment|/* fall through */
case|case
name|OP_M2_STRING
case|:
case|case
name|OP_STRING
case|:
case|case
name|OP_NAME
case|:
case|case
name|OP_EXPRSTRING
case|:
name|oplen
operator|=
name|longest_to_int
argument_list|(
name|inexpr
operator|->
name|elts
index|[
name|inend
operator|-
literal|2
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
name|oplen
operator|=
literal|4
operator|+
name|BYTES_TO_EXP_ELEM
argument_list|(
name|oplen
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_BITSTRING
case|:
name|oplen
operator|=
name|longest_to_int
argument_list|(
name|inexpr
operator|->
name|elts
index|[
name|inend
operator|-
literal|2
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
name|oplen
operator|=
operator|(
name|oplen
operator|+
name|HOST_CHAR_BIT
operator|-
literal|1
operator|)
operator|/
name|HOST_CHAR_BIT
expr_stmt|;
name|oplen
operator|=
literal|4
operator|+
name|BYTES_TO_EXP_ELEM
argument_list|(
name|oplen
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_ARRAY
case|:
name|oplen
operator|=
literal|4
expr_stmt|;
name|args
operator|=
name|longest_to_int
argument_list|(
name|inexpr
operator|->
name|elts
index|[
name|inend
operator|-
literal|2
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
name|args
operator|-=
name|longest_to_int
argument_list|(
name|inexpr
operator|->
name|elts
index|[
name|inend
operator|-
literal|3
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
name|args
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|TERNOP_COND
case|:
case|case
name|TERNOP_SLICE
case|:
case|case
name|TERNOP_SLICE_COUNT
case|:
name|args
operator|=
literal|3
expr_stmt|;
break|break;
case|case
name|BINOP_ASSIGN_MODIFY
case|:
name|oplen
operator|=
literal|3
expr_stmt|;
name|args
operator|=
literal|2
expr_stmt|;
break|break;
comment|/* Modula-2 */
case|case
name|MULTI_SUBSCRIPT
case|:
name|oplen
operator|=
literal|3
expr_stmt|;
name|args
operator|=
literal|1
operator|+
name|longest_to_int
argument_list|(
name|inexpr
operator|->
name|elts
index|[
name|inend
operator|-
literal|2
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
break|break;
comment|/* C++ */
case|case
name|OP_THIS
case|:
name|oplen
operator|=
literal|2
expr_stmt|;
break|break;
default|default:
name|args
operator|=
literal|1
operator|+
operator|(
operator|(
name|int
operator|)
name|opcode
operator|<
operator|(
name|int
operator|)
name|BINOP_END
operator|)
expr_stmt|;
block|}
comment|/* Copy the final operator itself, from the end of the input      to the beginning of the output.  */
name|inend
operator|-=
name|oplen
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|outexpr
operator|->
name|elts
index|[
name|outbeg
index|]
argument_list|,
operator|&
name|inexpr
operator|->
name|elts
index|[
name|inend
index|]
argument_list|,
name|EXP_ELEM_TO_BYTES
argument_list|(
name|oplen
argument_list|)
argument_list|)
expr_stmt|;
name|outbeg
operator|+=
name|oplen
expr_stmt|;
comment|/* Find the lengths of the arg subexpressions.  */
name|arglens
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|args
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|args
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|oplen
operator|=
name|length_of_subexp
argument_list|(
name|inexpr
argument_list|,
name|inend
argument_list|)
expr_stmt|;
name|arglens
index|[
name|i
index|]
operator|=
name|oplen
expr_stmt|;
name|inend
operator|-=
name|oplen
expr_stmt|;
block|}
comment|/* Now copy each subexpression, preserving the order of      the subexpressions, but prefixifying each one.      In this loop, inend starts at the beginning of      the expression this level is working on      and marches forward over the arguments.      outbeg does similarly in the output.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|args
condition|;
name|i
operator|++
control|)
block|{
name|oplen
operator|=
name|arglens
index|[
name|i
index|]
expr_stmt|;
name|inend
operator|+=
name|oplen
expr_stmt|;
name|prefixify_subexp
argument_list|(
name|inexpr
argument_list|,
name|outexpr
argument_list|,
name|inend
argument_list|,
name|outbeg
argument_list|)
expr_stmt|;
name|outbeg
operator|+=
name|oplen
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This page contains the two entry points to this file.  */
end_comment

begin_comment
comment|/* Read an expression from the string *STRINGPTR points to,    parse it, and return a pointer to a  struct expression  that we malloc.    Use block BLOCK as the lexical context for variable names;    if BLOCK is zero, use the block of the selected stack frame.    Meanwhile, advance *STRINGPTR to point after the expression,    at the first nonwhite character that is not part of the expression    (possibly a null character).     If COMMA is nonzero, stop if a comma is reached.  */
end_comment

begin_function
name|struct
name|expression
modifier|*
name|parse_exp_1
parameter_list|(
name|stringptr
parameter_list|,
name|block
parameter_list|,
name|comma
parameter_list|)
name|char
modifier|*
modifier|*
name|stringptr
decl_stmt|;
name|struct
name|block
modifier|*
name|block
decl_stmt|;
name|int
name|comma
decl_stmt|;
block|{
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|lexptr
operator|=
operator|*
name|stringptr
expr_stmt|;
name|paren_depth
operator|=
literal|0
expr_stmt|;
name|type_stack_depth
operator|=
literal|0
expr_stmt|;
name|comma_terminates
operator|=
name|comma
expr_stmt|;
if|if
condition|(
name|lexptr
operator|==
literal|0
operator|||
operator|*
name|lexptr
operator|==
literal|0
condition|)
name|error_no_arg
argument_list|(
literal|"expression to compute"
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
operator|(
name|make_cleanup_func
operator|)
name|free_funcalls
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|funcall_chain
operator|=
literal|0
expr_stmt|;
name|expression_context_block
operator|=
name|block
condition|?
name|block
else|:
name|get_selected_block
argument_list|()
expr_stmt|;
name|namecopy
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|lexptr
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|expout_size
operator|=
literal|10
expr_stmt|;
name|expout_ptr
operator|=
literal|0
expr_stmt|;
name|expout
operator|=
operator|(
expr|struct
name|expression
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|expression
argument_list|)
operator|+
name|EXP_ELEM_TO_BYTES
argument_list|(
name|expout_size
argument_list|)
argument_list|)
expr_stmt|;
name|expout
operator|->
name|language_defn
operator|=
name|current_language
expr_stmt|;
name|make_cleanup
argument_list|(
operator|(
name|make_cleanup_func
operator|)
name|free_current_contents
argument_list|,
operator|&
name|expout
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_language
operator|->
name|la_parser
argument_list|()
condition|)
name|current_language
operator|->
name|la_error
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|discard_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
comment|/* Record the actual number of expression elements, and then      reallocate the expression memory so that we free up any      excess elements. */
name|expout
operator|->
name|nelts
operator|=
name|expout_ptr
expr_stmt|;
name|expout
operator|=
operator|(
expr|struct
name|expression
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|expout
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|expression
argument_list|)
operator|+
name|EXP_ELEM_TO_BYTES
argument_list|(
name|expout_ptr
argument_list|)
argument_list|)
expr_stmt|;
empty_stmt|;
comment|/* Convert expression from postfix form as generated by yacc      parser, to a prefix form. */
ifdef|#
directive|ifdef
name|MAINTENANCE_CMDS
if|if
condition|(
name|expressiondebug
condition|)
name|dump_prefix_expression
argument_list|(
name|expout
argument_list|,
name|gdb_stdout
argument_list|,
literal|"before conversion to prefix form"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MAINTENANCE_CMDS */
name|prefixify_expression
argument_list|(
name|expout
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MAINTENANCE_CMDS
if|if
condition|(
name|expressiondebug
condition|)
name|dump_postfix_expression
argument_list|(
name|expout
argument_list|,
name|gdb_stdout
argument_list|,
literal|"after conversion to prefix form"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MAINTENANCE_CMDS */
operator|*
name|stringptr
operator|=
name|lexptr
expr_stmt|;
return|return
name|expout
return|;
block|}
end_function

begin_comment
comment|/* Parse STRING as an expression, and complain if this fails    to use up all of the contents of STRING.  */
end_comment

begin_function
name|struct
name|expression
modifier|*
name|parse_expression
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
specifier|register
name|struct
name|expression
modifier|*
name|exp
decl_stmt|;
name|exp
operator|=
name|parse_exp_1
argument_list|(
operator|&
name|string
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|string
condition|)
name|error
argument_list|(
literal|"Junk after end of expression."
argument_list|)
expr_stmt|;
return|return
name|exp
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Stuff for maintaining a stack of types.  Currently just used by C, but    probably useful for any language which declares its types "backwards".  */
end_comment

begin_function
name|void
name|push_type
parameter_list|(
name|tp
parameter_list|)
name|enum
name|type_pieces
name|tp
decl_stmt|;
block|{
if|if
condition|(
name|type_stack_depth
operator|==
name|type_stack_size
condition|)
block|{
name|type_stack_size
operator|*=
literal|2
expr_stmt|;
name|type_stack
operator|=
operator|(
expr|union
name|type_stack_elt
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|type_stack
argument_list|,
name|type_stack_size
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|type_stack
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|type_stack
index|[
name|type_stack_depth
operator|++
index|]
operator|.
name|piece
operator|=
name|tp
expr_stmt|;
block|}
end_function

begin_function
name|void
name|push_type_int
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
if|if
condition|(
name|type_stack_depth
operator|==
name|type_stack_size
condition|)
block|{
name|type_stack_size
operator|*=
literal|2
expr_stmt|;
name|type_stack
operator|=
operator|(
expr|union
name|type_stack_elt
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|type_stack
argument_list|,
name|type_stack_size
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|type_stack
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|type_stack
index|[
name|type_stack_depth
operator|++
index|]
operator|.
name|int_val
operator|=
name|n
expr_stmt|;
block|}
end_function

begin_function
name|enum
name|type_pieces
name|pop_type
parameter_list|()
block|{
if|if
condition|(
name|type_stack_depth
condition|)
return|return
name|type_stack
index|[
operator|--
name|type_stack_depth
index|]
operator|.
name|piece
return|;
return|return
name|tp_end
return|;
block|}
end_function

begin_function
name|int
name|pop_type_int
parameter_list|()
block|{
if|if
condition|(
name|type_stack_depth
condition|)
return|return
name|type_stack
index|[
operator|--
name|type_stack_depth
index|]
operator|.
name|int_val
return|;
comment|/* "Can't happen".  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Pop the type stack and return the type which corresponds to FOLLOW_TYPE    as modified by all the stuff on the stack.  */
end_comment

begin_function
name|struct
name|type
modifier|*
name|follow_types
parameter_list|(
name|follow_type
parameter_list|)
name|struct
name|type
modifier|*
name|follow_type
decl_stmt|;
block|{
name|int
name|done
init|=
literal|0
decl_stmt|;
name|int
name|array_size
decl_stmt|;
name|struct
name|type
modifier|*
name|range_type
decl_stmt|;
while|while
condition|(
operator|!
name|done
condition|)
switch|switch
condition|(
name|pop_type
argument_list|()
condition|)
block|{
case|case
name|tp_end
case|:
name|done
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|tp_pointer
case|:
name|follow_type
operator|=
name|lookup_pointer_type
argument_list|(
name|follow_type
argument_list|)
expr_stmt|;
break|break;
case|case
name|tp_reference
case|:
name|follow_type
operator|=
name|lookup_reference_type
argument_list|(
name|follow_type
argument_list|)
expr_stmt|;
break|break;
case|case
name|tp_array
case|:
name|array_size
operator|=
name|pop_type_int
argument_list|()
expr_stmt|;
comment|/* FIXME-type-allocation: need a way to free this type when we are 	   done with it.  */
name|range_type
operator|=
name|create_range_type
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|)
name|NULL
argument_list|,
name|builtin_type_int
argument_list|,
literal|0
argument_list|,
name|array_size
operator|>=
literal|0
condition|?
name|array_size
operator|-
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
name|follow_type
operator|=
name|create_array_type
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|)
name|NULL
argument_list|,
name|follow_type
argument_list|,
name|range_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|array_size
operator|<
literal|0
condition|)
name|TYPE_ARRAY_UPPER_BOUND_TYPE
argument_list|(
name|follow_type
argument_list|)
operator|=
name|BOUND_CANNOT_BE_DETERMINED
expr_stmt|;
break|break;
case|case
name|tp_function
case|:
comment|/* FIXME-type-allocation: need a way to free this type when we are 	   done with it.  */
name|follow_type
operator|=
name|lookup_function_type
argument_list|(
name|follow_type
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|follow_type
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|_initialize_parse
parameter_list|()
block|{
name|type_stack_size
operator|=
literal|80
expr_stmt|;
name|type_stack_depth
operator|=
literal|0
expr_stmt|;
name|type_stack
operator|=
operator|(
expr|union
name|type_stack_elt
operator|*
operator|)
name|xmalloc
argument_list|(
name|type_stack_size
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|type_stack
argument_list|)
argument_list|)
expr_stmt|;
name|msym_text_symbol_type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FUNC
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"<text variable, no debug info>"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|TYPE_TARGET_TYPE
argument_list|(
name|msym_text_symbol_type
argument_list|)
operator|=
name|builtin_type_int
expr_stmt|;
name|msym_data_symbol_type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_INT_BIT
operator|/
name|HOST_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"<data variable, no debug info>"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|msym_unknown_symbol_type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"<variable (not text or data), no debug info>"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MAINTENANCE_CMDS
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"expressiondebug"
argument_list|,
name|class_maintenance
argument_list|,
name|var_zinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|expressiondebug
argument_list|,
literal|"Set expression debugging.\n\ When non-zero, the internal representation of expressions will be printed."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

end_unit

