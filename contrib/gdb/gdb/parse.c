begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Parse expressions for GDB.    Copyright 1986, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997,    1998, 1999, 2000, 2001 Free Software Foundation, Inc.    Modified from expread.y by the Department of Computer Science at the    State University of New York at Buffalo, 1991.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* Parse an expression from text in a string,    and return the result as a  struct expression  pointer.    That structure contains arithmetic operations in reverse polish,    with constants represented by operations that are followed by special data.    See expression.h for the details of the format.    What is important here is that it can be built up sequentially    during the process of parsing; the lower levels of the tree always    come first in the result.  */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"parser-defs.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_comment
comment|/* for overlay functions */
end_comment

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_comment
comment|/* for NUM_PSEUDO_REGS.  NOTE: replace  				   with "gdbarch.h" when appropriate.  */
end_comment

begin_include
include|#
directive|include
file|"doublest.h"
end_include

begin_include
include|#
directive|include
file|"gdb_assert.h"
end_include

begin_include
include|#
directive|include
file|"block.h"
end_include

begin_comment
comment|/* Standard set of definitions for printing, dumping, prefixifying,  * and evaluating expressions.  */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|exp_descriptor
name|exp_descriptor_standard
init|=
block|{
name|print_subexp_standard
block|,
name|operator_length_standard
block|,
name|op_name_standard
block|,
name|dump_subexp_body_standard
block|,
name|evaluate_subexp_standard
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Symbols which architectures can redefine.  */
end_comment

begin_comment
comment|/* Some systems have routines whose names start with `$'.  Giving this    macro a non-zero value tells GDB's expression parser to check for    such routines when parsing tokens that begin with `$'.     On HP-UX, certain system routines (millicode) have names beginning    with `$' or `$$'.  For example, `$$dyncall' is a millicode routine    that handles inter-space procedure calls on PA-RISC.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SYMBOLS_CAN_START_WITH_DOLLAR
end_ifndef

begin_define
define|#
directive|define
name|SYMBOLS_CAN_START_WITH_DOLLAR
value|(0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Global variables declared in parser-defs.h (and commented there).  */
end_comment

begin_decl_stmt
name|struct
name|expression
modifier|*
name|expout
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|expout_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|expout_ptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|block
modifier|*
name|expression_context_block
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|CORE_ADDR
name|expression_context_pc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|block
modifier|*
name|innermost_block
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|arglist_len
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|union
name|type_stack_elt
modifier|*
name|type_stack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|type_stack_depth
decl_stmt|,
name|type_stack_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|lexptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|prev_lexptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|namecopy
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|paren_depth
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|comma_terminates
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|int
name|expressiondebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|hp_som_som_object_present
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|free_funcalls
parameter_list|(
name|void
modifier|*
name|ignore
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|prefixify_expression
parameter_list|(
name|struct
name|expression
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|prefixify_subexp
parameter_list|(
name|struct
name|expression
modifier|*
parameter_list|,
name|struct
name|expression
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|_initialize_parse
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Data structure for saving values of arglist_len for function calls whose    arguments contain other function calls.  */
end_comment

begin_struct
struct|struct
name|funcall
block|{
name|struct
name|funcall
modifier|*
name|next
decl_stmt|;
name|int
name|arglist_len
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|funcall
modifier|*
name|funcall_chain
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Begin counting arguments for a function call,    saving the data about any containing call.  */
end_comment

begin_function
name|void
name|start_arglist
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|funcall
modifier|*
name|new
decl_stmt|;
name|new
operator|=
operator|(
expr|struct
name|funcall
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|funcall
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|funcall_chain
expr_stmt|;
name|new
operator|->
name|arglist_len
operator|=
name|arglist_len
expr_stmt|;
name|arglist_len
operator|=
literal|0
expr_stmt|;
name|funcall_chain
operator|=
name|new
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the number of arguments in a function call just terminated,    and restore the data for the containing function call.  */
end_comment

begin_function
name|int
name|end_arglist
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|val
init|=
name|arglist_len
decl_stmt|;
name|struct
name|funcall
modifier|*
name|call
init|=
name|funcall_chain
decl_stmt|;
name|funcall_chain
operator|=
name|call
operator|->
name|next
expr_stmt|;
name|arglist_len
operator|=
name|call
operator|->
name|arglist_len
expr_stmt|;
name|xfree
argument_list|(
name|call
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Free everything in the funcall chain.    Used when there is an error inside parsing.  */
end_comment

begin_function
specifier|static
name|void
name|free_funcalls
parameter_list|(
name|void
modifier|*
name|ignore
parameter_list|)
block|{
name|struct
name|funcall
modifier|*
name|call
decl_stmt|,
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|call
operator|=
name|funcall_chain
init|;
name|call
condition|;
name|call
operator|=
name|next
control|)
block|{
name|next
operator|=
name|call
operator|->
name|next
expr_stmt|;
name|xfree
argument_list|(
name|call
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This page contains the functions for adding data to the  struct expression    being constructed.  */
end_comment

begin_comment
comment|/* Add one element to the end of the expression.  */
end_comment

begin_comment
comment|/* To avoid a bug in the Sun 4 compiler, we pass things that can fit into    a register through here */
end_comment

begin_function
name|void
name|write_exp_elt
parameter_list|(
name|union
name|exp_element
name|expelt
parameter_list|)
block|{
if|if
condition|(
name|expout_ptr
operator|>=
name|expout_size
condition|)
block|{
name|expout_size
operator|*=
literal|2
expr_stmt|;
name|expout
operator|=
operator|(
expr|struct
name|expression
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|expout
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|expression
argument_list|)
operator|+
name|EXP_ELEM_TO_BYTES
argument_list|(
name|expout_size
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|expout
operator|->
name|elts
index|[
name|expout_ptr
operator|++
index|]
operator|=
name|expelt
expr_stmt|;
block|}
end_function

begin_function
name|void
name|write_exp_elt_opcode
parameter_list|(
name|enum
name|exp_opcode
name|expelt
parameter_list|)
block|{
name|union
name|exp_element
name|tmp
decl_stmt|;
name|tmp
operator|.
name|opcode
operator|=
name|expelt
expr_stmt|;
name|write_exp_elt
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|write_exp_elt_sym
parameter_list|(
name|struct
name|symbol
modifier|*
name|expelt
parameter_list|)
block|{
name|union
name|exp_element
name|tmp
decl_stmt|;
name|tmp
operator|.
name|symbol
operator|=
name|expelt
expr_stmt|;
name|write_exp_elt
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|write_exp_elt_block
parameter_list|(
name|struct
name|block
modifier|*
name|b
parameter_list|)
block|{
name|union
name|exp_element
name|tmp
decl_stmt|;
name|tmp
operator|.
name|block
operator|=
name|b
expr_stmt|;
name|write_exp_elt
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|write_exp_elt_longcst
parameter_list|(
name|LONGEST
name|expelt
parameter_list|)
block|{
name|union
name|exp_element
name|tmp
decl_stmt|;
name|tmp
operator|.
name|longconst
operator|=
name|expelt
expr_stmt|;
name|write_exp_elt
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|write_exp_elt_dblcst
parameter_list|(
name|DOUBLEST
name|expelt
parameter_list|)
block|{
name|union
name|exp_element
name|tmp
decl_stmt|;
name|tmp
operator|.
name|doubleconst
operator|=
name|expelt
expr_stmt|;
name|write_exp_elt
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|write_exp_elt_type
parameter_list|(
name|struct
name|type
modifier|*
name|expelt
parameter_list|)
block|{
name|union
name|exp_element
name|tmp
decl_stmt|;
name|tmp
operator|.
name|type
operator|=
name|expelt
expr_stmt|;
name|write_exp_elt
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|write_exp_elt_intern
parameter_list|(
name|struct
name|internalvar
modifier|*
name|expelt
parameter_list|)
block|{
name|union
name|exp_element
name|tmp
decl_stmt|;
name|tmp
operator|.
name|internalvar
operator|=
name|expelt
expr_stmt|;
name|write_exp_elt
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a string constant to the end of the expression.     String constants are stored by first writing an expression element    that contains the length of the string, then stuffing the string    constant itself into however many expression elements are needed    to hold it, and then writing another expression element that contains    the length of the string.  I.E. an expression element at each end of    the string records the string length, so you can skip over the     expression elements containing the actual string bytes from either    end of the string.  Note that this also allows gdb to handle    strings with embedded null bytes, as is required for some languages.     Don't be fooled by the fact that the string is null byte terminated,    this is strictly for the convenience of debugging gdb itself.  Gdb    Gdb does not depend up the string being null terminated, since the    actual length is recorded in expression elements at each end of the    string.  The null byte is taken into consideration when computing how    many expression elements are required to hold the string constant, of    course. */
end_comment

begin_function
name|void
name|write_exp_string
parameter_list|(
name|struct
name|stoken
name|str
parameter_list|)
block|{
name|int
name|len
init|=
name|str
operator|.
name|length
decl_stmt|;
name|int
name|lenelt
decl_stmt|;
name|char
modifier|*
name|strdata
decl_stmt|;
comment|/* Compute the number of expression elements required to hold the string      (including a null byte terminator), along with one expression element      at each end to record the actual string length (not including the      null byte terminator). */
name|lenelt
operator|=
literal|2
operator|+
name|BYTES_TO_EXP_ELEM
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Ensure that we have enough available expression elements to store      everything. */
if|if
condition|(
operator|(
name|expout_ptr
operator|+
name|lenelt
operator|)
operator|>=
name|expout_size
condition|)
block|{
name|expout_size
operator|=
name|max
argument_list|(
name|expout_size
operator|*
literal|2
argument_list|,
name|expout_ptr
operator|+
name|lenelt
operator|+
literal|10
argument_list|)
expr_stmt|;
name|expout
operator|=
operator|(
expr|struct
name|expression
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|expout
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|expression
argument_list|)
operator|+
name|EXP_ELEM_TO_BYTES
argument_list|(
name|expout_size
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Write the leading length expression element (which advances the current      expression element index), then write the string constant followed by a      terminating null byte, and then write the trailing length expression      element. */
name|write_exp_elt_longcst
argument_list|(
operator|(
name|LONGEST
operator|)
name|len
argument_list|)
expr_stmt|;
name|strdata
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|expout
operator|->
name|elts
index|[
name|expout_ptr
index|]
expr_stmt|;
name|memcpy
argument_list|(
name|strdata
argument_list|,
name|str
operator|.
name|ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|*
operator|(
name|strdata
operator|+
name|len
operator|)
operator|=
literal|'\0'
expr_stmt|;
name|expout_ptr
operator|+=
name|lenelt
operator|-
literal|2
expr_stmt|;
name|write_exp_elt_longcst
argument_list|(
operator|(
name|LONGEST
operator|)
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a bitstring constant to the end of the expression.     Bitstring constants are stored by first writing an expression element    that contains the length of the bitstring (in bits), then stuffing the    bitstring constant itself into however many expression elements are    needed to hold it, and then writing another expression element that    contains the length of the bitstring.  I.E. an expression element at    each end of the bitstring records the bitstring length, so you can skip    over the expression elements containing the actual bitstring bytes from    either end of the bitstring. */
end_comment

begin_function
name|void
name|write_exp_bitstring
parameter_list|(
name|struct
name|stoken
name|str
parameter_list|)
block|{
name|int
name|bits
init|=
name|str
operator|.
name|length
decl_stmt|;
comment|/* length in bits */
name|int
name|len
init|=
operator|(
name|bits
operator|+
name|HOST_CHAR_BIT
operator|-
literal|1
operator|)
operator|/
name|HOST_CHAR_BIT
decl_stmt|;
name|int
name|lenelt
decl_stmt|;
name|char
modifier|*
name|strdata
decl_stmt|;
comment|/* Compute the number of expression elements required to hold the bitstring,      along with one expression element at each end to record the actual      bitstring length in bits. */
name|lenelt
operator|=
literal|2
operator|+
name|BYTES_TO_EXP_ELEM
argument_list|(
name|len
argument_list|)
expr_stmt|;
comment|/* Ensure that we have enough available expression elements to store      everything. */
if|if
condition|(
operator|(
name|expout_ptr
operator|+
name|lenelt
operator|)
operator|>=
name|expout_size
condition|)
block|{
name|expout_size
operator|=
name|max
argument_list|(
name|expout_size
operator|*
literal|2
argument_list|,
name|expout_ptr
operator|+
name|lenelt
operator|+
literal|10
argument_list|)
expr_stmt|;
name|expout
operator|=
operator|(
expr|struct
name|expression
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|expout
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|expression
argument_list|)
operator|+
name|EXP_ELEM_TO_BYTES
argument_list|(
name|expout_size
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Write the leading length expression element (which advances the current      expression element index), then write the bitstring constant, and then      write the trailing length expression element. */
name|write_exp_elt_longcst
argument_list|(
operator|(
name|LONGEST
operator|)
name|bits
argument_list|)
expr_stmt|;
name|strdata
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|expout
operator|->
name|elts
index|[
name|expout_ptr
index|]
expr_stmt|;
name|memcpy
argument_list|(
name|strdata
argument_list|,
name|str
operator|.
name|ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|expout_ptr
operator|+=
name|lenelt
operator|-
literal|2
expr_stmt|;
name|write_exp_elt_longcst
argument_list|(
operator|(
name|LONGEST
operator|)
name|bits
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add the appropriate elements for a minimal symbol to the end of    the expression.  The rationale behind passing in text_symbol_type and    data_symbol_type was so that Modula-2 could pass in WORD for    data_symbol_type.  Perhaps it still is useful to have those types vary    based on the language, but they no longer have names like "int", so    the initial rationale is gone.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|msym_text_symbol_type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|msym_data_symbol_type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|msym_unknown_symbol_type
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|write_exp_msymbol
parameter_list|(
name|struct
name|minimal_symbol
modifier|*
name|msymbol
parameter_list|,
name|struct
name|type
modifier|*
name|text_symbol_type
parameter_list|,
name|struct
name|type
modifier|*
name|data_symbol_type
parameter_list|)
block|{
name|CORE_ADDR
name|addr
decl_stmt|;
name|write_exp_elt_opcode
argument_list|(
name|OP_LONG
argument_list|)
expr_stmt|;
comment|/* Let's make the type big enough to hold a 64-bit address.  */
name|write_exp_elt_type
argument_list|(
name|builtin_type_CORE_ADDR
argument_list|)
expr_stmt|;
name|addr
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|overlay_debugging
condition|)
name|addr
operator|=
name|symbol_overlayed_address
argument_list|(
name|addr
argument_list|,
name|SYMBOL_BFD_SECTION
argument_list|(
name|msymbol
argument_list|)
argument_list|)
expr_stmt|;
name|write_exp_elt_longcst
argument_list|(
operator|(
name|LONGEST
operator|)
name|addr
argument_list|)
expr_stmt|;
name|write_exp_elt_opcode
argument_list|(
name|OP_LONG
argument_list|)
expr_stmt|;
name|write_exp_elt_opcode
argument_list|(
name|UNOP_MEMVAL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|msymbol
operator|->
name|type
condition|)
block|{
case|case
name|mst_text
case|:
case|case
name|mst_file_text
case|:
case|case
name|mst_solib_trampoline
case|:
name|write_exp_elt_type
argument_list|(
name|msym_text_symbol_type
argument_list|)
expr_stmt|;
break|break;
case|case
name|mst_data
case|:
case|case
name|mst_file_data
case|:
case|case
name|mst_bss
case|:
case|case
name|mst_file_bss
case|:
name|write_exp_elt_type
argument_list|(
name|msym_data_symbol_type
argument_list|)
expr_stmt|;
break|break;
default|default:
name|write_exp_elt_type
argument_list|(
name|msym_unknown_symbol_type
argument_list|)
expr_stmt|;
break|break;
block|}
name|write_exp_elt_opcode
argument_list|(
name|UNOP_MEMVAL
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Recognize tokens that start with '$'.  These include:     $regname     A native register name or a "standard    register name".     $variable    A convenience variable with a name chosen    by the user.     $digits              Value history with index<digits>, starting    from the first value which has index 1.     $$digits     Value history with index<digits> relative    to the last value.  I.E. $$0 is the last    value, $$1 is the one previous to that, $$2    is the one previous to $$1, etc.     $ | $0 | $$0 The last value in the value history.     $$           An abbreviation for the second to the last    value in the value history, I.E. $$1   */
end_comment

begin_function
name|void
name|write_dollar_variable
parameter_list|(
name|struct
name|stoken
name|str
parameter_list|)
block|{
comment|/* Handle the tokens $digits; also $ (short for $0) and $$ (short for $$1)      and $$digits (equivalent to $<-digits> if you could type that). */
name|int
name|negate
init|=
literal|0
decl_stmt|;
name|int
name|i
init|=
literal|1
decl_stmt|;
comment|/* Double dollar means negate the number and add -1 as well.      Thus $$ alone means -1.  */
if|if
condition|(
name|str
operator|.
name|length
operator|>=
literal|2
operator|&&
name|str
operator|.
name|ptr
index|[
literal|1
index|]
operator|==
literal|'$'
condition|)
block|{
name|negate
operator|=
literal|1
expr_stmt|;
name|i
operator|=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|str
operator|.
name|length
condition|)
block|{
comment|/* Just dollars (one or two) */
name|i
operator|=
operator|-
name|negate
expr_stmt|;
goto|goto
name|handle_last
goto|;
block|}
comment|/* Is the rest of the token digits?  */
for|for
control|(
init|;
name|i
operator|<
name|str
operator|.
name|length
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
operator|(
name|str
operator|.
name|ptr
index|[
name|i
index|]
operator|>=
literal|'0'
operator|&&
name|str
operator|.
name|ptr
index|[
name|i
index|]
operator|<=
literal|'9'
operator|)
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|str
operator|.
name|length
condition|)
block|{
name|i
operator|=
name|atoi
argument_list|(
name|str
operator|.
name|ptr
operator|+
literal|1
operator|+
name|negate
argument_list|)
expr_stmt|;
if|if
condition|(
name|negate
condition|)
name|i
operator|=
operator|-
name|i
expr_stmt|;
goto|goto
name|handle_last
goto|;
block|}
comment|/* Handle tokens that refer to machine registers:      $ followed by a register name.  */
name|i
operator|=
name|frame_map_name_to_regnum
argument_list|(
name|deprecated_selected_frame
argument_list|,
name|str
operator|.
name|ptr
operator|+
literal|1
argument_list|,
name|str
operator|.
name|length
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
goto|goto
name|handle_register
goto|;
if|if
condition|(
name|SYMBOLS_CAN_START_WITH_DOLLAR
condition|)
block|{
name|struct
name|symbol
modifier|*
name|sym
init|=
name|NULL
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|msym
init|=
name|NULL
decl_stmt|;
comment|/* On HP-UX, certain system routines (millicode) have names beginning 	 with $ or $$, e.g. $$dyncall, which handles inter-space procedure 	 calls on PA-RISC. Check for those, first. */
comment|/* This code is not enabled on non HP-UX systems, since worst case  	 symbol table lookup performance is awful, to put it mildly. */
name|sym
operator|=
name|lookup_symbol
argument_list|(
name|copy_name
argument_list|(
name|str
argument_list|)
argument_list|,
operator|(
expr|struct
name|block
operator|*
operator|)
name|NULL
argument_list|,
name|VAR_DOMAIN
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
operator|(
expr|struct
name|symtab
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
condition|)
block|{
name|write_exp_elt_opcode
argument_list|(
name|OP_VAR_VALUE
argument_list|)
expr_stmt|;
name|write_exp_elt_block
argument_list|(
name|block_found
argument_list|)
expr_stmt|;
comment|/* set by lookup_symbol */
name|write_exp_elt_sym
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|write_exp_elt_opcode
argument_list|(
name|OP_VAR_VALUE
argument_list|)
expr_stmt|;
return|return;
block|}
name|msym
operator|=
name|lookup_minimal_symbol
argument_list|(
name|copy_name
argument_list|(
name|str
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|msym
condition|)
block|{
name|write_exp_msymbol
argument_list|(
name|msym
argument_list|,
name|lookup_function_type
argument_list|(
name|builtin_type_int
argument_list|)
argument_list|,
name|builtin_type_int
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Any other names starting in $ are debugger internal variables.  */
name|write_exp_elt_opcode
argument_list|(
name|OP_INTERNALVAR
argument_list|)
expr_stmt|;
name|write_exp_elt_intern
argument_list|(
name|lookup_internalvar
argument_list|(
name|copy_name
argument_list|(
name|str
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|write_exp_elt_opcode
argument_list|(
name|OP_INTERNALVAR
argument_list|)
expr_stmt|;
return|return;
name|handle_last
label|:
name|write_exp_elt_opcode
argument_list|(
name|OP_LAST
argument_list|)
expr_stmt|;
name|write_exp_elt_longcst
argument_list|(
operator|(
name|LONGEST
operator|)
name|i
argument_list|)
expr_stmt|;
name|write_exp_elt_opcode
argument_list|(
name|OP_LAST
argument_list|)
expr_stmt|;
return|return;
name|handle_register
label|:
name|write_exp_elt_opcode
argument_list|(
name|OP_REGISTER
argument_list|)
expr_stmt|;
name|write_exp_elt_longcst
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|write_exp_elt_opcode
argument_list|(
name|OP_REGISTER
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Parse a string that is possibly a namespace / nested class    specification, i.e., something of the form A::B::C::x.  Input    (NAME) is the entire string; LEN is the current valid length; the    output is a string, TOKEN, which points to the largest recognized    prefix which is a series of namespaces or classes.  CLASS_PREFIX is    another output, which records whether a nested class spec was    recognized (= 1) or a fully qualified variable name was found (=    0).  ARGPTR is side-effected (if non-NULL) to point to beyond the    string recognized and consumed by this routine.     The return value is a pointer to the symbol for the base class or    variable if found, or NULL if not found.  Callers must check this    first -- if NULL, the outputs may not be correct.      This function is used c-exp.y.  This is used specifically to get    around HP aCC (and possibly other compilers), which insists on    generating names with embedded colons for namespace or nested class    members.     (Argument LEN is currently unused. 1997-08-27)     Callers must free memory allocated for the output string TOKEN.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|coloncolon
index|[
literal|2
index|]
init|=
block|{
literal|':'
block|,
literal|':'
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|struct
name|symbol
modifier|*
name|parse_nested_classes_for_hpacc
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|len
parameter_list|,
name|char
modifier|*
modifier|*
name|token
parameter_list|,
name|int
modifier|*
name|class_prefix
parameter_list|,
name|char
modifier|*
modifier|*
name|argptr
parameter_list|)
block|{
comment|/* Comment below comes from decode_line_1 which has very similar      code, which is called for "break" command parsing. */
comment|/* We have what looks like a class or namespace      scope specification (A::B), possibly with many      levels of namespaces or classes (A::B::C::D).       Some versions of the HP ANSI C++ compiler (as also possibly      other compilers) generate class/function/member names with      embedded double-colons if they are inside namespaces. To      handle this, we loop a few times, considering larger and      larger prefixes of the string as though they were single      symbols.  So, if the initially supplied string is      A::B::C::D::foo, we have to look up "A", then "A::B",      then "A::B::C", then "A::B::C::D", and finally      "A::B::C::D::foo" as single, monolithic symbols, because      A, B, C or D may be namespaces.       Note that namespaces can nest only inside other      namespaces, and not inside classes.  So we need only      consider *prefixes* of the string; there is no need to look up      "B::C" separately as a symbol in the previous example. */
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|start
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|char
modifier|*
name|prefix
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|tmp
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym_class
init|=
name|NULL
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym_var
init|=
name|NULL
decl_stmt|;
name|struct
name|type
modifier|*
name|t
decl_stmt|;
name|int
name|prefix_len
init|=
literal|0
decl_stmt|;
name|int
name|done
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|;
comment|/* Check for HP-compiled executable -- in other cases      return NULL, and caller must default to standard GDB      behaviour. */
if|if
condition|(
operator|!
name|hp_som_som_object_present
condition|)
return|return
operator|(
expr|struct
name|symbol
operator|*
operator|)
name|NULL
return|;
name|p
operator|=
name|name
expr_stmt|;
comment|/* Skip over whitespace and possible global "::" */
while|while
condition|(
operator|*
name|p
operator|&&
operator|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
operator|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|':'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
name|p
operator|+=
literal|2
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
operator|)
condition|)
name|p
operator|++
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Get to the end of the next namespace or class spec. */
comment|/* If we're looking at some non-token, fail immediately */
name|start
operator|=
name|p
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|isalpha
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|'$'
operator|||
operator|*
name|p
operator|==
literal|'_'
operator|)
condition|)
return|return
operator|(
expr|struct
name|symbol
operator|*
operator|)
name|NULL
return|;
name|p
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|(
name|isalnum
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|'$'
operator|||
operator|*
name|p
operator|==
literal|'_'
operator|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'<'
condition|)
block|{
comment|/* If we have the start of a template specification, 	     scan right ahead to its end */
name|q
operator|=
name|find_template_name_end
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
condition|)
name|p
operator|=
name|q
expr_stmt|;
block|}
name|end
operator|=
name|p
expr_stmt|;
comment|/* Skip over "::" and whitespace for next time around */
while|while
condition|(
operator|*
name|p
operator|&&
operator|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
operator|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|':'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
name|p
operator|+=
literal|2
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
operator|)
condition|)
name|p
operator|++
expr_stmt|;
comment|/* Done with tokens? */
if|if
condition|(
operator|!
operator|*
name|p
operator|||
operator|!
operator|(
name|isalpha
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|'$'
operator|||
operator|*
name|p
operator|==
literal|'_'
operator|)
condition|)
name|done
operator|=
literal|1
expr_stmt|;
name|tmp
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|prefix_len
operator|+
name|end
operator|-
name|start
operator|+
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|prefix
condition|)
block|{
name|memcpy
argument_list|(
name|tmp
argument_list|,
name|prefix
argument_list|,
name|prefix_len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|tmp
operator|+
name|prefix_len
argument_list|,
name|coloncolon
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|tmp
operator|+
name|prefix_len
operator|+
literal|2
argument_list|,
name|start
argument_list|,
name|end
operator|-
name|start
argument_list|)
expr_stmt|;
name|tmp
index|[
name|prefix_len
operator|+
literal|2
operator|+
name|end
operator|-
name|start
index|]
operator|=
literal|'\000'
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|tmp
argument_list|,
name|start
argument_list|,
name|end
operator|-
name|start
argument_list|)
expr_stmt|;
name|tmp
index|[
name|end
operator|-
name|start
index|]
operator|=
literal|'\000'
expr_stmt|;
block|}
name|prefix
operator|=
name|tmp
expr_stmt|;
name|prefix_len
operator|=
name|strlen
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
comment|/* See if the prefix we have now is something we know about */
if|if
condition|(
operator|!
name|done
condition|)
block|{
comment|/* More tokens to process, so this must be a class/namespace */
name|sym_class
operator|=
name|lookup_symbol
argument_list|(
name|prefix
argument_list|,
literal|0
argument_list|,
name|STRUCT_DOMAIN
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|symtab
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* No more tokens, so try as a variable first */
name|sym_var
operator|=
name|lookup_symbol
argument_list|(
name|prefix
argument_list|,
literal|0
argument_list|,
name|VAR_DOMAIN
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|symtab
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/* If failed, try as class/namespace */
if|if
condition|(
operator|!
name|sym_var
condition|)
name|sym_class
operator|=
name|lookup_symbol
argument_list|(
name|prefix
argument_list|,
literal|0
argument_list|,
name|STRUCT_DOMAIN
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|symtab
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sym_var
operator|||
operator|(
name|sym_class
operator|&&
operator|(
name|t
operator|=
name|check_typedef
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym_class
argument_list|)
argument_list|)
operator|,
operator|(
name|TYPE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
operator|||
name|TYPE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_CODE_UNION
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* We found a valid token */
operator|*
name|token
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|prefix_len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|*
name|token
argument_list|,
name|prefix
argument_list|,
name|prefix_len
argument_list|)
expr_stmt|;
operator|(
operator|*
name|token
operator|)
index|[
name|prefix_len
index|]
operator|=
literal|'\000'
expr_stmt|;
break|break;
block|}
comment|/* No variable or class/namespace found, no more tokens */
if|if
condition|(
name|done
condition|)
return|return
operator|(
expr|struct
name|symbol
operator|*
operator|)
name|NULL
return|;
block|}
comment|/* Out of loop, so we must have found a valid token */
if|if
condition|(
name|sym_var
condition|)
operator|*
name|class_prefix
operator|=
literal|0
expr_stmt|;
else|else
operator|*
name|class_prefix
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|argptr
condition|)
operator|*
name|argptr
operator|=
name|done
condition|?
name|p
else|:
name|end
expr_stmt|;
return|return
name|sym_var
condition|?
name|sym_var
else|:
name|sym_class
return|;
comment|/* found */
block|}
end_function

begin_function
name|char
modifier|*
name|find_template_name_end
parameter_list|(
name|char
modifier|*
name|p
parameter_list|)
block|{
name|int
name|depth
init|=
literal|1
decl_stmt|;
name|int
name|just_seen_right
init|=
literal|0
decl_stmt|;
name|int
name|just_seen_colon
init|=
literal|0
decl_stmt|;
name|int
name|just_seen_space
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|p
operator|||
operator|(
operator|*
name|p
operator|!=
literal|'<'
operator|)
condition|)
return|return
literal|0
return|;
while|while
condition|(
operator|*
operator|++
name|p
condition|)
block|{
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'\''
case|:
case|case
literal|'\"'
case|:
case|case
literal|'{'
case|:
case|case
literal|'}'
case|:
comment|/* In future, may want to allow these?? */
return|return
literal|0
return|;
case|case
literal|'<'
case|:
name|depth
operator|++
expr_stmt|;
comment|/* start nested template */
if|if
condition|(
name|just_seen_colon
operator|||
name|just_seen_right
operator|||
name|just_seen_space
condition|)
return|return
literal|0
return|;
comment|/* but not after : or :: or> or space */
break|break;
case|case
literal|'>'
case|:
if|if
condition|(
name|just_seen_colon
operator|||
name|just_seen_right
condition|)
return|return
literal|0
return|;
comment|/* end a (nested?) template */
name|just_seen_right
operator|=
literal|1
expr_stmt|;
comment|/* but not after : or :: */
if|if
condition|(
operator|--
name|depth
operator|==
literal|0
condition|)
comment|/* also disallow>>, insist on>> */
return|return
operator|++
name|p
return|;
comment|/* if outermost ended, return */
break|break;
case|case
literal|':'
case|:
if|if
condition|(
name|just_seen_space
operator|||
operator|(
name|just_seen_colon
operator|>
literal|1
operator|)
condition|)
return|return
literal|0
return|;
comment|/* nested class spec coming up */
name|just_seen_colon
operator|++
expr_stmt|;
comment|/* we allow :: but not :::: */
break|break;
case|case
literal|' '
case|:
break|break;
default|default:
if|if
condition|(
operator|!
operator|(
operator|(
operator|*
name|p
operator|>=
literal|'a'
operator|&&
operator|*
name|p
operator|<=
literal|'z'
operator|)
operator|||
comment|/* allow token chars */
operator|(
operator|*
name|p
operator|>=
literal|'A'
operator|&&
operator|*
name|p
operator|<=
literal|'Z'
operator|)
operator|||
operator|(
operator|*
name|p
operator|>=
literal|'0'
operator|&&
operator|*
name|p
operator|<=
literal|'9'
operator|)
operator|||
operator|(
operator|*
name|p
operator|==
literal|'_'
operator|)
operator|||
operator|(
operator|*
name|p
operator|==
literal|','
operator|)
operator|||
comment|/* commas for template args */
operator|(
operator|*
name|p
operator|==
literal|'&'
operator|)
operator|||
operator|(
operator|*
name|p
operator|==
literal|'*'
operator|)
operator|||
comment|/* pointer and ref types */
operator|(
operator|*
name|p
operator|==
literal|'('
operator|)
operator|||
operator|(
operator|*
name|p
operator|==
literal|')'
operator|)
operator|||
comment|/* function types */
operator|(
operator|*
name|p
operator|==
literal|'['
operator|)
operator|||
operator|(
operator|*
name|p
operator|==
literal|']'
operator|)
operator|)
condition|)
comment|/* array types */
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|*
name|p
operator|!=
literal|' '
condition|)
name|just_seen_space
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|':'
condition|)
name|just_seen_colon
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'>'
condition|)
name|just_seen_right
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a null-terminated temporary copy of the name    of a string token.  */
end_comment

begin_function
name|char
modifier|*
name|copy_name
parameter_list|(
name|struct
name|stoken
name|token
parameter_list|)
block|{
name|memcpy
argument_list|(
name|namecopy
argument_list|,
name|token
operator|.
name|ptr
argument_list|,
name|token
operator|.
name|length
argument_list|)
expr_stmt|;
name|namecopy
index|[
name|token
operator|.
name|length
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|namecopy
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Reverse an expression from suffix form (in which it is constructed)    to prefix form (in which we can conveniently print or execute it).  */
end_comment

begin_function
specifier|static
name|void
name|prefixify_expression
parameter_list|(
name|struct
name|expression
modifier|*
name|expr
parameter_list|)
block|{
name|int
name|len
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|expression
argument_list|)
operator|+
name|EXP_ELEM_TO_BYTES
argument_list|(
name|expr
operator|->
name|nelts
argument_list|)
decl_stmt|;
name|struct
name|expression
modifier|*
name|temp
decl_stmt|;
name|int
name|inpos
init|=
name|expr
operator|->
name|nelts
decl_stmt|,
name|outpos
init|=
literal|0
decl_stmt|;
name|temp
operator|=
operator|(
expr|struct
name|expression
operator|*
operator|)
name|alloca
argument_list|(
name|len
argument_list|)
expr_stmt|;
comment|/* Copy the original expression into temp.  */
name|memcpy
argument_list|(
name|temp
argument_list|,
name|expr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|prefixify_subexp
argument_list|(
name|temp
argument_list|,
name|expr
argument_list|,
name|inpos
argument_list|,
name|outpos
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the number of exp_elements in the postfix subexpression     of EXPR whose operator is at index ENDPOS - 1 in EXPR.  */
end_comment

begin_function
name|int
name|length_of_subexp
parameter_list|(
name|struct
name|expression
modifier|*
name|expr
parameter_list|,
name|int
name|endpos
parameter_list|)
block|{
name|int
name|oplen
decl_stmt|,
name|args
decl_stmt|,
name|i
decl_stmt|;
name|operator_length
argument_list|(
name|expr
argument_list|,
name|endpos
argument_list|,
operator|&
name|oplen
argument_list|,
operator|&
name|args
argument_list|)
expr_stmt|;
while|while
condition|(
name|args
operator|>
literal|0
condition|)
block|{
name|oplen
operator|+=
name|length_of_subexp
argument_list|(
name|expr
argument_list|,
name|endpos
operator|-
name|oplen
argument_list|)
expr_stmt|;
name|args
operator|--
expr_stmt|;
block|}
return|return
name|oplen
return|;
block|}
end_function

begin_comment
comment|/* Sets *OPLENP to the length of the operator whose (last) index is     ENDPOS - 1 in EXPR, and sets *ARGSP to the number of arguments that    operator takes.  */
end_comment

begin_function
name|void
name|operator_length
parameter_list|(
name|struct
name|expression
modifier|*
name|expr
parameter_list|,
name|int
name|endpos
parameter_list|,
name|int
modifier|*
name|oplenp
parameter_list|,
name|int
modifier|*
name|argsp
parameter_list|)
block|{
name|expr
operator|->
name|language_defn
operator|->
name|la_exp_desc
operator|->
name|operator_length
argument_list|(
name|expr
argument_list|,
name|endpos
argument_list|,
name|oplenp
argument_list|,
name|argsp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Default value for operator_length in exp_descriptor vectors.  */
end_comment

begin_function
name|void
name|operator_length_standard
parameter_list|(
name|struct
name|expression
modifier|*
name|expr
parameter_list|,
name|int
name|endpos
parameter_list|,
name|int
modifier|*
name|oplenp
parameter_list|,
name|int
modifier|*
name|argsp
parameter_list|)
block|{
name|int
name|oplen
init|=
literal|1
decl_stmt|;
name|int
name|args
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|endpos
operator|<
literal|1
condition|)
name|error
argument_list|(
literal|"?error in operator_length_standard"
argument_list|)
expr_stmt|;
name|i
operator|=
operator|(
name|int
operator|)
name|expr
operator|->
name|elts
index|[
name|endpos
operator|-
literal|1
index|]
operator|.
name|opcode
expr_stmt|;
switch|switch
condition|(
name|i
condition|)
block|{
comment|/* C++  */
case|case
name|OP_SCOPE
case|:
name|oplen
operator|=
name|longest_to_int
argument_list|(
name|expr
operator|->
name|elts
index|[
name|endpos
operator|-
literal|2
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
name|oplen
operator|=
literal|5
operator|+
name|BYTES_TO_EXP_ELEM
argument_list|(
name|oplen
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_LONG
case|:
case|case
name|OP_DOUBLE
case|:
case|case
name|OP_VAR_VALUE
case|:
name|oplen
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|OP_TYPE
case|:
case|case
name|OP_BOOL
case|:
case|case
name|OP_LAST
case|:
case|case
name|OP_REGISTER
case|:
case|case
name|OP_INTERNALVAR
case|:
name|oplen
operator|=
literal|3
expr_stmt|;
break|break;
case|case
name|OP_COMPLEX
case|:
name|oplen
operator|=
literal|1
expr_stmt|;
name|args
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|OP_FUNCALL
case|:
case|case
name|OP_F77_UNDETERMINED_ARGLIST
case|:
name|oplen
operator|=
literal|3
expr_stmt|;
name|args
operator|=
literal|1
operator|+
name|longest_to_int
argument_list|(
name|expr
operator|->
name|elts
index|[
name|endpos
operator|-
literal|2
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_OBJC_MSGCALL
case|:
comment|/* Objective C message (method) call */
name|oplen
operator|=
literal|4
expr_stmt|;
name|args
operator|=
literal|1
operator|+
name|longest_to_int
argument_list|(
name|expr
operator|->
name|elts
index|[
name|endpos
operator|-
literal|2
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNOP_MAX
case|:
case|case
name|UNOP_MIN
case|:
name|oplen
operator|=
literal|3
expr_stmt|;
break|break;
case|case
name|BINOP_VAL
case|:
case|case
name|UNOP_CAST
case|:
case|case
name|UNOP_MEMVAL
case|:
name|oplen
operator|=
literal|3
expr_stmt|;
name|args
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|UNOP_ABS
case|:
case|case
name|UNOP_CAP
case|:
case|case
name|UNOP_CHR
case|:
case|case
name|UNOP_FLOAT
case|:
case|case
name|UNOP_HIGH
case|:
case|case
name|UNOP_ODD
case|:
case|case
name|UNOP_ORD
case|:
case|case
name|UNOP_TRUNC
case|:
name|oplen
operator|=
literal|1
expr_stmt|;
name|args
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OP_LABELED
case|:
case|case
name|STRUCTOP_STRUCT
case|:
case|case
name|STRUCTOP_PTR
case|:
name|args
operator|=
literal|1
expr_stmt|;
comment|/* fall through */
case|case
name|OP_M2_STRING
case|:
case|case
name|OP_STRING
case|:
case|case
name|OP_OBJC_NSSTRING
case|:
comment|/* Objective C Foundation Class NSString constant */
case|case
name|OP_OBJC_SELECTOR
case|:
comment|/* Objective C "@selector" pseudo-op */
case|case
name|OP_NAME
case|:
case|case
name|OP_EXPRSTRING
case|:
name|oplen
operator|=
name|longest_to_int
argument_list|(
name|expr
operator|->
name|elts
index|[
name|endpos
operator|-
literal|2
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
name|oplen
operator|=
literal|4
operator|+
name|BYTES_TO_EXP_ELEM
argument_list|(
name|oplen
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_BITSTRING
case|:
name|oplen
operator|=
name|longest_to_int
argument_list|(
name|expr
operator|->
name|elts
index|[
name|endpos
operator|-
literal|2
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
name|oplen
operator|=
operator|(
name|oplen
operator|+
name|HOST_CHAR_BIT
operator|-
literal|1
operator|)
operator|/
name|HOST_CHAR_BIT
expr_stmt|;
name|oplen
operator|=
literal|4
operator|+
name|BYTES_TO_EXP_ELEM
argument_list|(
name|oplen
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_ARRAY
case|:
name|oplen
operator|=
literal|4
expr_stmt|;
name|args
operator|=
name|longest_to_int
argument_list|(
name|expr
operator|->
name|elts
index|[
name|endpos
operator|-
literal|2
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
name|args
operator|-=
name|longest_to_int
argument_list|(
name|expr
operator|->
name|elts
index|[
name|endpos
operator|-
literal|3
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
name|args
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|TERNOP_COND
case|:
case|case
name|TERNOP_SLICE
case|:
case|case
name|TERNOP_SLICE_COUNT
case|:
name|args
operator|=
literal|3
expr_stmt|;
break|break;
comment|/* Modula-2 */
case|case
name|MULTI_SUBSCRIPT
case|:
name|oplen
operator|=
literal|3
expr_stmt|;
name|args
operator|=
literal|1
operator|+
name|longest_to_int
argument_list|(
name|expr
operator|->
name|elts
index|[
name|endpos
operator|-
literal|2
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_ASSIGN_MODIFY
case|:
name|oplen
operator|=
literal|3
expr_stmt|;
name|args
operator|=
literal|2
expr_stmt|;
break|break;
comment|/* C++ */
case|case
name|OP_THIS
case|:
case|case
name|OP_OBJC_SELF
case|:
name|oplen
operator|=
literal|2
expr_stmt|;
break|break;
default|default:
name|args
operator|=
literal|1
operator|+
operator|(
name|i
operator|<
operator|(
name|int
operator|)
name|BINOP_END
operator|)
expr_stmt|;
block|}
operator|*
name|oplenp
operator|=
name|oplen
expr_stmt|;
operator|*
name|argsp
operator|=
name|args
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy the subexpression ending just before index INEND in INEXPR    into OUTEXPR, starting at index OUTBEG.    In the process, convert it from suffix to prefix form.  */
end_comment

begin_function
specifier|static
name|void
name|prefixify_subexp
parameter_list|(
name|struct
name|expression
modifier|*
name|inexpr
parameter_list|,
name|struct
name|expression
modifier|*
name|outexpr
parameter_list|,
name|int
name|inend
parameter_list|,
name|int
name|outbeg
parameter_list|)
block|{
name|int
name|oplen
decl_stmt|;
name|int
name|args
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
modifier|*
name|arglens
decl_stmt|;
name|enum
name|exp_opcode
name|opcode
decl_stmt|;
name|operator_length
argument_list|(
name|inexpr
argument_list|,
name|inend
argument_list|,
operator|&
name|oplen
argument_list|,
operator|&
name|args
argument_list|)
expr_stmt|;
comment|/* Copy the final operator itself, from the end of the input      to the beginning of the output.  */
name|inend
operator|-=
name|oplen
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|outexpr
operator|->
name|elts
index|[
name|outbeg
index|]
argument_list|,
operator|&
name|inexpr
operator|->
name|elts
index|[
name|inend
index|]
argument_list|,
name|EXP_ELEM_TO_BYTES
argument_list|(
name|oplen
argument_list|)
argument_list|)
expr_stmt|;
name|outbeg
operator|+=
name|oplen
expr_stmt|;
comment|/* Find the lengths of the arg subexpressions.  */
name|arglens
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|args
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|args
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|oplen
operator|=
name|length_of_subexp
argument_list|(
name|inexpr
argument_list|,
name|inend
argument_list|)
expr_stmt|;
name|arglens
index|[
name|i
index|]
operator|=
name|oplen
expr_stmt|;
name|inend
operator|-=
name|oplen
expr_stmt|;
block|}
comment|/* Now copy each subexpression, preserving the order of      the subexpressions, but prefixifying each one.      In this loop, inend starts at the beginning of      the expression this level is working on      and marches forward over the arguments.      outbeg does similarly in the output.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|args
condition|;
name|i
operator|++
control|)
block|{
name|oplen
operator|=
name|arglens
index|[
name|i
index|]
expr_stmt|;
name|inend
operator|+=
name|oplen
expr_stmt|;
name|prefixify_subexp
argument_list|(
name|inexpr
argument_list|,
name|outexpr
argument_list|,
name|inend
argument_list|,
name|outbeg
argument_list|)
expr_stmt|;
name|outbeg
operator|+=
name|oplen
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This page contains the two entry points to this file.  */
end_comment

begin_comment
comment|/* Read an expression from the string *STRINGPTR points to,    parse it, and return a pointer to a  struct expression  that we malloc.    Use block BLOCK as the lexical context for variable names;    if BLOCK is zero, use the block of the selected stack frame.    Meanwhile, advance *STRINGPTR to point after the expression,    at the first nonwhite character that is not part of the expression    (possibly a null character).     If COMMA is nonzero, stop if a comma is reached.  */
end_comment

begin_function
name|struct
name|expression
modifier|*
name|parse_exp_1
parameter_list|(
name|char
modifier|*
modifier|*
name|stringptr
parameter_list|,
name|struct
name|block
modifier|*
name|block
parameter_list|,
name|int
name|comma
parameter_list|)
block|{
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|lexptr
operator|=
operator|*
name|stringptr
expr_stmt|;
name|prev_lexptr
operator|=
name|NULL
expr_stmt|;
name|paren_depth
operator|=
literal|0
expr_stmt|;
name|type_stack_depth
operator|=
literal|0
expr_stmt|;
name|comma_terminates
operator|=
name|comma
expr_stmt|;
if|if
condition|(
name|lexptr
operator|==
literal|0
operator|||
operator|*
name|lexptr
operator|==
literal|0
condition|)
name|error_no_arg
argument_list|(
literal|"expression to compute"
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|free_funcalls
argument_list|,
literal|0
comment|/*ignore*/
argument_list|)
expr_stmt|;
name|funcall_chain
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|block
condition|)
block|{
name|expression_context_block
operator|=
name|block
expr_stmt|;
name|expression_context_pc
operator|=
name|BLOCK_START
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
else|else
name|expression_context_block
operator|=
name|get_selected_block
argument_list|(
operator|&
name|expression_context_pc
argument_list|)
expr_stmt|;
name|namecopy
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|lexptr
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|expout_size
operator|=
literal|10
expr_stmt|;
name|expout_ptr
operator|=
literal|0
expr_stmt|;
name|expout
operator|=
operator|(
expr|struct
name|expression
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|expression
argument_list|)
operator|+
name|EXP_ELEM_TO_BYTES
argument_list|(
name|expout_size
argument_list|)
argument_list|)
expr_stmt|;
name|expout
operator|->
name|language_defn
operator|=
name|current_language
expr_stmt|;
name|make_cleanup
argument_list|(
name|free_current_contents
argument_list|,
operator|&
name|expout
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_language
operator|->
name|la_parser
argument_list|()
condition|)
name|current_language
operator|->
name|la_error
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|discard_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
comment|/* Record the actual number of expression elements, and then      reallocate the expression memory so that we free up any      excess elements. */
name|expout
operator|->
name|nelts
operator|=
name|expout_ptr
expr_stmt|;
name|expout
operator|=
operator|(
expr|struct
name|expression
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|expout
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|expression
argument_list|)
operator|+
name|EXP_ELEM_TO_BYTES
argument_list|(
name|expout_ptr
argument_list|)
argument_list|)
expr_stmt|;
empty_stmt|;
comment|/* Convert expression from postfix form as generated by yacc      parser, to a prefix form. */
if|if
condition|(
name|expressiondebug
condition|)
name|dump_raw_expression
argument_list|(
name|expout
argument_list|,
name|gdb_stdlog
argument_list|,
literal|"before conversion to prefix form"
argument_list|)
expr_stmt|;
name|prefixify_expression
argument_list|(
name|expout
argument_list|)
expr_stmt|;
if|if
condition|(
name|expressiondebug
condition|)
name|dump_prefix_expression
argument_list|(
name|expout
argument_list|,
name|gdb_stdlog
argument_list|)
expr_stmt|;
operator|*
name|stringptr
operator|=
name|lexptr
expr_stmt|;
return|return
name|expout
return|;
block|}
end_function

begin_comment
comment|/* Parse STRING as an expression, and complain if this fails    to use up all of the contents of STRING.  */
end_comment

begin_function
name|struct
name|expression
modifier|*
name|parse_expression
parameter_list|(
name|char
modifier|*
name|string
parameter_list|)
block|{
name|struct
name|expression
modifier|*
name|exp
decl_stmt|;
name|exp
operator|=
name|parse_exp_1
argument_list|(
operator|&
name|string
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|string
condition|)
name|error
argument_list|(
literal|"Junk after end of expression."
argument_list|)
expr_stmt|;
return|return
name|exp
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Stuff for maintaining a stack of types.  Currently just used by C, but    probably useful for any language which declares its types "backwards".  */
end_comment

begin_function
specifier|static
name|void
name|check_type_stack_depth
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|type_stack_depth
operator|==
name|type_stack_size
condition|)
block|{
name|type_stack_size
operator|*=
literal|2
expr_stmt|;
name|type_stack
operator|=
operator|(
expr|union
name|type_stack_elt
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|type_stack
argument_list|,
name|type_stack_size
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|type_stack
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|push_type
parameter_list|(
name|enum
name|type_pieces
name|tp
parameter_list|)
block|{
name|check_type_stack_depth
argument_list|()
expr_stmt|;
name|type_stack
index|[
name|type_stack_depth
operator|++
index|]
operator|.
name|piece
operator|=
name|tp
expr_stmt|;
block|}
end_function

begin_function
name|void
name|push_type_int
parameter_list|(
name|int
name|n
parameter_list|)
block|{
name|check_type_stack_depth
argument_list|()
expr_stmt|;
name|type_stack
index|[
name|type_stack_depth
operator|++
index|]
operator|.
name|int_val
operator|=
name|n
expr_stmt|;
block|}
end_function

begin_function
name|void
name|push_type_address_space
parameter_list|(
name|char
modifier|*
name|string
parameter_list|)
block|{
name|push_type_int
argument_list|(
name|address_space_name_to_int
argument_list|(
name|string
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|enum
name|type_pieces
name|pop_type
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|type_stack_depth
condition|)
return|return
name|type_stack
index|[
operator|--
name|type_stack_depth
index|]
operator|.
name|piece
return|;
return|return
name|tp_end
return|;
block|}
end_function

begin_function
name|int
name|pop_type_int
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|type_stack_depth
condition|)
return|return
name|type_stack
index|[
operator|--
name|type_stack_depth
index|]
operator|.
name|int_val
return|;
comment|/* "Can't happen".  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Pop the type stack and return the type which corresponds to FOLLOW_TYPE    as modified by all the stuff on the stack.  */
end_comment

begin_function
name|struct
name|type
modifier|*
name|follow_types
parameter_list|(
name|struct
name|type
modifier|*
name|follow_type
parameter_list|)
block|{
name|int
name|done
init|=
literal|0
decl_stmt|;
name|int
name|make_const
init|=
literal|0
decl_stmt|;
name|int
name|make_volatile
init|=
literal|0
decl_stmt|;
name|int
name|make_addr_space
init|=
literal|0
decl_stmt|;
name|int
name|array_size
decl_stmt|;
name|struct
name|type
modifier|*
name|range_type
decl_stmt|;
while|while
condition|(
operator|!
name|done
condition|)
switch|switch
condition|(
name|pop_type
argument_list|()
condition|)
block|{
case|case
name|tp_end
case|:
name|done
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|make_const
condition|)
name|follow_type
operator|=
name|make_cv_type
argument_list|(
name|make_const
argument_list|,
name|TYPE_VOLATILE
argument_list|(
name|follow_type
argument_list|)
argument_list|,
name|follow_type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|make_volatile
condition|)
name|follow_type
operator|=
name|make_cv_type
argument_list|(
name|TYPE_CONST
argument_list|(
name|follow_type
argument_list|)
argument_list|,
name|make_volatile
argument_list|,
name|follow_type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|make_addr_space
condition|)
name|follow_type
operator|=
name|make_type_with_address_space
argument_list|(
name|follow_type
argument_list|,
name|make_addr_space
argument_list|)
expr_stmt|;
name|make_const
operator|=
name|make_volatile
operator|=
literal|0
expr_stmt|;
name|make_addr_space
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|tp_const
case|:
name|make_const
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|tp_volatile
case|:
name|make_volatile
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|tp_space_identifier
case|:
name|make_addr_space
operator|=
name|pop_type_int
argument_list|()
expr_stmt|;
break|break;
case|case
name|tp_pointer
case|:
name|follow_type
operator|=
name|lookup_pointer_type
argument_list|(
name|follow_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|make_const
condition|)
name|follow_type
operator|=
name|make_cv_type
argument_list|(
name|make_const
argument_list|,
name|TYPE_VOLATILE
argument_list|(
name|follow_type
argument_list|)
argument_list|,
name|follow_type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|make_volatile
condition|)
name|follow_type
operator|=
name|make_cv_type
argument_list|(
name|TYPE_CONST
argument_list|(
name|follow_type
argument_list|)
argument_list|,
name|make_volatile
argument_list|,
name|follow_type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|make_addr_space
condition|)
name|follow_type
operator|=
name|make_type_with_address_space
argument_list|(
name|follow_type
argument_list|,
name|make_addr_space
argument_list|)
expr_stmt|;
name|make_const
operator|=
name|make_volatile
operator|=
literal|0
expr_stmt|;
name|make_addr_space
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|tp_reference
case|:
name|follow_type
operator|=
name|lookup_reference_type
argument_list|(
name|follow_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|make_const
condition|)
name|follow_type
operator|=
name|make_cv_type
argument_list|(
name|make_const
argument_list|,
name|TYPE_VOLATILE
argument_list|(
name|follow_type
argument_list|)
argument_list|,
name|follow_type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|make_volatile
condition|)
name|follow_type
operator|=
name|make_cv_type
argument_list|(
name|TYPE_CONST
argument_list|(
name|follow_type
argument_list|)
argument_list|,
name|make_volatile
argument_list|,
name|follow_type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|make_addr_space
condition|)
name|follow_type
operator|=
name|make_type_with_address_space
argument_list|(
name|follow_type
argument_list|,
name|make_addr_space
argument_list|)
expr_stmt|;
name|make_const
operator|=
name|make_volatile
operator|=
literal|0
expr_stmt|;
name|make_addr_space
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|tp_array
case|:
name|array_size
operator|=
name|pop_type_int
argument_list|()
expr_stmt|;
comment|/* FIXME-type-allocation: need a way to free this type when we are 	   done with it.  */
name|range_type
operator|=
name|create_range_type
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|)
name|NULL
argument_list|,
name|builtin_type_int
argument_list|,
literal|0
argument_list|,
name|array_size
operator|>=
literal|0
condition|?
name|array_size
operator|-
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
name|follow_type
operator|=
name|create_array_type
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|)
name|NULL
argument_list|,
name|follow_type
argument_list|,
name|range_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|array_size
operator|<
literal|0
condition|)
name|TYPE_ARRAY_UPPER_BOUND_TYPE
argument_list|(
name|follow_type
argument_list|)
operator|=
name|BOUND_CANNOT_BE_DETERMINED
expr_stmt|;
break|break;
case|case
name|tp_function
case|:
comment|/* FIXME-type-allocation: need a way to free this type when we are 	   done with it.  */
name|follow_type
operator|=
name|lookup_function_type
argument_list|(
name|follow_type
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|follow_type
return|;
block|}
end_function

begin_escape
end_escape

begin_function_decl
specifier|static
name|void
name|build_parse
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|build_parse
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|msym_text_symbol_type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FUNC
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"<text variable, no debug info>"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|TYPE_TARGET_TYPE
argument_list|(
name|msym_text_symbol_type
argument_list|)
operator|=
name|builtin_type_int
expr_stmt|;
name|msym_data_symbol_type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_INT_BIT
operator|/
name|HOST_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"<data variable, no debug info>"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|msym_unknown_symbol_type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"<variable (not text or data), no debug info>"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function avoids direct calls to fprintf     in the parser generated debug code.  */
end_comment

begin_function
name|void
name|parser_fprintf
parameter_list|(
name|FILE
modifier|*
name|x
parameter_list|,
specifier|const
name|char
modifier|*
name|y
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|stderr
condition|)
name|vfprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
name|y
argument_list|,
name|args
argument_list|)
expr_stmt|;
else|else
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|" Unknown FILE used.\n"
argument_list|)
expr_stmt|;
name|vfprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
name|y
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_initialize_parse
parameter_list|(
name|void
parameter_list|)
block|{
name|type_stack_size
operator|=
literal|80
expr_stmt|;
name|type_stack_depth
operator|=
literal|0
expr_stmt|;
name|type_stack
operator|=
operator|(
expr|union
name|type_stack_elt
operator|*
operator|)
name|xmalloc
argument_list|(
name|type_stack_size
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|type_stack
argument_list|)
argument_list|)
expr_stmt|;
name|build_parse
argument_list|()
expr_stmt|;
comment|/* FIXME - For the moment, handle types by swapping them in and out.      Should be using the per-architecture data-pointer and a large      struct. */
name|DEPRECATED_REGISTER_GDBARCH_SWAP
argument_list|(
name|msym_text_symbol_type
argument_list|)
expr_stmt|;
name|DEPRECATED_REGISTER_GDBARCH_SWAP
argument_list|(
name|msym_data_symbol_type
argument_list|)
expr_stmt|;
name|DEPRECATED_REGISTER_GDBARCH_SWAP
argument_list|(
name|msym_unknown_symbol_type
argument_list|)
expr_stmt|;
name|deprecated_register_gdbarch_swap
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|build_parse
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"expression"
argument_list|,
name|class_maintenance
argument_list|,
name|var_zinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|expressiondebug
argument_list|,
literal|"Set expression debugging.\n\ When non-zero, the internal representation of expressions will be printed."
argument_list|,
operator|&
name|setdebuglist
argument_list|)
argument_list|,
operator|&
name|showdebuglist
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

