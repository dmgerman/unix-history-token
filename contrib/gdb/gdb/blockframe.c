begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Get info from stack frames;    convert between frames, blocks, functions and pc values.    Copyright 1986, 1987, 1988, 1989, 1991, 1994, 1995              Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_comment
comment|/* for read_register */
end_comment

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_comment
comment|/* for target_has_stack */
end_comment

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_comment
comment|/* for read_pc */
end_comment

begin_include
include|#
directive|include
file|"annotate.h"
end_include

begin_comment
comment|/* Is ADDR inside the startup file?  Note that if your machine    has a way to detect the bottom of the stack, there is no need    to call this function from FRAME_CHAIN_VALID; the reason for    doing so is that some machines have no way of detecting bottom    of stack.      A PC of zero is always considered to be the bottom of the stack. */
end_comment

begin_function
name|int
name|inside_entry_file
parameter_list|(
name|addr
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
block|{
if|if
condition|(
name|addr
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|symfile_objfile
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|#
directive|if
name|CALL_DUMMY_LOCATION
operator|==
name|AT_ENTRY_POINT
comment|/* Do not stop backtracing if the pc is in the call dummy      at the entry point.  */
if|if
condition|(
name|PC_IN_CALL_DUMMY
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
return|return
operator|(
name|addr
operator|>=
name|symfile_objfile
operator|->
name|ei
operator|.
name|entry_file_lowpc
operator|&&
name|addr
operator|<
name|symfile_objfile
operator|->
name|ei
operator|.
name|entry_file_highpc
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Test a specified PC value to see if it is in the range of addresses    that correspond to the main() function.  See comments above for why    we might want to do this.     Typically called from FRAME_CHAIN_VALID.     A PC of zero is always considered to be the bottom of the stack. */
end_comment

begin_function
name|int
name|inside_main_func
parameter_list|(
name|pc
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
block|{
name|struct
name|symbol
modifier|*
name|mainsym
decl_stmt|;
if|if
condition|(
name|pc
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|symfile_objfile
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* If the addr range is not set up at symbol reading time, set it up now.      This is for FRAME_CHAIN_VALID_ALTERNATE. I do this for coff, because      it is unable to set it up and symbol reading time. */
if|if
condition|(
name|symfile_objfile
operator|->
name|ei
operator|.
name|main_func_lowpc
operator|==
name|INVALID_ENTRY_LOWPC
operator|&&
name|symfile_objfile
operator|->
name|ei
operator|.
name|main_func_highpc
operator|==
name|INVALID_ENTRY_HIGHPC
condition|)
block|{
name|mainsym
operator|=
name|lookup_symbol
argument_list|(
literal|"main"
argument_list|,
name|NULL
argument_list|,
name|VAR_NAMESPACE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mainsym
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|mainsym
argument_list|)
operator|==
name|LOC_BLOCK
condition|)
block|{
name|symfile_objfile
operator|->
name|ei
operator|.
name|main_func_lowpc
operator|=
name|BLOCK_START
argument_list|(
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|mainsym
argument_list|)
argument_list|)
expr_stmt|;
name|symfile_objfile
operator|->
name|ei
operator|.
name|main_func_highpc
operator|=
name|BLOCK_END
argument_list|(
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|mainsym
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|symfile_objfile
operator|->
name|ei
operator|.
name|main_func_lowpc
operator|<=
name|pc
operator|&&
name|symfile_objfile
operator|->
name|ei
operator|.
name|main_func_highpc
operator|>
name|pc
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Test a specified PC value to see if it is in the range of addresses    that correspond to the process entry point function.  See comments    in objfiles.h for why we might want to do this.     Typically called from FRAME_CHAIN_VALID.     A PC of zero is always considered to be the bottom of the stack. */
end_comment

begin_function
name|int
name|inside_entry_func
parameter_list|(
name|pc
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
block|{
if|if
condition|(
name|pc
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|symfile_objfile
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|#
directive|if
name|CALL_DUMMY_LOCATION
operator|==
name|AT_ENTRY_POINT
comment|/* Do not stop backtracing if the pc is in the call dummy      at the entry point.  */
if|if
condition|(
name|PC_IN_CALL_DUMMY
argument_list|(
name|pc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
return|return
operator|(
name|symfile_objfile
operator|->
name|ei
operator|.
name|entry_func_lowpc
operator|<=
name|pc
operator|&&
name|symfile_objfile
operator|->
name|ei
operator|.
name|entry_func_highpc
operator|>
name|pc
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Info about the innermost stack frame (contents of FP register) */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|frame_info
modifier|*
name|current_frame
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Cache for frame addresses already read by gdb.  Valid only while    inferior is stopped.  Control variables for the frame cache should    be local to this module.  */
end_comment

begin_decl_stmt
name|struct
name|obstack
name|frame_cache_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return the innermost (currently executing) stack frame.  */
end_comment

begin_function
name|struct
name|frame_info
modifier|*
name|get_current_frame
parameter_list|()
block|{
if|if
condition|(
name|current_frame
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|target_has_stack
condition|)
name|current_frame
operator|=
name|create_new_frame
argument_list|(
name|read_fp
argument_list|()
argument_list|,
name|read_pc
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"No stack."
argument_list|)
expr_stmt|;
block|}
return|return
name|current_frame
return|;
block|}
end_function

begin_function
name|void
name|set_current_frame
parameter_list|(
name|frame
parameter_list|)
name|struct
name|frame_info
modifier|*
name|frame
decl_stmt|;
block|{
name|current_frame
operator|=
name|frame
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create an arbitrary (i.e. address specified by user) or innermost frame.    Always returns a non-NULL value.  */
end_comment

begin_function
name|struct
name|frame_info
modifier|*
name|create_new_frame
parameter_list|(
name|addr
parameter_list|,
name|pc
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
name|CORE_ADDR
name|pc
decl_stmt|;
block|{
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|fi
operator|=
operator|(
expr|struct
name|frame_info
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|frame_cache_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|frame_info
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Arbitrary frame */
name|fi
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|fi
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
name|fi
operator|->
name|frame
operator|=
name|addr
expr_stmt|;
name|fi
operator|->
name|pc
operator|=
name|pc
expr_stmt|;
name|find_pc_partial_function
argument_list|(
name|pc
argument_list|,
operator|&
name|name
argument_list|,
operator|(
name|CORE_ADDR
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|CORE_ADDR
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|fi
operator|->
name|signal_handler_caller
operator|=
name|IN_SIGTRAMP
argument_list|(
name|fi
operator|->
name|pc
argument_list|,
name|name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INIT_EXTRA_FRAME_INFO
name|INIT_EXTRA_FRAME_INFO
argument_list|(
literal|0
argument_list|,
name|fi
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|fi
return|;
block|}
end_function

begin_comment
comment|/* Return the frame that called FI.    If FI is the original frame (it has no caller), return 0.  */
end_comment

begin_function
name|struct
name|frame_info
modifier|*
name|get_prev_frame
parameter_list|(
name|frame
parameter_list|)
name|struct
name|frame_info
modifier|*
name|frame
decl_stmt|;
block|{
return|return
name|get_prev_frame_info
argument_list|(
name|frame
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the frame that FRAME calls (NULL if FRAME is the innermost    frame).  */
end_comment

begin_function
name|struct
name|frame_info
modifier|*
name|get_next_frame
parameter_list|(
name|frame
parameter_list|)
name|struct
name|frame_info
modifier|*
name|frame
decl_stmt|;
block|{
return|return
name|frame
operator|->
name|next
return|;
block|}
end_function

begin_comment
comment|/* Flush the entire frame cache.  */
end_comment

begin_function
name|void
name|flush_cached_frames
parameter_list|()
block|{
comment|/* Since we can't really be sure what the first object allocated was */
name|obstack_free
argument_list|(
operator|&
name|frame_cache_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|obstack_init
argument_list|(
operator|&
name|frame_cache_obstack
argument_list|)
expr_stmt|;
name|current_frame
operator|=
name|NULL
expr_stmt|;
comment|/* Invalidate cache */
name|select_frame
argument_list|(
name|NULL
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|annotate_frames_invalid
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Flush the frame cache, and start a new one if necessary.  */
end_comment

begin_function
name|void
name|reinit_frame_cache
parameter_list|()
block|{
name|flush_cached_frames
argument_list|()
expr_stmt|;
comment|/* FIXME: The inferior_pid test is wrong if there is a corefile.  */
if|if
condition|(
name|inferior_pid
operator|!=
literal|0
condition|)
block|{
name|select_frame
argument_list|(
name|get_current_frame
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* If a machine allows frameless functions, it should define a macro    FRAMELESS_FUNCTION_INVOCATION(FI, FRAMELESS) in param.h.  FI is the struct    frame_info for the frame, and FRAMELESS should be set to nonzero    if it represents a frameless function invocation.  */
end_comment

begin_comment
comment|/* Return nonzero if the function for this frame lacks a prologue.  Many    machines can define FRAMELESS_FUNCTION_INVOCATION to just call this    function.  */
end_comment

begin_function
name|int
name|frameless_look_for_prologue
parameter_list|(
name|frame
parameter_list|)
name|struct
name|frame_info
modifier|*
name|frame
decl_stmt|;
block|{
name|CORE_ADDR
name|func_start
decl_stmt|,
name|after_prologue
decl_stmt|;
name|func_start
operator|=
operator|(
name|get_pc_function_start
argument_list|(
name|frame
operator|->
name|pc
argument_list|)
operator|+
name|FUNCTION_START_OFFSET
operator|)
expr_stmt|;
if|if
condition|(
name|func_start
condition|)
block|{
name|after_prologue
operator|=
name|func_start
expr_stmt|;
ifdef|#
directive|ifdef
name|SKIP_PROLOGUE_FRAMELESS_P
comment|/* This is faster, since only care whether there *is* a prologue, 	 not how long it is.  */
name|SKIP_PROLOGUE_FRAMELESS_P
argument_list|(
name|after_prologue
argument_list|)
expr_stmt|;
else|#
directive|else
name|SKIP_PROLOGUE
argument_list|(
name|after_prologue
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|after_prologue
operator|==
name|func_start
return|;
block|}
else|else
comment|/* If we can't find the start of the function, we don't really        know whether the function is frameless, but we should be able        to get a reasonable (i.e. best we can do under the        circumstances) backtrace by saying that it isn't.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Default a few macros that people seldom redefine.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|INIT_FRAME_PC
argument_list|)
end_if

begin_define
define|#
directive|define
name|INIT_FRAME_PC
parameter_list|(
name|fromleaf
parameter_list|,
name|prev
parameter_list|)
define|\
value|prev->pc = (fromleaf ? SAVED_PC_AFTER_CALL (prev->next) : \ 	      prev->next ? FRAME_SAVED_PC (prev->next) : read_pc ());
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|FRAME_CHAIN_COMBINE
end_ifndef

begin_define
define|#
directive|define
name|FRAME_CHAIN_COMBINE
parameter_list|(
name|chain
parameter_list|,
name|thisframe
parameter_list|)
value|(chain)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Return a structure containing various interesting information    about the frame that called NEXT_FRAME.  Returns NULL    if there is no such frame.  */
end_comment

begin_function
name|struct
name|frame_info
modifier|*
name|get_prev_frame_info
parameter_list|(
name|next_frame
parameter_list|)
name|struct
name|frame_info
modifier|*
name|next_frame
decl_stmt|;
block|{
name|CORE_ADDR
name|address
init|=
literal|0
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|prev
decl_stmt|;
name|int
name|fromleaf
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
comment|/* If the requested entry is in the cache, return it.      Otherwise, figure out what the address should be for the entry      we're about to add to the cache. */
if|if
condition|(
operator|!
name|next_frame
condition|)
block|{
if|#
directive|if
literal|0
comment|/* This screws value_of_variable, which just wants a nice clean 	 NULL return from block_innermost_frame if there are no frames. 	 I don't think I've ever seen this message happen otherwise. 	 And returning NULL here is a perfectly legitimate thing to do.  */
block|if (!current_frame) 	{ 	  error ("You haven't set up a process's stack to examine."); 	}
endif|#
directive|endif
return|return
name|current_frame
return|;
block|}
comment|/* If we have the prev one, return it */
if|if
condition|(
name|next_frame
operator|->
name|prev
condition|)
return|return
name|next_frame
operator|->
name|prev
return|;
comment|/* On some machines it is possible to call a function without      setting up a stack frame for it.  On these machines, we      define this macro to take two args; a frameinfo pointer      identifying a frame and a variable to set or clear if it is      or isn't leafless.  */
ifdef|#
directive|ifdef
name|FRAMELESS_FUNCTION_INVOCATION
comment|/* Still don't want to worry about this except on the innermost      frame.  This macro will set FROMLEAF if NEXT_FRAME is a      frameless function invocation.  */
if|if
condition|(
operator|!
operator|(
name|next_frame
operator|->
name|next
operator|)
condition|)
block|{
name|FRAMELESS_FUNCTION_INVOCATION
argument_list|(
name|next_frame
argument_list|,
name|fromleaf
argument_list|)
expr_stmt|;
if|if
condition|(
name|fromleaf
condition|)
name|address
operator|=
name|FRAME_FP
argument_list|(
name|next_frame
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|fromleaf
condition|)
block|{
comment|/* Two macros defined in tm.h specify the machine-dependent 	 actions to be performed here. 	 First, get the frame's chain-pointer. 	 If that is zero, the frame is the outermost frame or a leaf 	 called by the outermost frame.  This means that if start 	 calls main without a frame, we'll return 0 (which is fine 	 anyway).  	 Nope; there's a problem.  This also returns when the current 	 routine is a leaf of main.  This is unacceptable.  We move 	 this to after the ffi test; I'd rather have backtraces from 	 start go curfluy than have an abort called from main not show 	 main.  */
name|address
operator|=
name|FRAME_CHAIN
argument_list|(
name|next_frame
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|FRAME_CHAIN_VALID
argument_list|(
name|address
argument_list|,
name|next_frame
argument_list|)
condition|)
return|return
literal|0
return|;
name|address
operator|=
name|FRAME_CHAIN_COMBINE
argument_list|(
name|address
argument_list|,
name|next_frame
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|address
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|prev
operator|=
operator|(
expr|struct
name|frame_info
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|frame_cache_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|frame_info
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_frame
condition|)
name|next_frame
operator|->
name|prev
operator|=
name|prev
expr_stmt|;
name|prev
operator|->
name|next
operator|=
name|next_frame
expr_stmt|;
name|prev
operator|->
name|prev
operator|=
operator|(
expr|struct
name|frame_info
operator|*
operator|)
literal|0
expr_stmt|;
name|prev
operator|->
name|frame
operator|=
name|address
expr_stmt|;
name|prev
operator|->
name|signal_handler_caller
operator|=
literal|0
expr_stmt|;
comment|/* This change should not be needed, FIXME!  We should    determine whether any targets *need* INIT_FRAME_PC to happen    after INIT_EXTRA_FRAME_INFO and come up with a simple way to    express what goes on here.        INIT_EXTRA_FRAME_INFO is called from two places: create_new_frame       		(where the PC is already set up) and here (where it isn't).       INIT_FRAME_PC is only called from here, always after       		INIT_EXTRA_FRAME_INFO.        The catch is the MIPS, where INIT_EXTRA_FRAME_INFO requires the PC    value (which hasn't been set yet).  Some other machines appear to    require INIT_EXTRA_FRAME_INFO before they can do INIT_FRAME_PC.  Phoo.     We shouldn't need INIT_FRAME_PC_FIRST to add more complication to    an already overcomplicated part of GDB.   gnu@cygnus.com, 15Sep92.     Assuming that some machines need INIT_FRAME_PC after    INIT_EXTRA_FRAME_INFO, one possible scheme:     SETUP_INNERMOST_FRAME()      Default version is just create_new_frame (read_fp ()),      read_pc ()).  Machines with extra frame info would do that (or the      local equivalent) and then set the extra fields.    SETUP_ARBITRARY_FRAME(argc, argv)      Only change here is that create_new_frame would no longer init extra      frame info; SETUP_ARBITRARY_FRAME would have to do that.    INIT_PREV_FRAME(fromleaf, prev)      Replace INIT_EXTRA_FRAME_INFO and INIT_FRAME_PC.  This should      also return a flag saying whether to keep the new frame, or      whether to discard it, because on some machines (e.g.  mips) it      is really awkward to have FRAME_CHAIN_VALID called *before*      INIT_EXTRA_FRAME_INFO (there is no good way to get information      deduced in FRAME_CHAIN_VALID into the extra fields of the new frame).    std_frame_pc(fromleaf, prev)      This is the default setting for INIT_PREV_FRAME.  It just does what      the default INIT_FRAME_PC does.  Some machines will call it from      INIT_PREV_FRAME (either at the beginning, the end, or in the middle).      Some machines won't use it.    kingdon@cygnus.com, 13Apr93, 31Jan94, 14Dec94.  */
ifdef|#
directive|ifdef
name|INIT_FRAME_PC_FIRST
name|INIT_FRAME_PC_FIRST
argument_list|(
name|fromleaf
argument_list|,
name|prev
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INIT_EXTRA_FRAME_INFO
name|INIT_EXTRA_FRAME_INFO
argument_list|(
name|fromleaf
argument_list|,
name|prev
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* This entry is in the frame queue now, which is good since      FRAME_SAVED_PC may use that queue to figure out its value      (see tm-sparc.h).  We want the pc saved in the inferior frame. */
name|INIT_FRAME_PC
argument_list|(
name|fromleaf
argument_list|,
name|prev
argument_list|)
expr_stmt|;
comment|/* If ->frame and ->pc are unchanged, we are in the process of getting      ourselves into an infinite backtrace.  Some architectures check this      in FRAME_CHAIN or thereabouts, but it seems like there is no reason      this can't be an architecture-independent check.  */
if|if
condition|(
name|next_frame
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|prev
operator|->
name|frame
operator|==
name|next_frame
operator|->
name|frame
operator|&&
name|prev
operator|->
name|pc
operator|==
name|next_frame
operator|->
name|pc
condition|)
block|{
name|next_frame
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|frame_cache_obstack
argument_list|,
name|prev
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
name|find_pc_partial_function
argument_list|(
name|prev
operator|->
name|pc
argument_list|,
operator|&
name|name
argument_list|,
operator|(
name|CORE_ADDR
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|CORE_ADDR
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|IN_SIGTRAMP
argument_list|(
name|prev
operator|->
name|pc
argument_list|,
name|name
argument_list|)
condition|)
name|prev
operator|->
name|signal_handler_caller
operator|=
literal|1
expr_stmt|;
return|return
name|prev
return|;
block|}
end_function

begin_function
name|CORE_ADDR
name|get_frame_pc
parameter_list|(
name|frame
parameter_list|)
name|struct
name|frame_info
modifier|*
name|frame
decl_stmt|;
block|{
return|return
name|frame
operator|->
name|pc
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|FRAME_FIND_SAVED_REGS
argument_list|)
end_if

begin_comment
comment|/* Find the addresses in which registers are saved in FRAME.  */
end_comment

begin_function
name|void
name|get_frame_saved_regs
parameter_list|(
name|frame
parameter_list|,
name|saved_regs_addr
parameter_list|)
name|struct
name|frame_info
modifier|*
name|frame
decl_stmt|;
name|struct
name|frame_saved_regs
modifier|*
name|saved_regs_addr
decl_stmt|;
block|{
name|FRAME_FIND_SAVED_REGS
argument_list|(
name|frame
argument_list|,
operator|*
name|saved_regs_addr
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Return the innermost lexical block in execution    in a specified stack frame.  The frame address is assumed valid.  */
end_comment

begin_function
name|struct
name|block
modifier|*
name|get_frame_block
parameter_list|(
name|frame
parameter_list|)
name|struct
name|frame_info
modifier|*
name|frame
decl_stmt|;
block|{
name|CORE_ADDR
name|pc
decl_stmt|;
name|pc
operator|=
name|frame
operator|->
name|pc
expr_stmt|;
if|if
condition|(
name|frame
operator|->
name|next
operator|!=
literal|0
operator|&&
name|frame
operator|->
name|next
operator|->
name|signal_handler_caller
operator|==
literal|0
condition|)
comment|/* We are not in the innermost frame and we were not interrupted        by a signal.  We need to subtract one to get the correct block,        in case the call instruction was the last instruction of the block.        If there are any machines on which the saved pc does not point to        after the call insn, we probably want to make frame->pc point after        the call insn anyway.  */
operator|--
name|pc
expr_stmt|;
return|return
name|block_for_pc
argument_list|(
name|pc
argument_list|)
return|;
block|}
end_function

begin_function
name|struct
name|block
modifier|*
name|get_current_block
parameter_list|()
block|{
return|return
name|block_for_pc
argument_list|(
name|read_pc
argument_list|()
argument_list|)
return|;
block|}
end_function

begin_function
name|CORE_ADDR
name|get_pc_function_start
parameter_list|(
name|pc
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
block|{
specifier|register
name|struct
name|block
modifier|*
name|bl
decl_stmt|;
specifier|register
name|struct
name|symbol
modifier|*
name|symbol
decl_stmt|;
specifier|register
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
name|CORE_ADDR
name|fstart
decl_stmt|;
if|if
condition|(
operator|(
name|bl
operator|=
name|block_for_pc
argument_list|(
name|pc
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|(
name|symbol
operator|=
name|block_function
argument_list|(
name|bl
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|bl
operator|=
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
name|fstart
operator|=
name|BLOCK_START
argument_list|(
name|bl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|msymbol
operator|=
name|lookup_minimal_symbol_by_pc
argument_list|(
name|pc
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|fstart
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fstart
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|fstart
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the symbol for the function executing in frame FRAME.  */
end_comment

begin_function
name|struct
name|symbol
modifier|*
name|get_frame_function
parameter_list|(
name|frame
parameter_list|)
name|struct
name|frame_info
modifier|*
name|frame
decl_stmt|;
block|{
specifier|register
name|struct
name|block
modifier|*
name|bl
init|=
name|get_frame_block
argument_list|(
name|frame
argument_list|)
decl_stmt|;
if|if
condition|(
name|bl
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|block_function
argument_list|(
name|bl
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the blockvector immediately containing the innermost lexical block    containing the specified pc value, or 0 if there is none.    PINDEX is a pointer to the index value of the block.  If PINDEX    is NULL, we don't pass this information back to the caller.  */
end_comment

begin_function
name|struct
name|blockvector
modifier|*
name|blockvector_for_pc
parameter_list|(
name|pc
parameter_list|,
name|pindex
parameter_list|)
specifier|register
name|CORE_ADDR
name|pc
decl_stmt|;
name|int
modifier|*
name|pindex
decl_stmt|;
block|{
specifier|register
name|struct
name|block
modifier|*
name|b
decl_stmt|;
specifier|register
name|int
name|bot
decl_stmt|,
name|top
decl_stmt|,
name|half
decl_stmt|;
specifier|register
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
name|struct
name|blockvector
modifier|*
name|bl
decl_stmt|;
comment|/* First search all symtabs for one whose file contains our pc */
name|s
operator|=
name|find_pc_symtab
argument_list|(
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|bl
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|b
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Then search that symtab for the smallest block that wins.  */
comment|/* Use binary search to find the last block that starts before PC.  */
name|bot
operator|=
literal|0
expr_stmt|;
name|top
operator|=
name|BLOCKVECTOR_NBLOCKS
argument_list|(
name|bl
argument_list|)
expr_stmt|;
while|while
condition|(
name|top
operator|-
name|bot
operator|>
literal|1
condition|)
block|{
name|half
operator|=
operator|(
name|top
operator|-
name|bot
operator|+
literal|1
operator|)
operator|>>
literal|1
expr_stmt|;
name|b
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bl
argument_list|,
name|bot
operator|+
name|half
argument_list|)
expr_stmt|;
if|if
condition|(
name|BLOCK_START
argument_list|(
name|b
argument_list|)
operator|<=
name|pc
condition|)
name|bot
operator|+=
name|half
expr_stmt|;
else|else
name|top
operator|=
name|bot
operator|+
name|half
expr_stmt|;
block|}
comment|/* Now search backward for a block that ends after PC.  */
while|while
condition|(
name|bot
operator|>=
literal|0
condition|)
block|{
name|b
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bl
argument_list|,
name|bot
argument_list|)
expr_stmt|;
if|if
condition|(
name|BLOCK_END
argument_list|(
name|b
argument_list|)
operator|>
name|pc
condition|)
block|{
if|if
condition|(
name|pindex
condition|)
operator|*
name|pindex
operator|=
name|bot
expr_stmt|;
return|return
name|bl
return|;
block|}
name|bot
operator|--
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return the innermost lexical block containing the specified pc value,    or 0 if there is none.  */
end_comment

begin_function
name|struct
name|block
modifier|*
name|block_for_pc
parameter_list|(
name|pc
parameter_list|)
specifier|register
name|CORE_ADDR
name|pc
decl_stmt|;
block|{
specifier|register
name|struct
name|blockvector
modifier|*
name|bl
decl_stmt|;
name|int
name|index
decl_stmt|;
name|bl
operator|=
name|blockvector_for_pc
argument_list|(
name|pc
argument_list|,
operator|&
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|bl
condition|)
return|return
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bl
argument_list|,
name|index
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return the function containing pc value PC.    Returns 0 if function is not known.  */
end_comment

begin_function
name|struct
name|symbol
modifier|*
name|find_pc_function
parameter_list|(
name|pc
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
block|{
specifier|register
name|struct
name|block
modifier|*
name|b
init|=
name|block_for_pc
argument_list|(
name|pc
argument_list|)
decl_stmt|;
if|if
condition|(
name|b
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|block_function
argument_list|(
name|b
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* These variables are used to cache the most recent result  * of find_pc_partial_function. */
end_comment

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|cache_pc_function_low
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|cache_pc_function_high
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|cache_pc_function_name
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Clear cache, e.g. when symbol table is discarded. */
end_comment

begin_function
name|void
name|clear_pc_function_cache
parameter_list|()
block|{
name|cache_pc_function_low
operator|=
literal|0
expr_stmt|;
name|cache_pc_function_high
operator|=
literal|0
expr_stmt|;
name|cache_pc_function_name
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finds the "function" (text symbol) that is smaller than PC but    greatest of all of the potential text symbols.  Sets *NAME and/or    *ADDRESS conditionally if that pointer is non-null.  If ENDADDR is    non-null, then set *ENDADDR to be the end of the function    (exclusive), but passing ENDADDR as non-null means that the    function might cause symbols to be read.  This function either    succeeds or fails (not halfway succeeds).  If it succeeds, it sets    *NAME, *ADDRESS, and *ENDADDR to real information and returns 1.    If it fails, it sets *NAME, *ADDRESS, and *ENDADDR to zero    and returns 0.  */
end_comment

begin_function
name|int
name|find_pc_partial_function
parameter_list|(
name|pc
parameter_list|,
name|name
parameter_list|,
name|address
parameter_list|,
name|endaddr
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
name|char
modifier|*
modifier|*
name|name
decl_stmt|;
name|CORE_ADDR
modifier|*
name|address
decl_stmt|;
name|CORE_ADDR
modifier|*
name|endaddr
decl_stmt|;
block|{
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
name|struct
name|symbol
modifier|*
name|f
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
name|struct
name|partial_symbol
modifier|*
name|psb
decl_stmt|;
name|struct
name|obj_section
modifier|*
name|sec
decl_stmt|;
if|if
condition|(
name|pc
operator|>=
name|cache_pc_function_low
operator|&&
name|pc
operator|<
name|cache_pc_function_high
condition|)
goto|goto
name|return_cached_value
goto|;
comment|/* If sigtramp is in the u area, it counts as a function (especially      important for step_1).  */
if|#
directive|if
name|defined
name|SIGTRAMP_START
if|if
condition|(
name|IN_SIGTRAMP
argument_list|(
name|pc
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
condition|)
block|{
name|cache_pc_function_low
operator|=
name|SIGTRAMP_START
expr_stmt|;
name|cache_pc_function_high
operator|=
name|SIGTRAMP_END
expr_stmt|;
name|cache_pc_function_name
operator|=
literal|"<sigtramp>"
expr_stmt|;
goto|goto
name|return_cached_value
goto|;
block|}
endif|#
directive|endif
name|msymbol
operator|=
name|lookup_minimal_symbol_by_pc
argument_list|(
name|pc
argument_list|)
expr_stmt|;
name|pst
operator|=
name|find_pc_psymtab
argument_list|(
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|pst
condition|)
block|{
comment|/* Need to read the symbols to get a good value for the end address.  */
if|if
condition|(
name|endaddr
operator|!=
name|NULL
operator|&&
operator|!
name|pst
operator|->
name|readin
condition|)
block|{
comment|/* Need to get the terminal in case symbol-reading produces 	     output.  */
name|target_terminal_ours_for_output
argument_list|()
expr_stmt|;
name|PSYMTAB_TO_SYMTAB
argument_list|(
name|pst
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pst
operator|->
name|readin
condition|)
block|{
comment|/* Checking whether the msymbol has a larger value is for the 	     "pathological" case mentioned in print_frame_info.  */
name|f
operator|=
name|find_pc_function
argument_list|(
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|!=
name|NULL
operator|&&
operator|(
name|msymbol
operator|==
name|NULL
operator|||
operator|(
name|BLOCK_START
argument_list|(
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|f
argument_list|)
argument_list|)
operator|>=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
operator|)
operator|)
condition|)
block|{
name|cache_pc_function_low
operator|=
name|BLOCK_START
argument_list|(
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|f
argument_list|)
argument_list|)
expr_stmt|;
name|cache_pc_function_high
operator|=
name|BLOCK_END
argument_list|(
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|f
argument_list|)
argument_list|)
expr_stmt|;
name|cache_pc_function_name
operator|=
name|SYMBOL_NAME
argument_list|(
name|f
argument_list|)
expr_stmt|;
goto|goto
name|return_cached_value
goto|;
block|}
block|}
else|else
block|{
comment|/* Now that static symbols go in the minimal symbol table, perhaps 	     we could just ignore the partial symbols.  But at least for now 	     we use the partial or minimal symbol, whichever is larger.  */
name|psb
operator|=
name|find_pc_psymbol
argument_list|(
name|pst
argument_list|,
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|psb
operator|&&
operator|(
name|msymbol
operator|==
name|NULL
operator|||
operator|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|psb
argument_list|)
operator|>=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
operator|)
operator|)
condition|)
block|{
comment|/* This case isn't being cached currently. */
if|if
condition|(
name|address
condition|)
operator|*
name|address
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|psb
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
operator|*
name|name
operator|=
name|SYMBOL_NAME
argument_list|(
name|psb
argument_list|)
expr_stmt|;
comment|/* endaddr non-NULL can't happen here.  */
return|return
literal|1
return|;
block|}
block|}
block|}
comment|/* Not in the normal symbol tables, see if the pc is in a known section.      If it's not, then give up.  This ensures that anything beyond the end      of the text seg doesn't appear to be part of the last function in the      text segment.  */
name|sec
operator|=
name|find_pc_section
argument_list|(
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sec
condition|)
name|msymbol
operator|=
name|NULL
expr_stmt|;
comment|/* Must be in the minimal symbol table.  */
if|if
condition|(
name|msymbol
operator|==
name|NULL
condition|)
block|{
comment|/* No available symbol.  */
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
operator|*
name|name
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|address
operator|!=
name|NULL
condition|)
operator|*
name|address
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|endaddr
operator|!=
name|NULL
condition|)
operator|*
name|endaddr
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
name|cache_pc_function_low
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
expr_stmt|;
name|cache_pc_function_name
operator|=
name|SYMBOL_NAME
argument_list|(
name|msymbol
argument_list|)
expr_stmt|;
comment|/* Use the lesser of the next minimal symbol, or the end of the section, as      the end of the function.  */
if|if
condition|(
name|SYMBOL_NAME
argument_list|(
name|msymbol
operator|+
literal|1
argument_list|)
operator|!=
name|NULL
operator|&&
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
operator|+
literal|1
argument_list|)
operator|<
name|sec
operator|->
name|endaddr
condition|)
name|cache_pc_function_high
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
comment|/* We got the start address from the last msymbol in the objfile.        So the end address is the end of the section.  */
name|cache_pc_function_high
operator|=
name|sec
operator|->
name|endaddr
expr_stmt|;
name|return_cached_value
label|:
if|if
condition|(
name|address
condition|)
operator|*
name|address
operator|=
name|cache_pc_function_low
expr_stmt|;
if|if
condition|(
name|name
condition|)
operator|*
name|name
operator|=
name|cache_pc_function_name
expr_stmt|;
if|if
condition|(
name|endaddr
condition|)
operator|*
name|endaddr
operator|=
name|cache_pc_function_high
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return the innermost stack frame executing inside of BLOCK,    or NULL if there is no such frame.  If BLOCK is NULL, just return NULL.  */
end_comment

begin_function
name|struct
name|frame_info
modifier|*
name|block_innermost_frame
parameter_list|(
name|block
parameter_list|)
name|struct
name|block
modifier|*
name|block
decl_stmt|;
block|{
name|struct
name|frame_info
modifier|*
name|frame
decl_stmt|;
specifier|register
name|CORE_ADDR
name|start
decl_stmt|;
specifier|register
name|CORE_ADDR
name|end
decl_stmt|;
if|if
condition|(
name|block
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|start
operator|=
name|BLOCK_START
argument_list|(
name|block
argument_list|)
expr_stmt|;
name|end
operator|=
name|BLOCK_END
argument_list|(
name|block
argument_list|)
expr_stmt|;
name|frame
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|frame
operator|=
name|get_prev_frame
argument_list|(
name|frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|frame
operator|->
name|pc
operator|>=
name|start
operator|&&
name|frame
operator|->
name|pc
operator|<
name|end
condition|)
return|return
name|frame
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return the full FRAME which corresponds to the given CORE_ADDR    or NULL if no FRAME on the chain corresponds to CORE_ADDR.  */
end_comment

begin_function
name|struct
name|frame_info
modifier|*
name|find_frame_addr_in_frame_chain
parameter_list|(
name|frame_addr
parameter_list|)
name|CORE_ADDR
name|frame_addr
decl_stmt|;
block|{
name|struct
name|frame_info
modifier|*
name|frame
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|frame_addr
operator|==
operator|(
name|CORE_ADDR
operator|)
literal|0
condition|)
return|return
name|NULL
return|;
while|while
condition|(
literal|1
condition|)
block|{
name|frame
operator|=
name|get_prev_frame
argument_list|(
name|frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|FRAME_FP
argument_list|(
name|frame
argument_list|)
operator|==
name|frame_addr
condition|)
return|return
name|frame
return|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SIGCONTEXT_PC_OFFSET
end_ifdef

begin_comment
comment|/* Get saved user PC for sigtramp from sigcontext for BSD style sigtramp.  */
end_comment

begin_function
name|CORE_ADDR
name|sigtramp_saved_pc
parameter_list|(
name|frame
parameter_list|)
name|struct
name|frame_info
modifier|*
name|frame
decl_stmt|;
block|{
name|CORE_ADDR
name|sigcontext_addr
decl_stmt|;
name|char
name|buf
index|[
name|TARGET_PTR_BIT
operator|/
name|TARGET_CHAR_BIT
index|]
decl_stmt|;
name|int
name|ptrbytes
init|=
name|TARGET_PTR_BIT
operator|/
name|TARGET_CHAR_BIT
decl_stmt|;
name|int
name|sigcontext_offs
init|=
operator|(
literal|2
operator|*
name|TARGET_INT_BIT
operator|)
operator|/
name|TARGET_CHAR_BIT
decl_stmt|;
comment|/* Get sigcontext address, it is the third parameter on the stack.  */
if|if
condition|(
name|frame
operator|->
name|next
condition|)
name|sigcontext_addr
operator|=
name|read_memory_integer
argument_list|(
name|FRAME_ARGS_ADDRESS
argument_list|(
name|frame
operator|->
name|next
argument_list|)
operator|+
name|FRAME_ARGS_SKIP
operator|+
name|sigcontext_offs
argument_list|,
name|ptrbytes
argument_list|)
expr_stmt|;
else|else
name|sigcontext_addr
operator|=
name|read_memory_integer
argument_list|(
name|read_register
argument_list|(
name|SP_REGNUM
argument_list|)
operator|+
name|sigcontext_offs
argument_list|,
name|ptrbytes
argument_list|)
expr_stmt|;
comment|/* Don't cause a memory_error when accessing sigcontext in case the stack      layout has changed or the stack is corrupt.  */
name|target_read_memory
argument_list|(
name|sigcontext_addr
operator|+
name|SIGCONTEXT_PC_OFFSET
argument_list|,
name|buf
argument_list|,
name|ptrbytes
argument_list|)
expr_stmt|;
return|return
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
name|ptrbytes
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SIGCONTEXT_PC_OFFSET */
end_comment

begin_function
name|void
name|_initialize_blockframe
parameter_list|()
block|{
name|obstack_init
argument_list|(
operator|&
name|frame_cache_obstack
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

