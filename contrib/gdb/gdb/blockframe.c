begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Get info from stack frames; convert between frames, blocks,    functions and pc values.     Copyright 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994,    1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004    Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_comment
comment|/* for read_register */
end_comment

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_comment
comment|/* for target_has_stack */
end_comment

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_comment
comment|/* for read_pc */
end_comment

begin_include
include|#
directive|include
file|"annotate.h"
end_include

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_include
include|#
directive|include
file|"gdb_assert.h"
end_include

begin_include
include|#
directive|include
file|"dummy-frame.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"block.h"
end_include

begin_comment
comment|/* Prototypes for exported functions. */
end_comment

begin_function_decl
name|void
name|_initialize_blockframe
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Is ADDR inside the startup file?  Note that if your machine has a    way to detect the bottom of the stack, there is no need to call    this function from DEPRECATED_FRAME_CHAIN_VALID; the reason for    doing so is that some machines have no way of detecting bottom of    stack.     A PC of zero is always considered to be the bottom of the stack. */
end_comment

begin_function
name|int
name|deprecated_inside_entry_file
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|)
block|{
if|if
condition|(
name|addr
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|symfile_objfile
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|CALL_DUMMY_LOCATION
operator|==
name|AT_ENTRY_POINT
operator|||
name|CALL_DUMMY_LOCATION
operator|==
name|AT_SYMBOL
condition|)
block|{
comment|/* Do not stop backtracing if the pc is in the call dummy          at the entry point.  */
comment|/* FIXME: Won't always work with zeros for the last two arguments */
if|if
condition|(
name|DEPRECATED_PC_IN_CALL_DUMMY
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
operator|(
name|addr
operator|>=
name|symfile_objfile
operator|->
name|ei
operator|.
name|deprecated_entry_file_lowpc
operator|&&
name|addr
operator|<
name|symfile_objfile
operator|->
name|ei
operator|.
name|deprecated_entry_file_highpc
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Test whether PC is in the range of addresses that corresponds to    the "main" function.  */
end_comment

begin_function
name|int
name|inside_main_func
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
if|if
condition|(
name|symfile_objfile
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|msymbol
operator|=
name|lookup_minimal_symbol
argument_list|(
name|main_name
argument_list|()
argument_list|,
name|NULL
argument_list|,
name|symfile_objfile
argument_list|)
expr_stmt|;
comment|/* If the address range hasn't been set up at symbol reading time,      set it up now.  */
if|if
condition|(
name|msymbol
operator|!=
name|NULL
operator|&&
name|symfile_objfile
operator|->
name|ei
operator|.
name|main_func_lowpc
operator|==
name|INVALID_ENTRY_LOWPC
operator|&&
name|symfile_objfile
operator|->
name|ei
operator|.
name|main_func_highpc
operator|==
name|INVALID_ENTRY_HIGHPC
condition|)
block|{
comment|/* brobecker/2003-10-10: We used to rely on lookup_symbol() to 	 search the symbol associated to the "main" function. 	 Unfortunately, lookup_symbol() uses the current-language 	 la_lookup_symbol_nonlocal function to do the global symbol 	 search.  Depending on the language, this can introduce 	 certain side-effects, because certain languages, for instance 	 Ada, may find more than one match.  Therefore we prefer to 	 search the "main" function symbol using its address rather 	 than its name.  */
name|struct
name|symbol
modifier|*
name|mainsym
init|=
name|find_pc_function
argument_list|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|mainsym
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|mainsym
argument_list|)
operator|==
name|LOC_BLOCK
condition|)
block|{
name|symfile_objfile
operator|->
name|ei
operator|.
name|main_func_lowpc
operator|=
name|BLOCK_START
argument_list|(
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|mainsym
argument_list|)
argument_list|)
expr_stmt|;
name|symfile_objfile
operator|->
name|ei
operator|.
name|main_func_highpc
operator|=
name|BLOCK_END
argument_list|(
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|mainsym
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Not in the normal symbol tables, see if "main" is in the partial      symbol table.  If it's not, then give up.  */
if|if
condition|(
name|msymbol
operator|!=
name|NULL
operator|&&
name|MSYMBOL_TYPE
argument_list|(
name|msymbol
argument_list|)
operator|==
name|mst_text
condition|)
block|{
name|CORE_ADDR
name|maddr
init|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
decl_stmt|;
name|asection
modifier|*
name|msect
init|=
name|SYMBOL_BFD_SECTION
argument_list|(
name|msymbol
argument_list|)
decl_stmt|;
name|struct
name|obj_section
modifier|*
name|osect
init|=
name|find_pc_sect_section
argument_list|(
name|maddr
argument_list|,
name|msect
argument_list|)
decl_stmt|;
if|if
condition|(
name|osect
operator|!=
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Step over other symbols at this same address, and symbols 	     in other sections, to find the next symbol in this 	     section with a different address.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|SYMBOL_LINKAGE_NAME
argument_list|(
name|msymbol
operator|+
name|i
argument_list|)
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
operator|+
name|i
argument_list|)
operator|!=
name|maddr
operator|&&
name|SYMBOL_BFD_SECTION
argument_list|(
name|msymbol
operator|+
name|i
argument_list|)
operator|==
name|msect
condition|)
break|break;
block|}
name|symfile_objfile
operator|->
name|ei
operator|.
name|main_func_lowpc
operator|=
name|maddr
expr_stmt|;
comment|/* Use the lesser of the next minimal symbol in the same 	     section, or the end of the section, as the end of the 	     function.  */
if|if
condition|(
name|SYMBOL_LINKAGE_NAME
argument_list|(
name|msymbol
operator|+
name|i
argument_list|)
operator|!=
name|NULL
operator|&&
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
operator|+
name|i
argument_list|)
operator|<
name|osect
operator|->
name|endaddr
condition|)
name|symfile_objfile
operator|->
name|ei
operator|.
name|main_func_highpc
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
operator|+
name|i
argument_list|)
expr_stmt|;
else|else
comment|/* We got the start address from the last msymbol in the 	       objfile.  So the end address is the end of the 	       section.  */
name|symfile_objfile
operator|->
name|ei
operator|.
name|main_func_highpc
operator|=
name|osect
operator|->
name|endaddr
expr_stmt|;
block|}
block|}
return|return
operator|(
name|symfile_objfile
operator|->
name|ei
operator|.
name|main_func_lowpc
operator|<=
name|pc
operator|&&
name|symfile_objfile
operator|->
name|ei
operator|.
name|main_func_highpc
operator|>
name|pc
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Test whether THIS_FRAME is inside the process entry point function.  */
end_comment

begin_function
name|int
name|inside_entry_func
parameter_list|(
name|struct
name|frame_info
modifier|*
name|this_frame
parameter_list|)
block|{
return|return
operator|(
name|get_frame_func
argument_list|(
name|this_frame
argument_list|)
operator|==
name|entry_point_address
argument_list|()
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Similar to inside_entry_func, but accomodating legacy frame code.  */
end_comment

begin_function
specifier|static
name|int
name|legacy_inside_entry_func
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
if|if
condition|(
name|symfile_objfile
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|CALL_DUMMY_LOCATION
operator|==
name|AT_ENTRY_POINT
condition|)
block|{
comment|/* Do not stop backtracing if the program counter is in the call          dummy at the entry point.  */
comment|/* FIXME: This won't always work with zeros for the last two          arguments.  */
if|if
condition|(
name|DEPRECATED_PC_IN_CALL_DUMMY
argument_list|(
name|pc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
operator|(
name|symfile_objfile
operator|->
name|ei
operator|.
name|entry_func_lowpc
operator|<=
name|pc
operator|&&
name|symfile_objfile
operator|->
name|ei
operator|.
name|entry_func_highpc
operator|>
name|pc
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if the function for this frame lacks a prologue.    Many machines can define DEPRECATED_FRAMELESS_FUNCTION_INVOCATION    to just call this function.  */
end_comment

begin_function
name|int
name|legacy_frameless_look_for_prologue
parameter_list|(
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|)
block|{
name|CORE_ADDR
name|func_start
decl_stmt|;
name|func_start
operator|=
name|get_frame_func
argument_list|(
name|frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|func_start
condition|)
block|{
name|func_start
operator|+=
name|FUNCTION_START_OFFSET
expr_stmt|;
comment|/* NOTE: cagney/2004-02-09: Eliminated per-architecture          PROLOGUE_FRAMELESS_P call as architectures with custom          implementations had all been deleted.  Eventually even this          function can go - GDB no longer tries to differentiate          between framed, frameless and stackless functions.  They are          all now considered equally evil :-^.  */
comment|/* If skipping the prologue ends up skips nothing, there must be          no prologue and hence no code creating a frame.  There for          the function is "frameless" :-/.  */
return|return
name|func_start
operator|==
name|SKIP_PROLOGUE
argument_list|(
name|func_start
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|get_frame_pc
argument_list|(
name|frame
argument_list|)
operator|==
literal|0
condition|)
comment|/* A frame with a zero PC is usually created by dereferencing a        NULL function pointer, normally causing an immediate core dump        of the inferior. Mark function as frameless, as the inferior        has no chance of setting up a stack frame.  */
return|return
literal|1
return|;
else|else
comment|/* If we can't find the start of the function, we don't really        know whether the function is frameless, but we should be able        to get a reasonable (i.e. best we can do under the        circumstances) backtrace by saying that it isn't.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return the innermost lexical block in execution    in a specified stack frame.  The frame address is assumed valid.     If ADDR_IN_BLOCK is non-zero, set *ADDR_IN_BLOCK to the exact code    address we used to choose the block.  We use this to find a source    line, to decide which macro definitions are in scope.     The value returned in *ADDR_IN_BLOCK isn't necessarily the frame's    PC, and may not really be a valid PC at all.  For example, in the    caller of a function declared to never return, the code at the    return address will never be reached, so the call instruction may    be the very last instruction in the block.  So the address we use    to choose the block is actually one byte before the return address    --- hopefully pointing us at the call instruction, or its delay    slot instruction.  */
end_comment

begin_function
name|struct
name|block
modifier|*
name|get_frame_block
parameter_list|(
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|,
name|CORE_ADDR
modifier|*
name|addr_in_block
parameter_list|)
block|{
specifier|const
name|CORE_ADDR
name|pc
init|=
name|get_frame_address_in_block
argument_list|(
name|frame
argument_list|)
decl_stmt|;
if|if
condition|(
name|addr_in_block
condition|)
operator|*
name|addr_in_block
operator|=
name|pc
expr_stmt|;
return|return
name|block_for_pc
argument_list|(
name|pc
argument_list|)
return|;
block|}
end_function

begin_function
name|CORE_ADDR
name|get_pc_function_start
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
name|struct
name|block
modifier|*
name|bl
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
name|bl
operator|=
name|block_for_pc
argument_list|(
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|bl
condition|)
block|{
name|struct
name|symbol
modifier|*
name|symbol
init|=
name|block_function
argument_list|(
name|bl
argument_list|)
decl_stmt|;
if|if
condition|(
name|symbol
condition|)
block|{
name|bl
operator|=
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
return|return
name|BLOCK_START
argument_list|(
name|bl
argument_list|)
return|;
block|}
block|}
name|msymbol
operator|=
name|lookup_minimal_symbol_by_pc
argument_list|(
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|msymbol
condition|)
block|{
name|CORE_ADDR
name|fstart
init|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
decl_stmt|;
if|if
condition|(
name|find_pc_section
argument_list|(
name|fstart
argument_list|)
condition|)
return|return
name|fstart
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return the symbol for the function executing in frame FRAME.  */
end_comment

begin_function
name|struct
name|symbol
modifier|*
name|get_frame_function
parameter_list|(
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|)
block|{
name|struct
name|block
modifier|*
name|bl
init|=
name|get_frame_block
argument_list|(
name|frame
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|bl
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|block_function
argument_list|(
name|bl
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the function containing pc value PC in section SECTION.    Returns 0 if function is not known.  */
end_comment

begin_function
name|struct
name|symbol
modifier|*
name|find_pc_sect_function
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|struct
name|bfd_section
modifier|*
name|section
parameter_list|)
block|{
name|struct
name|block
modifier|*
name|b
init|=
name|block_for_pc_sect
argument_list|(
name|pc
argument_list|,
name|section
argument_list|)
decl_stmt|;
if|if
condition|(
name|b
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|block_function
argument_list|(
name|b
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the function containing pc value PC.    Returns 0 if function is not known.  Backward compatibility, no section */
end_comment

begin_function
name|struct
name|symbol
modifier|*
name|find_pc_function
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
return|return
name|find_pc_sect_function
argument_list|(
name|pc
argument_list|,
name|find_pc_mapped_section
argument_list|(
name|pc
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* These variables are used to cache the most recent result  * of find_pc_partial_function. */
end_comment

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|cache_pc_function_low
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|cache_pc_function_high
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|cache_pc_function_name
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bfd_section
modifier|*
name|cache_pc_function_section
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Clear cache, e.g. when symbol table is discarded. */
end_comment

begin_function
name|void
name|clear_pc_function_cache
parameter_list|(
name|void
parameter_list|)
block|{
name|cache_pc_function_low
operator|=
literal|0
expr_stmt|;
name|cache_pc_function_high
operator|=
literal|0
expr_stmt|;
name|cache_pc_function_name
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
name|cache_pc_function_section
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finds the "function" (text symbol) that is smaller than PC but    greatest of all of the potential text symbols in SECTION.  Sets    *NAME and/or *ADDRESS conditionally if that pointer is non-null.    If ENDADDR is non-null, then set *ENDADDR to be the end of the    function (exclusive), but passing ENDADDR as non-null means that    the function might cause symbols to be read.  This function either    succeeds or fails (not halfway succeeds).  If it succeeds, it sets    *NAME, *ADDRESS, and *ENDADDR to real information and returns 1.    If it fails, it sets *NAME, *ADDRESS, and *ENDADDR to zero and    returns 0.  */
end_comment

begin_function
name|int
name|find_pc_sect_partial_function
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|asection
modifier|*
name|section
parameter_list|,
name|char
modifier|*
modifier|*
name|name
parameter_list|,
name|CORE_ADDR
modifier|*
name|address
parameter_list|,
name|CORE_ADDR
modifier|*
name|endaddr
parameter_list|)
block|{
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
name|struct
name|symbol
modifier|*
name|f
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
name|struct
name|partial_symbol
modifier|*
name|psb
decl_stmt|;
name|struct
name|obj_section
modifier|*
name|osect
decl_stmt|;
name|int
name|i
decl_stmt|;
name|CORE_ADDR
name|mapped_pc
decl_stmt|;
name|mapped_pc
operator|=
name|overlay_mapped_address
argument_list|(
name|pc
argument_list|,
name|section
argument_list|)
expr_stmt|;
if|if
condition|(
name|mapped_pc
operator|>=
name|cache_pc_function_low
operator|&&
name|mapped_pc
operator|<
name|cache_pc_function_high
operator|&&
name|section
operator|==
name|cache_pc_function_section
condition|)
goto|goto
name|return_cached_value
goto|;
comment|/* If sigtramp is in the u area, it counts as a function (especially      important for step_1).  */
if|if
condition|(
name|SIGTRAMP_START_P
argument_list|()
operator|&&
name|PC_IN_SIGTRAMP
argument_list|(
name|mapped_pc
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
condition|)
block|{
name|cache_pc_function_low
operator|=
name|SIGTRAMP_START
argument_list|(
name|mapped_pc
argument_list|)
expr_stmt|;
name|cache_pc_function_high
operator|=
name|SIGTRAMP_END
argument_list|(
name|mapped_pc
argument_list|)
expr_stmt|;
name|cache_pc_function_name
operator|=
literal|"<sigtramp>"
expr_stmt|;
name|cache_pc_function_section
operator|=
name|section
expr_stmt|;
goto|goto
name|return_cached_value
goto|;
block|}
name|msymbol
operator|=
name|lookup_minimal_symbol_by_pc_section
argument_list|(
name|mapped_pc
argument_list|,
name|section
argument_list|)
expr_stmt|;
name|pst
operator|=
name|find_pc_sect_psymtab
argument_list|(
name|mapped_pc
argument_list|,
name|section
argument_list|)
expr_stmt|;
if|if
condition|(
name|pst
condition|)
block|{
comment|/* Need to read the symbols to get a good value for the end address.  */
if|if
condition|(
name|endaddr
operator|!=
name|NULL
operator|&&
operator|!
name|pst
operator|->
name|readin
condition|)
block|{
comment|/* Need to get the terminal in case symbol-reading produces 	     output.  */
name|target_terminal_ours_for_output
argument_list|()
expr_stmt|;
name|PSYMTAB_TO_SYMTAB
argument_list|(
name|pst
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pst
operator|->
name|readin
condition|)
block|{
comment|/* Checking whether the msymbol has a larger value is for the 	     "pathological" case mentioned in print_frame_info.  */
name|f
operator|=
name|find_pc_sect_function
argument_list|(
name|mapped_pc
argument_list|,
name|section
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|!=
name|NULL
operator|&&
operator|(
name|msymbol
operator|==
name|NULL
operator|||
operator|(
name|BLOCK_START
argument_list|(
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|f
argument_list|)
argument_list|)
operator|>=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
operator|)
operator|)
condition|)
block|{
name|cache_pc_function_low
operator|=
name|BLOCK_START
argument_list|(
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|f
argument_list|)
argument_list|)
expr_stmt|;
name|cache_pc_function_high
operator|=
name|BLOCK_END
argument_list|(
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|f
argument_list|)
argument_list|)
expr_stmt|;
name|cache_pc_function_name
operator|=
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|cache_pc_function_section
operator|=
name|section
expr_stmt|;
goto|goto
name|return_cached_value
goto|;
block|}
block|}
else|else
block|{
comment|/* Now that static symbols go in the minimal symbol table, perhaps 	     we could just ignore the partial symbols.  But at least for now 	     we use the partial or minimal symbol, whichever is larger.  */
name|psb
operator|=
name|find_pc_sect_psymbol
argument_list|(
name|pst
argument_list|,
name|mapped_pc
argument_list|,
name|section
argument_list|)
expr_stmt|;
if|if
condition|(
name|psb
operator|&&
operator|(
name|msymbol
operator|==
name|NULL
operator|||
operator|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|psb
argument_list|)
operator|>=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
operator|)
operator|)
condition|)
block|{
comment|/* This case isn't being cached currently. */
if|if
condition|(
name|address
condition|)
operator|*
name|address
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|psb
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
operator|*
name|name
operator|=
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|psb
argument_list|)
expr_stmt|;
comment|/* endaddr non-NULL can't happen here.  */
return|return
literal|1
return|;
block|}
block|}
block|}
comment|/* Not in the normal symbol tables, see if the pc is in a known section.      If it's not, then give up.  This ensures that anything beyond the end      of the text seg doesn't appear to be part of the last function in the      text segment.  */
name|osect
operator|=
name|find_pc_sect_section
argument_list|(
name|mapped_pc
argument_list|,
name|section
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|osect
condition|)
name|msymbol
operator|=
name|NULL
expr_stmt|;
comment|/* Must be in the minimal symbol table.  */
if|if
condition|(
name|msymbol
operator|==
name|NULL
condition|)
block|{
comment|/* No available symbol.  */
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
operator|*
name|name
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|address
operator|!=
name|NULL
condition|)
operator|*
name|address
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|endaddr
operator|!=
name|NULL
condition|)
operator|*
name|endaddr
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
name|cache_pc_function_low
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
expr_stmt|;
name|cache_pc_function_name
operator|=
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|msymbol
argument_list|)
expr_stmt|;
name|cache_pc_function_section
operator|=
name|section
expr_stmt|;
comment|/* Use the lesser of the next minimal symbol in the same section, or      the end of the section, as the end of the function.  */
comment|/* Step over other symbols at this same address, and symbols in      other sections, to find the next symbol in this section with      a different address.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|msymbol
operator|+
name|i
argument_list|)
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
operator|+
name|i
argument_list|)
operator|!=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
operator|&&
name|SYMBOL_BFD_SECTION
argument_list|(
name|msymbol
operator|+
name|i
argument_list|)
operator|==
name|SYMBOL_BFD_SECTION
argument_list|(
name|msymbol
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|msymbol
operator|+
name|i
argument_list|)
operator|!=
name|NULL
operator|&&
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
operator|+
name|i
argument_list|)
operator|<
name|osect
operator|->
name|endaddr
condition|)
name|cache_pc_function_high
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
operator|+
name|i
argument_list|)
expr_stmt|;
else|else
comment|/* We got the start address from the last msymbol in the objfile.        So the end address is the end of the section.  */
name|cache_pc_function_high
operator|=
name|osect
operator|->
name|endaddr
expr_stmt|;
name|return_cached_value
label|:
if|if
condition|(
name|address
condition|)
block|{
if|if
condition|(
name|pc_in_unmapped_range
argument_list|(
name|pc
argument_list|,
name|section
argument_list|)
condition|)
operator|*
name|address
operator|=
name|overlay_unmapped_address
argument_list|(
name|cache_pc_function_low
argument_list|,
name|section
argument_list|)
expr_stmt|;
else|else
operator|*
name|address
operator|=
name|cache_pc_function_low
expr_stmt|;
block|}
if|if
condition|(
name|name
condition|)
operator|*
name|name
operator|=
name|cache_pc_function_name
expr_stmt|;
if|if
condition|(
name|endaddr
condition|)
block|{
if|if
condition|(
name|pc_in_unmapped_range
argument_list|(
name|pc
argument_list|,
name|section
argument_list|)
condition|)
block|{
comment|/* Because the high address is actually beyond the end of 	     the function (and therefore possibly beyond the end of 	     the overlay), we must actually convert (high - 1) and 	     then add one to that. */
operator|*
name|endaddr
operator|=
literal|1
operator|+
name|overlay_unmapped_address
argument_list|(
name|cache_pc_function_high
operator|-
literal|1
argument_list|,
name|section
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|endaddr
operator|=
name|cache_pc_function_high
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Backward compatibility, no section argument.  */
end_comment

begin_function
name|int
name|find_pc_partial_function
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|char
modifier|*
modifier|*
name|name
parameter_list|,
name|CORE_ADDR
modifier|*
name|address
parameter_list|,
name|CORE_ADDR
modifier|*
name|endaddr
parameter_list|)
block|{
name|struct
name|bfd_section
modifier|*
name|bfd_section
decl_stmt|;
comment|/* To ensure that the symbol returned belongs to the correct setion      (and that the last [random] symbol from the previous section      isn't returned) try to find the section containing PC.  First try      the overlay code (which by default returns NULL); and second try      the normal section code (which almost always succeeds).  */
name|bfd_section
operator|=
name|find_pc_overlay
argument_list|(
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_section
operator|==
name|NULL
condition|)
block|{
name|struct
name|obj_section
modifier|*
name|obj_section
init|=
name|find_pc_section
argument_list|(
name|pc
argument_list|)
decl_stmt|;
if|if
condition|(
name|obj_section
operator|==
name|NULL
condition|)
name|bfd_section
operator|=
name|NULL
expr_stmt|;
else|else
name|bfd_section
operator|=
name|obj_section
operator|->
name|the_bfd_section
expr_stmt|;
block|}
return|return
name|find_pc_sect_partial_function
argument_list|(
name|pc
argument_list|,
name|bfd_section
argument_list|,
name|name
argument_list|,
name|address
argument_list|,
name|endaddr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the innermost stack frame executing inside of BLOCK,    or NULL if there is no such frame.  If BLOCK is NULL, just return NULL.  */
end_comment

begin_function
name|struct
name|frame_info
modifier|*
name|block_innermost_frame
parameter_list|(
name|struct
name|block
modifier|*
name|block
parameter_list|)
block|{
name|struct
name|frame_info
modifier|*
name|frame
decl_stmt|;
name|CORE_ADDR
name|start
decl_stmt|;
name|CORE_ADDR
name|end
decl_stmt|;
name|CORE_ADDR
name|calling_pc
decl_stmt|;
if|if
condition|(
name|block
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|start
operator|=
name|BLOCK_START
argument_list|(
name|block
argument_list|)
expr_stmt|;
name|end
operator|=
name|BLOCK_END
argument_list|(
name|block
argument_list|)
expr_stmt|;
name|frame
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|frame
operator|=
name|get_prev_frame
argument_list|(
name|frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|calling_pc
operator|=
name|get_frame_address_in_block
argument_list|(
name|frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|calling_pc
operator|>=
name|start
operator|&&
name|calling_pc
operator|<
name|end
condition|)
return|return
name|frame
return|;
block|}
block|}
end_function

begin_comment
comment|/* Are we in a call dummy?  The code below which allows DECR_PC_AFTER_BREAK    below is for infrun.c, which may give the macro a pc without that    subtracted out.  */
end_comment

begin_comment
comment|/* Is the PC in a call dummy?  SP and FRAME_ADDRESS are the bottom and    top of the stack frame which we are checking, where "bottom" and    "top" refer to some section of memory which contains the code for    the call dummy.  Calls to this macro assume that the contents of    SP_REGNUM and DEPRECATED_FP_REGNUM (or the saved values thereof),    respectively, are the things to pass.     This won't work on the 29k, where SP_REGNUM and    DEPRECATED_FP_REGNUM don't have that meaning, but the 29k doesn't    use ON_STACK.  This could be fixed by generalizing this scheme,    perhaps by passing in a frame and adding a few fields, at least on    machines which need them for DEPRECATED_PC_IN_CALL_DUMMY.     Something simpler, like checking for the stack segment, doesn't work,    since various programs (threads implementations, gcc nested function    stubs, etc) may either allocate stack frames in another segment, or    allocate other kinds of code on the stack.  */
end_comment

begin_function
name|int
name|deprecated_pc_in_call_dummy_on_stack
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|CORE_ADDR
name|sp
parameter_list|,
name|CORE_ADDR
name|frame_address
parameter_list|)
block|{
return|return
operator|(
name|INNER_THAN
argument_list|(
operator|(
name|sp
operator|)
argument_list|,
operator|(
name|pc
operator|)
argument_list|)
operator|&&
operator|(
name|frame_address
operator|!=
literal|0
operator|)
operator|&&
name|INNER_THAN
argument_list|(
operator|(
name|pc
operator|)
argument_list|,
operator|(
name|frame_address
operator|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|deprecated_pc_in_call_dummy_at_entry_point
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|CORE_ADDR
name|sp
parameter_list|,
name|CORE_ADDR
name|frame_address
parameter_list|)
block|{
name|CORE_ADDR
name|addr
init|=
name|entry_point_address
argument_list|()
decl_stmt|;
return|return
operator|(
operator|(
name|pc
operator|)
operator|>=
name|addr
operator|&&
operator|(
name|pc
operator|)
operator|<=
operator|(
name|addr
operator|+
name|DECR_PC_AFTER_BREAK
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns true for a user frame or a call_function_by_hand dummy    frame, and false for the CRT0 start-up frame.  Purpose is to    terminate backtrace.  */
end_comment

begin_function
name|int
name|legacy_frame_chain_valid
parameter_list|(
name|CORE_ADDR
name|fp
parameter_list|,
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|)
block|{
comment|/* Don't prune CALL_DUMMY frames.  */
if|if
condition|(
name|DEPRECATED_USE_GENERIC_DUMMY_FRAMES
operator|&&
name|DEPRECATED_PC_IN_CALL_DUMMY
argument_list|(
name|get_frame_pc
argument_list|(
name|fi
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* If the new frame pointer is zero, then it isn't valid.  */
if|if
condition|(
name|fp
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* If the new frame would be inside (younger than) the previous frame,      then it isn't valid.  */
if|if
condition|(
name|INNER_THAN
argument_list|(
name|fp
argument_list|,
name|get_frame_base
argument_list|(
name|fi
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* If the architecture has a custom DEPRECATED_FRAME_CHAIN_VALID,      call it now.  */
if|if
condition|(
name|DEPRECATED_FRAME_CHAIN_VALID_P
argument_list|()
condition|)
return|return
name|DEPRECATED_FRAME_CHAIN_VALID
argument_list|(
name|fp
argument_list|,
name|fi
argument_list|)
return|;
comment|/* If we're already inside the entry function for the main objfile, then it      isn't valid.  */
if|if
condition|(
name|legacy_inside_entry_func
argument_list|(
name|get_frame_pc
argument_list|(
name|fi
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* If we're inside the entry file, it isn't valid.  */
comment|/* NOTE/drow 2002-12-25: should there be a way to disable this check?  It      assumes a single small entry file, and the way some debug readers (e.g.      dbxread) figure out which object is the entry file is somewhat hokey.  */
if|if
condition|(
name|deprecated_inside_entry_file
argument_list|(
name|frame_pc_unwind
argument_list|(
name|fi
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

end_unit

