begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Get info from stack frames;    convert between frames, blocks, functions and pc values.    Copyright 1986, 87, 88, 89, 91, 94, 95, 96, 97, 1998              Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_comment
comment|/* for read_register */
end_comment

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_comment
comment|/* for target_has_stack */
end_comment

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_comment
comment|/* for read_pc */
end_comment

begin_include
include|#
directive|include
file|"annotate.h"
end_include

begin_comment
comment|/* Prototypes for exported functions. */
end_comment

begin_decl_stmt
name|void
name|_initialize_blockframe
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A default FRAME_CHAIN_VALID, in the form that is suitable for most    targets.  If FRAME_CHAIN_VALID returns zero it means that the given    frame is the outermost one and has no caller. */
end_comment

begin_function
name|int
name|default_frame_chain_valid
parameter_list|(
name|chain
parameter_list|,
name|thisframe
parameter_list|)
name|CORE_ADDR
name|chain
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|thisframe
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|chain
operator|)
operator|!=
literal|0
operator|&&
operator|!
name|inside_main_func
argument_list|(
operator|(
name|thisframe
operator|)
operator|->
name|pc
argument_list|)
operator|&&
operator|!
name|inside_entry_func
argument_list|(
operator|(
name|thisframe
operator|)
operator|->
name|pc
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Use the alternate method of avoiding running up off the end of the    frame chain or following frames back into the startup code.  See    the comments in objfiles.h. */
end_comment

begin_function
name|int
name|alternate_frame_chain_valid
parameter_list|(
name|chain
parameter_list|,
name|thisframe
parameter_list|)
name|CORE_ADDR
name|chain
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|thisframe
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|chain
operator|)
operator|!=
literal|0
operator|&&
operator|!
name|inside_entry_file
argument_list|(
name|FRAME_SAVED_PC
argument_list|(
name|thisframe
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* A very simple method of determining a valid frame */
end_comment

begin_function
name|int
name|nonnull_frame_chain_valid
parameter_list|(
name|chain
parameter_list|,
name|thisframe
parameter_list|)
name|CORE_ADDR
name|chain
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|thisframe
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|chain
operator|)
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Is ADDR inside the startup file?  Note that if your machine    has a way to detect the bottom of the stack, there is no need    to call this function from FRAME_CHAIN_VALID; the reason for    doing so is that some machines have no way of detecting bottom    of stack.      A PC of zero is always considered to be the bottom of the stack. */
end_comment

begin_function
name|int
name|inside_entry_file
parameter_list|(
name|addr
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
block|{
if|if
condition|(
name|addr
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|symfile_objfile
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|#
directive|if
name|CALL_DUMMY_LOCATION
operator|==
name|AT_ENTRY_POINT
comment|/* Do not stop backtracing if the pc is in the call dummy      at the entry point.  */
comment|/* FIXME: Won't always work with zeros for the last two arguments */
if|if
condition|(
name|PC_IN_CALL_DUMMY
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
return|return
operator|(
name|addr
operator|>=
name|symfile_objfile
operator|->
name|ei
operator|.
name|entry_file_lowpc
operator|&&
name|addr
operator|<
name|symfile_objfile
operator|->
name|ei
operator|.
name|entry_file_highpc
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Test a specified PC value to see if it is in the range of addresses    that correspond to the main() function.  See comments above for why    we might want to do this.     Typically called from FRAME_CHAIN_VALID.     A PC of zero is always considered to be the bottom of the stack. */
end_comment

begin_function
name|int
name|inside_main_func
parameter_list|(
name|pc
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
block|{
if|if
condition|(
name|pc
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|symfile_objfile
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* If the addr range is not set up at symbol reading time, set it up now.      This is for FRAME_CHAIN_VALID_ALTERNATE. I do this for coff, because      it is unable to set it up and symbol reading time. */
if|if
condition|(
name|symfile_objfile
operator|->
name|ei
operator|.
name|main_func_lowpc
operator|==
name|INVALID_ENTRY_LOWPC
operator|&&
name|symfile_objfile
operator|->
name|ei
operator|.
name|main_func_highpc
operator|==
name|INVALID_ENTRY_HIGHPC
condition|)
block|{
name|struct
name|symbol
modifier|*
name|mainsym
decl_stmt|;
name|mainsym
operator|=
name|lookup_symbol
argument_list|(
literal|"main"
argument_list|,
name|NULL
argument_list|,
name|VAR_NAMESPACE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mainsym
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|mainsym
argument_list|)
operator|==
name|LOC_BLOCK
condition|)
block|{
name|symfile_objfile
operator|->
name|ei
operator|.
name|main_func_lowpc
operator|=
name|BLOCK_START
argument_list|(
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|mainsym
argument_list|)
argument_list|)
expr_stmt|;
name|symfile_objfile
operator|->
name|ei
operator|.
name|main_func_highpc
operator|=
name|BLOCK_END
argument_list|(
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|mainsym
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|symfile_objfile
operator|->
name|ei
operator|.
name|main_func_lowpc
operator|<=
name|pc
operator|&&
name|symfile_objfile
operator|->
name|ei
operator|.
name|main_func_highpc
operator|>
name|pc
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Test a specified PC value to see if it is in the range of addresses    that correspond to the process entry point function.  See comments    in objfiles.h for why we might want to do this.     Typically called from FRAME_CHAIN_VALID.     A PC of zero is always considered to be the bottom of the stack. */
end_comment

begin_function
name|int
name|inside_entry_func
parameter_list|(
name|pc
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
block|{
if|if
condition|(
name|pc
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|symfile_objfile
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|#
directive|if
name|CALL_DUMMY_LOCATION
operator|==
name|AT_ENTRY_POINT
comment|/* Do not stop backtracing if the pc is in the call dummy      at the entry point.  */
comment|/* FIXME: Won't always work with zeros for the last two arguments */
if|if
condition|(
name|PC_IN_CALL_DUMMY
argument_list|(
name|pc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
return|return
operator|(
name|symfile_objfile
operator|->
name|ei
operator|.
name|entry_func_lowpc
operator|<=
name|pc
operator|&&
name|symfile_objfile
operator|->
name|ei
operator|.
name|entry_func_highpc
operator|>
name|pc
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Info about the innermost stack frame (contents of FP register) */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|frame_info
modifier|*
name|current_frame
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Cache for frame addresses already read by gdb.  Valid only while    inferior is stopped.  Control variables for the frame cache should    be local to this module.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|frame_cache_obstack
decl_stmt|;
end_decl_stmt

begin_function
name|void
modifier|*
name|frame_obstack_alloc
parameter_list|(
name|size
parameter_list|)
name|unsigned
name|long
name|size
decl_stmt|;
block|{
return|return
name|obstack_alloc
argument_list|(
operator|&
name|frame_cache_obstack
argument_list|,
name|size
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|frame_saved_regs_zalloc
parameter_list|(
name|fi
parameter_list|)
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
block|{
name|fi
operator|->
name|saved_regs
operator|=
operator|(
name|CORE_ADDR
operator|*
operator|)
name|frame_obstack_alloc
argument_list|(
name|SIZEOF_FRAME_SAVED_REGS
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|fi
operator|->
name|saved_regs
argument_list|,
literal|0
argument_list|,
name|SIZEOF_FRAME_SAVED_REGS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the innermost (currently executing) stack frame.  */
end_comment

begin_function
name|struct
name|frame_info
modifier|*
name|get_current_frame
parameter_list|()
block|{
if|if
condition|(
name|current_frame
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|target_has_stack
condition|)
name|current_frame
operator|=
name|create_new_frame
argument_list|(
name|read_fp
argument_list|()
argument_list|,
name|read_pc
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"No stack."
argument_list|)
expr_stmt|;
block|}
return|return
name|current_frame
return|;
block|}
end_function

begin_function
name|void
name|set_current_frame
parameter_list|(
name|frame
parameter_list|)
name|struct
name|frame_info
modifier|*
name|frame
decl_stmt|;
block|{
name|current_frame
operator|=
name|frame
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create an arbitrary (i.e. address specified by user) or innermost frame.    Always returns a non-NULL value.  */
end_comment

begin_function
name|struct
name|frame_info
modifier|*
name|create_new_frame
parameter_list|(
name|addr
parameter_list|,
name|pc
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
name|CORE_ADDR
name|pc
decl_stmt|;
block|{
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|fi
operator|=
operator|(
expr|struct
name|frame_info
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|frame_cache_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|frame_info
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Arbitrary frame */
name|fi
operator|->
name|saved_regs
operator|=
name|NULL
expr_stmt|;
name|fi
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|fi
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
name|fi
operator|->
name|frame
operator|=
name|addr
expr_stmt|;
name|fi
operator|->
name|pc
operator|=
name|pc
expr_stmt|;
name|find_pc_partial_function
argument_list|(
name|pc
argument_list|,
operator|&
name|name
argument_list|,
operator|(
name|CORE_ADDR
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|CORE_ADDR
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|fi
operator|->
name|signal_handler_caller
operator|=
name|IN_SIGTRAMP
argument_list|(
name|fi
operator|->
name|pc
argument_list|,
name|name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INIT_EXTRA_FRAME_INFO
name|INIT_EXTRA_FRAME_INFO
argument_list|(
literal|0
argument_list|,
name|fi
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|fi
return|;
block|}
end_function

begin_comment
comment|/* Return the frame that called FI.    If FI is the original frame (it has no caller), return 0.  */
end_comment

begin_function
name|struct
name|frame_info
modifier|*
name|get_prev_frame
parameter_list|(
name|frame
parameter_list|)
name|struct
name|frame_info
modifier|*
name|frame
decl_stmt|;
block|{
return|return
name|get_prev_frame_info
argument_list|(
name|frame
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the frame that FRAME calls (NULL if FRAME is the innermost    frame).  */
end_comment

begin_function
name|struct
name|frame_info
modifier|*
name|get_next_frame
parameter_list|(
name|frame
parameter_list|)
name|struct
name|frame_info
modifier|*
name|frame
decl_stmt|;
block|{
return|return
name|frame
operator|->
name|next
return|;
block|}
end_function

begin_comment
comment|/* Flush the entire frame cache.  */
end_comment

begin_function
name|void
name|flush_cached_frames
parameter_list|()
block|{
comment|/* Since we can't really be sure what the first object allocated was */
name|obstack_free
argument_list|(
operator|&
name|frame_cache_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|obstack_init
argument_list|(
operator|&
name|frame_cache_obstack
argument_list|)
expr_stmt|;
name|current_frame
operator|=
name|NULL
expr_stmt|;
comment|/* Invalidate cache */
name|select_frame
argument_list|(
name|NULL
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|annotate_frames_invalid
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Flush the frame cache, and start a new one if necessary.  */
end_comment

begin_function
name|void
name|reinit_frame_cache
parameter_list|()
block|{
name|flush_cached_frames
argument_list|()
expr_stmt|;
comment|/* FIXME: The inferior_pid test is wrong if there is a corefile.  */
if|if
condition|(
name|inferior_pid
operator|!=
literal|0
condition|)
block|{
name|select_frame
argument_list|(
name|get_current_frame
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* If a machine allows frameless functions, it should define a macro    FRAMELESS_FUNCTION_INVOCATION(FI, FRAMELESS) in param.h.  FI is the struct    frame_info for the frame, and FRAMELESS should be set to nonzero    if it represents a frameless function invocation.  */
end_comment

begin_comment
comment|/* Return nonzero if the function for this frame lacks a prologue.  Many    machines can define FRAMELESS_FUNCTION_INVOCATION to just call this    function.  */
end_comment

begin_function
name|int
name|frameless_look_for_prologue
parameter_list|(
name|frame
parameter_list|)
name|struct
name|frame_info
modifier|*
name|frame
decl_stmt|;
block|{
name|CORE_ADDR
name|func_start
decl_stmt|,
name|after_prologue
decl_stmt|;
name|func_start
operator|=
name|get_pc_function_start
argument_list|(
name|frame
operator|->
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|func_start
condition|)
block|{
name|func_start
operator|+=
name|FUNCTION_START_OFFSET
expr_stmt|;
name|after_prologue
operator|=
name|func_start
expr_stmt|;
ifdef|#
directive|ifdef
name|SKIP_PROLOGUE_FRAMELESS_P
comment|/* This is faster, since only care whether there *is* a prologue, 	 not how long it is.  */
name|SKIP_PROLOGUE_FRAMELESS_P
argument_list|(
name|after_prologue
argument_list|)
expr_stmt|;
else|#
directive|else
name|SKIP_PROLOGUE
argument_list|(
name|after_prologue
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|after_prologue
operator|==
name|func_start
return|;
block|}
elseif|else
if|if
condition|(
name|frame
operator|->
name|pc
operator|==
literal|0
condition|)
comment|/* A frame with a zero PC is usually created by dereferencing a NULL        function pointer, normally causing an immediate core dump of the        inferior. Mark function as frameless, as the inferior has no chance        of setting up a stack frame.  */
return|return
literal|1
return|;
else|else
comment|/* If we can't find the start of the function, we don't really        know whether the function is frameless, but we should be able        to get a reasonable (i.e. best we can do under the        circumstances) backtrace by saying that it isn't.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Default a few macros that people seldom redefine.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|INIT_FRAME_PC
argument_list|)
end_if

begin_define
define|#
directive|define
name|INIT_FRAME_PC
parameter_list|(
name|fromleaf
parameter_list|,
name|prev
parameter_list|)
define|\
value|prev->pc = (fromleaf ? SAVED_PC_AFTER_CALL (prev->next) : \ 	      prev->next ? FRAME_SAVED_PC (prev->next) : read_pc ());
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|FRAME_CHAIN_COMBINE
end_ifndef

begin_define
define|#
directive|define
name|FRAME_CHAIN_COMBINE
parameter_list|(
name|chain
parameter_list|,
name|thisframe
parameter_list|)
value|(chain)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Return a structure containing various interesting information    about the frame that called NEXT_FRAME.  Returns NULL    if there is no such frame.  */
end_comment

begin_function
name|struct
name|frame_info
modifier|*
name|get_prev_frame_info
parameter_list|(
name|next_frame
parameter_list|)
name|struct
name|frame_info
modifier|*
name|next_frame
decl_stmt|;
block|{
name|CORE_ADDR
name|address
init|=
literal|0
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|prev
decl_stmt|;
name|int
name|fromleaf
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
comment|/* If the requested entry is in the cache, return it.      Otherwise, figure out what the address should be for the entry      we're about to add to the cache. */
if|if
condition|(
operator|!
name|next_frame
condition|)
block|{
if|#
directive|if
literal|0
comment|/* This screws value_of_variable, which just wants a nice clean 	 NULL return from block_innermost_frame if there are no frames. 	 I don't think I've ever seen this message happen otherwise. 	 And returning NULL here is a perfectly legitimate thing to do.  */
block|if (!current_frame) 	{ 	  error ("You haven't set up a process's stack to examine."); 	}
endif|#
directive|endif
return|return
name|current_frame
return|;
block|}
comment|/* If we have the prev one, return it */
if|if
condition|(
name|next_frame
operator|->
name|prev
condition|)
return|return
name|next_frame
operator|->
name|prev
return|;
comment|/* On some machines it is possible to call a function without      setting up a stack frame for it.  On these machines, we      define this macro to take two args; a frameinfo pointer      identifying a frame and a variable to set or clear if it is      or isn't leafless.  */
ifdef|#
directive|ifdef
name|FRAMELESS_FUNCTION_INVOCATION
comment|/* Still don't want to worry about this except on the innermost      frame.  This macro will set FROMLEAF if NEXT_FRAME is a      frameless function invocation.  */
if|if
condition|(
operator|!
operator|(
name|next_frame
operator|->
name|next
operator|)
condition|)
block|{
name|FRAMELESS_FUNCTION_INVOCATION
argument_list|(
name|next_frame
argument_list|,
name|fromleaf
argument_list|)
expr_stmt|;
if|if
condition|(
name|fromleaf
condition|)
name|address
operator|=
name|FRAME_FP
argument_list|(
name|next_frame
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|fromleaf
condition|)
block|{
comment|/* Two macros defined in tm.h specify the machine-dependent 	 actions to be performed here. 	 First, get the frame's chain-pointer. 	 If that is zero, the frame is the outermost frame or a leaf 	 called by the outermost frame.  This means that if start 	 calls main without a frame, we'll return 0 (which is fine 	 anyway).  	 Nope; there's a problem.  This also returns when the current 	 routine is a leaf of main.  This is unacceptable.  We move 	 this to after the ffi test; I'd rather have backtraces from 	 start go curfluy than have an abort called from main not show 	 main.  */
name|address
operator|=
name|FRAME_CHAIN
argument_list|(
name|next_frame
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|FRAME_CHAIN_VALID
argument_list|(
name|address
argument_list|,
name|next_frame
argument_list|)
condition|)
return|return
literal|0
return|;
name|address
operator|=
name|FRAME_CHAIN_COMBINE
argument_list|(
name|address
argument_list|,
name|next_frame
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|address
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|prev
operator|=
operator|(
expr|struct
name|frame_info
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|frame_cache_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|frame_info
argument_list|)
argument_list|)
expr_stmt|;
name|prev
operator|->
name|saved_regs
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|next_frame
condition|)
name|next_frame
operator|->
name|prev
operator|=
name|prev
expr_stmt|;
name|prev
operator|->
name|next
operator|=
name|next_frame
expr_stmt|;
name|prev
operator|->
name|prev
operator|=
operator|(
expr|struct
name|frame_info
operator|*
operator|)
literal|0
expr_stmt|;
name|prev
operator|->
name|frame
operator|=
name|address
expr_stmt|;
name|prev
operator|->
name|signal_handler_caller
operator|=
literal|0
expr_stmt|;
comment|/* This change should not be needed, FIXME!  We should    determine whether any targets *need* INIT_FRAME_PC to happen    after INIT_EXTRA_FRAME_INFO and come up with a simple way to    express what goes on here.        INIT_EXTRA_FRAME_INFO is called from two places: create_new_frame       		(where the PC is already set up) and here (where it isn't).       INIT_FRAME_PC is only called from here, always after       		INIT_EXTRA_FRAME_INFO.        The catch is the MIPS, where INIT_EXTRA_FRAME_INFO requires the PC    value (which hasn't been set yet).  Some other machines appear to    require INIT_EXTRA_FRAME_INFO before they can do INIT_FRAME_PC.  Phoo.     We shouldn't need INIT_FRAME_PC_FIRST to add more complication to    an already overcomplicated part of GDB.   gnu@cygnus.com, 15Sep92.     Assuming that some machines need INIT_FRAME_PC after    INIT_EXTRA_FRAME_INFO, one possible scheme:     SETUP_INNERMOST_FRAME()      Default version is just create_new_frame (read_fp ()),      read_pc ()).  Machines with extra frame info would do that (or the      local equivalent) and then set the extra fields.    SETUP_ARBITRARY_FRAME(argc, argv)      Only change here is that create_new_frame would no longer init extra      frame info; SETUP_ARBITRARY_FRAME would have to do that.    INIT_PREV_FRAME(fromleaf, prev)      Replace INIT_EXTRA_FRAME_INFO and INIT_FRAME_PC.  This should      also return a flag saying whether to keep the new frame, or      whether to discard it, because on some machines (e.g.  mips) it      is really awkward to have FRAME_CHAIN_VALID called *before*      INIT_EXTRA_FRAME_INFO (there is no good way to get information      deduced in FRAME_CHAIN_VALID into the extra fields of the new frame).    std_frame_pc(fromleaf, prev)      This is the default setting for INIT_PREV_FRAME.  It just does what      the default INIT_FRAME_PC does.  Some machines will call it from      INIT_PREV_FRAME (either at the beginning, the end, or in the middle).      Some machines won't use it.    kingdon@cygnus.com, 13Apr93, 31Jan94, 14Dec94.  */
ifdef|#
directive|ifdef
name|INIT_FRAME_PC_FIRST
name|INIT_FRAME_PC_FIRST
argument_list|(
name|fromleaf
argument_list|,
name|prev
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INIT_EXTRA_FRAME_INFO
name|INIT_EXTRA_FRAME_INFO
argument_list|(
name|fromleaf
argument_list|,
name|prev
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* This entry is in the frame queue now, which is good since      FRAME_SAVED_PC may use that queue to figure out its value      (see tm-sparc.h).  We want the pc saved in the inferior frame. */
name|INIT_FRAME_PC
argument_list|(
name|fromleaf
argument_list|,
name|prev
argument_list|)
expr_stmt|;
comment|/* If ->frame and ->pc are unchanged, we are in the process of getting      ourselves into an infinite backtrace.  Some architectures check this      in FRAME_CHAIN or thereabouts, but it seems like there is no reason      this can't be an architecture-independent check.  */
if|if
condition|(
name|next_frame
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|prev
operator|->
name|frame
operator|==
name|next_frame
operator|->
name|frame
operator|&&
name|prev
operator|->
name|pc
operator|==
name|next_frame
operator|->
name|pc
condition|)
block|{
name|next_frame
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|frame_cache_obstack
argument_list|,
name|prev
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
name|find_pc_partial_function
argument_list|(
name|prev
operator|->
name|pc
argument_list|,
operator|&
name|name
argument_list|,
operator|(
name|CORE_ADDR
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|CORE_ADDR
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|IN_SIGTRAMP
argument_list|(
name|prev
operator|->
name|pc
argument_list|,
name|name
argument_list|)
condition|)
name|prev
operator|->
name|signal_handler_caller
operator|=
literal|1
expr_stmt|;
return|return
name|prev
return|;
block|}
end_function

begin_function
name|CORE_ADDR
name|get_frame_pc
parameter_list|(
name|frame
parameter_list|)
name|struct
name|frame_info
modifier|*
name|frame
decl_stmt|;
block|{
return|return
name|frame
operator|->
name|pc
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|FRAME_FIND_SAVED_REGS
end_ifdef

begin_comment
comment|/* XXX - deprecated.  This is a compatibility function for targets    that do not yet implement FRAME_INIT_SAVED_REGS.  */
end_comment

begin_comment
comment|/* Find the addresses in which registers are saved in FRAME.  */
end_comment

begin_function
name|void
name|get_frame_saved_regs
parameter_list|(
name|frame
parameter_list|,
name|saved_regs_addr
parameter_list|)
name|struct
name|frame_info
modifier|*
name|frame
decl_stmt|;
name|struct
name|frame_saved_regs
modifier|*
name|saved_regs_addr
decl_stmt|;
block|{
if|if
condition|(
name|frame
operator|->
name|saved_regs
operator|==
name|NULL
condition|)
block|{
name|frame
operator|->
name|saved_regs
operator|=
operator|(
name|CORE_ADDR
operator|*
operator|)
name|frame_obstack_alloc
argument_list|(
name|SIZEOF_FRAME_SAVED_REGS
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|saved_regs_addr
operator|==
name|NULL
condition|)
block|{
name|struct
name|frame_saved_regs
name|saved_regs
decl_stmt|;
name|FRAME_FIND_SAVED_REGS
argument_list|(
name|frame
argument_list|,
name|saved_regs
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|frame
operator|->
name|saved_regs
argument_list|,
operator|&
name|saved_regs
argument_list|,
name|SIZEOF_FRAME_SAVED_REGS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|FRAME_FIND_SAVED_REGS
argument_list|(
name|frame
argument_list|,
operator|*
name|saved_regs_addr
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|frame
operator|->
name|saved_regs
argument_list|,
name|saved_regs_addr
argument_list|,
name|SIZEOF_FRAME_SAVED_REGS
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Return the innermost lexical block in execution    in a specified stack frame.  The frame address is assumed valid.  */
end_comment

begin_function
name|struct
name|block
modifier|*
name|get_frame_block
parameter_list|(
name|frame
parameter_list|)
name|struct
name|frame_info
modifier|*
name|frame
decl_stmt|;
block|{
name|CORE_ADDR
name|pc
decl_stmt|;
name|pc
operator|=
name|frame
operator|->
name|pc
expr_stmt|;
if|if
condition|(
name|frame
operator|->
name|next
operator|!=
literal|0
operator|&&
name|frame
operator|->
name|next
operator|->
name|signal_handler_caller
operator|==
literal|0
condition|)
comment|/* We are not in the innermost frame and we were not interrupted        by a signal.  We need to subtract one to get the correct block,        in case the call instruction was the last instruction of the block.        If there are any machines on which the saved pc does not point to        after the call insn, we probably want to make frame->pc point after        the call insn anyway.  */
operator|--
name|pc
expr_stmt|;
return|return
name|block_for_pc
argument_list|(
name|pc
argument_list|)
return|;
block|}
end_function

begin_function
name|struct
name|block
modifier|*
name|get_current_block
parameter_list|()
block|{
return|return
name|block_for_pc
argument_list|(
name|read_pc
argument_list|()
argument_list|)
return|;
block|}
end_function

begin_function
name|CORE_ADDR
name|get_pc_function_start
parameter_list|(
name|pc
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
block|{
specifier|register
name|struct
name|block
modifier|*
name|bl
decl_stmt|;
specifier|register
name|struct
name|symbol
modifier|*
name|symbol
decl_stmt|;
specifier|register
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
name|CORE_ADDR
name|fstart
decl_stmt|;
if|if
condition|(
operator|(
name|bl
operator|=
name|block_for_pc
argument_list|(
name|pc
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|(
name|symbol
operator|=
name|block_function
argument_list|(
name|bl
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|bl
operator|=
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
name|fstart
operator|=
name|BLOCK_START
argument_list|(
name|bl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|msymbol
operator|=
name|lookup_minimal_symbol_by_pc
argument_list|(
name|pc
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|fstart
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fstart
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|fstart
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the symbol for the function executing in frame FRAME.  */
end_comment

begin_function
name|struct
name|symbol
modifier|*
name|get_frame_function
parameter_list|(
name|frame
parameter_list|)
name|struct
name|frame_info
modifier|*
name|frame
decl_stmt|;
block|{
specifier|register
name|struct
name|block
modifier|*
name|bl
init|=
name|get_frame_block
argument_list|(
name|frame
argument_list|)
decl_stmt|;
if|if
condition|(
name|bl
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|block_function
argument_list|(
name|bl
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the blockvector immediately containing the innermost lexical block    containing the specified pc value and section, or 0 if there is none.    PINDEX is a pointer to the index value of the block.  If PINDEX    is NULL, we don't pass this information back to the caller.  */
end_comment

begin_function
name|struct
name|blockvector
modifier|*
name|blockvector_for_pc_sect
parameter_list|(
name|pc
parameter_list|,
name|section
parameter_list|,
name|pindex
parameter_list|,
name|symtab
parameter_list|)
specifier|register
name|CORE_ADDR
name|pc
decl_stmt|;
name|struct
name|sec
modifier|*
name|section
decl_stmt|;
name|int
modifier|*
name|pindex
decl_stmt|;
name|struct
name|symtab
modifier|*
name|symtab
decl_stmt|;
block|{
specifier|register
name|struct
name|block
modifier|*
name|b
decl_stmt|;
specifier|register
name|int
name|bot
decl_stmt|,
name|top
decl_stmt|,
name|half
decl_stmt|;
name|struct
name|blockvector
modifier|*
name|bl
decl_stmt|;
if|if
condition|(
name|symtab
operator|==
literal|0
condition|)
comment|/* if no symtab specified by caller */
block|{
comment|/* First search all symtabs for one whose file contains our pc */
if|if
condition|(
operator|(
name|symtab
operator|=
name|find_pc_sect_symtab
argument_list|(
name|pc
argument_list|,
name|section
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
name|bl
operator|=
name|BLOCKVECTOR
argument_list|(
name|symtab
argument_list|)
expr_stmt|;
name|b
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Then search that symtab for the smallest block that wins.  */
comment|/* Use binary search to find the last block that starts before PC.  */
name|bot
operator|=
literal|0
expr_stmt|;
name|top
operator|=
name|BLOCKVECTOR_NBLOCKS
argument_list|(
name|bl
argument_list|)
expr_stmt|;
while|while
condition|(
name|top
operator|-
name|bot
operator|>
literal|1
condition|)
block|{
name|half
operator|=
operator|(
name|top
operator|-
name|bot
operator|+
literal|1
operator|)
operator|>>
literal|1
expr_stmt|;
name|b
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bl
argument_list|,
name|bot
operator|+
name|half
argument_list|)
expr_stmt|;
if|if
condition|(
name|BLOCK_START
argument_list|(
name|b
argument_list|)
operator|<=
name|pc
condition|)
name|bot
operator|+=
name|half
expr_stmt|;
else|else
name|top
operator|=
name|bot
operator|+
name|half
expr_stmt|;
block|}
comment|/* Now search backward for a block that ends after PC.  */
while|while
condition|(
name|bot
operator|>=
literal|0
condition|)
block|{
name|b
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bl
argument_list|,
name|bot
argument_list|)
expr_stmt|;
if|if
condition|(
name|BLOCK_END
argument_list|(
name|b
argument_list|)
operator|>=
name|pc
condition|)
block|{
if|if
condition|(
name|pindex
condition|)
operator|*
name|pindex
operator|=
name|bot
expr_stmt|;
return|return
name|bl
return|;
block|}
name|bot
operator|--
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return the blockvector immediately containing the innermost lexical block    containing the specified pc value, or 0 if there is none.    Backward compatibility, no section.  */
end_comment

begin_function
name|struct
name|blockvector
modifier|*
name|blockvector_for_pc
parameter_list|(
name|pc
parameter_list|,
name|pindex
parameter_list|)
specifier|register
name|CORE_ADDR
name|pc
decl_stmt|;
name|int
modifier|*
name|pindex
decl_stmt|;
block|{
return|return
name|blockvector_for_pc_sect
argument_list|(
name|pc
argument_list|,
name|find_pc_mapped_section
argument_list|(
name|pc
argument_list|)
argument_list|,
name|pindex
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the innermost lexical block containing the specified pc value    in the specified section, or 0 if there is none.  */
end_comment

begin_function
name|struct
name|block
modifier|*
name|block_for_pc_sect
parameter_list|(
name|pc
parameter_list|,
name|section
parameter_list|)
specifier|register
name|CORE_ADDR
name|pc
decl_stmt|;
name|struct
name|sec
modifier|*
name|section
decl_stmt|;
block|{
specifier|register
name|struct
name|blockvector
modifier|*
name|bl
decl_stmt|;
name|int
name|index
decl_stmt|;
name|bl
operator|=
name|blockvector_for_pc_sect
argument_list|(
name|pc
argument_list|,
name|section
argument_list|,
operator|&
name|index
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|bl
condition|)
return|return
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bl
argument_list|,
name|index
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return the innermost lexical block containing the specified pc value,    or 0 if there is none.  Backward compatibility, no section.  */
end_comment

begin_function
name|struct
name|block
modifier|*
name|block_for_pc
parameter_list|(
name|pc
parameter_list|)
specifier|register
name|CORE_ADDR
name|pc
decl_stmt|;
block|{
return|return
name|block_for_pc_sect
argument_list|(
name|pc
argument_list|,
name|find_pc_mapped_section
argument_list|(
name|pc
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the function containing pc value PC in section SECTION.    Returns 0 if function is not known.  */
end_comment

begin_function
name|struct
name|symbol
modifier|*
name|find_pc_sect_function
parameter_list|(
name|pc
parameter_list|,
name|section
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
name|struct
name|sec
modifier|*
name|section
decl_stmt|;
block|{
specifier|register
name|struct
name|block
modifier|*
name|b
init|=
name|block_for_pc_sect
argument_list|(
name|pc
argument_list|,
name|section
argument_list|)
decl_stmt|;
if|if
condition|(
name|b
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|block_function
argument_list|(
name|b
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the function containing pc value PC.    Returns 0 if function is not known.  Backward compatibility, no section */
end_comment

begin_function
name|struct
name|symbol
modifier|*
name|find_pc_function
parameter_list|(
name|pc
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
block|{
return|return
name|find_pc_sect_function
argument_list|(
name|pc
argument_list|,
name|find_pc_mapped_section
argument_list|(
name|pc
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* These variables are used to cache the most recent result  * of find_pc_partial_function. */
end_comment

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|cache_pc_function_low
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|cache_pc_function_high
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|cache_pc_function_name
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|sec
modifier|*
name|cache_pc_function_section
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Clear cache, e.g. when symbol table is discarded. */
end_comment

begin_function
name|void
name|clear_pc_function_cache
parameter_list|()
block|{
name|cache_pc_function_low
operator|=
literal|0
expr_stmt|;
name|cache_pc_function_high
operator|=
literal|0
expr_stmt|;
name|cache_pc_function_name
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
name|cache_pc_function_section
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finds the "function" (text symbol) that is smaller than PC but    greatest of all of the potential text symbols in SECTION.  Sets    *NAME and/or *ADDRESS conditionally if that pointer is non-null.    If ENDADDR is non-null, then set *ENDADDR to be the end of the    function (exclusive), but passing ENDADDR as non-null means that    the function might cause symbols to be read.  This function either    succeeds or fails (not halfway succeeds).  If it succeeds, it sets    *NAME, *ADDRESS, and *ENDADDR to real information and returns 1.    If it fails, it sets *NAME, *ADDRESS, and *ENDADDR to zero and    returns 0.  */
end_comment

begin_function
name|int
name|find_pc_sect_partial_function
parameter_list|(
name|pc
parameter_list|,
name|section
parameter_list|,
name|name
parameter_list|,
name|address
parameter_list|,
name|endaddr
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|char
modifier|*
modifier|*
name|name
decl_stmt|;
name|CORE_ADDR
modifier|*
name|address
decl_stmt|;
name|CORE_ADDR
modifier|*
name|endaddr
decl_stmt|;
block|{
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
name|struct
name|symbol
modifier|*
name|f
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
name|struct
name|partial_symbol
modifier|*
name|psb
decl_stmt|;
name|struct
name|obj_section
modifier|*
name|osect
decl_stmt|;
name|int
name|i
decl_stmt|;
name|CORE_ADDR
name|mapped_pc
decl_stmt|;
name|mapped_pc
operator|=
name|overlay_mapped_address
argument_list|(
name|pc
argument_list|,
name|section
argument_list|)
expr_stmt|;
if|if
condition|(
name|mapped_pc
operator|>=
name|cache_pc_function_low
operator|&&
name|mapped_pc
operator|<
name|cache_pc_function_high
operator|&&
name|section
operator|==
name|cache_pc_function_section
condition|)
goto|goto
name|return_cached_value
goto|;
comment|/* If sigtramp is in the u area, it counts as a function (especially      important for step_1).  */
if|#
directive|if
name|defined
name|SIGTRAMP_START
if|if
condition|(
name|IN_SIGTRAMP
argument_list|(
name|mapped_pc
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
condition|)
block|{
name|cache_pc_function_low
operator|=
name|SIGTRAMP_START
argument_list|(
name|mapped_pc
argument_list|)
expr_stmt|;
name|cache_pc_function_high
operator|=
name|SIGTRAMP_END
argument_list|(
name|mapped_pc
argument_list|)
expr_stmt|;
name|cache_pc_function_name
operator|=
literal|"<sigtramp>"
expr_stmt|;
name|cache_pc_function_section
operator|=
name|section
expr_stmt|;
goto|goto
name|return_cached_value
goto|;
block|}
endif|#
directive|endif
name|msymbol
operator|=
name|lookup_minimal_symbol_by_pc_section
argument_list|(
name|mapped_pc
argument_list|,
name|section
argument_list|)
expr_stmt|;
name|pst
operator|=
name|find_pc_sect_psymtab
argument_list|(
name|mapped_pc
argument_list|,
name|section
argument_list|)
expr_stmt|;
if|if
condition|(
name|pst
condition|)
block|{
comment|/* Need to read the symbols to get a good value for the end address.  */
if|if
condition|(
name|endaddr
operator|!=
name|NULL
operator|&&
operator|!
name|pst
operator|->
name|readin
condition|)
block|{
comment|/* Need to get the terminal in case symbol-reading produces 	     output.  */
name|target_terminal_ours_for_output
argument_list|()
expr_stmt|;
name|PSYMTAB_TO_SYMTAB
argument_list|(
name|pst
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pst
operator|->
name|readin
condition|)
block|{
comment|/* Checking whether the msymbol has a larger value is for the 	     "pathological" case mentioned in print_frame_info.  */
name|f
operator|=
name|find_pc_sect_function
argument_list|(
name|mapped_pc
argument_list|,
name|section
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|!=
name|NULL
operator|&&
operator|(
name|msymbol
operator|==
name|NULL
operator|||
operator|(
name|BLOCK_START
argument_list|(
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|f
argument_list|)
argument_list|)
operator|>=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
operator|)
operator|)
condition|)
block|{
name|cache_pc_function_low
operator|=
name|BLOCK_START
argument_list|(
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|f
argument_list|)
argument_list|)
expr_stmt|;
name|cache_pc_function_high
operator|=
name|BLOCK_END
argument_list|(
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|f
argument_list|)
argument_list|)
expr_stmt|;
name|cache_pc_function_name
operator|=
name|SYMBOL_NAME
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|cache_pc_function_section
operator|=
name|section
expr_stmt|;
goto|goto
name|return_cached_value
goto|;
block|}
block|}
else|else
block|{
comment|/* Now that static symbols go in the minimal symbol table, perhaps 	     we could just ignore the partial symbols.  But at least for now 	     we use the partial or minimal symbol, whichever is larger.  */
name|psb
operator|=
name|find_pc_sect_psymbol
argument_list|(
name|pst
argument_list|,
name|mapped_pc
argument_list|,
name|section
argument_list|)
expr_stmt|;
if|if
condition|(
name|psb
operator|&&
operator|(
name|msymbol
operator|==
name|NULL
operator|||
operator|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|psb
argument_list|)
operator|>=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
operator|)
operator|)
condition|)
block|{
comment|/* This case isn't being cached currently. */
if|if
condition|(
name|address
condition|)
operator|*
name|address
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|psb
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
operator|*
name|name
operator|=
name|SYMBOL_NAME
argument_list|(
name|psb
argument_list|)
expr_stmt|;
comment|/* endaddr non-NULL can't happen here.  */
return|return
literal|1
return|;
block|}
block|}
block|}
comment|/* Not in the normal symbol tables, see if the pc is in a known section.      If it's not, then give up.  This ensures that anything beyond the end      of the text seg doesn't appear to be part of the last function in the      text segment.  */
name|osect
operator|=
name|find_pc_sect_section
argument_list|(
name|mapped_pc
argument_list|,
name|section
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|osect
condition|)
name|msymbol
operator|=
name|NULL
expr_stmt|;
comment|/* Must be in the minimal symbol table.  */
if|if
condition|(
name|msymbol
operator|==
name|NULL
condition|)
block|{
comment|/* No available symbol.  */
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
operator|*
name|name
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|address
operator|!=
name|NULL
condition|)
operator|*
name|address
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|endaddr
operator|!=
name|NULL
condition|)
operator|*
name|endaddr
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
name|cache_pc_function_low
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
expr_stmt|;
name|cache_pc_function_name
operator|=
name|SYMBOL_NAME
argument_list|(
name|msymbol
argument_list|)
expr_stmt|;
name|cache_pc_function_section
operator|=
name|section
expr_stmt|;
comment|/* Use the lesser of the next minimal symbol in the same section, or      the end of the section, as the end of the function.  */
comment|/* Step over other symbols at this same address, and symbols in      other sections, to find the next symbol in this section with      a different address.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|SYMBOL_NAME
argument_list|(
name|msymbol
operator|+
name|i
argument_list|)
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
operator|+
name|i
argument_list|)
operator|!=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
operator|&&
name|SYMBOL_BFD_SECTION
argument_list|(
name|msymbol
operator|+
name|i
argument_list|)
operator|==
name|SYMBOL_BFD_SECTION
argument_list|(
name|msymbol
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|SYMBOL_NAME
argument_list|(
name|msymbol
operator|+
name|i
argument_list|)
operator|!=
name|NULL
operator|&&
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
operator|+
name|i
argument_list|)
operator|<
name|osect
operator|->
name|endaddr
condition|)
name|cache_pc_function_high
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
operator|+
name|i
argument_list|)
expr_stmt|;
else|else
comment|/* We got the start address from the last msymbol in the objfile.        So the end address is the end of the section.  */
name|cache_pc_function_high
operator|=
name|osect
operator|->
name|endaddr
expr_stmt|;
name|return_cached_value
label|:
if|if
condition|(
name|address
condition|)
block|{
if|if
condition|(
name|pc_in_unmapped_range
argument_list|(
name|pc
argument_list|,
name|section
argument_list|)
condition|)
operator|*
name|address
operator|=
name|overlay_unmapped_address
argument_list|(
name|cache_pc_function_low
argument_list|,
name|section
argument_list|)
expr_stmt|;
else|else
operator|*
name|address
operator|=
name|cache_pc_function_low
expr_stmt|;
block|}
if|if
condition|(
name|name
condition|)
operator|*
name|name
operator|=
name|cache_pc_function_name
expr_stmt|;
if|if
condition|(
name|endaddr
condition|)
block|{
if|if
condition|(
name|pc_in_unmapped_range
argument_list|(
name|pc
argument_list|,
name|section
argument_list|)
condition|)
block|{
comment|/* Because the high address is actually beyond the end of 	     the function (and therefore possibly beyond the end of 	     the overlay), we must actually convert (high - 1) 	     and then add one to that. */
operator|*
name|endaddr
operator|=
literal|1
operator|+
name|overlay_unmapped_address
argument_list|(
name|cache_pc_function_high
operator|-
literal|1
argument_list|,
name|section
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|endaddr
operator|=
name|cache_pc_function_high
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Backward compatibility, no section argument */
end_comment

begin_function
name|int
name|find_pc_partial_function
parameter_list|(
name|pc
parameter_list|,
name|name
parameter_list|,
name|address
parameter_list|,
name|endaddr
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
name|char
modifier|*
modifier|*
name|name
decl_stmt|;
name|CORE_ADDR
modifier|*
name|address
decl_stmt|;
name|CORE_ADDR
modifier|*
name|endaddr
decl_stmt|;
block|{
name|asection
modifier|*
name|section
decl_stmt|;
name|section
operator|=
name|find_pc_overlay
argument_list|(
name|pc
argument_list|)
expr_stmt|;
return|return
name|find_pc_sect_partial_function
argument_list|(
name|pc
argument_list|,
name|section
argument_list|,
name|name
argument_list|,
name|address
argument_list|,
name|endaddr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the innermost stack frame executing inside of BLOCK,    or NULL if there is no such frame.  If BLOCK is NULL, just return NULL.  */
end_comment

begin_function
name|struct
name|frame_info
modifier|*
name|block_innermost_frame
parameter_list|(
name|block
parameter_list|)
name|struct
name|block
modifier|*
name|block
decl_stmt|;
block|{
name|struct
name|frame_info
modifier|*
name|frame
decl_stmt|;
specifier|register
name|CORE_ADDR
name|start
decl_stmt|;
specifier|register
name|CORE_ADDR
name|end
decl_stmt|;
if|if
condition|(
name|block
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|start
operator|=
name|BLOCK_START
argument_list|(
name|block
argument_list|)
expr_stmt|;
name|end
operator|=
name|BLOCK_END
argument_list|(
name|block
argument_list|)
expr_stmt|;
name|frame
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|frame
operator|=
name|get_prev_frame
argument_list|(
name|frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|frame
operator|->
name|pc
operator|>=
name|start
operator|&&
name|frame
operator|->
name|pc
operator|<
name|end
condition|)
return|return
name|frame
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return the full FRAME which corresponds to the given CORE_ADDR    or NULL if no FRAME on the chain corresponds to CORE_ADDR.  */
end_comment

begin_function
name|struct
name|frame_info
modifier|*
name|find_frame_addr_in_frame_chain
parameter_list|(
name|frame_addr
parameter_list|)
name|CORE_ADDR
name|frame_addr
decl_stmt|;
block|{
name|struct
name|frame_info
modifier|*
name|frame
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|frame_addr
operator|==
operator|(
name|CORE_ADDR
operator|)
literal|0
condition|)
return|return
name|NULL
return|;
while|while
condition|(
literal|1
condition|)
block|{
name|frame
operator|=
name|get_prev_frame
argument_list|(
name|frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|FRAME_FP
argument_list|(
name|frame
argument_list|)
operator|==
name|frame_addr
condition|)
return|return
name|frame
return|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SIGCONTEXT_PC_OFFSET
end_ifdef

begin_comment
comment|/* Get saved user PC for sigtramp from sigcontext for BSD style sigtramp.  */
end_comment

begin_function
name|CORE_ADDR
name|sigtramp_saved_pc
parameter_list|(
name|frame
parameter_list|)
name|struct
name|frame_info
modifier|*
name|frame
decl_stmt|;
block|{
name|CORE_ADDR
name|sigcontext_addr
decl_stmt|;
name|char
name|buf
index|[
name|TARGET_PTR_BIT
operator|/
name|TARGET_CHAR_BIT
index|]
decl_stmt|;
name|int
name|ptrbytes
init|=
name|TARGET_PTR_BIT
operator|/
name|TARGET_CHAR_BIT
decl_stmt|;
name|int
name|sigcontext_offs
init|=
operator|(
literal|2
operator|*
name|TARGET_INT_BIT
operator|)
operator|/
name|TARGET_CHAR_BIT
decl_stmt|;
comment|/* Get sigcontext address, it is the third parameter on the stack.  */
if|if
condition|(
name|frame
operator|->
name|next
condition|)
name|sigcontext_addr
operator|=
name|read_memory_integer
argument_list|(
name|FRAME_ARGS_ADDRESS
argument_list|(
name|frame
operator|->
name|next
argument_list|)
operator|+
name|FRAME_ARGS_SKIP
operator|+
name|sigcontext_offs
argument_list|,
name|ptrbytes
argument_list|)
expr_stmt|;
else|else
name|sigcontext_addr
operator|=
name|read_memory_integer
argument_list|(
name|read_register
argument_list|(
name|SP_REGNUM
argument_list|)
operator|+
name|sigcontext_offs
argument_list|,
name|ptrbytes
argument_list|)
expr_stmt|;
comment|/* Don't cause a memory_error when accessing sigcontext in case the stack      layout has changed or the stack is corrupt.  */
name|target_read_memory
argument_list|(
name|sigcontext_addr
operator|+
name|SIGCONTEXT_PC_OFFSET
argument_list|,
name|buf
argument_list|,
name|ptrbytes
argument_list|)
expr_stmt|;
return|return
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
name|ptrbytes
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SIGCONTEXT_PC_OFFSET */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USE_GENERIC_DUMMY_FRAMES
end_ifdef

begin_comment
comment|/*  * GENERIC DUMMY FRAMES  *   * The following code serves to maintain the dummy stack frames for  * inferior function calls (ie. when gdb calls into the inferior via  * call_function_by_hand).  This code saves the machine state before   * the call in host memory, so we must maintain an independant stack   * and keep it consistant etc.  I am attempting to make this code   * generic enough to be used by many targets.  *  * The cheapest and most generic way to do CALL_DUMMY on a new target  * is probably to define CALL_DUMMY to be empty, CALL_DUMMY_LENGTH to  * zero, and CALL_DUMMY_LOCATION to AT_ENTRY.  Then you must remember  * to define PUSH_RETURN_ADDRESS, because no call instruction will be  * being executed by the target.  Also FRAME_CHAIN_VALID as  * generic_frame_chain_valid.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|dummy_frame
modifier|*
name|dummy_frame_stack
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function: find_dummy_frame(pc, fp, sp)    Search the stack of dummy frames for one matching the given PC, FP and SP.    This is the work-horse for pc_in_call_dummy and read_register_dummy     */
end_comment

begin_function
name|char
modifier|*
name|generic_find_dummy_frame
parameter_list|(
name|pc
parameter_list|,
name|fp
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
name|CORE_ADDR
name|fp
decl_stmt|;
block|{
name|struct
name|dummy_frame
modifier|*
name|dummyframe
decl_stmt|;
if|if
condition|(
name|pc
operator|!=
name|entry_point_address
argument_list|()
condition|)
return|return
literal|0
return|;
for|for
control|(
name|dummyframe
operator|=
name|dummy_frame_stack
init|;
name|dummyframe
operator|!=
name|NULL
condition|;
name|dummyframe
operator|=
name|dummyframe
operator|->
name|next
control|)
if|if
condition|(
name|fp
operator|==
name|dummyframe
operator|->
name|fp
operator|||
name|fp
operator|==
name|dummyframe
operator|->
name|sp
condition|)
comment|/* The frame in question lies between the saved fp and sp, inclusive */
return|return
name|dummyframe
operator|->
name|regs
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Function: pc_in_call_dummy (pc, fp)    Return true if this is a dummy frame created by gdb for an inferior call */
end_comment

begin_function
name|int
name|generic_pc_in_call_dummy
parameter_list|(
name|pc
parameter_list|,
name|fp
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
name|CORE_ADDR
name|fp
decl_stmt|;
block|{
comment|/* if find_dummy_frame succeeds, then PC is in a call dummy */
return|return
operator|(
name|generic_find_dummy_frame
argument_list|(
name|pc
argument_list|,
name|fp
argument_list|)
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Function: read_register_dummy     Find a saved register from before GDB calls a function in the inferior */
end_comment

begin_function
name|CORE_ADDR
name|generic_read_register_dummy
parameter_list|(
name|pc
parameter_list|,
name|fp
parameter_list|,
name|regno
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
name|CORE_ADDR
name|fp
decl_stmt|;
name|int
name|regno
decl_stmt|;
block|{
name|char
modifier|*
name|dummy_regs
init|=
name|generic_find_dummy_frame
argument_list|(
name|pc
argument_list|,
name|fp
argument_list|)
decl_stmt|;
if|if
condition|(
name|dummy_regs
condition|)
return|return
name|extract_address
argument_list|(
operator|&
name|dummy_regs
index|[
name|REGISTER_BYTE
argument_list|(
name|regno
argument_list|)
index|]
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
argument_list|)
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Save all the registers on the dummy frame stack.  Most ports save the    registers on the target stack.  This results in lots of unnecessary memory    references, which are slow when debugging via a serial line.  Instead, we    save all the registers internally, and never write them to the stack.  The    registers get restored when the called function returns to the entry point,    where a breakpoint is laying in wait.  */
end_comment

begin_function
name|void
name|generic_push_dummy_frame
parameter_list|()
block|{
name|struct
name|dummy_frame
modifier|*
name|dummy_frame
decl_stmt|;
name|CORE_ADDR
name|fp
init|=
operator|(
name|get_current_frame
argument_list|()
operator|)
operator|->
name|frame
decl_stmt|;
comment|/* check to see if there are stale dummy frames,       perhaps left over from when a longjump took us out of a       function that was called by the debugger */
name|dummy_frame
operator|=
name|dummy_frame_stack
expr_stmt|;
while|while
condition|(
name|dummy_frame
condition|)
if|if
condition|(
name|INNER_THAN
argument_list|(
name|dummy_frame
operator|->
name|fp
argument_list|,
name|fp
argument_list|)
condition|)
comment|/* stale -- destroy! */
block|{
name|dummy_frame_stack
operator|=
name|dummy_frame
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|dummy_frame
argument_list|)
expr_stmt|;
name|dummy_frame
operator|=
name|dummy_frame_stack
expr_stmt|;
block|}
else|else
name|dummy_frame
operator|=
name|dummy_frame
operator|->
name|next
expr_stmt|;
name|dummy_frame
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|dummy_frame
argument_list|)
argument_list|)
expr_stmt|;
name|dummy_frame
operator|->
name|pc
operator|=
name|read_register
argument_list|(
name|PC_REGNUM
argument_list|)
expr_stmt|;
name|dummy_frame
operator|->
name|sp
operator|=
name|read_register
argument_list|(
name|SP_REGNUM
argument_list|)
expr_stmt|;
name|dummy_frame
operator|->
name|fp
operator|=
name|fp
expr_stmt|;
name|read_register_bytes
argument_list|(
literal|0
argument_list|,
name|dummy_frame
operator|->
name|regs
argument_list|,
name|REGISTER_BYTES
argument_list|)
expr_stmt|;
name|dummy_frame
operator|->
name|next
operator|=
name|dummy_frame_stack
expr_stmt|;
name|dummy_frame_stack
operator|=
name|dummy_frame
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Function: pop_frame    Restore the machine state from either the saved dummy stack or a    real stack frame. */
end_comment

begin_function_decl
name|void
name|generic_pop_current_frame
parameter_list|(
name|pop
parameter_list|)
function_decl|void
parameter_list|(
function_decl|*pop
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
expr|struct
name|frame_info
operator|*
name|frame
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|frame_info
modifier|*
name|frame
init|=
name|get_current_frame
argument_list|()
decl_stmt|;
if|if
condition|(
name|PC_IN_CALL_DUMMY
argument_list|(
name|frame
operator|->
name|pc
argument_list|,
name|frame
operator|->
name|frame
argument_list|,
name|frame
operator|->
name|frame
argument_list|)
condition|)
name|generic_pop_dummy_frame
argument_list|()
expr_stmt|;
else|else
name|pop
argument_list|(
name|frame
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Function: pop_dummy_frame    Restore the machine state from a saved dummy stack frame. */
end_comment

begin_function
name|void
name|generic_pop_dummy_frame
parameter_list|()
block|{
name|struct
name|dummy_frame
modifier|*
name|dummy_frame
init|=
name|dummy_frame_stack
decl_stmt|;
comment|/* FIXME: what if the first frame isn't the right one, eg..      because one call-by-hand function has done a longjmp into another one? */
if|if
condition|(
operator|!
name|dummy_frame
condition|)
name|error
argument_list|(
literal|"Can't pop dummy frame!"
argument_list|)
expr_stmt|;
name|dummy_frame_stack
operator|=
name|dummy_frame
operator|->
name|next
expr_stmt|;
name|write_register_bytes
argument_list|(
literal|0
argument_list|,
name|dummy_frame
operator|->
name|regs
argument_list|,
name|REGISTER_BYTES
argument_list|)
expr_stmt|;
name|flush_cached_frames
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|dummy_frame
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Function: frame_chain_valid     Returns true for a user frame or a call_function_by_hand dummy frame,    and false for the CRT0 start-up frame.  Purpose is to terminate backtrace */
end_comment

begin_function
name|int
name|generic_frame_chain_valid
parameter_list|(
name|fp
parameter_list|,
name|fi
parameter_list|)
name|CORE_ADDR
name|fp
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
block|{
if|if
condition|(
name|PC_IN_CALL_DUMMY
argument_list|(
name|FRAME_SAVED_PC
argument_list|(
name|fi
argument_list|)
argument_list|,
name|fp
argument_list|,
name|fp
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* don't prune CALL_DUMMY frames */
else|else
comment|/* fall back to default algorithm (see frame.h) */
return|return
operator|(
name|fp
operator|!=
literal|0
operator|&&
operator|(
name|INNER_THAN
argument_list|(
name|fi
operator|->
name|frame
argument_list|,
name|fp
argument_list|)
operator|||
name|fi
operator|->
name|frame
operator|==
name|fp
operator|)
operator|&&
operator|!
name|inside_entry_file
argument_list|(
name|FRAME_SAVED_PC
argument_list|(
name|fi
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Function: get_saved_register    Find register number REGNUM relative to FRAME and put its (raw,    target format) contents in *RAW_BUFFER.       Set *OPTIMIZED if the variable was optimized out (and thus can't be    fetched).  Note that this is never set to anything other than zero    in this implementation.     Set *LVAL to lval_memory, lval_register, or not_lval, depending on    whether the value was fetched from memory, from a register, or in a    strange and non-modifiable way (e.g. a frame pointer which was    calculated rather than fetched).  We will use not_lval for values    fetched from generic dummy frames.     Set *ADDRP to the address, either in memory on as a REGISTER_BYTE    offset into the registers array.  If the value is stored in a dummy    frame, set *ADDRP to zero.     To use this implementation, define a function called    "get_saved_register" in your target code, which simply passes all    of its arguments to this function.     The argument RAW_BUFFER must point to aligned memory.  */
end_comment

begin_function
name|void
name|generic_get_saved_register
parameter_list|(
name|raw_buffer
parameter_list|,
name|optimized
parameter_list|,
name|addrp
parameter_list|,
name|frame
parameter_list|,
name|regnum
parameter_list|,
name|lval
parameter_list|)
name|char
modifier|*
name|raw_buffer
decl_stmt|;
name|int
modifier|*
name|optimized
decl_stmt|;
name|CORE_ADDR
modifier|*
name|addrp
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|frame
decl_stmt|;
name|int
name|regnum
decl_stmt|;
name|enum
name|lval_type
modifier|*
name|lval
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|target_has_registers
condition|)
name|error
argument_list|(
literal|"No registers."
argument_list|)
expr_stmt|;
comment|/* Normal systems don't optimize out things with register numbers.  */
if|if
condition|(
name|optimized
operator|!=
name|NULL
condition|)
operator|*
name|optimized
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|addrp
condition|)
comment|/* default assumption: not found in memory */
operator|*
name|addrp
operator|=
literal|0
expr_stmt|;
comment|/* Note: since the current frame's registers could only have been      saved by frames INTERIOR TO the current frame, we skip examining      the current frame itself: otherwise, we would be getting the      previous frame's registers which were saved by the current frame.  */
while|while
condition|(
name|frame
operator|&&
operator|(
operator|(
name|frame
operator|=
name|frame
operator|->
name|next
operator|)
operator|!=
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
name|PC_IN_CALL_DUMMY
argument_list|(
name|frame
operator|->
name|pc
argument_list|,
name|frame
operator|->
name|frame
argument_list|,
name|frame
operator|->
name|frame
argument_list|)
condition|)
block|{
if|if
condition|(
name|lval
condition|)
comment|/* found it in a CALL_DUMMY frame */
operator|*
name|lval
operator|=
name|not_lval
expr_stmt|;
if|if
condition|(
name|raw_buffer
condition|)
name|memcpy
argument_list|(
name|raw_buffer
argument_list|,
name|generic_find_dummy_frame
argument_list|(
name|frame
operator|->
name|pc
argument_list|,
name|frame
operator|->
name|frame
argument_list|)
operator|+
name|REGISTER_BYTE
argument_list|(
name|regnum
argument_list|)
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|FRAME_INIT_SAVED_REGS
argument_list|(
name|frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame
operator|->
name|saved_regs
operator|!=
name|NULL
operator|&&
name|frame
operator|->
name|saved_regs
index|[
name|regnum
index|]
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|lval
condition|)
comment|/* found it saved on the stack */
operator|*
name|lval
operator|=
name|lval_memory
expr_stmt|;
if|if
condition|(
name|regnum
operator|==
name|SP_REGNUM
condition|)
block|{
if|if
condition|(
name|raw_buffer
condition|)
comment|/* SP register treated specially */
name|store_address
argument_list|(
name|raw_buffer
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|,
name|frame
operator|->
name|saved_regs
index|[
name|regnum
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|addrp
condition|)
comment|/* any other register */
operator|*
name|addrp
operator|=
name|frame
operator|->
name|saved_regs
index|[
name|regnum
index|]
expr_stmt|;
if|if
condition|(
name|raw_buffer
condition|)
name|read_memory
argument_list|(
name|frame
operator|->
name|saved_regs
index|[
name|regnum
index|]
argument_list|,
name|raw_buffer
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
block|}
comment|/* If we get thru the loop to this point, it means the register was      not saved in any frame.  Return the actual live-register value.  */
if|if
condition|(
name|lval
condition|)
comment|/* found it in a live register */
operator|*
name|lval
operator|=
name|lval_register
expr_stmt|;
if|if
condition|(
name|addrp
condition|)
operator|*
name|addrp
operator|=
name|REGISTER_BYTE
argument_list|(
name|regnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|raw_buffer
condition|)
name|read_register_gen
argument_list|(
name|regnum
argument_list|,
name|raw_buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_GENERIC_DUMMY_FRAMES */
end_comment

begin_function
name|void
name|_initialize_blockframe
parameter_list|()
block|{
name|obstack_init
argument_list|(
operator|&
name|frame_cache_obstack
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

