begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Support for printing Pascal types for GDB, the GNU debugger.    Copyright 2000, 2001, 2002    Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This file is derived from p-typeprint.c */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_comment
comment|/* Binary File Description */
end_comment

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"p-lang.h"
end_include

begin_include
include|#
directive|include
file|"typeprint.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_function_decl
specifier|static
name|void
name|pascal_type_print_varspec_suffix
parameter_list|(
name|struct
name|type
modifier|*
parameter_list|,
name|struct
name|ui_file
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pascal_type_print_derivation_info
parameter_list|(
name|struct
name|ui_file
modifier|*
parameter_list|,
name|struct
name|type
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|pascal_type_print_varspec_prefix
parameter_list|(
name|struct
name|type
modifier|*
parameter_list|,
name|struct
name|ui_file
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* LEVEL is the depth to indent lines by.  */
end_comment

begin_function
name|void
name|pascal_print_type
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|char
modifier|*
name|varstring
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|int
name|show
parameter_list|,
name|int
name|level
parameter_list|)
block|{
specifier|register
name|enum
name|type_code
name|code
decl_stmt|;
name|int
name|demangled_args
decl_stmt|;
name|code
operator|=
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|show
operator|>
literal|0
condition|)
name|CHECK_TYPEDEF
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|code
operator|==
name|TYPE_CODE_FUNC
operator|||
name|code
operator|==
name|TYPE_CODE_METHOD
operator|)
condition|)
block|{
name|pascal_type_print_varspec_prefix
argument_list|(
name|type
argument_list|,
name|stream
argument_list|,
name|show
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* first the name */
name|fputs_filtered
argument_list|(
name|varstring
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|varstring
operator|!=
name|NULL
operator|&&
operator|*
name|varstring
operator|!=
literal|'\0'
operator|)
operator|&&
operator|!
operator|(
name|code
operator|==
name|TYPE_CODE_FUNC
operator|||
name|code
operator|==
name|TYPE_CODE_METHOD
operator|)
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|" : "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|code
operator|==
name|TYPE_CODE_FUNC
operator|||
name|code
operator|==
name|TYPE_CODE_METHOD
operator|)
condition|)
block|{
name|pascal_type_print_varspec_prefix
argument_list|(
name|type
argument_list|,
name|stream
argument_list|,
name|show
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|pascal_type_print_base
argument_list|(
name|type
argument_list|,
name|stream
argument_list|,
name|show
argument_list|,
name|level
argument_list|)
expr_stmt|;
comment|/* For demangled function names, we have the arglist as part of the name,      so don't print an additional pair of ()'s */
name|demangled_args
operator|=
name|varstring
condition|?
name|strchr
argument_list|(
name|varstring
argument_list|,
literal|'('
argument_list|)
operator|!=
name|NULL
else|:
literal|0
expr_stmt|;
name|pascal_type_print_varspec_suffix
argument_list|(
name|type
argument_list|,
name|stream
argument_list|,
name|show
argument_list|,
literal|0
argument_list|,
name|demangled_args
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If TYPE is a derived type, then print out derivation information.    Print only the actual base classes of this type, not the base classes    of the base classes.  I.E.  for the derivation hierarchy:     class A { int a; };    class B : public A {int b; };    class C : public B {int c; };     Print the type of class C as:     class C : public B {    int c;    }     Not as the following (like gdb used to), which is not legal C++ syntax for    derived types and may be confused with the multiple inheritance form:     class C : public B : public A {    int c;    }     In general, gdb should try to print the types as closely as possible to    the form that they appear in the source code. */
end_comment

begin_function
specifier|static
name|void
name|pascal_type_print_derivation_info
parameter_list|(
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|fputs_filtered
argument_list|(
name|i
operator|==
literal|0
condition|?
literal|": "
else|:
literal|", "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%s%s "
argument_list|,
name|BASETYPE_VIA_PUBLIC
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|?
literal|"public"
else|:
literal|"private"
argument_list|,
name|BASETYPE_VIA_VIRTUAL
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|?
literal|" virtual"
else|:
literal|""
argument_list|)
expr_stmt|;
name|name
operator|=
name|type_name_no_tag
argument_list|(
name|TYPE_BASECLASS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|name
condition|?
name|name
else|:
literal|"(null)"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|" "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print the Pascal method arguments ARGS to the file STREAM.  */
end_comment

begin_function
name|void
name|pascal_type_print_method_args
parameter_list|(
name|char
modifier|*
name|physname
parameter_list|,
name|char
modifier|*
name|methodname
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|)
block|{
name|int
name|is_constructor
init|=
name|STREQN
argument_list|(
name|physname
argument_list|,
literal|"__ct__"
argument_list|,
literal|6
argument_list|)
decl_stmt|;
name|int
name|is_destructor
init|=
name|STREQN
argument_list|(
name|physname
argument_list|,
literal|"__dt__"
argument_list|,
literal|6
argument_list|)
decl_stmt|;
if|if
condition|(
name|is_constructor
operator|||
name|is_destructor
condition|)
block|{
name|physname
operator|+=
literal|6
expr_stmt|;
block|}
name|fputs_filtered
argument_list|(
name|methodname
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|physname
operator|&&
operator|(
operator|*
name|physname
operator|!=
literal|0
operator|)
condition|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|len
init|=
literal|0
decl_stmt|;
name|char
name|storec
decl_stmt|;
name|char
modifier|*
name|argname
decl_stmt|;
name|fputs_filtered
argument_list|(
literal|" ("
argument_list|,
name|stream
argument_list|)
expr_stmt|;
comment|/* we must demangle this */
while|while
condition|(
name|isdigit
argument_list|(
name|physname
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
while|while
condition|(
name|isdigit
argument_list|(
name|physname
index|[
name|len
index|]
argument_list|)
condition|)
block|{
name|len
operator|++
expr_stmt|;
block|}
name|i
operator|=
name|strtol
argument_list|(
name|physname
argument_list|,
operator|&
name|argname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|physname
operator|+=
name|len
expr_stmt|;
name|storec
operator|=
name|physname
index|[
name|i
index|]
expr_stmt|;
name|physname
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|fputs_filtered
argument_list|(
name|physname
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|physname
index|[
name|i
index|]
operator|=
name|storec
expr_stmt|;
name|physname
operator|+=
name|i
expr_stmt|;
if|if
condition|(
name|physname
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|", "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
name|fputs_filtered
argument_list|(
literal|")"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print any asterisks or open-parentheses needed before the    variable name (to describe its type).     On outermost call, pass 0 for PASSED_A_PTR.    On outermost call, SHOW> 0 means should ignore    any typename for TYPE and show its details.    SHOW is always zero on recursive calls.  */
end_comment

begin_function
name|void
name|pascal_type_print_varspec_prefix
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|int
name|show
parameter_list|,
name|int
name|passed_a_ptr
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|type
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|&&
name|show
operator|<=
literal|0
condition|)
return|return;
name|QUIT
expr_stmt|;
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_PTR
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"^"
argument_list|)
expr_stmt|;
name|pascal_type_print_varspec_prefix
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
comment|/* pointer should be handled normally in pascal */
case|case
name|TYPE_CODE_MEMBER
case|:
if|if
condition|(
name|passed_a_ptr
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|pascal_type_print_varspec_prefix
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|name
operator|=
name|type_name_no_tag
argument_list|(
name|TYPE_DOMAIN_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
name|fputs_filtered
argument_list|(
name|name
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
name|pascal_type_print_base
argument_list|(
name|TYPE_DOMAIN_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
name|passed_a_ptr
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"::"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_METHOD
case|:
if|if
condition|(
name|passed_a_ptr
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|TYPE_CODE_VOID
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"function  "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"procedure "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|passed_a_ptr
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|pascal_type_print_base
argument_list|(
name|TYPE_DOMAIN_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
name|passed_a_ptr
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"::"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_CODE_REF
case|:
name|pascal_type_print_varspec_prefix
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"&"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_FUNC
case|:
if|if
condition|(
name|passed_a_ptr
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|TYPE_CODE_VOID
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"function  "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"procedure "
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_CODE_ARRAY
case|:
if|if
condition|(
name|passed_a_ptr
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"array "
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|>=
literal|0
operator|&&
name|TYPE_LENGTH
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|>
literal|0
operator|&&
name|TYPE_ARRAY_UPPER_BOUND_TYPE
argument_list|(
name|type
argument_list|)
operator|!=
name|BOUND_CANNOT_BE_DETERMINED
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"[%d..%d] "
argument_list|,
name|TYPE_ARRAY_LOWER_BOUND_VALUE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_ARRAY_UPPER_BOUND_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"of "
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_UNDEF
case|:
case|case
name|TYPE_CODE_STRUCT
case|:
case|case
name|TYPE_CODE_UNION
case|:
case|case
name|TYPE_CODE_ENUM
case|:
case|case
name|TYPE_CODE_INT
case|:
case|case
name|TYPE_CODE_FLT
case|:
case|case
name|TYPE_CODE_VOID
case|:
case|case
name|TYPE_CODE_ERROR
case|:
case|case
name|TYPE_CODE_CHAR
case|:
case|case
name|TYPE_CODE_BOOL
case|:
case|case
name|TYPE_CODE_SET
case|:
case|case
name|TYPE_CODE_RANGE
case|:
case|case
name|TYPE_CODE_STRING
case|:
case|case
name|TYPE_CODE_BITSTRING
case|:
case|case
name|TYPE_CODE_COMPLEX
case|:
case|case
name|TYPE_CODE_TYPEDEF
case|:
case|case
name|TYPE_CODE_TEMPLATE
case|:
comment|/* These types need no prefix.  They are listed here so that          gcc -Wall will reveal any types that haven't been handled.  */
break|break;
default|default:
name|error
argument_list|(
literal|"type not handled in pascal_type_print_varspec_prefix()"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|pascal_print_func_args
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|len
init|=
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|", "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|"    "
argument_list|)
expr_stmt|;
block|}
comment|/*  can we find if it is a var parameter ??          if ( TYPE_FIELD(type, i) == )          {          fprintf_filtered (stream, "var ");          } */
name|pascal_print_type
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
literal|""
comment|/* TYPE_FIELD_NAME seems invalid ! */
argument_list|,
name|stream
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|len
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print any array sizes, function arguments or close parentheses    needed after the variable name (to describe its type).    Args work like pascal_type_print_varspec_prefix.  */
end_comment

begin_function
specifier|static
name|void
name|pascal_type_print_varspec_suffix
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|int
name|show
parameter_list|,
name|int
name|passed_a_ptr
parameter_list|,
name|int
name|demangled_args
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|&&
name|show
operator|<=
literal|0
condition|)
return|return;
name|QUIT
expr_stmt|;
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_ARRAY
case|:
if|if
condition|(
name|passed_a_ptr
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_MEMBER
case|:
if|if
condition|(
name|passed_a_ptr
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
name|pascal_type_print_varspec_suffix
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_METHOD
case|:
if|if
condition|(
name|passed_a_ptr
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
name|pascal_type_print_method_args
argument_list|(
literal|""
argument_list|,
literal|""
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|TYPE_CODE_VOID
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" : "
argument_list|)
expr_stmt|;
name|pascal_type_print_varspec_prefix
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pascal_type_print_base
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
name|show
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pascal_type_print_varspec_suffix
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
name|passed_a_ptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_CODE_PTR
case|:
case|case
name|TYPE_CODE_REF
case|:
name|pascal_type_print_varspec_suffix
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_FUNC
case|:
if|if
condition|(
name|passed_a_ptr
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|demangled_args
condition|)
name|pascal_print_func_args
argument_list|(
name|type
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|TYPE_CODE_VOID
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" : "
argument_list|)
expr_stmt|;
name|pascal_type_print_varspec_prefix
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pascal_type_print_base
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
name|show
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pascal_type_print_varspec_suffix
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
name|passed_a_ptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_CODE_UNDEF
case|:
case|case
name|TYPE_CODE_STRUCT
case|:
case|case
name|TYPE_CODE_UNION
case|:
case|case
name|TYPE_CODE_ENUM
case|:
case|case
name|TYPE_CODE_INT
case|:
case|case
name|TYPE_CODE_FLT
case|:
case|case
name|TYPE_CODE_VOID
case|:
case|case
name|TYPE_CODE_ERROR
case|:
case|case
name|TYPE_CODE_CHAR
case|:
case|case
name|TYPE_CODE_BOOL
case|:
case|case
name|TYPE_CODE_SET
case|:
case|case
name|TYPE_CODE_RANGE
case|:
case|case
name|TYPE_CODE_STRING
case|:
case|case
name|TYPE_CODE_BITSTRING
case|:
case|case
name|TYPE_CODE_COMPLEX
case|:
case|case
name|TYPE_CODE_TYPEDEF
case|:
case|case
name|TYPE_CODE_TEMPLATE
case|:
comment|/* These types do not need a suffix.  They are listed so that          gcc -Wall will report types that may not have been considered.  */
break|break;
default|default:
name|error
argument_list|(
literal|"type not handled in pascal_type_print_varspec_suffix()"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Print the name of the type (or the ultimate pointer target,    function value or array element), or the description of a    structure or union.     SHOW positive means print details about the type (e.g. enum values),    and print structure elements passing SHOW - 1 for show.    SHOW negative means just print the type name or struct tag if there is one.    If there is no name, print something sensible but concise like    "struct {...}".    SHOW zero means just print the type name or struct tag if there is one.    If there is no name, print something sensible but not as concise like    "struct {int x; int y;}".     LEVEL is the number of spaces to indent by.    We increase it for some recursive calls.  */
end_comment

begin_function
name|void
name|pascal_type_print_base
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|int
name|show
parameter_list|,
name|int
name|level
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
specifier|register
name|int
name|lastval
decl_stmt|;
enum|enum
block|{
name|s_none
block|,
name|s_public
block|,
name|s_private
block|,
name|s_protected
block|}
name|section_type
enum|;
name|QUIT
expr_stmt|;
name|wrap_here
argument_list|(
literal|"    "
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|NULL
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|"<type unknown>"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* void pointer */
if|if
condition|(
operator|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_PTR
operator|)
operator|&&
operator|(
name|TYPE_CODE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_VOID
operator|)
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
condition|?
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
else|:
literal|"pointer"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* When SHOW is zero or less, and there is a valid type name, then always      just print the type name directly from the type.  */
if|if
condition|(
name|show
operator|<=
literal|0
operator|&&
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|fputs_filtered
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
block|}
name|CHECK_TYPEDEF
argument_list|(
name|type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_TYPEDEF
case|:
case|case
name|TYPE_CODE_PTR
case|:
case|case
name|TYPE_CODE_MEMBER
case|:
case|case
name|TYPE_CODE_REF
case|:
comment|/* case TYPE_CODE_FUNC:          case TYPE_CODE_METHOD: */
name|pascal_type_print_base
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
name|show
argument_list|,
name|level
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_ARRAY
case|:
comment|/* pascal_type_print_varspec_prefix (TYPE_TARGET_TYPE (type), stream, 0, 0);          pascal_type_print_base (TYPE_TARGET_TYPE (type), stream, show, level);          pascal_type_print_varspec_suffix (TYPE_TARGET_TYPE (type), stream, 0, 0, 0); */
name|pascal_print_type
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_FUNC
case|:
case|case
name|TYPE_CODE_METHOD
case|:
comment|/*          pascal_type_print_base (TYPE_TARGET_TYPE (type), stream, show, level);          only after args !! */
break|break;
case|case
name|TYPE_CODE_STRUCT
case|:
if|if
condition|(
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|fputs_filtered
argument_list|(
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|" = "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|HAVE_CPLUS_STRUCT
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"class "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"record "
argument_list|)
expr_stmt|;
block|}
goto|goto
name|struct_union
goto|;
case|case
name|TYPE_CODE_UNION
case|:
if|if
condition|(
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|fputs_filtered
argument_list|(
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|" = "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"case<?> of "
argument_list|)
expr_stmt|;
name|struct_union
label|:
name|wrap_here
argument_list|(
literal|"    "
argument_list|)
expr_stmt|;
if|if
condition|(
name|show
operator|<
literal|0
condition|)
block|{
comment|/* If we just printed a tag name, no need to print anything else.  */
if|if
condition|(
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
operator|==
name|NULL
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"{...}"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|show
operator|>
literal|0
operator|||
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|pascal_type_print_derivation_info
argument_list|(
name|stream
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|TYPE_NFN_FIELDS
argument_list|(
name|type
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|TYPE_STUB
argument_list|(
name|type
argument_list|)
condition|)
name|fprintfi_filtered
argument_list|(
name|level
operator|+
literal|4
argument_list|,
name|stream
argument_list|,
literal|"<incomplete type>\n"
argument_list|)
expr_stmt|;
else|else
name|fprintfi_filtered
argument_list|(
name|level
operator|+
literal|4
argument_list|,
name|stream
argument_list|,
literal|"<no data fields>\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Start off with no specific section type, so we can print 	     one for the first field we find, and use that section type 	     thereafter until we find another type. */
name|section_type
operator|=
name|s_none
expr_stmt|;
comment|/* If there is a base class for this type, 	     do not print the field that it occupies.  */
name|len
operator|=
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
comment|/* Don't print out virtual function table.  */
if|if
condition|(
name|STREQN
argument_list|(
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
literal|"_vptr"
argument_list|,
literal|5
argument_list|)
operator|&&
name|is_cplus_marker
argument_list|(
operator|(
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
operator|)
index|[
literal|5
index|]
argument_list|)
condition|)
continue|continue;
comment|/* If this is a pascal object or class we can print the 	         various section labels. */
if|if
condition|(
name|HAVE_CPLUS_STRUCT
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|TYPE_FIELD_PROTECTED
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
block|{
if|if
condition|(
name|section_type
operator|!=
name|s_protected
condition|)
block|{
name|section_type
operator|=
name|s_protected
expr_stmt|;
name|fprintfi_filtered
argument_list|(
name|level
operator|+
literal|2
argument_list|,
name|stream
argument_list|,
literal|"protected\n"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TYPE_FIELD_PRIVATE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
block|{
if|if
condition|(
name|section_type
operator|!=
name|s_private
condition|)
block|{
name|section_type
operator|=
name|s_private
expr_stmt|;
name|fprintfi_filtered
argument_list|(
name|level
operator|+
literal|2
argument_list|,
name|stream
argument_list|,
literal|"private\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|section_type
operator|!=
name|s_public
condition|)
block|{
name|section_type
operator|=
name|s_public
expr_stmt|;
name|fprintfi_filtered
argument_list|(
name|level
operator|+
literal|2
argument_list|,
name|stream
argument_list|,
literal|"public\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|print_spaces_filtered
argument_list|(
name|level
operator|+
literal|4
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_FIELD_STATIC
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"static "
argument_list|)
expr_stmt|;
block|}
name|pascal_print_type
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|stream
argument_list|,
name|show
operator|-
literal|1
argument_list|,
name|level
operator|+
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_FIELD_STATIC
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
operator|&&
name|TYPE_FIELD_PACKED
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
block|{
comment|/* It is a bitfield.  This code does not attempt 		     to look at the bitpos and reconstruct filler, 		     unnamed fields.  This would lead to misleading 		     results if the compiler does not put out fields 		     for such things (I don't know what it does).  */
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" : %d"
argument_list|,
name|TYPE_FIELD_BITSIZE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|";\n"
argument_list|)
expr_stmt|;
block|}
comment|/* If there are both fields and methods, put a space between. */
name|len
operator|=
name|TYPE_NFN_FIELDS
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|&&
name|section_type
operator|!=
name|s_none
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* Pbject pascal: print out the methods */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|fn_field
modifier|*
name|f
init|=
name|TYPE_FN_FIELDLIST1
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|int
name|j
decl_stmt|,
name|len2
init|=
name|TYPE_FN_FIELDLIST_LENGTH
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|char
modifier|*
name|method_name
init|=
name|TYPE_FN_FIELDLIST_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|type_name_no_tag
argument_list|(
name|type
argument_list|)
decl_stmt|;
comment|/* this is GNU C++ specific 	         how can we know constructor/destructor? 	         It might work for GNU pascal */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|len2
condition|;
name|j
operator|++
control|)
block|{
name|char
modifier|*
name|physname
init|=
name|TYPE_FN_FIELD_PHYSNAME
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
decl_stmt|;
name|int
name|is_constructor
init|=
name|STREQN
argument_list|(
name|physname
argument_list|,
literal|"__ct__"
argument_list|,
literal|6
argument_list|)
decl_stmt|;
name|int
name|is_destructor
init|=
name|STREQN
argument_list|(
name|physname
argument_list|,
literal|"__dt__"
argument_list|,
literal|6
argument_list|)
decl_stmt|;
name|QUIT
expr_stmt|;
if|if
condition|(
name|TYPE_FN_FIELD_PROTECTED
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
condition|)
block|{
if|if
condition|(
name|section_type
operator|!=
name|s_protected
condition|)
block|{
name|section_type
operator|=
name|s_protected
expr_stmt|;
name|fprintfi_filtered
argument_list|(
name|level
operator|+
literal|2
argument_list|,
name|stream
argument_list|,
literal|"protected\n"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TYPE_FN_FIELD_PRIVATE
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
condition|)
block|{
if|if
condition|(
name|section_type
operator|!=
name|s_private
condition|)
block|{
name|section_type
operator|=
name|s_private
expr_stmt|;
name|fprintfi_filtered
argument_list|(
name|level
operator|+
literal|2
argument_list|,
name|stream
argument_list|,
literal|"private\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|section_type
operator|!=
name|s_public
condition|)
block|{
name|section_type
operator|=
name|s_public
expr_stmt|;
name|fprintfi_filtered
argument_list|(
name|level
operator|+
literal|2
argument_list|,
name|stream
argument_list|,
literal|"public\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|print_spaces_filtered
argument_list|(
name|level
operator|+
literal|4
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_FN_FIELD_STATIC_P
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"static "
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_TARGET_TYPE
argument_list|(
name|TYPE_FN_FIELD_TYPE
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Keep GDB from crashing here.  */
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<undefined type> %s;\n"
argument_list|,
name|TYPE_FN_FIELD_PHYSNAME
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|is_constructor
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"constructor "
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_destructor
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"destructor  "
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_TARGET_TYPE
argument_list|(
name|TYPE_FN_FIELD_TYPE
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
argument_list|)
operator|!=
literal|0
operator|&&
name|TYPE_CODE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|TYPE_FN_FIELD_TYPE
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|TYPE_CODE_VOID
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"function  "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"procedure "
argument_list|)
expr_stmt|;
block|}
comment|/* this does not work, no idea why !! */
name|pascal_type_print_method_args
argument_list|(
name|physname
argument_list|,
name|method_name
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_TARGET_TYPE
argument_list|(
name|TYPE_FN_FIELD_TYPE
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
argument_list|)
operator|!=
literal|0
operator|&&
name|TYPE_CODE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|TYPE_FN_FIELD_TYPE
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|TYPE_CODE_VOID
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|" : "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|type_print
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|TYPE_FN_FIELD_TYPE
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
argument_list|)
argument_list|,
literal|""
argument_list|,
name|stream
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_FN_FIELD_VIRTUAL_P
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"; virtual"
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|";\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintfi_filtered
argument_list|(
name|level
argument_list|,
name|stream
argument_list|,
literal|"end"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_CODE_ENUM
case|:
if|if
condition|(
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|fputs_filtered
argument_list|(
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|show
operator|>
literal|0
condition|)
name|fputs_filtered
argument_list|(
literal|" "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
comment|/* enum is just defined by          type enume_name = (enum_member1,enum_member2,...) */
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" = "
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|"    "
argument_list|)
expr_stmt|;
if|if
condition|(
name|show
operator|<
literal|0
condition|)
block|{
comment|/* If we just printed a tag name, no need to print anything else.  */
if|if
condition|(
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
operator|==
name|NULL
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"(...)"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|show
operator|>
literal|0
operator|||
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|len
operator|=
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|lastval
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
if|if
condition|(
name|i
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|"    "
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|lastval
operator|!=
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" := %d"
argument_list|,
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|lastval
operator|=
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|lastval
operator|++
expr_stmt|;
block|}
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_CODE_VOID
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"void"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_UNDEF
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"record<unknown>"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_ERROR
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<unknown type>"
argument_list|)
expr_stmt|;
break|break;
comment|/* this probably does not work for enums */
case|case
name|TYPE_CODE_RANGE
case|:
block|{
name|struct
name|type
modifier|*
name|target
init|=
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|target
operator|==
name|NULL
condition|)
name|target
operator|=
name|builtin_type_long
expr_stmt|;
name|print_type_scalar
argument_list|(
name|target
argument_list|,
name|TYPE_LOW_BOUND
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|".."
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|print_type_scalar
argument_list|(
name|target
argument_list|,
name|TYPE_HIGH_BOUND
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_CODE_SET
case|:
name|fputs_filtered
argument_list|(
literal|"set of "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|pascal_print_type
argument_list|(
name|TYPE_INDEX_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|""
argument_list|,
name|stream
argument_list|,
name|show
operator|-
literal|1
argument_list|,
name|level
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Handle types not explicitly handled by the other cases,          such as fundamental types.  For these, just print whatever          the type name is, as recorded in the type itself.  If there          is no type name, then complain. */
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|fputs_filtered
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* At least for dump_symtab, it is important that this not be 	     an error ().  */
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<invalid unnamed pascal type code %d>"
argument_list|,
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
end_function

end_unit

