begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Remote debugging for the ARM RDP interface.    Copyright 1994, 1995 Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.      */
end_comment

begin_comment
comment|/*     Much of this file (in particular the SWI stuff) is based on code by    David Taylor (djt1000@uk.ac.cam.hermes).     I hacked on and simplified it by removing a lot of sexy features he    had added, and some of the (unix specific) workarounds he'd done    for other GDB problems - which if they still exist should be fixed    in GDB, not in a remote-foo thing .  I also made it conform more to    the doc I have; which may be wrong.     Steve Chamberlain (sac@cygnus.com).  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"wait.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"callback.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|ANSI_PROTOTYPES
end_ifdef

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"remote-utils.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|struct
name|target_ops
name|remote_rdp_ops
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|serial_t
name|io
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|host_callback
modifier|*
name|callback
init|=
operator|&
name|default_callback
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
block|{
name|int
name|step_info
decl_stmt|;
name|int
name|break_info
decl_stmt|;
name|int
name|model_info
decl_stmt|;
name|int
name|target_info
decl_stmt|;
name|int
name|can_step
decl_stmt|;
name|char
name|command_line
index|[
literal|10
index|]
decl_stmt|;
name|int
name|rdi_level
decl_stmt|;
name|int
name|rdi_stopped_status
decl_stmt|;
block|}
name|ds
struct|;
end_struct

begin_comment
comment|/* Definitions for the RDP protocol. */
end_comment

begin_define
define|#
directive|define
name|RDP_MOUTHFULL
value|(1<<6)
end_define

begin_define
define|#
directive|define
name|FPU_COPRO_NUMBER
value|1
end_define

begin_define
define|#
directive|define
name|RDP_OPEN
value|0
end_define

begin_define
define|#
directive|define
name|RDP_OPEN_TYPE_COLD
value|0
end_define

begin_define
define|#
directive|define
name|RDP_OPEN_TYPE_WARM
value|1
end_define

begin_define
define|#
directive|define
name|RDP_OPEN_TYPE_BAUDRATE
value|2
end_define

begin_define
define|#
directive|define
name|RDP_OPEN_BAUDRATE_9600
value|1
end_define

begin_define
define|#
directive|define
name|RDP_OPEN_BAUDRATE_19200
value|2
end_define

begin_define
define|#
directive|define
name|RDP_OPEN_BAUDRATE_38400
value|3
end_define

begin_define
define|#
directive|define
name|RDP_OPEN_TYPE_RETURN_SEX
value|(1<<3)
end_define

begin_define
define|#
directive|define
name|RDP_CLOSE
value|1
end_define

begin_define
define|#
directive|define
name|RDP_MEM_READ
value|2
end_define

begin_define
define|#
directive|define
name|RDP_MEM_WRITE
value|3
end_define

begin_define
define|#
directive|define
name|RDP_CPU_READ
value|4
end_define

begin_define
define|#
directive|define
name|RDP_CPU_WRITE
value|5
end_define

begin_define
define|#
directive|define
name|RDP_CPU_READWRITE_MODE_CURRENT
value|255
end_define

begin_define
define|#
directive|define
name|RDP_CPU_READWRITE_MASK_PC
value|(1<<16)
end_define

begin_define
define|#
directive|define
name|RDP_CPU_READWRITE_MASK_CPSR
value|(1<<17)
end_define

begin_define
define|#
directive|define
name|RDP_CPU_READWRITE_MASK_SPSR
value|(1<<18)
end_define

begin_define
define|#
directive|define
name|RDP_COPRO_READ
value|6
end_define

begin_define
define|#
directive|define
name|RDP_COPRO_WRITE
value|7
end_define

begin_define
define|#
directive|define
name|RDP_FPU_READWRITE_MASK_FPS
value|(1<<8)
end_define

begin_define
define|#
directive|define
name|RDP_SET_BREAK
value|0xa
end_define

begin_define
define|#
directive|define
name|RDP_SET_BREAK_TYPE_PC_EQUAL
value|0
end_define

begin_define
define|#
directive|define
name|RDP_SET_BREAK_TYPE_GET_HANDLE
value|(0x10)
end_define

begin_define
define|#
directive|define
name|RDP_CLEAR_BREAK
value|0xb
end_define

begin_define
define|#
directive|define
name|RDP_EXEC
value|0x10
end_define

begin_define
define|#
directive|define
name|RDP_EXEC_TYPE_SYNC
value|0
end_define

begin_define
define|#
directive|define
name|RDP_STEP
value|0x11
end_define

begin_define
define|#
directive|define
name|RDP_INFO
value|0x12
end_define

begin_define
define|#
directive|define
name|RDP_INFO_ABOUT_STEP
value|2
end_define

begin_define
define|#
directive|define
name|RDP_INFO_ABOUT_STEP_GT_1
value|1
end_define

begin_define
define|#
directive|define
name|RDP_INFO_ABOUT_STEP_TO_JMP
value|2
end_define

begin_define
define|#
directive|define
name|RDP_INFO_ABOUT_STEP_1
value|4
end_define

begin_define
define|#
directive|define
name|RDP_INFO_ABOUT_TARGET
value|0
end_define

begin_define
define|#
directive|define
name|RDP_INFO_ABOUT_BREAK
value|1
end_define

begin_define
define|#
directive|define
name|RDP_INFO_ABOUT_BREAK_COMP
value|1
end_define

begin_define
define|#
directive|define
name|RDP_INFO_ABOUT_BREAK_RANGE
value|2
end_define

begin_define
define|#
directive|define
name|RDP_INFO_ABOUT_BREAK_BYTE_READ
value|4
end_define

begin_define
define|#
directive|define
name|RDP_INFO_ABOUT_BREAK_HALFWORD_READ
value|8
end_define

begin_define
define|#
directive|define
name|RDP_INFO_ABOUT_BREAK_WORD_READ
value|(1<<4)
end_define

begin_define
define|#
directive|define
name|RDP_INFO_ABOUT_BREAK_BYTE_WRITE
value|(1<<5)
end_define

begin_define
define|#
directive|define
name|RDP_INFO_ABOUT_BREAK_HALFWORD_WRITE
value|(1<<6)
end_define

begin_define
define|#
directive|define
name|RDP_INFO_ABOUT_BREAK_WORD_WRITE
value|(1<<7)
end_define

begin_define
define|#
directive|define
name|RDP_INFO_ABOUT_BREAK_MASK
value|(1<<8)
end_define

begin_define
define|#
directive|define
name|RDP_INFO_ABOUT_BREAK_THREAD_BREAK
value|(1<<9)
end_define

begin_define
define|#
directive|define
name|RDP_INFO_ABOUT_BREAK_THREAD_WATCH
value|(1<<10)
end_define

begin_define
define|#
directive|define
name|RDP_INFO_ABOUT_BREAK_COND
value|(1<<11)
end_define

begin_define
define|#
directive|define
name|RDP_RESET
value|0x7f
end_define

begin_comment
comment|/* Returns from RDP */
end_comment

begin_define
define|#
directive|define
name|RDP_RES_STOPPED
value|0x20
end_define

begin_define
define|#
directive|define
name|RDP_RES_SWI
value|0x21
end_define

begin_define
define|#
directive|define
name|RDP_RES_FATAL
value|0x5e
end_define

begin_define
define|#
directive|define
name|RDP_RES_VALUE
value|0x5f
end_define

begin_define
define|#
directive|define
name|RDP_RES_VALUE_LITTLE_ENDIAN
value|240
end_define

begin_define
define|#
directive|define
name|RDP_RES_VALUE_BIG_ENDIAN
value|241
end_define

begin_define
define|#
directive|define
name|RDP_RES_RESET
value|0x7f
end_define

begin_define
define|#
directive|define
name|RDP_RES_AT_BREAKPOINT
value|143
end_define

begin_define
define|#
directive|define
name|RDP_RES_IDUNNO
value|0xe6
end_define

begin_define
define|#
directive|define
name|RDP_OSOpReply
value|0x13
end_define

begin_define
define|#
directive|define
name|RDP_OSOpWord
value|2
end_define

begin_define
define|#
directive|define
name|RDP_OSOpNothing
value|0
end_define

begin_decl_stmt
specifier|static
name|int
name|timeout
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|remote_rdp_xfer_inferior_memory
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
name|memaddr
operator|,
name|char
operator|*
name|myaddr
operator|,
name|int
name|len
operator|,
name|int
name|write
operator|,
expr|struct
name|target_ops
operator|*
name|target
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Stuff for talking to the serial layer. */
end_comment

begin_function
specifier|static
name|unsigned
name|char
name|get_byte
parameter_list|()
block|{
name|int
name|c
init|=
name|SERIAL_READCHAR
argument_list|(
name|io
argument_list|,
name|timeout
argument_list|)
decl_stmt|;
if|if
condition|(
name|remote_debug
condition|)
name|printf
argument_list|(
literal|"[%02x]\n"
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|SERIAL_TIMEOUT
condition|)
block|{
if|if
condition|(
name|timeout
operator|==
literal|0
condition|)
return|return
operator|(
name|unsigned
name|char
operator|)
name|c
return|;
name|error
argument_list|(
literal|"Timeout reading from remote_system"
argument_list|)
expr_stmt|;
block|}
return|return
name|c
return|;
block|}
end_function

begin_comment
comment|/* Note that the target always speaks little-endian to us,    even if it's a big endian machine. */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|get_word
parameter_list|()
block|{
name|unsigned
name|int
name|val
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|c
decl_stmt|;
name|int
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|4
condition|;
name|n
operator|++
control|)
block|{
name|c
operator|=
name|get_byte
argument_list|()
expr_stmt|;
name|val
operator||=
name|c
operator|<<
operator|(
name|n
operator|*
literal|8
operator|)
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|put_byte
parameter_list|(
name|val
parameter_list|)
name|char
name|val
decl_stmt|;
block|{
if|if
condition|(
name|remote_debug
condition|)
name|printf
argument_list|(
literal|"(%02x)\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|SERIAL_WRITE
argument_list|(
name|io
argument_list|,
operator|&
name|val
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|put_word
parameter_list|(
name|val
parameter_list|)
name|int
name|val
decl_stmt|;
block|{
comment|/* We always send in little endian */
name|unsigned
name|char
name|b
index|[
literal|4
index|]
decl_stmt|;
name|b
index|[
literal|0
index|]
operator|=
name|val
expr_stmt|;
name|b
index|[
literal|1
index|]
operator|=
name|val
operator|>>
literal|8
expr_stmt|;
name|b
index|[
literal|2
index|]
operator|=
name|val
operator|>>
literal|16
expr_stmt|;
name|b
index|[
literal|3
index|]
operator|=
name|val
operator|>>
literal|24
expr_stmt|;
if|if
condition|(
name|remote_debug
condition|)
name|printf
argument_list|(
literal|"(%04x)"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|SERIAL_WRITE
argument_list|(
name|io
argument_list|,
name|b
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Stuff for talking to the RDP layer. */
end_comment

begin_comment
comment|/* This is a bit more fancy that need be so that it syncs even in nasty cases.     I'be been unable to make it reliably sync up with the change    baudrate open command.  It likes to sit and say it's been reset,    with no more action.  So I took all that code out.  I'd rather sync    reliably at 9600 than wait forever for a possible 19200 connection.   */
end_comment

begin_function
specifier|static
name|void
name|rdp_init
parameter_list|(
name|cold
parameter_list|,
name|tty
parameter_list|)
name|int
name|cold
decl_stmt|;
name|int
name|tty
decl_stmt|;
block|{
name|int
name|sync
init|=
literal|0
decl_stmt|;
name|int
name|type
init|=
name|cold
condition|?
name|RDP_OPEN_TYPE_COLD
else|:
name|RDP_OPEN_TYPE_WARM
decl_stmt|;
name|int
name|baudtry
init|=
literal|9600
decl_stmt|;
name|time_t
name|now
init|=
name|time
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|time_t
name|stop_time
init|=
name|now
operator|+
literal|10
decl_stmt|;
comment|/* Try and sync for 10 seconds, then give up */
while|while
condition|(
name|time
argument_list|(
literal|0
argument_list|)
operator|<
name|stop_time
operator|&&
operator|!
name|sync
condition|)
block|{
name|int
name|restype
decl_stmt|;
name|QUIT
expr_stmt|;
name|SERIAL_FLUSH_INPUT
argument_list|(
name|io
argument_list|)
expr_stmt|;
name|SERIAL_FLUSH_OUTPUT
argument_list|(
name|io
argument_list|)
expr_stmt|;
if|if
condition|(
name|tty
condition|)
name|printf_unfiltered
argument_list|(
literal|"Trying to connect at %d baud.\n"
argument_list|,
name|baudtry
argument_list|)
expr_stmt|;
name|put_byte
argument_list|(
name|RDP_OPEN
argument_list|)
expr_stmt|;
name|put_byte
argument_list|(
name|type
operator||
name|RDP_OPEN_TYPE_RETURN_SEX
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|sync
operator|&&
operator|(
name|restype
operator|=
name|SERIAL_READCHAR
argument_list|(
name|io
argument_list|,
literal|1
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|remote_debug
condition|)
name|printf_unfiltered
argument_list|(
literal|"[%02x]\n"
argument_list|,
name|restype
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|restype
condition|)
block|{
case|case
name|SERIAL_TIMEOUT
case|:
break|break;
case|case
name|RDP_RESET
case|:
while|while
condition|(
operator|(
name|restype
operator|=
name|SERIAL_READCHAR
argument_list|(
name|io
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|RDP_RESET
condition|)
empty_stmt|;
while|while
condition|(
operator|(
name|restype
operator|=
name|SERIAL_READCHAR
argument_list|(
name|io
argument_list|,
literal|1
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"%c"
argument_list|,
name|isgraph
argument_list|(
name|restype
argument_list|)
condition|?
name|restype
else|:
literal|' '
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|restype
operator|=
name|SERIAL_READCHAR
argument_list|(
name|io
argument_list|,
literal|1
argument_list|)
operator|)
operator|>
literal|0
condition|)
empty_stmt|;
if|if
condition|(
name|tty
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"\nThe board has sent notification that it was reset.\n"
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"Waiting for it to settle down...\n"
argument_list|)
expr_stmt|;
block|}
name|sleep
argument_list|(
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|tty
condition|)
name|printf_unfiltered
argument_list|(
literal|"\nTrying again.\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
case|case
name|RDP_RES_VALUE
case|:
block|{
name|int
name|resval
init|=
name|SERIAL_READCHAR
argument_list|(
name|io
argument_list|,
literal|1
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|resval
condition|)
block|{
case|case
name|SERIAL_TIMEOUT
case|:
break|break;
case|case
name|RDP_RES_VALUE_LITTLE_ENDIAN
case|:
name|target_byte_order
operator|=
name|LITTLE_ENDIAN
expr_stmt|;
name|sync
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|RDP_RES_VALUE_BIG_ENDIAN
case|:
name|target_byte_order
operator|=
name|BIG_ENDIAN
expr_stmt|;
name|sync
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
block|}
block|}
block|}
if|if
condition|(
operator|!
name|sync
condition|)
block|{
name|error
argument_list|(
literal|"Couldn't reset the board, try pressing the reset button"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ANSI_PROTOTYPES
end_ifdef

begin_decl_stmt
name|void
name|send_rdp
argument_list|(
name|char
operator|*
name|template
argument_list|,
operator|...
argument_list|)
else|#
directive|else
name|void
name|send_rdp
argument_list|(
name|char
operator|*
name|template
argument_list|,
name|va_alist
argument_list|)
name|va_dcl
endif|#
directive|endif
block|{
name|char
name|buf
index|[
literal|200
index|]
decl_stmt|;
name|char
modifier|*
name|dst
init|=
name|buf
decl_stmt|;
name|va_list
name|alist
decl_stmt|;
ifdef|#
directive|ifdef
name|ANSI_PROTOTYPES
name|va_start
argument_list|(
name|alist
argument_list|,
name|template
argument_list|)
expr_stmt|;
else|#
directive|else
name|va_start
argument_list|(
name|alist
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
operator|*
name|template
condition|)
block|{
name|unsigned
name|int
name|val
decl_stmt|;
name|int
modifier|*
name|pi
decl_stmt|;
name|int
modifier|*
name|pstat
decl_stmt|;
name|char
modifier|*
name|pc
decl_stmt|;
name|int
name|i
decl_stmt|;
switch|switch
condition|(
operator|*
name|template
operator|++
condition|)
block|{
case|case
literal|'b'
case|:
name|val
operator|=
name|va_arg
argument_list|(
name|alist
argument_list|,
name|int
argument_list|)
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
name|val
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|val
operator|=
name|va_arg
argument_list|(
name|alist
argument_list|,
name|int
argument_list|)
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
name|val
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
name|val
operator|>>
literal|8
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
name|val
operator|>>
literal|16
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
name|val
operator|>>
literal|24
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|val
operator|=
name|get_byte
argument_list|()
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|RDP_RES_VALUE
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"got bad res value of %d, %x\n"
argument_list|,
name|val
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'V'
case|:
name|pstat
operator|=
name|va_arg
argument_list|(
name|alist
argument_list|,
name|int
operator|*
argument_list|)
expr_stmt|;
name|pi
operator|=
name|va_arg
argument_list|(
name|alist
argument_list|,
name|int
operator|*
argument_list|)
expr_stmt|;
operator|*
name|pstat
operator|=
name|get_byte
argument_list|()
expr_stmt|;
comment|/* Check the result was zero, if not read the syndrome */
if|if
condition|(
operator|*
name|pstat
condition|)
block|{
operator|*
name|pi
operator|=
name|get_word
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|'Z'
case|:
comment|/* Check the result code, error if not zero */
if|if
condition|(
name|get_byte
argument_list|()
condition|)
name|error
argument_list|(
literal|"Command garbled"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
comment|/* Read a word from the target */
name|pi
operator|=
name|va_arg
argument_list|(
name|alist
argument_list|,
name|int
operator|*
argument_list|)
expr_stmt|;
operator|*
name|pi
operator|=
name|get_word
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
comment|/* Read in some bytes from the target. */
name|pc
operator|=
name|va_arg
argument_list|(
name|alist
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|val
operator|=
name|va_arg
argument_list|(
name|alist
argument_list|,
name|int
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|val
condition|;
name|i
operator|++
control|)
block|{
name|pc
index|[
name|i
index|]
operator|=
name|get_byte
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|'p'
case|:
comment|/* send what's being pointed at */
name|pc
operator|=
name|va_arg
argument_list|(
name|alist
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|val
operator|=
name|va_arg
argument_list|(
name|alist
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|dst
operator|=
name|buf
expr_stmt|;
name|SERIAL_WRITE
argument_list|(
name|io
argument_list|,
name|pc
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
comment|/* Send whats in the queue */
if|if
condition|(
name|dst
operator|!=
name|buf
condition|)
block|{
name|SERIAL_WRITE
argument_list|(
name|io
argument_list|,
name|buf
argument_list|,
name|dst
operator|-
name|buf
argument_list|)
expr_stmt|;
name|dst
operator|=
name|buf
expr_stmt|;
block|}
break|break;
case|case
literal|'B'
case|:
name|pi
operator|=
name|va_arg
argument_list|(
name|alist
argument_list|,
name|int
operator|*
argument_list|)
expr_stmt|;
operator|*
name|pi
operator|=
name|get_byte
argument_list|()
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|!=
name|buf
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
end_decl_stmt

begin_function
specifier|static
name|int
name|rdp_write
parameter_list|(
name|memaddr
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|int
name|res
decl_stmt|;
name|int
name|val
decl_stmt|;
name|send_rdp
argument_list|(
literal|"bww-p-SV"
argument_list|,
name|RDP_MEM_WRITE
argument_list|,
name|memaddr
argument_list|,
name|len
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
operator|&
name|res
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
condition|)
block|{
return|return
name|val
return|;
block|}
return|return
name|len
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|rdp_read
parameter_list|(
name|memaddr
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|int
name|res
decl_stmt|;
name|int
name|val
decl_stmt|;
name|send_rdp
argument_list|(
literal|"bww-S-P-V"
argument_list|,
name|RDP_MEM_READ
argument_list|,
name|memaddr
argument_list|,
name|len
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
operator|&
name|res
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
condition|)
block|{
return|return
name|val
return|;
block|}
return|return
name|len
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|rdp_fetch_one_register
parameter_list|(
name|mask
parameter_list|,
name|buf
parameter_list|)
name|int
name|mask
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
block|{
name|int
name|val
decl_stmt|;
name|send_rdp
argument_list|(
literal|"bbw-SWZ"
argument_list|,
name|RDP_CPU_READ
argument_list|,
name|RDP_CPU_READWRITE_MODE_CURRENT
argument_list|,
name|mask
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|store_signed_integer
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rdp_fetch_one_fpu_register
parameter_list|(
name|mask
parameter_list|,
name|buf
parameter_list|)
name|int
name|mask
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
block|{
if|#
directive|if
literal|0
comment|/* !!! Since the PIE board doesn't work as documented,      and it doesn't have FPU hardware anyway and since it      slows everything down, I've disabled this. */
block|int val;   if (mask == RDP_FPU_READWRITE_MASK_FPS)     {
comment|/* this guy is only a word */
block|send_rdp ("bbw-SWZ", RDP_COPRO_READ, FPU_COPRO_NUMBER, mask,&val);       store_signed_integer (buf, 4, val);     }   else     {
comment|/* There are 12 bytes long           !! fixme about endianness         */
block|int dummy;
comment|/* I've seen these come back as four words !! */
block|send_rdp ("bbw-SWWWWZ", RDP_COPRO_READ, FPU_COPRO_NUMBER, mask, buf + 0, buf + 4, buf + 8,&dummy);     }
endif|#
directive|endif
name|memset
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|MAX_REGISTER_RAW_SIZE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rdp_store_one_register
parameter_list|(
name|mask
parameter_list|,
name|buf
parameter_list|)
name|int
name|mask
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
block|{
name|int
name|val
init|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|)
decl_stmt|;
name|send_rdp
argument_list|(
literal|"bbww-SZ"
argument_list|,
name|RDP_CPU_WRITE
argument_list|,
name|RDP_CPU_READWRITE_MODE_CURRENT
argument_list|,
name|mask
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rdp_store_one_fpu_register
parameter_list|(
name|mask
parameter_list|,
name|buf
parameter_list|)
name|int
name|mask
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
block|{
if|#
directive|if
literal|0
comment|/* See comment in fetch_one_fpu_register */
block|if (mask == RDP_FPU_READWRITE_MASK_FPS)     {       int val = extract_unsigned_integer (buf, 4);
comment|/* this guy is only a word */
block|send_rdp ("bbww-SZ", RDP_COPRO_WRITE, 		FPU_COPRO_NUMBER, 		mask, val);     }   else     {
comment|/* There are 12 bytes long           !! fixme about endianness         */
block|int dummy = 0;
comment|/* I've seen these come as four words, not the three advertized !! */
block|printf ("Sending mask %x\n", mask);       send_rdp ("bbwwwww-SZ", 		RDP_COPRO_WRITE, 		FPU_COPRO_NUMBER, 		mask, 		*(int *) (buf + 0), 		*(int *) (buf + 4), 		*(int *) (buf + 8), 		0);        printf ("done mask %x\n", mask);     }
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Convert between GDB requests and the RDP layer. */
end_comment

begin_function
specifier|static
name|void
name|remote_rdp_fetch_register
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
if|if
condition|(
name|regno
operator|==
operator|-
literal|1
condition|)
block|{
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|NUM_REGS
condition|;
name|regno
operator|++
control|)
name|remote_rdp_fetch_register
argument_list|(
name|regno
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
name|buf
index|[
name|MAX_REGISTER_RAW_SIZE
index|]
decl_stmt|;
if|if
condition|(
name|regno
operator|<
literal|15
condition|)
name|rdp_fetch_one_register
argument_list|(
literal|1
operator|<<
name|regno
argument_list|,
name|buf
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|regno
operator|==
name|PC_REGNUM
condition|)
name|rdp_fetch_one_register
argument_list|(
name|RDP_CPU_READWRITE_MASK_PC
argument_list|,
name|buf
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|regno
operator|==
name|PS_REGNUM
condition|)
name|rdp_fetch_one_register
argument_list|(
name|RDP_CPU_READWRITE_MASK_CPSR
argument_list|,
name|buf
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|regno
operator|==
name|FPS_REGNUM
condition|)
name|rdp_fetch_one_fpu_register
argument_list|(
name|RDP_FPU_READWRITE_MASK_FPS
argument_list|,
name|buf
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|regno
operator|>=
name|F0_REGNUM
operator|&&
name|regno
operator|<=
name|F7_REGNUM
condition|)
name|rdp_fetch_one_fpu_register
argument_list|(
literal|1
operator|<<
operator|(
name|regno
operator|-
name|F0_REGNUM
operator|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"Help me with fetch reg %d\n"
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
name|supply_register
argument_list|(
name|regno
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|remote_rdp_store_register
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
if|if
condition|(
name|regno
operator|==
operator|-
literal|1
condition|)
block|{
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|NUM_REGS
condition|;
name|regno
operator|++
control|)
name|remote_rdp_store_register
argument_list|(
name|regno
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
name|tmp
index|[
name|MAX_REGISTER_RAW_SIZE
index|]
decl_stmt|;
name|read_register_gen
argument_list|(
name|regno
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|<
literal|15
condition|)
name|rdp_store_one_register
argument_list|(
literal|1
operator|<<
name|regno
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|regno
operator|==
name|PC_REGNUM
condition|)
name|rdp_store_one_register
argument_list|(
name|RDP_CPU_READWRITE_MASK_PC
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|regno
operator|==
name|PS_REGNUM
condition|)
name|rdp_store_one_register
argument_list|(
name|RDP_CPU_READWRITE_MASK_CPSR
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|regno
operator|>=
name|F0_REGNUM
operator|&&
name|regno
operator|<=
name|F7_REGNUM
condition|)
name|rdp_store_one_fpu_register
argument_list|(
literal|1
operator|<<
operator|(
name|regno
operator|-
name|F0_REGNUM
operator|)
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"Help me with reg %d\n"
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|remote_rdp_kill
parameter_list|()
block|{
name|callback
operator|->
name|shutdown
argument_list|(
name|callback
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rdp_info
parameter_list|()
block|{
name|send_rdp
argument_list|(
literal|"bw-S-W-Z"
argument_list|,
name|RDP_INFO
argument_list|,
name|RDP_INFO_ABOUT_STEP
argument_list|,
operator|&
name|ds
operator|.
name|step_info
argument_list|)
expr_stmt|;
name|send_rdp
argument_list|(
literal|"bw-S-W-Z"
argument_list|,
name|RDP_INFO
argument_list|,
name|RDP_INFO_ABOUT_BREAK
argument_list|,
operator|&
name|ds
operator|.
name|break_info
argument_list|)
expr_stmt|;
name|send_rdp
argument_list|(
literal|"bw-S-WW-Z"
argument_list|,
name|RDP_INFO
argument_list|,
name|RDP_INFO_ABOUT_TARGET
argument_list|,
operator|&
name|ds
operator|.
name|target_info
argument_list|,
operator|&
name|ds
operator|.
name|model_info
argument_list|)
expr_stmt|;
name|ds
operator|.
name|can_step
operator|=
name|ds
operator|.
name|step_info
operator|&
name|RDP_INFO_ABOUT_STEP_1
expr_stmt|;
name|ds
operator|.
name|rdi_level
operator|=
operator|(
name|ds
operator|.
name|target_info
operator|>>
literal|5
operator|)
operator|&
literal|3
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rdp_execute_start
parameter_list|()
block|{
comment|/* Start it off, but don't wait for it */
name|send_rdp
argument_list|(
literal|"bb-"
argument_list|,
name|RDP_EXEC
argument_list|,
name|RDP_EXEC_TYPE_SYNC
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|a_byte
value|1
end_define

begin_define
define|#
directive|define
name|a_word
value|2
end_define

begin_define
define|#
directive|define
name|a_string
value|3
end_define

begin_typedef
typedef|typedef
struct|struct
block|{
name|CORE_ADDR
name|n
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
block|}
name|argsin
typedef|;
end_typedef

begin_define
define|#
directive|define
name|ABYTE
value|1
end_define

begin_define
define|#
directive|define
name|AWORD
value|2
end_define

begin_define
define|#
directive|define
name|ASTRING
value|3
end_define

begin_define
define|#
directive|define
name|ADDRLEN
value|4
end_define

begin_define
define|#
directive|define
name|SWI_WriteC
value|0x0
end_define

begin_define
define|#
directive|define
name|SWI_Write0
value|0x2
end_define

begin_define
define|#
directive|define
name|SWI_ReadC
value|0x4
end_define

begin_define
define|#
directive|define
name|SWI_CLI
value|0x5
end_define

begin_define
define|#
directive|define
name|SWI_GetEnv
value|0x10
end_define

begin_define
define|#
directive|define
name|SWI_Exit
value|0x11
end_define

begin_define
define|#
directive|define
name|SWI_EnterOS
value|0x16
end_define

begin_define
define|#
directive|define
name|SWI_GetErrno
value|0x60
end_define

begin_define
define|#
directive|define
name|SWI_Clock
value|0x61
end_define

begin_define
define|#
directive|define
name|SWI_Time
value|0x63
end_define

begin_define
define|#
directive|define
name|SWI_Remove
value|0x64
end_define

begin_define
define|#
directive|define
name|SWI_Rename
value|0x65
end_define

begin_define
define|#
directive|define
name|SWI_Open
value|0x66
end_define

begin_define
define|#
directive|define
name|SWI_Close
value|0x68
end_define

begin_define
define|#
directive|define
name|SWI_Write
value|0x69
end_define

begin_define
define|#
directive|define
name|SWI_Read
value|0x6a
end_define

begin_define
define|#
directive|define
name|SWI_Seek
value|0x6b
end_define

begin_define
define|#
directive|define
name|SWI_Flen
value|0x6c
end_define

begin_define
define|#
directive|define
name|SWI_IsTTY
value|0x6e
end_define

begin_define
define|#
directive|define
name|SWI_TmpNam
value|0x6f
end_define

begin_define
define|#
directive|define
name|SWI_InstallHandler
value|0x70
end_define

begin_define
define|#
directive|define
name|SWI_GenerateError
value|0x71
end_define

begin_function
specifier|static
name|int
name|exec_swi
parameter_list|(
name|swi
parameter_list|,
name|args
parameter_list|)
name|int
name|swi
decl_stmt|;
name|argsin
modifier|*
name|args
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|char
name|c
decl_stmt|;
switch|switch
condition|(
name|swi
condition|)
block|{
case|case
name|SWI_WriteC
case|:
name|callback
operator|->
name|write_stdout
argument_list|(
name|callback
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SWI_Write0
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|args
operator|->
name|n
condition|;
name|i
operator|++
control|)
name|callback
operator|->
name|write_stdout
argument_list|(
name|callback
argument_list|,
name|args
operator|->
name|s
argument_list|,
name|strlen
argument_list|(
name|args
operator|->
name|s
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SWI_ReadC
case|:
name|callback
operator|->
name|read_stdin
argument_list|(
name|callback
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|args
operator|->
name|n
operator|=
name|c
expr_stmt|;
return|return
literal|1
return|;
case|case
name|SWI_CLI
case|:
name|args
operator|->
name|n
operator|=
name|callback
operator|->
name|system
argument_list|(
name|callback
argument_list|,
name|args
operator|->
name|s
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|SWI_GetErrno
case|:
name|args
operator|->
name|n
operator|=
name|callback
operator|->
name|get_errno
argument_list|(
name|callback
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|SWI_Time
case|:
name|args
operator|->
name|n
operator|=
name|callback
operator|->
name|time
argument_list|(
name|callback
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|SWI_Remove
case|:
name|args
operator|->
name|n
operator|=
name|callback
operator|->
name|unlink
argument_list|(
name|callback
argument_list|,
name|args
operator|->
name|s
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|SWI_Rename
case|:
name|args
operator|->
name|n
operator|=
name|callback
operator|->
name|rename
argument_list|(
name|callback
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|s
argument_list|,
name|args
index|[
literal|1
index|]
operator|.
name|s
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|SWI_Open
case|:
name|i
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|O_BINARY
if|if
condition|(
name|args
index|[
literal|1
index|]
operator|.
name|n
operator|&
literal|1
condition|)
name|i
operator||=
name|O_BINARY
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|args
index|[
literal|1
index|]
operator|.
name|n
operator|&
literal|2
condition|)
name|i
operator||=
name|O_RDWR
expr_stmt|;
if|if
condition|(
name|args
index|[
literal|1
index|]
operator|.
name|n
operator|&
literal|4
condition|)
block|{
name|i
operator||=
name|O_CREAT
expr_stmt|;
block|}
if|if
condition|(
name|args
index|[
literal|1
index|]
operator|.
name|n
operator|&
literal|8
condition|)
name|i
operator||=
name|O_APPEND
expr_stmt|;
name|args
operator|->
name|n
operator|=
name|callback
operator|->
name|open
argument_list|(
name|callback
argument_list|,
name|args
operator|->
name|s
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|SWI_Close
case|:
name|args
operator|->
name|n
operator|=
name|callback
operator|->
name|close
argument_list|(
name|callback
argument_list|,
name|args
operator|->
name|n
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|SWI_Write
case|:
name|args
operator|->
name|n
operator|=
name|callback
operator|->
name|write
argument_list|(
name|callback
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|n
argument_list|,
name|args
index|[
literal|1
index|]
operator|.
name|s
argument_list|,
name|args
index|[
literal|1
index|]
operator|.
name|n
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|SWI_Read
case|:
block|{
name|char
modifier|*
name|copy
init|=
name|alloca
argument_list|(
name|args
index|[
literal|2
index|]
operator|.
name|n
argument_list|)
decl_stmt|;
name|int
name|done
init|=
name|callback
operator|->
name|read
argument_list|(
name|callback
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|n
argument_list|,
name|copy
argument_list|,
name|args
index|[
literal|2
index|]
operator|.
name|n
argument_list|)
decl_stmt|;
if|if
condition|(
name|done
operator|>
literal|0
condition|)
name|remote_rdp_xfer_inferior_memory
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|n
argument_list|,
name|copy
argument_list|,
name|done
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|args
operator|->
name|n
operator|-=
name|done
expr_stmt|;
return|return
literal|1
return|;
block|}
case|case
name|SWI_Seek
case|:
name|args
operator|->
name|n
operator|=
name|callback
operator|->
name|lseek
argument_list|(
name|callback
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|n
argument_list|,
name|args
index|[
literal|1
index|]
operator|.
name|n
argument_list|,
literal|0
argument_list|)
operator|>=
literal|0
expr_stmt|;
return|return
literal|1
return|;
case|case
name|SWI_Flen
case|:
block|{
name|long
name|old
init|=
name|callback
operator|->
name|lseek
argument_list|(
name|callback
argument_list|,
name|args
operator|->
name|n
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|args
operator|->
name|n
operator|=
name|callback
operator|->
name|lseek
argument_list|(
name|callback
argument_list|,
name|args
operator|->
name|n
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|callback
operator|->
name|lseek
argument_list|(
name|callback
argument_list|,
name|args
operator|->
name|n
argument_list|,
name|old
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
case|case
name|SWI_IsTTY
case|:
name|args
operator|->
name|n
operator|=
name|callback
operator|->
name|isatty
argument_list|(
name|callback
argument_list|,
name|args
operator|->
name|n
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|handle_swi
parameter_list|()
block|{
name|argsin
name|args
index|[
literal|3
index|]
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|int
name|swino
init|=
name|get_word
argument_list|()
decl_stmt|;
name|int
name|type
init|=
name|get_byte
argument_list|()
decl_stmt|;
while|while
condition|(
name|type
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
name|type
operator|&
literal|0x3
condition|)
block|{
case|case
name|ABYTE
case|:
name|args
index|[
name|count
index|]
operator|.
name|n
operator|=
name|get_byte
argument_list|()
expr_stmt|;
break|break;
case|case
name|AWORD
case|:
name|args
index|[
name|count
index|]
operator|.
name|n
operator|=
name|get_word
argument_list|()
expr_stmt|;
break|break;
case|case
name|ASTRING
case|:
comment|/* If the word is under 32 bytes it will be sent otherwise 	     an address to it is passed. Also: Special case of 255 */
name|len
operator|=
name|get_byte
argument_list|()
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|32
condition|)
block|{
if|if
condition|(
name|len
operator|==
literal|255
condition|)
block|{
name|len
operator|=
name|get_word
argument_list|()
expr_stmt|;
block|}
name|buf
operator|=
name|alloca
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|remote_rdp_xfer_inferior_memory
argument_list|(
name|get_word
argument_list|()
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
name|buf
operator|=
name|alloca
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|buf
index|[
name|i
index|]
operator|=
name|get_byte
argument_list|()
expr_stmt|;
name|buf
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|args
index|[
name|count
index|]
operator|.
name|n
operator|=
name|len
expr_stmt|;
name|args
index|[
name|count
index|]
operator|.
name|s
operator|=
name|buf
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Unimplented SWI argument"
argument_list|)
expr_stmt|;
block|}
name|type
operator|=
name|type
operator|>>
literal|2
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|exec_swi
argument_list|(
name|swino
argument_list|,
name|args
argument_list|)
condition|)
block|{
comment|/* We have two options here reply with either a byte or a word          which is stored in args[0].n. There is no harm in replying with          a word all the time, so thats what I do! */
name|send_rdp
argument_list|(
literal|"bbw-"
argument_list|,
name|RDP_OSOpReply
argument_list|,
name|RDP_OSOpWord
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|n
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|send_rdp
argument_list|(
literal|"bb-"
argument_list|,
name|RDP_OSOpReply
argument_list|,
name|RDP_OSOpNothing
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|rdp_execute_finish
parameter_list|()
block|{
name|int
name|running
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|running
condition|)
block|{
name|int
name|res
decl_stmt|;
name|res
operator|=
name|SERIAL_READCHAR
argument_list|(
name|io
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|res
operator|==
name|SERIAL_TIMEOUT
condition|)
block|{
name|QUIT
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Waiting for target..\n"
argument_list|)
expr_stmt|;
name|res
operator|=
name|SERIAL_READCHAR
argument_list|(
name|io
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|res
condition|)
block|{
case|case
name|RDP_RES_SWI
case|:
name|handle_swi
argument_list|()
expr_stmt|;
break|break;
case|case
name|RDP_RES_VALUE
case|:
name|send_rdp
argument_list|(
literal|"B"
argument_list|,
operator|&
name|ds
operator|.
name|rdi_stopped_status
argument_list|)
expr_stmt|;
name|running
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|RDP_RESET
case|:
name|printf_filtered
argument_list|(
literal|"Target reset\n"
argument_list|)
expr_stmt|;
name|running
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|printf_filtered
argument_list|(
literal|"Ignoring %x\n"
argument_list|,
name|res
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|rdp_execute
parameter_list|()
block|{
name|rdp_execute_start
argument_list|()
expr_stmt|;
name|rdp_execute_finish
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|remote_rdp_insert_breakpoint
parameter_list|(
name|addr
parameter_list|,
name|save
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
name|char
modifier|*
name|save
decl_stmt|;
block|{
name|int
name|res
decl_stmt|;
if|if
condition|(
name|ds
operator|.
name|rdi_level
operator|>
literal|0
condition|)
block|{
name|send_rdp
argument_list|(
literal|"bwb-SWB"
argument_list|,
name|RDP_SET_BREAK
argument_list|,
name|addr
argument_list|,
name|RDP_SET_BREAK_TYPE_PC_EQUAL
operator||
name|RDP_SET_BREAK_TYPE_GET_HANDLE
argument_list|,
name|save
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|send_rdp
argument_list|(
literal|"bwb-SB"
argument_list|,
name|RDP_SET_BREAK
argument_list|,
name|addr
argument_list|,
name|RDP_SET_BREAK_TYPE_PC_EQUAL
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|remote_rdp_remove_breakpoint
parameter_list|(
name|addr
parameter_list|,
name|save
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
name|char
modifier|*
name|save
decl_stmt|;
block|{
name|int
name|res
decl_stmt|;
if|if
condition|(
name|ds
operator|.
name|rdi_level
operator|>
literal|0
condition|)
block|{
name|send_rdp
argument_list|(
literal|"b-p-S-B"
argument_list|,
name|RDP_CLEAR_BREAK
argument_list|,
name|save
argument_list|,
literal|4
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|send_rdp
argument_list|(
literal|"bw-S-B"
argument_list|,
name|RDP_CLEAR_BREAK
argument_list|,
name|addr
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|rdp_step
parameter_list|()
block|{
if|if
condition|(
name|ds
operator|.
name|can_step
operator|&&
literal|0
condition|)
block|{
comment|/* The pie board can't do steps so I can't test this, and          the other code will always work. */
name|int
name|status
decl_stmt|;
name|send_rdp
argument_list|(
literal|"bbw-S-B"
argument_list|,
name|RDP_STEP
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
name|handle
index|[
literal|4
index|]
decl_stmt|;
name|CORE_ADDR
name|pc
init|=
name|read_register
argument_list|(
name|PC_REGNUM
argument_list|)
decl_stmt|;
name|pc
operator|=
name|arm_get_next_pc
argument_list|(
name|pc
argument_list|)
expr_stmt|;
name|remote_rdp_insert_breakpoint
argument_list|(
name|pc
argument_list|,
operator|&
name|handle
argument_list|)
expr_stmt|;
name|rdp_execute
argument_list|()
expr_stmt|;
name|remote_rdp_remove_breakpoint
argument_list|(
name|pc
argument_list|,
operator|&
name|handle
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|remote_rdp_open
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|args
condition|)
name|error_no_arg
argument_list|(
literal|"serial port device name"
argument_list|)
expr_stmt|;
name|baud_rate
operator|=
literal|9600
expr_stmt|;
name|target_preopen
argument_list|(
name|from_tty
argument_list|)
expr_stmt|;
name|io
operator|=
name|SERIAL_OPEN
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|io
condition|)
name|perror_with_name
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|SERIAL_RAW
argument_list|(
name|io
argument_list|)
expr_stmt|;
name|rdp_init
argument_list|(
literal|1
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"Remote RDP debugging using %s at %d baud\n"
argument_list|,
name|args
argument_list|,
name|baud_rate
argument_list|)
expr_stmt|;
block|}
name|rdp_info
argument_list|()
expr_stmt|;
name|push_target
argument_list|(
operator|&
name|remote_rdp_ops
argument_list|)
expr_stmt|;
name|callback
operator|->
name|init
argument_list|(
name|callback
argument_list|)
expr_stmt|;
name|flush_cached_frames
argument_list|()
expr_stmt|;
name|registers_changed
argument_list|()
expr_stmt|;
name|stop_pc
operator|=
name|read_pc
argument_list|()
expr_stmt|;
name|set_current_frame
argument_list|(
name|create_new_frame
argument_list|(
name|read_fp
argument_list|()
argument_list|,
name|stop_pc
argument_list|)
argument_list|)
expr_stmt|;
name|select_frame
argument_list|(
name|get_current_frame
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|print_stack_frame
argument_list|(
name|selected_frame
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Close out all files and local state before this target loses control. */
end_comment

begin_function
specifier|static
name|void
name|remote_rdp_close
parameter_list|(
name|quitting
parameter_list|)
name|int
name|quitting
decl_stmt|;
block|{
name|callback
operator|->
name|shutdown
argument_list|(
name|callback
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
condition|)
name|SERIAL_CLOSE
argument_list|(
name|io
argument_list|)
expr_stmt|;
name|io
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Resume execution of the target process.  STEP says whether to single-step    or to run free; SIGGNAL is the signal value (e.g. SIGINT) to be given    to the target, or zero for no signal.  */
end_comment

begin_function
specifier|static
name|void
name|remote_rdp_resume
parameter_list|(
name|pid
parameter_list|,
name|step
parameter_list|,
name|siggnal
parameter_list|)
name|int
name|pid
decl_stmt|,
name|step
decl_stmt|;
name|enum
name|target_signal
name|siggnal
decl_stmt|;
block|{
if|if
condition|(
name|step
condition|)
name|rdp_step
argument_list|()
expr_stmt|;
else|else
name|rdp_execute
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Wait for inferior process to do something.  Return pid of child,    or -1 in case of error; store status through argument pointer STATUS,    just as `wait' would.  */
end_comment

begin_function
specifier|static
name|int
name|remote_rdp_wait
parameter_list|(
name|pid
parameter_list|,
name|status
parameter_list|)
name|int
name|pid
decl_stmt|;
name|struct
name|target_waitstatus
modifier|*
name|status
decl_stmt|;
block|{
switch|switch
condition|(
name|ds
operator|.
name|rdi_stopped_status
condition|)
block|{
default|default:
case|case
name|RDP_RES_RESET
case|:
case|case
name|RDP_RES_SWI
case|:
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_EXITED
expr_stmt|;
name|status
operator|->
name|value
operator|.
name|integer
operator|=
name|read_register
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|RDP_RES_AT_BREAKPOINT
case|:
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_STOPPED
expr_stmt|;
comment|/* The signal in sigrc is a host signal.  That probably          should be fixed.  */
name|status
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_TRAP
expr_stmt|;
break|break;
if|#
directive|if
literal|0
block|case rdp_signalled:       status->kind = TARGET_WAITKIND_SIGNALLED;
comment|/* The signal in sigrc is a host signal.  That probably          should be fixed.  */
block|status->value.sig = target_signal_from_host (sigrc);       break;
endif|#
directive|endif
block|}
return|return
name|inferior_pid
return|;
block|}
end_function

begin_comment
comment|/* Get ready to modify the registers array.  On machines which store    individual registers, this doesn't need to do anything.  On machines    which store all the registers in one fell swoop, this makes sure    that registers contains all the registers from the program being    debugged.  */
end_comment

begin_function
specifier|static
name|void
name|remote_rdp_prepare_to_store
parameter_list|()
block|{
comment|/* Do nothing, since we can store individual regs */
block|}
end_function

begin_function
specifier|static
name|int
name|remote_rdp_xfer_inferior_memory
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|,
name|write
parameter_list|,
name|target
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|write
decl_stmt|;
name|struct
name|target_ops
modifier|*
name|target
decl_stmt|;
comment|/* ignored */
block|{
comment|/* I infer from D Taylor's code that there's a limit on the amount      we can transfer in one chunk.. */
name|int
name|done
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|done
operator|<
name|len
condition|)
block|{
name|int
name|justdone
decl_stmt|;
name|int
name|thisbite
init|=
name|len
operator|-
name|done
decl_stmt|;
if|if
condition|(
name|thisbite
operator|>
name|RDP_MOUTHFULL
condition|)
name|thisbite
operator|=
name|RDP_MOUTHFULL
expr_stmt|;
name|QUIT
expr_stmt|;
if|if
condition|(
name|write
condition|)
block|{
name|justdone
operator|=
name|rdp_write
argument_list|(
name|memaddr
operator|+
name|done
argument_list|,
name|myaddr
operator|+
name|done
argument_list|,
name|thisbite
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|justdone
operator|=
name|rdp_read
argument_list|(
name|memaddr
operator|+
name|done
argument_list|,
name|myaddr
operator|+
name|done
argument_list|,
name|thisbite
argument_list|)
expr_stmt|;
block|}
name|done
operator|+=
name|justdone
expr_stmt|;
if|if
condition|(
name|justdone
operator|!=
name|thisbite
condition|)
break|break;
block|}
return|return
name|done
return|;
block|}
end_function

begin_struct
struct|struct
name|yn
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|bit
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|yn
name|stepinfo
index|[]
init|=
block|{
block|{
literal|"Step more than one instruction"
block|,
name|RDP_INFO_ABOUT_STEP_GT_1
block|}
block|,
block|{
literal|"Step to jump"
block|,
name|RDP_INFO_ABOUT_STEP_TO_JMP
block|}
block|,
block|{
literal|"Step one instruction"
block|,
name|RDP_INFO_ABOUT_STEP_1
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|yn
name|breakinfo
index|[]
init|=
block|{
block|{
literal|"comparison breakpoints supported"
block|,
name|RDP_INFO_ABOUT_BREAK_COMP
block|}
block|,
block|{
literal|"range breakpoints supported"
block|,
name|RDP_INFO_ABOUT_BREAK_RANGE
block|}
block|,
block|{
literal|"watchpoints for byte reads supported"
block|,
name|RDP_INFO_ABOUT_BREAK_BYTE_READ
block|}
block|,
block|{
literal|"watchpoints for half-word reads supported"
block|,
name|RDP_INFO_ABOUT_BREAK_HALFWORD_READ
block|}
block|,
block|{
literal|"watchpoints for word reads supported"
block|,
name|RDP_INFO_ABOUT_BREAK_WORD_READ
block|}
block|,
block|{
literal|"watchpoints for byte writes supported"
block|,
name|RDP_INFO_ABOUT_BREAK_BYTE_WRITE
block|}
block|,
block|{
literal|"watchpoints for half-word writes supported"
block|,
name|RDP_INFO_ABOUT_BREAK_HALFWORD_WRITE
block|}
block|,
block|{
literal|"watchpoints for word writes supported"
block|,
name|RDP_INFO_ABOUT_BREAK_WORD_WRITE
block|}
block|,
block|{
literal|"mask break/watch-points supported"
block|,
name|RDP_INFO_ABOUT_BREAK_MASK
block|}
block|,
block|{
literal|"thread-specific breakpoints supported"
block|,
name|RDP_INFO_ABOUT_BREAK_THREAD_BREAK
block|}
block|,
block|{
literal|"thread-specific watchpoints supported"
block|,
name|RDP_INFO_ABOUT_BREAK_THREAD_WATCH
block|}
block|,
block|{
literal|"conditional breakpoints supported"
block|,
name|RDP_INFO_ABOUT_BREAK_COND
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|dump_bits
parameter_list|(
name|t
parameter_list|,
name|info
parameter_list|)
name|struct
name|yn
modifier|*
name|t
decl_stmt|;
name|int
name|info
decl_stmt|;
block|{
while|while
condition|(
name|t
operator|->
name|name
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"  %-45s : %s\n"
argument_list|,
name|t
operator|->
name|name
argument_list|,
operator|(
name|info
operator|&
name|t
operator|->
name|bit
operator|)
condition|?
literal|"Yes"
else|:
literal|"No"
argument_list|)
expr_stmt|;
name|t
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|remote_rdp_files_info
parameter_list|(
name|target
parameter_list|)
name|struct
name|target_ops
modifier|*
name|target
decl_stmt|;
block|{
name|printf_filtered
argument_list|(
literal|"Target capabilities:\n"
argument_list|)
expr_stmt|;
name|dump_bits
argument_list|(
name|stepinfo
argument_list|,
name|ds
operator|.
name|step_info
argument_list|)
expr_stmt|;
name|dump_bits
argument_list|(
name|breakinfo
argument_list|,
name|ds
operator|.
name|break_info
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"target level RDI %x\n"
argument_list|,
operator|(
name|ds
operator|.
name|target_info
operator|>>
literal|5
operator|)
operator|&
literal|3
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Define the target subroutine names */
end_comment

begin_decl_stmt
name|struct
name|target_ops
name|remote_rdp_ops
init|=
block|{
literal|"rdp"
block|,
comment|/* to_shortname */
comment|/* to_longname */
literal|"Remote Target using the RDProtocol"
block|,
comment|/* to_doc */
literal|"Use a remote ARM system which uses the ARM Remote Debugging Protocol"
block|,
name|remote_rdp_open
block|,
comment|/* to_open */
name|remote_rdp_close
block|,
comment|/* to_close */
name|NULL
block|,
comment|/* to_attach */
name|NULL
block|,
comment|/* to_detach */
name|remote_rdp_resume
block|,
comment|/* to_resume */
name|remote_rdp_wait
block|,
comment|/* to_wait */
name|remote_rdp_fetch_register
block|,
comment|/* to_fetch_registers */
name|remote_rdp_store_register
block|,
comment|/* to_store_registers */
name|remote_rdp_prepare_to_store
block|,
comment|/* to_prepare_to_store */
name|remote_rdp_xfer_inferior_memory
block|,
comment|/* to_xfer_memory */
name|remote_rdp_files_info
block|,
comment|/* to_files_info */
name|remote_rdp_insert_breakpoint
block|,
comment|/* to_insert_breakpoint */
name|remote_rdp_remove_breakpoint
block|,
comment|/* to_remove_breakpoint */
name|NULL
block|,
comment|/* to_terminal_init */
name|NULL
block|,
comment|/* to_terminal_inferior */
name|NULL
block|,
comment|/* to_terminal_ours_for_output */
name|NULL
block|,
comment|/* to_terminal_ours */
name|NULL
block|,
comment|/* to_terminal_info */
name|remote_rdp_kill
block|,
comment|/* to_kill */
name|generic_load
block|,
comment|/* to_load */
name|NULL
block|,
comment|/* to_lookup_symbol */
name|NULL
block|,
comment|/* to_create_inferior */
name|generic_mourn_inferior
block|,
comment|/* to_mourn_inferior */
literal|0
block|,
comment|/* to_can_run */
literal|0
block|,
comment|/* to_notice_signals */
literal|0
block|,
comment|/* to_thread_alive */
literal|0
block|,
comment|/* to_stop */
name|process_stratum
block|,
comment|/* to_stratum */
name|NULL
block|,
comment|/* to_next */
literal|1
block|,
comment|/* to_has_all_memory */
literal|1
block|,
comment|/* to_has_memory */
literal|1
block|,
comment|/* to_has_stack */
literal|1
block|,
comment|/* to_has_registers */
literal|1
block|,
comment|/* to_has_execution */
name|NULL
block|,
comment|/* sections */
name|NULL
block|,
comment|/* sections_end */
name|OPS_MAGIC
block|,
comment|/* to_magic */
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|_initialize_remote_rdp
parameter_list|()
block|{
name|add_target
argument_list|(
operator|&
name|remote_rdp_ops
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

