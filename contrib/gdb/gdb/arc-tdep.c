begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ARC target-dependent stuff.    Copyright (C) 1995, 1997 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"floatformat.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_comment
comment|/* Current CPU, set with the "set cpu" command.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|arc_bfd_mach_type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|arc_cpu_type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|tmp_arc_cpu_type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Table of cpu names.  */
end_comment

begin_struct
struct|struct
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|value
decl_stmt|;
block|}
name|arc_cpu_type_table
index|[]
init|=
block|{
block|{
literal|"base"
block|,
name|bfd_mach_arc_base
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_comment
comment|/* Used by simulator.  */
end_comment

begin_decl_stmt
name|int
name|display_pipeline_p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cpu_timer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This one must have the same type as used in the emulator.    It's currently an enum so this should be ok for now.  */
end_comment

begin_decl_stmt
name|int
name|debug_pipeline_p
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ARC_CALL_SAVED_REG
parameter_list|(
name|r
parameter_list|)
value|((r)>= 16&& (r)< 24)
end_define

begin_define
define|#
directive|define
name|OPMASK
value|0xf8000000
end_define

begin_comment
comment|/* Instruction field accessor macros.    See the Programmer's Reference Manual.  */
end_comment

begin_define
define|#
directive|define
name|X_OP
parameter_list|(
name|i
parameter_list|)
value|(((i)>> 27)& 0x1f)
end_define

begin_define
define|#
directive|define
name|X_A
parameter_list|(
name|i
parameter_list|)
value|(((i)>> 21)& 0x3f)
end_define

begin_define
define|#
directive|define
name|X_B
parameter_list|(
name|i
parameter_list|)
value|(((i)>> 15)& 0x3f)
end_define

begin_define
define|#
directive|define
name|X_C
parameter_list|(
name|i
parameter_list|)
value|(((i)>> 9)& 0x3f)
end_define

begin_define
define|#
directive|define
name|X_D
parameter_list|(
name|i
parameter_list|)
value|((((i)& 0x1ff) ^ 0x100) - 0x100)
end_define

begin_define
define|#
directive|define
name|X_L
parameter_list|(
name|i
parameter_list|)
value|(((((i)>> 5)& 0x3ffffc) ^ 0x200000) - 0x200000)
end_define

begin_define
define|#
directive|define
name|X_N
parameter_list|(
name|i
parameter_list|)
value|(((i)>> 5)& 3)
end_define

begin_define
define|#
directive|define
name|X_Q
parameter_list|(
name|i
parameter_list|)
value|((i)& 0x1f)
end_define

begin_comment
comment|/* Return non-zero if X is a short immediate data indicator.  */
end_comment

begin_define
define|#
directive|define
name|SHIMM_P
parameter_list|(
name|x
parameter_list|)
value|((x) == 61 || (x) == 63)
end_define

begin_comment
comment|/* Return non-zero if X is a "long" (32 bit) immediate data indicator.  */
end_comment

begin_define
define|#
directive|define
name|LIMM_P
parameter_list|(
name|x
parameter_list|)
value|((x) == 62)
end_define

begin_comment
comment|/* Build a simple instruction.  */
end_comment

begin_define
define|#
directive|define
name|BUILD_INSN
parameter_list|(
name|op
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|)
define|\
value|((((op)& 31)<< 27) \    | (((a)& 63)<< 21) \    | (((b)& 63)<< 15) \    | (((c)& 63)<< 9) \    | ((d)& 511))
end_define

begin_escape
end_escape

begin_comment
comment|/* Codestream stuff.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|codestream_read
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|codestream_seek
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|codestream_fill
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CODESTREAM_BUFSIZ
value|16
end_define

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|codestream_next_addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|codestream_addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|codestream_buf
index|[
name|CODESTREAM_BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|codestream_off
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|codestream_cnt
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|codestream_tell
parameter_list|()
define|\
value|(codestream_addr + codestream_off * sizeof (codestream_buf[0]))
end_define

begin_define
define|#
directive|define
name|codestream_peek
parameter_list|()
define|\
value|(codestream_cnt == 0 \    ? codestream_fill (1) \    : codestream_buf[codestream_off])
end_define

begin_define
define|#
directive|define
name|codestream_get
parameter_list|()
define|\
value|(codestream_cnt-- == 0 \    ? codestream_fill (0) \    : codestream_buf[codestream_off++])
end_define

begin_function
specifier|static
name|unsigned
name|int
name|codestream_fill
parameter_list|(
name|peek_flag
parameter_list|)
name|int
name|peek_flag
decl_stmt|;
block|{
name|codestream_addr
operator|=
name|codestream_next_addr
expr_stmt|;
name|codestream_next_addr
operator|+=
name|CODESTREAM_BUFSIZ
operator|*
sizeof|sizeof
argument_list|(
name|codestream_buf
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|codestream_off
operator|=
literal|0
expr_stmt|;
name|codestream_cnt
operator|=
name|CODESTREAM_BUFSIZ
expr_stmt|;
name|read_memory
argument_list|(
name|codestream_addr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|codestream_buf
argument_list|,
name|CODESTREAM_BUFSIZ
operator|*
sizeof|sizeof
argument_list|(
name|codestream_buf
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* FIXME: check return code?  */
comment|/* Handle byte order differences.  */
if|if
condition|(
name|HOST_BYTE_ORDER
operator|!=
name|TARGET_BYTE_ORDER
condition|)
block|{
specifier|register
name|unsigned
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|n
init|=
sizeof|sizeof
argument_list|(
name|codestream_buf
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
specifier|register
name|char
name|tmp
decl_stmt|,
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|codestream_buf
init|;
name|i
operator|<
name|CODESTREAM_BUFSIZ
condition|;
operator|++
name|i
operator|,
name|p
operator|+=
name|n
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n
operator|/
literal|2
condition|;
operator|++
name|j
control|)
name|tmp
operator|=
name|p
index|[
name|j
index|]
operator|,
name|p
index|[
name|j
index|]
operator|=
name|p
index|[
name|n
operator|-
literal|1
operator|-
name|j
index|]
operator|,
name|p
index|[
name|n
operator|-
literal|1
operator|-
name|j
index|]
operator|=
name|tmp
expr_stmt|;
block|}
if|if
condition|(
name|peek_flag
condition|)
return|return
name|codestream_peek
argument_list|()
return|;
else|else
return|return
name|codestream_get
argument_list|()
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|codestream_seek
parameter_list|(
name|place
parameter_list|)
name|CORE_ADDR
name|place
decl_stmt|;
block|{
name|codestream_next_addr
operator|=
name|place
operator|/
name|CODESTREAM_BUFSIZ
expr_stmt|;
name|codestream_next_addr
operator|*=
name|CODESTREAM_BUFSIZ
expr_stmt|;
name|codestream_cnt
operator|=
literal|0
expr_stmt|;
name|codestream_fill
argument_list|(
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|codestream_tell
argument_list|()
operator|!=
name|place
condition|)
name|codestream_get
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function is currently unused but leave in for now.  */
end_comment

begin_function
specifier|static
name|void
name|codestream_read
parameter_list|(
name|buf
parameter_list|,
name|count
parameter_list|)
name|unsigned
name|int
modifier|*
name|buf
decl_stmt|;
name|int
name|count
decl_stmt|;
block|{
name|unsigned
name|int
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|++
operator|=
name|codestream_get
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Set up prologue scanning and return the first insn.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|setup_prologue_scan
parameter_list|(
name|pc
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
block|{
name|unsigned
name|int
name|insn
decl_stmt|;
name|codestream_seek
argument_list|(
name|pc
argument_list|)
expr_stmt|;
name|insn
operator|=
name|codestream_get
argument_list|()
expr_stmt|;
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/*  * Find& return amount a local space allocated, and advance codestream to  * first register push (if any).  * If entry sequence doesn't make sense, return -1, and leave   * codestream pointer random.  */
end_comment

begin_function
specifier|static
name|long
name|arc_get_frame_setup
parameter_list|(
name|pc
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
block|{
name|unsigned
name|int
name|insn
decl_stmt|;
comment|/* Size of frame or -1 if unrecognizable prologue.  */
name|int
name|frame_size
init|=
operator|-
literal|1
decl_stmt|;
comment|/* An initial "sub sp,sp,N" may or may not be for a stdarg fn.  */
name|int
name|maybe_stdarg_decr
init|=
operator|-
literal|1
decl_stmt|;
name|insn
operator|=
name|setup_prologue_scan
argument_list|(
name|pc
argument_list|)
expr_stmt|;
comment|/* The authority for what appears here is the home-grown ABI.      The most recent version is 1.2.  */
comment|/* First insn may be "sub sp,sp,N" if stdarg fn.  */
if|if
condition|(
operator|(
name|insn
operator|&
name|BUILD_INSN
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|BUILD_INSN
argument_list|(
literal|10
argument_list|,
name|SP_REGNUM
argument_list|,
name|SP_REGNUM
argument_list|,
name|SHIMM_REGNUM
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|maybe_stdarg_decr
operator|=
name|X_D
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|insn
operator|=
name|codestream_get
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|insn
operator|&
name|BUILD_INSN
argument_list|(
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
operator|)
comment|/* st blink,[sp,4] */
operator|==
name|BUILD_INSN
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
name|SP_REGNUM
argument_list|,
name|BLINK_REGNUM
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|insn
operator|=
name|codestream_get
argument_list|()
expr_stmt|;
comment|/* Frame may not be necessary, even though blink is saved. 	 At least this is something we recognize.  */
name|frame_size
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|insn
operator|&
name|BUILD_INSN
argument_list|(
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
operator|)
comment|/* st fp,[sp] */
operator|==
name|BUILD_INSN
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
name|SP_REGNUM
argument_list|,
name|FP_REGNUM
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|insn
operator|=
name|codestream_get
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|insn
operator|&
name|BUILD_INSN
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|BUILD_INSN
argument_list|(
literal|12
argument_list|,
name|FP_REGNUM
argument_list|,
name|SP_REGNUM
argument_list|,
name|SP_REGNUM
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Check for stack adjustment sub sp,sp,N.  */
name|insn
operator|=
name|codestream_peek
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|insn
operator|&
name|BUILD_INSN
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|BUILD_INSN
argument_list|(
literal|10
argument_list|,
name|SP_REGNUM
argument_list|,
name|SP_REGNUM
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
name|LIMM_P
argument_list|(
name|X_C
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
name|frame_size
operator|=
name|codestream_get
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|SHIMM_P
argument_list|(
name|X_C
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
name|frame_size
operator|=
name|X_D
argument_list|(
name|insn
argument_list|)
expr_stmt|;
else|else
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|frame_size
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|codestream_get
argument_list|()
expr_stmt|;
comment|/* This sequence is used to get the address of the return 	     buffer for a function that returns a structure.  */
name|insn
operator|=
name|codestream_peek
argument_list|()
expr_stmt|;
if|if
condition|(
name|insn
operator|&
name|OPMASK
operator|==
literal|0x60000000
condition|)
name|codestream_get
argument_list|()
expr_stmt|;
block|}
comment|/* Frameless fn.  */
else|else
block|{
name|frame_size
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* If we found a "sub sp,sp,N" and nothing else, it may or may not be a      stdarg fn.  The stdarg decrement is not treated as part of the frame size,      so we have a dilemma: what do we return?  For now, if we get a      "sub sp,sp,N" and nothing else assume this isn't a stdarg fn.  One way      to fix this completely would be to add a bit to the function descriptor      that says the function is a stdarg function.  */
if|if
condition|(
name|frame_size
operator|<
literal|0
operator|&&
name|maybe_stdarg_decr
operator|>
literal|0
condition|)
return|return
name|maybe_stdarg_decr
return|;
return|return
name|frame_size
return|;
block|}
end_function

begin_comment
comment|/* Given a pc value, skip it forward past the function prologue by    disassembling instructions that appear to be a prologue.     If FRAMELESS_P is set, we are only testing to see if the function    is frameless.  If it is a frameless function, return PC unchanged.    This allows a quicker answer.  */
end_comment

begin_function
name|CORE_ADDR
name|skip_prologue
parameter_list|(
name|pc
parameter_list|,
name|frameless_p
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
name|int
name|frameless_p
decl_stmt|;
block|{
name|unsigned
name|int
name|insn
decl_stmt|;
name|int
name|i
decl_stmt|,
name|frame_size
decl_stmt|;
if|if
condition|(
operator|(
name|frame_size
operator|=
name|arc_get_frame_setup
argument_list|(
name|pc
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|pc
operator|)
return|;
if|if
condition|(
name|frameless_p
condition|)
return|return
name|frame_size
operator|==
literal|0
condition|?
name|pc
else|:
name|codestream_tell
argument_list|()
return|;
comment|/* Skip over register saves.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|insn
operator|=
name|codestream_peek
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|insn
operator|&
name|BUILD_INSN
argument_list|(
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|BUILD_INSN
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
name|SP_REGNUM
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
break|break;
comment|/* not st insn */
if|if
condition|(
operator|!
name|ARC_CALL_SAVED_REG
argument_list|(
name|X_C
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
break|break;
name|codestream_get
argument_list|()
expr_stmt|;
block|}
return|return
name|codestream_tell
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/* Return the return address for a frame.    This is used to implement FRAME_SAVED_PC.    This is taken from frameless_look_for_prologue.  */
end_comment

begin_function
name|CORE_ADDR
name|arc_frame_saved_pc
parameter_list|(
name|frame
parameter_list|)
name|struct
name|frame_info
modifier|*
name|frame
decl_stmt|;
block|{
name|CORE_ADDR
name|func_start
decl_stmt|;
name|unsigned
name|int
name|insn
decl_stmt|;
name|func_start
operator|=
name|get_pc_function_start
argument_list|(
name|frame
operator|->
name|pc
argument_list|)
operator|+
name|FUNCTION_START_OFFSET
expr_stmt|;
if|if
condition|(
name|func_start
operator|==
literal|0
condition|)
block|{
comment|/* Best guess.  */
return|return
name|ARC_PC_TO_REAL_ADDRESS
argument_list|(
name|read_memory_integer
argument_list|(
name|FRAME_FP
argument_list|(
name|frame
argument_list|)
operator|+
literal|4
argument_list|,
literal|4
argument_list|)
argument_list|)
return|;
block|}
comment|/* The authority for what appears here is the home-grown ABI.      The most recent version is 1.2.  */
name|insn
operator|=
name|setup_prologue_scan
argument_list|(
name|func_start
argument_list|)
expr_stmt|;
comment|/* First insn may be "sub sp,sp,N" if stdarg fn.  */
if|if
condition|(
operator|(
name|insn
operator|&
name|BUILD_INSN
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|BUILD_INSN
argument_list|(
literal|10
argument_list|,
name|SP_REGNUM
argument_list|,
name|SP_REGNUM
argument_list|,
name|SHIMM_REGNUM
argument_list|,
literal|0
argument_list|)
condition|)
name|insn
operator|=
name|codestream_get
argument_list|()
expr_stmt|;
comment|/* If the next insn is "st blink,[sp,4]" we can get blink from there.      Otherwise this is a leaf function and we can use blink.  Note that      this still allows for the case where a leaf function saves/clobbers/      restores blink.  */
if|if
condition|(
operator|(
name|insn
operator|&
name|BUILD_INSN
argument_list|(
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
operator|)
comment|/* st blink,[sp,4] */
operator|!=
name|BUILD_INSN
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
name|SP_REGNUM
argument_list|,
name|BLINK_REGNUM
argument_list|,
literal|4
argument_list|)
condition|)
return|return
name|ARC_PC_TO_REAL_ADDRESS
argument_list|(
name|read_register
argument_list|(
name|BLINK_REGNUM
argument_list|)
argument_list|)
return|;
else|else
return|return
name|ARC_PC_TO_REAL_ADDRESS
argument_list|(
name|read_memory_integer
argument_list|(
name|FRAME_FP
argument_list|(
name|frame
argument_list|)
operator|+
literal|4
argument_list|,
literal|4
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Parse the first few instructions of the function to see  * what registers were stored.  *  * The startup sequence can be at the start of the function.  * 'st blink,[sp+4], st fp,[sp], mov fp,sp'   *  * Local space is allocated just below by sub sp,sp,nnn.  * Next, the registers used by this function are stored (as offsets from sp).  */
end_comment

begin_function
name|void
name|frame_find_saved_regs
parameter_list|(
name|fip
parameter_list|,
name|fsrp
parameter_list|)
name|struct
name|frame_info
modifier|*
name|fip
decl_stmt|;
name|struct
name|frame_saved_regs
modifier|*
name|fsrp
decl_stmt|;
block|{
name|long
name|locals
decl_stmt|;
name|unsigned
name|int
name|insn
decl_stmt|;
name|CORE_ADDR
name|dummy_bottom
decl_stmt|;
name|CORE_ADDR
name|adr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|regnum
decl_stmt|,
name|offset
decl_stmt|;
name|memset
argument_list|(
name|fsrp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|fsrp
argument_list|)
expr_stmt|;
comment|/* If frame is the end of a dummy, compute where the beginning would be.  */
name|dummy_bottom
operator|=
name|fip
operator|->
name|frame
operator|-
literal|4
operator|-
name|REGISTER_BYTES
operator|-
name|CALL_DUMMY_LENGTH
expr_stmt|;
comment|/* Check if the PC is in the stack, in a dummy frame.  */
if|if
condition|(
name|dummy_bottom
operator|<=
name|fip
operator|->
name|pc
operator|&&
name|fip
operator|->
name|pc
operator|<=
name|fip
operator|->
name|frame
condition|)
block|{
comment|/* all regs were saved by push_call_dummy () */
name|adr
operator|=
name|fip
operator|->
name|frame
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_REGS
condition|;
name|i
operator|++
control|)
block|{
name|adr
operator|-=
name|REGISTER_RAW_SIZE
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|fsrp
operator|->
name|regs
index|[
name|i
index|]
operator|=
name|adr
expr_stmt|;
block|}
return|return;
block|}
name|locals
operator|=
name|arc_get_frame_setup
argument_list|(
name|get_pc_function_start
argument_list|(
name|fip
operator|->
name|pc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|locals
operator|>=
literal|0
condition|)
block|{
comment|/* Set `adr' to the value of `sp'.  */
name|adr
operator|=
name|fip
operator|->
name|frame
operator|-
name|locals
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|insn
operator|=
name|codestream_get
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|insn
operator|&
name|BUILD_INSN
argument_list|(
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|BUILD_INSN
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
name|SP_REGNUM
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
break|break;
name|regnum
operator|=
name|X_C
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|offset
operator|=
name|X_D
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|fsrp
operator|->
name|regs
index|[
name|regnum
index|]
operator|=
name|adr
operator|+
name|offset
expr_stmt|;
block|}
block|}
name|fsrp
operator|->
name|regs
index|[
name|PC_REGNUM
index|]
operator|=
name|fip
operator|->
name|frame
operator|+
literal|4
expr_stmt|;
name|fsrp
operator|->
name|regs
index|[
name|FP_REGNUM
index|]
operator|=
name|fip
operator|->
name|frame
expr_stmt|;
block|}
end_function

begin_function
name|void
name|push_dummy_frame
parameter_list|()
block|{
name|CORE_ADDR
name|sp
init|=
name|read_register
argument_list|(
name|SP_REGNUM
argument_list|)
decl_stmt|;
name|int
name|regnum
decl_stmt|;
name|char
name|regbuf
index|[
name|MAX_REGISTER_RAW_SIZE
index|]
decl_stmt|;
name|read_register_gen
argument_list|(
name|PC_REGNUM
argument_list|,
name|regbuf
argument_list|)
expr_stmt|;
name|write_memory
argument_list|(
name|sp
operator|+
literal|4
argument_list|,
name|regbuf
argument_list|,
name|REGISTER_SIZE
argument_list|)
expr_stmt|;
name|read_register_gen
argument_list|(
name|FP_REGNUM
argument_list|,
name|regbuf
argument_list|)
expr_stmt|;
name|write_memory
argument_list|(
name|sp
argument_list|,
name|regbuf
argument_list|,
name|REGISTER_SIZE
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|FP_REGNUM
argument_list|,
name|sp
argument_list|)
expr_stmt|;
for|for
control|(
name|regnum
operator|=
literal|0
init|;
name|regnum
operator|<
name|NUM_REGS
condition|;
name|regnum
operator|++
control|)
block|{
name|read_register_gen
argument_list|(
name|regnum
argument_list|,
name|regbuf
argument_list|)
expr_stmt|;
name|sp
operator|=
name|push_bytes
argument_list|(
name|sp
argument_list|,
name|regbuf
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sp
operator|+=
operator|(
literal|2
operator|*
name|REGISTER_SIZE
operator|)
expr_stmt|;
name|write_register
argument_list|(
name|SP_REGNUM
argument_list|,
name|sp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pop_frame
parameter_list|()
block|{
name|struct
name|frame_info
modifier|*
name|frame
init|=
name|get_current_frame
argument_list|()
decl_stmt|;
name|CORE_ADDR
name|fp
decl_stmt|;
name|int
name|regnum
decl_stmt|;
name|struct
name|frame_saved_regs
name|fsr
decl_stmt|;
name|char
name|regbuf
index|[
name|MAX_REGISTER_RAW_SIZE
index|]
decl_stmt|;
name|fp
operator|=
name|FRAME_FP
argument_list|(
name|frame
argument_list|)
expr_stmt|;
name|get_frame_saved_regs
argument_list|(
name|frame
argument_list|,
operator|&
name|fsr
argument_list|)
expr_stmt|;
for|for
control|(
name|regnum
operator|=
literal|0
init|;
name|regnum
operator|<
name|NUM_REGS
condition|;
name|regnum
operator|++
control|)
block|{
name|CORE_ADDR
name|adr
decl_stmt|;
name|adr
operator|=
name|fsr
operator|.
name|regs
index|[
name|regnum
index|]
expr_stmt|;
if|if
condition|(
name|adr
condition|)
block|{
name|read_memory
argument_list|(
name|adr
argument_list|,
name|regbuf
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
name|write_register_bytes
argument_list|(
name|REGISTER_BYTE
argument_list|(
name|regnum
argument_list|)
argument_list|,
name|regbuf
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|write_register
argument_list|(
name|FP_REGNUM
argument_list|,
name|read_memory_integer
argument_list|(
name|fp
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|PC_REGNUM
argument_list|,
name|read_memory_integer
argument_list|(
name|fp
operator|+
literal|4
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|SP_REGNUM
argument_list|,
name|fp
operator|+
literal|8
argument_list|)
expr_stmt|;
name|flush_cached_frames
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Simulate single-step.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|NORMAL4
block|,
comment|/* a normal 4 byte insn */
name|NORMAL8
block|,
comment|/* a normal 8 byte insn */
name|BRANCH4
block|,
comment|/* a 4 byte branch insn, including ones without delay slots */
name|BRANCH8
block|,
comment|/* an 8 byte branch insn, including ones with delay slots */
block|}
name|insn_type
typedef|;
end_typedef

begin_comment
comment|/* Return the type of INSN and store in TARGET the destination address of a    branch if this is one.  */
end_comment

begin_comment
comment|/* ??? Need to verify all cases are properly handled.  */
end_comment

begin_function
specifier|static
name|insn_type
name|get_insn_type
parameter_list|(
name|insn
parameter_list|,
name|pc
parameter_list|,
name|target
parameter_list|)
name|unsigned
name|long
name|insn
decl_stmt|;
name|CORE_ADDR
name|pc
decl_stmt|,
decl|*
name|target
decl_stmt|;
end_function

begin_block
block|{
name|unsigned
name|long
name|limm
decl_stmt|;
switch|switch
condition|(
name|insn
operator|>>
literal|27
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|1
case|:
case|case
literal|2
case|:
comment|/* load/store insns */
if|if
condition|(
name|LIMM_P
argument_list|(
name|X_A
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|||
name|LIMM_P
argument_list|(
name|X_B
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|||
name|LIMM_P
argument_list|(
name|X_C
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
return|return
name|NORMAL8
return|;
return|return
name|NORMAL4
return|;
case|case
literal|4
case|:
case|case
literal|5
case|:
case|case
literal|6
case|:
comment|/* branch insns */
operator|*
name|target
operator|=
name|pc
operator|+
literal|4
operator|+
name|X_L
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* ??? It isn't clear that this is always the right answer. 	 The problem occurs when the next insn is an 8 byte insn.  If the 	 branch is conditional there's no worry as there shouldn't be an 8 	 byte insn following.  The programmer may be cheating if s/he knows 	 the branch will never be taken, but we don't deal with that. 	 Note that the programmer is also allowed to play games by putting 	 an insn with long immediate data in the delay slot and then duplicate 	 the long immediate data at the branch target.  Ugh!  */
if|if
condition|(
name|X_N
argument_list|(
name|insn
argument_list|)
operator|==
literal|0
condition|)
return|return
name|BRANCH4
return|;
return|return
name|BRANCH8
return|;
case|case
literal|7
case|:
comment|/* jump insns */
if|if
condition|(
name|LIMM_P
argument_list|(
name|X_B
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
block|{
name|limm
operator|=
name|read_memory_integer
argument_list|(
name|pc
operator|+
literal|4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
operator|*
name|target
operator|=
name|ARC_PC_TO_REAL_ADDRESS
argument_list|(
name|limm
argument_list|)
expr_stmt|;
return|return
name|BRANCH8
return|;
block|}
if|if
condition|(
name|SHIMM_P
argument_list|(
name|X_B
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
operator|*
name|target
operator|=
name|ARC_PC_TO_REAL_ADDRESS
argument_list|(
name|X_D
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|*
name|target
operator|=
name|ARC_PC_TO_REAL_ADDRESS
argument_list|(
name|read_register
argument_list|(
name|X_B
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|X_Q
argument_list|(
name|insn
argument_list|)
operator|==
literal|0
operator|&&
name|X_N
argument_list|(
name|insn
argument_list|)
operator|==
literal|0
condition|)
return|return
name|BRANCH4
return|;
return|return
name|BRANCH8
return|;
default|default :
comment|/* arithmetic insns, etc. */
if|if
condition|(
name|LIMM_P
argument_list|(
name|X_A
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|||
name|LIMM_P
argument_list|(
name|X_B
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|||
name|LIMM_P
argument_list|(
name|X_C
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
return|return
name|NORMAL8
return|;
return|return
name|NORMAL4
return|;
block|}
block|}
end_block

begin_comment
comment|/* single_step() is called just before we want to resume the inferior, if we    want to single-step it but there is no hardware or kernel single-step    support.  We find all the possible targets of the coming instruction and    breakpoint them.     single_step is also called just after the inferior stops.  If we had    set up a simulated single-step, we undo our damage.  */
end_comment

begin_function
name|void
name|arc_software_single_step
parameter_list|(
name|ignore
parameter_list|,
name|insert_breakpoints_p
parameter_list|)
name|enum
name|target_signal
name|ignore
decl_stmt|;
comment|/* sig but we don't need it */
name|int
name|insert_breakpoints_p
decl_stmt|;
block|{
specifier|static
name|CORE_ADDR
name|next_pc
decl_stmt|,
name|target
decl_stmt|;
specifier|static
name|int
name|brktrg_p
decl_stmt|;
typedef|typedef
name|char
name|binsn_quantum
index|[
name|BREAKPOINT_MAX
index|]
typedef|;
specifier|static
name|binsn_quantum
name|break_mem
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|insert_breakpoints_p
condition|)
block|{
name|insn_type
name|type
decl_stmt|;
name|CORE_ADDR
name|pc
decl_stmt|;
name|unsigned
name|long
name|insn
decl_stmt|;
name|pc
operator|=
name|read_register
argument_list|(
name|PC_REGNUM
argument_list|)
expr_stmt|;
name|insn
operator|=
name|read_memory_integer
argument_list|(
name|pc
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|type
operator|=
name|get_insn_type
argument_list|(
name|insn
argument_list|,
name|pc
argument_list|,
operator|&
name|target
argument_list|)
expr_stmt|;
comment|/* Always set a breakpoint for the insn after the branch.  */
name|next_pc
operator|=
name|pc
operator|+
operator|(
operator|(
name|type
operator|==
name|NORMAL8
operator|||
name|type
operator|==
name|BRANCH8
operator|)
condition|?
literal|8
else|:
literal|4
operator|)
expr_stmt|;
name|target_insert_breakpoint
argument_list|(
name|next_pc
argument_list|,
name|break_mem
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|brktrg_p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|==
name|BRANCH4
operator|||
name|type
operator|==
name|BRANCH8
operator|)
comment|/* Watch out for branches to the following location. 	     We just stored a breakpoint there and another call to 	     target_insert_breakpoint will think the real insn is the 	     breakpoint we just stored there.  */
operator|&&
name|target
operator|!=
name|next_pc
condition|)
block|{
name|brktrg_p
operator|=
literal|1
expr_stmt|;
name|target_insert_breakpoint
argument_list|(
name|target
argument_list|,
name|break_mem
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Remove breakpoints.  */
name|target_remove_breakpoint
argument_list|(
name|next_pc
argument_list|,
name|break_mem
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|brktrg_p
condition|)
name|target_remove_breakpoint
argument_list|(
name|target
argument_list|,
name|break_mem
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* Fix the pc.  */
name|stop_pc
operator|-=
name|DECR_PC_AFTER_BREAK
expr_stmt|;
name|write_pc
argument_list|(
name|stop_pc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|GET_LONGJMP_TARGET
end_ifdef

begin_comment
comment|/* Figure out where the longjmp will land.  Slurp the args out of the stack.    We expect the first arg to be a pointer to the jmp_buf structure from which    we extract the pc (JB_PC) that we will land at.  The pc is copied into PC.    This routine returns true on success. */
end_comment

begin_function
name|int
name|get_longjmp_target
parameter_list|(
name|pc
parameter_list|)
name|CORE_ADDR
modifier|*
name|pc
decl_stmt|;
block|{
name|char
name|buf
index|[
name|TARGET_PTR_BIT
operator|/
name|TARGET_CHAR_BIT
index|]
decl_stmt|;
name|CORE_ADDR
name|sp
decl_stmt|,
name|jb_addr
decl_stmt|;
name|sp
operator|=
name|read_register
argument_list|(
name|SP_REGNUM
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_read_memory
argument_list|(
name|sp
operator|+
name|SP_ARG0
argument_list|,
comment|/* Offset of first arg on stack */
name|buf
argument_list|,
name|TARGET_PTR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|)
condition|)
return|return
literal|0
return|;
name|jb_addr
operator|=
name|extract_address
argument_list|(
name|buf
argument_list|,
name|TARGET_PTR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_read_memory
argument_list|(
name|jb_addr
operator|+
name|JB_PC
operator|*
name|JB_ELEMENT_SIZE
argument_list|,
name|buf
argument_list|,
name|TARGET_PTR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|)
condition|)
return|return
literal|0
return|;
operator|*
name|pc
operator|=
name|extract_address
argument_list|(
name|buf
argument_list|,
name|TARGET_PTR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* GET_LONGJMP_TARGET */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Disassemble one instruction.  */
end_comment

begin_function
specifier|static
name|int
name|arc_print_insn
parameter_list|(
name|vma
parameter_list|,
name|info
parameter_list|)
name|bfd_vma
name|vma
decl_stmt|;
name|disassemble_info
modifier|*
name|info
decl_stmt|;
block|{
specifier|static
name|int
name|current_mach
decl_stmt|;
specifier|static
name|int
name|current_endian
decl_stmt|;
specifier|static
name|disassembler_ftype
name|current_disasm
decl_stmt|;
if|if
condition|(
name|current_disasm
operator|==
name|NULL
operator|||
name|arc_bfd_mach_type
operator|!=
name|current_mach
operator|||
name|TARGET_BYTE_ORDER
operator|!=
name|current_endian
condition|)
block|{
name|current_mach
operator|=
name|arc_bfd_mach_type
expr_stmt|;
name|current_endian
operator|=
name|TARGET_BYTE_ORDER
expr_stmt|;
name|current_disasm
operator|=
name|arc_get_disassembler
argument_list|(
name|current_mach
argument_list|,
name|current_endian
operator|==
name|BIG_ENDIAN
argument_list|)
expr_stmt|;
block|}
return|return
call|(
modifier|*
name|current_disasm
call|)
argument_list|(
name|vma
argument_list|,
name|info
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Command to set cpu type.  */
end_comment

begin_function
name|void
name|arc_set_cpu_type_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|tmp_arc_cpu_type
operator|==
name|NULL
operator|||
operator|*
name|tmp_arc_cpu_type
operator|==
literal|'\0'
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"The known ARC cpu types are as follows:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|arc_cpu_type_table
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
operator|++
name|i
control|)
name|printf_unfiltered
argument_list|(
literal|"%s\n"
argument_list|,
name|arc_cpu_type_table
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
comment|/* Restore the value.  */
name|tmp_arc_cpu_type
operator|=
name|strsave
argument_list|(
name|arc_cpu_type
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|arc_set_cpu_type
argument_list|(
name|tmp_arc_cpu_type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"Unknown cpu type `%s'."
argument_list|,
name|tmp_arc_cpu_type
argument_list|)
expr_stmt|;
comment|/* Restore its value.  */
name|tmp_arc_cpu_type
operator|=
name|strsave
argument_list|(
name|arc_cpu_type
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|arc_show_cpu_type_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{ }
end_function

begin_comment
comment|/* Modify the actual cpu type.    Result is a boolean indicating success.  */
end_comment

begin_function
name|int
name|arc_set_cpu_type
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|arc_cpu_type_table
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|str
argument_list|,
name|arc_cpu_type_table
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|arc_cpu_type
operator|=
name|str
expr_stmt|;
name|arc_bfd_mach_type
operator|=
name|arc_cpu_type_table
index|[
name|i
index|]
operator|.
name|value
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|_initialize_arc_tdep
parameter_list|()
block|{
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
name|c
operator|=
name|add_set_cmd
argument_list|(
literal|"cpu"
argument_list|,
name|class_support
argument_list|,
name|var_string_noescape
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|tmp_arc_cpu_type
argument_list|,
literal|"Set the type of ARC cpu in use.\n\ This command has two purposes.  In a multi-cpu system it lets one\n\ change the cpu being debugged.  It also gives one access to\n\ cpu-type-specific registers and recognize cpu-type-specific instructions.\ "
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|c
operator|->
name|function
operator|.
name|cfunc
operator|=
name|arc_set_cpu_type_command
expr_stmt|;
name|c
operator|=
name|add_show_from_set
argument_list|(
name|c
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|c
operator|->
name|function
operator|.
name|cfunc
operator|=
name|arc_show_cpu_type_command
expr_stmt|;
comment|/* We have to use strsave here because the `set' command frees it before      setting a new value.  */
name|tmp_arc_cpu_type
operator|=
name|strsave
argument_list|(
name|DEFAULT_ARC_CPU_TYPE
argument_list|)
expr_stmt|;
name|arc_set_cpu_type
argument_list|(
name|tmp_arc_cpu_type
argument_list|)
expr_stmt|;
name|c
operator|=
name|add_set_cmd
argument_list|(
literal|"displaypipeline"
argument_list|,
name|class_support
argument_list|,
name|var_zinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|display_pipeline_p
argument_list|,
literal|"Set pipeline display (simulator only).\n\ When enabled, the state of the pipeline after each cycle is displayed."
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|c
operator|=
name|add_show_from_set
argument_list|(
name|c
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|c
operator|=
name|add_set_cmd
argument_list|(
literal|"debugpipeline"
argument_list|,
name|class_support
argument_list|,
name|var_zinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|debug_pipeline_p
argument_list|,
literal|"Set pipeline debug display (simulator only).\n\ When enabled, debugging information about the pipeline is displayed."
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|c
operator|=
name|add_show_from_set
argument_list|(
name|c
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|c
operator|=
name|add_set_cmd
argument_list|(
literal|"cputimer"
argument_list|,
name|class_support
argument_list|,
name|var_zinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|cpu_timer
argument_list|,
literal|"Set maximum cycle count (simulator only).\n\ Control will return to gdb if the timer expires.\n\ A negative value disables the timer."
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|c
operator|=
name|add_show_from_set
argument_list|(
name|c
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|tm_print_insn
operator|=
name|arc_print_insn
expr_stmt|;
block|}
end_function

end_unit

