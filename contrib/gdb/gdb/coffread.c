begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Read coff symbol tables and convert to internal format, for GDB.    Copyright 1987, 88, 89, 90, 91, 92, 93, 94, 96, 97, 1998              Free Software Foundation, Inc.    Contributed by David D. Johnson, Brown University (ddj@cs.brown.edu).  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_include
include|#
directive|include
file|"breakpoint.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"coff/internal.h"
end_include

begin_comment
comment|/* Internal format of COFF symbols in BFD */
end_comment

begin_include
include|#
directive|include
file|"libcoff.h"
end_include

begin_comment
comment|/* FIXME secret internal data from BFD */
end_comment

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"buildsym.h"
end_include

begin_include
include|#
directive|include
file|"gdb-stabs.h"
end_include

begin_include
include|#
directive|include
file|"stabsread.h"
end_include

begin_include
include|#
directive|include
file|"complaints.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_struct
struct|struct
name|coff_symfile_info
block|{
name|file_ptr
name|min_lineno_offset
decl_stmt|;
comment|/* Where in file lowest line#s are */
name|file_ptr
name|max_lineno_offset
decl_stmt|;
comment|/* 1+last byte of line#s in file */
name|CORE_ADDR
name|textaddr
decl_stmt|;
comment|/* Addr of .text section. */
name|unsigned
name|int
name|textsize
decl_stmt|;
comment|/* Size of .text section. */
name|struct
name|stab_section_list
modifier|*
name|stabsects
decl_stmt|;
comment|/* .stab sections.  */
name|asection
modifier|*
name|stabstrsect
decl_stmt|;
comment|/* Section pointer for .stab section */
name|char
modifier|*
name|stabstrdata
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Translate an external name string into a user-visible name.  */
end_comment

begin_define
define|#
directive|define
name|EXTERNAL_NAME
parameter_list|(
name|string
parameter_list|,
name|abfd
parameter_list|)
define|\
value|(string[0] == bfd_get_symbol_leading_char(abfd)? string+1: string)
end_define

begin_comment
comment|/* To be an sdb debug type, type must have at least a basic or primary    derived type.  Using this rather than checking against T_NULL is    said to prevent core dumps if we try to operate on Michael Bloom    dbx-in-coff file.  */
end_comment

begin_define
define|#
directive|define
name|SDB_TYPE
parameter_list|(
name|type
parameter_list|)
value|(BTYPE(type) | (type& N_TMASK))
end_define

begin_comment
comment|/* Convert from an sdb register number to an internal gdb register number.    This should be defined in tm.h, if REGISTER_NAMES is not set up    to map one to one onto the sdb register numbers.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SDB_REG_TO_REGNUM
end_ifndef

begin_define
define|#
directive|define
name|SDB_REG_TO_REGNUM
parameter_list|(
name|value
parameter_list|)
value|(value)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Core address of start and end of text of current source file.    This comes from a ".text" symbol where x_nlinno> 0.  */
end_comment

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|current_source_start_addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|current_source_end_addr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The addresses of the symbol table stream and number of symbols    of the object file we are reading (as copied into core).  */
end_comment

begin_decl_stmt
specifier|static
name|bfd
modifier|*
name|nlist_bfd_global
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nlist_nsyms_global
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Vector of line number information.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|linetable
modifier|*
name|line_vector
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Index of next entry to go in line_vector_index.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|line_vector_index
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last line number recorded in the line vector.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|prev_line_number
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of elements allocated for line_vector currently.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|line_vector_length
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointers to scratch storage, used for reading raw symbols and auxents.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|temp_sym
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|temp_aux
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Local variables that hold the shift and mask values for the    COFF file that we are currently reading.  These come back to us    from BFD, and are referenced by their macro names, as well as    internally to the BTYPE, ISPTR, ISFCN, ISARY, ISTAG, and DECREF    macros from include/coff/internal.h .  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|local_n_btmask
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|local_n_btshft
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|local_n_tmask
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|local_n_tshift
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|N_BTMASK
value|local_n_btmask
end_define

begin_define
define|#
directive|define
name|N_BTSHFT
value|local_n_btshft
end_define

begin_define
define|#
directive|define
name|N_TMASK
value|local_n_tmask
end_define

begin_define
define|#
directive|define
name|N_TSHIFT
value|local_n_tshift
end_define

begin_comment
comment|/* Local variables that hold the sizes in the file of various COFF structures.    (We only need to know this to read them from the file -- BFD will then    translate the data in them, into `internal_xxx' structs in the right    byte order, alignment, etc.)  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|local_linesz
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|local_symesz
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|local_auxesz
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is set if this is a PE format file.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pe_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain of typedefs of pointers to empty struct/union types.    They are chained thru the SYMBOL_VALUE_CHAIN.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|symbol
modifier|*
name|opaque_type_chain
index|[
name|HASHSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Complaints about various problems in the file being read  */
end_comment

begin_decl_stmt
name|struct
name|complaint
name|ef_complaint
init|=
block|{
literal|"Unmatched .ef symbol(s) ignored starting at symnum %d"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|ef_stack_complaint
init|=
block|{
literal|"`.ef' symbol without matching `.bf' symbol ignored starting at symnum %d"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|eb_stack_complaint
init|=
block|{
literal|"`.eb' symbol without matching `.bb' symbol ignored starting at symnum %d"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|bf_no_aux_complaint
init|=
block|{
literal|"`.bf' symbol %d has no aux entry"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|ef_no_aux_complaint
init|=
block|{
literal|"`.ef' symbol %d has no aux entry"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|lineno_complaint
init|=
block|{
literal|"Line number pointer %d lower than start of line numbers"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|unexpected_type_complaint
init|=
block|{
literal|"Unexpected type for symbol %s"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|bad_sclass_complaint
init|=
block|{
literal|"Bad n_sclass for symbol %s"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|misordered_blocks_complaint
init|=
block|{
literal|"Blocks out of order at address %x"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|tagndx_bad_complaint
init|=
block|{
literal|"Symbol table entry for %s has bad tagndx value"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|eb_complaint
init|=
block|{
literal|"Mismatched .eb symbol ignored starting at symnum %d"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Simplified internal version of coff symbol table information */
end_comment

begin_struct
struct|struct
name|coff_symbol
block|{
name|char
modifier|*
name|c_name
decl_stmt|;
name|int
name|c_symnum
decl_stmt|;
comment|/* symbol number of this entry */
name|int
name|c_naux
decl_stmt|;
comment|/* 0 if syment only, 1 if syment + auxent, etc */
name|long
name|c_value
decl_stmt|;
name|int
name|c_sclass
decl_stmt|;
name|int
name|c_secnum
decl_stmt|;
name|unsigned
name|int
name|c_type
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|coff_read_struct_type
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|decode_base_type
name|PARAMS
argument_list|(
operator|(
expr|struct
name|coff_symbol
operator|*
operator|,
name|unsigned
name|int
operator|,
expr|union
name|internal_auxent
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|decode_type
name|PARAMS
argument_list|(
operator|(
expr|struct
name|coff_symbol
operator|*
operator|,
name|unsigned
name|int
operator|,
expr|union
name|internal_auxent
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|decode_function_type
name|PARAMS
argument_list|(
operator|(
expr|struct
name|coff_symbol
operator|*
operator|,
name|unsigned
name|int
operator|,
expr|union
name|internal_auxent
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|coff_read_enum_type
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|symbol
modifier|*
name|process_coff_symbol
name|PARAMS
argument_list|(
operator|(
expr|struct
name|coff_symbol
operator|*
operator|,
expr|union
name|internal_auxent
operator|*
operator|,
expr|struct
name|section_offsets
operator|*
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|patch_opaque_types
name|PARAMS
argument_list|(
operator|(
expr|struct
name|symtab
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|patch_type
name|PARAMS
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|,
expr|struct
name|type
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|enter_linenos
name|PARAMS
argument_list|(
operator|(
name|long
operator|,
name|int
operator|,
name|int
operator|,
expr|struct
name|section_offsets
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_linetab
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|init_lineno
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|long
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|getsymname
name|PARAMS
argument_list|(
operator|(
expr|struct
name|internal_syment
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|coff_getfilename
name|PARAMS
argument_list|(
operator|(
expr|union
name|internal_auxent
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_stringtab
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|init_stringtab
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|read_one_sym
name|PARAMS
argument_list|(
operator|(
expr|struct
name|coff_symbol
operator|*
operator|,
expr|struct
name|internal_syment
operator|*
operator|,
expr|union
name|internal_auxent
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|coff_symtab_read
name|PARAMS
argument_list|(
operator|(
name|long
operator|,
name|int
operator|,
expr|struct
name|section_offsets
operator|*
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|find_linenos
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|sec_ptr
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|coff_symfile_init
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|coff_new_init
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|coff_symfile_read
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|,
expr|struct
name|section_offsets
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|coff_symfile_finish
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|record_minimal_symbol
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|CORE_ADDR
operator|,
expr|enum
name|minimal_symbol_type
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|coff_end_symtab
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|complete_symtab
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|CORE_ADDR
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|coff_start_symtab
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|coff_record_line
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|CORE_ADDR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|coff_alloc_type
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
modifier|*
name|coff_lookup_type
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|coff_locate_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* We are called once per section from coff_symfile_read.  We    need to examine each section we are passed, check to see    if it is something we are interested in processing, and    if so, stash away some access information for the section.     FIXME: The section names should not be hardwired strings (what    should they be?  I don't think most object file formats have enough    section flags to specify what kind of debug section it is    -kingdon).  */
end_comment

begin_function
specifier|static
name|void
name|coff_locate_sections
parameter_list|(
name|abfd
parameter_list|,
name|sectp
parameter_list|,
name|csip
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sectp
decl_stmt|;
name|PTR
name|csip
decl_stmt|;
block|{
specifier|register
name|struct
name|coff_symfile_info
modifier|*
name|csi
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|csi
operator|=
operator|(
expr|struct
name|coff_symfile_info
operator|*
operator|)
name|csip
expr_stmt|;
name|name
operator|=
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sectp
argument_list|)
expr_stmt|;
if|if
condition|(
name|STREQ
argument_list|(
name|name
argument_list|,
literal|".text"
argument_list|)
condition|)
block|{
name|csi
operator|->
name|textaddr
operator|=
name|bfd_section_vma
argument_list|(
name|abfd
argument_list|,
name|sectp
argument_list|)
expr_stmt|;
name|csi
operator|->
name|textsize
operator|+=
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|sectp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".text"
argument_list|,
sizeof|sizeof
expr|".text"
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|csi
operator|->
name|textsize
operator|+=
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|sectp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|name
argument_list|,
literal|".stabstr"
argument_list|)
condition|)
block|{
name|csi
operator|->
name|stabstrsect
operator|=
name|sectp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".stab"
argument_list|,
sizeof|sizeof
expr|".stab"
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
comment|/* We can have multiple .stab sections if linked with          --split-by-reloc.  */
for|for
control|(
name|s
operator|=
name|name
operator|+
sizeof|sizeof
expr|".stab"
operator|-
literal|1
init|;
operator|*
name|s
operator|!=
literal|'\0'
condition|;
name|s
operator|++
control|)
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
condition|)
block|{
name|struct
name|stab_section_list
modifier|*
name|n
decl_stmt|,
modifier|*
modifier|*
name|pn
decl_stmt|;
name|n
operator|=
operator|(
operator|(
expr|struct
name|stab_section_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|stab_section_list
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|n
operator|->
name|section
operator|=
name|sectp
expr_stmt|;
name|n
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|pn
operator|=
operator|&
name|csi
operator|->
name|stabsects
init|;
operator|*
name|pn
operator|!=
name|NULL
condition|;
name|pn
operator|=
operator|&
operator|(
operator|*
name|pn
operator|)
operator|->
name|next
control|)
empty_stmt|;
operator|*
name|pn
operator|=
name|n
expr_stmt|;
comment|/* This will be run after coffstab_build_psymtabs is called              in coff_symfile_read, at which point we no longer need              the information.  */
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Return the section_offsets* that CS points to.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cs_to_section
name|PARAMS
argument_list|(
operator|(
expr|struct
name|coff_symbol
operator|*
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|find_targ_sec_arg
block|{
name|int
name|targ_index
decl_stmt|;
name|asection
modifier|*
modifier|*
name|resultp
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|void
name|find_targ_sec
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|find_targ_sec
parameter_list|(
name|abfd
parameter_list|,
name|sect
parameter_list|,
name|obj
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sect
decl_stmt|;
name|PTR
name|obj
decl_stmt|;
block|{
name|struct
name|find_targ_sec_arg
modifier|*
name|args
init|=
operator|(
expr|struct
name|find_targ_sec_arg
operator|*
operator|)
name|obj
decl_stmt|;
if|if
condition|(
name|sect
operator|->
name|target_index
operator|==
name|args
operator|->
name|targ_index
condition|)
operator|*
name|args
operator|->
name|resultp
operator|=
name|sect
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the section number (SECT_OFF_*) that CS points to.  */
end_comment

begin_function
specifier|static
name|int
name|cs_to_section
parameter_list|(
name|cs
parameter_list|,
name|objfile
parameter_list|)
name|struct
name|coff_symbol
modifier|*
name|cs
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|asection
modifier|*
name|sect
init|=
name|NULL
decl_stmt|;
name|struct
name|find_targ_sec_arg
name|args
decl_stmt|;
name|int
name|off
init|=
name|SECT_OFF_TEXT
decl_stmt|;
name|args
operator|.
name|targ_index
operator|=
name|cs
operator|->
name|c_secnum
expr_stmt|;
name|args
operator|.
name|resultp
operator|=
operator|&
name|sect
expr_stmt|;
name|bfd_map_over_sections
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|find_targ_sec
argument_list|,
operator|&
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|sect
operator|!=
name|NULL
condition|)
block|{
comment|/* This is the section.  Figure out what SECT_OFF_* code it is.  */
if|if
condition|(
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|sect
argument_list|)
operator|&
name|SEC_CODE
condition|)
name|off
operator|=
name|SECT_OFF_TEXT
expr_stmt|;
elseif|else
if|if
condition|(
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|sect
argument_list|)
operator|&
name|SEC_LOAD
condition|)
name|off
operator|=
name|SECT_OFF_DATA
expr_stmt|;
else|else
name|off
operator|=
name|SECT_OFF_BSS
expr_stmt|;
block|}
return|return
name|off
return|;
block|}
end_function

begin_comment
comment|/* Return the address of the section of a COFF symbol.  */
end_comment

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|cs_section_address
name|PARAMS
argument_list|(
operator|(
expr|struct
name|coff_symbol
operator|*
operator|,
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|CORE_ADDR
name|cs_section_address
parameter_list|(
name|cs
parameter_list|,
name|abfd
parameter_list|)
name|struct
name|coff_symbol
modifier|*
name|cs
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|asection
modifier|*
name|sect
init|=
name|NULL
decl_stmt|;
name|struct
name|find_targ_sec_arg
name|args
decl_stmt|;
name|CORE_ADDR
name|addr
init|=
literal|0
decl_stmt|;
name|args
operator|.
name|targ_index
operator|=
name|cs
operator|->
name|c_secnum
expr_stmt|;
name|args
operator|.
name|resultp
operator|=
operator|&
name|sect
expr_stmt|;
name|bfd_map_over_sections
argument_list|(
name|abfd
argument_list|,
name|find_targ_sec
argument_list|,
operator|&
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|sect
operator|!=
name|NULL
condition|)
name|addr
operator|=
name|bfd_get_section_vma
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|sect
argument_list|)
expr_stmt|;
return|return
name|addr
return|;
block|}
end_function

begin_comment
comment|/* Look up a coff type-number index.  Return the address of the slot    where the type for that index is stored.    The type-number is in INDEX.      This can be used for finding the type associated with that index    or for associating a new type with the index.  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
modifier|*
name|coff_lookup_type
parameter_list|(
name|index
parameter_list|)
specifier|register
name|int
name|index
decl_stmt|;
block|{
if|if
condition|(
name|index
operator|>=
name|type_vector_length
condition|)
block|{
name|int
name|old_vector_length
init|=
name|type_vector_length
decl_stmt|;
name|type_vector_length
operator|*=
literal|2
expr_stmt|;
if|if
condition|(
name|index
comment|/* is still */
operator|>=
name|type_vector_length
condition|)
name|type_vector_length
operator|=
name|index
operator|*
literal|2
expr_stmt|;
name|type_vector
operator|=
operator|(
expr|struct
name|type
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|type_vector
argument_list|,
name|type_vector_length
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|type_vector
index|[
name|old_vector_length
index|]
argument_list|,
literal|0
argument_list|,
operator|(
name|type_vector_length
operator|-
name|old_vector_length
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|&
name|type_vector
index|[
name|index
index|]
return|;
block|}
end_function

begin_comment
comment|/* Make sure there is a type allocated for type number index    and return the type object.    This can create an empty (zeroed) type object.  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|coff_alloc_type
parameter_list|(
name|index
parameter_list|)
name|int
name|index
decl_stmt|;
block|{
specifier|register
name|struct
name|type
modifier|*
modifier|*
name|type_addr
init|=
name|coff_lookup_type
argument_list|(
name|index
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|type
modifier|*
name|type
init|=
operator|*
name|type_addr
decl_stmt|;
comment|/* If we are referring to a type not known at all yet,      allocate an empty type for it.      We will fill it in later if we find out how.  */
if|if
condition|(
name|type
operator|==
name|NULL
condition|)
block|{
name|type
operator|=
name|alloc_type
argument_list|(
name|current_objfile
argument_list|)
expr_stmt|;
operator|*
name|type_addr
operator|=
name|type
expr_stmt|;
block|}
return|return
name|type
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Record a line number entry for line LINE at address PC.    FIXME:  Use record_line instead.  */
end_comment

begin_function
specifier|static
name|void
name|coff_record_line
parameter_list|(
name|line
parameter_list|,
name|pc
parameter_list|)
name|int
name|line
decl_stmt|;
name|CORE_ADDR
name|pc
decl_stmt|;
block|{
name|struct
name|linetable_entry
modifier|*
name|e
decl_stmt|;
comment|/* Make sure line vector is big enough.  */
if|if
condition|(
name|line_vector_index
operator|+
literal|2
operator|>=
name|line_vector_length
condition|)
block|{
name|line_vector_length
operator|*=
literal|2
expr_stmt|;
name|line_vector
operator|=
operator|(
expr|struct
name|linetable
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|line_vector
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|linetable
argument_list|)
operator|+
operator|(
name|line_vector_length
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|linetable_entry
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
name|e
operator|=
name|line_vector
operator|->
name|item
operator|+
name|line_vector_index
operator|++
expr_stmt|;
name|e
operator|->
name|line
operator|=
name|line
expr_stmt|;
name|e
operator|->
name|pc
operator|=
name|pc
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Start a new symtab for a new source file.    This is called when a COFF ".file" symbol is seen;    it indicates the start of data for one original source file.  */
end_comment

begin_function
specifier|static
name|void
name|coff_start_symtab
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|start_symtab
argument_list|(
comment|/* We fill in the filename later.  start_symtab puts 		   this pointer into last_source_file and we put it in 		   subfiles->name, which end_symtab frees; that's why 		   it must be malloc'd.  */
name|savestring
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
argument_list|,
comment|/* We never know the directory name for COFF.  */
name|NULL
argument_list|,
comment|/* The start address is irrelevant, since we set 		   last_source_start_addr in coff_end_symtab.  */
literal|0
argument_list|)
expr_stmt|;
name|record_debugformat
argument_list|(
literal|"COFF"
argument_list|)
expr_stmt|;
comment|/* Initialize the source file line number information for this file.  */
if|if
condition|(
name|line_vector
condition|)
comment|/* Unlikely, but maybe possible? */
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|line_vector
argument_list|)
expr_stmt|;
name|line_vector_index
operator|=
literal|0
expr_stmt|;
name|line_vector_length
operator|=
literal|1000
expr_stmt|;
name|prev_line_number
operator|=
operator|-
literal|2
expr_stmt|;
comment|/* Force first line number to be explicit */
name|line_vector
operator|=
operator|(
expr|struct
name|linetable
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|linetable
argument_list|)
operator|+
name|line_vector_length
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|linetable_entry
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Save the vital information from when starting to read a file,    for use when closing off the current file.    NAME is the file name the symbols came from, START_ADDR is the first    text address for the file, and SIZE is the number of bytes of text.  */
end_comment

begin_function
specifier|static
name|void
name|complete_symtab
parameter_list|(
name|name
parameter_list|,
name|start_addr
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|CORE_ADDR
name|start_addr
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
block|{
if|if
condition|(
name|last_source_file
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|last_source_file
argument_list|)
expr_stmt|;
name|last_source_file
operator|=
name|savestring
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|current_source_start_addr
operator|=
name|start_addr
expr_stmt|;
name|current_source_end_addr
operator|=
name|start_addr
operator|+
name|size
expr_stmt|;
if|if
condition|(
name|current_objfile
operator|->
name|ei
operator|.
name|entry_point
operator|>=
name|current_source_start_addr
operator|&&
name|current_objfile
operator|->
name|ei
operator|.
name|entry_point
operator|<
name|current_source_end_addr
condition|)
block|{
name|current_objfile
operator|->
name|ei
operator|.
name|entry_file_lowpc
operator|=
name|current_source_start_addr
expr_stmt|;
name|current_objfile
operator|->
name|ei
operator|.
name|entry_file_highpc
operator|=
name|current_source_end_addr
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Finish the symbol definitions for one main source file,    close off all the lexical contexts for that file    (creating struct block's for them), then make the    struct symtab for that file and put it in the list of all such. */
end_comment

begin_function
specifier|static
name|void
name|coff_end_symtab
parameter_list|(
name|objfile
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|struct
name|symtab
modifier|*
name|symtab
decl_stmt|;
name|last_source_start_addr
operator|=
name|current_source_start_addr
expr_stmt|;
comment|/* For no good reason, this file stores the number of entries in a      separate variable instead of in line_vector->nitems.  Fix it.  */
if|if
condition|(
name|line_vector
condition|)
name|line_vector
operator|->
name|nitems
operator|=
name|line_vector_index
expr_stmt|;
comment|/* For COFF, we only have one subfile, so we can just look at      subfiles and not worry about there being other elements in the      chain.  We fill in various fields now because we didn't know them      before (or because doing it now is simply an artifact of how this      file used to be written).  */
name|subfiles
operator|->
name|line_vector
operator|=
name|line_vector
expr_stmt|;
name|symtab
operator|=
name|end_symtab
argument_list|(
name|current_source_end_addr
argument_list|,
name|objfile
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|symtab
operator|!=
name|NULL
condition|)
name|free_named_symtabs
argument_list|(
name|symtab
operator|->
name|filename
argument_list|)
expr_stmt|;
comment|/* Reinitialize for beginning of new file. */
name|line_vector
operator|=
literal|0
expr_stmt|;
name|line_vector_length
operator|=
operator|-
literal|1
expr_stmt|;
name|last_source_file
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|record_minimal_symbol
parameter_list|(
name|name
parameter_list|,
name|address
parameter_list|,
name|type
parameter_list|,
name|objfile
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|CORE_ADDR
name|address
decl_stmt|;
name|enum
name|minimal_symbol_type
name|type
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
comment|/* We don't want TDESC entry points in the minimal symbol table */
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'@'
condition|)
return|return;
name|prim_record_minimal_symbol
argument_list|(
name|name
argument_list|,
name|address
argument_list|,
name|type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* coff_symfile_init ()    is the coff-specific initialization routine for reading symbols.    It is passed a struct objfile which contains, among other things,    the BFD for the file whose symbols are being read, and a slot for    a pointer to "private data" which we fill with cookies and other    treats for coff_symfile_read ().     We will only be called if this is a COFF or COFF-like file.    BFD handles figuring out the format of the file, and code in symtab.c    uses BFD's determination to vector to us.     The ultimate result is a new symtab (or, FIXME, eventually a psymtab).  */
end_comment

begin_function
specifier|static
name|void
name|coff_symfile_init
parameter_list|(
name|objfile
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
comment|/* Allocate struct to keep track of stab reading. */
name|objfile
operator|->
name|sym_stab_info
operator|=
operator|(
expr|struct
name|dbx_symfile_info
operator|*
operator|)
name|xmmalloc
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dbx_symfile_info
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|PTR
operator|)
name|objfile
operator|->
name|sym_stab_info
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dbx_symfile_info
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Allocate struct to keep track of the symfile */
name|objfile
operator|->
name|sym_private
operator|=
name|xmmalloc
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|coff_symfile_info
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|objfile
operator|->
name|sym_private
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|coff_symfile_info
argument_list|)
argument_list|)
expr_stmt|;
comment|/* COFF objects may be reordered, so set OBJF_REORDERED.  If we      find this causes a significant slowdown in gdb then we could      set it in the debug symbol readers only when necessary.  */
name|objfile
operator|->
name|flags
operator||=
name|OBJF_REORDERED
expr_stmt|;
name|init_entry_point_info
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function is called for every section; it finds the outer limits    of the line table (minimum and maximum file offset) so that the    mainline code can read the whole thing for efficiency.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|find_linenos
parameter_list|(
name|abfd
parameter_list|,
name|asect
parameter_list|,
name|vpinfo
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|sec_ptr
name|asect
decl_stmt|;
name|PTR
name|vpinfo
decl_stmt|;
block|{
name|struct
name|coff_symfile_info
modifier|*
name|info
decl_stmt|;
name|int
name|size
decl_stmt|,
name|count
decl_stmt|;
name|file_ptr
name|offset
decl_stmt|,
name|maxoff
decl_stmt|;
comment|/* WARNING WILL ROBINSON!  ACCESSING BFD-PRIVATE DATA HERE!  FIXME!  */
name|count
operator|=
name|asect
operator|->
name|lineno_count
expr_stmt|;
comment|/* End of warning */
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return;
name|size
operator|=
name|count
operator|*
name|local_linesz
expr_stmt|;
name|info
operator|=
operator|(
expr|struct
name|coff_symfile_info
operator|*
operator|)
name|vpinfo
expr_stmt|;
comment|/* WARNING WILL ROBINSON!  ACCESSING BFD-PRIVATE DATA HERE!  FIXME!  */
name|offset
operator|=
name|asect
operator|->
name|line_filepos
expr_stmt|;
comment|/* End of warning */
if|if
condition|(
name|offset
operator|<
name|info
operator|->
name|min_lineno_offset
operator|||
name|info
operator|->
name|min_lineno_offset
operator|==
literal|0
condition|)
name|info
operator|->
name|min_lineno_offset
operator|=
name|offset
expr_stmt|;
name|maxoff
operator|=
name|offset
operator|+
name|size
expr_stmt|;
if|if
condition|(
name|maxoff
operator|>
name|info
operator|->
name|max_lineno_offset
condition|)
name|info
operator|->
name|max_lineno_offset
operator|=
name|maxoff
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The BFD for this file -- only good while we're actively reading    symbols into a psymtab or a symtab.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd
modifier|*
name|symfile_bfd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Read a symbol file, after initialization by coff_symfile_init.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|coff_symfile_read
parameter_list|(
name|objfile
parameter_list|,
name|section_offsets
parameter_list|,
name|mainline
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|section_offsets
modifier|*
name|section_offsets
decl_stmt|;
name|int
name|mainline
decl_stmt|;
block|{
name|struct
name|coff_symfile_info
modifier|*
name|info
decl_stmt|;
name|struct
name|dbx_symfile_info
modifier|*
name|dbxinfo
decl_stmt|;
name|bfd
modifier|*
name|abfd
init|=
name|objfile
operator|->
name|obfd
decl_stmt|;
name|coff_data_type
modifier|*
name|cdata
init|=
name|coff_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
specifier|register
name|int
name|val
decl_stmt|;
name|int
name|num_symbols
decl_stmt|;
name|int
name|symtab_offset
decl_stmt|;
name|int
name|stringtab_offset
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|back_to
decl_stmt|;
name|int
name|stabstrsize
decl_stmt|;
name|info
operator|=
operator|(
expr|struct
name|coff_symfile_info
operator|*
operator|)
name|objfile
operator|->
name|sym_private
expr_stmt|;
name|dbxinfo
operator|=
name|objfile
operator|->
name|sym_stab_info
expr_stmt|;
name|symfile_bfd
operator|=
name|abfd
expr_stmt|;
comment|/* Kludge for swap routines */
comment|/* WARNING WILL ROBINSON!  ACCESSING BFD-PRIVATE DATA HERE!  FIXME!  */
name|num_symbols
operator|=
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* How many syms */
name|symtab_offset
operator|=
name|cdata
operator|->
name|sym_filepos
expr_stmt|;
comment|/* Symbol table file offset */
name|stringtab_offset
operator|=
name|symtab_offset
operator|+
comment|/* String table file offset */
name|num_symbols
operator|*
name|cdata
operator|->
name|local_symesz
expr_stmt|;
comment|/* Set a few file-statics that give us specific information about      the particular COFF file format we're reading.  */
name|local_linesz
operator|=
name|cdata
operator|->
name|local_linesz
expr_stmt|;
name|local_n_btmask
operator|=
name|cdata
operator|->
name|local_n_btmask
expr_stmt|;
name|local_n_btshft
operator|=
name|cdata
operator|->
name|local_n_btshft
expr_stmt|;
name|local_n_tmask
operator|=
name|cdata
operator|->
name|local_n_tmask
expr_stmt|;
name|local_n_tshift
operator|=
name|cdata
operator|->
name|local_n_tshift
expr_stmt|;
name|local_linesz
operator|=
name|cdata
operator|->
name|local_linesz
expr_stmt|;
name|local_symesz
operator|=
name|cdata
operator|->
name|local_symesz
expr_stmt|;
name|local_auxesz
operator|=
name|cdata
operator|->
name|local_auxesz
expr_stmt|;
comment|/* Allocate space for raw symbol and aux entries, based on their      space requirements as reported by BFD.  */
name|temp_sym
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|cdata
operator|->
name|local_symesz
operator|+
name|cdata
operator|->
name|local_auxesz
argument_list|)
expr_stmt|;
name|temp_aux
operator|=
name|temp_sym
operator|+
name|cdata
operator|->
name|local_symesz
expr_stmt|;
name|back_to
operator|=
name|make_cleanup
argument_list|(
operator|(
name|make_cleanup_func
operator|)
name|free_current_contents
argument_list|,
operator|&
name|temp_sym
argument_list|)
expr_stmt|;
comment|/* We need to know whether this is a PE file, because in PE files,      unlike standard COFF files, symbol values are stored as offsets      from the section address, rather than as absolute addresses.      FIXME: We should use BFD to read the symbol table, and thus avoid      this problem.  */
name|pe_file
operator|=
name|strncmp
argument_list|(
name|bfd_get_target
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|)
argument_list|,
literal|"pe"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
expr_stmt|;
comment|/* End of warning */
comment|/* Read the line number table, all at once.  */
name|info
operator|->
name|min_lineno_offset
operator|=
literal|0
expr_stmt|;
name|info
operator|->
name|max_lineno_offset
operator|=
literal|0
expr_stmt|;
name|bfd_map_over_sections
argument_list|(
name|abfd
argument_list|,
name|find_linenos
argument_list|,
operator|(
name|PTR
operator|)
name|info
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
operator|(
name|make_cleanup_func
operator|)
name|free_linetab
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|val
operator|=
name|init_lineno
argument_list|(
name|abfd
argument_list|,
name|info
operator|->
name|min_lineno_offset
argument_list|,
name|info
operator|->
name|max_lineno_offset
operator|-
name|info
operator|->
name|min_lineno_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"\"%s\": error reading line numbers\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Now read the string table, all at once.  */
name|make_cleanup
argument_list|(
operator|(
name|make_cleanup_func
operator|)
name|free_stringtab
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|val
operator|=
name|init_stringtab
argument_list|(
name|abfd
argument_list|,
name|stringtab_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"\"%s\": can't get string table"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|init_minimal_symbol_collection
argument_list|()
expr_stmt|;
name|make_cleanup
argument_list|(
operator|(
name|make_cleanup_func
operator|)
name|discard_minimal_symbols
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Now that the executable file is positioned at symbol table,      process it and define symbols accordingly.  */
name|coff_symtab_read
argument_list|(
operator|(
name|long
operator|)
name|symtab_offset
argument_list|,
name|num_symbols
argument_list|,
name|section_offsets
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* Sort symbols alphabetically within each block.  */
block|{
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
name|objfile
operator|->
name|symtabs
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
name|sort_symtab_syms
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
comment|/* Install any minimal symbols that have been collected as the current      minimal symbols for this objfile.  */
name|install_minimal_symbols
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
name|bfd_map_over_sections
argument_list|(
name|abfd
argument_list|,
name|coff_locate_sections
argument_list|,
operator|(
name|PTR
operator|)
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|stabsects
condition|)
block|{
comment|/* FIXME: dubious.  Why can't we use something normal like 	 bfd_get_section_contents?  */
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|abfd
operator|->
name|where
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|stabstrsize
operator|=
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|info
operator|->
name|stabstrsect
argument_list|)
expr_stmt|;
name|coffstab_build_psymtabs
argument_list|(
name|objfile
argument_list|,
name|section_offsets
argument_list|,
name|mainline
argument_list|,
name|info
operator|->
name|textaddr
argument_list|,
name|info
operator|->
name|textsize
argument_list|,
name|info
operator|->
name|stabsects
argument_list|,
name|info
operator|->
name|stabstrsect
operator|->
name|filepos
argument_list|,
name|stabstrsize
argument_list|)
expr_stmt|;
block|}
name|do_cleanups
argument_list|(
name|back_to
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|coff_new_init
parameter_list|(
name|ignore
parameter_list|)
name|struct
name|objfile
modifier|*
name|ignore
decl_stmt|;
block|{ }
end_function

begin_comment
comment|/* Perform any local cleanups required when we are done with a particular    objfile.  I.E, we are in the process of discarding all symbol information    for an objfile, freeing up all memory held for it, and unlinking the    objfile struct from the global list of known objfiles. */
end_comment

begin_function
specifier|static
name|void
name|coff_symfile_finish
parameter_list|(
name|objfile
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
if|if
condition|(
name|objfile
operator|->
name|sym_private
operator|!=
name|NULL
condition|)
block|{
name|mfree
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
name|objfile
operator|->
name|sym_private
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given pointers to a symbol table in coff style exec file,    analyze them and create struct symtab's describing the symbols.    NSYMS is the number of symbols in the symbol table.    We read them one at a time using read_one_sym ().  */
end_comment

begin_function
specifier|static
name|void
name|coff_symtab_read
parameter_list|(
name|symtab_offset
parameter_list|,
name|nsyms
parameter_list|,
name|section_offsets
parameter_list|,
name|objfile
parameter_list|)
name|long
name|symtab_offset
decl_stmt|;
name|int
name|nsyms
decl_stmt|;
name|struct
name|section_offsets
modifier|*
name|section_offsets
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
specifier|register
name|struct
name|context_stack
modifier|*
name|new
decl_stmt|;
name|struct
name|coff_symbol
name|coff_symbol
decl_stmt|;
specifier|register
name|struct
name|coff_symbol
modifier|*
name|cs
init|=
operator|&
name|coff_symbol
decl_stmt|;
specifier|static
name|struct
name|internal_syment
name|main_sym
decl_stmt|;
specifier|static
name|union
name|internal_auxent
name|main_aux
decl_stmt|;
name|struct
name|coff_symbol
name|fcn_cs_saved
decl_stmt|;
specifier|static
name|struct
name|internal_syment
name|fcn_sym_saved
decl_stmt|;
specifier|static
name|union
name|internal_auxent
name|fcn_aux_saved
decl_stmt|;
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
comment|/* A .file is open.  */
name|int
name|in_source_file
init|=
literal|0
decl_stmt|;
name|int
name|next_file_symnum
init|=
operator|-
literal|1
decl_stmt|;
comment|/* Name of the current file.  */
name|char
modifier|*
name|filestring
init|=
literal|""
decl_stmt|;
name|int
name|depth
init|=
literal|0
decl_stmt|;
name|int
name|fcn_first_line
init|=
literal|0
decl_stmt|;
name|int
name|fcn_last_line
init|=
literal|0
decl_stmt|;
name|int
name|fcn_start_addr
init|=
literal|0
decl_stmt|;
name|long
name|fcn_line_ptr
init|=
literal|0
decl_stmt|;
name|int
name|val
decl_stmt|;
name|CORE_ADDR
name|tmpaddr
decl_stmt|;
comment|/* Work around a stdio bug in SunOS4.1.1 (this makes me nervous....      it's hard to know I've really worked around it.  The fix should be      harmless, anyway).  The symptom of the bug is that the first      fread (in read_one_sym), will (in my example) actually get data      from file offset 268, when the fseek was to 264 (and ftell shows      264).  This causes all hell to break loose.  I was unable to      reproduce this on a short test program which operated on the same      file, performing (I think) the same sequence of operations.       It stopped happening when I put in this (former) rewind().       FIXME: Find out if this has been reported to Sun, whether it has      been fixed in a later release, etc.  */
name|bfd_seek
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Position to read the symbol table. */
name|val
operator|=
name|bfd_seek
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
operator|(
name|long
operator|)
name|symtab_offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|objfile
operator|->
name|name
argument_list|)
expr_stmt|;
name|current_objfile
operator|=
name|objfile
expr_stmt|;
name|nlist_bfd_global
operator|=
name|objfile
operator|->
name|obfd
expr_stmt|;
name|nlist_nsyms_global
operator|=
name|nsyms
expr_stmt|;
name|last_source_file
operator|=
name|NULL
expr_stmt|;
name|memset
argument_list|(
name|opaque_type_chain
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|opaque_type_chain
argument_list|)
expr_stmt|;
if|if
condition|(
name|type_vector
condition|)
comment|/* Get rid of previous one */
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|type_vector
argument_list|)
expr_stmt|;
name|type_vector_length
operator|=
literal|160
expr_stmt|;
name|type_vector
operator|=
operator|(
expr|struct
name|type
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|type_vector_length
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|type_vector
argument_list|,
literal|0
argument_list|,
name|type_vector_length
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|coff_start_symtab
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|symnum
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|symnum
operator|<
name|nsyms
condition|)
block|{
name|QUIT
expr_stmt|;
comment|/* Make this command interruptable.  */
name|read_one_sym
argument_list|(
name|cs
argument_list|,
operator|&
name|main_sym
argument_list|,
operator|&
name|main_aux
argument_list|)
expr_stmt|;
if|if
condition|(
name|cs
operator|->
name|c_symnum
operator|==
name|next_file_symnum
operator|&&
name|cs
operator|->
name|c_sclass
operator|!=
name|C_FILE
condition|)
block|{
if|if
condition|(
name|last_source_file
condition|)
name|coff_end_symtab
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
name|coff_start_symtab
argument_list|(
literal|"_globals_"
argument_list|)
expr_stmt|;
name|complete_symtab
argument_list|(
literal|"_globals_"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* done with all files, everything from here on out is globals */
block|}
comment|/* Special case for file with type declarations only, no text.  */
if|if
condition|(
operator|!
name|last_source_file
operator|&&
name|SDB_TYPE
argument_list|(
name|cs
operator|->
name|c_type
argument_list|)
operator|&&
name|cs
operator|->
name|c_secnum
operator|==
name|N_DEBUG
condition|)
name|complete_symtab
argument_list|(
name|filestring
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Typedefs should not be treated as symbol definitions.  */
if|if
condition|(
name|ISFCN
argument_list|(
name|cs
operator|->
name|c_type
argument_list|)
operator|&&
name|cs
operator|->
name|c_sclass
operator|!=
name|C_TPDEF
condition|)
block|{
comment|/* Record all functions -- external and static -- in minsyms. */
name|tmpaddr
operator|=
name|cs
operator|->
name|c_value
operator|+
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
expr_stmt|;
name|record_minimal_symbol
argument_list|(
name|cs
operator|->
name|c_name
argument_list|,
name|tmpaddr
argument_list|,
name|mst_text
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|fcn_line_ptr
operator|=
name|main_aux
operator|.
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_lnnoptr
expr_stmt|;
name|fcn_start_addr
operator|=
name|tmpaddr
expr_stmt|;
name|fcn_cs_saved
operator|=
operator|*
name|cs
expr_stmt|;
name|fcn_sym_saved
operator|=
name|main_sym
expr_stmt|;
name|fcn_aux_saved
operator|=
name|main_aux
expr_stmt|;
continue|continue;
block|}
switch|switch
condition|(
name|cs
operator|->
name|c_sclass
condition|)
block|{
case|case
name|C_EFCN
case|:
case|case
name|C_EXTDEF
case|:
case|case
name|C_ULABEL
case|:
case|case
name|C_USTATIC
case|:
case|case
name|C_LINE
case|:
case|case
name|C_ALIAS
case|:
case|case
name|C_HIDDEN
case|:
name|complain
argument_list|(
operator|&
name|bad_sclass_complaint
argument_list|,
name|cs
operator|->
name|c_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_FILE
case|:
comment|/* c_value field contains symnum of next .file entry in table 	       or symnum of first global after last .file.  */
name|next_file_symnum
operator|=
name|cs
operator|->
name|c_value
expr_stmt|;
if|if
condition|(
name|cs
operator|->
name|c_naux
operator|>
literal|0
condition|)
name|filestring
operator|=
name|coff_getfilename
argument_list|(
operator|&
name|main_aux
argument_list|)
expr_stmt|;
else|else
name|filestring
operator|=
literal|""
expr_stmt|;
comment|/* Complete symbol table for last object file 	       containing debugging information.  */
if|if
condition|(
name|last_source_file
condition|)
block|{
name|coff_end_symtab
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
name|coff_start_symtab
argument_list|(
name|filestring
argument_list|)
expr_stmt|;
block|}
name|in_source_file
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* C_LABEL is used for labels and static functions.  Including 	     it here allows gdb to see static functions when no debug 	     info is available.  */
case|case
name|C_LABEL
case|:
comment|/* However, labels within a function can make weird backtraces, 	       so filter them out (from phdm@macqel.be). */
if|if
condition|(
name|within_function
condition|)
break|break;
case|case
name|C_STAT
case|:
case|case
name|C_THUMBLABEL
case|:
case|case
name|C_THUMBSTAT
case|:
case|case
name|C_THUMBSTATFUNC
case|:
if|if
condition|(
name|cs
operator|->
name|c_name
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
name|STREQ
argument_list|(
name|cs
operator|->
name|c_name
argument_list|,
literal|".text"
argument_list|)
condition|)
block|{
comment|/* FIXME:  don't wire in ".text" as section name 		     or symbol name! */
comment|/* Check for in_source_file deals with case of 		     a file with debugging symbols 		     followed by a later file with no symbols.  */
if|if
condition|(
name|in_source_file
condition|)
name|complete_symtab
argument_list|(
name|filestring
argument_list|,
name|cs
operator|->
name|c_value
operator|+
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
argument_list|,
name|main_aux
operator|.
name|x_scn
operator|.
name|x_scnlen
argument_list|)
expr_stmt|;
name|in_source_file
operator|=
literal|0
expr_stmt|;
block|}
comment|/* flush rest of '.' symbols */
break|break;
block|}
elseif|else
if|if
condition|(
operator|!
name|SDB_TYPE
argument_list|(
name|cs
operator|->
name|c_type
argument_list|)
operator|&&
name|cs
operator|->
name|c_name
index|[
literal|0
index|]
operator|==
literal|'L'
operator|&&
operator|(
name|strncmp
argument_list|(
name|cs
operator|->
name|c_name
argument_list|,
literal|"LI%"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|cs
operator|->
name|c_name
argument_list|,
literal|"LF%"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|cs
operator|->
name|c_name
argument_list|,
literal|"LC%"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|cs
operator|->
name|c_name
argument_list|,
literal|"LP%"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|cs
operator|->
name|c_name
argument_list|,
literal|"LPB%"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|cs
operator|->
name|c_name
argument_list|,
literal|"LBB%"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|cs
operator|->
name|c_name
argument_list|,
literal|"LBE%"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|cs
operator|->
name|c_name
argument_list|,
literal|"LPBX%"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|)
condition|)
comment|/* At least on a 3b1, gcc generates swbeg and string labels 		 that look like this.  Ignore them.  */
break|break;
comment|/* fall in for static symbols that don't start with '.' */
case|case
name|C_THUMBEXT
case|:
case|case
name|C_THUMBEXTFUNC
case|:
case|case
name|C_EXT
case|:
block|{
comment|/* Record it in the minimal symbols regardless of 		 SDB_TYPE.  This parallels what we do for other debug 		 formats, and probably is needed to make 		 print_address_symbolic work right without the (now 		 gone) "set fast-symbolic-addr off" kludge.  */
comment|/* FIXME: should use mst_abs, and not relocate, if absolute.  */
name|enum
name|minimal_symbol_type
name|ms_type
decl_stmt|;
name|int
name|sec
decl_stmt|;
if|if
condition|(
name|cs
operator|->
name|c_secnum
operator|==
name|N_UNDEF
condition|)
block|{
comment|/* This is a common symbol.  See if the target 		     environment knows where it has been relocated to.  */
name|CORE_ADDR
name|reladdr
decl_stmt|;
if|if
condition|(
name|target_lookup_symbol
argument_list|(
name|cs
operator|->
name|c_name
argument_list|,
operator|&
name|reladdr
argument_list|)
condition|)
block|{
comment|/* Error in lookup; ignore symbol.  */
break|break;
block|}
name|tmpaddr
operator|=
name|reladdr
expr_stmt|;
comment|/* The address has already been relocated; make sure that 		     objfile_relocate doesn't relocate it again.  */
name|sec
operator|=
operator|-
literal|2
expr_stmt|;
name|ms_type
operator|=
name|cs
operator|->
name|c_sclass
operator|==
name|C_EXT
operator|||
name|cs
operator|->
name|c_sclass
operator|==
name|C_THUMBEXT
condition|?
name|mst_bss
else|:
name|mst_file_bss
expr_stmt|;
block|}
else|else
block|{
name|sec
operator|=
name|cs_to_section
argument_list|(
name|cs
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|tmpaddr
operator|=
name|cs
operator|->
name|c_value
expr_stmt|;
if|if
condition|(
name|cs
operator|->
name|c_sclass
operator|==
name|C_EXT
operator|||
name|cs
operator|->
name|c_sclass
operator|==
name|C_THUMBEXTFUNC
operator|||
name|cs
operator|->
name|c_sclass
operator|==
name|C_THUMBEXT
condition|)
name|tmpaddr
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|sec
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sec
condition|)
block|{
case|case
name|SECT_OFF_TEXT
case|:
case|case
name|SECT_OFF_RODATA
case|:
name|ms_type
operator|=
name|cs
operator|->
name|c_sclass
operator|==
name|C_EXT
operator|||
name|cs
operator|->
name|c_sclass
operator|==
name|C_THUMBEXTFUNC
operator|||
name|cs
operator|->
name|c_sclass
operator|==
name|C_THUMBEXT
condition|?
name|mst_text
else|:
name|mst_file_text
expr_stmt|;
ifdef|#
directive|ifdef
name|SMASH_TEXT_ADDRESS
if|if
condition|(
name|tmpaddr
operator|&
literal|1
condition|)
comment|/* FIXME: delete this line */
name|SMASH_TEXT_ADDRESS
argument_list|(
name|tmpaddr
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|SECT_OFF_DATA
case|:
name|ms_type
operator|=
name|cs
operator|->
name|c_sclass
operator|==
name|C_EXT
operator|||
name|cs
operator|->
name|c_sclass
operator|==
name|C_THUMBEXT
condition|?
name|mst_data
else|:
name|mst_file_data
expr_stmt|;
break|break;
case|case
name|SECT_OFF_BSS
case|:
name|ms_type
operator|=
name|cs
operator|->
name|c_sclass
operator|==
name|C_EXT
operator|||
name|cs
operator|->
name|c_sclass
operator|==
name|C_THUMBEXT
condition|?
name|mst_data
else|:
name|mst_file_data
expr_stmt|;
break|break;
default|default:
name|ms_type
operator|=
name|mst_unknown
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|cs
operator|->
name|c_name
index|[
literal|0
index|]
operator|!=
literal|'@'
comment|/* Skip tdesc symbols */
condition|)
block|{
name|struct
name|minimal_symbol
modifier|*
name|msym
decl_stmt|;
name|msym
operator|=
name|prim_record_minimal_symbol_and_info
argument_list|(
name|cs
operator|->
name|c_name
argument_list|,
name|tmpaddr
argument_list|,
name|ms_type
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|long
operator|)
name|cs
operator|->
name|c_sclass
argument_list|,
name|sec
argument_list|,
name|NULL
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|COFF_MAKE_MSYMBOL_SPECIAL
if|if
condition|(
name|msym
condition|)
name|COFF_MAKE_MSYMBOL_SPECIAL
argument_list|(
name|cs
operator|->
name|c_sclass
argument_list|,
name|msym
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|SDB_TYPE
argument_list|(
name|cs
operator|->
name|c_type
argument_list|)
condition|)
block|{
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|sym
operator|=
name|process_coff_symbol
argument_list|(
name|cs
argument_list|,
operator|&
name|main_aux
argument_list|,
name|section_offsets
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|tmpaddr
expr_stmt|;
name|SYMBOL_SECTION
argument_list|(
name|sym
argument_list|)
operator|=
name|sec
expr_stmt|;
block|}
block|}
break|break;
case|case
name|C_FCN
case|:
if|if
condition|(
name|STREQ
argument_list|(
name|cs
operator|->
name|c_name
argument_list|,
literal|".bf"
argument_list|)
condition|)
block|{
name|within_function
operator|=
literal|1
expr_stmt|;
comment|/* value contains address of first non-init type code */
comment|/* main_aux.x_sym.x_misc.x_lnsz.x_lnno 			    contains line number of '{' } */
if|if
condition|(
name|cs
operator|->
name|c_naux
operator|!=
literal|1
condition|)
name|complain
argument_list|(
operator|&
name|bf_no_aux_complaint
argument_list|,
name|cs
operator|->
name|c_symnum
argument_list|)
expr_stmt|;
name|fcn_first_line
operator|=
name|main_aux
operator|.
name|x_sym
operator|.
name|x_misc
operator|.
name|x_lnsz
operator|.
name|x_lnno
expr_stmt|;
comment|/* Might want to check that locals are 0 and 		   context_stack_depth is zero, and complain if not.  */
name|depth
operator|=
literal|0
expr_stmt|;
name|new
operator|=
name|push_context
argument_list|(
name|depth
argument_list|,
name|fcn_start_addr
argument_list|)
expr_stmt|;
name|fcn_cs_saved
operator|.
name|c_name
operator|=
name|getsymname
argument_list|(
operator|&
name|fcn_sym_saved
argument_list|)
expr_stmt|;
name|new
operator|->
name|name
operator|=
name|process_coff_symbol
argument_list|(
operator|&
name|fcn_cs_saved
argument_list|,
operator|&
name|fcn_aux_saved
argument_list|,
name|section_offsets
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|cs
operator|->
name|c_name
argument_list|,
literal|".ef"
argument_list|)
condition|)
block|{
comment|/* the value of .ef is the address of epilogue code; 		   not useful for gdb.  */
comment|/* { main_aux.x_sym.x_misc.x_lnsz.x_lnno 			    contains number of lines to '}' */
if|if
condition|(
name|context_stack_depth
operator|<=
literal|0
condition|)
block|{
comment|/* We attempted to pop an empty context stack */
name|complain
argument_list|(
operator|&
name|ef_stack_complaint
argument_list|,
name|cs
operator|->
name|c_symnum
argument_list|)
expr_stmt|;
name|within_function
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|new
operator|=
name|pop_context
argument_list|()
expr_stmt|;
comment|/* Stack must be empty now.  */
if|if
condition|(
name|context_stack_depth
operator|>
literal|0
operator|||
name|new
operator|==
name|NULL
condition|)
block|{
name|complain
argument_list|(
operator|&
name|ef_complaint
argument_list|,
name|cs
operator|->
name|c_symnum
argument_list|)
expr_stmt|;
name|within_function
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cs
operator|->
name|c_naux
operator|!=
literal|1
condition|)
block|{
name|complain
argument_list|(
operator|&
name|ef_no_aux_complaint
argument_list|,
name|cs
operator|->
name|c_symnum
argument_list|)
expr_stmt|;
name|fcn_last_line
operator|=
literal|0x7FFFFFFF
expr_stmt|;
block|}
else|else
block|{
name|fcn_last_line
operator|=
name|main_aux
operator|.
name|x_sym
operator|.
name|x_misc
operator|.
name|x_lnsz
operator|.
name|x_lnno
expr_stmt|;
block|}
name|enter_linenos
argument_list|(
name|fcn_line_ptr
argument_list|,
name|fcn_first_line
argument_list|,
name|fcn_last_line
argument_list|,
name|section_offsets
argument_list|)
expr_stmt|;
name|finish_block
argument_list|(
name|new
operator|->
name|name
argument_list|,
operator|&
name|local_symbols
argument_list|,
name|new
operator|->
name|old_blocks
argument_list|,
name|new
operator|->
name|start_addr
argument_list|,
if|#
directive|if
name|defined
argument_list|(
name|FUNCTION_EPILOGUE_SIZE
argument_list|)
comment|/* This macro should be defined only on 				 machines where the 				 fcn_aux_saved.x_sym.x_misc.x_fsize 				 field is always zero. 				 So use the .bf record information that 				 points to the epilogue and add the size 				 of the epilogue.  */
name|cs
operator|->
name|c_value
operator|+
name|FUNCTION_EPILOGUE_SIZE
operator|+
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
argument_list|,
else|#
directive|else
name|fcn_cs_saved
operator|.
name|c_value
operator|+
name|fcn_aux_saved
operator|.
name|x_sym
operator|.
name|x_misc
operator|.
name|x_fsize
operator|+
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
argument_list|,
endif|#
directive|endif
name|objfile
argument_list|)
expr_stmt|;
name|within_function
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|C_BLOCK
case|:
if|if
condition|(
name|STREQ
argument_list|(
name|cs
operator|->
name|c_name
argument_list|,
literal|".bb"
argument_list|)
condition|)
block|{
name|tmpaddr
operator|=
name|cs
operator|->
name|c_value
expr_stmt|;
name|tmpaddr
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
expr_stmt|;
name|push_context
argument_list|(
operator|++
name|depth
argument_list|,
name|tmpaddr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|cs
operator|->
name|c_name
argument_list|,
literal|".eb"
argument_list|)
condition|)
block|{
if|if
condition|(
name|context_stack_depth
operator|<=
literal|0
condition|)
block|{
comment|/* We attempted to pop an empty context stack */
name|complain
argument_list|(
operator|&
name|eb_stack_complaint
argument_list|,
name|cs
operator|->
name|c_symnum
argument_list|)
expr_stmt|;
break|break;
block|}
name|new
operator|=
name|pop_context
argument_list|()
expr_stmt|;
if|if
condition|(
name|depth
operator|--
operator|!=
name|new
operator|->
name|depth
condition|)
block|{
name|complain
argument_list|(
operator|&
name|eb_complaint
argument_list|,
name|symnum
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|local_symbols
operator|&&
name|context_stack_depth
operator|>
literal|0
condition|)
block|{
name|tmpaddr
operator|=
name|cs
operator|->
name|c_value
operator|+
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
expr_stmt|;
comment|/* Make a block for the local symbols within.  */
name|finish_block
argument_list|(
literal|0
argument_list|,
operator|&
name|local_symbols
argument_list|,
name|new
operator|->
name|old_blocks
argument_list|,
name|new
operator|->
name|start_addr
argument_list|,
name|tmpaddr
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
comment|/* Now pop locals of block just finished.  */
name|local_symbols
operator|=
name|new
operator|->
name|locals
expr_stmt|;
block|}
break|break;
default|default:
name|process_coff_symbol
argument_list|(
name|cs
argument_list|,
operator|&
name|main_aux
argument_list|,
name|section_offsets
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|last_source_file
condition|)
name|coff_end_symtab
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
comment|/* Patch up any opaque types (references to types that are not defined      in the file where they are referenced, e.g. "struct foo *bar").  */
name|ALL_OBJFILE_SYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
name|patch_opaque_types
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|current_objfile
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Routines for reading headers and symbols from executable.  */
end_comment

begin_comment
comment|/* Read the next symbol, swap it, and return it in both internal_syment    form, and coff_symbol form.  Also return its first auxent, if any,    in internal_auxent form, and skip any other auxents.  */
end_comment

begin_function
specifier|static
name|void
name|read_one_sym
parameter_list|(
name|cs
parameter_list|,
name|sym
parameter_list|,
name|aux
parameter_list|)
specifier|register
name|struct
name|coff_symbol
modifier|*
name|cs
decl_stmt|;
specifier|register
name|struct
name|internal_syment
modifier|*
name|sym
decl_stmt|;
specifier|register
name|union
name|internal_auxent
modifier|*
name|aux
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|cs
operator|->
name|c_symnum
operator|=
name|symnum
expr_stmt|;
name|bfd_read
argument_list|(
name|temp_sym
argument_list|,
name|local_symesz
argument_list|,
literal|1
argument_list|,
name|nlist_bfd_global
argument_list|)
expr_stmt|;
name|bfd_coff_swap_sym_in
argument_list|(
name|symfile_bfd
argument_list|,
name|temp_sym
argument_list|,
operator|(
name|char
operator|*
operator|)
name|sym
argument_list|)
expr_stmt|;
name|cs
operator|->
name|c_naux
operator|=
name|sym
operator|->
name|n_numaux
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|cs
operator|->
name|c_naux
operator|>=
literal|1
condition|)
block|{
name|bfd_read
argument_list|(
name|temp_aux
argument_list|,
name|local_auxesz
argument_list|,
literal|1
argument_list|,
name|nlist_bfd_global
argument_list|)
expr_stmt|;
name|bfd_coff_swap_aux_in
argument_list|(
name|symfile_bfd
argument_list|,
name|temp_aux
argument_list|,
name|sym
operator|->
name|n_type
argument_list|,
name|sym
operator|->
name|n_sclass
argument_list|,
literal|0
argument_list|,
name|cs
operator|->
name|c_naux
argument_list|,
operator|(
name|char
operator|*
operator|)
name|aux
argument_list|)
expr_stmt|;
comment|/* If more than one aux entry, read past it (only the first aux        is important). */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|cs
operator|->
name|c_naux
condition|;
name|i
operator|++
control|)
name|bfd_read
argument_list|(
name|temp_aux
argument_list|,
name|local_auxesz
argument_list|,
literal|1
argument_list|,
name|nlist_bfd_global
argument_list|)
expr_stmt|;
block|}
name|cs
operator|->
name|c_name
operator|=
name|getsymname
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|cs
operator|->
name|c_value
operator|=
name|sym
operator|->
name|n_value
expr_stmt|;
name|cs
operator|->
name|c_sclass
operator|=
operator|(
name|sym
operator|->
name|n_sclass
operator|&
literal|0xff
operator|)
expr_stmt|;
name|cs
operator|->
name|c_secnum
operator|=
name|sym
operator|->
name|n_scnum
expr_stmt|;
name|cs
operator|->
name|c_type
operator|=
operator|(
name|unsigned
operator|)
name|sym
operator|->
name|n_type
expr_stmt|;
if|if
condition|(
operator|!
name|SDB_TYPE
argument_list|(
name|cs
operator|->
name|c_type
argument_list|)
condition|)
name|cs
operator|->
name|c_type
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|0
block|if (cs->c_sclass& 128)     printf("thumb symbol %s, class 0x%x\n", cs->c_name, cs->c_sclass);
endif|#
directive|endif
name|symnum
operator|+=
literal|1
operator|+
name|cs
operator|->
name|c_naux
expr_stmt|;
comment|/* The PE file format stores symbol values as offsets within the      section, rather than as absolute addresses.  We correct that      here, if the symbol has an appropriate storage class.  FIXME: We      should use BFD to read the symbols, rather than duplicating the      work here.  */
if|if
condition|(
name|pe_file
condition|)
block|{
switch|switch
condition|(
name|cs
operator|->
name|c_sclass
condition|)
block|{
case|case
name|C_EXT
case|:
case|case
name|C_THUMBEXT
case|:
case|case
name|C_THUMBEXTFUNC
case|:
case|case
name|C_SECTION
case|:
case|case
name|C_NT_WEAK
case|:
case|case
name|C_STAT
case|:
case|case
name|C_THUMBSTAT
case|:
case|case
name|C_THUMBSTATFUNC
case|:
case|case
name|C_LABEL
case|:
case|case
name|C_THUMBLABEL
case|:
case|case
name|C_BLOCK
case|:
case|case
name|C_FCN
case|:
case|case
name|C_EFCN
case|:
if|if
condition|(
name|cs
operator|->
name|c_secnum
operator|!=
literal|0
condition|)
name|cs
operator|->
name|c_value
operator|+=
name|cs_section_address
argument_list|(
name|cs
argument_list|,
name|symfile_bfd
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Support for string table handling */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|stringtab
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|init_stringtab
parameter_list|(
name|abfd
parameter_list|,
name|offset
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|long
name|offset
decl_stmt|;
block|{
name|long
name|length
decl_stmt|;
name|int
name|val
decl_stmt|;
name|unsigned
name|char
name|lengthbuf
index|[
literal|4
index|]
decl_stmt|;
name|free_stringtab
argument_list|()
expr_stmt|;
comment|/* If the file is stripped, the offset might be zero, indicating no      string table.  Just return with `stringtab' set to null. */
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|val
operator|=
name|bfd_read
argument_list|(
operator|(
name|char
operator|*
operator|)
name|lengthbuf
argument_list|,
sizeof|sizeof
name|lengthbuf
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|length
operator|=
name|bfd_h_get_32
argument_list|(
name|symfile_bfd
argument_list|,
name|lengthbuf
argument_list|)
expr_stmt|;
comment|/* If no string table is needed, then the file may end immediately      after the symbols.  Just return with `stringtab' set to null. */
if|if
condition|(
name|val
operator|!=
sizeof|sizeof
name|lengthbuf
operator|||
name|length
operator|<
sizeof|sizeof
name|lengthbuf
condition|)
return|return
literal|0
return|;
name|stringtab
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|length
argument_list|)
expr_stmt|;
comment|/* This is in target format (probably not very useful, and not currently      used), not host format.  */
name|memcpy
argument_list|(
name|stringtab
argument_list|,
name|lengthbuf
argument_list|,
sizeof|sizeof
name|lengthbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|==
sizeof|sizeof
name|length
condition|)
comment|/* Empty table -- just the count */
return|return
literal|0
return|;
name|val
operator|=
name|bfd_read
argument_list|(
name|stringtab
operator|+
sizeof|sizeof
name|lengthbuf
argument_list|,
name|length
operator|-
sizeof|sizeof
name|lengthbuf
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|length
operator|-
sizeof|sizeof
name|lengthbuf
operator|||
name|stringtab
index|[
name|length
operator|-
literal|1
index|]
operator|!=
literal|'\0'
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_stringtab
parameter_list|()
block|{
if|if
condition|(
name|stringtab
condition|)
name|free
argument_list|(
name|stringtab
argument_list|)
expr_stmt|;
name|stringtab
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|getsymname
parameter_list|(
name|symbol_entry
parameter_list|)
name|struct
name|internal_syment
modifier|*
name|symbol_entry
decl_stmt|;
block|{
specifier|static
name|char
name|buffer
index|[
name|SYMNMLEN
operator|+
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
if|if
condition|(
name|symbol_entry
operator|->
name|_n
operator|.
name|_n_n
operator|.
name|_n_zeroes
operator|==
literal|0
condition|)
block|{
comment|/* FIXME: Probably should be detecting corrupt symbol files by 	 seeing whether offset points to within the stringtab.  */
name|result
operator|=
name|stringtab
operator|+
name|symbol_entry
operator|->
name|_n
operator|.
name|_n_n
operator|.
name|_n_offset
expr_stmt|;
block|}
else|else
block|{
name|strncpy
argument_list|(
name|buffer
argument_list|,
name|symbol_entry
operator|->
name|_n
operator|.
name|_n_name
argument_list|,
name|SYMNMLEN
argument_list|)
expr_stmt|;
name|buffer
index|[
name|SYMNMLEN
index|]
operator|=
literal|'\0'
expr_stmt|;
name|result
operator|=
name|buffer
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Extract the file name from the aux entry of a C_FILE symbol.  Return    only the last component of the name.  Result is in static storage and    is only good for temporary use.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|coff_getfilename
parameter_list|(
name|aux_entry
parameter_list|)
name|union
name|internal_auxent
modifier|*
name|aux_entry
decl_stmt|;
block|{
specifier|static
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|temp
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
if|if
condition|(
name|aux_entry
operator|->
name|x_file
operator|.
name|x_n
operator|.
name|x_zeroes
operator|==
literal|0
condition|)
name|strcpy
argument_list|(
name|buffer
argument_list|,
name|stringtab
operator|+
name|aux_entry
operator|->
name|x_file
operator|.
name|x_n
operator|.
name|x_offset
argument_list|)
expr_stmt|;
else|else
block|{
name|strncpy
argument_list|(
name|buffer
argument_list|,
name|aux_entry
operator|->
name|x_file
operator|.
name|x_fname
argument_list|,
name|FILNMLEN
argument_list|)
expr_stmt|;
name|buffer
index|[
name|FILNMLEN
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|result
operator|=
name|buffer
expr_stmt|;
comment|/* FIXME: We should not be throwing away the information about what      directory.  It should go into dirname of the symtab, or some such      place.  */
if|if
condition|(
operator|(
name|temp
operator|=
name|strrchr
argument_list|(
name|result
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|result
operator|=
name|temp
operator|+
literal|1
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Support for line number handling.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|linetab
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|linetab_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|linetab_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Read in all the line numbers for fast lookups later.  Leave them in    external (unswapped) format in memory; we'll swap them as we enter    them into GDB's data structures.  */
end_comment

begin_function
specifier|static
name|int
name|init_lineno
parameter_list|(
name|abfd
parameter_list|,
name|offset
parameter_list|,
name|size
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|long
name|offset
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|int
name|val
decl_stmt|;
name|linetab_offset
operator|=
name|offset
expr_stmt|;
name|linetab_size
operator|=
name|size
expr_stmt|;
name|free_linetab
argument_list|()
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Allocate the desired table, plus a sentinel */
name|linetab
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|size
operator|+
name|local_linesz
argument_list|)
expr_stmt|;
name|val
operator|=
name|bfd_read
argument_list|(
name|linetab
argument_list|,
name|size
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|size
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Terminate it with an all-zero sentinel record */
name|memset
argument_list|(
name|linetab
operator|+
name|size
argument_list|,
literal|0
argument_list|,
name|local_linesz
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_linetab
parameter_list|()
block|{
if|if
condition|(
name|linetab
condition|)
name|free
argument_list|(
name|linetab
argument_list|)
expr_stmt|;
name|linetab
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|L_LNNO32
argument_list|)
end_if

begin_define
define|#
directive|define
name|L_LNNO32
parameter_list|(
name|lp
parameter_list|)
value|((lp)->l_lnno)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|enter_linenos
parameter_list|(
name|file_offset
parameter_list|,
name|first_line
parameter_list|,
name|last_line
parameter_list|,
name|section_offsets
parameter_list|)
name|long
name|file_offset
decl_stmt|;
specifier|register
name|int
name|first_line
decl_stmt|;
specifier|register
name|int
name|last_line
decl_stmt|;
name|struct
name|section_offsets
modifier|*
name|section_offsets
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|rawptr
decl_stmt|;
name|struct
name|internal_lineno
name|lptr
decl_stmt|;
if|if
condition|(
operator|!
name|linetab
condition|)
return|return ;
if|if
condition|(
name|file_offset
operator|<
name|linetab_offset
condition|)
block|{
name|complain
argument_list|(
operator|&
name|lineno_complaint
argument_list|,
name|file_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|file_offset
operator|>
name|linetab_size
condition|)
comment|/* Too big to be an offset? */
return|return;
name|file_offset
operator|+=
name|linetab_offset
expr_stmt|;
comment|/* Try reading at that linetab offset */
block|}
name|rawptr
operator|=
operator|&
name|linetab
index|[
name|file_offset
operator|-
name|linetab_offset
index|]
expr_stmt|;
comment|/* skip first line entry for each function */
name|rawptr
operator|+=
name|local_linesz
expr_stmt|;
comment|/* line numbers start at one for the first line of the function */
name|first_line
operator|--
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|bfd_coff_swap_lineno_in
argument_list|(
name|symfile_bfd
argument_list|,
name|rawptr
argument_list|,
operator|&
name|lptr
argument_list|)
expr_stmt|;
name|rawptr
operator|+=
name|local_linesz
expr_stmt|;
comment|/* The next function, or the sentinel, will have L_LNNO32 zero; we exit. */
if|if
condition|(
name|L_LNNO32
argument_list|(
operator|&
name|lptr
argument_list|)
operator|&&
name|L_LNNO32
argument_list|(
operator|&
name|lptr
argument_list|)
operator|<=
name|last_line
condition|)
name|coff_record_line
argument_list|(
name|first_line
operator|+
name|L_LNNO32
argument_list|(
operator|&
name|lptr
argument_list|)
argument_list|,
name|lptr
operator|.
name|l_addr
operator|.
name|l_paddr
operator|+
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|patch_type
parameter_list|(
name|type
parameter_list|,
name|real_type
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|struct
name|type
modifier|*
name|real_type
decl_stmt|;
block|{
specifier|register
name|struct
name|type
modifier|*
name|target
init|=
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|type
modifier|*
name|real_target
init|=
name|TYPE_TARGET_TYPE
argument_list|(
name|real_type
argument_list|)
decl_stmt|;
name|int
name|field_size
init|=
name|TYPE_NFIELDS
argument_list|(
name|real_target
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
decl_stmt|;
name|TYPE_LENGTH
argument_list|(
name|target
argument_list|)
operator|=
name|TYPE_LENGTH
argument_list|(
name|real_target
argument_list|)
expr_stmt|;
name|TYPE_NFIELDS
argument_list|(
name|target
argument_list|)
operator|=
name|TYPE_NFIELDS
argument_list|(
name|real_target
argument_list|)
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|target
argument_list|)
operator|=
operator|(
expr|struct
name|field
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|target
argument_list|,
name|field_size
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|target
argument_list|)
argument_list|,
name|TYPE_FIELDS
argument_list|(
name|real_target
argument_list|)
argument_list|,
name|field_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|real_target
argument_list|)
condition|)
block|{
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|target
argument_list|)
condition|)
name|free
argument_list|(
name|TYPE_NAME
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|target
argument_list|)
operator|=
name|concat
argument_list|(
name|TYPE_NAME
argument_list|(
name|real_target
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Patch up all appropriate typedef symbols in the opaque_type_chains    so that they can be used to print out opaque data structures properly.  */
end_comment

begin_function
specifier|static
name|void
name|patch_opaque_types
parameter_list|(
name|s
parameter_list|)
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|struct
name|block
modifier|*
name|b
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|symbol
modifier|*
name|real_sym
decl_stmt|;
comment|/* Go through the per-file symbols only */
name|b
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
argument_list|,
name|STATIC_BLOCK
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|BLOCK_NSYMS
argument_list|(
name|b
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
comment|/* Find completed typedefs to use to fix opaque ones. 	 Remove syms from the chain when their types are stored, 	 but search the whole chain, as there may be several syms 	 from different files with the same name.  */
name|real_sym
operator|=
name|BLOCK_SYM
argument_list|(
name|b
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|SYMBOL_CLASS
argument_list|(
name|real_sym
argument_list|)
operator|==
name|LOC_TYPEDEF
operator|&&
name|SYMBOL_NAMESPACE
argument_list|(
name|real_sym
argument_list|)
operator|==
name|VAR_NAMESPACE
operator|&&
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|real_sym
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_PTR
operator|&&
name|TYPE_LENGTH
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|real_sym
argument_list|)
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
specifier|register
name|char
modifier|*
name|name
init|=
name|SYMBOL_NAME
argument_list|(
name|real_sym
argument_list|)
decl_stmt|;
specifier|register
name|int
name|hash
init|=
name|hashname
argument_list|(
name|name
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
name|prev
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|sym
operator|=
name|opaque_type_chain
index|[
name|hash
index|]
init|;
name|sym
condition|;
control|)
block|{
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
index|[
literal|0
index|]
operator|&&
name|STREQ
argument_list|(
name|name
operator|+
literal|1
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|+
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|prev
condition|)
block|{
name|SYMBOL_VALUE_CHAIN
argument_list|(
name|prev
argument_list|)
operator|=
name|SYMBOL_VALUE_CHAIN
argument_list|(
name|sym
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|opaque_type_chain
index|[
name|hash
index|]
operator|=
name|SYMBOL_VALUE_CHAIN
argument_list|(
name|sym
argument_list|)
expr_stmt|;
block|}
name|patch_type
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|,
name|SYMBOL_TYPE
argument_list|(
name|real_sym
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
condition|)
block|{
name|sym
operator|=
name|SYMBOL_VALUE_CHAIN
argument_list|(
name|prev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sym
operator|=
name|opaque_type_chain
index|[
name|hash
index|]
expr_stmt|;
block|}
block|}
else|else
block|{
name|prev
operator|=
name|sym
expr_stmt|;
name|sym
operator|=
name|SYMBOL_VALUE_CHAIN
argument_list|(
name|sym
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|struct
name|symbol
modifier|*
name|process_coff_symbol
parameter_list|(
name|cs
parameter_list|,
name|aux
parameter_list|,
name|section_offsets
parameter_list|,
name|objfile
parameter_list|)
specifier|register
name|struct
name|coff_symbol
modifier|*
name|cs
decl_stmt|;
specifier|register
name|union
name|internal_auxent
modifier|*
name|aux
decl_stmt|;
name|struct
name|section_offsets
modifier|*
name|section_offsets
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
specifier|register
name|struct
name|symbol
modifier|*
name|sym
init|=
operator|(
expr|struct
name|symbol
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|memset
argument_list|(
name|sym
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
name|name
operator|=
name|cs
operator|->
name|c_name
expr_stmt|;
name|name
operator|=
name|EXTERNAL_NAME
argument_list|(
name|name
argument_list|,
name|objfile
operator|->
name|obfd
argument_list|)
expr_stmt|;
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|=
name|obsavestring
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|)
expr_stmt|;
name|SYMBOL_LANGUAGE
argument_list|(
name|sym
argument_list|)
operator|=
name|language_auto
expr_stmt|;
name|SYMBOL_INIT_DEMANGLED_NAME
argument_list|(
name|sym
argument_list|,
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|)
expr_stmt|;
comment|/* default assumptions */
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|cs
operator|->
name|c_value
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
name|SYMBOL_SECTION
argument_list|(
name|sym
argument_list|)
operator|=
name|cs_to_section
argument_list|(
name|cs
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISFCN
argument_list|(
name|cs
operator|->
name|c_type
argument_list|)
condition|)
block|{
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
expr_stmt|;
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|lookup_function_type
argument_list|(
name|decode_function_type
argument_list|(
name|cs
argument_list|,
name|cs
operator|->
name|c_type
argument_list|,
name|aux
argument_list|)
argument_list|)
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_BLOCK
expr_stmt|;
if|if
condition|(
name|cs
operator|->
name|c_sclass
operator|==
name|C_STAT
operator|||
name|cs
operator|->
name|c_sclass
operator|==
name|C_THUMBSTAT
operator|||
name|cs
operator|->
name|c_sclass
operator|==
name|C_THUMBSTATFUNC
condition|)
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|file_symbols
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cs
operator|->
name|c_sclass
operator|==
name|C_EXT
operator|||
name|cs
operator|->
name|c_sclass
operator|==
name|C_THUMBEXT
operator|||
name|cs
operator|->
name|c_sclass
operator|==
name|C_THUMBEXTFUNC
condition|)
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|global_symbols
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|decode_type
argument_list|(
name|cs
argument_list|,
name|cs
operator|->
name|c_type
argument_list|,
name|aux
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cs
operator|->
name|c_sclass
condition|)
block|{
case|case
name|C_NULL
case|:
break|break;
case|case
name|C_AUTO
case|:
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_LOCAL
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|local_symbols
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_THUMBEXT
case|:
case|case
name|C_THUMBEXTFUNC
case|:
case|case
name|C_EXT
case|:
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_STATIC
expr_stmt|;
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym
argument_list|)
operator|=
operator|(
name|CORE_ADDR
operator|)
name|cs
operator|->
name|c_value
expr_stmt|;
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym
argument_list|)
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|global_symbols
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_THUMBSTAT
case|:
case|case
name|C_THUMBSTATFUNC
case|:
case|case
name|C_STAT
case|:
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_STATIC
expr_stmt|;
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym
argument_list|)
operator|=
operator|(
name|CORE_ADDR
operator|)
name|cs
operator|->
name|c_value
expr_stmt|;
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym
argument_list|)
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
expr_stmt|;
if|if
condition|(
name|within_function
condition|)
block|{
comment|/* Static symbol of local scope */
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|local_symbols
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Static symbol at top level of file */
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|file_symbols
argument_list|)
expr_stmt|;
block|}
break|break;
ifdef|#
directive|ifdef
name|C_GLBLREG
comment|/* AMD coff */
case|case
name|C_GLBLREG
case|:
endif|#
directive|endif
case|case
name|C_REG
case|:
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_REGISTER
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|SDB_REG_TO_REGNUM
argument_list|(
name|cs
operator|->
name|c_value
argument_list|)
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|local_symbols
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_THUMBLABEL
case|:
case|case
name|C_LABEL
case|:
break|break;
case|case
name|C_ARG
case|:
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_ARG
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|local_symbols
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|BELIEVE_PCC_PROMOTION
argument_list|)
if|if
condition|(
name|TARGET_BYTE_ORDER
operator|==
name|BIG_ENDIAN
condition|)
block|{
comment|/* If PCC says a parameter is a short or a char, 		   aligned on an int boundary, realign it to the 		   "little end" of the int.  */
name|struct
name|type
modifier|*
name|temptype
decl_stmt|;
name|temptype
operator|=
name|lookup_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_INTEGER
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|<
name|TYPE_LENGTH
argument_list|(
name|temptype
argument_list|)
operator|&&
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_INT
operator|&&
literal|0
operator|==
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|%
name|TYPE_LENGTH
argument_list|(
name|temptype
argument_list|)
condition|)
block|{
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|+=
name|TYPE_LENGTH
argument_list|(
name|temptype
argument_list|)
operator|-
name|TYPE_LENGTH
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
break|break;
case|case
name|C_REGPARM
case|:
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_REGPARM
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|SDB_REG_TO_REGNUM
argument_list|(
name|cs
operator|->
name|c_value
argument_list|)
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|local_symbols
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|BELIEVE_PCC_PROMOTION
argument_list|)
comment|/* FIXME:  This should retain the current type, since it's just 	       a register value.  gnu@adobe, 26Feb93 */
block|{
comment|/* If PCC says a parameter is a short or a char, 		   it is really an int.  */
name|struct
name|type
modifier|*
name|temptype
decl_stmt|;
name|temptype
operator|=
name|lookup_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_INTEGER
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|<
name|TYPE_LENGTH
argument_list|(
name|temptype
argument_list|)
operator|&&
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_INT
condition|)
block|{
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
operator|(
name|TYPE_UNSIGNED
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
condition|?
name|lookup_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_UNSIGNED_INTEGER
argument_list|)
else|:
name|temptype
operator|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
break|break;
case|case
name|C_TPDEF
case|:
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_TYPEDEF
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
comment|/* If type has no name, give it one */
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_PTR
operator|||
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_FUNC
condition|)
block|{
comment|/* If we are giving a name to a type such as "pointer to 		       foo" or "function returning foo", we better not set 		       the TYPE_NAME.  If the program contains "typedef char 		       *caddr_t;", we don't want all variables of type char 		       * to print as caddr_t.  This is not just a 		       consequence of GDB's type management; CC and GCC (at 		       least through version 2.4) both output variables of 		       either type char * or caddr_t with the type 		       refering to the C_TPDEF symbol for caddr_t.  If a future 		       compiler cleans this up it GDB is not ready for it 		       yet, but if it becomes ready we somehow need to 		       disable this check (without breaking the PCC/GCC2.4 		       case).  		       Sigh.  		       Fortunately, this check seems not to be necessary 		       for anything except pointers or functions.  */
empty_stmt|;
block|}
else|else
name|TYPE_NAME
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|=
name|concat
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|CXUX_TARGET
comment|/* Ignore vendor section for Harris CX/UX targets. */
elseif|else
if|if
condition|(
name|cs
operator|->
name|c_name
index|[
literal|0
index|]
operator|==
literal|'$'
condition|)
break|break;
endif|#
directive|endif
comment|/* CXUX_TARGET */
comment|/* Keep track of any type which points to empty structured type, 		so it can be filled from a definition from another file.  A 		simple forward reference (TYPE_CODE_UNDEF) is not an 		empty structured type, though; the forward references 		work themselves out via the magic of coff_lookup_type.  */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_PTR
operator|&&
name|TYPE_LENGTH
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
name|TYPE_CODE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|TYPE_CODE_UNDEF
condition|)
block|{
specifier|register
name|int
name|i
init|=
name|hashname
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
decl_stmt|;
name|SYMBOL_VALUE_CHAIN
argument_list|(
name|sym
argument_list|)
operator|=
name|opaque_type_chain
index|[
name|i
index|]
expr_stmt|;
name|opaque_type_chain
index|[
name|i
index|]
operator|=
name|sym
expr_stmt|;
block|}
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|file_symbols
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_STRTAG
case|:
case|case
name|C_UNTAG
case|:
case|case
name|C_ENTAG
case|:
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_TYPEDEF
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
name|STRUCT_NAMESPACE
expr_stmt|;
comment|/* Some compilers try to be helpful by inventing "fake"                names for anonymous enums, structures, and unions, like                "~0fake" or ".0fake".  Thanks, but no thanks... */
if|if
condition|(
name|TYPE_TAG_NAME
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
if|if
condition|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|!=
name|NULL
operator|&&
operator|*
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|!=
literal|'~'
operator|&&
operator|*
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|!=
literal|'.'
condition|)
name|TYPE_TAG_NAME
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|=
name|concat
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|file_symbols
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
return|return
name|sym
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Decode a coff type specifier;  return the type that is meant.  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|decode_type
parameter_list|(
name|cs
parameter_list|,
name|c_type
parameter_list|,
name|aux
parameter_list|)
specifier|register
name|struct
name|coff_symbol
modifier|*
name|cs
decl_stmt|;
name|unsigned
name|int
name|c_type
decl_stmt|;
specifier|register
name|union
name|internal_auxent
modifier|*
name|aux
decl_stmt|;
block|{
specifier|register
name|struct
name|type
modifier|*
name|type
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|new_c_type
decl_stmt|;
if|if
condition|(
name|c_type
operator|&
operator|~
name|N_BTMASK
condition|)
block|{
name|new_c_type
operator|=
name|DECREF
argument_list|(
name|c_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISPTR
argument_list|(
name|c_type
argument_list|)
condition|)
block|{
name|type
operator|=
name|decode_type
argument_list|(
name|cs
argument_list|,
name|new_c_type
argument_list|,
name|aux
argument_list|)
expr_stmt|;
name|type
operator|=
name|lookup_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ISFCN
argument_list|(
name|c_type
argument_list|)
condition|)
block|{
name|type
operator|=
name|decode_type
argument_list|(
name|cs
argument_list|,
name|new_c_type
argument_list|,
name|aux
argument_list|)
expr_stmt|;
name|type
operator|=
name|lookup_function_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ISARY
argument_list|(
name|c_type
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
specifier|register
name|unsigned
name|short
modifier|*
name|dim
decl_stmt|;
name|struct
name|type
modifier|*
name|base_type
decl_stmt|,
modifier|*
name|index_type
decl_stmt|,
modifier|*
name|range_type
decl_stmt|;
comment|/* Define an array type.  */
comment|/* auxent refers to array, not base type */
if|if
condition|(
name|aux
operator|->
name|x_sym
operator|.
name|x_tagndx
operator|.
name|l
operator|==
literal|0
condition|)
name|cs
operator|->
name|c_naux
operator|=
literal|0
expr_stmt|;
comment|/* shift the indices down */
name|dim
operator|=
operator|&
name|aux
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_ary
operator|.
name|x_dimen
index|[
literal|0
index|]
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
name|n
operator|=
name|dim
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|*
name|dim
operator|&&
name|i
operator|<
name|DIMNUM
operator|-
literal|1
condition|;
name|i
operator|++
operator|,
name|dim
operator|++
control|)
operator|*
name|dim
operator|=
operator|*
operator|(
name|dim
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|dim
operator|=
literal|0
expr_stmt|;
name|base_type
operator|=
name|decode_type
argument_list|(
name|cs
argument_list|,
name|new_c_type
argument_list|,
name|aux
argument_list|)
expr_stmt|;
name|index_type
operator|=
name|lookup_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_INTEGER
argument_list|)
expr_stmt|;
name|range_type
operator|=
name|create_range_type
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|)
name|NULL
argument_list|,
name|index_type
argument_list|,
literal|0
argument_list|,
name|n
operator|-
literal|1
argument_list|)
expr_stmt|;
name|type
operator|=
name|create_array_type
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|)
name|NULL
argument_list|,
name|base_type
argument_list|,
name|range_type
argument_list|)
expr_stmt|;
block|}
return|return
name|type
return|;
block|}
comment|/* Reference to existing type.  This only occurs with the      struct, union, and enum types.  EPI a29k coff      fakes us out by producing aux entries with a nonzero      x_tagndx for definitions of structs, unions, and enums, so we      have to check the c_sclass field.  SCO 3.2v4 cc gets confused      with pointers to pointers to defined structs, and generates      negative x_tagndx fields.  */
if|if
condition|(
name|cs
operator|->
name|c_naux
operator|>
literal|0
operator|&&
name|aux
operator|->
name|x_sym
operator|.
name|x_tagndx
operator|.
name|l
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|cs
operator|->
name|c_sclass
operator|!=
name|C_STRTAG
operator|&&
name|cs
operator|->
name|c_sclass
operator|!=
name|C_UNTAG
operator|&&
name|cs
operator|->
name|c_sclass
operator|!=
name|C_ENTAG
operator|&&
name|aux
operator|->
name|x_sym
operator|.
name|x_tagndx
operator|.
name|l
operator|>=
literal|0
condition|)
block|{
name|type
operator|=
name|coff_alloc_type
argument_list|(
name|aux
operator|->
name|x_sym
operator|.
name|x_tagndx
operator|.
name|l
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
else|else
block|{
name|complain
argument_list|(
operator|&
name|tagndx_bad_complaint
argument_list|,
name|cs
operator|->
name|c_name
argument_list|)
expr_stmt|;
comment|/* And fall through to decode_base_type... */
block|}
block|}
return|return
name|decode_base_type
argument_list|(
name|cs
argument_list|,
name|BTYPE
argument_list|(
name|c_type
argument_list|)
argument_list|,
name|aux
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Decode a coff type specifier for function definition;    return the type that the function returns.  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|decode_function_type
parameter_list|(
name|cs
parameter_list|,
name|c_type
parameter_list|,
name|aux
parameter_list|)
specifier|register
name|struct
name|coff_symbol
modifier|*
name|cs
decl_stmt|;
name|unsigned
name|int
name|c_type
decl_stmt|;
specifier|register
name|union
name|internal_auxent
modifier|*
name|aux
decl_stmt|;
block|{
if|if
condition|(
name|aux
operator|->
name|x_sym
operator|.
name|x_tagndx
operator|.
name|l
operator|==
literal|0
condition|)
name|cs
operator|->
name|c_naux
operator|=
literal|0
expr_stmt|;
comment|/* auxent refers to function, not base type */
return|return
name|decode_type
argument_list|(
name|cs
argument_list|,
name|DECREF
argument_list|(
name|c_type
argument_list|)
argument_list|,
name|aux
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* basic C types */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|decode_base_type
parameter_list|(
name|cs
parameter_list|,
name|c_type
parameter_list|,
name|aux
parameter_list|)
specifier|register
name|struct
name|coff_symbol
modifier|*
name|cs
decl_stmt|;
name|unsigned
name|int
name|c_type
decl_stmt|;
specifier|register
name|union
name|internal_auxent
modifier|*
name|aux
decl_stmt|;
block|{
name|struct
name|type
modifier|*
name|type
decl_stmt|;
switch|switch
condition|(
name|c_type
condition|)
block|{
case|case
name|T_NULL
case|:
comment|/* shows up with "void (*foo)();" structure members */
return|return
name|lookup_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_VOID
argument_list|)
return|;
if|#
directive|if
literal|0
comment|/* DGUX actually defines both T_ARG and T_VOID to the same value.  */
ifdef|#
directive|ifdef
name|T_ARG
block|case T_ARG:
comment|/* Shows up in DGUX, I think.  Not sure where.  */
block|return lookup_fundamental_type (current_objfile, FT_VOID);
comment|/* shouldn't show up here */
endif|#
directive|endif
endif|#
directive|endif
comment|/* 0 */
ifdef|#
directive|ifdef
name|T_VOID
case|case
name|T_VOID
case|:
comment|/* Intel 960 COFF has this symbol and meaning.  */
return|return
name|lookup_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_VOID
argument_list|)
return|;
endif|#
directive|endif
case|case
name|T_CHAR
case|:
return|return
name|lookup_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_CHAR
argument_list|)
return|;
case|case
name|T_SHORT
case|:
return|return
name|lookup_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_SHORT
argument_list|)
return|;
case|case
name|T_INT
case|:
return|return
name|lookup_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_INTEGER
argument_list|)
return|;
case|case
name|T_LONG
case|:
if|if
condition|(
name|cs
operator|->
name|c_sclass
operator|==
name|C_FIELD
operator|&&
name|aux
operator|->
name|x_sym
operator|.
name|x_misc
operator|.
name|x_lnsz
operator|.
name|x_size
operator|>
name|TARGET_LONG_BIT
condition|)
return|return
name|lookup_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_LONG_LONG
argument_list|)
return|;
else|else
return|return
name|lookup_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_LONG
argument_list|)
return|;
case|case
name|T_FLOAT
case|:
return|return
name|lookup_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_FLOAT
argument_list|)
return|;
case|case
name|T_DOUBLE
case|:
return|return
name|lookup_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_DBL_PREC_FLOAT
argument_list|)
return|;
case|case
name|T_LNGDBL
case|:
return|return
name|lookup_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_EXT_PREC_FLOAT
argument_list|)
return|;
case|case
name|T_STRUCT
case|:
if|if
condition|(
name|cs
operator|->
name|c_naux
operator|!=
literal|1
condition|)
block|{
comment|/* anonymous structure type */
name|type
operator|=
name|coff_alloc_type
argument_list|(
name|cs
operator|->
name|c_symnum
argument_list|)
expr_stmt|;
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_CODE_STRUCT
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|=
name|NULL
expr_stmt|;
comment|/* This used to set the tag to "<opaque>".  But I think setting it 	       to NULL is right, and the printing code can print it as 	       "struct {...}".  */
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|INIT_CPLUS_SPECIFIC
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
name|coff_read_struct_type
argument_list|(
name|cs
operator|->
name|c_symnum
argument_list|,
name|aux
operator|->
name|x_sym
operator|.
name|x_misc
operator|.
name|x_lnsz
operator|.
name|x_size
argument_list|,
name|aux
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_endndx
operator|.
name|l
argument_list|)
expr_stmt|;
block|}
return|return
name|type
return|;
case|case
name|T_UNION
case|:
if|if
condition|(
name|cs
operator|->
name|c_naux
operator|!=
literal|1
condition|)
block|{
comment|/* anonymous union type */
name|type
operator|=
name|coff_alloc_type
argument_list|(
name|cs
operator|->
name|c_symnum
argument_list|)
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|=
name|NULL
expr_stmt|;
comment|/* This used to set the tag to "<opaque>".  But I think setting it 	       to NULL is right, and the printing code can print it as 	       "union {...}".  */
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|INIT_CPLUS_SPECIFIC
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
name|coff_read_struct_type
argument_list|(
name|cs
operator|->
name|c_symnum
argument_list|,
name|aux
operator|->
name|x_sym
operator|.
name|x_misc
operator|.
name|x_lnsz
operator|.
name|x_size
argument_list|,
name|aux
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_endndx
operator|.
name|l
argument_list|)
expr_stmt|;
block|}
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_CODE_UNION
expr_stmt|;
return|return
name|type
return|;
case|case
name|T_ENUM
case|:
if|if
condition|(
name|cs
operator|->
name|c_naux
operator|!=
literal|1
condition|)
block|{
comment|/* anonymous enum type */
name|type
operator|=
name|coff_alloc_type
argument_list|(
name|cs
operator|->
name|c_symnum
argument_list|)
expr_stmt|;
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_CODE_ENUM
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|=
name|NULL
expr_stmt|;
comment|/* This used to set the tag to "<opaque>".  But I think setting it 	       to NULL is right, and the printing code can print it as 	       "enum {...}".  */
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
name|coff_read_enum_type
argument_list|(
name|cs
operator|->
name|c_symnum
argument_list|,
name|aux
operator|->
name|x_sym
operator|.
name|x_misc
operator|.
name|x_lnsz
operator|.
name|x_size
argument_list|,
name|aux
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_endndx
operator|.
name|l
argument_list|)
expr_stmt|;
block|}
return|return
name|type
return|;
case|case
name|T_MOE
case|:
comment|/* shouldn't show up here */
break|break;
case|case
name|T_UCHAR
case|:
return|return
name|lookup_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_UNSIGNED_CHAR
argument_list|)
return|;
case|case
name|T_USHORT
case|:
return|return
name|lookup_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_UNSIGNED_SHORT
argument_list|)
return|;
case|case
name|T_UINT
case|:
return|return
name|lookup_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_UNSIGNED_INTEGER
argument_list|)
return|;
case|case
name|T_ULONG
case|:
if|if
condition|(
name|cs
operator|->
name|c_sclass
operator|==
name|C_FIELD
operator|&&
name|aux
operator|->
name|x_sym
operator|.
name|x_misc
operator|.
name|x_lnsz
operator|.
name|x_size
operator|>
name|TARGET_LONG_BIT
condition|)
return|return
name|lookup_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_UNSIGNED_LONG_LONG
argument_list|)
return|;
else|else
return|return
name|lookup_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_UNSIGNED_LONG
argument_list|)
return|;
block|}
name|complain
argument_list|(
operator|&
name|unexpected_type_complaint
argument_list|,
name|cs
operator|->
name|c_name
argument_list|)
expr_stmt|;
return|return
name|lookup_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_VOID
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This page contains subroutines of read_type.  */
end_comment

begin_comment
comment|/* Read the description of a structure (or union type) and return an    object describing the type.  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|coff_read_struct_type
parameter_list|(
name|index
parameter_list|,
name|length
parameter_list|,
name|lastsym
parameter_list|)
name|int
name|index
decl_stmt|;
name|int
name|length
decl_stmt|;
name|int
name|lastsym
decl_stmt|;
block|{
struct|struct
name|nextfield
block|{
name|struct
name|nextfield
modifier|*
name|next
decl_stmt|;
name|struct
name|field
name|field
decl_stmt|;
block|}
struct|;
specifier|register
name|struct
name|type
modifier|*
name|type
decl_stmt|;
specifier|register
name|struct
name|nextfield
modifier|*
name|list
init|=
literal|0
decl_stmt|;
name|struct
name|nextfield
modifier|*
name|new
decl_stmt|;
name|int
name|nfields
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|coff_symbol
name|member_sym
decl_stmt|;
specifier|register
name|struct
name|coff_symbol
modifier|*
name|ms
init|=
operator|&
name|member_sym
decl_stmt|;
name|struct
name|internal_syment
name|sub_sym
decl_stmt|;
name|union
name|internal_auxent
name|sub_aux
decl_stmt|;
name|int
name|done
init|=
literal|0
decl_stmt|;
name|type
operator|=
name|coff_alloc_type
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_CODE_STRUCT
expr_stmt|;
name|INIT_CPLUS_SPECIFIC
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
name|length
expr_stmt|;
while|while
condition|(
operator|!
name|done
operator|&&
name|symnum
operator|<
name|lastsym
operator|&&
name|symnum
operator|<
name|nlist_nsyms_global
condition|)
block|{
name|read_one_sym
argument_list|(
name|ms
argument_list|,
operator|&
name|sub_sym
argument_list|,
operator|&
name|sub_aux
argument_list|)
expr_stmt|;
name|name
operator|=
name|ms
operator|->
name|c_name
expr_stmt|;
name|name
operator|=
name|EXTERNAL_NAME
argument_list|(
name|name
argument_list|,
name|current_objfile
operator|->
name|obfd
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ms
operator|->
name|c_sclass
condition|)
block|{
case|case
name|C_MOS
case|:
case|case
name|C_MOU
case|:
comment|/* Get space to record the next field's data.  */
name|new
operator|=
operator|(
expr|struct
name|nextfield
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nextfield
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|list
expr_stmt|;
name|list
operator|=
name|new
expr_stmt|;
comment|/* Save the data.  */
name|list
operator|->
name|field
operator|.
name|name
operator|=
name|obsavestring
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
operator|&
name|current_objfile
operator|->
name|symbol_obstack
argument_list|)
expr_stmt|;
name|FIELD_TYPE
argument_list|(
name|list
operator|->
name|field
argument_list|)
operator|=
name|decode_type
argument_list|(
name|ms
argument_list|,
name|ms
operator|->
name|c_type
argument_list|,
operator|&
name|sub_aux
argument_list|)
expr_stmt|;
name|FIELD_BITPOS
argument_list|(
name|list
operator|->
name|field
argument_list|)
operator|=
literal|8
operator|*
name|ms
operator|->
name|c_value
expr_stmt|;
name|FIELD_BITSIZE
argument_list|(
name|list
operator|->
name|field
argument_list|)
operator|=
literal|0
expr_stmt|;
name|nfields
operator|++
expr_stmt|;
break|break;
case|case
name|C_FIELD
case|:
comment|/* Get space to record the next field's data.  */
name|new
operator|=
operator|(
expr|struct
name|nextfield
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nextfield
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|list
expr_stmt|;
name|list
operator|=
name|new
expr_stmt|;
comment|/* Save the data.  */
name|list
operator|->
name|field
operator|.
name|name
operator|=
name|obsavestring
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
operator|&
name|current_objfile
operator|->
name|symbol_obstack
argument_list|)
expr_stmt|;
name|FIELD_TYPE
argument_list|(
name|list
operator|->
name|field
argument_list|)
operator|=
name|decode_type
argument_list|(
name|ms
argument_list|,
name|ms
operator|->
name|c_type
argument_list|,
operator|&
name|sub_aux
argument_list|)
expr_stmt|;
name|FIELD_BITPOS
argument_list|(
name|list
operator|->
name|field
argument_list|)
operator|=
name|ms
operator|->
name|c_value
expr_stmt|;
name|FIELD_BITSIZE
argument_list|(
name|list
operator|->
name|field
argument_list|)
operator|=
name|sub_aux
operator|.
name|x_sym
operator|.
name|x_misc
operator|.
name|x_lnsz
operator|.
name|x_size
expr_stmt|;
name|nfields
operator|++
expr_stmt|;
break|break;
case|case
name|C_EOS
case|:
name|done
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
comment|/* Now create the vector of fields, and record how big it is.  */
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|=
name|nfields
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
expr|struct
name|field
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|type
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
operator|*
name|nfields
argument_list|)
expr_stmt|;
comment|/* Copy the saved-up fields into the field vector.  */
for|for
control|(
name|n
operator|=
name|nfields
init|;
name|list
condition|;
name|list
operator|=
name|list
operator|->
name|next
control|)
name|TYPE_FIELD
argument_list|(
name|type
argument_list|,
operator|--
name|n
argument_list|)
operator|=
name|list
operator|->
name|field
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read a definition of an enumeration type,    and create and return a suitable type object.    Also defines the symbols that represent the values of the type.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|coff_read_enum_type
parameter_list|(
name|index
parameter_list|,
name|length
parameter_list|,
name|lastsym
parameter_list|)
name|int
name|index
decl_stmt|;
name|int
name|length
decl_stmt|;
name|int
name|lastsym
decl_stmt|;
block|{
specifier|register
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
specifier|register
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|int
name|nsyms
init|=
literal|0
decl_stmt|;
name|int
name|done
init|=
literal|0
decl_stmt|;
name|struct
name|pending
modifier|*
modifier|*
name|symlist
decl_stmt|;
name|struct
name|coff_symbol
name|member_sym
decl_stmt|;
specifier|register
name|struct
name|coff_symbol
modifier|*
name|ms
init|=
operator|&
name|member_sym
decl_stmt|;
name|struct
name|internal_syment
name|sub_sym
decl_stmt|;
name|union
name|internal_auxent
name|sub_aux
decl_stmt|;
name|struct
name|pending
modifier|*
name|osyms
decl_stmt|,
modifier|*
name|syms
decl_stmt|;
name|int
name|o_nsyms
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|unsigned_enum
init|=
literal|1
decl_stmt|;
name|type
operator|=
name|coff_alloc_type
argument_list|(
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|within_function
condition|)
name|symlist
operator|=
operator|&
name|local_symbols
expr_stmt|;
else|else
name|symlist
operator|=
operator|&
name|file_symbols
expr_stmt|;
name|osyms
operator|=
operator|*
name|symlist
expr_stmt|;
name|o_nsyms
operator|=
name|osyms
condition|?
name|osyms
operator|->
name|nsyms
else|:
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|done
operator|&&
name|symnum
operator|<
name|lastsym
operator|&&
name|symnum
operator|<
name|nlist_nsyms_global
condition|)
block|{
name|read_one_sym
argument_list|(
name|ms
argument_list|,
operator|&
name|sub_sym
argument_list|,
operator|&
name|sub_aux
argument_list|)
expr_stmt|;
name|name
operator|=
name|ms
operator|->
name|c_name
expr_stmt|;
name|name
operator|=
name|EXTERNAL_NAME
argument_list|(
name|name
argument_list|,
name|current_objfile
operator|->
name|obfd
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ms
operator|->
name|c_sclass
condition|)
block|{
case|case
name|C_MOE
case|:
name|sym
operator|=
operator|(
expr|struct
name|symbol
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|current_objfile
operator|->
name|symbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|sym
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|=
name|obsavestring
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
operator|&
name|current_objfile
operator|->
name|symbol_obstack
argument_list|)
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_CONST
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|ms
operator|->
name|c_value
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
name|symlist
argument_list|)
expr_stmt|;
name|nsyms
operator|++
expr_stmt|;
break|break;
case|case
name|C_EOS
case|:
comment|/* Sometimes the linker (on 386/ix 2.0.2 at least) screws 	       up the count of how many symbols to read.  So stop 	       on .eos.  */
name|done
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
comment|/* Now fill in the fields of the type-structure.  */
if|if
condition|(
name|length
operator|>
literal|0
condition|)
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
name|length
expr_stmt|;
else|else
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
name|TARGET_INT_BIT
operator|/
name|TARGET_CHAR_BIT
expr_stmt|;
comment|/* Assume ints */
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_CODE_ENUM
expr_stmt|;
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|=
name|nsyms
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
expr|struct
name|field
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|type
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
operator|*
name|nsyms
argument_list|)
expr_stmt|;
comment|/* Find the symbols for the values and put them into the type.      The symbols can be found in the symlist that we put them on      to cause them to be defined.  osyms contains the old value      of that symlist; everything up to there was defined by us.  */
comment|/* Note that we preserve the order of the enum constants, so      that in something like "enum {FOO, LAST_THING=FOO}" we print      FOO, not LAST_THING.  */
for|for
control|(
name|syms
operator|=
operator|*
name|symlist
operator|,
name|n
operator|=
literal|0
init|;
name|syms
condition|;
name|syms
operator|=
name|syms
operator|->
name|next
control|)
block|{
name|int
name|j
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|syms
operator|==
name|osyms
condition|)
name|j
operator|=
name|o_nsyms
expr_stmt|;
for|for
control|(
init|;
name|j
operator|<
name|syms
operator|->
name|nsyms
condition|;
name|j
operator|++
operator|,
name|n
operator|++
control|)
block|{
name|struct
name|symbol
modifier|*
name|xsym
init|=
name|syms
operator|->
name|symbol
index|[
name|j
index|]
decl_stmt|;
name|SYMBOL_TYPE
argument_list|(
name|xsym
argument_list|)
operator|=
name|type
expr_stmt|;
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|n
argument_list|)
operator|=
name|SYMBOL_NAME
argument_list|(
name|xsym
argument_list|)
expr_stmt|;
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|n
argument_list|)
operator|=
name|SYMBOL_VALUE
argument_list|(
name|xsym
argument_list|)
expr_stmt|;
if|if
condition|(
name|SYMBOL_VALUE
argument_list|(
name|xsym
argument_list|)
operator|<
literal|0
condition|)
name|unsigned_enum
operator|=
literal|0
expr_stmt|;
name|TYPE_FIELD_BITSIZE
argument_list|(
name|type
argument_list|,
name|n
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|syms
operator|==
name|osyms
condition|)
break|break;
block|}
if|if
condition|(
name|unsigned_enum
condition|)
name|TYPE_FLAGS
argument_list|(
name|type
argument_list|)
operator||=
name|TYPE_FLAG_UNSIGNED
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Register our ability to parse symbols for coff BFD files. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sym_fns
name|coff_sym_fns
init|=
block|{
name|bfd_target_coff_flavour
block|,
name|coff_new_init
block|,
comment|/* sym_new_init: init anything gbl to entire symtab */
name|coff_symfile_init
block|,
comment|/* sym_init: read initial info, setup for sym_read() */
name|coff_symfile_read
block|,
comment|/* sym_read: read a symbol file into symtab */
name|coff_symfile_finish
block|,
comment|/* sym_finish: finished with file, cleanup */
name|default_symfile_offsets
block|,
comment|/* sym_offsets:  xlate external to internal form */
name|NULL
comment|/* next: pointer to next struct sym_fns */
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|_initialize_coffread
parameter_list|()
block|{
name|add_symtab_fns
argument_list|(
operator|&
name|coff_sym_fns
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

