begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Generic symbol file reading for the GNU debugger, GDB.    Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996    Free Software Foundation, Inc.    Contributed by Cygnus Support, using pieces from other GDB modules.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"breakpoint.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"complaints.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_comment
comment|/* for write_pc */
end_comment

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"gdb_stat.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|O_BINARY
end_ifndef

begin_define
define|#
directive|define
name|O_BINARY
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Global variables owned by this file */
end_comment

begin_decl_stmt
name|int
name|readnow_symbol_files
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Read full symbols immediately */
end_comment

begin_decl_stmt
name|struct
name|complaint
name|oldsyms_complaint
init|=
block|{
literal|"Replacing old symbols for `%s'"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|empty_symtab_complaint
init|=
block|{
literal|"Empty symbol table found for `%s'"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* External variables and functions referenced. */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|info_verbose
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Functions this file defines */
end_comment

begin_decl_stmt
specifier|static
name|void
name|set_initial_language
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|load_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_symbol_file_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_shared_symbol_files_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cashier_psymtab
name|PARAMS
argument_list|(
operator|(
expr|struct
name|partial_symtab
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|compare_psymbols
name|PARAMS
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|,
specifier|const
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|compare_symbols
name|PARAMS
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|,
specifier|const
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd
modifier|*
name|symfile_bfd_open
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|find_sym_fns
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of all available sym_fns.  On gdb startup, each object file reader    calls add_symtab_fns() to register information on each format it is    prepared to read. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sym_fns
modifier|*
name|symtab_fns
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag for whether user will be reloading symbols multiple times.    Defaults to ON for VxWorks, otherwise OFF.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SYMBOL_RELOADING_DEFAULT
end_ifdef

begin_decl_stmt
name|int
name|symbol_reloading
init|=
name|SYMBOL_RELOADING_DEFAULT
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|symbol_reloading
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* If true, then shared library symbols will be added automatically    when the inferior is created, new libraries are loaded, or when    attaching to the inferior.  This is almost always what users    will want to have happen; but for very large programs, the startup    time will be excessive, and so if this is a problem, the user can    clear this flag and then add the shared library symbols as needed.    Note that there is a potential for confusion, since if the shared    library symbols are not loaded, commands like "info fun" will *not*    report all the functions that are actually present.  */
end_comment

begin_decl_stmt
name|int
name|auto_solib_add
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Since this function is called from within qsort, in an ANSI environment    it must conform to the prototype for qsort, which specifies that the    comparison function takes two "void *" pointers. */
end_comment

begin_function
specifier|static
name|int
name|compare_symbols
parameter_list|(
name|s1p
parameter_list|,
name|s2p
parameter_list|)
specifier|const
name|PTR
name|s1p
decl_stmt|;
specifier|const
name|PTR
name|s2p
decl_stmt|;
block|{
specifier|register
name|struct
name|symbol
modifier|*
modifier|*
name|s1
decl_stmt|,
modifier|*
modifier|*
name|s2
decl_stmt|;
name|s1
operator|=
operator|(
expr|struct
name|symbol
operator|*
operator|*
operator|)
name|s1p
expr_stmt|;
name|s2
operator|=
operator|(
expr|struct
name|symbol
operator|*
operator|*
operator|)
name|s2p
expr_stmt|;
return|return
operator|(
name|STRCMP
argument_list|(
name|SYMBOL_NAME
argument_list|(
operator|*
name|s1
argument_list|)
argument_list|,
name|SYMBOL_NAME
argument_list|(
operator|*
name|s2
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	compare_psymbols -- compare two partial symbols by name  DESCRIPTION  	Given pointers to pointers to two partial symbol table entries, 	compare them by name and return -N, 0, or +N (ala strcmp). 	Typically used by sorting routines like qsort().  NOTES  	Does direct compare of first two characters before punting 	and passing to strcmp for longer compares.  Note that the 	original version had a bug whereby two null strings or two 	identically named one character strings would return the 	comparison of memory following the null byte.   */
end_comment

begin_function
specifier|static
name|int
name|compare_psymbols
parameter_list|(
name|s1p
parameter_list|,
name|s2p
parameter_list|)
specifier|const
name|PTR
name|s1p
decl_stmt|;
specifier|const
name|PTR
name|s2p
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|st1
init|=
name|SYMBOL_NAME
argument_list|(
operator|*
operator|(
expr|struct
name|partial_symbol
operator|*
operator|*
operator|)
name|s1p
argument_list|)
decl_stmt|;
specifier|register
name|char
modifier|*
name|st2
init|=
name|SYMBOL_NAME
argument_list|(
operator|*
operator|(
expr|struct
name|partial_symbol
operator|*
operator|*
operator|)
name|s2p
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|st1
index|[
literal|0
index|]
operator|-
name|st2
index|[
literal|0
index|]
operator|)
operator|||
operator|!
name|st1
index|[
literal|0
index|]
condition|)
block|{
return|return
operator|(
name|st1
index|[
literal|0
index|]
operator|-
name|st2
index|[
literal|0
index|]
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|st1
index|[
literal|1
index|]
operator|-
name|st2
index|[
literal|1
index|]
operator|)
operator|||
operator|!
name|st1
index|[
literal|1
index|]
condition|)
block|{
return|return
operator|(
name|st1
index|[
literal|1
index|]
operator|-
name|st2
index|[
literal|1
index|]
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|STRCMP
argument_list|(
name|st1
operator|+
literal|2
argument_list|,
name|st2
operator|+
literal|2
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_function
name|void
name|sort_pst_symbols
parameter_list|(
name|pst
parameter_list|)
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
block|{
comment|/* Sort the global list; don't sort the static list */
name|qsort
argument_list|(
name|pst
operator|->
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
operator|+
name|pst
operator|->
name|globals_offset
argument_list|,
name|pst
operator|->
name|n_global_syms
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|partial_symbol
operator|*
argument_list|)
argument_list|,
name|compare_psymbols
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Call sort_block_syms to sort alphabetically the symbols of one block.  */
end_comment

begin_function
name|void
name|sort_block_syms
parameter_list|(
name|b
parameter_list|)
specifier|register
name|struct
name|block
modifier|*
name|b
decl_stmt|;
block|{
name|qsort
argument_list|(
operator|&
name|BLOCK_SYM
argument_list|(
name|b
argument_list|,
literal|0
argument_list|)
argument_list|,
name|BLOCK_NSYMS
argument_list|(
name|b
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
operator|*
argument_list|)
argument_list|,
name|compare_symbols
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Call sort_symtab_syms to sort alphabetically    the symbols of each block of one symtab.  */
end_comment

begin_function
name|void
name|sort_symtab_syms
parameter_list|(
name|s
parameter_list|)
specifier|register
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|struct
name|blockvector
modifier|*
name|bv
decl_stmt|;
name|int
name|nbl
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|block
modifier|*
name|b
decl_stmt|;
if|if
condition|(
name|s
operator|==
literal|0
condition|)
return|return;
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|nbl
operator|=
name|BLOCKVECTOR_NBLOCKS
argument_list|(
name|bv
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbl
condition|;
name|i
operator|++
control|)
block|{
name|b
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|BLOCK_SHOULD_SORT
argument_list|(
name|b
argument_list|)
condition|)
name|sort_block_syms
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Make a copy of the string at PTR with SIZE characters in the symbol obstack    (and add a null character at the end in the copy).    Returns the address of the copy.  */
end_comment

begin_function
name|char
modifier|*
name|obsavestring
parameter_list|(
name|ptr
parameter_list|,
name|size
parameter_list|,
name|obstackp
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|size
decl_stmt|;
name|struct
name|obstack
modifier|*
name|obstackp
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
init|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
name|obstackp
argument_list|,
name|size
operator|+
literal|1
argument_list|)
decl_stmt|;
comment|/* Open-coded memcpy--saves function call time.      These strings are usually short.  */
block|{
specifier|register
name|char
modifier|*
name|p1
init|=
name|ptr
decl_stmt|;
specifier|register
name|char
modifier|*
name|p2
init|=
name|p
decl_stmt|;
name|char
modifier|*
name|end
init|=
name|ptr
operator|+
name|size
decl_stmt|;
while|while
condition|(
name|p1
operator|!=
name|end
condition|)
operator|*
name|p2
operator|++
operator|=
operator|*
name|p1
operator|++
expr_stmt|;
block|}
name|p
index|[
name|size
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Concatenate strings S1, S2 and S3; return the new string.    Space is found in the symbol_obstack.  */
end_comment

begin_function
name|char
modifier|*
name|obconcat
parameter_list|(
name|obstackp
parameter_list|,
name|s1
parameter_list|,
name|s2
parameter_list|,
name|s3
parameter_list|)
name|struct
name|obstack
modifier|*
name|obstackp
decl_stmt|;
specifier|const
name|char
modifier|*
name|s1
decl_stmt|,
decl|*
name|s2
decl_stmt|,
modifier|*
name|s3
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|int
name|len
init|=
name|strlen
argument_list|(
name|s1
argument_list|)
operator|+
name|strlen
argument_list|(
name|s2
argument_list|)
operator|+
name|strlen
argument_list|(
name|s3
argument_list|)
operator|+
literal|1
decl_stmt|;
specifier|register
name|char
modifier|*
name|val
init|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
name|obstackp
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|val
argument_list|,
name|s1
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|val
argument_list|,
name|s2
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|val
argument_list|,
name|s3
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_block

begin_comment
comment|/* True if we are nested inside psymtab_to_symtab. */
end_comment

begin_decl_stmt
name|int
name|currently_reading_symtab
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|decrement_reading_symtab
parameter_list|(
name|dummy
parameter_list|)
name|void
modifier|*
name|dummy
decl_stmt|;
block|{
name|currently_reading_symtab
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get the symbol table that corresponds to a partial_symtab.    This is fast after the first time you do it.  In fact, there    is an even faster macro PSYMTAB_TO_SYMTAB that does the fast    case inline.  */
end_comment

begin_function
name|struct
name|symtab
modifier|*
name|psymtab_to_symtab
parameter_list|(
name|pst
parameter_list|)
specifier|register
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
block|{
comment|/* If it's been looked up before, return it. */
if|if
condition|(
name|pst
operator|->
name|symtab
condition|)
return|return
name|pst
operator|->
name|symtab
return|;
comment|/* If it has not yet been read in, read it.  */
if|if
condition|(
operator|!
name|pst
operator|->
name|readin
condition|)
block|{
name|struct
name|cleanup
modifier|*
name|back_to
init|=
name|make_cleanup
argument_list|(
name|decrement_reading_symtab
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|currently_reading_symtab
operator|++
expr_stmt|;
call|(
modifier|*
name|pst
operator|->
name|read_symtab
call|)
argument_list|(
name|pst
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|back_to
argument_list|)
expr_stmt|;
block|}
return|return
name|pst
operator|->
name|symtab
return|;
block|}
end_function

begin_comment
comment|/* Initialize entry point information for this objfile. */
end_comment

begin_function
name|void
name|init_entry_point_info
parameter_list|(
name|objfile
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
comment|/* Save startup file's range of PC addresses to help blockframe.c      decide where the bottom of the stack is.  */
if|if
condition|(
name|bfd_get_file_flags
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|)
operator|&
name|EXEC_P
condition|)
block|{
comment|/* Executable file -- record its entry point so we'll recognize 	 the startup file because it contains the entry point.  */
name|objfile
operator|->
name|ei
operator|.
name|entry_point
operator|=
name|bfd_get_start_address
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Examination of non-executable.o files.  Short-circuit this stuff.  */
name|objfile
operator|->
name|ei
operator|.
name|entry_point
operator|=
name|INVALID_ENTRY_POINT
expr_stmt|;
block|}
name|objfile
operator|->
name|ei
operator|.
name|entry_file_lowpc
operator|=
name|INVALID_ENTRY_LOWPC
expr_stmt|;
name|objfile
operator|->
name|ei
operator|.
name|entry_file_highpc
operator|=
name|INVALID_ENTRY_HIGHPC
expr_stmt|;
name|objfile
operator|->
name|ei
operator|.
name|entry_func_lowpc
operator|=
name|INVALID_ENTRY_LOWPC
expr_stmt|;
name|objfile
operator|->
name|ei
operator|.
name|entry_func_highpc
operator|=
name|INVALID_ENTRY_HIGHPC
expr_stmt|;
name|objfile
operator|->
name|ei
operator|.
name|main_func_lowpc
operator|=
name|INVALID_ENTRY_LOWPC
expr_stmt|;
name|objfile
operator|->
name|ei
operator|.
name|main_func_highpc
operator|=
name|INVALID_ENTRY_HIGHPC
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get current entry point address.  */
end_comment

begin_function
name|CORE_ADDR
name|entry_point_address
parameter_list|()
block|{
return|return
name|symfile_objfile
condition|?
name|symfile_objfile
operator|->
name|ei
operator|.
name|entry_point
else|:
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Remember the lowest-addressed loadable section we've seen.      This function is called via bfd_map_over_sections.      In case of equal vmas, the section with the largest size becomes the    lowest-addressed loadable section.     If the vmas and sizes are equal, the last section is considered the    lowest-addressed loadable section.  */
end_comment

begin_function
name|void
name|find_lowest_section
parameter_list|(
name|abfd
parameter_list|,
name|sect
parameter_list|,
name|obj
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sect
decl_stmt|;
name|PTR
name|obj
decl_stmt|;
block|{
name|asection
modifier|*
modifier|*
name|lowest
init|=
operator|(
name|asection
operator|*
operator|*
operator|)
name|obj
decl_stmt|;
if|if
condition|(
literal|0
operator|==
operator|(
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|sect
argument_list|)
operator|&
name|SEC_LOAD
operator|)
condition|)
return|return;
if|if
condition|(
operator|!
operator|*
name|lowest
condition|)
operator|*
name|lowest
operator|=
name|sect
expr_stmt|;
comment|/* First loadable section */
elseif|else
if|if
condition|(
name|bfd_section_vma
argument_list|(
name|abfd
argument_list|,
operator|*
name|lowest
argument_list|)
operator|>
name|bfd_section_vma
argument_list|(
name|abfd
argument_list|,
name|sect
argument_list|)
condition|)
operator|*
name|lowest
operator|=
name|sect
expr_stmt|;
comment|/* A lower loadable section */
elseif|else
if|if
condition|(
name|bfd_section_vma
argument_list|(
name|abfd
argument_list|,
operator|*
name|lowest
argument_list|)
operator|==
name|bfd_section_vma
argument_list|(
name|abfd
argument_list|,
name|sect
argument_list|)
operator|&&
operator|(
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
operator|(
operator|*
name|lowest
operator|)
argument_list|)
operator|<=
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|sect
argument_list|)
operator|)
condition|)
operator|*
name|lowest
operator|=
name|sect
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Process a symbol file, as either the main file or as a dynamically    loaded file.     NAME is the file name (which will be tilde-expanded and made    absolute herein) (but we don't free or modify NAME itself).    FROM_TTY says how verbose to be.  MAINLINE specifies whether this    is the main symbol file, or whether it's an extra symbol file such    as dynamically loaded code.  If !mainline, ADDR is the address    where the text segment was loaded.  If VERBO, the caller has printed    a verbose message about the symbol reading (and complaints can be    more terse about it).  */
end_comment

begin_function
name|void
name|syms_from_objfile
parameter_list|(
name|objfile
parameter_list|,
name|addr
parameter_list|,
name|mainline
parameter_list|,
name|verbo
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|int
name|mainline
decl_stmt|;
name|int
name|verbo
decl_stmt|;
block|{
name|struct
name|section_offsets
modifier|*
name|section_offsets
decl_stmt|;
name|asection
modifier|*
name|lowest_sect
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|init_entry_point_info
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
name|find_sym_fns
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
comment|/* Make sure that partially constructed symbol tables will be cleaned up      if an error occurs during symbol reading.  */
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|free_objfile
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|mainline
condition|)
block|{
comment|/* We will modify the main symbol table, make sure that all its users 	 will be cleaned up if an error occurs during symbol reading.  */
name|make_cleanup
argument_list|(
name|clear_symtab_users
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Since no error yet, throw away the old symbol table.  */
if|if
condition|(
name|symfile_objfile
operator|!=
name|NULL
condition|)
block|{
name|free_objfile
argument_list|(
name|symfile_objfile
argument_list|)
expr_stmt|;
name|symfile_objfile
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Currently we keep symbols from the add-symbol-file command. 	 If the user wants to get rid of them, they should do "symbol-file" 	 without arguments first.  Not sure this is the best behavior 	 (PR 2207).  */
call|(
modifier|*
name|objfile
operator|->
name|sf
operator|->
name|sym_new_init
call|)
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
block|}
comment|/* Convert addr into an offset rather than an absolute address.      We find the lowest address of a loaded segment in the objfile,      and assume that<addr> is where that got loaded.  Due to historical      precedent, we warn if that doesn't happen to be a text segment.  */
if|if
condition|(
name|mainline
condition|)
block|{
name|addr
operator|=
literal|0
expr_stmt|;
comment|/* No offset from objfile addresses.  */
block|}
else|else
block|{
name|lowest_sect
operator|=
name|bfd_get_section_by_name
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
literal|".text"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lowest_sect
operator|==
name|NULL
condition|)
name|bfd_map_over_sections
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|find_lowest_section
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|lowest_sect
argument_list|)
expr_stmt|;
if|if
condition|(
name|lowest_sect
operator|==
name|NULL
condition|)
name|warning
argument_list|(
literal|"no loadable sections found in added symbol-file %s"
argument_list|,
name|objfile
operator|->
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|bfd_get_section_flags
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|lowest_sect
argument_list|)
operator|&
name|SEC_CODE
operator|)
operator|==
literal|0
condition|)
comment|/* FIXME-32x64--assumes bfd_vma fits in long.  */
name|warning
argument_list|(
literal|"Lowest section in %s is %s at 0x%lx"
argument_list|,
name|objfile
operator|->
name|name
argument_list|,
name|bfd_section_name
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|lowest_sect
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|bfd_section_vma
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|lowest_sect
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lowest_sect
condition|)
name|addr
operator|-=
name|bfd_section_vma
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|lowest_sect
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize symbol reading routines for this objfile, allow complaints to      appear for this new file, and record how verbose to be, then do the      initial symbol reading for this file. */
call|(
modifier|*
name|objfile
operator|->
name|sf
operator|->
name|sym_init
call|)
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
name|clear_complaints
argument_list|(
literal|1
argument_list|,
name|verbo
argument_list|)
expr_stmt|;
name|section_offsets
operator|=
call|(
modifier|*
name|objfile
operator|->
name|sf
operator|->
name|sym_offsets
call|)
argument_list|(
name|objfile
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|objfile
operator|->
name|section_offsets
operator|=
name|section_offsets
expr_stmt|;
ifndef|#
directive|ifndef
name|IBM6000_TARGET
comment|/* This is a SVR4/SunOS specific hack, I think.  In any event, it      screws RS/6000.  sym_offsets should be doing this sort of thing,      because it knows the mapping between bfd sections and      section_offsets.  */
comment|/* This is a hack.  As far as I can tell, section offsets are not      target dependent.  They are all set to addr with a couple of      exceptions.  The exceptions are sysvr4 shared libraries, whose      offsets are kept in solib structures anyway and rs6000 xcoff      which handles shared libraries in a completely unique way.       Section offsets are built similarly, except that they are built      by adding addr in all cases because there is no clear mapping      from section_offsets into actual sections.  Note that solib.c      has a different algorythm for finding section offsets.       These should probably all be collapsed into some target      independent form of shared library support.  FIXME.  */
if|if
condition|(
name|addr
condition|)
block|{
name|struct
name|obj_section
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
name|objfile
operator|->
name|sections
init|;
name|s
operator|<
name|objfile
operator|->
name|sections_end
condition|;
operator|++
name|s
control|)
block|{
name|s
operator|->
name|addr
operator|-=
name|s
operator|->
name|offset
expr_stmt|;
name|s
operator|->
name|addr
operator|+=
name|addr
expr_stmt|;
name|s
operator|->
name|endaddr
operator|-=
name|s
operator|->
name|offset
expr_stmt|;
name|s
operator|->
name|endaddr
operator|+=
name|addr
expr_stmt|;
name|s
operator|->
name|offset
operator|+=
name|addr
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* not IBM6000_TARGET */
call|(
modifier|*
name|objfile
operator|->
name|sf
operator|->
name|sym_read
call|)
argument_list|(
name|objfile
argument_list|,
name|section_offsets
argument_list|,
name|mainline
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|have_partial_symbols
argument_list|()
operator|&&
operator|!
name|have_full_symbols
argument_list|()
condition|)
block|{
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"(no debugging symbols found)..."
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
comment|/* Don't allow char * to have a typename (else would get caddr_t).      Ditto void *.  FIXME: Check whether this is now done by all the      symbol readers themselves (many of them now do), and if so remove      it from here.  */
name|TYPE_NAME
argument_list|(
name|lookup_pointer_type
argument_list|(
name|builtin_type_char
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|lookup_pointer_type
argument_list|(
name|builtin_type_void
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Mark the objfile has having had initial symbol read attempted.  Note      that this does not mean we found any symbols... */
name|objfile
operator|->
name|flags
operator||=
name|OBJF_SYMS
expr_stmt|;
comment|/* Discard cleanups as symbol reading was successful.  */
name|discard_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
comment|/* Call this after reading in a new symbol table to give target dependant code    a crack at the new symbols.  For instance, this could be used to update the    values of target-specific symbols GDB needs to keep track of (such as    _sigtramp, or whatever).  */
name|TARGET_SYMFILE_POSTREAD
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Perform required actions after either reading in the initial    symbols for a new objfile, or mapping in the symbols from a reusable    objfile. */
end_comment

begin_function
name|void
name|new_symfile_objfile
parameter_list|(
name|objfile
parameter_list|,
name|mainline
parameter_list|,
name|verbo
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|int
name|mainline
decl_stmt|;
name|int
name|verbo
decl_stmt|;
block|{
comment|/* If this is the main symbol file we have to clean up all users of the      old main symbol file. Otherwise it is sufficient to fixup all the      breakpoints that may have been redefined by this symbol file.  */
if|if
condition|(
name|mainline
condition|)
block|{
comment|/* OK, make it the "real" symbol file.  */
name|symfile_objfile
operator|=
name|objfile
expr_stmt|;
name|clear_symtab_users
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|breakpoint_re_set
argument_list|()
expr_stmt|;
block|}
comment|/* We're done reading the symbol file; finish off complaints.  */
name|clear_complaints
argument_list|(
literal|0
argument_list|,
name|verbo
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Process a symbol file, as either the main file or as a dynamically    loaded file.     NAME is the file name (which will be tilde-expanded and made    absolute herein) (but we don't free or modify NAME itself).    FROM_TTY says how verbose to be.  MAINLINE specifies whether this    is the main symbol file, or whether it's an extra symbol file such    as dynamically loaded code.  If !mainline, ADDR is the address    where the text segment was loaded.     Upon success, returns a pointer to the objfile that was added.    Upon failure, jumps back to command level (never returns). */
end_comment

begin_function
name|struct
name|objfile
modifier|*
name|symbol_file_add
parameter_list|(
name|name
parameter_list|,
name|from_tty
parameter_list|,
name|addr
parameter_list|,
name|mainline
parameter_list|,
name|mapped
parameter_list|,
name|readnow
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|int
name|mainline
decl_stmt|;
name|int
name|mapped
decl_stmt|;
name|int
name|readnow
decl_stmt|;
block|{
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|partial_symtab
modifier|*
name|psymtab
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
comment|/* Open a bfd for the file, and give user a chance to burp if we'd be      interactively wiping out any existing symbols.  */
name|abfd
operator|=
name|symfile_bfd_open
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|have_full_symbols
argument_list|()
operator|||
name|have_partial_symbols
argument_list|()
operator|)
operator|&&
name|mainline
operator|&&
name|from_tty
operator|&&
operator|!
name|query
argument_list|(
literal|"Load new symbol table from \"%s\"? "
argument_list|,
name|name
argument_list|)
condition|)
name|error
argument_list|(
literal|"Not confirmed."
argument_list|)
expr_stmt|;
name|objfile
operator|=
name|allocate_objfile
argument_list|(
name|abfd
argument_list|,
name|mapped
argument_list|)
expr_stmt|;
comment|/* If the objfile uses a mapped symbol file, and we have a psymtab for      it, then skip reading any symbols at this time. */
if|if
condition|(
operator|(
name|objfile
operator|->
name|flags
operator|&
name|OBJF_MAPPED
operator|)
operator|&&
operator|(
name|objfile
operator|->
name|flags
operator|&
name|OBJF_SYMS
operator|)
condition|)
block|{
comment|/* We mapped in an existing symbol table file that already has had 	 initial symbol reading performed, so we can skip that part.  Notify 	 the user that instead of reading the symbols, they have been mapped. 	 */
if|if
condition|(
name|from_tty
operator|||
name|info_verbose
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Mapped symbols for %s..."
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
name|init_entry_point_info
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
name|find_sym_fns
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We either created a new mapped symbol table, mapped an existing 	 symbol table file which has not had initial symbol reading 	 performed, or need to read an unmapped symbol table. */
if|if
condition|(
name|from_tty
operator|||
name|info_verbose
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Reading symbols from %s..."
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
name|syms_from_objfile
argument_list|(
name|objfile
argument_list|,
name|addr
argument_list|,
name|mainline
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
comment|/* We now have at least a partial symbol table.  Check to see if the      user requested that all symbols be read on initial access via either      the gdb startup command line or on a per symbol file basis.  Expand      all partial symbol tables for this objfile if so. */
if|if
condition|(
name|readnow
operator|||
name|readnow_symbol_files
condition|)
block|{
if|if
condition|(
name|from_tty
operator|||
name|info_verbose
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"expanding to full symbols..."
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|psymtab
operator|=
name|objfile
operator|->
name|psymtabs
init|;
name|psymtab
operator|!=
name|NULL
condition|;
name|psymtab
operator|=
name|psymtab
operator|->
name|next
control|)
block|{
name|psymtab_to_symtab
argument_list|(
name|psymtab
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|from_tty
operator|||
name|info_verbose
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"done.\n"
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
name|new_symfile_objfile
argument_list|(
name|objfile
argument_list|,
name|mainline
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
return|return
operator|(
name|objfile
operator|)
return|;
block|}
end_function

begin_comment
comment|/* This is the symbol-file command.  Read the file, analyze its    symbols, and add a struct symtab to a symtab list.  The syntax of    the command is rather bizarre--(1) buildargv implements various    quoting conventions which are undocumented and have little or    nothing in common with the way things are quoted (or not quoted)    elsewhere in GDB, (2) options are used, which are not generally    used in GDB (perhaps "set mapped on", "set readnow on" would be    better), (3) the order of options matters, which is contrary to GNU    conventions (because it is confusing and inconvenient).  */
end_comment

begin_function
name|void
name|symbol_file_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
name|CORE_ADDR
name|text_relocation
init|=
literal|0
decl_stmt|;
comment|/* text_relocation */
name|struct
name|cleanup
modifier|*
name|cleanups
decl_stmt|;
name|int
name|mapped
init|=
literal|0
decl_stmt|;
name|int
name|readnow
init|=
literal|0
decl_stmt|;
name|dont_repeat
argument_list|()
expr_stmt|;
if|if
condition|(
name|args
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|have_full_symbols
argument_list|()
operator|||
name|have_partial_symbols
argument_list|()
operator|)
operator|&&
name|from_tty
operator|&&
operator|!
name|query
argument_list|(
literal|"Discard symbol table from `%s'? "
argument_list|,
name|symfile_objfile
operator|->
name|name
argument_list|)
condition|)
name|error
argument_list|(
literal|"Not confirmed."
argument_list|)
expr_stmt|;
name|free_all_objfiles
argument_list|()
expr_stmt|;
name|symfile_objfile
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"No symbol file now.\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|argv
operator|=
name|buildargv
argument_list|(
name|args
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|nomem
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|cleanups
operator|=
name|make_cleanup
argument_list|(
name|freeargv
argument_list|,
operator|(
name|char
operator|*
operator|)
name|argv
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|argv
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|STREQ
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-mapped"
argument_list|)
condition|)
block|{
name|mapped
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-readnow"
argument_list|)
condition|)
block|{
name|readnow
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
operator|*
name|argv
operator|==
literal|'-'
condition|)
block|{
name|error
argument_list|(
literal|"unknown option `%s'"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|name
operator|=
operator|*
name|argv
expr_stmt|;
comment|/* this is for rombug remote only, to get the text relocation by               using link command */
name|p
operator|=
name|strrchr
argument_list|(
name|name
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
name|p
operator|++
expr_stmt|;
else|else
name|p
operator|=
name|name
expr_stmt|;
name|target_link
argument_list|(
name|p
argument_list|,
operator|&
name|text_relocation
argument_list|)
expr_stmt|;
if|if
condition|(
name|text_relocation
operator|==
operator|(
name|CORE_ADDR
operator|)
literal|0
condition|)
return|return;
elseif|else
if|if
condition|(
name|text_relocation
operator|==
operator|(
name|CORE_ADDR
operator|)
operator|-
literal|1
condition|)
name|symbol_file_add
argument_list|(
name|name
argument_list|,
name|from_tty
argument_list|,
operator|(
name|CORE_ADDR
operator|)
literal|0
argument_list|,
literal|1
argument_list|,
name|mapped
argument_list|,
name|readnow
argument_list|)
expr_stmt|;
else|else
name|symbol_file_add
argument_list|(
name|name
argument_list|,
name|from_tty
argument_list|,
operator|(
name|CORE_ADDR
operator|)
name|text_relocation
argument_list|,
literal|0
argument_list|,
name|mapped
argument_list|,
name|readnow
argument_list|)
expr_stmt|;
comment|/* Getting new symbols may change our opinion about what is 		 frameless.  */
name|reinit_frame_cache
argument_list|()
expr_stmt|;
name|set_initial_language
argument_list|()
expr_stmt|;
block|}
name|argv
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"no symbol file name was specified"
argument_list|)
expr_stmt|;
block|}
name|do_cleanups
argument_list|(
name|cleanups
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Set the initial language.     A better solution would be to record the language in the psymtab when reading    partial symbols, and then use it (if known) to set the language.  This would    be a win for formats that encode the language in an easily discoverable place,    such as DWARF.  For stabs, we can jump through hoops looking for specially    named symbols or try to intuit the language from the specific type of stabs    we find, but we can't do that until later when we read in full symbols.    FIXME.  */
end_comment

begin_function
specifier|static
name|void
name|set_initial_language
parameter_list|()
block|{
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
name|enum
name|language
name|lang
init|=
name|language_unknown
decl_stmt|;
name|pst
operator|=
name|find_main_psymtab
argument_list|()
expr_stmt|;
if|if
condition|(
name|pst
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|pst
operator|->
name|filename
operator|!=
name|NULL
condition|)
block|{
name|lang
operator|=
name|deduce_language_from_filename
argument_list|(
name|pst
operator|->
name|filename
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lang
operator|==
name|language_unknown
condition|)
block|{
comment|/* Make C the default language */
name|lang
operator|=
name|language_c
expr_stmt|;
block|}
name|set_language
argument_list|(
name|lang
argument_list|)
expr_stmt|;
name|expected_language
operator|=
name|current_language
expr_stmt|;
comment|/* Don't warn the user */
block|}
block|}
end_function

begin_comment
comment|/* Open file specified by NAME and hand it off to BFD for preliminary    analysis.  Result is a newly initialized bfd *, which includes a newly    malloc'd` copy of NAME (tilde-expanded and made absolute).    In case of trouble, error() is called.  */
end_comment

begin_function
specifier|static
name|bfd
modifier|*
name|symfile_bfd_open
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|bfd
modifier|*
name|sym_bfd
decl_stmt|;
name|int
name|desc
decl_stmt|;
name|char
modifier|*
name|absolute_name
decl_stmt|;
name|name
operator|=
name|tilde_expand
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* Returns 1st new malloc'd copy */
comment|/* Look down path for it, allocate 2nd new malloc'd copy.  */
name|desc
operator|=
name|openp
argument_list|(
name|getenv
argument_list|(
literal|"PATH"
argument_list|)
argument_list|,
literal|1
argument_list|,
name|name
argument_list|,
name|O_RDONLY
operator||
name|O_BINARY
argument_list|,
literal|0
argument_list|,
operator|&
name|absolute_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|<
literal|0
condition|)
block|{
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|perror_with_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
name|fcntl
argument_list|(
name|desc
argument_list|,
name|F_SETFD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* Free 1st new malloc'd copy */
name|name
operator|=
name|absolute_name
expr_stmt|;
comment|/* Keep 2nd malloc'd copy in bfd */
comment|/* It'll be freed in free_objfile(). */
name|sym_bfd
operator|=
name|bfd_fdopenr
argument_list|(
name|name
argument_list|,
name|gnutarget
argument_list|,
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sym_bfd
condition|)
block|{
name|close
argument_list|(
name|desc
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"\"%s\": can't open to read symbols: %s."
argument_list|,
name|name
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sym_bfd
operator|->
name|cacheable
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_check_format
argument_list|(
name|sym_bfd
argument_list|,
name|bfd_object
argument_list|)
condition|)
block|{
comment|/* FIXME: should be checking for errors from bfd_close (for one thing, 	 on error it does not free all the storage associated with the 	 bfd).  */
name|bfd_close
argument_list|(
name|sym_bfd
argument_list|)
expr_stmt|;
comment|/* This also closes desc */
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"\"%s\": can't read symbols: %s."
argument_list|,
name|name
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|sym_bfd
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Link a new symtab_fns into the global symtab_fns list.  Called on gdb    startup by the _initialize routine in each object file format reader,    to register information about each format the the reader is prepared    to handle. */
end_comment

begin_function
name|void
name|add_symtab_fns
parameter_list|(
name|sf
parameter_list|)
name|struct
name|sym_fns
modifier|*
name|sf
decl_stmt|;
block|{
name|sf
operator|->
name|next
operator|=
name|symtab_fns
expr_stmt|;
name|symtab_fns
operator|=
name|sf
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize to read symbols from the symbol file sym_bfd.  It either    returns or calls error().  The result is an initialized struct sym_fns    in the objfile structure, that contains cached information about the    symbol file.  */
end_comment

begin_function
specifier|static
name|void
name|find_sym_fns
parameter_list|(
name|objfile
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|struct
name|sym_fns
modifier|*
name|sf
decl_stmt|;
name|enum
name|bfd_flavour
name|our_flavour
init|=
name|bfd_get_flavour
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|)
decl_stmt|;
name|char
modifier|*
name|our_target
init|=
name|bfd_get_target
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|)
decl_stmt|;
comment|/* Special kludge for RS/6000 and PowerMac.  See xcoffread.c.  */
if|if
condition|(
name|STREQ
argument_list|(
name|our_target
argument_list|,
literal|"aixcoff-rs6000"
argument_list|)
operator|||
name|STREQ
argument_list|(
name|our_target
argument_list|,
literal|"xcoff-powermac"
argument_list|)
condition|)
name|our_flavour
operator|=
operator|(
expr|enum
name|bfd_flavour
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* Special kludge for apollo.  See dstread.c.  */
if|if
condition|(
name|STREQN
argument_list|(
name|our_target
argument_list|,
literal|"apollo"
argument_list|,
literal|6
argument_list|)
condition|)
name|our_flavour
operator|=
operator|(
expr|enum
name|bfd_flavour
operator|)
operator|-
literal|2
expr_stmt|;
for|for
control|(
name|sf
operator|=
name|symtab_fns
init|;
name|sf
operator|!=
name|NULL
condition|;
name|sf
operator|=
name|sf
operator|->
name|next
control|)
block|{
if|if
condition|(
name|our_flavour
operator|==
name|sf
operator|->
name|sym_flavour
condition|)
block|{
name|objfile
operator|->
name|sf
operator|=
name|sf
expr_stmt|;
return|return;
block|}
block|}
name|error
argument_list|(
literal|"I'm sorry, Dave, I can't do that.  Symbol format `%s' unknown."
argument_list|,
name|bfd_get_target
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This function runs the load command of our current target.  */
end_comment

begin_function
specifier|static
name|void
name|load_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
if|if
condition|(
name|arg
operator|==
name|NULL
condition|)
name|arg
operator|=
name|get_exec_file
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|target_load
argument_list|(
name|arg
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This version of "load" should be usable for any target.  Currently    it is just used for remote targets, not inftarg.c or core files,    on the theory that only in that case is it useful.     Avoiding xmodem and the like seems like a win (a) because we don't have    to worry about finding it, and (b) On VMS, fork() is very slow and so    we don't want to run a subprocess.  On the other hand, I'm not sure how    performance compares.  */
end_comment

begin_function
name|void
name|generic_load
parameter_list|(
name|filename
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|struct
name|cleanup
modifier|*
name|old_cleanups
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd
modifier|*
name|loadfile_bfd
decl_stmt|;
name|time_t
name|start_time
decl_stmt|,
name|end_time
decl_stmt|;
comment|/* Start and end times of download */
name|unsigned
name|long
name|data_count
decl_stmt|;
comment|/* Number of bytes transferred to memory */
name|loadfile_bfd
operator|=
name|bfd_openr
argument_list|(
name|filename
argument_list|,
name|gnutarget
argument_list|)
expr_stmt|;
if|if
condition|(
name|loadfile_bfd
operator|==
name|NULL
condition|)
block|{
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* FIXME: should be checking for errors from bfd_close (for one thing,      on error it does not free all the storage associated with the      bfd).  */
name|old_cleanups
operator|=
name|make_cleanup
argument_list|(
name|bfd_close
argument_list|,
name|loadfile_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_check_format
argument_list|(
name|loadfile_bfd
argument_list|,
name|bfd_object
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"\"%s\" is not an object file: %s"
argument_list|,
name|filename
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|start_time
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|loadfile_bfd
operator|->
name|sections
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
if|if
condition|(
name|s
operator|->
name|flags
operator|&
name|SEC_LOAD
condition|)
block|{
name|bfd_size_type
name|size
decl_stmt|;
name|size
operator|=
name|bfd_get_section_size_before_reloc
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|>
literal|0
condition|)
block|{
name|char
modifier|*
name|buffer
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|bfd_vma
name|vma
decl_stmt|;
name|data_count
operator|+=
name|size
expr_stmt|;
name|buffer
operator|=
name|xmalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|vma
operator|=
name|bfd_get_section_vma
argument_list|(
name|loadfile_bfd
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* Is this really necessary?  I guess it gives the user something 		 to look at during a long download.  */
name|printf_filtered
argument_list|(
literal|"Loading section %s, size 0x%lx vma "
argument_list|,
name|bfd_get_section_name
argument_list|(
name|loadfile_bfd
argument_list|,
name|s
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|size
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|vma
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|bfd_get_section_contents
argument_list|(
name|loadfile_bfd
argument_list|,
name|s
argument_list|,
name|buffer
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|target_write_memory
argument_list|(
name|vma
argument_list|,
name|buffer
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|end_time
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|/* We were doing this in remote-mips.c, I suspect it is right      for other targets too.  */
name|write_pc
argument_list|(
name|loadfile_bfd
operator|->
name|start_address
argument_list|)
expr_stmt|;
comment|/* FIXME: are we supposed to call symbol_file_add or not?  According to      a comment from remote-mips.c (where a call to symbol_file_add was      commented out), making the call confuses GDB if more than one file is      loaded in.  remote-nindy.c had no call to symbol_file_add, but remote-vx.c      does.  */
if|if
condition|(
name|end_time
operator|!=
name|start_time
condition|)
name|printf_filtered
argument_list|(
literal|"Transfer rate: %d bits/sec.\n"
argument_list|,
operator|(
name|data_count
operator|*
literal|8
operator|)
operator|/
operator|(
name|end_time
operator|-
name|start_time
operator|)
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_cleanups
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function allows the addition of incrementally linked object files.    It does not modify any state in the target, only in the debugger.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|add_symbol_file_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|char
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
name|CORE_ADDR
name|text_addr
decl_stmt|;
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|readnow
init|=
literal|0
decl_stmt|;
name|int
name|mapped
init|=
literal|0
decl_stmt|;
name|dont_repeat
argument_list|()
expr_stmt|;
if|if
condition|(
name|args
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"add-symbol-file takes a file name and an address"
argument_list|)
expr_stmt|;
block|}
comment|/* Make a copy of the string that we can safely write into. */
name|args
operator|=
name|strdup
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|args
argument_list|)
expr_stmt|;
comment|/* Pick off any -option args and the file name. */
while|while
condition|(
operator|(
operator|*
name|args
operator|!=
literal|'\000'
operator|)
operator|&&
operator|(
name|name
operator|==
name|NULL
operator|)
condition|)
block|{
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|args
argument_list|)
condition|)
block|{
name|args
operator|++
expr_stmt|;
block|}
name|arg
operator|=
name|args
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|args
operator|!=
literal|'\000'
operator|)
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|args
argument_list|)
condition|)
block|{
name|args
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|args
operator|!=
literal|'\000'
condition|)
block|{
operator|*
name|args
operator|++
operator|=
literal|'\000'
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|arg
operator|!=
literal|'-'
condition|)
block|{
name|name
operator|=
name|arg
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|arg
argument_list|,
literal|"-mapped"
argument_list|)
condition|)
block|{
name|mapped
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|arg
argument_list|,
literal|"-readnow"
argument_list|)
condition|)
block|{
name|readnow
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"unknown option `%s'"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* After picking off any options and the file name, args should be      left pointing at the remainder of the command line, which should      be the address expression to evaluate. */
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"add-symbol-file takes a file name"
argument_list|)
expr_stmt|;
block|}
name|name
operator|=
name|tilde_expand
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|args
operator|!=
literal|'\000'
condition|)
block|{
name|text_addr
operator|=
name|parse_and_eval_address
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|target_link
argument_list|(
name|name
argument_list|,
operator|&
name|text_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|text_addr
operator|==
operator|(
name|CORE_ADDR
operator|)
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"Don't know how to get text start location for this file"
argument_list|)
expr_stmt|;
block|}
comment|/* FIXME-32x64: Assumes text_addr fits in a long.  */
if|if
condition|(
operator|!
name|query
argument_list|(
literal|"add symbol table from file \"%s\" at text_addr = %s?\n"
argument_list|,
name|name
argument_list|,
name|local_hex_string
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|text_addr
argument_list|)
argument_list|)
condition|)
name|error
argument_list|(
literal|"Not confirmed."
argument_list|)
expr_stmt|;
name|symbol_file_add
argument_list|(
name|name
argument_list|,
literal|0
argument_list|,
name|text_addr
argument_list|,
literal|0
argument_list|,
name|mapped
argument_list|,
name|readnow
argument_list|)
expr_stmt|;
comment|/* Getting new symbols may change our opinion about what is      frameless.  */
name|reinit_frame_cache
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|add_shared_symbol_files_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|ADD_SHARED_SYMBOL_FILES
name|ADD_SHARED_SYMBOL_FILES
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
argument_list|(
literal|"This command is not available in this configuration of GDB."
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Re-read symbols if a symbol-file has changed.  */
end_comment

begin_function
name|void
name|reread_symbols
parameter_list|()
block|{
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|long
name|new_modtime
decl_stmt|;
name|int
name|reread_one
init|=
literal|0
decl_stmt|;
name|struct
name|stat
name|new_statbuf
decl_stmt|;
name|int
name|res
decl_stmt|;
comment|/* With the addition of shared libraries, this should be modified,      the load time should be saved in the partial symbol tables, since      different tables may come from different source files.  FIXME.      This routine should then walk down each partial symbol table      and see if the symbol table that it originates from has been changed */
for|for
control|(
name|objfile
operator|=
name|object_files
init|;
name|objfile
condition|;
name|objfile
operator|=
name|objfile
operator|->
name|next
control|)
block|{
if|if
condition|(
name|objfile
operator|->
name|obfd
condition|)
block|{
ifdef|#
directive|ifdef
name|IBM6000_TARGET
comment|/* If this object is from a shared library, then you should         stat on the library name, not member name. */
if|if
condition|(
name|objfile
operator|->
name|obfd
operator|->
name|my_archive
condition|)
name|res
operator|=
name|stat
argument_list|(
name|objfile
operator|->
name|obfd
operator|->
name|my_archive
operator|->
name|filename
argument_list|,
operator|&
name|new_statbuf
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|res
operator|=
name|stat
argument_list|(
name|objfile
operator|->
name|name
argument_list|,
operator|&
name|new_statbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
literal|0
condition|)
block|{
comment|/* FIXME, should use print_sys_errmsg but it's not filtered. */
name|printf_filtered
argument_list|(
literal|"`%s' has disappeared; keeping its symbols.\n"
argument_list|,
name|objfile
operator|->
name|name
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|new_modtime
operator|=
name|new_statbuf
operator|.
name|st_mtime
expr_stmt|;
if|if
condition|(
name|new_modtime
operator|!=
name|objfile
operator|->
name|mtime
condition|)
block|{
name|struct
name|cleanup
modifier|*
name|old_cleanups
decl_stmt|;
name|struct
name|section_offsets
modifier|*
name|offsets
decl_stmt|;
name|int
name|num_offsets
decl_stmt|;
name|int
name|section_offsets_size
decl_stmt|;
name|char
modifier|*
name|obfd_filename
decl_stmt|;
name|printf_filtered
argument_list|(
literal|"`%s' has changed; re-reading symbols.\n"
argument_list|,
name|objfile
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* There are various functions like symbol_file_add, 	     symfile_bfd_open, syms_from_objfile, etc., which might 	     appear to do what we want.  But they have various other 	     effects which we *don't* want.  So we just do stuff 	     ourselves.  We don't worry about mapped files (for one thing, 	     any mapped file will be out of date).  */
comment|/* If we get an error, blow away this objfile (not sure if 	     that is the correct response for things like shared 	     libraries).  */
name|old_cleanups
operator|=
name|make_cleanup
argument_list|(
name|free_objfile
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* We need to do this whenever any symbols go away.  */
name|make_cleanup
argument_list|(
name|clear_symtab_users
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Clean up any state BFD has sitting around.  We don't need 	     to close the descriptor but BFD lacks a way of closing the 	     BFD without closing the descriptor.  */
name|obfd_filename
operator|=
name|bfd_get_filename
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_close
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|)
condition|)
name|error
argument_list|(
literal|"Can't close BFD for %s: %s"
argument_list|,
name|objfile
operator|->
name|name
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|objfile
operator|->
name|obfd
operator|=
name|bfd_openr
argument_list|(
name|obfd_filename
argument_list|,
name|gnutarget
argument_list|)
expr_stmt|;
if|if
condition|(
name|objfile
operator|->
name|obfd
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Can't open %s to read symbols."
argument_list|,
name|objfile
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* bfd_openr sets cacheable to true, which is what we want.  */
if|if
condition|(
operator|!
name|bfd_check_format
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|bfd_object
argument_list|)
condition|)
name|error
argument_list|(
literal|"Can't read symbols from %s: %s."
argument_list|,
name|objfile
operator|->
name|name
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Save the offsets, we will nuke them with the rest of the 	     psymbol_obstack.  */
name|num_offsets
operator|=
name|objfile
operator|->
name|num_sections
expr_stmt|;
name|section_offsets_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|section_offsets
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|objfile
operator|->
name|section_offsets
operator|->
name|offsets
argument_list|)
operator|*
name|num_offsets
expr_stmt|;
name|offsets
operator|=
operator|(
expr|struct
name|section_offsets
operator|*
operator|)
name|alloca
argument_list|(
name|section_offsets_size
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|offsets
argument_list|,
name|objfile
operator|->
name|section_offsets
argument_list|,
name|section_offsets_size
argument_list|)
expr_stmt|;
comment|/* Nuke all the state that we will re-read.  Much of the following 	     code which sets things to NULL really is necessary to tell 	     other parts of GDB that there is nothing currently there.  */
comment|/* FIXME: Do we have to free a whole linked list, or is this 	     enough?  */
if|if
condition|(
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
condition|)
name|mfree
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|objfile
operator|->
name|global_psymbols
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|objfile
operator|->
name|global_psymbols
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|objfile
operator|->
name|static_psymbols
operator|.
name|list
condition|)
name|mfree
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
name|objfile
operator|->
name|static_psymbols
operator|.
name|list
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|objfile
operator|->
name|static_psymbols
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|objfile
operator|->
name|static_psymbols
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Free the obstacks for non-reusable objfiles */
name|obstack_free
argument_list|(
operator|&
name|objfile
operator|->
name|psymbol_cache
operator|.
name|cache
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|objfile
operator|->
name|psymbol_cache
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|objfile
operator|->
name|psymbol_cache
argument_list|)
argument_list|)
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|objfile
operator|->
name|psymbol_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|objfile
operator|->
name|type_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|objfile
operator|->
name|sections
operator|=
name|NULL
expr_stmt|;
name|objfile
operator|->
name|symtabs
operator|=
name|NULL
expr_stmt|;
name|objfile
operator|->
name|psymtabs
operator|=
name|NULL
expr_stmt|;
name|objfile
operator|->
name|free_psymtabs
operator|=
name|NULL
expr_stmt|;
name|objfile
operator|->
name|msymbols
operator|=
name|NULL
expr_stmt|;
name|objfile
operator|->
name|minimal_symbol_count
operator|=
literal|0
expr_stmt|;
name|objfile
operator|->
name|fundamental_types
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|objfile
operator|->
name|sf
operator|!=
name|NULL
condition|)
block|{
call|(
modifier|*
name|objfile
operator|->
name|sf
operator|->
name|sym_finish
call|)
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
block|}
comment|/* We never make this a mapped file.  */
name|objfile
operator|->
name|md
operator|=
name|NULL
expr_stmt|;
comment|/* obstack_specify_allocation also initializes the obstack so 	     it is empty.  */
name|obstack_specify_allocation
argument_list|(
operator|&
name|objfile
operator|->
name|psymbol_cache
operator|.
name|cache
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|xmalloc
argument_list|,
name|free
argument_list|)
expr_stmt|;
name|obstack_specify_allocation
argument_list|(
operator|&
name|objfile
operator|->
name|psymbol_obstack
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|xmalloc
argument_list|,
name|free
argument_list|)
expr_stmt|;
name|obstack_specify_allocation
argument_list|(
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|xmalloc
argument_list|,
name|free
argument_list|)
expr_stmt|;
name|obstack_specify_allocation
argument_list|(
operator|&
name|objfile
operator|->
name|type_obstack
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|xmalloc
argument_list|,
name|free
argument_list|)
expr_stmt|;
if|if
condition|(
name|build_objfile_section_table
argument_list|(
name|objfile
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"Can't find the file sections in `%s': %s"
argument_list|,
name|objfile
operator|->
name|name
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* We use the same section offsets as from last time.  I'm not 	     sure whether that is always correct for shared libraries.  */
name|objfile
operator|->
name|section_offsets
operator|=
operator|(
expr|struct
name|section_offsets
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|psymbol_obstack
argument_list|,
name|section_offsets_size
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|objfile
operator|->
name|section_offsets
argument_list|,
name|offsets
argument_list|,
name|section_offsets_size
argument_list|)
expr_stmt|;
name|objfile
operator|->
name|num_sections
operator|=
name|num_offsets
expr_stmt|;
comment|/* What the hell is sym_new_init for, anyway?  The concept of 	     distinguishing between the main file and additional files 	     in this way seems rather dubious.  */
if|if
condition|(
name|objfile
operator|==
name|symfile_objfile
condition|)
call|(
modifier|*
name|objfile
operator|->
name|sf
operator|->
name|sym_new_init
call|)
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
call|(
modifier|*
name|objfile
operator|->
name|sf
operator|->
name|sym_init
call|)
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
name|clear_complaints
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* The "mainline" parameter is a hideous hack; I think leaving it 	     zero is OK since dbxread.c also does what it needs to do if 	     objfile->global_psymbols.size is 0.  */
call|(
modifier|*
name|objfile
operator|->
name|sf
operator|->
name|sym_read
call|)
argument_list|(
name|objfile
argument_list|,
name|objfile
operator|->
name|section_offsets
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|have_partial_symbols
argument_list|()
operator|&&
operator|!
name|have_full_symbols
argument_list|()
condition|)
block|{
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"(no debugging symbols found)\n"
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
name|objfile
operator|->
name|flags
operator||=
name|OBJF_SYMS
expr_stmt|;
comment|/* We're done reading the symbol file; finish off complaints.  */
name|clear_complaints
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Getting new symbols may change our opinion about what is 	     frameless.  */
name|reinit_frame_cache
argument_list|()
expr_stmt|;
comment|/* Discard cleanups as symbol reading was successful.  */
name|discard_cleanups
argument_list|(
name|old_cleanups
argument_list|)
expr_stmt|;
comment|/* If the mtime has changed between the time we set new_modtime 	     and now, we *want* this to be out of date, so don't call stat 	     again now.  */
name|objfile
operator|->
name|mtime
operator|=
name|new_modtime
expr_stmt|;
name|reread_one
operator|=
literal|1
expr_stmt|;
comment|/* Call this after reading in a new symbol table to give target 	     dependant code a crack at the new symbols.  For instance, this 	     could be used to update the values of target-specific symbols GDB 	     needs to keep track of (such as _sigtramp, or whatever).  */
name|TARGET_SYMFILE_POSTREAD
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|reread_one
condition|)
name|clear_symtab_users
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|enum
name|language
name|deduce_language_from_filename
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|char
modifier|*
name|c
decl_stmt|;
if|if
condition|(
literal|0
operator|==
name|filename
condition|)
empty_stmt|;
comment|/* Get default */
elseif|else
if|if
condition|(
literal|0
operator|==
operator|(
name|c
operator|=
name|strrchr
argument_list|(
name|filename
argument_list|,
literal|'.'
argument_list|)
operator|)
condition|)
empty_stmt|;
comment|/* Get default. */
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|c
argument_list|,
literal|".c"
argument_list|)
condition|)
return|return
name|language_c
return|;
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|c
argument_list|,
literal|".cc"
argument_list|)
operator|||
name|STREQ
argument_list|(
name|c
argument_list|,
literal|".C"
argument_list|)
operator|||
name|STREQ
argument_list|(
name|c
argument_list|,
literal|".cxx"
argument_list|)
operator|||
name|STREQ
argument_list|(
name|c
argument_list|,
literal|".cpp"
argument_list|)
operator|||
name|STREQ
argument_list|(
name|c
argument_list|,
literal|".cp"
argument_list|)
operator|||
name|STREQ
argument_list|(
name|c
argument_list|,
literal|".c++"
argument_list|)
condition|)
return|return
name|language_cplus
return|;
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|c
argument_list|,
literal|".ch"
argument_list|)
operator|||
name|STREQ
argument_list|(
name|c
argument_list|,
literal|".c186"
argument_list|)
operator|||
name|STREQ
argument_list|(
name|c
argument_list|,
literal|".c286"
argument_list|)
condition|)
return|return
name|language_chill
return|;
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|c
argument_list|,
literal|".f"
argument_list|)
operator|||
name|STREQ
argument_list|(
name|c
argument_list|,
literal|".F"
argument_list|)
condition|)
return|return
name|language_fortran
return|;
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|c
argument_list|,
literal|".mod"
argument_list|)
condition|)
return|return
name|language_m2
return|;
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|c
argument_list|,
literal|".s"
argument_list|)
operator|||
name|STREQ
argument_list|(
name|c
argument_list|,
literal|".S"
argument_list|)
condition|)
return|return
name|language_asm
return|;
return|return
name|language_unknown
return|;
comment|/* default */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* allocate_symtab:     Allocate and partly initialize a new symbol table.  Return a pointer    to it.  error() if no space.     Caller must set these fields: 	LINETABLE(symtab) 	symtab->blockvector 	symtab->dirname 	symtab->free_code 	symtab->free_ptr 	initialize any EXTRA_SYMTAB_INFO 	possibly free_named_symtabs (symtab->filename);  */
end_comment

begin_function
name|struct
name|symtab
modifier|*
name|allocate_symtab
parameter_list|(
name|filename
parameter_list|,
name|objfile
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
specifier|register
name|struct
name|symtab
modifier|*
name|symtab
decl_stmt|;
name|symtab
operator|=
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symtab
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|symtab
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|symtab
argument_list|)
argument_list|)
expr_stmt|;
name|symtab
operator|->
name|filename
operator|=
name|obsavestring
argument_list|(
name|filename
argument_list|,
name|strlen
argument_list|(
name|filename
argument_list|)
argument_list|,
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|)
expr_stmt|;
name|symtab
operator|->
name|fullname
operator|=
name|NULL
expr_stmt|;
name|symtab
operator|->
name|language
operator|=
name|deduce_language_from_filename
argument_list|(
name|filename
argument_list|)
expr_stmt|;
comment|/* Hook it to the objfile it comes from */
name|symtab
operator|->
name|objfile
operator|=
name|objfile
expr_stmt|;
name|symtab
operator|->
name|next
operator|=
name|objfile
operator|->
name|symtabs
expr_stmt|;
name|objfile
operator|->
name|symtabs
operator|=
name|symtab
expr_stmt|;
ifdef|#
directive|ifdef
name|INIT_EXTRA_SYMTAB_INFO
name|INIT_EXTRA_SYMTAB_INFO
argument_list|(
name|symtab
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|symtab
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|partial_symtab
modifier|*
name|allocate_psymtab
parameter_list|(
name|filename
parameter_list|,
name|objfile
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|struct
name|partial_symtab
modifier|*
name|psymtab
decl_stmt|;
if|if
condition|(
name|objfile
operator|->
name|free_psymtabs
condition|)
block|{
name|psymtab
operator|=
name|objfile
operator|->
name|free_psymtabs
expr_stmt|;
name|objfile
operator|->
name|free_psymtabs
operator|=
name|psymtab
operator|->
name|next
expr_stmt|;
block|}
else|else
name|psymtab
operator|=
operator|(
expr|struct
name|partial_symtab
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|psymbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|partial_symtab
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|psymtab
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|partial_symtab
argument_list|)
argument_list|)
expr_stmt|;
name|psymtab
operator|->
name|filename
operator|=
name|obsavestring
argument_list|(
name|filename
argument_list|,
name|strlen
argument_list|(
name|filename
argument_list|)
argument_list|,
operator|&
name|objfile
operator|->
name|psymbol_obstack
argument_list|)
expr_stmt|;
name|psymtab
operator|->
name|symtab
operator|=
name|NULL
expr_stmt|;
comment|/* Hook it to the objfile it comes from */
name|psymtab
operator|->
name|objfile
operator|=
name|objfile
expr_stmt|;
name|psymtab
operator|->
name|next
operator|=
name|objfile
operator|->
name|psymtabs
expr_stmt|;
name|objfile
operator|->
name|psymtabs
operator|=
name|psymtab
expr_stmt|;
return|return
operator|(
name|psymtab
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Reset all data structures in gdb which may contain references to symbol    table date.  */
end_comment

begin_function
name|void
name|clear_symtab_users
parameter_list|()
block|{
comment|/* Someday, we should do better than this, by only blowing away      the things that really need to be blown.  */
name|clear_value_history
argument_list|()
expr_stmt|;
name|clear_displays
argument_list|()
expr_stmt|;
name|clear_internalvars
argument_list|()
expr_stmt|;
name|breakpoint_re_set
argument_list|()
expr_stmt|;
name|set_default_breakpoint
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|current_source_symtab
operator|=
literal|0
expr_stmt|;
name|current_source_line
operator|=
literal|0
expr_stmt|;
name|clear_pc_function_cache
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* clear_symtab_users_once:     This function is run after symbol reading, or from a cleanup.    If an old symbol table was obsoleted, the old symbol table    has been blown away, but the other GDB data structures that may     reference it have not yet been cleared or re-directed.  (The old    symtab was zapped, and the cleanup queued, in free_named_symtab()    below.)     This function can be queued N times as a cleanup, or called    directly; it will do all the work the first time, and then will be a    no-op until the next time it is queued.  This works by bumping a    counter at queueing time.  Much later when the cleanup is run, or at    the end of symbol processing (in case the cleanup is discarded), if    the queued count is greater than the "done-count", we do the work    and set the done-count to the queued count.  If the queued count is    less than or equal to the done-count, we just ignore the call.  This    is needed because reading a single .o file will often replace many    symtabs (one per .h file, for example), and we don't want to reset    the breakpoints N times in the user's face.     The reason we both queue a cleanup, and call it directly after symbol    reading, is because the cleanup protects us in case of errors, but is    discarded if symbol reading is successful.  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* FIXME:  As free_named_symtabs is currently a big noop this function    is no longer needed.  */
end_comment

begin_comment
unit|static void clear_symtab_users_once PARAMS ((void));  static int clear_symtab_users_queued; static int clear_symtab_users_done;  static void clear_symtab_users_once () {
comment|/* Enforce once-per-`do_cleanups'-semantics */
end_comment

begin_endif
unit|if (clear_symtab_users_queued<= clear_symtab_users_done)     return;   clear_symtab_users_done = clear_symtab_users_queued;    clear_symtab_users (); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* Delete the specified psymtab, and any others that reference it.  */
end_comment

begin_function
specifier|static
name|void
name|cashier_psymtab
parameter_list|(
name|pst
parameter_list|)
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
block|{
name|struct
name|partial_symtab
modifier|*
name|ps
decl_stmt|,
modifier|*
name|pprev
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Find its previous psymtab in the chain */
for|for
control|(
name|ps
operator|=
name|pst
operator|->
name|objfile
operator|->
name|psymtabs
init|;
name|ps
condition|;
name|ps
operator|=
name|ps
operator|->
name|next
control|)
block|{
if|if
condition|(
name|ps
operator|==
name|pst
condition|)
break|break;
name|pprev
operator|=
name|ps
expr_stmt|;
block|}
if|if
condition|(
name|ps
condition|)
block|{
comment|/* Unhook it from the chain.  */
if|if
condition|(
name|ps
operator|==
name|pst
operator|->
name|objfile
operator|->
name|psymtabs
condition|)
name|pst
operator|->
name|objfile
operator|->
name|psymtabs
operator|=
name|ps
operator|->
name|next
expr_stmt|;
else|else
name|pprev
operator|->
name|next
operator|=
name|ps
operator|->
name|next
expr_stmt|;
comment|/* FIXME, we can't conveniently deallocate the entries in the        partial_symbol lists (global_psymbols/static_psymbols) that        this psymtab points to.  These just take up space until all        the psymtabs are reclaimed.  Ditto the dependencies list and        filename, which are all in the psymbol_obstack.  */
comment|/* We need to cashier any psymtab that has this one as a dependency... */
name|again
label|:
for|for
control|(
name|ps
operator|=
name|pst
operator|->
name|objfile
operator|->
name|psymtabs
init|;
name|ps
condition|;
name|ps
operator|=
name|ps
operator|->
name|next
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ps
operator|->
name|number_of_dependencies
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ps
operator|->
name|dependencies
index|[
name|i
index|]
operator|==
name|pst
condition|)
block|{
name|cashier_psymtab
argument_list|(
name|ps
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
comment|/* Must restart, chain has been munged. */
block|}
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* If a symtab or psymtab for filename NAME is found, free it along    with any dependent breakpoints, displays, etc.    Used when loading new versions of object modules with the "add-file"    command.  This is only called on the top-level symtab or psymtab's name;    it is not called for subsidiary files such as .h files.     Return value is 1 if we blew away the environment, 0 if not.    FIXME.  The return valu appears to never be used.     FIXME.  I think this is not the best way to do this.  We should    work on being gentler to the environment while still cleaning up    all stray pointers into the freed symtab.  */
end_comment

begin_function
name|int
name|free_named_symtabs
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
if|#
directive|if
literal|0
comment|/* FIXME:  With the new method of each objfile having it's own      psymtab list, this function needs serious rethinking.  In particular,      why was it ever necessary to toss psymtabs with specific compilation      unit filenames, as opposed to all psymtabs from a particular symbol      file?  -- fnf      Well, the answer is that some systems permit reloading of particular      compilation units.  We want to blow away any old info about these      compilation units, regardless of which objfiles they arrived in. --gnu.  */
block|register struct symtab *s;   register struct symtab *prev;   register struct partial_symtab *ps;   struct blockvector *bv;   int blewit = 0;
comment|/* We only wack things if the symbol-reload switch is set.  */
block|if (!symbol_reloading)     return 0;
comment|/* Some symbol formats have trouble providing file names... */
block|if (name == 0 || *name == '\0')     return 0;
comment|/* Look for a psymtab with the specified name.  */
block|again2:   for (ps = partial_symtab_list; ps; ps = ps->next) {     if (STREQ (name, ps->filename)) {       cashier_psymtab (ps);
comment|/* Blow it away...and its little dog, too.  */
block|goto again2;
comment|/* Must restart, chain has been munged */
block|}   }
comment|/* Look for a symtab with the specified name.  */
block|for (s = symtab_list; s; s = s->next)     {       if (STREQ (name, s->filename)) 	break;       prev = s;     }    if (s)     {       if (s == symtab_list) 	symtab_list = s->next;       else 	prev->next = s->next;
comment|/* For now, queue a delete for all breakpoints, displays, etc., whether 	 or not they depend on the symtab being freed.  This should be 	 changed so that only those data structures affected are deleted.  */
comment|/* But don't delete anything if the symtab is empty. 	 This test is necessary due to a bug in "dbxread.c" that 	 causes empty symtabs to be created for N_SO symbols that 	 contain the pathname of the object file.  (This problem 	 has been fixed in GDB 3.9x).  */
block|bv = BLOCKVECTOR (s);       if (BLOCKVECTOR_NBLOCKS (bv)> 2 	  || BLOCK_NSYMS (BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK)) 	  || BLOCK_NSYMS (BLOCKVECTOR_BLOCK (bv, STATIC_BLOCK))) 	{ 	  complain (&oldsyms_complaint, name);  	  clear_symtab_users_queued++; 	  make_cleanup (clear_symtab_users_once, 0); 	  blewit = 1; 	} else { 	  complain (&empty_symtab_complaint, name); 	}        free_symtab (s);     }   else     {
comment|/* It is still possible that some breakpoints will be affected 	 even though no symtab was found, since the file might have 	 been compiled without debugging, and hence not be associated 	 with a symtab.  In order to handle this correctly, we would need 	 to keep a list of text address ranges for undebuggable files. 	 For now, we do nothing, since this is a fairly obscure case.  */
block|;     }
comment|/* FIXME, what about the minimal symbol table? */
block|return blewit;
else|#
directive|else
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Allocate and partially fill a partial symtab.  It will be    completely filled at the end of the symbol list.     SYMFILE_NAME is the name of the symbol-file we are reading from, and ADDR    is the address relative to which its symbols are (incremental) or 0    (normal). */
end_comment

begin_function
name|struct
name|partial_symtab
modifier|*
name|start_psymtab_common
parameter_list|(
name|objfile
parameter_list|,
name|section_offsets
parameter_list|,
name|filename
parameter_list|,
name|textlow
parameter_list|,
name|global_syms
parameter_list|,
name|static_syms
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|section_offsets
modifier|*
name|section_offsets
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|CORE_ADDR
name|textlow
decl_stmt|;
name|struct
name|partial_symbol
modifier|*
modifier|*
name|global_syms
decl_stmt|;
name|struct
name|partial_symbol
modifier|*
modifier|*
name|static_syms
decl_stmt|;
block|{
name|struct
name|partial_symtab
modifier|*
name|psymtab
decl_stmt|;
name|psymtab
operator|=
name|allocate_psymtab
argument_list|(
name|filename
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|psymtab
operator|->
name|section_offsets
operator|=
name|section_offsets
expr_stmt|;
name|psymtab
operator|->
name|textlow
operator|=
name|textlow
expr_stmt|;
name|psymtab
operator|->
name|texthigh
operator|=
name|psymtab
operator|->
name|textlow
expr_stmt|;
comment|/* default */
name|psymtab
operator|->
name|globals_offset
operator|=
name|global_syms
operator|-
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
expr_stmt|;
name|psymtab
operator|->
name|statics_offset
operator|=
name|static_syms
operator|-
name|objfile
operator|->
name|static_psymbols
operator|.
name|list
expr_stmt|;
return|return
operator|(
name|psymtab
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add a symbol with a long value to a psymtab.    Since one arg is a struct, we pass in a ptr and deref it (sigh).  */
end_comment

begin_function
name|void
name|add_psymbol_to_list
parameter_list|(
name|name
parameter_list|,
name|namelength
parameter_list|,
name|namespace
parameter_list|,
name|class
parameter_list|,
name|list
parameter_list|,
name|val
parameter_list|,
name|coreaddr
parameter_list|,
name|language
parameter_list|,
name|objfile
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|namelength
decl_stmt|;
name|namespace_enum
name|namespace
decl_stmt|;
name|enum
name|address_class
name|class
decl_stmt|;
name|struct
name|psymbol_allocation_list
modifier|*
name|list
decl_stmt|;
name|long
name|val
decl_stmt|;
comment|/* Value as a long */
name|CORE_ADDR
name|coreaddr
decl_stmt|;
comment|/* Value as a CORE_ADDR */
name|enum
name|language
name|language
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
specifier|register
name|struct
name|partial_symbol
modifier|*
name|psym
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|alloca
argument_list|(
name|namelength
operator|+
literal|1
argument_list|)
decl_stmt|;
comment|/* psymbol is static so that there will be no uninitialized gaps in the      structure which might contain random data, causing cache misses in      bcache. */
specifier|static
name|struct
name|partial_symbol
name|psymbol
decl_stmt|;
comment|/* Create local copy of the partial symbol */
name|memcpy
argument_list|(
name|buf
argument_list|,
name|name
argument_list|,
name|namelength
argument_list|)
expr_stmt|;
name|buf
index|[
name|namelength
index|]
operator|=
literal|'\0'
expr_stmt|;
name|SYMBOL_NAME
argument_list|(
operator|&
name|psymbol
argument_list|)
operator|=
name|bcache
argument_list|(
name|buf
argument_list|,
name|namelength
operator|+
literal|1
argument_list|,
operator|&
name|objfile
operator|->
name|psymbol_cache
argument_list|)
expr_stmt|;
comment|/* val and coreaddr are mutually exclusive, one of them *will* be zero */
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
block|{
name|SYMBOL_VALUE
argument_list|(
operator|&
name|psymbol
argument_list|)
operator|=
name|val
expr_stmt|;
block|}
else|else
block|{
name|SYMBOL_VALUE_ADDRESS
argument_list|(
operator|&
name|psymbol
argument_list|)
operator|=
name|coreaddr
expr_stmt|;
block|}
name|SYMBOL_SECTION
argument_list|(
operator|&
name|psymbol
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SYMBOL_LANGUAGE
argument_list|(
operator|&
name|psymbol
argument_list|)
operator|=
name|language
expr_stmt|;
name|PSYMBOL_NAMESPACE
argument_list|(
operator|&
name|psymbol
argument_list|)
operator|=
name|namespace
expr_stmt|;
name|PSYMBOL_CLASS
argument_list|(
operator|&
name|psymbol
argument_list|)
operator|=
name|class
expr_stmt|;
name|SYMBOL_INIT_LANGUAGE_SPECIFIC
argument_list|(
operator|&
name|psymbol
argument_list|,
name|language
argument_list|)
expr_stmt|;
comment|/* Stash the partial symbol away in the cache */
name|psym
operator|=
name|bcache
argument_list|(
operator|&
name|psymbol
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|partial_symbol
argument_list|)
argument_list|,
operator|&
name|objfile
operator|->
name|psymbol_cache
argument_list|)
expr_stmt|;
comment|/* Save pointer to partial symbol in psymtab, growing symtab if needed. */
if|if
condition|(
name|list
operator|->
name|next
operator|>=
name|list
operator|->
name|list
operator|+
name|list
operator|->
name|size
condition|)
block|{
name|extend_psymbol_list
argument_list|(
name|list
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
operator|*
name|list
operator|->
name|next
operator|++
operator|=
name|psym
expr_stmt|;
name|OBJSTAT
argument_list|(
name|objfile
argument_list|,
name|n_psyms
operator|++
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize storage for partial symbols.  */
end_comment

begin_function
name|void
name|init_psymbol_list
parameter_list|(
name|objfile
parameter_list|,
name|total_symbols
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|int
name|total_symbols
decl_stmt|;
block|{
comment|/* Free any previously allocated psymbol lists.  */
if|if
condition|(
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
condition|)
block|{
name|mfree
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
operator|(
name|PTR
operator|)
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|objfile
operator|->
name|static_psymbols
operator|.
name|list
condition|)
block|{
name|mfree
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
operator|(
name|PTR
operator|)
name|objfile
operator|->
name|static_psymbols
operator|.
name|list
argument_list|)
expr_stmt|;
block|}
comment|/* Current best guess is that approximately a twentieth      of the total symbols (in a debugging file) are global or static      oriented symbols */
name|objfile
operator|->
name|global_psymbols
operator|.
name|size
operator|=
name|total_symbols
operator|/
literal|10
expr_stmt|;
name|objfile
operator|->
name|static_psymbols
operator|.
name|size
operator|=
name|total_symbols
operator|/
literal|10
expr_stmt|;
name|objfile
operator|->
name|global_psymbols
operator|.
name|next
operator|=
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
operator|=
operator|(
expr|struct
name|partial_symbol
operator|*
operator|*
operator|)
name|xmmalloc
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
name|objfile
operator|->
name|global_psymbols
operator|.
name|size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|partial_symbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|objfile
operator|->
name|static_psymbols
operator|.
name|next
operator|=
name|objfile
operator|->
name|static_psymbols
operator|.
name|list
operator|=
operator|(
expr|struct
name|partial_symbol
operator|*
operator|*
operator|)
name|xmmalloc
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
name|objfile
operator|->
name|static_psymbols
operator|.
name|size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|partial_symbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|_initialize_symfile
parameter_list|()
block|{
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
name|c
operator|=
name|add_cmd
argument_list|(
literal|"symbol-file"
argument_list|,
name|class_files
argument_list|,
name|symbol_file_command
argument_list|,
literal|"Load symbol table from executable file FILE.\n\ The `file' command can also load symbol tables, as well as setting the file\n\ to execute."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|c
operator|->
name|completer
operator|=
name|filename_completer
expr_stmt|;
name|c
operator|=
name|add_cmd
argument_list|(
literal|"add-symbol-file"
argument_list|,
name|class_files
argument_list|,
name|add_symbol_file_command
argument_list|,
literal|"Usage: add-symbol-file FILE ADDR\n\ Load the symbols from FILE, assuming FILE has been dynamically loaded.\n\ ADDR is the starting address of the file's text."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|c
operator|->
name|completer
operator|=
name|filename_completer
expr_stmt|;
name|c
operator|=
name|add_cmd
argument_list|(
literal|"add-shared-symbol-files"
argument_list|,
name|class_files
argument_list|,
name|add_shared_symbol_files_command
argument_list|,
literal|"Load the symbols from shared objects in the dynamic linker's link map."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|c
operator|=
name|add_alias_cmd
argument_list|(
literal|"assf"
argument_list|,
literal|"add-shared-symbol-files"
argument_list|,
name|class_files
argument_list|,
literal|1
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|c
operator|=
name|add_cmd
argument_list|(
literal|"load"
argument_list|,
name|class_files
argument_list|,
name|load_command
argument_list|,
literal|"Dynamically load FILE into the running program, and record its symbols\n\ for access from GDB."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|c
operator|->
name|completer
operator|=
name|filename_completer
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"symbol-reloading"
argument_list|,
name|class_support
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|symbol_reloading
argument_list|,
literal|"Set dynamic symbol table reloading multiple times in one run."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

