begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Generic symbol file reading for the GNU debugger, GDB.     Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.     Contributed by Cygnus Support, using pieces from other GDB modules.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"source.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"breakpoint.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"complaints.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_comment
comment|/* for write_pc */
end_comment

begin_include
include|#
directive|include
file|"filenames.h"
end_include

begin_comment
comment|/* for DOSish file names */
end_comment

begin_include
include|#
directive|include
file|"gdb-stabs.h"
end_include

begin_include
include|#
directive|include
file|"gdb_obstack.h"
end_include

begin_include
include|#
directive|include
file|"completer.h"
end_include

begin_include
include|#
directive|include
file|"bcache.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_include
include|#
directive|include
file|"readline/readline.h"
end_include

begin_include
include|#
directive|include
file|"gdb_assert.h"
end_include

begin_include
include|#
directive|include
file|"block.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"gdb_stat.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|O_BINARY
end_ifndef

begin_define
define|#
directive|define
name|O_BINARY
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HPUXHPPA
end_ifdef

begin_comment
comment|/* Some HP-UX related globals to clear when a new "main"    symbol file is loaded. HP-specific.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|hp_som_som_object_present
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|hp_cxx_exception_support_initialized
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|RESET_HP_UX_GLOBALS
parameter_list|()
value|do {\                                     hp_som_som_object_present = 0;
comment|/* indicates HP-compiled code */
value|\                                     hp_cxx_exception_support_initialized = 0;
comment|/* must reinitialize exception stuff */
value|\                               } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|int
function_decl|(
modifier|*
name|ui_load_progress_hook
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
name|section
parameter_list|,
name|unsigned
name|long
name|num
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
function_decl|(
modifier|*
name|show_load_progress
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
name|section
parameter_list|,
name|unsigned
name|long
name|section_sent
parameter_list|,
name|unsigned
name|long
name|section_size
parameter_list|,
name|unsigned
name|long
name|total_sent
parameter_list|,
name|unsigned
name|long
name|total_size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
function_decl|(
modifier|*
name|pre_add_symbol_hook
function_decl|)
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
function_decl|(
modifier|*
name|post_add_symbol_hook
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
function_decl|(
modifier|*
name|target_new_objfile_hook
function_decl|)
parameter_list|(
name|struct
name|objfile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|clear_symtab_users_cleanup
parameter_list|(
name|void
modifier|*
name|ignore
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Global variables owned by this file */
end_comment

begin_decl_stmt
name|int
name|readnow_symbol_files
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Read full symbols immediately */
end_comment

begin_comment
comment|/* External variables and functions referenced. */
end_comment

begin_function_decl
specifier|extern
name|void
name|report_transfer_performance
parameter_list|(
name|unsigned
name|long
parameter_list|,
name|time_t
parameter_list|,
name|time_t
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Functions this file defines */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static int simple_read_overlay_region_table (void); static void simple_free_overlay_region_table (void);
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|set_initial_language
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|load_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|symbol_file_add_main_1
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_symbol_file_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_shared_symbol_files_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|reread_separate_symbols
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cashier_psymtab
parameter_list|(
name|struct
name|partial_symtab
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|bfd
modifier|*
name|symfile_bfd_open
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|get_section_index
parameter_list|(
name|struct
name|objfile
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|find_sym_fns
parameter_list|(
name|struct
name|objfile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|decrement_reading_symtab
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|overlay_invalidate_all
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|overlay_is_mapped
parameter_list|(
name|struct
name|obj_section
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|list_overlays_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|map_overlay_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|unmap_overlay_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|overlay_auto_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|overlay_manual_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|overlay_off_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|overlay_load_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|overlay_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|simple_free_overlay_table
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|read_target_long_array
parameter_list|(
name|CORE_ADDR
parameter_list|,
name|unsigned
name|int
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|simple_read_overlay_table
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|simple_overlay_update_1
parameter_list|(
name|struct
name|obj_section
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_filename_language
parameter_list|(
name|char
modifier|*
name|ext
parameter_list|,
name|enum
name|language
name|lang
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_ext_lang_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|info_ext_lang_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|find_separate_debug_file
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|init_filename_language_table
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|_initialize_symfile
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* List of all available sym_fns.  On gdb startup, each object file reader    calls add_symtab_fns() to register information on each format it is    prepared to read. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sym_fns
modifier|*
name|symtab_fns
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag for whether user will be reloading symbols multiple times.    Defaults to ON for VxWorks, otherwise OFF.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SYMBOL_RELOADING_DEFAULT
end_ifdef

begin_decl_stmt
name|int
name|symbol_reloading
init|=
name|SYMBOL_RELOADING_DEFAULT
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|symbol_reloading
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* If non-zero, shared library symbols will be added automatically    when the inferior is created, new libraries are loaded, or when    attaching to the inferior.  This is almost always what users will    want to have happen; but for very large programs, the startup time    will be excessive, and so if this is a problem, the user can clear    this flag and then add the shared library symbols as needed.  Note    that there is a potential for confusion, since if the shared    library symbols are not loaded, commands like "info fun" will *not*    report all the functions that are actually present. */
end_comment

begin_decl_stmt
name|int
name|auto_solib_add
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For systems that support it, a threshold size in megabytes.  If    automatically adding a new library's symbol table to those already    known to the debugger would cause the total shared library symbol    size to exceed this threshhold, then the shlib's symbols are not    added.  The threshold is ignored if the user explicitly asks for a    shlib to be added, such as when using the "sharedlibrary"    command. */
end_comment

begin_decl_stmt
name|int
name|auto_solib_limit
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* This compares two partial symbols by names, using strcmp_iw_ordered    for the comparison.  */
end_comment

begin_function
specifier|static
name|int
name|compare_psymbols
parameter_list|(
specifier|const
name|void
modifier|*
name|s1p
parameter_list|,
specifier|const
name|void
modifier|*
name|s2p
parameter_list|)
block|{
name|struct
name|partial_symbol
modifier|*
specifier|const
modifier|*
name|s1
init|=
name|s1p
decl_stmt|;
name|struct
name|partial_symbol
modifier|*
specifier|const
modifier|*
name|s2
init|=
name|s2p
decl_stmt|;
return|return
name|strcmp_iw_ordered
argument_list|(
name|SYMBOL_NATURAL_NAME
argument_list|(
operator|*
name|s1
argument_list|)
argument_list|,
name|SYMBOL_NATURAL_NAME
argument_list|(
operator|*
name|s2
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|sort_pst_symbols
parameter_list|(
name|struct
name|partial_symtab
modifier|*
name|pst
parameter_list|)
block|{
comment|/* Sort the global list; don't sort the static list */
name|qsort
argument_list|(
name|pst
operator|->
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
operator|+
name|pst
operator|->
name|globals_offset
argument_list|,
name|pst
operator|->
name|n_global_syms
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|partial_symbol
operator|*
argument_list|)
argument_list|,
name|compare_psymbols
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make a null terminated copy of the string at PTR with SIZE characters in    the obstack pointed to by OBSTACKP .  Returns the address of the copy.    Note that the string at PTR does not have to be null terminated, I.E. it    may be part of a larger string and we are only saving a substring. */
end_comment

begin_function
name|char
modifier|*
name|obsavestring
parameter_list|(
specifier|const
name|char
modifier|*
name|ptr
parameter_list|,
name|int
name|size
parameter_list|,
name|struct
name|obstack
modifier|*
name|obstackp
parameter_list|)
block|{
name|char
modifier|*
name|p
init|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
name|obstackp
argument_list|,
name|size
operator|+
literal|1
argument_list|)
decl_stmt|;
comment|/* Open-coded memcpy--saves function call time.  These strings are usually      short.  FIXME: Is this really still true with a compiler that can      inline memcpy? */
block|{
specifier|const
name|char
modifier|*
name|p1
init|=
name|ptr
decl_stmt|;
name|char
modifier|*
name|p2
init|=
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|end
init|=
name|ptr
operator|+
name|size
decl_stmt|;
while|while
condition|(
name|p1
operator|!=
name|end
condition|)
operator|*
name|p2
operator|++
operator|=
operator|*
name|p1
operator|++
expr_stmt|;
block|}
name|p
index|[
name|size
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Concatenate strings S1, S2 and S3; return the new string.  Space is found    in the obstack pointed to by OBSTACKP.  */
end_comment

begin_function
name|char
modifier|*
name|obconcat
parameter_list|(
name|struct
name|obstack
modifier|*
name|obstackp
parameter_list|,
specifier|const
name|char
modifier|*
name|s1
parameter_list|,
specifier|const
name|char
modifier|*
name|s2
parameter_list|,
specifier|const
name|char
modifier|*
name|s3
parameter_list|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|s1
argument_list|)
operator|+
name|strlen
argument_list|(
name|s2
argument_list|)
operator|+
name|strlen
argument_list|(
name|s3
argument_list|)
operator|+
literal|1
decl_stmt|;
name|char
modifier|*
name|val
init|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
name|obstackp
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|val
argument_list|,
name|s1
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|val
argument_list|,
name|s2
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|val
argument_list|,
name|s3
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* True if we are nested inside psymtab_to_symtab. */
end_comment

begin_decl_stmt
name|int
name|currently_reading_symtab
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|decrement_reading_symtab
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
block|{
name|currently_reading_symtab
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get the symbol table that corresponds to a partial_symtab.    This is fast after the first time you do it.  In fact, there    is an even faster macro PSYMTAB_TO_SYMTAB that does the fast    case inline.  */
end_comment

begin_function
name|struct
name|symtab
modifier|*
name|psymtab_to_symtab
parameter_list|(
name|struct
name|partial_symtab
modifier|*
name|pst
parameter_list|)
block|{
comment|/* If it's been looked up before, return it. */
if|if
condition|(
name|pst
operator|->
name|symtab
condition|)
return|return
name|pst
operator|->
name|symtab
return|;
comment|/* If it has not yet been read in, read it.  */
if|if
condition|(
operator|!
name|pst
operator|->
name|readin
condition|)
block|{
name|struct
name|cleanup
modifier|*
name|back_to
init|=
name|make_cleanup
argument_list|(
name|decrement_reading_symtab
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|currently_reading_symtab
operator|++
expr_stmt|;
call|(
modifier|*
name|pst
operator|->
name|read_symtab
call|)
argument_list|(
name|pst
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|back_to
argument_list|)
expr_stmt|;
block|}
return|return
name|pst
operator|->
name|symtab
return|;
block|}
end_function

begin_comment
comment|/* Remember the lowest-addressed loadable section we've seen.      This function is called via bfd_map_over_sections.      In case of equal vmas, the section with the largest size becomes the    lowest-addressed loadable section.     If the vmas and sizes are equal, the last section is considered the    lowest-addressed loadable section.  */
end_comment

begin_function
name|void
name|find_lowest_section
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sect
parameter_list|,
name|void
modifier|*
name|obj
parameter_list|)
block|{
name|asection
modifier|*
modifier|*
name|lowest
init|=
operator|(
name|asection
operator|*
operator|*
operator|)
name|obj
decl_stmt|;
if|if
condition|(
literal|0
operator|==
operator|(
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|sect
argument_list|)
operator|&
name|SEC_LOAD
operator|)
condition|)
return|return;
if|if
condition|(
operator|!
operator|*
name|lowest
condition|)
operator|*
name|lowest
operator|=
name|sect
expr_stmt|;
comment|/* First loadable section */
elseif|else
if|if
condition|(
name|bfd_section_vma
argument_list|(
name|abfd
argument_list|,
operator|*
name|lowest
argument_list|)
operator|>
name|bfd_section_vma
argument_list|(
name|abfd
argument_list|,
name|sect
argument_list|)
condition|)
operator|*
name|lowest
operator|=
name|sect
expr_stmt|;
comment|/* A lower loadable section */
elseif|else
if|if
condition|(
name|bfd_section_vma
argument_list|(
name|abfd
argument_list|,
operator|*
name|lowest
argument_list|)
operator|==
name|bfd_section_vma
argument_list|(
name|abfd
argument_list|,
name|sect
argument_list|)
operator|&&
operator|(
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
operator|(
operator|*
name|lowest
operator|)
argument_list|)
operator|<=
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|sect
argument_list|)
operator|)
condition|)
operator|*
name|lowest
operator|=
name|sect
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create a new section_addr_info, with room for NUM_SECTIONS.  */
end_comment

begin_function
name|struct
name|section_addr_info
modifier|*
name|alloc_section_addr_info
parameter_list|(
name|size_t
name|num_sections
parameter_list|)
block|{
name|struct
name|section_addr_info
modifier|*
name|sap
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|size
operator|=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|section_addr_info
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|other_sections
argument_list|)
operator|*
operator|(
name|num_sections
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|sap
operator|=
operator|(
expr|struct
name|section_addr_info
operator|*
operator|)
name|xmalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|sap
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|sap
operator|->
name|num_sections
operator|=
name|num_sections
expr_stmt|;
return|return
name|sap
return|;
block|}
end_function

begin_comment
comment|/* Build (allocate and populate) a section_addr_info struct from    an existing section table. */
end_comment

begin_function
specifier|extern
name|struct
name|section_addr_info
modifier|*
name|build_section_addr_info_from_section_table
parameter_list|(
specifier|const
name|struct
name|section_table
modifier|*
name|start
parameter_list|,
specifier|const
name|struct
name|section_table
modifier|*
name|end
parameter_list|)
block|{
name|struct
name|section_addr_info
modifier|*
name|sap
decl_stmt|;
specifier|const
name|struct
name|section_table
modifier|*
name|stp
decl_stmt|;
name|int
name|oidx
decl_stmt|;
name|sap
operator|=
name|alloc_section_addr_info
argument_list|(
name|end
operator|-
name|start
argument_list|)
expr_stmt|;
for|for
control|(
name|stp
operator|=
name|start
operator|,
name|oidx
operator|=
literal|0
init|;
name|stp
operator|!=
name|end
condition|;
name|stp
operator|++
control|)
block|{
if|if
condition|(
name|bfd_get_section_flags
argument_list|(
name|stp
operator|->
name|bfd
argument_list|,
name|stp
operator|->
name|the_bfd_section
argument_list|)
operator|&
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator|)
operator|&&
name|oidx
operator|<
name|end
operator|-
name|start
condition|)
block|{
name|sap
operator|->
name|other
index|[
name|oidx
index|]
operator|.
name|addr
operator|=
name|stp
operator|->
name|addr
expr_stmt|;
name|sap
operator|->
name|other
index|[
name|oidx
index|]
operator|.
name|name
operator|=
name|xstrdup
argument_list|(
name|bfd_section_name
argument_list|(
name|stp
operator|->
name|bfd
argument_list|,
name|stp
operator|->
name|the_bfd_section
argument_list|)
argument_list|)
expr_stmt|;
name|sap
operator|->
name|other
index|[
name|oidx
index|]
operator|.
name|sectindex
operator|=
name|stp
operator|->
name|the_bfd_section
operator|->
name|index
expr_stmt|;
name|oidx
operator|++
expr_stmt|;
block|}
block|}
return|return
name|sap
return|;
block|}
end_function

begin_comment
comment|/* Free all memory allocated by build_section_addr_info_from_section_table. */
end_comment

begin_function
specifier|extern
name|void
name|free_section_addr_info
parameter_list|(
name|struct
name|section_addr_info
modifier|*
name|sap
parameter_list|)
block|{
name|int
name|idx
decl_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|sap
operator|->
name|num_sections
condition|;
name|idx
operator|++
control|)
if|if
condition|(
name|sap
operator|->
name|other
index|[
name|idx
index|]
operator|.
name|name
condition|)
name|xfree
argument_list|(
name|sap
operator|->
name|other
index|[
name|idx
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|sap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize OBJFILE's sect_index_* members.  */
end_comment

begin_function
specifier|static
name|void
name|init_objfile_sect_indices
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|asection
modifier|*
name|sect
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sect
operator|=
name|bfd_get_section_by_name
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
literal|".text"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sect
condition|)
name|objfile
operator|->
name|sect_index_text
operator|=
name|sect
operator|->
name|index
expr_stmt|;
name|sect
operator|=
name|bfd_get_section_by_name
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
literal|".data"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sect
condition|)
name|objfile
operator|->
name|sect_index_data
operator|=
name|sect
operator|->
name|index
expr_stmt|;
name|sect
operator|=
name|bfd_get_section_by_name
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
literal|".bss"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sect
condition|)
name|objfile
operator|->
name|sect_index_bss
operator|=
name|sect
operator|->
name|index
expr_stmt|;
name|sect
operator|=
name|bfd_get_section_by_name
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
literal|".rodata"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sect
condition|)
name|objfile
operator|->
name|sect_index_rodata
operator|=
name|sect
operator|->
name|index
expr_stmt|;
comment|/* This is where things get really weird...  We MUST have valid      indices for the various sect_index_* members or gdb will abort.      So if for example, there is no ".text" section, we have to      accomodate that.  Except when explicitly adding symbol files at      some address, section_offsets contains nothing but zeros, so it      doesn't matter which slot in section_offsets the individual      sect_index_* members index into.  So if they are all zero, it is      safe to just point all the currently uninitialized indices to the      first slot. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|objfile
operator|->
name|num_sections
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ANOFFSET
argument_list|(
name|objfile
operator|->
name|section_offsets
argument_list|,
name|i
argument_list|)
operator|!=
literal|0
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
name|objfile
operator|->
name|num_sections
condition|)
block|{
if|if
condition|(
name|objfile
operator|->
name|sect_index_text
operator|==
operator|-
literal|1
condition|)
name|objfile
operator|->
name|sect_index_text
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|objfile
operator|->
name|sect_index_data
operator|==
operator|-
literal|1
condition|)
name|objfile
operator|->
name|sect_index_data
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|objfile
operator|->
name|sect_index_bss
operator|==
operator|-
literal|1
condition|)
name|objfile
operator|->
name|sect_index_bss
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|objfile
operator|->
name|sect_index_rodata
operator|==
operator|-
literal|1
condition|)
name|objfile
operator|->
name|sect_index_rodata
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Parse the user's idea of an offset for dynamic linking, into our idea    of how to represent it for fast symbol reading.  This is the default     version of the sym_fns.sym_offsets function for symbol readers that    don't need to do anything special.  It allocates a section_offsets table    for the objectfile OBJFILE and stuffs ADDR into all of the offsets.  */
end_comment

begin_function
name|void
name|default_symfile_offsets
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|,
name|struct
name|section_addr_info
modifier|*
name|addrs
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|objfile
operator|->
name|num_sections
operator|=
name|bfd_count_sections
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|)
expr_stmt|;
name|objfile
operator|->
name|section_offsets
operator|=
operator|(
expr|struct
name|section_offsets
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
name|SIZEOF_N_SECTION_OFFSETS
argument_list|(
name|objfile
operator|->
name|num_sections
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|objfile
operator|->
name|section_offsets
argument_list|,
literal|0
argument_list|,
name|SIZEOF_N_SECTION_OFFSETS
argument_list|(
name|objfile
operator|->
name|num_sections
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now calculate offsets for section that were specified by the      caller. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|addrs
operator|->
name|num_sections
operator|&&
name|addrs
operator|->
name|other
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|other_sections
modifier|*
name|osp
decl_stmt|;
name|osp
operator|=
operator|&
name|addrs
operator|->
name|other
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|osp
operator|->
name|addr
operator|==
literal|0
condition|)
continue|continue;
comment|/* Record all sections in offsets */
comment|/* The section_offsets in the objfile are here filled in using          the BFD index. */
operator|(
name|objfile
operator|->
name|section_offsets
operator|)
operator|->
name|offsets
index|[
name|osp
operator|->
name|sectindex
index|]
operator|=
name|osp
operator|->
name|addr
expr_stmt|;
block|}
comment|/* Remember the bfd indexes for the .text, .data, .bss and      .rodata sections. */
name|init_objfile_sect_indices
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Process a symbol file, as either the main file or as a dynamically    loaded file.     OBJFILE is where the symbols are to be read from.     ADDRS is the list of section load addresses.  If the user has given    an 'add-symbol-file' command, then this is the list of offsets and    addresses he or she provided as arguments to the command; or, if    we're handling a shared library, these are the actual addresses the    sections are loaded at, according to the inferior's dynamic linker    (as gleaned by GDB's shared library code).  We convert each address    into an offset from the section VMA's as it appears in the object    file, and then call the file's sym_offsets function to convert this    into a format-specific offset table --- a `struct section_offsets'.    If ADDRS is non-zero, OFFSETS must be zero.     OFFSETS is a table of section offsets already in the right    format-specific representation.  NUM_OFFSETS is the number of    elements present in OFFSETS->offsets.  If OFFSETS is non-zero, we    assume this is the proper table the call to sym_offsets described    above would produce.  Instead of calling sym_offsets, we just dump    it right into objfile->section_offsets.  (When we're re-reading    symbols from an objfile, we don't have the original load address    list any more; all we have is the section offset table.)  If    OFFSETS is non-zero, ADDRS must be zero.     MAINLINE is nonzero if this is the main symbol file, or zero if    it's an extra symbol file such as dynamically loaded code.     VERBO is nonzero if the caller has printed a verbose message about    the symbol reading (and complaints can be more terse about it).  */
end_comment

begin_function
name|void
name|syms_from_objfile
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|,
name|struct
name|section_addr_info
modifier|*
name|addrs
parameter_list|,
name|struct
name|section_offsets
modifier|*
name|offsets
parameter_list|,
name|int
name|num_offsets
parameter_list|,
name|int
name|mainline
parameter_list|,
name|int
name|verbo
parameter_list|)
block|{
name|struct
name|section_addr_info
modifier|*
name|local_addr
init|=
name|NULL
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|gdb_assert
argument_list|(
operator|!
operator|(
name|addrs
operator|&&
name|offsets
operator|)
argument_list|)
expr_stmt|;
name|init_entry_point_info
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
name|find_sym_fns
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|objfile
operator|->
name|sf
operator|==
name|NULL
condition|)
return|return;
comment|/* No symbols. */
comment|/* Make sure that partially constructed symbol tables will be cleaned up      if an error occurs during symbol reading.  */
name|old_chain
operator|=
name|make_cleanup_free_objfile
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
comment|/* If ADDRS and OFFSETS are both NULL, put together a dummy address      list.  We now establish the convention that an addr of zero means      no load address was specified. */
if|if
condition|(
operator|!
name|addrs
operator|&&
operator|!
name|offsets
condition|)
block|{
name|local_addr
operator|=
name|alloc_section_addr_info
argument_list|(
name|bfd_count_sections
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|)
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|local_addr
argument_list|)
expr_stmt|;
name|addrs
operator|=
name|local_addr
expr_stmt|;
block|}
comment|/* Now either addrs or offsets is non-zero.  */
if|if
condition|(
name|mainline
condition|)
block|{
comment|/* We will modify the main symbol table, make sure that all its users          will be cleaned up if an error occurs during symbol reading.  */
name|make_cleanup
argument_list|(
name|clear_symtab_users_cleanup
argument_list|,
literal|0
comment|/*ignore*/
argument_list|)
expr_stmt|;
comment|/* Since no error yet, throw away the old symbol table.  */
if|if
condition|(
name|symfile_objfile
operator|!=
name|NULL
condition|)
block|{
name|free_objfile
argument_list|(
name|symfile_objfile
argument_list|)
expr_stmt|;
name|symfile_objfile
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Currently we keep symbols from the add-symbol-file command.          If the user wants to get rid of them, they should do "symbol-file"          without arguments first.  Not sure this is the best behavior          (PR 2207).  */
call|(
modifier|*
name|objfile
operator|->
name|sf
operator|->
name|sym_new_init
call|)
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
block|}
comment|/* Convert addr into an offset rather than an absolute address.      We find the lowest address of a loaded segment in the objfile,      and assume that<addr> is where that got loaded.       We no longer warn if the lowest section is not a text segment (as      happens for the PA64 port.  */
if|if
condition|(
operator|!
name|mainline
operator|&&
name|addrs
operator|&&
name|addrs
operator|->
name|other
index|[
literal|0
index|]
operator|.
name|name
condition|)
block|{
name|asection
modifier|*
name|lower_sect
decl_stmt|;
name|asection
modifier|*
name|sect
decl_stmt|;
name|CORE_ADDR
name|lower_offset
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Find lowest loadable section to be used as starting point for           continguous sections. FIXME!! won't work without call to find 	 .text first, but this assumes text is lowest section. */
name|lower_sect
operator|=
name|bfd_get_section_by_name
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
literal|".text"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lower_sect
operator|==
name|NULL
condition|)
name|bfd_map_over_sections
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|find_lowest_section
argument_list|,
operator|&
name|lower_sect
argument_list|)
expr_stmt|;
if|if
condition|(
name|lower_sect
operator|==
name|NULL
condition|)
name|warning
argument_list|(
literal|"no loadable sections found in added symbol-file %s"
argument_list|,
name|objfile
operator|->
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|bfd_get_section_flags
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|lower_sect
argument_list|)
operator|&
name|SEC_CODE
operator|)
operator|==
literal|0
condition|)
name|warning
argument_list|(
literal|"Lowest section in %s is %s at %s"
argument_list|,
name|objfile
operator|->
name|name
argument_list|,
name|bfd_section_name
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|lower_sect
argument_list|)
argument_list|,
name|paddr
argument_list|(
name|bfd_section_vma
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|lower_sect
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lower_sect
operator|!=
name|NULL
condition|)
name|lower_offset
operator|=
name|bfd_section_vma
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|lower_sect
argument_list|)
expr_stmt|;
else|else
name|lower_offset
operator|=
literal|0
expr_stmt|;
comment|/* Calculate offsets for the loadable sections.  	 FIXME! Sections must be in order of increasing loadable section  	 so that contiguous sections can use the lower-offset!!!            Adjust offsets if the segments are not contiguous.          If the section is contiguous, its offset should be set to  	 the offset of the highest loadable section lower than it  	 (the loadable section directly below it in memory).  	 this_offset = lower_offset = lower_addr - lower_orig_addr */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|addrs
operator|->
name|num_sections
operator|&&
name|addrs
operator|->
name|other
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|addrs
operator|->
name|other
index|[
name|i
index|]
operator|.
name|addr
operator|!=
literal|0
condition|)
block|{
name|sect
operator|=
name|bfd_get_section_by_name
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|addrs
operator|->
name|other
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sect
condition|)
block|{
name|addrs
operator|->
name|other
index|[
name|i
index|]
operator|.
name|addr
operator|-=
name|bfd_section_vma
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|sect
argument_list|)
expr_stmt|;
name|lower_offset
operator|=
name|addrs
operator|->
name|other
index|[
name|i
index|]
operator|.
name|addr
expr_stmt|;
comment|/* This is the index used by BFD. */
name|addrs
operator|->
name|other
index|[
name|i
index|]
operator|.
name|sectindex
operator|=
name|sect
operator|->
name|index
expr_stmt|;
block|}
else|else
block|{
name|warning
argument_list|(
literal|"section %s not found in %s"
argument_list|,
name|addrs
operator|->
name|other
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|objfile
operator|->
name|name
argument_list|)
expr_stmt|;
name|addrs
operator|->
name|other
index|[
name|i
index|]
operator|.
name|addr
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
name|addrs
operator|->
name|other
index|[
name|i
index|]
operator|.
name|addr
operator|=
name|lower_offset
expr_stmt|;
block|}
block|}
comment|/* Initialize symbol reading routines for this objfile, allow complaints to      appear for this new file, and record how verbose to be, then do the      initial symbol reading for this file. */
call|(
modifier|*
name|objfile
operator|->
name|sf
operator|->
name|sym_init
call|)
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
name|clear_complaints
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|1
argument_list|,
name|verbo
argument_list|)
expr_stmt|;
if|if
condition|(
name|addrs
condition|)
call|(
modifier|*
name|objfile
operator|->
name|sf
operator|->
name|sym_offsets
call|)
argument_list|(
name|objfile
argument_list|,
name|addrs
argument_list|)
expr_stmt|;
else|else
block|{
name|size_t
name|size
init|=
name|SIZEOF_N_SECTION_OFFSETS
argument_list|(
name|num_offsets
argument_list|)
decl_stmt|;
comment|/* Just copy in the offset table directly as given to us.  */
name|objfile
operator|->
name|num_sections
operator|=
name|num_offsets
expr_stmt|;
name|objfile
operator|->
name|section_offsets
operator|=
operator|(
operator|(
expr|struct
name|section_offsets
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
name|size
argument_list|)
operator|)
expr_stmt|;
name|memcpy
argument_list|(
name|objfile
operator|->
name|section_offsets
argument_list|,
name|offsets
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|init_objfile_sect_indices
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|DEPRECATED_IBM6000_TARGET
comment|/* This is a SVR4/SunOS specific hack, I think.  In any event, it      screws RS/6000.  sym_offsets should be doing this sort of thing,      because it knows the mapping between bfd sections and      section_offsets.  */
comment|/* This is a hack.  As far as I can tell, section offsets are not      target dependent.  They are all set to addr with a couple of      exceptions.  The exceptions are sysvr4 shared libraries, whose      offsets are kept in solib structures anyway and rs6000 xcoff      which handles shared libraries in a completely unique way.       Section offsets are built similarly, except that they are built      by adding addr in all cases because there is no clear mapping      from section_offsets into actual sections.  Note that solib.c      has a different algorithm for finding section offsets.       These should probably all be collapsed into some target      independent form of shared library support.  FIXME.  */
if|if
condition|(
name|addrs
condition|)
block|{
name|struct
name|obj_section
modifier|*
name|s
decl_stmt|;
comment|/* Map section offsets in "addr" back to the object's   	   sections by comparing the section names with bfd's   	   section names.  Then adjust the section address by  	   the offset. */
comment|/* for gdb/13815 */
name|ALL_OBJFILE_OSECTIONS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
block|{
name|CORE_ADDR
name|s_addr
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|!
name|s_addr
operator|&&
name|i
operator|<
name|addrs
operator|->
name|num_sections
operator|&&
name|addrs
operator|->
name|other
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|bfd_section_name
argument_list|(
name|s
operator|->
name|objfile
operator|->
name|obfd
argument_list|,
name|s
operator|->
name|the_bfd_section
argument_list|)
argument_list|,
name|addrs
operator|->
name|other
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
name|s_addr
operator|=
name|addrs
operator|->
name|other
index|[
name|i
index|]
operator|.
name|addr
expr_stmt|;
comment|/* end added for gdb/13815 */
name|s
operator|->
name|addr
operator|-=
name|s
operator|->
name|offset
expr_stmt|;
name|s
operator|->
name|addr
operator|+=
name|s_addr
expr_stmt|;
name|s
operator|->
name|endaddr
operator|-=
name|s
operator|->
name|offset
expr_stmt|;
name|s
operator|->
name|endaddr
operator|+=
name|s_addr
expr_stmt|;
name|s
operator|->
name|offset
operator|+=
name|s_addr
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* not DEPRECATED_IBM6000_TARGET */
call|(
modifier|*
name|objfile
operator|->
name|sf
operator|->
name|sym_read
call|)
argument_list|(
name|objfile
argument_list|,
name|mainline
argument_list|)
expr_stmt|;
comment|/* Don't allow char * to have a typename (else would get caddr_t).      Ditto void *.  FIXME: Check whether this is now done by all the      symbol readers themselves (many of them now do), and if so remove      it from here.  */
name|TYPE_NAME
argument_list|(
name|lookup_pointer_type
argument_list|(
name|builtin_type_char
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|lookup_pointer_type
argument_list|(
name|builtin_type_void
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Mark the objfile has having had initial symbol read attempted.  Note      that this does not mean we found any symbols... */
name|objfile
operator|->
name|flags
operator||=
name|OBJF_SYMS
expr_stmt|;
comment|/* Discard cleanups as symbol reading was successful.  */
name|discard_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Perform required actions after either reading in the initial    symbols for a new objfile, or mapping in the symbols from a reusable    objfile. */
end_comment

begin_function
name|void
name|new_symfile_objfile
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|,
name|int
name|mainline
parameter_list|,
name|int
name|verbo
parameter_list|)
block|{
comment|/* If this is the main symbol file we have to clean up all users of the      old main symbol file. Otherwise it is sufficient to fixup all the      breakpoints that may have been redefined by this symbol file.  */
if|if
condition|(
name|mainline
condition|)
block|{
comment|/* OK, make it the "real" symbol file.  */
name|symfile_objfile
operator|=
name|objfile
expr_stmt|;
name|clear_symtab_users
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|breakpoint_re_set
argument_list|()
expr_stmt|;
block|}
comment|/* We're done reading the symbol file; finish off complaints.  */
name|clear_complaints
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|0
argument_list|,
name|verbo
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Process a symbol file, as either the main file or as a dynamically    loaded file.     NAME is the file name (which will be tilde-expanded and made    absolute herein) (but we don't free or modify NAME itself).     FROM_TTY says how verbose to be.     MAINLINE specifies whether this is the main symbol file, or whether    it's an extra symbol file such as dynamically loaded code.     ADDRS, OFFSETS, and NUM_OFFSETS are as described for    syms_from_objfile, above.  ADDRS is ignored when MAINLINE is    non-zero.     Upon success, returns a pointer to the objfile that was added.    Upon failure, jumps back to command level (never returns). */
end_comment

begin_function
specifier|static
name|struct
name|objfile
modifier|*
name|symbol_file_add_with_addrs_or_offsets
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|from_tty
parameter_list|,
name|struct
name|section_addr_info
modifier|*
name|addrs
parameter_list|,
name|struct
name|section_offsets
modifier|*
name|offsets
parameter_list|,
name|int
name|num_offsets
parameter_list|,
name|int
name|mainline
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|partial_symtab
modifier|*
name|psymtab
decl_stmt|;
name|char
modifier|*
name|debugfile
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|section_addr_info
modifier|*
name|orig_addrs
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|my_cleanups
decl_stmt|;
comment|/* Open a bfd for the file, and give user a chance to burp if we'd be      interactively wiping out any existing symbols.  */
name|abfd
operator|=
name|symfile_bfd_open
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|have_full_symbols
argument_list|()
operator|||
name|have_partial_symbols
argument_list|()
operator|)
operator|&&
name|mainline
operator|&&
name|from_tty
operator|&&
operator|!
name|query
argument_list|(
literal|"Load new symbol table from \"%s\"? "
argument_list|,
name|name
argument_list|)
condition|)
name|error
argument_list|(
literal|"Not confirmed."
argument_list|)
expr_stmt|;
name|objfile
operator|=
name|allocate_objfile
argument_list|(
name|abfd
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|orig_addrs
operator|=
name|alloc_section_addr_info
argument_list|(
name|bfd_count_sections
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|my_cleanups
operator|=
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|orig_addrs
argument_list|)
expr_stmt|;
if|if
condition|(
name|addrs
condition|)
block|{
name|int
name|i
decl_stmt|;
name|orig_addrs
operator|->
name|num_sections
operator|=
name|addrs
operator|->
name|num_sections
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|addrs
operator|->
name|num_sections
condition|;
name|i
operator|++
control|)
name|orig_addrs
operator|->
name|other
index|[
name|i
index|]
operator|=
name|addrs
operator|->
name|other
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/* We either created a new mapped symbol table, mapped an existing      symbol table file which has not had initial symbol reading      performed, or need to read an unmapped symbol table. */
if|if
condition|(
name|from_tty
operator|||
name|info_verbose
condition|)
block|{
if|if
condition|(
name|pre_add_symbol_hook
condition|)
name|pre_add_symbol_hook
argument_list|(
name|name
argument_list|)
expr_stmt|;
else|else
block|{
name|printf_unfiltered
argument_list|(
literal|"Reading symbols from %s..."
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
block|}
name|syms_from_objfile
argument_list|(
name|objfile
argument_list|,
name|addrs
argument_list|,
name|offsets
argument_list|,
name|num_offsets
argument_list|,
name|mainline
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
comment|/* We now have at least a partial symbol table.  Check to see if the      user requested that all symbols be read on initial access via either      the gdb startup command line or on a per symbol file basis.  Expand      all partial symbol tables for this objfile if so. */
if|if
condition|(
operator|(
name|flags
operator|&
name|OBJF_READNOW
operator|)
operator|||
name|readnow_symbol_files
condition|)
block|{
if|if
condition|(
name|from_tty
operator|||
name|info_verbose
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"expanding to full symbols..."
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|psymtab
operator|=
name|objfile
operator|->
name|psymtabs
init|;
name|psymtab
operator|!=
name|NULL
condition|;
name|psymtab
operator|=
name|psymtab
operator|->
name|next
control|)
block|{
name|psymtab_to_symtab
argument_list|(
name|psymtab
argument_list|)
expr_stmt|;
block|}
block|}
name|debugfile
operator|=
name|find_separate_debug_file
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|debugfile
condition|)
block|{
if|if
condition|(
name|addrs
operator|!=
name|NULL
condition|)
block|{
name|objfile
operator|->
name|separate_debug_objfile
operator|=
name|symbol_file_add
argument_list|(
name|debugfile
argument_list|,
name|from_tty
argument_list|,
name|orig_addrs
argument_list|,
literal|0
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|objfile
operator|->
name|separate_debug_objfile
operator|=
name|symbol_file_add
argument_list|(
name|debugfile
argument_list|,
name|from_tty
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
name|objfile
operator|->
name|separate_debug_objfile
operator|->
name|separate_debug_objfile_backlink
operator|=
name|objfile
expr_stmt|;
comment|/* Put the separate debug object before the normal one, this is so that          usage of the ALL_OBJFILES_SAFE macro will stay safe. */
name|put_objfile_before
argument_list|(
name|objfile
operator|->
name|separate_debug_objfile
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|debugfile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|have_partial_symbols
argument_list|()
operator|&&
operator|!
name|have_full_symbols
argument_list|()
condition|)
block|{
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"(no debugging symbols found)..."
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|from_tty
operator|||
name|info_verbose
condition|)
block|{
if|if
condition|(
name|post_add_symbol_hook
condition|)
name|post_add_symbol_hook
argument_list|()
expr_stmt|;
else|else
block|{
name|printf_unfiltered
argument_list|(
literal|"done.\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* We print some messages regardless of whether 'from_tty ||      info_verbose' is true, so make sure they go out at the right      time.  */
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|my_cleanups
argument_list|)
expr_stmt|;
if|if
condition|(
name|objfile
operator|->
name|sf
operator|==
name|NULL
condition|)
return|return
name|objfile
return|;
comment|/* No symbols. */
name|new_symfile_objfile
argument_list|(
name|objfile
argument_list|,
name|mainline
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_new_objfile_hook
condition|)
name|target_new_objfile_hook
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
return|return
operator|(
name|objfile
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Process a symbol file, as either the main file or as a dynamically    loaded file.  See symbol_file_add_with_addrs_or_offsets's comments    for details.  */
end_comment

begin_function
name|struct
name|objfile
modifier|*
name|symbol_file_add
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|from_tty
parameter_list|,
name|struct
name|section_addr_info
modifier|*
name|addrs
parameter_list|,
name|int
name|mainline
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
return|return
name|symbol_file_add_with_addrs_or_offsets
argument_list|(
name|name
argument_list|,
name|from_tty
argument_list|,
name|addrs
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|mainline
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Call symbol_file_add() with default values and update whatever is    affected by the loading of a new main().    Used when the file is supplied in the gdb command line    and by some targets with special loading requirements.    The auxiliary function, symbol_file_add_main_1(), has the flags    argument for the switches that can only be specified in the symbol_file    command itself.  */
end_comment

begin_function
name|void
name|symbol_file_add_main
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|symbol_file_add_main_1
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|symbol_file_add_main_1
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|symbol_file_add
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
name|flags
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HPUXHPPA
name|RESET_HP_UX_GLOBALS
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* Getting new symbols may change our opinion about      what is frameless.  */
name|reinit_frame_cache
argument_list|()
expr_stmt|;
name|set_initial_language
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|symbol_file_clear
parameter_list|(
name|int
name|from_tty
parameter_list|)
block|{
if|if
condition|(
operator|(
name|have_full_symbols
argument_list|()
operator|||
name|have_partial_symbols
argument_list|()
operator|)
operator|&&
name|from_tty
operator|&&
operator|!
name|query
argument_list|(
literal|"Discard symbol table from `%s'? "
argument_list|,
name|symfile_objfile
operator|->
name|name
argument_list|)
condition|)
name|error
argument_list|(
literal|"Not confirmed."
argument_list|)
expr_stmt|;
name|free_all_objfiles
argument_list|()
expr_stmt|;
comment|/* solib descriptors may have handles to objfiles.  Since their        storage has just been released, we'd better wipe the solib        descriptors as well.      */
if|#
directive|if
name|defined
argument_list|(
name|SOLIB_RESTART
argument_list|)
name|SOLIB_RESTART
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|symfile_objfile
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
name|printf_unfiltered
argument_list|(
literal|"No symbol file now.\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HPUXHPPA
name|RESET_HP_UX_GLOBALS
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|get_debug_link_info
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|,
name|unsigned
name|long
modifier|*
name|crc32_out
parameter_list|)
block|{
name|asection
modifier|*
name|sect
decl_stmt|;
name|bfd_size_type
name|debuglink_size
decl_stmt|;
name|unsigned
name|long
name|crc32
decl_stmt|;
name|char
modifier|*
name|contents
decl_stmt|;
name|int
name|crc_offset
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|sect
operator|=
name|bfd_get_section_by_name
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
literal|".gnu_debuglink"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sect
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|debuglink_size
operator|=
name|bfd_section_size
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|sect
argument_list|)
expr_stmt|;
name|contents
operator|=
name|xmalloc
argument_list|(
name|debuglink_size
argument_list|)
expr_stmt|;
name|bfd_get_section_contents
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|sect
argument_list|,
name|contents
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|debuglink_size
argument_list|)
expr_stmt|;
comment|/* Crc value is stored after the filename, aligned up to 4 bytes. */
name|crc_offset
operator|=
name|strlen
argument_list|(
name|contents
argument_list|)
operator|+
literal|1
expr_stmt|;
name|crc_offset
operator|=
operator|(
name|crc_offset
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
expr_stmt|;
name|crc32
operator|=
name|bfd_get_32
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
operator|(
name|contents
operator|+
name|crc_offset
operator|)
argument_list|)
expr_stmt|;
operator|*
name|crc32_out
operator|=
name|crc32
expr_stmt|;
return|return
name|contents
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|separate_debug_file_exists
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|unsigned
name|long
name|crc
parameter_list|)
block|{
name|unsigned
name|long
name|file_crc
init|=
literal|0
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|char
name|buffer
index|[
literal|8
operator|*
literal|1024
index|]
decl_stmt|;
name|int
name|count
decl_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|name
argument_list|,
name|O_RDONLY
operator||
name|O_BINARY
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
return|return
literal|0
return|;
while|while
condition|(
operator|(
name|count
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|)
operator|)
operator|>
literal|0
condition|)
name|file_crc
operator|=
name|gnu_debuglink_crc32
argument_list|(
name|file_crc
argument_list|,
name|buffer
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|crc
operator|==
name|file_crc
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
modifier|*
name|debug_file_directory
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|DEBUG_SUBDIRECTORY
argument_list|)
end_if

begin_define
define|#
directive|define
name|DEBUG_SUBDIRECTORY
value|".debug"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|char
modifier|*
name|find_separate_debug_file
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|asection
modifier|*
name|sect
decl_stmt|;
name|char
modifier|*
name|basename
decl_stmt|;
name|char
modifier|*
name|dir
decl_stmt|;
name|char
modifier|*
name|debugfile
decl_stmt|;
name|char
modifier|*
name|name_copy
decl_stmt|;
name|bfd_size_type
name|debuglink_size
decl_stmt|;
name|unsigned
name|long
name|crc32
decl_stmt|;
name|int
name|i
decl_stmt|;
name|basename
operator|=
name|get_debug_link_info
argument_list|(
name|objfile
argument_list|,
operator|&
name|crc32
argument_list|)
expr_stmt|;
if|if
condition|(
name|basename
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|dir
operator|=
name|xstrdup
argument_list|(
name|objfile
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* Strip off the final filename part, leaving the directory name,      followed by a slash.  Objfile names should always be absolute and      tilde-expanded, so there should always be a slash in there      somewhere.  */
for|for
control|(
name|i
operator|=
name|strlen
argument_list|(
name|dir
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|IS_DIR_SEPARATOR
argument_list|(
name|dir
index|[
name|i
index|]
argument_list|)
condition|)
break|break;
block|}
name|gdb_assert
argument_list|(
name|i
operator|>=
literal|0
operator|&&
name|IS_DIR_SEPARATOR
argument_list|(
name|dir
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|dir
index|[
name|i
operator|+
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|debugfile
operator|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|debug_file_directory
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|dir
argument_list|)
operator|+
name|strlen
argument_list|(
name|DEBUG_SUBDIRECTORY
argument_list|)
operator|+
name|strlen
argument_list|(
literal|"/"
argument_list|)
operator|+
name|strlen
argument_list|(
name|basename
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* First try in the same directory as the original file.  */
name|strcpy
argument_list|(
name|debugfile
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|debugfile
argument_list|,
name|basename
argument_list|)
expr_stmt|;
if|if
condition|(
name|separate_debug_file_exists
argument_list|(
name|debugfile
argument_list|,
name|crc32
argument_list|)
condition|)
block|{
name|xfree
argument_list|(
name|basename
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|dir
argument_list|)
expr_stmt|;
return|return
name|xstrdup
argument_list|(
name|debugfile
argument_list|)
return|;
block|}
comment|/* Then try in the subdirectory named DEBUG_SUBDIRECTORY.  */
name|strcpy
argument_list|(
name|debugfile
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|debugfile
argument_list|,
name|DEBUG_SUBDIRECTORY
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|debugfile
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|debugfile
argument_list|,
name|basename
argument_list|)
expr_stmt|;
if|if
condition|(
name|separate_debug_file_exists
argument_list|(
name|debugfile
argument_list|,
name|crc32
argument_list|)
condition|)
block|{
name|xfree
argument_list|(
name|basename
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|dir
argument_list|)
expr_stmt|;
return|return
name|xstrdup
argument_list|(
name|debugfile
argument_list|)
return|;
block|}
comment|/* Then try in the global debugfile directory.  */
name|strcpy
argument_list|(
name|debugfile
argument_list|,
name|debug_file_directory
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|debugfile
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|debugfile
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|debugfile
argument_list|,
name|basename
argument_list|)
expr_stmt|;
if|if
condition|(
name|separate_debug_file_exists
argument_list|(
name|debugfile
argument_list|,
name|crc32
argument_list|)
condition|)
block|{
name|xfree
argument_list|(
name|basename
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|dir
argument_list|)
expr_stmt|;
return|return
name|xstrdup
argument_list|(
name|debugfile
argument_list|)
return|;
block|}
name|xfree
argument_list|(
name|basename
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|dir
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* This is the symbol-file command.  Read the file, analyze its    symbols, and add a struct symtab to a symtab list.  The syntax of    the command is rather bizarre--(1) buildargv implements various    quoting conventions which are undocumented and have little or    nothing in common with the way things are quoted (or not quoted)    elsewhere in GDB, (2) options are used, which are not generally    used in GDB (perhaps "set mapped on", "set readnow on" would be    better), (3) the order of options matters, which is contrary to GNU    conventions (because it is confusing and inconvenient).  */
end_comment

begin_comment
comment|/* Note: ezannoni 2000-04-17. This function used to have support for    rombug (see remote-os9k.c). It consisted of a call to target_link()    (target.c) to get the address of the text segment from the target,    and pass that to symbol_file_add(). This is no longer supported. */
end_comment

begin_function
name|void
name|symbol_file_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|cleanups
decl_stmt|;
name|int
name|flags
init|=
name|OBJF_USERLOADED
decl_stmt|;
name|dont_repeat
argument_list|()
expr_stmt|;
if|if
condition|(
name|args
operator|==
name|NULL
condition|)
block|{
name|symbol_file_clear
argument_list|(
name|from_tty
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|argv
operator|=
name|buildargv
argument_list|(
name|args
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|nomem
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|cleanups
operator|=
name|make_cleanup_freeargv
argument_list|(
name|argv
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|argv
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-readnow"
argument_list|)
operator|==
literal|0
condition|)
name|flags
operator||=
name|OBJF_READNOW
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
operator|*
name|argv
operator|==
literal|'-'
condition|)
name|error
argument_list|(
literal|"unknown option `%s'"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
else|else
block|{
name|name
operator|=
operator|*
name|argv
expr_stmt|;
name|symbol_file_add_main_1
argument_list|(
name|name
argument_list|,
name|from_tty
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
name|argv
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"no symbol file name was specified"
argument_list|)
expr_stmt|;
block|}
name|do_cleanups
argument_list|(
name|cleanups
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Set the initial language.     A better solution would be to record the language in the psymtab when reading    partial symbols, and then use it (if known) to set the language.  This would    be a win for formats that encode the language in an easily discoverable place,    such as DWARF.  For stabs, we can jump through hoops looking for specially    named symbols or try to intuit the language from the specific type of stabs    we find, but we can't do that until later when we read in full symbols.    FIXME.  */
end_comment

begin_function
specifier|static
name|void
name|set_initial_language
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
name|enum
name|language
name|lang
init|=
name|language_unknown
decl_stmt|;
name|pst
operator|=
name|find_main_psymtab
argument_list|()
expr_stmt|;
if|if
condition|(
name|pst
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|pst
operator|->
name|filename
operator|!=
name|NULL
condition|)
block|{
name|lang
operator|=
name|deduce_language_from_filename
argument_list|(
name|pst
operator|->
name|filename
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lang
operator|==
name|language_unknown
condition|)
block|{
comment|/* Make C the default language */
name|lang
operator|=
name|language_c
expr_stmt|;
block|}
name|set_language
argument_list|(
name|lang
argument_list|)
expr_stmt|;
name|expected_language
operator|=
name|current_language
expr_stmt|;
comment|/* Don't warn the user */
block|}
block|}
end_function

begin_comment
comment|/* Open file specified by NAME and hand it off to BFD for preliminary    analysis.  Result is a newly initialized bfd *, which includes a newly    malloc'd` copy of NAME (tilde-expanded and made absolute).    In case of trouble, error() is called.  */
end_comment

begin_function
name|bfd
modifier|*
name|symfile_bfd_open
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|bfd
modifier|*
name|sym_bfd
decl_stmt|;
name|int
name|desc
decl_stmt|;
name|char
modifier|*
name|absolute_name
decl_stmt|;
name|name
operator|=
name|tilde_expand
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* Returns 1st new malloc'd copy */
comment|/* Look down path for it, allocate 2nd new malloc'd copy.  */
name|desc
operator|=
name|openp
argument_list|(
name|getenv
argument_list|(
literal|"PATH"
argument_list|)
argument_list|,
literal|1
argument_list|,
name|name
argument_list|,
name|O_RDONLY
operator||
name|O_BINARY
argument_list|,
literal|0
argument_list|,
operator|&
name|absolute_name
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__GO32__
argument_list|)
operator|||
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
if|if
condition|(
name|desc
operator|<
literal|0
condition|)
block|{
name|char
modifier|*
name|exename
init|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|5
argument_list|)
decl_stmt|;
name|strcat
argument_list|(
name|strcpy
argument_list|(
name|exename
argument_list|,
name|name
argument_list|)
argument_list|,
literal|".exe"
argument_list|)
expr_stmt|;
name|desc
operator|=
name|openp
argument_list|(
name|getenv
argument_list|(
literal|"PATH"
argument_list|)
argument_list|,
literal|1
argument_list|,
name|exename
argument_list|,
name|O_RDONLY
operator||
name|O_BINARY
argument_list|,
literal|0
argument_list|,
operator|&
name|absolute_name
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|desc
operator|<
literal|0
condition|)
block|{
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|perror_with_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
name|xfree
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* Free 1st new malloc'd copy */
name|name
operator|=
name|absolute_name
expr_stmt|;
comment|/* Keep 2nd malloc'd copy in bfd */
comment|/* It'll be freed in free_objfile(). */
name|sym_bfd
operator|=
name|bfd_fdopenr
argument_list|(
name|name
argument_list|,
name|gnutarget
argument_list|,
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sym_bfd
condition|)
block|{
name|close
argument_list|(
name|desc
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"\"%s\": can't open to read symbols: %s."
argument_list|,
name|name
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|bfd_set_cacheable
argument_list|(
name|sym_bfd
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_check_format
argument_list|(
name|sym_bfd
argument_list|,
name|bfd_object
argument_list|)
condition|)
block|{
comment|/* FIXME: should be checking for errors from bfd_close (for one thing,          on error it does not free all the storage associated with the          bfd).  */
name|bfd_close
argument_list|(
name|sym_bfd
argument_list|)
expr_stmt|;
comment|/* This also closes desc */
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"\"%s\": can't read symbols: %s."
argument_list|,
name|name
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|sym_bfd
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the section index for the given section name. Return -1 if    the section was not found. */
end_comment

begin_function
name|int
name|get_section_index
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|,
name|char
modifier|*
name|section_name
parameter_list|)
block|{
name|asection
modifier|*
name|sect
init|=
name|bfd_get_section_by_name
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|section_name
argument_list|)
decl_stmt|;
if|if
condition|(
name|sect
condition|)
return|return
name|sect
operator|->
name|index
return|;
else|else
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Link a new symtab_fns into the global symtab_fns list.  Called on gdb    startup by the _initialize routine in each object file format reader,    to register information about each format the the reader is prepared    to handle. */
end_comment

begin_function
name|void
name|add_symtab_fns
parameter_list|(
name|struct
name|sym_fns
modifier|*
name|sf
parameter_list|)
block|{
name|sf
operator|->
name|next
operator|=
name|symtab_fns
expr_stmt|;
name|symtab_fns
operator|=
name|sf
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize to read symbols from the symbol file sym_bfd.  It either    returns or calls error().  The result is an initialized struct sym_fns    in the objfile structure, that contains cached information about the    symbol file.  */
end_comment

begin_function
specifier|static
name|void
name|find_sym_fns
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|struct
name|sym_fns
modifier|*
name|sf
decl_stmt|;
name|enum
name|bfd_flavour
name|our_flavour
init|=
name|bfd_get_flavour
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|)
decl_stmt|;
name|char
modifier|*
name|our_target
init|=
name|bfd_get_target
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|)
decl_stmt|;
if|if
condition|(
name|our_flavour
operator|==
name|bfd_target_srec_flavour
operator|||
name|our_flavour
operator|==
name|bfd_target_ihex_flavour
operator|||
name|our_flavour
operator|==
name|bfd_target_tekhex_flavour
condition|)
return|return;
comment|/* No symbols. */
for|for
control|(
name|sf
operator|=
name|symtab_fns
init|;
name|sf
operator|!=
name|NULL
condition|;
name|sf
operator|=
name|sf
operator|->
name|next
control|)
block|{
if|if
condition|(
name|our_flavour
operator|==
name|sf
operator|->
name|sym_flavour
condition|)
block|{
name|objfile
operator|->
name|sf
operator|=
name|sf
expr_stmt|;
return|return;
block|}
block|}
name|error
argument_list|(
literal|"I'm sorry, Dave, I can't do that.  Symbol format `%s' unknown."
argument_list|,
name|bfd_get_target
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This function runs the load command of our current target.  */
end_comment

begin_function
specifier|static
name|void
name|load_command
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
if|if
condition|(
name|arg
operator|==
name|NULL
condition|)
name|arg
operator|=
name|get_exec_file
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|target_load
argument_list|(
name|arg
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
comment|/* After re-loading the executable, we don't really know which      overlays are mapped any more.  */
name|overlay_cache_invalid
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This version of "load" should be usable for any target.  Currently    it is just used for remote targets, not inftarg.c or core files,    on the theory that only in that case is it useful.     Avoiding xmodem and the like seems like a win (a) because we don't have    to worry about finding it, and (b) On VMS, fork() is very slow and so    we don't want to run a subprocess.  On the other hand, I'm not sure how    performance compares.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|download_write_size
init|=
literal|512
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|validate_download
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Callback service function for generic_load (bfd_map_over_sections).  */
end_comment

begin_function
specifier|static
name|void
name|add_section_size_callback
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|asec
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|bfd_size_type
modifier|*
name|sum
init|=
name|data
decl_stmt|;
operator|*
name|sum
operator|+=
name|bfd_get_section_size_before_reloc
argument_list|(
name|asec
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Opaque data for load_section_callback.  */
end_comment

begin_struct
struct|struct
name|load_section_data
block|{
name|unsigned
name|long
name|load_offset
decl_stmt|;
name|unsigned
name|long
name|write_count
decl_stmt|;
name|unsigned
name|long
name|data_count
decl_stmt|;
name|bfd_size_type
name|total_size
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Callback service function for generic_load (bfd_map_over_sections).  */
end_comment

begin_function
specifier|static
name|void
name|load_section_callback
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|asec
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|load_section_data
modifier|*
name|args
init|=
name|data
decl_stmt|;
if|if
condition|(
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|asec
argument_list|)
operator|&
name|SEC_LOAD
condition|)
block|{
name|bfd_size_type
name|size
init|=
name|bfd_get_section_size_before_reloc
argument_list|(
name|asec
argument_list|)
decl_stmt|;
if|if
condition|(
name|size
operator|>
literal|0
condition|)
block|{
name|char
modifier|*
name|buffer
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|CORE_ADDR
name|lma
init|=
name|bfd_section_lma
argument_list|(
name|abfd
argument_list|,
name|asec
argument_list|)
operator|+
name|args
operator|->
name|load_offset
decl_stmt|;
name|bfd_size_type
name|block_size
decl_stmt|;
name|int
name|err
decl_stmt|;
specifier|const
name|char
modifier|*
name|sect_name
init|=
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|asec
argument_list|)
decl_stmt|;
name|bfd_size_type
name|sent
decl_stmt|;
if|if
condition|(
name|download_write_size
operator|>
literal|0
operator|&&
name|size
operator|>
name|download_write_size
condition|)
name|block_size
operator|=
name|download_write_size
expr_stmt|;
else|else
name|block_size
operator|=
name|size
expr_stmt|;
name|buffer
operator|=
name|xmalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
comment|/* Is this really necessary?  I guess it gives the user something 	     to look at during a long download.  */
name|ui_out_message
argument_list|(
name|uiout
argument_list|,
literal|0
argument_list|,
literal|"Loading section %s, size 0x%s lma 0x%s\n"
argument_list|,
name|sect_name
argument_list|,
name|paddr_nz
argument_list|(
name|size
argument_list|)
argument_list|,
name|paddr_nz
argument_list|(
name|lma
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|asec
argument_list|,
name|buffer
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|sent
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|int
name|len
decl_stmt|;
name|bfd_size_type
name|this_transfer
init|=
name|size
operator|-
name|sent
decl_stmt|;
if|if
condition|(
name|this_transfer
operator|>=
name|block_size
condition|)
name|this_transfer
operator|=
name|block_size
expr_stmt|;
name|len
operator|=
name|target_write_memory_partial
argument_list|(
name|lma
argument_list|,
name|buffer
argument_list|,
name|this_transfer
argument_list|,
operator|&
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
break|break;
if|if
condition|(
name|validate_download
condition|)
block|{
comment|/* Broken memories and broken monitors manifest 		     themselves here when bring new computers to 		     life.  This doubles already slow downloads.  */
comment|/* NOTE: cagney/1999-10-18: A more efficient 		     implementation might add a verify_memory() 		     method to the target vector and then use 		     that.  remote.c could implement that method 		     using the ``qCRC'' packet.  */
name|char
modifier|*
name|check
init|=
name|xmalloc
argument_list|(
name|len
argument_list|)
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|verify_cleanups
init|=
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|check
argument_list|)
decl_stmt|;
if|if
condition|(
name|target_read_memory
argument_list|(
name|lma
argument_list|,
name|check
argument_list|,
name|len
argument_list|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|"Download verify read failed at 0x%s"
argument_list|,
name|paddr
argument_list|(
name|lma
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|buffer
argument_list|,
name|check
argument_list|,
name|len
argument_list|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|"Download verify compare failed at 0x%s"
argument_list|,
name|paddr
argument_list|(
name|lma
argument_list|)
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|verify_cleanups
argument_list|)
expr_stmt|;
block|}
name|args
operator|->
name|data_count
operator|+=
name|len
expr_stmt|;
name|lma
operator|+=
name|len
expr_stmt|;
name|buffer
operator|+=
name|len
expr_stmt|;
name|args
operator|->
name|write_count
operator|+=
literal|1
expr_stmt|;
name|sent
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|quit_flag
operator|||
operator|(
name|ui_load_progress_hook
operator|!=
name|NULL
operator|&&
name|ui_load_progress_hook
argument_list|(
name|sect_name
argument_list|,
name|sent
argument_list|)
operator|)
condition|)
name|error
argument_list|(
literal|"Canceled the download"
argument_list|)
expr_stmt|;
if|if
condition|(
name|show_load_progress
operator|!=
name|NULL
condition|)
name|show_load_progress
argument_list|(
name|sect_name
argument_list|,
name|sent
argument_list|,
name|size
argument_list|,
name|args
operator|->
name|data_count
argument_list|,
name|args
operator|->
name|total_size
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|sent
operator|<
name|size
condition|)
do|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|"Memory access error while loading section %s."
argument_list|,
name|sect_name
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|generic_load
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd
modifier|*
name|loadfile_bfd
decl_stmt|;
name|time_t
name|start_time
decl_stmt|,
name|end_time
decl_stmt|;
comment|/* Start and end times of download */
name|char
modifier|*
name|filename
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_cleanups
decl_stmt|;
name|char
modifier|*
name|offptr
decl_stmt|;
name|struct
name|load_section_data
name|cbdata
decl_stmt|;
name|CORE_ADDR
name|entry
decl_stmt|;
name|cbdata
operator|.
name|load_offset
operator|=
literal|0
expr_stmt|;
comment|/* Offset to add to vma for each section. */
name|cbdata
operator|.
name|write_count
operator|=
literal|0
expr_stmt|;
comment|/* Number of writes needed. */
name|cbdata
operator|.
name|data_count
operator|=
literal|0
expr_stmt|;
comment|/* Number of bytes written to target memory. */
name|cbdata
operator|.
name|total_size
operator|=
literal|0
expr_stmt|;
comment|/* Total size of all bfd sectors. */
comment|/* Parse the input argument - the user can specify a load offset as      a second argument. */
name|filename
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|args
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|old_cleanups
operator|=
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|filename
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|offptr
operator|=
name|strchr
argument_list|(
name|filename
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|offptr
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|endptr
decl_stmt|;
name|cbdata
operator|.
name|load_offset
operator|=
name|strtoul
argument_list|(
name|offptr
argument_list|,
operator|&
name|endptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|offptr
operator|==
name|endptr
condition|)
name|error
argument_list|(
literal|"Invalid download offset:%s\n"
argument_list|,
name|offptr
argument_list|)
expr_stmt|;
operator|*
name|offptr
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
name|cbdata
operator|.
name|load_offset
operator|=
literal|0
expr_stmt|;
comment|/* Open the file for loading. */
name|loadfile_bfd
operator|=
name|bfd_openr
argument_list|(
name|filename
argument_list|,
name|gnutarget
argument_list|)
expr_stmt|;
if|if
condition|(
name|loadfile_bfd
operator|==
name|NULL
condition|)
block|{
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* FIXME: should be checking for errors from bfd_close (for one thing,      on error it does not free all the storage associated with the      bfd).  */
name|make_cleanup_bfd_close
argument_list|(
name|loadfile_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_check_format
argument_list|(
name|loadfile_bfd
argument_list|,
name|bfd_object
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"\"%s\" is not an object file: %s"
argument_list|,
name|filename
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|bfd_map_over_sections
argument_list|(
name|loadfile_bfd
argument_list|,
name|add_section_size_callback
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|cbdata
operator|.
name|total_size
argument_list|)
expr_stmt|;
name|start_time
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|bfd_map_over_sections
argument_list|(
name|loadfile_bfd
argument_list|,
name|load_section_callback
argument_list|,
operator|&
name|cbdata
argument_list|)
expr_stmt|;
name|end_time
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|entry
operator|=
name|bfd_get_start_address
argument_list|(
name|loadfile_bfd
argument_list|)
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|"Start address "
argument_list|)
expr_stmt|;
name|ui_out_field_fmt
argument_list|(
name|uiout
argument_list|,
literal|"address"
argument_list|,
literal|"0x%s"
argument_list|,
name|paddr_nz
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|", load size "
argument_list|)
expr_stmt|;
name|ui_out_field_fmt
argument_list|(
name|uiout
argument_list|,
literal|"load-size"
argument_list|,
literal|"%lu"
argument_list|,
name|cbdata
operator|.
name|data_count
argument_list|)
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* We were doing this in remote-mips.c, I suspect it is right      for other targets too.  */
name|write_pc
argument_list|(
name|entry
argument_list|)
expr_stmt|;
comment|/* FIXME: are we supposed to call symbol_file_add or not?  According      to a comment from remote-mips.c (where a call to symbol_file_add      was commented out), making the call confuses GDB if more than one      file is loaded in.  Some targets do (e.g., remote-vx.c) but      others don't (or didn't - perhaphs they have all been deleted).  */
name|print_transfer_performance
argument_list|(
name|gdb_stdout
argument_list|,
name|cbdata
operator|.
name|data_count
argument_list|,
name|cbdata
operator|.
name|write_count
argument_list|,
name|end_time
operator|-
name|start_time
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_cleanups
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Report how fast the transfer went. */
end_comment

begin_comment
comment|/* DEPRECATED: cagney/1999-10-18: report_transfer_performance is being    replaced by print_transfer_performance (with a very different    function signature). */
end_comment

begin_function
name|void
name|report_transfer_performance
parameter_list|(
name|unsigned
name|long
name|data_count
parameter_list|,
name|time_t
name|start_time
parameter_list|,
name|time_t
name|end_time
parameter_list|)
block|{
name|print_transfer_performance
argument_list|(
name|gdb_stdout
argument_list|,
name|data_count
argument_list|,
name|end_time
operator|-
name|start_time
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|print_transfer_performance
parameter_list|(
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|unsigned
name|long
name|data_count
parameter_list|,
name|unsigned
name|long
name|write_count
parameter_list|,
name|unsigned
name|long
name|time_count
parameter_list|)
block|{
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|"Transfer rate: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|time_count
operator|>
literal|0
condition|)
block|{
name|ui_out_field_fmt
argument_list|(
name|uiout
argument_list|,
literal|"transfer-rate"
argument_list|,
literal|"%lu"
argument_list|,
operator|(
name|data_count
operator|*
literal|8
operator|)
operator|/
name|time_count
argument_list|)
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|" bits/sec"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ui_out_field_fmt
argument_list|(
name|uiout
argument_list|,
literal|"transferred-bits"
argument_list|,
literal|"%lu"
argument_list|,
operator|(
name|data_count
operator|*
literal|8
operator|)
argument_list|)
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|" bits in<1 sec"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|write_count
operator|>
literal|0
condition|)
block|{
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|ui_out_field_fmt
argument_list|(
name|uiout
argument_list|,
literal|"write-rate"
argument_list|,
literal|"%lu"
argument_list|,
name|data_count
operator|/
name|write_count
argument_list|)
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|" bytes/write"
argument_list|)
expr_stmt|;
block|}
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|".\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function allows the addition of incrementally linked object files.    It does not modify any state in the target, only in the debugger.  */
end_comment

begin_comment
comment|/* Note: ezannoni 2000-04-13 This function/command used to have a    special case syntax for the rombug target (Rombug is the boot    monitor for Microware's OS-9 / OS-9000, see remote-os9k.c). In the    rombug case, the user doesn't need to supply a text address,    instead a call to target_link() (in target.c) would supply the    value to use. We are now discontinuing this type of ad hoc syntax. */
end_comment

begin_function
specifier|static
name|void
name|add_symbol_file_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|char
modifier|*
name|filename
init|=
name|NULL
decl_stmt|;
name|int
name|flags
init|=
name|OBJF_USERLOADED
decl_stmt|;
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|expecting_option
init|=
literal|0
decl_stmt|;
name|int
name|section_index
init|=
literal|0
decl_stmt|;
name|int
name|argcnt
init|=
literal|0
decl_stmt|;
name|int
name|sec_num
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|expecting_sec_name
init|=
literal|0
decl_stmt|;
name|int
name|expecting_sec_addr
init|=
literal|0
decl_stmt|;
struct|struct
name|sect_opt
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
block|}
struct|;
name|struct
name|section_addr_info
modifier|*
name|section_addrs
decl_stmt|;
name|struct
name|sect_opt
modifier|*
name|sect_opts
init|=
name|NULL
decl_stmt|;
name|size_t
name|num_sect_opts
init|=
literal|0
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|my_cleanups
init|=
name|make_cleanup
argument_list|(
name|null_cleanup
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|num_sect_opts
operator|=
literal|16
expr_stmt|;
name|sect_opts
operator|=
operator|(
expr|struct
name|sect_opt
operator|*
operator|)
name|xmalloc
argument_list|(
name|num_sect_opts
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sect_opt
argument_list|)
argument_list|)
expr_stmt|;
name|dont_repeat
argument_list|()
expr_stmt|;
if|if
condition|(
name|args
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"add-symbol-file takes a file name and an address"
argument_list|)
expr_stmt|;
comment|/* Make a copy of the string that we can safely write into. */
name|args
operator|=
name|xstrdup
argument_list|(
name|args
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|args
operator|!=
literal|'\000'
condition|)
block|{
comment|/* Any leading spaces? */
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|args
argument_list|)
condition|)
name|args
operator|++
expr_stmt|;
comment|/* Point arg to the beginning of the argument. */
name|arg
operator|=
name|args
expr_stmt|;
comment|/* Move args pointer over the argument. */
while|while
condition|(
operator|(
operator|*
name|args
operator|!=
literal|'\000'
operator|)
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|args
argument_list|)
condition|)
name|args
operator|++
expr_stmt|;
comment|/* If there are more arguments, terminate arg and          proceed past it. */
if|if
condition|(
operator|*
name|args
operator|!=
literal|'\000'
condition|)
operator|*
name|args
operator|++
operator|=
literal|'\000'
expr_stmt|;
comment|/* Now process the argument. */
if|if
condition|(
name|argcnt
operator|==
literal|0
condition|)
block|{
comment|/* The first argument is the file name. */
name|filename
operator|=
name|tilde_expand
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argcnt
operator|==
literal|1
condition|)
block|{
comment|/* The second argument is always the text address at which                to load the program. */
name|sect_opts
index|[
name|section_index
index|]
operator|.
name|name
operator|=
literal|".text"
expr_stmt|;
name|sect_opts
index|[
name|section_index
index|]
operator|.
name|value
operator|=
name|arg
expr_stmt|;
if|if
condition|(
operator|++
name|section_index
operator|>
name|num_sect_opts
condition|)
block|{
name|num_sect_opts
operator|*=
literal|2
expr_stmt|;
name|sect_opts
operator|=
operator|(
operator|(
expr|struct
name|sect_opt
operator|*
operator|)
name|xrealloc
argument_list|(
name|sect_opts
argument_list|,
name|num_sect_opts
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sect_opt
argument_list|)
argument_list|)
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* It's an option (starting with '-') or it's an argument 	       to an option */
if|if
condition|(
operator|*
name|arg
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"-readnow"
argument_list|)
operator|==
literal|0
condition|)
name|flags
operator||=
name|OBJF_READNOW
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"-s"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|expecting_sec_name
operator|=
literal|1
expr_stmt|;
name|expecting_sec_addr
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|expecting_sec_name
condition|)
block|{
name|sect_opts
index|[
name|section_index
index|]
operator|.
name|name
operator|=
name|arg
expr_stmt|;
name|expecting_sec_name
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|expecting_sec_addr
condition|)
block|{
name|sect_opts
index|[
name|section_index
index|]
operator|.
name|value
operator|=
name|arg
expr_stmt|;
name|expecting_sec_addr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|++
name|section_index
operator|>
name|num_sect_opts
condition|)
block|{
name|num_sect_opts
operator|*=
literal|2
expr_stmt|;
name|sect_opts
operator|=
operator|(
operator|(
expr|struct
name|sect_opt
operator|*
operator|)
name|xrealloc
argument_list|(
name|sect_opts
argument_list|,
name|num_sect_opts
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sect_opt
argument_list|)
argument_list|)
operator|)
expr_stmt|;
block|}
block|}
else|else
name|error
argument_list|(
literal|"USAGE: add-symbol-file<filename><textaddress> [-mapped] [-readnow] [-s<secname><addr>]*"
argument_list|)
expr_stmt|;
block|}
block|}
name|argcnt
operator|++
expr_stmt|;
block|}
comment|/* Print the prompt for the query below. And save the arguments into      a sect_addr_info structure to be passed around to other      functions.  We have to split this up into separate print      statements because local_hex_string returns a local static      string. */
name|printf_unfiltered
argument_list|(
literal|"add symbol table from file \"%s\" at\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|section_addrs
operator|=
name|alloc_section_addr_info
argument_list|(
name|section_index
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|section_addrs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|section_index
condition|;
name|i
operator|++
control|)
block|{
name|CORE_ADDR
name|addr
decl_stmt|;
name|char
modifier|*
name|val
init|=
name|sect_opts
index|[
name|i
index|]
operator|.
name|value
decl_stmt|;
name|char
modifier|*
name|sec
init|=
name|sect_opts
index|[
name|i
index|]
operator|.
name|name
decl_stmt|;
name|addr
operator|=
name|parse_and_eval_address
argument_list|(
name|val
argument_list|)
expr_stmt|;
comment|/* Here we store the section offsets in the order they were          entered on the command line. */
name|section_addrs
operator|->
name|other
index|[
name|sec_num
index|]
operator|.
name|name
operator|=
name|sec
expr_stmt|;
name|section_addrs
operator|->
name|other
index|[
name|sec_num
index|]
operator|.
name|addr
operator|=
name|addr
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"\t%s_addr = %s\n"
argument_list|,
name|sec
argument_list|,
name|local_hex_string
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|sec_num
operator|++
expr_stmt|;
comment|/* The object's sections are initialized when a  	 call is made to build_objfile_section_table (objfile). 	 This happens in reread_symbols.  	 At this point, we don't know what file type this is, 	 so we can't determine what section names are valid.  */
block|}
if|if
condition|(
name|from_tty
operator|&&
operator|(
operator|!
name|query
argument_list|(
literal|"%s"
argument_list|,
literal|""
argument_list|)
operator|)
condition|)
name|error
argument_list|(
literal|"Not confirmed."
argument_list|)
expr_stmt|;
name|symbol_file_add
argument_list|(
name|filename
argument_list|,
name|from_tty
argument_list|,
name|section_addrs
argument_list|,
literal|0
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* Getting new symbols may change our opinion about what is      frameless.  */
name|reinit_frame_cache
argument_list|()
expr_stmt|;
name|do_cleanups
argument_list|(
name|my_cleanups
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|add_shared_symbol_files_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ADD_SHARED_SYMBOL_FILES
name|ADD_SHARED_SYMBOL_FILES
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
argument_list|(
literal|"This command is not available in this configuration of GDB."
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Re-read symbols if a symbol-file has changed.  */
end_comment

begin_function
name|void
name|reread_symbols
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|long
name|new_modtime
decl_stmt|;
name|int
name|reread_one
init|=
literal|0
decl_stmt|;
name|struct
name|stat
name|new_statbuf
decl_stmt|;
name|int
name|res
decl_stmt|;
comment|/* With the addition of shared libraries, this should be modified,      the load time should be saved in the partial symbol tables, since      different tables may come from different source files.  FIXME.      This routine should then walk down each partial symbol table      and see if the symbol table that it originates from has been changed */
for|for
control|(
name|objfile
operator|=
name|object_files
init|;
name|objfile
condition|;
name|objfile
operator|=
name|objfile
operator|->
name|next
control|)
block|{
if|if
condition|(
name|objfile
operator|->
name|obfd
condition|)
block|{
ifdef|#
directive|ifdef
name|DEPRECATED_IBM6000_TARGET
comment|/* If this object is from a shared library, then you should 	     stat on the library name, not member name. */
if|if
condition|(
name|objfile
operator|->
name|obfd
operator|->
name|my_archive
condition|)
name|res
operator|=
name|stat
argument_list|(
name|objfile
operator|->
name|obfd
operator|->
name|my_archive
operator|->
name|filename
argument_list|,
operator|&
name|new_statbuf
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|res
operator|=
name|stat
argument_list|(
name|objfile
operator|->
name|name
argument_list|,
operator|&
name|new_statbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
literal|0
condition|)
block|{
comment|/* FIXME, should use print_sys_errmsg but it's not filtered. */
name|printf_unfiltered
argument_list|(
literal|"`%s' has disappeared; keeping its symbols.\n"
argument_list|,
name|objfile
operator|->
name|name
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|new_modtime
operator|=
name|new_statbuf
operator|.
name|st_mtime
expr_stmt|;
if|if
condition|(
name|new_modtime
operator|!=
name|objfile
operator|->
name|mtime
condition|)
block|{
name|struct
name|cleanup
modifier|*
name|old_cleanups
decl_stmt|;
name|struct
name|section_offsets
modifier|*
name|offsets
decl_stmt|;
name|int
name|num_offsets
decl_stmt|;
name|char
modifier|*
name|obfd_filename
decl_stmt|;
name|printf_unfiltered
argument_list|(
literal|"`%s' has changed; re-reading symbols.\n"
argument_list|,
name|objfile
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* There are various functions like symbol_file_add, 	         symfile_bfd_open, syms_from_objfile, etc., which might 	         appear to do what we want.  But they have various other 	         effects which we *don't* want.  So we just do stuff 	         ourselves.  We don't worry about mapped files (for one thing, 	         any mapped file will be out of date).  */
comment|/* If we get an error, blow away this objfile (not sure if 	         that is the correct response for things like shared 	         libraries).  */
name|old_cleanups
operator|=
name|make_cleanup_free_objfile
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
comment|/* We need to do this whenever any symbols go away.  */
name|make_cleanup
argument_list|(
name|clear_symtab_users_cleanup
argument_list|,
literal|0
comment|/*ignore*/
argument_list|)
expr_stmt|;
comment|/* Clean up any state BFD has sitting around.  We don't need 	         to close the descriptor but BFD lacks a way of closing the 	         BFD without closing the descriptor.  */
name|obfd_filename
operator|=
name|bfd_get_filename
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_close
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|)
condition|)
name|error
argument_list|(
literal|"Can't close BFD for %s: %s"
argument_list|,
name|objfile
operator|->
name|name
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|objfile
operator|->
name|obfd
operator|=
name|bfd_openr
argument_list|(
name|obfd_filename
argument_list|,
name|gnutarget
argument_list|)
expr_stmt|;
if|if
condition|(
name|objfile
operator|->
name|obfd
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Can't open %s to read symbols."
argument_list|,
name|objfile
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* bfd_openr sets cacheable to true, which is what we want.  */
if|if
condition|(
operator|!
name|bfd_check_format
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|bfd_object
argument_list|)
condition|)
name|error
argument_list|(
literal|"Can't read symbols from %s: %s."
argument_list|,
name|objfile
operator|->
name|name
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Save the offsets, we will nuke them with the rest of the 	         objfile_obstack.  */
name|num_offsets
operator|=
name|objfile
operator|->
name|num_sections
expr_stmt|;
name|offsets
operator|=
operator|(
operator|(
expr|struct
name|section_offsets
operator|*
operator|)
name|alloca
argument_list|(
name|SIZEOF_N_SECTION_OFFSETS
argument_list|(
name|num_offsets
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|memcpy
argument_list|(
name|offsets
argument_list|,
name|objfile
operator|->
name|section_offsets
argument_list|,
name|SIZEOF_N_SECTION_OFFSETS
argument_list|(
name|num_offsets
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Nuke all the state that we will re-read.  Much of the following 	         code which sets things to NULL really is necessary to tell 	         other parts of GDB that there is nothing currently there.  */
comment|/* FIXME: Do we have to free a whole linked list, or is this 	         enough?  */
if|if
condition|(
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
condition|)
name|xmfree
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|objfile
operator|->
name|global_psymbols
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|objfile
operator|->
name|global_psymbols
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|objfile
operator|->
name|static_psymbols
operator|.
name|list
condition|)
name|xmfree
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
name|objfile
operator|->
name|static_psymbols
operator|.
name|list
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|objfile
operator|->
name|static_psymbols
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|objfile
operator|->
name|static_psymbols
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Free the obstacks for non-reusable objfiles */
name|bcache_xfree
argument_list|(
name|objfile
operator|->
name|psymbol_cache
argument_list|)
expr_stmt|;
name|objfile
operator|->
name|psymbol_cache
operator|=
name|bcache_xmalloc
argument_list|()
expr_stmt|;
name|bcache_xfree
argument_list|(
name|objfile
operator|->
name|macro_cache
argument_list|)
expr_stmt|;
name|objfile
operator|->
name|macro_cache
operator|=
name|bcache_xmalloc
argument_list|()
expr_stmt|;
if|if
condition|(
name|objfile
operator|->
name|demangled_names_hash
operator|!=
name|NULL
condition|)
block|{
name|htab_delete
argument_list|(
name|objfile
operator|->
name|demangled_names_hash
argument_list|)
expr_stmt|;
name|objfile
operator|->
name|demangled_names_hash
operator|=
name|NULL
expr_stmt|;
block|}
name|obstack_free
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|objfile
operator|->
name|sections
operator|=
name|NULL
expr_stmt|;
name|objfile
operator|->
name|symtabs
operator|=
name|NULL
expr_stmt|;
name|objfile
operator|->
name|psymtabs
operator|=
name|NULL
expr_stmt|;
name|objfile
operator|->
name|free_psymtabs
operator|=
name|NULL
expr_stmt|;
name|objfile
operator|->
name|cp_namespace_symtab
operator|=
name|NULL
expr_stmt|;
name|objfile
operator|->
name|msymbols
operator|=
name|NULL
expr_stmt|;
name|objfile
operator|->
name|sym_private
operator|=
name|NULL
expr_stmt|;
name|objfile
operator|->
name|minimal_symbol_count
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|&
name|objfile
operator|->
name|msymbol_hash
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|objfile
operator|->
name|msymbol_hash
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|objfile
operator|->
name|msymbol_demangled_hash
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|objfile
operator|->
name|msymbol_demangled_hash
argument_list|)
argument_list|)
expr_stmt|;
name|objfile
operator|->
name|fundamental_types
operator|=
name|NULL
expr_stmt|;
name|clear_objfile_data
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|objfile
operator|->
name|sf
operator|!=
name|NULL
condition|)
block|{
call|(
modifier|*
name|objfile
operator|->
name|sf
operator|->
name|sym_finish
call|)
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
block|}
comment|/* We never make this a mapped file.  */
name|objfile
operator|->
name|md
operator|=
name|NULL
expr_stmt|;
name|objfile
operator|->
name|psymbol_cache
operator|=
name|bcache_xmalloc
argument_list|()
expr_stmt|;
name|objfile
operator|->
name|macro_cache
operator|=
name|bcache_xmalloc
argument_list|()
expr_stmt|;
comment|/* obstack_init also initializes the obstack so it is 	         empty.  We could use obstack_specify_allocation but 	         gdb_obstack.h specifies the alloc/dealloc 	         functions.  */
name|obstack_init
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|)
expr_stmt|;
if|if
condition|(
name|build_objfile_section_table
argument_list|(
name|objfile
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"Can't find the file sections in `%s': %s"
argument_list|,
name|objfile
operator|->
name|name
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|terminate_minimal_symbol_table
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
comment|/* We use the same section offsets as from last time.  I'm not 	         sure whether that is always correct for shared libraries.  */
name|objfile
operator|->
name|section_offsets
operator|=
operator|(
expr|struct
name|section_offsets
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
name|SIZEOF_N_SECTION_OFFSETS
argument_list|(
name|num_offsets
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|objfile
operator|->
name|section_offsets
argument_list|,
name|offsets
argument_list|,
name|SIZEOF_N_SECTION_OFFSETS
argument_list|(
name|num_offsets
argument_list|)
argument_list|)
expr_stmt|;
name|objfile
operator|->
name|num_sections
operator|=
name|num_offsets
expr_stmt|;
comment|/* What the hell is sym_new_init for, anyway?  The concept of 	         distinguishing between the main file and additional files 	         in this way seems rather dubious.  */
if|if
condition|(
name|objfile
operator|==
name|symfile_objfile
condition|)
block|{
call|(
modifier|*
name|objfile
operator|->
name|sf
operator|->
name|sym_new_init
call|)
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HPUXHPPA
name|RESET_HP_UX_GLOBALS
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
call|(
modifier|*
name|objfile
operator|->
name|sf
operator|->
name|sym_init
call|)
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
name|clear_complaints
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* The "mainline" parameter is a hideous hack; I think leaving it 	         zero is OK since dbxread.c also does what it needs to do if 	         objfile->global_psymbols.size is 0.  */
call|(
modifier|*
name|objfile
operator|->
name|sf
operator|->
name|sym_read
call|)
argument_list|(
name|objfile
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|have_partial_symbols
argument_list|()
operator|&&
operator|!
name|have_full_symbols
argument_list|()
condition|)
block|{
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"(no debugging symbols found)\n"
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
name|objfile
operator|->
name|flags
operator||=
name|OBJF_SYMS
expr_stmt|;
comment|/* We're done reading the symbol file; finish off complaints.  */
name|clear_complaints
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Getting new symbols may change our opinion about what is 	         frameless.  */
name|reinit_frame_cache
argument_list|()
expr_stmt|;
comment|/* Discard cleanups as symbol reading was successful.  */
name|discard_cleanups
argument_list|(
name|old_cleanups
argument_list|)
expr_stmt|;
comment|/* If the mtime has changed between the time we set new_modtime 	         and now, we *want* this to be out of date, so don't call stat 	         again now.  */
name|objfile
operator|->
name|mtime
operator|=
name|new_modtime
expr_stmt|;
name|reread_one
operator|=
literal|1
expr_stmt|;
name|reread_separate_symbols
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|reread_one
condition|)
name|clear_symtab_users
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle separate debug info for OBJFILE, which has just been    re-read:    - If we had separate debug info before, but now we don't, get rid      of the separated objfile.    - If we didn't have separated debug info before, but now we do,      read in the new separated debug info file.    - If the debug link points to a different file, toss the old one      and read the new one.    This function does *not* handle the case where objfile is still    using the same separate debug info file, but that file's timestamp    has changed.  That case should be handled by the loop in    reread_symbols already.  */
end_comment

begin_function
specifier|static
name|void
name|reread_separate_symbols
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|char
modifier|*
name|debug_file
decl_stmt|;
name|unsigned
name|long
name|crc32
decl_stmt|;
comment|/* Does the updated objfile's debug info live in a      separate file?  */
name|debug_file
operator|=
name|find_separate_debug_file
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|objfile
operator|->
name|separate_debug_objfile
condition|)
block|{
comment|/* There are two cases where we need to get rid of          the old separated debug info objfile:          - if the new primary objfile doesn't have          separated debug info, or          - if the new primary objfile has separate debug          info, but it's under a different filename.            If the old and new objfiles both have separate          debug info, under the same filename, then we're          okay --- if the separated file's contents have          changed, we will have caught that when we          visited it in this function's outermost          loop.  */
if|if
condition|(
operator|!
name|debug_file
operator|||
name|strcmp
argument_list|(
name|debug_file
argument_list|,
name|objfile
operator|->
name|separate_debug_objfile
operator|->
name|name
argument_list|)
operator|!=
literal|0
condition|)
name|free_objfile
argument_list|(
name|objfile
operator|->
name|separate_debug_objfile
argument_list|)
expr_stmt|;
block|}
comment|/* If the new objfile has separate debug info, and we      haven't loaded it already, do so now.  */
if|if
condition|(
name|debug_file
operator|&&
operator|!
name|objfile
operator|->
name|separate_debug_objfile
condition|)
block|{
comment|/* Use the same section offset table as objfile itself.          Preserve the flags from objfile that make sense.  */
name|objfile
operator|->
name|separate_debug_objfile
operator|=
operator|(
name|symbol_file_add_with_addrs_or_offsets
argument_list|(
name|debug_file
argument_list|,
name|info_verbose
argument_list|,
comment|/* from_tty: Don't override the default. */
literal|0
argument_list|,
comment|/* No addr table.  */
name|objfile
operator|->
name|section_offsets
argument_list|,
name|objfile
operator|->
name|num_sections
argument_list|,
literal|0
argument_list|,
comment|/* Not mainline.  See comments about this above.  */
name|objfile
operator|->
name|flags
operator|&
operator|(
name|OBJF_REORDERED
operator||
name|OBJF_SHARED
operator||
name|OBJF_READNOW
operator||
name|OBJF_USERLOADED
operator|)
argument_list|)
operator|)
expr_stmt|;
name|objfile
operator|->
name|separate_debug_objfile
operator|->
name|separate_debug_objfile_backlink
operator|=
name|objfile
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|ext
decl_stmt|;
name|enum
name|language
name|lang
decl_stmt|;
block|}
name|filename_language
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|filename_language
modifier|*
name|filename_language_table
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fl_table_size
decl_stmt|,
name|fl_table_next
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|add_filename_language
parameter_list|(
name|char
modifier|*
name|ext
parameter_list|,
name|enum
name|language
name|lang
parameter_list|)
block|{
if|if
condition|(
name|fl_table_next
operator|>=
name|fl_table_size
condition|)
block|{
name|fl_table_size
operator|+=
literal|10
expr_stmt|;
name|filename_language_table
operator|=
name|xrealloc
argument_list|(
name|filename_language_table
argument_list|,
name|fl_table_size
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|filename_language_table
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|filename_language_table
index|[
name|fl_table_next
index|]
operator|.
name|ext
operator|=
name|xstrdup
argument_list|(
name|ext
argument_list|)
expr_stmt|;
name|filename_language_table
index|[
name|fl_table_next
index|]
operator|.
name|lang
operator|=
name|lang
expr_stmt|;
name|fl_table_next
operator|++
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ext_args
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|set_ext_lang_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|cp
init|=
name|ext_args
decl_stmt|;
name|enum
name|language
name|lang
decl_stmt|;
comment|/* First arg is filename extension, starting with '.' */
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'.'
condition|)
name|error
argument_list|(
literal|"'%s': Filename extension must begin with '.'"
argument_list|,
name|ext_args
argument_list|)
expr_stmt|;
comment|/* Find end of first arg.  */
while|while
condition|(
operator|*
name|cp
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
name|error
argument_list|(
literal|"'%s': two arguments required -- filename extension and language"
argument_list|,
name|ext_args
argument_list|)
expr_stmt|;
comment|/* Null-terminate first arg */
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* Find beginning of second arg, which should be a source language.  */
while|while
condition|(
operator|*
name|cp
operator|&&
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
name|error
argument_list|(
literal|"'%s': two arguments required -- filename extension and language"
argument_list|,
name|ext_args
argument_list|)
expr_stmt|;
comment|/* Lookup the language from among those we know.  */
name|lang
operator|=
name|language_enum
argument_list|(
name|cp
argument_list|)
expr_stmt|;
comment|/* Now lookup the filename extension: do we already know it?  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fl_table_next
condition|;
name|i
operator|++
control|)
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
name|ext_args
argument_list|,
name|filename_language_table
index|[
name|i
index|]
operator|.
name|ext
argument_list|)
condition|)
break|break;
if|if
condition|(
name|i
operator|>=
name|fl_table_next
condition|)
block|{
comment|/* new file extension */
name|add_filename_language
argument_list|(
name|ext_args
argument_list|,
name|lang
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* redefining a previously known filename extension */
comment|/* if (from_tty) */
comment|/*   query ("Really make files of type %s '%s'?", */
comment|/*          ext_args, language_str (lang));           */
name|xfree
argument_list|(
name|filename_language_table
index|[
name|i
index|]
operator|.
name|ext
argument_list|)
expr_stmt|;
name|filename_language_table
index|[
name|i
index|]
operator|.
name|ext
operator|=
name|xstrdup
argument_list|(
name|ext_args
argument_list|)
expr_stmt|;
name|filename_language_table
index|[
name|i
index|]
operator|.
name|lang
operator|=
name|lang
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|info_ext_lang_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|printf_filtered
argument_list|(
literal|"Filename extensions and the languages they represent:"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fl_table_next
condition|;
name|i
operator|++
control|)
name|printf_filtered
argument_list|(
literal|"\t%s\t- %s\n"
argument_list|,
name|filename_language_table
index|[
name|i
index|]
operator|.
name|ext
argument_list|,
name|language_str
argument_list|(
name|filename_language_table
index|[
name|i
index|]
operator|.
name|lang
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|init_filename_language_table
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|fl_table_size
operator|==
literal|0
condition|)
comment|/* protect against repetition */
block|{
name|fl_table_size
operator|=
literal|20
expr_stmt|;
name|fl_table_next
operator|=
literal|0
expr_stmt|;
name|filename_language_table
operator|=
name|xmalloc
argument_list|(
name|fl_table_size
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|filename_language_table
argument_list|)
argument_list|)
expr_stmt|;
name|add_filename_language
argument_list|(
literal|".c"
argument_list|,
name|language_c
argument_list|)
expr_stmt|;
name|add_filename_language
argument_list|(
literal|".C"
argument_list|,
name|language_cplus
argument_list|)
expr_stmt|;
name|add_filename_language
argument_list|(
literal|".cc"
argument_list|,
name|language_cplus
argument_list|)
expr_stmt|;
name|add_filename_language
argument_list|(
literal|".cp"
argument_list|,
name|language_cplus
argument_list|)
expr_stmt|;
name|add_filename_language
argument_list|(
literal|".cpp"
argument_list|,
name|language_cplus
argument_list|)
expr_stmt|;
name|add_filename_language
argument_list|(
literal|".cxx"
argument_list|,
name|language_cplus
argument_list|)
expr_stmt|;
name|add_filename_language
argument_list|(
literal|".c++"
argument_list|,
name|language_cplus
argument_list|)
expr_stmt|;
name|add_filename_language
argument_list|(
literal|".java"
argument_list|,
name|language_java
argument_list|)
expr_stmt|;
name|add_filename_language
argument_list|(
literal|".class"
argument_list|,
name|language_java
argument_list|)
expr_stmt|;
name|add_filename_language
argument_list|(
literal|".m"
argument_list|,
name|language_objc
argument_list|)
expr_stmt|;
name|add_filename_language
argument_list|(
literal|".f"
argument_list|,
name|language_fortran
argument_list|)
expr_stmt|;
name|add_filename_language
argument_list|(
literal|".F"
argument_list|,
name|language_fortran
argument_list|)
expr_stmt|;
name|add_filename_language
argument_list|(
literal|".s"
argument_list|,
name|language_asm
argument_list|)
expr_stmt|;
name|add_filename_language
argument_list|(
literal|".S"
argument_list|,
name|language_asm
argument_list|)
expr_stmt|;
name|add_filename_language
argument_list|(
literal|".pas"
argument_list|,
name|language_pascal
argument_list|)
expr_stmt|;
name|add_filename_language
argument_list|(
literal|".p"
argument_list|,
name|language_pascal
argument_list|)
expr_stmt|;
name|add_filename_language
argument_list|(
literal|".pp"
argument_list|,
name|language_pascal
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|enum
name|language
name|deduce_language_from_filename
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|filename
operator|!=
name|NULL
condition|)
if|if
condition|(
operator|(
name|cp
operator|=
name|strrchr
argument_list|(
name|filename
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fl_table_next
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
name|filename_language_table
index|[
name|i
index|]
operator|.
name|ext
argument_list|)
operator|==
literal|0
condition|)
return|return
name|filename_language_table
index|[
name|i
index|]
operator|.
name|lang
return|;
return|return
name|language_unknown
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* allocate_symtab:     Allocate and partly initialize a new symbol table.  Return a pointer    to it.  error() if no space.     Caller must set these fields:    LINETABLE(symtab)    symtab->blockvector    symtab->dirname    symtab->free_code    symtab->free_ptr    possibly free_named_symtabs (symtab->filename);  */
end_comment

begin_function
name|struct
name|symtab
modifier|*
name|allocate_symtab
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|struct
name|symtab
modifier|*
name|symtab
decl_stmt|;
name|symtab
operator|=
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symtab
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|symtab
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|symtab
argument_list|)
argument_list|)
expr_stmt|;
name|symtab
operator|->
name|filename
operator|=
name|obsavestring
argument_list|(
name|filename
argument_list|,
name|strlen
argument_list|(
name|filename
argument_list|)
argument_list|,
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|)
expr_stmt|;
name|symtab
operator|->
name|fullname
operator|=
name|NULL
expr_stmt|;
name|symtab
operator|->
name|language
operator|=
name|deduce_language_from_filename
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|symtab
operator|->
name|debugformat
operator|=
name|obsavestring
argument_list|(
literal|"unknown"
argument_list|,
literal|7
argument_list|,
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|)
expr_stmt|;
comment|/* Hook it to the objfile it comes from */
name|symtab
operator|->
name|objfile
operator|=
name|objfile
expr_stmt|;
name|symtab
operator|->
name|next
operator|=
name|objfile
operator|->
name|symtabs
expr_stmt|;
name|objfile
operator|->
name|symtabs
operator|=
name|symtab
expr_stmt|;
comment|/* FIXME: This should go away.  It is only defined for the Z8000,      and the Z8000 definition of this macro doesn't have anything to      do with the now-nonexistent EXTRA_SYMTAB_INFO macro, it's just      here for convenience.  */
ifdef|#
directive|ifdef
name|INIT_EXTRA_SYMTAB_INFO
name|INIT_EXTRA_SYMTAB_INFO
argument_list|(
name|symtab
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|symtab
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|partial_symtab
modifier|*
name|allocate_psymtab
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|struct
name|partial_symtab
modifier|*
name|psymtab
decl_stmt|;
if|if
condition|(
name|objfile
operator|->
name|free_psymtabs
condition|)
block|{
name|psymtab
operator|=
name|objfile
operator|->
name|free_psymtabs
expr_stmt|;
name|objfile
operator|->
name|free_psymtabs
operator|=
name|psymtab
operator|->
name|next
expr_stmt|;
block|}
else|else
name|psymtab
operator|=
operator|(
expr|struct
name|partial_symtab
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|partial_symtab
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|psymtab
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|partial_symtab
argument_list|)
argument_list|)
expr_stmt|;
name|psymtab
operator|->
name|filename
operator|=
name|obsavestring
argument_list|(
name|filename
argument_list|,
name|strlen
argument_list|(
name|filename
argument_list|)
argument_list|,
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|)
expr_stmt|;
name|psymtab
operator|->
name|symtab
operator|=
name|NULL
expr_stmt|;
comment|/* Prepend it to the psymtab list for the objfile it belongs to.      Psymtabs are searched in most recent inserted -> least recent      inserted order. */
name|psymtab
operator|->
name|objfile
operator|=
name|objfile
expr_stmt|;
name|psymtab
operator|->
name|next
operator|=
name|objfile
operator|->
name|psymtabs
expr_stmt|;
name|objfile
operator|->
name|psymtabs
operator|=
name|psymtab
expr_stmt|;
if|#
directive|if
literal|0
block|{     struct partial_symtab **prev_pst;     psymtab->objfile = objfile;     psymtab->next = NULL;     prev_pst =&(objfile->psymtabs);     while ((*prev_pst) != NULL)       prev_pst =&((*prev_pst)->next);     (*prev_pst) = psymtab;   }
endif|#
directive|endif
return|return
operator|(
name|psymtab
operator|)
return|;
block|}
end_function

begin_function
name|void
name|discard_psymtab
parameter_list|(
name|struct
name|partial_symtab
modifier|*
name|pst
parameter_list|)
block|{
name|struct
name|partial_symtab
modifier|*
modifier|*
name|prev_pst
decl_stmt|;
comment|/* From dbxread.c:      Empty psymtabs happen as a result of header files which don't      have any symbols in them.  There can be a lot of them.  But this      check is wrong, in that a psymtab with N_SLINE entries but      nothing else is not empty, but we don't realize that.  Fixing      that without slowing things down might be tricky.  */
comment|/* First, snip it out of the psymtab chain */
name|prev_pst
operator|=
operator|&
operator|(
name|pst
operator|->
name|objfile
operator|->
name|psymtabs
operator|)
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|prev_pst
operator|)
operator|!=
name|pst
condition|)
name|prev_pst
operator|=
operator|&
operator|(
operator|(
operator|*
name|prev_pst
operator|)
operator|->
name|next
operator|)
expr_stmt|;
operator|(
operator|*
name|prev_pst
operator|)
operator|=
name|pst
operator|->
name|next
expr_stmt|;
comment|/* Next, put it on a free list for recycling */
name|pst
operator|->
name|next
operator|=
name|pst
operator|->
name|objfile
operator|->
name|free_psymtabs
expr_stmt|;
name|pst
operator|->
name|objfile
operator|->
name|free_psymtabs
operator|=
name|pst
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Reset all data structures in gdb which may contain references to symbol    table data.  */
end_comment

begin_function
name|void
name|clear_symtab_users
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Someday, we should do better than this, by only blowing away      the things that really need to be blown.  */
name|clear_value_history
argument_list|()
expr_stmt|;
name|clear_displays
argument_list|()
expr_stmt|;
name|clear_internalvars
argument_list|()
expr_stmt|;
name|breakpoint_re_set
argument_list|()
expr_stmt|;
name|set_default_breakpoint
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|clear_current_source_symtab_and_line
argument_list|()
expr_stmt|;
name|clear_pc_function_cache
argument_list|()
expr_stmt|;
if|if
condition|(
name|target_new_objfile_hook
condition|)
name|target_new_objfile_hook
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|clear_symtab_users_cleanup
parameter_list|(
name|void
modifier|*
name|ignore
parameter_list|)
block|{
name|clear_symtab_users
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* clear_symtab_users_once:     This function is run after symbol reading, or from a cleanup.    If an old symbol table was obsoleted, the old symbol table    has been blown away, but the other GDB data structures that may     reference it have not yet been cleared or re-directed.  (The old    symtab was zapped, and the cleanup queued, in free_named_symtab()    below.)     This function can be queued N times as a cleanup, or called    directly; it will do all the work the first time, and then will be a    no-op until the next time it is queued.  This works by bumping a    counter at queueing time.  Much later when the cleanup is run, or at    the end of symbol processing (in case the cleanup is discarded), if    the queued count is greater than the "done-count", we do the work    and set the done-count to the queued count.  If the queued count is    less than or equal to the done-count, we just ignore the call.  This    is needed because reading a single .o file will often replace many    symtabs (one per .h file, for example), and we don't want to reset    the breakpoints N times in the user's face.     The reason we both queue a cleanup, and call it directly after symbol    reading, is because the cleanup protects us in case of errors, but is    discarded if symbol reading is successful.  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* FIXME:  As free_named_symtabs is currently a big noop this function    is no longer needed.  */
end_comment

begin_comment
unit|static void clear_symtab_users_once (void);  static int clear_symtab_users_queued; static int clear_symtab_users_done;  static void clear_symtab_users_once (void) {
comment|/* Enforce once-per-`do_cleanups'-semantics */
end_comment

begin_endif
unit|if (clear_symtab_users_queued<= clear_symtab_users_done)     return;   clear_symtab_users_done = clear_symtab_users_queued;    clear_symtab_users (); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* Delete the specified psymtab, and any others that reference it.  */
end_comment

begin_function
specifier|static
name|void
name|cashier_psymtab
parameter_list|(
name|struct
name|partial_symtab
modifier|*
name|pst
parameter_list|)
block|{
name|struct
name|partial_symtab
modifier|*
name|ps
decl_stmt|,
modifier|*
name|pprev
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Find its previous psymtab in the chain */
for|for
control|(
name|ps
operator|=
name|pst
operator|->
name|objfile
operator|->
name|psymtabs
init|;
name|ps
condition|;
name|ps
operator|=
name|ps
operator|->
name|next
control|)
block|{
if|if
condition|(
name|ps
operator|==
name|pst
condition|)
break|break;
name|pprev
operator|=
name|ps
expr_stmt|;
block|}
if|if
condition|(
name|ps
condition|)
block|{
comment|/* Unhook it from the chain.  */
if|if
condition|(
name|ps
operator|==
name|pst
operator|->
name|objfile
operator|->
name|psymtabs
condition|)
name|pst
operator|->
name|objfile
operator|->
name|psymtabs
operator|=
name|ps
operator|->
name|next
expr_stmt|;
else|else
name|pprev
operator|->
name|next
operator|=
name|ps
operator|->
name|next
expr_stmt|;
comment|/* FIXME, we can't conveniently deallocate the entries in the          partial_symbol lists (global_psymbols/static_psymbols) that          this psymtab points to.  These just take up space until all          the psymtabs are reclaimed.  Ditto the dependencies list and          filename, which are all in the objfile_obstack.  */
comment|/* We need to cashier any psymtab that has this one as a dependency... */
name|again
label|:
for|for
control|(
name|ps
operator|=
name|pst
operator|->
name|objfile
operator|->
name|psymtabs
init|;
name|ps
condition|;
name|ps
operator|=
name|ps
operator|->
name|next
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ps
operator|->
name|number_of_dependencies
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ps
operator|->
name|dependencies
index|[
name|i
index|]
operator|==
name|pst
condition|)
block|{
name|cashier_psymtab
argument_list|(
name|ps
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
comment|/* Must restart, chain has been munged. */
block|}
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* If a symtab or psymtab for filename NAME is found, free it along    with any dependent breakpoints, displays, etc.    Used when loading new versions of object modules with the "add-file"    command.  This is only called on the top-level symtab or psymtab's name;    it is not called for subsidiary files such as .h files.     Return value is 1 if we blew away the environment, 0 if not.    FIXME.  The return value appears to never be used.     FIXME.  I think this is not the best way to do this.  We should    work on being gentler to the environment while still cleaning up    all stray pointers into the freed symtab.  */
end_comment

begin_function
name|int
name|free_named_symtabs
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
if|#
directive|if
literal|0
comment|/* FIXME:  With the new method of each objfile having it's own      psymtab list, this function needs serious rethinking.  In particular,      why was it ever necessary to toss psymtabs with specific compilation      unit filenames, as opposed to all psymtabs from a particular symbol      file?  -- fnf      Well, the answer is that some systems permit reloading of particular      compilation units.  We want to blow away any old info about these      compilation units, regardless of which objfiles they arrived in. --gnu.  */
block|struct symtab *s;   struct symtab *prev;   struct partial_symtab *ps;   struct blockvector *bv;   int blewit = 0;
comment|/* We only wack things if the symbol-reload switch is set.  */
block|if (!symbol_reloading)     return 0;
comment|/* Some symbol formats have trouble providing file names... */
block|if (name == 0 || *name == '\0')     return 0;
comment|/* Look for a psymtab with the specified name.  */
block|again2:   for (ps = partial_symtab_list; ps; ps = ps->next)     {       if (strcmp (name, ps->filename) == 0) 	{ 	  cashier_psymtab (ps);
comment|/* Blow it away...and its little dog, too.  */
block|goto again2;
comment|/* Must restart, chain has been munged */
block|}     }
comment|/* Look for a symtab with the specified name.  */
block|for (s = symtab_list; s; s = s->next)     {       if (strcmp (name, s->filename) == 0) 	break;       prev = s;     }    if (s)     {       if (s == symtab_list) 	symtab_list = s->next;       else 	prev->next = s->next;
comment|/* For now, queue a delete for all breakpoints, displays, etc., whether          or not they depend on the symtab being freed.  This should be          changed so that only those data structures affected are deleted.  */
comment|/* But don't delete anything if the symtab is empty.          This test is necessary due to a bug in "dbxread.c" that          causes empty symtabs to be created for N_SO symbols that          contain the pathname of the object file.  (This problem          has been fixed in GDB 3.9x).  */
block|bv = BLOCKVECTOR (s);       if (BLOCKVECTOR_NBLOCKS (bv)> 2 	  || BLOCK_NSYMS (BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK)) 	  || BLOCK_NSYMS (BLOCKVECTOR_BLOCK (bv, STATIC_BLOCK))) 	{ 	  complaint (&symfile_complaints, "Replacing old symbols for `%s'", 		     name); 	  clear_symtab_users_queued++; 	  make_cleanup (clear_symtab_users_once, 0); 	  blewit = 1; 	}       else 	{ 	  complaint (&symfile_complaints, "Empty symbol table found for `%s'", 		     name); 	}        free_symtab (s);     }   else     {
comment|/* It is still possible that some breakpoints will be affected          even though no symtab was found, since the file might have          been compiled without debugging, and hence not be associated          with a symtab.  In order to handle this correctly, we would need          to keep a list of text address ranges for undebuggable files.          For now, we do nothing, since this is a fairly obscure case.  */
block|;     }
comment|/* FIXME, what about the minimal symbol table? */
block|return blewit;
else|#
directive|else
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Allocate and partially fill a partial symtab.  It will be    completely filled at the end of the symbol list.     FILENAME is the name of the symbol-file we are reading from. */
end_comment

begin_function
name|struct
name|partial_symtab
modifier|*
name|start_psymtab_common
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|,
name|struct
name|section_offsets
modifier|*
name|section_offsets
parameter_list|,
name|char
modifier|*
name|filename
parameter_list|,
name|CORE_ADDR
name|textlow
parameter_list|,
name|struct
name|partial_symbol
modifier|*
modifier|*
name|global_syms
parameter_list|,
name|struct
name|partial_symbol
modifier|*
modifier|*
name|static_syms
parameter_list|)
block|{
name|struct
name|partial_symtab
modifier|*
name|psymtab
decl_stmt|;
name|psymtab
operator|=
name|allocate_psymtab
argument_list|(
name|filename
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|psymtab
operator|->
name|section_offsets
operator|=
name|section_offsets
expr_stmt|;
name|psymtab
operator|->
name|textlow
operator|=
name|textlow
expr_stmt|;
name|psymtab
operator|->
name|texthigh
operator|=
name|psymtab
operator|->
name|textlow
expr_stmt|;
comment|/* default */
name|psymtab
operator|->
name|globals_offset
operator|=
name|global_syms
operator|-
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
expr_stmt|;
name|psymtab
operator|->
name|statics_offset
operator|=
name|static_syms
operator|-
name|objfile
operator|->
name|static_psymbols
operator|.
name|list
expr_stmt|;
return|return
operator|(
name|psymtab
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add a symbol with a long value to a psymtab.    Since one arg is a struct, we pass in a ptr and deref it (sigh).      Return the partial symbol that has been added.  */
end_comment

begin_comment
comment|/* NOTE: carlton/2003-09-11: The reason why we return the partial    symbol is so that callers can get access to the symbol's demangled    name, which they don't have any cheap way to determine otherwise.    (Currenly, dwarf2read.c is the only file who uses that information,    though it's possible that other readers might in the future.)    Elena wasn't thrilled about that, and I don't blame her, but we    couldn't come up with a better way to get that information.  If    it's needed in other situations, we could consider breaking up    SYMBOL_SET_NAMES to provide access to the demangled name lookup    cache.  */
end_comment

begin_function
specifier|const
name|struct
name|partial_symbol
modifier|*
name|add_psymbol_to_list
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelength
parameter_list|,
name|domain_enum
name|domain
parameter_list|,
name|enum
name|address_class
name|class
parameter_list|,
name|struct
name|psymbol_allocation_list
modifier|*
name|list
parameter_list|,
name|long
name|val
parameter_list|,
comment|/* Value as a long */
name|CORE_ADDR
name|coreaddr
parameter_list|,
comment|/* Value as a CORE_ADDR */
name|enum
name|language
name|language
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|struct
name|partial_symbol
modifier|*
name|psym
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|alloca
argument_list|(
name|namelength
operator|+
literal|1
argument_list|)
decl_stmt|;
comment|/* psymbol is static so that there will be no uninitialized gaps in the      structure which might contain random data, causing cache misses in      bcache. */
specifier|static
name|struct
name|partial_symbol
name|psymbol
decl_stmt|;
comment|/* Create local copy of the partial symbol */
name|memcpy
argument_list|(
name|buf
argument_list|,
name|name
argument_list|,
name|namelength
argument_list|)
expr_stmt|;
name|buf
index|[
name|namelength
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* val and coreaddr are mutually exclusive, one of them *will* be zero */
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
block|{
name|SYMBOL_VALUE
argument_list|(
operator|&
name|psymbol
argument_list|)
operator|=
name|val
expr_stmt|;
block|}
else|else
block|{
name|SYMBOL_VALUE_ADDRESS
argument_list|(
operator|&
name|psymbol
argument_list|)
operator|=
name|coreaddr
expr_stmt|;
block|}
name|SYMBOL_SECTION
argument_list|(
operator|&
name|psymbol
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SYMBOL_LANGUAGE
argument_list|(
operator|&
name|psymbol
argument_list|)
operator|=
name|language
expr_stmt|;
name|PSYMBOL_DOMAIN
argument_list|(
operator|&
name|psymbol
argument_list|)
operator|=
name|domain
expr_stmt|;
name|PSYMBOL_CLASS
argument_list|(
operator|&
name|psymbol
argument_list|)
operator|=
name|class
expr_stmt|;
name|SYMBOL_SET_NAMES
argument_list|(
operator|&
name|psymbol
argument_list|,
name|buf
argument_list|,
name|namelength
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* Stash the partial symbol away in the cache */
name|psym
operator|=
name|deprecated_bcache
argument_list|(
operator|&
name|psymbol
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|partial_symbol
argument_list|)
argument_list|,
name|objfile
operator|->
name|psymbol_cache
argument_list|)
expr_stmt|;
comment|/* Save pointer to partial symbol in psymtab, growing symtab if needed. */
if|if
condition|(
name|list
operator|->
name|next
operator|>=
name|list
operator|->
name|list
operator|+
name|list
operator|->
name|size
condition|)
block|{
name|extend_psymbol_list
argument_list|(
name|list
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
operator|*
name|list
operator|->
name|next
operator|++
operator|=
name|psym
expr_stmt|;
name|OBJSTAT
argument_list|(
name|objfile
argument_list|,
name|n_psyms
operator|++
argument_list|)
expr_stmt|;
return|return
name|psym
return|;
block|}
end_function

begin_comment
comment|/* Add a symbol with a long value to a psymtab. This differs from  * add_psymbol_to_list above in taking both a mangled and a demangled  * name. */
end_comment

begin_function
name|void
name|add_psymbol_with_dem_name_to_list
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelength
parameter_list|,
name|char
modifier|*
name|dem_name
parameter_list|,
name|int
name|dem_namelength
parameter_list|,
name|domain_enum
name|domain
parameter_list|,
name|enum
name|address_class
name|class
parameter_list|,
name|struct
name|psymbol_allocation_list
modifier|*
name|list
parameter_list|,
name|long
name|val
parameter_list|,
comment|/* Value as a long */
name|CORE_ADDR
name|coreaddr
parameter_list|,
comment|/* Value as a CORE_ADDR */
name|enum
name|language
name|language
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|struct
name|partial_symbol
modifier|*
name|psym
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|alloca
argument_list|(
name|namelength
operator|+
literal|1
argument_list|)
decl_stmt|;
comment|/* psymbol is static so that there will be no uninitialized gaps in the      structure which might contain random data, causing cache misses in      bcache. */
specifier|static
name|struct
name|partial_symbol
name|psymbol
decl_stmt|;
comment|/* Create local copy of the partial symbol */
name|memcpy
argument_list|(
name|buf
argument_list|,
name|name
argument_list|,
name|namelength
argument_list|)
expr_stmt|;
name|buf
index|[
name|namelength
index|]
operator|=
literal|'\0'
expr_stmt|;
name|DEPRECATED_SYMBOL_NAME
argument_list|(
operator|&
name|psymbol
argument_list|)
operator|=
name|deprecated_bcache
argument_list|(
name|buf
argument_list|,
name|namelength
operator|+
literal|1
argument_list|,
name|objfile
operator|->
name|psymbol_cache
argument_list|)
expr_stmt|;
name|buf
operator|=
name|alloca
argument_list|(
name|dem_namelength
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
name|dem_name
argument_list|,
name|dem_namelength
argument_list|)
expr_stmt|;
name|buf
index|[
name|dem_namelength
index|]
operator|=
literal|'\0'
expr_stmt|;
switch|switch
condition|(
name|language
condition|)
block|{
case|case
name|language_c
case|:
case|case
name|language_cplus
case|:
name|SYMBOL_CPLUS_DEMANGLED_NAME
argument_list|(
operator|&
name|psymbol
argument_list|)
operator|=
name|deprecated_bcache
argument_list|(
name|buf
argument_list|,
name|dem_namelength
operator|+
literal|1
argument_list|,
name|objfile
operator|->
name|psymbol_cache
argument_list|)
expr_stmt|;
break|break;
comment|/* FIXME What should be done for the default case? Ignoring for now. */
block|}
comment|/* val and coreaddr are mutually exclusive, one of them *will* be zero */
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
block|{
name|SYMBOL_VALUE
argument_list|(
operator|&
name|psymbol
argument_list|)
operator|=
name|val
expr_stmt|;
block|}
else|else
block|{
name|SYMBOL_VALUE_ADDRESS
argument_list|(
operator|&
name|psymbol
argument_list|)
operator|=
name|coreaddr
expr_stmt|;
block|}
name|SYMBOL_SECTION
argument_list|(
operator|&
name|psymbol
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SYMBOL_LANGUAGE
argument_list|(
operator|&
name|psymbol
argument_list|)
operator|=
name|language
expr_stmt|;
name|PSYMBOL_DOMAIN
argument_list|(
operator|&
name|psymbol
argument_list|)
operator|=
name|domain
expr_stmt|;
name|PSYMBOL_CLASS
argument_list|(
operator|&
name|psymbol
argument_list|)
operator|=
name|class
expr_stmt|;
name|SYMBOL_INIT_LANGUAGE_SPECIFIC
argument_list|(
operator|&
name|psymbol
argument_list|,
name|language
argument_list|)
expr_stmt|;
comment|/* Stash the partial symbol away in the cache */
name|psym
operator|=
name|deprecated_bcache
argument_list|(
operator|&
name|psymbol
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|partial_symbol
argument_list|)
argument_list|,
name|objfile
operator|->
name|psymbol_cache
argument_list|)
expr_stmt|;
comment|/* Save pointer to partial symbol in psymtab, growing symtab if needed. */
if|if
condition|(
name|list
operator|->
name|next
operator|>=
name|list
operator|->
name|list
operator|+
name|list
operator|->
name|size
condition|)
block|{
name|extend_psymbol_list
argument_list|(
name|list
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
operator|*
name|list
operator|->
name|next
operator|++
operator|=
name|psym
expr_stmt|;
name|OBJSTAT
argument_list|(
name|objfile
argument_list|,
name|n_psyms
operator|++
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize storage for partial symbols.  */
end_comment

begin_function
name|void
name|init_psymbol_list
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|,
name|int
name|total_symbols
parameter_list|)
block|{
comment|/* Free any previously allocated psymbol lists.  */
if|if
condition|(
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
condition|)
block|{
name|xmfree
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|objfile
operator|->
name|static_psymbols
operator|.
name|list
condition|)
block|{
name|xmfree
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
name|objfile
operator|->
name|static_psymbols
operator|.
name|list
argument_list|)
expr_stmt|;
block|}
comment|/* Current best guess is that approximately a twentieth      of the total symbols (in a debugging file) are global or static      oriented symbols */
name|objfile
operator|->
name|global_psymbols
operator|.
name|size
operator|=
name|total_symbols
operator|/
literal|10
expr_stmt|;
name|objfile
operator|->
name|static_psymbols
operator|.
name|size
operator|=
name|total_symbols
operator|/
literal|10
expr_stmt|;
if|if
condition|(
name|objfile
operator|->
name|global_psymbols
operator|.
name|size
operator|>
literal|0
condition|)
block|{
name|objfile
operator|->
name|global_psymbols
operator|.
name|next
operator|=
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
operator|=
operator|(
expr|struct
name|partial_symbol
operator|*
operator|*
operator|)
name|xmmalloc
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
operator|(
name|objfile
operator|->
name|global_psymbols
operator|.
name|size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|partial_symbol
operator|*
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|objfile
operator|->
name|static_psymbols
operator|.
name|size
operator|>
literal|0
condition|)
block|{
name|objfile
operator|->
name|static_psymbols
operator|.
name|next
operator|=
name|objfile
operator|->
name|static_psymbols
operator|.
name|list
operator|=
operator|(
expr|struct
name|partial_symbol
operator|*
operator|*
operator|)
name|xmmalloc
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
operator|(
name|objfile
operator|->
name|static_psymbols
operator|.
name|size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|partial_symbol
operator|*
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* OVERLAYS:    The following code implements an abstraction for debugging overlay sections.     The target model is as follows:    1) The gnu linker will permit multiple sections to be mapped into the    same VMA, each with its own unique LMA (or load address).    2) It is assumed that some runtime mechanism exists for mapping the    sections, one by one, from the load address into the VMA address.    3) This code provides a mechanism for gdb to keep track of which     sections should be considered to be mapped from the VMA to the LMA.    This information is used for symbol lookup, and memory read/write.    For instance, if a section has been mapped then its contents     should be read from the VMA, otherwise from the LMA.     Two levels of debugger support for overlays are available.  One is    "manual", in which the debugger relies on the user to tell it which    overlays are currently mapped.  This level of support is    implemented entirely in the core debugger, and the information about    whether a section is mapped is kept in the objfile->obj_section table.     The second level of support is "automatic", and is only available if    the target-specific code provides functionality to read the target's    overlay mapping table, and translate its contents for the debugger    (by updating the mapped state information in the obj_section tables).     The interface is as follows:    User commands:    overlay map<name>   -- tell gdb to consider this section mapped    overlay unmap<name> -- tell gdb to consider this section unmapped    overlay list         -- list the sections that GDB thinks are mapped    overlay read-target  -- get the target's state of what's mapped    overlay off/manual/auto -- set overlay debugging state    Functional interface:    find_pc_mapped_section(pc):    if the pc is in the range of a mapped    section, return that section.    find_pc_overlay(pc):       find any overlay section that contains     the pc, either in its VMA or its LMA    overlay_is_mapped(sect):       true if overlay is marked as mapped    section_is_overlay(sect):      true if section's VMA != LMA    pc_in_mapped_range(pc,sec):    true if pc belongs to section's VMA    pc_in_unmapped_range(...):     true if pc belongs to section's LMA    sections_overlap(sec1, sec2):  true if mapped sec1 and sec2 ranges overlap    overlay_mapped_address(...):   map an address from section's LMA to VMA    overlay_unmapped_address(...): map an address from section's VMA to LMA    symbol_overlayed_address(...): Return a "current" address for symbol:    either in VMA or LMA depending on whether    the symbol's section is currently mapped  */
end_comment

begin_comment
comment|/* Overlay debugging state: */
end_comment

begin_decl_stmt
name|enum
name|overlay_debugging_state
name|overlay_debugging
init|=
name|ovly_off
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|overlay_cache_invalid
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True if need to refresh mapped state */
end_comment

begin_comment
comment|/* Target vector for refreshing overlay mapped state */
end_comment

begin_function_decl
specifier|static
name|void
name|simple_overlay_update
parameter_list|(
name|struct
name|obj_section
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
function_decl|(
modifier|*
name|target_overlay_update
function_decl|)
parameter_list|(
name|struct
name|obj_section
modifier|*
parameter_list|)
init|=
name|simple_overlay_update
function_decl|;
end_function_decl

begin_comment
comment|/* Function: section_is_overlay (SECTION)    Returns true if SECTION has VMA not equal to LMA, ie.     SECTION is loaded at an address different from where it will "run".  */
end_comment

begin_function
name|int
name|section_is_overlay
parameter_list|(
name|asection
modifier|*
name|section
parameter_list|)
block|{
comment|/* FIXME: need bfd *, so we can use bfd_section_lma methods. */
if|if
condition|(
name|overlay_debugging
condition|)
if|if
condition|(
name|section
operator|&&
name|section
operator|->
name|lma
operator|!=
literal|0
operator|&&
name|section
operator|->
name|vma
operator|!=
name|section
operator|->
name|lma
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Function: overlay_invalidate_all (void)    Invalidate the mapped state of all overlay sections (mark it as stale).  */
end_comment

begin_function
specifier|static
name|void
name|overlay_invalidate_all
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|obj_section
modifier|*
name|sect
decl_stmt|;
name|ALL_OBJSECTIONS
argument_list|(
argument|objfile
argument_list|,
argument|sect
argument_list|)
if|if
condition|(
name|section_is_overlay
argument_list|(
name|sect
operator|->
name|the_bfd_section
argument_list|)
condition|)
name|sect
operator|->
name|ovly_mapped
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Function: overlay_is_mapped (SECTION)    Returns true if section is an overlay, and is currently mapped.     Private: public access is thru function section_is_mapped.     Access to the ovly_mapped flag is restricted to this function, so    that we can do automatic update.  If the global flag    OVERLAY_CACHE_INVALID is set (by wait_for_inferior), then call    overlay_invalidate_all.  If the mapped state of the particular    section is stale, then call TARGET_OVERLAY_UPDATE to refresh it.  */
end_comment

begin_function
specifier|static
name|int
name|overlay_is_mapped
parameter_list|(
name|struct
name|obj_section
modifier|*
name|osect
parameter_list|)
block|{
if|if
condition|(
name|osect
operator|==
literal|0
operator|||
operator|!
name|section_is_overlay
argument_list|(
name|osect
operator|->
name|the_bfd_section
argument_list|)
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|overlay_debugging
condition|)
block|{
default|default:
case|case
name|ovly_off
case|:
return|return
literal|0
return|;
comment|/* overlay debugging off */
case|case
name|ovly_auto
case|:
comment|/* overlay debugging automatic */
comment|/* Unles there is a target_overlay_update function,           there's really nothing useful to do here (can't really go auto)  */
if|if
condition|(
name|target_overlay_update
condition|)
block|{
if|if
condition|(
name|overlay_cache_invalid
condition|)
block|{
name|overlay_invalidate_all
argument_list|()
expr_stmt|;
name|overlay_cache_invalid
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|osect
operator|->
name|ovly_mapped
operator|==
operator|-
literal|1
condition|)
call|(
modifier|*
name|target_overlay_update
call|)
argument_list|(
name|osect
argument_list|)
expr_stmt|;
block|}
comment|/* fall thru to manual case */
case|case
name|ovly_on
case|:
comment|/* overlay debugging manual */
return|return
name|osect
operator|->
name|ovly_mapped
operator|==
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/* Function: section_is_mapped    Returns true if section is an overlay, and is currently mapped.  */
end_comment

begin_function
name|int
name|section_is_mapped
parameter_list|(
name|asection
modifier|*
name|section
parameter_list|)
block|{
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|obj_section
modifier|*
name|osect
decl_stmt|;
if|if
condition|(
name|overlay_debugging
condition|)
if|if
condition|(
name|section
operator|&&
name|section_is_overlay
argument_list|(
name|section
argument_list|)
condition|)
name|ALL_OBJSECTIONS
argument_list|(
argument|objfile
argument_list|,
argument|osect
argument_list|)
if|if
condition|(
name|osect
operator|->
name|the_bfd_section
operator|==
name|section
condition|)
return|return
name|overlay_is_mapped
argument_list|(
name|osect
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Function: pc_in_unmapped_range    If PC falls into the lma range of SECTION, return true, else false.  */
end_comment

begin_function
name|CORE_ADDR
name|pc_in_unmapped_range
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|asection
modifier|*
name|section
parameter_list|)
block|{
comment|/* FIXME: need bfd *, so we can use bfd_section_lma methods. */
name|int
name|size
decl_stmt|;
if|if
condition|(
name|overlay_debugging
condition|)
if|if
condition|(
name|section
operator|&&
name|section_is_overlay
argument_list|(
name|section
argument_list|)
condition|)
block|{
name|size
operator|=
name|bfd_get_section_size_before_reloc
argument_list|(
name|section
argument_list|)
expr_stmt|;
if|if
condition|(
name|section
operator|->
name|lma
operator|<=
name|pc
operator|&&
name|pc
operator|<
name|section
operator|->
name|lma
operator|+
name|size
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Function: pc_in_mapped_range    If PC falls into the vma range of SECTION, return true, else false.  */
end_comment

begin_function
name|CORE_ADDR
name|pc_in_mapped_range
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|asection
modifier|*
name|section
parameter_list|)
block|{
comment|/* FIXME: need bfd *, so we can use bfd_section_vma methods. */
name|int
name|size
decl_stmt|;
if|if
condition|(
name|overlay_debugging
condition|)
if|if
condition|(
name|section
operator|&&
name|section_is_overlay
argument_list|(
name|section
argument_list|)
condition|)
block|{
name|size
operator|=
name|bfd_get_section_size_before_reloc
argument_list|(
name|section
argument_list|)
expr_stmt|;
if|if
condition|(
name|section
operator|->
name|vma
operator|<=
name|pc
operator|&&
name|pc
operator|<
name|section
operator|->
name|vma
operator|+
name|size
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return true if the mapped ranges of sections A and B overlap, false    otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|sections_overlap
parameter_list|(
name|asection
modifier|*
name|a
parameter_list|,
name|asection
modifier|*
name|b
parameter_list|)
block|{
comment|/* FIXME: need bfd *, so we can use bfd_section_vma methods. */
name|CORE_ADDR
name|a_start
init|=
name|a
operator|->
name|vma
decl_stmt|;
name|CORE_ADDR
name|a_end
init|=
name|a
operator|->
name|vma
operator|+
name|bfd_get_section_size_before_reloc
argument_list|(
name|a
argument_list|)
decl_stmt|;
name|CORE_ADDR
name|b_start
init|=
name|b
operator|->
name|vma
decl_stmt|;
name|CORE_ADDR
name|b_end
init|=
name|b
operator|->
name|vma
operator|+
name|bfd_get_section_size_before_reloc
argument_list|(
name|b
argument_list|)
decl_stmt|;
return|return
operator|(
name|a_start
operator|<
name|b_end
operator|&&
name|b_start
operator|<
name|a_end
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Function: overlay_unmapped_address (PC, SECTION)    Returns the address corresponding to PC in the unmapped (load) range.    May be the same as PC.  */
end_comment

begin_function
name|CORE_ADDR
name|overlay_unmapped_address
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|asection
modifier|*
name|section
parameter_list|)
block|{
comment|/* FIXME: need bfd *, so we can use bfd_section_lma methods. */
if|if
condition|(
name|overlay_debugging
condition|)
if|if
condition|(
name|section
operator|&&
name|section_is_overlay
argument_list|(
name|section
argument_list|)
operator|&&
name|pc_in_mapped_range
argument_list|(
name|pc
argument_list|,
name|section
argument_list|)
condition|)
return|return
name|pc
operator|+
name|section
operator|->
name|lma
operator|-
name|section
operator|->
name|vma
return|;
return|return
name|pc
return|;
block|}
end_function

begin_comment
comment|/* Function: overlay_mapped_address (PC, SECTION)    Returns the address corresponding to PC in the mapped (runtime) range.    May be the same as PC.  */
end_comment

begin_function
name|CORE_ADDR
name|overlay_mapped_address
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|asection
modifier|*
name|section
parameter_list|)
block|{
comment|/* FIXME: need bfd *, so we can use bfd_section_vma methods. */
if|if
condition|(
name|overlay_debugging
condition|)
if|if
condition|(
name|section
operator|&&
name|section_is_overlay
argument_list|(
name|section
argument_list|)
operator|&&
name|pc_in_unmapped_range
argument_list|(
name|pc
argument_list|,
name|section
argument_list|)
condition|)
return|return
name|pc
operator|+
name|section
operator|->
name|vma
operator|-
name|section
operator|->
name|lma
return|;
return|return
name|pc
return|;
block|}
end_function

begin_comment
comment|/* Function: symbol_overlayed_address     Return one of two addresses (relative to the VMA or to the LMA),    depending on whether the section is mapped or not.  */
end_comment

begin_function
name|CORE_ADDR
name|symbol_overlayed_address
parameter_list|(
name|CORE_ADDR
name|address
parameter_list|,
name|asection
modifier|*
name|section
parameter_list|)
block|{
if|if
condition|(
name|overlay_debugging
condition|)
block|{
comment|/* If the symbol has no section, just return its regular address. */
if|if
condition|(
name|section
operator|==
literal|0
condition|)
return|return
name|address
return|;
comment|/* If the symbol's section is not an overlay, just return its address */
if|if
condition|(
operator|!
name|section_is_overlay
argument_list|(
name|section
argument_list|)
condition|)
return|return
name|address
return|;
comment|/* If the symbol's section is mapped, just return its address */
if|if
condition|(
name|section_is_mapped
argument_list|(
name|section
argument_list|)
condition|)
return|return
name|address
return|;
comment|/*        * HOWEVER: if the symbol is in an overlay section which is NOT mapped,        * then return its LOADED address rather than its vma address!!        */
return|return
name|overlay_unmapped_address
argument_list|(
name|address
argument_list|,
name|section
argument_list|)
return|;
block|}
return|return
name|address
return|;
block|}
end_function

begin_comment
comment|/* Function: find_pc_overlay (PC)     Return the best-match overlay section for PC:    If PC matches a mapped overlay section's VMA, return that section.    Else if PC matches an unmapped section's VMA, return that section.    Else if PC matches an unmapped section's LMA, return that section.  */
end_comment

begin_function
name|asection
modifier|*
name|find_pc_overlay
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|obj_section
modifier|*
name|osect
decl_stmt|,
modifier|*
name|best_match
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|overlay_debugging
condition|)
name|ALL_OBJSECTIONS
argument_list|(
argument|objfile
argument_list|,
argument|osect
argument_list|)
if|if
condition|(
name|section_is_overlay
argument_list|(
name|osect
operator|->
name|the_bfd_section
argument_list|)
condition|)
block|{
if|if
condition|(
name|pc_in_mapped_range
argument_list|(
name|pc
argument_list|,
name|osect
operator|->
name|the_bfd_section
argument_list|)
condition|)
block|{
if|if
condition|(
name|overlay_is_mapped
argument_list|(
name|osect
argument_list|)
condition|)
return|return
name|osect
operator|->
name|the_bfd_section
return|;
else|else
name|best_match
operator|=
name|osect
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pc_in_unmapped_range
argument_list|(
name|pc
argument_list|,
name|osect
operator|->
name|the_bfd_section
argument_list|)
condition|)
name|best_match
operator|=
name|osect
expr_stmt|;
block|}
return|return
name|best_match
condition|?
name|best_match
operator|->
name|the_bfd_section
else|:
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Function: find_pc_mapped_section (PC)    If PC falls into the VMA address range of an overlay section that is     currently marked as MAPPED, return that section.  Else return NULL.  */
end_comment

begin_function
name|asection
modifier|*
name|find_pc_mapped_section
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|obj_section
modifier|*
name|osect
decl_stmt|;
if|if
condition|(
name|overlay_debugging
condition|)
name|ALL_OBJSECTIONS
argument_list|(
argument|objfile
argument_list|,
argument|osect
argument_list|)
if|if
condition|(
name|pc_in_mapped_range
argument_list|(
name|pc
argument_list|,
name|osect
operator|->
name|the_bfd_section
argument_list|)
operator|&&
name|overlay_is_mapped
argument_list|(
name|osect
argument_list|)
condition|)
return|return
name|osect
operator|->
name|the_bfd_section
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Function: list_overlays_command    Print a list of mapped sections and their PC ranges */
end_comment

begin_function
name|void
name|list_overlays_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|int
name|nmapped
init|=
literal|0
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|obj_section
modifier|*
name|osect
decl_stmt|;
if|if
condition|(
name|overlay_debugging
condition|)
name|ALL_OBJSECTIONS
argument_list|(
argument|objfile
argument_list|,
argument|osect
argument_list|)
if|if
condition|(
name|overlay_is_mapped
argument_list|(
name|osect
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|bfd_vma
name|lma
decl_stmt|,
name|vma
decl_stmt|;
name|int
name|size
decl_stmt|;
name|vma
operator|=
name|bfd_section_vma
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|osect
operator|->
name|the_bfd_section
argument_list|)
expr_stmt|;
name|lma
operator|=
name|bfd_section_lma
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|osect
operator|->
name|the_bfd_section
argument_list|)
expr_stmt|;
name|size
operator|=
name|bfd_get_section_size_before_reloc
argument_list|(
name|osect
operator|->
name|the_bfd_section
argument_list|)
expr_stmt|;
name|name
operator|=
name|bfd_section_name
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|osect
operator|->
name|the_bfd_section
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Section %s, loaded at "
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|lma
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
literal|" - "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|lma
operator|+
name|size
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|", mapped at "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|vma
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
literal|" - "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|vma
operator|+
name|size
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|nmapped
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|nmapped
operator|==
literal|0
condition|)
name|printf_filtered
argument_list|(
literal|"No sections are mapped.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Function: map_overlay_command    Mark the named section as mapped (ie. residing at its VMA address).  */
end_comment

begin_function
name|void
name|map_overlay_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|,
modifier|*
name|objfile2
decl_stmt|;
name|struct
name|obj_section
modifier|*
name|sec
decl_stmt|,
modifier|*
name|sec2
decl_stmt|;
name|asection
modifier|*
name|bfdsec
decl_stmt|;
if|if
condition|(
operator|!
name|overlay_debugging
condition|)
name|error
argument_list|(
literal|"\ Overlay debugging not enabled.  Use either the 'overlay auto' or\n\ the 'overlay manual' command."
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|==
literal|0
operator|||
operator|*
name|args
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Argument required: name of an overlay section"
argument_list|)
expr_stmt|;
comment|/* First, find a section matching the user supplied argument */
name|ALL_OBJSECTIONS
argument_list|(
argument|objfile
argument_list|,
argument|sec
argument_list|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|bfd_section_name
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|sec
operator|->
name|the_bfd_section
argument_list|)
argument_list|,
name|args
argument_list|)
condition|)
block|{
comment|/* Now, check to see if the section is an overlay. */
name|bfdsec
operator|=
name|sec
operator|->
name|the_bfd_section
expr_stmt|;
if|if
condition|(
operator|!
name|section_is_overlay
argument_list|(
name|bfdsec
argument_list|)
condition|)
continue|continue;
comment|/* not an overlay section */
comment|/* Mark the overlay as "mapped" */
name|sec
operator|->
name|ovly_mapped
operator|=
literal|1
expr_stmt|;
comment|/* Next, make a pass and unmap any sections that are          overlapped by this new section: */
name|ALL_OBJSECTIONS
argument_list|(
argument|objfile2
argument_list|,
argument|sec2
argument_list|)
if|if
condition|(
name|sec2
operator|->
name|ovly_mapped
operator|&&
name|sec
operator|!=
name|sec2
operator|&&
name|sec
operator|->
name|the_bfd_section
operator|!=
name|sec2
operator|->
name|the_bfd_section
operator|&&
name|sections_overlap
argument_list|(
name|sec
operator|->
name|the_bfd_section
argument_list|,
name|sec2
operator|->
name|the_bfd_section
argument_list|)
condition|)
block|{
if|if
condition|(
name|info_verbose
condition|)
name|printf_unfiltered
argument_list|(
literal|"Note: section %s unmapped by overlap\n"
argument_list|,
name|bfd_section_name
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|sec2
operator|->
name|the_bfd_section
argument_list|)
argument_list|)
expr_stmt|;
name|sec2
operator|->
name|ovly_mapped
operator|=
literal|0
expr_stmt|;
comment|/* sec2 overlaps sec: unmap sec2 */
block|}
return|return;
block|}
name|error
argument_list|(
literal|"No overlay section called %s"
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Function: unmap_overlay_command    Mark the overlay section as unmapped     (ie. resident in its LMA address range, rather than the VMA range).  */
end_comment

begin_function
name|void
name|unmap_overlay_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|obj_section
modifier|*
name|sec
decl_stmt|;
if|if
condition|(
operator|!
name|overlay_debugging
condition|)
name|error
argument_list|(
literal|"\ Overlay debugging not enabled.  Use either the 'overlay auto' or\n\ the 'overlay manual' command."
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|==
literal|0
operator|||
operator|*
name|args
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Argument required: name of an overlay section"
argument_list|)
expr_stmt|;
comment|/* First, find a section matching the user supplied argument */
name|ALL_OBJSECTIONS
argument_list|(
argument|objfile
argument_list|,
argument|sec
argument_list|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|bfd_section_name
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|sec
operator|->
name|the_bfd_section
argument_list|)
argument_list|,
name|args
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|sec
operator|->
name|ovly_mapped
condition|)
name|error
argument_list|(
literal|"Section %s is not mapped"
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|sec
operator|->
name|ovly_mapped
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|error
argument_list|(
literal|"No overlay section called %s"
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Function: overlay_auto_command    A utility command to turn on overlay debugging.    Possibly this should be done via a set/show command. */
end_comment

begin_function
specifier|static
name|void
name|overlay_auto_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|overlay_debugging
operator|=
name|ovly_auto
expr_stmt|;
name|enable_overlay_breakpoints
argument_list|()
expr_stmt|;
if|if
condition|(
name|info_verbose
condition|)
name|printf_unfiltered
argument_list|(
literal|"Automatic overlay debugging enabled."
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Function: overlay_manual_command    A utility command to turn on overlay debugging.    Possibly this should be done via a set/show command. */
end_comment

begin_function
specifier|static
name|void
name|overlay_manual_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|overlay_debugging
operator|=
name|ovly_on
expr_stmt|;
name|disable_overlay_breakpoints
argument_list|()
expr_stmt|;
if|if
condition|(
name|info_verbose
condition|)
name|printf_unfiltered
argument_list|(
literal|"Overlay debugging enabled."
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Function: overlay_off_command    A utility command to turn on overlay debugging.    Possibly this should be done via a set/show command. */
end_comment

begin_function
specifier|static
name|void
name|overlay_off_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|overlay_debugging
operator|=
name|ovly_off
expr_stmt|;
name|disable_overlay_breakpoints
argument_list|()
expr_stmt|;
if|if
condition|(
name|info_verbose
condition|)
name|printf_unfiltered
argument_list|(
literal|"Overlay debugging disabled."
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|overlay_load_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
if|if
condition|(
name|target_overlay_update
condition|)
call|(
modifier|*
name|target_overlay_update
call|)
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"This target does not know how to read its overlay state."
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Function: overlay_command    A place-holder for a mis-typed command */
end_comment

begin_comment
comment|/* Command list chain containing all defined "overlay" subcommands. */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|overlaylist
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|overlay_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|printf_unfiltered
argument_list|(
literal|"\"overlay\" must be followed by the name of an overlay command.\n"
argument_list|)
expr_stmt|;
name|help_list
argument_list|(
name|overlaylist
argument_list|,
literal|"overlay "
argument_list|,
operator|-
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Target Overlays for the "Simplest" overlay manager:     This is GDB's default target overlay layer.  It works with the     minimal overlay manager supplied as an example by Cygnus.  The     entry point is via a function pointer "target_overlay_update",     so targets that use a different runtime overlay manager can     substitute their own overlay_update function and take over the    function pointer.     The overlay_update function pokes around in the target's data structures    to see what overlays are mapped, and updates GDB's overlay mapping with    this information.     In this simple implementation, the target data structures are as follows:    unsigned _novlys;            /# number of overlay sections #/    unsigned _ovly_table[_novlys][4] = {    {VMA, SIZE, LMA, MAPPED},    /# one entry per overlay section #/    {..., ...,  ..., ...},    }    unsigned _novly_regions;     /# number of overlay regions #/    unsigned _ovly_region_table[_novly_regions][3] = {    {VMA, SIZE, MAPPED_TO_LMA},  /# one entry per overlay region #/    {..., ...,  ...},    }    These functions will attempt to update GDB's mappedness state in the    symbol section table, based on the target's mappedness state.     To do this, we keep a cached copy of the target's _ovly_table, and    attempt to detect when the cached copy is invalidated.  The main    entry point is "simple_overlay_update(SECT), which looks up SECT in    the cached table and re-reads only the entry for that section from    the target (whenever possible).  */
end_comment

begin_comment
comment|/* Cached, dynamically allocated copies of the target data structures: */
end_comment

begin_expr_stmt
specifier|static
name|unsigned
argument_list|(
operator|*
name|cache_ovly_table
argument_list|)
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static unsigned (*cache_ovly_region_table)[3] = 0;
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|unsigned
name|cache_novlys
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static unsigned cache_novly_regions = 0;
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|cache_ovly_table_base
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static CORE_ADDR cache_ovly_region_table_base = 0;
endif|#
directive|endif
end_endif

begin_enum
enum|enum
name|ovly_index
block|{
name|VMA
block|,
name|SIZE
block|,
name|LMA
block|,
name|MAPPED
block|}
enum|;
end_enum

begin_define
define|#
directive|define
name|TARGET_LONG_BYTES
value|(TARGET_LONG_BIT / TARGET_CHAR_BIT)
end_define

begin_comment
comment|/* Throw away the cached copy of _ovly_table */
end_comment

begin_function
specifier|static
name|void
name|simple_free_overlay_table
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|cache_ovly_table
condition|)
name|xfree
argument_list|(
name|cache_ovly_table
argument_list|)
expr_stmt|;
name|cache_novlys
operator|=
literal|0
expr_stmt|;
name|cache_ovly_table
operator|=
name|NULL
expr_stmt|;
name|cache_ovly_table_base
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Throw away the cached copy of _ovly_region_table */
end_comment

begin_endif
unit|static void simple_free_overlay_region_table (void) {   if (cache_ovly_region_table)     xfree (cache_ovly_region_table);   cache_novly_regions = 0;   cache_ovly_region_table = NULL;   cache_ovly_region_table_base = 0; }
endif|#
directive|endif
end_endif

begin_comment
comment|/* Read an array of ints from the target into a local buffer.    Convert to host order.  int LEN is number of ints  */
end_comment

begin_function
specifier|static
name|void
name|read_target_long_array
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|unsigned
name|int
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
comment|/* FIXME (alloca): Not safe if array is very large. */
name|char
modifier|*
name|buf
init|=
name|alloca
argument_list|(
name|len
operator|*
name|TARGET_LONG_BYTES
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|read_memory
argument_list|(
name|memaddr
argument_list|,
name|buf
argument_list|,
name|len
operator|*
name|TARGET_LONG_BYTES
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|myaddr
index|[
name|i
index|]
operator|=
name|extract_unsigned_integer
argument_list|(
name|TARGET_LONG_BYTES
operator|*
name|i
operator|+
name|buf
argument_list|,
name|TARGET_LONG_BYTES
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find and grab a copy of the target _ovly_table    (and _novlys, which is needed for the table's size) */
end_comment

begin_function
specifier|static
name|int
name|simple_read_overlay_table
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|minimal_symbol
modifier|*
name|novlys_msym
decl_stmt|,
modifier|*
name|ovly_table_msym
decl_stmt|;
name|simple_free_overlay_table
argument_list|()
expr_stmt|;
name|novlys_msym
operator|=
name|lookup_minimal_symbol
argument_list|(
literal|"_novlys"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|novlys_msym
condition|)
block|{
name|error
argument_list|(
literal|"Error reading inferior's overlay table: "
literal|"couldn't find `_novlys' variable\n"
literal|"in inferior.  Use `overlay manual' mode."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|ovly_table_msym
operator|=
name|lookup_minimal_symbol
argument_list|(
literal|"_ovly_table"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ovly_table_msym
condition|)
block|{
name|error
argument_list|(
literal|"Error reading inferior's overlay table: couldn't find "
literal|"`_ovly_table' array\n"
literal|"in inferior.  Use `overlay manual' mode."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|cache_novlys
operator|=
name|read_memory_integer
argument_list|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|novlys_msym
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|cache_ovly_table
operator|=
operator|(
name|void
operator|*
operator|)
name|xmalloc
argument_list|(
name|cache_novlys
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|cache_ovly_table
argument_list|)
argument_list|)
expr_stmt|;
name|cache_ovly_table_base
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|ovly_table_msym
argument_list|)
expr_stmt|;
name|read_target_long_array
argument_list|(
name|cache_ovly_table_base
argument_list|,
operator|(
name|int
operator|*
operator|)
name|cache_ovly_table
argument_list|,
name|cache_novlys
operator|*
literal|4
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
comment|/* SUCCESS */
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Find and grab a copy of the target _ovly_region_table    (and _novly_regions, which is needed for the table's size) */
end_comment

begin_comment
unit|static int simple_read_overlay_region_table (void) {   struct minimal_symbol *msym;    simple_free_overlay_region_table ();   msym = lookup_minimal_symbol ("_novly_regions", NULL, NULL);   if (msym != NULL)     cache_novly_regions = read_memory_integer (SYMBOL_VALUE_ADDRESS (msym), 4);   else     return 0;
comment|/* failure */
end_comment

begin_comment
unit|cache_ovly_region_table = (void *) xmalloc (cache_novly_regions * 12);   if (cache_ovly_region_table != NULL)     {       msym = lookup_minimal_symbol ("_ovly_region_table", NULL, NULL);       if (msym != NULL) 	{ 	  cache_ovly_region_table_base = SYMBOL_VALUE_ADDRESS (msym); 	  read_target_long_array (cache_ovly_region_table_base, 				  (int *) cache_ovly_region_table, 				  cache_novly_regions * 3); 	}       else 	return 0;
comment|/* failure */
end_comment

begin_comment
unit|}   else     return 0;
comment|/* failure */
end_comment

begin_comment
unit|return 1;
comment|/* SUCCESS */
end_comment

begin_endif
unit|}
endif|#
directive|endif
end_endif

begin_comment
comment|/* Function: simple_overlay_update_1     A helper function for simple_overlay_update.  Assuming a cached copy    of _ovly_table exists, look through it to find an entry whose vma,    lma and size match those of OSECT.  Re-read the entry and make sure    it still matches OSECT (else the table may no longer be valid).    Set OSECT's mapped state to match the entry.  Return: 1 for    success, 0 for failure.  */
end_comment

begin_function
specifier|static
name|int
name|simple_overlay_update_1
parameter_list|(
name|struct
name|obj_section
modifier|*
name|osect
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|size
decl_stmt|;
name|bfd
modifier|*
name|obfd
init|=
name|osect
operator|->
name|objfile
operator|->
name|obfd
decl_stmt|;
name|asection
modifier|*
name|bsect
init|=
name|osect
operator|->
name|the_bfd_section
decl_stmt|;
name|size
operator|=
name|bfd_get_section_size_before_reloc
argument_list|(
name|osect
operator|->
name|the_bfd_section
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cache_novlys
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|cache_ovly_table
index|[
name|i
index|]
index|[
name|VMA
index|]
operator|==
name|bfd_section_vma
argument_list|(
name|obfd
argument_list|,
name|bsect
argument_list|)
operator|&&
name|cache_ovly_table
index|[
name|i
index|]
index|[
name|LMA
index|]
operator|==
name|bfd_section_lma
argument_list|(
name|obfd
argument_list|,
name|bsect
argument_list|)
comment|/*&& cache_ovly_table[i][SIZE] == size */
condition|)
block|{
name|read_target_long_array
argument_list|(
name|cache_ovly_table_base
operator|+
name|i
operator|*
name|TARGET_LONG_BYTES
argument_list|,
operator|(
name|int
operator|*
operator|)
name|cache_ovly_table
index|[
name|i
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|cache_ovly_table
index|[
name|i
index|]
index|[
name|VMA
index|]
operator|==
name|bfd_section_vma
argument_list|(
name|obfd
argument_list|,
name|bsect
argument_list|)
operator|&&
name|cache_ovly_table
index|[
name|i
index|]
index|[
name|LMA
index|]
operator|==
name|bfd_section_lma
argument_list|(
name|obfd
argument_list|,
name|bsect
argument_list|)
comment|/*&& cache_ovly_table[i][SIZE] == size */
condition|)
block|{
name|osect
operator|->
name|ovly_mapped
operator|=
name|cache_ovly_table
index|[
name|i
index|]
index|[
name|MAPPED
index|]
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
comment|/* Warning!  Warning!  Target's ovly table has changed! */
return|return
literal|0
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Function: simple_overlay_update    If OSECT is NULL, then update all sections' mapped state     (after re-reading the entire target _ovly_table).     If OSECT is non-NULL, then try to find a matching entry in the     cached ovly_table and update only OSECT's mapped state.    If a cached entry can't be found or the cache isn't valid, then     re-read the entire cache, and go ahead and update all sections.  */
end_comment

begin_function
specifier|static
name|void
name|simple_overlay_update
parameter_list|(
name|struct
name|obj_section
modifier|*
name|osect
parameter_list|)
block|{
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
comment|/* Were we given an osect to look up?  NULL means do all of them. */
if|if
condition|(
name|osect
condition|)
comment|/* Have we got a cached copy of the target's overlay table? */
if|if
condition|(
name|cache_ovly_table
operator|!=
name|NULL
condition|)
comment|/* Does its cached location match what's currently in the symtab? */
if|if
condition|(
name|cache_ovly_table_base
operator|==
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|lookup_minimal_symbol
argument_list|(
literal|"_ovly_table"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
argument_list|)
condition|)
comment|/* Then go ahead and try to look up this single section in the cache */
if|if
condition|(
name|simple_overlay_update_1
argument_list|(
name|osect
argument_list|)
condition|)
comment|/* Found it!  We're done. */
return|return;
comment|/* Cached table no good: need to read the entire table anew.      Or else we want all the sections, in which case it's actually      more efficient to read the whole table in one block anyway.  */
if|if
condition|(
operator|!
name|simple_read_overlay_table
argument_list|()
condition|)
return|return;
comment|/* Now may as well update all sections, even if only one was requested. */
name|ALL_OBJSECTIONS
argument_list|(
argument|objfile
argument_list|,
argument|osect
argument_list|)
if|if
condition|(
name|section_is_overlay
argument_list|(
name|osect
operator|->
name|the_bfd_section
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|,
name|size
decl_stmt|;
name|bfd
modifier|*
name|obfd
init|=
name|osect
operator|->
name|objfile
operator|->
name|obfd
decl_stmt|;
name|asection
modifier|*
name|bsect
init|=
name|osect
operator|->
name|the_bfd_section
decl_stmt|;
name|size
operator|=
name|bfd_get_section_size_before_reloc
argument_list|(
name|osect
operator|->
name|the_bfd_section
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cache_novlys
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|cache_ovly_table
index|[
name|i
index|]
index|[
name|VMA
index|]
operator|==
name|bfd_section_vma
argument_list|(
name|obfd
argument_list|,
name|bsect
argument_list|)
operator|&&
name|cache_ovly_table
index|[
name|i
index|]
index|[
name|LMA
index|]
operator|==
name|bfd_section_lma
argument_list|(
name|obfd
argument_list|,
name|bsect
argument_list|)
comment|/*&& cache_ovly_table[i][SIZE] == size */
condition|)
block|{
comment|/* obj_section matches i'th entry in ovly_table */
name|osect
operator|->
name|ovly_mapped
operator|=
name|cache_ovly_table
index|[
name|i
index|]
index|[
name|MAPPED
index|]
expr_stmt|;
break|break;
comment|/* finished with inner for loop: break out */
block|}
block|}
block|}
end_function

begin_comment
comment|/* Set the output sections and output offsets for section SECTP in    ABFD.  The relocation code in BFD will read these offsets, so we    need to be sure they're initialized.  We map each section to itself,    with no offset; this means that SECTP->vma will be honored.  */
end_comment

begin_function
specifier|static
name|void
name|symfile_dummy_outputs
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sectp
parameter_list|,
name|void
modifier|*
name|dummy
parameter_list|)
block|{
name|sectp
operator|->
name|output_section
operator|=
name|sectp
expr_stmt|;
name|sectp
operator|->
name|output_offset
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Relocate the contents of a debug section SECTP in ABFD.  The    contents are stored in BUF if it is non-NULL, or returned in a    malloc'd buffer otherwise.     For some platforms and debug info formats, shared libraries contain    relocations against the debug sections (particularly for DWARF-2;    one affected platform is PowerPC GNU/Linux, although it depends on    the version of the linker in use).  Also, ELF object files naturally    have unresolved relocations for their debug sections.  We need to apply    the relocations in order to get the locations of symbols correct.  */
end_comment

begin_function
name|bfd_byte
modifier|*
name|symfile_relocate_debug_section
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sectp
parameter_list|,
name|bfd_byte
modifier|*
name|buf
parameter_list|)
block|{
comment|/* We're only interested in debugging sections with relocation      information.  */
if|if
condition|(
operator|(
name|sectp
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|(
name|sectp
operator|->
name|flags
operator|&
name|SEC_DEBUGGING
operator|)
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
comment|/* We will handle section offsets properly elsewhere, so relocate as if      all sections begin at 0.  */
name|bfd_map_over_sections
argument_list|(
name|abfd
argument_list|,
name|symfile_dummy_outputs
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|bfd_simple_get_relocated_section_contents
argument_list|(
name|abfd
argument_list|,
name|sectp
argument_list|,
name|buf
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|_initialize_symfile
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
name|c
operator|=
name|add_cmd
argument_list|(
literal|"symbol-file"
argument_list|,
name|class_files
argument_list|,
name|symbol_file_command
argument_list|,
literal|"Load symbol table from executable file FILE.\n\ The `file' command can also load symbol tables, as well as setting the file\n\ to execute."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|set_cmd_completer
argument_list|(
name|c
argument_list|,
name|filename_completer
argument_list|)
expr_stmt|;
name|c
operator|=
name|add_cmd
argument_list|(
literal|"add-symbol-file"
argument_list|,
name|class_files
argument_list|,
name|add_symbol_file_command
argument_list|,
literal|"Usage: add-symbol-file FILE ADDR [-s<SECT><SECT_ADDR> -s<SECT><SECT_ADDR> ...]\n\ Load the symbols from FILE, assuming FILE has been dynamically loaded.\n\ ADDR is the starting address of the file's text.\n\ The optional arguments are section-name section-address pairs and\n\ should be specified if the data and bss segments are not contiguous\n\ with the text.  SECT is a section name to be loaded at SECT_ADDR."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|set_cmd_completer
argument_list|(
name|c
argument_list|,
name|filename_completer
argument_list|)
expr_stmt|;
name|c
operator|=
name|add_cmd
argument_list|(
literal|"add-shared-symbol-files"
argument_list|,
name|class_files
argument_list|,
name|add_shared_symbol_files_command
argument_list|,
literal|"Load the symbols from shared objects in the dynamic linker's link map."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|c
operator|=
name|add_alias_cmd
argument_list|(
literal|"assf"
argument_list|,
literal|"add-shared-symbol-files"
argument_list|,
name|class_files
argument_list|,
literal|1
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|c
operator|=
name|add_cmd
argument_list|(
literal|"load"
argument_list|,
name|class_files
argument_list|,
name|load_command
argument_list|,
literal|"Dynamically load FILE into the running program, and record its symbols\n\ for access from GDB."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|set_cmd_completer
argument_list|(
name|c
argument_list|,
name|filename_completer
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"symbol-reloading"
argument_list|,
name|class_support
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|symbol_reloading
argument_list|,
literal|"Set dynamic symbol table reloading multiple times in one run."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"overlay"
argument_list|,
name|class_support
argument_list|,
name|overlay_command
argument_list|,
literal|"Commands for debugging overlays."
argument_list|,
operator|&
name|overlaylist
argument_list|,
literal|"overlay "
argument_list|,
literal|0
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"ovly"
argument_list|,
literal|"overlay"
argument_list|,
name|class_alias
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"ov"
argument_list|,
literal|"overlay"
argument_list|,
name|class_alias
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"map-overlay"
argument_list|,
name|class_support
argument_list|,
name|map_overlay_command
argument_list|,
literal|"Assert that an overlay section is mapped."
argument_list|,
operator|&
name|overlaylist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"unmap-overlay"
argument_list|,
name|class_support
argument_list|,
name|unmap_overlay_command
argument_list|,
literal|"Assert that an overlay section is unmapped."
argument_list|,
operator|&
name|overlaylist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"list-overlays"
argument_list|,
name|class_support
argument_list|,
name|list_overlays_command
argument_list|,
literal|"List mappings of overlay sections."
argument_list|,
operator|&
name|overlaylist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"manual"
argument_list|,
name|class_support
argument_list|,
name|overlay_manual_command
argument_list|,
literal|"Enable overlay debugging."
argument_list|,
operator|&
name|overlaylist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"off"
argument_list|,
name|class_support
argument_list|,
name|overlay_off_command
argument_list|,
literal|"Disable overlay debugging."
argument_list|,
operator|&
name|overlaylist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"auto"
argument_list|,
name|class_support
argument_list|,
name|overlay_auto_command
argument_list|,
literal|"Enable automatic overlay debugging."
argument_list|,
operator|&
name|overlaylist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"load-target"
argument_list|,
name|class_support
argument_list|,
name|overlay_load_command
argument_list|,
literal|"Read the overlay mapping state from the target."
argument_list|,
operator|&
name|overlaylist
argument_list|)
expr_stmt|;
comment|/* Filename extension to source language lookup table: */
name|init_filename_language_table
argument_list|()
expr_stmt|;
name|c
operator|=
name|add_set_cmd
argument_list|(
literal|"extension-language"
argument_list|,
name|class_files
argument_list|,
name|var_string_noescape
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ext_args
argument_list|,
literal|"Set mapping between filename extension and source language.\n\ Usage: set extension-language .foo bar"
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|set_cmd_cfunc
argument_list|(
name|c
argument_list|,
name|set_ext_lang_command
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"extensions"
argument_list|,
name|info_ext_lang_command
argument_list|,
literal|"All filename extensions associated with a source language."
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"download-write-size"
argument_list|,
name|class_obscure
argument_list|,
name|var_integer
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|download_write_size
argument_list|,
literal|"Set the write size used when downloading a program.\n"
literal|"Only used when downloading a program onto a remote\n"
literal|"target. Specify zero, or a negative value, to disable\n"
literal|"blocked writes. The actual size of each transfer is also\n"
literal|"limited by the size of the target packet and the memory\n"
literal|"cache.\n"
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|debug_file_directory
operator|=
name|xstrdup
argument_list|(
name|DEBUGDIR
argument_list|)
expr_stmt|;
name|c
operator|=
operator|(
name|add_set_cmd
argument_list|(
literal|"debug-file-directory"
argument_list|,
name|class_support
argument_list|,
name|var_string
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|debug_file_directory
argument_list|,
literal|"Set the directory where separate debug symbols are searched for.\n"
literal|"Separate debug symbols are first searched for in the same\n"
literal|"directory as the binary, then in the `"
name|DEBUG_SUBDIRECTORY
literal|"' subdirectory,\n"
literal|"and lastly at the path of the directory of the binary with\n"
literal|"the global debug-file directory prepended\n"
argument_list|,
operator|&
name|setlist
argument_list|)
operator|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|c
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|set_cmd_completer
argument_list|(
name|c
argument_list|,
name|filename_completer
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

