begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Generic symbol file reading for the GNU debugger, GDB.    Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998    Free Software Foundation, Inc.    Contributed by Cygnus Support, using pieces from other GDB modules.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"breakpoint.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"complaints.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_comment
comment|/* for write_pc */
end_comment

begin_include
include|#
directive|include
file|"gdb-stabs.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"gdb_stat.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|O_BINARY
end_ifndef

begin_define
define|#
directive|define
name|O_BINARY
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HPUXHPPA
end_ifdef

begin_comment
comment|/* Some HP-UX related globals to clear when a new "main"    symbol file is loaded. HP-specific.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|hp_som_som_object_present
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|hp_cxx_exception_support_initialized
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|RESET_HP_UX_GLOBALS
parameter_list|()
value|do {\                                     hp_som_som_object_present = 0;
comment|/* indicates HP-compiled code */
value|\                                     hp_cxx_exception_support_initialized = 0;
comment|/* must reinitialize exception stuff */
value|\                               } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|int
argument_list|(
argument|*ui_load_progress_hook
argument_list|)
end_macro

begin_expr_stmt
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|unsigned
name|long
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|void
argument_list|(
argument|*pre_add_symbol_hook
argument_list|)
end_macro

begin_expr_stmt
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|void
argument_list|(
argument|*post_add_symbol_hook
argument_list|)
end_macro

begin_expr_stmt
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Global variables owned by this file */
end_comment

begin_decl_stmt
name|int
name|readnow_symbol_files
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Read full symbols immediately */
end_comment

begin_decl_stmt
name|struct
name|complaint
name|oldsyms_complaint
init|=
block|{
literal|"Replacing old symbols for `%s'"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|empty_symtab_complaint
init|=
block|{
literal|"Empty symbol table found for `%s'"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* External variables and functions referenced. */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|info_verbose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|report_transfer_performance
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|long
operator|,
name|time_t
operator|,
name|time_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Functions this file defines */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static int simple_read_overlay_region_table PARAMS ((void)); static void simple_free_overlay_region_table PARAMS ((void));
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|set_initial_language
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|load_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_symbol_file_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_shared_symbol_files_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cashier_psymtab
name|PARAMS
argument_list|(
operator|(
expr|struct
name|partial_symtab
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|compare_psymbols
name|PARAMS
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|,
specifier|const
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|compare_symbols
name|PARAMS
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|,
specifier|const
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bfd
modifier|*
name|symfile_bfd_open
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|find_sym_fns
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|decrement_reading_symtab
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|overlay_invalidate_all
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|overlay_is_mapped
name|PARAMS
argument_list|(
operator|(
expr|struct
name|obj_section
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|list_overlays_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|map_overlay_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|unmap_overlay_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|overlay_auto_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|overlay_manual_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|overlay_off_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|overlay_load_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|overlay_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|simple_free_overlay_table
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|read_target_long_array
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
operator|,
name|unsigned
name|int
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|simple_read_overlay_table
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|simple_overlay_update_1
name|PARAMS
argument_list|(
operator|(
expr|struct
name|obj_section
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|_initialize_symfile
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of all available sym_fns.  On gdb startup, each object file reader    calls add_symtab_fns() to register information on each format it is    prepared to read. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sym_fns
modifier|*
name|symtab_fns
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag for whether user will be reloading symbols multiple times.    Defaults to ON for VxWorks, otherwise OFF.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SYMBOL_RELOADING_DEFAULT
end_ifdef

begin_decl_stmt
name|int
name|symbol_reloading
init|=
name|SYMBOL_RELOADING_DEFAULT
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|symbol_reloading
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* If non-zero, then on HP-UX (i.e., platforms that use somsolib.c),    this variable is interpreted as a threshhold.  If adding a new    library's symbol table to those already known to the debugger would    exceed this threshhold, then the shlib's symbols are not added.     If non-zero on other platforms, shared library symbols will be added    automatically when the inferior is created, new libraries are loaded,    or when attaching to the inferior.  This is almost always what users    will want to have happen; but for very large programs, the startup    time will be excessive, and so if this is a problem, the user can    clear this flag and then add the shared library symbols as needed.    Note that there is a potential for confusion, since if the shared    library symbols are not loaded, commands like "info fun" will *not*    report all the functions that are actually present.      Note that HP-UX interprets this variable to mean, "threshhold size    in megabytes, where zero means never add".  Other platforms interpret    this variable to mean, "always add if non-zero, never add if zero."    */
end_comment

begin_decl_stmt
name|int
name|auto_solib_add
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Since this function is called from within qsort, in an ANSI environment    it must conform to the prototype for qsort, which specifies that the    comparison function takes two "void *" pointers. */
end_comment

begin_function
specifier|static
name|int
name|compare_symbols
parameter_list|(
name|s1p
parameter_list|,
name|s2p
parameter_list|)
specifier|const
name|PTR
name|s1p
decl_stmt|;
specifier|const
name|PTR
name|s2p
decl_stmt|;
block|{
specifier|register
name|struct
name|symbol
modifier|*
modifier|*
name|s1
decl_stmt|,
modifier|*
modifier|*
name|s2
decl_stmt|;
name|s1
operator|=
operator|(
expr|struct
name|symbol
operator|*
operator|*
operator|)
name|s1p
expr_stmt|;
name|s2
operator|=
operator|(
expr|struct
name|symbol
operator|*
operator|*
operator|)
name|s2p
expr_stmt|;
return|return
operator|(
name|STRCMP
argument_list|(
name|SYMBOL_NAME
argument_list|(
operator|*
name|s1
argument_list|)
argument_list|,
name|SYMBOL_NAME
argument_list|(
operator|*
name|s2
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	compare_psymbols -- compare two partial symbols by name  DESCRIPTION  	Given pointers to pointers to two partial symbol table entries, 	compare them by name and return -N, 0, or +N (ala strcmp). 	Typically used by sorting routines like qsort().  NOTES  	Does direct compare of first two characters before punting 	and passing to strcmp for longer compares.  Note that the 	original version had a bug whereby two null strings or two 	identically named one character strings would return the 	comparison of memory following the null byte.   */
end_comment

begin_function
specifier|static
name|int
name|compare_psymbols
parameter_list|(
name|s1p
parameter_list|,
name|s2p
parameter_list|)
specifier|const
name|PTR
name|s1p
decl_stmt|;
specifier|const
name|PTR
name|s2p
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|st1
init|=
name|SYMBOL_NAME
argument_list|(
operator|*
operator|(
expr|struct
name|partial_symbol
operator|*
operator|*
operator|)
name|s1p
argument_list|)
decl_stmt|;
specifier|register
name|char
modifier|*
name|st2
init|=
name|SYMBOL_NAME
argument_list|(
operator|*
operator|(
expr|struct
name|partial_symbol
operator|*
operator|*
operator|)
name|s2p
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|st1
index|[
literal|0
index|]
operator|-
name|st2
index|[
literal|0
index|]
operator|)
operator|||
operator|!
name|st1
index|[
literal|0
index|]
condition|)
block|{
return|return
operator|(
name|st1
index|[
literal|0
index|]
operator|-
name|st2
index|[
literal|0
index|]
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|st1
index|[
literal|1
index|]
operator|-
name|st2
index|[
literal|1
index|]
operator|)
operator|||
operator|!
name|st1
index|[
literal|1
index|]
condition|)
block|{
return|return
operator|(
name|st1
index|[
literal|1
index|]
operator|-
name|st2
index|[
literal|1
index|]
operator|)
return|;
block|}
else|else
block|{
comment|/* Note: I replaced the STRCMP line (commented out below)        * with a simpler "strcmp()" which compares the 2 strings        * from the beginning. (STRCMP is a macro which first compares        * the initial characters, then falls back on strcmp).        * The reason is that the STRCMP line was tickling a C compiler        * bug on HP-UX 10.30, which is avoided with the simpler        * code. The performance gain from the more complicated code        * is negligible, given that we have already checked the        * initial 2 characters above. I reported the compiler bug,        * and once it is fixed the original line can be put back. RT        */
comment|/* return ( STRCMP (st1 + 2, st2 + 2)); */
return|return
operator|(
name|strcmp
argument_list|(
name|st1
argument_list|,
name|st2
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_function
name|void
name|sort_pst_symbols
parameter_list|(
name|pst
parameter_list|)
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
block|{
comment|/* Sort the global list; don't sort the static list */
name|qsort
argument_list|(
name|pst
operator|->
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
operator|+
name|pst
operator|->
name|globals_offset
argument_list|,
name|pst
operator|->
name|n_global_syms
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|partial_symbol
operator|*
argument_list|)
argument_list|,
name|compare_psymbols
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Call sort_block_syms to sort alphabetically the symbols of one block.  */
end_comment

begin_function
name|void
name|sort_block_syms
parameter_list|(
name|b
parameter_list|)
specifier|register
name|struct
name|block
modifier|*
name|b
decl_stmt|;
block|{
name|qsort
argument_list|(
operator|&
name|BLOCK_SYM
argument_list|(
name|b
argument_list|,
literal|0
argument_list|)
argument_list|,
name|BLOCK_NSYMS
argument_list|(
name|b
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
operator|*
argument_list|)
argument_list|,
name|compare_symbols
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Call sort_symtab_syms to sort alphabetically    the symbols of each block of one symtab.  */
end_comment

begin_function
name|void
name|sort_symtab_syms
parameter_list|(
name|s
parameter_list|)
specifier|register
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|struct
name|blockvector
modifier|*
name|bv
decl_stmt|;
name|int
name|nbl
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|block
modifier|*
name|b
decl_stmt|;
if|if
condition|(
name|s
operator|==
literal|0
condition|)
return|return;
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|nbl
operator|=
name|BLOCKVECTOR_NBLOCKS
argument_list|(
name|bv
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbl
condition|;
name|i
operator|++
control|)
block|{
name|b
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|BLOCK_SHOULD_SORT
argument_list|(
name|b
argument_list|)
condition|)
name|sort_block_syms
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Make a null terminated copy of the string at PTR with SIZE characters in    the obstack pointed to by OBSTACKP .  Returns the address of the copy.    Note that the string at PTR does not have to be null terminated, I.E. it    may be part of a larger string and we are only saving a substring. */
end_comment

begin_function
name|char
modifier|*
name|obsavestring
parameter_list|(
name|ptr
parameter_list|,
name|size
parameter_list|,
name|obstackp
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|size
decl_stmt|;
name|struct
name|obstack
modifier|*
name|obstackp
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
init|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
name|obstackp
argument_list|,
name|size
operator|+
literal|1
argument_list|)
decl_stmt|;
comment|/* Open-coded memcpy--saves function call time.  These strings are usually      short.  FIXME: Is this really still true with a compiler that can      inline memcpy? */
block|{
specifier|register
name|char
modifier|*
name|p1
init|=
name|ptr
decl_stmt|;
specifier|register
name|char
modifier|*
name|p2
init|=
name|p
decl_stmt|;
name|char
modifier|*
name|end
init|=
name|ptr
operator|+
name|size
decl_stmt|;
while|while
condition|(
name|p1
operator|!=
name|end
condition|)
operator|*
name|p2
operator|++
operator|=
operator|*
name|p1
operator|++
expr_stmt|;
block|}
name|p
index|[
name|size
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Concatenate strings S1, S2 and S3; return the new string.  Space is found    in the obstack pointed to by OBSTACKP.  */
end_comment

begin_function
name|char
modifier|*
name|obconcat
parameter_list|(
name|obstackp
parameter_list|,
name|s1
parameter_list|,
name|s2
parameter_list|,
name|s3
parameter_list|)
name|struct
name|obstack
modifier|*
name|obstackp
decl_stmt|;
specifier|const
name|char
modifier|*
name|s1
decl_stmt|,
decl|*
name|s2
decl_stmt|,
modifier|*
name|s3
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|int
name|len
init|=
name|strlen
argument_list|(
name|s1
argument_list|)
operator|+
name|strlen
argument_list|(
name|s2
argument_list|)
operator|+
name|strlen
argument_list|(
name|s3
argument_list|)
operator|+
literal|1
decl_stmt|;
specifier|register
name|char
modifier|*
name|val
init|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
name|obstackp
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|val
argument_list|,
name|s1
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|val
argument_list|,
name|s2
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|val
argument_list|,
name|s3
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_block

begin_comment
comment|/* True if we are nested inside psymtab_to_symtab. */
end_comment

begin_decl_stmt
name|int
name|currently_reading_symtab
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|decrement_reading_symtab
parameter_list|(
name|dummy
parameter_list|)
name|void
modifier|*
name|dummy
decl_stmt|;
block|{
name|currently_reading_symtab
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get the symbol table that corresponds to a partial_symtab.    This is fast after the first time you do it.  In fact, there    is an even faster macro PSYMTAB_TO_SYMTAB that does the fast    case inline.  */
end_comment

begin_function
name|struct
name|symtab
modifier|*
name|psymtab_to_symtab
parameter_list|(
name|pst
parameter_list|)
specifier|register
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
block|{
comment|/* If it's been looked up before, return it. */
if|if
condition|(
name|pst
operator|->
name|symtab
condition|)
return|return
name|pst
operator|->
name|symtab
return|;
comment|/* If it has not yet been read in, read it.  */
if|if
condition|(
operator|!
name|pst
operator|->
name|readin
condition|)
block|{
name|struct
name|cleanup
modifier|*
name|back_to
init|=
name|make_cleanup
argument_list|(
name|decrement_reading_symtab
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|currently_reading_symtab
operator|++
expr_stmt|;
call|(
modifier|*
name|pst
operator|->
name|read_symtab
call|)
argument_list|(
name|pst
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|back_to
argument_list|)
expr_stmt|;
block|}
return|return
name|pst
operator|->
name|symtab
return|;
block|}
end_function

begin_comment
comment|/* Initialize entry point information for this objfile. */
end_comment

begin_function
name|void
name|init_entry_point_info
parameter_list|(
name|objfile
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
comment|/* Save startup file's range of PC addresses to help blockframe.c      decide where the bottom of the stack is.  */
if|if
condition|(
name|bfd_get_file_flags
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|)
operator|&
name|EXEC_P
condition|)
block|{
comment|/* Executable file -- record its entry point so we'll recognize 	 the startup file because it contains the entry point.  */
name|objfile
operator|->
name|ei
operator|.
name|entry_point
operator|=
name|bfd_get_start_address
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Examination of non-executable.o files.  Short-circuit this stuff.  */
name|objfile
operator|->
name|ei
operator|.
name|entry_point
operator|=
name|INVALID_ENTRY_POINT
expr_stmt|;
block|}
name|objfile
operator|->
name|ei
operator|.
name|entry_file_lowpc
operator|=
name|INVALID_ENTRY_LOWPC
expr_stmt|;
name|objfile
operator|->
name|ei
operator|.
name|entry_file_highpc
operator|=
name|INVALID_ENTRY_HIGHPC
expr_stmt|;
name|objfile
operator|->
name|ei
operator|.
name|entry_func_lowpc
operator|=
name|INVALID_ENTRY_LOWPC
expr_stmt|;
name|objfile
operator|->
name|ei
operator|.
name|entry_func_highpc
operator|=
name|INVALID_ENTRY_HIGHPC
expr_stmt|;
name|objfile
operator|->
name|ei
operator|.
name|main_func_lowpc
operator|=
name|INVALID_ENTRY_LOWPC
expr_stmt|;
name|objfile
operator|->
name|ei
operator|.
name|main_func_highpc
operator|=
name|INVALID_ENTRY_HIGHPC
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get current entry point address.  */
end_comment

begin_function
name|CORE_ADDR
name|entry_point_address
parameter_list|()
block|{
return|return
name|symfile_objfile
condition|?
name|symfile_objfile
operator|->
name|ei
operator|.
name|entry_point
else|:
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Remember the lowest-addressed loadable section we've seen.      This function is called via bfd_map_over_sections.      In case of equal vmas, the section with the largest size becomes the    lowest-addressed loadable section.     If the vmas and sizes are equal, the last section is considered the    lowest-addressed loadable section.  */
end_comment

begin_function
name|void
name|find_lowest_section
parameter_list|(
name|abfd
parameter_list|,
name|sect
parameter_list|,
name|obj
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sect
decl_stmt|;
name|PTR
name|obj
decl_stmt|;
block|{
name|asection
modifier|*
modifier|*
name|lowest
init|=
operator|(
name|asection
operator|*
operator|*
operator|)
name|obj
decl_stmt|;
if|if
condition|(
literal|0
operator|==
operator|(
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|sect
argument_list|)
operator|&
name|SEC_LOAD
operator|)
condition|)
return|return;
if|if
condition|(
operator|!
operator|*
name|lowest
condition|)
operator|*
name|lowest
operator|=
name|sect
expr_stmt|;
comment|/* First loadable section */
elseif|else
if|if
condition|(
name|bfd_section_vma
argument_list|(
name|abfd
argument_list|,
operator|*
name|lowest
argument_list|)
operator|>
name|bfd_section_vma
argument_list|(
name|abfd
argument_list|,
name|sect
argument_list|)
condition|)
operator|*
name|lowest
operator|=
name|sect
expr_stmt|;
comment|/* A lower loadable section */
elseif|else
if|if
condition|(
name|bfd_section_vma
argument_list|(
name|abfd
argument_list|,
operator|*
name|lowest
argument_list|)
operator|==
name|bfd_section_vma
argument_list|(
name|abfd
argument_list|,
name|sect
argument_list|)
operator|&&
operator|(
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
operator|(
operator|*
name|lowest
operator|)
argument_list|)
operator|<=
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|sect
argument_list|)
operator|)
condition|)
operator|*
name|lowest
operator|=
name|sect
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse the user's idea of an offset for dynamic linking, into our idea    of how to represent it for fast symbol reading.  This is the default     version of the sym_fns.sym_offsets function for symbol readers that    don't need to do anything special.  It allocates a section_offsets table    for the objectfile OBJFILE and stuffs ADDR into all of the offsets.  */
end_comment

begin_function
name|struct
name|section_offsets
modifier|*
name|default_symfile_offsets
parameter_list|(
name|objfile
parameter_list|,
name|addr
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
block|{
name|struct
name|section_offsets
modifier|*
name|section_offsets
decl_stmt|;
name|int
name|i
decl_stmt|;
name|objfile
operator|->
name|num_sections
operator|=
name|SECT_OFF_MAX
expr_stmt|;
name|section_offsets
operator|=
operator|(
expr|struct
name|section_offsets
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|psymbol_obstack
argument_list|,
name|SIZEOF_SECTION_OFFSETS
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SECT_OFF_MAX
condition|;
name|i
operator|++
control|)
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|i
argument_list|)
operator|=
name|addr
expr_stmt|;
return|return
name|section_offsets
return|;
block|}
end_function

begin_comment
comment|/* Process a symbol file, as either the main file or as a dynamically    loaded file.     NAME is the file name (which will be tilde-expanded and made    absolute herein) (but we don't free or modify NAME itself).    FROM_TTY says how verbose to be.  MAINLINE specifies whether this    is the main symbol file, or whether it's an extra symbol file such    as dynamically loaded code.  If !mainline, ADDR is the address    where the text segment was loaded.  If VERBO, the caller has printed    a verbose message about the symbol reading (and complaints can be    more terse about it).  */
end_comment

begin_function
name|void
name|syms_from_objfile
parameter_list|(
name|objfile
parameter_list|,
name|addr
parameter_list|,
name|mainline
parameter_list|,
name|verbo
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|int
name|mainline
decl_stmt|;
name|int
name|verbo
decl_stmt|;
block|{
name|struct
name|section_offsets
modifier|*
name|section_offsets
decl_stmt|;
name|asection
modifier|*
name|lowest_sect
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|init_entry_point_info
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
name|find_sym_fns
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
comment|/* Make sure that partially constructed symbol tables will be cleaned up      if an error occurs during symbol reading.  */
name|old_chain
operator|=
name|make_cleanup
argument_list|(
operator|(
name|make_cleanup_func
operator|)
name|free_objfile
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|mainline
condition|)
block|{
comment|/* We will modify the main symbol table, make sure that all its users 	 will be cleaned up if an error occurs during symbol reading.  */
name|make_cleanup
argument_list|(
operator|(
name|make_cleanup_func
operator|)
name|clear_symtab_users
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Since no error yet, throw away the old symbol table.  */
if|if
condition|(
name|symfile_objfile
operator|!=
name|NULL
condition|)
block|{
name|free_objfile
argument_list|(
name|symfile_objfile
argument_list|)
expr_stmt|;
name|symfile_objfile
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Currently we keep symbols from the add-symbol-file command. 	 If the user wants to get rid of them, they should do "symbol-file" 	 without arguments first.  Not sure this is the best behavior 	 (PR 2207).  */
call|(
modifier|*
name|objfile
operator|->
name|sf
operator|->
name|sym_new_init
call|)
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
block|}
comment|/* Convert addr into an offset rather than an absolute address.      We find the lowest address of a loaded segment in the objfile,      and assume that<addr> is where that got loaded.  Due to historical      precedent, we warn if that doesn't happen to be a text segment.  */
if|if
condition|(
name|mainline
condition|)
block|{
name|addr
operator|=
literal|0
expr_stmt|;
comment|/* No offset from objfile addresses.  */
block|}
else|else
block|{
name|lowest_sect
operator|=
name|bfd_get_section_by_name
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
literal|".text"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lowest_sect
operator|==
name|NULL
condition|)
name|bfd_map_over_sections
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|find_lowest_section
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|lowest_sect
argument_list|)
expr_stmt|;
if|if
condition|(
name|lowest_sect
operator|==
name|NULL
condition|)
name|warning
argument_list|(
literal|"no loadable sections found in added symbol-file %s"
argument_list|,
name|objfile
operator|->
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|bfd_get_section_flags
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|lowest_sect
argument_list|)
operator|&
name|SEC_CODE
operator|)
operator|==
literal|0
condition|)
comment|/* FIXME-32x64--assumes bfd_vma fits in long.  */
name|warning
argument_list|(
literal|"Lowest section in %s is %s at 0x%lx"
argument_list|,
name|objfile
operator|->
name|name
argument_list|,
name|bfd_section_name
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|lowest_sect
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|bfd_section_vma
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|lowest_sect
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lowest_sect
condition|)
name|addr
operator|-=
name|bfd_section_vma
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|lowest_sect
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize symbol reading routines for this objfile, allow complaints to      appear for this new file, and record how verbose to be, then do the      initial symbol reading for this file. */
call|(
modifier|*
name|objfile
operator|->
name|sf
operator|->
name|sym_init
call|)
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
name|clear_complaints
argument_list|(
literal|1
argument_list|,
name|verbo
argument_list|)
expr_stmt|;
name|section_offsets
operator|=
call|(
modifier|*
name|objfile
operator|->
name|sf
operator|->
name|sym_offsets
call|)
argument_list|(
name|objfile
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|objfile
operator|->
name|section_offsets
operator|=
name|section_offsets
expr_stmt|;
ifndef|#
directive|ifndef
name|IBM6000_TARGET
comment|/* This is a SVR4/SunOS specific hack, I think.  In any event, it      screws RS/6000.  sym_offsets should be doing this sort of thing,      because it knows the mapping between bfd sections and      section_offsets.  */
comment|/* This is a hack.  As far as I can tell, section offsets are not      target dependent.  They are all set to addr with a couple of      exceptions.  The exceptions are sysvr4 shared libraries, whose      offsets are kept in solib structures anyway and rs6000 xcoff      which handles shared libraries in a completely unique way.       Section offsets are built similarly, except that they are built      by adding addr in all cases because there is no clear mapping      from section_offsets into actual sections.  Note that solib.c      has a different algorythm for finding section offsets.       These should probably all be collapsed into some target      independent form of shared library support.  FIXME.  */
if|if
condition|(
name|addr
condition|)
block|{
name|struct
name|obj_section
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
name|objfile
operator|->
name|sections
init|;
name|s
operator|<
name|objfile
operator|->
name|sections_end
condition|;
operator|++
name|s
control|)
block|{
name|s
operator|->
name|addr
operator|-=
name|s
operator|->
name|offset
expr_stmt|;
name|s
operator|->
name|addr
operator|+=
name|addr
expr_stmt|;
name|s
operator|->
name|endaddr
operator|-=
name|s
operator|->
name|offset
expr_stmt|;
name|s
operator|->
name|endaddr
operator|+=
name|addr
expr_stmt|;
name|s
operator|->
name|offset
operator|+=
name|addr
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* not IBM6000_TARGET */
call|(
modifier|*
name|objfile
operator|->
name|sf
operator|->
name|sym_read
call|)
argument_list|(
name|objfile
argument_list|,
name|section_offsets
argument_list|,
name|mainline
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|have_partial_symbols
argument_list|()
operator|&&
operator|!
name|have_full_symbols
argument_list|()
condition|)
block|{
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"(no debugging symbols found)..."
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
comment|/* Don't allow char * to have a typename (else would get caddr_t).      Ditto void *.  FIXME: Check whether this is now done by all the      symbol readers themselves (many of them now do), and if so remove      it from here.  */
name|TYPE_NAME
argument_list|(
name|lookup_pointer_type
argument_list|(
name|builtin_type_char
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|lookup_pointer_type
argument_list|(
name|builtin_type_void
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Mark the objfile has having had initial symbol read attempted.  Note      that this does not mean we found any symbols... */
name|objfile
operator|->
name|flags
operator||=
name|OBJF_SYMS
expr_stmt|;
comment|/* Discard cleanups as symbol reading was successful.  */
name|discard_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
comment|/* Call this after reading in a new symbol table to give target dependant code    a crack at the new symbols.  For instance, this could be used to update the    values of target-specific symbols GDB needs to keep track of (such as    _sigtramp, or whatever).  */
name|TARGET_SYMFILE_POSTREAD
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Perform required actions after either reading in the initial    symbols for a new objfile, or mapping in the symbols from a reusable    objfile. */
end_comment

begin_function
name|void
name|new_symfile_objfile
parameter_list|(
name|objfile
parameter_list|,
name|mainline
parameter_list|,
name|verbo
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|int
name|mainline
decl_stmt|;
name|int
name|verbo
decl_stmt|;
block|{
comment|/* If this is the main symbol file we have to clean up all users of the      old main symbol file. Otherwise it is sufficient to fixup all the      breakpoints that may have been redefined by this symbol file.  */
if|if
condition|(
name|mainline
condition|)
block|{
comment|/* OK, make it the "real" symbol file.  */
name|symfile_objfile
operator|=
name|objfile
expr_stmt|;
name|clear_symtab_users
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|breakpoint_re_set
argument_list|()
expr_stmt|;
block|}
comment|/* We're done reading the symbol file; finish off complaints.  */
name|clear_complaints
argument_list|(
literal|0
argument_list|,
name|verbo
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Process a symbol file, as either the main file or as a dynamically    loaded file.     NAME is the file name (which will be tilde-expanded and made    absolute herein) (but we don't free or modify NAME itself).    FROM_TTY says how verbose to be.  MAINLINE specifies whether this    is the main symbol file, or whether it's an extra symbol file such    as dynamically loaded code.  If !mainline, ADDR is the address    where the text segment was loaded.     USER_LOADED is TRUE if the add-symbol-file command was how this    symbol file came to be processed.     IS_SOLIB is TRUE if this symbol file represents a solib, as discovered    by the target's implementation of the solib package.     Upon success, returns a pointer to the objfile that was added.    Upon failure, jumps back to command level (never returns). */
end_comment

begin_function
name|struct
name|objfile
modifier|*
name|symbol_file_add
parameter_list|(
name|name
parameter_list|,
name|from_tty
parameter_list|,
name|addr
parameter_list|,
name|mainline
parameter_list|,
name|mapped
parameter_list|,
name|readnow
parameter_list|,
name|user_loaded
parameter_list|,
name|is_solib
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|int
name|mainline
decl_stmt|;
name|int
name|mapped
decl_stmt|;
name|int
name|readnow
decl_stmt|;
name|int
name|user_loaded
decl_stmt|;
name|int
name|is_solib
decl_stmt|;
block|{
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|partial_symtab
modifier|*
name|psymtab
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
comment|/* Open a bfd for the file, and give user a chance to burp if we'd be      interactively wiping out any existing symbols.  */
name|abfd
operator|=
name|symfile_bfd_open
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|have_full_symbols
argument_list|()
operator|||
name|have_partial_symbols
argument_list|()
operator|)
operator|&&
name|mainline
operator|&&
name|from_tty
operator|&&
operator|!
name|query
argument_list|(
literal|"Load new symbol table from \"%s\"? "
argument_list|,
name|name
argument_list|)
condition|)
name|error
argument_list|(
literal|"Not confirmed."
argument_list|)
expr_stmt|;
name|objfile
operator|=
name|allocate_objfile
argument_list|(
name|abfd
argument_list|,
name|mapped
argument_list|,
name|user_loaded
argument_list|,
name|is_solib
argument_list|)
expr_stmt|;
comment|/* If the objfile uses a mapped symbol file, and we have a psymtab for      it, then skip reading any symbols at this time. */
if|if
condition|(
operator|(
name|objfile
operator|->
name|flags
operator|&
name|OBJF_MAPPED
operator|)
operator|&&
operator|(
name|objfile
operator|->
name|flags
operator|&
name|OBJF_SYMS
operator|)
condition|)
block|{
comment|/* We mapped in an existing symbol table file that already has had 	 initial symbol reading performed, so we can skip that part.  Notify 	 the user that instead of reading the symbols, they have been mapped. 	 */
if|if
condition|(
name|from_tty
operator|||
name|info_verbose
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Mapped symbols for %s..."
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
name|init_entry_point_info
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
name|find_sym_fns
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We either created a new mapped symbol table, mapped an existing 	 symbol table file which has not had initial symbol reading 	 performed, or need to read an unmapped symbol table. */
if|if
condition|(
name|from_tty
operator|||
name|info_verbose
condition|)
block|{
if|if
condition|(
name|pre_add_symbol_hook
condition|)
name|pre_add_symbol_hook
argument_list|(
name|name
argument_list|)
expr_stmt|;
else|else
block|{
name|printf_filtered
argument_list|(
literal|"Reading symbols from %s..."
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
block|}
name|syms_from_objfile
argument_list|(
name|objfile
argument_list|,
name|addr
argument_list|,
name|mainline
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
comment|/* We now have at least a partial symbol table.  Check to see if the      user requested that all symbols be read on initial access via either      the gdb startup command line or on a per symbol file basis.  Expand      all partial symbol tables for this objfile if so. */
if|if
condition|(
name|readnow
operator|||
name|readnow_symbol_files
condition|)
block|{
if|if
condition|(
name|from_tty
operator|||
name|info_verbose
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"expanding to full symbols..."
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|psymtab
operator|=
name|objfile
operator|->
name|psymtabs
init|;
name|psymtab
operator|!=
name|NULL
condition|;
name|psymtab
operator|=
name|psymtab
operator|->
name|next
control|)
block|{
name|psymtab_to_symtab
argument_list|(
name|psymtab
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|from_tty
operator|||
name|info_verbose
condition|)
block|{
if|if
condition|(
name|post_add_symbol_hook
condition|)
name|post_add_symbol_hook
argument_list|()
expr_stmt|;
else|else
block|{
name|printf_filtered
argument_list|(
literal|"done.\n"
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
block|}
name|new_symfile_objfile
argument_list|(
name|objfile
argument_list|,
name|mainline
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
name|target_new_objfile
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
return|return
operator|(
name|objfile
operator|)
return|;
block|}
end_function

begin_comment
comment|/* This is the symbol-file command.  Read the file, analyze its    symbols, and add a struct symtab to a symtab list.  The syntax of    the command is rather bizarre--(1) buildargv implements various    quoting conventions which are undocumented and have little or    nothing in common with the way things are quoted (or not quoted)    elsewhere in GDB, (2) options are used, which are not generally    used in GDB (perhaps "set mapped on", "set readnow on" would be    better), (3) the order of options matters, which is contrary to GNU    conventions (because it is confusing and inconvenient).  */
end_comment

begin_function
name|void
name|symbol_file_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
name|CORE_ADDR
name|text_relocation
init|=
literal|0
decl_stmt|;
comment|/* text_relocation */
name|struct
name|cleanup
modifier|*
name|cleanups
decl_stmt|;
name|int
name|mapped
init|=
literal|0
decl_stmt|;
name|int
name|readnow
init|=
literal|0
decl_stmt|;
name|dont_repeat
argument_list|()
expr_stmt|;
if|if
condition|(
name|args
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|have_full_symbols
argument_list|()
operator|||
name|have_partial_symbols
argument_list|()
operator|)
operator|&&
name|from_tty
operator|&&
operator|!
name|query
argument_list|(
literal|"Discard symbol table from `%s'? "
argument_list|,
name|symfile_objfile
operator|->
name|name
argument_list|)
condition|)
name|error
argument_list|(
literal|"Not confirmed."
argument_list|)
expr_stmt|;
name|free_all_objfiles
argument_list|()
expr_stmt|;
comment|/* solib descriptors may have handles to objfiles.  Since their          storage has just been released, we'd better wipe the solib          descriptors as well.          */
if|#
directive|if
name|defined
argument_list|(
name|SOLIB_RESTART
argument_list|)
name|SOLIB_RESTART
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|symfile_objfile
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"No symbol file now.\n"
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HPUXHPPA
name|RESET_HP_UX_GLOBALS
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
if|if
condition|(
operator|(
name|argv
operator|=
name|buildargv
argument_list|(
name|args
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|nomem
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|cleanups
operator|=
name|make_cleanup
argument_list|(
operator|(
name|make_cleanup_func
operator|)
name|freeargv
argument_list|,
operator|(
name|char
operator|*
operator|)
name|argv
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|argv
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|STREQ
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-mapped"
argument_list|)
condition|)
block|{
name|mapped
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-readnow"
argument_list|)
condition|)
block|{
name|readnow
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
operator|*
name|argv
operator|==
literal|'-'
condition|)
block|{
name|error
argument_list|(
literal|"unknown option `%s'"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|name
operator|=
operator|*
name|argv
expr_stmt|;
comment|/* this is for rombug remote only, to get the text relocation by               using link command */
name|p
operator|=
name|strrchr
argument_list|(
name|name
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
name|p
operator|++
expr_stmt|;
else|else
name|p
operator|=
name|name
expr_stmt|;
name|target_link
argument_list|(
name|p
argument_list|,
operator|&
name|text_relocation
argument_list|)
expr_stmt|;
if|if
condition|(
name|text_relocation
operator|==
operator|(
name|CORE_ADDR
operator|)
literal|0
condition|)
return|return;
elseif|else
if|if
condition|(
name|text_relocation
operator|==
operator|(
name|CORE_ADDR
operator|)
operator|-
literal|1
condition|)
block|{
name|symbol_file_add
argument_list|(
name|name
argument_list|,
name|from_tty
argument_list|,
operator|(
name|CORE_ADDR
operator|)
literal|0
argument_list|,
literal|1
argument_list|,
name|mapped
argument_list|,
name|readnow
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HPUXHPPA
name|RESET_HP_UX_GLOBALS
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|symbol_file_add
argument_list|(
name|name
argument_list|,
name|from_tty
argument_list|,
operator|(
name|CORE_ADDR
operator|)
name|text_relocation
argument_list|,
literal|0
argument_list|,
name|mapped
argument_list|,
name|readnow
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Getting new symbols may change our opinion about what is 		 frameless.  */
name|reinit_frame_cache
argument_list|()
expr_stmt|;
name|set_initial_language
argument_list|()
expr_stmt|;
block|}
name|argv
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"no symbol file name was specified"
argument_list|)
expr_stmt|;
block|}
name|TUIDO
argument_list|(
operator|(
operator|(
name|TuiOpaqueFuncPtr
operator|)
name|tuiDisplayMainFunction
operator|)
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|cleanups
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Set the initial language.     A better solution would be to record the language in the psymtab when reading    partial symbols, and then use it (if known) to set the language.  This would    be a win for formats that encode the language in an easily discoverable place,    such as DWARF.  For stabs, we can jump through hoops looking for specially    named symbols or try to intuit the language from the specific type of stabs    we find, but we can't do that until later when we read in full symbols.    FIXME.  */
end_comment

begin_function
specifier|static
name|void
name|set_initial_language
parameter_list|()
block|{
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
name|enum
name|language
name|lang
init|=
name|language_unknown
decl_stmt|;
name|pst
operator|=
name|find_main_psymtab
argument_list|()
expr_stmt|;
if|if
condition|(
name|pst
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|pst
operator|->
name|filename
operator|!=
name|NULL
condition|)
block|{
name|lang
operator|=
name|deduce_language_from_filename
argument_list|(
name|pst
operator|->
name|filename
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lang
operator|==
name|language_unknown
condition|)
block|{
comment|/* Make C the default language */
name|lang
operator|=
name|language_c
expr_stmt|;
block|}
name|set_language
argument_list|(
name|lang
argument_list|)
expr_stmt|;
name|expected_language
operator|=
name|current_language
expr_stmt|;
comment|/* Don't warn the user */
block|}
block|}
end_function

begin_comment
comment|/* Open file specified by NAME and hand it off to BFD for preliminary    analysis.  Result is a newly initialized bfd *, which includes a newly    malloc'd` copy of NAME (tilde-expanded and made absolute).    In case of trouble, error() is called.  */
end_comment

begin_function
name|bfd
modifier|*
name|symfile_bfd_open
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|bfd
modifier|*
name|sym_bfd
decl_stmt|;
name|int
name|desc
decl_stmt|;
name|char
modifier|*
name|absolute_name
decl_stmt|;
name|name
operator|=
name|tilde_expand
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* Returns 1st new malloc'd copy */
comment|/* Look down path for it, allocate 2nd new malloc'd copy.  */
name|desc
operator|=
name|openp
argument_list|(
name|getenv
argument_list|(
literal|"PATH"
argument_list|)
argument_list|,
literal|1
argument_list|,
name|name
argument_list|,
name|O_RDONLY
operator||
name|O_BINARY
argument_list|,
literal|0
argument_list|,
operator|&
name|absolute_name
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__GO32__
argument_list|)
operator|||
name|defined
argument_list|(
name|_WIN32
argument_list|)
if|if
condition|(
name|desc
operator|<
literal|0
condition|)
block|{
name|char
modifier|*
name|exename
init|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|5
argument_list|)
decl_stmt|;
name|strcat
argument_list|(
name|strcpy
argument_list|(
name|exename
argument_list|,
name|name
argument_list|)
argument_list|,
literal|".exe"
argument_list|)
expr_stmt|;
name|desc
operator|=
name|openp
argument_list|(
name|getenv
argument_list|(
literal|"PATH"
argument_list|)
argument_list|,
literal|1
argument_list|,
name|exename
argument_list|,
name|O_RDONLY
operator||
name|O_BINARY
argument_list|,
literal|0
argument_list|,
operator|&
name|absolute_name
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|desc
operator|<
literal|0
condition|)
block|{
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|perror_with_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
name|fcntl
argument_list|(
name|desc
argument_list|,
name|F_SETFD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* Free 1st new malloc'd copy */
name|name
operator|=
name|absolute_name
expr_stmt|;
comment|/* Keep 2nd malloc'd copy in bfd */
comment|/* It'll be freed in free_objfile(). */
name|sym_bfd
operator|=
name|bfd_fdopenr
argument_list|(
name|name
argument_list|,
name|gnutarget
argument_list|,
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sym_bfd
condition|)
block|{
name|close
argument_list|(
name|desc
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"\"%s\": can't open to read symbols: %s."
argument_list|,
name|name
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sym_bfd
operator|->
name|cacheable
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_check_format
argument_list|(
name|sym_bfd
argument_list|,
name|bfd_object
argument_list|)
condition|)
block|{
comment|/* FIXME: should be checking for errors from bfd_close (for one thing, 	 on error it does not free all the storage associated with the 	 bfd).  */
name|bfd_close
argument_list|(
name|sym_bfd
argument_list|)
expr_stmt|;
comment|/* This also closes desc */
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"\"%s\": can't read symbols: %s."
argument_list|,
name|name
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|sym_bfd
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Link a new symtab_fns into the global symtab_fns list.  Called on gdb    startup by the _initialize routine in each object file format reader,    to register information about each format the the reader is prepared    to handle. */
end_comment

begin_function
name|void
name|add_symtab_fns
parameter_list|(
name|sf
parameter_list|)
name|struct
name|sym_fns
modifier|*
name|sf
decl_stmt|;
block|{
name|sf
operator|->
name|next
operator|=
name|symtab_fns
expr_stmt|;
name|symtab_fns
operator|=
name|sf
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize to read symbols from the symbol file sym_bfd.  It either    returns or calls error().  The result is an initialized struct sym_fns    in the objfile structure, that contains cached information about the    symbol file.  */
end_comment

begin_function
specifier|static
name|void
name|find_sym_fns
parameter_list|(
name|objfile
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|struct
name|sym_fns
modifier|*
name|sf
decl_stmt|;
name|enum
name|bfd_flavour
name|our_flavour
init|=
name|bfd_get_flavour
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|)
decl_stmt|;
name|char
modifier|*
name|our_target
init|=
name|bfd_get_target
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|)
decl_stmt|;
comment|/* Special kludge for RS/6000 and PowerMac.  See xcoffread.c.  */
if|if
condition|(
name|STREQ
argument_list|(
name|our_target
argument_list|,
literal|"aixcoff-rs6000"
argument_list|)
operator|||
name|STREQ
argument_list|(
name|our_target
argument_list|,
literal|"xcoff-powermac"
argument_list|)
condition|)
name|our_flavour
operator|=
operator|(
expr|enum
name|bfd_flavour
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* Special kludge for apollo.  See dstread.c.  */
if|if
condition|(
name|STREQN
argument_list|(
name|our_target
argument_list|,
literal|"apollo"
argument_list|,
literal|6
argument_list|)
condition|)
name|our_flavour
operator|=
operator|(
expr|enum
name|bfd_flavour
operator|)
operator|-
literal|2
expr_stmt|;
for|for
control|(
name|sf
operator|=
name|symtab_fns
init|;
name|sf
operator|!=
name|NULL
condition|;
name|sf
operator|=
name|sf
operator|->
name|next
control|)
block|{
if|if
condition|(
name|our_flavour
operator|==
name|sf
operator|->
name|sym_flavour
condition|)
block|{
name|objfile
operator|->
name|sf
operator|=
name|sf
expr_stmt|;
return|return;
block|}
block|}
name|error
argument_list|(
literal|"I'm sorry, Dave, I can't do that.  Symbol format `%s' unknown."
argument_list|,
name|bfd_get_target
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This function runs the load command of our current target.  */
end_comment

begin_function
specifier|static
name|void
name|load_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
if|if
condition|(
name|arg
operator|==
name|NULL
condition|)
name|arg
operator|=
name|get_exec_file
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|target_load
argument_list|(
name|arg
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This version of "load" should be usable for any target.  Currently    it is just used for remote targets, not inftarg.c or core files,    on the theory that only in that case is it useful.     Avoiding xmodem and the like seems like a win (a) because we don't have    to worry about finding it, and (b) On VMS, fork() is very slow and so    we don't want to run a subprocess.  On the other hand, I'm not sure how    performance compares.  */
end_comment

begin_define
define|#
directive|define
name|GENERIC_LOAD_CHUNK
value|256
end_define

begin_define
define|#
directive|define
name|VALIDATE_DOWNLOAD
value|0
end_define

begin_function
name|void
name|generic_load
parameter_list|(
name|filename
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|struct
name|cleanup
modifier|*
name|old_cleanups
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd
modifier|*
name|loadfile_bfd
decl_stmt|;
name|time_t
name|start_time
decl_stmt|,
name|end_time
decl_stmt|;
comment|/* Start and end times of download */
name|unsigned
name|long
name|data_count
init|=
literal|0
decl_stmt|;
comment|/* Number of bytes transferred to memory */
name|int
name|n
decl_stmt|;
name|unsigned
name|long
name|load_offset
init|=
literal|0
decl_stmt|;
comment|/* offset to add to vma for each section */
name|char
name|buf
index|[
name|GENERIC_LOAD_CHUNK
operator|+
literal|8
index|]
decl_stmt|;
if|#
directive|if
name|VALIDATE_DOWNLOAD
name|char
name|verify_buffer
index|[
name|GENERIC_LOAD_CHUNK
operator|+
literal|8
index|]
decl_stmt|;
endif|#
directive|endif
comment|/* enable user to specify address for downloading as 2nd arg to load */
name|n
operator|=
name|sscanf
argument_list|(
name|filename
argument_list|,
literal|"%s 0x%lx"
argument_list|,
name|buf
argument_list|,
operator|&
name|load_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|1
condition|)
name|filename
operator|=
name|buf
expr_stmt|;
else|else
name|load_offset
operator|=
literal|0
expr_stmt|;
name|loadfile_bfd
operator|=
name|bfd_openr
argument_list|(
name|filename
argument_list|,
name|gnutarget
argument_list|)
expr_stmt|;
if|if
condition|(
name|loadfile_bfd
operator|==
name|NULL
condition|)
block|{
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* FIXME: should be checking for errors from bfd_close (for one thing,      on error it does not free all the storage associated with the      bfd).  */
name|old_cleanups
operator|=
name|make_cleanup
argument_list|(
operator|(
name|make_cleanup_func
operator|)
name|bfd_close
argument_list|,
name|loadfile_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_check_format
argument_list|(
name|loadfile_bfd
argument_list|,
name|bfd_object
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"\"%s\" is not an object file: %s"
argument_list|,
name|filename
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|start_time
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|loadfile_bfd
operator|->
name|sections
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
if|if
condition|(
name|s
operator|->
name|flags
operator|&
name|SEC_LOAD
condition|)
block|{
name|bfd_size_type
name|size
decl_stmt|;
name|size
operator|=
name|bfd_get_section_size_before_reloc
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|>
literal|0
condition|)
block|{
name|char
modifier|*
name|buffer
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|bfd_vma
name|lma
decl_stmt|;
name|unsigned
name|long
name|l
init|=
name|size
decl_stmt|;
name|int
name|err
decl_stmt|;
name|char
modifier|*
name|sect
decl_stmt|;
name|unsigned
name|long
name|sent
decl_stmt|;
name|unsigned
name|long
name|len
decl_stmt|;
name|l
operator|=
name|l
operator|>
name|GENERIC_LOAD_CHUNK
condition|?
name|GENERIC_LOAD_CHUNK
else|:
name|l
expr_stmt|;
name|buffer
operator|=
name|xmalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|lma
operator|=
name|s
operator|->
name|lma
expr_stmt|;
name|lma
operator|+=
name|load_offset
expr_stmt|;
comment|/* Is this really necessary?  I guess it gives the user something                  to look at during a long download.  */
name|printf_filtered
argument_list|(
literal|"Loading section %s, size 0x%lx lma "
argument_list|,
name|bfd_get_section_name
argument_list|(
name|loadfile_bfd
argument_list|,
name|s
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|size
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|lma
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|bfd_get_section_contents
argument_list|(
name|loadfile_bfd
argument_list|,
name|s
argument_list|,
name|buffer
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|sect
operator|=
operator|(
name|char
operator|*
operator|)
name|bfd_get_section_name
argument_list|(
name|loadfile_bfd
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|sent
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|len
operator|=
operator|(
name|size
operator|-
name|sent
operator|)
operator|<
name|l
condition|?
operator|(
name|size
operator|-
name|sent
operator|)
else|:
name|l
expr_stmt|;
name|sent
operator|+=
name|len
expr_stmt|;
name|err
operator|=
name|target_write_memory
argument_list|(
name|lma
argument_list|,
name|buffer
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|ui_load_progress_hook
condition|)
if|if
condition|(
name|ui_load_progress_hook
argument_list|(
name|sect
argument_list|,
name|sent
argument_list|)
condition|)
name|error
argument_list|(
literal|"Canceled the download"
argument_list|)
expr_stmt|;
if|#
directive|if
name|VALIDATE_DOWNLOAD
comment|/* Broken memories and broken monitors manifest themselves 		     here when bring new computers to life. 		     This doubles already slow downloads. 		  */
if|if
condition|(
name|err
condition|)
break|break ;
block|{
name|target_read_memory
argument_list|(
name|lma
argument_list|,
name|verify_buffer
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|!=
name|bcmp
argument_list|(
name|buffer
argument_list|,
name|verify_buffer
argument_list|,
name|len
argument_list|)
condition|)
name|error
argument_list|(
literal|"Download verify failed at %08x"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|lma
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|data_count
operator|+=
name|len
expr_stmt|;
name|lma
operator|+=
name|len
expr_stmt|;
name|buffer
operator|+=
name|len
expr_stmt|;
block|}
comment|/* od */
do|while
condition|(
name|err
operator|==
literal|0
operator|&&
name|sent
operator|<
name|size
condition|)
do|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|"Memory access error while loading section %s."
argument_list|,
name|bfd_get_section_name
argument_list|(
name|loadfile_bfd
argument_list|,
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|end_time
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|{
name|unsigned
name|long
name|entry
decl_stmt|;
name|entry
operator|=
name|bfd_get_start_address
argument_list|(
name|loadfile_bfd
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Start address 0x%lx , load size %d\n"
argument_list|,
name|entry
argument_list|,
name|data_count
argument_list|)
expr_stmt|;
comment|/* We were doing this in remote-mips.c, I suspect it is right        for other targets too.  */
name|write_pc
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
comment|/* FIXME: are we supposed to call symbol_file_add or not?  According to      a comment from remote-mips.c (where a call to symbol_file_add was      commented out), making the call confuses GDB if more than one file is      loaded in.  remote-nindy.c had no call to symbol_file_add, but remote-vx.c      does.  */
name|report_transfer_performance
argument_list|(
name|data_count
argument_list|,
name|start_time
argument_list|,
name|end_time
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_cleanups
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Report how fast the transfer went. */
end_comment

begin_function
name|void
name|report_transfer_performance
parameter_list|(
name|data_count
parameter_list|,
name|start_time
parameter_list|,
name|end_time
parameter_list|)
name|unsigned
name|long
name|data_count
decl_stmt|;
name|time_t
name|start_time
decl_stmt|,
name|end_time
decl_stmt|;
block|{
name|printf_filtered
argument_list|(
literal|"Transfer rate: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|end_time
operator|!=
name|start_time
condition|)
name|printf_filtered
argument_list|(
literal|"%d bits/sec"
argument_list|,
operator|(
name|data_count
operator|*
literal|8
operator|)
operator|/
operator|(
name|end_time
operator|-
name|start_time
operator|)
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|"%d bits in<1 sec"
argument_list|,
operator|(
name|data_count
operator|*
literal|8
operator|)
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|".\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function allows the addition of incrementally linked object files.    It does not modify any state in the target, only in the debugger.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|add_symbol_file_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|char
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
name|CORE_ADDR
name|text_addr
decl_stmt|;
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|readnow
init|=
literal|0
decl_stmt|;
name|int
name|mapped
init|=
literal|0
decl_stmt|;
name|dont_repeat
argument_list|()
expr_stmt|;
if|if
condition|(
name|args
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"add-symbol-file takes a file name and an address"
argument_list|)
expr_stmt|;
block|}
comment|/* Make a copy of the string that we can safely write into. */
name|args
operator|=
name|strdup
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|args
argument_list|)
expr_stmt|;
comment|/* Pick off any -option args and the file name. */
while|while
condition|(
operator|(
operator|*
name|args
operator|!=
literal|'\000'
operator|)
operator|&&
operator|(
name|name
operator|==
name|NULL
operator|)
condition|)
block|{
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|args
argument_list|)
condition|)
block|{
name|args
operator|++
expr_stmt|;
block|}
name|arg
operator|=
name|args
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|args
operator|!=
literal|'\000'
operator|)
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|args
argument_list|)
condition|)
block|{
name|args
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|args
operator|!=
literal|'\000'
condition|)
block|{
operator|*
name|args
operator|++
operator|=
literal|'\000'
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|arg
operator|!=
literal|'-'
condition|)
block|{
name|name
operator|=
name|arg
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|arg
argument_list|,
literal|"-mapped"
argument_list|)
condition|)
block|{
name|mapped
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|arg
argument_list|,
literal|"-readnow"
argument_list|)
condition|)
block|{
name|readnow
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"unknown option `%s'"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* After picking off any options and the file name, args should be      left pointing at the remainder of the command line, which should      be the address expression to evaluate. */
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"add-symbol-file takes a file name"
argument_list|)
expr_stmt|;
block|}
name|name
operator|=
name|tilde_expand
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|args
operator|!=
literal|'\000'
condition|)
block|{
name|text_addr
operator|=
name|parse_and_eval_address
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|target_link
argument_list|(
name|name
argument_list|,
operator|&
name|text_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|text_addr
operator|==
operator|(
name|CORE_ADDR
operator|)
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"Don't know how to get text start location for this file"
argument_list|)
expr_stmt|;
block|}
comment|/* FIXME-32x64: Assumes text_addr fits in a long.  */
if|if
condition|(
operator|(
name|from_tty
operator|)
operator|&&
operator|(
operator|!
name|query
argument_list|(
literal|"add symbol table from file \"%s\" at text_addr = %s?\n"
argument_list|,
name|name
argument_list|,
name|local_hex_string
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|text_addr
argument_list|)
argument_list|)
operator|)
condition|)
name|error
argument_list|(
literal|"Not confirmed."
argument_list|)
expr_stmt|;
name|symbol_file_add
argument_list|(
name|name
argument_list|,
name|from_tty
argument_list|,
name|text_addr
argument_list|,
literal|0
argument_list|,
name|mapped
argument_list|,
name|readnow
argument_list|,
literal|1
argument_list|,
comment|/* user_loaded */
literal|0
argument_list|)
expr_stmt|;
comment|/* We'll guess it's ! is_solib */
comment|/* Getting new symbols may change our opinion about what is      frameless.  */
name|reinit_frame_cache
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|add_shared_symbol_files_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|ADD_SHARED_SYMBOL_FILES
name|ADD_SHARED_SYMBOL_FILES
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
argument_list|(
literal|"This command is not available in this configuration of GDB."
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Re-read symbols if a symbol-file has changed.  */
end_comment

begin_function
name|void
name|reread_symbols
parameter_list|()
block|{
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|long
name|new_modtime
decl_stmt|;
name|int
name|reread_one
init|=
literal|0
decl_stmt|;
name|struct
name|stat
name|new_statbuf
decl_stmt|;
name|int
name|res
decl_stmt|;
comment|/* With the addition of shared libraries, this should be modified,      the load time should be saved in the partial symbol tables, since      different tables may come from different source files.  FIXME.      This routine should then walk down each partial symbol table      and see if the symbol table that it originates from has been changed */
for|for
control|(
name|objfile
operator|=
name|object_files
init|;
name|objfile
condition|;
name|objfile
operator|=
name|objfile
operator|->
name|next
control|)
block|{
if|if
condition|(
name|objfile
operator|->
name|obfd
condition|)
block|{
ifdef|#
directive|ifdef
name|IBM6000_TARGET
comment|/* If this object is from a shared library, then you should         stat on the library name, not member name. */
if|if
condition|(
name|objfile
operator|->
name|obfd
operator|->
name|my_archive
condition|)
name|res
operator|=
name|stat
argument_list|(
name|objfile
operator|->
name|obfd
operator|->
name|my_archive
operator|->
name|filename
argument_list|,
operator|&
name|new_statbuf
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|res
operator|=
name|stat
argument_list|(
name|objfile
operator|->
name|name
argument_list|,
operator|&
name|new_statbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
literal|0
condition|)
block|{
comment|/* FIXME, should use print_sys_errmsg but it's not filtered. */
name|printf_filtered
argument_list|(
literal|"`%s' has disappeared; keeping its symbols.\n"
argument_list|,
name|objfile
operator|->
name|name
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|new_modtime
operator|=
name|new_statbuf
operator|.
name|st_mtime
expr_stmt|;
if|if
condition|(
name|new_modtime
operator|!=
name|objfile
operator|->
name|mtime
condition|)
block|{
name|struct
name|cleanup
modifier|*
name|old_cleanups
decl_stmt|;
name|struct
name|section_offsets
modifier|*
name|offsets
decl_stmt|;
name|int
name|num_offsets
decl_stmt|;
name|int
name|section_offsets_size
decl_stmt|;
name|char
modifier|*
name|obfd_filename
decl_stmt|;
name|printf_filtered
argument_list|(
literal|"`%s' has changed; re-reading symbols.\n"
argument_list|,
name|objfile
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* There are various functions like symbol_file_add, 	     symfile_bfd_open, syms_from_objfile, etc., which might 	     appear to do what we want.  But they have various other 	     effects which we *don't* want.  So we just do stuff 	     ourselves.  We don't worry about mapped files (for one thing, 	     any mapped file will be out of date).  */
comment|/* If we get an error, blow away this objfile (not sure if 	     that is the correct response for things like shared 	     libraries).  */
name|old_cleanups
operator|=
name|make_cleanup
argument_list|(
operator|(
name|make_cleanup_func
operator|)
name|free_objfile
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* We need to do this whenever any symbols go away.  */
name|make_cleanup
argument_list|(
operator|(
name|make_cleanup_func
operator|)
name|clear_symtab_users
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Clean up any state BFD has sitting around.  We don't need 	     to close the descriptor but BFD lacks a way of closing the 	     BFD without closing the descriptor.  */
name|obfd_filename
operator|=
name|bfd_get_filename
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_close
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|)
condition|)
name|error
argument_list|(
literal|"Can't close BFD for %s: %s"
argument_list|,
name|objfile
operator|->
name|name
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|objfile
operator|->
name|obfd
operator|=
name|bfd_openr
argument_list|(
name|obfd_filename
argument_list|,
name|gnutarget
argument_list|)
expr_stmt|;
if|if
condition|(
name|objfile
operator|->
name|obfd
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Can't open %s to read symbols."
argument_list|,
name|objfile
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* bfd_openr sets cacheable to true, which is what we want.  */
if|if
condition|(
operator|!
name|bfd_check_format
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|bfd_object
argument_list|)
condition|)
name|error
argument_list|(
literal|"Can't read symbols from %s: %s."
argument_list|,
name|objfile
operator|->
name|name
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Save the offsets, we will nuke them with the rest of the 	     psymbol_obstack.  */
name|num_offsets
operator|=
name|objfile
operator|->
name|num_sections
expr_stmt|;
name|section_offsets_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|section_offsets
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|objfile
operator|->
name|section_offsets
operator|->
name|offsets
argument_list|)
operator|*
name|num_offsets
expr_stmt|;
name|offsets
operator|=
operator|(
expr|struct
name|section_offsets
operator|*
operator|)
name|alloca
argument_list|(
name|section_offsets_size
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|offsets
argument_list|,
name|objfile
operator|->
name|section_offsets
argument_list|,
name|section_offsets_size
argument_list|)
expr_stmt|;
comment|/* Nuke all the state that we will re-read.  Much of the following 	     code which sets things to NULL really is necessary to tell 	     other parts of GDB that there is nothing currently there.  */
comment|/* FIXME: Do we have to free a whole linked list, or is this 	     enough?  */
if|if
condition|(
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
condition|)
name|mfree
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|objfile
operator|->
name|global_psymbols
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|objfile
operator|->
name|global_psymbols
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|objfile
operator|->
name|static_psymbols
operator|.
name|list
condition|)
name|mfree
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
name|objfile
operator|->
name|static_psymbols
operator|.
name|list
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|objfile
operator|->
name|static_psymbols
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|objfile
operator|->
name|static_psymbols
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Free the obstacks for non-reusable objfiles */
name|obstack_free
argument_list|(
operator|&
name|objfile
operator|->
name|psymbol_cache
operator|.
name|cache
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|objfile
operator|->
name|psymbol_cache
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|objfile
operator|->
name|psymbol_cache
argument_list|)
argument_list|)
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|objfile
operator|->
name|psymbol_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|objfile
operator|->
name|type_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|objfile
operator|->
name|sections
operator|=
name|NULL
expr_stmt|;
name|objfile
operator|->
name|symtabs
operator|=
name|NULL
expr_stmt|;
name|objfile
operator|->
name|psymtabs
operator|=
name|NULL
expr_stmt|;
name|objfile
operator|->
name|free_psymtabs
operator|=
name|NULL
expr_stmt|;
name|objfile
operator|->
name|msymbols
operator|=
name|NULL
expr_stmt|;
name|objfile
operator|->
name|minimal_symbol_count
operator|=
literal|0
expr_stmt|;
name|objfile
operator|->
name|fundamental_types
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|objfile
operator|->
name|sf
operator|!=
name|NULL
condition|)
block|{
call|(
modifier|*
name|objfile
operator|->
name|sf
operator|->
name|sym_finish
call|)
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
block|}
comment|/* We never make this a mapped file.  */
name|objfile
operator|->
name|md
operator|=
name|NULL
expr_stmt|;
comment|/* obstack_specify_allocation also initializes the obstack so 	     it is empty.  */
name|obstack_specify_allocation
argument_list|(
operator|&
name|objfile
operator|->
name|psymbol_cache
operator|.
name|cache
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|xmalloc
argument_list|,
name|free
argument_list|)
expr_stmt|;
name|obstack_specify_allocation
argument_list|(
operator|&
name|objfile
operator|->
name|psymbol_obstack
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|xmalloc
argument_list|,
name|free
argument_list|)
expr_stmt|;
name|obstack_specify_allocation
argument_list|(
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|xmalloc
argument_list|,
name|free
argument_list|)
expr_stmt|;
name|obstack_specify_allocation
argument_list|(
operator|&
name|objfile
operator|->
name|type_obstack
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|xmalloc
argument_list|,
name|free
argument_list|)
expr_stmt|;
if|if
condition|(
name|build_objfile_section_table
argument_list|(
name|objfile
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"Can't find the file sections in `%s': %s"
argument_list|,
name|objfile
operator|->
name|name
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* We use the same section offsets as from last time.  I'm not 	     sure whether that is always correct for shared libraries.  */
name|objfile
operator|->
name|section_offsets
operator|=
operator|(
expr|struct
name|section_offsets
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|psymbol_obstack
argument_list|,
name|section_offsets_size
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|objfile
operator|->
name|section_offsets
argument_list|,
name|offsets
argument_list|,
name|section_offsets_size
argument_list|)
expr_stmt|;
name|objfile
operator|->
name|num_sections
operator|=
name|num_offsets
expr_stmt|;
comment|/* What the hell is sym_new_init for, anyway?  The concept of 	     distinguishing between the main file and additional files 	     in this way seems rather dubious.  */
if|if
condition|(
name|objfile
operator|==
name|symfile_objfile
condition|)
block|{
call|(
modifier|*
name|objfile
operator|->
name|sf
operator|->
name|sym_new_init
call|)
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HPUXHPPA
name|RESET_HP_UX_GLOBALS
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
call|(
modifier|*
name|objfile
operator|->
name|sf
operator|->
name|sym_init
call|)
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
name|clear_complaints
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* The "mainline" parameter is a hideous hack; I think leaving it 	     zero is OK since dbxread.c also does what it needs to do if 	     objfile->global_psymbols.size is 0.  */
call|(
modifier|*
name|objfile
operator|->
name|sf
operator|->
name|sym_read
call|)
argument_list|(
name|objfile
argument_list|,
name|objfile
operator|->
name|section_offsets
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|have_partial_symbols
argument_list|()
operator|&&
operator|!
name|have_full_symbols
argument_list|()
condition|)
block|{
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"(no debugging symbols found)\n"
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
name|objfile
operator|->
name|flags
operator||=
name|OBJF_SYMS
expr_stmt|;
comment|/* We're done reading the symbol file; finish off complaints.  */
name|clear_complaints
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Getting new symbols may change our opinion about what is 	     frameless.  */
name|reinit_frame_cache
argument_list|()
expr_stmt|;
comment|/* Discard cleanups as symbol reading was successful.  */
name|discard_cleanups
argument_list|(
name|old_cleanups
argument_list|)
expr_stmt|;
comment|/* If the mtime has changed between the time we set new_modtime 	     and now, we *want* this to be out of date, so don't call stat 	     again now.  */
name|objfile
operator|->
name|mtime
operator|=
name|new_modtime
expr_stmt|;
name|reread_one
operator|=
literal|1
expr_stmt|;
comment|/* Call this after reading in a new symbol table to give target 	     dependant code a crack at the new symbols.  For instance, this 	     could be used to update the values of target-specific symbols GDB 	     needs to keep track of (such as _sigtramp, or whatever).  */
name|TARGET_SYMFILE_POSTREAD
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|reread_one
condition|)
name|clear_symtab_users
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|ext
decl_stmt|;
name|enum
name|language
name|lang
decl_stmt|;
block|}
name|filename_language
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|filename_language
modifier|*
name|filename_language_table
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fl_table_size
decl_stmt|,
name|fl_table_next
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|add_filename_language
parameter_list|(
name|ext
parameter_list|,
name|lang
parameter_list|)
name|char
modifier|*
name|ext
decl_stmt|;
name|enum
name|language
name|lang
decl_stmt|;
block|{
if|if
condition|(
name|fl_table_next
operator|>=
name|fl_table_size
condition|)
block|{
name|fl_table_size
operator|+=
literal|10
expr_stmt|;
name|filename_language_table
operator|=
name|realloc
argument_list|(
name|filename_language_table
argument_list|,
name|fl_table_size
argument_list|)
expr_stmt|;
block|}
name|filename_language_table
index|[
name|fl_table_next
index|]
operator|.
name|ext
operator|=
name|strsave
argument_list|(
name|ext
argument_list|)
expr_stmt|;
name|filename_language_table
index|[
name|fl_table_next
index|]
operator|.
name|lang
operator|=
name|lang
expr_stmt|;
name|fl_table_next
operator|++
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ext_args
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|set_ext_lang_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|cp
init|=
name|ext_args
decl_stmt|;
name|enum
name|language
name|lang
decl_stmt|;
comment|/* First arg is filename extension, starting with '.' */
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'.'
condition|)
name|error
argument_list|(
literal|"'%s': Filename extension must begin with '.'"
argument_list|,
name|ext_args
argument_list|)
expr_stmt|;
comment|/* Find end of first arg.  */
while|while
condition|(
operator|*
name|cp
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
name|error
argument_list|(
literal|"'%s': two arguments required -- filename extension and language"
argument_list|,
name|ext_args
argument_list|)
expr_stmt|;
comment|/* Null-terminate first arg */
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* Find beginning of second arg, which should be a source language.  */
while|while
condition|(
operator|*
name|cp
operator|&&
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
name|error
argument_list|(
literal|"'%s': two arguments required -- filename extension and language"
argument_list|,
name|ext_args
argument_list|)
expr_stmt|;
comment|/* Lookup the language from among those we know.  */
name|lang
operator|=
name|language_enum
argument_list|(
name|cp
argument_list|)
expr_stmt|;
comment|/* Now lookup the filename extension: do we already know it?  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fl_table_next
condition|;
name|i
operator|++
control|)
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
name|ext_args
argument_list|,
name|filename_language_table
index|[
name|i
index|]
operator|.
name|ext
argument_list|)
condition|)
break|break;
if|if
condition|(
name|i
operator|>=
name|fl_table_next
condition|)
block|{
comment|/* new file extension */
name|add_filename_language
argument_list|(
name|ext_args
argument_list|,
name|lang
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* redefining a previously known filename extension */
comment|/* if (from_tty) */
comment|/*   query ("Really make files of type %s '%s'?", */
comment|/*          ext_args, language_str (lang));           */
name|free
argument_list|(
name|filename_language_table
index|[
name|i
index|]
operator|.
name|ext
argument_list|)
expr_stmt|;
name|filename_language_table
index|[
name|i
index|]
operator|.
name|ext
operator|=
name|strsave
argument_list|(
name|ext_args
argument_list|)
expr_stmt|;
name|filename_language_table
index|[
name|i
index|]
operator|.
name|lang
operator|=
name|lang
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|info_ext_lang_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|printf_filtered
argument_list|(
literal|"Filename extensions and the languages they represent:"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fl_table_next
condition|;
name|i
operator|++
control|)
name|printf_filtered
argument_list|(
literal|"\t%s\t- %s\n"
argument_list|,
name|filename_language_table
index|[
name|i
index|]
operator|.
name|ext
argument_list|,
name|language_str
argument_list|(
name|filename_language_table
index|[
name|i
index|]
operator|.
name|lang
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|init_filename_language_table
parameter_list|()
block|{
if|if
condition|(
name|fl_table_size
operator|==
literal|0
condition|)
comment|/* protect against repetition */
block|{
name|fl_table_size
operator|=
literal|20
expr_stmt|;
name|fl_table_next
operator|=
literal|0
expr_stmt|;
name|filename_language_table
operator|=
name|xmalloc
argument_list|(
name|fl_table_size
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|filename_language_table
argument_list|)
argument_list|)
expr_stmt|;
name|add_filename_language
argument_list|(
literal|".c"
argument_list|,
name|language_c
argument_list|)
expr_stmt|;
name|add_filename_language
argument_list|(
literal|".C"
argument_list|,
name|language_cplus
argument_list|)
expr_stmt|;
name|add_filename_language
argument_list|(
literal|".cc"
argument_list|,
name|language_cplus
argument_list|)
expr_stmt|;
name|add_filename_language
argument_list|(
literal|".cp"
argument_list|,
name|language_cplus
argument_list|)
expr_stmt|;
name|add_filename_language
argument_list|(
literal|".cpp"
argument_list|,
name|language_cplus
argument_list|)
expr_stmt|;
name|add_filename_language
argument_list|(
literal|".cxx"
argument_list|,
name|language_cplus
argument_list|)
expr_stmt|;
name|add_filename_language
argument_list|(
literal|".c++"
argument_list|,
name|language_cplus
argument_list|)
expr_stmt|;
name|add_filename_language
argument_list|(
literal|".java"
argument_list|,
name|language_java
argument_list|)
expr_stmt|;
name|add_filename_language
argument_list|(
literal|".class"
argument_list|,
name|language_java
argument_list|)
expr_stmt|;
name|add_filename_language
argument_list|(
literal|".ch"
argument_list|,
name|language_chill
argument_list|)
expr_stmt|;
name|add_filename_language
argument_list|(
literal|".c186"
argument_list|,
name|language_chill
argument_list|)
expr_stmt|;
name|add_filename_language
argument_list|(
literal|".c286"
argument_list|,
name|language_chill
argument_list|)
expr_stmt|;
name|add_filename_language
argument_list|(
literal|".f"
argument_list|,
name|language_fortran
argument_list|)
expr_stmt|;
name|add_filename_language
argument_list|(
literal|".F"
argument_list|,
name|language_fortran
argument_list|)
expr_stmt|;
name|add_filename_language
argument_list|(
literal|".s"
argument_list|,
name|language_asm
argument_list|)
expr_stmt|;
name|add_filename_language
argument_list|(
literal|".S"
argument_list|,
name|language_asm
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|enum
name|language
name|deduce_language_from_filename
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|filename
operator|!=
name|NULL
condition|)
if|if
condition|(
operator|(
name|cp
operator|=
name|strrchr
argument_list|(
name|filename
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fl_table_next
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
name|filename_language_table
index|[
name|i
index|]
operator|.
name|ext
argument_list|)
operator|==
literal|0
condition|)
return|return
name|filename_language_table
index|[
name|i
index|]
operator|.
name|lang
return|;
return|return
name|language_unknown
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* allocate_symtab:     Allocate and partly initialize a new symbol table.  Return a pointer    to it.  error() if no space.     Caller must set these fields: 	LINETABLE(symtab) 	symtab->blockvector 	symtab->dirname 	symtab->free_code 	symtab->free_ptr 	possibly free_named_symtabs (symtab->filename);  */
end_comment

begin_function
name|struct
name|symtab
modifier|*
name|allocate_symtab
parameter_list|(
name|filename
parameter_list|,
name|objfile
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
specifier|register
name|struct
name|symtab
modifier|*
name|symtab
decl_stmt|;
name|symtab
operator|=
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symtab
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|symtab
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|symtab
argument_list|)
argument_list|)
expr_stmt|;
name|symtab
operator|->
name|filename
operator|=
name|obsavestring
argument_list|(
name|filename
argument_list|,
name|strlen
argument_list|(
name|filename
argument_list|)
argument_list|,
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|)
expr_stmt|;
name|symtab
operator|->
name|fullname
operator|=
name|NULL
expr_stmt|;
name|symtab
operator|->
name|language
operator|=
name|deduce_language_from_filename
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|symtab
operator|->
name|debugformat
operator|=
name|obsavestring
argument_list|(
literal|"unknown"
argument_list|,
literal|7
argument_list|,
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|)
expr_stmt|;
comment|/* Hook it to the objfile it comes from */
name|symtab
operator|->
name|objfile
operator|=
name|objfile
expr_stmt|;
name|symtab
operator|->
name|next
operator|=
name|objfile
operator|->
name|symtabs
expr_stmt|;
name|objfile
operator|->
name|symtabs
operator|=
name|symtab
expr_stmt|;
comment|/* FIXME: This should go away.  It is only defined for the Z8000,      and the Z8000 definition of this macro doesn't have anything to      do with the now-nonexistent EXTRA_SYMTAB_INFO macro, it's just      here for convenience.  */
ifdef|#
directive|ifdef
name|INIT_EXTRA_SYMTAB_INFO
name|INIT_EXTRA_SYMTAB_INFO
argument_list|(
name|symtab
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|symtab
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|partial_symtab
modifier|*
name|allocate_psymtab
parameter_list|(
name|filename
parameter_list|,
name|objfile
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|struct
name|partial_symtab
modifier|*
name|psymtab
decl_stmt|;
if|if
condition|(
name|objfile
operator|->
name|free_psymtabs
condition|)
block|{
name|psymtab
operator|=
name|objfile
operator|->
name|free_psymtabs
expr_stmt|;
name|objfile
operator|->
name|free_psymtabs
operator|=
name|psymtab
operator|->
name|next
expr_stmt|;
block|}
else|else
name|psymtab
operator|=
operator|(
expr|struct
name|partial_symtab
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|psymbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|partial_symtab
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|psymtab
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|partial_symtab
argument_list|)
argument_list|)
expr_stmt|;
name|psymtab
operator|->
name|filename
operator|=
name|obsavestring
argument_list|(
name|filename
argument_list|,
name|strlen
argument_list|(
name|filename
argument_list|)
argument_list|,
operator|&
name|objfile
operator|->
name|psymbol_obstack
argument_list|)
expr_stmt|;
name|psymtab
operator|->
name|symtab
operator|=
name|NULL
expr_stmt|;
comment|/* Prepend it to the psymtab list for the objfile it belongs to.      Psymtabs are searched in most recent inserted -> least recent      inserted order. */
name|psymtab
operator|->
name|objfile
operator|=
name|objfile
expr_stmt|;
name|psymtab
operator|->
name|next
operator|=
name|objfile
operator|->
name|psymtabs
expr_stmt|;
name|objfile
operator|->
name|psymtabs
operator|=
name|psymtab
expr_stmt|;
if|#
directive|if
literal|0
block|{     struct partial_symtab **prev_pst;     psymtab -> objfile = objfile;     psymtab -> next = NULL;     prev_pst =&(objfile -> psymtabs);     while ((*prev_pst) != NULL)       prev_pst =&((*prev_pst) -> next);     (*prev_pst) = psymtab;   }
endif|#
directive|endif
return|return
operator|(
name|psymtab
operator|)
return|;
block|}
end_function

begin_function
name|void
name|discard_psymtab
parameter_list|(
name|pst
parameter_list|)
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
block|{
name|struct
name|partial_symtab
modifier|*
modifier|*
name|prev_pst
decl_stmt|;
comment|/* From dbxread.c:      Empty psymtabs happen as a result of header files which don't      have any symbols in them.  There can be a lot of them.  But this      check is wrong, in that a psymtab with N_SLINE entries but      nothing else is not empty, but we don't realize that.  Fixing      that without slowing things down might be tricky.  */
comment|/* First, snip it out of the psymtab chain */
name|prev_pst
operator|=
operator|&
operator|(
name|pst
operator|->
name|objfile
operator|->
name|psymtabs
operator|)
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|prev_pst
operator|)
operator|!=
name|pst
condition|)
name|prev_pst
operator|=
operator|&
operator|(
operator|(
operator|*
name|prev_pst
operator|)
operator|->
name|next
operator|)
expr_stmt|;
operator|(
operator|*
name|prev_pst
operator|)
operator|=
name|pst
operator|->
name|next
expr_stmt|;
comment|/* Next, put it on a free list for recycling */
name|pst
operator|->
name|next
operator|=
name|pst
operator|->
name|objfile
operator|->
name|free_psymtabs
expr_stmt|;
name|pst
operator|->
name|objfile
operator|->
name|free_psymtabs
operator|=
name|pst
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Reset all data structures in gdb which may contain references to symbol    table data.  */
end_comment

begin_function
name|void
name|clear_symtab_users
parameter_list|()
block|{
comment|/* Someday, we should do better than this, by only blowing away      the things that really need to be blown.  */
name|clear_value_history
argument_list|()
expr_stmt|;
name|clear_displays
argument_list|()
expr_stmt|;
name|clear_internalvars
argument_list|()
expr_stmt|;
name|breakpoint_re_set
argument_list|()
expr_stmt|;
name|set_default_breakpoint
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|current_source_symtab
operator|=
literal|0
expr_stmt|;
name|current_source_line
operator|=
literal|0
expr_stmt|;
name|clear_pc_function_cache
argument_list|()
expr_stmt|;
name|target_new_objfile
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* clear_symtab_users_once:     This function is run after symbol reading, or from a cleanup.    If an old symbol table was obsoleted, the old symbol table    has been blown away, but the other GDB data structures that may     reference it have not yet been cleared or re-directed.  (The old    symtab was zapped, and the cleanup queued, in free_named_symtab()    below.)     This function can be queued N times as a cleanup, or called    directly; it will do all the work the first time, and then will be a    no-op until the next time it is queued.  This works by bumping a    counter at queueing time.  Much later when the cleanup is run, or at    the end of symbol processing (in case the cleanup is discarded), if    the queued count is greater than the "done-count", we do the work    and set the done-count to the queued count.  If the queued count is    less than or equal to the done-count, we just ignore the call.  This    is needed because reading a single .o file will often replace many    symtabs (one per .h file, for example), and we don't want to reset    the breakpoints N times in the user's face.     The reason we both queue a cleanup, and call it directly after symbol    reading, is because the cleanup protects us in case of errors, but is    discarded if symbol reading is successful.  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* FIXME:  As free_named_symtabs is currently a big noop this function    is no longer needed.  */
end_comment

begin_comment
unit|static void clear_symtab_users_once PARAMS ((void));  static int clear_symtab_users_queued; static int clear_symtab_users_done;  static void clear_symtab_users_once () {
comment|/* Enforce once-per-`do_cleanups'-semantics */
end_comment

begin_endif
unit|if (clear_symtab_users_queued<= clear_symtab_users_done)     return;   clear_symtab_users_done = clear_symtab_users_queued;    clear_symtab_users (); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* Delete the specified psymtab, and any others that reference it.  */
end_comment

begin_function
specifier|static
name|void
name|cashier_psymtab
parameter_list|(
name|pst
parameter_list|)
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
block|{
name|struct
name|partial_symtab
modifier|*
name|ps
decl_stmt|,
modifier|*
name|pprev
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Find its previous psymtab in the chain */
for|for
control|(
name|ps
operator|=
name|pst
operator|->
name|objfile
operator|->
name|psymtabs
init|;
name|ps
condition|;
name|ps
operator|=
name|ps
operator|->
name|next
control|)
block|{
if|if
condition|(
name|ps
operator|==
name|pst
condition|)
break|break;
name|pprev
operator|=
name|ps
expr_stmt|;
block|}
if|if
condition|(
name|ps
condition|)
block|{
comment|/* Unhook it from the chain.  */
if|if
condition|(
name|ps
operator|==
name|pst
operator|->
name|objfile
operator|->
name|psymtabs
condition|)
name|pst
operator|->
name|objfile
operator|->
name|psymtabs
operator|=
name|ps
operator|->
name|next
expr_stmt|;
else|else
name|pprev
operator|->
name|next
operator|=
name|ps
operator|->
name|next
expr_stmt|;
comment|/* FIXME, we can't conveniently deallocate the entries in the        partial_symbol lists (global_psymbols/static_psymbols) that        this psymtab points to.  These just take up space until all        the psymtabs are reclaimed.  Ditto the dependencies list and        filename, which are all in the psymbol_obstack.  */
comment|/* We need to cashier any psymtab that has this one as a dependency... */
name|again
label|:
for|for
control|(
name|ps
operator|=
name|pst
operator|->
name|objfile
operator|->
name|psymtabs
init|;
name|ps
condition|;
name|ps
operator|=
name|ps
operator|->
name|next
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ps
operator|->
name|number_of_dependencies
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ps
operator|->
name|dependencies
index|[
name|i
index|]
operator|==
name|pst
condition|)
block|{
name|cashier_psymtab
argument_list|(
name|ps
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
comment|/* Must restart, chain has been munged. */
block|}
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* If a symtab or psymtab for filename NAME is found, free it along    with any dependent breakpoints, displays, etc.    Used when loading new versions of object modules with the "add-file"    command.  This is only called on the top-level symtab or psymtab's name;    it is not called for subsidiary files such as .h files.     Return value is 1 if we blew away the environment, 0 if not.    FIXME.  The return valu appears to never be used.     FIXME.  I think this is not the best way to do this.  We should    work on being gentler to the environment while still cleaning up    all stray pointers into the freed symtab.  */
end_comment

begin_function
name|int
name|free_named_symtabs
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
if|#
directive|if
literal|0
comment|/* FIXME:  With the new method of each objfile having it's own      psymtab list, this function needs serious rethinking.  In particular,      why was it ever necessary to toss psymtabs with specific compilation      unit filenames, as opposed to all psymtabs from a particular symbol      file?  -- fnf      Well, the answer is that some systems permit reloading of particular      compilation units.  We want to blow away any old info about these      compilation units, regardless of which objfiles they arrived in. --gnu.  */
block|register struct symtab *s;   register struct symtab *prev;   register struct partial_symtab *ps;   struct blockvector *bv;   int blewit = 0;
comment|/* We only wack things if the symbol-reload switch is set.  */
block|if (!symbol_reloading)     return 0;
comment|/* Some symbol formats have trouble providing file names... */
block|if (name == 0 || *name == '\0')     return 0;
comment|/* Look for a psymtab with the specified name.  */
block|again2:   for (ps = partial_symtab_list; ps; ps = ps->next) {     if (STREQ (name, ps->filename)) {       cashier_psymtab (ps);
comment|/* Blow it away...and its little dog, too.  */
block|goto again2;
comment|/* Must restart, chain has been munged */
block|}   }
comment|/* Look for a symtab with the specified name.  */
block|for (s = symtab_list; s; s = s->next)     {       if (STREQ (name, s->filename)) 	break;       prev = s;     }    if (s)     {       if (s == symtab_list) 	symtab_list = s->next;       else 	prev->next = s->next;
comment|/* For now, queue a delete for all breakpoints, displays, etc., whether 	 or not they depend on the symtab being freed.  This should be 	 changed so that only those data structures affected are deleted.  */
comment|/* But don't delete anything if the symtab is empty. 	 This test is necessary due to a bug in "dbxread.c" that 	 causes empty symtabs to be created for N_SO symbols that 	 contain the pathname of the object file.  (This problem 	 has been fixed in GDB 3.9x).  */
block|bv = BLOCKVECTOR (s);       if (BLOCKVECTOR_NBLOCKS (bv)> 2 	  || BLOCK_NSYMS (BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK)) 	  || BLOCK_NSYMS (BLOCKVECTOR_BLOCK (bv, STATIC_BLOCK))) 	{ 	  complain (&oldsyms_complaint, name);  	  clear_symtab_users_queued++; 	  make_cleanup (clear_symtab_users_once, 0); 	  blewit = 1; 	} else { 	  complain (&empty_symtab_complaint, name); 	}        free_symtab (s);     }   else     {
comment|/* It is still possible that some breakpoints will be affected 	 even though no symtab was found, since the file might have 	 been compiled without debugging, and hence not be associated 	 with a symtab.  In order to handle this correctly, we would need 	 to keep a list of text address ranges for undebuggable files. 	 For now, we do nothing, since this is a fairly obscure case.  */
block|;     }
comment|/* FIXME, what about the minimal symbol table? */
block|return blewit;
else|#
directive|else
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Allocate and partially fill a partial symtab.  It will be    completely filled at the end of the symbol list.     SYMFILE_NAME is the name of the symbol-file we are reading from, and ADDR    is the address relative to which its symbols are (incremental) or 0    (normal). */
end_comment

begin_function
name|struct
name|partial_symtab
modifier|*
name|start_psymtab_common
parameter_list|(
name|objfile
parameter_list|,
name|section_offsets
parameter_list|,
name|filename
parameter_list|,
name|textlow
parameter_list|,
name|global_syms
parameter_list|,
name|static_syms
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|section_offsets
modifier|*
name|section_offsets
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|CORE_ADDR
name|textlow
decl_stmt|;
name|struct
name|partial_symbol
modifier|*
modifier|*
name|global_syms
decl_stmt|;
name|struct
name|partial_symbol
modifier|*
modifier|*
name|static_syms
decl_stmt|;
block|{
name|struct
name|partial_symtab
modifier|*
name|psymtab
decl_stmt|;
name|psymtab
operator|=
name|allocate_psymtab
argument_list|(
name|filename
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|psymtab
operator|->
name|section_offsets
operator|=
name|section_offsets
expr_stmt|;
name|psymtab
operator|->
name|textlow
operator|=
name|textlow
expr_stmt|;
name|psymtab
operator|->
name|texthigh
operator|=
name|psymtab
operator|->
name|textlow
expr_stmt|;
comment|/* default */
name|psymtab
operator|->
name|globals_offset
operator|=
name|global_syms
operator|-
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
expr_stmt|;
name|psymtab
operator|->
name|statics_offset
operator|=
name|static_syms
operator|-
name|objfile
operator|->
name|static_psymbols
operator|.
name|list
expr_stmt|;
return|return
operator|(
name|psymtab
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add a symbol with a long value to a psymtab.    Since one arg is a struct, we pass in a ptr and deref it (sigh).  */
end_comment

begin_function
name|void
name|add_psymbol_to_list
parameter_list|(
name|name
parameter_list|,
name|namelength
parameter_list|,
name|namespace
parameter_list|,
name|class
parameter_list|,
name|list
parameter_list|,
name|val
parameter_list|,
name|coreaddr
parameter_list|,
name|language
parameter_list|,
name|objfile
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|namelength
decl_stmt|;
name|namespace_enum
name|namespace
decl_stmt|;
name|enum
name|address_class
name|class
decl_stmt|;
name|struct
name|psymbol_allocation_list
modifier|*
name|list
decl_stmt|;
name|long
name|val
decl_stmt|;
comment|/* Value as a long */
name|CORE_ADDR
name|coreaddr
decl_stmt|;
comment|/* Value as a CORE_ADDR */
name|enum
name|language
name|language
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
specifier|register
name|struct
name|partial_symbol
modifier|*
name|psym
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|alloca
argument_list|(
name|namelength
operator|+
literal|1
argument_list|)
decl_stmt|;
comment|/* psymbol is static so that there will be no uninitialized gaps in the      structure which might contain random data, causing cache misses in      bcache. */
specifier|static
name|struct
name|partial_symbol
name|psymbol
decl_stmt|;
comment|/* Create local copy of the partial symbol */
name|memcpy
argument_list|(
name|buf
argument_list|,
name|name
argument_list|,
name|namelength
argument_list|)
expr_stmt|;
name|buf
index|[
name|namelength
index|]
operator|=
literal|'\0'
expr_stmt|;
name|SYMBOL_NAME
argument_list|(
operator|&
name|psymbol
argument_list|)
operator|=
name|bcache
argument_list|(
name|buf
argument_list|,
name|namelength
operator|+
literal|1
argument_list|,
operator|&
name|objfile
operator|->
name|psymbol_cache
argument_list|)
expr_stmt|;
comment|/* val and coreaddr are mutually exclusive, one of them *will* be zero */
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
block|{
name|SYMBOL_VALUE
argument_list|(
operator|&
name|psymbol
argument_list|)
operator|=
name|val
expr_stmt|;
block|}
else|else
block|{
name|SYMBOL_VALUE_ADDRESS
argument_list|(
operator|&
name|psymbol
argument_list|)
operator|=
name|coreaddr
expr_stmt|;
block|}
name|SYMBOL_SECTION
argument_list|(
operator|&
name|psymbol
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SYMBOL_LANGUAGE
argument_list|(
operator|&
name|psymbol
argument_list|)
operator|=
name|language
expr_stmt|;
name|PSYMBOL_NAMESPACE
argument_list|(
operator|&
name|psymbol
argument_list|)
operator|=
name|namespace
expr_stmt|;
name|PSYMBOL_CLASS
argument_list|(
operator|&
name|psymbol
argument_list|)
operator|=
name|class
expr_stmt|;
name|SYMBOL_INIT_LANGUAGE_SPECIFIC
argument_list|(
operator|&
name|psymbol
argument_list|,
name|language
argument_list|)
expr_stmt|;
comment|/* Stash the partial symbol away in the cache */
name|psym
operator|=
name|bcache
argument_list|(
operator|&
name|psymbol
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|partial_symbol
argument_list|)
argument_list|,
operator|&
name|objfile
operator|->
name|psymbol_cache
argument_list|)
expr_stmt|;
comment|/* Save pointer to partial symbol in psymtab, growing symtab if needed. */
if|if
condition|(
name|list
operator|->
name|next
operator|>=
name|list
operator|->
name|list
operator|+
name|list
operator|->
name|size
condition|)
block|{
name|extend_psymbol_list
argument_list|(
name|list
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
operator|*
name|list
operator|->
name|next
operator|++
operator|=
name|psym
expr_stmt|;
name|OBJSTAT
argument_list|(
name|objfile
argument_list|,
name|n_psyms
operator|++
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a symbol with a long value to a psymtab. This differs from  * add_psymbol_to_list above in taking both a mangled and a demangled  * name. */
end_comment

begin_function
name|void
name|add_psymbol_with_dem_name_to_list
parameter_list|(
name|name
parameter_list|,
name|namelength
parameter_list|,
name|dem_name
parameter_list|,
name|dem_namelength
parameter_list|,
name|namespace
parameter_list|,
name|class
parameter_list|,
name|list
parameter_list|,
name|val
parameter_list|,
name|coreaddr
parameter_list|,
name|language
parameter_list|,
name|objfile
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|namelength
decl_stmt|;
name|char
modifier|*
name|dem_name
decl_stmt|;
name|int
name|dem_namelength
decl_stmt|;
name|namespace_enum
name|namespace
decl_stmt|;
name|enum
name|address_class
name|class
decl_stmt|;
name|struct
name|psymbol_allocation_list
modifier|*
name|list
decl_stmt|;
name|long
name|val
decl_stmt|;
comment|/* Value as a long */
name|CORE_ADDR
name|coreaddr
decl_stmt|;
comment|/* Value as a CORE_ADDR */
name|enum
name|language
name|language
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
specifier|register
name|struct
name|partial_symbol
modifier|*
name|psym
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|alloca
argument_list|(
name|namelength
operator|+
literal|1
argument_list|)
decl_stmt|;
comment|/* psymbol is static so that there will be no uninitialized gaps in the      structure which might contain random data, causing cache misses in      bcache. */
specifier|static
name|struct
name|partial_symbol
name|psymbol
decl_stmt|;
comment|/* Create local copy of the partial symbol */
name|memcpy
argument_list|(
name|buf
argument_list|,
name|name
argument_list|,
name|namelength
argument_list|)
expr_stmt|;
name|buf
index|[
name|namelength
index|]
operator|=
literal|'\0'
expr_stmt|;
name|SYMBOL_NAME
argument_list|(
operator|&
name|psymbol
argument_list|)
operator|=
name|bcache
argument_list|(
name|buf
argument_list|,
name|namelength
operator|+
literal|1
argument_list|,
operator|&
name|objfile
operator|->
name|psymbol_cache
argument_list|)
expr_stmt|;
name|buf
operator|=
name|alloca
argument_list|(
name|dem_namelength
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
name|dem_name
argument_list|,
name|dem_namelength
argument_list|)
expr_stmt|;
name|buf
index|[
name|dem_namelength
index|]
operator|=
literal|'\0'
expr_stmt|;
switch|switch
condition|(
name|language
condition|)
block|{
case|case
name|language_c
case|:
case|case
name|language_cplus
case|:
name|SYMBOL_CPLUS_DEMANGLED_NAME
argument_list|(
operator|&
name|psymbol
argument_list|)
operator|=
name|bcache
argument_list|(
name|buf
argument_list|,
name|dem_namelength
operator|+
literal|1
argument_list|,
operator|&
name|objfile
operator|->
name|psymbol_cache
argument_list|)
expr_stmt|;
break|break;
case|case
name|language_chill
case|:
name|SYMBOL_CHILL_DEMANGLED_NAME
argument_list|(
operator|&
name|psymbol
argument_list|)
operator|=
name|bcache
argument_list|(
name|buf
argument_list|,
name|dem_namelength
operator|+
literal|1
argument_list|,
operator|&
name|objfile
operator|->
name|psymbol_cache
argument_list|)
expr_stmt|;
comment|/* FIXME What should be done for the default case? Ignoring for now. */
block|}
comment|/* val and coreaddr are mutually exclusive, one of them *will* be zero */
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
block|{
name|SYMBOL_VALUE
argument_list|(
operator|&
name|psymbol
argument_list|)
operator|=
name|val
expr_stmt|;
block|}
else|else
block|{
name|SYMBOL_VALUE_ADDRESS
argument_list|(
operator|&
name|psymbol
argument_list|)
operator|=
name|coreaddr
expr_stmt|;
block|}
name|SYMBOL_SECTION
argument_list|(
operator|&
name|psymbol
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SYMBOL_LANGUAGE
argument_list|(
operator|&
name|psymbol
argument_list|)
operator|=
name|language
expr_stmt|;
name|PSYMBOL_NAMESPACE
argument_list|(
operator|&
name|psymbol
argument_list|)
operator|=
name|namespace
expr_stmt|;
name|PSYMBOL_CLASS
argument_list|(
operator|&
name|psymbol
argument_list|)
operator|=
name|class
expr_stmt|;
name|SYMBOL_INIT_LANGUAGE_SPECIFIC
argument_list|(
operator|&
name|psymbol
argument_list|,
name|language
argument_list|)
expr_stmt|;
comment|/* Stash the partial symbol away in the cache */
name|psym
operator|=
name|bcache
argument_list|(
operator|&
name|psymbol
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|partial_symbol
argument_list|)
argument_list|,
operator|&
name|objfile
operator|->
name|psymbol_cache
argument_list|)
expr_stmt|;
comment|/* Save pointer to partial symbol in psymtab, growing symtab if needed. */
if|if
condition|(
name|list
operator|->
name|next
operator|>=
name|list
operator|->
name|list
operator|+
name|list
operator|->
name|size
condition|)
block|{
name|extend_psymbol_list
argument_list|(
name|list
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
operator|*
name|list
operator|->
name|next
operator|++
operator|=
name|psym
expr_stmt|;
name|OBJSTAT
argument_list|(
name|objfile
argument_list|,
name|n_psyms
operator|++
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize storage for partial symbols.  */
end_comment

begin_function
name|void
name|init_psymbol_list
parameter_list|(
name|objfile
parameter_list|,
name|total_symbols
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|int
name|total_symbols
decl_stmt|;
block|{
comment|/* Free any previously allocated psymbol lists.  */
if|if
condition|(
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
condition|)
block|{
name|mfree
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
operator|(
name|PTR
operator|)
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|objfile
operator|->
name|static_psymbols
operator|.
name|list
condition|)
block|{
name|mfree
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
operator|(
name|PTR
operator|)
name|objfile
operator|->
name|static_psymbols
operator|.
name|list
argument_list|)
expr_stmt|;
block|}
comment|/* Current best guess is that approximately a twentieth      of the total symbols (in a debugging file) are global or static      oriented symbols */
name|objfile
operator|->
name|global_psymbols
operator|.
name|size
operator|=
name|total_symbols
operator|/
literal|10
expr_stmt|;
name|objfile
operator|->
name|static_psymbols
operator|.
name|size
operator|=
name|total_symbols
operator|/
literal|10
expr_stmt|;
if|if
condition|(
name|objfile
operator|->
name|global_psymbols
operator|.
name|size
operator|>
literal|0
condition|)
block|{
name|objfile
operator|->
name|global_psymbols
operator|.
name|next
operator|=
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
operator|=
operator|(
expr|struct
name|partial_symbol
operator|*
operator|*
operator|)
name|xmmalloc
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
operator|(
name|objfile
operator|->
name|global_psymbols
operator|.
name|size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|partial_symbol
operator|*
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|objfile
operator|->
name|static_psymbols
operator|.
name|size
operator|>
literal|0
condition|)
block|{
name|objfile
operator|->
name|static_psymbols
operator|.
name|next
operator|=
name|objfile
operator|->
name|static_psymbols
operator|.
name|list
operator|=
operator|(
expr|struct
name|partial_symbol
operator|*
operator|*
operator|)
name|xmmalloc
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
operator|(
name|objfile
operator|->
name|static_psymbols
operator|.
name|size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|partial_symbol
operator|*
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* OVERLAYS:    The following code implements an abstraction for debugging overlay sections.     The target model is as follows:    1) The gnu linker will permit multiple sections to be mapped into the       same VMA, each with its own unique LMA (or load address).    2) It is assumed that some runtime mechanism exists for mapping the       sections, one by one, from the load address into the VMA address.    3) This code provides a mechanism for gdb to keep track of which        sections should be considered to be mapped from the VMA to the LMA.       This information is used for symbol lookup, and memory read/write.       For instance, if a section has been mapped then its contents        should be read from the VMA, otherwise from the LMA.     Two levels of debugger support for overlays are available.  One is    "manual", in which the debugger relies on the user to tell it which    overlays are currently mapped.  This level of support is    implemented entirely in the core debugger, and the information about    whether a section is mapped is kept in the objfile->obj_section table.     The second level of support is "automatic", and is only available if    the target-specific code provides functionality to read the target's    overlay mapping table, and translate its contents for the debugger    (by updating the mapped state information in the obj_section tables).     The interface is as follows:      User commands:        overlay map<name>	-- tell gdb to consider this section mapped        overlay unmap<name>	-- tell gdb to consider this section unmapped        overlay list		-- list the sections that GDB thinks are mapped        overlay read-target	-- get the target's state of what's mapped        overlay off/manual/auto -- set overlay debugging state      Functional interface:        find_pc_mapped_section(pc):    if the pc is in the range of a mapped 				      section, return that section.        find_pc_overlay(pc):	      find any overlay section that contains  				      the pc, either in its VMA or its LMA        overlay_is_mapped(sect):       true if overlay is marked as mapped        section_is_overlay(sect):      true if section's VMA != LMA        pc_in_mapped_range(pc,sec):    true if pc belongs to section's VMA        pc_in_unmapped_range(...):     true if pc belongs to section's LMA        overlay_mapped_address(...):   map an address from section's LMA to VMA        overlay_unmapped_address(...): map an address from section's VMA to LMA        symbol_overlayed_address(...): Return a "current" address for symbol: 				      either in VMA or LMA depending on whether 				      the symbol's section is currently mapped  */
end_comment

begin_comment
comment|/* Overlay debugging state: */
end_comment

begin_decl_stmt
name|int
name|overlay_debugging
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 0 == off, 1 == manual, -1 == auto */
end_comment

begin_decl_stmt
name|int
name|overlay_cache_invalid
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True if need to refresh mapped state */
end_comment

begin_comment
comment|/* Target vector for refreshing overlay mapped state */
end_comment

begin_decl_stmt
specifier|static
name|void
name|simple_overlay_update
name|PARAMS
argument_list|(
operator|(
expr|struct
name|obj_section
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_macro
name|void
argument_list|(
argument|*target_overlay_update
argument_list|)
end_macro

begin_expr_stmt
name|PARAMS
argument_list|(
operator|(
expr|struct
name|obj_section
operator|*
operator|)
argument_list|)
operator|=
name|simple_overlay_update
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Function: section_is_overlay (SECTION)    Returns true if SECTION has VMA not equal to LMA, ie.     SECTION is loaded at an address different from where it will "run".  */
end_comment

begin_function
name|int
name|section_is_overlay
parameter_list|(
name|section
parameter_list|)
name|asection
modifier|*
name|section
decl_stmt|;
block|{
if|if
condition|(
name|overlay_debugging
condition|)
if|if
condition|(
name|section
operator|&&
name|section
operator|->
name|lma
operator|!=
literal|0
operator|&&
name|section
operator|->
name|vma
operator|!=
name|section
operator|->
name|lma
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Function: overlay_invalidate_all (void)    Invalidate the mapped state of all overlay sections (mark it as stale).  */
end_comment

begin_function
specifier|static
name|void
name|overlay_invalidate_all
parameter_list|()
block|{
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|obj_section
modifier|*
name|sect
decl_stmt|;
name|ALL_OBJSECTIONS
argument_list|(
argument|objfile
argument_list|,
argument|sect
argument_list|)
if|if
condition|(
name|section_is_overlay
argument_list|(
name|sect
operator|->
name|the_bfd_section
argument_list|)
condition|)
name|sect
operator|->
name|ovly_mapped
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Function: overlay_is_mapped (SECTION)    Returns true if section is an overlay, and is currently mapped.     Private: public access is thru function section_is_mapped.     Access to the ovly_mapped flag is restricted to this function, so    that we can do automatic update.  If the global flag    OVERLAY_CACHE_INVALID is set (by wait_for_inferior), then call    overlay_invalidate_all.  If the mapped state of the particular    section is stale, then call TARGET_OVERLAY_UPDATE to refresh it.  */
end_comment

begin_function
specifier|static
name|int
name|overlay_is_mapped
parameter_list|(
name|osect
parameter_list|)
name|struct
name|obj_section
modifier|*
name|osect
decl_stmt|;
block|{
if|if
condition|(
name|osect
operator|==
literal|0
operator|||
operator|!
name|section_is_overlay
argument_list|(
name|osect
operator|->
name|the_bfd_section
argument_list|)
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|overlay_debugging
condition|)
block|{
default|default:
case|case
literal|0
case|:
return|return
literal|0
return|;
comment|/* overlay debugging off */
case|case
operator|-
literal|1
case|:
comment|/* overlay debugging automatic */
comment|/* Unles there is a target_overlay_update function,  	 there's really nothing useful to do here (can't really go auto)  */
if|if
condition|(
name|target_overlay_update
condition|)
block|{
if|if
condition|(
name|overlay_cache_invalid
condition|)
block|{
name|overlay_invalidate_all
argument_list|()
expr_stmt|;
name|overlay_cache_invalid
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|osect
operator|->
name|ovly_mapped
operator|==
operator|-
literal|1
condition|)
call|(
modifier|*
name|target_overlay_update
call|)
argument_list|(
name|osect
argument_list|)
expr_stmt|;
block|}
comment|/* fall thru to manual case */
case|case
literal|1
case|:
comment|/* overlay debugging manual */
return|return
name|osect
operator|->
name|ovly_mapped
operator|==
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/* Function: section_is_mapped    Returns true if section is an overlay, and is currently mapped.  */
end_comment

begin_function
name|int
name|section_is_mapped
parameter_list|(
name|section
parameter_list|)
name|asection
modifier|*
name|section
decl_stmt|;
block|{
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|obj_section
modifier|*
name|osect
decl_stmt|;
if|if
condition|(
name|overlay_debugging
condition|)
if|if
condition|(
name|section
operator|&&
name|section_is_overlay
argument_list|(
name|section
argument_list|)
condition|)
name|ALL_OBJSECTIONS
argument_list|(
argument|objfile
argument_list|,
argument|osect
argument_list|)
if|if
condition|(
name|osect
operator|->
name|the_bfd_section
operator|==
name|section
condition|)
return|return
name|overlay_is_mapped
argument_list|(
name|osect
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Function: pc_in_unmapped_range    If PC falls into the lma range of SECTION, return true, else false.  */
end_comment

begin_function
name|CORE_ADDR
name|pc_in_unmapped_range
parameter_list|(
name|pc
parameter_list|,
name|section
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
block|{
name|int
name|size
decl_stmt|;
if|if
condition|(
name|overlay_debugging
condition|)
if|if
condition|(
name|section
operator|&&
name|section_is_overlay
argument_list|(
name|section
argument_list|)
condition|)
block|{
name|size
operator|=
name|bfd_get_section_size_before_reloc
argument_list|(
name|section
argument_list|)
expr_stmt|;
if|if
condition|(
name|section
operator|->
name|lma
operator|<=
name|pc
operator|&&
name|pc
operator|<
name|section
operator|->
name|lma
operator|+
name|size
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Function: pc_in_mapped_range    If PC falls into the vma range of SECTION, return true, else false.  */
end_comment

begin_function
name|CORE_ADDR
name|pc_in_mapped_range
parameter_list|(
name|pc
parameter_list|,
name|section
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
block|{
name|int
name|size
decl_stmt|;
if|if
condition|(
name|overlay_debugging
condition|)
if|if
condition|(
name|section
operator|&&
name|section_is_overlay
argument_list|(
name|section
argument_list|)
condition|)
block|{
name|size
operator|=
name|bfd_get_section_size_before_reloc
argument_list|(
name|section
argument_list|)
expr_stmt|;
if|if
condition|(
name|section
operator|->
name|vma
operator|<=
name|pc
operator|&&
name|pc
operator|<
name|section
operator|->
name|vma
operator|+
name|size
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Function: overlay_unmapped_address (PC, SECTION)    Returns the address corresponding to PC in the unmapped (load) range.    May be the same as PC.  */
end_comment

begin_function
name|CORE_ADDR
name|overlay_unmapped_address
parameter_list|(
name|pc
parameter_list|,
name|section
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
block|{
if|if
condition|(
name|overlay_debugging
condition|)
if|if
condition|(
name|section
operator|&&
name|section_is_overlay
argument_list|(
name|section
argument_list|)
operator|&&
name|pc_in_mapped_range
argument_list|(
name|pc
argument_list|,
name|section
argument_list|)
condition|)
return|return
name|pc
operator|+
name|section
operator|->
name|lma
operator|-
name|section
operator|->
name|vma
return|;
return|return
name|pc
return|;
block|}
end_function

begin_comment
comment|/* Function: overlay_mapped_address (PC, SECTION)    Returns the address corresponding to PC in the mapped (runtime) range.    May be the same as PC.  */
end_comment

begin_function
name|CORE_ADDR
name|overlay_mapped_address
parameter_list|(
name|pc
parameter_list|,
name|section
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
block|{
if|if
condition|(
name|overlay_debugging
condition|)
if|if
condition|(
name|section
operator|&&
name|section_is_overlay
argument_list|(
name|section
argument_list|)
operator|&&
name|pc_in_unmapped_range
argument_list|(
name|pc
argument_list|,
name|section
argument_list|)
condition|)
return|return
name|pc
operator|+
name|section
operator|->
name|vma
operator|-
name|section
operator|->
name|lma
return|;
return|return
name|pc
return|;
block|}
end_function

begin_comment
comment|/* Function: symbol_overlayed_address     Return one of two addresses (relative to the VMA or to the LMA),    depending on whether the section is mapped or not.  */
end_comment

begin_function
name|CORE_ADDR
name|symbol_overlayed_address
parameter_list|(
name|address
parameter_list|,
name|section
parameter_list|)
name|CORE_ADDR
name|address
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
block|{
if|if
condition|(
name|overlay_debugging
condition|)
block|{
comment|/* If the symbol has no section, just return its regular address. */
if|if
condition|(
name|section
operator|==
literal|0
condition|)
return|return
name|address
return|;
comment|/* If the symbol's section is not an overlay, just return its address */
if|if
condition|(
operator|!
name|section_is_overlay
argument_list|(
name|section
argument_list|)
condition|)
return|return
name|address
return|;
comment|/* If the symbol's section is mapped, just return its address */
if|if
condition|(
name|section_is_mapped
argument_list|(
name|section
argument_list|)
condition|)
return|return
name|address
return|;
comment|/*        * HOWEVER: if the symbol is in an overlay section which is NOT mapped,        * then return its LOADED address rather than its vma address!!        */
return|return
name|overlay_unmapped_address
argument_list|(
name|address
argument_list|,
name|section
argument_list|)
return|;
block|}
return|return
name|address
return|;
block|}
end_function

begin_comment
comment|/* Function: find_pc_overlay (PC)     Return the best-match overlay section for PC:    If PC matches a mapped overlay section's VMA, return that section.    Else if PC matches an unmapped section's VMA, return that section.    Else if PC matches an unmapped section's LMA, return that section.  */
end_comment

begin_function
name|asection
modifier|*
name|find_pc_overlay
parameter_list|(
name|pc
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
block|{
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|obj_section
modifier|*
name|osect
decl_stmt|,
modifier|*
name|best_match
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|overlay_debugging
condition|)
name|ALL_OBJSECTIONS
argument_list|(
argument|objfile
argument_list|,
argument|osect
argument_list|)
if|if
condition|(
name|section_is_overlay
argument_list|(
name|osect
operator|->
name|the_bfd_section
argument_list|)
condition|)
block|{
if|if
condition|(
name|pc_in_mapped_range
argument_list|(
name|pc
argument_list|,
name|osect
operator|->
name|the_bfd_section
argument_list|)
condition|)
block|{
if|if
condition|(
name|overlay_is_mapped
argument_list|(
name|osect
argument_list|)
condition|)
return|return
name|osect
operator|->
name|the_bfd_section
return|;
else|else
name|best_match
operator|=
name|osect
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pc_in_unmapped_range
argument_list|(
name|pc
argument_list|,
name|osect
operator|->
name|the_bfd_section
argument_list|)
condition|)
name|best_match
operator|=
name|osect
expr_stmt|;
block|}
return|return
name|best_match
condition|?
name|best_match
operator|->
name|the_bfd_section
else|:
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Function: find_pc_mapped_section (PC)    If PC falls into the VMA address range of an overlay section that is     currently marked as MAPPED, return that section.  Else return NULL.  */
end_comment

begin_function
name|asection
modifier|*
name|find_pc_mapped_section
parameter_list|(
name|pc
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
block|{
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|obj_section
modifier|*
name|osect
decl_stmt|;
if|if
condition|(
name|overlay_debugging
condition|)
name|ALL_OBJSECTIONS
argument_list|(
argument|objfile
argument_list|,
argument|osect
argument_list|)
if|if
condition|(
name|pc_in_mapped_range
argument_list|(
name|pc
argument_list|,
name|osect
operator|->
name|the_bfd_section
argument_list|)
operator|&&
name|overlay_is_mapped
argument_list|(
name|osect
argument_list|)
condition|)
return|return
name|osect
operator|->
name|the_bfd_section
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Function: list_overlays_command    Print a list of mapped sections and their PC ranges */
end_comment

begin_function
name|void
name|list_overlays_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|int
name|nmapped
init|=
literal|0
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|obj_section
modifier|*
name|osect
decl_stmt|;
if|if
condition|(
name|overlay_debugging
condition|)
name|ALL_OBJSECTIONS
argument_list|(
argument|objfile
argument_list|,
argument|osect
argument_list|)
if|if
condition|(
name|overlay_is_mapped
argument_list|(
name|osect
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|bfd_vma
name|lma
decl_stmt|,
name|vma
decl_stmt|;
name|int
name|size
decl_stmt|;
name|vma
operator|=
name|bfd_section_vma
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|osect
operator|->
name|the_bfd_section
argument_list|)
expr_stmt|;
name|lma
operator|=
name|bfd_section_lma
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|osect
operator|->
name|the_bfd_section
argument_list|)
expr_stmt|;
name|size
operator|=
name|bfd_get_section_size_before_reloc
argument_list|(
name|osect
operator|->
name|the_bfd_section
argument_list|)
expr_stmt|;
name|name
operator|=
name|bfd_section_name
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|osect
operator|->
name|the_bfd_section
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Section %s, loaded at "
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|lma
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
literal|" - "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|lma
operator|+
name|size
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|", mapped at "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|vma
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
literal|" - "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|vma
operator|+
name|size
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|nmapped
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|nmapped
operator|==
literal|0
condition|)
name|printf_filtered
argument_list|(
literal|"No sections are mapped.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Function: map_overlay_command    Mark the named section as mapped (ie. residing at its VMA address).  */
end_comment

begin_function
name|void
name|map_overlay_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|,
modifier|*
name|objfile2
decl_stmt|;
name|struct
name|obj_section
modifier|*
name|sec
decl_stmt|,
modifier|*
name|sec2
decl_stmt|;
name|asection
modifier|*
name|bfdsec
decl_stmt|;
if|if
condition|(
operator|!
name|overlay_debugging
condition|)
name|error
argument_list|(
literal|"Overlay debugging not enabled.  Use the 'OVERLAY ON' command."
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|==
literal|0
operator|||
operator|*
name|args
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Argument required: name of an overlay section"
argument_list|)
expr_stmt|;
comment|/* First, find a section matching the user supplied argument */
name|ALL_OBJSECTIONS
argument_list|(
argument|objfile
argument_list|,
argument|sec
argument_list|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|bfd_section_name
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|sec
operator|->
name|the_bfd_section
argument_list|)
argument_list|,
name|args
argument_list|)
condition|)
block|{
comment|/* Now, check to see if the section is an overlay. */
name|bfdsec
operator|=
name|sec
operator|->
name|the_bfd_section
expr_stmt|;
if|if
condition|(
operator|!
name|section_is_overlay
argument_list|(
name|bfdsec
argument_list|)
condition|)
continue|continue;
comment|/* not an overlay section */
comment|/* Mark the overlay as "mapped" */
name|sec
operator|->
name|ovly_mapped
operator|=
literal|1
expr_stmt|;
comment|/* Next, make a pass and unmap any sections that are 	   overlapped by this new section: */
name|ALL_OBJSECTIONS
argument_list|(
argument|objfile2
argument_list|,
argument|sec2
argument_list|)
if|if
condition|(
name|sec2
operator|->
name|ovly_mapped
operator|&&
name|sec
operator|!=
name|sec2
operator|&&
name|sec
operator|->
name|the_bfd_section
operator|!=
name|sec2
operator|->
name|the_bfd_section
operator|&&
operator|(
name|pc_in_mapped_range
argument_list|(
name|sec2
operator|->
name|addr
argument_list|,
name|sec
operator|->
name|the_bfd_section
argument_list|)
operator|||
name|pc_in_mapped_range
argument_list|(
name|sec2
operator|->
name|endaddr
argument_list|,
name|sec
operator|->
name|the_bfd_section
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|info_verbose
condition|)
name|printf_filtered
argument_list|(
literal|"Note: section %s unmapped by overlap\n"
argument_list|,
name|bfd_section_name
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|sec2
operator|->
name|the_bfd_section
argument_list|)
argument_list|)
expr_stmt|;
name|sec2
operator|->
name|ovly_mapped
operator|=
literal|0
expr_stmt|;
comment|/* sec2 overlaps sec: unmap sec2 */
block|}
return|return;
block|}
name|error
argument_list|(
literal|"No overlay section called %s"
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Function: unmap_overlay_command    Mark the overlay section as unmapped     (ie. resident in its LMA address range, rather than the VMA range).  */
end_comment

begin_function
name|void
name|unmap_overlay_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|obj_section
modifier|*
name|sec
decl_stmt|;
if|if
condition|(
operator|!
name|overlay_debugging
condition|)
name|error
argument_list|(
literal|"Overlay debugging not enabled.  Use the 'OVERLAY ON' command."
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|==
literal|0
operator|||
operator|*
name|args
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Argument required: name of an overlay section"
argument_list|)
expr_stmt|;
comment|/* First, find a section matching the user supplied argument */
name|ALL_OBJSECTIONS
argument_list|(
argument|objfile
argument_list|,
argument|sec
argument_list|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|bfd_section_name
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|sec
operator|->
name|the_bfd_section
argument_list|)
argument_list|,
name|args
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|sec
operator|->
name|ovly_mapped
condition|)
name|error
argument_list|(
literal|"Section %s is not mapped"
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|sec
operator|->
name|ovly_mapped
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|error
argument_list|(
literal|"No overlay section called %s"
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Function: overlay_auto_command    A utility command to turn on overlay debugging.    Possibly this should be done via a set/show command. */
end_comment

begin_function
specifier|static
name|void
name|overlay_auto_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|overlay_debugging
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|info_verbose
condition|)
name|printf_filtered
argument_list|(
literal|"Automatic overlay debugging enabled."
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Function: overlay_manual_command    A utility command to turn on overlay debugging.    Possibly this should be done via a set/show command. */
end_comment

begin_function
specifier|static
name|void
name|overlay_manual_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|overlay_debugging
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|info_verbose
condition|)
name|printf_filtered
argument_list|(
literal|"Overlay debugging enabled."
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Function: overlay_off_command    A utility command to turn on overlay debugging.    Possibly this should be done via a set/show command. */
end_comment

begin_function
specifier|static
name|void
name|overlay_off_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|overlay_debugging
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|info_verbose
condition|)
name|printf_filtered
argument_list|(
literal|"Overlay debugging disabled."
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|overlay_load_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
if|if
condition|(
name|target_overlay_update
condition|)
call|(
modifier|*
name|target_overlay_update
call|)
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"This target does not know how to read its overlay state."
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Function: overlay_command    A place-holder for a mis-typed command */
end_comment

begin_comment
comment|/* Command list chain containing all defined "overlay" subcommands. */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|overlaylist
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|overlay_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|printf_unfiltered
argument_list|(
literal|"\"overlay\" must be followed by the name of an overlay command.\n"
argument_list|)
expr_stmt|;
name|help_list
argument_list|(
name|overlaylist
argument_list|,
literal|"overlay "
argument_list|,
operator|-
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Target Overlays for the "Simplest" overlay manager:     This is GDB's default target overlay layer.  It works with the     minimal overlay manager supplied as an example by Cygnus.  The     entry point is via a function pointer "target_overlay_update",     so targets that use a different runtime overlay manager can     substitute their own overlay_update function and take over the    function pointer.     The overlay_update function pokes around in the target's data structures    to see what overlays are mapped, and updates GDB's overlay mapping with    this information.     In this simple implementation, the target data structures are as follows:    	unsigned _novlys;		/# number of overlay sections #/ 	unsigned _ovly_table[_novlys][4] = { 	  {VMA, SIZE, LMA, MAPPED},	/# one entry per overlay section #/ 	  {..., ...,  ..., ...}, 	} 	unsigned _novly_regions;	/# number of overlay regions #/ 	unsigned _ovly_region_table[_novly_regions][3] = { 	  {VMA, SIZE, MAPPED_TO_LMA},	/# one entry per overlay region #/ 	  {..., ...,  ...}, 	}    These functions will attempt to update GDB's mappedness state in the    symbol section table, based on the target's mappedness state.     To do this, we keep a cached copy of the target's _ovly_table, and    attempt to detect when the cached copy is invalidated.  The main    entry point is "simple_overlay_update(SECT), which looks up SECT in    the cached table and re-reads only the entry for that section from    the target (whenever possible).  */
end_comment

begin_comment
comment|/* Cached, dynamically allocated copies of the target data structures: */
end_comment

begin_expr_stmt
specifier|static
name|unsigned
argument_list|(
operator|*
name|cache_ovly_table
argument_list|)
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static unsigned  (*cache_ovly_region_table)[3] = 0;
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|unsigned
name|cache_novlys
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static unsigned  cache_novly_regions = 0;
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|cache_ovly_table_base
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static CORE_ADDR cache_ovly_region_table_base = 0;
endif|#
directive|endif
end_endif

begin_enum
enum|enum
name|ovly_index
block|{
name|VMA
block|,
name|SIZE
block|,
name|LMA
block|,
name|MAPPED
block|}
enum|;
end_enum

begin_define
define|#
directive|define
name|TARGET_LONG_BYTES
value|(TARGET_LONG_BIT / TARGET_CHAR_BIT)
end_define

begin_comment
comment|/* Throw away the cached copy of _ovly_table */
end_comment

begin_function
specifier|static
name|void
name|simple_free_overlay_table
parameter_list|()
block|{
if|if
condition|(
name|cache_ovly_table
condition|)
name|free
argument_list|(
name|cache_ovly_table
argument_list|)
expr_stmt|;
name|cache_novlys
operator|=
literal|0
expr_stmt|;
name|cache_ovly_table
operator|=
name|NULL
expr_stmt|;
name|cache_ovly_table_base
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Throw away the cached copy of _ovly_region_table */
end_comment

begin_endif
unit|static void simple_free_overlay_region_table () {   if (cache_ovly_region_table)     free(cache_ovly_region_table);   cache_novly_regions     = 0;   cache_ovly_region_table = NULL;   cache_ovly_region_table_base = 0; }
endif|#
directive|endif
end_endif

begin_comment
comment|/* Read an array of ints from the target into a local buffer.    Convert to host order.  int LEN is number of ints  */
end_comment

begin_function
specifier|static
name|void
name|read_target_long_array
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|unsigned
name|int
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|char
modifier|*
name|buf
init|=
name|alloca
argument_list|(
name|len
operator|*
name|TARGET_LONG_BYTES
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|read_memory
argument_list|(
name|memaddr
argument_list|,
name|buf
argument_list|,
name|len
operator|*
name|TARGET_LONG_BYTES
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|myaddr
index|[
name|i
index|]
operator|=
name|extract_unsigned_integer
argument_list|(
name|TARGET_LONG_BYTES
operator|*
name|i
operator|+
name|buf
argument_list|,
name|TARGET_LONG_BYTES
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find and grab a copy of the target _ovly_table    (and _novlys, which is needed for the table's size) */
end_comment

begin_function
specifier|static
name|int
name|simple_read_overlay_table
parameter_list|()
block|{
name|struct
name|minimal_symbol
modifier|*
name|msym
decl_stmt|;
name|simple_free_overlay_table
argument_list|()
expr_stmt|;
name|msym
operator|=
name|lookup_minimal_symbol
argument_list|(
literal|"_novlys"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|msym
operator|!=
name|NULL
condition|)
name|cache_novlys
operator|=
name|read_memory_integer
argument_list|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msym
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
else|else
return|return
literal|0
return|;
comment|/* failure */
name|cache_ovly_table
operator|=
operator|(
name|void
operator|*
operator|)
name|xmalloc
argument_list|(
name|cache_novlys
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|cache_ovly_table
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cache_ovly_table
operator|!=
name|NULL
condition|)
block|{
name|msym
operator|=
name|lookup_minimal_symbol
argument_list|(
literal|"_ovly_table"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|msym
operator|!=
name|NULL
condition|)
block|{
name|cache_ovly_table_base
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msym
argument_list|)
expr_stmt|;
name|read_target_long_array
argument_list|(
name|cache_ovly_table_base
argument_list|,
operator|(
name|int
operator|*
operator|)
name|cache_ovly_table
argument_list|,
name|cache_novlys
operator|*
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
comment|/* failure */
block|}
else|else
return|return
literal|0
return|;
comment|/* failure */
return|return
literal|1
return|;
comment|/* SUCCESS */
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Find and grab a copy of the target _ovly_region_table    (and _novly_regions, which is needed for the table's size) */
end_comment

begin_comment
unit|static int  simple_read_overlay_region_table () {   struct minimal_symbol *msym;    simple_free_overlay_region_table ();   msym = lookup_minimal_symbol ("_novly_regions", 0, 0);   if (msym != NULL)     cache_novly_regions = read_memory_integer (SYMBOL_VALUE_ADDRESS (msym), 4);   else      return 0;
comment|/* failure */
end_comment

begin_comment
unit|cache_ovly_region_table = (void *) xmalloc (cache_novly_regions * 12);   if (cache_ovly_region_table != NULL)     {       msym = lookup_minimal_symbol ("_ovly_region_table", 0, 0);       if (msym != NULL) 	{ 	  cache_ovly_region_table_base = SYMBOL_VALUE_ADDRESS (msym); 	  read_target_long_array (cache_ovly_region_table_base,  				  (int *) cache_ovly_region_table,  				  cache_novly_regions * 3); 	}       else  	return 0;
comment|/* failure */
end_comment

begin_comment
unit|}   else      return 0;
comment|/* failure */
end_comment

begin_comment
unit|return 1;
comment|/* SUCCESS */
end_comment

begin_endif
unit|}
endif|#
directive|endif
end_endif

begin_comment
comment|/* Function: simple_overlay_update_1     A helper function for simple_overlay_update.  Assuming a cached copy    of _ovly_table exists, look through it to find an entry whose vma,    lma and size match those of OSECT.  Re-read the entry and make sure    it still matches OSECT (else the table may no longer be valid).    Set OSECT's mapped state to match the entry.  Return: 1 for    success, 0 for failure.  */
end_comment

begin_function
specifier|static
name|int
name|simple_overlay_update_1
parameter_list|(
name|osect
parameter_list|)
name|struct
name|obj_section
modifier|*
name|osect
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|size
decl_stmt|;
name|size
operator|=
name|bfd_get_section_size_before_reloc
argument_list|(
name|osect
operator|->
name|the_bfd_section
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cache_novlys
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|cache_ovly_table
index|[
name|i
index|]
index|[
name|VMA
index|]
operator|==
name|osect
operator|->
name|the_bfd_section
operator|->
name|vma
operator|&&
name|cache_ovly_table
index|[
name|i
index|]
index|[
name|LMA
index|]
operator|==
name|osect
operator|->
name|the_bfd_section
operator|->
name|lma
comment|/*&& 	cache_ovly_table[i][SIZE] == size */
condition|)
block|{
name|read_target_long_array
argument_list|(
name|cache_ovly_table_base
operator|+
name|i
operator|*
name|TARGET_LONG_BYTES
argument_list|,
operator|(
name|int
operator|*
operator|)
name|cache_ovly_table
index|[
name|i
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|cache_ovly_table
index|[
name|i
index|]
index|[
name|VMA
index|]
operator|==
name|osect
operator|->
name|the_bfd_section
operator|->
name|vma
operator|&&
name|cache_ovly_table
index|[
name|i
index|]
index|[
name|LMA
index|]
operator|==
name|osect
operator|->
name|the_bfd_section
operator|->
name|lma
comment|/*&& 	    cache_ovly_table[i][SIZE] == size */
condition|)
block|{
name|osect
operator|->
name|ovly_mapped
operator|=
name|cache_ovly_table
index|[
name|i
index|]
index|[
name|MAPPED
index|]
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
comment|/* Warning!  Warning!  Target's ovly table has changed! */
return|return
literal|0
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Function: simple_overlay_update    If OSECT is NULL, then update all sections' mapped state     (after re-reading the entire target _ovly_table).     If OSECT is non-NULL, then try to find a matching entry in the     cached ovly_table and update only OSECT's mapped state.    If a cached entry can't be found or the cache isn't valid, then     re-read the entire cache, and go ahead and update all sections.  */
end_comment

begin_function
specifier|static
name|void
name|simple_overlay_update
parameter_list|(
name|osect
parameter_list|)
name|struct
name|obj_section
modifier|*
name|osect
decl_stmt|;
block|{
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
comment|/* Were we given an osect to look up?  NULL means do all of them. */
if|if
condition|(
name|osect
condition|)
comment|/* Have we got a cached copy of the target's overlay table? */
if|if
condition|(
name|cache_ovly_table
operator|!=
name|NULL
condition|)
comment|/* Does its cached location match what's currently in the symtab? */
if|if
condition|(
name|cache_ovly_table_base
operator|==
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|lookup_minimal_symbol
argument_list|(
literal|"_ovly_table"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
comment|/* Then go ahead and try to look up this single section in the cache */
if|if
condition|(
name|simple_overlay_update_1
argument_list|(
name|osect
argument_list|)
condition|)
comment|/* Found it!  We're done. */
return|return;
comment|/* Cached table no good: need to read the entire table anew.      Or else we want all the sections, in which case it's actually      more efficient to read the whole table in one block anyway.  */
if|if
condition|(
name|simple_read_overlay_table
argument_list|()
operator|==
literal|0
condition|)
comment|/* read failed?  No table? */
block|{
name|warning
argument_list|(
literal|"Failed to read the target overlay mapping table."
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Now may as well update all sections, even if only one was requested. */
name|ALL_OBJSECTIONS
argument_list|(
argument|objfile
argument_list|,
argument|osect
argument_list|)
if|if
condition|(
name|section_is_overlay
argument_list|(
name|osect
operator|->
name|the_bfd_section
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|,
name|size
decl_stmt|;
name|size
operator|=
name|bfd_get_section_size_before_reloc
argument_list|(
name|osect
operator|->
name|the_bfd_section
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cache_novlys
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|cache_ovly_table
index|[
name|i
index|]
index|[
name|VMA
index|]
operator|==
name|osect
operator|->
name|the_bfd_section
operator|->
name|vma
operator|&&
name|cache_ovly_table
index|[
name|i
index|]
index|[
name|LMA
index|]
operator|==
name|osect
operator|->
name|the_bfd_section
operator|->
name|lma
comment|/*&& 	      cache_ovly_table[i][SIZE] == size */
condition|)
block|{
comment|/* obj_section matches i'th entry in ovly_table */
name|osect
operator|->
name|ovly_mapped
operator|=
name|cache_ovly_table
index|[
name|i
index|]
index|[
name|MAPPED
index|]
expr_stmt|;
break|break;
comment|/* finished with inner for loop: break out */
block|}
block|}
block|}
end_function

begin_function
name|void
name|_initialize_symfile
parameter_list|()
block|{
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
name|c
operator|=
name|add_cmd
argument_list|(
literal|"symbol-file"
argument_list|,
name|class_files
argument_list|,
name|symbol_file_command
argument_list|,
literal|"Load symbol table from executable file FILE.\n\ The `file' command can also load symbol tables, as well as setting the file\n\ to execute."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|c
operator|->
name|completer
operator|=
name|filename_completer
expr_stmt|;
name|c
operator|=
name|add_cmd
argument_list|(
literal|"add-symbol-file"
argument_list|,
name|class_files
argument_list|,
name|add_symbol_file_command
argument_list|,
literal|"Usage: add-symbol-file FILE ADDR\n\ Load the symbols from FILE, assuming FILE has been dynamically loaded.\n\ ADDR is the starting address of the file's text."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|c
operator|->
name|completer
operator|=
name|filename_completer
expr_stmt|;
name|c
operator|=
name|add_cmd
argument_list|(
literal|"add-shared-symbol-files"
argument_list|,
name|class_files
argument_list|,
name|add_shared_symbol_files_command
argument_list|,
literal|"Load the symbols from shared objects in the dynamic linker's link map."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|c
operator|=
name|add_alias_cmd
argument_list|(
literal|"assf"
argument_list|,
literal|"add-shared-symbol-files"
argument_list|,
name|class_files
argument_list|,
literal|1
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|c
operator|=
name|add_cmd
argument_list|(
literal|"load"
argument_list|,
name|class_files
argument_list|,
name|load_command
argument_list|,
literal|"Dynamically load FILE into the running program, and record its symbols\n\ for access from GDB."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|c
operator|->
name|completer
operator|=
name|filename_completer
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"symbol-reloading"
argument_list|,
name|class_support
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|symbol_reloading
argument_list|,
literal|"Set dynamic symbol table reloading multiple times in one run."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"overlay"
argument_list|,
name|class_support
argument_list|,
name|overlay_command
argument_list|,
literal|"Commands for debugging overlays."
argument_list|,
operator|&
name|overlaylist
argument_list|,
literal|"overlay "
argument_list|,
literal|0
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"ovly"
argument_list|,
literal|"overlay"
argument_list|,
name|class_alias
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"ov"
argument_list|,
literal|"overlay"
argument_list|,
name|class_alias
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"map-overlay"
argument_list|,
name|class_support
argument_list|,
name|map_overlay_command
argument_list|,
literal|"Assert that an overlay section is mapped."
argument_list|,
operator|&
name|overlaylist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"unmap-overlay"
argument_list|,
name|class_support
argument_list|,
name|unmap_overlay_command
argument_list|,
literal|"Assert that an overlay section is unmapped."
argument_list|,
operator|&
name|overlaylist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"list-overlays"
argument_list|,
name|class_support
argument_list|,
name|list_overlays_command
argument_list|,
literal|"List mappings of overlay sections."
argument_list|,
operator|&
name|overlaylist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"manual"
argument_list|,
name|class_support
argument_list|,
name|overlay_manual_command
argument_list|,
literal|"Enable overlay debugging."
argument_list|,
operator|&
name|overlaylist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"off"
argument_list|,
name|class_support
argument_list|,
name|overlay_off_command
argument_list|,
literal|"Disable overlay debugging."
argument_list|,
operator|&
name|overlaylist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"auto"
argument_list|,
name|class_support
argument_list|,
name|overlay_auto_command
argument_list|,
literal|"Enable automatic overlay debugging."
argument_list|,
operator|&
name|overlaylist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"load-target"
argument_list|,
name|class_support
argument_list|,
name|overlay_load_command
argument_list|,
literal|"Read the overlay mapping state from the target."
argument_list|,
operator|&
name|overlaylist
argument_list|)
expr_stmt|;
comment|/* Filename extension to source language lookup table: */
name|init_filename_language_table
argument_list|()
expr_stmt|;
name|c
operator|=
name|add_set_cmd
argument_list|(
literal|"extension-language"
argument_list|,
name|class_files
argument_list|,
name|var_string_noescape
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ext_args
argument_list|,
literal|"Set mapping between filename extension and source language.\n\ Usage: set extension-language .foo bar"
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|c
operator|->
name|function
operator|.
name|cfunc
operator|=
name|set_ext_lang_command
expr_stmt|;
name|add_info
argument_list|(
literal|"extensions"
argument_list|,
name|info_ext_lang_command
argument_list|,
literal|"All filename extensions associated with a source language."
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

