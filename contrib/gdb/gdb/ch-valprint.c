begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Support for printing Chill values for GDB, the GNU debugger.    Copyright 1986, 1988, 1989, 1991, 1992, 1993, 1994    Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"valprint.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_include
include|#
directive|include
file|"c-lang.h"
end_include

begin_comment
comment|/* For c_val_print */
end_comment

begin_include
include|#
directive|include
file|"typeprint.h"
end_include

begin_include
include|#
directive|include
file|"ch-lang.h"
end_include

begin_include
include|#
directive|include
file|"annotate.h"
end_include

begin_decl_stmt
specifier|static
name|void
name|chill_print_value_fields
name|PARAMS
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|,
name|char
operator|*
operator|,
name|GDB_FILE
operator|*
operator|,
name|int
operator|,
name|int
operator|,
expr|enum
name|val_prettyprint
operator|,
expr|struct
name|type
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|chill_print_type_scalar
name|PARAMS
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|,
name|LONGEST
operator|,
name|GDB_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|chill_val_print_array_elements
name|PARAMS
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|,
name|char
operator|*
operator|,
name|CORE_ADDR
operator|,
name|GDB_FILE
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
expr|enum
name|val_prettyprint
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Print integral scalar data VAL, of type TYPE, onto stdio stream STREAM.    Used to print data from type structures in a specified type.  For example,    array bounds may be characters or booleans in some languages, and this    allows the ranges to be printed in their "natural" form rather than as    decimal integer values. */
end_comment

begin_function
specifier|static
name|void
name|chill_print_type_scalar
parameter_list|(
name|type
parameter_list|,
name|val
parameter_list|,
name|stream
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|LONGEST
name|val
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
block|{
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_RANGE
case|:
if|if
condition|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|chill_print_type_scalar
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|val
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|TYPE_CODE_UNDEF
case|:
case|case
name|TYPE_CODE_PTR
case|:
case|case
name|TYPE_CODE_ARRAY
case|:
case|case
name|TYPE_CODE_STRUCT
case|:
case|case
name|TYPE_CODE_UNION
case|:
case|case
name|TYPE_CODE_ENUM
case|:
case|case
name|TYPE_CODE_FUNC
case|:
case|case
name|TYPE_CODE_INT
case|:
case|case
name|TYPE_CODE_FLT
case|:
case|case
name|TYPE_CODE_VOID
case|:
case|case
name|TYPE_CODE_SET
case|:
case|case
name|TYPE_CODE_STRING
case|:
case|case
name|TYPE_CODE_BITSTRING
case|:
case|case
name|TYPE_CODE_ERROR
case|:
case|case
name|TYPE_CODE_MEMBER
case|:
case|case
name|TYPE_CODE_METHOD
case|:
case|case
name|TYPE_CODE_REF
case|:
case|case
name|TYPE_CODE_CHAR
case|:
case|case
name|TYPE_CODE_BOOL
case|:
case|case
name|TYPE_CODE_COMPLEX
case|:
case|case
name|TYPE_CODE_TYPEDEF
case|:
default|default:
break|break;
block|}
name|print_type_scalar
argument_list|(
name|type
argument_list|,
name|val
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print the elements of an array.    Similar to val_print_array_elements, but prints    element indexes (in Chill syntax). */
end_comment

begin_function
specifier|static
name|void
name|chill_val_print_array_elements
parameter_list|(
name|type
parameter_list|,
name|valaddr
parameter_list|,
name|address
parameter_list|,
name|stream
parameter_list|,
name|format
parameter_list|,
name|deref_ref
parameter_list|,
name|recurse
parameter_list|,
name|pretty
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|char
modifier|*
name|valaddr
decl_stmt|;
name|CORE_ADDR
name|address
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|format
decl_stmt|;
name|int
name|deref_ref
decl_stmt|;
name|int
name|recurse
decl_stmt|;
name|enum
name|val_prettyprint
name|pretty
decl_stmt|;
block|{
name|unsigned
name|int
name|i
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|things_printed
init|=
literal|0
decl_stmt|;
name|unsigned
name|len
decl_stmt|;
name|struct
name|type
modifier|*
name|elttype
decl_stmt|;
name|struct
name|type
modifier|*
name|range_type
init|=
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|struct
name|type
modifier|*
name|index_type
init|=
name|TYPE_TARGET_TYPE
argument_list|(
name|range_type
argument_list|)
decl_stmt|;
name|unsigned
name|eltlen
decl_stmt|;
comment|/* Position of the array element we are examining to see      whether it is repeated.  */
name|unsigned
name|int
name|rep1
decl_stmt|;
comment|/* Number of repetitions we have detected so far.  */
name|unsigned
name|int
name|reps
decl_stmt|;
name|LONGEST
name|low_bound
init|=
name|TYPE_FIELD_BITPOS
argument_list|(
name|range_type
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|elttype
operator|=
name|check_typedef
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|eltlen
operator|=
name|TYPE_LENGTH
argument_list|(
name|elttype
argument_list|)
expr_stmt|;
name|len
operator|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|/
name|eltlen
expr_stmt|;
name|annotate_array_section_begin
argument_list|(
name|i
argument_list|,
name|elttype
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|len
operator|&&
name|things_printed
operator|<
name|print_max
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|prettyprint_arrays
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|",\n"
argument_list|)
expr_stmt|;
name|print_spaces_filtered
argument_list|(
literal|2
operator|+
literal|2
operator|*
name|recurse
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
block|}
block|}
name|wrap_here
argument_list|(
name|n_spaces
argument_list|(
literal|2
operator|+
literal|2
operator|*
name|recurse
argument_list|)
argument_list|)
expr_stmt|;
name|rep1
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|reps
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|rep1
operator|<
name|len
operator|)
operator|&&
operator|!
name|memcmp
argument_list|(
name|valaddr
operator|+
name|i
operator|*
name|eltlen
argument_list|,
name|valaddr
operator|+
name|rep1
operator|*
name|eltlen
argument_list|,
name|eltlen
argument_list|)
condition|)
block|{
operator|++
name|reps
expr_stmt|;
operator|++
name|rep1
expr_stmt|;
block|}
name|fputs_filtered
argument_list|(
literal|"("
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|chill_print_type_scalar
argument_list|(
name|index_type
argument_list|,
name|low_bound
operator|+
name|i
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|reps
operator|>
literal|1
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|":"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|chill_print_type_scalar
argument_list|(
name|index_type
argument_list|,
name|low_bound
operator|+
name|i
operator|+
name|reps
operator|-
literal|1
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"): "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|val_print
argument_list|(
name|elttype
argument_list|,
name|valaddr
operator|+
name|i
operator|*
name|eltlen
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|deref_ref
argument_list|,
name|recurse
operator|+
literal|1
argument_list|,
name|pretty
argument_list|)
expr_stmt|;
name|i
operator|=
name|rep1
operator|-
literal|1
expr_stmt|;
name|things_printed
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|fputs_filtered
argument_list|(
literal|"): "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|val_print
argument_list|(
name|elttype
argument_list|,
name|valaddr
operator|+
name|i
operator|*
name|eltlen
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|deref_ref
argument_list|,
name|recurse
operator|+
literal|1
argument_list|,
name|pretty
argument_list|)
expr_stmt|;
name|annotate_elt
argument_list|()
expr_stmt|;
name|things_printed
operator|++
expr_stmt|;
block|}
block|}
name|annotate_array_section_end
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|len
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"..."
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print data of type TYPE located at VALADDR (within GDB), which came from    the inferior at address ADDRESS, onto stdio stream STREAM according to    FORMAT (a letter or 0 for natural format).  The data at VALADDR is in    target byte order.     If the data are a string pointer, returns the number of string characters    printed.     If DEREF_REF is nonzero, then dereference references, otherwise just print    them like pointers.     The PRETTY parameter controls prettyprinting.  */
end_comment

begin_function
name|int
name|chill_val_print
parameter_list|(
name|type
parameter_list|,
name|valaddr
parameter_list|,
name|embedded_offset
parameter_list|,
name|address
parameter_list|,
name|stream
parameter_list|,
name|format
parameter_list|,
name|deref_ref
parameter_list|,
name|recurse
parameter_list|,
name|pretty
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|char
modifier|*
name|valaddr
decl_stmt|;
name|int
name|embedded_offset
decl_stmt|;
name|CORE_ADDR
name|address
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|format
decl_stmt|;
name|int
name|deref_ref
decl_stmt|;
name|int
name|recurse
decl_stmt|;
name|enum
name|val_prettyprint
name|pretty
decl_stmt|;
block|{
name|LONGEST
name|val
decl_stmt|;
name|unsigned
name|int
name|i
init|=
literal|0
decl_stmt|;
comment|/* Number of characters printed.  */
name|struct
name|type
modifier|*
name|elttype
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|CHECK_TYPEDEF
argument_list|(
name|type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_ARRAY
case|:
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|>
literal|0
operator|&&
name|TYPE_LENGTH
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|prettyprint_arrays
condition|)
block|{
name|print_spaces_filtered
argument_list|(
literal|2
operator|+
literal|2
operator|*
name|recurse
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"["
argument_list|)
expr_stmt|;
name|chill_val_print_array_elements
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|,
name|address
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|deref_ref
argument_list|,
name|recurse
argument_list|,
name|pretty
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"]"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"unimplemented in chill_val_print; unspecified array length"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_CODE_INT
case|:
name|format
operator|=
name|format
condition|?
name|format
else|:
name|output_format
expr_stmt|;
if|if
condition|(
name|format
condition|)
block|{
name|print_scalar_formatted
argument_list|(
name|valaddr
argument_list|,
name|type
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|val_print_type_code_int
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_CODE_CHAR
case|:
name|format
operator|=
name|format
condition|?
name|format
else|:
name|output_format
expr_stmt|;
if|if
condition|(
name|format
condition|)
block|{
name|print_scalar_formatted
argument_list|(
name|valaddr
argument_list|,
name|type
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LA_PRINT_CHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|unpack_long
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_CODE_FLT
case|:
if|if
condition|(
name|format
condition|)
block|{
name|print_scalar_formatted
argument_list|(
name|valaddr
argument_list|,
name|type
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|print_floating
argument_list|(
name|valaddr
argument_list|,
name|type
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_CODE_BOOL
case|:
name|format
operator|=
name|format
condition|?
name|format
else|:
name|output_format
expr_stmt|;
if|if
condition|(
name|format
condition|)
block|{
name|print_scalar_formatted
argument_list|(
name|valaddr
argument_list|,
name|type
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* FIXME: Why is this using builtin_type_chill_bool not type?  */
name|val
operator|=
name|unpack_long
argument_list|(
name|builtin_type_chill_bool
argument_list|,
name|valaddr
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|val
condition|?
literal|"TRUE"
else|:
literal|"FALSE"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_CODE_UNDEF
case|:
comment|/* This happens (without TYPE_FLAG_STUB set) on systems which don't use 	 dbx xrefs (NO_DBX_XREFS in gcc) if a file has a "struct foo *bar" 	 and no complete type for struct foo in that file.  */
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<incomplete type>"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_PTR
case|:
if|if
condition|(
name|format
operator|&&
name|format
operator|!=
literal|'s'
condition|)
block|{
name|print_scalar_formatted
argument_list|(
name|valaddr
argument_list|,
name|type
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
block|}
name|addr
operator|=
name|unpack_pointer
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|)
expr_stmt|;
name|elttype
operator|=
name|check_typedef
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We assume a NULL pointer is all zeros ... */
if|if
condition|(
name|addr
operator|==
literal|0
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|"NULL"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|elttype
argument_list|)
operator|==
name|TYPE_CODE_FUNC
condition|)
block|{
comment|/* Try to print what function it points to.  */
name|print_address_demangle
argument_list|(
name|addr
argument_list|,
name|stream
argument_list|,
name|demangle
argument_list|)
expr_stmt|;
comment|/* Return value is irrelevant except for string pointers.  */
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|addressprint
operator|&&
name|format
operator|!=
literal|'s'
condition|)
block|{
name|print_address_numeric
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
comment|/* For a pointer to char or unsigned char, also print the string 	 pointed to, unless pointer is null.  */
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|elttype
argument_list|)
operator|==
literal|1
operator|&&
name|TYPE_CODE
argument_list|(
name|elttype
argument_list|)
operator|==
name|TYPE_CODE_CHAR
operator|&&
operator|(
name|format
operator|==
literal|0
operator|||
name|format
operator|==
literal|'s'
operator|)
operator|&&
name|addr
operator|!=
literal|0
operator|&&
comment|/* If print_max is UINT_MAX, the alloca below will fail. 		In that case don't try to print the string.  */
name|print_max
operator|<
name|UINT_MAX
condition|)
name|i
operator|=
name|val_print_string
argument_list|(
name|addr
argument_list|,
operator|-
literal|1
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|elttype
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
comment|/* Return number of characters printed, plus one for the 	 terminating null if we have "reached the end".  */
return|return
operator|(
name|i
operator|+
operator|(
name|print_max
operator|&&
name|i
operator|!=
name|print_max
operator|)
operator|)
return|;
break|break;
case|case
name|TYPE_CODE_STRING
case|:
name|i
operator|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|LA_PRINT_STRING
argument_list|(
name|stream
argument_list|,
name|valaddr
argument_list|,
name|i
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Return number of characters printed, plus one for the terminating 	 null if we have "reached the end".  */
return|return
operator|(
name|i
operator|+
operator|(
name|print_max
operator|&&
name|i
operator|!=
name|print_max
operator|)
operator|)
return|;
break|break;
case|case
name|TYPE_CODE_BITSTRING
case|:
case|case
name|TYPE_CODE_SET
case|:
name|elttype
operator|=
name|TYPE_INDEX_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|CHECK_TYPEDEF
argument_list|(
name|elttype
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_FLAGS
argument_list|(
name|elttype
argument_list|)
operator|&
name|TYPE_FLAG_STUB
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<incomplete type>"
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|stream
argument_list|)
expr_stmt|;
break|break;
block|}
block|{
name|struct
name|type
modifier|*
name|range
init|=
name|elttype
decl_stmt|;
name|LONGEST
name|low_bound
decl_stmt|,
name|high_bound
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|is_bitstring
init|=
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_BITSTRING
decl_stmt|;
name|int
name|need_comma
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|is_bitstring
condition|)
name|fputs_filtered
argument_list|(
literal|"B'"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
name|fputs_filtered
argument_list|(
literal|"["
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|i
operator|=
name|get_discrete_bounds
argument_list|(
name|range
argument_list|,
operator|&
name|low_bound
argument_list|,
operator|&
name|high_bound
argument_list|)
expr_stmt|;
name|maybe_bad_bstring
label|:
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|"<error value>"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
for|for
control|(
name|i
operator|=
name|low_bound
init|;
name|i
operator|<=
name|high_bound
condition|;
name|i
operator|++
control|)
block|{
name|int
name|element
init|=
name|value_bit_index
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|element
operator|<
literal|0
condition|)
block|{
name|i
operator|=
name|element
expr_stmt|;
goto|goto
name|maybe_bad_bstring
goto|;
block|}
if|if
condition|(
name|is_bitstring
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%d"
argument_list|,
name|element
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|element
condition|)
block|{
if|if
condition|(
name|need_comma
condition|)
name|fputs_filtered
argument_list|(
literal|", "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|chill_print_type_scalar
argument_list|(
name|range
argument_list|,
operator|(
name|LONGEST
operator|)
name|i
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|need_comma
operator|=
literal|1
expr_stmt|;
comment|/* Look for a continuous range of true elements. */
if|if
condition|(
name|i
operator|+
literal|1
operator|<=
name|high_bound
operator|&&
name|value_bit_index
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|,
operator|++
name|i
argument_list|)
condition|)
block|{
name|int
name|j
init|=
name|i
decl_stmt|;
comment|/* j is the upper bound so far of the range */
name|fputs_filtered
argument_list|(
literal|":"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|+
literal|1
operator|<=
name|high_bound
operator|&&
name|value_bit_index
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|,
operator|++
name|i
argument_list|)
condition|)
name|j
operator|=
name|i
expr_stmt|;
name|chill_print_type_scalar
argument_list|(
name|range
argument_list|,
operator|(
name|LONGEST
operator|)
name|j
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|done
label|:
if|if
condition|(
name|is_bitstring
condition|)
name|fputs_filtered
argument_list|(
literal|"'"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
name|fputs_filtered
argument_list|(
literal|"]"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_CODE_STRUCT
case|:
if|if
condition|(
name|chill_varying_type
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|struct
name|type
modifier|*
name|inner
init|=
name|check_typedef
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|long
name|length
init|=
name|unpack_long
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
argument_list|,
name|valaddr
argument_list|)
decl_stmt|;
name|char
modifier|*
name|data_addr
init|=
name|valaddr
operator|+
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
literal|1
argument_list|)
operator|/
literal|8
decl_stmt|;
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|inner
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_STRING
case|:
if|if
condition|(
name|length
operator|>
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|-
literal|2
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<dynamic length %ld> static length %d> *invalid*"
argument_list|,
name|length
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Don't print the string; doing so might produce a 		     segfault.  */
return|return
name|length
return|;
block|}
name|LA_PRINT_STRING
argument_list|(
name|stream
argument_list|,
name|data_addr
argument_list|,
name|length
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|length
return|;
default|default:
break|break;
block|}
block|}
name|chill_print_value_fields
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|recurse
argument_list|,
name|pretty
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_REF
case|:
if|if
condition|(
name|addressprint
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"LOC("
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|extract_address
argument_list|(
name|valaddr
argument_list|,
name|TARGET_PTR_BIT
operator|/
name|HOST_CHAR_BIT
argument_list|)
argument_list|,
literal|1
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
if|if
condition|(
name|deref_ref
condition|)
name|fputs_filtered
argument_list|(
literal|": "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
comment|/* De-reference the reference.  */
if|if
condition|(
name|deref_ref
condition|)
block|{
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|TYPE_CODE_UNDEF
condition|)
block|{
name|value_ptr
name|deref_val
init|=
name|value_at
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|unpack_pointer
argument_list|(
name|lookup_pointer_type
argument_list|(
name|builtin_type_void
argument_list|)
argument_list|,
name|valaddr
argument_list|)
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|val_print
argument_list|(
name|VALUE_TYPE
argument_list|(
name|deref_val
argument_list|)
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|deref_val
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VALUE_ADDRESS
argument_list|(
name|deref_val
argument_list|)
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|deref_ref
argument_list|,
name|recurse
operator|+
literal|1
argument_list|,
name|pretty
argument_list|)
expr_stmt|;
block|}
else|else
name|fputs_filtered
argument_list|(
literal|"???"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_CODE_ENUM
case|:
name|c_val_print
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|,
literal|0
argument_list|,
name|address
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|deref_ref
argument_list|,
name|recurse
argument_list|,
name|pretty
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_RANGE
case|:
if|if
condition|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
condition|)
name|chill_val_print
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|valaddr
argument_list|,
literal|0
argument_list|,
name|address
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|deref_ref
argument_list|,
name|recurse
argument_list|,
name|pretty
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_MEMBER
case|:
case|case
name|TYPE_CODE_UNION
case|:
case|case
name|TYPE_CODE_FUNC
case|:
case|case
name|TYPE_CODE_VOID
case|:
case|case
name|TYPE_CODE_ERROR
case|:
default|default:
comment|/* Let's defer printing to the C printer, rather than 	 print an error message.  FIXME! */
name|c_val_print
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|,
literal|0
argument_list|,
name|address
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|deref_ref
argument_list|,
name|recurse
argument_list|,
name|pretty
argument_list|)
expr_stmt|;
block|}
name|gdb_flush
argument_list|(
name|stream
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Mutually recursive subroutines of cplus_print_value and c_val_print to    print out a structure's fields: cp_print_value_fields and cplus_print_value.     TYPE, VALADDR, STREAM, RECURSE, and PRETTY have the    same meanings as in cplus_print_value and c_val_print.     DONT_PRINT is an array of baseclass types that we    should not print, or zero if called from top level.  */
end_comment

begin_function
specifier|static
name|void
name|chill_print_value_fields
parameter_list|(
name|type
parameter_list|,
name|valaddr
parameter_list|,
name|stream
parameter_list|,
name|format
parameter_list|,
name|recurse
parameter_list|,
name|pretty
parameter_list|,
name|dont_print
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|char
modifier|*
name|valaddr
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|format
decl_stmt|;
name|int
name|recurse
decl_stmt|;
name|enum
name|val_prettyprint
name|pretty
decl_stmt|;
name|struct
name|type
modifier|*
modifier|*
name|dont_print
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
name|int
name|fields_seen
init|=
literal|0
decl_stmt|;
name|CHECK_TYPEDEF
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"["
argument_list|)
expr_stmt|;
name|len
operator|=
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<No data fields>"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fields_seen
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
block|}
name|fields_seen
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|pretty
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|print_spaces_filtered
argument_list|(
literal|2
operator|+
literal|2
operator|*
name|recurse
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|wrap_here
argument_list|(
name|n_spaces
argument_list|(
literal|2
operator|+
literal|2
operator|*
name|recurse
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fputs_filtered
argument_list|(
literal|"."
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprintf_symbol_filtered
argument_list|(
name|stream
argument_list|,
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|language_chill
argument_list|,
name|DMGL_NO_OPTS
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|": "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_FIELD_PACKED
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|value_ptr
name|v
decl_stmt|;
comment|/* Bitfields require special handling, especially due to byte 		 order problems.  */
name|v
operator|=
name|value_from_longest
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|unpack_field_as_long
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|chill_val_print
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|v
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
name|recurse
operator|+
literal|1
argument_list|,
name|pretty
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|chill_val_print
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|valaddr
operator|+
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
operator|/
literal|8
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
name|recurse
operator|+
literal|1
argument_list|,
name|pretty
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pretty
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|print_spaces_filtered
argument_list|(
literal|2
operator|*
name|recurse
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"]"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|int
name|chill_value_print
parameter_list|(
name|val
parameter_list|,
name|stream
parameter_list|,
name|format
parameter_list|,
name|pretty
parameter_list|)
name|value_ptr
name|val
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|format
decl_stmt|;
name|enum
name|val_prettyprint
name|pretty
decl_stmt|;
block|{
name|struct
name|type
modifier|*
name|type
init|=
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
decl_stmt|;
name|struct
name|type
modifier|*
name|real_type
init|=
name|check_typedef
argument_list|(
name|type
argument_list|)
decl_stmt|;
comment|/* If it is a pointer, indicate what it points to.       Print type also if it is a reference. */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|real_type
argument_list|)
operator|==
name|TYPE_CODE_PTR
operator|||
name|TYPE_CODE
argument_list|(
name|real_type
argument_list|)
operator|==
name|TYPE_CODE_REF
condition|)
block|{
name|char
modifier|*
name|valaddr
init|=
name|VALUE_CONTENTS
argument_list|(
name|val
argument_list|)
decl_stmt|;
name|CORE_ADDR
name|addr
init|=
name|unpack_pointer
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_CODE_PTR
operator|||
name|addr
operator|!=
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|name
condition|)
name|fputs_filtered
argument_list|(
name|name
argument_list|,
name|stream
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_VOID
condition|)
name|fputs_filtered
argument_list|(
literal|"PTR"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|type_print
argument_list|(
name|type
argument_list|,
literal|""
argument_list|,
name|stream
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|i
operator|=
name|val_print
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|,
literal|0
argument_list|,
name|VALUE_ADDRESS
argument_list|(
name|val
argument_list|)
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|pretty
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
return|return
name|i
return|;
block|}
block|}
return|return
operator|(
name|val_print
argument_list|(
name|type
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|val
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VALUE_ADDRESS
argument_list|(
name|val
argument_list|)
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|pretty
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

