begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Intel 386 native support.    Copyright (C) 1988, 1989, 1991, 1992 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|"gdb_stat.h"
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<sys/ptrace.h>
end_include

begin_comment
comment|/* Does AIX define this in<errno.h>?  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|NO_SYS_REG_H
end_ifndef

begin_include
include|#
directive|include
file|<sys/reg.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"floatformat.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* this table must line up with REGISTER_NAMES in tm-i386v.h */
end_comment

begin_comment
comment|/* symbols like 'EAX' come from<sys/reg.h> */
end_comment

begin_decl_stmt
specifier|static
name|int
name|regmap
index|[]
init|=
block|{
name|EAX
block|,
name|ECX
block|,
name|EDX
block|,
name|EBX
block|,
name|USP
block|,
name|EBP
block|,
name|ESI
block|,
name|EDI
block|,
name|EIP
block|,
name|EFL
block|,
name|CS
block|,
name|SS
block|,
name|DS
block|,
name|ES
block|,
name|FS
block|,
name|GS
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* blockend is the value of u.u_ar0, and points to the  * place where GS is stored  */
end_comment

begin_function
name|int
name|i386_register_u_addr
parameter_list|(
name|blockend
parameter_list|,
name|regnum
parameter_list|)
name|int
name|blockend
decl_stmt|;
name|int
name|regnum
decl_stmt|;
block|{
if|#
directive|if
literal|0
comment|/* this will be needed if fp registers are reinstated */
comment|/* for now, you can look at them with 'info float'    * sys5 wont let you change them with ptrace anyway    */
block|if (regnum>= FP0_REGNUM&& regnum<= FP7_REGNUM)      {       int ubase, fpstate;       struct user u;       ubase = blockend + 4 * (SS + 1) - KSTKSZ;       fpstate = ubase + ((char *)&u.u_fpstate - (char *)&u);       return (fpstate + 0x1c + 10 * (regnum - FP0_REGNUM));     }    else
endif|#
directive|endif
return|return
operator|(
name|blockend
operator|+
literal|4
operator|*
name|regmap
index|[
name|regnum
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/* The code below only work on the aix ps/2 (i386-ibm-aix) -  * mtranle@paris - Sat Apr 11 10:34:12 1992  */
end_comment

begin_struct
struct|struct
name|env387
block|{
name|unsigned
name|short
name|control
decl_stmt|;
name|unsigned
name|short
name|r0
decl_stmt|;
name|unsigned
name|short
name|status
decl_stmt|;
name|unsigned
name|short
name|r1
decl_stmt|;
name|unsigned
name|short
name|tag
decl_stmt|;
name|unsigned
name|short
name|r2
decl_stmt|;
name|unsigned
name|long
name|eip
decl_stmt|;
name|unsigned
name|short
name|code_seg
decl_stmt|;
name|unsigned
name|short
name|opcode
decl_stmt|;
name|unsigned
name|long
name|operand
decl_stmt|;
name|unsigned
name|short
name|operand_seg
decl_stmt|;
name|unsigned
name|short
name|r3
decl_stmt|;
name|unsigned
name|char
name|regs
index|[
literal|8
index|]
index|[
literal|10
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
specifier|static
name|print_387_status
argument_list|(
argument|status
argument_list|,
argument|ep
argument_list|)
name|unsigned
name|short
name|status
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|env387
modifier|*
name|ep
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|int
name|bothstatus
decl_stmt|;
name|int
name|top
decl_stmt|;
name|int
name|fpreg
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|bothstatus
operator|=
operator|(
operator|(
name|status
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|ep
operator|->
name|status
operator|!=
literal|0
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|bothstatus
condition|)
name|printf_unfiltered
argument_list|(
literal|"u: "
argument_list|)
expr_stmt|;
name|print_387_status_word
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ep
operator|->
name|status
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|bothstatus
condition|)
name|printf_unfiltered
argument_list|(
literal|"e: "
argument_list|)
expr_stmt|;
name|print_387_status_word
argument_list|(
name|ep
operator|->
name|status
argument_list|)
expr_stmt|;
block|}
name|print_387_control_word
argument_list|(
name|ep
operator|->
name|control
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"last exception: "
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"opcode %s; "
argument_list|,
name|local_hex_string
argument_list|(
name|ep
operator|->
name|opcode
argument_list|)
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"pc %s:"
argument_list|,
name|local_hex_string
argument_list|(
name|ep
operator|->
name|code_seg
argument_list|)
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"%s; "
argument_list|,
name|local_hex_string
argument_list|(
name|ep
operator|->
name|eip
argument_list|)
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"operand %s"
argument_list|,
name|local_hex_string
argument_list|(
name|ep
operator|->
name|operand_seg
argument_list|)
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|":%s\n"
argument_list|,
name|local_hex_string
argument_list|(
name|ep
operator|->
name|operand
argument_list|)
argument_list|)
expr_stmt|;
name|top
operator|=
operator|(
operator|(
name|ep
operator|->
name|status
operator|>>
literal|11
operator|)
operator|&
literal|7
operator|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"regno  tag  msb              lsb  value\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|fpreg
operator|=
literal|7
init|;
name|fpreg
operator|>=
literal|0
condition|;
name|fpreg
operator|--
control|)
block|{
name|double
name|val
decl_stmt|;
name|printf_unfiltered
argument_list|(
literal|"%s %d: "
argument_list|,
name|fpreg
operator|==
name|top
condition|?
literal|"=>"
else|:
literal|"  "
argument_list|,
name|fpreg
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|(
name|ep
operator|->
name|tag
operator|>>
operator|(
operator|(
literal|7
operator|-
name|fpreg
operator|)
operator|*
literal|2
operator|)
operator|)
operator|&
literal|3
condition|)
block|{
case|case
literal|0
case|:
name|printf_unfiltered
argument_list|(
literal|"valid "
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|printf_unfiltered
argument_list|(
literal|"zero  "
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|printf_unfiltered
argument_list|(
literal|"trap  "
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|printf_unfiltered
argument_list|(
literal|"empty "
argument_list|)
expr_stmt|;
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|9
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|printf_unfiltered
argument_list|(
literal|"%02x"
argument_list|,
name|ep
operator|->
name|regs
index|[
name|fpreg
index|]
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|i387_to_double
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ep
operator|->
name|regs
index|[
name|fpreg
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|val
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"  %#g\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_decl_stmt
specifier|static
name|struct
name|env387
name|core_env387
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|i386_float_info
parameter_list|()
block|{
name|struct
name|env387
name|fps
decl_stmt|;
name|int
name|fpsaved
init|=
literal|0
decl_stmt|;
comment|/* We need to reverse the order of the registers.  Apparently AIX stores      the highest-numbered ones first.  */
name|struct
name|env387
name|fps_fixed
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|inferior_pid
condition|)
block|{
name|char
name|buf
index|[
literal|10
index|]
decl_stmt|;
name|unsigned
name|short
name|status
decl_stmt|;
name|ptrace
argument_list|(
name|PT_READ_FPR
argument_list|,
name|inferior_pid
argument_list|,
name|buf
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|env387
argument_list|,
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|status
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|fpsaved
operator|=
name|status
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|fpsaved
operator|=
name|core_env387
operator|.
name|status
operator|)
operator|!=
literal|0
condition|)
name|memcpy
argument_list|(
operator|&
name|fps
argument_list|,
operator|&
name|core_env387
argument_list|,
sizeof|sizeof
argument_list|(
name|fps
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fpsaved
operator|==
literal|0
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"no floating point status saved\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|inferior_pid
condition|)
block|{
name|int
name|offset
decl_stmt|;
for|for
control|(
name|offset
operator|=
literal|0
init|;
name|offset
operator|<
sizeof|sizeof
argument_list|(
name|fps
argument_list|)
condition|;
name|offset
operator|+=
literal|10
control|)
block|{
name|char
name|buf
index|[
literal|10
index|]
decl_stmt|;
name|ptrace
argument_list|(
name|PT_READ_FPR
argument_list|,
name|inferior_pid
argument_list|,
name|buf
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|fps
operator|.
name|control
operator|+
name|offset
argument_list|,
name|buf
argument_list|,
name|MIN
argument_list|(
literal|10
argument_list|,
sizeof|sizeof
argument_list|(
name|fps
argument_list|)
operator|-
name|offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|fps_fixed
operator|=
name|fps
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
operator|++
name|i
control|)
name|memcpy
argument_list|(
name|fps_fixed
operator|.
name|regs
index|[
name|i
index|]
argument_list|,
name|fps
operator|.
name|regs
index|[
literal|7
operator|-
name|i
index|]
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|print_387_status
argument_list|(
literal|0
argument_list|,
operator|&
name|fps_fixed
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fetch one register.  */
end_comment

begin_function
specifier|static
name|void
name|fetch_register
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
name|char
name|buf
index|[
name|MAX_REGISTER_RAW_SIZE
index|]
decl_stmt|;
if|if
condition|(
name|regno
operator|<
name|FP0_REGNUM
condition|)
operator|*
operator|(
name|int
operator|*
operator|)
name|buf
operator|=
name|ptrace
argument_list|(
name|PT_READ_GPR
argument_list|,
name|inferior_pid
argument_list|,
name|PT_REG
argument_list|(
name|regmap
index|[
name|regno
index|]
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|ptrace
argument_list|(
name|PT_READ_FPR
argument_list|,
name|inferior_pid
argument_list|,
name|buf
argument_list|,
operator|(
name|regno
operator|-
name|FP0_REGNUM
operator|)
operator|*
literal|10
operator|+
name|offsetof
argument_list|(
expr|struct
name|env387
argument_list|,
name|regs
argument_list|)
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|regno
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fetch_inferior_registers
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
if|if
condition|(
name|regno
operator|<
literal|0
condition|)
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|NUM_REGS
condition|;
name|regno
operator|++
control|)
name|fetch_register
argument_list|(
name|regno
argument_list|)
expr_stmt|;
else|else
name|fetch_register
argument_list|(
name|regno
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* store one register */
end_comment

begin_function
specifier|static
name|void
name|store_register
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|80
index|]
decl_stmt|;
specifier|extern
name|char
name|registers
index|[]
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|regno
operator|<
name|FP0_REGNUM
condition|)
name|ptrace
argument_list|(
name|PT_WRITE_GPR
argument_list|,
name|inferior_pid
argument_list|,
name|PT_REG
argument_list|(
name|regmap
index|[
name|regno
index|]
argument_list|)
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|regno
argument_list|)
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|ptrace
argument_list|(
name|PT_WRITE_FPR
argument_list|,
name|inferior_pid
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|regno
argument_list|)
index|]
argument_list|,
operator|(
name|regno
operator|-
name|FP0_REGNUM
operator|)
operator|*
literal|10
operator|+
name|offsetof
argument_list|(
expr|struct
name|env387
argument_list|,
name|regs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"writing register number %d"
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|perror_with_name
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Store our register values back into the inferior.    If REGNO is -1, do this for all registers.    Otherwise, REGNO specifies which register (so we can save time).  */
end_comment

begin_function
name|void
name|store_inferior_registers
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
if|if
condition|(
name|regno
operator|<
literal|0
condition|)
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|NUM_REGS
condition|;
name|regno
operator|++
control|)
name|store_register
argument_list|(
name|regno
argument_list|)
expr_stmt|;
else|else
name|store_register
argument_list|(
name|regno
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|CD_AX
end_ifndef

begin_comment
comment|/* defined in sys/i386/coredump.h */
end_comment

begin_define
define|#
directive|define
name|CD_AX
value|0
end_define

begin_define
define|#
directive|define
name|CD_BX
value|1
end_define

begin_define
define|#
directive|define
name|CD_CX
value|2
end_define

begin_define
define|#
directive|define
name|CD_DX
value|3
end_define

begin_define
define|#
directive|define
name|CD_SI
value|4
end_define

begin_define
define|#
directive|define
name|CD_DI
value|5
end_define

begin_define
define|#
directive|define
name|CD_BP
value|6
end_define

begin_define
define|#
directive|define
name|CD_SP
value|7
end_define

begin_define
define|#
directive|define
name|CD_FL
value|8
end_define

begin_define
define|#
directive|define
name|CD_IP
value|9
end_define

begin_define
define|#
directive|define
name|CD_CS
value|10
end_define

begin_define
define|#
directive|define
name|CD_DS
value|11
end_define

begin_define
define|#
directive|define
name|CD_ES
value|12
end_define

begin_define
define|#
directive|define
name|CD_FS
value|13
end_define

begin_define
define|#
directive|define
name|CD_GS
value|14
end_define

begin_define
define|#
directive|define
name|CD_SS
value|15
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * The order here in core_regmap[] has to be the same as in   * regmap[] above.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|core_regmap
index|[]
init|=
block|{
name|CD_AX
block|,
name|CD_CX
block|,
name|CD_DX
block|,
name|CD_BX
block|,
name|CD_SP
block|,
name|CD_BP
block|,
name|CD_SI
block|,
name|CD_DI
block|,
name|CD_IP
block|,
name|CD_FL
block|,
name|CD_CS
block|,
name|CD_SS
block|,
name|CD_DS
block|,
name|CD_ES
block|,
name|CD_FS
block|,
name|CD_GS
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|fetch_core_registers
parameter_list|(
name|core_reg_sect
parameter_list|,
name|core_reg_size
parameter_list|,
name|which
parameter_list|,
name|reg_addr
parameter_list|)
name|char
modifier|*
name|core_reg_sect
decl_stmt|;
name|unsigned
name|core_reg_size
decl_stmt|;
name|int
name|which
decl_stmt|;
name|unsigned
name|int
name|reg_addr
decl_stmt|;
comment|/* ignored */
block|{
if|if
condition|(
name|which
operator|==
literal|0
condition|)
block|{
comment|/* Integer registers */
define|#
directive|define
name|cd_regs
parameter_list|(
name|n
parameter_list|)
value|((int *)core_reg_sect)[n]
define|#
directive|define
name|regs
parameter_list|(
name|n
parameter_list|)
value|*((int *)&registers[REGISTER_BYTE (n)])
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FP0_REGNUM
condition|;
name|i
operator|++
control|)
name|regs
argument_list|(
name|i
argument_list|)
operator|=
name|cd_regs
argument_list|(
name|core_regmap
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|which
operator|==
literal|2
condition|)
block|{
comment|/* Floating point registers */
if|if
condition|(
name|core_reg_size
operator|>=
sizeof|sizeof
argument_list|(
name|core_env387
argument_list|)
condition|)
name|memcpy
argument_list|(
operator|&
name|core_env387
argument_list|,
name|core_reg_sect
argument_list|,
name|core_reg_size
argument_list|)
expr_stmt|;
else|else
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Couldn't read float regs from core file\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Register that we are able to handle i386aix core file formats.    FIXME: is this really bfd_target_unknown_flavour? */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|core_fns
name|i386aix_core_fns
init|=
block|{
name|bfd_target_unknown_flavour
block|,
name|fetch_core_registers
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|_initialize_core_i386aix
parameter_list|()
block|{
name|add_core_fns
argument_list|(
operator|&
name|i386aix_core_fns
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

