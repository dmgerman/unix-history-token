begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Support routines for decoding "stabs" debugging information format.     Copyright 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994,    1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004 Free    Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* Support routines for reading and decoding debugging information in    the "stabs" format.  This format is used with many systems that use    the a.out object file format, as well as some systems that use    COFF or ELF where the stabs data is placed in a special section.    Avoid placing any object file format specific code in this file. */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"gdb_obstack.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"aout/stab_gnu.h"
end_include

begin_comment
comment|/* We always use GNU stabs, not native */
end_comment

begin_include
include|#
directive|include
file|"libaout.h"
end_include

begin_include
include|#
directive|include
file|"aout/aout64.h"
end_include

begin_include
include|#
directive|include
file|"gdb-stabs.h"
end_include

begin_include
include|#
directive|include
file|"buildsym.h"
end_include

begin_include
include|#
directive|include
file|"complaints.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"doublest.h"
end_include

begin_include
include|#
directive|include
file|"cp-abi.h"
end_include

begin_include
include|#
directive|include
file|"cp-support.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_comment
comment|/* Ask stabsread.h to define the vars it normally declares `extern'.  */
end_comment

begin_define
define|#
directive|define
name|EXTERN
end_define

begin_comment
comment|/**/
end_comment

begin_include
include|#
directive|include
file|"stabsread.h"
end_include

begin_comment
comment|/* Our own declarations */
end_comment

begin_undef
undef|#
directive|undef
name|EXTERN
end_undef

begin_function_decl
specifier|extern
name|void
name|_initialize_stabsread
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* The routines that read and process a complete stabs for a C struct or     C++ class pass lists of data member fields and lists of member function    fields in an instance of a field_info structure, as defined below.    This is part of some reorganization of low level C++ support and is    expected to eventually go away... (FIXME) */
end_comment

begin_struct
struct|struct
name|field_info
block|{
struct|struct
name|nextfield
block|{
name|struct
name|nextfield
modifier|*
name|next
decl_stmt|;
comment|/* This is the raw visibility from the stab.  It is not checked 	   for being one of the visibilities we recognize, so code which 	   examines this field better be able to deal.  */
name|int
name|visibility
decl_stmt|;
name|struct
name|field
name|field
decl_stmt|;
block|}
modifier|*
name|list
struct|;
struct|struct
name|next_fnfieldlist
block|{
name|struct
name|next_fnfieldlist
modifier|*
name|next
decl_stmt|;
name|struct
name|fn_fieldlist
name|fn_fieldlist
decl_stmt|;
block|}
modifier|*
name|fnlist
struct|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|void
name|read_one_struct_field
parameter_list|(
name|struct
name|field_info
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|struct
name|type
modifier|*
parameter_list|,
name|struct
name|objfile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|type
modifier|*
name|dbx_alloc_type
parameter_list|(
name|int
index|[
literal|2
index|]
parameter_list|,
name|struct
name|objfile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|long
name|read_huge_number
parameter_list|(
name|char
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|type
modifier|*
name|error_type
parameter_list|(
name|char
modifier|*
modifier|*
parameter_list|,
name|struct
name|objfile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|patch_block_stabs
parameter_list|(
name|struct
name|pending
modifier|*
parameter_list|,
name|struct
name|pending_stabs
modifier|*
parameter_list|,
name|struct
name|objfile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fix_common_block
parameter_list|(
name|struct
name|symbol
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|read_type_number
parameter_list|(
name|char
modifier|*
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|type
modifier|*
name|read_type
parameter_list|(
name|char
modifier|*
modifier|*
parameter_list|,
name|struct
name|objfile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|type
modifier|*
name|read_range_type
parameter_list|(
name|char
modifier|*
modifier|*
parameter_list|,
name|int
index|[
literal|2
index|]
parameter_list|,
name|struct
name|objfile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|type
modifier|*
name|read_sun_builtin_type
parameter_list|(
name|char
modifier|*
modifier|*
parameter_list|,
name|int
index|[
literal|2
index|]
parameter_list|,
name|struct
name|objfile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|type
modifier|*
name|read_sun_floating_type
parameter_list|(
name|char
modifier|*
modifier|*
parameter_list|,
name|int
index|[
literal|2
index|]
parameter_list|,
name|struct
name|objfile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|type
modifier|*
name|read_enum_type
parameter_list|(
name|char
modifier|*
modifier|*
parameter_list|,
name|struct
name|type
modifier|*
parameter_list|,
name|struct
name|objfile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|type
modifier|*
name|rs6000_builtin_type
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|read_member_functions
parameter_list|(
name|struct
name|field_info
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|,
name|struct
name|type
modifier|*
parameter_list|,
name|struct
name|objfile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|read_struct_fields
parameter_list|(
name|struct
name|field_info
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|,
name|struct
name|type
modifier|*
parameter_list|,
name|struct
name|objfile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|read_baseclasses
parameter_list|(
name|struct
name|field_info
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|,
name|struct
name|type
modifier|*
parameter_list|,
name|struct
name|objfile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|read_tilde_fields
parameter_list|(
name|struct
name|field_info
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|,
name|struct
name|type
modifier|*
parameter_list|,
name|struct
name|objfile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|attach_fn_fields_to_type
parameter_list|(
name|struct
name|field_info
modifier|*
parameter_list|,
name|struct
name|type
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|attach_fields_to_type
parameter_list|(
name|struct
name|field_info
modifier|*
parameter_list|,
name|struct
name|type
modifier|*
parameter_list|,
name|struct
name|objfile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|type
modifier|*
name|read_struct_type
parameter_list|(
name|char
modifier|*
modifier|*
parameter_list|,
name|struct
name|type
modifier|*
parameter_list|,
name|enum
name|type_code
parameter_list|,
name|struct
name|objfile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|type
modifier|*
name|read_array_type
parameter_list|(
name|char
modifier|*
modifier|*
parameter_list|,
name|struct
name|type
modifier|*
parameter_list|,
name|struct
name|objfile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|field
modifier|*
name|read_args
parameter_list|(
name|char
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|objfile
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_undefined_type
parameter_list|(
name|struct
name|type
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|read_cpp_abbrev
parameter_list|(
name|struct
name|field_info
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|,
name|struct
name|type
modifier|*
parameter_list|,
name|struct
name|objfile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|find_name_end
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|process_reference
parameter_list|(
name|char
modifier|*
modifier|*
name|string
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|stabsread_clear_cache
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
specifier|const
name|char
name|vptr_name
index|[]
init|=
literal|"_vptr$"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|vb_name
index|[]
init|=
literal|"_vb$"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Define this as 1 if a pcc declaration of a char or short argument    gives the correct address.  Otherwise assume pcc gives the    address of the corresponding int, which is not the same on a    big-endian machine.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|BELIEVE_PCC_PROMOTION
argument_list|)
end_if

begin_define
define|#
directive|define
name|BELIEVE_PCC_PROMOTION
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|invalid_cpp_abbrev_complaint
parameter_list|(
specifier|const
name|char
modifier|*
name|arg1
parameter_list|)
block|{
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"invalid C++ abbreviation `%s'"
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|reg_value_complaint
parameter_list|(
name|int
name|arg1
parameter_list|,
name|int
name|arg2
parameter_list|,
specifier|const
name|char
modifier|*
name|arg3
parameter_list|)
block|{
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"register number %d too large (max %d) in symbol %s"
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|arg3
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|stabs_general_complaint
parameter_list|(
specifier|const
name|char
modifier|*
name|arg1
parameter_list|)
block|{
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"%s"
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make a list of forward references which haven't been defined.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
modifier|*
name|undef_types
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|undef_types_allocated
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|undef_types_length
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|symbol
modifier|*
name|current_symbol
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Check for and handle cretinous stabs symbol name continuation!  */
end_comment

begin_define
define|#
directive|define
name|STABS_CONTINUE
parameter_list|(
name|pp
parameter_list|,
name|objfile
parameter_list|)
define|\
value|do {							\     if (**(pp) == '\\' || (**(pp) == '?'&& (*(pp))[1] == '\0')) \       *(pp) = next_symbol_text (objfile);	\   } while (0)
end_define

begin_escape
end_escape

begin_comment
comment|/* Look up a dbx type-number pair.  Return the address of the slot    where the type for that number-pair is stored.    The number-pair is in TYPENUMS.     This can be used for finding the type associated with that pair    or for associating a new type with the pair.  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
modifier|*
name|dbx_lookup_type
parameter_list|(
name|int
name|typenums
index|[
literal|2
index|]
parameter_list|)
block|{
name|int
name|filenum
init|=
name|typenums
index|[
literal|0
index|]
decl_stmt|;
name|int
name|index
init|=
name|typenums
index|[
literal|1
index|]
decl_stmt|;
name|unsigned
name|old_len
decl_stmt|;
name|int
name|real_filenum
decl_stmt|;
name|struct
name|header_file
modifier|*
name|f
decl_stmt|;
name|int
name|f_orig_length
decl_stmt|;
if|if
condition|(
name|filenum
operator|==
operator|-
literal|1
condition|)
comment|/* -1,-1 is for temporary types.  */
return|return
literal|0
return|;
if|if
condition|(
name|filenum
operator|<
literal|0
operator|||
name|filenum
operator|>=
name|n_this_object_header_files
condition|)
block|{
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"Invalid symbol data: type number (%d,%d) out of range at symtab pos %d."
argument_list|,
name|filenum
argument_list|,
name|index
argument_list|,
name|symnum
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
if|if
condition|(
name|filenum
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|index
operator|<
literal|0
condition|)
block|{
comment|/* Caller wants address of address of type.  We think 	     that negative (rs6k builtin) types will never appear as 	     "lvalues", (nor should they), so we stuff the real type 	     pointer into a temp, and return its address.  If referenced, 	     this will do the right thing.  */
specifier|static
name|struct
name|type
modifier|*
name|temp_type
decl_stmt|;
name|temp_type
operator|=
name|rs6000_builtin_type
argument_list|(
name|index
argument_list|)
expr_stmt|;
return|return
operator|&
name|temp_type
return|;
block|}
comment|/* Type is defined outside of header files.          Find it in this object file's type vector.  */
if|if
condition|(
name|index
operator|>=
name|type_vector_length
condition|)
block|{
name|old_len
operator|=
name|type_vector_length
expr_stmt|;
if|if
condition|(
name|old_len
operator|==
literal|0
condition|)
block|{
name|type_vector_length
operator|=
name|INITIAL_TYPE_VECTOR_LENGTH
expr_stmt|;
name|type_vector
operator|=
operator|(
expr|struct
name|type
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|type_vector_length
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|index
operator|>=
name|type_vector_length
condition|)
block|{
name|type_vector_length
operator|*=
literal|2
expr_stmt|;
block|}
name|type_vector
operator|=
operator|(
expr|struct
name|type
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|type_vector
argument_list|,
operator|(
name|type_vector_length
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|type_vector
index|[
name|old_len
index|]
argument_list|,
literal|0
argument_list|,
operator|(
name|type_vector_length
operator|-
name|old_len
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|&
name|type_vector
index|[
name|index
index|]
operator|)
return|;
block|}
else|else
block|{
name|real_filenum
operator|=
name|this_object_header_files
index|[
name|filenum
index|]
expr_stmt|;
if|if
condition|(
name|real_filenum
operator|>=
name|N_HEADER_FILES
argument_list|(
name|current_objfile
argument_list|)
condition|)
block|{
name|struct
name|type
modifier|*
name|temp_type
decl_stmt|;
name|struct
name|type
modifier|*
modifier|*
name|temp_type_p
decl_stmt|;
name|warning
argument_list|(
literal|"GDB internal error: bad real_filenum"
argument_list|)
expr_stmt|;
name|error_return
label|:
name|temp_type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_ERROR
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|temp_type_p
operator|=
operator|(
expr|struct
name|type
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|temp_type_p
operator|=
name|temp_type
expr_stmt|;
return|return
name|temp_type_p
return|;
block|}
name|f
operator|=
name|HEADER_FILES
argument_list|(
name|current_objfile
argument_list|)
operator|+
name|real_filenum
expr_stmt|;
name|f_orig_length
operator|=
name|f
operator|->
name|length
expr_stmt|;
if|if
condition|(
name|index
operator|>=
name|f_orig_length
condition|)
block|{
while|while
condition|(
name|index
operator|>=
name|f
operator|->
name|length
condition|)
block|{
name|f
operator|->
name|length
operator|*=
literal|2
expr_stmt|;
block|}
name|f
operator|->
name|vector
operator|=
operator|(
expr|struct
name|type
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|f
operator|->
name|vector
argument_list|,
name|f
operator|->
name|length
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|f
operator|->
name|vector
index|[
name|f_orig_length
index|]
argument_list|,
literal|0
argument_list|,
operator|(
name|f
operator|->
name|length
operator|-
name|f_orig_length
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|&
name|f
operator|->
name|vector
index|[
name|index
index|]
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Make sure there is a type allocated for type numbers TYPENUMS    and return the type object.    This can create an empty (zeroed) type object.    TYPENUMS may be (-1, -1) to return a new type object that is not    put into the type vector, and so may not be referred to by number. */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|dbx_alloc_type
parameter_list|(
name|int
name|typenums
index|[
literal|2
index|]
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|struct
name|type
modifier|*
modifier|*
name|type_addr
decl_stmt|;
if|if
condition|(
name|typenums
index|[
literal|0
index|]
operator|==
operator|-
literal|1
condition|)
block|{
return|return
operator|(
name|alloc_type
argument_list|(
name|objfile
argument_list|)
operator|)
return|;
block|}
name|type_addr
operator|=
name|dbx_lookup_type
argument_list|(
name|typenums
argument_list|)
expr_stmt|;
comment|/* If we are referring to a type not known at all yet,      allocate an empty type for it.      We will fill it in later if we find out how.  */
if|if
condition|(
operator|*
name|type_addr
operator|==
literal|0
condition|)
block|{
operator|*
name|type_addr
operator|=
name|alloc_type
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|*
name|type_addr
operator|)
return|;
block|}
end_function

begin_comment
comment|/* for all the stabs in a given stab vector, build appropriate types     and fix their symbols in given symbol vector. */
end_comment

begin_function
specifier|static
name|void
name|patch_block_stabs
parameter_list|(
name|struct
name|pending
modifier|*
name|symbols
parameter_list|,
name|struct
name|pending_stabs
modifier|*
name|stabs
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|int
name|ii
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|pp
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
if|if
condition|(
name|stabs
condition|)
block|{
comment|/* for all the stab entries, find their corresponding symbols and           patch their types! */
for|for
control|(
name|ii
operator|=
literal|0
init|;
name|ii
operator|<
name|stabs
operator|->
name|count
condition|;
operator|++
name|ii
control|)
block|{
name|name
operator|=
name|stabs
operator|->
name|stab
index|[
name|ii
index|]
expr_stmt|;
name|pp
operator|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|name
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
while|while
condition|(
name|pp
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
block|{
name|pp
operator|+=
literal|2
expr_stmt|;
name|pp
operator|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|pp
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
block|}
name|sym
operator|=
name|find_symbol_in_list
argument_list|(
name|symbols
argument_list|,
name|name
argument_list|,
name|pp
operator|-
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sym
condition|)
block|{
comment|/* FIXME-maybe: it would be nice if we noticed whether 	         the variable was defined *anywhere*, not just whether 	         it is defined in this compilation unit.  But neither 	         xlc or GCC seem to need such a definition, and until 	         we do psymtabs (so that the minimal symbols from all 	         compilation units are available now), I'm not sure 	         how to get the information.  */
comment|/* On xcoff, if a global is defined and never referenced, 	         ld will remove it from the executable.  There is then 	         a N_GSYM stab for it, but no regular (C_EXT) symbol.  */
name|sym
operator|=
operator|(
expr|struct
name|symbol
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|sym
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
name|SYMBOL_DOMAIN
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_DOMAIN
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_OPTIMIZED_OUT
expr_stmt|;
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|=
name|obsavestring
argument_list|(
name|name
argument_list|,
name|pp
operator|-
name|name
argument_list|,
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|)
expr_stmt|;
name|pp
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|pp
operator|-
literal|1
operator|)
operator|==
literal|'F'
operator|||
operator|*
operator|(
name|pp
operator|-
literal|1
operator|)
operator|==
literal|'f'
condition|)
block|{
comment|/* I don't think the linker does this with functions, 		     so as far as I know this is never executed. 		     But it doesn't hurt to check.  */
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|lookup_function_type
argument_list|(
name|read_type
argument_list|(
operator|&
name|pp
argument_list|,
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|read_type
argument_list|(
operator|&
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|global_symbols
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pp
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|pp
operator|-
literal|1
operator|)
operator|==
literal|'F'
operator|||
operator|*
operator|(
name|pp
operator|-
literal|1
operator|)
operator|==
literal|'f'
condition|)
block|{
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|lookup_function_type
argument_list|(
name|read_type
argument_list|(
operator|&
name|pp
argument_list|,
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|read_type
argument_list|(
operator|&
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read a number by which a type is referred to in dbx data,    or perhaps read a pair (FILENUM, TYPENUM) in parentheses.    Just a single number N is equivalent to (0,N).    Return the two numbers by storing them in the vector TYPENUMS.    TYPENUMS will then be used as an argument to dbx_lookup_type.     Returns 0 for success, -1 for error.  */
end_comment

begin_function
specifier|static
name|int
name|read_type_number
parameter_list|(
name|char
modifier|*
modifier|*
name|pp
parameter_list|,
name|int
modifier|*
name|typenums
parameter_list|)
block|{
name|int
name|nbits
decl_stmt|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|'('
condition|)
block|{
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
name|typenums
index|[
literal|0
index|]
operator|=
name|read_huge_number
argument_list|(
name|pp
argument_list|,
literal|','
argument_list|,
operator|&
name|nbits
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbits
operator|!=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|typenums
index|[
literal|1
index|]
operator|=
name|read_huge_number
argument_list|(
name|pp
argument_list|,
literal|')'
argument_list|,
operator|&
name|nbits
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbits
operator|!=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
name|typenums
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|typenums
index|[
literal|1
index|]
operator|=
name|read_huge_number
argument_list|(
name|pp
argument_list|,
literal|0
argument_list|,
operator|&
name|nbits
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbits
operator|!=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_define
define|#
directive|define
name|VISIBILITY_PRIVATE
value|'0'
end_define

begin_comment
comment|/* Stabs character for private field */
end_comment

begin_define
define|#
directive|define
name|VISIBILITY_PROTECTED
value|'1'
end_define

begin_comment
comment|/* Stabs character for protected fld */
end_comment

begin_define
define|#
directive|define
name|VISIBILITY_PUBLIC
value|'2'
end_define

begin_comment
comment|/* Stabs character for public field */
end_comment

begin_define
define|#
directive|define
name|VISIBILITY_IGNORE
value|'9'
end_define

begin_comment
comment|/* Optimized out or zero length */
end_comment

begin_comment
comment|/* Structure for storing pointers to reference definitions for fast lookup     during "process_later". */
end_comment

begin_struct
struct|struct
name|ref_map
block|{
name|char
modifier|*
name|stabs
decl_stmt|;
name|CORE_ADDR
name|value
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|MAX_CHUNK_REFS
value|100
end_define

begin_define
define|#
directive|define
name|REF_CHUNK_SIZE
value|(MAX_CHUNK_REFS * sizeof (struct ref_map))
end_define

begin_define
define|#
directive|define
name|REF_MAP_SIZE
parameter_list|(
name|ref_chunk
parameter_list|)
value|((ref_chunk) * REF_CHUNK_SIZE)
end_define

begin_decl_stmt
specifier|static
name|struct
name|ref_map
modifier|*
name|ref_map
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Ptr to free cell in chunk's linked list. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ref_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of chunks malloced. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ref_chunk
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This file maintains a cache of stabs aliases found in the symbol    table. If the symbol table changes, this cache must be cleared    or we are left holding onto data in invalid obstacks. */
end_comment

begin_function
name|void
name|stabsread_clear_cache
parameter_list|(
name|void
parameter_list|)
block|{
name|ref_count
operator|=
literal|0
expr_stmt|;
name|ref_chunk
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create array of pointers mapping refids to symbols and stab strings.    Add pointers to reference definition symbols and/or their values as we     find them, using their reference numbers as our index.     These will be used later when we resolve references. */
end_comment

begin_function
name|void
name|ref_add
parameter_list|(
name|int
name|refnum
parameter_list|,
name|struct
name|symbol
modifier|*
name|sym
parameter_list|,
name|char
modifier|*
name|stabs
parameter_list|,
name|CORE_ADDR
name|value
parameter_list|)
block|{
if|if
condition|(
name|ref_count
operator|==
literal|0
condition|)
name|ref_chunk
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|refnum
operator|>=
name|ref_count
condition|)
name|ref_count
operator|=
name|refnum
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|ref_count
operator|>
name|ref_chunk
operator|*
name|MAX_CHUNK_REFS
condition|)
block|{
name|int
name|new_slots
init|=
name|ref_count
operator|-
name|ref_chunk
operator|*
name|MAX_CHUNK_REFS
decl_stmt|;
name|int
name|new_chunks
init|=
name|new_slots
operator|/
name|MAX_CHUNK_REFS
operator|+
literal|1
decl_stmt|;
name|ref_map
operator|=
operator|(
expr|struct
name|ref_map
operator|*
operator|)
name|xrealloc
argument_list|(
name|ref_map
argument_list|,
name|REF_MAP_SIZE
argument_list|(
name|ref_chunk
operator|+
name|new_chunks
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|ref_map
operator|+
name|ref_chunk
operator|*
name|MAX_CHUNK_REFS
argument_list|,
literal|0
argument_list|,
name|new_chunks
operator|*
name|REF_CHUNK_SIZE
argument_list|)
expr_stmt|;
name|ref_chunk
operator|+=
name|new_chunks
expr_stmt|;
block|}
name|ref_map
index|[
name|refnum
index|]
operator|.
name|stabs
operator|=
name|stabs
expr_stmt|;
name|ref_map
index|[
name|refnum
index|]
operator|.
name|sym
operator|=
name|sym
expr_stmt|;
name|ref_map
index|[
name|refnum
index|]
operator|.
name|value
operator|=
name|value
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return defined sym for the reference REFNUM.  */
end_comment

begin_function
name|struct
name|symbol
modifier|*
name|ref_search
parameter_list|(
name|int
name|refnum
parameter_list|)
block|{
if|if
condition|(
name|refnum
operator|<
literal|0
operator|||
name|refnum
operator|>
name|ref_count
condition|)
return|return
literal|0
return|;
return|return
name|ref_map
index|[
name|refnum
index|]
operator|.
name|sym
return|;
block|}
end_function

begin_comment
comment|/* Parse a reference id in STRING and return the resulting    reference number.  Move STRING beyond the reference id.  */
end_comment

begin_function
specifier|static
name|int
name|process_reference
parameter_list|(
name|char
modifier|*
modifier|*
name|string
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|refnum
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|*
operator|*
name|string
operator|!=
literal|'#'
condition|)
return|return
literal|0
return|;
comment|/* Advance beyond the initial '#'.  */
name|p
operator|=
operator|*
name|string
operator|+
literal|1
expr_stmt|;
comment|/* Read number as reference id. */
while|while
condition|(
operator|*
name|p
operator|&&
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|refnum
operator|=
name|refnum
operator|*
literal|10
operator|+
operator|*
name|p
operator|-
literal|'0'
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
operator|*
name|string
operator|=
name|p
expr_stmt|;
return|return
name|refnum
return|;
block|}
end_function

begin_comment
comment|/* If STRING defines a reference, store away a pointer to the reference     definition for later use.  Return the reference number.  */
end_comment

begin_function
name|int
name|symbol_reference_defined
parameter_list|(
name|char
modifier|*
modifier|*
name|string
parameter_list|)
block|{
name|char
modifier|*
name|p
init|=
operator|*
name|string
decl_stmt|;
name|int
name|refnum
init|=
literal|0
decl_stmt|;
name|refnum
operator|=
name|process_reference
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
comment|/* Defining symbols end in '=' */
if|if
condition|(
operator|*
name|p
operator|==
literal|'='
condition|)
block|{
comment|/* Symbol is being defined here. */
operator|*
name|string
operator|=
name|p
operator|+
literal|1
expr_stmt|;
return|return
name|refnum
return|;
block|}
else|else
block|{
comment|/* Must be a reference.   Either the symbol has already been defined,          or this is a forward reference to it.  */
operator|*
name|string
operator|=
name|p
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function

begin_function
name|struct
name|symbol
modifier|*
name|define_symbol
parameter_list|(
name|CORE_ADDR
name|valu
parameter_list|,
name|char
modifier|*
name|string
parameter_list|,
name|int
name|desc
parameter_list|,
name|int
name|type
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|char
modifier|*
name|p
init|=
operator|(
name|char
operator|*
operator|)
name|find_name_end
argument_list|(
name|string
argument_list|)
decl_stmt|;
name|int
name|deftype
decl_stmt|;
name|int
name|synonym
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* We would like to eliminate nameless symbols, but keep their types.      E.g. stab entry ":t10=*2" should produce a type 10, which is a pointer      to type 2, but, should not create a symbol to address that type. Since      the symbol will be nameless, there is no way any user can refer to it. */
name|int
name|nameless
decl_stmt|;
comment|/* Ignore syms with empty names.  */
if|if
condition|(
name|string
index|[
literal|0
index|]
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Ignore old-style symbols from cc -go  */
if|if
condition|(
name|p
operator|==
literal|0
condition|)
return|return
literal|0
return|;
while|while
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
block|{
name|p
operator|+=
literal|2
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
block|}
comment|/* If a nameless stab entry, all we need is the type, not the symbol.      e.g. ":t10=*2" or a nameless enum like " :T16=ered:0,green:1,blue:2,;" */
name|nameless
operator|=
operator|(
name|p
operator|==
name|string
operator|||
operator|(
operator|(
name|string
index|[
literal|0
index|]
operator|==
literal|' '
operator|)
operator|&&
operator|(
name|string
index|[
literal|1
index|]
operator|==
literal|':'
operator|)
operator|)
operator|)
expr_stmt|;
name|current_symbol
operator|=
name|sym
operator|=
operator|(
expr|struct
name|symbol
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|sym
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
operator|&
name|N_TYPE
condition|)
block|{
case|case
name|N_TEXT
case|:
name|SYMBOL_SECTION
argument_list|(
name|sym
argument_list|)
operator|=
name|SECT_OFF_TEXT
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_DATA
case|:
name|SYMBOL_SECTION
argument_list|(
name|sym
argument_list|)
operator|=
name|SECT_OFF_DATA
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_BSS
case|:
name|SYMBOL_SECTION
argument_list|(
name|sym
argument_list|)
operator|=
name|SECT_OFF_BSS
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|processing_gcc_compilation
condition|)
block|{
comment|/* GCC 2.x puts the line number in desc.  SunOS apparently puts in the          number of bytes occupied by a type or object, which we ignore.  */
name|SYMBOL_LINE
argument_list|(
name|sym
argument_list|)
operator|=
name|desc
expr_stmt|;
block|}
else|else
block|{
name|SYMBOL_LINE
argument_list|(
name|sym
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* unknown */
block|}
if|if
condition|(
name|is_cplus_marker
argument_list|(
name|string
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
comment|/* Special GNU C++ names.  */
switch|switch
condition|(
name|string
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'t'
case|:
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|=
name|obsavestring
argument_list|(
literal|"this"
argument_list|,
name|strlen
argument_list|(
literal|"this"
argument_list|)
argument_list|,
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
comment|/* $vtbl_ptr_type */
comment|/* Was: DEPRECATED_SYMBOL_NAME (sym) = "vptr"; */
goto|goto
name|normal
goto|;
case|case
literal|'e'
case|:
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|=
name|obsavestring
argument_list|(
literal|"eh_throw"
argument_list|,
name|strlen
argument_list|(
literal|"eh_throw"
argument_list|)
argument_list|,
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'_'
case|:
comment|/* This was an anonymous type that was never fixed up.  */
goto|goto
name|normal
goto|;
ifdef|#
directive|ifdef
name|STATIC_TRANSFORM_NAME
case|case
literal|'X'
case|:
comment|/* SunPRO (3.0 at least) static variable encoding.  */
goto|goto
name|normal
goto|;
endif|#
directive|endif
default|default:
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"Unknown C++ symbol name `%s'"
argument_list|,
name|string
argument_list|)
expr_stmt|;
goto|goto
name|normal
goto|;
comment|/* Do *something* with it */
block|}
block|}
else|else
block|{
name|normal
label|:
name|SYMBOL_LANGUAGE
argument_list|(
name|sym
argument_list|)
operator|=
name|current_subfile
operator|->
name|language
expr_stmt|;
name|SYMBOL_SET_NAMES
argument_list|(
name|sym
argument_list|,
name|string
argument_list|,
name|p
operator|-
name|string
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
name|p
operator|++
expr_stmt|;
comment|/* Determine the type of name being defined.  */
if|#
directive|if
literal|0
comment|/* Getting GDB to correctly skip the symbol on an undefined symbol      descriptor and not ever dump core is a very dodgy proposition if      we do things this way.  I say the acorn RISC machine can just      fix their compiler.  */
comment|/* The Acorn RISC machine's compiler can put out locals that don't      start with "234=" or "(3,4)=", so assume anything other than the      deftypes we know how to handle is a local.  */
block|if (!strchr ("cfFGpPrStTvVXCR", *p))
else|#
directive|else
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|'('
operator|||
operator|*
name|p
operator|==
literal|'-'
condition|)
endif|#
directive|endif
name|deftype
operator|=
literal|'l'
expr_stmt|;
else|else
name|deftype
operator|=
operator|*
name|p
operator|++
expr_stmt|;
switch|switch
condition|(
name|deftype
condition|)
block|{
case|case
literal|'c'
case|:
comment|/* c is a special case, not followed by a type-number.          SYMBOL:c=iVALUE for an integer constant symbol.          SYMBOL:c=rVALUE for a floating constant symbol.          SYMBOL:c=eTYPE,INTVALUE for an enum constant symbol.          e.g. "b:c=e6,0" for "const b = blob1"          (where type 6 is defined by "blobs:t6=eblob1:0,blob2:1,;").  */
if|if
condition|(
operator|*
name|p
operator|!=
literal|'='
condition|)
block|{
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_CONST
expr_stmt|;
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|error_type
argument_list|(
operator|&
name|p
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|SYMBOL_DOMAIN
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_DOMAIN
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|file_symbols
argument_list|)
expr_stmt|;
return|return
name|sym
return|;
block|}
operator|++
name|p
expr_stmt|;
switch|switch
condition|(
operator|*
name|p
operator|++
condition|)
block|{
case|case
literal|'r'
case|:
block|{
name|double
name|d
init|=
name|atof
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|char
modifier|*
name|dbl_valu
decl_stmt|;
comment|/* FIXME-if-picky-about-floating-accuracy: Should be using 	       target arithmetic to get the value.  real.c in GCC 	       probably has the necessary code.  */
comment|/* FIXME: lookup_fundamental_type is a hack.  We should be 	       creating a type especially for the type of float constants. 	       Problem is, what type should it be?  	       Also, what should the name of this type be?  Should we 	       be using 'S' constants (see stabs.texinfo) instead?  */
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|lookup_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_DBL_PREC_FLOAT
argument_list|)
expr_stmt|;
name|dbl_valu
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|store_typed_floating
argument_list|(
name|dbl_valu
argument_list|,
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|SYMBOL_VALUE_BYTES
argument_list|(
name|sym
argument_list|)
operator|=
name|dbl_valu
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_CONST_BYTES
expr_stmt|;
block|}
break|break;
case|case
literal|'i'
case|:
block|{
comment|/* Defining integer constants this way is kind of silly, 	       since 'e' constants allows the compiler to give not 	       only the value, but the type as well.  C has at least 	       int, long, unsigned int, and long long as constant 	       types; other languages probably should have at least 	       unsigned as well as signed constants.  */
comment|/* We just need one int constant type for all objfiles. 	       It doesn't depend on languages or anything (arguably its 	       name should be a language-specific name for a type of 	       that size, but I'm inclined to say that if the compiler 	       wants a nice name for the type, it can use 'e').  */
specifier|static
name|struct
name|type
modifier|*
name|int_const_type
decl_stmt|;
comment|/* Yes, this is as long as a *host* int.  That is because we 	       use atoi.  */
if|if
condition|(
name|int_const_type
operator|==
name|NULL
condition|)
name|int_const_type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|HOST_CHAR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"integer constant"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|int_const_type
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|atoi
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_CONST
expr_stmt|;
block|}
break|break;
case|case
literal|'e'
case|:
comment|/* SYMBOL:c=eTYPE,INTVALUE for a constant symbol whose value 	     can be represented as integral. 	     e.g. "b:c=e6,0" for "const b = blob1" 	     (where type 6 is defined by "blobs:t6=eblob1:0,blob2:1,;").  */
block|{
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_CONST
expr_stmt|;
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|read_type
argument_list|(
operator|&
name|p
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|','
condition|)
block|{
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|error_type
argument_list|(
operator|&
name|p
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
block|}
operator|++
name|p
expr_stmt|;
comment|/* If the value is too big to fit in an int (perhaps because 	       it is unsigned), or something like that, we silently get 	       a bogus value.  The type and everything else about it is 	       correct.  Ideally, we should be using whatever we have 	       available for parsing unsigned and long long values, 	       however.  */
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|atoi
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
block|{
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_CONST
expr_stmt|;
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|error_type
argument_list|(
operator|&
name|p
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
block|}
name|SYMBOL_DOMAIN
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_DOMAIN
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|file_symbols
argument_list|)
expr_stmt|;
return|return
name|sym
return|;
case|case
literal|'C'
case|:
comment|/* The name of a caught exception.  */
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|read_type
argument_list|(
operator|&
name|p
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_LABEL
expr_stmt|;
name|SYMBOL_DOMAIN
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_DOMAIN
expr_stmt|;
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym
argument_list|)
operator|=
name|valu
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|local_symbols
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* A static function definition.  */
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|read_type
argument_list|(
operator|&
name|p
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_BLOCK
expr_stmt|;
name|SYMBOL_DOMAIN
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_DOMAIN
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|file_symbols
argument_list|)
expr_stmt|;
comment|/* fall into process_function_types.  */
name|process_function_types
label|:
comment|/* Function result types are described as the result type in stabs.          We need to convert this to the function-returning-type-X type          in GDB.  E.g. "int" is converted to "function returning int".  */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|!=
name|TYPE_CODE_FUNC
condition|)
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|lookup_function_type
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
comment|/* All functions in C++ have prototypes.  Stabs does not offer an          explicit way to identify prototyped or unprototyped functions,          but both GCC and Sun CC emit stabs for the "call-as" type rather          than the "declared-as" type for unprototyped functions, so          we treat all functions as if they were prototyped.  This is used          primarily for promotion when calling the function from GDB.  */
name|TYPE_FLAGS
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator||=
name|TYPE_FLAG_PROTOTYPED
expr_stmt|;
comment|/* fall into process_prototype_types */
name|process_prototype_types
label|:
comment|/* Sun acc puts declared types of arguments here.  */
if|if
condition|(
operator|*
name|p
operator|==
literal|';'
condition|)
block|{
name|struct
name|type
modifier|*
name|ftype
init|=
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
decl_stmt|;
name|int
name|nsemi
init|=
literal|0
decl_stmt|;
name|int
name|nparams
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|p1
init|=
name|p
decl_stmt|;
comment|/* Obtain a worst case guess for the number of arguments 	     by counting the semicolons.  */
while|while
condition|(
operator|*
name|p1
condition|)
block|{
if|if
condition|(
operator|*
name|p1
operator|++
operator|==
literal|';'
condition|)
name|nsemi
operator|++
expr_stmt|;
block|}
comment|/* Allocate parameter information fields and fill them in. */
name|TYPE_FIELDS
argument_list|(
name|ftype
argument_list|)
operator|=
operator|(
expr|struct
name|field
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|ftype
argument_list|,
name|nsemi
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|++
operator|==
literal|';'
condition|)
block|{
name|struct
name|type
modifier|*
name|ptype
decl_stmt|;
comment|/* A type number of zero indicates the start of varargs. 	         FIXME: GDB currently ignores vararg functions.  */
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'0'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
break|break;
name|ptype
operator|=
name|read_type
argument_list|(
operator|&
name|p
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* The Sun compilers mark integer arguments, which should 	         be promoted to the width of the calling conventions, with 	         a type which references itself. This type is turned into 	         a TYPE_CODE_VOID type by read_type, and we have to turn 	         it back into builtin_type_int here. 	         FIXME: Do we need a new builtin_type_promoted_int_arg ?  */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|ptype
argument_list|)
operator|==
name|TYPE_CODE_VOID
condition|)
name|ptype
operator|=
name|builtin_type_int
expr_stmt|;
name|TYPE_FIELD_TYPE
argument_list|(
name|ftype
argument_list|,
name|nparams
argument_list|)
operator|=
name|ptype
expr_stmt|;
name|TYPE_FIELD_ARTIFICIAL
argument_list|(
name|ftype
argument_list|,
name|nparams
operator|++
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
name|TYPE_NFIELDS
argument_list|(
name|ftype
argument_list|)
operator|=
name|nparams
expr_stmt|;
name|TYPE_FLAGS
argument_list|(
name|ftype
argument_list|)
operator||=
name|TYPE_FLAG_PROTOTYPED
expr_stmt|;
block|}
break|break;
case|case
literal|'F'
case|:
comment|/* A global function definition.  */
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|read_type
argument_list|(
operator|&
name|p
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_BLOCK
expr_stmt|;
name|SYMBOL_DOMAIN
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_DOMAIN
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|global_symbols
argument_list|)
expr_stmt|;
goto|goto
name|process_function_types
goto|;
case|case
literal|'G'
case|:
comment|/* For a class G (global) symbol, it appears that the          value is not correct.  It is necessary to search for the          corresponding linker definition to find the value.          These definitions appear at the end of the namelist.  */
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|read_type
argument_list|(
operator|&
name|p
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_STATIC
expr_stmt|;
name|SYMBOL_DOMAIN
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_DOMAIN
expr_stmt|;
comment|/* Don't add symbol references to global_sym_chain.          Symbol references don't have valid names and wont't match up with          minimal symbols when the global_sym_chain is relocated.          We'll fixup symbol references when we fixup the defining symbol.  */
if|if
condition|(
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|&&
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
index|[
literal|0
index|]
operator|!=
literal|'#'
condition|)
block|{
name|i
operator|=
name|hashname
argument_list|(
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|SYMBOL_VALUE_CHAIN
argument_list|(
name|sym
argument_list|)
operator|=
name|global_sym_chain
index|[
name|i
index|]
expr_stmt|;
name|global_sym_chain
index|[
name|i
index|]
operator|=
name|sym
expr_stmt|;
block|}
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|global_symbols
argument_list|)
expr_stmt|;
break|break;
comment|/* This case is faked by a conditional above,          when there is no code letter in the dbx data.          Dbx data never actually contains 'l'.  */
case|case
literal|'s'
case|:
case|case
literal|'l'
case|:
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|read_type
argument_list|(
operator|&
name|p
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_LOCAL
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|valu
expr_stmt|;
name|SYMBOL_DOMAIN
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_DOMAIN
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|local_symbols
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
if|if
condition|(
operator|*
name|p
operator|==
literal|'F'
condition|)
comment|/* pF is a two-letter code that means a function parameter in Fortran. 	   The type-number specifies the type of the return value. 	   Translate it into a pointer-to-function type.  */
block|{
name|p
operator|++
expr_stmt|;
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|lookup_pointer_type
argument_list|(
name|lookup_function_type
argument_list|(
name|read_type
argument_list|(
operator|&
name|p
argument_list|,
name|objfile
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|read_type
argument_list|(
operator|&
name|p
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_ARG
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|valu
expr_stmt|;
name|SYMBOL_DOMAIN
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_DOMAIN
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|local_symbols
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_BYTE_ORDER
operator|!=
name|BFD_ENDIAN_BIG
condition|)
block|{
comment|/* On little-endian machines, this crud is never necessary, 	     and, if the extra bytes contain garbage, is harmful.  */
break|break;
block|}
comment|/* If it's gcc-compiled, if it says `short', believe it.  */
if|if
condition|(
name|processing_gcc_compilation
operator|||
name|BELIEVE_PCC_PROMOTION
condition|)
break|break;
if|if
condition|(
operator|!
name|BELIEVE_PCC_PROMOTION
condition|)
block|{
comment|/* This is the signed type which arguments get promoted to.  */
specifier|static
name|struct
name|type
modifier|*
name|pcc_promotion_type
decl_stmt|;
comment|/* This is the unsigned type which arguments get promoted to.  */
specifier|static
name|struct
name|type
modifier|*
name|pcc_unsigned_promotion_type
decl_stmt|;
comment|/* Call it "int" because this is mainly C lossage.  */
if|if
condition|(
name|pcc_promotion_type
operator|==
name|NULL
condition|)
name|pcc_promotion_type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_INT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"int"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcc_unsigned_promotion_type
operator|==
name|NULL
condition|)
name|pcc_unsigned_promotion_type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_INT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"unsigned int"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|BELIEVE_PCC_PROMOTION_TYPE
condition|)
block|{
comment|/* This is defined on machines (e.g. sparc) where we 	         should believe the type of a PCC 'short' argument, 	         but shouldn't believe the address (the address is the 	         address of the corresponding int).  	         My guess is that this correction, as opposed to 	         changing the parameter to an 'int' (as done below, 	         for PCC on most machines), is the right thing to do 	         on all machines, but I don't want to risk breaking 	         something that already works.  On most PCC machines, 	         the sparc problem doesn't come up because the calling 	         function has to zero the top bytes (not knowing 	         whether the called function wants an int or a short), 	         so there is little practical difference between an 	         int and a short (except perhaps what happens when the 	         GDB user types "print short_arg = 0x10000;").  	         Hacked for SunOS 4.1 by gnu@cygnus.com.  In 4.1, the 	         compiler actually produces the correct address (we 	         don't need to fix it up).  I made this code adapt so 	         that it will offset the symbol if it was pointing at 	         an int-aligned location and not otherwise.  This way 	         you can use the same gdb for 4.0.x and 4.1 systems.  	         If the parameter is shorter than an int, and is 	         integral (e.g. char, short, or unsigned equivalent), 	         and is claimed to be passed on an integer boundary, 	         don't believe it!  Offset the parameter's address to 	         the tail-end of that integer.  */
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|<
name|TYPE_LENGTH
argument_list|(
name|pcc_promotion_type
argument_list|)
operator|&&
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_INT
operator|&&
literal|0
operator|==
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|%
name|TYPE_LENGTH
argument_list|(
name|pcc_promotion_type
argument_list|)
condition|)
block|{
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|+=
name|TYPE_LENGTH
argument_list|(
name|pcc_promotion_type
argument_list|)
operator|-
name|TYPE_LENGTH
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
else|else
block|{
comment|/* If PCC says a parameter is a short or a char, 	         it is really an int.  */
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|<
name|TYPE_LENGTH
argument_list|(
name|pcc_promotion_type
argument_list|)
operator|&&
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_INT
condition|)
block|{
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|TYPE_UNSIGNED
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
condition|?
name|pcc_unsigned_promotion_type
else|:
name|pcc_promotion_type
expr_stmt|;
block|}
break|break;
block|}
block|}
case|case
literal|'P'
case|:
comment|/* acc seems to use P to declare the prototypes of functions that          are referenced by this file.  gdb is not prepared to deal          with this extra information.  FIXME, it ought to.  */
if|if
condition|(
name|type
operator|==
name|N_FUN
condition|)
block|{
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|read_type
argument_list|(
operator|&
name|p
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
goto|goto
name|process_prototype_types
goto|;
block|}
comment|/*FALLTHROUGH */
case|case
literal|'R'
case|:
comment|/* Parameter which is in a register.  */
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|read_type
argument_list|(
operator|&
name|p
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_REGPARM
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|STAB_REG_TO_REGNUM
argument_list|(
name|valu
argument_list|)
expr_stmt|;
if|if
condition|(
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|>=
name|NUM_REGS
operator|+
name|NUM_PSEUDO_REGS
condition|)
block|{
name|reg_value_complaint
argument_list|(
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
argument_list|,
name|NUM_REGS
operator|+
name|NUM_PSEUDO_REGS
argument_list|,
name|SYMBOL_PRINT_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|SP_REGNUM
expr_stmt|;
comment|/* Known safe, though useless */
block|}
name|SYMBOL_DOMAIN
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_DOMAIN
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|local_symbols
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* Register variable (either global or local).  */
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|read_type
argument_list|(
operator|&
name|p
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_REGISTER
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|STAB_REG_TO_REGNUM
argument_list|(
name|valu
argument_list|)
expr_stmt|;
if|if
condition|(
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|>=
name|NUM_REGS
operator|+
name|NUM_PSEUDO_REGS
condition|)
block|{
name|reg_value_complaint
argument_list|(
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
argument_list|,
name|NUM_REGS
operator|+
name|NUM_PSEUDO_REGS
argument_list|,
name|SYMBOL_PRINT_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|SP_REGNUM
expr_stmt|;
comment|/* Known safe, though useless */
block|}
name|SYMBOL_DOMAIN
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_DOMAIN
expr_stmt|;
if|if
condition|(
name|within_function
condition|)
block|{
comment|/* Sun cc uses a pair of symbols, one 'p' and one 'r', with 	     the same name to represent an argument passed in a 	     register.  GCC uses 'P' for the same case.  So if we find 	     such a symbol pair we combine it into one 'P' symbol. 	     For Sun cc we need to do this regardless of 	     stabs_argument_has_addr, because the compiler puts out 	     the 'p' symbol even if it never saves the argument onto 	     the stack.  	     On most machines, we want to preserve both symbols, so 	     that we can still get information about what is going on 	     with the stack (VAX for computing args_printed, using 	     stack slots instead of saved registers in backtraces, 	     etc.).  	     Note that this code illegally combines 	     main(argc) struct foo argc; { register struct foo argc; } 	     but this case is considered pathological and causes a warning 	     from a decent compiler.  */
if|if
condition|(
name|local_symbols
operator|&&
name|local_symbols
operator|->
name|nsyms
operator|>
literal|0
operator|&&
name|gdbarch_stabs_argument_has_addr
argument_list|(
name|current_gdbarch
argument_list|,
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
condition|)
block|{
name|struct
name|symbol
modifier|*
name|prev_sym
decl_stmt|;
name|prev_sym
operator|=
name|local_symbols
operator|->
name|symbol
index|[
name|local_symbols
operator|->
name|nsyms
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|SYMBOL_CLASS
argument_list|(
name|prev_sym
argument_list|)
operator|==
name|LOC_REF_ARG
operator|||
name|SYMBOL_CLASS
argument_list|(
name|prev_sym
argument_list|)
operator|==
name|LOC_ARG
operator|)
operator|&&
name|strcmp
argument_list|(
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|prev_sym
argument_list|)
argument_list|,
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|SYMBOL_CLASS
argument_list|(
name|prev_sym
argument_list|)
operator|=
name|LOC_REGPARM
expr_stmt|;
comment|/* Use the type from the LOC_REGISTER; that is the type 		     that is actually in that register.  */
name|SYMBOL_TYPE
argument_list|(
name|prev_sym
argument_list|)
operator|=
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|prev_sym
argument_list|)
operator|=
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|sym
operator|=
name|prev_sym
expr_stmt|;
break|break;
block|}
block|}
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|local_symbols
argument_list|)
expr_stmt|;
block|}
else|else
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|file_symbols
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
comment|/* Static symbol at top level of file */
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|read_type
argument_list|(
operator|&
name|p
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_STATIC
expr_stmt|;
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym
argument_list|)
operator|=
name|valu
expr_stmt|;
ifdef|#
directive|ifdef
name|STATIC_TRANSFORM_NAME
if|if
condition|(
name|IS_STATIC_TRANSFORM_NAME
argument_list|(
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
condition|)
block|{
name|struct
name|minimal_symbol
modifier|*
name|msym
decl_stmt|;
name|msym
operator|=
name|lookup_minimal_symbol
argument_list|(
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|msym
operator|!=
name|NULL
condition|)
block|{
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|=
name|STATIC_TRANSFORM_NAME
argument_list|(
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym
argument_list|)
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msym
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|SYMBOL_DOMAIN
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_DOMAIN
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|file_symbols
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* Typedef */
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|read_type
argument_list|(
operator|&
name|p
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* For a nameless type, we don't want a create a symbol, thus we          did not use `sym'. Return without further processing. */
if|if
condition|(
name|nameless
condition|)
return|return
name|NULL
return|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_TYPEDEF
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|valu
expr_stmt|;
name|SYMBOL_DOMAIN
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_DOMAIN
expr_stmt|;
comment|/* C++ vagaries: we may have a type which is derived from          a base type which did not have its name defined when the          derived class was output.  We fill in the derived class's          base part member's name here in that case.  */
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|!=
name|NULL
condition|)
if|if
condition|(
operator|(
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
operator|||
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_UNION
operator|)
operator|&&
name|TYPE_N_BASECLASSES
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|TYPE_N_BASECLASSES
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|TYPE_BASECLASS_NAME
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|,
name|j
argument_list|)
operator|==
literal|0
condition|)
name|TYPE_BASECLASS_NAME
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|,
name|j
argument_list|)
operator|=
name|type_name_no_tag
argument_list|(
name|TYPE_BASECLASS
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* gcc-2.6 or later (when using -fvtable-thunks) 	     emits a unique named type for a vtable entry. 	     Some gdb code depends on that specific name. */
specifier|extern
specifier|const
name|char
name|vtbl_ptr_name
index|[]
decl_stmt|;
if|if
condition|(
operator|(
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_PTR
operator|&&
name|strcmp
argument_list|(
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|vtbl_ptr_name
argument_list|)
operator|)
operator|||
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_FUNC
condition|)
block|{
comment|/* If we are giving a name to a type such as "pointer to 	         foo" or "function returning foo", we better not set 	         the TYPE_NAME.  If the program contains "typedef char 	         *caddr_t;", we don't want all variables of type char 	         * to print as caddr_t.  This is not just a 	         consequence of GDB's type management; PCC and GCC (at 	         least through version 2.4) both output variables of 	         either type char * or caddr_t with the type number 	         defined in the 't' symbol for caddr_t.  If a future 	         compiler cleans this up it GDB is not ready for it 	         yet, but if it becomes ready we somehow need to 	         disable this check (without breaking the PCC/GCC2.4 	         case).  	         Sigh.  	         Fortunately, this check seems not to be necessary 	         for anything except pointers or functions.  */
comment|/* ezannoni: 2000-10-26. This seems to apply for 		 versions of gcc older than 2.8. This was the original 		 problem: with the following code gdb would tell that 		 the type for name1 is caddr_t, and func is char() 	         typedef char *caddr_t; 		 char *name2; 		 struct x 		 { 		 char *name1; 		 } xx; 		 char *func() 		 { 		 } 		 main () {} 		 */
comment|/* Pascal accepts names for pointer types. */
if|if
condition|(
name|current_subfile
operator|->
name|language
operator|==
name|language_pascal
condition|)
block|{
name|TYPE_NAME
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|=
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|TYPE_NAME
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|=
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
expr_stmt|;
block|}
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|file_symbols
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
comment|/* Struct, union, or enum tag.  For GNU C++, this can be be followed          by 't' which means we are typedef'ing it as well.  */
name|synonym
operator|=
operator|*
name|p
operator|==
literal|'t'
expr_stmt|;
if|if
condition|(
name|synonym
condition|)
name|p
operator|++
expr_stmt|;
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|read_type
argument_list|(
operator|&
name|p
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* For a nameless type, we don't want a create a symbol, thus we          did not use `sym'. Return without further processing. */
if|if
condition|(
name|nameless
condition|)
return|return
name|NULL
return|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_TYPEDEF
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|valu
expr_stmt|;
name|SYMBOL_DOMAIN
argument_list|(
name|sym
argument_list|)
operator|=
name|STRUCT_DOMAIN
expr_stmt|;
if|if
condition|(
name|TYPE_TAG_NAME
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|TYPE_TAG_NAME
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|=
name|obconcat
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|file_symbols
argument_list|)
expr_stmt|;
if|if
condition|(
name|synonym
condition|)
block|{
comment|/* Clone the sym and then modify it. */
name|struct
name|symbol
modifier|*
name|typedef_sym
init|=
operator|(
expr|struct
name|symbol
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
decl_stmt|;
operator|*
name|typedef_sym
operator|=
operator|*
name|sym
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|typedef_sym
argument_list|)
operator|=
name|LOC_TYPEDEF
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|typedef_sym
argument_list|)
operator|=
name|valu
expr_stmt|;
name|SYMBOL_DOMAIN
argument_list|(
name|typedef_sym
argument_list|)
operator|=
name|VAR_DOMAIN
expr_stmt|;
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|TYPE_NAME
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|=
name|obconcat
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|typedef_sym
argument_list|,
operator|&
name|file_symbols
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'V'
case|:
comment|/* Static symbol of local scope */
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|read_type
argument_list|(
operator|&
name|p
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_STATIC
expr_stmt|;
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym
argument_list|)
operator|=
name|valu
expr_stmt|;
ifdef|#
directive|ifdef
name|STATIC_TRANSFORM_NAME
if|if
condition|(
name|IS_STATIC_TRANSFORM_NAME
argument_list|(
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
condition|)
block|{
name|struct
name|minimal_symbol
modifier|*
name|msym
decl_stmt|;
name|msym
operator|=
name|lookup_minimal_symbol
argument_list|(
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|msym
operator|!=
name|NULL
condition|)
block|{
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|=
name|STATIC_TRANSFORM_NAME
argument_list|(
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym
argument_list|)
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msym
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|SYMBOL_DOMAIN
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_DOMAIN
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|local_symbols
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
comment|/* Reference parameter */
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|read_type
argument_list|(
operator|&
name|p
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_REF_ARG
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|valu
expr_stmt|;
name|SYMBOL_DOMAIN
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_DOMAIN
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|local_symbols
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
comment|/* Reference parameter which is in a register.  */
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|read_type
argument_list|(
operator|&
name|p
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_REGPARM_ADDR
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|STAB_REG_TO_REGNUM
argument_list|(
name|valu
argument_list|)
expr_stmt|;
if|if
condition|(
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|>=
name|NUM_REGS
operator|+
name|NUM_PSEUDO_REGS
condition|)
block|{
name|reg_value_complaint
argument_list|(
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
argument_list|,
name|NUM_REGS
operator|+
name|NUM_PSEUDO_REGS
argument_list|,
name|SYMBOL_PRINT_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|SP_REGNUM
expr_stmt|;
comment|/* Known safe, though useless */
block|}
name|SYMBOL_DOMAIN
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_DOMAIN
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|local_symbols
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
comment|/* This is used by Sun FORTRAN for "function result value".          Sun claims ("dbx and dbxtool interfaces", 2nd ed)          that Pascal uses it too, but when I tried it Pascal used          "x:3" (local symbol) instead.  */
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|read_type
argument_list|(
operator|&
name|p
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_LOCAL
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|valu
expr_stmt|;
name|SYMBOL_DOMAIN
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_DOMAIN
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|local_symbols
argument_list|)
expr_stmt|;
break|break;
default|default:
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|error_type
argument_list|(
operator|&
name|p
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_CONST
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SYMBOL_DOMAIN
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_DOMAIN
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|file_symbols
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Some systems pass variables of certain types by reference instead      of by value, i.e. they will pass the address of a structure (in a      register or on the stack) instead of the structure itself.  */
if|if
condition|(
name|gdbarch_stabs_argument_has_addr
argument_list|(
name|current_gdbarch
argument_list|,
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|&&
operator|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_REGPARM
operator|||
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_ARG
operator|)
condition|)
block|{
comment|/* We have to convert LOC_REGPARM to LOC_REGPARM_ADDR (for          variables passed in a register).  */
if|if
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_REGPARM
condition|)
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_REGPARM_ADDR
expr_stmt|;
comment|/* Likewise for converting LOC_ARG to LOC_REF_ARG (for the 7th 	 and subsequent arguments on SPARC, for example).  */
elseif|else
if|if
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_ARG
condition|)
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_REF_ARG
expr_stmt|;
block|}
return|return
name|sym
return|;
block|}
end_function

begin_comment
comment|/* Skip rest of this symbol and return an error type.     General notes on error recovery:  error_type always skips to the    end of the symbol (modulo cretinous dbx symbol name continuation).    Thus code like this:     if (*(*pp)++ != ';')    return error_type (pp, objfile);     is wrong because if *pp starts out pointing at '\0' (typically as the    result of an earlier error), it will be incremented to point to the    start of the next symbol, which might produce strange results, at least    if you run off the end of the string table.  Instead use     if (**pp != ';')    return error_type (pp, objfile);    ++*pp;     or     if (**pp != ';')    foo = error_type (pp, objfile);    else    ++*pp;     And in case it isn't obvious, the point of all this hair is so the compiler    can define new types and new syntaxes, and old versions of the    debugger will be able to read the new symbol tables.  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|error_type
parameter_list|(
name|char
modifier|*
modifier|*
name|pp
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"couldn't parse type; debugger out of date?"
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Skip to end of symbol.  */
while|while
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|'\0'
condition|)
block|{
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
block|}
comment|/* Check for and handle cretinous dbx symbol name continuation!  */
if|if
condition|(
operator|(
operator|*
name|pp
operator|)
index|[
operator|-
literal|1
index|]
operator|==
literal|'\\'
operator|||
operator|(
operator|*
name|pp
operator|)
index|[
operator|-
literal|1
index|]
operator|==
literal|'?'
condition|)
block|{
operator|*
name|pp
operator|=
name|next_symbol_text
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
return|return
operator|(
name|builtin_type_error
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read type information or a type definition; return the type.  Even    though this routine accepts either type information or a type    definition, the distinction is relevant--some parts of stabsread.c    assume that type information starts with a digit, '-', or '(' in    deciding whether to call read_type.  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|read_type
parameter_list|(
name|char
modifier|*
modifier|*
name|pp
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|type
init|=
literal|0
decl_stmt|;
name|struct
name|type
modifier|*
name|type1
decl_stmt|;
name|int
name|typenums
index|[
literal|2
index|]
decl_stmt|;
name|char
name|type_descriptor
decl_stmt|;
comment|/* Size in bits of type if specified by a type attribute, or -1 if      there is no size attribute.  */
name|int
name|type_size
init|=
operator|-
literal|1
decl_stmt|;
comment|/* Used to distinguish string and bitstring from char-array and set. */
name|int
name|is_string
init|=
literal|0
decl_stmt|;
comment|/* Used to distinguish vector from array. */
name|int
name|is_vector
init|=
literal|0
decl_stmt|;
comment|/* Read type number if present.  The type number may be omitted.      for instance in a two-dimensional array declared with type      "ar1;1;10;ar1;1;10;4".  */
if|if
condition|(
operator|(
operator|*
operator|*
name|pp
operator|>=
literal|'0'
operator|&&
operator|*
operator|*
name|pp
operator|<=
literal|'9'
operator|)
operator|||
operator|*
operator|*
name|pp
operator|==
literal|'('
operator|||
operator|*
operator|*
name|pp
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
name|read_type_number
argument_list|(
name|pp
argument_list|,
name|typenums
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|error_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
return|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|'='
condition|)
block|{
comment|/* Type is not being defined here.  Either it already              exists, or this is a forward reference to it.              dbx_alloc_type handles both cases.  */
name|type
operator|=
name|dbx_alloc_type
argument_list|(
name|typenums
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* If this is a forward reference, arrange to complain if it              doesn't get patched up by the time we're done              reading.  */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_UNDEF
condition|)
name|add_undefined_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
comment|/* Type is being defined here.  */
comment|/* Skip the '='.          Also skip the type descriptor - we get it below with (*pp)[-1].  */
operator|(
operator|*
name|pp
operator|)
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
comment|/* 'typenums=' not present, type is anonymous.  Read and return          the definition, but don't put it in the type vector.  */
name|typenums
index|[
literal|0
index|]
operator|=
name|typenums
index|[
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
block|}
name|again
label|:
name|type_descriptor
operator|=
operator|(
operator|*
name|pp
operator|)
index|[
operator|-
literal|1
index|]
expr_stmt|;
switch|switch
condition|(
name|type_descriptor
condition|)
block|{
case|case
literal|'x'
case|:
block|{
name|enum
name|type_code
name|code
decl_stmt|;
comment|/* Used to index through file_symbols.  */
name|struct
name|pending
modifier|*
name|ppt
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Name including "struct", etc.  */
name|char
modifier|*
name|type_name
decl_stmt|;
block|{
name|char
modifier|*
name|from
decl_stmt|,
modifier|*
name|to
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|q1
decl_stmt|,
modifier|*
name|q2
decl_stmt|;
comment|/* Set the type code according to the following letter.  */
switch|switch
condition|(
operator|(
operator|*
name|pp
operator|)
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'s'
case|:
name|code
operator|=
name|TYPE_CODE_STRUCT
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|code
operator|=
name|TYPE_CODE_UNION
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|code
operator|=
name|TYPE_CODE_ENUM
expr_stmt|;
break|break;
default|default:
block|{
comment|/* Complain and keep going, so compilers can invent new 		   cross-reference types.  */
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"Unrecognized cross-reference type `%c'"
argument_list|,
operator|(
operator|*
name|pp
operator|)
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|code
operator|=
name|TYPE_CODE_STRUCT
expr_stmt|;
break|break;
block|}
block|}
name|q1
operator|=
name|strchr
argument_list|(
operator|*
name|pp
argument_list|,
literal|'<'
argument_list|)
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
operator|*
name|pp
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
name|error_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
return|;
if|if
condition|(
name|q1
operator|&&
name|p
operator|>
name|q1
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
block|{
name|int
name|nesting_level
init|=
literal|0
decl_stmt|;
for|for
control|(
name|q2
operator|=
name|q1
init|;
operator|*
name|q2
condition|;
name|q2
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|q2
operator|==
literal|'<'
condition|)
name|nesting_level
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|q2
operator|==
literal|'>'
condition|)
name|nesting_level
operator|--
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|q2
operator|==
literal|':'
operator|&&
name|nesting_level
operator|==
literal|0
condition|)
break|break;
block|}
name|p
operator|=
name|q2
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|':'
condition|)
return|return
name|error_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
return|;
block|}
name|to
operator|=
name|type_name
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
name|p
operator|-
operator|*
name|pp
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Copy the name.  */
name|from
operator|=
operator|*
name|pp
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|from
operator|<
name|p
condition|)
operator|*
name|to
operator|++
operator|=
operator|*
name|from
operator|++
expr_stmt|;
operator|*
name|to
operator|=
literal|'\0'
expr_stmt|;
comment|/* Set the pointer ahead of the name which we just read, and 	     the colon.  */
operator|*
name|pp
operator|=
name|from
operator|+
literal|1
expr_stmt|;
block|}
comment|/* If this type has already been declared, then reuse the same            type, rather than allocating a new one.  This saves some            memory.  */
for|for
control|(
name|ppt
operator|=
name|file_symbols
init|;
name|ppt
condition|;
name|ppt
operator|=
name|ppt
operator|->
name|next
control|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ppt
operator|->
name|nsyms
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|symbol
modifier|*
name|sym
init|=
name|ppt
operator|->
name|symbol
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_TYPEDEF
operator|&&
name|SYMBOL_DOMAIN
argument_list|(
name|sym
argument_list|)
operator|==
name|STRUCT_DOMAIN
operator|&&
operator|(
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|==
name|code
operator|)
operator|&&
name|strcmp
argument_list|(
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|type_name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|obstack_free
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
name|type_name
argument_list|)
expr_stmt|;
name|type
operator|=
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|typenums
index|[
literal|0
index|]
operator|!=
operator|-
literal|1
condition|)
operator|*
name|dbx_lookup_type
argument_list|(
name|typenums
argument_list|)
operator|=
name|type
expr_stmt|;
return|return
name|type
return|;
block|}
block|}
comment|/* Didn't find the type to which this refers, so we must 	   be dealing with a forward reference.  Allocate a type 	   structure for it, and keep track of it so we can 	   fill in the rest of the fields when we get the full 	   type.  */
name|type
operator|=
name|dbx_alloc_type
argument_list|(
name|typenums
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|code
expr_stmt|;
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
operator|=
name|type_name
expr_stmt|;
name|INIT_CPLUS_SPECIFIC
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_FLAGS
argument_list|(
name|type
argument_list|)
operator||=
name|TYPE_FLAG_STUB
expr_stmt|;
name|add_undefined_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
case|case
literal|'-'
case|:
comment|/* RS/6000 built-in type */
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
case|case
literal|'('
case|:
operator|(
operator|*
name|pp
operator|)
operator|--
expr_stmt|;
comment|/* We deal with something like t(1,2)=(3,4)=... which          the Lucid compiler and recent gcc versions (post 2.7.3) use. */
comment|/* Allocate and enter the typedef type first.          This handles recursive types. */
name|type
operator|=
name|dbx_alloc_type
argument_list|(
name|typenums
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_CODE_TYPEDEF
expr_stmt|;
block|{
name|struct
name|type
modifier|*
name|xtype
init|=
name|read_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|xtype
condition|)
block|{
comment|/* It's being defined as itself.  That means it is "void".  */
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_CODE_VOID
expr_stmt|;
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type_size
operator|>=
literal|0
operator|||
name|is_string
condition|)
block|{
comment|/* This is the absolute wrong way to construct types.  Every 	       other debug format has found a way around this problem and 	       the related problems with unnecessarily stubbed types; 	       someone motivated should attempt to clean up the issue 	       here as well.  Once a type pointed to has been created it 	       should not be modified.                 Well, it's not *absolutely* wrong.  Constructing recursive                types (trees, linked lists) necessarily entails modifying                types after creating them.  Constructing any loop structure                entails side effects.  The Dwarf 2 reader does handle this                more gracefully (it never constructs more than once                instance of a type object, so it doesn't have to copy type                objects wholesale), but it still mutates type objects after                other folks have references to them.                 Keep in mind that this circularity/mutation issue shows up                at the source language level, too: C's "incomplete types",                for example.  So the proper cleanup, I think, would be to                limit GDB's type smashing to match exactly those required                by the source language.  So GDB could have a                "complete_this_type" function, but never create unnecessary                copies of a type otherwise.  */
name|replace_type
argument_list|(
name|type
argument_list|,
name|xtype
argument_list|)
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|TYPE_FLAGS
argument_list|(
name|type
argument_list|)
operator||=
name|TYPE_FLAG_TARGET_STUB
expr_stmt|;
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
operator|=
name|xtype
expr_stmt|;
block|}
block|}
break|break;
comment|/* In the following types, we must be sure to overwrite any existing          type that the typenums refer to, rather than allocating a new one          and making the typenums point to the new one.  This is because there          may already be pointers to the existing type (if it had been          forward-referenced), and we must change it to a pointer, function,          reference, or whatever, *in-place*.  */
case|case
literal|'*'
case|:
comment|/* Pointer to another type */
name|type1
operator|=
name|read_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|type
operator|=
name|make_pointer_type
argument_list|(
name|type1
argument_list|,
name|dbx_lookup_type
argument_list|(
name|typenums
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'&'
case|:
comment|/* Reference to another type */
name|type1
operator|=
name|read_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|type
operator|=
name|make_reference_type
argument_list|(
name|type1
argument_list|,
name|dbx_lookup_type
argument_list|(
name|typenums
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* Function returning another type */
name|type1
operator|=
name|read_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|type
operator|=
name|make_function_type
argument_list|(
name|type1
argument_list|,
name|dbx_lookup_type
argument_list|(
name|typenums
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
comment|/* Prototyped function.  (Sun)  */
block|{
comment|/* Unresolved questions:             - According to Sun's ``STABS Interface Manual'', for 'f'            and 'F' symbol descriptors, a `0' in the argument type list            indicates a varargs function.  But it doesn't say how 'g'            type descriptors represent that info.  Someone with access            to Sun's toolchain should try it out.             - According to the comment in define_symbol (search for            `process_prototype_types:'), Sun emits integer arguments as            types which ref themselves --- like `void' types.  Do we            have to deal with that here, too?  Again, someone with            access to Sun's toolchain should try it out and let us            know.  */
specifier|const
name|char
modifier|*
name|type_start
init|=
operator|(
operator|*
name|pp
operator|)
operator|-
literal|1
decl_stmt|;
name|struct
name|type
modifier|*
name|return_type
init|=
name|read_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
decl_stmt|;
name|struct
name|type
modifier|*
name|func_type
init|=
name|make_function_type
argument_list|(
name|return_type
argument_list|,
name|dbx_lookup_type
argument_list|(
name|typenums
argument_list|)
argument_list|)
decl_stmt|;
struct|struct
name|type_list
block|{
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|struct
name|type_list
modifier|*
name|next
decl_stmt|;
block|}
modifier|*
name|arg_types
init|=
literal|0
struct|;
name|int
name|num_args
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
operator|*
name|pp
operator|&&
operator|*
operator|*
name|pp
operator|!=
literal|'#'
condition|)
block|{
name|struct
name|type
modifier|*
name|arg_type
init|=
name|read_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
decl_stmt|;
name|struct
name|type_list
modifier|*
name|new
init|=
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|new
argument_list|)
argument_list|)
decl_stmt|;
name|new
operator|->
name|type
operator|=
name|arg_type
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|arg_types
expr_stmt|;
name|arg_types
operator|=
name|new
expr_stmt|;
name|num_args
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|'#'
condition|)
operator|++
operator|*
name|pp
expr_stmt|;
else|else
block|{
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"Prototyped function type didn't end arguments with `#':\n%s"
argument_list|,
name|type_start
argument_list|)
expr_stmt|;
block|}
comment|/* If there is just one argument whose type is `void', then            that's just an empty argument list.  */
if|if
condition|(
name|arg_types
operator|&&
operator|!
name|arg_types
operator|->
name|next
operator|&&
name|TYPE_CODE
argument_list|(
name|arg_types
operator|->
name|type
argument_list|)
operator|==
name|TYPE_CODE_VOID
condition|)
name|num_args
operator|=
literal|0
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|func_type
argument_list|)
operator|=
operator|(
expr|struct
name|field
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|func_type
argument_list|,
name|num_args
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|func_type
argument_list|)
argument_list|,
literal|0
argument_list|,
name|num_args
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
argument_list|)
expr_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|struct
name|type_list
modifier|*
name|t
decl_stmt|;
comment|/* We stuck each argument type onto the front of the list              when we read it, so the list is reversed.  Build the              fields array right-to-left.  */
for|for
control|(
name|t
operator|=
name|arg_types
operator|,
name|i
operator|=
name|num_args
operator|-
literal|1
init|;
name|t
condition|;
name|t
operator|=
name|t
operator|->
name|next
operator|,
name|i
operator|--
control|)
name|TYPE_FIELD_TYPE
argument_list|(
name|func_type
argument_list|,
name|i
argument_list|)
operator|=
name|t
operator|->
name|type
expr_stmt|;
block|}
name|TYPE_NFIELDS
argument_list|(
name|func_type
argument_list|)
operator|=
name|num_args
expr_stmt|;
name|TYPE_FLAGS
argument_list|(
name|func_type
argument_list|)
operator||=
name|TYPE_FLAG_PROTOTYPED
expr_stmt|;
name|type
operator|=
name|func_type
expr_stmt|;
break|break;
block|}
case|case
literal|'k'
case|:
comment|/* Const qualifier on some type (Sun) */
name|type
operator|=
name|read_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|type
operator|=
name|make_cv_type
argument_list|(
literal|1
argument_list|,
name|TYPE_VOLATILE
argument_list|(
name|type
argument_list|)
argument_list|,
name|type
argument_list|,
name|dbx_lookup_type
argument_list|(
name|typenums
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
comment|/* Volatile qual on some type (Sun) */
name|type
operator|=
name|read_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|type
operator|=
name|make_cv_type
argument_list|(
name|TYPE_CONST
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|,
name|type
argument_list|,
name|dbx_lookup_type
argument_list|(
name|typenums
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'@'
case|:
if|if
condition|(
name|isdigit
argument_list|(
operator|*
operator|*
name|pp
argument_list|)
operator|||
operator|*
operator|*
name|pp
operator|==
literal|'('
operator|||
operator|*
operator|*
name|pp
operator|==
literal|'-'
condition|)
block|{
comment|/* Member (class& variable) type */
comment|/* FIXME -- we should be doing smash_to_XXX types here.  */
name|struct
name|type
modifier|*
name|domain
init|=
name|read_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
decl_stmt|;
name|struct
name|type
modifier|*
name|memtype
decl_stmt|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|','
condition|)
comment|/* Invalid member type data format.  */
return|return
name|error_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
return|;
operator|++
operator|*
name|pp
expr_stmt|;
name|memtype
operator|=
name|read_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|type
operator|=
name|dbx_alloc_type
argument_list|(
name|typenums
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|smash_to_member_type
argument_list|(
name|type
argument_list|,
name|domain
argument_list|,
name|memtype
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* type attribute */
block|{
name|char
modifier|*
name|attr
init|=
operator|*
name|pp
decl_stmt|;
comment|/* Skip to the semicolon.  */
while|while
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|';'
operator|&&
operator|*
operator|*
name|pp
operator|!=
literal|'\0'
condition|)
operator|++
operator|(
operator|*
name|pp
operator|)
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|'\0'
condition|)
return|return
name|error_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
return|;
else|else
operator|++
operator|*
name|pp
expr_stmt|;
comment|/* Skip the semicolon.  */
switch|switch
condition|(
operator|*
name|attr
condition|)
block|{
case|case
literal|'s'
case|:
comment|/* Size attribute */
name|type_size
operator|=
name|atoi
argument_list|(
name|attr
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|type_size
operator|<=
literal|0
condition|)
name|type_size
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
comment|/* String attribute */
comment|/* FIXME: check to see if following type is array? */
name|is_string
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
comment|/* Vector attribute */
comment|/* FIXME: check to see if following type is array? */
name|is_vector
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
comment|/* Ignore unrecognized type attributes, so future compilers 	         can invent new ones.  */
break|break;
block|}
operator|++
operator|*
name|pp
expr_stmt|;
goto|goto
name|again
goto|;
block|}
break|break;
case|case
literal|'#'
case|:
comment|/* Method (class& fn) type */
if|if
condition|(
operator|(
operator|*
name|pp
operator|)
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
block|{
comment|/* We'll get the parameter types from the name.  */
name|struct
name|type
modifier|*
name|return_type
decl_stmt|;
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
name|return_type
operator|=
name|read_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
operator|*
name|pp
operator|)
operator|++
operator|!=
literal|';'
condition|)
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"invalid (minimal) member type data format at symtab pos %d."
argument_list|,
name|symnum
argument_list|)
expr_stmt|;
name|type
operator|=
name|allocate_stub_method
argument_list|(
name|return_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|typenums
index|[
literal|0
index|]
operator|!=
operator|-
literal|1
condition|)
operator|*
name|dbx_lookup_type
argument_list|(
name|typenums
argument_list|)
operator|=
name|type
expr_stmt|;
block|}
else|else
block|{
name|struct
name|type
modifier|*
name|domain
init|=
name|read_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
decl_stmt|;
name|struct
name|type
modifier|*
name|return_type
decl_stmt|;
name|struct
name|field
modifier|*
name|args
decl_stmt|;
name|int
name|nargs
decl_stmt|,
name|varargs
decl_stmt|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|','
condition|)
comment|/* Invalid member type data format.  */
return|return
name|error_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
return|;
else|else
operator|++
operator|(
operator|*
name|pp
operator|)
expr_stmt|;
name|return_type
operator|=
name|read_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|args
operator|=
name|read_args
argument_list|(
name|pp
argument_list|,
literal|';'
argument_list|,
name|objfile
argument_list|,
operator|&
name|nargs
argument_list|,
operator|&
name|varargs
argument_list|)
expr_stmt|;
name|type
operator|=
name|dbx_alloc_type
argument_list|(
name|typenums
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|smash_to_method_type
argument_list|(
name|type
argument_list|,
name|domain
argument_list|,
name|return_type
argument_list|,
name|args
argument_list|,
name|nargs
argument_list|,
name|varargs
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'r'
case|:
comment|/* Range type */
name|type
operator|=
name|read_range_type
argument_list|(
name|pp
argument_list|,
name|typenums
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|typenums
index|[
literal|0
index|]
operator|!=
operator|-
literal|1
condition|)
operator|*
name|dbx_lookup_type
argument_list|(
name|typenums
argument_list|)
operator|=
name|type
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
block|{
comment|/* Sun ACC builtin int type */
name|type
operator|=
name|read_sun_builtin_type
argument_list|(
name|pp
argument_list|,
name|typenums
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|typenums
index|[
literal|0
index|]
operator|!=
operator|-
literal|1
condition|)
operator|*
name|dbx_lookup_type
argument_list|(
name|typenums
argument_list|)
operator|=
name|type
expr_stmt|;
block|}
break|break;
case|case
literal|'R'
case|:
comment|/* Sun ACC builtin float type */
name|type
operator|=
name|read_sun_floating_type
argument_list|(
name|pp
argument_list|,
name|typenums
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|typenums
index|[
literal|0
index|]
operator|!=
operator|-
literal|1
condition|)
operator|*
name|dbx_lookup_type
argument_list|(
name|typenums
argument_list|)
operator|=
name|type
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
comment|/* Enumeration type */
name|type
operator|=
name|dbx_alloc_type
argument_list|(
name|typenums
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|type
operator|=
name|read_enum_type
argument_list|(
name|pp
argument_list|,
name|type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|typenums
index|[
literal|0
index|]
operator|!=
operator|-
literal|1
condition|)
operator|*
name|dbx_lookup_type
argument_list|(
name|typenums
argument_list|)
operator|=
name|type
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* Struct type */
case|case
literal|'u'
case|:
comment|/* Union type */
block|{
name|enum
name|type_code
name|type_code
init|=
name|TYPE_CODE_UNDEF
decl_stmt|;
name|type
operator|=
name|dbx_alloc_type
argument_list|(
name|typenums
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type_descriptor
condition|)
block|{
case|case
literal|'s'
case|:
name|type_code
operator|=
name|TYPE_CODE_STRUCT
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|type_code
operator|=
name|TYPE_CODE_UNION
expr_stmt|;
break|break;
block|}
name|type
operator|=
name|read_struct_type
argument_list|(
name|pp
argument_list|,
name|type
argument_list|,
name|type_code
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'a'
case|:
comment|/* Array type */
if|if
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|'r'
condition|)
return|return
name|error_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
return|;
operator|++
operator|*
name|pp
expr_stmt|;
name|type
operator|=
name|dbx_alloc_type
argument_list|(
name|typenums
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|type
operator|=
name|read_array_type
argument_list|(
name|pp
argument_list|,
name|type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_string
condition|)
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_CODE_STRING
expr_stmt|;
if|if
condition|(
name|is_vector
condition|)
name|TYPE_FLAGS
argument_list|(
name|type
argument_list|)
operator||=
name|TYPE_FLAG_VECTOR
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
comment|/* Set or bitstring  type */
name|type1
operator|=
name|read_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|type
operator|=
name|create_set_type
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|)
name|NULL
argument_list|,
name|type1
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_string
condition|)
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_CODE_BITSTRING
expr_stmt|;
if|if
condition|(
name|typenums
index|[
literal|0
index|]
operator|!=
operator|-
literal|1
condition|)
operator|*
name|dbx_lookup_type
argument_list|(
name|typenums
argument_list|)
operator|=
name|type
expr_stmt|;
break|break;
default|default:
operator|--
operator|*
name|pp
expr_stmt|;
comment|/* Go back to the symbol in error */
comment|/* Particularly important if it was \0! */
return|return
name|error_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
return|;
block|}
if|if
condition|(
name|type
operator|==
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"GDB internal error, type is NULL in stabsread.c\n"
argument_list|)
expr_stmt|;
return|return
name|error_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
return|;
block|}
comment|/* Size specified in a type attribute overrides any other size.  */
if|if
condition|(
name|type_size
operator|!=
operator|-
literal|1
condition|)
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
operator|(
name|type_size
operator|+
name|TARGET_CHAR_BIT
operator|-
literal|1
operator|)
operator|/
name|TARGET_CHAR_BIT
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* RS/6000 xlc/dbx combination uses a set of builtin types, starting from -1.    Return the proper type node for a given builtin type number. */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|rs6000_builtin_type
parameter_list|(
name|int
name|typenum
parameter_list|)
block|{
comment|/* We recognize types numbered from -NUMBER_RECOGNIZED to -1.  */
define|#
directive|define
name|NUMBER_RECOGNIZED
value|34
comment|/* This includes an empty slot for type number -0.  */
specifier|static
name|struct
name|type
modifier|*
name|negative_types
index|[
name|NUMBER_RECOGNIZED
operator|+
literal|1
index|]
decl_stmt|;
name|struct
name|type
modifier|*
name|rettype
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|typenum
operator|>=
literal|0
operator|||
name|typenum
operator|<
operator|-
name|NUMBER_RECOGNIZED
condition|)
block|{
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"Unknown builtin type %d"
argument_list|,
name|typenum
argument_list|)
expr_stmt|;
return|return
name|builtin_type_error
return|;
block|}
if|if
condition|(
name|negative_types
index|[
operator|-
name|typenum
index|]
operator|!=
name|NULL
condition|)
return|return
name|negative_types
index|[
operator|-
name|typenum
index|]
return|;
if|#
directive|if
name|TARGET_CHAR_BIT
operator|!=
literal|8
error|#
directive|error
error|This code wrong for TARGET_CHAR_BIT not 8
comment|/* These definitions all assume that TARGET_CHAR_BIT is 8.  I think      that if that ever becomes not true, the correct fix will be to      make the size in the struct type to be in bits, not in units of      TARGET_CHAR_BIT.  */
endif|#
directive|endif
switch|switch
condition|(
operator|-
name|typenum
condition|)
block|{
case|case
literal|1
case|:
comment|/* The size of this and all the other types are fixed, defined          by the debugging format.  If there is a type called "int" which          is other than 32 bits, then it should use a new negative type          number (or avoid negative type numbers for that case).          See stabs.texinfo.  */
name|rettype
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
literal|"int"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|rettype
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"char"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|rettype
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"short"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|rettype
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
literal|"long"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|rettype
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|1
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"unsigned char"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|rettype
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"signed char"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|7
case|:
name|rettype
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|2
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"unsigned short"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|rettype
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|4
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"unsigned int"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|9
case|:
name|rettype
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|4
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"unsigned"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
case|case
literal|10
case|:
name|rettype
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|4
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"unsigned long"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|11
case|:
name|rettype
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_VOID
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"void"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|12
case|:
comment|/* IEEE single precision (32 bit).  */
name|rettype
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
literal|"float"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|13
case|:
comment|/* IEEE double precision (64 bit).  */
name|rettype
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
literal|8
argument_list|,
literal|0
argument_list|,
literal|"double"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|14
case|:
comment|/* This is an IEEE double on the RS/6000, and different machines with          different sizes for "long double" should use different negative          type numbers.  See stabs.texinfo.  */
name|rettype
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
literal|8
argument_list|,
literal|0
argument_list|,
literal|"long double"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|15
case|:
name|rettype
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
literal|"integer"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|rettype
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_BOOL
argument_list|,
literal|4
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"boolean"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|17
case|:
name|rettype
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
literal|"short real"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|18
case|:
name|rettype
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
literal|8
argument_list|,
literal|0
argument_list|,
literal|"real"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|19
case|:
name|rettype
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_ERROR
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"stringptr"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|20
case|:
name|rettype
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_CHAR
argument_list|,
literal|1
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"character"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|21
case|:
name|rettype
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_BOOL
argument_list|,
literal|1
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"logical*1"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|22
case|:
name|rettype
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_BOOL
argument_list|,
literal|2
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"logical*2"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|23
case|:
name|rettype
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_BOOL
argument_list|,
literal|4
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"logical*4"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|24
case|:
name|rettype
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_BOOL
argument_list|,
literal|4
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"logical"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|25
case|:
comment|/* Complex type consisting of two IEEE single precision values.  */
name|rettype
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_COMPLEX
argument_list|,
literal|8
argument_list|,
literal|0
argument_list|,
literal|"complex"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|TYPE_TARGET_TYPE
argument_list|(
name|rettype
argument_list|)
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
literal|"float"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|26
case|:
comment|/* Complex type consisting of two IEEE double precision values.  */
name|rettype
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_COMPLEX
argument_list|,
literal|16
argument_list|,
literal|0
argument_list|,
literal|"double complex"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|TYPE_TARGET_TYPE
argument_list|(
name|rettype
argument_list|)
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
literal|8
argument_list|,
literal|0
argument_list|,
literal|"double"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|27
case|:
name|rettype
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"integer*1"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|28
case|:
name|rettype
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"integer*2"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|29
case|:
name|rettype
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
literal|"integer*4"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|30
case|:
name|rettype
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_CHAR
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"wchar"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|31
case|:
name|rettype
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|8
argument_list|,
literal|0
argument_list|,
literal|"long long"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|32
case|:
name|rettype
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|8
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"unsigned long long"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|33
case|:
name|rettype
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|8
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"logical*8"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|34
case|:
name|rettype
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|8
argument_list|,
literal|0
argument_list|,
literal|"integer*8"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
name|negative_types
index|[
operator|-
name|typenum
index|]
operator|=
name|rettype
expr_stmt|;
return|return
name|rettype
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This page contains subroutines of read_type.  */
end_comment

begin_comment
comment|/* Replace *OLD_NAME with the method name portion of PHYSNAME.  */
end_comment

begin_function
specifier|static
name|void
name|update_method_name_from_physname
parameter_list|(
name|char
modifier|*
modifier|*
name|old_name
parameter_list|,
name|char
modifier|*
name|physname
parameter_list|)
block|{
name|char
modifier|*
name|method_name
decl_stmt|;
name|method_name
operator|=
name|method_name_from_physname
argument_list|(
name|physname
argument_list|)
expr_stmt|;
if|if
condition|(
name|method_name
operator|==
name|NULL
condition|)
block|{
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"Method has bad physname %s\n"
argument_list|,
name|physname
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|old_name
argument_list|,
name|method_name
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|xfree
argument_list|(
operator|*
name|old_name
argument_list|)
expr_stmt|;
operator|*
name|old_name
operator|=
name|method_name
expr_stmt|;
block|}
else|else
name|xfree
argument_list|(
name|method_name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read member function stabs info for C++ classes.  The form of each member    function data is:     NAME :: TYPENUM[=type definition] ARGS : PHYSNAME ;     An example with two member functions is:     afunc1::20=##15;:i;2A.;afunc2::20:i;2A.;     For the case of overloaded operators, the format is op$::*.funcs, where    $ is the CPLUS_MARKER (usually '$'), `*' holds the place for an operator    name (such as `+=') and `.' marks the end of the operator name.     Returns 1 for success, 0 for failure.  */
end_comment

begin_function
specifier|static
name|int
name|read_member_functions
parameter_list|(
name|struct
name|field_info
modifier|*
name|fip
parameter_list|,
name|char
modifier|*
modifier|*
name|pp
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|int
name|nfn_fields
init|=
literal|0
decl_stmt|;
name|int
name|length
init|=
literal|0
decl_stmt|;
comment|/* Total number of member functions defined in this class.  If the class      defines two `f' functions, and one `g' function, then this will have      the value 3.  */
name|int
name|total_length
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
struct|struct
name|next_fnfield
block|{
name|struct
name|next_fnfield
modifier|*
name|next
decl_stmt|;
name|struct
name|fn_field
name|fn_field
decl_stmt|;
block|}
modifier|*
name|sublist
struct|;
name|struct
name|type
modifier|*
name|look_ahead_type
decl_stmt|;
name|struct
name|next_fnfieldlist
modifier|*
name|new_fnlist
decl_stmt|;
name|struct
name|next_fnfield
modifier|*
name|new_sublist
decl_stmt|;
name|char
modifier|*
name|main_fn_name
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Process each list until we find something that is not a member function      or find the end of the functions. */
while|while
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|';'
condition|)
block|{
comment|/* We should be positioned at the start of the function name.          Scan forward to find the first ':' and if it is not the          first of a "::" delimiter, then this is not a member function. */
name|p
operator|=
operator|*
name|pp
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|':'
condition|)
block|{
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|!=
literal|':'
condition|)
block|{
break|break;
block|}
name|sublist
operator|=
name|NULL
expr_stmt|;
name|look_ahead_type
operator|=
name|NULL
expr_stmt|;
name|length
operator|=
literal|0
expr_stmt|;
name|new_fnlist
operator|=
operator|(
expr|struct
name|next_fnfieldlist
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|next_fnfieldlist
argument_list|)
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|new_fnlist
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|new_fnlist
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|next_fnfieldlist
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|pp
operator|)
index|[
literal|0
index|]
operator|==
literal|'o'
operator|&&
operator|(
operator|*
name|pp
operator|)
index|[
literal|1
index|]
operator|==
literal|'p'
operator|&&
name|is_cplus_marker
argument_list|(
operator|(
operator|*
name|pp
operator|)
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
comment|/* This is a completely wierd case.  In order to stuff in the 	     names that might contain colons (the usual name delimiter), 	     Mike Tiemann defined a different name format which is 	     signalled if the identifier is "op$".  In that case, the 	     format is "op$::XXXX." where XXXX is the name.  This is 	     used for names like "+" or "=".  YUUUUUUUK!  FIXME!  */
comment|/* This lets the user type "break operator+". 	     We could just put in "+" as the name, but that wouldn't 	     work for "*".  */
specifier|static
name|char
name|opname
index|[
literal|32
index|]
init|=
literal|"op$"
decl_stmt|;
name|char
modifier|*
name|o
init|=
name|opname
operator|+
literal|3
decl_stmt|;
comment|/* Skip past '::'.  */
operator|*
name|pp
operator|=
name|p
operator|+
literal|2
expr_stmt|;
name|STABS_CONTINUE
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|p
operator|=
operator|*
name|pp
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'.'
condition|)
block|{
operator|*
name|o
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
name|main_fn_name
operator|=
name|savestring
argument_list|(
name|opname
argument_list|,
name|o
operator|-
name|opname
argument_list|)
expr_stmt|;
comment|/* Skip past '.'  */
operator|*
name|pp
operator|=
name|p
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|main_fn_name
operator|=
name|savestring
argument_list|(
operator|*
name|pp
argument_list|,
name|p
operator|-
operator|*
name|pp
argument_list|)
expr_stmt|;
comment|/* Skip past '::'.  */
operator|*
name|pp
operator|=
name|p
operator|+
literal|2
expr_stmt|;
block|}
name|new_fnlist
operator|->
name|fn_fieldlist
operator|.
name|name
operator|=
name|main_fn_name
expr_stmt|;
do|do
block|{
name|new_sublist
operator|=
operator|(
expr|struct
name|next_fnfield
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|next_fnfield
argument_list|)
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|new_sublist
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|new_sublist
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|next_fnfield
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check for and handle cretinous dbx symbol name continuation!  */
if|if
condition|(
name|look_ahead_type
operator|==
name|NULL
condition|)
block|{
comment|/* Normal case. */
name|STABS_CONTINUE
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|new_sublist
operator|->
name|fn_field
operator|.
name|type
operator|=
name|read_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|':'
condition|)
block|{
comment|/* Invalid symtab info for member function.  */
return|return
literal|0
return|;
block|}
block|}
else|else
block|{
comment|/* g++ version 1 kludge */
name|new_sublist
operator|->
name|fn_field
operator|.
name|type
operator|=
name|look_ahead_type
expr_stmt|;
name|look_ahead_type
operator|=
name|NULL
expr_stmt|;
block|}
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
name|p
operator|=
operator|*
name|pp
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|';'
condition|)
block|{
name|p
operator|++
expr_stmt|;
block|}
comment|/* If this is just a stub, then we don't have the real name here. */
if|if
condition|(
name|TYPE_STUB
argument_list|(
name|new_sublist
operator|->
name|fn_field
operator|.
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|TYPE_DOMAIN_TYPE
argument_list|(
name|new_sublist
operator|->
name|fn_field
operator|.
name|type
argument_list|)
condition|)
name|TYPE_DOMAIN_TYPE
argument_list|(
name|new_sublist
operator|->
name|fn_field
operator|.
name|type
argument_list|)
operator|=
name|type
expr_stmt|;
name|new_sublist
operator|->
name|fn_field
operator|.
name|is_stub
operator|=
literal|1
expr_stmt|;
block|}
name|new_sublist
operator|->
name|fn_field
operator|.
name|physname
operator|=
name|savestring
argument_list|(
operator|*
name|pp
argument_list|,
name|p
operator|-
operator|*
name|pp
argument_list|)
expr_stmt|;
operator|*
name|pp
operator|=
name|p
operator|+
literal|1
expr_stmt|;
comment|/* Set this member function's visibility fields.  */
switch|switch
condition|(
operator|*
operator|(
operator|*
name|pp
operator|)
operator|++
condition|)
block|{
case|case
name|VISIBILITY_PRIVATE
case|:
name|new_sublist
operator|->
name|fn_field
operator|.
name|is_private
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|VISIBILITY_PROTECTED
case|:
name|new_sublist
operator|->
name|fn_field
operator|.
name|is_protected
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|STABS_CONTINUE
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
operator|*
name|pp
condition|)
block|{
case|case
literal|'A'
case|:
comment|/* Normal functions. */
name|new_sublist
operator|->
name|fn_field
operator|.
name|is_const
operator|=
literal|0
expr_stmt|;
name|new_sublist
operator|->
name|fn_field
operator|.
name|is_volatile
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
comment|/* `const' member functions. */
name|new_sublist
operator|->
name|fn_field
operator|.
name|is_const
operator|=
literal|1
expr_stmt|;
name|new_sublist
operator|->
name|fn_field
operator|.
name|is_volatile
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
comment|/* `volatile' member function. */
name|new_sublist
operator|->
name|fn_field
operator|.
name|is_const
operator|=
literal|0
expr_stmt|;
name|new_sublist
operator|->
name|fn_field
operator|.
name|is_volatile
operator|=
literal|1
expr_stmt|;
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
comment|/* `const volatile' member function. */
name|new_sublist
operator|->
name|fn_field
operator|.
name|is_const
operator|=
literal|1
expr_stmt|;
name|new_sublist
operator|->
name|fn_field
operator|.
name|is_volatile
operator|=
literal|1
expr_stmt|;
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
comment|/* File compiled with g++ version 1 -- no info */
case|case
literal|'?'
case|:
case|case
literal|'.'
case|:
break|break;
default|default:
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"const/volatile indicator missing, got '%c'"
argument_list|,
operator|*
operator|*
name|pp
argument_list|)
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
operator|*
operator|(
operator|*
name|pp
operator|)
operator|++
condition|)
block|{
case|case
literal|'*'
case|:
block|{
name|int
name|nbits
decl_stmt|;
comment|/* virtual member function, followed by index. 		   The sign bit is set to distinguish pointers-to-methods 		   from virtual function indicies.  Since the array is 		   in words, the quantity must be shifted left by 1 		   on 16 bit machine, and by 2 on 32 bit machine, forcing 		   the sign bit out, and usable as a valid index into 		   the array.  Remove the sign bit here.  */
name|new_sublist
operator|->
name|fn_field
operator|.
name|voffset
operator|=
operator|(
literal|0x7fffffff
operator|&
name|read_huge_number
argument_list|(
name|pp
argument_list|,
literal|';'
argument_list|,
operator|&
name|nbits
argument_list|)
operator|)
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|nbits
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
name|STABS_CONTINUE
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|';'
operator|||
operator|*
operator|*
name|pp
operator|==
literal|'\0'
condition|)
block|{
comment|/* Must be g++ version 1.  */
name|new_sublist
operator|->
name|fn_field
operator|.
name|fcontext
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Figure out from whence this virtual function came. 		       It may belong to virtual function table of 		       one of its baseclasses.  */
name|look_ahead_type
operator|=
name|read_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|':'
condition|)
block|{
comment|/* g++ version 1 overloaded methods. */
block|}
else|else
block|{
name|new_sublist
operator|->
name|fn_field
operator|.
name|fcontext
operator|=
name|look_ahead_type
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|';'
condition|)
block|{
return|return
literal|0
return|;
block|}
else|else
block|{
operator|++
operator|*
name|pp
expr_stmt|;
block|}
name|look_ahead_type
operator|=
name|NULL
expr_stmt|;
block|}
block|}
break|break;
block|}
case|case
literal|'?'
case|:
comment|/* static member function.  */
block|{
name|int
name|slen
init|=
name|strlen
argument_list|(
name|main_fn_name
argument_list|)
decl_stmt|;
name|new_sublist
operator|->
name|fn_field
operator|.
name|voffset
operator|=
name|VOFFSET_STATIC
expr_stmt|;
comment|/* For static member functions, we can't tell if they 		   are stubbed, as they are put out as functions, and not as 		   methods. 		   GCC v2 emits the fully mangled name if 		   dbxout.c:flag_minimal_debug is not set, so we have to 		   detect a fully mangled physname here and set is_stub 		   accordingly.  Fully mangled physnames in v2 start with 		   the member function name, followed by two underscores. 		   GCC v3 currently always emits stubbed member functions, 		   but with fully mangled physnames, which start with _Z.  */
if|if
condition|(
operator|!
operator|(
name|strncmp
argument_list|(
name|new_sublist
operator|->
name|fn_field
operator|.
name|physname
argument_list|,
name|main_fn_name
argument_list|,
name|slen
argument_list|)
operator|==
literal|0
operator|&&
name|new_sublist
operator|->
name|fn_field
operator|.
name|physname
index|[
name|slen
index|]
operator|==
literal|'_'
operator|&&
name|new_sublist
operator|->
name|fn_field
operator|.
name|physname
index|[
name|slen
operator|+
literal|1
index|]
operator|==
literal|'_'
operator|)
condition|)
block|{
name|new_sublist
operator|->
name|fn_field
operator|.
name|is_stub
operator|=
literal|1
expr_stmt|;
block|}
break|break;
block|}
default|default:
comment|/* error */
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"member function type missing, got '%c'"
argument_list|,
operator|(
operator|*
name|pp
operator|)
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* Fall through into normal member function.  */
case|case
literal|'.'
case|:
comment|/* normal member function.  */
name|new_sublist
operator|->
name|fn_field
operator|.
name|voffset
operator|=
literal|0
expr_stmt|;
name|new_sublist
operator|->
name|fn_field
operator|.
name|fcontext
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|new_sublist
operator|->
name|next
operator|=
name|sublist
expr_stmt|;
name|sublist
operator|=
name|new_sublist
expr_stmt|;
name|length
operator|++
expr_stmt|;
name|STABS_CONTINUE
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|';'
operator|&&
operator|*
operator|*
name|pp
operator|!=
literal|'\0'
condition|)
do|;
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
name|STABS_CONTINUE
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* Skip GCC 3.X member functions which are duplicates of the callable 	 constructor/destructor.  */
if|if
condition|(
name|strcmp
argument_list|(
name|main_fn_name
argument_list|,
literal|"__base_ctor"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|main_fn_name
argument_list|,
literal|"__base_dtor"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|main_fn_name
argument_list|,
literal|"__deleting_dtor"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|xfree
argument_list|(
name|main_fn_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|has_stub
init|=
literal|0
decl_stmt|;
name|int
name|has_destructor
init|=
literal|0
decl_stmt|,
name|has_other
init|=
literal|0
decl_stmt|;
name|int
name|is_v3
init|=
literal|0
decl_stmt|;
name|struct
name|next_fnfield
modifier|*
name|tmp_sublist
decl_stmt|;
comment|/* Various versions of GCC emit various mostly-useless 	     strings in the name field for special member functions.  	     For stub methods, we need to defer correcting the name 	     until we are ready to unstub the method, because the current 	     name string is used by gdb_mangle_name.  The only stub methods 	     of concern here are GNU v2 operators; other methods have their 	     names correct (see caveat below).  	     For non-stub methods, in GNU v3, we have a complete physname. 	     Therefore we can safely correct the name now.  This primarily 	     affects constructors and destructors, whose name will be 	     __comp_ctor or __comp_dtor instead of Foo or ~Foo.  Cast 	     operators will also have incorrect names; for instance, 	     "operator int" will be named "operator i" (i.e. the type is 	     mangled).  	     For non-stub methods in GNU v2, we have no easy way to 	     know if we have a complete physname or not.  For most 	     methods the result depends on the platform (if CPLUS_MARKER 	     can be `$' or `.', it will use minimal debug information, or 	     otherwise the full physname will be included).  	     Rather than dealing with this, we take a different approach. 	     For v3 mangled names, we can use the full physname; for v2, 	     we use cplus_demangle_opname (which is actually v2 specific), 	     because the only interesting names are all operators - once again 	     barring the caveat below.  Skip this process if any method in the 	     group is a stub, to prevent our fouling up the workings of 	     gdb_mangle_name.  	     The caveat: GCC 2.95.x (and earlier?) put constructors and 	     destructors in the same method group.  We need to split this 	     into two groups, because they should have different names. 	     So for each method group we check whether it contains both 	     routines whose physname appears to be a destructor (the physnames 	     for and destructors are always provided, due to quirks in v2 	     mangling) and routines whose physname does not appear to be a 	     destructor.  If so then we break up the list into two halves. 	     Even if the constructors and destructors aren't in the same group 	     the destructor will still lack the leading tilde, so that also 	     needs to be fixed.  	     So, to summarize what we expect and handle here:  	        Given         Given          Real         Real       Action 	     method name     physname      physname   method name  	     __opi            [none]     __opi__3Foo  operator int    opname 	                                                           [now or later] 	     Foo              _._3Foo       _._3Foo      ~Foo       separate and 	                                                               rename 	     operator i     _ZN3FoocviEv _ZN3FoocviEv operator int    demangle 	     __comp_ctor  _ZN3FooC1ERKS_ _ZN3FooC1ERKS_   Foo         demangle 	  */
name|tmp_sublist
operator|=
name|sublist
expr_stmt|;
while|while
condition|(
name|tmp_sublist
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|tmp_sublist
operator|->
name|fn_field
operator|.
name|is_stub
condition|)
name|has_stub
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|tmp_sublist
operator|->
name|fn_field
operator|.
name|physname
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|tmp_sublist
operator|->
name|fn_field
operator|.
name|physname
index|[
literal|1
index|]
operator|==
literal|'Z'
condition|)
name|is_v3
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|is_destructor_name
argument_list|(
name|tmp_sublist
operator|->
name|fn_field
operator|.
name|physname
argument_list|)
condition|)
name|has_destructor
operator|++
expr_stmt|;
else|else
name|has_other
operator|++
expr_stmt|;
name|tmp_sublist
operator|=
name|tmp_sublist
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|has_destructor
operator|&&
name|has_other
condition|)
block|{
name|struct
name|next_fnfieldlist
modifier|*
name|destr_fnlist
decl_stmt|;
name|struct
name|next_fnfield
modifier|*
name|last_sublist
decl_stmt|;
comment|/* Create a new fn_fieldlist for the destructors.  */
name|destr_fnlist
operator|=
operator|(
expr|struct
name|next_fnfieldlist
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|next_fnfieldlist
argument_list|)
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|destr_fnlist
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|destr_fnlist
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|next_fnfieldlist
argument_list|)
argument_list|)
expr_stmt|;
name|destr_fnlist
operator|->
name|fn_fieldlist
operator|.
name|name
operator|=
name|obconcat
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
literal|""
argument_list|,
literal|"~"
argument_list|,
name|new_fnlist
operator|->
name|fn_fieldlist
operator|.
name|name
argument_list|)
expr_stmt|;
name|destr_fnlist
operator|->
name|fn_fieldlist
operator|.
name|fn_fields
operator|=
operator|(
expr|struct
name|fn_field
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|fn_field
argument_list|)
operator|*
name|has_destructor
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|destr_fnlist
operator|->
name|fn_fieldlist
operator|.
name|fn_fields
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|fn_field
argument_list|)
operator|*
name|has_destructor
argument_list|)
expr_stmt|;
name|tmp_sublist
operator|=
name|sublist
expr_stmt|;
name|last_sublist
operator|=
name|NULL
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|tmp_sublist
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|is_destructor_name
argument_list|(
name|tmp_sublist
operator|->
name|fn_field
operator|.
name|physname
argument_list|)
condition|)
block|{
name|tmp_sublist
operator|=
name|tmp_sublist
operator|->
name|next
expr_stmt|;
continue|continue;
block|}
name|destr_fnlist
operator|->
name|fn_fieldlist
operator|.
name|fn_fields
index|[
name|i
operator|++
index|]
operator|=
name|tmp_sublist
operator|->
name|fn_field
expr_stmt|;
if|if
condition|(
name|last_sublist
condition|)
name|last_sublist
operator|->
name|next
operator|=
name|tmp_sublist
operator|->
name|next
expr_stmt|;
else|else
name|sublist
operator|=
name|tmp_sublist
operator|->
name|next
expr_stmt|;
name|last_sublist
operator|=
name|tmp_sublist
expr_stmt|;
name|tmp_sublist
operator|=
name|tmp_sublist
operator|->
name|next
expr_stmt|;
block|}
name|destr_fnlist
operator|->
name|fn_fieldlist
operator|.
name|length
operator|=
name|has_destructor
expr_stmt|;
name|destr_fnlist
operator|->
name|next
operator|=
name|fip
operator|->
name|fnlist
expr_stmt|;
name|fip
operator|->
name|fnlist
operator|=
name|destr_fnlist
expr_stmt|;
name|nfn_fields
operator|++
expr_stmt|;
name|total_length
operator|+=
name|has_destructor
expr_stmt|;
name|length
operator|-=
name|has_destructor
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_v3
condition|)
block|{
comment|/* v3 mangling prevents the use of abbreviated physnames, 		 so we can do this here.  There are stubbed methods in v3 		 only: 		 - in -gstabs instead of -gstabs+ 		 - or for static methods, which are output as a function type 		   instead of a method type.  */
name|update_method_name_from_physname
argument_list|(
operator|&
name|new_fnlist
operator|->
name|fn_fieldlist
operator|.
name|name
argument_list|,
name|sublist
operator|->
name|fn_field
operator|.
name|physname
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|has_destructor
operator|&&
name|new_fnlist
operator|->
name|fn_fieldlist
operator|.
name|name
index|[
literal|0
index|]
operator|!=
literal|'~'
condition|)
block|{
name|new_fnlist
operator|->
name|fn_fieldlist
operator|.
name|name
operator|=
name|concat
argument_list|(
literal|"~"
argument_list|,
name|main_fn_name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|main_fn_name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|has_stub
condition|)
block|{
name|char
name|dem_opname
index|[
literal|256
index|]
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|cplus_demangle_opname
argument_list|(
name|new_fnlist
operator|->
name|fn_fieldlist
operator|.
name|name
argument_list|,
name|dem_opname
argument_list|,
name|DMGL_ANSI
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
name|ret
operator|=
name|cplus_demangle_opname
argument_list|(
name|new_fnlist
operator|->
name|fn_fieldlist
operator|.
name|name
argument_list|,
name|dem_opname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|new_fnlist
operator|->
name|fn_fieldlist
operator|.
name|name
operator|=
name|obsavestring
argument_list|(
name|dem_opname
argument_list|,
name|strlen
argument_list|(
name|dem_opname
argument_list|)
argument_list|,
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|)
expr_stmt|;
block|}
name|new_fnlist
operator|->
name|fn_fieldlist
operator|.
name|fn_fields
operator|=
operator|(
expr|struct
name|fn_field
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|fn_field
argument_list|)
operator|*
name|length
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|new_fnlist
operator|->
name|fn_fieldlist
operator|.
name|fn_fields
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|fn_field
argument_list|)
operator|*
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|length
init|;
operator|(
name|i
operator|--
operator|,
name|sublist
operator|)
condition|;
name|sublist
operator|=
name|sublist
operator|->
name|next
control|)
block|{
name|new_fnlist
operator|->
name|fn_fieldlist
operator|.
name|fn_fields
index|[
name|i
index|]
operator|=
name|sublist
operator|->
name|fn_field
expr_stmt|;
block|}
name|new_fnlist
operator|->
name|fn_fieldlist
operator|.
name|length
operator|=
name|length
expr_stmt|;
name|new_fnlist
operator|->
name|next
operator|=
name|fip
operator|->
name|fnlist
expr_stmt|;
name|fip
operator|->
name|fnlist
operator|=
name|new_fnlist
expr_stmt|;
name|nfn_fields
operator|++
expr_stmt|;
name|total_length
operator|+=
name|length
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nfn_fields
condition|)
block|{
name|ALLOCATE_CPLUS_STRUCT_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_FN_FIELDLISTS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
expr|struct
name|fn_fieldlist
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|type
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|fn_fieldlist
argument_list|)
operator|*
name|nfn_fields
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|TYPE_FN_FIELDLISTS
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|fn_fieldlist
argument_list|)
operator|*
name|nfn_fields
argument_list|)
expr_stmt|;
name|TYPE_NFN_FIELDS
argument_list|(
name|type
argument_list|)
operator|=
name|nfn_fields
expr_stmt|;
name|TYPE_NFN_FIELDS_TOTAL
argument_list|(
name|type
argument_list|)
operator|=
name|total_length
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Special GNU C++ name.     Returns 1 for success, 0 for failure.  "failure" means that we can't    keep parsing and it's time for error_type().  */
end_comment

begin_function
specifier|static
name|int
name|read_cpp_abbrev
parameter_list|(
name|struct
name|field_info
modifier|*
name|fip
parameter_list|,
name|char
modifier|*
modifier|*
name|pp
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|cpp_abbrev
decl_stmt|;
name|struct
name|type
modifier|*
name|context
decl_stmt|;
name|p
operator|=
operator|*
name|pp
expr_stmt|;
if|if
condition|(
operator|*
operator|++
name|p
operator|==
literal|'v'
condition|)
block|{
name|name
operator|=
name|NULL
expr_stmt|;
name|cpp_abbrev
operator|=
operator|*
operator|++
name|p
expr_stmt|;
operator|*
name|pp
operator|=
name|p
operator|+
literal|1
expr_stmt|;
comment|/* At this point, *pp points to something like "22:23=*22...",          where the type number before the ':' is the "context" and          everything after is a regular type definition.  Lookup the          type, find it's name, and construct the field name. */
name|context
operator|=
name|read_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cpp_abbrev
condition|)
block|{
case|case
literal|'f'
case|:
comment|/* $vf -- a virtual function table pointer */
name|name
operator|=
name|type_name_no_tag
argument_list|(
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
name|name
operator|=
literal|""
expr_stmt|;
block|}
name|fip
operator|->
name|list
operator|->
name|field
operator|.
name|name
operator|=
name|obconcat
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
name|vptr_name
argument_list|,
name|name
argument_list|,
literal|""
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
comment|/* $vb -- a virtual bsomethingorother */
name|name
operator|=
name|type_name_no_tag
argument_list|(
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"C++ abbreviated type name unknown at symtab pos %d"
argument_list|,
name|symnum
argument_list|)
expr_stmt|;
name|name
operator|=
literal|"FOO"
expr_stmt|;
block|}
name|fip
operator|->
name|list
operator|->
name|field
operator|.
name|name
operator|=
name|obconcat
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
name|vb_name
argument_list|,
name|name
argument_list|,
literal|""
argument_list|)
expr_stmt|;
break|break;
default|default:
name|invalid_cpp_abbrev_complaint
argument_list|(
operator|*
name|pp
argument_list|)
expr_stmt|;
name|fip
operator|->
name|list
operator|->
name|field
operator|.
name|name
operator|=
name|obconcat
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
literal|"INVALID_CPLUSPLUS_ABBREV"
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* At this point, *pp points to the ':'.  Skip it and read the          field type. */
name|p
operator|=
operator|++
operator|(
operator|*
name|pp
operator|)
expr_stmt|;
if|if
condition|(
name|p
index|[
operator|-
literal|1
index|]
operator|!=
literal|':'
condition|)
block|{
name|invalid_cpp_abbrev_complaint
argument_list|(
operator|*
name|pp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|fip
operator|->
name|list
operator|->
name|field
operator|.
name|type
operator|=
name|read_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|','
condition|)
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
comment|/* Skip the comma.  */
else|else
return|return
literal|0
return|;
block|{
name|int
name|nbits
decl_stmt|;
name|FIELD_BITPOS
argument_list|(
name|fip
operator|->
name|list
operator|->
name|field
argument_list|)
operator|=
name|read_huge_number
argument_list|(
name|pp
argument_list|,
literal|';'
argument_list|,
operator|&
name|nbits
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbits
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
block|}
comment|/* This field is unpacked.  */
name|FIELD_BITSIZE
argument_list|(
name|fip
operator|->
name|list
operator|->
name|field
argument_list|)
operator|=
literal|0
expr_stmt|;
name|fip
operator|->
name|list
operator|->
name|visibility
operator|=
name|VISIBILITY_PRIVATE
expr_stmt|;
block|}
else|else
block|{
name|invalid_cpp_abbrev_complaint
argument_list|(
operator|*
name|pp
argument_list|)
expr_stmt|;
comment|/* We have no idea what syntax an unrecognized abbrev would have, so          better return 0.  If we returned 1, we would need to at least advance          *pp to avoid an infinite loop.  */
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|read_one_struct_field
parameter_list|(
name|struct
name|field_info
modifier|*
name|fip
parameter_list|,
name|char
modifier|*
modifier|*
name|pp
parameter_list|,
name|char
modifier|*
name|p
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|fip
operator|->
name|list
operator|->
name|field
operator|.
name|name
operator|=
name|obsavestring
argument_list|(
operator|*
name|pp
argument_list|,
name|p
operator|-
operator|*
name|pp
argument_list|,
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|)
expr_stmt|;
operator|*
name|pp
operator|=
name|p
operator|+
literal|1
expr_stmt|;
comment|/* This means we have a visibility for a field coming. */
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|'/'
condition|)
block|{
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
name|fip
operator|->
name|list
operator|->
name|visibility
operator|=
operator|*
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* normal dbx-style format, no explicit visibility */
name|fip
operator|->
name|list
operator|->
name|visibility
operator|=
name|VISIBILITY_PUBLIC
expr_stmt|;
block|}
name|fip
operator|->
name|list
operator|->
name|field
operator|.
name|type
operator|=
name|read_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|':'
condition|)
block|{
name|p
operator|=
operator|++
operator|(
operator|*
name|pp
operator|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Possible future hook for nested types. */
block|if (**pp == '!') 	{ 	  fip->list->field.bitpos = (long) -2;
comment|/* nested type */
block|p = ++(*pp); 	}       else 	...;
endif|#
directive|endif
while|while
condition|(
operator|*
name|p
operator|!=
literal|';'
condition|)
block|{
name|p
operator|++
expr_stmt|;
block|}
comment|/* Static class member.  */
name|SET_FIELD_PHYSNAME
argument_list|(
name|fip
operator|->
name|list
operator|->
name|field
argument_list|,
name|savestring
argument_list|(
operator|*
name|pp
argument_list|,
name|p
operator|-
operator|*
name|pp
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|pp
operator|=
name|p
operator|+
literal|1
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|','
condition|)
block|{
comment|/* Bad structure-type format.  */
name|stabs_general_complaint
argument_list|(
literal|"bad structure-type format"
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
comment|/* Skip the comma.  */
block|{
name|int
name|nbits
decl_stmt|;
name|FIELD_BITPOS
argument_list|(
name|fip
operator|->
name|list
operator|->
name|field
argument_list|)
operator|=
name|read_huge_number
argument_list|(
name|pp
argument_list|,
literal|','
argument_list|,
operator|&
name|nbits
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbits
operator|!=
literal|0
condition|)
block|{
name|stabs_general_complaint
argument_list|(
literal|"bad structure-type format"
argument_list|)
expr_stmt|;
return|return;
block|}
name|FIELD_BITSIZE
argument_list|(
name|fip
operator|->
name|list
operator|->
name|field
argument_list|)
operator|=
name|read_huge_number
argument_list|(
name|pp
argument_list|,
literal|';'
argument_list|,
operator|&
name|nbits
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbits
operator|!=
literal|0
condition|)
block|{
name|stabs_general_complaint
argument_list|(
literal|"bad structure-type format"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|FIELD_BITPOS
argument_list|(
name|fip
operator|->
name|list
operator|->
name|field
argument_list|)
operator|==
literal|0
operator|&&
name|FIELD_BITSIZE
argument_list|(
name|fip
operator|->
name|list
operator|->
name|field
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* This can happen in two cases: (1) at least for gcc 2.4.5 or so,          it is a field which has been optimized out.  The correct stab for          this case is to use VISIBILITY_IGNORE, but that is a recent          invention.  (2) It is a 0-size array.  For example          union { int num; char str[0]; } foo.  Printing "<no value>" for          str in "p foo" is OK, since foo.str (and thus foo.str[3])          will continue to work, and a 0-size array as a whole doesn't          have any contents to print.           I suspect this probably could also happen with gcc -gstabs (not          -gstabs+) for static fields, and perhaps other C++ extensions.          Hopefully few people use -gstabs with gdb, since it is intended          for dbx compatibility.  */
comment|/* Ignore this field.  */
name|fip
operator|->
name|list
operator|->
name|visibility
operator|=
name|VISIBILITY_IGNORE
expr_stmt|;
block|}
else|else
block|{
comment|/* Detect an unpacked field and mark it as such.          dbx gives a bit size for all fields.          Note that forward refs cannot be packed,          and treat enums as if they had the width of ints.  */
name|struct
name|type
modifier|*
name|field_type
init|=
name|check_typedef
argument_list|(
name|FIELD_TYPE
argument_list|(
name|fip
operator|->
name|list
operator|->
name|field
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|field_type
argument_list|)
operator|!=
name|TYPE_CODE_INT
operator|&&
name|TYPE_CODE
argument_list|(
name|field_type
argument_list|)
operator|!=
name|TYPE_CODE_RANGE
operator|&&
name|TYPE_CODE
argument_list|(
name|field_type
argument_list|)
operator|!=
name|TYPE_CODE_BOOL
operator|&&
name|TYPE_CODE
argument_list|(
name|field_type
argument_list|)
operator|!=
name|TYPE_CODE_ENUM
condition|)
block|{
name|FIELD_BITSIZE
argument_list|(
name|fip
operator|->
name|list
operator|->
name|field
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|FIELD_BITSIZE
argument_list|(
name|fip
operator|->
name|list
operator|->
name|field
argument_list|)
operator|==
name|TARGET_CHAR_BIT
operator|*
name|TYPE_LENGTH
argument_list|(
name|field_type
argument_list|)
operator|||
operator|(
name|TYPE_CODE
argument_list|(
name|field_type
argument_list|)
operator|==
name|TYPE_CODE_ENUM
operator|&&
name|FIELD_BITSIZE
argument_list|(
name|fip
operator|->
name|list
operator|->
name|field
argument_list|)
operator|==
name|TARGET_INT_BIT
operator|)
operator|)
operator|&&
name|FIELD_BITPOS
argument_list|(
name|fip
operator|->
name|list
operator|->
name|field
argument_list|)
operator|%
literal|8
operator|==
literal|0
condition|)
block|{
name|FIELD_BITSIZE
argument_list|(
name|fip
operator|->
name|list
operator|->
name|field
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Read struct or class data fields.  They have the form:     NAME : [VISIBILITY] TYPENUM , BITPOS , BITSIZE ;     At the end, we see a semicolon instead of a field.     In C++, this may wind up being NAME:?TYPENUM:PHYSNAME; for    a static field.     The optional VISIBILITY is one of:     '/0' (VISIBILITY_PRIVATE)    '/1' (VISIBILITY_PROTECTED)    '/2' (VISIBILITY_PUBLIC)    '/9' (VISIBILITY_IGNORE)     or nothing, for C style fields with public visibility.     Returns 1 for success, 0 for failure.  */
end_comment

begin_function
specifier|static
name|int
name|read_struct_fields
parameter_list|(
name|struct
name|field_info
modifier|*
name|fip
parameter_list|,
name|char
modifier|*
modifier|*
name|pp
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|struct
name|nextfield
modifier|*
name|new
decl_stmt|;
comment|/* We better set p right now, in case there are no fields at all...    */
name|p
operator|=
operator|*
name|pp
expr_stmt|;
comment|/* Read each data member type until we find the terminating ';' at the end of      the data member list, or break for some other reason such as finding the      start of the member function list. */
comment|/* Stab string for structure/union does not end with two ';' in      SUN C compiler 5.3 i.e. F6U2, hence check for end of string. */
while|while
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|';'
operator|&&
operator|*
operator|*
name|pp
operator|!=
literal|'\0'
condition|)
block|{
name|STABS_CONTINUE
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* Get space to record the next field's data.  */
name|new
operator|=
operator|(
expr|struct
name|nextfield
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nextfield
argument_list|)
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|new
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nextfield
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|fip
operator|->
name|list
expr_stmt|;
name|fip
operator|->
name|list
operator|=
name|new
expr_stmt|;
comment|/* Get the field name.  */
name|p
operator|=
operator|*
name|pp
expr_stmt|;
comment|/* If is starts with CPLUS_MARKER it is a special abbreviation,          unless the CPLUS_MARKER is followed by an underscore, in          which case it is just the name of an anonymous type, which we          should handle like any other type name.  */
if|if
condition|(
name|is_cplus_marker
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
operator|&&
name|p
index|[
literal|1
index|]
operator|!=
literal|'_'
condition|)
block|{
if|if
condition|(
operator|!
name|read_cpp_abbrev
argument_list|(
name|fip
argument_list|,
name|pp
argument_list|,
name|type
argument_list|,
name|objfile
argument_list|)
condition|)
return|return
literal|0
return|;
continue|continue;
block|}
comment|/* Look for the ':' that separates the field name from the field          values.  Data members are delimited by a single ':', while member          functions are delimited by a pair of ':'s.  When we hit the member          functions (if any), terminate scan loop and return. */
while|while
condition|(
operator|*
name|p
operator|!=
literal|':'
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
return|return
literal|0
return|;
comment|/* Check to see if we have hit the member functions yet.  */
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
block|{
break|break;
block|}
name|read_one_struct_field
argument_list|(
name|fip
argument_list|,
name|pp
argument_list|,
name|p
argument_list|,
name|type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|':'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
block|{
comment|/* (the deleted) chill the list of fields: the last entry (at          the head) is a partially constructed entry which we now          scrub. */
name|fip
operator|->
name|list
operator|=
name|fip
operator|->
name|list
operator|->
name|next
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* *INDENT-OFF* */
end_comment

begin_comment
comment|/* The stabs for C++ derived classes contain baseclass information which    is marked by a '!' character after the total size.  This function is    called when we encounter the baseclass marker, and slurps up all the    baseclass information.     Immediately following the '!' marker is the number of base classes that    the class is derived from, followed by information for each base class.    For each base class, there are two visibility specifiers, a bit offset    to the base class information within the derived class, a reference to    the type for the base class, and a terminating semicolon.     A typical example, with two base classes, would be "!2,020,19;0264,21;".    						       ^^ ^ ^ ^  ^ ^  ^ 	Baseclass information marker __________________|| | | |  | |  | 	Number of baseclasses __________________________| | | |  | |  | 	Visibility specifiers (2) ________________________| | |  | |  | 	Offset in bits from start of class _________________| |  | |  | 	Type number for base class ___________________________|  | |  | 	Visibility specifiers (2) _______________________________| |  | 	Offset in bits from start of class ________________________|  | 	Type number of base class ____________________________________|    Return 1 for success, 0 for (error-type-inducing) failure.  */
end_comment

begin_comment
comment|/* *INDENT-ON* */
end_comment

begin_function
specifier|static
name|int
name|read_baseclasses
parameter_list|(
name|struct
name|field_info
modifier|*
name|fip
parameter_list|,
name|char
modifier|*
modifier|*
name|pp
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|nextfield
modifier|*
name|new
decl_stmt|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|'!'
condition|)
block|{
return|return
literal|1
return|;
block|}
else|else
block|{
comment|/* Skip the '!' baseclass information marker. */
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
block|}
name|ALLOCATE_CPLUS_STRUCT_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|{
name|int
name|nbits
decl_stmt|;
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
operator|=
name|read_huge_number
argument_list|(
name|pp
argument_list|,
literal|','
argument_list|,
operator|&
name|nbits
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbits
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
block|}
if|#
directive|if
literal|0
comment|/* Some stupid compilers have trouble with the following, so break      it up into simpler expressions.  */
block|TYPE_FIELD_VIRTUAL_BITS (type) = (B_TYPE *)     TYPE_ALLOC (type, B_BYTES (TYPE_N_BASECLASSES (type)));
else|#
directive|else
block|{
name|int
name|num_bytes
init|=
name|B_BYTES
argument_list|(
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
name|char
modifier|*
name|pointer
decl_stmt|;
name|pointer
operator|=
operator|(
name|char
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|type
argument_list|,
name|num_bytes
argument_list|)
expr_stmt|;
name|TYPE_FIELD_VIRTUAL_BITS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
name|B_TYPE
operator|*
operator|)
name|pointer
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 0 */
name|B_CLRALL
argument_list|(
name|TYPE_FIELD_VIRTUAL_BITS
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|new
operator|=
operator|(
expr|struct
name|nextfield
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nextfield
argument_list|)
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|new
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nextfield
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|fip
operator|->
name|list
expr_stmt|;
name|fip
operator|->
name|list
operator|=
name|new
expr_stmt|;
name|FIELD_BITSIZE
argument_list|(
name|new
operator|->
name|field
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* this should be an unpacked field! */
name|STABS_CONTINUE
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
operator|*
name|pp
condition|)
block|{
case|case
literal|'0'
case|:
comment|/* Nothing to do. */
break|break;
case|case
literal|'1'
case|:
name|SET_TYPE_FIELD_VIRTUAL
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Unknown character.  Complain and treat it as non-virtual.  */
block|{
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"Unknown virtual character `%c' for baseclass"
argument_list|,
operator|*
operator|*
name|pp
argument_list|)
expr_stmt|;
block|}
block|}
operator|++
operator|(
operator|*
name|pp
operator|)
expr_stmt|;
name|new
operator|->
name|visibility
operator|=
operator|*
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
switch|switch
condition|(
name|new
operator|->
name|visibility
condition|)
block|{
case|case
name|VISIBILITY_PRIVATE
case|:
case|case
name|VISIBILITY_PROTECTED
case|:
case|case
name|VISIBILITY_PUBLIC
case|:
break|break;
default|default:
comment|/* Bad visibility format.  Complain and treat it as 	     public.  */
block|{
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"Unknown visibility `%c' for baseclass"
argument_list|,
name|new
operator|->
name|visibility
argument_list|)
expr_stmt|;
name|new
operator|->
name|visibility
operator|=
name|VISIBILITY_PUBLIC
expr_stmt|;
block|}
block|}
block|{
name|int
name|nbits
decl_stmt|;
comment|/* The remaining value is the bit offset of the portion of the object 	   corresponding to this baseclass.  Always zero in the absence of 	   multiple inheritance.  */
name|FIELD_BITPOS
argument_list|(
name|new
operator|->
name|field
argument_list|)
operator|=
name|read_huge_number
argument_list|(
name|pp
argument_list|,
literal|','
argument_list|,
operator|&
name|nbits
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbits
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
block|}
comment|/* The last piece of baseclass information is the type of the          base class.  Read it, and remember it's type name as this          field's name. */
name|new
operator|->
name|field
operator|.
name|type
operator|=
name|read_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|new
operator|->
name|field
operator|.
name|name
operator|=
name|type_name_no_tag
argument_list|(
name|new
operator|->
name|field
operator|.
name|type
argument_list|)
expr_stmt|;
comment|/* skip trailing ';' and bump count of number of fields seen */
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|';'
condition|)
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
else|else
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* The tail end of stabs for C++ classes that contain a virtual function    pointer contains a tilde, a %, and a type number.    The type number refers to the base class (possibly this class itself) which    contains the vtable pointer for the current class.     This function is called when we have parsed all the method declarations,    so we can look for the vptr base class info.  */
end_comment

begin_function
specifier|static
name|int
name|read_tilde_fields
parameter_list|(
name|struct
name|field_info
modifier|*
name|fip
parameter_list|,
name|char
modifier|*
modifier|*
name|pp
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|STABS_CONTINUE
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* If we are positioned at a ';', then skip it. */
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|';'
condition|)
block|{
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|'~'
condition|)
block|{
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|'='
operator|||
operator|*
operator|*
name|pp
operator|==
literal|'+'
operator|||
operator|*
operator|*
name|pp
operator|==
literal|'-'
condition|)
block|{
comment|/* Obsolete flags that used to indicate the presence 	     of constructors and/or destructors. */
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
block|}
comment|/* Read either a '%' or the final ';'.  */
if|if
condition|(
operator|*
operator|(
operator|*
name|pp
operator|)
operator|++
operator|==
literal|'%'
condition|)
block|{
comment|/* The next number is the type number of the base class 	     (possibly our own class) which supplies the vtable for 	     this class.  Parse it out, and search that class to find 	     its vtable pointer, and install those into TYPE_VPTR_BASETYPE 	     and TYPE_VPTR_FIELDNO.  */
name|struct
name|type
modifier|*
name|t
decl_stmt|;
name|int
name|i
decl_stmt|;
name|t
operator|=
name|read_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|*
name|p
operator|!=
literal|';'
condition|)
block|{
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
comment|/* Premature end of symbol.  */
return|return
literal|0
return|;
block|}
name|TYPE_VPTR_BASETYPE
argument_list|(
name|type
argument_list|)
operator|=
name|t
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|t
condition|)
comment|/* Our own class provides vtbl ptr */
block|{
for|for
control|(
name|i
operator|=
name|TYPE_NFIELDS
argument_list|(
name|t
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
name|TYPE_N_BASECLASSES
argument_list|(
name|t
argument_list|)
condition|;
operator|--
name|i
control|)
block|{
name|char
modifier|*
name|name
init|=
name|TYPE_FIELD_NAME
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|name
argument_list|,
name|vptr_name
argument_list|,
sizeof|sizeof
argument_list|(
name|vptr_name
argument_list|)
operator|-
literal|2
argument_list|)
operator|&&
name|is_cplus_marker
argument_list|(
name|name
index|[
sizeof|sizeof
argument_list|(
name|vptr_name
argument_list|)
operator|-
literal|2
index|]
argument_list|)
condition|)
block|{
name|TYPE_VPTR_FIELDNO
argument_list|(
name|type
argument_list|)
operator|=
name|i
expr_stmt|;
goto|goto
name|gotit
goto|;
block|}
block|}
comment|/* Virtual function table field not found.  */
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"virtual function table pointer not found when defining class `%s'"
argument_list|,
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|TYPE_VPTR_FIELDNO
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_VPTR_FIELDNO
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
name|gotit
label|:
operator|*
name|pp
operator|=
name|p
operator|+
literal|1
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|attach_fn_fields_to_type
parameter_list|(
name|struct
name|field_info
modifier|*
name|fip
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
name|TYPE_NFN_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|fip
operator|->
name|fnlist
operator|!=
name|NULL
condition|;
name|fip
operator|->
name|fnlist
operator|=
name|fip
operator|->
name|fnlist
operator|->
name|next
control|)
block|{
operator|--
name|n
expr_stmt|;
comment|/* Circumvent Sun3 compiler bug */
name|TYPE_FN_FIELDLISTS
argument_list|(
name|type
argument_list|)
index|[
name|n
index|]
operator|=
name|fip
operator|->
name|fnlist
operator|->
name|fn_fieldlist
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Create the vector of fields, and record how big it is.    We need this info to record proper virtual function table information    for this class's virtual functions.  */
end_comment

begin_function
specifier|static
name|int
name|attach_fields_to_type
parameter_list|(
name|struct
name|field_info
modifier|*
name|fip
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|int
name|nfields
init|=
literal|0
decl_stmt|;
name|int
name|non_public_fields
init|=
literal|0
decl_stmt|;
name|struct
name|nextfield
modifier|*
name|scan
decl_stmt|;
comment|/* Count up the number of fields that we have, as well as taking note of      whether or not there are any non-public fields, which requires us to      allocate and build the private_field_bits and protected_field_bits      bitfields. */
for|for
control|(
name|scan
operator|=
name|fip
operator|->
name|list
init|;
name|scan
operator|!=
name|NULL
condition|;
name|scan
operator|=
name|scan
operator|->
name|next
control|)
block|{
name|nfields
operator|++
expr_stmt|;
if|if
condition|(
name|scan
operator|->
name|visibility
operator|!=
name|VISIBILITY_PUBLIC
condition|)
block|{
name|non_public_fields
operator|++
expr_stmt|;
block|}
block|}
comment|/* Now we know how many fields there are, and whether or not there are any      non-public fields.  Record the field count, allocate space for the      array of fields, and create blank visibility bitfields if necessary. */
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|=
name|nfields
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
expr|struct
name|field
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|type
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
operator|*
name|nfields
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
operator|*
name|nfields
argument_list|)
expr_stmt|;
if|if
condition|(
name|non_public_fields
condition|)
block|{
name|ALLOCATE_CPLUS_STRUCT_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_FIELD_PRIVATE_BITS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
name|B_TYPE
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|type
argument_list|,
name|B_BYTES
argument_list|(
name|nfields
argument_list|)
argument_list|)
expr_stmt|;
name|B_CLRALL
argument_list|(
name|TYPE_FIELD_PRIVATE_BITS
argument_list|(
name|type
argument_list|)
argument_list|,
name|nfields
argument_list|)
expr_stmt|;
name|TYPE_FIELD_PROTECTED_BITS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
name|B_TYPE
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|type
argument_list|,
name|B_BYTES
argument_list|(
name|nfields
argument_list|)
argument_list|)
expr_stmt|;
name|B_CLRALL
argument_list|(
name|TYPE_FIELD_PROTECTED_BITS
argument_list|(
name|type
argument_list|)
argument_list|,
name|nfields
argument_list|)
expr_stmt|;
name|TYPE_FIELD_IGNORE_BITS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
name|B_TYPE
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|type
argument_list|,
name|B_BYTES
argument_list|(
name|nfields
argument_list|)
argument_list|)
expr_stmt|;
name|B_CLRALL
argument_list|(
name|TYPE_FIELD_IGNORE_BITS
argument_list|(
name|type
argument_list|)
argument_list|,
name|nfields
argument_list|)
expr_stmt|;
block|}
comment|/* Copy the saved-up fields into the field vector.  Start from the head      of the list, adding to the tail of the field array, so that they end      up in the same order in the array in which they were added to the list. */
while|while
condition|(
name|nfields
operator|--
operator|>
literal|0
condition|)
block|{
name|TYPE_FIELD
argument_list|(
name|type
argument_list|,
name|nfields
argument_list|)
operator|=
name|fip
operator|->
name|list
operator|->
name|field
expr_stmt|;
switch|switch
condition|(
name|fip
operator|->
name|list
operator|->
name|visibility
condition|)
block|{
case|case
name|VISIBILITY_PRIVATE
case|:
name|SET_TYPE_FIELD_PRIVATE
argument_list|(
name|type
argument_list|,
name|nfields
argument_list|)
expr_stmt|;
break|break;
case|case
name|VISIBILITY_PROTECTED
case|:
name|SET_TYPE_FIELD_PROTECTED
argument_list|(
name|type
argument_list|,
name|nfields
argument_list|)
expr_stmt|;
break|break;
case|case
name|VISIBILITY_IGNORE
case|:
name|SET_TYPE_FIELD_IGNORE
argument_list|(
name|type
argument_list|,
name|nfields
argument_list|)
expr_stmt|;
break|break;
case|case
name|VISIBILITY_PUBLIC
case|:
break|break;
default|default:
comment|/* Unknown visibility.  Complain and treat it as public.  */
block|{
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"Unknown visibility `%c' for field"
argument_list|,
name|fip
operator|->
name|list
operator|->
name|visibility
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|fip
operator|->
name|list
operator|=
name|fip
operator|->
name|list
operator|->
name|next
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Complain that the compiler has emitted more than one definition for the    structure type TYPE.  */
end_comment

begin_function
specifier|static
name|void
name|complain_about_struct_wipeout
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
name|char
modifier|*
name|name
init|=
literal|""
decl_stmt|;
name|char
modifier|*
name|kind
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|name
operator|=
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_STRUCT
case|:
name|kind
operator|=
literal|"struct "
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_UNION
case|:
name|kind
operator|=
literal|"union "
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_ENUM
case|:
name|kind
operator|=
literal|"enum "
expr_stmt|;
break|break;
default|default:
name|kind
operator|=
literal|""
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|name
operator|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|kind
operator|=
literal|""
expr_stmt|;
block|}
else|else
block|{
name|name
operator|=
literal|"<unknown>"
expr_stmt|;
name|kind
operator|=
literal|""
expr_stmt|;
block|}
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"struct/union type gets multiply defined: %s%s"
argument_list|,
name|kind
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read the description of a structure (or union type) and return an object    describing the type.     PP points to a character pointer that points to the next unconsumed token    in the the stabs string.  For example, given stabs "A:T4=s4a:1,0,32;;",    *PP will point to "4a:1,0,32;;".     TYPE points to an incomplete type that needs to be filled in.     OBJFILE points to the current objfile from which the stabs information is    being read.  (Note that it is redundant in that TYPE also contains a pointer    to this same objfile, so it might be a good idea to eliminate it.  FIXME).   */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|read_struct_type
parameter_list|(
name|char
modifier|*
modifier|*
name|pp
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|enum
name|type_code
name|type_code
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|struct
name|cleanup
modifier|*
name|back_to
decl_stmt|;
name|struct
name|field_info
name|fi
decl_stmt|;
name|fi
operator|.
name|list
operator|=
name|NULL
expr_stmt|;
name|fi
operator|.
name|fnlist
operator|=
name|NULL
expr_stmt|;
comment|/* When describing struct/union/class types in stabs, G++ always drops      all qualifications from the name.  So if you've got:        struct A { ... struct B { ... }; ... };      then G++ will emit stabs for `struct A::B' that call it simply      `struct B'.  Obviously, if you've got a real top-level definition for      `struct B', or other nested definitions, this is going to cause      problems.       Obviously, GDB can't fix this by itself, but it can at least avoid      scribbling on existing structure type objects when new definitions      appear.  */
if|if
condition|(
operator|!
operator|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_UNDEF
operator|||
name|TYPE_STUB
argument_list|(
name|type
argument_list|)
operator|)
condition|)
block|{
name|complain_about_struct_wipeout
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* It's probably best to return the type unchanged.  */
return|return
name|type
return|;
block|}
name|back_to
operator|=
name|make_cleanup
argument_list|(
name|null_cleanup
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|INIT_CPLUS_SPECIFIC
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|type_code
expr_stmt|;
name|TYPE_FLAGS
argument_list|(
name|type
argument_list|)
operator|&=
operator|~
name|TYPE_FLAG_STUB
expr_stmt|;
comment|/* First comes the total size in bytes.  */
block|{
name|int
name|nbits
decl_stmt|;
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
name|read_huge_number
argument_list|(
name|pp
argument_list|,
literal|0
argument_list|,
operator|&
name|nbits
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbits
operator|!=
literal|0
condition|)
return|return
name|error_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
return|;
block|}
comment|/* Now read the baseclasses, if any, read the regular C struct or C++      class member fields, attach the fields to the type, read the C++      member functions, attach them to the type, and then read any tilde      field (baseclass specifier for the class holding the main vtable). */
if|if
condition|(
operator|!
name|read_baseclasses
argument_list|(
operator|&
name|fi
argument_list|,
name|pp
argument_list|,
name|type
argument_list|,
name|objfile
argument_list|)
operator|||
operator|!
name|read_struct_fields
argument_list|(
operator|&
name|fi
argument_list|,
name|pp
argument_list|,
name|type
argument_list|,
name|objfile
argument_list|)
operator|||
operator|!
name|attach_fields_to_type
argument_list|(
operator|&
name|fi
argument_list|,
name|type
argument_list|,
name|objfile
argument_list|)
operator|||
operator|!
name|read_member_functions
argument_list|(
operator|&
name|fi
argument_list|,
name|pp
argument_list|,
name|type
argument_list|,
name|objfile
argument_list|)
operator|||
operator|!
name|attach_fn_fields_to_type
argument_list|(
operator|&
name|fi
argument_list|,
name|type
argument_list|)
operator|||
operator|!
name|read_tilde_fields
argument_list|(
operator|&
name|fi
argument_list|,
name|pp
argument_list|,
name|type
argument_list|,
name|objfile
argument_list|)
condition|)
block|{
name|type
operator|=
name|error_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
name|do_cleanups
argument_list|(
name|back_to
argument_list|)
expr_stmt|;
return|return
operator|(
name|type
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Read a definition of an array type,    and create and return a suitable type object.    Also creates a range type which represents the bounds of that    array.  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|read_array_type
parameter_list|(
name|char
modifier|*
modifier|*
name|pp
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|index_type
decl_stmt|,
modifier|*
name|element_type
decl_stmt|,
modifier|*
name|range_type
decl_stmt|;
name|int
name|lower
decl_stmt|,
name|upper
decl_stmt|;
name|int
name|adjustable
init|=
literal|0
decl_stmt|;
name|int
name|nbits
decl_stmt|;
comment|/* Format of an array type:      "ar<index type>;lower;upper;<array_contents_type>".      OS9000: "arlower,upper;<array_contents_type>".       Fortran adjustable arrays use Adigits or Tdigits for lower or upper;      for these, produce a type like float[][].  */
block|{
name|index_type
operator|=
name|read_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|';'
condition|)
comment|/* Improper format of array type decl.  */
return|return
name|error_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
return|;
operator|++
operator|*
name|pp
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
operator|*
operator|*
name|pp
operator|>=
literal|'0'
operator|&&
operator|*
operator|*
name|pp
operator|<=
literal|'9'
operator|)
operator|&&
operator|*
operator|*
name|pp
operator|!=
literal|'-'
condition|)
block|{
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
name|adjustable
operator|=
literal|1
expr_stmt|;
block|}
name|lower
operator|=
name|read_huge_number
argument_list|(
name|pp
argument_list|,
literal|';'
argument_list|,
operator|&
name|nbits
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbits
operator|!=
literal|0
condition|)
return|return
name|error_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
return|;
if|if
condition|(
operator|!
operator|(
operator|*
operator|*
name|pp
operator|>=
literal|'0'
operator|&&
operator|*
operator|*
name|pp
operator|<=
literal|'9'
operator|)
operator|&&
operator|*
operator|*
name|pp
operator|!=
literal|'-'
condition|)
block|{
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
name|adjustable
operator|=
literal|1
expr_stmt|;
block|}
name|upper
operator|=
name|read_huge_number
argument_list|(
name|pp
argument_list|,
literal|';'
argument_list|,
operator|&
name|nbits
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbits
operator|!=
literal|0
condition|)
return|return
name|error_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
return|;
name|element_type
operator|=
name|read_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|adjustable
condition|)
block|{
name|lower
operator|=
literal|0
expr_stmt|;
name|upper
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|range_type
operator|=
name|create_range_type
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|)
name|NULL
argument_list|,
name|index_type
argument_list|,
name|lower
argument_list|,
name|upper
argument_list|)
expr_stmt|;
name|type
operator|=
name|create_array_type
argument_list|(
name|type
argument_list|,
name|element_type
argument_list|,
name|range_type
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Read a definition of an enumeration type,    and create and return a suitable type object.    Also defines the symbols that represent the values of the type.  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|read_enum_type
parameter_list|(
name|char
modifier|*
modifier|*
name|pp
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|long
name|n
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|int
name|nsyms
init|=
literal|0
decl_stmt|;
name|struct
name|pending
modifier|*
modifier|*
name|symlist
decl_stmt|;
name|struct
name|pending
modifier|*
name|osyms
decl_stmt|,
modifier|*
name|syms
decl_stmt|;
name|int
name|o_nsyms
decl_stmt|;
name|int
name|nbits
decl_stmt|;
name|int
name|unsigned_enum
init|=
literal|1
decl_stmt|;
if|#
directive|if
literal|0
comment|/* FIXME!  The stabs produced by Sun CC merrily define things that ought      to be file-scope, between N_FN entries, using N_LSYM.  What's a mother      to do?  For now, force all enum values to file scope.  */
block|if (within_function)     symlist =&local_symbols;   else
endif|#
directive|endif
name|symlist
operator|=
operator|&
name|file_symbols
expr_stmt|;
name|osyms
operator|=
operator|*
name|symlist
expr_stmt|;
name|o_nsyms
operator|=
name|osyms
condition|?
name|osyms
operator|->
name|nsyms
else|:
literal|0
expr_stmt|;
comment|/* The aix4 compiler emits an extra field before the enum members;      my guess is it's a type of some sort.  Just ignore it.  */
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|'-'
condition|)
block|{
comment|/* Skip over the type.  */
while|while
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|':'
condition|)
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
comment|/* Skip over the colon.  */
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
block|}
comment|/* Read the value-names and their values.      The input syntax is NAME:VALUE,NAME:VALUE, and so on.      A semicolon or comma instead of a NAME means the end.  */
while|while
condition|(
operator|*
operator|*
name|pp
operator|&&
operator|*
operator|*
name|pp
operator|!=
literal|';'
operator|&&
operator|*
operator|*
name|pp
operator|!=
literal|','
condition|)
block|{
name|STABS_CONTINUE
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|p
operator|=
operator|*
name|pp
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|':'
condition|)
name|p
operator|++
expr_stmt|;
name|name
operator|=
name|obsavestring
argument_list|(
operator|*
name|pp
argument_list|,
name|p
operator|-
operator|*
name|pp
argument_list|,
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|)
expr_stmt|;
operator|*
name|pp
operator|=
name|p
operator|+
literal|1
expr_stmt|;
name|n
operator|=
name|read_huge_number
argument_list|(
name|pp
argument_list|,
literal|','
argument_list|,
operator|&
name|nbits
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbits
operator|!=
literal|0
condition|)
return|return
name|error_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
return|;
name|sym
operator|=
operator|(
expr|struct
name|symbol
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|sym
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|=
name|name
expr_stmt|;
name|SYMBOL_LANGUAGE
argument_list|(
name|sym
argument_list|)
operator|=
name|current_subfile
operator|->
name|language
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_CONST
expr_stmt|;
name|SYMBOL_DOMAIN
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_DOMAIN
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|n
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
name|unsigned_enum
operator|=
literal|0
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
name|symlist
argument_list|)
expr_stmt|;
name|nsyms
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|';'
condition|)
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
comment|/* Skip the semicolon.  */
comment|/* Now fill in the fields of the type-structure.  */
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
name|TARGET_INT_BIT
operator|/
name|HOST_CHAR_BIT
expr_stmt|;
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_CODE_ENUM
expr_stmt|;
name|TYPE_FLAGS
argument_list|(
name|type
argument_list|)
operator|&=
operator|~
name|TYPE_FLAG_STUB
expr_stmt|;
if|if
condition|(
name|unsigned_enum
condition|)
name|TYPE_FLAGS
argument_list|(
name|type
argument_list|)
operator||=
name|TYPE_FLAG_UNSIGNED
expr_stmt|;
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|=
name|nsyms
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
expr|struct
name|field
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|type
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
operator|*
name|nsyms
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
operator|*
name|nsyms
argument_list|)
expr_stmt|;
comment|/* Find the symbols for the values and put them into the type.      The symbols can be found in the symlist that we put them on      to cause them to be defined.  osyms contains the old value      of that symlist; everything up to there was defined by us.  */
comment|/* Note that we preserve the order of the enum constants, so      that in something like "enum {FOO, LAST_THING=FOO}" we print      FOO, not LAST_THING.  */
for|for
control|(
name|syms
operator|=
operator|*
name|symlist
operator|,
name|n
operator|=
name|nsyms
operator|-
literal|1
init|;
name|syms
condition|;
name|syms
operator|=
name|syms
operator|->
name|next
control|)
block|{
name|int
name|last
init|=
name|syms
operator|==
name|osyms
condition|?
name|o_nsyms
else|:
literal|0
decl_stmt|;
name|int
name|j
init|=
name|syms
operator|->
name|nsyms
decl_stmt|;
for|for
control|(
init|;
operator|--
name|j
operator|>=
name|last
condition|;
operator|--
name|n
control|)
block|{
name|struct
name|symbol
modifier|*
name|xsym
init|=
name|syms
operator|->
name|symbol
index|[
name|j
index|]
decl_stmt|;
name|SYMBOL_TYPE
argument_list|(
name|xsym
argument_list|)
operator|=
name|type
expr_stmt|;
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|n
argument_list|)
operator|=
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|xsym
argument_list|)
expr_stmt|;
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|n
argument_list|)
operator|=
name|SYMBOL_VALUE
argument_list|(
name|xsym
argument_list|)
expr_stmt|;
name|TYPE_FIELD_BITSIZE
argument_list|(
name|type
argument_list|,
name|n
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|syms
operator|==
name|osyms
condition|)
break|break;
block|}
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Sun's ACC uses a somewhat saner method for specifying the builtin    typedefs in every file (for int, long, etc):     type = b<signed><width><format type>;<offset>;<nbits>    signed = u or s.    optional format type = c or b for char or boolean.    offset = offset from high order bit to start bit of type.    width is # bytes in object of this type, nbits is # bits in type.     The width/offset stuff appears to be for small objects stored in    larger ones (e.g. `shorts' in `int' registers).  We ignore it for now,    FIXME.  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|read_sun_builtin_type
parameter_list|(
name|char
modifier|*
modifier|*
name|pp
parameter_list|,
name|int
name|typenums
index|[
literal|2
index|]
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|int
name|type_bits
decl_stmt|;
name|int
name|nbits
decl_stmt|;
name|int
name|signed_type
decl_stmt|;
name|enum
name|type_code
name|code
init|=
name|TYPE_CODE_INT
decl_stmt|;
switch|switch
condition|(
operator|*
operator|*
name|pp
condition|)
block|{
case|case
literal|'s'
case|:
name|signed_type
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|signed_type
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
return|return
name|error_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
return|;
block|}
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
comment|/* For some odd reason, all forms of char put a c here.  This is strange      because no other type has this honor.  We can safely ignore this because      we actually determine 'char'acterness by the number of bits specified in      the descriptor.      Boolean forms, e.g Fortran logical*X, put a b here.  */
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|'c'
condition|)
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|'b'
condition|)
block|{
name|code
operator|=
name|TYPE_CODE_BOOL
expr_stmt|;
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
block|}
comment|/* The first number appears to be the number of bytes occupied      by this type, except that unsigned short is 4 instead of 2.      Since this information is redundant with the third number,      we will ignore it.  */
name|read_huge_number
argument_list|(
name|pp
argument_list|,
literal|';'
argument_list|,
operator|&
name|nbits
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbits
operator|!=
literal|0
condition|)
return|return
name|error_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
return|;
comment|/* The second number is always 0, so ignore it too. */
name|read_huge_number
argument_list|(
name|pp
argument_list|,
literal|';'
argument_list|,
operator|&
name|nbits
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbits
operator|!=
literal|0
condition|)
return|return
name|error_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
return|;
comment|/* The third number is the number of bits for this type. */
name|type_bits
operator|=
name|read_huge_number
argument_list|(
name|pp
argument_list|,
literal|0
argument_list|,
operator|&
name|nbits
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbits
operator|!=
literal|0
condition|)
return|return
name|error_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
return|;
comment|/* The type *should* end with a semicolon.  If it are embedded      in a larger type the semicolon may be the only way to know where      the type ends.  If this type is at the end of the stabstring we      can deal with the omitted semicolon (but we don't have to like      it).  Don't bother to complain(), Sun's compiler omits the semicolon      for "void".  */
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|';'
condition|)
operator|++
operator|(
operator|*
name|pp
operator|)
expr_stmt|;
if|if
condition|(
name|type_bits
operator|==
literal|0
condition|)
return|return
name|init_type
argument_list|(
name|TYPE_CODE_VOID
argument_list|,
literal|1
argument_list|,
name|signed_type
condition|?
literal|0
else|:
name|TYPE_FLAG_UNSIGNED
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|objfile
argument_list|)
return|;
else|else
return|return
name|init_type
argument_list|(
name|code
argument_list|,
name|type_bits
operator|/
name|TARGET_CHAR_BIT
argument_list|,
name|signed_type
condition|?
literal|0
else|:
name|TYPE_FLAG_UNSIGNED
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|objfile
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|type
modifier|*
name|read_sun_floating_type
parameter_list|(
name|char
modifier|*
modifier|*
name|pp
parameter_list|,
name|int
name|typenums
index|[
literal|2
index|]
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|int
name|nbits
decl_stmt|;
name|int
name|details
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
name|struct
name|type
modifier|*
name|rettype
decl_stmt|;
comment|/* The first number has more details about the type, for example      FN_COMPLEX.  */
name|details
operator|=
name|read_huge_number
argument_list|(
name|pp
argument_list|,
literal|';'
argument_list|,
operator|&
name|nbits
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbits
operator|!=
literal|0
condition|)
return|return
name|error_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
return|;
comment|/* The second number is the number of bytes occupied by this type */
name|nbytes
operator|=
name|read_huge_number
argument_list|(
name|pp
argument_list|,
literal|';'
argument_list|,
operator|&
name|nbits
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbits
operator|!=
literal|0
condition|)
return|return
name|error_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
return|;
if|if
condition|(
name|details
operator|==
name|NF_COMPLEX
operator|||
name|details
operator|==
name|NF_COMPLEX16
operator|||
name|details
operator|==
name|NF_COMPLEX32
condition|)
block|{
name|rettype
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_COMPLEX
argument_list|,
name|nbytes
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|TYPE_TARGET_TYPE
argument_list|(
name|rettype
argument_list|)
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
name|nbytes
operator|/
literal|2
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
return|return
name|rettype
return|;
block|}
return|return
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
name|nbytes
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|objfile
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Read a number from the string pointed to by *PP.    The value of *PP is advanced over the number.    If END is nonzero, the character that ends the    number must match END, or an error happens;    and that character is skipped if it does match.    If END is zero, *PP is left pointing to that character.     If the number fits in a long, set *BITS to 0 and return the value.    If not, set *BITS to be the number of bits in the number and return 0.     If encounter garbage, set *BITS to -1 and return 0.  */
end_comment

begin_function
specifier|static
name|long
name|read_huge_number
parameter_list|(
name|char
modifier|*
modifier|*
name|pp
parameter_list|,
name|int
name|end
parameter_list|,
name|int
modifier|*
name|bits
parameter_list|)
block|{
name|char
modifier|*
name|p
init|=
operator|*
name|pp
decl_stmt|;
name|int
name|sign
init|=
literal|1
decl_stmt|;
name|long
name|n
init|=
literal|0
decl_stmt|;
name|int
name|radix
init|=
literal|10
decl_stmt|;
name|char
name|overflow
init|=
literal|0
decl_stmt|;
name|int
name|nbits
init|=
literal|0
decl_stmt|;
name|int
name|c
decl_stmt|;
name|long
name|upper_limit
decl_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
condition|)
block|{
name|sign
operator|=
operator|-
literal|1
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
comment|/* Leading zero means octal.  GCC uses this to output values larger      than an int (because that would be hard in decimal).  */
if|if
condition|(
operator|*
name|p
operator|==
literal|'0'
condition|)
block|{
name|radix
operator|=
literal|8
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
name|upper_limit
operator|=
name|LONG_MAX
operator|/
name|radix
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|>=
literal|'0'
operator|&&
name|c
operator|<
operator|(
literal|'0'
operator|+
name|radix
operator|)
condition|)
block|{
if|if
condition|(
name|n
operator|<=
name|upper_limit
condition|)
block|{
name|n
operator|*=
name|radix
expr_stmt|;
name|n
operator|+=
name|c
operator|-
literal|'0'
expr_stmt|;
comment|/* FIXME this overflows anyway */
block|}
else|else
name|overflow
operator|=
literal|1
expr_stmt|;
comment|/* This depends on large values being output in octal, which is          what GCC does. */
if|if
condition|(
name|radix
operator|==
literal|8
condition|)
block|{
if|if
condition|(
name|nbits
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'0'
condition|)
comment|/* Ignore leading zeroes.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'1'
condition|)
name|nbits
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'2'
operator|||
name|c
operator|==
literal|'3'
condition|)
name|nbits
operator|=
literal|2
expr_stmt|;
else|else
name|nbits
operator|=
literal|3
expr_stmt|;
block|}
else|else
name|nbits
operator|+=
literal|3
expr_stmt|;
block|}
block|}
if|if
condition|(
name|end
condition|)
block|{
if|if
condition|(
name|c
operator|&&
name|c
operator|!=
name|end
condition|)
block|{
if|if
condition|(
name|bits
operator|!=
name|NULL
condition|)
operator|*
name|bits
operator|=
operator|-
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
else|else
operator|--
name|p
expr_stmt|;
operator|*
name|pp
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|overflow
condition|)
block|{
if|if
condition|(
name|nbits
operator|==
literal|0
condition|)
block|{
comment|/* Large decimal constants are an error (because it is hard to 	     count how many bits are in them).  */
if|if
condition|(
name|bits
operator|!=
name|NULL
condition|)
operator|*
name|bits
operator|=
operator|-
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* -0x7f is the same as 0x80.  So deal with it by adding one to          the number of bits.  */
if|if
condition|(
name|sign
operator|==
operator|-
literal|1
condition|)
operator|++
name|nbits
expr_stmt|;
if|if
condition|(
name|bits
condition|)
operator|*
name|bits
operator|=
name|nbits
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|bits
condition|)
operator|*
name|bits
operator|=
literal|0
expr_stmt|;
return|return
name|n
operator|*
name|sign
return|;
block|}
comment|/* It's *BITS which has the interesting information.  */
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|type
modifier|*
name|read_range_type
parameter_list|(
name|char
modifier|*
modifier|*
name|pp
parameter_list|,
name|int
name|typenums
index|[
literal|2
index|]
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|char
modifier|*
name|orig_pp
init|=
operator|*
name|pp
decl_stmt|;
name|int
name|rangenums
index|[
literal|2
index|]
decl_stmt|;
name|long
name|n2
decl_stmt|,
name|n3
decl_stmt|;
name|int
name|n2bits
decl_stmt|,
name|n3bits
decl_stmt|;
name|int
name|self_subrange
decl_stmt|;
name|struct
name|type
modifier|*
name|result_type
decl_stmt|;
name|struct
name|type
modifier|*
name|index_type
init|=
name|NULL
decl_stmt|;
comment|/* First comes a type we are a subrange of.      In C it is usually 0, 1 or the type being defined.  */
if|if
condition|(
name|read_type_number
argument_list|(
name|pp
argument_list|,
name|rangenums
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|error_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
return|;
name|self_subrange
operator|=
operator|(
name|rangenums
index|[
literal|0
index|]
operator|==
name|typenums
index|[
literal|0
index|]
operator|&&
name|rangenums
index|[
literal|1
index|]
operator|==
name|typenums
index|[
literal|1
index|]
operator|)
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|'='
condition|)
block|{
operator|*
name|pp
operator|=
name|orig_pp
expr_stmt|;
name|index_type
operator|=
name|read_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
comment|/* A semicolon should now follow; skip it.  */
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|';'
condition|)
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
comment|/* The remaining two operands are usually lower and upper bounds      of the range.  But in some special cases they mean something else.  */
name|n2
operator|=
name|read_huge_number
argument_list|(
name|pp
argument_list|,
literal|';'
argument_list|,
operator|&
name|n2bits
argument_list|)
expr_stmt|;
name|n3
operator|=
name|read_huge_number
argument_list|(
name|pp
argument_list|,
literal|';'
argument_list|,
operator|&
name|n3bits
argument_list|)
expr_stmt|;
if|if
condition|(
name|n2bits
operator|==
operator|-
literal|1
operator|||
name|n3bits
operator|==
operator|-
literal|1
condition|)
return|return
name|error_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
return|;
if|if
condition|(
name|index_type
condition|)
goto|goto
name|handle_true_range
goto|;
comment|/* If limits are huge, must be large integral type.  */
if|if
condition|(
name|n2bits
operator|!=
literal|0
operator|||
name|n3bits
operator|!=
literal|0
condition|)
block|{
name|char
name|got_signed
init|=
literal|0
decl_stmt|;
name|char
name|got_unsigned
init|=
literal|0
decl_stmt|;
comment|/* Number of bits in the type.  */
name|int
name|nbits
init|=
literal|0
decl_stmt|;
comment|/* Range from 0 to<large number> is an unsigned large integral type.  */
if|if
condition|(
operator|(
name|n2bits
operator|==
literal|0
operator|&&
name|n2
operator|==
literal|0
operator|)
operator|&&
name|n3bits
operator|!=
literal|0
condition|)
block|{
name|got_unsigned
operator|=
literal|1
expr_stmt|;
name|nbits
operator|=
name|n3bits
expr_stmt|;
block|}
comment|/* Range from<large number> to<large number>-1 is a large signed          integral type.  Take care of the case where<large number> doesn't          fit in a long but<large number>-1 does.  */
elseif|else
if|if
condition|(
operator|(
name|n2bits
operator|!=
literal|0
operator|&&
name|n3bits
operator|!=
literal|0
operator|&&
name|n2bits
operator|==
name|n3bits
operator|+
literal|1
operator|)
operator|||
operator|(
name|n2bits
operator|!=
literal|0
operator|&&
name|n3bits
operator|==
literal|0
operator|&&
operator|(
name|n2bits
operator|==
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|*
name|HOST_CHAR_BIT
operator|)
operator|&&
name|n3
operator|==
name|LONG_MAX
operator|)
condition|)
block|{
name|got_signed
operator|=
literal|1
expr_stmt|;
name|nbits
operator|=
name|n2bits
expr_stmt|;
block|}
if|if
condition|(
name|got_signed
operator|||
name|got_unsigned
condition|)
block|{
return|return
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|nbits
operator|/
name|TARGET_CHAR_BIT
argument_list|,
name|got_unsigned
condition|?
name|TYPE_FLAG_UNSIGNED
else|:
literal|0
argument_list|,
name|NULL
argument_list|,
name|objfile
argument_list|)
return|;
block|}
else|else
return|return
name|error_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
return|;
block|}
comment|/* A type defined as a subrange of itself, with bounds both 0, is void.  */
if|if
condition|(
name|self_subrange
operator|&&
name|n2
operator|==
literal|0
operator|&&
name|n3
operator|==
literal|0
condition|)
return|return
name|init_type
argument_list|(
name|TYPE_CODE_VOID
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|objfile
argument_list|)
return|;
comment|/* If n3 is zero and n2 is positive, we want a floating type, and n2      is the width in bytes.       Fortran programs appear to use this for complex types also.  To      distinguish between floats and complex, g77 (and others?)  seem      to use self-subranges for the complexes, and subranges of int for      the floats.       Also note that for complexes, g77 sets n2 to the size of one of      the member floats, not the whole complex beast.  My guess is that      this was to work well with pre-COMPLEX versions of gdb. */
if|if
condition|(
name|n3
operator|==
literal|0
operator|&&
name|n2
operator|>
literal|0
condition|)
block|{
name|struct
name|type
modifier|*
name|float_type
init|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
name|n2
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|objfile
argument_list|)
decl_stmt|;
if|if
condition|(
name|self_subrange
condition|)
block|{
name|struct
name|type
modifier|*
name|complex_type
init|=
name|init_type
argument_list|(
name|TYPE_CODE_COMPLEX
argument_list|,
literal|2
operator|*
name|n2
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|objfile
argument_list|)
decl_stmt|;
name|TYPE_TARGET_TYPE
argument_list|(
name|complex_type
argument_list|)
operator|=
name|float_type
expr_stmt|;
return|return
name|complex_type
return|;
block|}
else|else
return|return
name|float_type
return|;
block|}
comment|/* If the upper bound is -1, it must really be an unsigned int.  */
elseif|else
if|if
condition|(
name|n2
operator|==
literal|0
operator|&&
name|n3
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* It is unsigned int or unsigned long.  */
comment|/* GCC 2.3.3 uses this for long long too, but that is just a GDB 3.5          compatibility hack.  */
return|return
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_INT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
name|NULL
argument_list|,
name|objfile
argument_list|)
return|;
block|}
comment|/* Special case: char is defined (Who knows why) as a subrange of      itself with range 0-127.  */
elseif|else
if|if
condition|(
name|self_subrange
operator|&&
name|n2
operator|==
literal|0
operator|&&
name|n3
operator|==
literal|127
condition|)
return|return
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|1
argument_list|,
name|TYPE_FLAG_NOSIGN
argument_list|,
name|NULL
argument_list|,
name|objfile
argument_list|)
return|;
comment|/* We used to do this only for subrange of self or subrange of int.  */
elseif|else
if|if
condition|(
name|n2
operator|==
literal|0
condition|)
block|{
comment|/* -1 is used for the upper bound of (4 byte) "unsigned int" and          "unsigned long", and we already checked for that,          so don't need to test for it here.  */
if|if
condition|(
name|n3
operator|<
literal|0
condition|)
comment|/* n3 actually gives the size.  */
return|return
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
operator|-
name|n3
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
name|NULL
argument_list|,
name|objfile
argument_list|)
return|;
comment|/* Is n3 == 2**(8n)-1 for some integer n?  Then it's an          unsigned n-byte integer.  But do require n to be a power of          two; we don't want 3- and 5-byte integers flying around.  */
block|{
name|int
name|bytes
decl_stmt|;
name|unsigned
name|long
name|bits
decl_stmt|;
name|bits
operator|=
name|n3
expr_stmt|;
for|for
control|(
name|bytes
operator|=
literal|0
init|;
operator|(
name|bits
operator|&
literal|0xff
operator|)
operator|==
literal|0xff
condition|;
name|bytes
operator|++
control|)
name|bits
operator|>>=
literal|8
expr_stmt|;
if|if
condition|(
name|bits
operator|==
literal|0
operator|&&
operator|(
operator|(
name|bytes
operator|-
literal|1
operator|)
operator|&
name|bytes
operator|)
operator|==
literal|0
condition|)
comment|/* "bytes is a power of two" */
return|return
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|bytes
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
name|NULL
argument_list|,
name|objfile
argument_list|)
return|;
block|}
block|}
comment|/* I think this is for Convex "long long".  Since I don't know whether      Convex sets self_subrange, I also accept that particular size regardless      of self_subrange.  */
elseif|else
if|if
condition|(
name|n3
operator|==
literal|0
operator|&&
name|n2
operator|<
literal|0
operator|&&
operator|(
name|self_subrange
operator|||
name|n2
operator|==
operator|-
name|TARGET_LONG_LONG_BIT
operator|/
name|TARGET_CHAR_BIT
operator|)
condition|)
return|return
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
operator|-
name|n2
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|objfile
argument_list|)
return|;
elseif|else
if|if
condition|(
name|n2
operator|==
operator|-
name|n3
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|n3
operator|==
literal|0x7f
condition|)
return|return
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|objfile
argument_list|)
return|;
if|if
condition|(
name|n3
operator|==
literal|0x7fff
condition|)
return|return
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|objfile
argument_list|)
return|;
if|if
condition|(
name|n3
operator|==
literal|0x7fffffff
condition|)
return|return
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|objfile
argument_list|)
return|;
block|}
comment|/* We have a real range type on our hands.  Allocate space and      return a real pointer.  */
name|handle_true_range
label|:
if|if
condition|(
name|self_subrange
condition|)
name|index_type
operator|=
name|builtin_type_int
expr_stmt|;
else|else
name|index_type
operator|=
operator|*
name|dbx_lookup_type
argument_list|(
name|rangenums
argument_list|)
expr_stmt|;
if|if
condition|(
name|index_type
operator|==
name|NULL
condition|)
block|{
comment|/* Does this actually ever happen?  Is that why we are worrying          about dealing with it rather than just calling error_type?  */
specifier|static
name|struct
name|type
modifier|*
name|range_type_index
decl_stmt|;
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"base type %d of range type is not defined"
argument_list|,
name|rangenums
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|range_type_index
operator|==
name|NULL
condition|)
name|range_type_index
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_INT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"range type index type"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|index_type
operator|=
name|range_type_index
expr_stmt|;
block|}
name|result_type
operator|=
name|create_range_type
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|)
name|NULL
argument_list|,
name|index_type
argument_list|,
name|n2
argument_list|,
name|n3
argument_list|)
expr_stmt|;
return|return
operator|(
name|result_type
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Read in an argument list.  This is a list of types, separated by commas    and terminated with END.  Return the list of types read in, or (struct type    **)-1 if there is an error.  */
end_comment

begin_function
specifier|static
name|struct
name|field
modifier|*
name|read_args
parameter_list|(
name|char
modifier|*
modifier|*
name|pp
parameter_list|,
name|int
name|end
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|,
name|int
modifier|*
name|nargsp
parameter_list|,
name|int
modifier|*
name|varargsp
parameter_list|)
block|{
comment|/* FIXME!  Remove this arbitrary limit!  */
name|struct
name|type
modifier|*
name|types
index|[
literal|1024
index|]
decl_stmt|;
comment|/* allow for fns of 1023 parameters */
name|int
name|n
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|field
modifier|*
name|rval
decl_stmt|;
while|while
condition|(
operator|*
operator|*
name|pp
operator|!=
name|end
condition|)
block|{
if|if
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|','
condition|)
comment|/* Invalid argument list: no ','.  */
return|return
operator|(
expr|struct
name|field
operator|*
operator|)
operator|-
literal|1
return|;
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
name|STABS_CONTINUE
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|types
index|[
name|n
operator|++
index|]
operator|=
name|read_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
comment|/* get past `end' (the ':' character) */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|types
index|[
name|n
operator|-
literal|1
index|]
argument_list|)
operator|!=
name|TYPE_CODE_VOID
condition|)
operator|*
name|varargsp
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|n
operator|--
expr_stmt|;
operator|*
name|varargsp
operator|=
literal|0
expr_stmt|;
block|}
name|rval
operator|=
operator|(
expr|struct
name|field
operator|*
operator|)
name|xmalloc
argument_list|(
name|n
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|rval
argument_list|,
literal|0
argument_list|,
name|n
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|rval
index|[
name|i
index|]
operator|.
name|type
operator|=
name|types
index|[
name|i
index|]
expr_stmt|;
operator|*
name|nargsp
operator|=
name|n
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Common block handling.  */
end_comment

begin_comment
comment|/* List of symbols declared since the last BCOMM.  This list is a tail    of local_symbols.  When ECOMM is seen, the symbols on the list    are noted so their proper addresses can be filled in later,    using the common block base address gotten from the assembler    stabs.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|pending
modifier|*
name|common_block
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|common_block_i
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name of the current common block.  We get it from the BCOMM instead of the    ECOMM to match IBM documentation (even though IBM puts the name both places    like everyone else).  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|common_block_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Process a N_BCOMM symbol.  The storage for NAME is not guaranteed    to remain after this function returns.  */
end_comment

begin_function
name|void
name|common_block_start
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
if|if
condition|(
name|common_block_name
operator|!=
name|NULL
condition|)
block|{
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"Invalid symbol data: common block within common block"
argument_list|)
expr_stmt|;
block|}
name|common_block
operator|=
name|local_symbols
expr_stmt|;
name|common_block_i
operator|=
name|local_symbols
condition|?
name|local_symbols
operator|->
name|nsyms
else|:
literal|0
expr_stmt|;
name|common_block_name
operator|=
name|obsavestring
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Process a N_ECOMM symbol.  */
end_comment

begin_function
name|void
name|common_block_end
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
comment|/* Symbols declared since the BCOMM are to have the common block      start address added in when we know it.  common_block and      common_block_i point to the first symbol after the BCOMM in      the local_symbols list; copy the list and hang it off the      symbol for the common block name for later fixup.  */
name|int
name|i
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|struct
name|pending
modifier|*
name|new
init|=
literal|0
decl_stmt|;
name|struct
name|pending
modifier|*
name|next
decl_stmt|;
name|int
name|j
decl_stmt|;
if|if
condition|(
name|common_block_name
operator|==
name|NULL
condition|)
block|{
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"ECOMM symbol unmatched by BCOMM"
argument_list|)
expr_stmt|;
return|return;
block|}
name|sym
operator|=
operator|(
expr|struct
name|symbol
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|sym
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Note: common_block_name already saved on objfile_obstack */
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|=
name|common_block_name
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_BLOCK
expr_stmt|;
comment|/* Now we copy all the symbols which have been defined since the BCOMM.  */
comment|/* Copy all the struct pendings before common_block.  */
for|for
control|(
name|next
operator|=
name|local_symbols
init|;
name|next
operator|!=
name|NULL
operator|&&
name|next
operator|!=
name|common_block
condition|;
name|next
operator|=
name|next
operator|->
name|next
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|next
operator|->
name|nsyms
condition|;
name|j
operator|++
control|)
name|add_symbol_to_list
argument_list|(
name|next
operator|->
name|symbol
index|[
name|j
index|]
argument_list|,
operator|&
name|new
argument_list|)
expr_stmt|;
block|}
comment|/* Copy however much of COMMON_BLOCK we need.  If COMMON_BLOCK is      NULL, it means copy all the local symbols (which we already did      above).  */
if|if
condition|(
name|common_block
operator|!=
name|NULL
condition|)
for|for
control|(
name|j
operator|=
name|common_block_i
init|;
name|j
operator|<
name|common_block
operator|->
name|nsyms
condition|;
name|j
operator|++
control|)
name|add_symbol_to_list
argument_list|(
name|common_block
operator|->
name|symbol
index|[
name|j
index|]
argument_list|,
operator|&
name|new
argument_list|)
expr_stmt|;
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
operator|(
expr|struct
name|type
operator|*
operator|)
name|new
expr_stmt|;
comment|/* Should we be putting local_symbols back to what it was?      Does it matter?  */
name|i
operator|=
name|hashname
argument_list|(
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|SYMBOL_VALUE_CHAIN
argument_list|(
name|sym
argument_list|)
operator|=
name|global_sym_chain
index|[
name|i
index|]
expr_stmt|;
name|global_sym_chain
index|[
name|i
index|]
operator|=
name|sym
expr_stmt|;
name|common_block_name
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a common block's start address to the offset of each symbol    declared to be in it (by being between a BCOMM/ECOMM pair that uses    the common block name).  */
end_comment

begin_function
specifier|static
name|void
name|fix_common_block
parameter_list|(
name|struct
name|symbol
modifier|*
name|sym
parameter_list|,
name|int
name|valu
parameter_list|)
block|{
name|struct
name|pending
modifier|*
name|next
init|=
operator|(
expr|struct
name|pending
operator|*
operator|)
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|next
condition|;
name|next
operator|=
name|next
operator|->
name|next
control|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|next
operator|->
name|nsyms
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|next
operator|->
name|symbol
index|[
name|j
index|]
argument_list|)
operator|+=
name|valu
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* What about types defined as forward references inside of a small lexical    scope?  */
end_comment

begin_comment
comment|/* Add a type to the list of undefined types to be checked through    once this file has been read in.  */
end_comment

begin_function
specifier|static
name|void
name|add_undefined_type
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
if|if
condition|(
name|undef_types_length
operator|==
name|undef_types_allocated
condition|)
block|{
name|undef_types_allocated
operator|*=
literal|2
expr_stmt|;
name|undef_types
operator|=
operator|(
expr|struct
name|type
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|undef_types
argument_list|,
name|undef_types_allocated
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|undef_types
index|[
name|undef_types_length
operator|++
index|]
operator|=
name|type
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Go through each undefined type, see if it's still undefined, and fix it    up if possible.  We have two kinds of undefined types:     TYPE_CODE_ARRAY:  Array whose target type wasn't defined yet.    Fix:  update array length using the element bounds    and the target type's length.    TYPE_CODE_STRUCT, TYPE_CODE_UNION:  Structure whose fields were not    yet defined at the time a pointer to it was made.    Fix:  Do a full lookup on the struct/union tag.  */
end_comment

begin_function
name|void
name|cleanup_undefined_types
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|type
modifier|*
modifier|*
name|type
decl_stmt|;
for|for
control|(
name|type
operator|=
name|undef_types
init|;
name|type
operator|<
name|undef_types
operator|+
name|undef_types_length
condition|;
name|type
operator|++
control|)
block|{
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
operator|*
name|type
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_STRUCT
case|:
case|case
name|TYPE_CODE_UNION
case|:
case|case
name|TYPE_CODE_ENUM
case|:
block|{
comment|/* Check if it has been defined since.  Need to do this here 	       as well as in check_typedef to deal with the (legitimate in 	       C though not C++) case of several types with the same name 	       in different source files.  */
if|if
condition|(
name|TYPE_STUB
argument_list|(
operator|*
name|type
argument_list|)
condition|)
block|{
name|struct
name|pending
modifier|*
name|ppt
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Name of the type, without "struct" or "union" */
name|char
modifier|*
name|typename
init|=
name|TYPE_TAG_NAME
argument_list|(
operator|*
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|typename
operator|==
name|NULL
condition|)
block|{
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"need a type name"
argument_list|)
expr_stmt|;
break|break;
block|}
for|for
control|(
name|ppt
operator|=
name|file_symbols
init|;
name|ppt
condition|;
name|ppt
operator|=
name|ppt
operator|->
name|next
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ppt
operator|->
name|nsyms
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|symbol
modifier|*
name|sym
init|=
name|ppt
operator|->
name|symbol
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_TYPEDEF
operator|&&
name|SYMBOL_DOMAIN
argument_list|(
name|sym
argument_list|)
operator|==
name|STRUCT_DOMAIN
operator|&&
operator|(
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE
argument_list|(
operator|*
name|type
argument_list|)
operator|)
operator|&&
name|strcmp
argument_list|(
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|typename
argument_list|)
operator|==
literal|0
condition|)
name|replace_type
argument_list|(
operator|*
name|type
argument_list|,
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
break|break;
default|default:
block|{
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"forward-referenced types left unresolved, "
literal|"type code %d."
argument_list|,
name|TYPE_CODE
argument_list|(
operator|*
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
name|undef_types_length
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Scan through all of the global symbols defined in the object file,    assigning values to the debugging symbols that need to be assigned    to.  Get these symbols from the minimal symbol table.  */
end_comment

begin_function
name|void
name|scan_file_globals
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|int
name|hash
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
name|struct
name|objfile
modifier|*
name|resolve_objfile
decl_stmt|;
comment|/* SVR4 based linkers copy referenced global symbols from shared      libraries to the main executable.      If we are scanning the symbols for a shared library, try to resolve      them from the minimal symbols of the main executable first.  */
if|if
condition|(
name|symfile_objfile
operator|&&
name|objfile
operator|!=
name|symfile_objfile
condition|)
name|resolve_objfile
operator|=
name|symfile_objfile
expr_stmt|;
else|else
name|resolve_objfile
operator|=
name|objfile
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Avoid expensive loop through all minimal symbols if there are          no unresolved symbols.  */
for|for
control|(
name|hash
operator|=
literal|0
init|;
name|hash
operator|<
name|HASHSIZE
condition|;
name|hash
operator|++
control|)
block|{
if|if
condition|(
name|global_sym_chain
index|[
name|hash
index|]
condition|)
break|break;
block|}
if|if
condition|(
name|hash
operator|>=
name|HASHSIZE
condition|)
return|return;
for|for
control|(
name|msymbol
operator|=
name|resolve_objfile
operator|->
name|msymbols
init|;
name|msymbol
operator|&&
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|msymbol
argument_list|)
operator|!=
name|NULL
condition|;
name|msymbol
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
comment|/* Skip static symbols.  */
switch|switch
condition|(
name|MSYMBOL_TYPE
argument_list|(
name|msymbol
argument_list|)
condition|)
block|{
case|case
name|mst_file_text
case|:
case|case
name|mst_file_data
case|:
case|case
name|mst_file_bss
case|:
continue|continue;
default|default:
break|break;
block|}
name|prev
operator|=
name|NULL
expr_stmt|;
comment|/* Get the hash index and check all the symbols 	     under that hash index. */
name|hash
operator|=
name|hashname
argument_list|(
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|msymbol
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|sym
operator|=
name|global_sym_chain
index|[
name|hash
index|]
init|;
name|sym
condition|;
control|)
block|{
if|if
condition|(
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|msymbol
argument_list|)
index|[
literal|0
index|]
operator|==
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
index|[
literal|0
index|]
operator|&&
name|strcmp
argument_list|(
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|msymbol
argument_list|)
operator|+
literal|1
argument_list|,
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|+
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Splice this symbol out of the hash chain and 		     assign the value we have to it. */
if|if
condition|(
name|prev
condition|)
block|{
name|SYMBOL_VALUE_CHAIN
argument_list|(
name|prev
argument_list|)
operator|=
name|SYMBOL_VALUE_CHAIN
argument_list|(
name|sym
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|global_sym_chain
index|[
name|hash
index|]
operator|=
name|SYMBOL_VALUE_CHAIN
argument_list|(
name|sym
argument_list|)
expr_stmt|;
block|}
comment|/* Check to see whether we need to fix up a common block.  */
comment|/* Note: this code might be executed several times for 		     the same symbol if there are multiple references.  */
if|if
condition|(
name|sym
condition|)
block|{
if|if
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_BLOCK
condition|)
block|{
name|fix_common_block
argument_list|(
name|sym
argument_list|,
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym
argument_list|)
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
expr_stmt|;
block|}
name|SYMBOL_SECTION
argument_list|(
name|sym
argument_list|)
operator|=
name|SYMBOL_SECTION
argument_list|(
name|msymbol
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|prev
condition|)
block|{
name|sym
operator|=
name|SYMBOL_VALUE_CHAIN
argument_list|(
name|prev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sym
operator|=
name|global_sym_chain
index|[
name|hash
index|]
expr_stmt|;
block|}
block|}
else|else
block|{
name|prev
operator|=
name|sym
expr_stmt|;
name|sym
operator|=
name|SYMBOL_VALUE_CHAIN
argument_list|(
name|sym
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|resolve_objfile
operator|==
name|objfile
condition|)
break|break;
name|resolve_objfile
operator|=
name|objfile
expr_stmt|;
block|}
comment|/* Change the storage class of any remaining unresolved globals to      LOC_UNRESOLVED and remove them from the chain.  */
for|for
control|(
name|hash
operator|=
literal|0
init|;
name|hash
operator|<
name|HASHSIZE
condition|;
name|hash
operator|++
control|)
block|{
name|sym
operator|=
name|global_sym_chain
index|[
name|hash
index|]
expr_stmt|;
while|while
condition|(
name|sym
condition|)
block|{
name|prev
operator|=
name|sym
expr_stmt|;
name|sym
operator|=
name|SYMBOL_VALUE_CHAIN
argument_list|(
name|sym
argument_list|)
expr_stmt|;
comment|/* Change the symbol address from the misleading chain value 	     to address zero.  */
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|prev
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Complain about unresolved common block symbols.  */
if|if
condition|(
name|SYMBOL_CLASS
argument_list|(
name|prev
argument_list|)
operator|==
name|LOC_STATIC
condition|)
name|SYMBOL_CLASS
argument_list|(
name|prev
argument_list|)
operator|=
name|LOC_UNRESOLVED
expr_stmt|;
else|else
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"%s: common block `%s' from global_sym_chain unresolved"
argument_list|,
name|objfile
operator|->
name|name
argument_list|,
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|prev
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|memset
argument_list|(
name|global_sym_chain
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|global_sym_chain
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize anything that needs initializing when starting to read    a fresh piece of a symbol file, e.g. reading in the stuff corresponding    to a psymtab.  */
end_comment

begin_function
name|void
name|stabsread_init
parameter_list|(
name|void
parameter_list|)
block|{ }
end_function

begin_comment
comment|/* Initialize anything that needs initializing when a completely new    symbol file is specified (not just adding some symbols from another    file, e.g. a shared library).  */
end_comment

begin_function
name|void
name|stabsread_new_init
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Empty the hash table of global syms looking for values.  */
name|memset
argument_list|(
name|global_sym_chain
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|global_sym_chain
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize anything that needs initializing at the same time as    start_symtab() is called. */
end_comment

begin_function
name|void
name|start_stabs
parameter_list|(
name|void
parameter_list|)
block|{
name|global_stabs
operator|=
name|NULL
expr_stmt|;
comment|/* AIX COFF */
comment|/* Leave FILENUM of 0 free for builtin types and this file's types.  */
name|n_this_object_header_files
operator|=
literal|1
expr_stmt|;
name|type_vector_length
operator|=
literal|0
expr_stmt|;
name|type_vector
operator|=
operator|(
expr|struct
name|type
operator|*
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* FIXME: If common_block_name is not already NULL, we should complain().  */
name|common_block_name
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Call after end_symtab() */
end_comment

begin_function
name|void
name|end_stabs
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|type_vector
condition|)
block|{
name|xfree
argument_list|(
name|type_vector
argument_list|)
expr_stmt|;
block|}
name|type_vector
operator|=
literal|0
expr_stmt|;
name|type_vector_length
operator|=
literal|0
expr_stmt|;
name|previous_stab_code
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|finish_global_stabs
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
if|if
condition|(
name|global_stabs
condition|)
block|{
name|patch_block_stabs
argument_list|(
name|global_symbols
argument_list|,
name|global_stabs
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|global_stabs
argument_list|)
expr_stmt|;
name|global_stabs
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Find the end of the name, delimited by a ':', but don't match    ObjC symbols which look like -[Foo bar::]:bla.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|find_name_end
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|char
modifier|*
name|s
init|=
name|name
decl_stmt|;
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
literal|'-'
operator|||
operator|*
name|s
operator|==
literal|'+'
condition|)
block|{
comment|/* Must be an ObjC method symbol.  */
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|!=
literal|'['
condition|)
block|{
name|error
argument_list|(
literal|"invalid symbol name \"%s\""
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|strchr
argument_list|(
name|s
argument_list|,
literal|']'
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"invalid symbol name \"%s\""
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
return|return
name|strchr
argument_list|(
name|s
argument_list|,
literal|':'
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|strchr
argument_list|(
name|s
argument_list|,
literal|':'
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Initializer for this module */
end_comment

begin_function
name|void
name|_initialize_stabsread
parameter_list|(
name|void
parameter_list|)
block|{
name|undef_types_allocated
operator|=
literal|20
expr_stmt|;
name|undef_types_length
operator|=
literal|0
expr_stmt|;
name|undef_types
operator|=
operator|(
expr|struct
name|type
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|undef_types_allocated
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

