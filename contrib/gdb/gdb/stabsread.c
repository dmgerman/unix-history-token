begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Support routines for decoding "stabs" debugging information format.    Copyright 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995,    1996, 1997, 1998, 1999, 2000, 2001, 2002    Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* Support routines for reading and decoding debugging information in    the "stabs" format.  This format is used with many systems that use    the a.out object file format, as well as some systems that use    COFF or ELF where the stabs data is placed in a special section.    Avoid placing any object file format specific code in this file. */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"aout/stab_gnu.h"
end_include

begin_comment
comment|/* We always use GNU stabs, not native */
end_comment

begin_include
include|#
directive|include
file|"libaout.h"
end_include

begin_include
include|#
directive|include
file|"aout/aout64.h"
end_include

begin_include
include|#
directive|include
file|"gdb-stabs.h"
end_include

begin_include
include|#
directive|include
file|"buildsym.h"
end_include

begin_include
include|#
directive|include
file|"complaints.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"doublest.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_comment
comment|/* Ask stabsread.h to define the vars it normally declares `extern'.  */
end_comment

begin_define
define|#
directive|define
name|EXTERN
end_define

begin_comment
comment|/**/
end_comment

begin_include
include|#
directive|include
file|"stabsread.h"
end_include

begin_comment
comment|/* Our own declarations */
end_comment

begin_undef
undef|#
directive|undef
name|EXTERN
end_undef

begin_function_decl
specifier|extern
name|void
name|_initialize_stabsread
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* The routines that read and process a complete stabs for a C struct or     C++ class pass lists of data member fields and lists of member function    fields in an instance of a field_info structure, as defined below.    This is part of some reorganization of low level C++ support and is    expected to eventually go away... (FIXME) */
end_comment

begin_struct
struct|struct
name|field_info
block|{
struct|struct
name|nextfield
block|{
name|struct
name|nextfield
modifier|*
name|next
decl_stmt|;
comment|/* This is the raw visibility from the stab.  It is not checked 	   for being one of the visibilities we recognize, so code which 	   examines this field better be able to deal.  */
name|int
name|visibility
decl_stmt|;
name|struct
name|field
name|field
decl_stmt|;
block|}
modifier|*
name|list
struct|;
struct|struct
name|next_fnfieldlist
block|{
name|struct
name|next_fnfieldlist
modifier|*
name|next
decl_stmt|;
name|struct
name|fn_fieldlist
name|fn_fieldlist
decl_stmt|;
block|}
modifier|*
name|fnlist
struct|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|void
name|read_one_struct_field
parameter_list|(
name|struct
name|field_info
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|struct
name|type
modifier|*
parameter_list|,
name|struct
name|objfile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|get_substring
parameter_list|(
name|char
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|type
modifier|*
name|dbx_alloc_type
parameter_list|(
name|int
index|[
literal|2
index|]
parameter_list|,
name|struct
name|objfile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|long
name|read_huge_number
parameter_list|(
name|char
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|type
modifier|*
name|error_type
parameter_list|(
name|char
modifier|*
modifier|*
parameter_list|,
name|struct
name|objfile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|patch_block_stabs
parameter_list|(
name|struct
name|pending
modifier|*
parameter_list|,
name|struct
name|pending_stabs
modifier|*
parameter_list|,
name|struct
name|objfile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fix_common_block
parameter_list|(
name|struct
name|symbol
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|read_type_number
parameter_list|(
name|char
modifier|*
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|type
modifier|*
name|read_range_type
parameter_list|(
name|char
modifier|*
modifier|*
parameter_list|,
name|int
index|[
literal|2
index|]
parameter_list|,
name|struct
name|objfile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|type
modifier|*
name|read_sun_builtin_type
parameter_list|(
name|char
modifier|*
modifier|*
parameter_list|,
name|int
index|[
literal|2
index|]
parameter_list|,
name|struct
name|objfile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|type
modifier|*
name|read_sun_floating_type
parameter_list|(
name|char
modifier|*
modifier|*
parameter_list|,
name|int
index|[
literal|2
index|]
parameter_list|,
name|struct
name|objfile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|type
modifier|*
name|read_enum_type
parameter_list|(
name|char
modifier|*
modifier|*
parameter_list|,
name|struct
name|type
modifier|*
parameter_list|,
name|struct
name|objfile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|type
modifier|*
name|rs6000_builtin_type
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|read_member_functions
parameter_list|(
name|struct
name|field_info
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|,
name|struct
name|type
modifier|*
parameter_list|,
name|struct
name|objfile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|read_struct_fields
parameter_list|(
name|struct
name|field_info
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|,
name|struct
name|type
modifier|*
parameter_list|,
name|struct
name|objfile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|read_baseclasses
parameter_list|(
name|struct
name|field_info
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|,
name|struct
name|type
modifier|*
parameter_list|,
name|struct
name|objfile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|read_tilde_fields
parameter_list|(
name|struct
name|field_info
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|,
name|struct
name|type
modifier|*
parameter_list|,
name|struct
name|objfile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|attach_fn_fields_to_type
parameter_list|(
name|struct
name|field_info
modifier|*
parameter_list|,
name|struct
name|type
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|attach_fields_to_type
parameter_list|(
name|struct
name|field_info
modifier|*
parameter_list|,
name|struct
name|type
modifier|*
parameter_list|,
name|struct
name|objfile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|type
modifier|*
name|read_struct_type
parameter_list|(
name|char
modifier|*
modifier|*
parameter_list|,
name|struct
name|type
modifier|*
parameter_list|,
name|struct
name|objfile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|type
modifier|*
name|read_array_type
parameter_list|(
name|char
modifier|*
modifier|*
parameter_list|,
name|struct
name|type
modifier|*
parameter_list|,
name|struct
name|objfile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|type
modifier|*
modifier|*
name|read_args
parameter_list|(
name|char
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|objfile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|read_cpp_abbrev
parameter_list|(
name|struct
name|field_info
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|,
name|struct
name|type
modifier|*
parameter_list|,
name|struct
name|objfile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* new functions added for cfront support */
end_comment

begin_function_decl
specifier|static
name|int
name|copy_cfront_struct_fields
parameter_list|(
name|struct
name|field_info
modifier|*
parameter_list|,
name|struct
name|type
modifier|*
parameter_list|,
name|struct
name|objfile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|get_cfront_method_physname
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|read_cfront_baseclasses
parameter_list|(
name|struct
name|field_info
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|,
name|struct
name|type
modifier|*
parameter_list|,
name|struct
name|objfile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|read_cfront_static_fields
parameter_list|(
name|struct
name|field_info
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|,
name|struct
name|type
modifier|*
parameter_list|,
name|struct
name|objfile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|read_cfront_member_functions
parameter_list|(
name|struct
name|field_info
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|,
name|struct
name|type
modifier|*
parameter_list|,
name|struct
name|objfile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* end new functions added for cfront support */
end_comment

begin_function_decl
specifier|static
name|void
name|add_live_range
parameter_list|(
name|struct
name|objfile
modifier|*
parameter_list|,
name|struct
name|symbol
modifier|*
parameter_list|,
name|CORE_ADDR
parameter_list|,
name|CORE_ADDR
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|resolve_live_range
parameter_list|(
name|struct
name|objfile
modifier|*
parameter_list|,
name|struct
name|symbol
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|process_reference
parameter_list|(
name|char
modifier|*
modifier|*
name|string
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|CORE_ADDR
name|ref_search_value
parameter_list|(
name|int
name|refnum
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|resolve_symbol_reference
parameter_list|(
name|struct
name|objfile
modifier|*
parameter_list|,
name|struct
name|symbol
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|stabsread_clear_cache
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
specifier|const
name|char
name|vptr_name
index|[]
init|=
block|{
literal|'_'
block|,
literal|'v'
block|,
literal|'p'
block|,
literal|'t'
block|,
literal|'r'
block|,
name|CPLUS_MARKER
block|,
literal|'\0'
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|vb_name
index|[]
init|=
block|{
literal|'_'
block|,
literal|'v'
block|,
literal|'b'
block|,
name|CPLUS_MARKER
block|,
literal|'\0'
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Define this as 1 if a pcc declaration of a char or short argument    gives the correct address.  Otherwise assume pcc gives the    address of the corresponding int, which is not the same on a    big-endian machine.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|BELIEVE_PCC_PROMOTION
argument_list|)
end_if

begin_define
define|#
directive|define
name|BELIEVE_PCC_PROMOTION
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|BELIEVE_PCC_PROMOTION_TYPE
argument_list|)
end_if

begin_define
define|#
directive|define
name|BELIEVE_PCC_PROMOTION_TYPE
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|complaint
name|invalid_cpp_abbrev_complaint
init|=
block|{
literal|"invalid C++ abbreviation `%s'"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|complaint
name|invalid_cpp_type_complaint
init|=
block|{
literal|"C++ abbreviated type name unknown at symtab pos %d"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|complaint
name|member_fn_complaint
init|=
block|{
literal|"member function type missing, got '%c'"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|complaint
name|const_vol_complaint
init|=
block|{
literal|"const/volatile indicator missing, got '%c'"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|complaint
name|error_type_complaint
init|=
block|{
literal|"couldn't parse type; debugger out of date?"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|complaint
name|invalid_member_complaint
init|=
block|{
literal|"invalid (minimal) member type data format at symtab pos %d."
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|complaint
name|range_type_base_complaint
init|=
block|{
literal|"base type %d of range type is not defined"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|complaint
name|reg_value_complaint
init|=
block|{
literal|"register number %d too large (max %d) in symbol %s"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|complaint
name|vtbl_notfound_complaint
init|=
block|{
literal|"virtual function table pointer not found when defining class `%s'"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|complaint
name|unrecognized_cplus_name_complaint
init|=
block|{
literal|"Unknown C++ symbol name `%s'"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|complaint
name|rs6000_builtin_complaint
init|=
block|{
literal|"Unknown builtin type %d"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|complaint
name|unresolved_sym_chain_complaint
init|=
block|{
literal|"%s: common block `%s' from global_sym_chain unresolved"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|complaint
name|stabs_general_complaint
init|=
block|{
literal|"%s"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|complaint
name|lrs_general_complaint
init|=
block|{
literal|"%s"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Make a list of forward references which haven't been defined.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
modifier|*
name|undef_types
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|undef_types_allocated
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|undef_types_length
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|symbol
modifier|*
name|current_symbol
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Check for and handle cretinous stabs symbol name continuation!  */
end_comment

begin_define
define|#
directive|define
name|STABS_CONTINUE
parameter_list|(
name|pp
parameter_list|,
name|objfile
parameter_list|)
define|\
value|do {							\     if (**(pp) == '\\' || (**(pp) == '?'&& (*(pp))[1] == '\0')) \       *(pp) = next_symbol_text (objfile);	\   } while (0)
end_define

begin_escape
end_escape

begin_comment
comment|/* FIXME: These probably should be our own types (like rs6000_builtin_type    has its own types) rather than builtin_type_*.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
modifier|*
name|os9k_type_vector
index|[]
init|=
block|{
literal|0
block|,
operator|&
name|builtin_type_int
block|,
operator|&
name|builtin_type_char
block|,
operator|&
name|builtin_type_long
block|,
operator|&
name|builtin_type_short
block|,
operator|&
name|builtin_type_unsigned_char
block|,
operator|&
name|builtin_type_unsigned_short
block|,
operator|&
name|builtin_type_unsigned_long
block|,
operator|&
name|builtin_type_unsigned_int
block|,
operator|&
name|builtin_type_float
block|,
operator|&
name|builtin_type_double
block|,
operator|&
name|builtin_type_void
block|,
operator|&
name|builtin_type_long_double
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|os9k_init_type_vector
parameter_list|(
name|struct
name|type
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|os9k_init_type_vector
parameter_list|(
name|struct
name|type
modifier|*
modifier|*
name|tv
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|os9k_type_vector
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
operator|*
argument_list|)
condition|;
name|i
operator|++
control|)
name|tv
index|[
name|i
index|]
operator|=
operator|(
name|os9k_type_vector
index|[
name|i
index|]
operator|==
literal|0
condition|?
literal|0
else|:
operator|*
operator|(
name|os9k_type_vector
index|[
name|i
index|]
operator|)
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Look up a dbx type-number pair.  Return the address of the slot    where the type for that number-pair is stored.    The number-pair is in TYPENUMS.     This can be used for finding the type associated with that pair    or for associating a new type with the pair.  */
end_comment

begin_function
name|struct
name|type
modifier|*
modifier|*
name|dbx_lookup_type
parameter_list|(
name|int
name|typenums
index|[
literal|2
index|]
parameter_list|)
block|{
specifier|register
name|int
name|filenum
init|=
name|typenums
index|[
literal|0
index|]
decl_stmt|;
specifier|register
name|int
name|index
init|=
name|typenums
index|[
literal|1
index|]
decl_stmt|;
name|unsigned
name|old_len
decl_stmt|;
specifier|register
name|int
name|real_filenum
decl_stmt|;
specifier|register
name|struct
name|header_file
modifier|*
name|f
decl_stmt|;
name|int
name|f_orig_length
decl_stmt|;
if|if
condition|(
name|filenum
operator|==
operator|-
literal|1
condition|)
comment|/* -1,-1 is for temporary types.  */
return|return
literal|0
return|;
if|if
condition|(
name|filenum
operator|<
literal|0
operator|||
name|filenum
operator|>=
name|n_this_object_header_files
condition|)
block|{
specifier|static
name|struct
name|complaint
name|msg
init|=
block|{
literal|"\ Invalid symbol data: type number (%d,%d) out of range at symtab pos %d."
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|complain
argument_list|(
operator|&
name|msg
argument_list|,
name|filenum
argument_list|,
name|index
argument_list|,
name|symnum
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
if|if
condition|(
name|filenum
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|index
operator|<
literal|0
condition|)
block|{
comment|/* Caller wants address of address of type.  We think 	     that negative (rs6k builtin) types will never appear as 	     "lvalues", (nor should they), so we stuff the real type 	     pointer into a temp, and return its address.  If referenced, 	     this will do the right thing.  */
specifier|static
name|struct
name|type
modifier|*
name|temp_type
decl_stmt|;
name|temp_type
operator|=
name|rs6000_builtin_type
argument_list|(
name|index
argument_list|)
expr_stmt|;
return|return
operator|&
name|temp_type
return|;
block|}
comment|/* Type is defined outside of header files.          Find it in this object file's type vector.  */
if|if
condition|(
name|index
operator|>=
name|type_vector_length
condition|)
block|{
name|old_len
operator|=
name|type_vector_length
expr_stmt|;
if|if
condition|(
name|old_len
operator|==
literal|0
condition|)
block|{
name|type_vector_length
operator|=
name|INITIAL_TYPE_VECTOR_LENGTH
expr_stmt|;
name|type_vector
operator|=
operator|(
expr|struct
name|type
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|type_vector_length
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|index
operator|>=
name|type_vector_length
condition|)
block|{
name|type_vector_length
operator|*=
literal|2
expr_stmt|;
block|}
name|type_vector
operator|=
operator|(
expr|struct
name|type
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|type_vector
argument_list|,
operator|(
name|type_vector_length
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|type_vector
index|[
name|old_len
index|]
argument_list|,
literal|0
argument_list|,
operator|(
name|type_vector_length
operator|-
name|old_len
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|os9k_stabs
condition|)
comment|/* Deal with OS9000 fundamental types.  */
name|os9k_init_type_vector
argument_list|(
name|type_vector
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|&
name|type_vector
index|[
name|index
index|]
operator|)
return|;
block|}
else|else
block|{
name|real_filenum
operator|=
name|this_object_header_files
index|[
name|filenum
index|]
expr_stmt|;
if|if
condition|(
name|real_filenum
operator|>=
name|N_HEADER_FILES
argument_list|(
name|current_objfile
argument_list|)
condition|)
block|{
name|struct
name|type
modifier|*
name|temp_type
decl_stmt|;
name|struct
name|type
modifier|*
modifier|*
name|temp_type_p
decl_stmt|;
name|warning
argument_list|(
literal|"GDB internal error: bad real_filenum"
argument_list|)
expr_stmt|;
name|error_return
label|:
name|temp_type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_ERROR
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|temp_type_p
operator|=
operator|(
expr|struct
name|type
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|temp_type_p
operator|=
name|temp_type
expr_stmt|;
return|return
name|temp_type_p
return|;
block|}
name|f
operator|=
name|HEADER_FILES
argument_list|(
name|current_objfile
argument_list|)
operator|+
name|real_filenum
expr_stmt|;
name|f_orig_length
operator|=
name|f
operator|->
name|length
expr_stmt|;
if|if
condition|(
name|index
operator|>=
name|f_orig_length
condition|)
block|{
while|while
condition|(
name|index
operator|>=
name|f
operator|->
name|length
condition|)
block|{
name|f
operator|->
name|length
operator|*=
literal|2
expr_stmt|;
block|}
name|f
operator|->
name|vector
operator|=
operator|(
expr|struct
name|type
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|f
operator|->
name|vector
argument_list|,
name|f
operator|->
name|length
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|f
operator|->
name|vector
index|[
name|f_orig_length
index|]
argument_list|,
literal|0
argument_list|,
operator|(
name|f
operator|->
name|length
operator|-
name|f_orig_length
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|&
name|f
operator|->
name|vector
index|[
name|index
index|]
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Make sure there is a type allocated for type numbers TYPENUMS    and return the type object.    This can create an empty (zeroed) type object.    TYPENUMS may be (-1, -1) to return a new type object that is not    put into the type vector, and so may not be referred to by number. */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|dbx_alloc_type
parameter_list|(
name|int
name|typenums
index|[
literal|2
index|]
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
specifier|register
name|struct
name|type
modifier|*
modifier|*
name|type_addr
decl_stmt|;
if|if
condition|(
name|typenums
index|[
literal|0
index|]
operator|==
operator|-
literal|1
condition|)
block|{
return|return
operator|(
name|alloc_type
argument_list|(
name|objfile
argument_list|)
operator|)
return|;
block|}
name|type_addr
operator|=
name|dbx_lookup_type
argument_list|(
name|typenums
argument_list|)
expr_stmt|;
comment|/* If we are referring to a type not known at all yet,      allocate an empty type for it.      We will fill it in later if we find out how.  */
if|if
condition|(
operator|*
name|type_addr
operator|==
literal|0
condition|)
block|{
operator|*
name|type_addr
operator|=
name|alloc_type
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|*
name|type_addr
operator|)
return|;
block|}
end_function

begin_comment
comment|/* for all the stabs in a given stab vector, build appropriate types     and fix their symbols in given symbol vector. */
end_comment

begin_function
specifier|static
name|void
name|patch_block_stabs
parameter_list|(
name|struct
name|pending
modifier|*
name|symbols
parameter_list|,
name|struct
name|pending_stabs
modifier|*
name|stabs
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|int
name|ii
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|pp
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
if|if
condition|(
name|stabs
condition|)
block|{
comment|/* for all the stab entries, find their corresponding symbols and           patch their types! */
for|for
control|(
name|ii
operator|=
literal|0
init|;
name|ii
operator|<
name|stabs
operator|->
name|count
condition|;
operator|++
name|ii
control|)
block|{
name|name
operator|=
name|stabs
operator|->
name|stab
index|[
name|ii
index|]
expr_stmt|;
name|pp
operator|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|name
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
while|while
condition|(
name|pp
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
block|{
name|pp
operator|+=
literal|2
expr_stmt|;
name|pp
operator|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|pp
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
block|}
name|sym
operator|=
name|find_symbol_in_list
argument_list|(
name|symbols
argument_list|,
name|name
argument_list|,
name|pp
operator|-
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sym
condition|)
block|{
comment|/* FIXME-maybe: it would be nice if we noticed whether 	         the variable was defined *anywhere*, not just whether 	         it is defined in this compilation unit.  But neither 	         xlc or GCC seem to need such a definition, and until 	         we do psymtabs (so that the minimal symbols from all 	         compilation units are available now), I'm not sure 	         how to get the information.  */
comment|/* On xcoff, if a global is defined and never referenced, 	         ld will remove it from the executable.  There is then 	         a N_GSYM stab for it, but no regular (C_EXT) symbol.  */
name|sym
operator|=
operator|(
expr|struct
name|symbol
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|sym
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_OPTIMIZED_OUT
expr_stmt|;
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|=
name|obsavestring
argument_list|(
name|name
argument_list|,
name|pp
operator|-
name|name
argument_list|,
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|)
expr_stmt|;
name|pp
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|pp
operator|-
literal|1
operator|)
operator|==
literal|'F'
operator|||
operator|*
operator|(
name|pp
operator|-
literal|1
operator|)
operator|==
literal|'f'
condition|)
block|{
comment|/* I don't think the linker does this with functions, 		     so as far as I know this is never executed. 		     But it doesn't hurt to check.  */
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|lookup_function_type
argument_list|(
name|read_type
argument_list|(
operator|&
name|pp
argument_list|,
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|read_type
argument_list|(
operator|&
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|global_symbols
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pp
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|pp
operator|-
literal|1
operator|)
operator|==
literal|'F'
operator|||
operator|*
operator|(
name|pp
operator|-
literal|1
operator|)
operator|==
literal|'f'
condition|)
block|{
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|lookup_function_type
argument_list|(
name|read_type
argument_list|(
operator|&
name|pp
argument_list|,
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|read_type
argument_list|(
operator|&
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read a number by which a type is referred to in dbx data,    or perhaps read a pair (FILENUM, TYPENUM) in parentheses.    Just a single number N is equivalent to (0,N).    Return the two numbers by storing them in the vector TYPENUMS.    TYPENUMS will then be used as an argument to dbx_lookup_type.     Returns 0 for success, -1 for error.  */
end_comment

begin_function
specifier|static
name|int
name|read_type_number
parameter_list|(
specifier|register
name|char
modifier|*
modifier|*
name|pp
parameter_list|,
specifier|register
name|int
modifier|*
name|typenums
parameter_list|)
block|{
name|int
name|nbits
decl_stmt|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|'('
condition|)
block|{
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
name|typenums
index|[
literal|0
index|]
operator|=
name|read_huge_number
argument_list|(
name|pp
argument_list|,
literal|','
argument_list|,
operator|&
name|nbits
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbits
operator|!=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|typenums
index|[
literal|1
index|]
operator|=
name|read_huge_number
argument_list|(
name|pp
argument_list|,
literal|')'
argument_list|,
operator|&
name|nbits
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbits
operator|!=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
name|typenums
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|typenums
index|[
literal|1
index|]
operator|=
name|read_huge_number
argument_list|(
name|pp
argument_list|,
literal|0
argument_list|,
operator|&
name|nbits
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbits
operator|!=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_define
define|#
directive|define
name|VISIBILITY_PRIVATE
value|'0'
end_define

begin_comment
comment|/* Stabs character for private field */
end_comment

begin_define
define|#
directive|define
name|VISIBILITY_PROTECTED
value|'1'
end_define

begin_comment
comment|/* Stabs character for protected fld */
end_comment

begin_define
define|#
directive|define
name|VISIBILITY_PUBLIC
value|'2'
end_define

begin_comment
comment|/* Stabs character for public field */
end_comment

begin_define
define|#
directive|define
name|VISIBILITY_IGNORE
value|'9'
end_define

begin_comment
comment|/* Optimized out or zero length */
end_comment

begin_define
define|#
directive|define
name|CFRONT_VISIBILITY_PRIVATE
value|'2'
end_define

begin_comment
comment|/* Stabs character for private field */
end_comment

begin_define
define|#
directive|define
name|CFRONT_VISIBILITY_PUBLIC
value|'1'
end_define

begin_comment
comment|/* Stabs character for public field */
end_comment

begin_comment
comment|/* This code added to support parsing of ARM/Cfront stabs strings */
end_comment

begin_comment
comment|/* Get substring from string up to char c, advance string pointer past    suibstring. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|get_substring
parameter_list|(
name|char
modifier|*
modifier|*
name|p
parameter_list|,
name|int
name|c
parameter_list|)
block|{
name|char
modifier|*
name|str
decl_stmt|;
name|str
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|=
name|strchr
argument_list|(
operator|*
name|p
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
block|{
operator|*
operator|*
name|p
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|p
operator|)
operator|++
expr_stmt|;
block|}
else|else
name|str
operator|=
literal|0
expr_stmt|;
return|return
name|str
return|;
block|}
end_function

begin_comment
comment|/* Physname gets strcat'd onto sname in order to recreate the mangled    name (see funtion gdb_mangle_name in gdbtypes.c).  For cfront, make    the physname look like that of g++ - take out the initial mangling    eg: for sname="a" and fname="foo__1aFPFs_i" return "FPFs_i" */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|get_cfront_method_physname
parameter_list|(
name|char
modifier|*
name|fname
parameter_list|)
block|{
name|int
name|len
init|=
literal|0
decl_stmt|;
comment|/* FIXME would like to make this generic for g++ too, but       that is already handled in read_member_funcctions */
name|char
modifier|*
name|p
init|=
name|fname
decl_stmt|;
comment|/* search ahead to find the start of the mangled suffix */
if|if
condition|(
operator|*
name|p
operator|==
literal|'_'
operator|&&
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|==
literal|'_'
condition|)
comment|/* compiler generated; probably a ctor/dtor */
name|p
operator|+=
literal|2
expr_stmt|;
while|while
condition|(
name|p
operator|&&
call|(
name|unsigned
call|)
argument_list|(
operator|(
name|p
operator|+
literal|1
operator|)
operator|-
name|fname
argument_list|)
operator|<
name|strlen
argument_list|(
name|fname
argument_list|)
operator|&&
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|!=
literal|'_'
condition|)
name|p
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'_'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|p
operator|&&
operator|*
name|p
operator|==
literal|'_'
operator|&&
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|==
literal|'_'
operator|)
condition|)
name|error
argument_list|(
literal|"Invalid mangled function name %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
comment|/* advance past '__' */
comment|/* struct name length and name of type should come next; advance past it */
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|len
operator|=
name|len
operator|*
literal|10
operator|+
operator|(
operator|*
name|p
operator|-
literal|'0'
operator|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
name|p
operator|+=
name|len
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Read base classes within cfront class definition.    eg: A:ZcA;1@Bpub v2@Bvirpri;__ct__1AFv func__1AFv *sfunc__1AFv ;as__1A ;;    ^^^^^^^^^^^^^^^^^^     A:ZcA;;foopri__1AFv foopro__1AFv __ct__1AFv __ct__1AFRC1A foopub__1AFv ;;;    ^  */
end_comment

begin_function
specifier|static
name|int
name|read_cfront_baseclasses
parameter_list|(
name|struct
name|field_info
modifier|*
name|fip
parameter_list|,
name|char
modifier|*
modifier|*
name|pp
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
specifier|static
name|struct
name|complaint
name|msg_unknown
init|=
block|{
literal|"\ 	 Unsupported token in stabs string %s.\n"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
specifier|static
name|struct
name|complaint
name|msg_notfound
init|=
block|{
literal|"\ 	           Unable to find base type for %s.\n"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|int
name|bnum
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|nextfield
modifier|*
name|new
decl_stmt|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|';'
condition|)
comment|/* no base classes; return */
block|{
operator|++
operator|(
operator|*
name|pp
operator|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* first count base classes so we can allocate space before parsing */
for|for
control|(
name|p
operator|=
operator|*
name|pp
init|;
name|p
operator|&&
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|';'
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|' '
condition|)
name|bnum
operator|++
expr_stmt|;
block|}
name|bnum
operator|++
expr_stmt|;
comment|/* add one more for last one */
comment|/* now parse the base classes until we get to the start of the methods       (code extracted and munged from read_baseclasses) */
name|ALLOCATE_CPLUS_STRUCT_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
operator|=
name|bnum
expr_stmt|;
comment|/* allocate space */
block|{
name|int
name|num_bytes
init|=
name|B_BYTES
argument_list|(
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
name|char
modifier|*
name|pointer
decl_stmt|;
name|pointer
operator|=
operator|(
name|char
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|type
argument_list|,
name|num_bytes
argument_list|)
expr_stmt|;
name|TYPE_FIELD_VIRTUAL_BITS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
name|B_TYPE
operator|*
operator|)
name|pointer
expr_stmt|;
block|}
name|B_CLRALL
argument_list|(
name|TYPE_FIELD_VIRTUAL_BITS
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|new
operator|=
operator|(
expr|struct
name|nextfield
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nextfield
argument_list|)
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|new
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nextfield
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|fip
operator|->
name|list
expr_stmt|;
name|fip
operator|->
name|list
operator|=
name|new
expr_stmt|;
name|FIELD_BITSIZE
argument_list|(
name|new
operator|->
name|field
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* this should be an unpacked field! */
name|STABS_CONTINUE
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* virtual?  eg: v2@Bvir */
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|'v'
condition|)
block|{
name|SET_TYPE_FIELD_VIRTUAL
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
expr_stmt|;
operator|++
operator|(
operator|*
name|pp
operator|)
expr_stmt|;
block|}
comment|/* access?  eg: 2@Bvir */
comment|/* Note: protected inheritance not supported in cfront */
switch|switch
condition|(
operator|*
operator|(
operator|*
name|pp
operator|)
operator|++
condition|)
block|{
case|case
name|CFRONT_VISIBILITY_PRIVATE
case|:
name|new
operator|->
name|visibility
operator|=
name|VISIBILITY_PRIVATE
expr_stmt|;
break|break;
case|case
name|CFRONT_VISIBILITY_PUBLIC
case|:
name|new
operator|->
name|visibility
operator|=
name|VISIBILITY_PUBLIC
expr_stmt|;
break|break;
default|default:
comment|/* Bad visibility format.  Complain and treat it as 	     public.  */
block|{
specifier|static
name|struct
name|complaint
name|msg
init|=
block|{
literal|"Unknown visibility `%c' for baseclass"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|complain
argument_list|(
operator|&
name|msg
argument_list|,
name|new
operator|->
name|visibility
argument_list|)
expr_stmt|;
name|new
operator|->
name|visibility
operator|=
name|VISIBILITY_PUBLIC
expr_stmt|;
block|}
block|}
comment|/* "@" comes next - eg: @Bvir */
if|if
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|'@'
condition|)
block|{
name|complain
argument_list|(
operator|&
name|msg_unknown
argument_list|,
operator|*
name|pp
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
operator|++
operator|(
operator|*
name|pp
operator|)
expr_stmt|;
comment|/* Set the bit offset of the portion of the object corresponding           to this baseclass.  Always zero in the absence of          multiple inheritance.  */
comment|/* Unable to read bit position from stabs;          Assuming no multiple inheritance for now FIXME! */
comment|/* We may have read this in the structure definition;          now we should fixup the members to be the actual base classes */
name|FIELD_BITPOS
argument_list|(
name|new
operator|->
name|field
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Get the base class name and type */
block|{
name|char
modifier|*
name|bname
decl_stmt|;
comment|/* base class name */
name|struct
name|symbol
modifier|*
name|bsym
decl_stmt|;
comment|/* base class */
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
name|p1
operator|=
name|strchr
argument_list|(
operator|*
name|pp
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|p2
operator|=
name|strchr
argument_list|(
operator|*
name|pp
argument_list|,
literal|';'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
operator|<
name|p2
condition|)
name|bname
operator|=
name|get_substring
argument_list|(
name|pp
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
else|else
name|bname
operator|=
name|get_substring
argument_list|(
name|pp
argument_list|,
literal|';'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bname
operator|||
operator|!
operator|*
name|bname
condition|)
block|{
name|complain
argument_list|(
operator|&
name|msg_unknown
argument_list|,
operator|*
name|pp
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* FIXME! attach base info to type */
name|bsym
operator|=
name|lookup_symbol
argument_list|(
name|bname
argument_list|,
literal|0
argument_list|,
name|STRUCT_NAMESPACE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*demangled_name */
if|if
condition|(
name|bsym
condition|)
block|{
name|new
operator|->
name|field
operator|.
name|type
operator|=
name|SYMBOL_TYPE
argument_list|(
name|bsym
argument_list|)
expr_stmt|;
name|new
operator|->
name|field
operator|.
name|name
operator|=
name|type_name_no_tag
argument_list|(
name|new
operator|->
name|field
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|complain
argument_list|(
operator|&
name|msg_notfound
argument_list|,
operator|*
name|pp
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
comment|/* If more base classes to parse, loop again.          We ate the last ' ' or ';' in get_substring,          so on exit we will have skipped the trailing ';' */
comment|/* if invalid, return 0; add code to detect  - FIXME! */
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* read cfront member functions.    pp points to string starting with list of functions    eg: A:ZcA;1@Bpub v2@Bvirpri;__ct__1AFv func__1AFv *sfunc__1AFv ;as__1A ;;    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^     A:ZcA;;foopri__1AFv foopro__1AFv __ct__1AFv __ct__1AFRC1A foopub__1AFv ;;;    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   */
end_comment

begin_function
specifier|static
name|int
name|read_cfront_member_functions
parameter_list|(
name|struct
name|field_info
modifier|*
name|fip
parameter_list|,
name|char
modifier|*
modifier|*
name|pp
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
comment|/* This code extracted from read_member_functions       so as to do the similar thing for our funcs */
name|int
name|nfn_fields
init|=
literal|0
decl_stmt|;
name|int
name|length
init|=
literal|0
decl_stmt|;
comment|/* Total number of member functions defined in this class.  If the class      defines two `f' functions, and one `g' function, then this will have      the value 3.  */
name|int
name|total_length
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
struct|struct
name|next_fnfield
block|{
name|struct
name|next_fnfield
modifier|*
name|next
decl_stmt|;
name|struct
name|fn_field
name|fn_field
decl_stmt|;
block|}
modifier|*
name|sublist
struct|;
name|struct
name|type
modifier|*
name|look_ahead_type
decl_stmt|;
name|struct
name|next_fnfieldlist
modifier|*
name|new_fnlist
decl_stmt|;
name|struct
name|next_fnfield
modifier|*
name|new_sublist
decl_stmt|;
name|char
modifier|*
name|main_fn_name
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
name|struct
name|symbol
modifier|*
name|ref_func
init|=
literal|0
decl_stmt|;
comment|/* Process each list until we find the end of the member functions.      eg: p = "__ct__1AFv foo__1AFv ;;;" */
name|STABS_CONTINUE
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* handle \\ */
while|while
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|';'
operator|&&
operator|(
name|fname
operator|=
name|get_substring
argument_list|(
name|pp
argument_list|,
literal|' '
argument_list|)
operator|,
name|fname
operator|)
condition|)
block|{
name|int
name|is_static
init|=
literal|0
decl_stmt|;
name|int
name|sublist_count
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|pname
decl_stmt|;
if|if
condition|(
name|fname
index|[
literal|0
index|]
operator|==
literal|'*'
condition|)
comment|/* static member */
block|{
name|is_static
operator|=
literal|1
expr_stmt|;
name|sublist_count
operator|++
expr_stmt|;
name|fname
operator|++
expr_stmt|;
block|}
name|ref_func
operator|=
name|lookup_symbol
argument_list|(
name|fname
argument_list|,
literal|0
argument_list|,
name|VAR_NAMESPACE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* demangled name */
if|if
condition|(
operator|!
name|ref_func
condition|)
block|{
specifier|static
name|struct
name|complaint
name|msg
init|=
block|{
literal|"\       		Unable to find function symbol for %s\n"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|complain
argument_list|(
operator|&
name|msg
argument_list|,
name|fname
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|sublist
operator|=
name|NULL
expr_stmt|;
name|look_ahead_type
operator|=
name|NULL
expr_stmt|;
name|length
operator|=
literal|0
expr_stmt|;
name|new_fnlist
operator|=
operator|(
expr|struct
name|next_fnfieldlist
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|next_fnfieldlist
argument_list|)
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|new_fnlist
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|new_fnlist
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|next_fnfieldlist
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The following is code to work around cfront generated stabs.          The stabs contains full mangled name for each field.          We try to demangle the name and extract the field name out of it.  */
block|{
name|char
modifier|*
name|dem
decl_stmt|,
modifier|*
name|dem_p
decl_stmt|,
modifier|*
name|dem_args
decl_stmt|;
name|int
name|dem_len
decl_stmt|;
name|dem
operator|=
name|cplus_demangle
argument_list|(
name|fname
argument_list|,
name|DMGL_ANSI
operator||
name|DMGL_PARAMS
argument_list|)
expr_stmt|;
if|if
condition|(
name|dem
operator|!=
name|NULL
condition|)
block|{
name|dem_p
operator|=
name|strrchr
argument_list|(
name|dem
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|dem_p
operator|!=
literal|0
operator|&&
operator|*
operator|(
name|dem_p
operator|-
literal|1
operator|)
operator|==
literal|':'
condition|)
name|dem_p
operator|++
expr_stmt|;
comment|/* get rid of args */
name|dem_args
operator|=
name|strchr
argument_list|(
name|dem_p
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
if|if
condition|(
name|dem_args
operator|==
name|NULL
condition|)
name|dem_len
operator|=
name|strlen
argument_list|(
name|dem_p
argument_list|)
expr_stmt|;
else|else
name|dem_len
operator|=
name|dem_args
operator|-
name|dem_p
expr_stmt|;
name|main_fn_name
operator|=
name|obsavestring
argument_list|(
name|dem_p
argument_list|,
name|dem_len
argument_list|,
operator|&
name|objfile
operator|->
name|type_obstack
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|main_fn_name
operator|=
name|obsavestring
argument_list|(
name|fname
argument_list|,
name|strlen
argument_list|(
name|fname
argument_list|)
argument_list|,
operator|&
name|objfile
operator|->
name|type_obstack
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* end of code for cfront work around */
name|new_fnlist
operator|->
name|fn_fieldlist
operator|.
name|name
operator|=
name|main_fn_name
expr_stmt|;
comment|/*-------------------------------------------------*/
comment|/* Set up the sublists          Sublists are stuff like args, static, visibility, etc.          so in ARM, we have to set that info some other way.          Multiple sublists happen if overloading          eg: foo::26=##1;:;2A.;          In g++, we'd loop here thru all the sublists...  */
name|new_sublist
operator|=
operator|(
expr|struct
name|next_fnfield
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|next_fnfield
argument_list|)
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|new_sublist
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|new_sublist
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|next_fnfield
argument_list|)
argument_list|)
expr_stmt|;
comment|/* eat 1; from :;2A.; */
name|new_sublist
operator|->
name|fn_field
operator|.
name|type
operator|=
name|SYMBOL_TYPE
argument_list|(
name|ref_func
argument_list|)
expr_stmt|;
comment|/* normally takes a read_type */
comment|/* Make this type look like a method stub for gdb */
name|TYPE_FLAGS
argument_list|(
name|new_sublist
operator|->
name|fn_field
operator|.
name|type
argument_list|)
operator||=
name|TYPE_FLAG_STUB
expr_stmt|;
name|TYPE_CODE
argument_list|(
name|new_sublist
operator|->
name|fn_field
operator|.
name|type
argument_list|)
operator|=
name|TYPE_CODE_METHOD
expr_stmt|;
comment|/* If this is just a stub, then we don't have the real name here. */
if|if
condition|(
name|TYPE_STUB
argument_list|(
name|new_sublist
operator|->
name|fn_field
operator|.
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|TYPE_DOMAIN_TYPE
argument_list|(
name|new_sublist
operator|->
name|fn_field
operator|.
name|type
argument_list|)
condition|)
name|TYPE_DOMAIN_TYPE
argument_list|(
name|new_sublist
operator|->
name|fn_field
operator|.
name|type
argument_list|)
operator|=
name|type
expr_stmt|;
name|new_sublist
operator|->
name|fn_field
operator|.
name|is_stub
operator|=
literal|1
expr_stmt|;
block|}
comment|/* physname used later in mangling; eg PFs_i,5 for foo__1aFPFs_i           physname gets strcat'd in order to recreate the onto mangled name */
name|pname
operator|=
name|get_cfront_method_physname
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|new_sublist
operator|->
name|fn_field
operator|.
name|physname
operator|=
name|savestring
argument_list|(
name|pname
argument_list|,
name|strlen
argument_list|(
name|pname
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set this member function's visibility fields.           Unable to distinguish access from stabs definition!          Assuming public for now.  FIXME!          (for private, set new_sublist->fn_field.is_private = 1,          for public, set new_sublist->fn_field.is_protected = 1) */
comment|/* Unable to distinguish const/volatile from stabs definition!          Assuming normal for now.  FIXME! */
name|new_sublist
operator|->
name|fn_field
operator|.
name|is_const
operator|=
literal|0
expr_stmt|;
name|new_sublist
operator|->
name|fn_field
operator|.
name|is_volatile
operator|=
literal|0
expr_stmt|;
comment|/* volatile not implemented in cfront */
comment|/* Set virtual/static function info          How to get vtable offsets ?           Assuming normal for now FIXME!!           For vtables, figure out from whence this virtual function came.          It may belong to virtual function table of          one of its baseclasses.          set:          new_sublist -> fn_field.voffset = vtable offset,          new_sublist -> fn_field.fcontext = look_ahead_type;          where look_ahead_type is type of baseclass */
if|if
condition|(
name|is_static
condition|)
name|new_sublist
operator|->
name|fn_field
operator|.
name|voffset
operator|=
name|VOFFSET_STATIC
expr_stmt|;
else|else
comment|/* normal member function.  */
name|new_sublist
operator|->
name|fn_field
operator|.
name|voffset
operator|=
literal|0
expr_stmt|;
name|new_sublist
operator|->
name|fn_field
operator|.
name|fcontext
operator|=
literal|0
expr_stmt|;
comment|/* Prepare new sublist */
name|new_sublist
operator|->
name|next
operator|=
name|sublist
expr_stmt|;
name|sublist
operator|=
name|new_sublist
expr_stmt|;
name|length
operator|++
expr_stmt|;
comment|/* In g++, we loop thu sublists - now we set from functions. */
name|new_fnlist
operator|->
name|fn_fieldlist
operator|.
name|fn_fields
operator|=
operator|(
expr|struct
name|fn_field
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|type_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|fn_field
argument_list|)
operator|*
name|length
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|new_fnlist
operator|->
name|fn_fieldlist
operator|.
name|fn_fields
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|fn_field
argument_list|)
operator|*
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|length
init|;
operator|(
name|i
operator|--
operator|,
name|sublist
operator|)
condition|;
name|sublist
operator|=
name|sublist
operator|->
name|next
control|)
block|{
name|new_fnlist
operator|->
name|fn_fieldlist
operator|.
name|fn_fields
index|[
name|i
index|]
operator|=
name|sublist
operator|->
name|fn_field
expr_stmt|;
block|}
name|new_fnlist
operator|->
name|fn_fieldlist
operator|.
name|length
operator|=
name|length
expr_stmt|;
name|new_fnlist
operator|->
name|next
operator|=
name|fip
operator|->
name|fnlist
expr_stmt|;
name|fip
operator|->
name|fnlist
operator|=
name|new_fnlist
expr_stmt|;
name|nfn_fields
operator|++
expr_stmt|;
name|total_length
operator|+=
name|length
expr_stmt|;
name|STABS_CONTINUE
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* handle \\ */
block|}
comment|/* end of loop */
if|if
condition|(
name|nfn_fields
condition|)
block|{
comment|/* type should already have space */
name|TYPE_FN_FIELDLISTS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
expr|struct
name|fn_fieldlist
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|type
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|fn_fieldlist
argument_list|)
operator|*
name|nfn_fields
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|TYPE_FN_FIELDLISTS
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|fn_fieldlist
argument_list|)
operator|*
name|nfn_fields
argument_list|)
expr_stmt|;
name|TYPE_NFN_FIELDS
argument_list|(
name|type
argument_list|)
operator|=
name|nfn_fields
expr_stmt|;
name|TYPE_NFN_FIELDS_TOTAL
argument_list|(
name|type
argument_list|)
operator|=
name|total_length
expr_stmt|;
block|}
comment|/* end of scope for reading member func */
comment|/* eg: ";;" */
comment|/* Skip trailing ';' and bump count of number of fields seen */
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|';'
condition|)
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
else|else
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* This routine fixes up partial cfront types that were created    while parsing the stabs.  The main need for this function is    to add information such as methods to classes.    Examples of "p": "sA;;__ct__1AFv foo__1AFv ;;;" */
end_comment

begin_function
name|int
name|resolve_cfront_continuation
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|,
name|struct
name|symbol
modifier|*
name|sym
parameter_list|,
name|char
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|symbol
modifier|*
name|ref_sym
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|sname
decl_stmt|;
comment|/* snarfed from read_struct_type */
name|struct
name|field_info
name|fi
decl_stmt|;
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|back_to
decl_stmt|;
comment|/* Need to make sure that fi isn't gunna conflict with struct       in case struct already had some fnfs */
name|fi
operator|.
name|list
operator|=
name|NULL
expr_stmt|;
name|fi
operator|.
name|fnlist
operator|=
name|NULL
expr_stmt|;
name|back_to
operator|=
name|make_cleanup
argument_list|(
name|null_cleanup
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* We only accept structs, classes and unions at the moment.       Other continuation types include t (typedef), r (long dbl), ...       We may want to add support for them as well;       right now they are handled by duplicating the symbol information       into the type information (see define_symbol) */
if|if
condition|(
operator|*
name|p
operator|!=
literal|'s'
comment|/* structs */
operator|&&
operator|*
name|p
operator|!=
literal|'c'
comment|/* class */
operator|&&
operator|*
name|p
operator|!=
literal|'u'
condition|)
comment|/* union */
return|return
literal|0
return|;
comment|/* only handle C++ types */
name|p
operator|++
expr_stmt|;
comment|/* Get symbol typs name and validate       eg: p = "A;;__ct__1AFv foo__1AFv ;;;" */
name|sname
operator|=
name|get_substring
argument_list|(
operator|&
name|p
argument_list|,
literal|';'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sname
operator|||
name|strcmp
argument_list|(
name|sname
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
condition|)
name|error
argument_list|(
literal|"Internal error: base symbol type name does not match\n"
argument_list|)
expr_stmt|;
comment|/* Find symbol's internal gdb reference using demangled_name.      This is the real sym that we want;       sym was a temp hack to make debugger happy */
name|ref_sym
operator|=
name|lookup_symbol
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
literal|0
argument_list|,
name|STRUCT_NAMESPACE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|type
operator|=
name|SYMBOL_TYPE
argument_list|(
name|ref_sym
argument_list|)
expr_stmt|;
comment|/* Now read the baseclasses, if any, read the regular C struct or C++      class member fields, attach the fields to the type, read the C++      member functions, attach them to the type, and then read any tilde      field (baseclass specifier for the class holding the main vtable). */
if|if
condition|(
operator|!
name|read_cfront_baseclasses
argument_list|(
operator|&
name|fi
argument_list|,
operator|&
name|p
argument_list|,
name|type
argument_list|,
name|objfile
argument_list|)
comment|/* g++ does this next, but cfront already did this:       || !read_struct_fields (&fi,&p, type, objfile) */
operator|||
operator|!
name|copy_cfront_struct_fields
argument_list|(
operator|&
name|fi
argument_list|,
name|type
argument_list|,
name|objfile
argument_list|)
operator|||
operator|!
name|read_cfront_member_functions
argument_list|(
operator|&
name|fi
argument_list|,
operator|&
name|p
argument_list|,
name|type
argument_list|,
name|objfile
argument_list|)
operator|||
operator|!
name|read_cfront_static_fields
argument_list|(
operator|&
name|fi
argument_list|,
operator|&
name|p
argument_list|,
name|type
argument_list|,
name|objfile
argument_list|)
operator|||
operator|!
name|attach_fields_to_type
argument_list|(
operator|&
name|fi
argument_list|,
name|type
argument_list|,
name|objfile
argument_list|)
operator|||
operator|!
name|attach_fn_fields_to_type
argument_list|(
operator|&
name|fi
argument_list|,
name|type
argument_list|)
comment|/* g++ does this next, but cfront doesn't seem to have this:       || !read_tilde_fields (&fi,&p, type, objfile) */
condition|)
block|{
name|type
operator|=
name|error_type
argument_list|(
operator|&
name|p
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
name|do_cleanups
argument_list|(
name|back_to
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* End of code added to support parsing of ARM/Cfront stabs strings */
end_comment

begin_comment
comment|/* This routine fixes up symbol references/aliases to point to the original    symbol definition.  Returns 0 on failure, non-zero on success.  */
end_comment

begin_function
specifier|static
name|int
name|resolve_symbol_reference
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|,
name|struct
name|symbol
modifier|*
name|sym
parameter_list|,
name|char
modifier|*
name|p
parameter_list|)
block|{
name|int
name|refnum
decl_stmt|;
name|struct
name|symbol
modifier|*
name|ref_sym
init|=
literal|0
decl_stmt|;
name|struct
name|alias_list
modifier|*
name|alias
decl_stmt|;
comment|/* If this is not a symbol reference return now.  */
if|if
condition|(
operator|*
name|p
operator|!=
literal|'#'
condition|)
return|return
literal|0
return|;
comment|/* Use "#<num>" as the name; we'll fix the name later.      We stored the original symbol name as "#<id>=<name>"      so we can now search for "#<id>" to resolving the reference.      We'll fix the names later by removing the "#<id>" or "#<id>=" */
comment|/*---------------------------------------------------------*/
comment|/* Get the reference id number, and       advance p past the names so we can parse the rest.       eg: id=2 for p : "2=", "2=z:r(0,1)" "2:r(0,1);l(#5,#6),l(#7,#4)" */
comment|/*---------------------------------------------------------*/
comment|/* This gets reference name from string.  sym may not have a name. */
comment|/* Get the reference number associated with the reference id in the      gdb stab string.  From that reference number, get the main/primary      symbol for this alias.  */
name|refnum
operator|=
name|process_reference
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
name|ref_sym
operator|=
name|ref_search
argument_list|(
name|refnum
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ref_sym
condition|)
block|{
name|complain
argument_list|(
operator|&
name|lrs_general_complaint
argument_list|,
literal|"symbol for reference not found"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Parse the stab of the referencing symbol      now that we have the referenced symbol.      Add it as a new symbol and a link back to the referenced symbol.      eg: p : "=", "=z:r(0,1)" ":r(0,1);l(#5,#6),l(#7,#4)" */
comment|/* If the stab symbol table and string contain:      RSYM   0      5      00000000 868    #15=z:r(0,1)      LBRAC  0      0      00000000 899    #5=      SLINE  0      16     00000003 923    #6=      Then the same symbols can be later referenced by:      RSYM   0      5      00000000 927    #15:r(0,1);l(#5,#6)      This is used in live range splitting to:      1) specify that a symbol (#15) is actually just a new storage       class for a symbol (#15=z) which was previously defined.      2) specify that the beginning and ending ranges for a symbol       (#15) are the values of the beginning (#5) and ending (#6)       symbols. */
comment|/* Read number as reference id.      eg: p : "=", "=z:r(0,1)" ":r(0,1);l(#5,#6),l(#7,#4)" */
comment|/* FIXME! Might I want to use SYMBOL_CLASS (sym) = LOC_OPTIMIZED_OUT;      in case of "l(0,0)"? */
comment|/*--------------------------------------------------*/
comment|/* Add this symbol to the reference list.           */
comment|/*--------------------------------------------------*/
name|alias
operator|=
operator|(
expr|struct
name|alias_list
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|type_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|alias_list
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|alias
condition|)
block|{
name|complain
argument_list|(
operator|&
name|lrs_general_complaint
argument_list|,
literal|"Unable to allocate alias list memory"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|alias
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|alias
operator|->
name|sym
operator|=
name|sym
expr_stmt|;
if|if
condition|(
operator|!
name|SYMBOL_ALIASES
argument_list|(
name|ref_sym
argument_list|)
condition|)
block|{
name|SYMBOL_ALIASES
argument_list|(
name|ref_sym
argument_list|)
operator|=
name|alias
expr_stmt|;
block|}
else|else
block|{
name|struct
name|alias_list
modifier|*
name|temp
decl_stmt|;
comment|/* Get to the end of the list.  */
for|for
control|(
name|temp
operator|=
name|SYMBOL_ALIASES
argument_list|(
name|ref_sym
argument_list|)
init|;
name|temp
operator|->
name|next
condition|;
name|temp
operator|=
name|temp
operator|->
name|next
control|)
empty_stmt|;
name|temp
operator|->
name|next
operator|=
name|alias
expr_stmt|;
block|}
comment|/* Want to fix up name so that other functions (eg. valops)      will correctly print the name.      Don't add_symbol_to_list so that lookup_symbol won't find it.      nope... needed for fixups. */
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|=
name|SYMBOL_NAME
argument_list|(
name|ref_sym
argument_list|)
expr_stmt|;
comment|/* Done!  */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Structure for storing pointers to reference definitions for fast lookup     during "process_later". */
end_comment

begin_struct
struct|struct
name|ref_map
block|{
name|char
modifier|*
name|stabs
decl_stmt|;
name|CORE_ADDR
name|value
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|MAX_CHUNK_REFS
value|100
end_define

begin_define
define|#
directive|define
name|REF_CHUNK_SIZE
value|(MAX_CHUNK_REFS * sizeof (struct ref_map))
end_define

begin_define
define|#
directive|define
name|REF_MAP_SIZE
parameter_list|(
name|ref_chunk
parameter_list|)
value|((ref_chunk) * REF_CHUNK_SIZE)
end_define

begin_decl_stmt
specifier|static
name|struct
name|ref_map
modifier|*
name|ref_map
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Ptr to free cell in chunk's linked list. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ref_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of chunks malloced. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ref_chunk
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This file maintains a cache of stabs aliases found in the symbol    table. If the symbol table changes, this cache must be cleared    or we are left holding onto data in invalid obstacks. */
end_comment

begin_function
name|void
name|stabsread_clear_cache
parameter_list|(
name|void
parameter_list|)
block|{
name|ref_count
operator|=
literal|0
expr_stmt|;
name|ref_chunk
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create array of pointers mapping refids to symbols and stab strings.    Add pointers to reference definition symbols and/or their values as we     find them, using their reference numbers as our index.     These will be used later when we resolve references. */
end_comment

begin_function
name|void
name|ref_add
parameter_list|(
name|int
name|refnum
parameter_list|,
name|struct
name|symbol
modifier|*
name|sym
parameter_list|,
name|char
modifier|*
name|stabs
parameter_list|,
name|CORE_ADDR
name|value
parameter_list|)
block|{
if|if
condition|(
name|ref_count
operator|==
literal|0
condition|)
name|ref_chunk
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|refnum
operator|>=
name|ref_count
condition|)
name|ref_count
operator|=
name|refnum
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|ref_count
operator|>
name|ref_chunk
operator|*
name|MAX_CHUNK_REFS
condition|)
block|{
name|int
name|new_slots
init|=
name|ref_count
operator|-
name|ref_chunk
operator|*
name|MAX_CHUNK_REFS
decl_stmt|;
name|int
name|new_chunks
init|=
name|new_slots
operator|/
name|MAX_CHUNK_REFS
operator|+
literal|1
decl_stmt|;
name|ref_map
operator|=
operator|(
expr|struct
name|ref_map
operator|*
operator|)
name|xrealloc
argument_list|(
name|ref_map
argument_list|,
name|REF_MAP_SIZE
argument_list|(
name|ref_chunk
operator|+
name|new_chunks
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|ref_map
operator|+
name|ref_chunk
operator|*
name|MAX_CHUNK_REFS
argument_list|,
literal|0
argument_list|,
name|new_chunks
operator|*
name|REF_CHUNK_SIZE
argument_list|)
expr_stmt|;
name|ref_chunk
operator|+=
name|new_chunks
expr_stmt|;
block|}
name|ref_map
index|[
name|refnum
index|]
operator|.
name|stabs
operator|=
name|stabs
expr_stmt|;
name|ref_map
index|[
name|refnum
index|]
operator|.
name|sym
operator|=
name|sym
expr_stmt|;
name|ref_map
index|[
name|refnum
index|]
operator|.
name|value
operator|=
name|value
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return defined sym for the reference REFNUM.  */
end_comment

begin_function
name|struct
name|symbol
modifier|*
name|ref_search
parameter_list|(
name|int
name|refnum
parameter_list|)
block|{
if|if
condition|(
name|refnum
operator|<
literal|0
operator|||
name|refnum
operator|>
name|ref_count
condition|)
return|return
literal|0
return|;
return|return
name|ref_map
index|[
name|refnum
index|]
operator|.
name|sym
return|;
block|}
end_function

begin_comment
comment|/* Return value for the reference REFNUM.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|ref_search_value
parameter_list|(
name|int
name|refnum
parameter_list|)
block|{
if|if
condition|(
name|refnum
operator|<
literal|0
operator|||
name|refnum
operator|>
name|ref_count
condition|)
return|return
literal|0
return|;
return|return
name|ref_map
index|[
name|refnum
index|]
operator|.
name|value
return|;
block|}
end_function

begin_comment
comment|/* Parse a reference id in STRING and return the resulting    reference number.  Move STRING beyond the reference id.  */
end_comment

begin_function
specifier|static
name|int
name|process_reference
parameter_list|(
name|char
modifier|*
modifier|*
name|string
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|refnum
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|*
operator|*
name|string
operator|!=
literal|'#'
condition|)
return|return
literal|0
return|;
comment|/* Advance beyond the initial '#'.  */
name|p
operator|=
operator|*
name|string
operator|+
literal|1
expr_stmt|;
comment|/* Read number as reference id. */
while|while
condition|(
operator|*
name|p
operator|&&
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|refnum
operator|=
name|refnum
operator|*
literal|10
operator|+
operator|*
name|p
operator|-
literal|'0'
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
operator|*
name|string
operator|=
name|p
expr_stmt|;
return|return
name|refnum
return|;
block|}
end_function

begin_comment
comment|/* If STRING defines a reference, store away a pointer to the reference     definition for later use.  Return the reference number.  */
end_comment

begin_function
name|int
name|symbol_reference_defined
parameter_list|(
name|char
modifier|*
modifier|*
name|string
parameter_list|)
block|{
name|char
modifier|*
name|p
init|=
operator|*
name|string
decl_stmt|;
name|int
name|refnum
init|=
literal|0
decl_stmt|;
name|refnum
operator|=
name|process_reference
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
comment|/* Defining symbols end in '=' */
if|if
condition|(
operator|*
name|p
operator|==
literal|'='
condition|)
block|{
comment|/* Symbol is being defined here. */
operator|*
name|string
operator|=
name|p
operator|+
literal|1
expr_stmt|;
return|return
name|refnum
return|;
block|}
else|else
block|{
comment|/* Must be a reference.   Either the symbol has already been defined,          or this is a forward reference to it.  */
operator|*
name|string
operator|=
name|p
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|struct
name|symbol
modifier|*
name|define_symbol
parameter_list|(
name|CORE_ADDR
name|valu
parameter_list|,
name|char
modifier|*
name|string
parameter_list|,
name|int
name|desc
parameter_list|,
name|int
name|type
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
specifier|register
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|char
modifier|*
name|p
init|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|string
argument_list|,
literal|':'
argument_list|)
decl_stmt|;
name|int
name|deftype
decl_stmt|;
name|int
name|synonym
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* We would like to eliminate nameless symbols, but keep their types.      E.g. stab entry ":t10=*2" should produce a type 10, which is a pointer      to type 2, but, should not create a symbol to address that type. Since      the symbol will be nameless, there is no way any user can refer to it. */
name|int
name|nameless
decl_stmt|;
comment|/* Ignore syms with empty names.  */
if|if
condition|(
name|string
index|[
literal|0
index|]
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Ignore old-style symbols from cc -go  */
if|if
condition|(
name|p
operator|==
literal|0
condition|)
return|return
literal|0
return|;
while|while
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
block|{
name|p
operator|+=
literal|2
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
block|}
comment|/* If a nameless stab entry, all we need is the type, not the symbol.      e.g. ":t10=*2" or a nameless enum like " :T16=ered:0,green:1,blue:2,;" */
name|nameless
operator|=
operator|(
name|p
operator|==
name|string
operator|||
operator|(
operator|(
name|string
index|[
literal|0
index|]
operator|==
literal|' '
operator|)
operator|&&
operator|(
name|string
index|[
literal|1
index|]
operator|==
literal|':'
operator|)
operator|)
operator|)
expr_stmt|;
name|current_symbol
operator|=
name|sym
operator|=
operator|(
expr|struct
name|symbol
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|sym
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
operator|&
name|N_TYPE
condition|)
block|{
case|case
name|N_TEXT
case|:
name|SYMBOL_SECTION
argument_list|(
name|sym
argument_list|)
operator|=
name|SECT_OFF_TEXT
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_DATA
case|:
name|SYMBOL_SECTION
argument_list|(
name|sym
argument_list|)
operator|=
name|SECT_OFF_DATA
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_BSS
case|:
name|SYMBOL_SECTION
argument_list|(
name|sym
argument_list|)
operator|=
name|SECT_OFF_BSS
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|processing_gcc_compilation
condition|)
block|{
comment|/* GCC 2.x puts the line number in desc.  SunOS apparently puts in the          number of bytes occupied by a type or object, which we ignore.  */
name|SYMBOL_LINE
argument_list|(
name|sym
argument_list|)
operator|=
name|desc
expr_stmt|;
block|}
else|else
block|{
name|SYMBOL_LINE
argument_list|(
name|sym
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* unknown */
block|}
if|if
condition|(
name|is_cplus_marker
argument_list|(
name|string
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
comment|/* Special GNU C++ names.  */
switch|switch
condition|(
name|string
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'t'
case|:
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|=
name|obsavestring
argument_list|(
literal|"this"
argument_list|,
name|strlen
argument_list|(
literal|"this"
argument_list|)
argument_list|,
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
comment|/* $vtbl_ptr_type */
comment|/* Was: SYMBOL_NAME (sym) = "vptr"; */
goto|goto
name|normal
goto|;
case|case
literal|'e'
case|:
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|=
name|obsavestring
argument_list|(
literal|"eh_throw"
argument_list|,
name|strlen
argument_list|(
literal|"eh_throw"
argument_list|)
argument_list|,
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'_'
case|:
comment|/* This was an anonymous type that was never fixed up.  */
goto|goto
name|normal
goto|;
ifdef|#
directive|ifdef
name|STATIC_TRANSFORM_NAME
case|case
literal|'X'
case|:
comment|/* SunPRO (3.0 at least) static variable encoding.  */
goto|goto
name|normal
goto|;
endif|#
directive|endif
default|default:
name|complain
argument_list|(
operator|&
name|unrecognized_cplus_name_complaint
argument_list|,
name|string
argument_list|)
expr_stmt|;
goto|goto
name|normal
goto|;
comment|/* Do *something* with it */
block|}
block|}
elseif|else
if|if
condition|(
name|string
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
block|{
comment|/* Special GNU C extension for referencing symbols.  */
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|refnum
decl_stmt|,
name|nlen
decl_stmt|;
comment|/* If STRING defines a new reference id, then add it to the          reference map.  Else it must be referring to a previously          defined symbol, so add it to the alias list of the previously          defined symbol.  */
name|s
operator|=
name|string
expr_stmt|;
name|refnum
operator|=
name|symbol_reference_defined
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|refnum
operator|>=
literal|0
condition|)
name|ref_add
argument_list|(
name|refnum
argument_list|,
name|sym
argument_list|,
name|string
argument_list|,
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|resolve_symbol_reference
argument_list|(
name|objfile
argument_list|,
name|sym
argument_list|,
name|string
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* S..P contains the name of the symbol.  We need to store          the correct name into SYMBOL_NAME.  */
name|nlen
operator|=
name|p
operator|-
name|s
expr_stmt|;
if|if
condition|(
name|refnum
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|nlen
operator|>
literal|0
condition|)
block|{
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|,
name|nlen
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|s
argument_list|,
name|nlen
argument_list|)
expr_stmt|;
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
index|[
name|nlen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|SYMBOL_INIT_DEMANGLED_NAME
argument_list|(
name|sym
argument_list|,
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* FIXME! Want SYMBOL_NAME (sym) = 0; 	       Get error if leave name 0.  So give it something. */
block|{
name|nlen
operator|=
name|p
operator|-
name|string
expr_stmt|;
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|,
name|nlen
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|string
argument_list|,
name|nlen
argument_list|)
expr_stmt|;
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
index|[
name|nlen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|SYMBOL_INIT_DEMANGLED_NAME
argument_list|(
name|sym
argument_list|,
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Advance STRING beyond the reference id.  */
name|string
operator|=
name|s
expr_stmt|;
block|}
else|else
block|{
name|normal
label|:
name|SYMBOL_LANGUAGE
argument_list|(
name|sym
argument_list|)
operator|=
name|current_subfile
operator|->
name|language
expr_stmt|;
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|,
operator|(
operator|(
name|p
operator|-
name|string
operator|)
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
comment|/* Open-coded memcpy--saves function call time.  */
comment|/* FIXME:  Does it really?  Try replacing with simple strcpy and          try it on an executable with a large symbol table. */
comment|/* FIXME: considering that gcc can open code memcpy anyway, I          doubt it.  xoxorich. */
block|{
specifier|register
name|char
modifier|*
name|p1
init|=
name|string
decl_stmt|;
specifier|register
name|char
modifier|*
name|p2
init|=
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
decl_stmt|;
while|while
condition|(
name|p1
operator|!=
name|p
condition|)
block|{
operator|*
name|p2
operator|++
operator|=
operator|*
name|p1
operator|++
expr_stmt|;
block|}
operator|*
name|p2
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* If this symbol is from a C++ compilation, then attempt to cache the          demangled form for future reference.  This is a typical time versus          space tradeoff, that was decided in favor of time because it sped up          C++ symbol lookups by a factor of about 20. */
name|SYMBOL_INIT_DEMANGLED_NAME
argument_list|(
name|sym
argument_list|,
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|)
expr_stmt|;
block|}
name|p
operator|++
expr_stmt|;
comment|/* Determine the type of name being defined.  */
if|#
directive|if
literal|0
comment|/* Getting GDB to correctly skip the symbol on an undefined symbol      descriptor and not ever dump core is a very dodgy proposition if      we do things this way.  I say the acorn RISC machine can just      fix their compiler.  */
comment|/* The Acorn RISC machine's compiler can put out locals that don't      start with "234=" or "(3,4)=", so assume anything other than the      deftypes we know how to handle is a local.  */
block|if (!strchr ("cfFGpPrStTvVXCR", *p))
else|#
directive|else
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|'('
operator|||
operator|*
name|p
operator|==
literal|'-'
condition|)
endif|#
directive|endif
name|deftype
operator|=
literal|'l'
expr_stmt|;
else|else
name|deftype
operator|=
operator|*
name|p
operator|++
expr_stmt|;
switch|switch
condition|(
name|deftype
condition|)
block|{
case|case
literal|'c'
case|:
comment|/* c is a special case, not followed by a type-number.          SYMBOL:c=iVALUE for an integer constant symbol.          SYMBOL:c=rVALUE for a floating constant symbol.          SYMBOL:c=eTYPE,INTVALUE for an enum constant symbol.          e.g. "b:c=e6,0" for "const b = blob1"          (where type 6 is defined by "blobs:t6=eblob1:0,blob2:1,;").  */
if|if
condition|(
operator|*
name|p
operator|!=
literal|'='
condition|)
block|{
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_CONST
expr_stmt|;
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|error_type
argument_list|(
operator|&
name|p
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|file_symbols
argument_list|)
expr_stmt|;
return|return
name|sym
return|;
block|}
operator|++
name|p
expr_stmt|;
switch|switch
condition|(
operator|*
name|p
operator|++
condition|)
block|{
case|case
literal|'r'
case|:
block|{
name|double
name|d
init|=
name|atof
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|char
modifier|*
name|dbl_valu
decl_stmt|;
comment|/* FIXME-if-picky-about-floating-accuracy: Should be using 	       target arithmetic to get the value.  real.c in GCC 	       probably has the necessary code.  */
comment|/* FIXME: lookup_fundamental_type is a hack.  We should be 	       creating a type especially for the type of float constants. 	       Problem is, what type should it be?  	       Also, what should the name of this type be?  Should we 	       be using 'S' constants (see stabs.texinfo) instead?  */
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|lookup_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_DBL_PREC_FLOAT
argument_list|)
expr_stmt|;
name|dbl_valu
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|store_typed_floating
argument_list|(
name|dbl_valu
argument_list|,
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|SYMBOL_VALUE_BYTES
argument_list|(
name|sym
argument_list|)
operator|=
name|dbl_valu
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_CONST_BYTES
expr_stmt|;
block|}
break|break;
case|case
literal|'i'
case|:
block|{
comment|/* Defining integer constants this way is kind of silly, 	       since 'e' constants allows the compiler to give not 	       only the value, but the type as well.  C has at least 	       int, long, unsigned int, and long long as constant 	       types; other languages probably should have at least 	       unsigned as well as signed constants.  */
comment|/* We just need one int constant type for all objfiles. 	       It doesn't depend on languages or anything (arguably its 	       name should be a language-specific name for a type of 	       that size, but I'm inclined to say that if the compiler 	       wants a nice name for the type, it can use 'e').  */
specifier|static
name|struct
name|type
modifier|*
name|int_const_type
decl_stmt|;
comment|/* Yes, this is as long as a *host* int.  That is because we 	       use atoi.  */
if|if
condition|(
name|int_const_type
operator|==
name|NULL
condition|)
name|int_const_type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|HOST_CHAR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"integer constant"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|int_const_type
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|atoi
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_CONST
expr_stmt|;
block|}
break|break;
case|case
literal|'e'
case|:
comment|/* SYMBOL:c=eTYPE,INTVALUE for a constant symbol whose value 	     can be represented as integral. 	     e.g. "b:c=e6,0" for "const b = blob1" 	     (where type 6 is defined by "blobs:t6=eblob1:0,blob2:1,;").  */
block|{
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_CONST
expr_stmt|;
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|read_type
argument_list|(
operator|&
name|p
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|','
condition|)
block|{
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|error_type
argument_list|(
operator|&
name|p
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
block|}
operator|++
name|p
expr_stmt|;
comment|/* If the value is too big to fit in an int (perhaps because 	       it is unsigned), or something like that, we silently get 	       a bogus value.  The type and everything else about it is 	       correct.  Ideally, we should be using whatever we have 	       available for parsing unsigned and long long values, 	       however.  */
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|atoi
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
block|{
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_CONST
expr_stmt|;
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|error_type
argument_list|(
operator|&
name|p
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
block|}
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|file_symbols
argument_list|)
expr_stmt|;
return|return
name|sym
return|;
case|case
literal|'C'
case|:
comment|/* The name of a caught exception.  */
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|read_type
argument_list|(
operator|&
name|p
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_LABEL
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym
argument_list|)
operator|=
name|valu
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|local_symbols
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* A static function definition.  */
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|read_type
argument_list|(
operator|&
name|p
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_BLOCK
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|file_symbols
argument_list|)
expr_stmt|;
comment|/* fall into process_function_types.  */
name|process_function_types
label|:
comment|/* Function result types are described as the result type in stabs.          We need to convert this to the function-returning-type-X type          in GDB.  E.g. "int" is converted to "function returning int".  */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|!=
name|TYPE_CODE_FUNC
condition|)
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|lookup_function_type
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
comment|/* All functions in C++ have prototypes.  */
if|if
condition|(
name|SYMBOL_LANGUAGE
argument_list|(
name|sym
argument_list|)
operator|==
name|language_cplus
condition|)
name|TYPE_FLAGS
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator||=
name|TYPE_FLAG_PROTOTYPED
expr_stmt|;
comment|/* fall into process_prototype_types */
name|process_prototype_types
label|:
comment|/* Sun acc puts declared types of arguments here.  */
if|if
condition|(
operator|*
name|p
operator|==
literal|';'
condition|)
block|{
name|struct
name|type
modifier|*
name|ftype
init|=
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
decl_stmt|;
name|int
name|nsemi
init|=
literal|0
decl_stmt|;
name|int
name|nparams
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|p1
init|=
name|p
decl_stmt|;
comment|/* Obtain a worst case guess for the number of arguments 	     by counting the semicolons.  */
while|while
condition|(
operator|*
name|p1
condition|)
block|{
if|if
condition|(
operator|*
name|p1
operator|++
operator|==
literal|';'
condition|)
name|nsemi
operator|++
expr_stmt|;
block|}
comment|/* Allocate parameter information fields and fill them in. */
name|TYPE_FIELDS
argument_list|(
name|ftype
argument_list|)
operator|=
operator|(
expr|struct
name|field
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|ftype
argument_list|,
name|nsemi
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|++
operator|==
literal|';'
condition|)
block|{
name|struct
name|type
modifier|*
name|ptype
decl_stmt|;
comment|/* A type number of zero indicates the start of varargs. 	         FIXME: GDB currently ignores vararg functions.  */
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'0'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
break|break;
name|ptype
operator|=
name|read_type
argument_list|(
operator|&
name|p
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* The Sun compilers mark integer arguments, which should 	         be promoted to the width of the calling conventions, with 	         a type which references itself. This type is turned into 	         a TYPE_CODE_VOID type by read_type, and we have to turn 	         it back into builtin_type_int here. 	         FIXME: Do we need a new builtin_type_promoted_int_arg ?  */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|ptype
argument_list|)
operator|==
name|TYPE_CODE_VOID
condition|)
name|ptype
operator|=
name|builtin_type_int
expr_stmt|;
name|TYPE_FIELD_TYPE
argument_list|(
name|ftype
argument_list|,
name|nparams
argument_list|)
operator|=
name|ptype
expr_stmt|;
name|TYPE_FIELD_ARTIFICIAL
argument_list|(
name|ftype
argument_list|,
name|nparams
operator|++
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
name|TYPE_NFIELDS
argument_list|(
name|ftype
argument_list|)
operator|=
name|nparams
expr_stmt|;
name|TYPE_FLAGS
argument_list|(
name|ftype
argument_list|)
operator||=
name|TYPE_FLAG_PROTOTYPED
expr_stmt|;
block|}
break|break;
case|case
literal|'F'
case|:
comment|/* A global function definition.  */
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|read_type
argument_list|(
operator|&
name|p
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_BLOCK
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|global_symbols
argument_list|)
expr_stmt|;
goto|goto
name|process_function_types
goto|;
case|case
literal|'G'
case|:
comment|/* For a class G (global) symbol, it appears that the          value is not correct.  It is necessary to search for the          corresponding linker definition to find the value.          These definitions appear at the end of the namelist.  */
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|read_type
argument_list|(
operator|&
name|p
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_STATIC
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
comment|/* Don't add symbol references to global_sym_chain.          Symbol references don't have valid names and wont't match up with          minimal symbols when the global_sym_chain is relocated.          We'll fixup symbol references when we fixup the defining symbol.  */
if|if
condition|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|&&
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
index|[
literal|0
index|]
operator|!=
literal|'#'
condition|)
block|{
name|i
operator|=
name|hashname
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|SYMBOL_VALUE_CHAIN
argument_list|(
name|sym
argument_list|)
operator|=
name|global_sym_chain
index|[
name|i
index|]
expr_stmt|;
name|global_sym_chain
index|[
name|i
index|]
operator|=
name|sym
expr_stmt|;
block|}
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|global_symbols
argument_list|)
expr_stmt|;
break|break;
comment|/* This case is faked by a conditional above,          when there is no code letter in the dbx data.          Dbx data never actually contains 'l'.  */
case|case
literal|'s'
case|:
case|case
literal|'l'
case|:
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|read_type
argument_list|(
operator|&
name|p
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_LOCAL
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|valu
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|local_symbols
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
if|if
condition|(
operator|*
name|p
operator|==
literal|'F'
condition|)
comment|/* pF is a two-letter code that means a function parameter in Fortran. 	   The type-number specifies the type of the return value. 	   Translate it into a pointer-to-function type.  */
block|{
name|p
operator|++
expr_stmt|;
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|lookup_pointer_type
argument_list|(
name|lookup_function_type
argument_list|(
name|read_type
argument_list|(
operator|&
name|p
argument_list|,
name|objfile
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|read_type
argument_list|(
operator|&
name|p
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* Normally this is a parameter, a LOC_ARG.  On the i960, it          can also be a LOC_LOCAL_ARG depending on symbol type.  */
ifndef|#
directive|ifndef
name|DBX_PARM_SYMBOL_CLASS
define|#
directive|define
name|DBX_PARM_SYMBOL_CLASS
parameter_list|(
name|type
parameter_list|)
value|LOC_ARG
endif|#
directive|endif
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|DBX_PARM_SYMBOL_CLASS
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|valu
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|local_symbols
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_BYTE_ORDER
operator|!=
name|BFD_ENDIAN_BIG
condition|)
block|{
comment|/* On little-endian machines, this crud is never necessary, 	     and, if the extra bytes contain garbage, is harmful.  */
break|break;
block|}
comment|/* If it's gcc-compiled, if it says `short', believe it.  */
if|if
condition|(
name|processing_gcc_compilation
operator|||
name|BELIEVE_PCC_PROMOTION
condition|)
break|break;
if|if
condition|(
operator|!
name|BELIEVE_PCC_PROMOTION
condition|)
block|{
comment|/* This is the signed type which arguments get promoted to.  */
specifier|static
name|struct
name|type
modifier|*
name|pcc_promotion_type
decl_stmt|;
comment|/* This is the unsigned type which arguments get promoted to.  */
specifier|static
name|struct
name|type
modifier|*
name|pcc_unsigned_promotion_type
decl_stmt|;
comment|/* Call it "int" because this is mainly C lossage.  */
if|if
condition|(
name|pcc_promotion_type
operator|==
name|NULL
condition|)
name|pcc_promotion_type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_INT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"int"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcc_unsigned_promotion_type
operator|==
name|NULL
condition|)
name|pcc_unsigned_promotion_type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_INT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"unsigned int"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|BELIEVE_PCC_PROMOTION_TYPE
condition|)
block|{
comment|/* This is defined on machines (e.g. sparc) where we 	         should believe the type of a PCC 'short' argument, 	         but shouldn't believe the address (the address is the 	         address of the corresponding int).  	         My guess is that this correction, as opposed to 	         changing the parameter to an 'int' (as done below, 	         for PCC on most machines), is the right thing to do 	         on all machines, but I don't want to risk breaking 	         something that already works.  On most PCC machines, 	         the sparc problem doesn't come up because the calling 	         function has to zero the top bytes (not knowing 	         whether the called function wants an int or a short), 	         so there is little practical difference between an 	         int and a short (except perhaps what happens when the 	         GDB user types "print short_arg = 0x10000;").  	         Hacked for SunOS 4.1 by gnu@cygnus.com.  In 4.1, the 	         compiler actually produces the correct address (we 	         don't need to fix it up).  I made this code adapt so 	         that it will offset the symbol if it was pointing at 	         an int-aligned location and not otherwise.  This way 	         you can use the same gdb for 4.0.x and 4.1 systems.  	         If the parameter is shorter than an int, and is 	         integral (e.g. char, short, or unsigned equivalent), 	         and is claimed to be passed on an integer boundary, 	         don't believe it!  Offset the parameter's address to 	         the tail-end of that integer.  */
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|<
name|TYPE_LENGTH
argument_list|(
name|pcc_promotion_type
argument_list|)
operator|&&
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_INT
operator|&&
literal|0
operator|==
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|%
name|TYPE_LENGTH
argument_list|(
name|pcc_promotion_type
argument_list|)
condition|)
block|{
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|+=
name|TYPE_LENGTH
argument_list|(
name|pcc_promotion_type
argument_list|)
operator|-
name|TYPE_LENGTH
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
else|else
block|{
comment|/* If PCC says a parameter is a short or a char, 	         it is really an int.  */
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|<
name|TYPE_LENGTH
argument_list|(
name|pcc_promotion_type
argument_list|)
operator|&&
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_INT
condition|)
block|{
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|TYPE_UNSIGNED
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
condition|?
name|pcc_unsigned_promotion_type
else|:
name|pcc_promotion_type
expr_stmt|;
block|}
break|break;
block|}
block|}
case|case
literal|'P'
case|:
comment|/* acc seems to use P to declare the prototypes of functions that          are referenced by this file.  gdb is not prepared to deal          with this extra information.  FIXME, it ought to.  */
if|if
condition|(
name|type
operator|==
name|N_FUN
condition|)
block|{
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|read_type
argument_list|(
operator|&
name|p
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
goto|goto
name|process_prototype_types
goto|;
block|}
comment|/*FALLTHROUGH */
case|case
literal|'R'
case|:
comment|/* Parameter which is in a register.  */
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|read_type
argument_list|(
operator|&
name|p
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_REGPARM
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|STAB_REG_TO_REGNUM
argument_list|(
name|valu
argument_list|)
expr_stmt|;
if|if
condition|(
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|>=
name|NUM_REGS
operator|+
name|NUM_PSEUDO_REGS
condition|)
block|{
name|complain
argument_list|(
operator|&
name|reg_value_complaint
argument_list|,
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
argument_list|,
name|NUM_REGS
operator|+
name|NUM_PSEUDO_REGS
argument_list|,
name|SYMBOL_SOURCE_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|SP_REGNUM
expr_stmt|;
comment|/* Known safe, though useless */
block|}
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|local_symbols
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* Register variable (either global or local).  */
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|read_type
argument_list|(
operator|&
name|p
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_REGISTER
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|STAB_REG_TO_REGNUM
argument_list|(
name|valu
argument_list|)
expr_stmt|;
if|if
condition|(
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|>=
name|NUM_REGS
operator|+
name|NUM_PSEUDO_REGS
condition|)
block|{
name|complain
argument_list|(
operator|&
name|reg_value_complaint
argument_list|,
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
argument_list|,
name|NUM_REGS
operator|+
name|NUM_PSEUDO_REGS
argument_list|,
name|SYMBOL_SOURCE_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|SP_REGNUM
expr_stmt|;
comment|/* Known safe, though useless */
block|}
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
if|if
condition|(
name|within_function
condition|)
block|{
comment|/* Sun cc uses a pair of symbols, one 'p' and one 'r' with the same 	     name to represent an argument passed in a register. 	     GCC uses 'P' for the same case.  So if we find such a symbol pair 	     we combine it into one 'P' symbol.  For Sun cc we need to do this 	     regardless of REG_STRUCT_HAS_ADDR, because the compiler puts out 	     the 'p' symbol even if it never saves the argument onto the stack.  	     On most machines, we want to preserve both symbols, so that 	     we can still get information about what is going on with the 	     stack (VAX for computing args_printed, using stack slots instead 	     of saved registers in backtraces, etc.).  	     Note that this code illegally combines 	     main(argc) struct foo argc; { register struct foo argc; } 	     but this case is considered pathological and causes a warning 	     from a decent compiler.  */
if|if
condition|(
name|local_symbols
operator|&&
name|local_symbols
operator|->
name|nsyms
operator|>
literal|0
ifndef|#
directive|ifndef
name|USE_REGISTER_NOT_ARG
operator|&&
name|REG_STRUCT_HAS_ADDR_P
argument_list|()
operator|&&
name|REG_STRUCT_HAS_ADDR
argument_list|(
name|processing_gcc_compilation
argument_list|,
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|&&
operator|(
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
operator|||
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_UNION
operator|||
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_SET
operator|||
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_BITSTRING
operator|)
endif|#
directive|endif
condition|)
block|{
name|struct
name|symbol
modifier|*
name|prev_sym
decl_stmt|;
name|prev_sym
operator|=
name|local_symbols
operator|->
name|symbol
index|[
name|local_symbols
operator|->
name|nsyms
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|SYMBOL_CLASS
argument_list|(
name|prev_sym
argument_list|)
operator|==
name|LOC_REF_ARG
operator|||
name|SYMBOL_CLASS
argument_list|(
name|prev_sym
argument_list|)
operator|==
name|LOC_ARG
operator|)
operator|&&
name|STREQ
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|prev_sym
argument_list|)
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
condition|)
block|{
name|SYMBOL_CLASS
argument_list|(
name|prev_sym
argument_list|)
operator|=
name|LOC_REGPARM
expr_stmt|;
comment|/* Use the type from the LOC_REGISTER; that is the type 		     that is actually in that register.  */
name|SYMBOL_TYPE
argument_list|(
name|prev_sym
argument_list|)
operator|=
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|prev_sym
argument_list|)
operator|=
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|sym
operator|=
name|prev_sym
expr_stmt|;
break|break;
block|}
block|}
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|local_symbols
argument_list|)
expr_stmt|;
block|}
else|else
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|file_symbols
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
comment|/* Static symbol at top level of file */
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|read_type
argument_list|(
operator|&
name|p
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_STATIC
expr_stmt|;
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym
argument_list|)
operator|=
name|valu
expr_stmt|;
ifdef|#
directive|ifdef
name|STATIC_TRANSFORM_NAME
if|if
condition|(
name|IS_STATIC_TRANSFORM_NAME
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
condition|)
block|{
name|struct
name|minimal_symbol
modifier|*
name|msym
decl_stmt|;
name|msym
operator|=
name|lookup_minimal_symbol
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|msym
operator|!=
name|NULL
condition|)
block|{
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|=
name|STATIC_TRANSFORM_NAME
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym
argument_list|)
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msym
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|file_symbols
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|read_type
argument_list|(
operator|&
name|p
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* For a nameless type, we don't want a create a symbol, thus we          did not use `sym'. Return without further processing. */
if|if
condition|(
name|nameless
condition|)
return|return
name|NULL
return|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_TYPEDEF
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|valu
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
comment|/* C++ vagaries: we may have a type which is derived from          a base type which did not have its name defined when the          derived class was output.  We fill in the derived class's          base part member's name here in that case.  */
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|!=
name|NULL
condition|)
if|if
condition|(
operator|(
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
operator|||
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_UNION
operator|)
operator|&&
name|TYPE_N_BASECLASSES
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|TYPE_N_BASECLASSES
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|TYPE_BASECLASS_NAME
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|,
name|j
argument_list|)
operator|==
literal|0
condition|)
name|TYPE_BASECLASS_NAME
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|,
name|j
argument_list|)
operator|=
name|type_name_no_tag
argument_list|(
name|TYPE_BASECLASS
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* gcc-2.6 or later (when using -fvtable-thunks) 	     emits a unique named type for a vtable entry. 	     Some gdb code depends on that specific name. */
specifier|extern
specifier|const
name|char
name|vtbl_ptr_name
index|[]
decl_stmt|;
if|if
condition|(
operator|(
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_PTR
operator|&&
name|strcmp
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|vtbl_ptr_name
argument_list|)
operator|)
operator|||
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_FUNC
condition|)
block|{
comment|/* If we are giving a name to a type such as "pointer to 	         foo" or "function returning foo", we better not set 	         the TYPE_NAME.  If the program contains "typedef char 	         *caddr_t;", we don't want all variables of type char 	         * to print as caddr_t.  This is not just a 	         consequence of GDB's type management; PCC and GCC (at 	         least through version 2.4) both output variables of 	         either type char * or caddr_t with the type number 	         defined in the 't' symbol for caddr_t.  If a future 	         compiler cleans this up it GDB is not ready for it 	         yet, but if it becomes ready we somehow need to 	         disable this check (without breaking the PCC/GCC2.4 	         case).  	         Sigh.  	         Fortunately, this check seems not to be necessary 	         for anything except pointers or functions.  */
comment|/* ezannoni: 2000-10-26. This seems to apply for 		 versions of gcc older than 2.8. This was the original 		 problem: with the following code gdb would tell that 		 the type for name1 is caddr_t, and func is char() 	         typedef char *caddr_t; 		 char *name2; 		 struct x 		 { 		 char *name1; 		 } xx; 		 char *func() 		 { 		 } 		 main () {} 		 */
comment|/* Pascal accepts names for pointer types. */
if|if
condition|(
name|current_subfile
operator|->
name|language
operator|==
name|language_pascal
condition|)
block|{
name|TYPE_NAME
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|=
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|TYPE_NAME
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|=
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
expr_stmt|;
block|}
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|file_symbols
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
comment|/* Struct, union, or enum tag.  For GNU C++, this can be be followed          by 't' which means we are typedef'ing it as well.  */
name|synonym
operator|=
operator|*
name|p
operator|==
literal|'t'
expr_stmt|;
if|if
condition|(
name|synonym
condition|)
name|p
operator|++
expr_stmt|;
comment|/* The semantics of C++ state that "struct foo { ... }" also defines           a typedef for "foo".  Unfortunately, cfront never makes the typedef          when translating C++ into C.  We make the typedef here so that          "ptype foo" works as expected for cfront translated code.  */
elseif|else
if|if
condition|(
name|current_subfile
operator|->
name|language
operator|==
name|language_cplus
condition|)
name|synonym
operator|=
literal|1
expr_stmt|;
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|read_type
argument_list|(
operator|&
name|p
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* For a nameless type, we don't want a create a symbol, thus we          did not use `sym'. Return without further processing. */
if|if
condition|(
name|nameless
condition|)
return|return
name|NULL
return|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_TYPEDEF
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|valu
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
name|STRUCT_NAMESPACE
expr_stmt|;
if|if
condition|(
name|TYPE_TAG_NAME
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|TYPE_TAG_NAME
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|=
name|obconcat
argument_list|(
operator|&
name|objfile
operator|->
name|type_obstack
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|file_symbols
argument_list|)
expr_stmt|;
if|if
condition|(
name|synonym
condition|)
block|{
comment|/* Clone the sym and then modify it. */
specifier|register
name|struct
name|symbol
modifier|*
name|typedef_sym
init|=
operator|(
expr|struct
name|symbol
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
decl_stmt|;
operator|*
name|typedef_sym
operator|=
operator|*
name|sym
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|typedef_sym
argument_list|)
operator|=
name|LOC_TYPEDEF
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|typedef_sym
argument_list|)
operator|=
name|valu
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|typedef_sym
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|TYPE_NAME
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|=
name|obconcat
argument_list|(
operator|&
name|objfile
operator|->
name|type_obstack
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|typedef_sym
argument_list|,
operator|&
name|file_symbols
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'V'
case|:
comment|/* Static symbol of local scope */
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|read_type
argument_list|(
operator|&
name|p
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_STATIC
expr_stmt|;
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym
argument_list|)
operator|=
name|valu
expr_stmt|;
ifdef|#
directive|ifdef
name|STATIC_TRANSFORM_NAME
if|if
condition|(
name|IS_STATIC_TRANSFORM_NAME
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
condition|)
block|{
name|struct
name|minimal_symbol
modifier|*
name|msym
decl_stmt|;
name|msym
operator|=
name|lookup_minimal_symbol
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|msym
operator|!=
name|NULL
condition|)
block|{
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|=
name|STATIC_TRANSFORM_NAME
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym
argument_list|)
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msym
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
if|if
condition|(
name|os9k_stabs
condition|)
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|global_symbols
argument_list|)
expr_stmt|;
else|else
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|local_symbols
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
comment|/* Reference parameter */
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|read_type
argument_list|(
operator|&
name|p
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_REF_ARG
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|valu
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|local_symbols
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
comment|/* Reference parameter which is in a register.  */
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|read_type
argument_list|(
operator|&
name|p
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_REGPARM_ADDR
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|STAB_REG_TO_REGNUM
argument_list|(
name|valu
argument_list|)
expr_stmt|;
if|if
condition|(
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|>=
name|NUM_REGS
operator|+
name|NUM_PSEUDO_REGS
condition|)
block|{
name|complain
argument_list|(
operator|&
name|reg_value_complaint
argument_list|,
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
argument_list|,
name|NUM_REGS
operator|+
name|NUM_PSEUDO_REGS
argument_list|,
name|SYMBOL_SOURCE_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|SP_REGNUM
expr_stmt|;
comment|/* Known safe, though useless */
block|}
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|local_symbols
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
comment|/* This is used by Sun FORTRAN for "function result value".          Sun claims ("dbx and dbxtool interfaces", 2nd ed)          that Pascal uses it too, but when I tried it Pascal used          "x:3" (local symbol) instead.  */
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|read_type
argument_list|(
operator|&
name|p
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_LOCAL
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|valu
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|local_symbols
argument_list|)
expr_stmt|;
break|break;
comment|/* New code added to support cfront stabs strings.          Note: case 'P' already handled above */
case|case
literal|'Z'
case|:
comment|/* Cfront type continuation coming up!          Find the original definition and add to it.          We'll have to do this for the typedef too,          since we cloned the symbol to define a type in read_type.          Stabs info examples:          __1C :Ztl           foo__1CFv :ZtF (first def foo__1CFv:F(0,3);(0,24))          C:ZsC;;__ct__1CFv func1__1CFv func2__1CFv ... ;;;          where C is the name of the class.          Unfortunately, we can't lookup the original symbol yet 'cuz           we haven't finished reading all the symbols.          Instead, we save it for processing later */
name|process_later
argument_list|(
name|sym
argument_list|,
name|p
argument_list|,
name|resolve_cfront_continuation
argument_list|)
expr_stmt|;
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|error_type
argument_list|(
operator|&
name|p
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* FIXME! change later */
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_CONST
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
comment|/* Don't add to list - we'll delete it later when           we add the continuation to the real sym */
return|return
name|sym
return|;
comment|/* End of new code added to support cfront stabs strings */
default|default:
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|error_type
argument_list|(
operator|&
name|p
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_CONST
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|file_symbols
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* When passing structures to a function, some systems sometimes pass      the address in a register, not the structure itself. */
if|if
condition|(
name|REG_STRUCT_HAS_ADDR_P
argument_list|()
operator|&&
name|REG_STRUCT_HAS_ADDR
argument_list|(
name|processing_gcc_compilation
argument_list|,
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|&&
operator|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_REGPARM
operator|||
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_ARG
operator|)
condition|)
block|{
name|struct
name|type
modifier|*
name|symbol_type
init|=
name|check_typedef
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|TYPE_CODE
argument_list|(
name|symbol_type
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
operator|)
operator|||
operator|(
name|TYPE_CODE
argument_list|(
name|symbol_type
argument_list|)
operator|==
name|TYPE_CODE_UNION
operator|)
operator|||
operator|(
name|TYPE_CODE
argument_list|(
name|symbol_type
argument_list|)
operator|==
name|TYPE_CODE_BITSTRING
operator|)
operator|||
operator|(
name|TYPE_CODE
argument_list|(
name|symbol_type
argument_list|)
operator|==
name|TYPE_CODE_SET
operator|)
condition|)
block|{
comment|/* If REG_STRUCT_HAS_ADDR yields non-zero we have to convert 	     LOC_REGPARM to LOC_REGPARM_ADDR for structures and unions. */
if|if
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_REGPARM
condition|)
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_REGPARM_ADDR
expr_stmt|;
comment|/* Likewise for converting LOC_ARG to LOC_REF_ARG (for the 7th 	     and subsequent arguments on the sparc, for example).  */
elseif|else
if|if
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_ARG
condition|)
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_REF_ARG
expr_stmt|;
block|}
block|}
comment|/* Is there more to parse?  For example LRS/alias information?  */
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|==
literal|';'
condition|)
block|{
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|&&
name|p
index|[
literal|0
index|]
operator|==
literal|'l'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'('
condition|)
block|{
comment|/* GNU extensions for live range splitting may be appended to  	     the end of the stab string.  eg. "l(#1,#2);l(#3,#5)" */
comment|/* Resolve the live range and add it to SYM's live range list.  */
if|if
condition|(
operator|!
name|resolve_live_range
argument_list|(
name|objfile
argument_list|,
name|sym
argument_list|,
name|p
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* Find end of live range info. */
name|p
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|p
operator|||
operator|*
name|p
operator|!=
literal|')'
condition|)
block|{
name|complain
argument_list|(
operator|&
name|lrs_general_complaint
argument_list|,
literal|"live range format not recognized"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|p
operator|++
expr_stmt|;
block|}
block|}
return|return
name|sym
return|;
block|}
end_function

begin_comment
comment|/* Add the live range found in P to the symbol SYM in objfile OBJFILE.  Returns    non-zero on success, zero otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|resolve_live_range
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|,
name|struct
name|symbol
modifier|*
name|sym
parameter_list|,
name|char
modifier|*
name|p
parameter_list|)
block|{
name|int
name|refnum
decl_stmt|;
name|CORE_ADDR
name|start
decl_stmt|,
name|end
decl_stmt|;
comment|/* Sanity check the beginning of the stabs string.  */
if|if
condition|(
operator|!
operator|*
name|p
operator|||
operator|*
name|p
operator|!=
literal|'l'
condition|)
block|{
name|complain
argument_list|(
operator|&
name|lrs_general_complaint
argument_list|,
literal|"live range string 1"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|p
operator|||
operator|*
name|p
operator|!=
literal|'('
condition|)
block|{
name|complain
argument_list|(
operator|&
name|lrs_general_complaint
argument_list|,
literal|"live range string 2"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|p
operator|++
expr_stmt|;
comment|/* Get starting value of range and advance P past the reference id.       ?!? In theory, the process_reference should never fail, but we should      catch that case just in case the compiler scrogged the stabs.  */
name|refnum
operator|=
name|process_reference
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
name|start
operator|=
name|ref_search_value
argument_list|(
name|refnum
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|start
condition|)
block|{
name|complain
argument_list|(
operator|&
name|lrs_general_complaint
argument_list|,
literal|"Live range symbol not found 1"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
operator|*
name|p
operator|||
operator|*
name|p
operator|!=
literal|','
condition|)
block|{
name|complain
argument_list|(
operator|&
name|lrs_general_complaint
argument_list|,
literal|"live range string 3"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|p
operator|++
expr_stmt|;
comment|/* Get ending value of range and advance P past the reference id.       ?!? In theory, the process_reference should never fail, but we should      catch that case just in case the compiler scrogged the stabs.  */
name|refnum
operator|=
name|process_reference
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
name|end
operator|=
name|ref_search_value
argument_list|(
name|refnum
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|end
condition|)
block|{
name|complain
argument_list|(
operator|&
name|lrs_general_complaint
argument_list|,
literal|"Live range symbol not found 2"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
operator|*
name|p
operator|||
operator|*
name|p
operator|!=
literal|')'
condition|)
block|{
name|complain
argument_list|(
operator|&
name|lrs_general_complaint
argument_list|,
literal|"live range string 4"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Now that we know the bounds of the range, add it to the      symbol.  */
name|add_live_range
argument_list|(
name|objfile
argument_list|,
name|sym
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Add a new live range defined by START and END to the symbol SYM    in objfile OBJFILE.  */
end_comment

begin_function
specifier|static
name|void
name|add_live_range
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|,
name|struct
name|symbol
modifier|*
name|sym
parameter_list|,
name|CORE_ADDR
name|start
parameter_list|,
name|CORE_ADDR
name|end
parameter_list|)
block|{
name|struct
name|range_list
modifier|*
name|r
decl_stmt|,
modifier|*
name|rs
decl_stmt|;
if|if
condition|(
name|start
operator|>=
name|end
condition|)
block|{
name|complain
argument_list|(
operator|&
name|lrs_general_complaint
argument_list|,
literal|"end of live range follows start"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Alloc new live range structure. */
name|r
operator|=
operator|(
expr|struct
name|range_list
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|type_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|range_list
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|->
name|start
operator|=
name|start
expr_stmt|;
name|r
operator|->
name|end
operator|=
name|end
expr_stmt|;
name|r
operator|->
name|next
operator|=
literal|0
expr_stmt|;
comment|/* Append this range to the symbol's range list. */
if|if
condition|(
operator|!
name|SYMBOL_RANGES
argument_list|(
name|sym
argument_list|)
condition|)
name|SYMBOL_RANGES
argument_list|(
name|sym
argument_list|)
operator|=
name|r
expr_stmt|;
else|else
block|{
comment|/* Get the last range for the symbol. */
for|for
control|(
name|rs
operator|=
name|SYMBOL_RANGES
argument_list|(
name|sym
argument_list|)
init|;
name|rs
operator|->
name|next
condition|;
name|rs
operator|=
name|rs
operator|->
name|next
control|)
empty_stmt|;
name|rs
operator|->
name|next
operator|=
name|r
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Skip rest of this symbol and return an error type.     General notes on error recovery:  error_type always skips to the    end of the symbol (modulo cretinous dbx symbol name continuation).    Thus code like this:     if (*(*pp)++ != ';')    return error_type (pp, objfile);     is wrong because if *pp starts out pointing at '\0' (typically as the    result of an earlier error), it will be incremented to point to the    start of the next symbol, which might produce strange results, at least    if you run off the end of the string table.  Instead use     if (**pp != ';')    return error_type (pp, objfile);    ++*pp;     or     if (**pp != ';')    foo = error_type (pp, objfile);    else    ++*pp;     And in case it isn't obvious, the point of all this hair is so the compiler    can define new types and new syntaxes, and old versions of the    debugger will be able to read the new symbol tables.  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|error_type
parameter_list|(
name|char
modifier|*
modifier|*
name|pp
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|complain
argument_list|(
operator|&
name|error_type_complaint
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Skip to end of symbol.  */
while|while
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|'\0'
condition|)
block|{
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
block|}
comment|/* Check for and handle cretinous dbx symbol name continuation!  */
if|if
condition|(
operator|(
operator|*
name|pp
operator|)
index|[
operator|-
literal|1
index|]
operator|==
literal|'\\'
operator|||
operator|(
operator|*
name|pp
operator|)
index|[
operator|-
literal|1
index|]
operator|==
literal|'?'
condition|)
block|{
operator|*
name|pp
operator|=
name|next_symbol_text
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
return|return
operator|(
name|builtin_type_error
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read type information or a type definition; return the type.  Even    though this routine accepts either type information or a type    definition, the distinction is relevant--some parts of stabsread.c    assume that type information starts with a digit, '-', or '(' in    deciding whether to call read_type.  */
end_comment

begin_function
name|struct
name|type
modifier|*
name|read_type
parameter_list|(
specifier|register
name|char
modifier|*
modifier|*
name|pp
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
specifier|register
name|struct
name|type
modifier|*
name|type
init|=
literal|0
decl_stmt|;
name|struct
name|type
modifier|*
name|type1
decl_stmt|;
name|int
name|typenums
index|[
literal|2
index|]
decl_stmt|;
name|char
name|type_descriptor
decl_stmt|;
comment|/* Size in bits of type if specified by a type attribute, or -1 if      there is no size attribute.  */
name|int
name|type_size
init|=
operator|-
literal|1
decl_stmt|;
comment|/* Used to distinguish string and bitstring from char-array and set. */
name|int
name|is_string
init|=
literal|0
decl_stmt|;
comment|/* Read type number if present.  The type number may be omitted.      for instance in a two-dimensional array declared with type      "ar1;1;10;ar1;1;10;4".  */
if|if
condition|(
operator|(
operator|*
operator|*
name|pp
operator|>=
literal|'0'
operator|&&
operator|*
operator|*
name|pp
operator|<=
literal|'9'
operator|)
operator|||
operator|*
operator|*
name|pp
operator|==
literal|'('
operator|||
operator|*
operator|*
name|pp
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
name|read_type_number
argument_list|(
name|pp
argument_list|,
name|typenums
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|error_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
return|;
comment|/* Type is not being defined here.  Either it already exists,          or this is a forward reference to it.  dbx_alloc_type handles          both cases.  */
if|if
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|'='
condition|)
return|return
name|dbx_alloc_type
argument_list|(
name|typenums
argument_list|,
name|objfile
argument_list|)
return|;
comment|/* Type is being defined here.  */
comment|/* Skip the '='.          Also skip the type descriptor - we get it below with (*pp)[-1].  */
operator|(
operator|*
name|pp
operator|)
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
comment|/* 'typenums=' not present, type is anonymous.  Read and return          the definition, but don't put it in the type vector.  */
name|typenums
index|[
literal|0
index|]
operator|=
name|typenums
index|[
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
block|}
name|again
label|:
name|type_descriptor
operator|=
operator|(
operator|*
name|pp
operator|)
index|[
operator|-
literal|1
index|]
expr_stmt|;
switch|switch
condition|(
name|type_descriptor
condition|)
block|{
case|case
literal|'x'
case|:
block|{
name|enum
name|type_code
name|code
decl_stmt|;
comment|/* Used to index through file_symbols.  */
name|struct
name|pending
modifier|*
name|ppt
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Name including "struct", etc.  */
name|char
modifier|*
name|type_name
decl_stmt|;
block|{
name|char
modifier|*
name|from
decl_stmt|,
modifier|*
name|to
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|q1
decl_stmt|,
modifier|*
name|q2
decl_stmt|;
comment|/* Set the type code according to the following letter.  */
switch|switch
condition|(
operator|(
operator|*
name|pp
operator|)
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'s'
case|:
name|code
operator|=
name|TYPE_CODE_STRUCT
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|code
operator|=
name|TYPE_CODE_UNION
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|code
operator|=
name|TYPE_CODE_ENUM
expr_stmt|;
break|break;
default|default:
block|{
comment|/* Complain and keep going, so compilers can invent new 		   cross-reference types.  */
specifier|static
name|struct
name|complaint
name|msg
init|=
block|{
literal|"Unrecognized cross-reference type `%c'"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|complain
argument_list|(
operator|&
name|msg
argument_list|,
operator|(
operator|*
name|pp
operator|)
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|code
operator|=
name|TYPE_CODE_STRUCT
expr_stmt|;
break|break;
block|}
block|}
name|q1
operator|=
name|strchr
argument_list|(
operator|*
name|pp
argument_list|,
literal|'<'
argument_list|)
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
operator|*
name|pp
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
name|error_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
return|;
if|if
condition|(
name|q1
operator|&&
name|p
operator|>
name|q1
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
block|{
name|int
name|nesting_level
init|=
literal|0
decl_stmt|;
for|for
control|(
name|q2
operator|=
name|q1
init|;
operator|*
name|q2
condition|;
name|q2
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|q2
operator|==
literal|'<'
condition|)
name|nesting_level
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|q2
operator|==
literal|'>'
condition|)
name|nesting_level
operator|--
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|q2
operator|==
literal|':'
operator|&&
name|nesting_level
operator|==
literal|0
condition|)
break|break;
block|}
name|p
operator|=
name|q2
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|':'
condition|)
return|return
name|error_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
return|;
block|}
name|to
operator|=
name|type_name
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|type_obstack
argument_list|,
name|p
operator|-
operator|*
name|pp
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Copy the name.  */
name|from
operator|=
operator|*
name|pp
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|from
operator|<
name|p
condition|)
operator|*
name|to
operator|++
operator|=
operator|*
name|from
operator|++
expr_stmt|;
operator|*
name|to
operator|=
literal|'\0'
expr_stmt|;
comment|/* Set the pointer ahead of the name which we just read, and 	     the colon.  */
operator|*
name|pp
operator|=
name|from
operator|+
literal|1
expr_stmt|;
block|}
comment|/* Now check to see whether the type has already been 	   declared.  This was written for arrays of cross-referenced 	   types before we had TYPE_CODE_TARGET_STUBBED, so I'm pretty 	   sure it is not necessary anymore.  But it might be a good 	   idea, to save a little memory.  */
for|for
control|(
name|ppt
operator|=
name|file_symbols
init|;
name|ppt
condition|;
name|ppt
operator|=
name|ppt
operator|->
name|next
control|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ppt
operator|->
name|nsyms
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|symbol
modifier|*
name|sym
init|=
name|ppt
operator|->
name|symbol
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_TYPEDEF
operator|&&
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|==
name|STRUCT_NAMESPACE
operator|&&
operator|(
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|==
name|code
operator|)
operator|&&
name|STREQ
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|type_name
argument_list|)
condition|)
block|{
name|obstack_free
argument_list|(
operator|&
name|objfile
operator|->
name|type_obstack
argument_list|,
name|type_name
argument_list|)
expr_stmt|;
name|type
operator|=
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
block|}
comment|/* Didn't find the type to which this refers, so we must 	   be dealing with a forward reference.  Allocate a type 	   structure for it, and keep track of it so we can 	   fill in the rest of the fields when we get the full 	   type.  */
name|type
operator|=
name|dbx_alloc_type
argument_list|(
name|typenums
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|code
expr_stmt|;
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
operator|=
name|type_name
expr_stmt|;
name|INIT_CPLUS_SPECIFIC
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_FLAGS
argument_list|(
name|type
argument_list|)
operator||=
name|TYPE_FLAG_STUB
expr_stmt|;
name|add_undefined_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
case|case
literal|'-'
case|:
comment|/* RS/6000 built-in type */
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
case|case
literal|'('
case|:
operator|(
operator|*
name|pp
operator|)
operator|--
expr_stmt|;
comment|/* We deal with something like t(1,2)=(3,4)=... which          the Lucid compiler and recent gcc versions (post 2.7.3) use. */
comment|/* Allocate and enter the typedef type first.          This handles recursive types. */
name|type
operator|=
name|dbx_alloc_type
argument_list|(
name|typenums
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_CODE_TYPEDEF
expr_stmt|;
block|{
name|struct
name|type
modifier|*
name|xtype
init|=
name|read_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|xtype
condition|)
block|{
comment|/* It's being defined as itself.  That means it is "void".  */
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_CODE_VOID
expr_stmt|;
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type_size
operator|>=
literal|0
operator|||
name|is_string
condition|)
block|{
comment|/* This is the absolute wrong way to construct types.  Every 	       other debug format has found a way around this problem and 	       the related problems with unnecessarily stubbed types; 	       someone motivated should attempt to clean up the issue 	       here as well.  Once a type pointed to has been created it 	       should not be modified.  */
name|replace_type
argument_list|(
name|type
argument_list|,
name|xtype
argument_list|)
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|TYPE_FLAGS
argument_list|(
name|type
argument_list|)
operator||=
name|TYPE_FLAG_TARGET_STUB
expr_stmt|;
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
operator|=
name|xtype
expr_stmt|;
block|}
block|}
break|break;
comment|/* In the following types, we must be sure to overwrite any existing          type that the typenums refer to, rather than allocating a new one          and making the typenums point to the new one.  This is because there          may already be pointers to the existing type (if it had been          forward-referenced), and we must change it to a pointer, function,          reference, or whatever, *in-place*.  */
case|case
literal|'*'
case|:
name|type1
operator|=
name|read_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|type
operator|=
name|make_pointer_type
argument_list|(
name|type1
argument_list|,
name|dbx_lookup_type
argument_list|(
name|typenums
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'&'
case|:
comment|/* Reference to another type */
name|type1
operator|=
name|read_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|type
operator|=
name|make_reference_type
argument_list|(
name|type1
argument_list|,
name|dbx_lookup_type
argument_list|(
name|typenums
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* Function returning another type */
if|if
condition|(
name|os9k_stabs
operator|&&
operator|*
operator|*
name|pp
operator|==
literal|'('
condition|)
block|{
comment|/* Function prototype; parse it. 	     We must conditionalize this on os9k_stabs because otherwise 	     it could be confused with a Sun-style (1,3) typenumber 	     (I think).  */
name|struct
name|type
modifier|*
name|t
decl_stmt|;
operator|++
operator|*
name|pp
expr_stmt|;
while|while
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|')'
condition|)
block|{
name|t
operator|=
name|read_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|','
condition|)
operator|++
operator|*
name|pp
expr_stmt|;
block|}
block|}
name|type1
operator|=
name|read_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|type
operator|=
name|make_function_type
argument_list|(
name|type1
argument_list|,
name|dbx_lookup_type
argument_list|(
name|typenums
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
comment|/* Prototyped function.  (Sun)  */
block|{
comment|/* Unresolved questions:             - According to Sun's ``STABS Interface Manual'', for 'f'            and 'F' symbol descriptors, a `0' in the argument type list            indicates a varargs function.  But it doesn't say how 'g'            type descriptors represent that info.  Someone with access            to Sun's toolchain should try it out.             - According to the comment in define_symbol (search for            `process_prototype_types:'), Sun emits integer arguments as            types which ref themselves --- like `void' types.  Do we            have to deal with that here, too?  Again, someone with            access to Sun's toolchain should try it out and let us            know.  */
specifier|const
name|char
modifier|*
name|type_start
init|=
operator|(
operator|*
name|pp
operator|)
operator|-
literal|1
decl_stmt|;
name|struct
name|type
modifier|*
name|return_type
init|=
name|read_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
decl_stmt|;
name|struct
name|type
modifier|*
name|func_type
init|=
name|make_function_type
argument_list|(
name|return_type
argument_list|,
name|dbx_lookup_type
argument_list|(
name|typenums
argument_list|)
argument_list|)
decl_stmt|;
struct|struct
name|type_list
block|{
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|struct
name|type_list
modifier|*
name|next
decl_stmt|;
block|}
modifier|*
name|arg_types
init|=
literal|0
struct|;
name|int
name|num_args
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
operator|*
name|pp
operator|&&
operator|*
operator|*
name|pp
operator|!=
literal|'#'
condition|)
block|{
name|struct
name|type
modifier|*
name|arg_type
init|=
name|read_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
decl_stmt|;
name|struct
name|type_list
modifier|*
name|new
init|=
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|new
argument_list|)
argument_list|)
decl_stmt|;
name|new
operator|->
name|type
operator|=
name|arg_type
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|arg_types
expr_stmt|;
name|arg_types
operator|=
name|new
expr_stmt|;
name|num_args
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|'#'
condition|)
operator|++
operator|*
name|pp
expr_stmt|;
else|else
block|{
specifier|static
name|struct
name|complaint
name|msg
init|=
block|{
literal|"Prototyped function type didn't end arguments with `#':\n%s"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|complain
argument_list|(
operator|&
name|msg
argument_list|,
name|type_start
argument_list|)
expr_stmt|;
block|}
comment|/* If there is just one argument whose type is `void', then            that's just an empty argument list.  */
if|if
condition|(
name|arg_types
operator|&&
operator|!
name|arg_types
operator|->
name|next
operator|&&
name|TYPE_CODE
argument_list|(
name|arg_types
operator|->
name|type
argument_list|)
operator|==
name|TYPE_CODE_VOID
condition|)
name|num_args
operator|=
literal|0
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|func_type
argument_list|)
operator|=
operator|(
expr|struct
name|field
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|func_type
argument_list|,
name|num_args
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|func_type
argument_list|)
argument_list|,
literal|0
argument_list|,
name|num_args
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
argument_list|)
expr_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|struct
name|type_list
modifier|*
name|t
decl_stmt|;
comment|/* We stuck each argument type onto the front of the list              when we read it, so the list is reversed.  Build the              fields array right-to-left.  */
for|for
control|(
name|t
operator|=
name|arg_types
operator|,
name|i
operator|=
name|num_args
operator|-
literal|1
init|;
name|t
condition|;
name|t
operator|=
name|t
operator|->
name|next
operator|,
name|i
operator|--
control|)
name|TYPE_FIELD_TYPE
argument_list|(
name|func_type
argument_list|,
name|i
argument_list|)
operator|=
name|t
operator|->
name|type
expr_stmt|;
block|}
name|TYPE_NFIELDS
argument_list|(
name|func_type
argument_list|)
operator|=
name|num_args
expr_stmt|;
name|TYPE_FLAGS
argument_list|(
name|func_type
argument_list|)
operator||=
name|TYPE_FLAG_PROTOTYPED
expr_stmt|;
name|type
operator|=
name|func_type
expr_stmt|;
break|break;
block|}
case|case
literal|'k'
case|:
comment|/* Const qualifier on some type (Sun) */
case|case
literal|'c'
case|:
comment|/* Const qualifier on some type (OS9000) */
comment|/* Because 'c' means other things to AIX and 'k' is perfectly good,          only accept 'c' in the os9k_stabs case.  */
if|if
condition|(
name|type_descriptor
operator|==
literal|'c'
operator|&&
operator|!
name|os9k_stabs
condition|)
return|return
name|error_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
return|;
name|type
operator|=
name|read_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|type
operator|=
name|make_cv_type
argument_list|(
literal|1
argument_list|,
name|TYPE_VOLATILE
argument_list|(
name|type
argument_list|)
argument_list|,
name|type
argument_list|,
name|dbx_lookup_type
argument_list|(
name|typenums
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
comment|/* Volatile qual on some type (Sun) */
case|case
literal|'i'
case|:
comment|/* Volatile qual on some type (OS9000) */
comment|/* Because 'i' means other things to AIX and 'B' is perfectly good,          only accept 'i' in the os9k_stabs case.  */
if|if
condition|(
name|type_descriptor
operator|==
literal|'i'
operator|&&
operator|!
name|os9k_stabs
condition|)
return|return
name|error_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
return|;
name|type
operator|=
name|read_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|type
operator|=
name|make_cv_type
argument_list|(
name|TYPE_CONST
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|,
name|type
argument_list|,
name|dbx_lookup_type
argument_list|(
name|typenums
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'@'
case|:
if|if
condition|(
name|isdigit
argument_list|(
operator|*
operator|*
name|pp
argument_list|)
operator|||
operator|*
operator|*
name|pp
operator|==
literal|'('
operator|||
operator|*
operator|*
name|pp
operator|==
literal|'-'
condition|)
block|{
comment|/* Member (class& variable) type */
comment|/* FIXME -- we should be doing smash_to_XXX types here.  */
name|struct
name|type
modifier|*
name|domain
init|=
name|read_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
decl_stmt|;
name|struct
name|type
modifier|*
name|memtype
decl_stmt|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|','
condition|)
comment|/* Invalid member type data format.  */
return|return
name|error_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
return|;
operator|++
operator|*
name|pp
expr_stmt|;
name|memtype
operator|=
name|read_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|type
operator|=
name|dbx_alloc_type
argument_list|(
name|typenums
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|smash_to_member_type
argument_list|(
name|type
argument_list|,
name|domain
argument_list|,
name|memtype
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* type attribute */
block|{
name|char
modifier|*
name|attr
init|=
operator|*
name|pp
decl_stmt|;
comment|/* Skip to the semicolon.  */
while|while
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|';'
operator|&&
operator|*
operator|*
name|pp
operator|!=
literal|'\0'
condition|)
operator|++
operator|(
operator|*
name|pp
operator|)
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|'\0'
condition|)
return|return
name|error_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
return|;
else|else
operator|++
operator|*
name|pp
expr_stmt|;
comment|/* Skip the semicolon.  */
switch|switch
condition|(
operator|*
name|attr
condition|)
block|{
case|case
literal|'s'
case|:
name|type_size
operator|=
name|atoi
argument_list|(
name|attr
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|type_size
operator|<=
literal|0
condition|)
name|type_size
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|is_string
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
comment|/* Ignore unrecognized type attributes, so future compilers 	         can invent new ones.  */
break|break;
block|}
operator|++
operator|*
name|pp
expr_stmt|;
goto|goto
name|again
goto|;
block|}
break|break;
case|case
literal|'#'
case|:
comment|/* Method (class& fn) type */
if|if
condition|(
operator|(
operator|*
name|pp
operator|)
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
block|{
comment|/* We'll get the parameter types from the name.  */
name|struct
name|type
modifier|*
name|return_type
decl_stmt|;
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
name|return_type
operator|=
name|read_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
operator|*
name|pp
operator|)
operator|++
operator|!=
literal|';'
condition|)
name|complain
argument_list|(
operator|&
name|invalid_member_complaint
argument_list|,
name|symnum
argument_list|)
expr_stmt|;
name|type
operator|=
name|allocate_stub_method
argument_list|(
name|return_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|typenums
index|[
literal|0
index|]
operator|!=
operator|-
literal|1
condition|)
operator|*
name|dbx_lookup_type
argument_list|(
name|typenums
argument_list|)
operator|=
name|type
expr_stmt|;
block|}
else|else
block|{
name|struct
name|type
modifier|*
name|domain
init|=
name|read_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
decl_stmt|;
name|struct
name|type
modifier|*
name|return_type
decl_stmt|;
name|struct
name|type
modifier|*
modifier|*
name|args
decl_stmt|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|','
condition|)
comment|/* Invalid member type data format.  */
return|return
name|error_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
return|;
else|else
operator|++
operator|(
operator|*
name|pp
operator|)
expr_stmt|;
name|return_type
operator|=
name|read_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|args
operator|=
name|read_args
argument_list|(
name|pp
argument_list|,
literal|';'
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|type
operator|=
name|dbx_alloc_type
argument_list|(
name|typenums
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|smash_to_method_type
argument_list|(
name|type
argument_list|,
name|domain
argument_list|,
name|return_type
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'r'
case|:
comment|/* Range type */
name|type
operator|=
name|read_range_type
argument_list|(
name|pp
argument_list|,
name|typenums
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|typenums
index|[
literal|0
index|]
operator|!=
operator|-
literal|1
condition|)
operator|*
name|dbx_lookup_type
argument_list|(
name|typenums
argument_list|)
operator|=
name|type
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
if|if
condition|(
name|os9k_stabs
condition|)
comment|/* Const and volatile qualified type.  */
name|type
operator|=
name|read_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Sun ACC builtin int type */
name|type
operator|=
name|read_sun_builtin_type
argument_list|(
name|pp
argument_list|,
name|typenums
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|typenums
index|[
literal|0
index|]
operator|!=
operator|-
literal|1
condition|)
operator|*
name|dbx_lookup_type
argument_list|(
name|typenums
argument_list|)
operator|=
name|type
expr_stmt|;
block|}
break|break;
case|case
literal|'R'
case|:
comment|/* Sun ACC builtin float type */
name|type
operator|=
name|read_sun_floating_type
argument_list|(
name|pp
argument_list|,
name|typenums
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|typenums
index|[
literal|0
index|]
operator|!=
operator|-
literal|1
condition|)
operator|*
name|dbx_lookup_type
argument_list|(
name|typenums
argument_list|)
operator|=
name|type
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
comment|/* Enumeration type */
name|type
operator|=
name|dbx_alloc_type
argument_list|(
name|typenums
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|type
operator|=
name|read_enum_type
argument_list|(
name|pp
argument_list|,
name|type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|typenums
index|[
literal|0
index|]
operator|!=
operator|-
literal|1
condition|)
operator|*
name|dbx_lookup_type
argument_list|(
name|typenums
argument_list|)
operator|=
name|type
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* Struct type */
case|case
literal|'u'
case|:
comment|/* Union type */
name|type
operator|=
name|dbx_alloc_type
argument_list|(
name|typenums
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type_descriptor
condition|)
block|{
case|case
literal|'s'
case|:
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_CODE_STRUCT
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_CODE_UNION
expr_stmt|;
break|break;
block|}
name|type
operator|=
name|read_struct_type
argument_list|(
name|pp
argument_list|,
name|type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
comment|/* Array type */
if|if
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|'r'
condition|)
return|return
name|error_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
return|;
operator|++
operator|*
name|pp
expr_stmt|;
name|type
operator|=
name|dbx_alloc_type
argument_list|(
name|typenums
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|type
operator|=
name|read_array_type
argument_list|(
name|pp
argument_list|,
name|type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_string
condition|)
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_CODE_STRING
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|type1
operator|=
name|read_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|type
operator|=
name|create_set_type
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|)
name|NULL
argument_list|,
name|type1
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_string
condition|)
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_CODE_BITSTRING
expr_stmt|;
if|if
condition|(
name|typenums
index|[
literal|0
index|]
operator|!=
operator|-
literal|1
condition|)
operator|*
name|dbx_lookup_type
argument_list|(
name|typenums
argument_list|)
operator|=
name|type
expr_stmt|;
break|break;
default|default:
operator|--
operator|*
name|pp
expr_stmt|;
comment|/* Go back to the symbol in error */
comment|/* Particularly important if it was \0! */
return|return
name|error_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
return|;
block|}
if|if
condition|(
name|type
operator|==
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"GDB internal error, type is NULL in stabsread.c\n"
argument_list|)
expr_stmt|;
return|return
name|error_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
return|;
block|}
comment|/* Size specified in a type attribute overrides any other size.  */
if|if
condition|(
name|type_size
operator|!=
operator|-
literal|1
condition|)
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
operator|(
name|type_size
operator|+
name|TARGET_CHAR_BIT
operator|-
literal|1
operator|)
operator|/
name|TARGET_CHAR_BIT
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* RS/6000 xlc/dbx combination uses a set of builtin types, starting from -1.    Return the proper type node for a given builtin type number. */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|rs6000_builtin_type
parameter_list|(
name|int
name|typenum
parameter_list|)
block|{
comment|/* We recognize types numbered from -NUMBER_RECOGNIZED to -1.  */
define|#
directive|define
name|NUMBER_RECOGNIZED
value|34
comment|/* This includes an empty slot for type number -0.  */
specifier|static
name|struct
name|type
modifier|*
name|negative_types
index|[
name|NUMBER_RECOGNIZED
operator|+
literal|1
index|]
decl_stmt|;
name|struct
name|type
modifier|*
name|rettype
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|typenum
operator|>=
literal|0
operator|||
name|typenum
operator|<
operator|-
name|NUMBER_RECOGNIZED
condition|)
block|{
name|complain
argument_list|(
operator|&
name|rs6000_builtin_complaint
argument_list|,
name|typenum
argument_list|)
expr_stmt|;
return|return
name|builtin_type_error
return|;
block|}
if|if
condition|(
name|negative_types
index|[
operator|-
name|typenum
index|]
operator|!=
name|NULL
condition|)
return|return
name|negative_types
index|[
operator|-
name|typenum
index|]
return|;
if|#
directive|if
name|TARGET_CHAR_BIT
operator|!=
literal|8
error|#
directive|error
error|This code wrong for TARGET_CHAR_BIT not 8
comment|/* These definitions all assume that TARGET_CHAR_BIT is 8.  I think      that if that ever becomes not true, the correct fix will be to      make the size in the struct type to be in bits, not in units of      TARGET_CHAR_BIT.  */
endif|#
directive|endif
switch|switch
condition|(
operator|-
name|typenum
condition|)
block|{
case|case
literal|1
case|:
comment|/* The size of this and all the other types are fixed, defined          by the debugging format.  If there is a type called "int" which          is other than 32 bits, then it should use a new negative type          number (or avoid negative type numbers for that case).          See stabs.texinfo.  */
name|rettype
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
literal|"int"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|rettype
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"char"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|rettype
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"short"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|rettype
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
literal|"long"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|rettype
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|1
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"unsigned char"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|rettype
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"signed char"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|7
case|:
name|rettype
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|2
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"unsigned short"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|rettype
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|4
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"unsigned int"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|9
case|:
name|rettype
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|4
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"unsigned"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
case|case
literal|10
case|:
name|rettype
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|4
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"unsigned long"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|11
case|:
name|rettype
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_VOID
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"void"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|12
case|:
comment|/* IEEE single precision (32 bit).  */
name|rettype
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
literal|"float"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|13
case|:
comment|/* IEEE double precision (64 bit).  */
name|rettype
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
literal|8
argument_list|,
literal|0
argument_list|,
literal|"double"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|14
case|:
comment|/* This is an IEEE double on the RS/6000, and different machines with          different sizes for "long double" should use different negative          type numbers.  See stabs.texinfo.  */
name|rettype
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
literal|8
argument_list|,
literal|0
argument_list|,
literal|"long double"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|15
case|:
name|rettype
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
literal|"integer"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|rettype
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_BOOL
argument_list|,
literal|4
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"boolean"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|17
case|:
name|rettype
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
literal|"short real"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|18
case|:
name|rettype
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
literal|8
argument_list|,
literal|0
argument_list|,
literal|"real"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|19
case|:
name|rettype
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_ERROR
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"stringptr"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|20
case|:
name|rettype
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_CHAR
argument_list|,
literal|1
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"character"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|21
case|:
name|rettype
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_BOOL
argument_list|,
literal|1
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"logical*1"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|22
case|:
name|rettype
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_BOOL
argument_list|,
literal|2
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"logical*2"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|23
case|:
name|rettype
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_BOOL
argument_list|,
literal|4
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"logical*4"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|24
case|:
name|rettype
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_BOOL
argument_list|,
literal|4
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"logical"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|25
case|:
comment|/* Complex type consisting of two IEEE single precision values.  */
name|rettype
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_COMPLEX
argument_list|,
literal|8
argument_list|,
literal|0
argument_list|,
literal|"complex"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|26
case|:
comment|/* Complex type consisting of two IEEE double precision values.  */
name|rettype
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_COMPLEX
argument_list|,
literal|16
argument_list|,
literal|0
argument_list|,
literal|"double complex"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|27
case|:
name|rettype
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"integer*1"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|28
case|:
name|rettype
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"integer*2"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|29
case|:
name|rettype
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
literal|"integer*4"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|30
case|:
name|rettype
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_CHAR
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"wchar"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|31
case|:
name|rettype
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|8
argument_list|,
literal|0
argument_list|,
literal|"long long"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|32
case|:
name|rettype
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|8
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"unsigned long long"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|33
case|:
name|rettype
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|8
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"logical*8"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|34
case|:
name|rettype
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|8
argument_list|,
literal|0
argument_list|,
literal|"integer*8"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
name|negative_types
index|[
operator|-
name|typenum
index|]
operator|=
name|rettype
expr_stmt|;
return|return
name|rettype
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This page contains subroutines of read_type.  */
end_comment

begin_comment
comment|/* Read member function stabs info for C++ classes.  The form of each member    function data is:     NAME :: TYPENUM[=type definition] ARGS : PHYSNAME ;     An example with two member functions is:     afunc1::20=##15;:i;2A.;afunc2::20:i;2A.;     For the case of overloaded operators, the format is op$::*.funcs, where    $ is the CPLUS_MARKER (usually '$'), `*' holds the place for an operator    name (such as `+=') and `.' marks the end of the operator name.     Returns 1 for success, 0 for failure.  */
end_comment

begin_function
specifier|static
name|int
name|read_member_functions
parameter_list|(
name|struct
name|field_info
modifier|*
name|fip
parameter_list|,
name|char
modifier|*
modifier|*
name|pp
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|int
name|nfn_fields
init|=
literal|0
decl_stmt|;
name|int
name|length
init|=
literal|0
decl_stmt|;
name|int
name|skip_method
decl_stmt|;
comment|/* Total number of member functions defined in this class.  If the class      defines two `f' functions, and one `g' function, then this will have      the value 3.  */
name|int
name|total_length
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
struct|struct
name|next_fnfield
block|{
name|struct
name|next_fnfield
modifier|*
name|next
decl_stmt|;
name|struct
name|fn_field
name|fn_field
decl_stmt|;
block|}
modifier|*
name|sublist
struct|;
name|struct
name|type
modifier|*
name|look_ahead_type
decl_stmt|;
name|struct
name|next_fnfieldlist
modifier|*
name|new_fnlist
decl_stmt|;
name|struct
name|next_fnfield
modifier|*
name|new_sublist
decl_stmt|;
name|char
modifier|*
name|main_fn_name
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Process each list until we find something that is not a member function      or find the end of the functions. */
while|while
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|';'
condition|)
block|{
comment|/* We should be positioned at the start of the function name.          Scan forward to find the first ':' and if it is not the          first of a "::" delimiter, then this is not a member function. */
name|p
operator|=
operator|*
name|pp
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|':'
condition|)
block|{
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|!=
literal|':'
condition|)
block|{
break|break;
block|}
name|sublist
operator|=
name|NULL
expr_stmt|;
name|look_ahead_type
operator|=
name|NULL
expr_stmt|;
name|length
operator|=
literal|0
expr_stmt|;
name|skip_method
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
operator|-
operator|*
name|pp
operator|==
name|strlen
argument_list|(
literal|"__base_ctor"
argument_list|)
operator|&&
name|strncmp
argument_list|(
operator|*
name|pp
argument_list|,
literal|"__base_ctor"
argument_list|,
name|strlen
argument_list|(
literal|"__base_ctor"
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|skip_method
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|-
operator|*
name|pp
operator|==
name|strlen
argument_list|(
literal|"__base_dtor"
argument_list|)
operator|&&
name|strncmp
argument_list|(
operator|*
name|pp
argument_list|,
literal|"__base_dtor"
argument_list|,
name|strlen
argument_list|(
literal|"__base_dtor"
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|skip_method
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|-
operator|*
name|pp
operator|==
name|strlen
argument_list|(
literal|"__deleting_dtor"
argument_list|)
operator|&&
name|strncmp
argument_list|(
operator|*
name|pp
argument_list|,
literal|"__deleting_dtor"
argument_list|,
name|strlen
argument_list|(
literal|"__deleting_dtor"
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|skip_method
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|skip_method
condition|)
block|{
comment|/* Skip past '::'.  */
operator|*
name|pp
operator|=
name|p
operator|+
literal|2
expr_stmt|;
comment|/* Read the type.  */
name|read_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* Skip past the colon, mangled name, semicolon, flags, and final 	     semicolon.  */
while|while
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|';'
condition|)
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
while|while
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|';'
condition|)
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
continue|continue;
block|}
name|new_fnlist
operator|=
operator|(
expr|struct
name|next_fnfieldlist
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|next_fnfieldlist
argument_list|)
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|new_fnlist
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|new_fnlist
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|next_fnfieldlist
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|pp
operator|)
index|[
literal|0
index|]
operator|==
literal|'o'
operator|&&
operator|(
operator|*
name|pp
operator|)
index|[
literal|1
index|]
operator|==
literal|'p'
operator|&&
name|is_cplus_marker
argument_list|(
operator|(
operator|*
name|pp
operator|)
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
comment|/* This is a completely wierd case.  In order to stuff in the 	     names that might contain colons (the usual name delimiter), 	     Mike Tiemann defined a different name format which is 	     signalled if the identifier is "op$".  In that case, the 	     format is "op$::XXXX." where XXXX is the name.  This is 	     used for names like "+" or "=".  YUUUUUUUK!  FIXME!  */
comment|/* This lets the user type "break operator+". 	     We could just put in "+" as the name, but that wouldn't 	     work for "*".  */
specifier|static
name|char
name|opname
index|[
literal|32
index|]
init|=
block|{
literal|'o'
block|,
literal|'p'
block|,
name|CPLUS_MARKER
block|}
decl_stmt|;
name|char
modifier|*
name|o
init|=
name|opname
operator|+
literal|3
decl_stmt|;
comment|/* Skip past '::'.  */
operator|*
name|pp
operator|=
name|p
operator|+
literal|2
expr_stmt|;
name|STABS_CONTINUE
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|p
operator|=
operator|*
name|pp
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'.'
condition|)
block|{
operator|*
name|o
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
name|main_fn_name
operator|=
name|savestring
argument_list|(
name|opname
argument_list|,
name|o
operator|-
name|opname
argument_list|)
expr_stmt|;
comment|/* Skip past '.'  */
operator|*
name|pp
operator|=
name|p
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|main_fn_name
operator|=
name|savestring
argument_list|(
operator|*
name|pp
argument_list|,
name|p
operator|-
operator|*
name|pp
argument_list|)
expr_stmt|;
comment|/* Skip past '::'.  */
operator|*
name|pp
operator|=
name|p
operator|+
literal|2
expr_stmt|;
block|}
name|new_fnlist
operator|->
name|fn_fieldlist
operator|.
name|name
operator|=
name|main_fn_name
expr_stmt|;
do|do
block|{
name|new_sublist
operator|=
operator|(
expr|struct
name|next_fnfield
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|next_fnfield
argument_list|)
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|new_sublist
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|new_sublist
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|next_fnfield
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check for and handle cretinous dbx symbol name continuation!  */
if|if
condition|(
name|look_ahead_type
operator|==
name|NULL
condition|)
block|{
comment|/* Normal case. */
name|STABS_CONTINUE
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|new_sublist
operator|->
name|fn_field
operator|.
name|type
operator|=
name|read_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|':'
condition|)
block|{
comment|/* Invalid symtab info for member function.  */
return|return
literal|0
return|;
block|}
block|}
else|else
block|{
comment|/* g++ version 1 kludge */
name|new_sublist
operator|->
name|fn_field
operator|.
name|type
operator|=
name|look_ahead_type
expr_stmt|;
name|look_ahead_type
operator|=
name|NULL
expr_stmt|;
block|}
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
name|p
operator|=
operator|*
name|pp
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|';'
condition|)
block|{
name|p
operator|++
expr_stmt|;
block|}
comment|/* If this is just a stub, then we don't have the real name here. */
if|if
condition|(
name|TYPE_STUB
argument_list|(
name|new_sublist
operator|->
name|fn_field
operator|.
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|TYPE_DOMAIN_TYPE
argument_list|(
name|new_sublist
operator|->
name|fn_field
operator|.
name|type
argument_list|)
condition|)
name|TYPE_DOMAIN_TYPE
argument_list|(
name|new_sublist
operator|->
name|fn_field
operator|.
name|type
argument_list|)
operator|=
name|type
expr_stmt|;
name|new_sublist
operator|->
name|fn_field
operator|.
name|is_stub
operator|=
literal|1
expr_stmt|;
block|}
name|new_sublist
operator|->
name|fn_field
operator|.
name|physname
operator|=
name|savestring
argument_list|(
operator|*
name|pp
argument_list|,
name|p
operator|-
operator|*
name|pp
argument_list|)
expr_stmt|;
operator|*
name|pp
operator|=
name|p
operator|+
literal|1
expr_stmt|;
comment|/* Set this member function's visibility fields.  */
switch|switch
condition|(
operator|*
operator|(
operator|*
name|pp
operator|)
operator|++
condition|)
block|{
case|case
name|VISIBILITY_PRIVATE
case|:
name|new_sublist
operator|->
name|fn_field
operator|.
name|is_private
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|VISIBILITY_PROTECTED
case|:
name|new_sublist
operator|->
name|fn_field
operator|.
name|is_protected
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|STABS_CONTINUE
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
operator|*
name|pp
condition|)
block|{
case|case
literal|'A'
case|:
comment|/* Normal functions. */
name|new_sublist
operator|->
name|fn_field
operator|.
name|is_const
operator|=
literal|0
expr_stmt|;
name|new_sublist
operator|->
name|fn_field
operator|.
name|is_volatile
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
comment|/* `const' member functions. */
name|new_sublist
operator|->
name|fn_field
operator|.
name|is_const
operator|=
literal|1
expr_stmt|;
name|new_sublist
operator|->
name|fn_field
operator|.
name|is_volatile
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
comment|/* `volatile' member function. */
name|new_sublist
operator|->
name|fn_field
operator|.
name|is_const
operator|=
literal|0
expr_stmt|;
name|new_sublist
operator|->
name|fn_field
operator|.
name|is_volatile
operator|=
literal|1
expr_stmt|;
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
comment|/* `const volatile' member function. */
name|new_sublist
operator|->
name|fn_field
operator|.
name|is_const
operator|=
literal|1
expr_stmt|;
name|new_sublist
operator|->
name|fn_field
operator|.
name|is_volatile
operator|=
literal|1
expr_stmt|;
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
comment|/* File compiled with g++ version 1 -- no info */
case|case
literal|'?'
case|:
case|case
literal|'.'
case|:
break|break;
default|default:
name|complain
argument_list|(
operator|&
name|const_vol_complaint
argument_list|,
operator|*
operator|*
name|pp
argument_list|)
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
operator|*
operator|(
operator|*
name|pp
operator|)
operator|++
condition|)
block|{
case|case
literal|'*'
case|:
block|{
name|int
name|nbits
decl_stmt|;
comment|/* virtual member function, followed by index. 		   The sign bit is set to distinguish pointers-to-methods 		   from virtual function indicies.  Since the array is 		   in words, the quantity must be shifted left by 1 		   on 16 bit machine, and by 2 on 32 bit machine, forcing 		   the sign bit out, and usable as a valid index into 		   the array.  Remove the sign bit here.  */
name|new_sublist
operator|->
name|fn_field
operator|.
name|voffset
operator|=
operator|(
literal|0x7fffffff
operator|&
name|read_huge_number
argument_list|(
name|pp
argument_list|,
literal|';'
argument_list|,
operator|&
name|nbits
argument_list|)
operator|)
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|nbits
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
name|STABS_CONTINUE
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|';'
operator|||
operator|*
operator|*
name|pp
operator|==
literal|'\0'
condition|)
block|{
comment|/* Must be g++ version 1.  */
name|new_sublist
operator|->
name|fn_field
operator|.
name|fcontext
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Figure out from whence this virtual function came. 		       It may belong to virtual function table of 		       one of its baseclasses.  */
name|look_ahead_type
operator|=
name|read_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|':'
condition|)
block|{
comment|/* g++ version 1 overloaded methods. */
block|}
else|else
block|{
name|new_sublist
operator|->
name|fn_field
operator|.
name|fcontext
operator|=
name|look_ahead_type
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|';'
condition|)
block|{
return|return
literal|0
return|;
block|}
else|else
block|{
operator|++
operator|*
name|pp
expr_stmt|;
block|}
name|look_ahead_type
operator|=
name|NULL
expr_stmt|;
block|}
block|}
break|break;
block|}
case|case
literal|'?'
case|:
comment|/* static member function.  */
name|new_sublist
operator|->
name|fn_field
operator|.
name|voffset
operator|=
name|VOFFSET_STATIC
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|new_sublist
operator|->
name|fn_field
operator|.
name|physname
argument_list|,
name|main_fn_name
argument_list|,
name|strlen
argument_list|(
name|main_fn_name
argument_list|)
argument_list|)
condition|)
block|{
name|new_sublist
operator|->
name|fn_field
operator|.
name|is_stub
operator|=
literal|1
expr_stmt|;
block|}
break|break;
default|default:
comment|/* error */
name|complain
argument_list|(
operator|&
name|member_fn_complaint
argument_list|,
operator|(
operator|*
name|pp
operator|)
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* Fall through into normal member function.  */
case|case
literal|'.'
case|:
comment|/* normal member function.  */
name|new_sublist
operator|->
name|fn_field
operator|.
name|voffset
operator|=
literal|0
expr_stmt|;
name|new_sublist
operator|->
name|fn_field
operator|.
name|fcontext
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|new_sublist
operator|->
name|next
operator|=
name|sublist
expr_stmt|;
name|sublist
operator|=
name|new_sublist
expr_stmt|;
name|length
operator|++
expr_stmt|;
name|STABS_CONTINUE
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|';'
operator|&&
operator|*
operator|*
name|pp
operator|!=
literal|'\0'
condition|)
do|;
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
name|new_fnlist
operator|->
name|fn_fieldlist
operator|.
name|fn_fields
operator|=
operator|(
expr|struct
name|fn_field
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|type_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|fn_field
argument_list|)
operator|*
name|length
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|new_fnlist
operator|->
name|fn_fieldlist
operator|.
name|fn_fields
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|fn_field
argument_list|)
operator|*
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|length
init|;
operator|(
name|i
operator|--
operator|,
name|sublist
operator|)
condition|;
name|sublist
operator|=
name|sublist
operator|->
name|next
control|)
block|{
name|new_fnlist
operator|->
name|fn_fieldlist
operator|.
name|fn_fields
index|[
name|i
index|]
operator|=
name|sublist
operator|->
name|fn_field
expr_stmt|;
block|}
name|new_fnlist
operator|->
name|fn_fieldlist
operator|.
name|length
operator|=
name|length
expr_stmt|;
name|new_fnlist
operator|->
name|next
operator|=
name|fip
operator|->
name|fnlist
expr_stmt|;
name|fip
operator|->
name|fnlist
operator|=
name|new_fnlist
expr_stmt|;
name|nfn_fields
operator|++
expr_stmt|;
name|total_length
operator|+=
name|length
expr_stmt|;
name|STABS_CONTINUE
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nfn_fields
condition|)
block|{
name|ALLOCATE_CPLUS_STRUCT_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_FN_FIELDLISTS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
expr|struct
name|fn_fieldlist
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|type
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|fn_fieldlist
argument_list|)
operator|*
name|nfn_fields
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|TYPE_FN_FIELDLISTS
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|fn_fieldlist
argument_list|)
operator|*
name|nfn_fields
argument_list|)
expr_stmt|;
name|TYPE_NFN_FIELDS
argument_list|(
name|type
argument_list|)
operator|=
name|nfn_fields
expr_stmt|;
name|TYPE_NFN_FIELDS_TOTAL
argument_list|(
name|type
argument_list|)
operator|=
name|total_length
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Special GNU C++ name.     Returns 1 for success, 0 for failure.  "failure" means that we can't    keep parsing and it's time for error_type().  */
end_comment

begin_function
specifier|static
name|int
name|read_cpp_abbrev
parameter_list|(
name|struct
name|field_info
modifier|*
name|fip
parameter_list|,
name|char
modifier|*
modifier|*
name|pp
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|cpp_abbrev
decl_stmt|;
name|struct
name|type
modifier|*
name|context
decl_stmt|;
name|p
operator|=
operator|*
name|pp
expr_stmt|;
if|if
condition|(
operator|*
operator|++
name|p
operator|==
literal|'v'
condition|)
block|{
name|name
operator|=
name|NULL
expr_stmt|;
name|cpp_abbrev
operator|=
operator|*
operator|++
name|p
expr_stmt|;
operator|*
name|pp
operator|=
name|p
operator|+
literal|1
expr_stmt|;
comment|/* At this point, *pp points to something like "22:23=*22...",          where the type number before the ':' is the "context" and          everything after is a regular type definition.  Lookup the          type, find it's name, and construct the field name. */
name|context
operator|=
name|read_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cpp_abbrev
condition|)
block|{
case|case
literal|'f'
case|:
comment|/* $vf -- a virtual function table pointer */
name|name
operator|=
name|type_name_no_tag
argument_list|(
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
name|name
operator|=
literal|""
expr_stmt|;
block|}
name|fip
operator|->
name|list
operator|->
name|field
operator|.
name|name
operator|=
name|obconcat
argument_list|(
operator|&
name|objfile
operator|->
name|type_obstack
argument_list|,
name|vptr_name
argument_list|,
name|name
argument_list|,
literal|""
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
comment|/* $vb -- a virtual bsomethingorother */
name|name
operator|=
name|type_name_no_tag
argument_list|(
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
name|complain
argument_list|(
operator|&
name|invalid_cpp_type_complaint
argument_list|,
name|symnum
argument_list|)
expr_stmt|;
name|name
operator|=
literal|"FOO"
expr_stmt|;
block|}
name|fip
operator|->
name|list
operator|->
name|field
operator|.
name|name
operator|=
name|obconcat
argument_list|(
operator|&
name|objfile
operator|->
name|type_obstack
argument_list|,
name|vb_name
argument_list|,
name|name
argument_list|,
literal|""
argument_list|)
expr_stmt|;
break|break;
default|default:
name|complain
argument_list|(
operator|&
name|invalid_cpp_abbrev_complaint
argument_list|,
operator|*
name|pp
argument_list|)
expr_stmt|;
name|fip
operator|->
name|list
operator|->
name|field
operator|.
name|name
operator|=
name|obconcat
argument_list|(
operator|&
name|objfile
operator|->
name|type_obstack
argument_list|,
literal|"INVALID_CPLUSPLUS_ABBREV"
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* At this point, *pp points to the ':'.  Skip it and read the          field type. */
name|p
operator|=
operator|++
operator|(
operator|*
name|pp
operator|)
expr_stmt|;
if|if
condition|(
name|p
index|[
operator|-
literal|1
index|]
operator|!=
literal|':'
condition|)
block|{
name|complain
argument_list|(
operator|&
name|invalid_cpp_abbrev_complaint
argument_list|,
operator|*
name|pp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|fip
operator|->
name|list
operator|->
name|field
operator|.
name|type
operator|=
name|read_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|','
condition|)
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
comment|/* Skip the comma.  */
else|else
return|return
literal|0
return|;
block|{
name|int
name|nbits
decl_stmt|;
name|FIELD_BITPOS
argument_list|(
name|fip
operator|->
name|list
operator|->
name|field
argument_list|)
operator|=
name|read_huge_number
argument_list|(
name|pp
argument_list|,
literal|';'
argument_list|,
operator|&
name|nbits
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbits
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
block|}
comment|/* This field is unpacked.  */
name|FIELD_BITSIZE
argument_list|(
name|fip
operator|->
name|list
operator|->
name|field
argument_list|)
operator|=
literal|0
expr_stmt|;
name|fip
operator|->
name|list
operator|->
name|visibility
operator|=
name|VISIBILITY_PRIVATE
expr_stmt|;
block|}
else|else
block|{
name|complain
argument_list|(
operator|&
name|invalid_cpp_abbrev_complaint
argument_list|,
operator|*
name|pp
argument_list|)
expr_stmt|;
comment|/* We have no idea what syntax an unrecognized abbrev would have, so          better return 0.  If we returned 1, we would need to at least advance          *pp to avoid an infinite loop.  */
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|read_one_struct_field
parameter_list|(
name|struct
name|field_info
modifier|*
name|fip
parameter_list|,
name|char
modifier|*
modifier|*
name|pp
parameter_list|,
name|char
modifier|*
name|p
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
comment|/* The following is code to work around cfront generated stabs.      The stabs contains full mangled name for each field.      We try to demangle the name and extract the field name out of it.    */
if|if
condition|(
name|ARM_DEMANGLING
operator|&&
name|current_subfile
operator|->
name|language
operator|==
name|language_cplus
condition|)
block|{
name|char
name|save_p
decl_stmt|;
name|char
modifier|*
name|dem
decl_stmt|,
modifier|*
name|dem_p
decl_stmt|;
name|save_p
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|dem
operator|=
name|cplus_demangle
argument_list|(
operator|*
name|pp
argument_list|,
name|DMGL_ANSI
operator||
name|DMGL_PARAMS
argument_list|)
expr_stmt|;
if|if
condition|(
name|dem
operator|!=
name|NULL
condition|)
block|{
name|dem_p
operator|=
name|strrchr
argument_list|(
name|dem
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|dem_p
operator|!=
literal|0
operator|&&
operator|*
operator|(
name|dem_p
operator|-
literal|1
operator|)
operator|==
literal|':'
condition|)
name|dem_p
operator|++
expr_stmt|;
name|FIELD_NAME
argument_list|(
name|fip
operator|->
name|list
operator|->
name|field
argument_list|)
operator|=
name|obsavestring
argument_list|(
name|dem_p
argument_list|,
name|strlen
argument_list|(
name|dem_p
argument_list|)
argument_list|,
operator|&
name|objfile
operator|->
name|type_obstack
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|FIELD_NAME
argument_list|(
name|fip
operator|->
name|list
operator|->
name|field
argument_list|)
operator|=
name|obsavestring
argument_list|(
operator|*
name|pp
argument_list|,
name|p
operator|-
operator|*
name|pp
argument_list|,
operator|&
name|objfile
operator|->
name|type_obstack
argument_list|)
expr_stmt|;
block|}
operator|*
name|p
operator|=
name|save_p
expr_stmt|;
block|}
comment|/* end of code for cfront work around */
else|else
name|fip
operator|->
name|list
operator|->
name|field
operator|.
name|name
operator|=
name|obsavestring
argument_list|(
operator|*
name|pp
argument_list|,
name|p
operator|-
operator|*
name|pp
argument_list|,
operator|&
name|objfile
operator|->
name|type_obstack
argument_list|)
expr_stmt|;
operator|*
name|pp
operator|=
name|p
operator|+
literal|1
expr_stmt|;
comment|/* This means we have a visibility for a field coming. */
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|'/'
condition|)
block|{
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
name|fip
operator|->
name|list
operator|->
name|visibility
operator|=
operator|*
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* normal dbx-style format, no explicit visibility */
name|fip
operator|->
name|list
operator|->
name|visibility
operator|=
name|VISIBILITY_PUBLIC
expr_stmt|;
block|}
name|fip
operator|->
name|list
operator|->
name|field
operator|.
name|type
operator|=
name|read_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|':'
condition|)
block|{
name|p
operator|=
operator|++
operator|(
operator|*
name|pp
operator|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Possible future hook for nested types. */
block|if (**pp == '!') 	{ 	  fip->list->field.bitpos = (long) -2;
comment|/* nested type */
block|p = ++(*pp); 	}       else 	...;
endif|#
directive|endif
while|while
condition|(
operator|*
name|p
operator|!=
literal|';'
condition|)
block|{
name|p
operator|++
expr_stmt|;
block|}
comment|/* Static class member.  */
name|SET_FIELD_PHYSNAME
argument_list|(
name|fip
operator|->
name|list
operator|->
name|field
argument_list|,
name|savestring
argument_list|(
operator|*
name|pp
argument_list|,
name|p
operator|-
operator|*
name|pp
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|pp
operator|=
name|p
operator|+
literal|1
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|','
condition|)
block|{
comment|/* Bad structure-type format.  */
name|complain
argument_list|(
operator|&
name|stabs_general_complaint
argument_list|,
literal|"bad structure-type format"
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
comment|/* Skip the comma.  */
block|{
name|int
name|nbits
decl_stmt|;
name|FIELD_BITPOS
argument_list|(
name|fip
operator|->
name|list
operator|->
name|field
argument_list|)
operator|=
name|read_huge_number
argument_list|(
name|pp
argument_list|,
literal|','
argument_list|,
operator|&
name|nbits
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbits
operator|!=
literal|0
condition|)
block|{
name|complain
argument_list|(
operator|&
name|stabs_general_complaint
argument_list|,
literal|"bad structure-type format"
argument_list|)
expr_stmt|;
return|return;
block|}
name|FIELD_BITSIZE
argument_list|(
name|fip
operator|->
name|list
operator|->
name|field
argument_list|)
operator|=
name|read_huge_number
argument_list|(
name|pp
argument_list|,
literal|';'
argument_list|,
operator|&
name|nbits
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbits
operator|!=
literal|0
condition|)
block|{
name|complain
argument_list|(
operator|&
name|stabs_general_complaint
argument_list|,
literal|"bad structure-type format"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|FIELD_BITPOS
argument_list|(
name|fip
operator|->
name|list
operator|->
name|field
argument_list|)
operator|==
literal|0
operator|&&
name|FIELD_BITSIZE
argument_list|(
name|fip
operator|->
name|list
operator|->
name|field
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* This can happen in two cases: (1) at least for gcc 2.4.5 or so,          it is a field which has been optimized out.  The correct stab for          this case is to use VISIBILITY_IGNORE, but that is a recent          invention.  (2) It is a 0-size array.  For example          union { int num; char str[0]; } foo.  Printing "<no value>" for          str in "p foo" is OK, since foo.str (and thus foo.str[3])          will continue to work, and a 0-size array as a whole doesn't          have any contents to print.           I suspect this probably could also happen with gcc -gstabs (not          -gstabs+) for static fields, and perhaps other C++ extensions.          Hopefully few people use -gstabs with gdb, since it is intended          for dbx compatibility.  */
comment|/* Ignore this field.  */
name|fip
operator|->
name|list
operator|->
name|visibility
operator|=
name|VISIBILITY_IGNORE
expr_stmt|;
block|}
else|else
block|{
comment|/* Detect an unpacked field and mark it as such.          dbx gives a bit size for all fields.          Note that forward refs cannot be packed,          and treat enums as if they had the width of ints.  */
name|struct
name|type
modifier|*
name|field_type
init|=
name|check_typedef
argument_list|(
name|FIELD_TYPE
argument_list|(
name|fip
operator|->
name|list
operator|->
name|field
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|field_type
argument_list|)
operator|!=
name|TYPE_CODE_INT
operator|&&
name|TYPE_CODE
argument_list|(
name|field_type
argument_list|)
operator|!=
name|TYPE_CODE_RANGE
operator|&&
name|TYPE_CODE
argument_list|(
name|field_type
argument_list|)
operator|!=
name|TYPE_CODE_BOOL
operator|&&
name|TYPE_CODE
argument_list|(
name|field_type
argument_list|)
operator|!=
name|TYPE_CODE_ENUM
condition|)
block|{
name|FIELD_BITSIZE
argument_list|(
name|fip
operator|->
name|list
operator|->
name|field
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|FIELD_BITSIZE
argument_list|(
name|fip
operator|->
name|list
operator|->
name|field
argument_list|)
operator|==
name|TARGET_CHAR_BIT
operator|*
name|TYPE_LENGTH
argument_list|(
name|field_type
argument_list|)
operator|||
operator|(
name|TYPE_CODE
argument_list|(
name|field_type
argument_list|)
operator|==
name|TYPE_CODE_ENUM
operator|&&
name|FIELD_BITSIZE
argument_list|(
name|fip
operator|->
name|list
operator|->
name|field
argument_list|)
operator|==
name|TARGET_INT_BIT
operator|)
operator|)
operator|&&
name|FIELD_BITPOS
argument_list|(
name|fip
operator|->
name|list
operator|->
name|field
argument_list|)
operator|%
literal|8
operator|==
literal|0
condition|)
block|{
name|FIELD_BITSIZE
argument_list|(
name|fip
operator|->
name|list
operator|->
name|field
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Read struct or class data fields.  They have the form:     NAME : [VISIBILITY] TYPENUM , BITPOS , BITSIZE ;     At the end, we see a semicolon instead of a field.     In C++, this may wind up being NAME:?TYPENUM:PHYSNAME; for    a static field.     The optional VISIBILITY is one of:     '/0' (VISIBILITY_PRIVATE)    '/1' (VISIBILITY_PROTECTED)    '/2' (VISIBILITY_PUBLIC)    '/9' (VISIBILITY_IGNORE)     or nothing, for C style fields with public visibility.     Returns 1 for success, 0 for failure.  */
end_comment

begin_function
specifier|static
name|int
name|read_struct_fields
parameter_list|(
name|struct
name|field_info
modifier|*
name|fip
parameter_list|,
name|char
modifier|*
modifier|*
name|pp
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|struct
name|nextfield
modifier|*
name|new
decl_stmt|;
comment|/* We better set p right now, in case there are no fields at all...    */
name|p
operator|=
operator|*
name|pp
expr_stmt|;
comment|/* Read each data member type until we find the terminating ';' at the end of      the data member list, or break for some other reason such as finding the      start of the member function list. */
comment|/* Stab string for structure/union does not end with two ';' in      SUN C compiler 5.3 i.e. F6U2, hence check for end of string. */
while|while
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|';'
operator|&&
operator|*
operator|*
name|pp
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|os9k_stabs
operator|&&
operator|*
operator|*
name|pp
operator|==
literal|','
condition|)
break|break;
name|STABS_CONTINUE
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* Get space to record the next field's data.  */
name|new
operator|=
operator|(
expr|struct
name|nextfield
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nextfield
argument_list|)
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|new
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nextfield
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|fip
operator|->
name|list
expr_stmt|;
name|fip
operator|->
name|list
operator|=
name|new
expr_stmt|;
comment|/* Get the field name.  */
name|p
operator|=
operator|*
name|pp
expr_stmt|;
comment|/* If is starts with CPLUS_MARKER it is a special abbreviation,          unless the CPLUS_MARKER is followed by an underscore, in          which case it is just the name of an anonymous type, which we          should handle like any other type name.  */
if|if
condition|(
name|is_cplus_marker
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
operator|&&
name|p
index|[
literal|1
index|]
operator|!=
literal|'_'
condition|)
block|{
if|if
condition|(
operator|!
name|read_cpp_abbrev
argument_list|(
name|fip
argument_list|,
name|pp
argument_list|,
name|type
argument_list|,
name|objfile
argument_list|)
condition|)
return|return
literal|0
return|;
continue|continue;
block|}
comment|/* Look for the ':' that separates the field name from the field          values.  Data members are delimited by a single ':', while member          functions are delimited by a pair of ':'s.  When we hit the member          functions (if any), terminate scan loop and return. */
while|while
condition|(
operator|*
name|p
operator|!=
literal|':'
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
return|return
literal|0
return|;
comment|/* Check to see if we have hit the member functions yet.  */
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
block|{
break|break;
block|}
name|read_one_struct_field
argument_list|(
name|fip
argument_list|,
name|pp
argument_list|,
name|p
argument_list|,
name|type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|':'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
block|{
comment|/* chill the list of fields: the last entry (at the head) is a          partially constructed entry which we now scrub. */
name|fip
operator|->
name|list
operator|=
name|fip
operator|->
name|list
operator|->
name|next
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* *INDENT-OFF* */
end_comment

begin_comment
comment|/* The stabs for C++ derived classes contain baseclass information which    is marked by a '!' character after the total size.  This function is    called when we encounter the baseclass marker, and slurps up all the    baseclass information.     Immediately following the '!' marker is the number of base classes that    the class is derived from, followed by information for each base class.    For each base class, there are two visibility specifiers, a bit offset    to the base class information within the derived class, a reference to    the type for the base class, and a terminating semicolon.     A typical example, with two base classes, would be "!2,020,19;0264,21;".    						       ^^ ^ ^ ^  ^ ^  ^ 	Baseclass information marker __________________|| | | |  | |  | 	Number of baseclasses __________________________| | | |  | |  | 	Visibility specifiers (2) ________________________| | |  | |  | 	Offset in bits from start of class _________________| |  | |  | 	Type number for base class ___________________________|  | |  | 	Visibility specifiers (2) _______________________________| |  | 	Offset in bits from start of class ________________________|  | 	Type number of base class ____________________________________|    Return 1 for success, 0 for (error-type-inducing) failure.  */
end_comment

begin_comment
comment|/* *INDENT-ON* */
end_comment

begin_function
specifier|static
name|int
name|read_baseclasses
parameter_list|(
name|struct
name|field_info
modifier|*
name|fip
parameter_list|,
name|char
modifier|*
modifier|*
name|pp
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|nextfield
modifier|*
name|new
decl_stmt|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|'!'
condition|)
block|{
return|return
literal|1
return|;
block|}
else|else
block|{
comment|/* Skip the '!' baseclass information marker. */
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
block|}
name|ALLOCATE_CPLUS_STRUCT_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|{
name|int
name|nbits
decl_stmt|;
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
operator|=
name|read_huge_number
argument_list|(
name|pp
argument_list|,
literal|','
argument_list|,
operator|&
name|nbits
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbits
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
block|}
if|#
directive|if
literal|0
comment|/* Some stupid compilers have trouble with the following, so break      it up into simpler expressions.  */
block|TYPE_FIELD_VIRTUAL_BITS (type) = (B_TYPE *)     TYPE_ALLOC (type, B_BYTES (TYPE_N_BASECLASSES (type)));
else|#
directive|else
block|{
name|int
name|num_bytes
init|=
name|B_BYTES
argument_list|(
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
name|char
modifier|*
name|pointer
decl_stmt|;
name|pointer
operator|=
operator|(
name|char
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|type
argument_list|,
name|num_bytes
argument_list|)
expr_stmt|;
name|TYPE_FIELD_VIRTUAL_BITS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
name|B_TYPE
operator|*
operator|)
name|pointer
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 0 */
name|B_CLRALL
argument_list|(
name|TYPE_FIELD_VIRTUAL_BITS
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|new
operator|=
operator|(
expr|struct
name|nextfield
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nextfield
argument_list|)
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|new
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nextfield
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|fip
operator|->
name|list
expr_stmt|;
name|fip
operator|->
name|list
operator|=
name|new
expr_stmt|;
name|FIELD_BITSIZE
argument_list|(
name|new
operator|->
name|field
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* this should be an unpacked field! */
name|STABS_CONTINUE
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
operator|*
name|pp
condition|)
block|{
case|case
literal|'0'
case|:
comment|/* Nothing to do. */
break|break;
case|case
literal|'1'
case|:
name|SET_TYPE_FIELD_VIRTUAL
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Unknown character.  Complain and treat it as non-virtual.  */
block|{
specifier|static
name|struct
name|complaint
name|msg
init|=
block|{
literal|"Unknown virtual character `%c' for baseclass"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|complain
argument_list|(
operator|&
name|msg
argument_list|,
operator|*
operator|*
name|pp
argument_list|)
expr_stmt|;
block|}
block|}
operator|++
operator|(
operator|*
name|pp
operator|)
expr_stmt|;
name|new
operator|->
name|visibility
operator|=
operator|*
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
switch|switch
condition|(
name|new
operator|->
name|visibility
condition|)
block|{
case|case
name|VISIBILITY_PRIVATE
case|:
case|case
name|VISIBILITY_PROTECTED
case|:
case|case
name|VISIBILITY_PUBLIC
case|:
break|break;
default|default:
comment|/* Bad visibility format.  Complain and treat it as 	     public.  */
block|{
specifier|static
name|struct
name|complaint
name|msg
init|=
block|{
literal|"Unknown visibility `%c' for baseclass"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|complain
argument_list|(
operator|&
name|msg
argument_list|,
name|new
operator|->
name|visibility
argument_list|)
expr_stmt|;
name|new
operator|->
name|visibility
operator|=
name|VISIBILITY_PUBLIC
expr_stmt|;
block|}
block|}
block|{
name|int
name|nbits
decl_stmt|;
comment|/* The remaining value is the bit offset of the portion of the object 	   corresponding to this baseclass.  Always zero in the absence of 	   multiple inheritance.  */
name|FIELD_BITPOS
argument_list|(
name|new
operator|->
name|field
argument_list|)
operator|=
name|read_huge_number
argument_list|(
name|pp
argument_list|,
literal|','
argument_list|,
operator|&
name|nbits
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbits
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
block|}
comment|/* The last piece of baseclass information is the type of the          base class.  Read it, and remember it's type name as this          field's name. */
name|new
operator|->
name|field
operator|.
name|type
operator|=
name|read_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|new
operator|->
name|field
operator|.
name|name
operator|=
name|type_name_no_tag
argument_list|(
name|new
operator|->
name|field
operator|.
name|type
argument_list|)
expr_stmt|;
comment|/* skip trailing ';' and bump count of number of fields seen */
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|';'
condition|)
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
else|else
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* The tail end of stabs for C++ classes that contain a virtual function    pointer contains a tilde, a %, and a type number.    The type number refers to the base class (possibly this class itself) which    contains the vtable pointer for the current class.     This function is called when we have parsed all the method declarations,    so we can look for the vptr base class info.  */
end_comment

begin_function
specifier|static
name|int
name|read_tilde_fields
parameter_list|(
name|struct
name|field_info
modifier|*
name|fip
parameter_list|,
name|char
modifier|*
modifier|*
name|pp
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|STABS_CONTINUE
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* If we are positioned at a ';', then skip it. */
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|';'
condition|)
block|{
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|'~'
condition|)
block|{
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|'='
operator|||
operator|*
operator|*
name|pp
operator|==
literal|'+'
operator|||
operator|*
operator|*
name|pp
operator|==
literal|'-'
condition|)
block|{
comment|/* Obsolete flags that used to indicate the presence 	     of constructors and/or destructors. */
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
block|}
comment|/* Read either a '%' or the final ';'.  */
if|if
condition|(
operator|*
operator|(
operator|*
name|pp
operator|)
operator|++
operator|==
literal|'%'
condition|)
block|{
comment|/* The next number is the type number of the base class 	     (possibly our own class) which supplies the vtable for 	     this class.  Parse it out, and search that class to find 	     its vtable pointer, and install those into TYPE_VPTR_BASETYPE 	     and TYPE_VPTR_FIELDNO.  */
name|struct
name|type
modifier|*
name|t
decl_stmt|;
name|int
name|i
decl_stmt|;
name|t
operator|=
name|read_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|*
name|p
operator|!=
literal|';'
condition|)
block|{
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
comment|/* Premature end of symbol.  */
return|return
literal|0
return|;
block|}
name|TYPE_VPTR_BASETYPE
argument_list|(
name|type
argument_list|)
operator|=
name|t
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|t
condition|)
comment|/* Our own class provides vtbl ptr */
block|{
for|for
control|(
name|i
operator|=
name|TYPE_NFIELDS
argument_list|(
name|t
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
name|TYPE_N_BASECLASSES
argument_list|(
name|t
argument_list|)
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|TYPE_FIELD_NAME
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
argument_list|,
name|vptr_name
argument_list|,
sizeof|sizeof
argument_list|(
name|vptr_name
argument_list|)
operator|-
literal|1
argument_list|)
condition|)
block|{
name|TYPE_VPTR_FIELDNO
argument_list|(
name|type
argument_list|)
operator|=
name|i
expr_stmt|;
goto|goto
name|gotit
goto|;
block|}
block|}
comment|/* Virtual function table field not found.  */
name|complain
argument_list|(
operator|&
name|vtbl_notfound_complaint
argument_list|,
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|TYPE_VPTR_FIELDNO
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_VPTR_FIELDNO
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
name|gotit
label|:
operator|*
name|pp
operator|=
name|p
operator|+
literal|1
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|attach_fn_fields_to_type
parameter_list|(
name|struct
name|field_info
modifier|*
name|fip
parameter_list|,
specifier|register
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
specifier|register
name|int
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
name|TYPE_NFN_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|fip
operator|->
name|fnlist
operator|!=
name|NULL
condition|;
name|fip
operator|->
name|fnlist
operator|=
name|fip
operator|->
name|fnlist
operator|->
name|next
control|)
block|{
operator|--
name|n
expr_stmt|;
comment|/* Circumvent Sun3 compiler bug */
name|TYPE_FN_FIELDLISTS
argument_list|(
name|type
argument_list|)
index|[
name|n
index|]
operator|=
name|fip
operator|->
name|fnlist
operator|->
name|fn_fieldlist
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* read cfront class static data.    pp points to string starting with the list of static data    eg: A:ZcA;1@Bpub v2@Bvirpri;__ct__1AFv func__1AFv *sfunc__1AFv ;as__1A ;;    ^^^^^^^^     A:ZcA;;foopri__1AFv foopro__1AFv __ct__1AFv __ct__1AFRC1A foopub__1AFv ;;;    ^  */
end_comment

begin_function
specifier|static
name|int
name|read_cfront_static_fields
parameter_list|(
name|struct
name|field_info
modifier|*
name|fip
parameter_list|,
name|char
modifier|*
modifier|*
name|pp
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|struct
name|nextfield
modifier|*
name|new
decl_stmt|;
name|struct
name|type
modifier|*
name|stype
decl_stmt|;
name|char
modifier|*
name|sname
decl_stmt|;
name|struct
name|symbol
modifier|*
name|ref_static
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|';'
condition|)
comment|/* no static data; return */
block|{
operator|++
operator|(
operator|*
name|pp
operator|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Process each field in the list until we find the terminating ";" */
comment|/* eg: p = "as__1A ;;;" */
name|STABS_CONTINUE
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* handle \\ */
while|while
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|';'
operator|&&
operator|(
name|sname
operator|=
name|get_substring
argument_list|(
name|pp
argument_list|,
literal|' '
argument_list|)
operator|,
name|sname
operator|)
condition|)
block|{
name|ref_static
operator|=
name|lookup_symbol
argument_list|(
name|sname
argument_list|,
literal|0
argument_list|,
name|VAR_NAMESPACE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*demangled_name */
if|if
condition|(
operator|!
name|ref_static
condition|)
block|{
specifier|static
name|struct
name|complaint
name|msg
init|=
block|{
literal|"\       		Unable to find symbol for static data field %s\n"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|complain
argument_list|(
operator|&
name|msg
argument_list|,
name|sname
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|stype
operator|=
name|SYMBOL_TYPE
argument_list|(
name|ref_static
argument_list|)
expr_stmt|;
comment|/* allocate a new fip */
name|new
operator|=
operator|(
expr|struct
name|nextfield
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nextfield
argument_list|)
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|new
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nextfield
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|fip
operator|->
name|list
expr_stmt|;
name|fip
operator|->
name|list
operator|=
name|new
expr_stmt|;
comment|/* set visibility */
comment|/* FIXME! no way to tell visibility from stabs??? */
name|new
operator|->
name|visibility
operator|=
name|VISIBILITY_PUBLIC
expr_stmt|;
comment|/* set field info into fip */
name|fip
operator|->
name|list
operator|->
name|field
operator|.
name|type
operator|=
name|stype
expr_stmt|;
comment|/* set bitpos& bitsize */
name|SET_FIELD_PHYSNAME
argument_list|(
name|fip
operator|->
name|list
operator|->
name|field
argument_list|,
name|savestring
argument_list|(
name|sname
argument_list|,
name|strlen
argument_list|(
name|sname
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set name field */
comment|/* The following is code to work around cfront generated stabs.          The stabs contains full mangled name for each field.          We try to demangle the name and extract the field name out of it.        */
if|if
condition|(
name|ARM_DEMANGLING
condition|)
block|{
name|char
modifier|*
name|dem
decl_stmt|,
modifier|*
name|dem_p
decl_stmt|;
name|dem
operator|=
name|cplus_demangle
argument_list|(
name|sname
argument_list|,
name|DMGL_ANSI
operator||
name|DMGL_PARAMS
argument_list|)
expr_stmt|;
if|if
condition|(
name|dem
operator|!=
name|NULL
condition|)
block|{
name|dem_p
operator|=
name|strrchr
argument_list|(
name|dem
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|dem_p
operator|!=
literal|0
operator|&&
operator|*
operator|(
name|dem_p
operator|-
literal|1
operator|)
operator|==
literal|':'
condition|)
name|dem_p
operator|++
expr_stmt|;
name|fip
operator|->
name|list
operator|->
name|field
operator|.
name|name
operator|=
name|obsavestring
argument_list|(
name|dem_p
argument_list|,
name|strlen
argument_list|(
name|dem_p
argument_list|)
argument_list|,
operator|&
name|objfile
operator|->
name|type_obstack
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fip
operator|->
name|list
operator|->
name|field
operator|.
name|name
operator|=
name|obsavestring
argument_list|(
name|sname
argument_list|,
name|strlen
argument_list|(
name|sname
argument_list|)
argument_list|,
operator|&
name|objfile
operator|->
name|type_obstack
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* end of code for cfront work around */
block|}
comment|/* loop again for next static field */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Copy structure fields to fip so attach_fields_to_type will work.    type has already been created with the initial instance data fields.    Now we want to be able to add the other members to the class,    so we want to add them back to the fip and reattach them again    once we have collected all the class members. */
end_comment

begin_function
specifier|static
name|int
name|copy_cfront_struct_fields
parameter_list|(
name|struct
name|field_info
modifier|*
name|fip
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|int
name|nfields
init|=
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|nextfield
modifier|*
name|new
decl_stmt|;
comment|/* Copy the fields into the list of fips and reset the types       to remove the old fields */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfields
condition|;
name|i
operator|++
control|)
block|{
comment|/* allocate a new fip */
name|new
operator|=
operator|(
expr|struct
name|nextfield
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nextfield
argument_list|)
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|new
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nextfield
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|fip
operator|->
name|list
expr_stmt|;
name|fip
operator|->
name|list
operator|=
name|new
expr_stmt|;
comment|/* copy field info into fip */
name|new
operator|->
name|field
operator|=
name|TYPE_FIELD
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* set visibility */
if|if
condition|(
name|TYPE_FIELD_PROTECTED
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
name|new
operator|->
name|visibility
operator|=
name|VISIBILITY_PROTECTED
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_FIELD_PRIVATE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
name|new
operator|->
name|visibility
operator|=
name|VISIBILITY_PRIVATE
expr_stmt|;
else|else
name|new
operator|->
name|visibility
operator|=
name|VISIBILITY_PUBLIC
expr_stmt|;
block|}
comment|/* Now delete the fields from the type since we will be       allocing new space once we get the rest of the fields       in attach_fields_to_type.      The pointer TYPE_FIELDS(type) is left dangling but should       be freed later by objstack_free */
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Create the vector of fields, and record how big it is.    We need this info to record proper virtual function table information    for this class's virtual functions.  */
end_comment

begin_function
specifier|static
name|int
name|attach_fields_to_type
parameter_list|(
name|struct
name|field_info
modifier|*
name|fip
parameter_list|,
specifier|register
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
specifier|register
name|int
name|nfields
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|non_public_fields
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|nextfield
modifier|*
name|scan
decl_stmt|;
comment|/* Count up the number of fields that we have, as well as taking note of      whether or not there are any non-public fields, which requires us to      allocate and build the private_field_bits and protected_field_bits      bitfields. */
for|for
control|(
name|scan
operator|=
name|fip
operator|->
name|list
init|;
name|scan
operator|!=
name|NULL
condition|;
name|scan
operator|=
name|scan
operator|->
name|next
control|)
block|{
name|nfields
operator|++
expr_stmt|;
if|if
condition|(
name|scan
operator|->
name|visibility
operator|!=
name|VISIBILITY_PUBLIC
condition|)
block|{
name|non_public_fields
operator|++
expr_stmt|;
block|}
block|}
comment|/* Now we know how many fields there are, and whether or not there are any      non-public fields.  Record the field count, allocate space for the      array of fields, and create blank visibility bitfields if necessary. */
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|=
name|nfields
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
expr|struct
name|field
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|type
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
operator|*
name|nfields
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
operator|*
name|nfields
argument_list|)
expr_stmt|;
if|if
condition|(
name|non_public_fields
condition|)
block|{
name|ALLOCATE_CPLUS_STRUCT_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_FIELD_PRIVATE_BITS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
name|B_TYPE
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|type
argument_list|,
name|B_BYTES
argument_list|(
name|nfields
argument_list|)
argument_list|)
expr_stmt|;
name|B_CLRALL
argument_list|(
name|TYPE_FIELD_PRIVATE_BITS
argument_list|(
name|type
argument_list|)
argument_list|,
name|nfields
argument_list|)
expr_stmt|;
name|TYPE_FIELD_PROTECTED_BITS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
name|B_TYPE
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|type
argument_list|,
name|B_BYTES
argument_list|(
name|nfields
argument_list|)
argument_list|)
expr_stmt|;
name|B_CLRALL
argument_list|(
name|TYPE_FIELD_PROTECTED_BITS
argument_list|(
name|type
argument_list|)
argument_list|,
name|nfields
argument_list|)
expr_stmt|;
name|TYPE_FIELD_IGNORE_BITS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
name|B_TYPE
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|type
argument_list|,
name|B_BYTES
argument_list|(
name|nfields
argument_list|)
argument_list|)
expr_stmt|;
name|B_CLRALL
argument_list|(
name|TYPE_FIELD_IGNORE_BITS
argument_list|(
name|type
argument_list|)
argument_list|,
name|nfields
argument_list|)
expr_stmt|;
block|}
comment|/* Copy the saved-up fields into the field vector.  Start from the head      of the list, adding to the tail of the field array, so that they end      up in the same order in the array in which they were added to the list. */
while|while
condition|(
name|nfields
operator|--
operator|>
literal|0
condition|)
block|{
name|TYPE_FIELD
argument_list|(
name|type
argument_list|,
name|nfields
argument_list|)
operator|=
name|fip
operator|->
name|list
operator|->
name|field
expr_stmt|;
switch|switch
condition|(
name|fip
operator|->
name|list
operator|->
name|visibility
condition|)
block|{
case|case
name|VISIBILITY_PRIVATE
case|:
name|SET_TYPE_FIELD_PRIVATE
argument_list|(
name|type
argument_list|,
name|nfields
argument_list|)
expr_stmt|;
break|break;
case|case
name|VISIBILITY_PROTECTED
case|:
name|SET_TYPE_FIELD_PROTECTED
argument_list|(
name|type
argument_list|,
name|nfields
argument_list|)
expr_stmt|;
break|break;
case|case
name|VISIBILITY_IGNORE
case|:
name|SET_TYPE_FIELD_IGNORE
argument_list|(
name|type
argument_list|,
name|nfields
argument_list|)
expr_stmt|;
break|break;
case|case
name|VISIBILITY_PUBLIC
case|:
break|break;
default|default:
comment|/* Unknown visibility.  Complain and treat it as public.  */
block|{
specifier|static
name|struct
name|complaint
name|msg
init|=
block|{
literal|"Unknown visibility `%c' for field"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|complain
argument_list|(
operator|&
name|msg
argument_list|,
name|fip
operator|->
name|list
operator|->
name|visibility
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|fip
operator|->
name|list
operator|=
name|fip
operator|->
name|list
operator|->
name|next
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Read the description of a structure (or union type) and return an object    describing the type.     PP points to a character pointer that points to the next unconsumed token    in the the stabs string.  For example, given stabs "A:T4=s4a:1,0,32;;",    *PP will point to "4a:1,0,32;;".     TYPE points to an incomplete type that needs to be filled in.     OBJFILE points to the current objfile from which the stabs information is    being read.  (Note that it is redundant in that TYPE also contains a pointer    to this same objfile, so it might be a good idea to eliminate it.  FIXME).   */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|read_struct_type
parameter_list|(
name|char
modifier|*
modifier|*
name|pp
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|struct
name|cleanup
modifier|*
name|back_to
decl_stmt|;
name|struct
name|field_info
name|fi
decl_stmt|;
name|fi
operator|.
name|list
operator|=
name|NULL
expr_stmt|;
name|fi
operator|.
name|fnlist
operator|=
name|NULL
expr_stmt|;
name|back_to
operator|=
name|make_cleanup
argument_list|(
name|null_cleanup
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|INIT_CPLUS_SPECIFIC
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_FLAGS
argument_list|(
name|type
argument_list|)
operator|&=
operator|~
name|TYPE_FLAG_STUB
expr_stmt|;
comment|/* First comes the total size in bytes.  */
block|{
name|int
name|nbits
decl_stmt|;
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
name|read_huge_number
argument_list|(
name|pp
argument_list|,
literal|0
argument_list|,
operator|&
name|nbits
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbits
operator|!=
literal|0
condition|)
return|return
name|error_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
return|;
block|}
comment|/* Now read the baseclasses, if any, read the regular C struct or C++      class member fields, attach the fields to the type, read the C++      member functions, attach them to the type, and then read any tilde      field (baseclass specifier for the class holding the main vtable). */
if|if
condition|(
operator|!
name|read_baseclasses
argument_list|(
operator|&
name|fi
argument_list|,
name|pp
argument_list|,
name|type
argument_list|,
name|objfile
argument_list|)
operator|||
operator|!
name|read_struct_fields
argument_list|(
operator|&
name|fi
argument_list|,
name|pp
argument_list|,
name|type
argument_list|,
name|objfile
argument_list|)
operator|||
operator|!
name|attach_fields_to_type
argument_list|(
operator|&
name|fi
argument_list|,
name|type
argument_list|,
name|objfile
argument_list|)
operator|||
operator|!
name|read_member_functions
argument_list|(
operator|&
name|fi
argument_list|,
name|pp
argument_list|,
name|type
argument_list|,
name|objfile
argument_list|)
operator|||
operator|!
name|attach_fn_fields_to_type
argument_list|(
operator|&
name|fi
argument_list|,
name|type
argument_list|)
operator|||
operator|!
name|read_tilde_fields
argument_list|(
operator|&
name|fi
argument_list|,
name|pp
argument_list|,
name|type
argument_list|,
name|objfile
argument_list|)
condition|)
block|{
name|type
operator|=
name|error_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
comment|/* Fix up any cv-qualified versions of this type.  */
name|finish_cv_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|back_to
argument_list|)
expr_stmt|;
return|return
operator|(
name|type
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Read a definition of an array type,    and create and return a suitable type object.    Also creates a range type which represents the bounds of that    array.  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|read_array_type
parameter_list|(
specifier|register
name|char
modifier|*
modifier|*
name|pp
parameter_list|,
specifier|register
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|index_type
decl_stmt|,
modifier|*
name|element_type
decl_stmt|,
modifier|*
name|range_type
decl_stmt|;
name|int
name|lower
decl_stmt|,
name|upper
decl_stmt|;
name|int
name|adjustable
init|=
literal|0
decl_stmt|;
name|int
name|nbits
decl_stmt|;
comment|/* Format of an array type:      "ar<index type>;lower;upper;<array_contents_type>".      OS9000: "arlower,upper;<array_contents_type>".       Fortran adjustable arrays use Adigits or Tdigits for lower or upper;      for these, produce a type like float[][].  */
if|if
condition|(
name|os9k_stabs
condition|)
name|index_type
operator|=
name|builtin_type_int
expr_stmt|;
else|else
block|{
name|index_type
operator|=
name|read_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|';'
condition|)
comment|/* Improper format of array type decl.  */
return|return
name|error_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
return|;
operator|++
operator|*
name|pp
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
operator|*
operator|*
name|pp
operator|>=
literal|'0'
operator|&&
operator|*
operator|*
name|pp
operator|<=
literal|'9'
operator|)
operator|&&
operator|*
operator|*
name|pp
operator|!=
literal|'-'
condition|)
block|{
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
name|adjustable
operator|=
literal|1
expr_stmt|;
block|}
name|lower
operator|=
name|read_huge_number
argument_list|(
name|pp
argument_list|,
name|os9k_stabs
condition|?
literal|','
else|:
literal|';'
argument_list|,
operator|&
name|nbits
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbits
operator|!=
literal|0
condition|)
return|return
name|error_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
return|;
if|if
condition|(
operator|!
operator|(
operator|*
operator|*
name|pp
operator|>=
literal|'0'
operator|&&
operator|*
operator|*
name|pp
operator|<=
literal|'9'
operator|)
operator|&&
operator|*
operator|*
name|pp
operator|!=
literal|'-'
condition|)
block|{
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
name|adjustable
operator|=
literal|1
expr_stmt|;
block|}
name|upper
operator|=
name|read_huge_number
argument_list|(
name|pp
argument_list|,
literal|';'
argument_list|,
operator|&
name|nbits
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbits
operator|!=
literal|0
condition|)
return|return
name|error_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
return|;
name|element_type
operator|=
name|read_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|adjustable
condition|)
block|{
name|lower
operator|=
literal|0
expr_stmt|;
name|upper
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|range_type
operator|=
name|create_range_type
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|)
name|NULL
argument_list|,
name|index_type
argument_list|,
name|lower
argument_list|,
name|upper
argument_list|)
expr_stmt|;
name|type
operator|=
name|create_array_type
argument_list|(
name|type
argument_list|,
name|element_type
argument_list|,
name|range_type
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Read a definition of an enumeration type,    and create and return a suitable type object.    Also defines the symbols that represent the values of the type.  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|read_enum_type
parameter_list|(
specifier|register
name|char
modifier|*
modifier|*
name|pp
parameter_list|,
specifier|register
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|long
name|n
decl_stmt|;
specifier|register
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|int
name|nsyms
init|=
literal|0
decl_stmt|;
name|struct
name|pending
modifier|*
modifier|*
name|symlist
decl_stmt|;
name|struct
name|pending
modifier|*
name|osyms
decl_stmt|,
modifier|*
name|syms
decl_stmt|;
name|int
name|o_nsyms
decl_stmt|;
name|int
name|nbits
decl_stmt|;
name|int
name|unsigned_enum
init|=
literal|1
decl_stmt|;
if|#
directive|if
literal|0
comment|/* FIXME!  The stabs produced by Sun CC merrily define things that ought      to be file-scope, between N_FN entries, using N_LSYM.  What's a mother      to do?  For now, force all enum values to file scope.  */
block|if (within_function)     symlist =&local_symbols;   else
endif|#
directive|endif
name|symlist
operator|=
operator|&
name|file_symbols
expr_stmt|;
name|osyms
operator|=
operator|*
name|symlist
expr_stmt|;
name|o_nsyms
operator|=
name|osyms
condition|?
name|osyms
operator|->
name|nsyms
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|os9k_stabs
condition|)
block|{
comment|/* Size.  Perhaps this does not have to be conditionalized on          os9k_stabs (assuming the name of an enum constant can't start          with a digit).  */
name|read_huge_number
argument_list|(
name|pp
argument_list|,
literal|0
argument_list|,
operator|&
name|nbits
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbits
operator|!=
literal|0
condition|)
return|return
name|error_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
return|;
block|}
comment|/* The aix4 compiler emits an extra field before the enum members;      my guess is it's a type of some sort.  Just ignore it.  */
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|'-'
condition|)
block|{
comment|/* Skip over the type.  */
while|while
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|':'
condition|)
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
comment|/* Skip over the colon.  */
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
block|}
comment|/* Read the value-names and their values.      The input syntax is NAME:VALUE,NAME:VALUE, and so on.      A semicolon or comma instead of a NAME means the end.  */
while|while
condition|(
operator|*
operator|*
name|pp
operator|&&
operator|*
operator|*
name|pp
operator|!=
literal|';'
operator|&&
operator|*
operator|*
name|pp
operator|!=
literal|','
condition|)
block|{
name|STABS_CONTINUE
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|p
operator|=
operator|*
name|pp
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|':'
condition|)
name|p
operator|++
expr_stmt|;
name|name
operator|=
name|obsavestring
argument_list|(
operator|*
name|pp
argument_list|,
name|p
operator|-
operator|*
name|pp
argument_list|,
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|)
expr_stmt|;
operator|*
name|pp
operator|=
name|p
operator|+
literal|1
expr_stmt|;
name|n
operator|=
name|read_huge_number
argument_list|(
name|pp
argument_list|,
literal|','
argument_list|,
operator|&
name|nbits
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbits
operator|!=
literal|0
condition|)
return|return
name|error_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
return|;
name|sym
operator|=
operator|(
expr|struct
name|symbol
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|sym
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|=
name|name
expr_stmt|;
name|SYMBOL_LANGUAGE
argument_list|(
name|sym
argument_list|)
operator|=
name|current_subfile
operator|->
name|language
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_CONST
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|n
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
name|unsigned_enum
operator|=
literal|0
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
name|symlist
argument_list|)
expr_stmt|;
name|nsyms
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|';'
condition|)
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
comment|/* Skip the semicolon.  */
comment|/* Now fill in the fields of the type-structure.  */
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
name|TARGET_INT_BIT
operator|/
name|HOST_CHAR_BIT
expr_stmt|;
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_CODE_ENUM
expr_stmt|;
name|TYPE_FLAGS
argument_list|(
name|type
argument_list|)
operator|&=
operator|~
name|TYPE_FLAG_STUB
expr_stmt|;
if|if
condition|(
name|unsigned_enum
condition|)
name|TYPE_FLAGS
argument_list|(
name|type
argument_list|)
operator||=
name|TYPE_FLAG_UNSIGNED
expr_stmt|;
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|=
name|nsyms
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
expr|struct
name|field
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|type
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
operator|*
name|nsyms
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
operator|*
name|nsyms
argument_list|)
expr_stmt|;
comment|/* Find the symbols for the values and put them into the type.      The symbols can be found in the symlist that we put them on      to cause them to be defined.  osyms contains the old value      of that symlist; everything up to there was defined by us.  */
comment|/* Note that we preserve the order of the enum constants, so      that in something like "enum {FOO, LAST_THING=FOO}" we print      FOO, not LAST_THING.  */
for|for
control|(
name|syms
operator|=
operator|*
name|symlist
operator|,
name|n
operator|=
name|nsyms
operator|-
literal|1
init|;
name|syms
condition|;
name|syms
operator|=
name|syms
operator|->
name|next
control|)
block|{
name|int
name|last
init|=
name|syms
operator|==
name|osyms
condition|?
name|o_nsyms
else|:
literal|0
decl_stmt|;
name|int
name|j
init|=
name|syms
operator|->
name|nsyms
decl_stmt|;
for|for
control|(
init|;
operator|--
name|j
operator|>=
name|last
condition|;
operator|--
name|n
control|)
block|{
name|struct
name|symbol
modifier|*
name|xsym
init|=
name|syms
operator|->
name|symbol
index|[
name|j
index|]
decl_stmt|;
name|SYMBOL_TYPE
argument_list|(
name|xsym
argument_list|)
operator|=
name|type
expr_stmt|;
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|n
argument_list|)
operator|=
name|SYMBOL_NAME
argument_list|(
name|xsym
argument_list|)
expr_stmt|;
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|n
argument_list|)
operator|=
name|SYMBOL_VALUE
argument_list|(
name|xsym
argument_list|)
expr_stmt|;
name|TYPE_FIELD_BITSIZE
argument_list|(
name|type
argument_list|,
name|n
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|syms
operator|==
name|osyms
condition|)
break|break;
block|}
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Sun's ACC uses a somewhat saner method for specifying the builtin    typedefs in every file (for int, long, etc):     type = b<signed><width><format type>;<offset>;<nbits>    signed = u or s.    optional format type = c or b for char or boolean.    offset = offset from high order bit to start bit of type.    width is # bytes in object of this type, nbits is # bits in type.     The width/offset stuff appears to be for small objects stored in    larger ones (e.g. `shorts' in `int' registers).  We ignore it for now,    FIXME.  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|read_sun_builtin_type
parameter_list|(
name|char
modifier|*
modifier|*
name|pp
parameter_list|,
name|int
name|typenums
index|[
literal|2
index|]
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|int
name|type_bits
decl_stmt|;
name|int
name|nbits
decl_stmt|;
name|int
name|signed_type
decl_stmt|;
name|enum
name|type_code
name|code
init|=
name|TYPE_CODE_INT
decl_stmt|;
switch|switch
condition|(
operator|*
operator|*
name|pp
condition|)
block|{
case|case
literal|'s'
case|:
name|signed_type
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|signed_type
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
return|return
name|error_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
return|;
block|}
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
comment|/* For some odd reason, all forms of char put a c here.  This is strange      because no other type has this honor.  We can safely ignore this because      we actually determine 'char'acterness by the number of bits specified in      the descriptor.      Boolean forms, e.g Fortran logical*X, put a b here.  */
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|'c'
condition|)
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|'b'
condition|)
block|{
name|code
operator|=
name|TYPE_CODE_BOOL
expr_stmt|;
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
block|}
comment|/* The first number appears to be the number of bytes occupied      by this type, except that unsigned short is 4 instead of 2.      Since this information is redundant with the third number,      we will ignore it.  */
name|read_huge_number
argument_list|(
name|pp
argument_list|,
literal|';'
argument_list|,
operator|&
name|nbits
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbits
operator|!=
literal|0
condition|)
return|return
name|error_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
return|;
comment|/* The second number is always 0, so ignore it too. */
name|read_huge_number
argument_list|(
name|pp
argument_list|,
literal|';'
argument_list|,
operator|&
name|nbits
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbits
operator|!=
literal|0
condition|)
return|return
name|error_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
return|;
comment|/* The third number is the number of bits for this type. */
name|type_bits
operator|=
name|read_huge_number
argument_list|(
name|pp
argument_list|,
literal|0
argument_list|,
operator|&
name|nbits
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbits
operator|!=
literal|0
condition|)
return|return
name|error_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
return|;
comment|/* The type *should* end with a semicolon.  If it are embedded      in a larger type the semicolon may be the only way to know where      the type ends.  If this type is at the end of the stabstring we      can deal with the omitted semicolon (but we don't have to like      it).  Don't bother to complain(), Sun's compiler omits the semicolon      for "void".  */
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|';'
condition|)
operator|++
operator|(
operator|*
name|pp
operator|)
expr_stmt|;
if|if
condition|(
name|type_bits
operator|==
literal|0
condition|)
return|return
name|init_type
argument_list|(
name|TYPE_CODE_VOID
argument_list|,
literal|1
argument_list|,
name|signed_type
condition|?
literal|0
else|:
name|TYPE_FLAG_UNSIGNED
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|objfile
argument_list|)
return|;
else|else
return|return
name|init_type
argument_list|(
name|code
argument_list|,
name|type_bits
operator|/
name|TARGET_CHAR_BIT
argument_list|,
name|signed_type
condition|?
literal|0
else|:
name|TYPE_FLAG_UNSIGNED
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|objfile
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|type
modifier|*
name|read_sun_floating_type
parameter_list|(
name|char
modifier|*
modifier|*
name|pp
parameter_list|,
name|int
name|typenums
index|[
literal|2
index|]
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|int
name|nbits
decl_stmt|;
name|int
name|details
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
comment|/* The first number has more details about the type, for example      FN_COMPLEX.  */
name|details
operator|=
name|read_huge_number
argument_list|(
name|pp
argument_list|,
literal|';'
argument_list|,
operator|&
name|nbits
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbits
operator|!=
literal|0
condition|)
return|return
name|error_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
return|;
comment|/* The second number is the number of bytes occupied by this type */
name|nbytes
operator|=
name|read_huge_number
argument_list|(
name|pp
argument_list|,
literal|';'
argument_list|,
operator|&
name|nbits
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbits
operator|!=
literal|0
condition|)
return|return
name|error_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
return|;
if|if
condition|(
name|details
operator|==
name|NF_COMPLEX
operator|||
name|details
operator|==
name|NF_COMPLEX16
operator|||
name|details
operator|==
name|NF_COMPLEX32
condition|)
comment|/* This is a type we can't handle, but we do know the size.        We also will be able to give it a name.  */
return|return
name|init_type
argument_list|(
name|TYPE_CODE_COMPLEX
argument_list|,
name|nbytes
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|objfile
argument_list|)
return|;
return|return
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
name|nbytes
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|objfile
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Read a number from the string pointed to by *PP.    The value of *PP is advanced over the number.    If END is nonzero, the character that ends the    number must match END, or an error happens;    and that character is skipped if it does match.    If END is zero, *PP is left pointing to that character.     If the number fits in a long, set *BITS to 0 and return the value.    If not, set *BITS to be the number of bits in the number and return 0.     If encounter garbage, set *BITS to -1 and return 0.  */
end_comment

begin_function
specifier|static
name|long
name|read_huge_number
parameter_list|(
name|char
modifier|*
modifier|*
name|pp
parameter_list|,
name|int
name|end
parameter_list|,
name|int
modifier|*
name|bits
parameter_list|)
block|{
name|char
modifier|*
name|p
init|=
operator|*
name|pp
decl_stmt|;
name|int
name|sign
init|=
literal|1
decl_stmt|;
name|long
name|n
init|=
literal|0
decl_stmt|;
name|int
name|radix
init|=
literal|10
decl_stmt|;
name|char
name|overflow
init|=
literal|0
decl_stmt|;
name|int
name|nbits
init|=
literal|0
decl_stmt|;
name|int
name|c
decl_stmt|;
name|long
name|upper_limit
decl_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
condition|)
block|{
name|sign
operator|=
operator|-
literal|1
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
comment|/* Leading zero means octal.  GCC uses this to output values larger      than an int (because that would be hard in decimal).  */
if|if
condition|(
operator|*
name|p
operator|==
literal|'0'
condition|)
block|{
name|radix
operator|=
literal|8
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|os9k_stabs
condition|)
name|upper_limit
operator|=
name|ULONG_MAX
operator|/
name|radix
expr_stmt|;
else|else
name|upper_limit
operator|=
name|LONG_MAX
operator|/
name|radix
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|>=
literal|'0'
operator|&&
name|c
operator|<
operator|(
literal|'0'
operator|+
name|radix
operator|)
condition|)
block|{
if|if
condition|(
name|n
operator|<=
name|upper_limit
condition|)
block|{
name|n
operator|*=
name|radix
expr_stmt|;
name|n
operator|+=
name|c
operator|-
literal|'0'
expr_stmt|;
comment|/* FIXME this overflows anyway */
block|}
else|else
name|overflow
operator|=
literal|1
expr_stmt|;
comment|/* This depends on large values being output in octal, which is          what GCC does. */
if|if
condition|(
name|radix
operator|==
literal|8
condition|)
block|{
if|if
condition|(
name|nbits
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'0'
condition|)
comment|/* Ignore leading zeroes.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'1'
condition|)
name|nbits
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'2'
operator|||
name|c
operator|==
literal|'3'
condition|)
name|nbits
operator|=
literal|2
expr_stmt|;
else|else
name|nbits
operator|=
literal|3
expr_stmt|;
block|}
else|else
name|nbits
operator|+=
literal|3
expr_stmt|;
block|}
block|}
if|if
condition|(
name|end
condition|)
block|{
if|if
condition|(
name|c
operator|&&
name|c
operator|!=
name|end
condition|)
block|{
if|if
condition|(
name|bits
operator|!=
name|NULL
condition|)
operator|*
name|bits
operator|=
operator|-
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
else|else
operator|--
name|p
expr_stmt|;
operator|*
name|pp
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|overflow
condition|)
block|{
if|if
condition|(
name|nbits
operator|==
literal|0
condition|)
block|{
comment|/* Large decimal constants are an error (because it is hard to 	     count how many bits are in them).  */
if|if
condition|(
name|bits
operator|!=
name|NULL
condition|)
operator|*
name|bits
operator|=
operator|-
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* -0x7f is the same as 0x80.  So deal with it by adding one to          the number of bits.  */
if|if
condition|(
name|sign
operator|==
operator|-
literal|1
condition|)
operator|++
name|nbits
expr_stmt|;
if|if
condition|(
name|bits
condition|)
operator|*
name|bits
operator|=
name|nbits
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|bits
condition|)
operator|*
name|bits
operator|=
literal|0
expr_stmt|;
return|return
name|n
operator|*
name|sign
return|;
block|}
comment|/* It's *BITS which has the interesting information.  */
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|type
modifier|*
name|read_range_type
parameter_list|(
name|char
modifier|*
modifier|*
name|pp
parameter_list|,
name|int
name|typenums
index|[
literal|2
index|]
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|char
modifier|*
name|orig_pp
init|=
operator|*
name|pp
decl_stmt|;
name|int
name|rangenums
index|[
literal|2
index|]
decl_stmt|;
name|long
name|n2
decl_stmt|,
name|n3
decl_stmt|;
name|int
name|n2bits
decl_stmt|,
name|n3bits
decl_stmt|;
name|int
name|self_subrange
decl_stmt|;
name|struct
name|type
modifier|*
name|result_type
decl_stmt|;
name|struct
name|type
modifier|*
name|index_type
init|=
name|NULL
decl_stmt|;
comment|/* First comes a type we are a subrange of.      In C it is usually 0, 1 or the type being defined.  */
if|if
condition|(
name|read_type_number
argument_list|(
name|pp
argument_list|,
name|rangenums
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|error_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
return|;
name|self_subrange
operator|=
operator|(
name|rangenums
index|[
literal|0
index|]
operator|==
name|typenums
index|[
literal|0
index|]
operator|&&
name|rangenums
index|[
literal|1
index|]
operator|==
name|typenums
index|[
literal|1
index|]
operator|)
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|'='
condition|)
block|{
operator|*
name|pp
operator|=
name|orig_pp
expr_stmt|;
name|index_type
operator|=
name|read_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
comment|/* A semicolon should now follow; skip it.  */
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|';'
condition|)
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
comment|/* The remaining two operands are usually lower and upper bounds      of the range.  But in some special cases they mean something else.  */
name|n2
operator|=
name|read_huge_number
argument_list|(
name|pp
argument_list|,
literal|';'
argument_list|,
operator|&
name|n2bits
argument_list|)
expr_stmt|;
name|n3
operator|=
name|read_huge_number
argument_list|(
name|pp
argument_list|,
literal|';'
argument_list|,
operator|&
name|n3bits
argument_list|)
expr_stmt|;
if|if
condition|(
name|n2bits
operator|==
operator|-
literal|1
operator|||
name|n3bits
operator|==
operator|-
literal|1
condition|)
return|return
name|error_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
return|;
if|if
condition|(
name|index_type
condition|)
goto|goto
name|handle_true_range
goto|;
comment|/* If limits are huge, must be large integral type.  */
if|if
condition|(
name|n2bits
operator|!=
literal|0
operator|||
name|n3bits
operator|!=
literal|0
condition|)
block|{
name|char
name|got_signed
init|=
literal|0
decl_stmt|;
name|char
name|got_unsigned
init|=
literal|0
decl_stmt|;
comment|/* Number of bits in the type.  */
name|int
name|nbits
init|=
literal|0
decl_stmt|;
comment|/* Range from 0 to<large number> is an unsigned large integral type.  */
if|if
condition|(
operator|(
name|n2bits
operator|==
literal|0
operator|&&
name|n2
operator|==
literal|0
operator|)
operator|&&
name|n3bits
operator|!=
literal|0
condition|)
block|{
name|got_unsigned
operator|=
literal|1
expr_stmt|;
name|nbits
operator|=
name|n3bits
expr_stmt|;
block|}
comment|/* Range from<large number> to<large number>-1 is a large signed          integral type.  Take care of the case where<large number> doesn't          fit in a long but<large number>-1 does.  */
elseif|else
if|if
condition|(
operator|(
name|n2bits
operator|!=
literal|0
operator|&&
name|n3bits
operator|!=
literal|0
operator|&&
name|n2bits
operator|==
name|n3bits
operator|+
literal|1
operator|)
operator|||
operator|(
name|n2bits
operator|!=
literal|0
operator|&&
name|n3bits
operator|==
literal|0
operator|&&
operator|(
name|n2bits
operator|==
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|*
name|HOST_CHAR_BIT
operator|)
operator|&&
name|n3
operator|==
name|LONG_MAX
operator|)
condition|)
block|{
name|got_signed
operator|=
literal|1
expr_stmt|;
name|nbits
operator|=
name|n2bits
expr_stmt|;
block|}
if|if
condition|(
name|got_signed
operator|||
name|got_unsigned
condition|)
block|{
return|return
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|nbits
operator|/
name|TARGET_CHAR_BIT
argument_list|,
name|got_unsigned
condition|?
name|TYPE_FLAG_UNSIGNED
else|:
literal|0
argument_list|,
name|NULL
argument_list|,
name|objfile
argument_list|)
return|;
block|}
else|else
return|return
name|error_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
return|;
block|}
comment|/* A type defined as a subrange of itself, with bounds both 0, is void.  */
if|if
condition|(
name|self_subrange
operator|&&
name|n2
operator|==
literal|0
operator|&&
name|n3
operator|==
literal|0
condition|)
return|return
name|init_type
argument_list|(
name|TYPE_CODE_VOID
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|objfile
argument_list|)
return|;
comment|/* If n3 is zero and n2 is positive, we want a floating type, and n2      is the width in bytes.       Fortran programs appear to use this for complex types also.  To      distinguish between floats and complex, g77 (and others?)  seem      to use self-subranges for the complexes, and subranges of int for      the floats.       Also note that for complexes, g77 sets n2 to the size of one of      the member floats, not the whole complex beast.  My guess is that      this was to work well with pre-COMPLEX versions of gdb. */
if|if
condition|(
name|n3
operator|==
literal|0
operator|&&
name|n2
operator|>
literal|0
condition|)
block|{
name|struct
name|type
modifier|*
name|float_type
init|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
name|n2
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|objfile
argument_list|)
decl_stmt|;
if|if
condition|(
name|self_subrange
condition|)
block|{
name|struct
name|type
modifier|*
name|complex_type
init|=
name|init_type
argument_list|(
name|TYPE_CODE_COMPLEX
argument_list|,
literal|2
operator|*
name|n2
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|objfile
argument_list|)
decl_stmt|;
name|TYPE_TARGET_TYPE
argument_list|(
name|complex_type
argument_list|)
operator|=
name|float_type
expr_stmt|;
return|return
name|complex_type
return|;
block|}
else|else
return|return
name|float_type
return|;
block|}
comment|/* If the upper bound is -1, it must really be an unsigned int.  */
elseif|else
if|if
condition|(
name|n2
operator|==
literal|0
operator|&&
name|n3
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* It is unsigned int or unsigned long.  */
comment|/* GCC 2.3.3 uses this for long long too, but that is just a GDB 3.5          compatibility hack.  */
return|return
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_INT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
name|NULL
argument_list|,
name|objfile
argument_list|)
return|;
block|}
comment|/* Special case: char is defined (Who knows why) as a subrange of      itself with range 0-127.  */
elseif|else
if|if
condition|(
name|self_subrange
operator|&&
name|n2
operator|==
literal|0
operator|&&
name|n3
operator|==
literal|127
condition|)
return|return
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|objfile
argument_list|)
return|;
elseif|else
if|if
condition|(
name|current_symbol
operator|&&
name|SYMBOL_LANGUAGE
argument_list|(
name|current_symbol
argument_list|)
operator|==
name|language_chill
operator|&&
operator|!
name|self_subrange
condition|)
goto|goto
name|handle_true_range
goto|;
comment|/* We used to do this only for subrange of self or subrange of int.  */
elseif|else
if|if
condition|(
name|n2
operator|==
literal|0
condition|)
block|{
comment|/* -1 is used for the upper bound of (4 byte) "unsigned int" and          "unsigned long", and we already checked for that,          so don't need to test for it here.  */
if|if
condition|(
name|n3
operator|<
literal|0
condition|)
comment|/* n3 actually gives the size.  */
return|return
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
operator|-
name|n3
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
name|NULL
argument_list|,
name|objfile
argument_list|)
return|;
comment|/* Is n3 == 2**(8n)-1 for some integer n?  Then it's an          unsigned n-byte integer.  But do require n to be a power of          two; we don't want 3- and 5-byte integers flying around.  */
block|{
name|int
name|bytes
decl_stmt|;
name|unsigned
name|long
name|bits
decl_stmt|;
name|bits
operator|=
name|n3
expr_stmt|;
for|for
control|(
name|bytes
operator|=
literal|0
init|;
operator|(
name|bits
operator|&
literal|0xff
operator|)
operator|==
literal|0xff
condition|;
name|bytes
operator|++
control|)
name|bits
operator|>>=
literal|8
expr_stmt|;
if|if
condition|(
name|bits
operator|==
literal|0
operator|&&
operator|(
operator|(
name|bytes
operator|-
literal|1
operator|)
operator|&
name|bytes
operator|)
operator|==
literal|0
condition|)
comment|/* "bytes is a power of two" */
return|return
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|bytes
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
name|NULL
argument_list|,
name|objfile
argument_list|)
return|;
block|}
block|}
comment|/* I think this is for Convex "long long".  Since I don't know whether      Convex sets self_subrange, I also accept that particular size regardless      of self_subrange.  */
elseif|else
if|if
condition|(
name|n3
operator|==
literal|0
operator|&&
name|n2
operator|<
literal|0
operator|&&
operator|(
name|self_subrange
operator|||
name|n2
operator|==
operator|-
name|TARGET_LONG_LONG_BIT
operator|/
name|TARGET_CHAR_BIT
operator|)
condition|)
return|return
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
operator|-
name|n2
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|objfile
argument_list|)
return|;
elseif|else
if|if
condition|(
name|n2
operator|==
operator|-
name|n3
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|n3
operator|==
literal|0x7f
condition|)
return|return
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|objfile
argument_list|)
return|;
if|if
condition|(
name|n3
operator|==
literal|0x7fff
condition|)
return|return
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|objfile
argument_list|)
return|;
if|if
condition|(
name|n3
operator|==
literal|0x7fffffff
condition|)
return|return
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|objfile
argument_list|)
return|;
block|}
comment|/* We have a real range type on our hands.  Allocate space and      return a real pointer.  */
name|handle_true_range
label|:
if|if
condition|(
name|self_subrange
condition|)
name|index_type
operator|=
name|builtin_type_int
expr_stmt|;
else|else
name|index_type
operator|=
operator|*
name|dbx_lookup_type
argument_list|(
name|rangenums
argument_list|)
expr_stmt|;
if|if
condition|(
name|index_type
operator|==
name|NULL
condition|)
block|{
comment|/* Does this actually ever happen?  Is that why we are worrying          about dealing with it rather than just calling error_type?  */
specifier|static
name|struct
name|type
modifier|*
name|range_type_index
decl_stmt|;
name|complain
argument_list|(
operator|&
name|range_type_base_complaint
argument_list|,
name|rangenums
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|range_type_index
operator|==
name|NULL
condition|)
name|range_type_index
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_INT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"range type index type"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|index_type
operator|=
name|range_type_index
expr_stmt|;
block|}
name|result_type
operator|=
name|create_range_type
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|)
name|NULL
argument_list|,
name|index_type
argument_list|,
name|n2
argument_list|,
name|n3
argument_list|)
expr_stmt|;
return|return
operator|(
name|result_type
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Read in an argument list.  This is a list of types, separated by commas    and terminated with END.  Return the list of types read in, or (struct type    **)-1 if there is an error.  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
modifier|*
name|read_args
parameter_list|(
name|char
modifier|*
modifier|*
name|pp
parameter_list|,
name|int
name|end
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
comment|/* FIXME!  Remove this arbitrary limit!  */
name|struct
name|type
modifier|*
name|types
index|[
literal|1024
index|]
decl_stmt|,
modifier|*
modifier|*
name|rval
decl_stmt|;
comment|/* allow for fns of 1023 parameters */
name|int
name|n
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
operator|*
name|pp
operator|!=
name|end
condition|)
block|{
if|if
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|','
condition|)
comment|/* Invalid argument list: no ','.  */
return|return
operator|(
expr|struct
name|type
operator|*
operator|*
operator|)
operator|-
literal|1
return|;
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
name|STABS_CONTINUE
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|types
index|[
name|n
operator|++
index|]
operator|=
name|read_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
comment|/* get past `end' (the ':' character) */
if|if
condition|(
name|n
operator|==
literal|1
condition|)
block|{
name|rval
operator|=
operator|(
expr|struct
name|type
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|types
index|[
name|n
operator|-
literal|1
index|]
argument_list|)
operator|!=
name|TYPE_CODE_VOID
condition|)
block|{
name|rval
operator|=
operator|(
expr|struct
name|type
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|n
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|rval
operator|+
name|n
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rval
operator|=
operator|(
expr|struct
name|type
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|n
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|rval
argument_list|,
name|types
argument_list|,
name|n
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Common block handling.  */
end_comment

begin_comment
comment|/* List of symbols declared since the last BCOMM.  This list is a tail    of local_symbols.  When ECOMM is seen, the symbols on the list    are noted so their proper addresses can be filled in later,    using the common block base address gotten from the assembler    stabs.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|pending
modifier|*
name|common_block
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|common_block_i
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name of the current common block.  We get it from the BCOMM instead of the    ECOMM to match IBM documentation (even though IBM puts the name both places    like everyone else).  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|common_block_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Process a N_BCOMM symbol.  The storage for NAME is not guaranteed    to remain after this function returns.  */
end_comment

begin_function
name|void
name|common_block_start
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
if|if
condition|(
name|common_block_name
operator|!=
name|NULL
condition|)
block|{
specifier|static
name|struct
name|complaint
name|msg
init|=
block|{
literal|"Invalid symbol data: common block within common block"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|complain
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
block|}
name|common_block
operator|=
name|local_symbols
expr_stmt|;
name|common_block_i
operator|=
name|local_symbols
condition|?
name|local_symbols
operator|->
name|nsyms
else|:
literal|0
expr_stmt|;
name|common_block_name
operator|=
name|obsavestring
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Process a N_ECOMM symbol.  */
end_comment

begin_function
name|void
name|common_block_end
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
comment|/* Symbols declared since the BCOMM are to have the common block      start address added in when we know it.  common_block and      common_block_i point to the first symbol after the BCOMM in      the local_symbols list; copy the list and hang it off the      symbol for the common block name for later fixup.  */
name|int
name|i
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|struct
name|pending
modifier|*
name|new
init|=
literal|0
decl_stmt|;
name|struct
name|pending
modifier|*
name|next
decl_stmt|;
name|int
name|j
decl_stmt|;
if|if
condition|(
name|common_block_name
operator|==
name|NULL
condition|)
block|{
specifier|static
name|struct
name|complaint
name|msg
init|=
block|{
literal|"ECOMM symbol unmatched by BCOMM"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|complain
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
return|return;
block|}
name|sym
operator|=
operator|(
expr|struct
name|symbol
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|sym
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Note: common_block_name already saved on symbol_obstack */
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|=
name|common_block_name
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_BLOCK
expr_stmt|;
comment|/* Now we copy all the symbols which have been defined since the BCOMM.  */
comment|/* Copy all the struct pendings before common_block.  */
for|for
control|(
name|next
operator|=
name|local_symbols
init|;
name|next
operator|!=
name|NULL
operator|&&
name|next
operator|!=
name|common_block
condition|;
name|next
operator|=
name|next
operator|->
name|next
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|next
operator|->
name|nsyms
condition|;
name|j
operator|++
control|)
name|add_symbol_to_list
argument_list|(
name|next
operator|->
name|symbol
index|[
name|j
index|]
argument_list|,
operator|&
name|new
argument_list|)
expr_stmt|;
block|}
comment|/* Copy however much of COMMON_BLOCK we need.  If COMMON_BLOCK is      NULL, it means copy all the local symbols (which we already did      above).  */
if|if
condition|(
name|common_block
operator|!=
name|NULL
condition|)
for|for
control|(
name|j
operator|=
name|common_block_i
init|;
name|j
operator|<
name|common_block
operator|->
name|nsyms
condition|;
name|j
operator|++
control|)
name|add_symbol_to_list
argument_list|(
name|common_block
operator|->
name|symbol
index|[
name|j
index|]
argument_list|,
operator|&
name|new
argument_list|)
expr_stmt|;
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
operator|(
expr|struct
name|type
operator|*
operator|)
name|new
expr_stmt|;
comment|/* Should we be putting local_symbols back to what it was?      Does it matter?  */
name|i
operator|=
name|hashname
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|SYMBOL_VALUE_CHAIN
argument_list|(
name|sym
argument_list|)
operator|=
name|global_sym_chain
index|[
name|i
index|]
expr_stmt|;
name|global_sym_chain
index|[
name|i
index|]
operator|=
name|sym
expr_stmt|;
name|common_block_name
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a common block's start address to the offset of each symbol    declared to be in it (by being between a BCOMM/ECOMM pair that uses    the common block name).  */
end_comment

begin_function
specifier|static
name|void
name|fix_common_block
parameter_list|(
name|struct
name|symbol
modifier|*
name|sym
parameter_list|,
name|int
name|valu
parameter_list|)
block|{
name|struct
name|pending
modifier|*
name|next
init|=
operator|(
expr|struct
name|pending
operator|*
operator|)
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|next
condition|;
name|next
operator|=
name|next
operator|->
name|next
control|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|next
operator|->
name|nsyms
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|next
operator|->
name|symbol
index|[
name|j
index|]
argument_list|)
operator|+=
name|valu
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* What about types defined as forward references inside of a small lexical    scope?  */
end_comment

begin_comment
comment|/* Add a type to the list of undefined types to be checked through    once this file has been read in.  */
end_comment

begin_function
name|void
name|add_undefined_type
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
if|if
condition|(
name|undef_types_length
operator|==
name|undef_types_allocated
condition|)
block|{
name|undef_types_allocated
operator|*=
literal|2
expr_stmt|;
name|undef_types
operator|=
operator|(
expr|struct
name|type
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|undef_types
argument_list|,
name|undef_types_allocated
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|undef_types
index|[
name|undef_types_length
operator|++
index|]
operator|=
name|type
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Go through each undefined type, see if it's still undefined, and fix it    up if possible.  We have two kinds of undefined types:     TYPE_CODE_ARRAY:  Array whose target type wasn't defined yet.    Fix:  update array length using the element bounds    and the target type's length.    TYPE_CODE_STRUCT, TYPE_CODE_UNION:  Structure whose fields were not    yet defined at the time a pointer to it was made.    Fix:  Do a full lookup on the struct/union tag.  */
end_comment

begin_function
name|void
name|cleanup_undefined_types
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|type
modifier|*
modifier|*
name|type
decl_stmt|;
for|for
control|(
name|type
operator|=
name|undef_types
init|;
name|type
operator|<
name|undef_types
operator|+
name|undef_types_length
condition|;
name|type
operator|++
control|)
block|{
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
operator|*
name|type
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_STRUCT
case|:
case|case
name|TYPE_CODE_UNION
case|:
case|case
name|TYPE_CODE_ENUM
case|:
block|{
comment|/* Check if it has been defined since.  Need to do this here 	       as well as in check_typedef to deal with the (legitimate in 	       C though not C++) case of several types with the same name 	       in different source files.  */
if|if
condition|(
name|TYPE_STUB
argument_list|(
operator|*
name|type
argument_list|)
condition|)
block|{
name|struct
name|pending
modifier|*
name|ppt
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Name of the type, without "struct" or "union" */
name|char
modifier|*
name|typename
init|=
name|TYPE_TAG_NAME
argument_list|(
operator|*
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|typename
operator|==
name|NULL
condition|)
block|{
specifier|static
name|struct
name|complaint
name|msg
init|=
block|{
literal|"need a type name"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|complain
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
break|break;
block|}
for|for
control|(
name|ppt
operator|=
name|file_symbols
init|;
name|ppt
condition|;
name|ppt
operator|=
name|ppt
operator|->
name|next
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ppt
operator|->
name|nsyms
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|symbol
modifier|*
name|sym
init|=
name|ppt
operator|->
name|symbol
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_TYPEDEF
operator|&&
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|==
name|STRUCT_NAMESPACE
operator|&&
operator|(
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE
argument_list|(
operator|*
name|type
argument_list|)
operator|)
operator|&&
name|STREQ
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|typename
argument_list|)
condition|)
block|{
name|memcpy
argument_list|(
operator|*
name|type
argument_list|,
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
break|break;
default|default:
block|{
specifier|static
name|struct
name|complaint
name|msg
init|=
block|{
literal|"\ GDB internal error.  cleanup_undefined_types with bad type %d."
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|complain
argument_list|(
operator|&
name|msg
argument_list|,
name|TYPE_CODE
argument_list|(
operator|*
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
name|undef_types_length
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Scan through all of the global symbols defined in the object file,    assigning values to the debugging symbols that need to be assigned    to.  Get these symbols from the minimal symbol table.  */
end_comment

begin_function
name|void
name|scan_file_globals
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|int
name|hash
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|,
modifier|*
name|prev
decl_stmt|,
modifier|*
name|rsym
decl_stmt|;
name|struct
name|objfile
modifier|*
name|resolve_objfile
decl_stmt|;
comment|/* SVR4 based linkers copy referenced global symbols from shared      libraries to the main executable.      If we are scanning the symbols for a shared library, try to resolve      them from the minimal symbols of the main executable first.  */
if|if
condition|(
name|symfile_objfile
operator|&&
name|objfile
operator|!=
name|symfile_objfile
condition|)
name|resolve_objfile
operator|=
name|symfile_objfile
expr_stmt|;
else|else
name|resolve_objfile
operator|=
name|objfile
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Avoid expensive loop through all minimal symbols if there are          no unresolved symbols.  */
for|for
control|(
name|hash
operator|=
literal|0
init|;
name|hash
operator|<
name|HASHSIZE
condition|;
name|hash
operator|++
control|)
block|{
if|if
condition|(
name|global_sym_chain
index|[
name|hash
index|]
condition|)
break|break;
block|}
if|if
condition|(
name|hash
operator|>=
name|HASHSIZE
condition|)
return|return;
for|for
control|(
name|msymbol
operator|=
name|resolve_objfile
operator|->
name|msymbols
init|;
name|msymbol
operator|&&
name|SYMBOL_NAME
argument_list|(
name|msymbol
argument_list|)
operator|!=
name|NULL
condition|;
name|msymbol
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
comment|/* Skip static symbols.  */
switch|switch
condition|(
name|MSYMBOL_TYPE
argument_list|(
name|msymbol
argument_list|)
condition|)
block|{
case|case
name|mst_file_text
case|:
case|case
name|mst_file_data
case|:
case|case
name|mst_file_bss
case|:
continue|continue;
default|default:
break|break;
block|}
name|prev
operator|=
name|NULL
expr_stmt|;
comment|/* Get the hash index and check all the symbols 	     under that hash index. */
name|hash
operator|=
name|hashname
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|msymbol
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|sym
operator|=
name|global_sym_chain
index|[
name|hash
index|]
init|;
name|sym
condition|;
control|)
block|{
if|if
condition|(
name|SYMBOL_NAME
argument_list|(
name|msymbol
argument_list|)
index|[
literal|0
index|]
operator|==
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
index|[
literal|0
index|]
operator|&&
name|STREQ
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|msymbol
argument_list|)
operator|+
literal|1
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|+
literal|1
argument_list|)
condition|)
block|{
name|struct
name|alias_list
modifier|*
name|aliases
decl_stmt|;
comment|/* Splice this symbol out of the hash chain and 		     assign the value we have to it. */
if|if
condition|(
name|prev
condition|)
block|{
name|SYMBOL_VALUE_CHAIN
argument_list|(
name|prev
argument_list|)
operator|=
name|SYMBOL_VALUE_CHAIN
argument_list|(
name|sym
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|global_sym_chain
index|[
name|hash
index|]
operator|=
name|SYMBOL_VALUE_CHAIN
argument_list|(
name|sym
argument_list|)
expr_stmt|;
block|}
comment|/* Check to see whether we need to fix up a common block.  */
comment|/* Note: this code might be executed several times for 		     the same symbol if there are multiple references.  */
comment|/* If symbol has aliases, do minimal symbol fixups for each. 		     These live aliases/references weren't added to  		     global_sym_chain hash but may also need to be fixed up. */
comment|/* FIXME: Maybe should have added aliases to the global chain,                     resolved symbol name, then treated aliases as normal  		     symbols?  Still, we wouldn't want to add_to_list. */
comment|/* Now do the same for each alias of this symbol */
name|rsym
operator|=
name|sym
expr_stmt|;
name|aliases
operator|=
name|SYMBOL_ALIASES
argument_list|(
name|sym
argument_list|)
expr_stmt|;
while|while
condition|(
name|rsym
condition|)
block|{
if|if
condition|(
name|SYMBOL_CLASS
argument_list|(
name|rsym
argument_list|)
operator|==
name|LOC_BLOCK
condition|)
block|{
name|fix_common_block
argument_list|(
name|rsym
argument_list|,
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|rsym
argument_list|)
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
expr_stmt|;
block|}
name|SYMBOL_SECTION
argument_list|(
name|rsym
argument_list|)
operator|=
name|SYMBOL_SECTION
argument_list|(
name|msymbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|aliases
condition|)
block|{
name|rsym
operator|=
name|aliases
operator|->
name|sym
expr_stmt|;
name|aliases
operator|=
name|aliases
operator|->
name|next
expr_stmt|;
block|}
else|else
name|rsym
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|prev
condition|)
block|{
name|sym
operator|=
name|SYMBOL_VALUE_CHAIN
argument_list|(
name|prev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sym
operator|=
name|global_sym_chain
index|[
name|hash
index|]
expr_stmt|;
block|}
block|}
else|else
block|{
name|prev
operator|=
name|sym
expr_stmt|;
name|sym
operator|=
name|SYMBOL_VALUE_CHAIN
argument_list|(
name|sym
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|resolve_objfile
operator|==
name|objfile
condition|)
break|break;
name|resolve_objfile
operator|=
name|objfile
expr_stmt|;
block|}
comment|/* Change the storage class of any remaining unresolved globals to      LOC_UNRESOLVED and remove them from the chain.  */
for|for
control|(
name|hash
operator|=
literal|0
init|;
name|hash
operator|<
name|HASHSIZE
condition|;
name|hash
operator|++
control|)
block|{
name|sym
operator|=
name|global_sym_chain
index|[
name|hash
index|]
expr_stmt|;
while|while
condition|(
name|sym
condition|)
block|{
name|prev
operator|=
name|sym
expr_stmt|;
name|sym
operator|=
name|SYMBOL_VALUE_CHAIN
argument_list|(
name|sym
argument_list|)
expr_stmt|;
comment|/* Change the symbol address from the misleading chain value 	     to address zero.  */
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|prev
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Complain about unresolved common block symbols.  */
if|if
condition|(
name|SYMBOL_CLASS
argument_list|(
name|prev
argument_list|)
operator|==
name|LOC_STATIC
condition|)
name|SYMBOL_CLASS
argument_list|(
name|prev
argument_list|)
operator|=
name|LOC_UNRESOLVED
expr_stmt|;
else|else
name|complain
argument_list|(
operator|&
name|unresolved_sym_chain_complaint
argument_list|,
name|objfile
operator|->
name|name
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|prev
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|memset
argument_list|(
name|global_sym_chain
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|global_sym_chain
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize anything that needs initializing when starting to read    a fresh piece of a symbol file, e.g. reading in the stuff corresponding    to a psymtab.  */
end_comment

begin_function
name|void
name|stabsread_init
parameter_list|(
name|void
parameter_list|)
block|{ }
end_function

begin_comment
comment|/* Initialize anything that needs initializing when a completely new    symbol file is specified (not just adding some symbols from another    file, e.g. a shared library).  */
end_comment

begin_function
name|void
name|stabsread_new_init
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Empty the hash table of global syms looking for values.  */
name|memset
argument_list|(
name|global_sym_chain
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|global_sym_chain
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize anything that needs initializing at the same time as    start_symtab() is called. */
end_comment

begin_function
name|void
name|start_stabs
parameter_list|(
name|void
parameter_list|)
block|{
name|global_stabs
operator|=
name|NULL
expr_stmt|;
comment|/* AIX COFF */
comment|/* Leave FILENUM of 0 free for builtin types and this file's types.  */
name|n_this_object_header_files
operator|=
literal|1
expr_stmt|;
name|type_vector_length
operator|=
literal|0
expr_stmt|;
name|type_vector
operator|=
operator|(
expr|struct
name|type
operator|*
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* FIXME: If common_block_name is not already NULL, we should complain().  */
name|common_block_name
operator|=
name|NULL
expr_stmt|;
name|os9k_stabs
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Call after end_symtab() */
end_comment

begin_function
name|void
name|end_stabs
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|type_vector
condition|)
block|{
name|xfree
argument_list|(
name|type_vector
argument_list|)
expr_stmt|;
block|}
name|type_vector
operator|=
literal|0
expr_stmt|;
name|type_vector_length
operator|=
literal|0
expr_stmt|;
name|previous_stab_code
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|finish_global_stabs
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
if|if
condition|(
name|global_stabs
condition|)
block|{
name|patch_block_stabs
argument_list|(
name|global_symbols
argument_list|,
name|global_stabs
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|global_stabs
argument_list|)
expr_stmt|;
name|global_stabs
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Initializer for this module */
end_comment

begin_function
name|void
name|_initialize_stabsread
parameter_list|(
name|void
parameter_list|)
block|{
name|undef_types_allocated
operator|=
literal|20
expr_stmt|;
name|undef_types_length
operator|=
literal|0
expr_stmt|;
name|undef_types
operator|=
operator|(
expr|struct
name|type
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|undef_types_allocated
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

