begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* GDB Notifications to Observers.    Copyright 2003 Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* An observer is an entity who is interested in being notified when GDB    reaches certain states, or certain events occur in GDB. The entity being    observed is called the Subject. To receive notifications, the observer    attaches a callback to the subject. One subject can have several    observers.     This file implements an internal generic low-level event notification    mechanism based on the Observer paradigm described in the book "Design    Patterns".  This generic event notification mechansim is then re-used    to implement the exported high-level notification management routines    for all possible notifications.     The current implementation of the generic observer provides support    for contextual data. This contextual data is given to the subject    when attaching the callback. In return, the subject will provide    this contextual data back to the observer as a parameter of the    callback.     FIXME: The current support for the contextual data is only partial,    as it lacks a mechanism that would deallocate this data when the    callback is detached. This is not a problem so far, as this contextual    data is only used internally to hold a function pointer. Later on,    if a certain observer needs to provide support for user-level    contextual data, then the generic notification mechanism will need    need to be enhanced to allow the observer to provide a routine to    deallocate the data when attaching the callback.     This file is currently maintained by hand, but the long term plan    if the number of different notifications starts growing is to create    a new script (observer.sh) that would generate this file, and the    associated documentation.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"observer.h"
end_include

begin_comment
comment|/* The internal generic observer.  */
end_comment

begin_typedef
typedef|typedef
name|void
function_decl|(
name|generic_observer_notification_ftype
function_decl|)
parameter_list|(
specifier|const
name|void
modifier|*
name|data
parameter_list|,
specifier|const
name|void
modifier|*
name|args
parameter_list|)
function_decl|;
end_typedef

begin_struct
struct|struct
name|observer
block|{
name|generic_observer_notification_ftype
modifier|*
name|notify
decl_stmt|;
comment|/* No memory management needed for the following field for now.  */
name|void
modifier|*
name|data
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* A list of observers, maintained by the subject.  A subject is    actually represented by its list of observers.  */
end_comment

begin_struct
struct|struct
name|observer_list
block|{
name|struct
name|observer_list
modifier|*
name|next
decl_stmt|;
name|struct
name|observer
modifier|*
name|observer
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Allocate a struct observer_list, intended to be used as a node    in the list of observers maintained by a subject.  */
end_comment

begin_function
specifier|static
name|struct
name|observer_list
modifier|*
name|xalloc_observer_list_node
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|observer_list
modifier|*
name|node
init|=
name|XMALLOC
argument_list|(
expr|struct
name|observer_list
argument_list|)
decl_stmt|;
name|node
operator|->
name|observer
operator|=
name|XMALLOC
argument_list|(
expr|struct
name|observer
argument_list|)
expr_stmt|;
return|return
name|node
return|;
block|}
end_function

begin_comment
comment|/* The opposite of xalloc_observer_list_node, frees the memory for    the given node.  */
end_comment

begin_function
specifier|static
name|void
name|xfree_observer_list_node
parameter_list|(
name|struct
name|observer_list
modifier|*
name|node
parameter_list|)
block|{
name|xfree
argument_list|(
name|node
operator|->
name|observer
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Attach the callback NOTIFY to a SUBJECT.  The DATA is also stored,    in order for the subject to provide it back to the observer during    a notification.  */
end_comment

begin_function
specifier|static
name|struct
name|observer
modifier|*
name|generic_observer_attach
parameter_list|(
name|struct
name|observer_list
modifier|*
modifier|*
name|subject
parameter_list|,
name|generic_observer_notification_ftype
modifier|*
name|notify
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|observer_list
modifier|*
name|observer_list
init|=
name|xalloc_observer_list_node
argument_list|()
decl_stmt|;
name|observer_list
operator|->
name|next
operator|=
operator|*
name|subject
expr_stmt|;
name|observer_list
operator|->
name|observer
operator|->
name|notify
operator|=
name|notify
expr_stmt|;
name|observer_list
operator|->
name|observer
operator|->
name|data
operator|=
name|data
expr_stmt|;
operator|*
name|subject
operator|=
name|observer_list
expr_stmt|;
return|return
name|observer_list
operator|->
name|observer
return|;
block|}
end_function

begin_comment
comment|/* Remove the given OBSERVER from the SUBJECT.  Once detached, OBSERVER    should no longer be used, as it is no longer valid.  */
end_comment

begin_function
specifier|static
name|void
name|generic_observer_detach
parameter_list|(
name|struct
name|observer_list
modifier|*
modifier|*
name|subject
parameter_list|,
specifier|const
name|struct
name|observer
modifier|*
name|observer
parameter_list|)
block|{
name|struct
name|observer_list
modifier|*
name|previous_node
init|=
name|NULL
decl_stmt|;
name|struct
name|observer_list
modifier|*
name|current_node
init|=
operator|*
name|subject
decl_stmt|;
while|while
condition|(
name|current_node
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|current_node
operator|->
name|observer
operator|==
name|observer
condition|)
block|{
if|if
condition|(
name|previous_node
operator|!=
name|NULL
condition|)
name|previous_node
operator|->
name|next
operator|=
name|current_node
operator|->
name|next
expr_stmt|;
else|else
operator|*
name|subject
operator|=
name|current_node
operator|->
name|next
expr_stmt|;
name|xfree_observer_list_node
argument_list|(
name|current_node
argument_list|)
expr_stmt|;
return|return;
block|}
name|previous_node
operator|=
name|current_node
expr_stmt|;
name|current_node
operator|=
name|current_node
operator|->
name|next
expr_stmt|;
block|}
comment|/* We should never reach this point.  However, this should not be      a very serious error, so simply report a warning to the user.  */
name|warning
argument_list|(
literal|"Failed to detach observer"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Send a notification to all the observers of SUBJECT.  ARGS is passed to    all observers as an argument to the notification callback.  */
end_comment

begin_function
specifier|static
name|void
name|generic_observer_notify
parameter_list|(
name|struct
name|observer_list
modifier|*
name|subject
parameter_list|,
specifier|const
name|void
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|observer_list
modifier|*
name|current_node
init|=
name|subject
decl_stmt|;
while|while
condition|(
name|current_node
operator|!=
name|NULL
condition|)
block|{
call|(
modifier|*
name|current_node
operator|->
name|observer
operator|->
name|notify
call|)
argument_list|(
name|current_node
operator|->
name|observer
operator|->
name|data
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|current_node
operator|=
name|current_node
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* normal_stop notifications.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|observer_list
modifier|*
name|normal_stop_subject
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|observer_normal_stop_notification_stub
parameter_list|(
specifier|const
name|void
modifier|*
name|data
parameter_list|,
specifier|const
name|void
modifier|*
name|unused_args
parameter_list|)
block|{
name|observer_normal_stop_ftype
modifier|*
name|notify
init|=
operator|(
name|observer_normal_stop_ftype
operator|*
operator|)
name|data
decl_stmt|;
call|(
modifier|*
name|notify
call|)
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|observer
modifier|*
name|observer_attach_normal_stop
parameter_list|(
name|observer_normal_stop_ftype
modifier|*
name|f
parameter_list|)
block|{
return|return
name|generic_observer_attach
argument_list|(
operator|&
name|normal_stop_subject
argument_list|,
operator|&
name|observer_normal_stop_notification_stub
argument_list|,
operator|(
name|void
operator|*
operator|)
name|f
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|observer_detach_normal_stop
parameter_list|(
name|struct
name|observer
modifier|*
name|observer
parameter_list|)
block|{
name|generic_observer_detach
argument_list|(
operator|&
name|normal_stop_subject
argument_list|,
name|observer
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|observer_notify_normal_stop
parameter_list|(
name|void
parameter_list|)
block|{
name|generic_observer_notify
argument_list|(
name|normal_stop_subject
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The following code is only used to unit-test the observers from our    testsuite.  DO NOT USE IT within observer.c (or anywhere else for    that matter)!  */
end_comment

begin_comment
comment|/* If we define these variables and functions as `static', the    compiler will optimize them out.  */
end_comment

begin_decl_stmt
name|int
name|observer_test_first_observer
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|observer_test_second_observer
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|observer_test_third_observer
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|observer_test_first_notification_function
parameter_list|(
name|void
parameter_list|)
block|{
name|observer_test_first_observer
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|void
name|observer_test_second_notification_function
parameter_list|(
name|void
parameter_list|)
block|{
name|observer_test_second_observer
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|void
name|observer_test_third_notification_function
parameter_list|(
name|void
parameter_list|)
block|{
name|observer_test_third_observer
operator|++
expr_stmt|;
block|}
end_function

end_unit

