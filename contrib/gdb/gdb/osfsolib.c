begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Handle OSF/1 shared libraries for GDB, the GNU Debugger.    Copyright 1993, 1994, 1995, 1996 Free Software Foundation, Inc.     This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* FIXME: Most of this code could be merged with solib.c by using    next_link_map_member and xfer_link_map_member in solib.c.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"gnu-regex.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_define
define|#
directive|define
name|MAX_PATH_SIZE
value|1024
end_define

begin_comment
comment|/* FIXME: Should be dynamic */
end_comment

begin_comment
comment|/* When handling shared libraries, GDB has to find out the pathnames    of all shared libraries that are currently loaded (to read in their    symbols) and where the shared libraries are loaded in memory    (to relocate them properly from their prelinked addresses to the    current load address).     Under OSF/1 there are two possibilities to get at this information:    1) Peek around in the runtime loader structures.       These are not documented, and they are not defined in the system       header files. The definitions below were obtained by experimentation,       but they seem stable enough.    2) Use the undocumented libxproc.a library, which contains the       equivalent ldr_* routines.       This approach is somewhat cleaner, but it requires that the GDB       executable is dynamically linked. In addition it requires a       NAT_CLIBS= -lxproc -Wl,-expect_unresolved,ldr_process_context       linker specification for GDB and all applications that are using       libgdb.    We will use the peeking approach until it becomes unwieldy.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|USE_LDR_ROUTINES
end_ifndef

begin_comment
comment|/* Definition of runtime loader structures, found by experimentation.  */
end_comment

begin_define
define|#
directive|define
name|RLD_CONTEXT_ADDRESS
value|0x3ffc0000000
end_define

begin_typedef
typedef|typedef
struct|struct
block|{
name|CORE_ADDR
name|next
decl_stmt|;
name|CORE_ADDR
name|previous
decl_stmt|;
name|CORE_ADDR
name|unknown1
decl_stmt|;
name|char
modifier|*
name|module_name
decl_stmt|;
name|CORE_ADDR
name|modinfo_addr
decl_stmt|;
name|long
name|module_id
decl_stmt|;
name|CORE_ADDR
name|unknown2
decl_stmt|;
name|CORE_ADDR
name|unknown3
decl_stmt|;
name|long
name|region_count
decl_stmt|;
name|CORE_ADDR
name|regioninfo_addr
decl_stmt|;
block|}
name|ldr_module_info_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|long
name|unknown1
decl_stmt|;
name|CORE_ADDR
name|regionname_addr
decl_stmt|;
name|long
name|protection
decl_stmt|;
name|CORE_ADDR
name|vaddr
decl_stmt|;
name|CORE_ADDR
name|mapaddr
decl_stmt|;
name|long
name|size
decl_stmt|;
name|long
name|unknown2
index|[
literal|5
index|]
decl_stmt|;
block|}
name|ldr_region_info_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|CORE_ADDR
name|unknown1
decl_stmt|;
name|CORE_ADDR
name|unknown2
decl_stmt|;
name|CORE_ADDR
name|head
decl_stmt|;
name|CORE_ADDR
name|tail
decl_stmt|;
block|}
name|ldr_context_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|ldr_context_t
name|ldr_context
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<loader.h>
end_include

begin_decl_stmt
specifier|static
name|ldr_process_t
name|fake_ldr_process
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Called by ldr_* routines to read memory from the current target.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ldr_read_memory
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
operator|,
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|ldr_read_memory
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|,
name|readstring
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|readstring
decl_stmt|;
block|{
name|int
name|result
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
if|if
condition|(
name|readstring
condition|)
block|{
name|target_read_string
argument_list|(
name|memaddr
argument_list|,
operator|&
name|buffer
argument_list|,
name|len
argument_list|,
operator|&
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
literal|0
condition|)
name|strcpy
argument_list|(
name|myaddr
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
else|else
name|result
operator|=
name|target_read_memory
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
name|result
operator|=
operator|-
name|result
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Define our own link_map structure.    This will help to share code with solib.c.  */
end_comment

begin_struct
struct|struct
name|link_map
block|{
name|CORE_ADDR
name|l_offset
decl_stmt|;
comment|/* prelink to load address offset */
name|char
modifier|*
name|l_name
decl_stmt|;
comment|/* full name of loaded object */
name|ldr_module_info_t
name|module_info
decl_stmt|;
comment|/* corresponding module info */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|LM_OFFSET
parameter_list|(
name|so
parameter_list|)
value|((so) -> lm.l_offset)
end_define

begin_define
define|#
directive|define
name|LM_NAME
parameter_list|(
name|so
parameter_list|)
value|((so) -> lm.l_name)
end_define

begin_struct
struct|struct
name|so_list
block|{
name|struct
name|so_list
modifier|*
name|next
decl_stmt|;
comment|/* next structure in linked list */
name|struct
name|link_map
name|lm
decl_stmt|;
comment|/* copy of link map from inferior */
name|struct
name|link_map
modifier|*
name|lmaddr
decl_stmt|;
comment|/* addr in inferior lm was read from */
name|CORE_ADDR
name|lmend
decl_stmt|;
comment|/* upper addr bound of mapped object */
name|char
name|so_name
index|[
name|MAX_PATH_SIZE
index|]
decl_stmt|;
comment|/* shared object lib name (FIXME) */
name|char
name|symbols_loaded
decl_stmt|;
comment|/* flag: symbols read in yet? */
name|char
name|from_tty
decl_stmt|;
comment|/* flag: print msgs? */
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
comment|/* objfile for loaded lib */
name|struct
name|section_table
modifier|*
name|sections
decl_stmt|;
name|struct
name|section_table
modifier|*
name|sections_end
decl_stmt|;
name|struct
name|section_table
modifier|*
name|textsection
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|so_list
modifier|*
name|so_list_head
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of known shared objects */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|fdmatch
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* In libiberty */
end_comment

begin_comment
comment|/* Local function prototypes */
end_comment

begin_decl_stmt
specifier|static
name|void
name|sharedlibrary_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|info_sharedlibrary_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|symbol_add_stub
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|so_list
modifier|*
name|find_solib
name|PARAMS
argument_list|(
operator|(
expr|struct
name|so_list
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|link_map
modifier|*
name|first_link_map_member
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|link_map
modifier|*
name|next_link_map_member
name|PARAMS
argument_list|(
operator|(
expr|struct
name|so_list
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|xfer_link_map_member
name|PARAMS
argument_list|(
operator|(
expr|struct
name|so_list
operator|*
operator|,
expr|struct
name|link_map
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|solib_map_sections
name|PARAMS
argument_list|(
operator|(
expr|struct
name|so_list
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  LOCAL FUNCTION  	solib_map_sections -- open bfd and build sections for shared lib  SYNOPSIS  	static void solib_map_sections (struct so_list *so)  DESCRIPTION  	Given a pointer to one of the shared objects in our list 	of mapped objects, use the recorded name to open a bfd 	descriptor for the object, build a section table, and then 	relocate all the section addresses by the base address at 	which the shared object was mapped.  FIXMES  	In most (all?) cases the shared object file name recorded in the 	dynamic linkage tables will be a fully qualified pathname.  For 	cases where it isn't, do we really mimic the systems search 	mechanism correctly in the below code (particularly the tilde 	expansion stuff?).  */
end_comment

begin_function
specifier|static
name|void
name|solib_map_sections
parameter_list|(
name|so
parameter_list|)
name|struct
name|so_list
modifier|*
name|so
decl_stmt|;
block|{
name|char
modifier|*
name|filename
decl_stmt|;
name|char
modifier|*
name|scratch_pathname
decl_stmt|;
name|int
name|scratch_chan
decl_stmt|;
name|struct
name|section_table
modifier|*
name|p
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|filename
operator|=
name|tilde_expand
argument_list|(
name|so
operator|->
name|so_name
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|scratch_chan
operator|=
name|openp
argument_list|(
name|getenv
argument_list|(
literal|"PATH"
argument_list|)
argument_list|,
literal|1
argument_list|,
name|filename
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|,
operator|&
name|scratch_pathname
argument_list|)
expr_stmt|;
if|if
condition|(
name|scratch_chan
operator|<
literal|0
condition|)
block|{
name|scratch_chan
operator|=
name|openp
argument_list|(
name|getenv
argument_list|(
literal|"LD_LIBRARY_PATH"
argument_list|)
argument_list|,
literal|1
argument_list|,
name|filename
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|,
operator|&
name|scratch_pathname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|scratch_chan
operator|<
literal|0
condition|)
block|{
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
comment|/* Leave scratch_pathname allocated.  bfd->name will point to it.  */
name|abfd
operator|=
name|bfd_fdopenr
argument_list|(
name|scratch_pathname
argument_list|,
name|gnutarget
argument_list|,
name|scratch_chan
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|abfd
condition|)
block|{
name|close
argument_list|(
name|scratch_chan
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Could not open `%s' as an executable file: %s"
argument_list|,
name|scratch_pathname
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Leave bfd open, core_xfer_memory and "info files" need it.  */
name|so
operator|->
name|abfd
operator|=
name|abfd
expr_stmt|;
name|abfd
operator|->
name|cacheable
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_check_format
argument_list|(
name|abfd
argument_list|,
name|bfd_object
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"\"%s\": not in executable format: %s."
argument_list|,
name|scratch_pathname
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|build_section_table
argument_list|(
name|abfd
argument_list|,
operator|&
name|so
operator|->
name|sections
argument_list|,
operator|&
name|so
operator|->
name|sections_end
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"Can't find the file sections in `%s': %s"
argument_list|,
name|bfd_get_filename
argument_list|(
name|exec_bfd
argument_list|)
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|p
operator|=
name|so
operator|->
name|sections
init|;
name|p
operator|<
name|so
operator|->
name|sections_end
condition|;
name|p
operator|++
control|)
block|{
comment|/* Relocate the section binding addresses as recorded in the shared 	 object's file by the offset to get the address to which the 	 object was actually mapped.  */
name|p
operator|->
name|addr
operator|+=
name|LM_OFFSET
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|p
operator|->
name|endaddr
operator|+=
name|LM_OFFSET
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|so
operator|->
name|lmend
operator|=
operator|(
name|CORE_ADDR
operator|)
name|max
argument_list|(
name|p
operator|->
name|endaddr
argument_list|,
name|so
operator|->
name|lmend
argument_list|)
expr_stmt|;
if|if
condition|(
name|STREQ
argument_list|(
name|p
operator|->
name|the_bfd_section
operator|->
name|name
argument_list|,
literal|".text"
argument_list|)
condition|)
block|{
name|so
operator|->
name|textsection
operator|=
name|p
expr_stmt|;
block|}
block|}
comment|/* Free the file names, close the file now.  */
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	first_link_map_member -- locate first member in dynamic linker's map  SYNOPSIS  	static struct link_map *first_link_map_member (void)  DESCRIPTION  	Read in a copy of the first member in the inferior's dynamic 	link map from the inferior's dynamic linker structures, and return 	a pointer to the copy in our address space. */
end_comment

begin_function
specifier|static
name|struct
name|link_map
modifier|*
name|first_link_map_member
parameter_list|()
block|{
name|struct
name|link_map
modifier|*
name|lm
init|=
name|NULL
decl_stmt|;
specifier|static
name|struct
name|link_map
name|first_lm
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_LDR_ROUTINES
name|ldr_module_t
name|mod_id
init|=
name|LDR_NULL_MODULE
decl_stmt|;
name|size_t
name|retsize
decl_stmt|;
name|fake_ldr_process
operator|=
name|ldr_core_process
argument_list|()
expr_stmt|;
name|ldr_set_core_reader
argument_list|(
name|ldr_read_memory
argument_list|)
expr_stmt|;
name|ldr_xdetach
argument_list|(
name|fake_ldr_process
argument_list|)
expr_stmt|;
if|if
condition|(
name|ldr_xattach
argument_list|(
name|fake_ldr_process
argument_list|)
operator|!=
literal|0
operator|||
name|ldr_next_module
argument_list|(
name|fake_ldr_process
argument_list|,
operator|&
name|mod_id
argument_list|)
operator|!=
literal|0
operator|||
name|mod_id
operator|==
name|LDR_NULL_MODULE
operator|||
name|ldr_inq_module
argument_list|(
name|fake_ldr_process
argument_list|,
name|mod_id
argument_list|,
operator|&
name|first_lm
operator|.
name|module_info
argument_list|,
sizeof|sizeof
argument_list|(
name|ldr_module_info_t
argument_list|)
argument_list|,
operator|&
name|retsize
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|lm
return|;
else|#
directive|else
name|CORE_ADDR
name|ldr_context_addr
decl_stmt|;
if|if
condition|(
name|target_read_memory
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|RLD_CONTEXT_ADDRESS
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ldr_context_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|CORE_ADDR
argument_list|)
argument_list|)
operator|!=
literal|0
operator|||
name|target_read_memory
argument_list|(
name|ldr_context_addr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ldr_context
argument_list|,
sizeof|sizeof
argument_list|(
name|ldr_context_t
argument_list|)
argument_list|)
operator|!=
literal|0
operator|||
name|target_read_memory
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|ldr_context
operator|.
name|head
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|first_lm
operator|.
name|module_info
argument_list|,
sizeof|sizeof
argument_list|(
name|ldr_module_info_t
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|lm
return|;
endif|#
directive|endif
name|lm
operator|=
operator|&
name|first_lm
expr_stmt|;
comment|/* The first entry is for the main program and should be skipped.  */
name|lm
operator|->
name|l_name
operator|=
name|NULL
expr_stmt|;
return|return
name|lm
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|link_map
modifier|*
name|next_link_map_member
parameter_list|(
name|so_list_ptr
parameter_list|)
name|struct
name|so_list
modifier|*
name|so_list_ptr
decl_stmt|;
block|{
name|struct
name|link_map
modifier|*
name|lm
init|=
name|NULL
decl_stmt|;
specifier|static
name|struct
name|link_map
name|next_lm
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_LDR_ROUTINES
name|ldr_module_t
name|mod_id
init|=
name|so_list_ptr
operator|->
name|lm
operator|.
name|module_info
operator|.
name|lmi_modid
decl_stmt|;
name|size_t
name|retsize
decl_stmt|;
if|if
condition|(
name|ldr_next_module
argument_list|(
name|fake_ldr_process
argument_list|,
operator|&
name|mod_id
argument_list|)
operator|!=
literal|0
operator|||
name|mod_id
operator|==
name|LDR_NULL_MODULE
operator|||
name|ldr_inq_module
argument_list|(
name|fake_ldr_process
argument_list|,
name|mod_id
argument_list|,
operator|&
name|next_lm
operator|.
name|module_info
argument_list|,
sizeof|sizeof
argument_list|(
name|ldr_module_info_t
argument_list|)
argument_list|,
operator|&
name|retsize
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|lm
return|;
name|lm
operator|=
operator|&
name|next_lm
expr_stmt|;
name|lm
operator|->
name|l_name
operator|=
name|lm
operator|->
name|module_info
operator|.
name|lmi_name
expr_stmt|;
else|#
directive|else
name|CORE_ADDR
name|ldr_context_addr
decl_stmt|;
comment|/* Reread context in case ldr_context.tail was updated.  */
if|if
condition|(
name|target_read_memory
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|RLD_CONTEXT_ADDRESS
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ldr_context_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|CORE_ADDR
argument_list|)
argument_list|)
operator|!=
literal|0
operator|||
name|target_read_memory
argument_list|(
name|ldr_context_addr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ldr_context
argument_list|,
sizeof|sizeof
argument_list|(
name|ldr_context_t
argument_list|)
argument_list|)
operator|!=
literal|0
operator|||
name|so_list_ptr
operator|->
name|lm
operator|.
name|module_info
operator|.
name|modinfo_addr
operator|==
name|ldr_context
operator|.
name|tail
operator|||
name|target_read_memory
argument_list|(
name|so_list_ptr
operator|->
name|lm
operator|.
name|module_info
operator|.
name|next
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|next_lm
operator|.
name|module_info
argument_list|,
sizeof|sizeof
argument_list|(
name|ldr_module_info_t
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|lm
return|;
name|lm
operator|=
operator|&
name|next_lm
expr_stmt|;
name|lm
operator|->
name|l_name
operator|=
name|lm
operator|->
name|module_info
operator|.
name|module_name
expr_stmt|;
endif|#
directive|endif
return|return
name|lm
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xfer_link_map_member
parameter_list|(
name|so_list_ptr
parameter_list|,
name|lm
parameter_list|)
name|struct
name|so_list
modifier|*
name|so_list_ptr
decl_stmt|;
name|struct
name|link_map
modifier|*
name|lm
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|so_list_ptr
operator|->
name|lm
operator|=
operator|*
name|lm
expr_stmt|;
comment|/* OSF/1 shared libraries are pre-linked to particular addresses,      but the runtime loader may have to relocate them if the      address ranges of the libraries used by the target executable clash,      or if the target executable is linked with the -taso option.      The offset is the difference between the address where the shared      library is mapped and the pre-linked address of the shared library.       FIXME:  GDB is currently unable to relocate the shared library      sections by different offsets. If sections are relocated by      different offsets, put out a warning and use the offset of the      first section for all remaining sections.  */
name|LM_OFFSET
argument_list|(
name|so_list_ptr
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* There is one entry that has no name (for the inferior executable)      since it is not a shared object. */
if|if
condition|(
name|LM_NAME
argument_list|(
name|so_list_ptr
argument_list|)
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|USE_LDR_ROUTINES
name|int
name|len
init|=
name|strlen
argument_list|(
name|LM_NAME
argument_list|(
name|so_list_ptr
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|>
name|MAX_PATH_SIZE
condition|)
name|len
operator|=
name|MAX_PATH_SIZE
expr_stmt|;
name|strncpy
argument_list|(
name|so_list_ptr
operator|->
name|so_name
argument_list|,
name|LM_NAME
argument_list|(
name|so_list_ptr
argument_list|)
argument_list|,
name|MAX_PATH_SIZE
argument_list|)
expr_stmt|;
name|so_list_ptr
operator|->
name|so_name
index|[
name|MAX_PATH_SIZE
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lm
operator|->
name|module_info
operator|.
name|lmi_nregion
condition|;
name|i
operator|++
control|)
block|{
name|ldr_region_info_t
name|region_info
decl_stmt|;
name|size_t
name|retsize
decl_stmt|;
name|CORE_ADDR
name|region_offset
decl_stmt|;
if|if
condition|(
name|ldr_inq_region
argument_list|(
name|fake_ldr_process
argument_list|,
name|lm
operator|->
name|module_info
operator|.
name|lmi_modid
argument_list|,
name|i
argument_list|,
operator|&
name|region_info
argument_list|,
sizeof|sizeof
argument_list|(
name|region_info
argument_list|)
argument_list|,
operator|&
name|retsize
argument_list|)
operator|!=
literal|0
condition|)
break|break;
name|region_offset
operator|=
operator|(
name|CORE_ADDR
operator|)
name|region_info
operator|.
name|lri_mapaddr
operator|-
operator|(
name|CORE_ADDR
operator|)
name|region_info
operator|.
name|lri_vaddr
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|LM_OFFSET
argument_list|(
name|so_list_ptr
argument_list|)
operator|=
name|region_offset
expr_stmt|;
elseif|else
if|if
condition|(
name|LM_OFFSET
argument_list|(
name|so_list_ptr
argument_list|)
operator|!=
name|region_offset
condition|)
name|warning
argument_list|(
literal|"cannot handle shared library relocation for %s (%s)"
argument_list|,
name|so_list_ptr
operator|->
name|so_name
argument_list|,
name|region_info
operator|.
name|lri_name
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|int
name|errcode
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
name|target_read_string
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|LM_NAME
argument_list|(
name|so_list_ptr
argument_list|)
argument_list|,
operator|&
name|buffer
argument_list|,
name|MAX_PATH_SIZE
operator|-
literal|1
argument_list|,
operator|&
name|errcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|errcode
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|"xfer_link_map_member: Can't read pathname for load map: %s\n"
argument_list|,
name|safe_strerror
argument_list|(
name|errcode
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|so_list_ptr
operator|->
name|so_name
argument_list|,
name|buffer
argument_list|,
name|MAX_PATH_SIZE
operator|-
literal|1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|so_list_ptr
operator|->
name|so_name
index|[
name|MAX_PATH_SIZE
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lm
operator|->
name|module_info
operator|.
name|region_count
condition|;
name|i
operator|++
control|)
block|{
name|ldr_region_info_t
name|region_info
decl_stmt|;
name|CORE_ADDR
name|region_offset
decl_stmt|;
if|if
condition|(
name|target_read_memory
argument_list|(
name|lm
operator|->
name|module_info
operator|.
name|regioninfo_addr
operator|+
name|i
operator|*
sizeof|sizeof
argument_list|(
name|region_info
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|region_info
argument_list|,
sizeof|sizeof
argument_list|(
name|region_info
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
break|break;
name|region_offset
operator|=
name|region_info
operator|.
name|mapaddr
operator|-
name|region_info
operator|.
name|vaddr
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|LM_OFFSET
argument_list|(
name|so_list_ptr
argument_list|)
operator|=
name|region_offset
expr_stmt|;
elseif|else
if|if
condition|(
name|LM_OFFSET
argument_list|(
name|so_list_ptr
argument_list|)
operator|!=
name|region_offset
condition|)
block|{
name|char
modifier|*
name|region_name
decl_stmt|;
name|target_read_string
argument_list|(
name|region_info
operator|.
name|regionname_addr
argument_list|,
operator|&
name|buffer
argument_list|,
name|MAX_PATH_SIZE
operator|-
literal|1
argument_list|,
operator|&
name|errcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|errcode
operator|==
literal|0
condition|)
name|region_name
operator|=
name|buffer
expr_stmt|;
else|else
name|region_name
operator|=
literal|"??"
expr_stmt|;
name|warning
argument_list|(
literal|"cannot handle shared library relocation for %s (%s)"
argument_list|,
name|so_list_ptr
operator|->
name|so_name
argument_list|,
name|region_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|solib_map_sections
argument_list|(
name|so_list_ptr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	find_solib -- step through list of shared objects  SYNOPSIS  	struct so_list *find_solib (struct so_list *so_list_ptr)  DESCRIPTION  	This module contains the routine which finds the names of any 	loaded "images" in the current process. The argument in must be 	NULL on the first call, and then the returned value must be passed 	in on subsequent calls. This provides the capability to "step" down 	the list of loaded objects. On the last object, a NULL value is 	returned.  	The arg and return value are "struct link_map" pointers, as defined 	in<link.h>.  */
end_comment

begin_function
specifier|static
name|struct
name|so_list
modifier|*
name|find_solib
parameter_list|(
name|so_list_ptr
parameter_list|)
name|struct
name|so_list
modifier|*
name|so_list_ptr
decl_stmt|;
comment|/* Last lm or NULL for first one */
block|{
name|struct
name|so_list
modifier|*
name|so_list_next
init|=
name|NULL
decl_stmt|;
name|struct
name|link_map
modifier|*
name|lm
init|=
name|NULL
decl_stmt|;
name|struct
name|so_list
modifier|*
name|new
decl_stmt|;
if|if
condition|(
name|so_list_ptr
operator|==
name|NULL
condition|)
block|{
comment|/* We are setting up for a new scan through the loaded images. */
if|if
condition|(
operator|(
name|so_list_next
operator|=
name|so_list_head
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* Find the first link map list member. */
name|lm
operator|=
name|first_link_map_member
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* We have been called before, and are in the process of walking 	 the shared library list.  Advance to the next shared object. */
name|lm
operator|=
name|next_link_map_member
argument_list|(
name|so_list_ptr
argument_list|)
expr_stmt|;
name|so_list_next
operator|=
name|so_list_ptr
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|so_list_next
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|lm
operator|!=
name|NULL
operator|)
condition|)
block|{
comment|/* Get next link map structure from inferior image and build a local 	 abbreviated load_map structure */
name|new
operator|=
operator|(
expr|struct
name|so_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|so_list
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|new
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|so_list
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|lmaddr
operator|=
name|lm
expr_stmt|;
comment|/* Add the new node as the next node in the list, or as the root 	 node if this is the first one. */
if|if
condition|(
name|so_list_ptr
operator|!=
name|NULL
condition|)
block|{
name|so_list_ptr
operator|->
name|next
operator|=
name|new
expr_stmt|;
block|}
else|else
block|{
name|so_list_head
operator|=
name|new
expr_stmt|;
block|}
name|so_list_next
operator|=
name|new
expr_stmt|;
name|xfer_link_map_member
argument_list|(
name|new
argument_list|,
name|lm
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|so_list_next
operator|)
return|;
block|}
end_function

begin_comment
comment|/* A small stub to get us past the arg-passing pinhole of catch_errors.  */
end_comment

begin_function
specifier|static
name|int
name|symbol_add_stub
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
specifier|register
name|struct
name|so_list
modifier|*
name|so
init|=
operator|(
expr|struct
name|so_list
operator|*
operator|)
name|arg
decl_stmt|;
comment|/* catch_errs bogon */
name|so
operator|->
name|objfile
operator|=
name|symbol_file_add
argument_list|(
name|so
operator|->
name|so_name
argument_list|,
name|so
operator|->
name|from_tty
argument_list|,
name|so
operator|->
name|textsection
operator|->
name|addr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  GLOBAL FUNCTION  	solib_add -- add a shared library file to the symtab and section list  SYNOPSIS  	void solib_add (char *arg_string, int from_tty, 			struct target_ops *target)  DESCRIPTION  */
end_comment

begin_function
name|void
name|solib_add
parameter_list|(
name|arg_string
parameter_list|,
name|from_tty
parameter_list|,
name|target
parameter_list|)
name|char
modifier|*
name|arg_string
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
name|struct
name|target_ops
modifier|*
name|target
decl_stmt|;
block|{
specifier|register
name|struct
name|so_list
modifier|*
name|so
init|=
name|NULL
decl_stmt|;
comment|/* link map state variable */
comment|/* Last shared library that we read.  */
name|struct
name|so_list
modifier|*
name|so_last
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|re_err
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|old
decl_stmt|;
if|if
condition|(
operator|(
name|re_err
operator|=
name|re_comp
argument_list|(
name|arg_string
condition|?
name|arg_string
else|:
literal|"."
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"Invalid regexp: %s"
argument_list|,
name|re_err
argument_list|)
expr_stmt|;
block|}
comment|/* Add the shared library sections to the section table of the      specified target, if any.  */
if|if
condition|(
name|target
condition|)
block|{
comment|/* Count how many new section_table entries there are.  */
name|so
operator|=
name|NULL
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|so
operator|=
name|find_solib
argument_list|(
name|so
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|so
operator|->
name|so_name
index|[
literal|0
index|]
condition|)
block|{
name|count
operator|+=
name|so
operator|->
name|sections_end
operator|-
name|so
operator|->
name|sections
expr_stmt|;
block|}
block|}
if|if
condition|(
name|count
condition|)
block|{
name|int
name|update_coreops
decl_stmt|;
comment|/* We must update the to_sections field in the core_ops structure 	     here, otherwise we dereference a potential dangling pointer 	     for each call to target_read/write_memory within this routine.  */
name|update_coreops
operator|=
name|core_ops
operator|.
name|to_sections
operator|==
name|target
operator|->
name|to_sections
expr_stmt|;
comment|/* Reallocate the target's section table including the new size.  */
if|if
condition|(
name|target
operator|->
name|to_sections
condition|)
block|{
name|old
operator|=
name|target
operator|->
name|to_sections_end
operator|-
name|target
operator|->
name|to_sections
expr_stmt|;
name|target
operator|->
name|to_sections
operator|=
operator|(
expr|struct
name|section_table
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|target
operator|->
name|to_sections
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|section_table
argument_list|)
operator|)
operator|*
operator|(
name|count
operator|+
name|old
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|old
operator|=
literal|0
expr_stmt|;
name|target
operator|->
name|to_sections
operator|=
operator|(
expr|struct
name|section_table
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|section_table
argument_list|)
operator|)
operator|*
name|count
argument_list|)
expr_stmt|;
block|}
name|target
operator|->
name|to_sections_end
operator|=
name|target
operator|->
name|to_sections
operator|+
operator|(
name|count
operator|+
name|old
operator|)
expr_stmt|;
comment|/* Update the to_sections field in the core_ops structure 	     if needed.  */
if|if
condition|(
name|update_coreops
condition|)
block|{
name|core_ops
operator|.
name|to_sections
operator|=
name|target
operator|->
name|to_sections
expr_stmt|;
name|core_ops
operator|.
name|to_sections_end
operator|=
name|target
operator|->
name|to_sections_end
expr_stmt|;
block|}
comment|/* Add these section table entries to the target's table.  */
while|while
condition|(
operator|(
name|so
operator|=
name|find_solib
argument_list|(
name|so
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|so
operator|->
name|so_name
index|[
literal|0
index|]
condition|)
block|{
name|count
operator|=
name|so
operator|->
name|sections_end
operator|-
name|so
operator|->
name|sections
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|target
operator|->
name|to_sections
operator|+
name|old
operator|)
argument_list|,
name|so
operator|->
name|sections
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|section_table
argument_list|)
operator|)
operator|*
name|count
argument_list|)
expr_stmt|;
name|old
operator|+=
name|count
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Now add the symbol files.  */
name|so
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|so
operator|=
name|find_solib
argument_list|(
name|so
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|so
operator|->
name|so_name
index|[
literal|0
index|]
operator|&&
name|re_exec
argument_list|(
name|so
operator|->
name|so_name
argument_list|)
condition|)
block|{
name|so
operator|->
name|from_tty
operator|=
name|from_tty
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|symbols_loaded
condition|)
block|{
if|if
condition|(
name|from_tty
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"Symbols already loaded for %s\n"
argument_list|,
name|so
operator|->
name|so_name
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|catch_errors
argument_list|(
name|symbol_add_stub
argument_list|,
operator|(
name|char
operator|*
operator|)
name|so
argument_list|,
literal|"Error while reading shared library symbols:\n"
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
condition|)
block|{
name|so_last
operator|=
name|so
expr_stmt|;
name|so
operator|->
name|symbols_loaded
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/* Getting new symbols may change our opinion about what is      frameless.  */
if|if
condition|(
name|so_last
condition|)
name|reinit_frame_cache
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	info_sharedlibrary_command -- code for "info sharedlibrary"  SYNOPSIS  	static void info_sharedlibrary_command ()  DESCRIPTION  	Walk through the shared library list and print information 	about each attached library. */
end_comment

begin_function
specifier|static
name|void
name|info_sharedlibrary_command
parameter_list|(
name|ignore
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|ignore
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
specifier|register
name|struct
name|so_list
modifier|*
name|so
init|=
name|NULL
decl_stmt|;
comment|/* link map state variable */
name|int
name|header_done
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|exec_bfd
operator|==
name|NULL
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"No exec file.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
operator|(
name|so
operator|=
name|find_solib
argument_list|(
name|so
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|so
operator|->
name|so_name
index|[
literal|0
index|]
condition|)
block|{
name|unsigned
name|long
name|txt_start
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|txt_end
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|header_done
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"%-20s%-20s%-12s%s\n"
argument_list|,
literal|"From"
argument_list|,
literal|"To"
argument_list|,
literal|"Syms Read"
argument_list|,
literal|"Shared Object Library"
argument_list|)
expr_stmt|;
name|header_done
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|so
operator|->
name|textsection
condition|)
block|{
name|txt_start
operator|=
operator|(
name|unsigned
name|long
operator|)
name|so
operator|->
name|textsection
operator|->
name|addr
expr_stmt|;
name|txt_end
operator|=
operator|(
name|unsigned
name|long
operator|)
name|so
operator|->
name|textsection
operator|->
name|endaddr
expr_stmt|;
block|}
name|printf_unfiltered
argument_list|(
literal|"%-20s"
argument_list|,
name|local_hex_string_custom
argument_list|(
name|txt_start
argument_list|,
literal|"08l"
argument_list|)
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"%-20s"
argument_list|,
name|local_hex_string_custom
argument_list|(
name|txt_end
argument_list|,
literal|"08l"
argument_list|)
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"%-12s"
argument_list|,
name|so
operator|->
name|symbols_loaded
condition|?
literal|"Yes"
else|:
literal|"No"
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"%s\n"
argument_list|,
name|so
operator|->
name|so_name
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|so_list_head
operator|==
name|NULL
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"No shared libraries loaded at this time.\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  GLOBAL FUNCTION  	solib_address -- check to see if an address is in a shared lib  SYNOPSIS  	char *solib_address (CORE_ADDR address)  DESCRIPTION  	Provides a hook for other gdb routines to discover whether or 	not a particular address is within the mapped address space of 	a shared library.  Any address between the base mapping address 	and the first address beyond the end of the last mapping, is 	considered to be within the shared library address space, for 	our purposes.  	For example, this routine is called at one point to disable 	breakpoints which are in shared libraries that are not currently 	mapped in.  */
end_comment

begin_function
name|char
modifier|*
name|solib_address
parameter_list|(
name|address
parameter_list|)
name|CORE_ADDR
name|address
decl_stmt|;
block|{
specifier|register
name|struct
name|so_list
modifier|*
name|so
init|=
literal|0
decl_stmt|;
comment|/* link map state variable */
while|while
condition|(
operator|(
name|so
operator|=
name|find_solib
argument_list|(
name|so
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|so
operator|->
name|so_name
index|[
literal|0
index|]
operator|&&
name|so
operator|->
name|textsection
condition|)
block|{
if|if
condition|(
operator|(
name|address
operator|>=
operator|(
name|CORE_ADDR
operator|)
name|so
operator|->
name|textsection
operator|->
name|addr
operator|)
operator|&&
operator|(
name|address
operator|<
operator|(
name|CORE_ADDR
operator|)
name|so
operator|->
name|textsection
operator|->
name|endaddr
operator|)
condition|)
return|return
operator|(
name|so
operator|->
name|so_name
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Called by free_all_symtabs */
end_comment

begin_function
name|void
name|clear_solib
parameter_list|()
block|{
name|struct
name|so_list
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|bfd_filename
decl_stmt|;
while|while
condition|(
name|so_list_head
condition|)
block|{
if|if
condition|(
name|so_list_head
operator|->
name|sections
condition|)
block|{
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|so_list_head
operator|->
name|sections
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|so_list_head
operator|->
name|abfd
condition|)
block|{
name|bfd_filename
operator|=
name|bfd_get_filename
argument_list|(
name|so_list_head
operator|->
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_close
argument_list|(
name|so_list_head
operator|->
name|abfd
argument_list|)
condition|)
name|warning
argument_list|(
literal|"cannot close \"%s\": %s"
argument_list|,
name|bfd_filename
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* This happens for the executable on SVR4.  */
name|bfd_filename
operator|=
name|NULL
expr_stmt|;
name|next
operator|=
name|so_list_head
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|bfd_filename
condition|)
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|bfd_filename
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|so_list_head
argument_list|)
expr_stmt|;
name|so_list_head
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*    GLOBAL FUNCTION    	solib_create_inferior_hook -- shared library startup support    SYNOPSIS    	void solib_create_inferior_hook()    DESCRIPTION  	When gdb starts up the inferior, it nurses it along (through the 	shell) until it is ready to execute it's first instruction.  At this 	point, this function gets called via expansion of the macro 	SOLIB_CREATE_INFERIOR_HOOK. 	For a statically bound executable, this first instruction is the 	one at "_start", or a similar text label. No further processing is 	needed in that case. 	For a dynamically bound executable, this first instruction is somewhere 	in the rld, and the actual user executable is not yet mapped in. 	We continue the inferior again, rld then maps in the actual user 	executable and any needed shared libraries and then sends 	itself a SIGTRAP. 	At that point we discover the names of all shared libraries and 	read their symbols in.  FIXME  	This code does not properly handle hitting breakpoints which the 	user might have set in the rld itself.  Proper handling would have 	to check if the SIGTRAP happened due to a kill call.  	Also, what if child has exit()ed?  Must exit loop somehow.   */
end_comment

begin_function
name|void
name|solib_create_inferior_hook
parameter_list|()
block|{
comment|/* Nothing to do for statically bound executables.  */
if|if
condition|(
name|symfile_objfile
operator|==
name|NULL
operator|||
name|symfile_objfile
operator|->
name|obfd
operator|==
name|NULL
operator|||
operator|(
operator|(
name|bfd_get_file_flags
argument_list|(
name|symfile_objfile
operator|->
name|obfd
argument_list|)
operator|&
name|DYNAMIC
operator|)
operator|==
literal|0
operator|)
condition|)
return|return;
comment|/* Now run the target.  It will eventually get a SIGTRAP, at      which point all of the libraries will have been mapped in and we      can go groveling around in the rld structures to find      out what we need to know about them. */
name|clear_proceed_status
argument_list|()
expr_stmt|;
name|stop_soon_quietly
operator|=
literal|1
expr_stmt|;
name|stop_signal
operator|=
name|TARGET_SIGNAL_0
expr_stmt|;
do|do
block|{
name|target_resume
argument_list|(
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|stop_signal
argument_list|)
expr_stmt|;
name|wait_for_inferior
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|stop_signal
operator|!=
name|TARGET_SIGNAL_TRAP
condition|)
do|;
comment|/*  solib_add will call reinit_frame_cache.       But we are stopped in the runtime loader and we do not have symbols       for the runtime loader. So heuristic_proc_start will be called       and will put out an annoying warning.       Delaying the resetting of stop_soon_quietly until after symbol loading       suppresses the warning.  */
if|if
condition|(
name|auto_solib_add
condition|)
name|solib_add
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|target_ops
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|stop_soon_quietly
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	sharedlibrary_command -- handle command to explicitly add library  SYNOPSIS  	static void sharedlibrary_command (char *args, int from_tty)  DESCRIPTION  */
end_comment

begin_function
specifier|static
name|void
name|sharedlibrary_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|dont_repeat
argument_list|()
expr_stmt|;
name|solib_add
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|,
operator|(
expr|struct
name|target_ops
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_initialize_solib
parameter_list|()
block|{
name|add_com
argument_list|(
literal|"sharedlibrary"
argument_list|,
name|class_files
argument_list|,
name|sharedlibrary_command
argument_list|,
literal|"Load shared object library symbols for files matching REGEXP."
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"sharedlibrary"
argument_list|,
name|info_sharedlibrary_command
argument_list|,
literal|"Status of loaded shared object libraries."
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"auto-solib-add"
argument_list|,
name|class_support
argument_list|,
name|var_zinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|auto_solib_add
argument_list|,
literal|"Set autoloading of shared library symbols.\n\ If nonzero, symbols from all shared object libraries will be loaded\n\ automatically when the inferior begins execution or when the dynamic linker\n\ informs gdb that a new library has been loaded.  Otherwise, symbols\n\ must be loaded manually, using `sharedlibrary'."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

