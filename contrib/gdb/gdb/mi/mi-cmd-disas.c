begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* MI Command Set - disassemble commands.    Copyright 2000, 2001, 2002 Free Software Foundation, Inc.    Contributed by Cygnus Solutions (a Red Hat company).     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"mi-cmds.h"
end_include

begin_include
include|#
directive|include
file|"mi-getopt.h"
end_include

begin_include
include|#
directive|include
file|"ui-out.h"
end_include

begin_function_decl
specifier|static
name|int
name|gdb_dis_asm_read_memory
parameter_list|(
name|bfd_vma
name|memaddr
parameter_list|,
name|bfd_byte
modifier|*
name|myaddr
parameter_list|,
name|unsigned
name|int
name|len
parameter_list|,
name|disassemble_info
modifier|*
name|info
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|compare_lines
parameter_list|(
specifier|const
name|PTR
name|mle1p
parameter_list|,
specifier|const
name|PTR
name|mle2p
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Disassemble functions. FIXME: these do not really belong here. We    should get rid of all the duplicate code in gdb that does the same    thing: disassemble_command() and the gdbtk variation. */
end_comment

begin_comment
comment|/* This Structure is used in mi_cmd_disassemble.    We need a different sort of line table from the normal one cuz we can't    depend upon implicit line-end pc's for lines to do the    reordering in this function.  */
end_comment

begin_struct
struct|struct
name|dis_line_entry
block|{
name|int
name|line
decl_stmt|;
name|CORE_ADDR
name|start_pc
decl_stmt|;
name|CORE_ADDR
name|end_pc
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This variable determines where memory used for disassembly is read from. */
end_comment

begin_decl_stmt
name|int
name|gdb_disassemble_from_exec
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is the memory_read_func for gdb_disassemble when we are    disassembling from the exec file. */
end_comment

begin_function
specifier|static
name|int
name|gdb_dis_asm_read_memory
parameter_list|(
name|bfd_vma
name|memaddr
parameter_list|,
name|bfd_byte
modifier|*
name|myaddr
parameter_list|,
name|unsigned
name|int
name|len
parameter_list|,
name|disassemble_info
modifier|*
name|info
parameter_list|)
block|{
specifier|extern
name|struct
name|target_ops
name|exec_ops
decl_stmt|;
name|int
name|res
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|res
operator|=
name|xfer_memory
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|exec_ops
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|len
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|errno
operator|==
literal|0
condition|)
return|return
name|EIO
return|;
else|else
return|return
name|errno
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|compare_lines
parameter_list|(
specifier|const
name|PTR
name|mle1p
parameter_list|,
specifier|const
name|PTR
name|mle2p
parameter_list|)
block|{
name|struct
name|dis_line_entry
modifier|*
name|mle1
decl_stmt|,
modifier|*
name|mle2
decl_stmt|;
name|int
name|val
decl_stmt|;
name|mle1
operator|=
operator|(
expr|struct
name|dis_line_entry
operator|*
operator|)
name|mle1p
expr_stmt|;
name|mle2
operator|=
operator|(
expr|struct
name|dis_line_entry
operator|*
operator|)
name|mle2p
expr_stmt|;
name|val
operator|=
name|mle1
operator|->
name|line
operator|-
name|mle2
operator|->
name|line
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
return|return
name|val
return|;
return|return
name|mle1
operator|->
name|start_pc
operator|-
name|mle2
operator|->
name|start_pc
return|;
block|}
end_function

begin_comment
comment|/* The arguments to be passed on the command line and parsed here are:     either:     START-ADDRESS: address to start the disassembly at.    END-ADDRESS: address to end the disassembly at.     or:     FILENAME: The name of the file where we want disassemble from.    LINE: The line around which we want to disassemble. It will    disassemble the function that contins that line.    HOW_MANY: Number of disassembly lines to display. In mixed mode, it    is the number of disassembly lines only, not counting the source    lines.       always required:     MODE: 0 or 1 for disassembly only, or mixed source and disassembly,    respectively. */
end_comment

begin_function
name|enum
name|mi_cmd_result
name|mi_cmd_disassemble
parameter_list|(
name|char
modifier|*
name|command
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|int
name|argc
parameter_list|)
block|{
name|CORE_ADDR
name|pc
decl_stmt|;
name|CORE_ADDR
name|start
decl_stmt|;
name|int
name|mixed_source_and_assembly
decl_stmt|;
name|int
name|num_displayed
decl_stmt|;
specifier|static
name|disassemble_info
name|di
decl_stmt|;
specifier|static
name|int
name|di_initialized
decl_stmt|;
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
comment|/* To collect the instruction outputted from opcodes. */
specifier|static
name|struct
name|ui_stream
modifier|*
name|stb
init|=
name|NULL
decl_stmt|;
comment|/* parts of the symbolic representation of the address */
name|int
name|line
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|int
name|unmapped
decl_stmt|;
name|char
modifier|*
name|filename
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
comment|/* Which options have we processed ... */
name|int
name|file_seen
init|=
literal|0
decl_stmt|;
name|int
name|line_seen
init|=
literal|0
decl_stmt|;
name|int
name|num_seen
init|=
literal|0
decl_stmt|;
name|int
name|start_seen
init|=
literal|0
decl_stmt|;
name|int
name|end_seen
init|=
literal|0
decl_stmt|;
comment|/* ... and their corresponding value. */
name|char
modifier|*
name|file_string
init|=
name|NULL
decl_stmt|;
name|int
name|line_num
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|how_many
init|=
operator|-
literal|1
decl_stmt|;
name|CORE_ADDR
name|low
init|=
literal|0
decl_stmt|;
name|CORE_ADDR
name|high
init|=
literal|0
decl_stmt|;
comment|/* Options processing stuff. */
name|int
name|optind
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|optarg
decl_stmt|;
enum|enum
name|opt
block|{
name|FILE_OPT
block|,
name|LINE_OPT
block|,
name|NUM_OPT
block|,
name|START_OPT
block|,
name|END_OPT
block|}
enum|;
specifier|static
name|struct
name|mi_opt
name|opts
index|[]
init|=
block|{
block|{
literal|"f"
block|,
name|FILE_OPT
block|,
literal|1
block|}
block|,
block|{
literal|"l"
block|,
name|LINE_OPT
block|,
literal|1
block|}
block|,
block|{
literal|"n"
block|,
name|NUM_OPT
block|,
literal|1
block|}
block|,
block|{
literal|"s"
block|,
name|START_OPT
block|,
literal|1
block|}
block|,
block|{
literal|"e"
block|,
name|END_OPT
block|,
literal|1
block|}
block|,
literal|0
block|}
decl_stmt|;
comment|/* Get the options with their arguments. Keep track of what we      encountered. */
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|opt
init|=
name|mi_getopt
argument_list|(
literal|"mi_cmd_disassemble"
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|opts
argument_list|,
operator|&
name|optind
argument_list|,
operator|&
name|optarg
argument_list|)
decl_stmt|;
if|if
condition|(
name|opt
operator|<
literal|0
condition|)
break|break;
switch|switch
condition|(
operator|(
expr|enum
name|opt
operator|)
name|opt
condition|)
block|{
case|case
name|FILE_OPT
case|:
name|file_string
operator|=
name|xstrdup
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
name|file_seen
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|LINE_OPT
case|:
name|line_num
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
name|line_seen
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|NUM_OPT
case|:
name|how_many
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
name|num_seen
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|START_OPT
case|:
name|low
operator|=
name|parse_and_eval_address
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
name|start_seen
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|END_OPT
case|:
name|high
operator|=
name|parse_and_eval_address
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
name|end_seen
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|argv
operator|+=
name|optind
expr_stmt|;
name|argc
operator|-=
name|optind
expr_stmt|;
comment|/* Allow only filename + linenum (with how_many which is not      required) OR start_addr + and_addr */
if|if
condition|(
operator|!
operator|(
operator|(
name|line_seen
operator|&&
name|file_seen
operator|&&
name|num_seen
operator|&&
operator|!
name|start_seen
operator|&&
operator|!
name|end_seen
operator|)
operator|||
operator|(
name|line_seen
operator|&&
name|file_seen
operator|&&
operator|!
name|num_seen
operator|&&
operator|!
name|start_seen
operator|&&
operator|!
name|end_seen
operator|)
operator|||
operator|(
operator|!
name|line_seen
operator|&&
operator|!
name|file_seen
operator|&&
operator|!
name|num_seen
operator|&&
name|start_seen
operator|&&
name|end_seen
operator|)
operator|)
condition|)
name|error
argument_list|(
literal|"mi_cmd_disassemble: Usage: ( [-f filename -l linenum [-n howmany]] | [-s startaddr -e endaddr]) [--] mixed_mode."
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|1
condition|)
name|error
argument_list|(
literal|"mi_cmd_disassemble: Usage: [-f filename -l linenum [-n howmany]] [-s startaddr -e endaddr] [--] mixed_mode."
argument_list|)
expr_stmt|;
name|mixed_source_and_assembly
operator|=
name|atoi
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mixed_source_and_assembly
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|mixed_source_and_assembly
operator|!=
literal|1
operator|)
condition|)
name|error
argument_list|(
literal|"mi_cmd_disassemble: Mixed_mode argument must be 0 or 1."
argument_list|)
expr_stmt|;
comment|/* We must get the function beginning and end where line_num is      contained. */
if|if
condition|(
name|line_seen
operator|&&
name|file_seen
condition|)
block|{
name|s
operator|=
name|lookup_symtab
argument_list|(
name|file_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"mi_cmd_disassemble: Invalid filename."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|find_line_pc
argument_list|(
name|s
argument_list|,
name|line_num
argument_list|,
operator|&
name|start
argument_list|)
condition|)
name|error
argument_list|(
literal|"mi_cmd_disassemble: Invalid line number"
argument_list|)
expr_stmt|;
if|if
condition|(
name|find_pc_partial_function
argument_list|(
name|start
argument_list|,
name|NULL
argument_list|,
operator|&
name|low
argument_list|,
operator|&
name|high
argument_list|)
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"mi_cmd_disassemble: No function contains specified address"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|di_initialized
condition|)
block|{
comment|/* We don't add a cleanup for this, because the allocation of          the stream is done once only for each gdb run, and we need to          keep it around until the end. Hopefully there won't be any          errors in the init code below, that make this function bail          out. */
name|stb
operator|=
name|ui_out_stream_new
argument_list|(
name|uiout
argument_list|)
expr_stmt|;
name|INIT_DISASSEMBLE_INFO_NO_ARCH
argument_list|(
name|di
argument_list|,
name|stb
operator|->
name|stream
argument_list|,
operator|(
name|fprintf_ftype
operator|)
name|fprintf_unfiltered
argument_list|)
expr_stmt|;
name|di
operator|.
name|flavour
operator|=
name|bfd_target_unknown_flavour
expr_stmt|;
name|di
operator|.
name|memory_error_func
operator|=
name|dis_asm_memory_error
expr_stmt|;
name|di
operator|.
name|print_address_func
operator|=
name|dis_asm_print_address
expr_stmt|;
name|di_initialized
operator|=
literal|1
expr_stmt|;
block|}
name|di
operator|.
name|mach
operator|=
name|TARGET_PRINT_INSN_INFO
operator|->
name|mach
expr_stmt|;
if|if
condition|(
name|TARGET_BYTE_ORDER
operator|==
name|BFD_ENDIAN_BIG
condition|)
name|di
operator|.
name|endian
operator|=
name|BFD_ENDIAN_BIG
expr_stmt|;
else|else
name|di
operator|.
name|endian
operator|=
name|BFD_ENDIAN_LITTLE
expr_stmt|;
comment|/* If gdb_disassemble_from_exec == -1, then we use the following heuristic to      determine whether or not to do disassembly from target memory or from the      exec file:       If we're debugging a local process, read target memory, instead of the      exec file.  This makes disassembly of functions in shared libs work      correctly.  Also, read target memory if we are debugging native threads.       Else, we're debugging a remote process, and should disassemble from the      exec file for speed.  However, this is no good if the target modifies its      code (for relocation, or whatever).    */
if|if
condition|(
name|gdb_disassemble_from_exec
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|target_shortname
argument_list|,
literal|"child"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|target_shortname
argument_list|,
literal|"procfs"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|target_shortname
argument_list|,
literal|"vxprocess"
argument_list|)
operator|==
literal|0
operator|||
name|strstr
argument_list|(
name|target_shortname
argument_list|,
literal|"-threads"
argument_list|)
operator|!=
name|NULL
condition|)
name|gdb_disassemble_from_exec
operator|=
literal|0
expr_stmt|;
comment|/* It's a child process, read inferior mem */
else|else
name|gdb_disassemble_from_exec
operator|=
literal|1
expr_stmt|;
comment|/* It's remote, read the exec file */
block|}
if|if
condition|(
name|gdb_disassemble_from_exec
condition|)
name|di
operator|.
name|read_memory_func
operator|=
name|gdb_dis_asm_read_memory
expr_stmt|;
else|else
name|di
operator|.
name|read_memory_func
operator|=
name|dis_asm_read_memory
expr_stmt|;
comment|/* If just doing straight assembly, all we need to do is disassemble      everything between low and high.  If doing mixed source/assembly,      we've got a totally different path to follow.  */
if|if
condition|(
name|mixed_source_and_assembly
condition|)
block|{
comment|/* Come here for mixed source/assembly */
comment|/* The idea here is to present a source-O-centric view of a          function to the user.  This means that things are presented          in source order, with (possibly) out of order assembly          immediately following.  */
name|struct
name|symtab
modifier|*
name|symtab
decl_stmt|;
name|struct
name|linetable_entry
modifier|*
name|le
decl_stmt|;
name|int
name|nlines
decl_stmt|;
name|int
name|newlines
decl_stmt|;
name|struct
name|dis_line_entry
modifier|*
name|mle
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|out_of_order
decl_stmt|;
name|int
name|next_line
decl_stmt|;
comment|/* Assume symtab is valid for whole PC range */
name|symtab
operator|=
name|find_pc_symtab
argument_list|(
name|low
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|symtab
operator|||
operator|!
name|symtab
operator|->
name|linetable
condition|)
goto|goto
name|assembly_only
goto|;
comment|/* First, convert the linetable to a bunch of my_line_entry's.  */
name|le
operator|=
name|symtab
operator|->
name|linetable
operator|->
name|item
expr_stmt|;
name|nlines
operator|=
name|symtab
operator|->
name|linetable
operator|->
name|nitems
expr_stmt|;
if|if
condition|(
name|nlines
operator|<=
literal|0
condition|)
goto|goto
name|assembly_only
goto|;
name|mle
operator|=
operator|(
expr|struct
name|dis_line_entry
operator|*
operator|)
name|alloca
argument_list|(
name|nlines
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|dis_line_entry
argument_list|)
argument_list|)
expr_stmt|;
name|out_of_order
operator|=
literal|0
expr_stmt|;
comment|/* Copy linetable entries for this function into our data          structure, creating end_pc's and setting out_of_order as          appropriate.  */
comment|/* First, skip all the preceding functions.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nlines
operator|-
literal|1
operator|&&
name|le
index|[
name|i
index|]
operator|.
name|pc
operator|<
name|low
condition|;
name|i
operator|++
control|)
empty_stmt|;
comment|/* Now, copy all entries before the end of this function.  */
name|newlines
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|nlines
operator|-
literal|1
operator|&&
name|le
index|[
name|i
index|]
operator|.
name|pc
operator|<
name|high
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|le
index|[
name|i
index|]
operator|.
name|line
operator|==
name|le
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|line
operator|&&
name|le
index|[
name|i
index|]
operator|.
name|pc
operator|==
name|le
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|pc
condition|)
continue|continue;
comment|/* Ignore duplicates */
comment|/* Skip any end-of-function markers.  */
if|if
condition|(
name|le
index|[
name|i
index|]
operator|.
name|line
operator|==
literal|0
condition|)
continue|continue;
name|mle
index|[
name|newlines
index|]
operator|.
name|line
operator|=
name|le
index|[
name|i
index|]
operator|.
name|line
expr_stmt|;
if|if
condition|(
name|le
index|[
name|i
index|]
operator|.
name|line
operator|>
name|le
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|line
condition|)
name|out_of_order
operator|=
literal|1
expr_stmt|;
name|mle
index|[
name|newlines
index|]
operator|.
name|start_pc
operator|=
name|le
index|[
name|i
index|]
operator|.
name|pc
expr_stmt|;
name|mle
index|[
name|newlines
index|]
operator|.
name|end_pc
operator|=
name|le
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|pc
expr_stmt|;
name|newlines
operator|++
expr_stmt|;
block|}
comment|/* If we're on the last line, and it's part of the function,          then we need to get the end pc in a special way.  */
if|if
condition|(
name|i
operator|==
name|nlines
operator|-
literal|1
operator|&&
name|le
index|[
name|i
index|]
operator|.
name|pc
operator|<
name|high
condition|)
block|{
name|mle
index|[
name|newlines
index|]
operator|.
name|line
operator|=
name|le
index|[
name|i
index|]
operator|.
name|line
expr_stmt|;
name|mle
index|[
name|newlines
index|]
operator|.
name|start_pc
operator|=
name|le
index|[
name|i
index|]
operator|.
name|pc
expr_stmt|;
name|sal
operator|=
name|find_pc_line
argument_list|(
name|le
index|[
name|i
index|]
operator|.
name|pc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mle
index|[
name|newlines
index|]
operator|.
name|end_pc
operator|=
name|sal
operator|.
name|end
expr_stmt|;
name|newlines
operator|++
expr_stmt|;
block|}
comment|/* Now, sort mle by line #s (and, then by addresses within          lines). */
if|if
condition|(
name|out_of_order
condition|)
name|qsort
argument_list|(
name|mle
argument_list|,
name|newlines
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dis_line_entry
argument_list|)
argument_list|,
name|compare_lines
argument_list|)
expr_stmt|;
comment|/* Now, for each line entry, emit the specified lines (unless          they have been emitted before), followed by the assembly code          for that line.  */
name|next_line
operator|=
literal|0
expr_stmt|;
comment|/* Force out first line */
name|ui_out_list_begin
argument_list|(
name|uiout
argument_list|,
literal|"asm_insns"
argument_list|)
expr_stmt|;
name|num_displayed
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|newlines
condition|;
name|i
operator|++
control|)
block|{
name|int
name|close_list
init|=
literal|1
decl_stmt|;
comment|/* Print out everything from next_line to the current line.  */
if|if
condition|(
name|mle
index|[
name|i
index|]
operator|.
name|line
operator|>=
name|next_line
condition|)
block|{
if|if
condition|(
name|next_line
operator|!=
literal|0
condition|)
block|{
comment|/* Just one line to print. */
if|if
condition|(
name|next_line
operator|==
name|mle
index|[
name|i
index|]
operator|.
name|line
condition|)
block|{
name|ui_out_tuple_begin
argument_list|(
name|uiout
argument_list|,
literal|"src_and_asm_line"
argument_list|)
expr_stmt|;
name|print_source_lines
argument_list|(
name|symtab
argument_list|,
name|next_line
argument_list|,
name|mle
index|[
name|i
index|]
operator|.
name|line
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Several source lines w/o asm instructions associated. */
for|for
control|(
init|;
name|next_line
operator|<
name|mle
index|[
name|i
index|]
operator|.
name|line
condition|;
name|next_line
operator|++
control|)
block|{
name|ui_out_tuple_begin
argument_list|(
name|uiout
argument_list|,
literal|"src_and_asm_line"
argument_list|)
expr_stmt|;
name|print_source_lines
argument_list|(
name|symtab
argument_list|,
name|next_line
argument_list|,
name|mle
index|[
name|i
index|]
operator|.
name|line
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ui_out_list_begin
argument_list|(
name|uiout
argument_list|,
literal|"line_asm_insn"
argument_list|)
expr_stmt|;
name|ui_out_list_end
argument_list|(
name|uiout
argument_list|)
expr_stmt|;
name|ui_out_tuple_end
argument_list|(
name|uiout
argument_list|)
expr_stmt|;
block|}
comment|/* Print the last line and leave list open for 		         asm instructions to be added. */
name|ui_out_tuple_begin
argument_list|(
name|uiout
argument_list|,
literal|"src_and_asm_line"
argument_list|)
expr_stmt|;
name|print_source_lines
argument_list|(
name|symtab
argument_list|,
name|next_line
argument_list|,
name|mle
index|[
name|i
index|]
operator|.
name|line
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ui_out_tuple_begin
argument_list|(
name|uiout
argument_list|,
literal|"src_and_asm_line"
argument_list|)
expr_stmt|;
name|print_source_lines
argument_list|(
name|symtab
argument_list|,
name|mle
index|[
name|i
index|]
operator|.
name|line
argument_list|,
name|mle
index|[
name|i
index|]
operator|.
name|line
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|next_line
operator|=
name|mle
index|[
name|i
index|]
operator|.
name|line
operator|+
literal|1
expr_stmt|;
name|ui_out_list_begin
argument_list|(
name|uiout
argument_list|,
literal|"line_asm_insn"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|+
literal|1
operator|<
name|newlines
operator|&&
name|mle
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|line
operator|<=
name|mle
index|[
name|i
index|]
operator|.
name|line
condition|)
name|close_list
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|pc
operator|=
name|mle
index|[
name|i
index|]
operator|.
name|start_pc
init|;
name|pc
operator|<
name|mle
index|[
name|i
index|]
operator|.
name|end_pc
condition|;
control|)
block|{
name|QUIT
expr_stmt|;
if|if
condition|(
name|how_many
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|num_displayed
operator|>=
name|how_many
condition|)
break|break;
else|else
name|num_displayed
operator|++
expr_stmt|;
block|}
name|ui_out_tuple_begin
argument_list|(
name|uiout
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ui_out_field_core_addr
argument_list|(
name|uiout
argument_list|,
literal|"address"
argument_list|,
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|build_address_symbolic
argument_list|(
name|pc
argument_list|,
literal|0
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|offset
argument_list|,
operator|&
name|filename
argument_list|,
operator|&
name|line
argument_list|,
operator|&
name|unmapped
argument_list|)
condition|)
block|{
comment|/* We don't care now about line, filename and 		     unmapped, but we might in the future. */
name|ui_out_field_string
argument_list|(
name|uiout
argument_list|,
literal|"func-name"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|ui_out_field_int
argument_list|(
name|uiout
argument_list|,
literal|"offset"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|filename
operator|!=
name|NULL
condition|)
name|xfree
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
name|xfree
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|ui_file_rewind
argument_list|(
name|stb
operator|->
name|stream
argument_list|)
expr_stmt|;
name|pc
operator|+=
call|(
modifier|*
name|tm_print_insn
call|)
argument_list|(
name|pc
argument_list|,
operator|&
name|di
argument_list|)
expr_stmt|;
name|ui_out_field_stream
argument_list|(
name|uiout
argument_list|,
literal|"inst"
argument_list|,
name|stb
argument_list|)
expr_stmt|;
name|ui_file_rewind
argument_list|(
name|stb
operator|->
name|stream
argument_list|)
expr_stmt|;
name|ui_out_tuple_end
argument_list|(
name|uiout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|close_list
condition|)
block|{
name|ui_out_list_end
argument_list|(
name|uiout
argument_list|)
expr_stmt|;
name|ui_out_tuple_end
argument_list|(
name|uiout
argument_list|)
expr_stmt|;
name|close_list
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|how_many
operator|>=
literal|0
condition|)
if|if
condition|(
name|num_displayed
operator|>=
name|how_many
condition|)
break|break;
block|}
name|ui_out_list_end
argument_list|(
name|uiout
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assembly_only
label|:
name|ui_out_list_begin
argument_list|(
name|uiout
argument_list|,
literal|"asm_insns"
argument_list|)
expr_stmt|;
name|num_displayed
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|pc
operator|=
name|low
init|;
name|pc
operator|<
name|high
condition|;
control|)
block|{
name|QUIT
expr_stmt|;
if|if
condition|(
name|how_many
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|num_displayed
operator|>=
name|how_many
condition|)
break|break;
else|else
name|num_displayed
operator|++
expr_stmt|;
block|}
name|ui_out_tuple_begin
argument_list|(
name|uiout
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ui_out_field_core_addr
argument_list|(
name|uiout
argument_list|,
literal|"address"
argument_list|,
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|build_address_symbolic
argument_list|(
name|pc
argument_list|,
literal|0
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|offset
argument_list|,
operator|&
name|filename
argument_list|,
operator|&
name|line
argument_list|,
operator|&
name|unmapped
argument_list|)
condition|)
block|{
comment|/* We don't care now about line, filename and 	         unmapped. But we might in the future. */
name|ui_out_field_string
argument_list|(
name|uiout
argument_list|,
literal|"func-name"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|ui_out_field_int
argument_list|(
name|uiout
argument_list|,
literal|"offset"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|filename
operator|!=
name|NULL
condition|)
name|xfree
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
name|xfree
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|ui_file_rewind
argument_list|(
name|stb
operator|->
name|stream
argument_list|)
expr_stmt|;
name|pc
operator|+=
call|(
modifier|*
name|tm_print_insn
call|)
argument_list|(
name|pc
argument_list|,
operator|&
name|di
argument_list|)
expr_stmt|;
name|ui_out_field_stream
argument_list|(
name|uiout
argument_list|,
literal|"inst"
argument_list|,
name|stb
argument_list|)
expr_stmt|;
name|ui_file_rewind
argument_list|(
name|stb
operator|->
name|stream
argument_list|)
expr_stmt|;
name|ui_out_tuple_end
argument_list|(
name|uiout
argument_list|)
expr_stmt|;
block|}
name|ui_out_list_end
argument_list|(
name|uiout
argument_list|)
expr_stmt|;
block|}
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
return|return
name|MI_CMD_DONE
return|;
block|}
end_function

end_unit

