begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* MI Command Set - breakpoint and watchpoint commands.    Copyright 2000, 2001, 2002 Free Software Foundation, Inc.    Contributed by Cygnus Solutions (a Red Hat company).     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"mi-cmds.h"
end_include

begin_include
include|#
directive|include
file|"ui-out.h"
end_include

begin_include
include|#
directive|include
file|"mi-out.h"
end_include

begin_include
include|#
directive|include
file|"breakpoint.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"mi-getopt.h"
end_include

begin_include
include|#
directive|include
file|"gdb-events.h"
end_include

begin_include
include|#
directive|include
file|"gdb.h"
end_include

begin_comment
comment|/* Convenience macro for allocting typesafe memory. */
end_comment

begin_undef
undef|#
directive|undef
name|XMALLOC
end_undef

begin_define
define|#
directive|define
name|XMALLOC
parameter_list|(
name|TYPE
parameter_list|)
value|(TYPE*) xmalloc (sizeof (TYPE))
end_define

begin_enum
enum|enum
block|{
name|FROM_TTY
init|=
literal|0
block|}
enum|;
end_enum

begin_comment
comment|/* Output a single breakpoint. */
end_comment

begin_function
specifier|static
name|void
name|breakpoint_notify
parameter_list|(
name|int
name|b
parameter_list|)
block|{
name|gdb_breakpoint_query
argument_list|(
name|uiout
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|struct
name|gdb_events
name|breakpoint_hooks
init|=
block|{
name|breakpoint_notify
block|,
name|breakpoint_notify
block|,
name|breakpoint_notify
block|, }
decl_stmt|;
end_decl_stmt

begin_enum
enum|enum
name|bp_type
block|{
name|REG_BP
block|,
name|HW_BP
block|,
name|REGEXP_BP
block|}
enum|;
end_enum

begin_comment
comment|/* Insert a breakpoint. The type of breakpoint is specified by the    first argument: -break-insert<location> --> insert a regular    breakpoint.  -break-insert -t<location> --> insert a temporary    breakpoint.  -break-insert -h<location> --> insert an hardware    breakpoint.  -break-insert -t -h<location> --> insert a temporary    hw bp.      -break-insert -r<regexp> --> insert a bp at functions matching<regexp> */
end_comment

begin_function
name|enum
name|mi_cmd_result
name|mi_cmd_break_insert
parameter_list|(
name|char
modifier|*
name|command
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|int
name|argc
parameter_list|)
block|{
name|char
modifier|*
name|address
init|=
name|NULL
decl_stmt|;
name|enum
name|bp_type
name|type
init|=
name|REG_BP
decl_stmt|;
name|int
name|temp_p
init|=
literal|0
decl_stmt|;
name|int
name|thread
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|ignore_count
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|condition
init|=
name|NULL
decl_stmt|;
name|enum
name|gdb_rc
name|rc
decl_stmt|;
name|struct
name|gdb_events
modifier|*
name|old_hooks
decl_stmt|;
enum|enum
name|opt
block|{
name|HARDWARE_OPT
block|,
name|TEMP_OPT
comment|/*, REGEXP_OPT */
block|,
name|CONDITION_OPT
block|,
name|IGNORE_COUNT_OPT
block|,
name|THREAD_OPT
block|}
enum|;
specifier|static
name|struct
name|mi_opt
name|opts
index|[]
init|=
block|{
block|{
literal|"h"
block|,
name|HARDWARE_OPT
block|,
literal|0
block|}
block|,
block|{
literal|"t"
block|,
name|TEMP_OPT
block|,
literal|0
block|}
block|,
block|{
literal|"c"
block|,
name|CONDITION_OPT
block|,
literal|1
block|}
block|,
block|{
literal|"i"
block|,
name|IGNORE_COUNT_OPT
block|,
literal|1
block|}
block|,
block|{
literal|"p"
block|,
name|THREAD_OPT
block|,
literal|1
block|}
block|,
literal|0
block|}
decl_stmt|;
comment|/* Parse arguments. It could be -r or -h or -t,<location> or ``--''      to denote the end of the option list. */
name|int
name|optind
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|optarg
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|opt
init|=
name|mi_getopt
argument_list|(
literal|"mi_cmd_break_insert"
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|opts
argument_list|,
operator|&
name|optind
argument_list|,
operator|&
name|optarg
argument_list|)
decl_stmt|;
if|if
condition|(
name|opt
operator|<
literal|0
condition|)
break|break;
switch|switch
condition|(
operator|(
expr|enum
name|opt
operator|)
name|opt
condition|)
block|{
case|case
name|TEMP_OPT
case|:
name|temp_p
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|HARDWARE_OPT
case|:
name|type
operator|=
name|HW_BP
expr_stmt|;
break|break;
if|#
directive|if
literal|0
block|case REGEXP_OPT: 	  type = REGEXP_BP; 	  break;
endif|#
directive|endif
case|case
name|CONDITION_OPT
case|:
name|condition
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
name|IGNORE_COUNT_OPT
case|:
name|ignore_count
operator|=
name|atol
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
name|THREAD_OPT
case|:
name|thread
operator|=
name|atol
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|optind
operator|>=
name|argc
condition|)
name|error
argument_list|(
literal|"mi_cmd_break_insert: Missing<location>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|optind
operator|<
name|argc
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"mi_cmd_break_insert: Garbage following<location>"
argument_list|)
expr_stmt|;
name|address
operator|=
name|argv
index|[
name|optind
index|]
expr_stmt|;
comment|/* Now we have what we need, let's insert the breakpoint! */
name|old_hooks
operator|=
name|set_gdb_event_hooks
argument_list|(
operator|&
name|breakpoint_hooks
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|REG_BP
case|:
name|rc
operator|=
name|gdb_breakpoint
argument_list|(
name|address
argument_list|,
name|condition
argument_list|,
literal|0
comment|/*hardwareflag */
argument_list|,
name|temp_p
argument_list|,
name|thread
argument_list|,
name|ignore_count
argument_list|)
expr_stmt|;
break|break;
case|case
name|HW_BP
case|:
name|rc
operator|=
name|gdb_breakpoint
argument_list|(
name|address
argument_list|,
name|condition
argument_list|,
literal|1
comment|/*hardwareflag */
argument_list|,
name|temp_p
argument_list|,
name|thread
argument_list|,
name|ignore_count
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
literal|0
block|case REGEXP_BP:       if (temp_p) 	error ("mi_cmd_break_insert: Unsupported tempoary regexp breakpoint");       else 	rbreak_command_wrapper (address, FROM_TTY);       return MI_CMD_DONE;       break;
endif|#
directive|endif
default|default:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"mi_cmd_break_insert: Bad switch."
argument_list|)
expr_stmt|;
block|}
name|set_gdb_event_hooks
argument_list|(
name|old_hooks
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
name|GDB_RC_FAIL
condition|)
return|return
name|MI_CMD_CAUGHT_ERROR
return|;
else|else
return|return
name|MI_CMD_DONE
return|;
block|}
end_function

begin_enum
enum|enum
name|wp_type
block|{
name|REG_WP
block|,
name|READ_WP
block|,
name|ACCESS_WP
block|}
enum|;
end_enum

begin_comment
comment|/* Insert a watchpoint. The type of watchpoint is specified by the    first argument:     -break-watch<expr> --> insert a regular wp.      -break-watch -r<expr> --> insert a read watchpoint.    -break-watch -a<expr> --> insert an access wp. */
end_comment

begin_function
name|enum
name|mi_cmd_result
name|mi_cmd_break_watch
parameter_list|(
name|char
modifier|*
name|command
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|int
name|argc
parameter_list|)
block|{
name|char
modifier|*
name|expr
init|=
name|NULL
decl_stmt|;
name|enum
name|wp_type
name|type
init|=
name|REG_WP
decl_stmt|;
enum|enum
name|opt
block|{
name|READ_OPT
block|,
name|ACCESS_OPT
block|}
enum|;
specifier|static
name|struct
name|mi_opt
name|opts
index|[]
init|=
block|{
block|{
literal|"r"
block|,
name|READ_OPT
block|,
literal|0
block|}
block|,
block|{
literal|"a"
block|,
name|ACCESS_OPT
block|,
literal|0
block|}
block|,
literal|0
block|}
decl_stmt|;
comment|/* Parse arguments. */
name|int
name|optind
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|optarg
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|opt
init|=
name|mi_getopt
argument_list|(
literal|"mi_cmd_break_watch"
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|opts
argument_list|,
operator|&
name|optind
argument_list|,
operator|&
name|optarg
argument_list|)
decl_stmt|;
if|if
condition|(
name|opt
operator|<
literal|0
condition|)
break|break;
switch|switch
condition|(
operator|(
expr|enum
name|opt
operator|)
name|opt
condition|)
block|{
case|case
name|READ_OPT
case|:
name|type
operator|=
name|READ_WP
expr_stmt|;
break|break;
case|case
name|ACCESS_OPT
case|:
name|type
operator|=
name|ACCESS_WP
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|optind
operator|>=
name|argc
condition|)
name|error
argument_list|(
literal|"mi_cmd_break_watch: Missing<expression>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|optind
operator|<
name|argc
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"mi_cmd_break_watch: Garbage following<expression>"
argument_list|)
expr_stmt|;
name|expr
operator|=
name|argv
index|[
name|optind
index|]
expr_stmt|;
comment|/* Now we have what we need, let's insert the watchpoint! */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|REG_WP
case|:
name|watch_command_wrapper
argument_list|(
name|expr
argument_list|,
name|FROM_TTY
argument_list|)
expr_stmt|;
break|break;
case|case
name|READ_WP
case|:
name|rwatch_command_wrapper
argument_list|(
name|expr
argument_list|,
name|FROM_TTY
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACCESS_WP
case|:
name|awatch_command_wrapper
argument_list|(
name|expr
argument_list|,
name|FROM_TTY
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"mi_cmd_break_watch: Unknown watchpoint type."
argument_list|)
expr_stmt|;
block|}
return|return
name|MI_CMD_DONE
return|;
block|}
end_function

end_unit

