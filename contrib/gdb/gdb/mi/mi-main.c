begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* MI Command Set.     Copyright 2000, 2001, 2002, 2003, 2004 Free Software Foundation,    Inc.     Contributed by Cygnus Solutions (a Red Hat company).     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* Work in progress */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"top.h"
end_include

begin_include
include|#
directive|include
file|"gdbthread.h"
end_include

begin_include
include|#
directive|include
file|"mi-cmds.h"
end_include

begin_include
include|#
directive|include
file|"mi-parse.h"
end_include

begin_include
include|#
directive|include
file|"mi-getopt.h"
end_include

begin_include
include|#
directive|include
file|"mi-console.h"
end_include

begin_include
include|#
directive|include
file|"ui-out.h"
end_include

begin_include
include|#
directive|include
file|"mi-out.h"
end_include

begin_include
include|#
directive|include
file|"interps.h"
end_include

begin_include
include|#
directive|include
file|"event-loop.h"
end_include

begin_include
include|#
directive|include
file|"event-top.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_comment
comment|/* for write_memory() */
end_comment

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_comment
comment|/* for deprecated_write_register_bytes() */
end_comment

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_include
include|#
directive|include
file|"gdb.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"mi-main.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_enum
enum|enum
block|{
name|FROM_TTY
init|=
literal|0
block|}
enum|;
end_enum

begin_comment
comment|/* Enumerations of the actions that may result from calling    captured_mi_execute_command */
end_comment

begin_enum
enum|enum
name|captured_mi_execute_command_actions
block|{
name|EXECUTE_COMMAND_DISPLAY_PROMPT
block|,
name|EXECUTE_COMMAND_SUPRESS_PROMPT
block|,
name|EXECUTE_COMMAND_DISPLAY_ERROR
block|}
enum|;
end_enum

begin_comment
comment|/* This structure is used to pass information from captured_mi_execute_command    to mi_execute_command. */
end_comment

begin_struct
struct|struct
name|captured_mi_execute_command_args
block|{
comment|/* This return result of the MI command (output) */
name|enum
name|mi_cmd_result
name|rc
decl_stmt|;
comment|/* What action to perform when the call is finished (output) */
name|enum
name|captured_mi_execute_command_actions
name|action
decl_stmt|;
comment|/* The command context to be executed (input) */
name|struct
name|mi_parse
modifier|*
name|command
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|int
name|mi_debug_p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ui_file
modifier|*
name|raw_stdout
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The token of the last asynchronous command */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|last_async_command
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|previous_async_command
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|mi_error_message
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|old_regs
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|void
name|_initialize_mi_main
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|mi_cmd_result
name|mi_cmd_execute
parameter_list|(
name|struct
name|mi_parse
modifier|*
name|parse
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mi_execute_cli_command
parameter_list|(
specifier|const
name|char
modifier|*
name|cmd
parameter_list|,
name|int
name|args_p
parameter_list|,
specifier|const
name|char
modifier|*
name|args
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|mi_cmd_result
name|mi_execute_async_cli_command
parameter_list|(
name|char
modifier|*
name|mi
parameter_list|,
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mi_exec_async_cli_cmd_continuation
parameter_list|(
name|struct
name|continuation_arg
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|register_changed_p
parameter_list|(
name|int
name|regnum
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_register
parameter_list|(
name|int
name|regnum
parameter_list|,
name|int
name|format
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* A helper function which will set mi_error_message to    error_last_message.  */
end_comment

begin_function
name|void
name|mi_error_last_message
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|s
init|=
name|error_last_message
argument_list|()
decl_stmt|;
name|xasprintf
argument_list|(
operator|&
name|mi_error_message
argument_list|,
literal|"%s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Command implementations. FIXME: Is this libgdb? No.  This is the MI    layer that calls libgdb.  Any operation used in the below should be    formalized. */
end_comment

begin_function
name|enum
name|mi_cmd_result
name|mi_cmd_gdb_exit
parameter_list|(
name|char
modifier|*
name|command
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|int
name|argc
parameter_list|)
block|{
comment|/* We have to print everything right here because we never return */
if|if
condition|(
name|last_async_command
condition|)
name|fputs_unfiltered
argument_list|(
name|last_async_command
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
literal|"^exit\n"
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|mi_out_put
argument_list|(
name|uiout
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
comment|/* FIXME: The function called is not yet a formal libgdb function */
name|quit_force
argument_list|(
name|NULL
argument_list|,
name|FROM_TTY
argument_list|)
expr_stmt|;
return|return
name|MI_CMD_DONE
return|;
block|}
end_function

begin_function
name|enum
name|mi_cmd_result
name|mi_cmd_exec_run
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
comment|/* FIXME: Should call a libgdb function, not a cli wrapper */
return|return
name|mi_execute_async_cli_command
argument_list|(
literal|"run"
argument_list|,
name|args
argument_list|,
name|from_tty
argument_list|)
return|;
block|}
end_function

begin_function
name|enum
name|mi_cmd_result
name|mi_cmd_exec_next
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
comment|/* FIXME: Should call a libgdb function, not a cli wrapper */
return|return
name|mi_execute_async_cli_command
argument_list|(
literal|"next"
argument_list|,
name|args
argument_list|,
name|from_tty
argument_list|)
return|;
block|}
end_function

begin_function
name|enum
name|mi_cmd_result
name|mi_cmd_exec_next_instruction
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
comment|/* FIXME: Should call a libgdb function, not a cli wrapper */
return|return
name|mi_execute_async_cli_command
argument_list|(
literal|"nexti"
argument_list|,
name|args
argument_list|,
name|from_tty
argument_list|)
return|;
block|}
end_function

begin_function
name|enum
name|mi_cmd_result
name|mi_cmd_exec_step
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
comment|/* FIXME: Should call a libgdb function, not a cli wrapper */
return|return
name|mi_execute_async_cli_command
argument_list|(
literal|"step"
argument_list|,
name|args
argument_list|,
name|from_tty
argument_list|)
return|;
block|}
end_function

begin_function
name|enum
name|mi_cmd_result
name|mi_cmd_exec_step_instruction
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
comment|/* FIXME: Should call a libgdb function, not a cli wrapper */
return|return
name|mi_execute_async_cli_command
argument_list|(
literal|"stepi"
argument_list|,
name|args
argument_list|,
name|from_tty
argument_list|)
return|;
block|}
end_function

begin_function
name|enum
name|mi_cmd_result
name|mi_cmd_exec_finish
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
comment|/* FIXME: Should call a libgdb function, not a cli wrapper */
return|return
name|mi_execute_async_cli_command
argument_list|(
literal|"finish"
argument_list|,
name|args
argument_list|,
name|from_tty
argument_list|)
return|;
block|}
end_function

begin_function
name|enum
name|mi_cmd_result
name|mi_cmd_exec_until
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
comment|/* FIXME: Should call a libgdb function, not a cli wrapper */
return|return
name|mi_execute_async_cli_command
argument_list|(
literal|"until"
argument_list|,
name|args
argument_list|,
name|from_tty
argument_list|)
return|;
block|}
end_function

begin_function
name|enum
name|mi_cmd_result
name|mi_cmd_exec_return
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
comment|/* This command doesn't really execute the target, it just pops the      specified number of frames. */
if|if
condition|(
operator|*
name|args
condition|)
comment|/* Call return_command with from_tty argument equal to 0 so as to        avoid being queried. */
name|return_command
argument_list|(
name|args
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
comment|/* Call return_command with from_tty argument equal to 0 so as to        avoid being queried. */
name|return_command
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Because we have called return_command with from_tty = 0, we need      to print the frame here. */
name|print_stack_frame
argument_list|(
name|deprecated_selected_frame
argument_list|,
name|frame_relative_level
argument_list|(
name|deprecated_selected_frame
argument_list|)
argument_list|,
name|LOC_AND_ADDRESS
argument_list|)
expr_stmt|;
return|return
name|MI_CMD_DONE
return|;
block|}
end_function

begin_function
name|enum
name|mi_cmd_result
name|mi_cmd_exec_continue
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
comment|/* FIXME: Should call a libgdb function, not a cli wrapper */
return|return
name|mi_execute_async_cli_command
argument_list|(
literal|"continue"
argument_list|,
name|args
argument_list|,
name|from_tty
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Interrupt the execution of the target. Note how we must play around    with the token varialbes, in order to display the current token in    the result of the interrupt command, and the previous execution    token when the target finally stops. See comments in    mi_cmd_execute. */
end_comment

begin_function
name|enum
name|mi_cmd_result
name|mi_cmd_exec_interrupt
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
if|if
condition|(
operator|!
name|target_executing
condition|)
block|{
name|xasprintf
argument_list|(
operator|&
name|mi_error_message
argument_list|,
literal|"mi_cmd_exec_interrupt: Inferior not executing."
argument_list|)
expr_stmt|;
return|return
name|MI_CMD_ERROR
return|;
block|}
name|interrupt_target_command
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_async_command
condition|)
name|fputs_unfiltered
argument_list|(
name|last_async_command
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
literal|"^done"
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|last_async_command
argument_list|)
expr_stmt|;
if|if
condition|(
name|previous_async_command
condition|)
name|last_async_command
operator|=
name|xstrdup
argument_list|(
name|previous_async_command
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|previous_async_command
argument_list|)
expr_stmt|;
name|previous_async_command
operator|=
name|NULL
expr_stmt|;
name|mi_out_put
argument_list|(
name|uiout
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|mi_out_rewind
argument_list|(
name|uiout
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
literal|"\n"
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
return|return
name|MI_CMD_QUIET
return|;
block|}
end_function

begin_function
name|enum
name|mi_cmd_result
name|mi_cmd_thread_select
parameter_list|(
name|char
modifier|*
name|command
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|int
name|argc
parameter_list|)
block|{
name|enum
name|gdb_rc
name|rc
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|1
condition|)
block|{
name|xasprintf
argument_list|(
operator|&
name|mi_error_message
argument_list|,
literal|"mi_cmd_thread_select: USAGE: threadnum."
argument_list|)
expr_stmt|;
return|return
name|MI_CMD_ERROR
return|;
block|}
else|else
name|rc
operator|=
name|gdb_thread_select
argument_list|(
name|uiout
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* RC is enum gdb_rc if it is successful (>=0)      enum return_reason if not (<0). */
if|if
condition|(
operator|(
name|int
operator|)
name|rc
operator|<
literal|0
operator|&&
operator|(
expr|enum
name|return_reason
operator|)
name|rc
operator|==
name|RETURN_ERROR
condition|)
return|return
name|MI_CMD_CAUGHT_ERROR
return|;
elseif|else
if|if
condition|(
operator|(
name|int
operator|)
name|rc
operator|>=
literal|0
operator|&&
name|rc
operator|==
name|GDB_RC_FAIL
condition|)
return|return
name|MI_CMD_ERROR
return|;
else|else
return|return
name|MI_CMD_DONE
return|;
block|}
end_function

begin_function
name|enum
name|mi_cmd_result
name|mi_cmd_thread_list_ids
parameter_list|(
name|char
modifier|*
name|command
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|int
name|argc
parameter_list|)
block|{
name|enum
name|gdb_rc
name|rc
init|=
name|MI_CMD_DONE
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|0
condition|)
block|{
name|xasprintf
argument_list|(
operator|&
name|mi_error_message
argument_list|,
literal|"mi_cmd_thread_list_ids: No arguments required."
argument_list|)
expr_stmt|;
return|return
name|MI_CMD_ERROR
return|;
block|}
else|else
name|rc
operator|=
name|gdb_list_thread_ids
argument_list|(
name|uiout
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
name|GDB_RC_FAIL
condition|)
return|return
name|MI_CMD_CAUGHT_ERROR
return|;
else|else
return|return
name|MI_CMD_DONE
return|;
block|}
end_function

begin_function
name|enum
name|mi_cmd_result
name|mi_cmd_data_list_register_names
parameter_list|(
name|char
modifier|*
name|command
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|int
name|argc
parameter_list|)
block|{
name|int
name|regnum
decl_stmt|,
name|numregs
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|cleanup
decl_stmt|;
comment|/* Note that the test for a valid register must include checking the      REGISTER_NAME because NUM_REGS may be allocated for the union of      the register sets within a family of related processors.  In this      case, some entries of REGISTER_NAME will change depending upon      the particular processor being debugged.  */
name|numregs
operator|=
name|NUM_REGS
operator|+
name|NUM_PSEUDO_REGS
expr_stmt|;
name|cleanup
operator|=
name|make_cleanup_ui_out_list_begin_end
argument_list|(
name|uiout
argument_list|,
literal|"register-names"
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
comment|/* No args, just do all the regs */
block|{
for|for
control|(
name|regnum
operator|=
literal|0
init|;
name|regnum
operator|<
name|numregs
condition|;
name|regnum
operator|++
control|)
block|{
if|if
condition|(
name|REGISTER_NAME
argument_list|(
name|regnum
argument_list|)
operator|==
name|NULL
operator|||
operator|*
operator|(
name|REGISTER_NAME
argument_list|(
name|regnum
argument_list|)
operator|)
operator|==
literal|'\0'
condition|)
name|ui_out_field_string
argument_list|(
name|uiout
argument_list|,
name|NULL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
else|else
name|ui_out_field_string
argument_list|(
name|uiout
argument_list|,
name|NULL
argument_list|,
name|REGISTER_NAME
argument_list|(
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Else, list of register #s, just do listed regs */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|regnum
operator|=
name|atoi
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|regnum
operator|<
literal|0
operator|||
name|regnum
operator|>=
name|numregs
condition|)
block|{
name|do_cleanups
argument_list|(
name|cleanup
argument_list|)
expr_stmt|;
name|xasprintf
argument_list|(
operator|&
name|mi_error_message
argument_list|,
literal|"bad register number"
argument_list|)
expr_stmt|;
return|return
name|MI_CMD_ERROR
return|;
block|}
if|if
condition|(
name|REGISTER_NAME
argument_list|(
name|regnum
argument_list|)
operator|==
name|NULL
operator|||
operator|*
operator|(
name|REGISTER_NAME
argument_list|(
name|regnum
argument_list|)
operator|)
operator|==
literal|'\0'
condition|)
name|ui_out_field_string
argument_list|(
name|uiout
argument_list|,
name|NULL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
else|else
name|ui_out_field_string
argument_list|(
name|uiout
argument_list|,
name|NULL
argument_list|,
name|REGISTER_NAME
argument_list|(
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|do_cleanups
argument_list|(
name|cleanup
argument_list|)
expr_stmt|;
return|return
name|MI_CMD_DONE
return|;
block|}
end_function

begin_function
name|enum
name|mi_cmd_result
name|mi_cmd_data_list_changed_registers
parameter_list|(
name|char
modifier|*
name|command
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|int
name|argc
parameter_list|)
block|{
name|int
name|regnum
decl_stmt|,
name|numregs
decl_stmt|,
name|changed
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|cleanup
decl_stmt|;
comment|/* Note that the test for a valid register must include checking the      REGISTER_NAME because NUM_REGS may be allocated for the union of      the register sets within a family of related processors.  In this      case, some entries of REGISTER_NAME will change depending upon      the particular processor being debugged.  */
name|numregs
operator|=
name|NUM_REGS
expr_stmt|;
name|cleanup
operator|=
name|make_cleanup_ui_out_list_begin_end
argument_list|(
name|uiout
argument_list|,
literal|"changed-registers"
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
comment|/* No args, just do all the regs */
block|{
for|for
control|(
name|regnum
operator|=
literal|0
init|;
name|regnum
operator|<
name|numregs
condition|;
name|regnum
operator|++
control|)
block|{
if|if
condition|(
name|REGISTER_NAME
argument_list|(
name|regnum
argument_list|)
operator|==
name|NULL
operator|||
operator|*
operator|(
name|REGISTER_NAME
argument_list|(
name|regnum
argument_list|)
operator|)
operator|==
literal|'\0'
condition|)
continue|continue;
name|changed
operator|=
name|register_changed_p
argument_list|(
name|regnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|changed
operator|<
literal|0
condition|)
block|{
name|do_cleanups
argument_list|(
name|cleanup
argument_list|)
expr_stmt|;
name|xasprintf
argument_list|(
operator|&
name|mi_error_message
argument_list|,
literal|"mi_cmd_data_list_changed_registers: Unable to read register contents."
argument_list|)
expr_stmt|;
return|return
name|MI_CMD_ERROR
return|;
block|}
elseif|else
if|if
condition|(
name|changed
condition|)
name|ui_out_field_int
argument_list|(
name|uiout
argument_list|,
name|NULL
argument_list|,
name|regnum
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Else, list of register #s, just do listed regs */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|regnum
operator|=
name|atoi
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|regnum
operator|>=
literal|0
operator|&&
name|regnum
operator|<
name|numregs
operator|&&
name|REGISTER_NAME
argument_list|(
name|regnum
argument_list|)
operator|!=
name|NULL
operator|&&
operator|*
name|REGISTER_NAME
argument_list|(
name|regnum
argument_list|)
operator|!=
literal|'\000'
condition|)
block|{
name|changed
operator|=
name|register_changed_p
argument_list|(
name|regnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|changed
operator|<
literal|0
condition|)
block|{
name|do_cleanups
argument_list|(
name|cleanup
argument_list|)
expr_stmt|;
name|xasprintf
argument_list|(
operator|&
name|mi_error_message
argument_list|,
literal|"mi_cmd_data_list_register_change: Unable to read register contents."
argument_list|)
expr_stmt|;
return|return
name|MI_CMD_ERROR
return|;
block|}
elseif|else
if|if
condition|(
name|changed
condition|)
name|ui_out_field_int
argument_list|(
name|uiout
argument_list|,
name|NULL
argument_list|,
name|regnum
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|do_cleanups
argument_list|(
name|cleanup
argument_list|)
expr_stmt|;
name|xasprintf
argument_list|(
operator|&
name|mi_error_message
argument_list|,
literal|"bad register number"
argument_list|)
expr_stmt|;
return|return
name|MI_CMD_ERROR
return|;
block|}
block|}
name|do_cleanups
argument_list|(
name|cleanup
argument_list|)
expr_stmt|;
return|return
name|MI_CMD_DONE
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|register_changed_p
parameter_list|(
name|int
name|regnum
parameter_list|)
block|{
name|char
name|raw_buffer
index|[
name|MAX_REGISTER_SIZE
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|frame_register_read
argument_list|(
name|deprecated_selected_frame
argument_list|,
name|regnum
argument_list|,
name|raw_buffer
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|memcmp
argument_list|(
operator|&
name|old_regs
index|[
name|DEPRECATED_REGISTER_BYTE
argument_list|(
name|regnum
argument_list|)
index|]
argument_list|,
name|raw_buffer
argument_list|,
name|DEPRECATED_REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Found a changed register. Return 1. */
name|memcpy
argument_list|(
operator|&
name|old_regs
index|[
name|DEPRECATED_REGISTER_BYTE
argument_list|(
name|regnum
argument_list|)
index|]
argument_list|,
name|raw_buffer
argument_list|,
name|DEPRECATED_REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return a list of register number and value pairs. The valid    arguments expected are: a letter indicating the format in which to    display the registers contents. This can be one of: x (hexadecimal), d    (decimal), N (natural), t (binary), o (octal), r (raw).  After the    format argumetn there can be a sequence of numbers, indicating which    registers to fetch the content of. If the format is the only argument,    a list of all the registers with their values is returned. */
end_comment

begin_function
name|enum
name|mi_cmd_result
name|mi_cmd_data_list_register_values
parameter_list|(
name|char
modifier|*
name|command
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|int
name|argc
parameter_list|)
block|{
name|int
name|regnum
decl_stmt|,
name|numregs
decl_stmt|,
name|format
decl_stmt|,
name|result
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|list_cleanup
decl_stmt|,
modifier|*
name|tuple_cleanup
decl_stmt|;
comment|/* Note that the test for a valid register must include checking the      REGISTER_NAME because NUM_REGS may be allocated for the union of      the register sets within a family of related processors.  In this      case, some entries of REGISTER_NAME will change depending upon      the particular processor being debugged.  */
name|numregs
operator|=
name|NUM_REGS
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
block|{
name|xasprintf
argument_list|(
operator|&
name|mi_error_message
argument_list|,
literal|"mi_cmd_data_list_register_values: Usage: -data-list-register-values<format> [<regnum1>...<regnumN>]"
argument_list|)
expr_stmt|;
return|return
name|MI_CMD_ERROR
return|;
block|}
name|format
operator|=
operator|(
name|int
operator|)
name|argv
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|target_has_registers
condition|)
block|{
name|xasprintf
argument_list|(
operator|&
name|mi_error_message
argument_list|,
literal|"mi_cmd_data_list_register_values: No registers."
argument_list|)
expr_stmt|;
return|return
name|MI_CMD_ERROR
return|;
block|}
name|list_cleanup
operator|=
name|make_cleanup_ui_out_list_begin_end
argument_list|(
name|uiout
argument_list|,
literal|"register-values"
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|1
condition|)
comment|/* No args, beside the format: do all the regs */
block|{
for|for
control|(
name|regnum
operator|=
literal|0
init|;
name|regnum
operator|<
name|numregs
condition|;
name|regnum
operator|++
control|)
block|{
if|if
condition|(
name|REGISTER_NAME
argument_list|(
name|regnum
argument_list|)
operator|==
name|NULL
operator|||
operator|*
operator|(
name|REGISTER_NAME
argument_list|(
name|regnum
argument_list|)
operator|)
operator|==
literal|'\0'
condition|)
continue|continue;
name|tuple_cleanup
operator|=
name|make_cleanup_ui_out_tuple_begin_end
argument_list|(
name|uiout
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ui_out_field_int
argument_list|(
name|uiout
argument_list|,
literal|"number"
argument_list|,
name|regnum
argument_list|)
expr_stmt|;
name|result
operator|=
name|get_register
argument_list|(
name|regnum
argument_list|,
name|format
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
operator|-
literal|1
condition|)
block|{
name|do_cleanups
argument_list|(
name|list_cleanup
argument_list|)
expr_stmt|;
return|return
name|MI_CMD_ERROR
return|;
block|}
name|do_cleanups
argument_list|(
name|tuple_cleanup
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Else, list of register #s, just do listed regs */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|regnum
operator|=
name|atoi
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|regnum
operator|>=
literal|0
operator|&&
name|regnum
operator|<
name|numregs
operator|&&
name|REGISTER_NAME
argument_list|(
name|regnum
argument_list|)
operator|!=
name|NULL
operator|&&
operator|*
name|REGISTER_NAME
argument_list|(
name|regnum
argument_list|)
operator|!=
literal|'\000'
condition|)
block|{
name|tuple_cleanup
operator|=
name|make_cleanup_ui_out_tuple_begin_end
argument_list|(
name|uiout
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ui_out_field_int
argument_list|(
name|uiout
argument_list|,
literal|"number"
argument_list|,
name|regnum
argument_list|)
expr_stmt|;
name|result
operator|=
name|get_register
argument_list|(
name|regnum
argument_list|,
name|format
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
operator|-
literal|1
condition|)
block|{
name|do_cleanups
argument_list|(
name|list_cleanup
argument_list|)
expr_stmt|;
return|return
name|MI_CMD_ERROR
return|;
block|}
name|do_cleanups
argument_list|(
name|tuple_cleanup
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|do_cleanups
argument_list|(
name|list_cleanup
argument_list|)
expr_stmt|;
name|xasprintf
argument_list|(
operator|&
name|mi_error_message
argument_list|,
literal|"bad register number"
argument_list|)
expr_stmt|;
return|return
name|MI_CMD_ERROR
return|;
block|}
block|}
name|do_cleanups
argument_list|(
name|list_cleanup
argument_list|)
expr_stmt|;
return|return
name|MI_CMD_DONE
return|;
block|}
end_function

begin_comment
comment|/* Output one register's contents in the desired format. */
end_comment

begin_function
specifier|static
name|int
name|get_register
parameter_list|(
name|int
name|regnum
parameter_list|,
name|int
name|format
parameter_list|)
block|{
name|char
name|raw_buffer
index|[
name|MAX_REGISTER_SIZE
index|]
decl_stmt|;
name|char
name|virtual_buffer
index|[
name|MAX_REGISTER_SIZE
index|]
decl_stmt|;
name|int
name|optim
decl_stmt|;
name|int
name|realnum
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|enum
name|lval_type
name|lval
decl_stmt|;
specifier|static
name|struct
name|ui_stream
modifier|*
name|stb
init|=
name|NULL
decl_stmt|;
name|stb
operator|=
name|ui_out_stream_new
argument_list|(
name|uiout
argument_list|)
expr_stmt|;
if|if
condition|(
name|format
operator|==
literal|'N'
condition|)
name|format
operator|=
literal|0
expr_stmt|;
name|frame_register
argument_list|(
name|deprecated_selected_frame
argument_list|,
name|regnum
argument_list|,
operator|&
name|optim
argument_list|,
operator|&
name|lval
argument_list|,
operator|&
name|addr
argument_list|,
operator|&
name|realnum
argument_list|,
name|raw_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|optim
condition|)
block|{
name|xasprintf
argument_list|(
operator|&
name|mi_error_message
argument_list|,
literal|"Optimized out"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Convert raw data to virtual format if necessary.  */
if|if
condition|(
name|DEPRECATED_REGISTER_CONVERTIBLE_P
argument_list|()
operator|&&
name|DEPRECATED_REGISTER_CONVERTIBLE
argument_list|(
name|regnum
argument_list|)
condition|)
block|{
name|DEPRECATED_REGISTER_CONVERT_TO_VIRTUAL
argument_list|(
name|regnum
argument_list|,
name|register_type
argument_list|(
name|current_gdbarch
argument_list|,
name|regnum
argument_list|)
argument_list|,
name|raw_buffer
argument_list|,
name|virtual_buffer
argument_list|)
expr_stmt|;
block|}
else|else
name|memcpy
argument_list|(
name|virtual_buffer
argument_list|,
name|raw_buffer
argument_list|,
name|DEPRECATED_REGISTER_VIRTUAL_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|format
operator|==
literal|'r'
condition|)
block|{
name|int
name|j
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|,
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"0x"
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|buf
operator|+
literal|2
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|DEPRECATED_REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|int
name|idx
init|=
name|TARGET_BYTE_ORDER
operator|==
name|BFD_ENDIAN_BIG
condition|?
name|j
else|:
name|DEPRECATED_REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
operator|-
literal|1
operator|-
name|j
decl_stmt|;
name|sprintf
argument_list|(
name|ptr
argument_list|,
literal|"%02x"
argument_list|,
operator|(
name|unsigned
name|char
operator|)
name|raw_buffer
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
name|ptr
operator|+=
literal|2
expr_stmt|;
block|}
name|ui_out_field_string
argument_list|(
name|uiout
argument_list|,
literal|"value"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/*fputs_filtered (buf, gdb_stdout); */
block|}
else|else
block|{
name|val_print
argument_list|(
name|register_type
argument_list|(
name|current_gdbarch
argument_list|,
name|regnum
argument_list|)
argument_list|,
name|virtual_buffer
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|stb
operator|->
name|stream
argument_list|,
name|format
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|Val_pretty_default
argument_list|)
expr_stmt|;
name|ui_out_field_stream
argument_list|(
name|uiout
argument_list|,
literal|"value"
argument_list|,
name|stb
argument_list|)
expr_stmt|;
name|ui_out_stream_delete
argument_list|(
name|stb
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Write given values into registers. The registers and values are    given as pairs. The corresponding MI command is     -data-write-register-values<format> [<regnum1><value1>...<regnumN><valueN>]*/
end_comment

begin_function
name|enum
name|mi_cmd_result
name|mi_cmd_data_write_register_values
parameter_list|(
name|char
modifier|*
name|command
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|int
name|argc
parameter_list|)
block|{
name|int
name|regnum
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|numregs
decl_stmt|;
name|LONGEST
name|value
decl_stmt|;
name|char
name|format
decl_stmt|;
comment|/* Note that the test for a valid register must include checking the      REGISTER_NAME because NUM_REGS may be allocated for the union of      the register sets within a family of related processors.  In this      case, some entries of REGISTER_NAME will change depending upon      the particular processor being debugged.  */
name|numregs
operator|=
name|NUM_REGS
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
block|{
name|xasprintf
argument_list|(
operator|&
name|mi_error_message
argument_list|,
literal|"mi_cmd_data_write_register_values: Usage: -data-write-register-values<format> [<regnum1><value1>...<regnumN><valueN>]"
argument_list|)
expr_stmt|;
return|return
name|MI_CMD_ERROR
return|;
block|}
name|format
operator|=
operator|(
name|int
operator|)
name|argv
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|target_has_registers
condition|)
block|{
name|xasprintf
argument_list|(
operator|&
name|mi_error_message
argument_list|,
literal|"mi_cmd_data_write_register_values: No registers."
argument_list|)
expr_stmt|;
return|return
name|MI_CMD_ERROR
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|argc
operator|-
literal|1
operator|)
condition|)
block|{
name|xasprintf
argument_list|(
operator|&
name|mi_error_message
argument_list|,
literal|"mi_cmd_data_write_register_values: No regs and values specified."
argument_list|)
expr_stmt|;
return|return
name|MI_CMD_ERROR
return|;
block|}
if|if
condition|(
operator|(
name|argc
operator|-
literal|1
operator|)
operator|%
literal|2
condition|)
block|{
name|xasprintf
argument_list|(
operator|&
name|mi_error_message
argument_list|,
literal|"mi_cmd_data_write_register_values: Regs and vals are not in pairs."
argument_list|)
expr_stmt|;
return|return
name|MI_CMD_ERROR
return|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|=
name|i
operator|+
literal|2
control|)
block|{
name|regnum
operator|=
name|atoi
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|regnum
operator|>=
literal|0
operator|&&
name|regnum
operator|<
name|numregs
operator|&&
name|REGISTER_NAME
argument_list|(
name|regnum
argument_list|)
operator|!=
name|NULL
operator|&&
operator|*
name|REGISTER_NAME
argument_list|(
name|regnum
argument_list|)
operator|!=
literal|'\000'
condition|)
block|{
name|void
modifier|*
name|buffer
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
comment|/* Get the value as a number */
name|value
operator|=
name|parse_and_eval_address
argument_list|(
name|argv
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* Get the value into an array */
name|buffer
operator|=
name|xmalloc
argument_list|(
name|DEPRECATED_REGISTER_SIZE
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|store_signed_integer
argument_list|(
name|buffer
argument_list|,
name|DEPRECATED_REGISTER_SIZE
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|/* Write it down */
name|deprecated_write_register_bytes
argument_list|(
name|DEPRECATED_REGISTER_BYTE
argument_list|(
name|regnum
argument_list|)
argument_list|,
name|buffer
argument_list|,
name|DEPRECATED_REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Free the buffer.  */
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xasprintf
argument_list|(
operator|&
name|mi_error_message
argument_list|,
literal|"bad register number"
argument_list|)
expr_stmt|;
return|return
name|MI_CMD_ERROR
return|;
block|}
block|}
return|return
name|MI_CMD_DONE
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/*This is commented out because we decided it was not useful. I leave    it, just in case. ezannoni:1999-12-08 */
end_comment

begin_comment
comment|/* Assign a value to a variable. The expression argument must be in    the form A=2 or "A = 2" (I.e. if there are spaces it needs to be    quoted. */
end_comment

begin_comment
unit|enum mi_cmd_result mi_cmd_data_assign (char *command, char **argv, int argc) {   struct expression *expr;   struct cleanup *old_chain;    if (argc != 1)     {       xasprintf (&mi_error_message, 		 "mi_cmd_data_assign: Usage: -data-assign expression");       return MI_CMD_ERROR;     }
comment|/* NOTE what follows is a clone of set_command(). FIXME: ezannoni      01-12-1999: Need to decide what to do with this for libgdb purposes. */
end_comment

begin_endif
unit|expr = parse_expression (argv[0]);   old_chain = make_cleanup (free_current_contents,&expr);   evaluate_expression (expr);   do_cleanups (old_chain);   return MI_CMD_DONE; }
endif|#
directive|endif
end_endif

begin_comment
comment|/* Evaluate the value of the argument. The argument is an    expression. If the expression contains spaces it needs to be    included in double quotes. */
end_comment

begin_function
name|enum
name|mi_cmd_result
name|mi_cmd_data_evaluate_expression
parameter_list|(
name|char
modifier|*
name|command
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|int
name|argc
parameter_list|)
block|{
name|struct
name|expression
modifier|*
name|expr
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
init|=
name|NULL
decl_stmt|;
name|struct
name|value
modifier|*
name|val
decl_stmt|;
name|struct
name|ui_stream
modifier|*
name|stb
init|=
name|NULL
decl_stmt|;
name|stb
operator|=
name|ui_out_stream_new
argument_list|(
name|uiout
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|1
condition|)
block|{
name|xasprintf
argument_list|(
operator|&
name|mi_error_message
argument_list|,
literal|"mi_cmd_data_evaluate_expression: Usage: -data-evaluate-expression expression"
argument_list|)
expr_stmt|;
return|return
name|MI_CMD_ERROR
return|;
block|}
name|expr
operator|=
name|parse_expression
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|free_current_contents
argument_list|,
operator|&
name|expr
argument_list|)
expr_stmt|;
name|val
operator|=
name|evaluate_expression
argument_list|(
name|expr
argument_list|)
expr_stmt|;
comment|/* Print the result of the expression evaluation. */
name|val_print
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|val
argument_list|)
argument_list|,
name|VALUE_EMBEDDED_OFFSET
argument_list|(
name|val
argument_list|)
argument_list|,
name|VALUE_ADDRESS
argument_list|(
name|val
argument_list|)
argument_list|,
name|stb
operator|->
name|stream
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ui_out_field_stream
argument_list|(
name|uiout
argument_list|,
literal|"value"
argument_list|,
name|stb
argument_list|)
expr_stmt|;
name|ui_out_stream_delete
argument_list|(
name|stb
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
name|MI_CMD_DONE
return|;
block|}
end_function

begin_function
name|enum
name|mi_cmd_result
name|mi_cmd_target_download
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|char
modifier|*
name|run
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_cleanups
init|=
name|NULL
decl_stmt|;
name|xasprintf
argument_list|(
operator|&
name|run
argument_list|,
literal|"load %s"
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|old_cleanups
operator|=
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|run
argument_list|)
expr_stmt|;
name|execute_command
argument_list|(
name|run
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_cleanups
argument_list|)
expr_stmt|;
return|return
name|MI_CMD_DONE
return|;
block|}
end_function

begin_comment
comment|/* Connect to the remote target. */
end_comment

begin_function
name|enum
name|mi_cmd_result
name|mi_cmd_target_select
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|char
modifier|*
name|run
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_cleanups
init|=
name|NULL
decl_stmt|;
name|xasprintf
argument_list|(
operator|&
name|run
argument_list|,
literal|"target %s"
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|old_cleanups
operator|=
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|run
argument_list|)
expr_stmt|;
comment|/* target-select is always synchronous.  once the call has returned      we know that we are connected. */
comment|/* NOTE: At present all targets that are connected are also      (implicitly) talking to a halted target.  In the future this may      change. */
name|execute_command
argument_list|(
name|run
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_cleanups
argument_list|)
expr_stmt|;
comment|/* Issue the completion message here. */
if|if
condition|(
name|last_async_command
condition|)
name|fputs_unfiltered
argument_list|(
name|last_async_command
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
literal|"^connected"
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|mi_out_put
argument_list|(
name|uiout
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|mi_out_rewind
argument_list|(
name|uiout
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
literal|"\n"
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|do_exec_cleanups
argument_list|(
name|ALL_CLEANUPS
argument_list|)
expr_stmt|;
return|return
name|MI_CMD_QUIET
return|;
block|}
end_function

begin_comment
comment|/* DATA-MEMORY-READ:     ADDR: start address of data to be dumped.    WORD-FORMAT: a char indicating format for the ``word''. See     the ``x'' command.    WORD-SIZE: size of each ``word''; 1,2,4, or 8 bytes    NR_ROW: Number of rows.    NR_COL: The number of colums (words per row).    ASCHAR: (OPTIONAL) Append an ascii character dump to each row.  Use    ASCHAR for unprintable characters.     Reads SIZE*NR_ROW*NR_COL bytes starting at ADDR from memory and    displayes them.  Returns:     {addr="...",rowN={wordN="..." ,... [,ascii="..."]}, ...}     Returns:     The number of bytes read is SIZE*ROW*COL. */
end_comment

begin_function
name|enum
name|mi_cmd_result
name|mi_cmd_data_read_memory
parameter_list|(
name|char
modifier|*
name|command
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|int
name|argc
parameter_list|)
block|{
name|struct
name|cleanup
modifier|*
name|cleanups
init|=
name|make_cleanup
argument_list|(
name|null_cleanup
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|long
name|total_bytes
decl_stmt|;
name|long
name|nr_cols
decl_stmt|;
name|long
name|nr_rows
decl_stmt|;
name|char
name|word_format
decl_stmt|;
name|struct
name|type
modifier|*
name|word_type
decl_stmt|;
name|long
name|word_size
decl_stmt|;
name|char
name|word_asize
decl_stmt|;
name|char
name|aschar
decl_stmt|;
name|char
modifier|*
name|mbuf
decl_stmt|;
name|int
name|nr_bytes
decl_stmt|;
name|long
name|offset
init|=
literal|0
decl_stmt|;
name|int
name|optind
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|optarg
decl_stmt|;
enum|enum
name|opt
block|{
name|OFFSET_OPT
block|}
enum|;
specifier|static
name|struct
name|mi_opt
name|opts
index|[]
init|=
block|{
block|{
literal|"o"
block|,
name|OFFSET_OPT
block|,
literal|1
block|}
block|,
literal|0
block|}
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|opt
init|=
name|mi_getopt
argument_list|(
literal|"mi_cmd_data_read_memory"
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|opts
argument_list|,
operator|&
name|optind
argument_list|,
operator|&
name|optarg
argument_list|)
decl_stmt|;
if|if
condition|(
name|opt
operator|<
literal|0
condition|)
break|break;
switch|switch
condition|(
operator|(
expr|enum
name|opt
operator|)
name|opt
condition|)
block|{
case|case
name|OFFSET_OPT
case|:
name|offset
operator|=
name|atol
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|argv
operator|+=
name|optind
expr_stmt|;
name|argc
operator|-=
name|optind
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|5
operator|||
name|argc
operator|>
literal|6
condition|)
block|{
name|xasprintf
argument_list|(
operator|&
name|mi_error_message
argument_list|,
literal|"mi_cmd_data_read_memory: Usage: ADDR WORD-FORMAT WORD-SIZE NR-ROWS NR-COLS [ASCHAR]."
argument_list|)
expr_stmt|;
return|return
name|MI_CMD_ERROR
return|;
block|}
comment|/* Extract all the arguments. */
comment|/* Start address of the memory dump. */
name|addr
operator|=
name|parse_and_eval_address
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
operator|+
name|offset
expr_stmt|;
comment|/* The format character to use when displaying a memory word. See      the ``x'' command. */
name|word_format
operator|=
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
comment|/* The size of the memory word. */
name|word_size
operator|=
name|atol
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|word_size
condition|)
block|{
case|case
literal|1
case|:
name|word_type
operator|=
name|builtin_type_int8
expr_stmt|;
name|word_asize
operator|=
literal|'b'
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|word_type
operator|=
name|builtin_type_int16
expr_stmt|;
name|word_asize
operator|=
literal|'h'
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|word_type
operator|=
name|builtin_type_int32
expr_stmt|;
name|word_asize
operator|=
literal|'w'
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|word_type
operator|=
name|builtin_type_int64
expr_stmt|;
name|word_asize
operator|=
literal|'g'
expr_stmt|;
break|break;
default|default:
name|word_type
operator|=
name|builtin_type_int8
expr_stmt|;
name|word_asize
operator|=
literal|'b'
expr_stmt|;
block|}
comment|/* The number of rows */
name|nr_rows
operator|=
name|atol
argument_list|(
name|argv
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|nr_rows
operator|<=
literal|0
condition|)
block|{
name|xasprintf
argument_list|(
operator|&
name|mi_error_message
argument_list|,
literal|"mi_cmd_data_read_memory: invalid number of rows."
argument_list|)
expr_stmt|;
return|return
name|MI_CMD_ERROR
return|;
block|}
comment|/* number of bytes per row. */
name|nr_cols
operator|=
name|atol
argument_list|(
name|argv
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|nr_cols
operator|<=
literal|0
condition|)
block|{
name|xasprintf
argument_list|(
operator|&
name|mi_error_message
argument_list|,
literal|"mi_cmd_data_read_memory: invalid number of columns."
argument_list|)
expr_stmt|;
block|}
comment|/* The un-printable character when printing ascii. */
if|if
condition|(
name|argc
operator|==
literal|6
condition|)
name|aschar
operator|=
operator|*
name|argv
index|[
literal|5
index|]
expr_stmt|;
else|else
name|aschar
operator|=
literal|0
expr_stmt|;
comment|/* create a buffer and read it in. */
name|total_bytes
operator|=
name|word_size
operator|*
name|nr_rows
operator|*
name|nr_cols
expr_stmt|;
name|mbuf
operator|=
name|xcalloc
argument_list|(
name|total_bytes
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|mbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbuf
operator|==
name|NULL
condition|)
block|{
name|xasprintf
argument_list|(
operator|&
name|mi_error_message
argument_list|,
literal|"mi_cmd_data_read_memory: out of memory."
argument_list|)
expr_stmt|;
return|return
name|MI_CMD_ERROR
return|;
block|}
name|nr_bytes
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|nr_bytes
operator|<
name|total_bytes
condition|)
block|{
name|int
name|error
decl_stmt|;
name|long
name|num
init|=
name|target_read_memory_partial
argument_list|(
name|addr
operator|+
name|nr_bytes
argument_list|,
name|mbuf
operator|+
name|nr_bytes
argument_list|,
name|total_bytes
operator|-
name|nr_bytes
argument_list|,
operator|&
name|error
argument_list|)
decl_stmt|;
if|if
condition|(
name|num
operator|<=
literal|0
condition|)
break|break;
name|nr_bytes
operator|+=
name|num
expr_stmt|;
block|}
comment|/* output the header information. */
name|ui_out_field_core_addr
argument_list|(
name|uiout
argument_list|,
literal|"addr"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|ui_out_field_int
argument_list|(
name|uiout
argument_list|,
literal|"nr-bytes"
argument_list|,
name|nr_bytes
argument_list|)
expr_stmt|;
name|ui_out_field_int
argument_list|(
name|uiout
argument_list|,
literal|"total-bytes"
argument_list|,
name|total_bytes
argument_list|)
expr_stmt|;
name|ui_out_field_core_addr
argument_list|(
name|uiout
argument_list|,
literal|"next-row"
argument_list|,
name|addr
operator|+
name|word_size
operator|*
name|nr_cols
argument_list|)
expr_stmt|;
name|ui_out_field_core_addr
argument_list|(
name|uiout
argument_list|,
literal|"prev-row"
argument_list|,
name|addr
operator|-
name|word_size
operator|*
name|nr_cols
argument_list|)
expr_stmt|;
name|ui_out_field_core_addr
argument_list|(
name|uiout
argument_list|,
literal|"next-page"
argument_list|,
name|addr
operator|+
name|total_bytes
argument_list|)
expr_stmt|;
name|ui_out_field_core_addr
argument_list|(
name|uiout
argument_list|,
literal|"prev-page"
argument_list|,
name|addr
operator|-
name|total_bytes
argument_list|)
expr_stmt|;
comment|/* Build the result as a two dimentional table. */
block|{
name|struct
name|ui_stream
modifier|*
name|stream
init|=
name|ui_out_stream_new
argument_list|(
name|uiout
argument_list|)
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|cleanup_list_memory
decl_stmt|;
name|int
name|row
decl_stmt|;
name|int
name|row_byte
decl_stmt|;
name|cleanup_list_memory
operator|=
name|make_cleanup_ui_out_list_begin_end
argument_list|(
name|uiout
argument_list|,
literal|"memory"
argument_list|)
expr_stmt|;
for|for
control|(
name|row
operator|=
literal|0
operator|,
name|row_byte
operator|=
literal|0
init|;
name|row
operator|<
name|nr_rows
condition|;
name|row
operator|++
operator|,
name|row_byte
operator|+=
name|nr_cols
operator|*
name|word_size
control|)
block|{
name|int
name|col
decl_stmt|;
name|int
name|col_byte
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|cleanup_tuple
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|cleanup_list_data
decl_stmt|;
name|cleanup_tuple
operator|=
name|make_cleanup_ui_out_tuple_begin_end
argument_list|(
name|uiout
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ui_out_field_core_addr
argument_list|(
name|uiout
argument_list|,
literal|"addr"
argument_list|,
name|addr
operator|+
name|row_byte
argument_list|)
expr_stmt|;
comment|/* ui_out_field_core_addr_symbolic (uiout, "saddr", addr + row_byte); */
name|cleanup_list_data
operator|=
name|make_cleanup_ui_out_list_begin_end
argument_list|(
name|uiout
argument_list|,
literal|"data"
argument_list|)
expr_stmt|;
for|for
control|(
name|col
operator|=
literal|0
operator|,
name|col_byte
operator|=
name|row_byte
init|;
name|col
operator|<
name|nr_cols
condition|;
name|col
operator|++
operator|,
name|col_byte
operator|+=
name|word_size
control|)
block|{
if|if
condition|(
name|col_byte
operator|+
name|word_size
operator|>
name|nr_bytes
condition|)
block|{
name|ui_out_field_string
argument_list|(
name|uiout
argument_list|,
name|NULL
argument_list|,
literal|"N/A"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ui_file_rewind
argument_list|(
name|stream
operator|->
name|stream
argument_list|)
expr_stmt|;
name|print_scalar_formatted
argument_list|(
name|mbuf
operator|+
name|col_byte
argument_list|,
name|word_type
argument_list|,
name|word_format
argument_list|,
name|word_asize
argument_list|,
name|stream
operator|->
name|stream
argument_list|)
expr_stmt|;
name|ui_out_field_stream
argument_list|(
name|uiout
argument_list|,
name|NULL
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
name|do_cleanups
argument_list|(
name|cleanup_list_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|aschar
condition|)
block|{
name|int
name|byte
decl_stmt|;
name|ui_file_rewind
argument_list|(
name|stream
operator|->
name|stream
argument_list|)
expr_stmt|;
for|for
control|(
name|byte
operator|=
name|row_byte
init|;
name|byte
operator|<
name|row_byte
operator|+
name|word_size
operator|*
name|nr_cols
condition|;
name|byte
operator|++
control|)
block|{
if|if
condition|(
name|byte
operator|>=
name|nr_bytes
condition|)
block|{
name|fputc_unfiltered
argument_list|(
literal|'X'
argument_list|,
name|stream
operator|->
name|stream
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mbuf
index|[
name|byte
index|]
operator|<
literal|32
operator|||
name|mbuf
index|[
name|byte
index|]
operator|>
literal|126
condition|)
block|{
name|fputc_unfiltered
argument_list|(
name|aschar
argument_list|,
name|stream
operator|->
name|stream
argument_list|)
expr_stmt|;
block|}
else|else
name|fputc_unfiltered
argument_list|(
name|mbuf
index|[
name|byte
index|]
argument_list|,
name|stream
operator|->
name|stream
argument_list|)
expr_stmt|;
block|}
name|ui_out_field_stream
argument_list|(
name|uiout
argument_list|,
literal|"ascii"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
name|do_cleanups
argument_list|(
name|cleanup_tuple
argument_list|)
expr_stmt|;
block|}
name|ui_out_stream_delete
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|cleanup_list_memory
argument_list|)
expr_stmt|;
block|}
name|do_cleanups
argument_list|(
name|cleanups
argument_list|)
expr_stmt|;
return|return
name|MI_CMD_DONE
return|;
block|}
end_function

begin_comment
comment|/* DATA-MEMORY-WRITE:     COLUMN_OFFSET: optional argument. Must be preceeded by '-o'. The    offset from the beginning of the memory grid row where the cell to    be written is.    ADDR: start address of the row in the memory grid where the memory    cell is, if OFFSET_COLUMN is specified. Otherwise, the address of    the location to write to.    FORMAT: a char indicating format for the ``word''. See     the ``x'' command.    WORD_SIZE: size of each ``word''; 1,2,4, or 8 bytes    VALUE: value to be written into the memory address.     Writes VALUE into ADDR + (COLUMN_OFFSET * WORD_SIZE).     Prints nothing. */
end_comment

begin_function
name|enum
name|mi_cmd_result
name|mi_cmd_data_write_memory
parameter_list|(
name|char
modifier|*
name|command
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|int
name|argc
parameter_list|)
block|{
name|CORE_ADDR
name|addr
decl_stmt|;
name|char
name|word_format
decl_stmt|;
name|long
name|word_size
decl_stmt|;
comment|/* FIXME: ezannoni 2000-02-17 LONGEST could possibly not be big      enough when using a compiler other than GCC. */
name|LONGEST
name|value
decl_stmt|;
name|void
modifier|*
name|buffer
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|long
name|offset
init|=
literal|0
decl_stmt|;
name|int
name|optind
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|optarg
decl_stmt|;
enum|enum
name|opt
block|{
name|OFFSET_OPT
block|}
enum|;
specifier|static
name|struct
name|mi_opt
name|opts
index|[]
init|=
block|{
block|{
literal|"o"
block|,
name|OFFSET_OPT
block|,
literal|1
block|}
block|,
literal|0
block|}
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|opt
init|=
name|mi_getopt
argument_list|(
literal|"mi_cmd_data_write_memory"
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|opts
argument_list|,
operator|&
name|optind
argument_list|,
operator|&
name|optarg
argument_list|)
decl_stmt|;
if|if
condition|(
name|opt
operator|<
literal|0
condition|)
break|break;
switch|switch
condition|(
operator|(
expr|enum
name|opt
operator|)
name|opt
condition|)
block|{
case|case
name|OFFSET_OPT
case|:
name|offset
operator|=
name|atol
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|argv
operator|+=
name|optind
expr_stmt|;
name|argc
operator|-=
name|optind
expr_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|4
condition|)
block|{
name|xasprintf
argument_list|(
operator|&
name|mi_error_message
argument_list|,
literal|"mi_cmd_data_write_memory: Usage: [-o COLUMN_OFFSET] ADDR FORMAT WORD-SIZE VALUE."
argument_list|)
expr_stmt|;
return|return
name|MI_CMD_ERROR
return|;
block|}
comment|/* Extract all the arguments. */
comment|/* Start address of the memory dump. */
name|addr
operator|=
name|parse_and_eval_address
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* The format character to use when displaying a memory word. See      the ``x'' command. */
name|word_format
operator|=
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
comment|/* The size of the memory word. */
name|word_size
operator|=
name|atol
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* Calculate the real address of the write destination. */
name|addr
operator|+=
operator|(
name|offset
operator|*
name|word_size
operator|)
expr_stmt|;
comment|/* Get the value as a number */
name|value
operator|=
name|parse_and_eval_address
argument_list|(
name|argv
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
comment|/* Get the value into an array */
name|buffer
operator|=
name|xmalloc
argument_list|(
name|word_size
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|store_signed_integer
argument_list|(
name|buffer
argument_list|,
name|word_size
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|/* Write it down to memory */
name|write_memory
argument_list|(
name|addr
argument_list|,
name|buffer
argument_list|,
name|word_size
argument_list|)
expr_stmt|;
comment|/* Free the buffer.  */
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
name|MI_CMD_DONE
return|;
block|}
end_function

begin_comment
comment|/* Execute a command within a safe environment.    Return<0 for error;>=0 for ok.     args->action will tell mi_execute_command what action    to perfrom after the given command has executed (display/supress    prompt, display error). */
end_comment

begin_function
specifier|static
name|int
name|captured_mi_execute_command
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|captured_mi_execute_command_args
modifier|*
name|args
init|=
operator|(
expr|struct
name|captured_mi_execute_command_args
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|mi_parse
modifier|*
name|context
init|=
name|args
operator|->
name|command
decl_stmt|;
switch|switch
condition|(
name|context
operator|->
name|op
condition|)
block|{
case|case
name|MI_COMMAND
case|:
comment|/* A MI command was read from the input stream */
if|if
condition|(
name|mi_debug_p
condition|)
comment|/* FIXME: gdb_???? */
name|fprintf_unfiltered
argument_list|(
name|raw_stdout
argument_list|,
literal|" token=`%s' command=`%s' args=`%s'\n"
argument_list|,
name|context
operator|->
name|token
argument_list|,
name|context
operator|->
name|command
argument_list|,
name|context
operator|->
name|args
argument_list|)
expr_stmt|;
comment|/* FIXME: cagney/1999-09-25: Rather than this convoluted          condition expression, each function should return an          indication of what action is required and then switch on          that. */
name|args
operator|->
name|action
operator|=
name|EXECUTE_COMMAND_DISPLAY_PROMPT
expr_stmt|;
name|args
operator|->
name|rc
operator|=
name|mi_cmd_execute
argument_list|(
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target_can_async_p
argument_list|()
operator|||
operator|!
name|target_executing
condition|)
block|{
comment|/* print the result if there were no errors  	     Remember that on the way out of executing a command, you have 	     to directly use the mi_interp's uiout, since the command could  	     have reset the interpreter, in which case the current uiout  	     will most likely crash in the mi_out_* routines.  */
if|if
condition|(
name|args
operator|->
name|rc
operator|==
name|MI_CMD_DONE
condition|)
block|{
name|fputs_unfiltered
argument_list|(
name|context
operator|->
name|token
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
literal|"^done"
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|mi_out_put
argument_list|(
name|uiout
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|mi_out_rewind
argument_list|(
name|uiout
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
literal|"\n"
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|args
operator|->
name|rc
operator|==
name|MI_CMD_ERROR
condition|)
block|{
if|if
condition|(
name|mi_error_message
condition|)
block|{
name|fputs_unfiltered
argument_list|(
name|context
operator|->
name|token
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
literal|"^error,msg=\""
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|fputstr_unfiltered
argument_list|(
name|mi_error_message
argument_list|,
literal|'"'
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|mi_error_message
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
literal|"\"\n"
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
block|}
name|mi_out_rewind
argument_list|(
name|uiout
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|args
operator|->
name|rc
operator|==
name|MI_CMD_CAUGHT_ERROR
condition|)
block|{
name|mi_out_rewind
argument_list|(
name|uiout
argument_list|)
expr_stmt|;
name|args
operator|->
name|action
operator|=
name|EXECUTE_COMMAND_DISPLAY_ERROR
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
name|mi_out_rewind
argument_list|(
name|uiout
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sync_execution
condition|)
block|{
comment|/* Don't print the prompt. We are executing the target in 	     synchronous mode. */
name|args
operator|->
name|action
operator|=
name|EXECUTE_COMMAND_SUPRESS_PROMPT
expr_stmt|;
return|return
literal|1
return|;
block|}
break|break;
case|case
name|CLI_COMMAND
case|:
comment|/* A CLI command was read from the input stream */
comment|/* This will be removed as soon as we have a complete set of          mi commands */
comment|/* echo the command on the console. */
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"%s\n"
argument_list|,
name|context
operator|->
name|command
argument_list|)
expr_stmt|;
name|mi_execute_cli_command
argument_list|(
name|context
operator|->
name|command
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* If we changed interpreters, DON'T print out anything. */
if|if
condition|(
name|current_interp_named_p
argument_list|(
name|INTERP_MI
argument_list|)
operator|||
name|current_interp_named_p
argument_list|(
name|INTERP_MI1
argument_list|)
operator|||
name|current_interp_named_p
argument_list|(
name|INTERP_MI2
argument_list|)
operator|||
name|current_interp_named_p
argument_list|(
name|INTERP_MI3
argument_list|)
condition|)
block|{
comment|/* print the result */
comment|/* FIXME: Check for errors here. */
name|fputs_unfiltered
argument_list|(
name|context
operator|->
name|token
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
literal|"^done"
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|mi_out_put
argument_list|(
name|uiout
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|mi_out_rewind
argument_list|(
name|uiout
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
literal|"\n"
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|args
operator|->
name|action
operator|=
name|EXECUTE_COMMAND_DISPLAY_PROMPT
expr_stmt|;
name|args
operator|->
name|rc
operator|=
name|MI_CMD_DONE
expr_stmt|;
block|}
break|break;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|mi_execute_command
parameter_list|(
name|char
modifier|*
name|cmd
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|mi_parse
modifier|*
name|command
decl_stmt|;
name|struct
name|captured_mi_execute_command_args
name|args
decl_stmt|;
name|struct
name|ui_out
modifier|*
name|saved_uiout
init|=
name|uiout
decl_stmt|;
name|int
name|result
decl_stmt|;
comment|/* This is to handle EOF (^D). We just quit gdb. */
comment|/* FIXME: we should call some API function here. */
if|if
condition|(
name|cmd
operator|==
literal|0
condition|)
name|quit_force
argument_list|(
name|NULL
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
name|command
operator|=
name|mi_parse
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|command
operator|!=
name|NULL
condition|)
block|{
comment|/* FIXME: cagney/1999-11-04: Can this use of catch_exceptions either          be pushed even further down or even eliminated? */
name|args
operator|.
name|command
operator|=
name|command
expr_stmt|;
name|result
operator|=
name|catch_exceptions
argument_list|(
name|uiout
argument_list|,
name|captured_mi_execute_command
argument_list|,
operator|&
name|args
argument_list|,
literal|""
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|.
name|action
operator|==
name|EXECUTE_COMMAND_SUPRESS_PROMPT
condition|)
block|{
comment|/* The command is executing synchronously.  Bail out early 	     suppressing the finished prompt. */
name|mi_parse_free
argument_list|(
name|command
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|args
operator|.
name|action
operator|==
name|EXECUTE_COMMAND_DISPLAY_ERROR
operator|||
name|result
operator|<
literal|0
condition|)
block|{
name|char
modifier|*
name|msg
init|=
name|error_last_message
argument_list|()
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|cleanup
init|=
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|msg
argument_list|)
decl_stmt|;
comment|/* The command execution failed and error() was called 	     somewhere */
name|fputs_unfiltered
argument_list|(
name|command
operator|->
name|token
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
literal|"^error,msg=\""
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|fputstr_unfiltered
argument_list|(
name|msg
argument_list|,
literal|'"'
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
literal|"\"\n"
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
block|}
name|mi_parse_free
argument_list|(
name|command
argument_list|)
expr_stmt|;
block|}
name|fputs_unfiltered
argument_list|(
literal|"(gdb) \n"
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|raw_stdout
argument_list|)
expr_stmt|;
comment|/* print any buffered hook code */
comment|/* ..... */
block|}
end_function

begin_function
specifier|static
name|enum
name|mi_cmd_result
name|mi_cmd_execute
parameter_list|(
name|struct
name|mi_parse
modifier|*
name|parse
parameter_list|)
block|{
if|if
condition|(
name|parse
operator|->
name|cmd
operator|->
name|argv_func
operator|!=
name|NULL
operator|||
name|parse
operator|->
name|cmd
operator|->
name|args_func
operator|!=
name|NULL
condition|)
block|{
comment|/* FIXME: We need to save the token because the command executed          may be asynchronous and need to print the token again.          In the future we can pass the token down to the func          and get rid of the last_async_command */
comment|/* The problem here is to keep the token around when we launch          the target, and we want to interrupt it later on.  The          interrupt command will have its own token, but when the          target stops, we must display the token corresponding to the          last execution command given. So we have another string where          we copy the token (previous_async_command), if this was          indeed the token of an execution command, and when we stop we          print that one. This is possible because the interrupt          command, when over, will copy that token back into the          default token string (last_async_command). */
if|if
condition|(
name|target_executing
condition|)
block|{
if|if
condition|(
operator|!
name|previous_async_command
condition|)
name|previous_async_command
operator|=
name|xstrdup
argument_list|(
name|last_async_command
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|parse
operator|->
name|command
argument_list|,
literal|"exec-interrupt"
argument_list|)
condition|)
block|{
name|fputs_unfiltered
argument_list|(
name|parse
operator|->
name|token
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
literal|"^error,msg=\""
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
literal|"Cannot execute command "
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|fputstr_unfiltered
argument_list|(
name|parse
operator|->
name|command
argument_list|,
literal|'"'
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
literal|" while target running"
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
literal|"\"\n"
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
return|return
name|MI_CMD_ERROR
return|;
block|}
block|}
name|last_async_command
operator|=
name|xstrdup
argument_list|(
name|parse
operator|->
name|token
argument_list|)
expr_stmt|;
name|make_exec_cleanup
argument_list|(
name|free_current_contents
argument_list|,
operator|&
name|last_async_command
argument_list|)
expr_stmt|;
comment|/* FIXME: DELETE THIS! */
if|if
condition|(
name|parse
operator|->
name|cmd
operator|->
name|args_func
operator|!=
name|NULL
condition|)
return|return
name|parse
operator|->
name|cmd
operator|->
name|args_func
argument_list|(
name|parse
operator|->
name|args
argument_list|,
literal|0
comment|/*from_tty */
argument_list|)
return|;
return|return
name|parse
operator|->
name|cmd
operator|->
name|argv_func
argument_list|(
name|parse
operator|->
name|command
argument_list|,
name|parse
operator|->
name|argv
argument_list|,
name|parse
operator|->
name|argc
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|parse
operator|->
name|cmd
operator|->
name|cli
operator|.
name|cmd
operator|!=
literal|0
condition|)
block|{
comment|/* FIXME: DELETE THIS. */
comment|/* The operation is still implemented by a cli command */
comment|/* Must be a synchronous one */
name|mi_execute_cli_command
argument_list|(
name|parse
operator|->
name|cmd
operator|->
name|cli
operator|.
name|cmd
argument_list|,
name|parse
operator|->
name|cmd
operator|->
name|cli
operator|.
name|args_p
argument_list|,
name|parse
operator|->
name|args
argument_list|)
expr_stmt|;
return|return
name|MI_CMD_DONE
return|;
block|}
else|else
block|{
comment|/* FIXME: DELETE THIS. */
name|fputs_unfiltered
argument_list|(
name|parse
operator|->
name|token
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
literal|"^error,msg=\""
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
literal|"Undefined mi command: "
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|fputstr_unfiltered
argument_list|(
name|parse
operator|->
name|command
argument_list|,
literal|'"'
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
literal|" (missing implementation)"
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
literal|"\"\n"
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
return|return
name|MI_CMD_ERROR
return|;
block|}
block|}
end_function

begin_comment
comment|/* FIXME: This is just a hack so we can get some extra commands going.    We don't want to channel things through the CLI, but call libgdb directly */
end_comment

begin_comment
comment|/* Use only for synchronous commands */
end_comment

begin_function
name|void
name|mi_execute_cli_command
parameter_list|(
specifier|const
name|char
modifier|*
name|cmd
parameter_list|,
name|int
name|args_p
parameter_list|,
specifier|const
name|char
modifier|*
name|args
parameter_list|)
block|{
if|if
condition|(
name|cmd
operator|!=
literal|0
condition|)
block|{
name|struct
name|cleanup
modifier|*
name|old_cleanups
decl_stmt|;
name|char
modifier|*
name|run
decl_stmt|;
if|if
condition|(
name|args_p
condition|)
name|xasprintf
argument_list|(
operator|&
name|run
argument_list|,
literal|"%s %s"
argument_list|,
name|cmd
argument_list|,
name|args
argument_list|)
expr_stmt|;
else|else
name|run
operator|=
name|xstrdup
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|mi_debug_p
condition|)
comment|/* FIXME: gdb_???? */
name|fprintf_unfiltered
argument_list|(
name|gdb_stdout
argument_list|,
literal|"cli=%s run=%s\n"
argument_list|,
name|cmd
argument_list|,
name|run
argument_list|)
expr_stmt|;
name|old_cleanups
operator|=
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|run
argument_list|)
expr_stmt|;
name|execute_command
argument_list|(
comment|/*ui */
name|run
argument_list|,
literal|0
comment|/*from_tty */
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_cleanups
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_function
name|enum
name|mi_cmd_result
name|mi_execute_async_cli_command
parameter_list|(
name|char
modifier|*
name|mi
parameter_list|,
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|cleanup
modifier|*
name|old_cleanups
decl_stmt|;
name|char
modifier|*
name|run
decl_stmt|;
name|char
modifier|*
name|async_args
decl_stmt|;
if|if
condition|(
name|target_can_async_p
argument_list|()
condition|)
block|{
name|async_args
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|args
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|make_exec_cleanup
argument_list|(
name|free
argument_list|,
name|async_args
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|async_args
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|async_args
argument_list|,
literal|"&"
argument_list|)
expr_stmt|;
name|xasprintf
argument_list|(
operator|&
name|run
argument_list|,
literal|"%s %s"
argument_list|,
name|mi
argument_list|,
name|async_args
argument_list|)
expr_stmt|;
name|make_exec_cleanup
argument_list|(
name|free
argument_list|,
name|run
argument_list|)
expr_stmt|;
name|add_continuation
argument_list|(
name|mi_exec_async_cli_cmd_continuation
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|old_cleanups
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|xasprintf
argument_list|(
operator|&
name|run
argument_list|,
literal|"%s %s"
argument_list|,
name|mi
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|old_cleanups
operator|=
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|run
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|target_can_async_p
argument_list|()
condition|)
block|{
comment|/* NOTE: For synchronous targets asynchronous behavour is faked by          printing out the GDB prompt before we even try to execute the          command. */
if|if
condition|(
name|last_async_command
condition|)
name|fputs_unfiltered
argument_list|(
name|last_async_command
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
literal|"^running\n"
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
literal|"(gdb) \n"
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|raw_stdout
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* FIXME: cagney/1999-11-29: Printing this message before          calling execute_command is wrong.  It should only be printed          once gdb has confirmed that it really has managed to send a          run command to the target. */
if|if
condition|(
name|last_async_command
condition|)
name|fputs_unfiltered
argument_list|(
name|last_async_command
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
literal|"^running\n"
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
block|}
name|execute_command
argument_list|(
comment|/*ui */
name|run
argument_list|,
literal|0
comment|/*from_tty */
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target_can_async_p
argument_list|()
condition|)
block|{
comment|/* Do this before doing any printing.  It would appear that some          print code leaves garbage around in the buffer. */
name|do_cleanups
argument_list|(
name|old_cleanups
argument_list|)
expr_stmt|;
comment|/* If the target was doing the operation synchronously we fake          the stopped message. */
if|if
condition|(
name|last_async_command
condition|)
name|fputs_unfiltered
argument_list|(
name|last_async_command
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
literal|"*stopped"
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|mi_out_put
argument_list|(
name|uiout
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|mi_out_rewind
argument_list|(
name|uiout
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
literal|"\n"
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
return|return
name|MI_CMD_QUIET
return|;
block|}
return|return
name|MI_CMD_DONE
return|;
block|}
end_function

begin_function
name|void
name|mi_exec_async_cli_cmd_continuation
parameter_list|(
name|struct
name|continuation_arg
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
name|last_async_command
condition|)
name|fputs_unfiltered
argument_list|(
name|last_async_command
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
literal|"*stopped"
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|mi_out_put
argument_list|(
name|uiout
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
literal|"\n"
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
literal|"(gdb) \n"
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|raw_stdout
argument_list|)
expr_stmt|;
name|do_exec_cleanups
argument_list|(
name|ALL_CLEANUPS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mi_load_progress
parameter_list|(
specifier|const
name|char
modifier|*
name|section_name
parameter_list|,
name|unsigned
name|long
name|sent_so_far
parameter_list|,
name|unsigned
name|long
name|total_section
parameter_list|,
name|unsigned
name|long
name|total_sent
parameter_list|,
name|unsigned
name|long
name|grand_total
parameter_list|)
block|{
name|struct
name|timeval
name|time_now
decl_stmt|,
name|delta
decl_stmt|,
name|update_threshold
decl_stmt|;
specifier|static
name|struct
name|timeval
name|last_update
decl_stmt|;
specifier|static
name|char
modifier|*
name|previous_sect_name
init|=
name|NULL
decl_stmt|;
name|int
name|new_section
decl_stmt|;
if|if
condition|(
operator|!
name|current_interp_named_p
argument_list|(
name|INTERP_MI
argument_list|)
operator|&&
operator|!
name|current_interp_named_p
argument_list|(
name|INTERP_MI1
argument_list|)
condition|)
return|return;
name|update_threshold
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|update_threshold
operator|.
name|tv_usec
operator|=
literal|500000
expr_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|time_now
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|delta
operator|.
name|tv_usec
operator|=
name|time_now
operator|.
name|tv_usec
operator|-
name|last_update
operator|.
name|tv_usec
expr_stmt|;
name|delta
operator|.
name|tv_sec
operator|=
name|time_now
operator|.
name|tv_sec
operator|-
name|last_update
operator|.
name|tv_sec
expr_stmt|;
if|if
condition|(
name|delta
operator|.
name|tv_usec
operator|<
literal|0
condition|)
block|{
name|delta
operator|.
name|tv_sec
operator|-=
literal|1
expr_stmt|;
name|delta
operator|.
name|tv_usec
operator|+=
literal|1000000
expr_stmt|;
block|}
name|new_section
operator|=
operator|(
name|previous_sect_name
condition|?
name|strcmp
argument_list|(
name|previous_sect_name
argument_list|,
name|section_name
argument_list|)
else|:
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|new_section
condition|)
block|{
name|struct
name|cleanup
modifier|*
name|cleanup_tuple
decl_stmt|;
name|xfree
argument_list|(
name|previous_sect_name
argument_list|)
expr_stmt|;
name|previous_sect_name
operator|=
name|xstrdup
argument_list|(
name|section_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_async_command
condition|)
name|fputs_unfiltered
argument_list|(
name|last_async_command
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
literal|"+download"
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|cleanup_tuple
operator|=
name|make_cleanup_ui_out_tuple_begin_end
argument_list|(
name|uiout
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ui_out_field_string
argument_list|(
name|uiout
argument_list|,
literal|"section"
argument_list|,
name|section_name
argument_list|)
expr_stmt|;
name|ui_out_field_int
argument_list|(
name|uiout
argument_list|,
literal|"section-size"
argument_list|,
name|total_section
argument_list|)
expr_stmt|;
name|ui_out_field_int
argument_list|(
name|uiout
argument_list|,
literal|"total-size"
argument_list|,
name|grand_total
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|cleanup_tuple
argument_list|)
expr_stmt|;
name|mi_out_put
argument_list|(
name|uiout
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
literal|"\n"
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|raw_stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|delta
operator|.
name|tv_sec
operator|>=
name|update_threshold
operator|.
name|tv_sec
operator|&&
name|delta
operator|.
name|tv_usec
operator|>=
name|update_threshold
operator|.
name|tv_usec
condition|)
block|{
name|struct
name|cleanup
modifier|*
name|cleanup_tuple
decl_stmt|;
name|last_update
operator|.
name|tv_sec
operator|=
name|time_now
operator|.
name|tv_sec
expr_stmt|;
name|last_update
operator|.
name|tv_usec
operator|=
name|time_now
operator|.
name|tv_usec
expr_stmt|;
if|if
condition|(
name|last_async_command
condition|)
name|fputs_unfiltered
argument_list|(
name|last_async_command
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
literal|"+download"
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|cleanup_tuple
operator|=
name|make_cleanup_ui_out_tuple_begin_end
argument_list|(
name|uiout
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ui_out_field_string
argument_list|(
name|uiout
argument_list|,
literal|"section"
argument_list|,
name|section_name
argument_list|)
expr_stmt|;
name|ui_out_field_int
argument_list|(
name|uiout
argument_list|,
literal|"section-sent"
argument_list|,
name|sent_so_far
argument_list|)
expr_stmt|;
name|ui_out_field_int
argument_list|(
name|uiout
argument_list|,
literal|"section-size"
argument_list|,
name|total_section
argument_list|)
expr_stmt|;
name|ui_out_field_int
argument_list|(
name|uiout
argument_list|,
literal|"total-sent"
argument_list|,
name|total_sent
argument_list|)
expr_stmt|;
name|ui_out_field_int
argument_list|(
name|uiout
argument_list|,
literal|"total-size"
argument_list|,
name|grand_total
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|cleanup_tuple
argument_list|)
expr_stmt|;
name|mi_out_put
argument_list|(
name|uiout
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
literal|"\n"
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|raw_stdout
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|mi_setup_architecture_data
parameter_list|(
name|void
parameter_list|)
block|{
name|old_regs
operator|=
name|xmalloc
argument_list|(
operator|(
name|NUM_REGS
operator|+
name|NUM_PSEUDO_REGS
operator|)
operator|*
name|MAX_REGISTER_SIZE
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|old_regs
argument_list|,
literal|0
argument_list|,
operator|(
name|NUM_REGS
operator|+
name|NUM_PSEUDO_REGS
operator|)
operator|*
name|MAX_REGISTER_SIZE
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_initialize_mi_main
parameter_list|(
name|void
parameter_list|)
block|{
name|DEPRECATED_REGISTER_GDBARCH_SWAP
argument_list|(
name|old_regs
argument_list|)
expr_stmt|;
name|deprecated_register_gdbarch_swap
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|mi_setup_architecture_data
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

