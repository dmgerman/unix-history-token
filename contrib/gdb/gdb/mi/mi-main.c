begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* MI Command Set.    Copyright 2000, 2001, 2002 Free Software Foundation, Inc.    Contributed by Cygnus Solutions (a Red Hat company).     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* Work in progress */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"top.h"
end_include

begin_include
include|#
directive|include
file|"gdbthread.h"
end_include

begin_include
include|#
directive|include
file|"mi-cmds.h"
end_include

begin_include
include|#
directive|include
file|"mi-parse.h"
end_include

begin_include
include|#
directive|include
file|"mi-getopt.h"
end_include

begin_include
include|#
directive|include
file|"mi-console.h"
end_include

begin_include
include|#
directive|include
file|"ui-out.h"
end_include

begin_include
include|#
directive|include
file|"mi-out.h"
end_include

begin_include
include|#
directive|include
file|"event-loop.h"
end_include

begin_include
include|#
directive|include
file|"event-top.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_comment
comment|/* for write_memory() */
end_comment

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_comment
comment|/* for write_register_bytes() */
end_comment

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_include
include|#
directive|include
file|"gdb.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_comment
comment|/* Convenience macro for allocting typesafe memory. */
end_comment

begin_undef
undef|#
directive|undef
name|XMALLOC
end_undef

begin_define
define|#
directive|define
name|XMALLOC
parameter_list|(
name|TYPE
parameter_list|)
value|(TYPE*) xmalloc (sizeof (TYPE))
end_define

begin_enum
enum|enum
block|{
name|FROM_TTY
init|=
literal|0
block|}
enum|;
end_enum

begin_decl_stmt
name|int
name|mi_debug_p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ui_file
modifier|*
name|raw_stdout
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The token of the last asynchronous command */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|last_async_command
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|previous_async_command
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|mi_error_message
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|old_regs
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|void
name|_initialize_mi_main
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|mi_input
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mi_execute_command
parameter_list|(
name|char
modifier|*
name|cmd
parameter_list|,
name|int
name|from_tty
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|mi_cmd_result
name|mi_cmd_execute
parameter_list|(
name|struct
name|mi_parse
modifier|*
name|parse
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mi_execute_cli_command
parameter_list|(
specifier|const
name|char
modifier|*
name|cli
parameter_list|,
name|char
modifier|*
name|args
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|mi_cmd_result
name|mi_execute_async_cli_command
parameter_list|(
name|char
modifier|*
name|mi
parameter_list|,
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mi_execute_command_wrapper
parameter_list|(
name|char
modifier|*
name|cmd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|mi_exec_async_cli_cmd_continuation
parameter_list|(
name|struct
name|continuation_arg
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|register_changed_p
parameter_list|(
name|int
name|regnum
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_register
parameter_list|(
name|int
name|regnum
parameter_list|,
name|int
name|format
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mi_load_progress
parameter_list|(
specifier|const
name|char
modifier|*
name|section_name
parameter_list|,
name|unsigned
name|long
name|sent_so_far
parameter_list|,
name|unsigned
name|long
name|total_section
parameter_list|,
name|unsigned
name|long
name|total_sent
parameter_list|,
name|unsigned
name|long
name|grand_total
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* FIXME: these should go in some .h file, but infcmd.c doesn't have a    corresponding .h file. These wrappers will be obsolete anyway, once    we pull the plug on the sanitization. */
end_comment

begin_function_decl
specifier|extern
name|void
name|interrupt_target_command_wrapper
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|return_command_wrapper
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Command implementations. FIXME: Is this libgdb? No.  This is the MI    layer that calls libgdb.  Any operation used in the below should be    formalized. */
end_comment

begin_function
name|enum
name|mi_cmd_result
name|mi_cmd_gdb_exit
parameter_list|(
name|char
modifier|*
name|command
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|int
name|argc
parameter_list|)
block|{
comment|/* We have to print everything right here because we never return */
if|if
condition|(
name|last_async_command
condition|)
name|fputs_unfiltered
argument_list|(
name|last_async_command
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
literal|"^exit\n"
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|mi_out_put
argument_list|(
name|uiout
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
comment|/* FIXME: The function called is not yet a formal libgdb function */
name|quit_force
argument_list|(
name|NULL
argument_list|,
name|FROM_TTY
argument_list|)
expr_stmt|;
return|return
name|MI_CMD_DONE
return|;
block|}
end_function

begin_function
name|enum
name|mi_cmd_result
name|mi_cmd_exec_run
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
comment|/* FIXME: Should call a libgdb function, not a cli wrapper */
return|return
name|mi_execute_async_cli_command
argument_list|(
literal|"run"
argument_list|,
name|args
argument_list|,
name|from_tty
argument_list|)
return|;
block|}
end_function

begin_function
name|enum
name|mi_cmd_result
name|mi_cmd_exec_next
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
comment|/* FIXME: Should call a libgdb function, not a cli wrapper */
return|return
name|mi_execute_async_cli_command
argument_list|(
literal|"next"
argument_list|,
name|args
argument_list|,
name|from_tty
argument_list|)
return|;
block|}
end_function

begin_function
name|enum
name|mi_cmd_result
name|mi_cmd_exec_next_instruction
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
comment|/* FIXME: Should call a libgdb function, not a cli wrapper */
return|return
name|mi_execute_async_cli_command
argument_list|(
literal|"nexti"
argument_list|,
name|args
argument_list|,
name|from_tty
argument_list|)
return|;
block|}
end_function

begin_function
name|enum
name|mi_cmd_result
name|mi_cmd_exec_step
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
comment|/* FIXME: Should call a libgdb function, not a cli wrapper */
return|return
name|mi_execute_async_cli_command
argument_list|(
literal|"step"
argument_list|,
name|args
argument_list|,
name|from_tty
argument_list|)
return|;
block|}
end_function

begin_function
name|enum
name|mi_cmd_result
name|mi_cmd_exec_step_instruction
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
comment|/* FIXME: Should call a libgdb function, not a cli wrapper */
return|return
name|mi_execute_async_cli_command
argument_list|(
literal|"stepi"
argument_list|,
name|args
argument_list|,
name|from_tty
argument_list|)
return|;
block|}
end_function

begin_function
name|enum
name|mi_cmd_result
name|mi_cmd_exec_finish
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
comment|/* FIXME: Should call a libgdb function, not a cli wrapper */
return|return
name|mi_execute_async_cli_command
argument_list|(
literal|"finish"
argument_list|,
name|args
argument_list|,
name|from_tty
argument_list|)
return|;
block|}
end_function

begin_function
name|enum
name|mi_cmd_result
name|mi_cmd_exec_until
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
comment|/* FIXME: Should call a libgdb function, not a cli wrapper */
return|return
name|mi_execute_async_cli_command
argument_list|(
literal|"until"
argument_list|,
name|args
argument_list|,
name|from_tty
argument_list|)
return|;
block|}
end_function

begin_function
name|enum
name|mi_cmd_result
name|mi_cmd_exec_return
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
comment|/* This command doesn't really execute the target, it just pops the      specified number of frames. */
if|if
condition|(
operator|*
name|args
condition|)
comment|/* Call return_command with from_tty argument equal to 0 so as to        avoid being queried. */
name|return_command_wrapper
argument_list|(
name|args
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
comment|/* Call return_command with from_tty argument equal to 0 so as to        avoid being queried. */
name|return_command_wrapper
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Because we have called return_command with from_tty = 0, we need      to print the frame here. */
name|show_and_print_stack_frame
argument_list|(
name|selected_frame
argument_list|,
name|selected_frame_level
argument_list|,
name|LOC_AND_ADDRESS
argument_list|)
expr_stmt|;
return|return
name|MI_CMD_DONE
return|;
block|}
end_function

begin_function
name|enum
name|mi_cmd_result
name|mi_cmd_exec_continue
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
comment|/* FIXME: Should call a libgdb function, not a cli wrapper */
return|return
name|mi_execute_async_cli_command
argument_list|(
literal|"continue"
argument_list|,
name|args
argument_list|,
name|from_tty
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Interrupt the execution of the target. Note how we must play around    with the token varialbes, in order to display the current token in    the result of the interrupt command, and the previous execution    token when the target finally stops. See comments in    mi_cmd_execute. */
end_comment

begin_function
name|enum
name|mi_cmd_result
name|mi_cmd_exec_interrupt
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
if|if
condition|(
operator|!
name|target_executing
condition|)
block|{
name|xasprintf
argument_list|(
operator|&
name|mi_error_message
argument_list|,
literal|"mi_cmd_exec_interrupt: Inferior not executing."
argument_list|)
expr_stmt|;
return|return
name|MI_CMD_ERROR
return|;
block|}
name|interrupt_target_command_wrapper
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_async_command
condition|)
name|fputs_unfiltered
argument_list|(
name|last_async_command
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
literal|"^done"
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|last_async_command
argument_list|)
expr_stmt|;
if|if
condition|(
name|previous_async_command
condition|)
name|last_async_command
operator|=
name|xstrdup
argument_list|(
name|previous_async_command
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|previous_async_command
argument_list|)
expr_stmt|;
name|previous_async_command
operator|=
name|NULL
expr_stmt|;
name|mi_out_put
argument_list|(
name|uiout
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|mi_out_rewind
argument_list|(
name|uiout
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
literal|"\n"
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
return|return
name|MI_CMD_QUIET
return|;
block|}
end_function

begin_function
name|enum
name|mi_cmd_result
name|mi_cmd_thread_select
parameter_list|(
name|char
modifier|*
name|command
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|int
name|argc
parameter_list|)
block|{
name|enum
name|gdb_rc
name|rc
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|1
condition|)
block|{
name|xasprintf
argument_list|(
operator|&
name|mi_error_message
argument_list|,
literal|"mi_cmd_thread_select: USAGE: threadnum."
argument_list|)
expr_stmt|;
return|return
name|MI_CMD_ERROR
return|;
block|}
else|else
name|rc
operator|=
name|gdb_thread_select
argument_list|(
name|uiout
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
name|GDB_RC_FAIL
condition|)
return|return
name|MI_CMD_CAUGHT_ERROR
return|;
else|else
return|return
name|MI_CMD_DONE
return|;
block|}
end_function

begin_function
name|enum
name|mi_cmd_result
name|mi_cmd_thread_list_ids
parameter_list|(
name|char
modifier|*
name|command
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|int
name|argc
parameter_list|)
block|{
name|enum
name|gdb_rc
name|rc
init|=
name|MI_CMD_DONE
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|0
condition|)
block|{
name|xasprintf
argument_list|(
operator|&
name|mi_error_message
argument_list|,
literal|"mi_cmd_thread_list_ids: No arguments required."
argument_list|)
expr_stmt|;
return|return
name|MI_CMD_ERROR
return|;
block|}
else|else
name|rc
operator|=
name|gdb_list_thread_ids
argument_list|(
name|uiout
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
name|GDB_RC_FAIL
condition|)
return|return
name|MI_CMD_CAUGHT_ERROR
return|;
else|else
return|return
name|MI_CMD_DONE
return|;
block|}
end_function

begin_function
name|enum
name|mi_cmd_result
name|mi_cmd_data_list_register_names
parameter_list|(
name|char
modifier|*
name|command
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|int
name|argc
parameter_list|)
block|{
name|int
name|regnum
decl_stmt|,
name|numregs
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Note that the test for a valid register must include checking the      REGISTER_NAME because NUM_REGS may be allocated for the union of      the register sets within a family of related processors.  In this      case, some entries of REGISTER_NAME will change depending upon      the particular processor being debugged.  */
name|numregs
operator|=
name|NUM_REGS
operator|+
name|NUM_PSEUDO_REGS
expr_stmt|;
name|ui_out_list_begin
argument_list|(
name|uiout
argument_list|,
literal|"register-names"
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
comment|/* No args, just do all the regs */
block|{
for|for
control|(
name|regnum
operator|=
literal|0
init|;
name|regnum
operator|<
name|numregs
condition|;
name|regnum
operator|++
control|)
block|{
if|if
condition|(
name|REGISTER_NAME
argument_list|(
name|regnum
argument_list|)
operator|==
name|NULL
operator|||
operator|*
operator|(
name|REGISTER_NAME
argument_list|(
name|regnum
argument_list|)
operator|)
operator|==
literal|'\0'
condition|)
name|ui_out_field_string
argument_list|(
name|uiout
argument_list|,
name|NULL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
else|else
name|ui_out_field_string
argument_list|(
name|uiout
argument_list|,
name|NULL
argument_list|,
name|REGISTER_NAME
argument_list|(
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Else, list of register #s, just do listed regs */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|regnum
operator|=
name|atoi
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|regnum
operator|<
literal|0
operator|||
name|regnum
operator|>=
name|numregs
condition|)
block|{
name|xasprintf
argument_list|(
operator|&
name|mi_error_message
argument_list|,
literal|"bad register number"
argument_list|)
expr_stmt|;
return|return
name|MI_CMD_ERROR
return|;
block|}
if|if
condition|(
name|REGISTER_NAME
argument_list|(
name|regnum
argument_list|)
operator|==
name|NULL
operator|||
operator|*
operator|(
name|REGISTER_NAME
argument_list|(
name|regnum
argument_list|)
operator|)
operator|==
literal|'\0'
condition|)
name|ui_out_field_string
argument_list|(
name|uiout
argument_list|,
name|NULL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
else|else
name|ui_out_field_string
argument_list|(
name|uiout
argument_list|,
name|NULL
argument_list|,
name|REGISTER_NAME
argument_list|(
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ui_out_list_end
argument_list|(
name|uiout
argument_list|)
expr_stmt|;
return|return
name|MI_CMD_DONE
return|;
block|}
end_function

begin_function
name|enum
name|mi_cmd_result
name|mi_cmd_data_list_changed_registers
parameter_list|(
name|char
modifier|*
name|command
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|int
name|argc
parameter_list|)
block|{
name|int
name|regnum
decl_stmt|,
name|numregs
decl_stmt|,
name|changed
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Note that the test for a valid register must include checking the      REGISTER_NAME because NUM_REGS may be allocated for the union of      the register sets within a family of related processors.  In this      case, some entries of REGISTER_NAME will change depending upon      the particular processor being debugged.  */
name|numregs
operator|=
name|NUM_REGS
expr_stmt|;
name|ui_out_list_begin
argument_list|(
name|uiout
argument_list|,
literal|"changed-registers"
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
comment|/* No args, just do all the regs */
block|{
for|for
control|(
name|regnum
operator|=
literal|0
init|;
name|regnum
operator|<
name|numregs
condition|;
name|regnum
operator|++
control|)
block|{
if|if
condition|(
name|REGISTER_NAME
argument_list|(
name|regnum
argument_list|)
operator|==
name|NULL
operator|||
operator|*
operator|(
name|REGISTER_NAME
argument_list|(
name|regnum
argument_list|)
operator|)
operator|==
literal|'\0'
condition|)
continue|continue;
name|changed
operator|=
name|register_changed_p
argument_list|(
name|regnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|changed
operator|<
literal|0
condition|)
block|{
name|xasprintf
argument_list|(
operator|&
name|mi_error_message
argument_list|,
literal|"mi_cmd_data_list_changed_registers: Unable to read register contents."
argument_list|)
expr_stmt|;
return|return
name|MI_CMD_ERROR
return|;
block|}
elseif|else
if|if
condition|(
name|changed
condition|)
name|ui_out_field_int
argument_list|(
name|uiout
argument_list|,
name|NULL
argument_list|,
name|regnum
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Else, list of register #s, just do listed regs */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|regnum
operator|=
name|atoi
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|regnum
operator|>=
literal|0
operator|&&
name|regnum
operator|<
name|numregs
operator|&&
name|REGISTER_NAME
argument_list|(
name|regnum
argument_list|)
operator|!=
name|NULL
operator|&&
operator|*
name|REGISTER_NAME
argument_list|(
name|regnum
argument_list|)
operator|!=
literal|'\000'
condition|)
block|{
name|changed
operator|=
name|register_changed_p
argument_list|(
name|regnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|changed
operator|<
literal|0
condition|)
block|{
name|xasprintf
argument_list|(
operator|&
name|mi_error_message
argument_list|,
literal|"mi_cmd_data_list_register_change: Unable to read register contents."
argument_list|)
expr_stmt|;
return|return
name|MI_CMD_ERROR
return|;
block|}
elseif|else
if|if
condition|(
name|changed
condition|)
name|ui_out_field_int
argument_list|(
name|uiout
argument_list|,
name|NULL
argument_list|,
name|regnum
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xasprintf
argument_list|(
operator|&
name|mi_error_message
argument_list|,
literal|"bad register number"
argument_list|)
expr_stmt|;
return|return
name|MI_CMD_ERROR
return|;
block|}
block|}
name|ui_out_list_end
argument_list|(
name|uiout
argument_list|)
expr_stmt|;
return|return
name|MI_CMD_DONE
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|register_changed_p
parameter_list|(
name|int
name|regnum
parameter_list|)
block|{
name|char
modifier|*
name|raw_buffer
init|=
name|alloca
argument_list|(
name|MAX_REGISTER_RAW_SIZE
argument_list|)
decl_stmt|;
if|if
condition|(
name|read_relative_register_raw_bytes
argument_list|(
name|regnum
argument_list|,
name|raw_buffer
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|memcmp
argument_list|(
operator|&
name|old_regs
index|[
name|REGISTER_BYTE
argument_list|(
name|regnum
argument_list|)
index|]
argument_list|,
name|raw_buffer
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Found a changed register. Return 1. */
name|memcpy
argument_list|(
operator|&
name|old_regs
index|[
name|REGISTER_BYTE
argument_list|(
name|regnum
argument_list|)
index|]
argument_list|,
name|raw_buffer
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return a list of register number and value pairs. The valid    arguments expected are: a letter indicating the format in which to    display the registers contents. This can be one of: x (hexadecimal), d    (decimal), N (natural), t (binary), o (octal), r (raw).  After the    format argumetn there can be a sequence of numbers, indicating which    registers to fetch the content of. If the format is the only argument,    a list of all the registers with their values is returned. */
end_comment

begin_function
name|enum
name|mi_cmd_result
name|mi_cmd_data_list_register_values
parameter_list|(
name|char
modifier|*
name|command
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|int
name|argc
parameter_list|)
block|{
name|int
name|regnum
decl_stmt|,
name|numregs
decl_stmt|,
name|format
decl_stmt|,
name|result
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Note that the test for a valid register must include checking the      REGISTER_NAME because NUM_REGS may be allocated for the union of      the register sets within a family of related processors.  In this      case, some entries of REGISTER_NAME will change depending upon      the particular processor being debugged.  */
name|numregs
operator|=
name|NUM_REGS
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
block|{
name|xasprintf
argument_list|(
operator|&
name|mi_error_message
argument_list|,
literal|"mi_cmd_data_list_register_values: Usage: -data-list-register-values<format> [<regnum1>...<regnumN>]"
argument_list|)
expr_stmt|;
return|return
name|MI_CMD_ERROR
return|;
block|}
name|format
operator|=
operator|(
name|int
operator|)
name|argv
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|target_has_registers
condition|)
block|{
name|xasprintf
argument_list|(
operator|&
name|mi_error_message
argument_list|,
literal|"mi_cmd_data_list_register_values: No registers."
argument_list|)
expr_stmt|;
return|return
name|MI_CMD_ERROR
return|;
block|}
name|ui_out_list_begin
argument_list|(
name|uiout
argument_list|,
literal|"register-values"
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|1
condition|)
comment|/* No args, beside the format: do all the regs */
block|{
for|for
control|(
name|regnum
operator|=
literal|0
init|;
name|regnum
operator|<
name|numregs
condition|;
name|regnum
operator|++
control|)
block|{
if|if
condition|(
name|REGISTER_NAME
argument_list|(
name|regnum
argument_list|)
operator|==
name|NULL
operator|||
operator|*
operator|(
name|REGISTER_NAME
argument_list|(
name|regnum
argument_list|)
operator|)
operator|==
literal|'\0'
condition|)
continue|continue;
name|ui_out_tuple_begin
argument_list|(
name|uiout
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ui_out_field_int
argument_list|(
name|uiout
argument_list|,
literal|"number"
argument_list|,
name|regnum
argument_list|)
expr_stmt|;
name|result
operator|=
name|get_register
argument_list|(
name|regnum
argument_list|,
name|format
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
operator|-
literal|1
condition|)
return|return
name|MI_CMD_ERROR
return|;
name|ui_out_tuple_end
argument_list|(
name|uiout
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Else, list of register #s, just do listed regs */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|regnum
operator|=
name|atoi
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|regnum
operator|>=
literal|0
operator|&&
name|regnum
operator|<
name|numregs
operator|&&
name|REGISTER_NAME
argument_list|(
name|regnum
argument_list|)
operator|!=
name|NULL
operator|&&
operator|*
name|REGISTER_NAME
argument_list|(
name|regnum
argument_list|)
operator|!=
literal|'\000'
condition|)
block|{
name|ui_out_tuple_begin
argument_list|(
name|uiout
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ui_out_field_int
argument_list|(
name|uiout
argument_list|,
literal|"number"
argument_list|,
name|regnum
argument_list|)
expr_stmt|;
name|result
operator|=
name|get_register
argument_list|(
name|regnum
argument_list|,
name|format
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
operator|-
literal|1
condition|)
return|return
name|MI_CMD_ERROR
return|;
name|ui_out_tuple_end
argument_list|(
name|uiout
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xasprintf
argument_list|(
operator|&
name|mi_error_message
argument_list|,
literal|"bad register number"
argument_list|)
expr_stmt|;
return|return
name|MI_CMD_ERROR
return|;
block|}
block|}
name|ui_out_list_end
argument_list|(
name|uiout
argument_list|)
expr_stmt|;
return|return
name|MI_CMD_DONE
return|;
block|}
end_function

begin_comment
comment|/* Output one register's contents in the desired format. */
end_comment

begin_function
specifier|static
name|int
name|get_register
parameter_list|(
name|int
name|regnum
parameter_list|,
name|int
name|format
parameter_list|)
block|{
name|char
modifier|*
name|raw_buffer
init|=
name|alloca
argument_list|(
name|MAX_REGISTER_RAW_SIZE
argument_list|)
decl_stmt|;
name|char
modifier|*
name|virtual_buffer
init|=
name|alloca
argument_list|(
name|MAX_REGISTER_VIRTUAL_SIZE
argument_list|)
decl_stmt|;
name|int
name|optim
decl_stmt|;
specifier|static
name|struct
name|ui_stream
modifier|*
name|stb
init|=
name|NULL
decl_stmt|;
name|stb
operator|=
name|ui_out_stream_new
argument_list|(
name|uiout
argument_list|)
expr_stmt|;
if|if
condition|(
name|format
operator|==
literal|'N'
condition|)
name|format
operator|=
literal|0
expr_stmt|;
comment|/* read_relative_register_raw_bytes returns a virtual frame pointer      (FRAME_FP (selected_frame)) if regnum == FP_REGNUM instead      of the real contents of the register. To get around this,      use get_saved_register instead. */
name|get_saved_register
argument_list|(
name|raw_buffer
argument_list|,
operator|&
name|optim
argument_list|,
operator|(
name|CORE_ADDR
operator|*
operator|)
name|NULL
argument_list|,
name|selected_frame
argument_list|,
name|regnum
argument_list|,
operator|(
expr|enum
name|lval_type
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|optim
condition|)
block|{
name|xasprintf
argument_list|(
operator|&
name|mi_error_message
argument_list|,
literal|"Optimized out"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Convert raw data to virtual format if necessary.  */
if|if
condition|(
name|REGISTER_CONVERTIBLE
argument_list|(
name|regnum
argument_list|)
condition|)
block|{
name|REGISTER_CONVERT_TO_VIRTUAL
argument_list|(
name|regnum
argument_list|,
name|REGISTER_VIRTUAL_TYPE
argument_list|(
name|regnum
argument_list|)
argument_list|,
name|raw_buffer
argument_list|,
name|virtual_buffer
argument_list|)
expr_stmt|;
block|}
else|else
name|memcpy
argument_list|(
name|virtual_buffer
argument_list|,
name|raw_buffer
argument_list|,
name|REGISTER_VIRTUAL_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|format
operator|==
literal|'r'
condition|)
block|{
name|int
name|j
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|,
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"0x"
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|buf
operator|+
literal|2
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
specifier|register
name|int
name|idx
init|=
name|TARGET_BYTE_ORDER
operator|==
name|BFD_ENDIAN_BIG
condition|?
name|j
else|:
name|REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
operator|-
literal|1
operator|-
name|j
decl_stmt|;
name|sprintf
argument_list|(
name|ptr
argument_list|,
literal|"%02x"
argument_list|,
operator|(
name|unsigned
name|char
operator|)
name|raw_buffer
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
name|ptr
operator|+=
literal|2
expr_stmt|;
block|}
name|ui_out_field_string
argument_list|(
name|uiout
argument_list|,
literal|"value"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/*fputs_filtered (buf, gdb_stdout); */
block|}
else|else
block|{
name|val_print
argument_list|(
name|REGISTER_VIRTUAL_TYPE
argument_list|(
name|regnum
argument_list|)
argument_list|,
name|virtual_buffer
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|stb
operator|->
name|stream
argument_list|,
name|format
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|Val_pretty_default
argument_list|)
expr_stmt|;
name|ui_out_field_stream
argument_list|(
name|uiout
argument_list|,
literal|"value"
argument_list|,
name|stb
argument_list|)
expr_stmt|;
name|ui_out_stream_delete
argument_list|(
name|stb
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Write given values into registers. The registers and values are    given as pairs. The corresponding MI command is     -data-write-register-values<format> [<regnum1><value1>...<regnumN><valueN>]*/
end_comment

begin_function
name|enum
name|mi_cmd_result
name|mi_cmd_data_write_register_values
parameter_list|(
name|char
modifier|*
name|command
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|int
name|argc
parameter_list|)
block|{
name|int
name|regnum
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|numregs
decl_stmt|;
name|LONGEST
name|value
decl_stmt|;
name|char
name|format
decl_stmt|;
comment|/* Note that the test for a valid register must include checking the      REGISTER_NAME because NUM_REGS may be allocated for the union of      the register sets within a family of related processors.  In this      case, some entries of REGISTER_NAME will change depending upon      the particular processor being debugged.  */
name|numregs
operator|=
name|NUM_REGS
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
block|{
name|xasprintf
argument_list|(
operator|&
name|mi_error_message
argument_list|,
literal|"mi_cmd_data_write_register_values: Usage: -data-write-register-values<format> [<regnum1><value1>...<regnumN><valueN>]"
argument_list|)
expr_stmt|;
return|return
name|MI_CMD_ERROR
return|;
block|}
name|format
operator|=
operator|(
name|int
operator|)
name|argv
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|target_has_registers
condition|)
block|{
name|xasprintf
argument_list|(
operator|&
name|mi_error_message
argument_list|,
literal|"mi_cmd_data_write_register_values: No registers."
argument_list|)
expr_stmt|;
return|return
name|MI_CMD_ERROR
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|argc
operator|-
literal|1
operator|)
condition|)
block|{
name|xasprintf
argument_list|(
operator|&
name|mi_error_message
argument_list|,
literal|"mi_cmd_data_write_register_values: No regs and values specified."
argument_list|)
expr_stmt|;
return|return
name|MI_CMD_ERROR
return|;
block|}
if|if
condition|(
operator|(
name|argc
operator|-
literal|1
operator|)
operator|%
literal|2
condition|)
block|{
name|xasprintf
argument_list|(
operator|&
name|mi_error_message
argument_list|,
literal|"mi_cmd_data_write_register_values: Regs and vals are not in pairs."
argument_list|)
expr_stmt|;
return|return
name|MI_CMD_ERROR
return|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|=
name|i
operator|+
literal|2
control|)
block|{
name|regnum
operator|=
name|atoi
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|regnum
operator|>=
literal|0
operator|&&
name|regnum
operator|<
name|numregs
operator|&&
name|REGISTER_NAME
argument_list|(
name|regnum
argument_list|)
operator|!=
name|NULL
operator|&&
operator|*
name|REGISTER_NAME
argument_list|(
name|regnum
argument_list|)
operator|!=
literal|'\000'
condition|)
block|{
name|void
modifier|*
name|buffer
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
comment|/* Get the value as a number */
name|value
operator|=
name|parse_and_eval_address
argument_list|(
name|argv
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* Get the value into an array */
name|buffer
operator|=
name|xmalloc
argument_list|(
name|REGISTER_SIZE
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|store_signed_integer
argument_list|(
name|buffer
argument_list|,
name|REGISTER_SIZE
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|/* Write it down */
name|write_register_bytes
argument_list|(
name|REGISTER_BYTE
argument_list|(
name|regnum
argument_list|)
argument_list|,
name|buffer
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Free the buffer.  */
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xasprintf
argument_list|(
operator|&
name|mi_error_message
argument_list|,
literal|"bad register number"
argument_list|)
expr_stmt|;
return|return
name|MI_CMD_ERROR
return|;
block|}
block|}
return|return
name|MI_CMD_DONE
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/*This is commented out because we decided it was not useful. I leave    it, just in case. ezannoni:1999-12-08 */
end_comment

begin_comment
comment|/* Assign a value to a variable. The expression argument must be in    the form A=2 or "A = 2" (I.e. if there are spaces it needs to be    quoted. */
end_comment

begin_comment
unit|enum mi_cmd_result mi_cmd_data_assign (char *command, char **argv, int argc) {   struct expression *expr;   struct cleanup *old_chain;    if (argc != 1)     {       xasprintf (&mi_error_message, 		 "mi_cmd_data_assign: Usage: -data-assign expression");       return MI_CMD_ERROR;     }
comment|/* NOTE what follows is a clone of set_command(). FIXME: ezannoni      01-12-1999: Need to decide what to do with this for libgdb purposes. */
end_comment

begin_endif
unit|expr = parse_expression (argv[0]);   old_chain = make_cleanup (free_current_contents,&expr);   evaluate_expression (expr);   do_cleanups (old_chain);   return MI_CMD_DONE; }
endif|#
directive|endif
end_endif

begin_comment
comment|/* Evaluate the value of the argument. The argument is an    expression. If the expression contains spaces it needs to be    included in double quotes. */
end_comment

begin_function
name|enum
name|mi_cmd_result
name|mi_cmd_data_evaluate_expression
parameter_list|(
name|char
modifier|*
name|command
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|int
name|argc
parameter_list|)
block|{
name|struct
name|expression
modifier|*
name|expr
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
init|=
name|NULL
decl_stmt|;
name|struct
name|value
modifier|*
name|val
decl_stmt|;
name|struct
name|ui_stream
modifier|*
name|stb
init|=
name|NULL
decl_stmt|;
name|stb
operator|=
name|ui_out_stream_new
argument_list|(
name|uiout
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|1
condition|)
block|{
name|xasprintf
argument_list|(
operator|&
name|mi_error_message
argument_list|,
literal|"mi_cmd_data_evaluate_expression: Usage: -data-evaluate-expression expression"
argument_list|)
expr_stmt|;
return|return
name|MI_CMD_ERROR
return|;
block|}
name|expr
operator|=
name|parse_expression
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|free_current_contents
argument_list|,
operator|&
name|expr
argument_list|)
expr_stmt|;
name|val
operator|=
name|evaluate_expression
argument_list|(
name|expr
argument_list|)
expr_stmt|;
comment|/* Print the result of the expression evaluation. */
name|val_print
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|val
argument_list|)
argument_list|,
name|VALUE_EMBEDDED_OFFSET
argument_list|(
name|val
argument_list|)
argument_list|,
name|VALUE_ADDRESS
argument_list|(
name|val
argument_list|)
argument_list|,
name|stb
operator|->
name|stream
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ui_out_field_stream
argument_list|(
name|uiout
argument_list|,
literal|"value"
argument_list|,
name|stb
argument_list|)
expr_stmt|;
name|ui_out_stream_delete
argument_list|(
name|stb
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
name|MI_CMD_DONE
return|;
block|}
end_function

begin_function
name|enum
name|mi_cmd_result
name|mi_cmd_target_download
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|char
modifier|*
name|run
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_cleanups
init|=
name|NULL
decl_stmt|;
name|xasprintf
argument_list|(
operator|&
name|run
argument_list|,
literal|"load %s"
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|old_cleanups
operator|=
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|run
argument_list|)
expr_stmt|;
name|execute_command
argument_list|(
name|run
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_cleanups
argument_list|)
expr_stmt|;
return|return
name|MI_CMD_DONE
return|;
block|}
end_function

begin_comment
comment|/* Connect to the remote target. */
end_comment

begin_function
name|enum
name|mi_cmd_result
name|mi_cmd_target_select
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|char
modifier|*
name|run
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_cleanups
init|=
name|NULL
decl_stmt|;
name|xasprintf
argument_list|(
operator|&
name|run
argument_list|,
literal|"target %s"
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|old_cleanups
operator|=
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|run
argument_list|)
expr_stmt|;
comment|/* target-select is always synchronous.  once the call has returned      we know that we are connected. */
comment|/* NOTE: At present all targets that are connected are also      (implicitly) talking to a halted target.  In the future this may      change. */
name|execute_command
argument_list|(
name|run
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_cleanups
argument_list|)
expr_stmt|;
comment|/* Issue the completion message here. */
if|if
condition|(
name|last_async_command
condition|)
name|fputs_unfiltered
argument_list|(
name|last_async_command
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
literal|"^connected"
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|mi_out_put
argument_list|(
name|uiout
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|mi_out_rewind
argument_list|(
name|uiout
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
literal|"\n"
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|do_exec_cleanups
argument_list|(
name|ALL_CLEANUPS
argument_list|)
expr_stmt|;
return|return
name|MI_CMD_QUIET
return|;
block|}
end_function

begin_comment
comment|/* DATA-MEMORY-READ:     ADDR: start address of data to be dumped.    WORD-FORMAT: a char indicating format for the ``word''. See     the ``x'' command.    WORD-SIZE: size of each ``word''; 1,2,4, or 8 bytes    NR_ROW: Number of rows.    NR_COL: The number of colums (words per row).    ASCHAR: (OPTIONAL) Append an ascii character dump to each row.  Use    ASCHAR for unprintable characters.     Reads SIZE*NR_ROW*NR_COL bytes starting at ADDR from memory and    displayes them.  Returns:     {addr="...",rowN={wordN="..." ,... [,ascii="..."]}, ...}     Returns:     The number of bytes read is SIZE*ROW*COL. */
end_comment

begin_function
name|enum
name|mi_cmd_result
name|mi_cmd_data_read_memory
parameter_list|(
name|char
modifier|*
name|command
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|int
name|argc
parameter_list|)
block|{
name|struct
name|cleanup
modifier|*
name|cleanups
init|=
name|make_cleanup
argument_list|(
name|null_cleanup
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|long
name|total_bytes
decl_stmt|;
name|long
name|nr_cols
decl_stmt|;
name|long
name|nr_rows
decl_stmt|;
name|char
name|word_format
decl_stmt|;
name|struct
name|type
modifier|*
name|word_type
decl_stmt|;
name|long
name|word_size
decl_stmt|;
name|char
name|word_asize
decl_stmt|;
name|char
name|aschar
decl_stmt|;
name|char
modifier|*
name|mbuf
decl_stmt|;
name|int
name|nr_bytes
decl_stmt|;
name|long
name|offset
init|=
literal|0
decl_stmt|;
name|int
name|optind
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|optarg
decl_stmt|;
enum|enum
name|opt
block|{
name|OFFSET_OPT
block|}
enum|;
specifier|static
name|struct
name|mi_opt
name|opts
index|[]
init|=
block|{
block|{
literal|"o"
block|,
name|OFFSET_OPT
block|,
literal|1
block|}
block|,
literal|0
block|}
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|opt
init|=
name|mi_getopt
argument_list|(
literal|"mi_cmd_data_read_memory"
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|opts
argument_list|,
operator|&
name|optind
argument_list|,
operator|&
name|optarg
argument_list|)
decl_stmt|;
if|if
condition|(
name|opt
operator|<
literal|0
condition|)
break|break;
switch|switch
condition|(
operator|(
expr|enum
name|opt
operator|)
name|opt
condition|)
block|{
case|case
name|OFFSET_OPT
case|:
name|offset
operator|=
name|atol
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|argv
operator|+=
name|optind
expr_stmt|;
name|argc
operator|-=
name|optind
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|5
operator|||
name|argc
operator|>
literal|6
condition|)
block|{
name|xasprintf
argument_list|(
operator|&
name|mi_error_message
argument_list|,
literal|"mi_cmd_data_read_memory: Usage: ADDR WORD-FORMAT WORD-SIZE NR-ROWS NR-COLS [ASCHAR]."
argument_list|)
expr_stmt|;
return|return
name|MI_CMD_ERROR
return|;
block|}
comment|/* Extract all the arguments. */
comment|/* Start address of the memory dump. */
name|addr
operator|=
name|parse_and_eval_address
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
operator|+
name|offset
expr_stmt|;
comment|/* The format character to use when displaying a memory word. See      the ``x'' command. */
name|word_format
operator|=
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
comment|/* The size of the memory word. */
name|word_size
operator|=
name|atol
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|word_size
condition|)
block|{
case|case
literal|1
case|:
name|word_type
operator|=
name|builtin_type_int8
expr_stmt|;
name|word_asize
operator|=
literal|'b'
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|word_type
operator|=
name|builtin_type_int16
expr_stmt|;
name|word_asize
operator|=
literal|'h'
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|word_type
operator|=
name|builtin_type_int32
expr_stmt|;
name|word_asize
operator|=
literal|'w'
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|word_type
operator|=
name|builtin_type_int64
expr_stmt|;
name|word_asize
operator|=
literal|'g'
expr_stmt|;
break|break;
default|default:
name|word_type
operator|=
name|builtin_type_int8
expr_stmt|;
name|word_asize
operator|=
literal|'b'
expr_stmt|;
block|}
comment|/* The number of rows */
name|nr_rows
operator|=
name|atol
argument_list|(
name|argv
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|nr_rows
operator|<=
literal|0
condition|)
block|{
name|xasprintf
argument_list|(
operator|&
name|mi_error_message
argument_list|,
literal|"mi_cmd_data_read_memory: invalid number of rows."
argument_list|)
expr_stmt|;
return|return
name|MI_CMD_ERROR
return|;
block|}
comment|/* number of bytes per row. */
name|nr_cols
operator|=
name|atol
argument_list|(
name|argv
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|nr_cols
operator|<=
literal|0
condition|)
block|{
name|xasprintf
argument_list|(
operator|&
name|mi_error_message
argument_list|,
literal|"mi_cmd_data_read_memory: invalid number of columns."
argument_list|)
expr_stmt|;
block|}
comment|/* The un-printable character when printing ascii. */
if|if
condition|(
name|argc
operator|==
literal|6
condition|)
name|aschar
operator|=
operator|*
name|argv
index|[
literal|5
index|]
expr_stmt|;
else|else
name|aschar
operator|=
literal|0
expr_stmt|;
comment|/* create a buffer and read it in. */
name|total_bytes
operator|=
name|word_size
operator|*
name|nr_rows
operator|*
name|nr_cols
expr_stmt|;
name|mbuf
operator|=
name|xcalloc
argument_list|(
name|total_bytes
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|mbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbuf
operator|==
name|NULL
condition|)
block|{
name|xasprintf
argument_list|(
operator|&
name|mi_error_message
argument_list|,
literal|"mi_cmd_data_read_memory: out of memory."
argument_list|)
expr_stmt|;
return|return
name|MI_CMD_ERROR
return|;
block|}
name|nr_bytes
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|nr_bytes
operator|<
name|total_bytes
condition|)
block|{
name|int
name|error
decl_stmt|;
name|long
name|num
init|=
name|target_read_memory_partial
argument_list|(
name|addr
operator|+
name|nr_bytes
argument_list|,
name|mbuf
operator|+
name|nr_bytes
argument_list|,
name|total_bytes
operator|-
name|nr_bytes
argument_list|,
operator|&
name|error
argument_list|)
decl_stmt|;
if|if
condition|(
name|num
operator|<=
literal|0
condition|)
break|break;
name|nr_bytes
operator|+=
name|num
expr_stmt|;
block|}
comment|/* output the header information. */
name|ui_out_field_core_addr
argument_list|(
name|uiout
argument_list|,
literal|"addr"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|ui_out_field_int
argument_list|(
name|uiout
argument_list|,
literal|"nr-bytes"
argument_list|,
name|nr_bytes
argument_list|)
expr_stmt|;
name|ui_out_field_int
argument_list|(
name|uiout
argument_list|,
literal|"total-bytes"
argument_list|,
name|total_bytes
argument_list|)
expr_stmt|;
name|ui_out_field_core_addr
argument_list|(
name|uiout
argument_list|,
literal|"next-row"
argument_list|,
name|addr
operator|+
name|word_size
operator|*
name|nr_cols
argument_list|)
expr_stmt|;
name|ui_out_field_core_addr
argument_list|(
name|uiout
argument_list|,
literal|"prev-row"
argument_list|,
name|addr
operator|-
name|word_size
operator|*
name|nr_cols
argument_list|)
expr_stmt|;
name|ui_out_field_core_addr
argument_list|(
name|uiout
argument_list|,
literal|"next-page"
argument_list|,
name|addr
operator|+
name|total_bytes
argument_list|)
expr_stmt|;
name|ui_out_field_core_addr
argument_list|(
name|uiout
argument_list|,
literal|"prev-page"
argument_list|,
name|addr
operator|-
name|total_bytes
argument_list|)
expr_stmt|;
comment|/* Build the result as a two dimentional table. */
block|{
name|struct
name|ui_stream
modifier|*
name|stream
init|=
name|ui_out_stream_new
argument_list|(
name|uiout
argument_list|)
decl_stmt|;
name|int
name|row
decl_stmt|;
name|int
name|row_byte
decl_stmt|;
name|ui_out_list_begin
argument_list|(
name|uiout
argument_list|,
literal|"memory"
argument_list|)
expr_stmt|;
for|for
control|(
name|row
operator|=
literal|0
operator|,
name|row_byte
operator|=
literal|0
init|;
name|row
operator|<
name|nr_rows
condition|;
name|row
operator|++
operator|,
name|row_byte
operator|+=
name|nr_cols
operator|*
name|word_size
control|)
block|{
name|int
name|col
decl_stmt|;
name|int
name|col_byte
decl_stmt|;
name|ui_out_tuple_begin
argument_list|(
name|uiout
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ui_out_field_core_addr
argument_list|(
name|uiout
argument_list|,
literal|"addr"
argument_list|,
name|addr
operator|+
name|row_byte
argument_list|)
expr_stmt|;
comment|/* ui_out_field_core_addr_symbolic (uiout, "saddr", addr + row_byte); */
name|ui_out_list_begin
argument_list|(
name|uiout
argument_list|,
literal|"data"
argument_list|)
expr_stmt|;
for|for
control|(
name|col
operator|=
literal|0
operator|,
name|col_byte
operator|=
name|row_byte
init|;
name|col
operator|<
name|nr_cols
condition|;
name|col
operator|++
operator|,
name|col_byte
operator|+=
name|word_size
control|)
block|{
if|if
condition|(
name|col_byte
operator|+
name|word_size
operator|>
name|nr_bytes
condition|)
block|{
name|ui_out_field_string
argument_list|(
name|uiout
argument_list|,
name|NULL
argument_list|,
literal|"N/A"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ui_file_rewind
argument_list|(
name|stream
operator|->
name|stream
argument_list|)
expr_stmt|;
name|print_scalar_formatted
argument_list|(
name|mbuf
operator|+
name|col_byte
argument_list|,
name|word_type
argument_list|,
name|word_format
argument_list|,
name|word_asize
argument_list|,
name|stream
operator|->
name|stream
argument_list|)
expr_stmt|;
name|ui_out_field_stream
argument_list|(
name|uiout
argument_list|,
name|NULL
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
name|ui_out_list_end
argument_list|(
name|uiout
argument_list|)
expr_stmt|;
if|if
condition|(
name|aschar
condition|)
block|{
name|int
name|byte
decl_stmt|;
name|ui_file_rewind
argument_list|(
name|stream
operator|->
name|stream
argument_list|)
expr_stmt|;
for|for
control|(
name|byte
operator|=
name|row_byte
init|;
name|byte
operator|<
name|row_byte
operator|+
name|word_size
operator|*
name|nr_cols
condition|;
name|byte
operator|++
control|)
block|{
if|if
condition|(
name|byte
operator|>=
name|nr_bytes
condition|)
block|{
name|fputc_unfiltered
argument_list|(
literal|'X'
argument_list|,
name|stream
operator|->
name|stream
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mbuf
index|[
name|byte
index|]
operator|<
literal|32
operator|||
name|mbuf
index|[
name|byte
index|]
operator|>
literal|126
condition|)
block|{
name|fputc_unfiltered
argument_list|(
name|aschar
argument_list|,
name|stream
operator|->
name|stream
argument_list|)
expr_stmt|;
block|}
else|else
name|fputc_unfiltered
argument_list|(
name|mbuf
index|[
name|byte
index|]
argument_list|,
name|stream
operator|->
name|stream
argument_list|)
expr_stmt|;
block|}
name|ui_out_field_stream
argument_list|(
name|uiout
argument_list|,
literal|"ascii"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
name|ui_out_tuple_end
argument_list|(
name|uiout
argument_list|)
expr_stmt|;
block|}
name|ui_out_stream_delete
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|ui_out_list_end
argument_list|(
name|uiout
argument_list|)
expr_stmt|;
block|}
name|do_cleanups
argument_list|(
name|cleanups
argument_list|)
expr_stmt|;
return|return
name|MI_CMD_DONE
return|;
block|}
end_function

begin_comment
comment|/* DATA-MEMORY-WRITE:     COLUMN_OFFSET: optional argument. Must be preceeded by '-o'. The    offset from the beginning of the memory grid row where the cell to    be written is.    ADDR: start address of the row in the memory grid where the memory    cell is, if OFFSET_COLUMN is specified. Otherwise, the address of    the location to write to.    FORMAT: a char indicating format for the ``word''. See     the ``x'' command.    WORD_SIZE: size of each ``word''; 1,2,4, or 8 bytes    VALUE: value to be written into the memory address.     Writes VALUE into ADDR + (COLUMN_OFFSET * WORD_SIZE).     Prints nothing. */
end_comment

begin_function
name|enum
name|mi_cmd_result
name|mi_cmd_data_write_memory
parameter_list|(
name|char
modifier|*
name|command
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|int
name|argc
parameter_list|)
block|{
name|CORE_ADDR
name|addr
decl_stmt|;
name|char
name|word_format
decl_stmt|;
name|long
name|word_size
decl_stmt|;
comment|/* FIXME: ezannoni 2000-02-17 LONGEST could possibly not be big      enough when using a compiler other than GCC. */
name|LONGEST
name|value
decl_stmt|;
name|void
modifier|*
name|buffer
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|long
name|offset
init|=
literal|0
decl_stmt|;
name|int
name|optind
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|optarg
decl_stmt|;
enum|enum
name|opt
block|{
name|OFFSET_OPT
block|}
enum|;
specifier|static
name|struct
name|mi_opt
name|opts
index|[]
init|=
block|{
block|{
literal|"o"
block|,
name|OFFSET_OPT
block|,
literal|1
block|}
block|,
literal|0
block|}
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|opt
init|=
name|mi_getopt
argument_list|(
literal|"mi_cmd_data_write_memory"
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|opts
argument_list|,
operator|&
name|optind
argument_list|,
operator|&
name|optarg
argument_list|)
decl_stmt|;
if|if
condition|(
name|opt
operator|<
literal|0
condition|)
break|break;
switch|switch
condition|(
operator|(
expr|enum
name|opt
operator|)
name|opt
condition|)
block|{
case|case
name|OFFSET_OPT
case|:
name|offset
operator|=
name|atol
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|argv
operator|+=
name|optind
expr_stmt|;
name|argc
operator|-=
name|optind
expr_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|4
condition|)
block|{
name|xasprintf
argument_list|(
operator|&
name|mi_error_message
argument_list|,
literal|"mi_cmd_data_write_memory: Usage: [-o COLUMN_OFFSET] ADDR FORMAT WORD-SIZE VALUE."
argument_list|)
expr_stmt|;
return|return
name|MI_CMD_ERROR
return|;
block|}
comment|/* Extract all the arguments. */
comment|/* Start address of the memory dump. */
name|addr
operator|=
name|parse_and_eval_address
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* The format character to use when displaying a memory word. See      the ``x'' command. */
name|word_format
operator|=
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
comment|/* The size of the memory word. */
name|word_size
operator|=
name|atol
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* Calculate the real address of the write destination. */
name|addr
operator|+=
operator|(
name|offset
operator|*
name|word_size
operator|)
expr_stmt|;
comment|/* Get the value as a number */
name|value
operator|=
name|parse_and_eval_address
argument_list|(
name|argv
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
comment|/* Get the value into an array */
name|buffer
operator|=
name|xmalloc
argument_list|(
name|word_size
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|store_signed_integer
argument_list|(
name|buffer
argument_list|,
name|word_size
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|/* Write it down to memory */
name|write_memory
argument_list|(
name|addr
argument_list|,
name|buffer
argument_list|,
name|word_size
argument_list|)
expr_stmt|;
comment|/* Free the buffer.  */
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
name|MI_CMD_DONE
return|;
block|}
end_function

begin_comment
comment|/* Execute a command within a safe environment.  Return>0 for    ok. Return<0 for supress prompt.  Return 0 to have the error    extracted from error_last_message(). */
end_comment

begin_function
specifier|static
name|int
name|captured_mi_execute_command
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|mi_parse
modifier|*
name|context
init|=
name|data
decl_stmt|;
name|enum
name|mi_cmd_result
name|rc
decl_stmt|;
switch|switch
condition|(
name|context
operator|->
name|op
condition|)
block|{
case|case
name|MI_COMMAND
case|:
comment|/* A MI command was read from the input stream */
if|if
condition|(
name|mi_debug_p
condition|)
comment|/* FIXME: gdb_???? */
name|fprintf_unfiltered
argument_list|(
name|raw_stdout
argument_list|,
literal|" token=`%s' command=`%s' args=`%s'\n"
argument_list|,
name|context
operator|->
name|token
argument_list|,
name|context
operator|->
name|command
argument_list|,
name|context
operator|->
name|args
argument_list|)
expr_stmt|;
comment|/* FIXME: cagney/1999-09-25: Rather than this convoluted          condition expression, each function should return an          indication of what action is required and then switch on          that. */
name|rc
operator|=
name|mi_cmd_execute
argument_list|(
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target_can_async_p
argument_list|()
operator|||
operator|!
name|target_executing
condition|)
block|{
comment|/* print the result if there were no errors */
if|if
condition|(
name|rc
operator|==
name|MI_CMD_DONE
condition|)
block|{
name|fputs_unfiltered
argument_list|(
name|context
operator|->
name|token
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
literal|"^done"
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|mi_out_put
argument_list|(
name|uiout
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|mi_out_rewind
argument_list|(
name|uiout
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
literal|"\n"
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rc
operator|==
name|MI_CMD_ERROR
condition|)
block|{
if|if
condition|(
name|mi_error_message
condition|)
block|{
name|fputs_unfiltered
argument_list|(
name|context
operator|->
name|token
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
literal|"^error,msg=\""
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|fputstr_unfiltered
argument_list|(
name|mi_error_message
argument_list|,
literal|'"'
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|mi_error_message
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
literal|"\"\n"
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
block|}
name|mi_out_rewind
argument_list|(
name|uiout
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rc
operator|==
name|MI_CMD_CAUGHT_ERROR
condition|)
block|{
name|mi_out_rewind
argument_list|(
name|uiout
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
name|mi_out_rewind
argument_list|(
name|uiout
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sync_execution
condition|)
comment|/* Don't print the prompt. We are executing the target in 	   synchronous mode. */
return|return
operator|-
literal|1
return|;
break|break;
case|case
name|CLI_COMMAND
case|:
comment|/* A CLI command was read from the input stream */
comment|/* This will be removed as soon as we have a complete set of          mi commands */
comment|/* echo the command on the console. */
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"%s\n"
argument_list|,
name|context
operator|->
name|command
argument_list|)
expr_stmt|;
comment|/* FIXME: If the command string has something that looks like           a format spec (e.g. %s) we will get a core dump */
name|mi_execute_cli_command
argument_list|(
literal|"%s"
argument_list|,
name|context
operator|->
name|command
argument_list|)
expr_stmt|;
comment|/* print the result */
comment|/* FIXME: Check for errors here. */
name|fputs_unfiltered
argument_list|(
name|context
operator|->
name|token
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
literal|"^done"
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|mi_out_put
argument_list|(
name|uiout
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|mi_out_rewind
argument_list|(
name|uiout
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
literal|"\n"
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|mi_execute_command
parameter_list|(
name|char
modifier|*
name|cmd
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|mi_parse
modifier|*
name|command
decl_stmt|;
comment|/* This is to handle EOF (^D). We just quit gdb. */
comment|/* FIXME: we should call some API function here. */
if|if
condition|(
name|cmd
operator|==
literal|0
condition|)
name|quit_force
argument_list|(
name|NULL
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
name|command
operator|=
name|mi_parse
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|command
operator|!=
name|NULL
condition|)
block|{
comment|/* FIXME: cagney/1999-11-04: Can this use of catch_errors either          be pushed even further down or even eliminated? */
name|int
name|rc
init|=
name|catch_errors
argument_list|(
name|captured_mi_execute_command
argument_list|,
name|command
argument_list|,
literal|""
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
decl_stmt|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
block|{
comment|/* The command is executing synchronously.  Bail out early 	     suppressing the finished prompt. */
name|mi_parse_free
argument_list|(
name|command
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|msg
init|=
name|error_last_message
argument_list|()
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|cleanup
init|=
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|msg
argument_list|)
decl_stmt|;
comment|/* The command execution failed and error() was called 	     somewhere */
name|fputs_unfiltered
argument_list|(
name|command
operator|->
name|token
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
literal|"^error,msg=\""
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|fputstr_unfiltered
argument_list|(
name|msg
argument_list|,
literal|'"'
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
literal|"\"\n"
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
block|}
name|mi_parse_free
argument_list|(
name|command
argument_list|)
expr_stmt|;
block|}
name|fputs_unfiltered
argument_list|(
literal|"(gdb) \n"
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|raw_stdout
argument_list|)
expr_stmt|;
comment|/* print any buffered hook code */
comment|/* ..... */
block|}
end_function

begin_function
specifier|static
name|enum
name|mi_cmd_result
name|mi_cmd_execute
parameter_list|(
name|struct
name|mi_parse
modifier|*
name|parse
parameter_list|)
block|{
if|if
condition|(
name|parse
operator|->
name|cmd
operator|->
name|argv_func
operator|!=
name|NULL
operator|||
name|parse
operator|->
name|cmd
operator|->
name|args_func
operator|!=
name|NULL
condition|)
block|{
comment|/* FIXME: We need to save the token because the command executed          may be asynchronous and need to print the token again.          In the future we can pass the token down to the func          and get rid of the last_async_command */
comment|/* The problem here is to keep the token around when we launch          the target, and we want to interrupt it later on.  The          interrupt command will have its own token, but when the          target stops, we must display the token corresponding to the          last execution command given. So we have another string where          we copy the token (previous_async_command), if this was          indeed the token of an execution command, and when we stop we          print that one. This is possible because the interrupt          command, when over, will copy that token back into the          default token string (last_async_command). */
if|if
condition|(
name|target_executing
condition|)
block|{
if|if
condition|(
operator|!
name|previous_async_command
condition|)
name|previous_async_command
operator|=
name|xstrdup
argument_list|(
name|last_async_command
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|parse
operator|->
name|command
argument_list|,
literal|"exec-interrupt"
argument_list|)
condition|)
block|{
name|fputs_unfiltered
argument_list|(
name|parse
operator|->
name|token
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
literal|"^error,msg=\""
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
literal|"Cannot execute command "
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|fputstr_unfiltered
argument_list|(
name|parse
operator|->
name|command
argument_list|,
literal|'"'
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
literal|" while target running"
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
literal|"\"\n"
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
return|return
name|MI_CMD_ERROR
return|;
block|}
block|}
name|last_async_command
operator|=
name|xstrdup
argument_list|(
name|parse
operator|->
name|token
argument_list|)
expr_stmt|;
name|make_exec_cleanup
argument_list|(
name|free_current_contents
argument_list|,
operator|&
name|last_async_command
argument_list|)
expr_stmt|;
comment|/* FIXME: DELETE THIS! */
if|if
condition|(
name|parse
operator|->
name|cmd
operator|->
name|args_func
operator|!=
name|NULL
condition|)
return|return
name|parse
operator|->
name|cmd
operator|->
name|args_func
argument_list|(
name|parse
operator|->
name|args
argument_list|,
literal|0
comment|/*from_tty */
argument_list|)
return|;
return|return
name|parse
operator|->
name|cmd
operator|->
name|argv_func
argument_list|(
name|parse
operator|->
name|command
argument_list|,
name|parse
operator|->
name|argv
argument_list|,
name|parse
operator|->
name|argc
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|parse
operator|->
name|cmd
operator|->
name|cli
operator|!=
literal|0
condition|)
block|{
comment|/* FIXME: DELETE THIS. */
comment|/* The operation is still implemented by a cli command */
comment|/* Must be a synchronous one */
name|mi_execute_cli_command
argument_list|(
name|parse
operator|->
name|cmd
operator|->
name|cli
argument_list|,
name|parse
operator|->
name|args
argument_list|)
expr_stmt|;
return|return
name|MI_CMD_DONE
return|;
block|}
else|else
block|{
comment|/* FIXME: DELETE THIS. */
name|fputs_unfiltered
argument_list|(
name|parse
operator|->
name|token
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
literal|"^error,msg=\""
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
literal|"Undefined mi command: "
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|fputstr_unfiltered
argument_list|(
name|parse
operator|->
name|command
argument_list|,
literal|'"'
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
literal|" (missing implementation)"
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
literal|"\"\n"
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
return|return
name|MI_CMD_ERROR
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mi_execute_command_wrapper
parameter_list|(
name|char
modifier|*
name|cmd
parameter_list|)
block|{
name|mi_execute_command
argument_list|(
name|cmd
argument_list|,
name|stdin
operator|==
name|instream
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* FIXME: This is just a hack so we can get some extra commands going.    We don't want to channel things through the CLI, but call libgdb directly */
end_comment

begin_comment
comment|/* Use only for synchronous commands */
end_comment

begin_function
name|void
name|mi_execute_cli_command
parameter_list|(
specifier|const
name|char
modifier|*
name|cli
parameter_list|,
name|char
modifier|*
name|args
parameter_list|)
block|{
if|if
condition|(
name|cli
operator|!=
literal|0
condition|)
block|{
name|struct
name|cleanup
modifier|*
name|old_cleanups
decl_stmt|;
name|char
modifier|*
name|run
decl_stmt|;
name|xasprintf
argument_list|(
operator|&
name|run
argument_list|,
name|cli
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|mi_debug_p
condition|)
comment|/* FIXME: gdb_???? */
name|fprintf_unfiltered
argument_list|(
name|gdb_stdout
argument_list|,
literal|"cli=%s run=%s\n"
argument_list|,
name|cli
argument_list|,
name|run
argument_list|)
expr_stmt|;
name|old_cleanups
operator|=
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|run
argument_list|)
expr_stmt|;
name|execute_command
argument_list|(
comment|/*ui */
name|run
argument_list|,
literal|0
comment|/*from_tty */
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_cleanups
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_function
name|enum
name|mi_cmd_result
name|mi_execute_async_cli_command
parameter_list|(
name|char
modifier|*
name|mi
parameter_list|,
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|cleanup
modifier|*
name|old_cleanups
decl_stmt|;
name|char
modifier|*
name|run
decl_stmt|;
name|char
modifier|*
name|async_args
decl_stmt|;
if|if
condition|(
name|target_can_async_p
argument_list|()
condition|)
block|{
name|async_args
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|args
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|make_exec_cleanup
argument_list|(
name|free
argument_list|,
name|async_args
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|async_args
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|async_args
argument_list|,
literal|"&"
argument_list|)
expr_stmt|;
name|xasprintf
argument_list|(
operator|&
name|run
argument_list|,
literal|"%s %s"
argument_list|,
name|mi
argument_list|,
name|async_args
argument_list|)
expr_stmt|;
name|make_exec_cleanup
argument_list|(
name|free
argument_list|,
name|run
argument_list|)
expr_stmt|;
name|add_continuation
argument_list|(
name|mi_exec_async_cli_cmd_continuation
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|old_cleanups
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|xasprintf
argument_list|(
operator|&
name|run
argument_list|,
literal|"%s %s"
argument_list|,
name|mi
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|old_cleanups
operator|=
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|run
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|target_can_async_p
argument_list|()
condition|)
block|{
comment|/* NOTE: For synchronous targets asynchronous behavour is faked by          printing out the GDB prompt before we even try to execute the          command. */
if|if
condition|(
name|last_async_command
condition|)
name|fputs_unfiltered
argument_list|(
name|last_async_command
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
literal|"^running\n"
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
literal|"(gdb) \n"
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|raw_stdout
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* FIXME: cagney/1999-11-29: Printing this message before          calling execute_command is wrong.  It should only be printed          once gdb has confirmed that it really has managed to send a          run command to the target. */
if|if
condition|(
name|last_async_command
condition|)
name|fputs_unfiltered
argument_list|(
name|last_async_command
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
literal|"^running\n"
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
block|}
name|execute_command
argument_list|(
comment|/*ui */
name|run
argument_list|,
literal|0
comment|/*from_tty */
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target_can_async_p
argument_list|()
condition|)
block|{
comment|/* Do this before doing any printing.  It would appear that some          print code leaves garbage around in the buffer. */
name|do_cleanups
argument_list|(
name|old_cleanups
argument_list|)
expr_stmt|;
comment|/* If the target was doing the operation synchronously we fake          the stopped message. */
if|if
condition|(
name|last_async_command
condition|)
name|fputs_unfiltered
argument_list|(
name|last_async_command
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
literal|"*stopped"
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|mi_out_put
argument_list|(
name|uiout
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|mi_out_rewind
argument_list|(
name|uiout
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
literal|"\n"
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
return|return
name|MI_CMD_QUIET
return|;
block|}
return|return
name|MI_CMD_DONE
return|;
block|}
end_function

begin_function
name|void
name|mi_exec_async_cli_cmd_continuation
parameter_list|(
name|struct
name|continuation_arg
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
name|last_async_command
condition|)
name|fputs_unfiltered
argument_list|(
name|last_async_command
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
literal|"*stopped"
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|mi_out_put
argument_list|(
name|uiout
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
literal|"\n"
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
literal|"(gdb) \n"
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|raw_stdout
argument_list|)
expr_stmt|;
name|do_exec_cleanups
argument_list|(
name|ALL_CLEANUPS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|mi_input
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|)
block|{
return|return
name|gdb_readline
argument_list|(
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mi_load_progress
parameter_list|(
specifier|const
name|char
modifier|*
name|section_name
parameter_list|,
name|unsigned
name|long
name|sent_so_far
parameter_list|,
name|unsigned
name|long
name|total_section
parameter_list|,
name|unsigned
name|long
name|total_sent
parameter_list|,
name|unsigned
name|long
name|grand_total
parameter_list|)
block|{
name|struct
name|timeval
name|time_now
decl_stmt|,
name|delta
decl_stmt|,
name|update_threshold
decl_stmt|;
specifier|static
name|struct
name|timeval
name|last_update
decl_stmt|;
specifier|static
name|char
modifier|*
name|previous_sect_name
init|=
name|NULL
decl_stmt|;
name|int
name|new_section
decl_stmt|;
if|if
condition|(
operator|!
name|interpreter_p
operator|||
name|strncmp
argument_list|(
name|interpreter_p
argument_list|,
literal|"mi"
argument_list|,
literal|2
argument_list|)
operator|!=
literal|0
condition|)
return|return;
name|update_threshold
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|update_threshold
operator|.
name|tv_usec
operator|=
literal|500000
expr_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|time_now
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|delta
operator|.
name|tv_usec
operator|=
name|time_now
operator|.
name|tv_usec
operator|-
name|last_update
operator|.
name|tv_usec
expr_stmt|;
name|delta
operator|.
name|tv_sec
operator|=
name|time_now
operator|.
name|tv_sec
operator|-
name|last_update
operator|.
name|tv_sec
expr_stmt|;
if|if
condition|(
name|delta
operator|.
name|tv_usec
operator|<
literal|0
condition|)
block|{
name|delta
operator|.
name|tv_sec
operator|-=
literal|1
expr_stmt|;
name|delta
operator|.
name|tv_usec
operator|+=
literal|1000000
expr_stmt|;
block|}
name|new_section
operator|=
operator|(
name|previous_sect_name
condition|?
name|strcmp
argument_list|(
name|previous_sect_name
argument_list|,
name|section_name
argument_list|)
else|:
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|new_section
condition|)
block|{
name|xfree
argument_list|(
name|previous_sect_name
argument_list|)
expr_stmt|;
name|previous_sect_name
operator|=
name|xstrdup
argument_list|(
name|section_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_async_command
condition|)
name|fputs_unfiltered
argument_list|(
name|last_async_command
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
literal|"+download"
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|ui_out_tuple_begin
argument_list|(
name|uiout
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ui_out_field_string
argument_list|(
name|uiout
argument_list|,
literal|"section"
argument_list|,
name|section_name
argument_list|)
expr_stmt|;
name|ui_out_field_int
argument_list|(
name|uiout
argument_list|,
literal|"section-size"
argument_list|,
name|total_section
argument_list|)
expr_stmt|;
name|ui_out_field_int
argument_list|(
name|uiout
argument_list|,
literal|"total-size"
argument_list|,
name|grand_total
argument_list|)
expr_stmt|;
name|ui_out_tuple_end
argument_list|(
name|uiout
argument_list|)
expr_stmt|;
name|mi_out_put
argument_list|(
name|uiout
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
literal|"\n"
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|raw_stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|delta
operator|.
name|tv_sec
operator|>=
name|update_threshold
operator|.
name|tv_sec
operator|&&
name|delta
operator|.
name|tv_usec
operator|>=
name|update_threshold
operator|.
name|tv_usec
condition|)
block|{
name|last_update
operator|.
name|tv_sec
operator|=
name|time_now
operator|.
name|tv_sec
expr_stmt|;
name|last_update
operator|.
name|tv_usec
operator|=
name|time_now
operator|.
name|tv_usec
expr_stmt|;
if|if
condition|(
name|last_async_command
condition|)
name|fputs_unfiltered
argument_list|(
name|last_async_command
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
literal|"+download"
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|ui_out_tuple_begin
argument_list|(
name|uiout
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ui_out_field_string
argument_list|(
name|uiout
argument_list|,
literal|"section"
argument_list|,
name|section_name
argument_list|)
expr_stmt|;
name|ui_out_field_int
argument_list|(
name|uiout
argument_list|,
literal|"section-sent"
argument_list|,
name|sent_so_far
argument_list|)
expr_stmt|;
name|ui_out_field_int
argument_list|(
name|uiout
argument_list|,
literal|"section-size"
argument_list|,
name|total_section
argument_list|)
expr_stmt|;
name|ui_out_field_int
argument_list|(
name|uiout
argument_list|,
literal|"total-sent"
argument_list|,
name|total_sent
argument_list|)
expr_stmt|;
name|ui_out_field_int
argument_list|(
name|uiout
argument_list|,
literal|"total-size"
argument_list|,
name|grand_total
argument_list|)
expr_stmt|;
name|ui_out_tuple_end
argument_list|(
name|uiout
argument_list|)
expr_stmt|;
name|mi_out_put
argument_list|(
name|uiout
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
literal|"\n"
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|raw_stdout
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mi_command_loop
parameter_list|(
name|int
name|mi_version
parameter_list|)
block|{
comment|/* HACK: Force stdout/stderr to point at the console.  This avoids      any potential side effects caused by legacy code that is still      using the TUI / fputs_unfiltered_hook */
name|raw_stdout
operator|=
name|stdio_fileopen
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/* Route normal output through the MIx */
name|gdb_stdout
operator|=
name|mi_console_file_new
argument_list|(
name|raw_stdout
argument_list|,
literal|"~"
argument_list|)
expr_stmt|;
comment|/* Route error and log output through the MI */
name|gdb_stderr
operator|=
name|mi_console_file_new
argument_list|(
name|raw_stdout
argument_list|,
literal|"&"
argument_list|)
expr_stmt|;
name|gdb_stdlog
operator|=
name|gdb_stderr
expr_stmt|;
comment|/* Route target output through the MI. */
name|gdb_stdtarg
operator|=
name|mi_console_file_new
argument_list|(
name|raw_stdout
argument_list|,
literal|"@"
argument_list|)
expr_stmt|;
comment|/* HACK: Poke the ui_out table directly.  Should we be creating a      mi_out object wired up to the above gdb_stdout / gdb_stderr? */
name|uiout
operator|=
name|mi_out_new
argument_list|(
name|mi_version
argument_list|)
expr_stmt|;
comment|/* HACK: Override any other interpreter hooks.  We need to create a      real event table and pass in that. */
name|init_ui_hook
operator|=
literal|0
expr_stmt|;
comment|/* command_loop_hook = 0; */
name|print_frame_info_listing_hook
operator|=
literal|0
expr_stmt|;
name|query_hook
operator|=
literal|0
expr_stmt|;
name|warning_hook
operator|=
literal|0
expr_stmt|;
name|create_breakpoint_hook
operator|=
literal|0
expr_stmt|;
name|delete_breakpoint_hook
operator|=
literal|0
expr_stmt|;
name|modify_breakpoint_hook
operator|=
literal|0
expr_stmt|;
name|interactive_hook
operator|=
literal|0
expr_stmt|;
name|registers_changed_hook
operator|=
literal|0
expr_stmt|;
name|readline_begin_hook
operator|=
literal|0
expr_stmt|;
name|readline_hook
operator|=
literal|0
expr_stmt|;
name|readline_end_hook
operator|=
literal|0
expr_stmt|;
name|register_changed_hook
operator|=
literal|0
expr_stmt|;
name|memory_changed_hook
operator|=
literal|0
expr_stmt|;
name|context_hook
operator|=
literal|0
expr_stmt|;
name|target_wait_hook
operator|=
literal|0
expr_stmt|;
name|call_command_hook
operator|=
literal|0
expr_stmt|;
name|error_hook
operator|=
literal|0
expr_stmt|;
name|error_begin_hook
operator|=
literal|0
expr_stmt|;
name|show_load_progress
operator|=
name|mi_load_progress
expr_stmt|;
comment|/* Turn off 8 bit strings in quoted output.  Any character with the      high bit set is printed using C's octal format. */
name|sevenbit_strings
operator|=
literal|1
expr_stmt|;
comment|/* Tell the world that we're alive */
name|fputs_unfiltered
argument_list|(
literal|"(gdb) \n"
argument_list|,
name|raw_stdout
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|raw_stdout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|event_loop_p
condition|)
name|simplified_command_loop
argument_list|(
name|mi_input
argument_list|,
name|mi_execute_command
argument_list|)
expr_stmt|;
else|else
name|start_event_loop
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mi0_command_loop
parameter_list|(
name|void
parameter_list|)
block|{
name|mi_command_loop
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mi1_command_loop
parameter_list|(
name|void
parameter_list|)
block|{
name|mi_command_loop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|setup_architecture_data
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* don't trust REGISTER_BYTES to be zero. */
name|old_regs
operator|=
name|xmalloc
argument_list|(
name|REGISTER_BYTES
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|old_regs
argument_list|,
literal|0
argument_list|,
name|REGISTER_BYTES
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mi_init_ui
parameter_list|(
name|char
modifier|*
name|arg0
parameter_list|)
block|{
comment|/* Eventually this will contain code that takes control of the      console. */
block|}
end_function

begin_function
name|void
name|_initialize_mi_main
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|interpreter_p
operator|==
name|NULL
condition|)
return|return;
comment|/* If we're _the_ interpreter, take control. */
if|if
condition|(
name|strcmp
argument_list|(
name|interpreter_p
argument_list|,
literal|"mi0"
argument_list|)
operator|==
literal|0
condition|)
name|command_loop_hook
operator|=
name|mi0_command_loop
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|interpreter_p
argument_list|,
literal|"mi"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|interpreter_p
argument_list|,
literal|"mi1"
argument_list|)
operator|==
literal|0
condition|)
name|command_loop_hook
operator|=
name|mi1_command_loop
expr_stmt|;
else|else
return|return;
name|init_ui_hook
operator|=
name|mi_init_ui
expr_stmt|;
name|setup_architecture_data
argument_list|()
expr_stmt|;
name|register_gdbarch_swap
argument_list|(
operator|&
name|old_regs
argument_list|,
sizeof|sizeof
argument_list|(
name|old_regs
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|register_gdbarch_swap
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|setup_architecture_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|event_loop_p
condition|)
block|{
comment|/* These overwrite some of the initialization done in 	 _intialize_event_loop. */
name|call_readline
operator|=
name|gdb_readline2
expr_stmt|;
name|input_handler
operator|=
name|mi_execute_command_wrapper
expr_stmt|;
name|add_file_handler
argument_list|(
name|input_fd
argument_list|,
name|stdin_event_handler
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|async_command_editing_p
operator|=
literal|0
expr_stmt|;
block|}
comment|/* FIXME: Should we notify main that we are here as a possible      interpreter? */
block|}
end_function

end_unit

