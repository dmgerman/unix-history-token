begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Native-dependent code for FreeBSD/i386.     Copyright 2001, 2002, 2003, 2004 Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/ptrace.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|"i386-tdep.h"
end_include

begin_comment
comment|/* Prevent warning from -Wmissing-prototypes.  */
end_comment

begin_function_decl
name|void
name|_initialize_i386fbsd_nat
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Resume execution of the inferior process.    If STEP is nonzero, single-step it.    If SIGNAL is nonzero, give it that signal.  */
end_comment

begin_function
name|void
name|child_resume
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
name|int
name|step
parameter_list|,
name|enum
name|target_signal
name|signal
parameter_list|)
block|{
name|pid_t
name|pid
init|=
name|ptid_get_pid
argument_list|(
name|ptid
argument_list|)
decl_stmt|;
name|int
name|request
init|=
name|PT_STEP
decl_stmt|;
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
comment|/* Resume all threads.  This only gets used in the non-threaded        case, where "resume all threads" and "resume inferior_ptid" are        the same.  */
name|pid
operator|=
name|ptid_get_pid
argument_list|(
name|inferior_ptid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|step
condition|)
block|{
name|ULONGEST
name|eflags
decl_stmt|;
comment|/* Workaround for a bug in FreeBSD.  Make sure that the trace  	 flag is off when doing a continue.  There is a code path  	 through the kernel which leaves the flag set when it should  	 have been cleared.  If a process has a signal pending (such  	 as SIGALRM) and we do a PT_STEP, the process never really has  	 a chance to run because the kernel needs to notify the  	 debugger that a signal is being sent.  Therefore, the process  	 never goes through the kernel's trap() function which would  	 normally clear it.  */
name|regcache_cooked_read_unsigned
argument_list|(
name|current_regcache
argument_list|,
name|I386_EFLAGS_REGNUM
argument_list|,
operator|&
name|eflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|eflags
operator|&
literal|0x0100
condition|)
name|regcache_cooked_write_unsigned
argument_list|(
name|current_regcache
argument_list|,
name|I386_EFLAGS_REGNUM
argument_list|,
name|eflags
operator|&
operator|~
literal|0x0100
argument_list|)
expr_stmt|;
name|request
operator|=
name|PT_CONTINUE
expr_stmt|;
block|}
comment|/* An addres of (caddr_t) 1 tells ptrace to continue from where it      was.  (If GDB wanted it to start some other way, we have already      written a new PC value to the child.)  */
if|if
condition|(
name|ptrace
argument_list|(
name|request
argument_list|,
name|pid
argument_list|,
operator|(
name|caddr_t
operator|)
literal|1
argument_list|,
name|target_signal_to_host
argument_list|(
name|signal
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|perror_with_name
argument_list|(
literal|"ptrace"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|_initialize_i386fbsd_nat
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* FreeBSD provides a kern.ps_strings sysctl that we can use to      locate the sigtramp.  That way we can still recognize a sigtramp      if its location is changed in a new kernel.  Of course this is      still based on the assumption that the sigtramp is placed      directly under the location where the program arguments and      environment can be found.  */
ifdef|#
directive|ifdef
name|KERN_PS_STRINGS
block|{
name|int
name|mib
index|[
literal|2
index|]
decl_stmt|;
name|int
name|ps_strings
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|mib
index|[
literal|0
index|]
operator|=
name|CTL_KERN
expr_stmt|;
name|mib
index|[
literal|1
index|]
operator|=
name|KERN_PS_STRINGS
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|ps_strings
argument_list|)
expr_stmt|;
if|if
condition|(
name|sysctl
argument_list|(
name|mib
argument_list|,
literal|2
argument_list|,
operator|&
name|ps_strings
argument_list|,
operator|&
name|len
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
name|i386fbsd_sigtramp_start_addr
operator|=
name|ps_strings
operator|-
literal|128
expr_stmt|;
name|i386fbsd_sigtramp_end_addr
operator|=
name|ps_strings
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
end_function

end_unit

