begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Intel 387 floating point stuff.     Copyright 1988, 1989, 1991, 1992, 1993, 1994, 1998, 1999, 2000,    2001, 2002, 2003, 2004 Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"doublest.h"
end_include

begin_include
include|#
directive|include
file|"floatformat.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"gdb_assert.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"i386-tdep.h"
end_include

begin_include
include|#
directive|include
file|"i387-tdep.h"
end_include

begin_comment
comment|/* Implement the `info float' layout based on the register definitions    in `tm-i386.h'.  */
end_comment

begin_comment
comment|/* Print the floating point number specified by RAW.  */
end_comment

begin_function
specifier|static
name|void
name|print_i387_value
parameter_list|(
name|char
modifier|*
name|raw
parameter_list|,
name|struct
name|ui_file
modifier|*
name|file
parameter_list|)
block|{
name|DOUBLEST
name|value
decl_stmt|;
comment|/* Using extract_typed_floating here might affect the representation      of certain numbers such as NaNs, even if GDB is running natively.      This is fine since our caller already detects such special      numbers and we print the hexadecimal representation anyway.  */
name|value
operator|=
name|extract_typed_floating
argument_list|(
name|raw
argument_list|,
name|builtin_type_i387_ext
argument_list|)
expr_stmt|;
comment|/* We try to print 19 digits.  The last digit may or may not contain      garbage, but we'd better print one too many.  We need enough room      to print the value, 1 position for the sign, 1 for the decimal      point, 19 for the digits and 6 for the exponent adds up to 27.  */
ifdef|#
directive|ifdef
name|PRINTF_HAS_LONG_DOUBLE
name|fprintf_filtered
argument_list|(
name|file
argument_list|,
literal|" %-+27.19Lg"
argument_list|,
operator|(
name|long
name|double
operator|)
name|value
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf_filtered
argument_list|(
name|file
argument_list|,
literal|" %-+27.19g"
argument_list|,
operator|(
name|double
operator|)
name|value
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Print the classification for the register contents RAW.  */
end_comment

begin_function
specifier|static
name|void
name|print_i387_ext
parameter_list|(
name|unsigned
name|char
modifier|*
name|raw
parameter_list|,
name|struct
name|ui_file
modifier|*
name|file
parameter_list|)
block|{
name|int
name|sign
decl_stmt|;
name|int
name|integer
decl_stmt|;
name|unsigned
name|int
name|exponent
decl_stmt|;
name|unsigned
name|long
name|fraction
index|[
literal|2
index|]
decl_stmt|;
name|sign
operator|=
name|raw
index|[
literal|9
index|]
operator|&
literal|0x80
expr_stmt|;
name|integer
operator|=
name|raw
index|[
literal|7
index|]
operator|&
literal|0x80
expr_stmt|;
name|exponent
operator|=
operator|(
operator|(
operator|(
name|raw
index|[
literal|9
index|]
operator|&
literal|0x7f
operator|)
operator|<<
literal|8
operator|)
operator||
name|raw
index|[
literal|8
index|]
operator|)
expr_stmt|;
name|fraction
index|[
literal|0
index|]
operator|=
operator|(
operator|(
name|raw
index|[
literal|3
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|raw
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|raw
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
name|raw
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|fraction
index|[
literal|1
index|]
operator|=
operator|(
operator|(
operator|(
name|raw
index|[
literal|7
index|]
operator|&
literal|0x7f
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
name|raw
index|[
literal|6
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|raw
index|[
literal|5
index|]
operator|<<
literal|8
operator|)
operator||
name|raw
index|[
literal|4
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|exponent
operator|==
literal|0x7fff
operator|&&
name|integer
condition|)
block|{
if|if
condition|(
name|fraction
index|[
literal|0
index|]
operator|==
literal|0x00000000
operator|&&
name|fraction
index|[
literal|1
index|]
operator|==
literal|0x00000000
condition|)
comment|/* Infinity.  */
name|fprintf_filtered
argument_list|(
name|file
argument_list|,
literal|" %cInf"
argument_list|,
operator|(
name|sign
condition|?
literal|'-'
else|:
literal|'+'
operator|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sign
operator|&&
name|fraction
index|[
literal|0
index|]
operator|==
literal|0x00000000
operator|&&
name|fraction
index|[
literal|1
index|]
operator|==
literal|0x40000000
condition|)
comment|/* Real Indefinite (QNaN).  */
name|fputs_unfiltered
argument_list|(
literal|" Real Indefinite (QNaN)"
argument_list|,
name|file
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fraction
index|[
literal|1
index|]
operator|&
literal|0x40000000
condition|)
comment|/* QNaN.  */
name|fputs_filtered
argument_list|(
literal|" QNaN"
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
comment|/* SNaN.  */
name|fputs_filtered
argument_list|(
literal|" SNaN"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|exponent
operator|<
literal|0x7fff
operator|&&
name|exponent
operator|>
literal|0x0000
operator|&&
name|integer
condition|)
comment|/* Normal.  */
name|print_i387_value
argument_list|(
name|raw
argument_list|,
name|file
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|exponent
operator|==
literal|0x0000
condition|)
block|{
comment|/* Denormal or zero.  */
name|print_i387_value
argument_list|(
name|raw
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|integer
condition|)
comment|/* Pseudo-denormal.  */
name|fputs_filtered
argument_list|(
literal|" Pseudo-denormal"
argument_list|,
name|file
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fraction
index|[
literal|0
index|]
operator|||
name|fraction
index|[
literal|1
index|]
condition|)
comment|/* Denormal.  */
name|fputs_filtered
argument_list|(
literal|" Denormal"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Unsupported.  */
name|fputs_filtered
argument_list|(
literal|" Unsupported"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print the status word STATUS.  */
end_comment

begin_function
specifier|static
name|void
name|print_i387_status_word
parameter_list|(
name|unsigned
name|int
name|status
parameter_list|,
name|struct
name|ui_file
modifier|*
name|file
parameter_list|)
block|{
name|fprintf_filtered
argument_list|(
name|file
argument_list|,
literal|"Status Word:         %s"
argument_list|,
name|local_hex_string_custom
argument_list|(
name|status
argument_list|,
literal|"04"
argument_list|)
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"  "
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|file
argument_list|,
literal|" %s"
argument_list|,
operator|(
name|status
operator|&
literal|0x0001
operator|)
condition|?
literal|"IE"
else|:
literal|"  "
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|file
argument_list|,
literal|" %s"
argument_list|,
operator|(
name|status
operator|&
literal|0x0002
operator|)
condition|?
literal|"DE"
else|:
literal|"  "
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|file
argument_list|,
literal|" %s"
argument_list|,
operator|(
name|status
operator|&
literal|0x0004
operator|)
condition|?
literal|"ZE"
else|:
literal|"  "
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|file
argument_list|,
literal|" %s"
argument_list|,
operator|(
name|status
operator|&
literal|0x0008
operator|)
condition|?
literal|"OE"
else|:
literal|"  "
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|file
argument_list|,
literal|" %s"
argument_list|,
operator|(
name|status
operator|&
literal|0x0010
operator|)
condition|?
literal|"UE"
else|:
literal|"  "
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|file
argument_list|,
literal|" %s"
argument_list|,
operator|(
name|status
operator|&
literal|0x0020
operator|)
condition|?
literal|"PE"
else|:
literal|"  "
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"  "
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|file
argument_list|,
literal|" %s"
argument_list|,
operator|(
name|status
operator|&
literal|0x0080
operator|)
condition|?
literal|"ES"
else|:
literal|"  "
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"  "
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|file
argument_list|,
literal|" %s"
argument_list|,
operator|(
name|status
operator|&
literal|0x0040
operator|)
condition|?
literal|"SF"
else|:
literal|"  "
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"  "
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|file
argument_list|,
literal|" %s"
argument_list|,
operator|(
name|status
operator|&
literal|0x0100
operator|)
condition|?
literal|"C0"
else|:
literal|"  "
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|file
argument_list|,
literal|" %s"
argument_list|,
operator|(
name|status
operator|&
literal|0x0200
operator|)
condition|?
literal|"C1"
else|:
literal|"  "
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|file
argument_list|,
literal|" %s"
argument_list|,
operator|(
name|status
operator|&
literal|0x0400
operator|)
condition|?
literal|"C2"
else|:
literal|"  "
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|file
argument_list|,
literal|" %s"
argument_list|,
operator|(
name|status
operator|&
literal|0x4000
operator|)
condition|?
literal|"C3"
else|:
literal|"  "
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|file
argument_list|,
literal|"                       TOP: %d\n"
argument_list|,
operator|(
operator|(
name|status
operator|>>
literal|11
operator|)
operator|&
literal|7
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print the control word CONTROL.  */
end_comment

begin_function
specifier|static
name|void
name|print_i387_control_word
parameter_list|(
name|unsigned
name|int
name|control
parameter_list|,
name|struct
name|ui_file
modifier|*
name|file
parameter_list|)
block|{
name|fprintf_filtered
argument_list|(
name|file
argument_list|,
literal|"Control Word:        %s"
argument_list|,
name|local_hex_string_custom
argument_list|(
name|control
argument_list|,
literal|"04"
argument_list|)
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"  "
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|file
argument_list|,
literal|" %s"
argument_list|,
operator|(
name|control
operator|&
literal|0x0001
operator|)
condition|?
literal|"IM"
else|:
literal|"  "
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|file
argument_list|,
literal|" %s"
argument_list|,
operator|(
name|control
operator|&
literal|0x0002
operator|)
condition|?
literal|"DM"
else|:
literal|"  "
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|file
argument_list|,
literal|" %s"
argument_list|,
operator|(
name|control
operator|&
literal|0x0004
operator|)
condition|?
literal|"ZM"
else|:
literal|"  "
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|file
argument_list|,
literal|" %s"
argument_list|,
operator|(
name|control
operator|&
literal|0x0008
operator|)
condition|?
literal|"OM"
else|:
literal|"  "
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|file
argument_list|,
literal|" %s"
argument_list|,
operator|(
name|control
operator|&
literal|0x0010
operator|)
condition|?
literal|"UM"
else|:
literal|"  "
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|file
argument_list|,
literal|" %s"
argument_list|,
operator|(
name|control
operator|&
literal|0x0020
operator|)
condition|?
literal|"PM"
else|:
literal|"  "
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"                       PC: "
argument_list|,
name|file
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|(
name|control
operator|>>
literal|8
operator|)
operator|&
literal|3
condition|)
block|{
case|case
literal|0
case|:
name|fputs_filtered
argument_list|(
literal|"Single Precision (24-bits)\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|fputs_filtered
argument_list|(
literal|"Reserved\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|fputs_filtered
argument_list|(
literal|"Double Precision (53-bits)\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|fputs_filtered
argument_list|(
literal|"Extended Precision (64-bits)\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
block|}
name|fputs_filtered
argument_list|(
literal|"                       RC: "
argument_list|,
name|file
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|(
name|control
operator|>>
literal|10
operator|)
operator|&
literal|3
condition|)
block|{
case|case
literal|0
case|:
name|fputs_filtered
argument_list|(
literal|"Round to nearest\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|fputs_filtered
argument_list|(
literal|"Round down\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|fputs_filtered
argument_list|(
literal|"Round up\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|fputs_filtered
argument_list|(
literal|"Round toward zero\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Print out the i387 floating point state.  Note that we ignore FRAME    in the code below.  That's OK since floating-point registers are    never saved on the stack.  */
end_comment

begin_function
name|void
name|i387_print_float_info
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|struct
name|ui_file
modifier|*
name|file
parameter_list|,
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|,
specifier|const
name|char
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|get_frame_arch
argument_list|(
name|frame
argument_list|)
argument_list|)
decl_stmt|;
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|ULONGEST
name|fctrl
decl_stmt|;
name|ULONGEST
name|fstat
decl_stmt|;
name|ULONGEST
name|ftag
decl_stmt|;
name|ULONGEST
name|fiseg
decl_stmt|;
name|ULONGEST
name|fioff
decl_stmt|;
name|ULONGEST
name|foseg
decl_stmt|;
name|ULONGEST
name|fooff
decl_stmt|;
name|ULONGEST
name|fop
decl_stmt|;
name|int
name|fpreg
decl_stmt|;
name|int
name|top
decl_stmt|;
name|gdb_assert
argument_list|(
name|gdbarch
operator|==
name|get_frame_arch
argument_list|(
name|frame
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Define I387_ST0_REGNUM such that we use the proper definitions      for FRAME's architecture.  */
define|#
directive|define
name|I387_ST0_REGNUM
value|tdep->st0_regnum
name|fctrl
operator|=
name|get_frame_register_unsigned
argument_list|(
name|frame
argument_list|,
name|I387_FCTRL_REGNUM
argument_list|)
expr_stmt|;
name|fstat
operator|=
name|get_frame_register_unsigned
argument_list|(
name|frame
argument_list|,
name|I387_FSTAT_REGNUM
argument_list|)
expr_stmt|;
name|ftag
operator|=
name|get_frame_register_unsigned
argument_list|(
name|frame
argument_list|,
name|I387_FTAG_REGNUM
argument_list|)
expr_stmt|;
name|fiseg
operator|=
name|get_frame_register_unsigned
argument_list|(
name|frame
argument_list|,
name|I387_FISEG_REGNUM
argument_list|)
expr_stmt|;
name|fioff
operator|=
name|get_frame_register_unsigned
argument_list|(
name|frame
argument_list|,
name|I387_FIOFF_REGNUM
argument_list|)
expr_stmt|;
name|foseg
operator|=
name|get_frame_register_unsigned
argument_list|(
name|frame
argument_list|,
name|I387_FOSEG_REGNUM
argument_list|)
expr_stmt|;
name|fooff
operator|=
name|get_frame_register_unsigned
argument_list|(
name|frame
argument_list|,
name|I387_FOOFF_REGNUM
argument_list|)
expr_stmt|;
name|fop
operator|=
name|get_frame_register_unsigned
argument_list|(
name|frame
argument_list|,
name|I387_FOP_REGNUM
argument_list|)
expr_stmt|;
name|top
operator|=
operator|(
operator|(
name|fstat
operator|>>
literal|11
operator|)
operator|&
literal|7
operator|)
expr_stmt|;
for|for
control|(
name|fpreg
operator|=
literal|7
init|;
name|fpreg
operator|>=
literal|0
condition|;
name|fpreg
operator|--
control|)
block|{
name|unsigned
name|char
name|raw
index|[
name|I386_MAX_REGISTER_SIZE
index|]
decl_stmt|;
name|int
name|tag
init|=
operator|(
name|ftag
operator|>>
operator|(
name|fpreg
operator|*
literal|2
operator|)
operator|)
operator|&
literal|3
decl_stmt|;
name|int
name|i
decl_stmt|;
name|fprintf_filtered
argument_list|(
name|file
argument_list|,
literal|"%sR%d: "
argument_list|,
name|fpreg
operator|==
name|top
condition|?
literal|"=>"
else|:
literal|"  "
argument_list|,
name|fpreg
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tag
condition|)
block|{
case|case
literal|0
case|:
name|fputs_filtered
argument_list|(
literal|"Valid   "
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|fputs_filtered
argument_list|(
literal|"Zero    "
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|fputs_filtered
argument_list|(
literal|"Special "
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|fputs_filtered
argument_list|(
literal|"Empty   "
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
block|}
name|get_frame_register
argument_list|(
name|frame
argument_list|,
operator|(
name|fpreg
operator|+
literal|8
operator|-
name|top
operator|)
operator|%
literal|8
operator|+
name|I387_ST0_REGNUM
argument_list|,
name|raw
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"0x"
argument_list|,
name|file
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|9
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|fprintf_filtered
argument_list|(
name|file
argument_list|,
literal|"%02x"
argument_list|,
name|raw
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag
operator|!=
literal|3
condition|)
name|print_i387_ext
argument_list|(
name|raw
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
name|fputs_filtered
argument_list|(
literal|"\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|print_i387_status_word
argument_list|(
name|fstat
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|print_i387_control_word
argument_list|(
name|fctrl
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|file
argument_list|,
literal|"Tag Word:            %s\n"
argument_list|,
name|local_hex_string_custom
argument_list|(
name|ftag
argument_list|,
literal|"04"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|file
argument_list|,
literal|"Instruction Pointer: %s:"
argument_list|,
name|local_hex_string_custom
argument_list|(
name|fiseg
argument_list|,
literal|"02"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|file
argument_list|,
literal|"%s\n"
argument_list|,
name|local_hex_string_custom
argument_list|(
name|fioff
argument_list|,
literal|"08"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|file
argument_list|,
literal|"Operand Pointer:     %s:"
argument_list|,
name|local_hex_string_custom
argument_list|(
name|foseg
argument_list|,
literal|"02"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|file
argument_list|,
literal|"%s\n"
argument_list|,
name|local_hex_string_custom
argument_list|(
name|fooff
argument_list|,
literal|"08"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|file
argument_list|,
literal|"Opcode:              %s\n"
argument_list|,
name|local_hex_string_custom
argument_list|(
name|fop
condition|?
operator|(
name|fop
operator||
literal|0xd800
operator|)
else|:
literal|0
argument_list|,
literal|"04"
argument_list|)
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|I387_ST0_REGNUM
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read a value of type TYPE from register REGNUM in frame FRAME, and    return its contents in TO.  */
end_comment

begin_function
name|void
name|i387_register_to_value
parameter_list|(
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|,
name|int
name|regnum
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|void
modifier|*
name|to
parameter_list|)
block|{
name|char
name|from
index|[
name|I386_MAX_REGISTER_SIZE
index|]
decl_stmt|;
name|gdb_assert
argument_list|(
name|i386_fp_regnum_p
argument_list|(
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We only support floating-point values.  */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_CODE_FLT
condition|)
block|{
name|warning
argument_list|(
literal|"Cannot convert floating-point register value "
literal|"to non-floating-point type."
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Convert to TYPE.  This should be a no-op if TYPE is equivalent to      the extended floating-point format used by the FPU.  */
name|get_frame_register
argument_list|(
name|frame
argument_list|,
name|regnum
argument_list|,
name|from
argument_list|)
expr_stmt|;
name|convert_typed_floating
argument_list|(
name|from
argument_list|,
name|builtin_type_i387_ext
argument_list|,
name|to
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write the contents FROM of a value of type TYPE into register    REGNUM in frame FRAME.  */
end_comment

begin_function
name|void
name|i387_value_to_register
parameter_list|(
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|,
name|int
name|regnum
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|,
specifier|const
name|void
modifier|*
name|from
parameter_list|)
block|{
name|char
name|to
index|[
name|I386_MAX_REGISTER_SIZE
index|]
decl_stmt|;
name|gdb_assert
argument_list|(
name|i386_fp_regnum_p
argument_list|(
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We only support floating-point values.  */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_CODE_FLT
condition|)
block|{
name|warning
argument_list|(
literal|"Cannot convert non-floating-point type "
literal|"to floating-point register value."
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Convert from TYPE.  This should be a no-op if TYPE is equivalent      to the extended floating-point format used by the FPU.  */
name|convert_typed_floating
argument_list|(
name|from
argument_list|,
name|type
argument_list|,
name|to
argument_list|,
name|builtin_type_i387_ext
argument_list|)
expr_stmt|;
name|put_frame_register
argument_list|(
name|frame
argument_list|,
name|regnum
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_escape
end_escape

begin_comment
comment|/* Handle FSAVE and FXSAVE formats.  */
end_comment

begin_comment
comment|/* FIXME: kettenis/20030927: The functions below should accept a    `regcache' argument, but I don't want to change the function    signature just yet.  There's some band-aid in the functions below    in the form of the `regcache' local variables.  This will ease the    transition later on.  */
end_comment

begin_comment
comment|/* At fsave_offset[REGNUM] you'll find the offset to the location in    the data structure used by the "fsave" instruction where GDB    register REGNUM is stored.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|fsave_offset
index|[]
init|=
block|{
literal|28
operator|+
literal|0
operator|*
literal|10
block|,
comment|/* %st(0) ...  */
literal|28
operator|+
literal|1
operator|*
literal|10
block|,
literal|28
operator|+
literal|2
operator|*
literal|10
block|,
literal|28
operator|+
literal|3
operator|*
literal|10
block|,
literal|28
operator|+
literal|4
operator|*
literal|10
block|,
literal|28
operator|+
literal|5
operator|*
literal|10
block|,
literal|28
operator|+
literal|6
operator|*
literal|10
block|,
literal|28
operator|+
literal|7
operator|*
literal|10
block|,
comment|/* ... %st(7).  */
literal|0
block|,
comment|/* `fctrl' (16 bits).  */
literal|4
block|,
comment|/* `fstat' (16 bits).  */
literal|8
block|,
comment|/* `ftag' (16 bits).  */
literal|16
block|,
comment|/* `fiseg' (16 bits).  */
literal|12
block|,
comment|/* `fioff'.  */
literal|24
block|,
comment|/* `foseg' (16 bits).  */
literal|20
block|,
comment|/* `fooff'.  */
literal|18
comment|/* `fop' (bottom 11 bits).  */
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|FSAVE_ADDR
parameter_list|(
name|fsave
parameter_list|,
name|regnum
parameter_list|)
define|\
value|(fsave + fsave_offset[regnum - I387_ST0_REGNUM])
end_define

begin_escape
end_escape

begin_comment
comment|/* Fill register REGNUM in REGCACHE with the appropriate value from    *FSAVE.  This function masks off any of the reserved bits in    *FSAVE.  */
end_comment

begin_function
name|void
name|i387_supply_fsave
parameter_list|(
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|int
name|regnum
parameter_list|,
specifier|const
name|void
modifier|*
name|fsave
parameter_list|)
block|{
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|get_regcache_arch
argument_list|(
name|regcache
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|regs
init|=
name|fsave
decl_stmt|;
name|int
name|i
decl_stmt|;
name|gdb_assert
argument_list|(
name|tdep
operator|->
name|st0_regnum
operator|>=
name|I386_ST0_REGNUM
argument_list|)
expr_stmt|;
comment|/* Define I387_ST0_REGNUM such that we use the proper definitions      for REGCACHE's architecture.  */
define|#
directive|define
name|I387_ST0_REGNUM
value|tdep->st0_regnum
for|for
control|(
name|i
operator|=
name|I387_ST0_REGNUM
init|;
name|i
operator|<
name|I387_XMM0_REGNUM
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regnum
operator|==
operator|-
literal|1
operator|||
name|regnum
operator|==
name|i
condition|)
block|{
if|if
condition|(
name|fsave
operator|==
name|NULL
condition|)
block|{
name|regcache_raw_supply
argument_list|(
name|regcache
argument_list|,
name|i
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Most of the FPU control registers occupy only 16 bits in the 	   fsave area.  Give those a special treatment.  */
if|if
condition|(
name|i
operator|>=
name|I387_FCTRL_REGNUM
operator|&&
name|i
operator|!=
name|I387_FIOFF_REGNUM
operator|&&
name|i
operator|!=
name|I387_FOOFF_REGNUM
condition|)
block|{
name|unsigned
name|char
name|val
index|[
literal|4
index|]
decl_stmt|;
name|memcpy
argument_list|(
name|val
argument_list|,
name|FSAVE_ADDR
argument_list|(
name|regs
argument_list|,
name|i
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|val
index|[
literal|2
index|]
operator|=
name|val
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|I387_FOP_REGNUM
condition|)
name|val
index|[
literal|1
index|]
operator|&=
operator|(
operator|(
literal|1
operator|<<
literal|3
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
name|regcache_raw_supply
argument_list|(
name|regcache
argument_list|,
name|i
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
else|else
name|regcache_raw_supply
argument_list|(
name|regcache
argument_list|,
name|i
argument_list|,
name|FSAVE_ADDR
argument_list|(
name|regs
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
undef|#
directive|undef
name|I387_ST0_REGNUM
block|}
end_function

begin_comment
comment|/* Fill register REGNUM (if it is a floating-point register) in *FSAVE    with the value in GDB's register cache.  If REGNUM is -1, do this    for all registers.  This function doesn't touch any of the reserved    bits in *FSAVE.  */
end_comment

begin_function
name|void
name|i387_fill_fsave
parameter_list|(
name|void
modifier|*
name|fsave
parameter_list|,
name|int
name|regnum
parameter_list|)
block|{
name|struct
name|regcache
modifier|*
name|regcache
init|=
name|current_regcache
decl_stmt|;
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
decl_stmt|;
name|char
modifier|*
name|regs
init|=
name|fsave
decl_stmt|;
name|int
name|i
decl_stmt|;
name|gdb_assert
argument_list|(
name|tdep
operator|->
name|st0_regnum
operator|>=
name|I386_ST0_REGNUM
argument_list|)
expr_stmt|;
comment|/* Define I387_ST0_REGNUM such that we use the proper definitions      for REGCACHE's architecture.  */
define|#
directive|define
name|I387_ST0_REGNUM
value|tdep->st0_regnum
for|for
control|(
name|i
operator|=
name|I387_ST0_REGNUM
init|;
name|i
operator|<
name|I387_XMM0_REGNUM
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regnum
operator|==
operator|-
literal|1
operator|||
name|regnum
operator|==
name|i
condition|)
block|{
comment|/* Most of the FPU control registers occupy only 16 bits in            the fsave area.  Give those a special treatment.  */
if|if
condition|(
name|i
operator|>=
name|I387_FCTRL_REGNUM
operator|&&
name|i
operator|!=
name|I387_FIOFF_REGNUM
operator|&&
name|i
operator|!=
name|I387_FOOFF_REGNUM
condition|)
block|{
name|unsigned
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|regcache_raw_collect
argument_list|(
name|regcache
argument_list|,
name|i
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|I387_FOP_REGNUM
condition|)
block|{
comment|/* The opcode occupies only 11 bits.  Make sure we                    don't touch the other bits.  */
name|buf
index|[
literal|1
index|]
operator|&=
operator|(
operator|(
literal|1
operator|<<
literal|3
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator||=
operator|(
operator|(
name|FSAVE_ADDR
argument_list|(
name|regs
argument_list|,
name|i
argument_list|)
operator|)
index|[
literal|1
index|]
operator|&
operator|~
operator|(
operator|(
literal|1
operator|<<
literal|3
operator|)
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|FSAVE_ADDR
argument_list|(
name|regs
argument_list|,
name|i
argument_list|)
argument_list|,
name|buf
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
name|regcache_raw_collect
argument_list|(
name|regcache
argument_list|,
name|i
argument_list|,
name|FSAVE_ADDR
argument_list|(
name|regs
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
undef|#
directive|undef
name|I387_ST0_REGNUM
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* At fxsave_offset[REGNUM] you'll find the offset to the location in    the data structure used by the "fxsave" instruction where GDB    register REGNUM is stored.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|fxsave_offset
index|[]
init|=
block|{
literal|32
block|,
comment|/* %st(0) through ...  */
literal|48
block|,
literal|64
block|,
literal|80
block|,
literal|96
block|,
literal|112
block|,
literal|128
block|,
literal|144
block|,
comment|/* ... %st(7) (80 bits each).  */
literal|0
block|,
comment|/* `fctrl' (16 bits).  */
literal|2
block|,
comment|/* `fstat' (16 bits).  */
literal|4
block|,
comment|/* `ftag' (16 bits).  */
literal|12
block|,
comment|/* `fiseg' (16 bits).  */
literal|8
block|,
comment|/* `fioff'.  */
literal|20
block|,
comment|/* `foseg' (16 bits).  */
literal|16
block|,
comment|/* `fooff'.  */
literal|6
block|,
comment|/* `fop' (bottom 11 bits).  */
literal|160
operator|+
literal|0
operator|*
literal|16
block|,
comment|/* %xmm0 through ...  */
literal|160
operator|+
literal|1
operator|*
literal|16
block|,
literal|160
operator|+
literal|2
operator|*
literal|16
block|,
literal|160
operator|+
literal|3
operator|*
literal|16
block|,
literal|160
operator|+
literal|4
operator|*
literal|16
block|,
literal|160
operator|+
literal|5
operator|*
literal|16
block|,
literal|160
operator|+
literal|6
operator|*
literal|16
block|,
literal|160
operator|+
literal|7
operator|*
literal|16
block|,
literal|160
operator|+
literal|8
operator|*
literal|16
block|,
literal|160
operator|+
literal|9
operator|*
literal|16
block|,
literal|160
operator|+
literal|10
operator|*
literal|16
block|,
literal|160
operator|+
literal|11
operator|*
literal|16
block|,
literal|160
operator|+
literal|12
operator|*
literal|16
block|,
literal|160
operator|+
literal|13
operator|*
literal|16
block|,
literal|160
operator|+
literal|14
operator|*
literal|16
block|,
literal|160
operator|+
literal|15
operator|*
literal|16
block|,
comment|/* ... %xmm15 (128 bits each).  */
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|FXSAVE_ADDR
parameter_list|(
name|fxsave
parameter_list|,
name|regnum
parameter_list|)
define|\
value|(fxsave + fxsave_offset[regnum - I387_ST0_REGNUM])
end_define

begin_comment
comment|/* We made an unfortunate choice in putting %mxcsr after the SSE    registers %xmm0-%xmm7 instead of before, since it makes supporting    the registers %xmm8-%xmm15 on AMD64 a bit involved.  Therefore we    don't include the offset for %mxcsr here above.  */
end_comment

begin_define
define|#
directive|define
name|FXSAVE_MXCSR_ADDR
parameter_list|(
name|fxsave
parameter_list|)
value|(fxsave + 24)
end_define

begin_function_decl
specifier|static
name|int
name|i387_tag
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|raw
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Fill register REGNUM in REGCACHE with the appropriate    floating-point or SSE register value from *FXSAVE.  This function    masks off any of the reserved bits in *FXSAVE.  */
end_comment

begin_function
name|void
name|i387_supply_fxsave
parameter_list|(
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|int
name|regnum
parameter_list|,
specifier|const
name|void
modifier|*
name|fxsave
parameter_list|)
block|{
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|get_regcache_arch
argument_list|(
name|regcache
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|regs
init|=
name|fxsave
decl_stmt|;
name|int
name|i
decl_stmt|;
name|gdb_assert
argument_list|(
name|tdep
operator|->
name|st0_regnum
operator|>=
name|I386_ST0_REGNUM
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
name|tdep
operator|->
name|num_xmm_regs
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|/* Define I387_ST0_REGNUM and I387_NUM_XMM_REGS such that we use the      proper definitions for REGCACHE's architecture.  */
define|#
directive|define
name|I387_ST0_REGNUM
value|tdep->st0_regnum
define|#
directive|define
name|I387_NUM_XMM_REGS
value|tdep->num_xmm_regs
for|for
control|(
name|i
operator|=
name|I387_ST0_REGNUM
init|;
name|i
operator|<
name|I387_MXCSR_REGNUM
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regnum
operator|==
operator|-
literal|1
operator|||
name|regnum
operator|==
name|i
condition|)
block|{
if|if
condition|(
name|regs
operator|==
name|NULL
condition|)
block|{
name|regcache_raw_supply
argument_list|(
name|regcache
argument_list|,
name|i
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Most of the FPU control registers occupy only 16 bits in 	   the fxsave area.  Give those a special treatment.  */
if|if
condition|(
name|i
operator|>=
name|I387_FCTRL_REGNUM
operator|&&
name|i
operator|<
name|I387_XMM0_REGNUM
operator|&&
name|i
operator|!=
name|I387_FIOFF_REGNUM
operator|&&
name|i
operator|!=
name|I387_FOOFF_REGNUM
condition|)
block|{
name|unsigned
name|char
name|val
index|[
literal|4
index|]
decl_stmt|;
name|memcpy
argument_list|(
name|val
argument_list|,
name|FXSAVE_ADDR
argument_list|(
name|regs
argument_list|,
name|i
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|val
index|[
literal|2
index|]
operator|=
name|val
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|I387_FOP_REGNUM
condition|)
name|val
index|[
literal|1
index|]
operator|&=
operator|(
operator|(
literal|1
operator|<<
literal|3
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
name|I387_FTAG_REGNUM
condition|)
block|{
comment|/* The fxsave area contains a simplified version of 		   the tag word.  We have to look at the actual 80-bit 		   FP data to recreate the traditional i387 tag word.  */
name|unsigned
name|long
name|ftag
init|=
literal|0
decl_stmt|;
name|int
name|fpreg
decl_stmt|;
name|int
name|top
decl_stmt|;
name|top
operator|=
operator|(
operator|(
name|FXSAVE_ADDR
argument_list|(
name|regs
argument_list|,
name|I387_FSTAT_REGNUM
argument_list|)
operator|)
index|[
literal|1
index|]
operator|>>
literal|3
operator|)
expr_stmt|;
name|top
operator|&=
literal|0x7
expr_stmt|;
for|for
control|(
name|fpreg
operator|=
literal|7
init|;
name|fpreg
operator|>=
literal|0
condition|;
name|fpreg
operator|--
control|)
block|{
name|int
name|tag
decl_stmt|;
if|if
condition|(
name|val
index|[
literal|0
index|]
operator|&
operator|(
literal|1
operator|<<
name|fpreg
operator|)
condition|)
block|{
name|int
name|regnum
init|=
operator|(
name|fpreg
operator|+
literal|8
operator|-
name|top
operator|)
operator|%
literal|8
operator|+
name|I387_ST0_REGNUM
decl_stmt|;
name|tag
operator|=
name|i387_tag
argument_list|(
name|FXSAVE_ADDR
argument_list|(
name|regs
argument_list|,
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|tag
operator|=
literal|3
expr_stmt|;
comment|/* Empty */
name|ftag
operator||=
name|tag
operator|<<
operator|(
literal|2
operator|*
name|fpreg
operator|)
expr_stmt|;
block|}
name|val
index|[
literal|0
index|]
operator|=
name|ftag
operator|&
literal|0xff
expr_stmt|;
name|val
index|[
literal|1
index|]
operator|=
operator|(
name|ftag
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
block|}
name|regcache_raw_supply
argument_list|(
name|regcache
argument_list|,
name|i
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
else|else
name|regcache_raw_supply
argument_list|(
name|regcache
argument_list|,
name|i
argument_list|,
name|FXSAVE_ADDR
argument_list|(
name|regs
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|regnum
operator|==
name|I387_MXCSR_REGNUM
operator|||
name|regnum
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|regs
operator|==
name|NULL
condition|)
name|regcache_raw_supply
argument_list|(
name|regcache
argument_list|,
name|I387_MXCSR_REGNUM
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|regcache_raw_supply
argument_list|(
name|regcache
argument_list|,
name|I387_MXCSR_REGNUM
argument_list|,
name|FXSAVE_MXCSR_ADDR
argument_list|(
name|regs
argument_list|)
argument_list|)
expr_stmt|;
block|}
undef|#
directive|undef
name|I387_ST0_REGNUM
undef|#
directive|undef
name|I387_NUM_XMM_REGS
block|}
end_function

begin_comment
comment|/* Fill register REGNUM (if it is a floating-point or SSE register) in    *FXSAVE with the value from REGCACHE.  If REGNUM is -1, do this for    all registers.  This function doesn't touch any of the reserved    bits in *FXSAVE.  */
end_comment

begin_function
name|void
name|i387_collect_fxsave
parameter_list|(
specifier|const
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|int
name|regnum
parameter_list|,
name|void
modifier|*
name|fxsave
parameter_list|)
block|{
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
decl_stmt|;
name|char
modifier|*
name|regs
init|=
name|fxsave
decl_stmt|;
name|int
name|i
decl_stmt|;
name|gdb_assert
argument_list|(
name|tdep
operator|->
name|st0_regnum
operator|>=
name|I386_ST0_REGNUM
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
name|tdep
operator|->
name|num_xmm_regs
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|/* Define I387_ST0_REGNUM and I387_NUM_XMM_REGS such that we use the      proper definitions for REGCACHE's architecture.  */
define|#
directive|define
name|I387_ST0_REGNUM
value|tdep->st0_regnum
define|#
directive|define
name|I387_NUM_XMM_REGS
value|tdep->num_xmm_regs
for|for
control|(
name|i
operator|=
name|I387_ST0_REGNUM
init|;
name|i
operator|<
name|I387_MXCSR_REGNUM
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regnum
operator|==
operator|-
literal|1
operator|||
name|regnum
operator|==
name|i
condition|)
block|{
comment|/* Most of the FPU control registers occupy only 16 bits in            the fxsave area.  Give those a special treatment.  */
if|if
condition|(
name|i
operator|>=
name|I387_FCTRL_REGNUM
operator|&&
name|i
operator|<
name|I387_XMM0_REGNUM
operator|&&
name|i
operator|!=
name|I387_FIOFF_REGNUM
operator|&&
name|i
operator|!=
name|I387_FOOFF_REGNUM
condition|)
block|{
name|unsigned
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|regcache_raw_collect
argument_list|(
name|regcache
argument_list|,
name|i
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|I387_FOP_REGNUM
condition|)
block|{
comment|/* The opcode occupies only 11 bits.  Make sure we                    don't touch the other bits.  */
name|buf
index|[
literal|1
index|]
operator|&=
operator|(
operator|(
literal|1
operator|<<
literal|3
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator||=
operator|(
operator|(
name|FXSAVE_ADDR
argument_list|(
name|regs
argument_list|,
name|i
argument_list|)
operator|)
index|[
literal|1
index|]
operator|&
operator|~
operator|(
operator|(
literal|1
operator|<<
literal|3
operator|)
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
name|I387_FTAG_REGNUM
condition|)
block|{
comment|/* Converting back is much easier.  */
name|unsigned
name|short
name|ftag
decl_stmt|;
name|int
name|fpreg
decl_stmt|;
name|ftag
operator|=
operator|(
name|buf
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
name|buf
index|[
literal|0
index|]
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|fpreg
operator|=
literal|7
init|;
name|fpreg
operator|>=
literal|0
condition|;
name|fpreg
operator|--
control|)
block|{
name|int
name|tag
init|=
operator|(
name|ftag
operator|>>
operator|(
name|fpreg
operator|*
literal|2
operator|)
operator|)
operator|&
literal|3
decl_stmt|;
if|if
condition|(
name|tag
operator|!=
literal|3
condition|)
name|buf
index|[
literal|0
index|]
operator||=
operator|(
literal|1
operator|<<
name|fpreg
operator|)
expr_stmt|;
block|}
block|}
name|memcpy
argument_list|(
name|FXSAVE_ADDR
argument_list|(
name|regs
argument_list|,
name|i
argument_list|)
argument_list|,
name|buf
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
name|regcache_raw_collect
argument_list|(
name|regcache
argument_list|,
name|i
argument_list|,
name|FXSAVE_ADDR
argument_list|(
name|regs
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|regnum
operator|==
name|I387_MXCSR_REGNUM
operator|||
name|regnum
operator|==
operator|-
literal|1
condition|)
name|regcache_raw_collect
argument_list|(
name|regcache
argument_list|,
name|I387_MXCSR_REGNUM
argument_list|,
name|FXSAVE_MXCSR_ADDR
argument_list|(
name|regs
argument_list|)
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|I387_ST0_REGNUM
undef|#
directive|undef
name|I387_NUM_XMM_REGS
block|}
end_function

begin_comment
comment|/* Fill register REGNUM (if it is a floating-point or SSE register) in    *FXSAVE with the value in GDB's register cache.  If REGNUM is -1, do    this for all registers.  This function doesn't touch any of the    reserved bits in *FXSAVE.  */
end_comment

begin_function
name|void
name|i387_fill_fxsave
parameter_list|(
name|void
modifier|*
name|fxsave
parameter_list|,
name|int
name|regnum
parameter_list|)
block|{
name|i387_collect_fxsave
argument_list|(
name|current_regcache
argument_list|,
name|regnum
argument_list|,
name|fxsave
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Recreate the FTW (tag word) valid bits from the 80-bit FP data in    *RAW.  */
end_comment

begin_function
specifier|static
name|int
name|i387_tag
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|raw
parameter_list|)
block|{
name|int
name|integer
decl_stmt|;
name|unsigned
name|int
name|exponent
decl_stmt|;
name|unsigned
name|long
name|fraction
index|[
literal|2
index|]
decl_stmt|;
name|integer
operator|=
name|raw
index|[
literal|7
index|]
operator|&
literal|0x80
expr_stmt|;
name|exponent
operator|=
operator|(
operator|(
operator|(
name|raw
index|[
literal|9
index|]
operator|&
literal|0x7f
operator|)
operator|<<
literal|8
operator|)
operator||
name|raw
index|[
literal|8
index|]
operator|)
expr_stmt|;
name|fraction
index|[
literal|0
index|]
operator|=
operator|(
operator|(
name|raw
index|[
literal|3
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|raw
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|raw
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
name|raw
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|fraction
index|[
literal|1
index|]
operator|=
operator|(
operator|(
operator|(
name|raw
index|[
literal|7
index|]
operator|&
literal|0x7f
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
name|raw
index|[
literal|6
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|raw
index|[
literal|5
index|]
operator|<<
literal|8
operator|)
operator||
name|raw
index|[
literal|4
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|exponent
operator|==
literal|0x7fff
condition|)
block|{
comment|/* Special.  */
return|return
operator|(
literal|2
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|exponent
operator|==
literal|0x0000
condition|)
block|{
if|if
condition|(
name|fraction
index|[
literal|0
index|]
operator|==
literal|0x0000
operator|&&
name|fraction
index|[
literal|1
index|]
operator|==
literal|0x0000
operator|&&
operator|!
name|integer
condition|)
block|{
comment|/* Zero.  */
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
comment|/* Special.  */
return|return
operator|(
literal|2
operator|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|integer
condition|)
block|{
comment|/* Valid.  */
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
comment|/* Special.  */
return|return
operator|(
literal|2
operator|)
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Prepare the FPU stack in REGCACHE for a function return.  */
end_comment

begin_function
name|void
name|i387_return_value
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|)
block|{
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|gdbarch
argument_list|)
decl_stmt|;
name|ULONGEST
name|fstat
decl_stmt|;
comment|/* Define I387_ST0_REGNUM such that we use the proper      definitions for the architecture.  */
define|#
directive|define
name|I387_ST0_REGNUM
value|tdep->st0_regnum
comment|/* Set the top of the floating-point register stack to 7.  The      actual value doesn't really matter, but 7 is what a normal      function return would end up with if the program started out with      a freshly initialized FPU.  */
name|regcache_raw_read_unsigned
argument_list|(
name|regcache
argument_list|,
name|I387_FSTAT_REGNUM
argument_list|,
operator|&
name|fstat
argument_list|)
expr_stmt|;
name|fstat
operator||=
operator|(
literal|7
operator|<<
literal|11
operator|)
expr_stmt|;
name|regcache_raw_write_unsigned
argument_list|(
name|regcache
argument_list|,
name|I387_FSTAT_REGNUM
argument_list|,
name|fstat
argument_list|)
expr_stmt|;
comment|/* Mark %st(1) through %st(7) as empty.  Since we set the top of the      floating-point register stack to 7, the appropriate value for the      tag word is 0x3fff.  */
name|regcache_raw_write_unsigned
argument_list|(
name|regcache
argument_list|,
name|I387_FTAG_REGNUM
argument_list|,
literal|0x3fff
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|I387_ST0_REGNUM
block|}
end_function

end_unit

