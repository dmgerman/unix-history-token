begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Target-dependent code for UltraSPARC.     Copyright 2003, 2004 Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"arch-utils.h"
end_include

begin_include
include|#
directive|include
file|"floatformat.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"frame-base.h"
end_include

begin_include
include|#
directive|include
file|"frame-unwind.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"osabi.h"
end_include

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"gdb_assert.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"sparc64-tdep.h"
end_include

begin_comment
comment|/* This file implements the The SPARC 64-bit ABI as defined by the    section "Low-Level System Information" of the SPARC Compliance    Definition (SCD) 2.4.1, which is the 64-bit System V psABI for    SPARC.  */
end_comment

begin_comment
comment|/* Please use the sparc32_-prefix for 32-bit specific code, the    sparc64_-prefix for 64-bit specific code and the sparc_-prefix for    code can handle both.  */
end_comment

begin_escape
end_escape

begin_comment
comment|/* The functions on this page are intended to be used to classify    function arguments.  */
end_comment

begin_comment
comment|/* Return the contents if register REGNUM as an address.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|sparc_address_from_register
parameter_list|(
name|int
name|regnum
parameter_list|)
block|{
name|ULONGEST
name|addr
decl_stmt|;
name|regcache_cooked_read_unsigned
argument_list|(
name|current_regcache
argument_list|,
name|regnum
argument_list|,
operator|&
name|addr
argument_list|)
expr_stmt|;
return|return
name|addr
return|;
block|}
end_function

begin_comment
comment|/* Check whether TYPE is "Integral or Pointer".  */
end_comment

begin_function
specifier|static
name|int
name|sparc64_integral_or_pointer_p
parameter_list|(
specifier|const
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_INT
case|:
case|case
name|TYPE_CODE_BOOL
case|:
case|case
name|TYPE_CODE_CHAR
case|:
case|case
name|TYPE_CODE_ENUM
case|:
case|case
name|TYPE_CODE_RANGE
case|:
block|{
name|int
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|gdb_assert
argument_list|(
name|len
operator|==
literal|1
operator|||
name|len
operator|==
literal|2
operator|||
name|len
operator|==
literal|4
operator|||
name|len
operator|==
literal|8
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
case|case
name|TYPE_CODE_PTR
case|:
case|case
name|TYPE_CODE_REF
case|:
block|{
name|int
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|gdb_assert
argument_list|(
name|len
operator|==
literal|8
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Check whether TYPE is "Floating".  */
end_comment

begin_function
specifier|static
name|int
name|sparc64_floating_p
parameter_list|(
specifier|const
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_FLT
case|:
block|{
name|int
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|gdb_assert
argument_list|(
name|len
operator|==
literal|4
operator|||
name|len
operator|==
literal|8
operator|||
name|len
operator|==
literal|16
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Check whether TYPE is "Structure or Union".  */
end_comment

begin_function
specifier|static
name|int
name|sparc64_structure_or_union_p
parameter_list|(
specifier|const
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_STRUCT
case|:
case|case
name|TYPE_CODE_UNION
case|:
return|return
literal|1
return|;
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Register information.  */
end_comment

begin_struct
struct|struct
name|sparc64_register_info
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|type
modifier|*
modifier|*
name|type
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|sparc64_register_info
name|sparc64_register_info
index|[]
init|=
block|{
block|{
literal|"g0"
block|,
operator|&
name|builtin_type_int64
block|}
block|,
block|{
literal|"g1"
block|,
operator|&
name|builtin_type_int64
block|}
block|,
block|{
literal|"g2"
block|,
operator|&
name|builtin_type_int64
block|}
block|,
block|{
literal|"g3"
block|,
operator|&
name|builtin_type_int64
block|}
block|,
block|{
literal|"g4"
block|,
operator|&
name|builtin_type_int64
block|}
block|,
block|{
literal|"g5"
block|,
operator|&
name|builtin_type_int64
block|}
block|,
block|{
literal|"g6"
block|,
operator|&
name|builtin_type_int64
block|}
block|,
block|{
literal|"g7"
block|,
operator|&
name|builtin_type_int64
block|}
block|,
block|{
literal|"o0"
block|,
operator|&
name|builtin_type_int64
block|}
block|,
block|{
literal|"o1"
block|,
operator|&
name|builtin_type_int64
block|}
block|,
block|{
literal|"o2"
block|,
operator|&
name|builtin_type_int64
block|}
block|,
block|{
literal|"o3"
block|,
operator|&
name|builtin_type_int64
block|}
block|,
block|{
literal|"o4"
block|,
operator|&
name|builtin_type_int64
block|}
block|,
block|{
literal|"o5"
block|,
operator|&
name|builtin_type_int64
block|}
block|,
block|{
literal|"sp"
block|,
operator|&
name|builtin_type_void_data_ptr
block|}
block|,
block|{
literal|"o7"
block|,
operator|&
name|builtin_type_int64
block|}
block|,
block|{
literal|"l0"
block|,
operator|&
name|builtin_type_int64
block|}
block|,
block|{
literal|"l1"
block|,
operator|&
name|builtin_type_int64
block|}
block|,
block|{
literal|"l2"
block|,
operator|&
name|builtin_type_int64
block|}
block|,
block|{
literal|"l3"
block|,
operator|&
name|builtin_type_int64
block|}
block|,
block|{
literal|"l4"
block|,
operator|&
name|builtin_type_int64
block|}
block|,
block|{
literal|"l5"
block|,
operator|&
name|builtin_type_int64
block|}
block|,
block|{
literal|"l6"
block|,
operator|&
name|builtin_type_int64
block|}
block|,
block|{
literal|"l7"
block|,
operator|&
name|builtin_type_int64
block|}
block|,
block|{
literal|"i0"
block|,
operator|&
name|builtin_type_int64
block|}
block|,
block|{
literal|"i1"
block|,
operator|&
name|builtin_type_int64
block|}
block|,
block|{
literal|"i2"
block|,
operator|&
name|builtin_type_int64
block|}
block|,
block|{
literal|"i3"
block|,
operator|&
name|builtin_type_int64
block|}
block|,
block|{
literal|"i4"
block|,
operator|&
name|builtin_type_int64
block|}
block|,
block|{
literal|"i5"
block|,
operator|&
name|builtin_type_int64
block|}
block|,
block|{
literal|"fp"
block|,
operator|&
name|builtin_type_void_data_ptr
block|}
block|,
block|{
literal|"i7"
block|,
operator|&
name|builtin_type_int64
block|}
block|,
block|{
literal|"f0"
block|,
operator|&
name|builtin_type_float
block|}
block|,
block|{
literal|"f1"
block|,
operator|&
name|builtin_type_float
block|}
block|,
block|{
literal|"f2"
block|,
operator|&
name|builtin_type_float
block|}
block|,
block|{
literal|"f3"
block|,
operator|&
name|builtin_type_float
block|}
block|,
block|{
literal|"f4"
block|,
operator|&
name|builtin_type_float
block|}
block|,
block|{
literal|"f5"
block|,
operator|&
name|builtin_type_float
block|}
block|,
block|{
literal|"f6"
block|,
operator|&
name|builtin_type_float
block|}
block|,
block|{
literal|"f7"
block|,
operator|&
name|builtin_type_float
block|}
block|,
block|{
literal|"f8"
block|,
operator|&
name|builtin_type_float
block|}
block|,
block|{
literal|"f9"
block|,
operator|&
name|builtin_type_float
block|}
block|,
block|{
literal|"f10"
block|,
operator|&
name|builtin_type_float
block|}
block|,
block|{
literal|"f11"
block|,
operator|&
name|builtin_type_float
block|}
block|,
block|{
literal|"f12"
block|,
operator|&
name|builtin_type_float
block|}
block|,
block|{
literal|"f13"
block|,
operator|&
name|builtin_type_float
block|}
block|,
block|{
literal|"f14"
block|,
operator|&
name|builtin_type_float
block|}
block|,
block|{
literal|"f15"
block|,
operator|&
name|builtin_type_float
block|}
block|,
block|{
literal|"f16"
block|,
operator|&
name|builtin_type_float
block|}
block|,
block|{
literal|"f17"
block|,
operator|&
name|builtin_type_float
block|}
block|,
block|{
literal|"f18"
block|,
operator|&
name|builtin_type_float
block|}
block|,
block|{
literal|"f19"
block|,
operator|&
name|builtin_type_float
block|}
block|,
block|{
literal|"f20"
block|,
operator|&
name|builtin_type_float
block|}
block|,
block|{
literal|"f21"
block|,
operator|&
name|builtin_type_float
block|}
block|,
block|{
literal|"f22"
block|,
operator|&
name|builtin_type_float
block|}
block|,
block|{
literal|"f23"
block|,
operator|&
name|builtin_type_float
block|}
block|,
block|{
literal|"f24"
block|,
operator|&
name|builtin_type_float
block|}
block|,
block|{
literal|"f25"
block|,
operator|&
name|builtin_type_float
block|}
block|,
block|{
literal|"f26"
block|,
operator|&
name|builtin_type_float
block|}
block|,
block|{
literal|"f27"
block|,
operator|&
name|builtin_type_float
block|}
block|,
block|{
literal|"f28"
block|,
operator|&
name|builtin_type_float
block|}
block|,
block|{
literal|"f29"
block|,
operator|&
name|builtin_type_float
block|}
block|,
block|{
literal|"f30"
block|,
operator|&
name|builtin_type_float
block|}
block|,
block|{
literal|"f31"
block|,
operator|&
name|builtin_type_float
block|}
block|,
block|{
literal|"f32"
block|,
operator|&
name|builtin_type_double
block|}
block|,
block|{
literal|"f34"
block|,
operator|&
name|builtin_type_double
block|}
block|,
block|{
literal|"f36"
block|,
operator|&
name|builtin_type_double
block|}
block|,
block|{
literal|"f38"
block|,
operator|&
name|builtin_type_double
block|}
block|,
block|{
literal|"f40"
block|,
operator|&
name|builtin_type_double
block|}
block|,
block|{
literal|"f42"
block|,
operator|&
name|builtin_type_double
block|}
block|,
block|{
literal|"f44"
block|,
operator|&
name|builtin_type_double
block|}
block|,
block|{
literal|"f46"
block|,
operator|&
name|builtin_type_double
block|}
block|,
block|{
literal|"f48"
block|,
operator|&
name|builtin_type_double
block|}
block|,
block|{
literal|"f50"
block|,
operator|&
name|builtin_type_double
block|}
block|,
block|{
literal|"f52"
block|,
operator|&
name|builtin_type_double
block|}
block|,
block|{
literal|"f54"
block|,
operator|&
name|builtin_type_double
block|}
block|,
block|{
literal|"f56"
block|,
operator|&
name|builtin_type_double
block|}
block|,
block|{
literal|"f58"
block|,
operator|&
name|builtin_type_double
block|}
block|,
block|{
literal|"f60"
block|,
operator|&
name|builtin_type_double
block|}
block|,
block|{
literal|"f62"
block|,
operator|&
name|builtin_type_double
block|}
block|,
block|{
literal|"pc"
block|,
operator|&
name|builtin_type_void_func_ptr
block|}
block|,
block|{
literal|"npc"
block|,
operator|&
name|builtin_type_void_func_ptr
block|}
block|,
comment|/* This raw register contains the contents of %cwp, %pstate, %asi      and %ccr as laid out in a %tstate register.  */
comment|/* FIXME: Give it a name until we start using register groups.  */
block|{
literal|"state"
block|,
operator|&
name|builtin_type_int64
block|}
block|,
block|{
literal|"fsr"
block|,
operator|&
name|builtin_type_int64
block|}
block|,
block|{
literal|"fprs"
block|,
operator|&
name|builtin_type_int64
block|}
block|,
comment|/* "Although Y is a 64-bit register, its high-order 32 bits are      reserved and always read as 0."  */
block|{
literal|"y"
block|,
operator|&
name|builtin_type_int64
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Total number of registers.  */
end_comment

begin_define
define|#
directive|define
name|SPARC64_NUM_REGS
value|ARRAY_SIZE (sparc64_register_info)
end_define

begin_comment
comment|/* We provide the aliases %d0..%d62 and %q0..%q60 for the floating    registers as "psuedo" registers.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sparc64_register_info
name|sparc64_pseudo_register_info
index|[]
init|=
block|{
block|{
literal|"cwp"
block|,
operator|&
name|builtin_type_int64
block|}
block|,
block|{
literal|"pstate"
block|,
operator|&
name|builtin_type_int64
block|}
block|,
block|{
literal|"asi"
block|,
operator|&
name|builtin_type_int64
block|}
block|,
block|{
literal|"ccr"
block|,
operator|&
name|builtin_type_int64
block|}
block|,
block|{
literal|"d0"
block|,
operator|&
name|builtin_type_double
block|}
block|,
block|{
literal|"d2"
block|,
operator|&
name|builtin_type_double
block|}
block|,
block|{
literal|"d4"
block|,
operator|&
name|builtin_type_double
block|}
block|,
block|{
literal|"d6"
block|,
operator|&
name|builtin_type_double
block|}
block|,
block|{
literal|"d8"
block|,
operator|&
name|builtin_type_double
block|}
block|,
block|{
literal|"d10"
block|,
operator|&
name|builtin_type_double
block|}
block|,
block|{
literal|"d12"
block|,
operator|&
name|builtin_type_double
block|}
block|,
block|{
literal|"d14"
block|,
operator|&
name|builtin_type_double
block|}
block|,
block|{
literal|"d16"
block|,
operator|&
name|builtin_type_double
block|}
block|,
block|{
literal|"d18"
block|,
operator|&
name|builtin_type_double
block|}
block|,
block|{
literal|"d20"
block|,
operator|&
name|builtin_type_double
block|}
block|,
block|{
literal|"d22"
block|,
operator|&
name|builtin_type_double
block|}
block|,
block|{
literal|"d24"
block|,
operator|&
name|builtin_type_double
block|}
block|,
block|{
literal|"d26"
block|,
operator|&
name|builtin_type_double
block|}
block|,
block|{
literal|"d28"
block|,
operator|&
name|builtin_type_double
block|}
block|,
block|{
literal|"d30"
block|,
operator|&
name|builtin_type_double
block|}
block|,
block|{
literal|"d32"
block|,
operator|&
name|builtin_type_double
block|}
block|,
block|{
literal|"d34"
block|,
operator|&
name|builtin_type_double
block|}
block|,
block|{
literal|"d36"
block|,
operator|&
name|builtin_type_double
block|}
block|,
block|{
literal|"d38"
block|,
operator|&
name|builtin_type_double
block|}
block|,
block|{
literal|"d40"
block|,
operator|&
name|builtin_type_double
block|}
block|,
block|{
literal|"d42"
block|,
operator|&
name|builtin_type_double
block|}
block|,
block|{
literal|"d44"
block|,
operator|&
name|builtin_type_double
block|}
block|,
block|{
literal|"d46"
block|,
operator|&
name|builtin_type_double
block|}
block|,
block|{
literal|"d48"
block|,
operator|&
name|builtin_type_double
block|}
block|,
block|{
literal|"d50"
block|,
operator|&
name|builtin_type_double
block|}
block|,
block|{
literal|"d52"
block|,
operator|&
name|builtin_type_double
block|}
block|,
block|{
literal|"d54"
block|,
operator|&
name|builtin_type_double
block|}
block|,
block|{
literal|"d56"
block|,
operator|&
name|builtin_type_double
block|}
block|,
block|{
literal|"d58"
block|,
operator|&
name|builtin_type_double
block|}
block|,
block|{
literal|"d60"
block|,
operator|&
name|builtin_type_double
block|}
block|,
block|{
literal|"d62"
block|,
operator|&
name|builtin_type_double
block|}
block|,
block|{
literal|"q0"
block|,
operator|&
name|builtin_type_long_double
block|}
block|,
block|{
literal|"q4"
block|,
operator|&
name|builtin_type_long_double
block|}
block|,
block|{
literal|"q8"
block|,
operator|&
name|builtin_type_long_double
block|}
block|,
block|{
literal|"q12"
block|,
operator|&
name|builtin_type_long_double
block|}
block|,
block|{
literal|"q16"
block|,
operator|&
name|builtin_type_long_double
block|}
block|,
block|{
literal|"q20"
block|,
operator|&
name|builtin_type_long_double
block|}
block|,
block|{
literal|"q24"
block|,
operator|&
name|builtin_type_long_double
block|}
block|,
block|{
literal|"q28"
block|,
operator|&
name|builtin_type_long_double
block|}
block|,
block|{
literal|"q32"
block|,
operator|&
name|builtin_type_long_double
block|}
block|,
block|{
literal|"q36"
block|,
operator|&
name|builtin_type_long_double
block|}
block|,
block|{
literal|"q40"
block|,
operator|&
name|builtin_type_long_double
block|}
block|,
block|{
literal|"q44"
block|,
operator|&
name|builtin_type_long_double
block|}
block|,
block|{
literal|"q48"
block|,
operator|&
name|builtin_type_long_double
block|}
block|,
block|{
literal|"q52"
block|,
operator|&
name|builtin_type_long_double
block|}
block|,
block|{
literal|"q56"
block|,
operator|&
name|builtin_type_long_double
block|}
block|,
block|{
literal|"q60"
block|,
operator|&
name|builtin_type_long_double
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Total number of pseudo registers.  */
end_comment

begin_define
define|#
directive|define
name|SPARC64_NUM_PSEUDO_REGS
value|ARRAY_SIZE (sparc64_pseudo_register_info)
end_define

begin_comment
comment|/* Return the name of register REGNUM.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|sparc64_register_name
parameter_list|(
name|int
name|regnum
parameter_list|)
block|{
if|if
condition|(
name|regnum
operator|>=
literal|0
operator|&&
name|regnum
operator|<
name|SPARC64_NUM_REGS
condition|)
return|return
name|sparc64_register_info
index|[
name|regnum
index|]
operator|.
name|name
return|;
if|if
condition|(
name|regnum
operator|>=
name|SPARC64_NUM_REGS
operator|&&
name|regnum
operator|<
name|SPARC64_NUM_REGS
operator|+
name|SPARC64_NUM_PSEUDO_REGS
condition|)
return|return
name|sparc64_pseudo_register_info
index|[
name|regnum
operator|-
name|SPARC64_NUM_REGS
index|]
operator|.
name|name
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Return the GDB type object for the "standard" data type of data in    register REGNUM. */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|sparc64_register_type
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|int
name|regnum
parameter_list|)
block|{
if|if
condition|(
name|regnum
operator|>=
name|SPARC64_NUM_REGS
operator|&&
name|regnum
operator|<
name|SPARC64_NUM_REGS
operator|+
name|SPARC64_NUM_PSEUDO_REGS
condition|)
return|return
operator|*
name|sparc64_pseudo_register_info
index|[
name|regnum
operator|-
name|SPARC64_NUM_REGS
index|]
operator|.
name|type
return|;
name|gdb_assert
argument_list|(
name|regnum
operator|>=
literal|0
operator|&&
name|regnum
operator|<
name|SPARC64_NUM_REGS
argument_list|)
expr_stmt|;
return|return
operator|*
name|sparc64_register_info
index|[
name|regnum
index|]
operator|.
name|type
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sparc64_pseudo_register_read
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|int
name|regnum
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|)
block|{
name|gdb_assert
argument_list|(
name|regnum
operator|>=
name|SPARC64_NUM_REGS
argument_list|)
expr_stmt|;
if|if
condition|(
name|regnum
operator|>=
name|SPARC64_D0_REGNUM
operator|&&
name|regnum
operator|<=
name|SPARC64_D30_REGNUM
condition|)
block|{
name|regnum
operator|=
name|SPARC_F0_REGNUM
operator|+
literal|2
operator|*
operator|(
name|regnum
operator|-
name|SPARC64_D0_REGNUM
operator|)
expr_stmt|;
name|regcache_raw_read
argument_list|(
name|regcache
argument_list|,
name|regnum
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|regcache_raw_read
argument_list|(
name|regcache
argument_list|,
name|regnum
operator|+
literal|1
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
name|buf
operator|)
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|regnum
operator|>=
name|SPARC64_D32_REGNUM
operator|&&
name|regnum
operator|<=
name|SPARC64_D62_REGNUM
condition|)
block|{
name|regnum
operator|=
name|SPARC64_F32_REGNUM
operator|+
operator|(
name|regnum
operator|-
name|SPARC64_D32_REGNUM
operator|)
expr_stmt|;
name|regcache_raw_read
argument_list|(
name|regcache
argument_list|,
name|regnum
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|regnum
operator|>=
name|SPARC64_Q0_REGNUM
operator|&&
name|regnum
operator|<=
name|SPARC64_Q28_REGNUM
condition|)
block|{
name|regnum
operator|=
name|SPARC_F0_REGNUM
operator|+
literal|4
operator|*
operator|(
name|regnum
operator|-
name|SPARC64_Q0_REGNUM
operator|)
expr_stmt|;
name|regcache_raw_read
argument_list|(
name|regcache
argument_list|,
name|regnum
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|regcache_raw_read
argument_list|(
name|regcache
argument_list|,
name|regnum
operator|+
literal|1
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
name|buf
operator|)
operator|+
literal|4
argument_list|)
expr_stmt|;
name|regcache_raw_read
argument_list|(
name|regcache
argument_list|,
name|regnum
operator|+
literal|2
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
name|buf
operator|)
operator|+
literal|8
argument_list|)
expr_stmt|;
name|regcache_raw_read
argument_list|(
name|regcache
argument_list|,
name|regnum
operator|+
literal|3
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
name|buf
operator|)
operator|+
literal|12
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|regnum
operator|>=
name|SPARC64_Q32_REGNUM
operator|&&
name|regnum
operator|<=
name|SPARC64_Q60_REGNUM
condition|)
block|{
name|regnum
operator|=
name|SPARC64_F32_REGNUM
operator|+
literal|2
operator|*
operator|(
name|regnum
operator|-
name|SPARC64_Q32_REGNUM
operator|)
expr_stmt|;
name|regcache_raw_read
argument_list|(
name|regcache
argument_list|,
name|regnum
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|regcache_raw_read
argument_list|(
name|regcache
argument_list|,
name|regnum
operator|+
literal|1
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
name|buf
operator|)
operator|+
literal|8
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|regnum
operator|==
name|SPARC64_CWP_REGNUM
operator|||
name|regnum
operator|==
name|SPARC64_PSTATE_REGNUM
operator|||
name|regnum
operator|==
name|SPARC64_ASI_REGNUM
operator|||
name|regnum
operator|==
name|SPARC64_CCR_REGNUM
condition|)
block|{
name|ULONGEST
name|state
decl_stmt|;
name|regcache_raw_read_unsigned
argument_list|(
name|regcache
argument_list|,
name|SPARC64_STATE_REGNUM
argument_list|,
operator|&
name|state
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|regnum
condition|)
block|{
case|case
name|SPARC64_CWP_REGNUM
case|:
name|state
operator|=
operator|(
name|state
operator|>>
literal|0
operator|)
operator|&
operator|(
operator|(
literal|1
operator|<<
literal|5
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
break|break;
case|case
name|SPARC64_PSTATE_REGNUM
case|:
name|state
operator|=
operator|(
name|state
operator|>>
literal|8
operator|)
operator|&
operator|(
operator|(
literal|1
operator|<<
literal|12
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
break|break;
case|case
name|SPARC64_ASI_REGNUM
case|:
name|state
operator|=
operator|(
name|state
operator|>>
literal|24
operator|)
operator|&
operator|(
operator|(
literal|1
operator|<<
literal|8
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
break|break;
case|case
name|SPARC64_CCR_REGNUM
case|:
name|state
operator|=
operator|(
name|state
operator|>>
literal|32
operator|)
operator|&
operator|(
operator|(
literal|1
operator|<<
literal|8
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
break|break;
block|}
name|store_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|8
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sparc64_pseudo_register_write
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|int
name|regnum
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|)
block|{
name|gdb_assert
argument_list|(
name|regnum
operator|>=
name|SPARC64_NUM_REGS
argument_list|)
expr_stmt|;
if|if
condition|(
name|regnum
operator|>=
name|SPARC64_D0_REGNUM
operator|&&
name|regnum
operator|<=
name|SPARC64_D30_REGNUM
condition|)
block|{
name|regnum
operator|=
name|SPARC_F0_REGNUM
operator|+
literal|2
operator|*
operator|(
name|regnum
operator|-
name|SPARC64_D0_REGNUM
operator|)
expr_stmt|;
name|regcache_raw_write
argument_list|(
name|regcache
argument_list|,
name|regnum
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|regcache_raw_write
argument_list|(
name|regcache
argument_list|,
name|regnum
operator|+
literal|1
argument_list|,
operator|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|buf
operator|)
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|regnum
operator|>=
name|SPARC64_D32_REGNUM
operator|&&
name|regnum
operator|<=
name|SPARC64_D62_REGNUM
condition|)
block|{
name|regnum
operator|=
name|SPARC64_F32_REGNUM
operator|+
operator|(
name|regnum
operator|-
name|SPARC64_D32_REGNUM
operator|)
expr_stmt|;
name|regcache_raw_write
argument_list|(
name|regcache
argument_list|,
name|regnum
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|regnum
operator|>=
name|SPARC64_Q0_REGNUM
operator|&&
name|regnum
operator|<=
name|SPARC64_Q28_REGNUM
condition|)
block|{
name|regnum
operator|=
name|SPARC_F0_REGNUM
operator|+
literal|4
operator|*
operator|(
name|regnum
operator|-
name|SPARC64_Q0_REGNUM
operator|)
expr_stmt|;
name|regcache_raw_write
argument_list|(
name|regcache
argument_list|,
name|regnum
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|regcache_raw_write
argument_list|(
name|regcache
argument_list|,
name|regnum
operator|+
literal|1
argument_list|,
operator|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|buf
operator|)
operator|+
literal|4
argument_list|)
expr_stmt|;
name|regcache_raw_write
argument_list|(
name|regcache
argument_list|,
name|regnum
operator|+
literal|2
argument_list|,
operator|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|buf
operator|)
operator|+
literal|8
argument_list|)
expr_stmt|;
name|regcache_raw_write
argument_list|(
name|regcache
argument_list|,
name|regnum
operator|+
literal|3
argument_list|,
operator|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|buf
operator|)
operator|+
literal|12
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|regnum
operator|>=
name|SPARC64_Q32_REGNUM
operator|&&
name|regnum
operator|<=
name|SPARC64_Q60_REGNUM
condition|)
block|{
name|regnum
operator|=
name|SPARC64_F32_REGNUM
operator|+
literal|2
operator|*
operator|(
name|regnum
operator|-
name|SPARC64_Q32_REGNUM
operator|)
expr_stmt|;
name|regcache_raw_write
argument_list|(
name|regcache
argument_list|,
name|regnum
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|regcache_raw_write
argument_list|(
name|regcache
argument_list|,
name|regnum
operator|+
literal|1
argument_list|,
operator|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|buf
operator|)
operator|+
literal|8
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|regnum
operator|==
name|SPARC64_CWP_REGNUM
operator|||
name|regnum
operator|==
name|SPARC64_PSTATE_REGNUM
operator|||
name|regnum
operator|==
name|SPARC64_ASI_REGNUM
operator|||
name|regnum
operator|==
name|SPARC64_CCR_REGNUM
condition|)
block|{
name|ULONGEST
name|state
decl_stmt|,
name|bits
decl_stmt|;
name|regcache_raw_read_unsigned
argument_list|(
name|regcache
argument_list|,
name|SPARC64_STATE_REGNUM
argument_list|,
operator|&
name|state
argument_list|)
expr_stmt|;
name|bits
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|regnum
condition|)
block|{
case|case
name|SPARC64_CWP_REGNUM
case|:
name|state
operator||=
operator|(
operator|(
name|bits
operator|&
operator|(
operator|(
literal|1
operator|<<
literal|5
operator|)
operator|-
literal|1
operator|)
operator|)
operator|<<
literal|0
operator|)
expr_stmt|;
break|break;
case|case
name|SPARC64_PSTATE_REGNUM
case|:
name|state
operator||=
operator|(
operator|(
name|bits
operator|&
operator|(
operator|(
literal|1
operator|<<
literal|12
operator|)
operator|-
literal|1
operator|)
operator|)
operator|<<
literal|8
operator|)
expr_stmt|;
break|break;
case|case
name|SPARC64_ASI_REGNUM
case|:
name|state
operator||=
operator|(
operator|(
name|bits
operator|&
operator|(
operator|(
literal|1
operator|<<
literal|8
operator|)
operator|-
literal|1
operator|)
operator|)
operator|<<
literal|24
operator|)
expr_stmt|;
break|break;
case|case
name|SPARC64_CCR_REGNUM
case|:
name|state
operator||=
operator|(
operator|(
name|bits
operator|&
operator|(
operator|(
literal|1
operator|<<
literal|8
operator|)
operator|-
literal|1
operator|)
operator|)
operator|<<
literal|32
operator|)
expr_stmt|;
break|break;
block|}
name|regcache_raw_write_unsigned
argument_list|(
name|regcache
argument_list|,
name|SPARC64_STATE_REGNUM
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return PC of first real instruction of the function starting at    START_PC.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|sparc64_skip_prologue
parameter_list|(
name|CORE_ADDR
name|start_pc
parameter_list|)
block|{
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|CORE_ADDR
name|func_start
decl_stmt|,
name|func_end
decl_stmt|;
name|struct
name|sparc_frame_cache
name|cache
decl_stmt|;
comment|/* This is the preferred method, find the end of the prologue by      using the debugging information.  */
if|if
condition|(
name|find_pc_partial_function
argument_list|(
name|start_pc
argument_list|,
name|NULL
argument_list|,
operator|&
name|func_start
argument_list|,
operator|&
name|func_end
argument_list|)
condition|)
block|{
name|sal
operator|=
name|find_pc_line
argument_list|(
name|func_start
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sal
operator|.
name|end
operator|<
name|func_end
operator|&&
name|start_pc
operator|<=
name|sal
operator|.
name|end
condition|)
return|return
name|sal
operator|.
name|end
return|;
block|}
return|return
name|sparc_analyze_prologue
argument_list|(
name|start_pc
argument_list|,
literal|0xffffffffffffffffULL
argument_list|,
operator|&
name|cache
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Normal frames.  */
end_comment

begin_function
specifier|static
name|struct
name|sparc_frame_cache
modifier|*
name|sparc64_frame_cache
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|void
modifier|*
modifier|*
name|this_cache
parameter_list|)
block|{
return|return
name|sparc_frame_cache
argument_list|(
name|next_frame
argument_list|,
name|this_cache
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sparc64_frame_this_id
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|void
modifier|*
modifier|*
name|this_cache
parameter_list|,
name|struct
name|frame_id
modifier|*
name|this_id
parameter_list|)
block|{
name|struct
name|sparc_frame_cache
modifier|*
name|cache
init|=
name|sparc64_frame_cache
argument_list|(
name|next_frame
argument_list|,
name|this_cache
argument_list|)
decl_stmt|;
comment|/* This marks the outermost frame.  */
if|if
condition|(
name|cache
operator|->
name|base
operator|==
literal|0
condition|)
return|return;
operator|(
operator|*
name|this_id
operator|)
operator|=
name|frame_id_build
argument_list|(
name|cache
operator|->
name|base
argument_list|,
name|cache
operator|->
name|pc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sparc64_frame_prev_register
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|void
modifier|*
modifier|*
name|this_cache
parameter_list|,
name|int
name|regnum
parameter_list|,
name|int
modifier|*
name|optimizedp
parameter_list|,
name|enum
name|lval_type
modifier|*
name|lvalp
parameter_list|,
name|CORE_ADDR
modifier|*
name|addrp
parameter_list|,
name|int
modifier|*
name|realnump
parameter_list|,
name|void
modifier|*
name|valuep
parameter_list|)
block|{
name|struct
name|sparc_frame_cache
modifier|*
name|cache
init|=
name|sparc64_frame_cache
argument_list|(
name|next_frame
argument_list|,
name|this_cache
argument_list|)
decl_stmt|;
if|if
condition|(
name|regnum
operator|==
name|SPARC64_PC_REGNUM
operator|||
name|regnum
operator|==
name|SPARC64_NPC_REGNUM
condition|)
block|{
operator|*
name|optimizedp
operator|=
literal|0
expr_stmt|;
operator|*
name|lvalp
operator|=
name|not_lval
expr_stmt|;
operator|*
name|addrp
operator|=
literal|0
expr_stmt|;
operator|*
name|realnump
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|valuep
condition|)
block|{
name|CORE_ADDR
name|pc
init|=
operator|(
name|regnum
operator|==
name|SPARC64_NPC_REGNUM
operator|)
condition|?
literal|4
else|:
literal|0
decl_stmt|;
name|regnum
operator|=
name|cache
operator|->
name|frameless_p
condition|?
name|SPARC_O7_REGNUM
else|:
name|SPARC_I7_REGNUM
expr_stmt|;
name|pc
operator|+=
name|frame_unwind_register_unsigned
argument_list|(
name|next_frame
argument_list|,
name|regnum
argument_list|)
operator|+
literal|8
expr_stmt|;
name|store_unsigned_integer
argument_list|(
name|valuep
argument_list|,
literal|8
argument_list|,
name|pc
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/* The previous frame's `local' and `in' registers have been saved      in the register save area.  */
if|if
condition|(
operator|!
name|cache
operator|->
name|frameless_p
operator|&&
name|regnum
operator|>=
name|SPARC_L0_REGNUM
operator|&&
name|regnum
operator|<=
name|SPARC_I7_REGNUM
condition|)
block|{
operator|*
name|optimizedp
operator|=
literal|0
expr_stmt|;
operator|*
name|lvalp
operator|=
name|lval_memory
expr_stmt|;
operator|*
name|addrp
operator|=
name|cache
operator|->
name|base
operator|+
name|BIAS
operator|+
operator|(
name|regnum
operator|-
name|SPARC_L0_REGNUM
operator|)
operator|*
literal|8
expr_stmt|;
operator|*
name|realnump
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|valuep
condition|)
block|{
name|struct
name|gdbarch
modifier|*
name|gdbarch
init|=
name|get_frame_arch
argument_list|(
name|next_frame
argument_list|)
decl_stmt|;
comment|/* Read the value in from memory.  */
name|read_memory
argument_list|(
operator|*
name|addrp
argument_list|,
name|valuep
argument_list|,
name|register_size
argument_list|(
name|gdbarch
argument_list|,
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/* The previous frame's `out' registers are accessable as the      current frame's `in' registers.  */
if|if
condition|(
operator|!
name|cache
operator|->
name|frameless_p
operator|&&
name|regnum
operator|>=
name|SPARC_O0_REGNUM
operator|&&
name|regnum
operator|<=
name|SPARC_O7_REGNUM
condition|)
name|regnum
operator|+=
operator|(
name|SPARC_I0_REGNUM
operator|-
name|SPARC_O0_REGNUM
operator|)
expr_stmt|;
name|frame_register_unwind
argument_list|(
name|next_frame
argument_list|,
name|regnum
argument_list|,
name|optimizedp
argument_list|,
name|lvalp
argument_list|,
name|addrp
argument_list|,
name|realnump
argument_list|,
name|valuep
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|frame_unwind
name|sparc64_frame_unwind
init|=
block|{
name|NORMAL_FRAME
block|,
name|sparc64_frame_this_id
block|,
name|sparc64_frame_prev_register
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|const
name|struct
name|frame_unwind
modifier|*
name|sparc64_frame_sniffer
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|)
block|{
return|return
operator|&
name|sparc64_frame_unwind
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|CORE_ADDR
name|sparc64_frame_base_address
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|void
modifier|*
modifier|*
name|this_cache
parameter_list|)
block|{
name|struct
name|sparc_frame_cache
modifier|*
name|cache
init|=
name|sparc64_frame_cache
argument_list|(
name|next_frame
argument_list|,
name|this_cache
argument_list|)
decl_stmt|;
comment|/* ??? Should we take BIAS into account here?  */
return|return
name|cache
operator|->
name|base
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|frame_base
name|sparc64_frame_base
init|=
block|{
operator|&
name|sparc64_frame_unwind
block|,
name|sparc64_frame_base_address
block|,
name|sparc64_frame_base_address
block|,
name|sparc64_frame_base_address
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Check whether TYPE must be 16-byte aligned.  */
end_comment

begin_function
specifier|static
name|int
name|sparc64_16_byte_align_p
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
if|if
condition|(
name|sparc64_floating_p
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|==
literal|16
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|sparc64_structure_or_union_p
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|type
modifier|*
name|subtype
init|=
name|check_typedef
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|sparc64_16_byte_align_p
argument_list|(
name|subtype
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Store floating fields of element ELEMENT of an "parameter array"    that has type TYPE and is stored at BITPOS in VALBUF in the    apropriate registers of REGCACHE.  This function can be called    recursively and therefore handles floating types in addition to    structures.  */
end_comment

begin_function
specifier|static
name|void
name|sparc64_store_floating_fields
parameter_list|(
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|char
modifier|*
name|valbuf
parameter_list|,
name|int
name|element
parameter_list|,
name|int
name|bitpos
parameter_list|)
block|{
name|gdb_assert
argument_list|(
name|element
operator|<
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|sparc64_floating_p
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|int
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|regnum
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|16
condition|)
block|{
name|gdb_assert
argument_list|(
name|bitpos
operator|==
literal|0
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
operator|(
name|element
operator|%
literal|2
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|regnum
operator|=
name|SPARC64_Q0_REGNUM
operator|+
name|element
operator|/
literal|2
expr_stmt|;
name|regcache_cooked_write
argument_list|(
name|regcache
argument_list|,
name|regnum
argument_list|,
name|valbuf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|len
operator|==
literal|8
condition|)
block|{
name|gdb_assert
argument_list|(
name|bitpos
operator|==
literal|0
operator|||
name|bitpos
operator|==
literal|64
argument_list|)
expr_stmt|;
name|regnum
operator|=
name|SPARC64_D0_REGNUM
operator|+
name|element
operator|+
name|bitpos
operator|/
literal|64
expr_stmt|;
name|regcache_cooked_write
argument_list|(
name|regcache
argument_list|,
name|regnum
argument_list|,
name|valbuf
operator|+
operator|(
name|bitpos
operator|/
literal|8
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gdb_assert
argument_list|(
name|len
operator|==
literal|4
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
name|bitpos
operator|%
literal|32
operator|==
literal|0
operator|&&
name|bitpos
operator|>=
literal|0
operator|&&
name|bitpos
operator|<
literal|128
argument_list|)
expr_stmt|;
name|regnum
operator|=
name|SPARC_F0_REGNUM
operator|+
name|element
operator|*
literal|2
operator|+
name|bitpos
operator|/
literal|32
expr_stmt|;
name|regcache_cooked_write
argument_list|(
name|regcache
argument_list|,
name|regnum
argument_list|,
name|valbuf
operator|+
operator|(
name|bitpos
operator|/
literal|8
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|sparc64_structure_or_union_p
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|type
modifier|*
name|subtype
init|=
name|check_typedef
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|subpos
init|=
name|bitpos
operator|+
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|sparc64_store_floating_fields
argument_list|(
name|regcache
argument_list|,
name|subtype
argument_list|,
name|valbuf
argument_list|,
name|element
argument_list|,
name|subpos
argument_list|)
expr_stmt|;
block|}
comment|/* GCC has an interesting bug.  If TYPE is a structure that has          a single `float' member, GCC doesn't treat it as a structure          at all, but rather as an ordinary `float' argument.  This          argument will be stored in %f1, as required by the psABI.          However, as a member of a structure the psABI requires it to          be stored in %f0.  This bug is present in GCC 3.3.2, but          probably in older releases to.  To appease GCC, if a          structure has only a single `float' member, we store its          value in %f1 too (we already have stored in %f0).  */
if|if
condition|(
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|==
literal|1
condition|)
block|{
name|struct
name|type
modifier|*
name|subtype
init|=
name|check_typedef
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|sparc64_floating_p
argument_list|(
name|subtype
argument_list|)
operator|&&
name|TYPE_LENGTH
argument_list|(
name|subtype
argument_list|)
operator|==
literal|4
condition|)
name|regcache_cooked_write
argument_list|(
name|regcache
argument_list|,
name|SPARC_F1_REGNUM
argument_list|,
name|valbuf
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Fetch floating fields from a variable of type TYPE from the    appropriate registers for BITPOS in REGCACHE and store it at BITPOS    in VALBUF.  This function can be called recursively and therefore    handles floating types in addition to structures.  */
end_comment

begin_function
specifier|static
name|void
name|sparc64_extract_floating_fields
parameter_list|(
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|char
modifier|*
name|valbuf
parameter_list|,
name|int
name|bitpos
parameter_list|)
block|{
if|if
condition|(
name|sparc64_floating_p
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|int
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|regnum
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|16
condition|)
block|{
name|gdb_assert
argument_list|(
name|bitpos
operator|==
literal|0
operator|||
name|bitpos
operator|==
literal|128
argument_list|)
expr_stmt|;
name|regnum
operator|=
name|SPARC64_Q0_REGNUM
operator|+
name|bitpos
operator|/
literal|128
expr_stmt|;
name|regcache_cooked_read
argument_list|(
name|regcache
argument_list|,
name|regnum
argument_list|,
name|valbuf
operator|+
operator|(
name|bitpos
operator|/
literal|8
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|len
operator|==
literal|8
condition|)
block|{
name|gdb_assert
argument_list|(
name|bitpos
operator|%
literal|64
operator|==
literal|0
operator|&&
name|bitpos
operator|>=
literal|0
operator|&&
name|bitpos
operator|<
literal|256
argument_list|)
expr_stmt|;
name|regnum
operator|=
name|SPARC64_D0_REGNUM
operator|+
name|bitpos
operator|/
literal|64
expr_stmt|;
name|regcache_cooked_read
argument_list|(
name|regcache
argument_list|,
name|regnum
argument_list|,
name|valbuf
operator|+
operator|(
name|bitpos
operator|/
literal|8
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gdb_assert
argument_list|(
name|len
operator|==
literal|4
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
name|bitpos
operator|%
literal|32
operator|==
literal|0
operator|&&
name|bitpos
operator|>=
literal|0
operator|&&
name|bitpos
operator|<
literal|256
argument_list|)
expr_stmt|;
name|regnum
operator|=
name|SPARC_F0_REGNUM
operator|+
name|bitpos
operator|/
literal|32
expr_stmt|;
name|regcache_cooked_read
argument_list|(
name|regcache
argument_list|,
name|regnum
argument_list|,
name|valbuf
operator|+
operator|(
name|bitpos
operator|/
literal|8
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|sparc64_structure_or_union_p
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|type
modifier|*
name|subtype
init|=
name|check_typedef
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|subpos
init|=
name|bitpos
operator|+
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|sparc64_extract_floating_fields
argument_list|(
name|regcache
argument_list|,
name|subtype
argument_list|,
name|valbuf
argument_list|,
name|subpos
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Store the NARGS arguments ARGS and STRUCT_ADDR (if STRUCT_RETURN is    non-zero) in REGCACHE and on the stack (starting from address SP).  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|sparc64_store_arguments
parameter_list|(
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|int
name|nargs
parameter_list|,
name|struct
name|value
modifier|*
modifier|*
name|args
parameter_list|,
name|CORE_ADDR
name|sp
parameter_list|,
name|int
name|struct_return
parameter_list|,
name|CORE_ADDR
name|struct_addr
parameter_list|)
block|{
comment|/* Number of extended words in the "parameter array".  */
name|int
name|num_elements
init|=
literal|0
decl_stmt|;
name|int
name|element
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Take BIAS into account.  */
name|sp
operator|+=
name|BIAS
expr_stmt|;
comment|/* First we calculate the number of extended words in the "parameter      array".  While doing so we also convert some of the arguments.  */
if|if
condition|(
name|struct_return
condition|)
name|num_elements
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nargs
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|type
modifier|*
name|type
init|=
name|VALUE_TYPE
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|sparc64_structure_or_union_p
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* Structure or Union arguments.  */
if|if
condition|(
name|len
operator|<=
literal|16
condition|)
block|{
if|if
condition|(
name|num_elements
operator|%
literal|2
operator|&&
name|sparc64_16_byte_align_p
argument_list|(
name|type
argument_list|)
condition|)
name|num_elements
operator|++
expr_stmt|;
name|num_elements
operator|+=
operator|(
operator|(
name|len
operator|+
literal|7
operator|)
operator|/
literal|8
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The psABI says that "Structures or unions larger than 		 sixteen bytes are copied by the caller and passed 		 indirectly; the caller will pass the address of a 		 correctly aligned structure value.  This sixty-four 		 bit address will occupy one word in the parameter 		 array, and may be promoted to an %o register like any 		 other pointer value."  Allocate memory for these 		 values on the stack.  */
name|sp
operator|-=
name|len
expr_stmt|;
comment|/* Use 16-byte alignment for these values.  That's                  always correct, and wasting a few bytes shouldn't be                  a problem.  */
name|sp
operator|&=
operator|~
literal|0xf
expr_stmt|;
name|write_memory
argument_list|(
name|sp
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|args
index|[
name|i
index|]
operator|=
name|value_from_pointer
argument_list|(
name|lookup_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|num_elements
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|sparc64_floating_p
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* Floating arguments.  */
if|if
condition|(
name|len
operator|==
literal|16
condition|)
block|{
comment|/* The psABI says that "Each quad-precision parameter                  value will be assigned to two extended words in the                  parameter array.  */
name|num_elements
operator|+=
literal|2
expr_stmt|;
comment|/* The psABI says that "Long doubles must be                  quad-aligned, and thus a hole might be introduced                  into the parameter array to force alignment."  Skip                  an element if necessary.  */
if|if
condition|(
name|num_elements
operator|%
literal|2
condition|)
name|num_elements
operator|++
expr_stmt|;
block|}
else|else
name|num_elements
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* Integral and pointer arguments.  */
name|gdb_assert
argument_list|(
name|sparc64_integral_or_pointer_p
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The psABI says that "Each argument value of integral type 	     smaller than an extended word will be widened by the 	     caller to an extended word according to the signed-ness 	     of the argument type."  */
if|if
condition|(
name|len
operator|<
literal|8
condition|)
name|args
index|[
name|i
index|]
operator|=
name|value_cast
argument_list|(
name|builtin_type_int64
argument_list|,
name|args
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|num_elements
operator|++
expr_stmt|;
block|}
block|}
comment|/* Allocate the "parameter array".  */
name|sp
operator|-=
name|num_elements
operator|*
literal|8
expr_stmt|;
comment|/* The psABI says that "Every stack frame must be 16-byte aligned."  */
name|sp
operator|&=
operator|~
literal|0xf
expr_stmt|;
comment|/* Now we store the arguments in to the "paramater array".  Some      Integer or Pointer arguments and Structure or Union arguments      will be passed in %o registers.  Some Floating arguments and      floating members of structures are passed in floating-point      registers.  However, for functions with variable arguments,      floating arguments are stored in an %0 register, and for      functions without a prototype floating arguments are stored in      both a floating-point and an %o registers, or a floating-point      register and memory.  To simplify the logic here we always pass      arguments in memory, an %o register, and a floating-point      register if appropriate.  This should be no problem since the      contents of any unused memory or registers in the "parameter      array" are undefined.  */
if|if
condition|(
name|struct_return
condition|)
block|{
name|regcache_cooked_write_unsigned
argument_list|(
name|regcache
argument_list|,
name|SPARC_O0_REGNUM
argument_list|,
name|struct_addr
argument_list|)
expr_stmt|;
name|element
operator|++
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nargs
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|valbuf
init|=
name|VALUE_CONTENTS
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|struct
name|type
modifier|*
name|type
init|=
name|VALUE_TYPE
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|regnum
init|=
operator|-
literal|1
decl_stmt|;
name|char
name|buf
index|[
literal|16
index|]
decl_stmt|;
if|if
condition|(
name|sparc64_structure_or_union_p
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* Structure or Union arguments.  */
name|gdb_assert
argument_list|(
name|len
operator|<=
literal|16
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|valbuf
operator|=
name|memcpy
argument_list|(
name|buf
argument_list|,
name|valbuf
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|element
operator|%
literal|2
operator|&&
name|sparc64_16_byte_align_p
argument_list|(
name|type
argument_list|)
condition|)
name|element
operator|++
expr_stmt|;
if|if
condition|(
name|element
operator|<
literal|6
condition|)
block|{
name|regnum
operator|=
name|SPARC_O0_REGNUM
operator|+
name|element
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|8
operator|&&
name|element
operator|<
literal|5
condition|)
name|regcache_cooked_write
argument_list|(
name|regcache
argument_list|,
name|regnum
operator|+
literal|1
argument_list|,
name|valbuf
operator|+
literal|8
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|element
operator|<
literal|16
condition|)
name|sparc64_store_floating_fields
argument_list|(
name|regcache
argument_list|,
name|type
argument_list|,
name|valbuf
argument_list|,
name|element
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sparc64_floating_p
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* Floating arguments.  */
if|if
condition|(
name|len
operator|==
literal|16
condition|)
block|{
if|if
condition|(
name|element
operator|%
literal|2
condition|)
name|element
operator|++
expr_stmt|;
if|if
condition|(
name|element
operator|<
literal|16
condition|)
name|regnum
operator|=
name|SPARC64_Q0_REGNUM
operator|+
name|element
operator|/
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|len
operator|==
literal|8
condition|)
block|{
if|if
condition|(
name|element
operator|<
literal|16
condition|)
name|regnum
operator|=
name|SPARC64_D0_REGNUM
operator|+
name|element
expr_stmt|;
block|}
else|else
block|{
comment|/* The psABI says "Each single-precision parameter value                  will be assigned to one extended word in the                  parameter array, and right-justified within that                  word; the left half (even floatregister) is                  undefined."  Even though the psABI says that "the                  left half is undefined", set it to zero here.  */
name|memset
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buf
operator|+
literal|4
argument_list|,
name|valbuf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|valbuf
operator|=
name|buf
expr_stmt|;
name|len
operator|=
literal|8
expr_stmt|;
if|if
condition|(
name|element
operator|<
literal|16
condition|)
name|regnum
operator|=
name|SPARC64_D0_REGNUM
operator|+
name|element
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Integral and pointer arguments.  */
name|gdb_assert
argument_list|(
name|len
operator|==
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|element
operator|<
literal|6
condition|)
name|regnum
operator|=
name|SPARC_O0_REGNUM
operator|+
name|element
expr_stmt|;
block|}
if|if
condition|(
name|regnum
operator|!=
operator|-
literal|1
condition|)
block|{
name|regcache_cooked_write
argument_list|(
name|regcache
argument_list|,
name|regnum
argument_list|,
name|valbuf
argument_list|)
expr_stmt|;
comment|/* If we're storing the value in a floating-point register,              also store it in the corresponding %0 register(s).  */
if|if
condition|(
name|regnum
operator|>=
name|SPARC64_D0_REGNUM
operator|&&
name|regnum
operator|<=
name|SPARC64_D10_REGNUM
condition|)
block|{
name|gdb_assert
argument_list|(
name|element
operator|<
literal|6
argument_list|)
expr_stmt|;
name|regnum
operator|=
name|SPARC_O0_REGNUM
operator|+
name|element
expr_stmt|;
name|regcache_cooked_write
argument_list|(
name|regcache
argument_list|,
name|regnum
argument_list|,
name|valbuf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|regnum
operator|>=
name|SPARC64_Q0_REGNUM
operator|&&
name|regnum
operator|<=
name|SPARC64_Q8_REGNUM
condition|)
block|{
name|gdb_assert
argument_list|(
name|element
operator|<
literal|6
argument_list|)
expr_stmt|;
name|regnum
operator|=
name|SPARC_O0_REGNUM
operator|+
name|element
expr_stmt|;
name|regcache_cooked_write
argument_list|(
name|regcache
argument_list|,
name|regnum
argument_list|,
name|valbuf
argument_list|)
expr_stmt|;
name|regcache_cooked_write
argument_list|(
name|regcache
argument_list|,
name|regnum
operator|+
literal|1
argument_list|,
name|valbuf
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Always store the argument in memeory.  */
name|write_memory
argument_list|(
name|sp
operator|+
name|element
operator|*
literal|8
argument_list|,
name|valbuf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|element
operator|+=
operator|(
operator|(
name|len
operator|+
literal|7
operator|)
operator|/
literal|8
operator|)
expr_stmt|;
block|}
name|gdb_assert
argument_list|(
name|element
operator|==
name|num_elements
argument_list|)
expr_stmt|;
comment|/* Take BIAS into account.  */
name|sp
operator|-=
name|BIAS
expr_stmt|;
return|return
name|sp
return|;
block|}
end_function

begin_function
specifier|static
name|CORE_ADDR
name|sparc64_push_dummy_call
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|CORE_ADDR
name|func_addr
parameter_list|,
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|CORE_ADDR
name|bp_addr
parameter_list|,
name|int
name|nargs
parameter_list|,
name|struct
name|value
modifier|*
modifier|*
name|args
parameter_list|,
name|CORE_ADDR
name|sp
parameter_list|,
name|int
name|struct_return
parameter_list|,
name|CORE_ADDR
name|struct_addr
parameter_list|)
block|{
comment|/* Set return address.  */
name|regcache_cooked_write_unsigned
argument_list|(
name|regcache
argument_list|,
name|SPARC_O7_REGNUM
argument_list|,
name|bp_addr
operator|-
literal|8
argument_list|)
expr_stmt|;
comment|/* Set up function arguments.  */
name|sp
operator|=
name|sparc64_store_arguments
argument_list|(
name|regcache
argument_list|,
name|nargs
argument_list|,
name|args
argument_list|,
name|sp
argument_list|,
name|struct_return
argument_list|,
name|struct_addr
argument_list|)
expr_stmt|;
comment|/* Allocate the register save area.  */
name|sp
operator|-=
literal|16
operator|*
literal|8
expr_stmt|;
comment|/* Stack should be 16-byte aligned at this point.  */
name|gdb_assert
argument_list|(
operator|(
name|sp
operator|+
name|BIAS
operator|)
operator|%
literal|16
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* Finally, update the stack pointer.  */
name|regcache_cooked_write_unsigned
argument_list|(
name|regcache
argument_list|,
name|SPARC_SP_REGNUM
argument_list|,
name|sp
argument_list|)
expr_stmt|;
return|return
name|sp
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Extract from an array REGBUF containing the (raw) register state, a    function return value of TYPE, and copy that into VALBUF.  */
end_comment

begin_function
specifier|static
name|void
name|sparc64_extract_return_value
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|void
modifier|*
name|valbuf
parameter_list|)
block|{
name|int
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|sparc64_structure_or_union_p
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* Structure or Union return values.  */
name|gdb_assert
argument_list|(
name|len
operator|<=
literal|32
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
operator|(
name|len
operator|+
literal|7
operator|)
operator|/
literal|8
operator|)
condition|;
name|i
operator|++
control|)
name|regcache_cooked_read
argument_list|(
name|regcache
argument_list|,
name|SPARC_O0_REGNUM
operator|+
name|i
argument_list|,
name|buf
operator|+
name|i
operator|*
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_CODE_UNION
condition|)
name|sparc64_extract_floating_fields
argument_list|(
name|regcache
argument_list|,
name|type
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|valbuf
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sparc64_floating_p
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* Floating return values.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
operator|/
literal|4
condition|;
name|i
operator|++
control|)
name|regcache_cooked_read
argument_list|(
name|regcache
argument_list|,
name|SPARC_F0_REGNUM
operator|+
name|i
argument_list|,
name|buf
operator|+
name|i
operator|*
literal|4
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|valbuf
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Integral and pointer return values.  */
name|gdb_assert
argument_list|(
name|sparc64_integral_or_pointer_p
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Just stripping off any unused bytes should preserve the          signed-ness just fine.  */
name|regcache_cooked_read
argument_list|(
name|regcache
argument_list|,
name|SPARC_O0_REGNUM
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|valbuf
argument_list|,
name|buf
operator|+
literal|8
operator|-
name|len
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Write into the appropriate registers a function return value stored    in VALBUF of type TYPE.  */
end_comment

begin_function
specifier|static
name|void
name|sparc64_store_return_value
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
specifier|const
name|void
modifier|*
name|valbuf
parameter_list|)
block|{
name|int
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|char
name|buf
index|[
literal|16
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|sparc64_structure_or_union_p
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* Structure or Union return values.  */
name|gdb_assert
argument_list|(
name|len
operator|<=
literal|32
argument_list|)
expr_stmt|;
comment|/* Simplify matters by storing the complete value (including          floating members) into %o0 and %o1.  Floating members are          also store in the appropriate floating-point registers.  */
name|memset
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
name|valbuf
argument_list|,
name|len
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
operator|(
name|len
operator|+
literal|7
operator|)
operator|/
literal|8
operator|)
condition|;
name|i
operator|++
control|)
name|regcache_cooked_write
argument_list|(
name|regcache
argument_list|,
name|SPARC_O0_REGNUM
operator|+
name|i
argument_list|,
name|buf
operator|+
name|i
operator|*
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_CODE_UNION
condition|)
name|sparc64_store_floating_fields
argument_list|(
name|regcache
argument_list|,
name|type
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sparc64_floating_p
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* Floating return values.  */
name|memcpy
argument_list|(
name|buf
argument_list|,
name|valbuf
argument_list|,
name|len
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
operator|/
literal|4
condition|;
name|i
operator|++
control|)
name|regcache_cooked_write
argument_list|(
name|regcache
argument_list|,
name|SPARC_F0_REGNUM
operator|+
name|i
argument_list|,
name|buf
operator|+
name|i
operator|*
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Integral and pointer return values.  */
name|gdb_assert
argument_list|(
name|sparc64_integral_or_pointer_p
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ??? Do we need to do any sign-extension here?  */
name|memset
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buf
operator|+
literal|8
operator|-
name|len
argument_list|,
name|valbuf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|regcache_cooked_write
argument_list|(
name|regcache
argument_list|,
name|SPARC_O0_REGNUM
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|enum
name|return_value_convention
name|sparc64_return_value
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|void
modifier|*
name|readbuf
parameter_list|,
specifier|const
name|void
modifier|*
name|writebuf
parameter_list|)
block|{
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|>
literal|32
condition|)
return|return
name|RETURN_VALUE_STRUCT_CONVENTION
return|;
if|if
condition|(
name|readbuf
condition|)
name|sparc64_extract_return_value
argument_list|(
name|type
argument_list|,
name|regcache
argument_list|,
name|readbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|writebuf
condition|)
name|sparc64_store_return_value
argument_list|(
name|type
argument_list|,
name|regcache
argument_list|,
name|writebuf
argument_list|)
expr_stmt|;
return|return
name|RETURN_VALUE_REGISTER_CONVENTION
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|sparc64_init_abi
parameter_list|(
name|struct
name|gdbarch_info
name|info
parameter_list|,
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|)
block|{
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|gdbarch
argument_list|)
decl_stmt|;
name|tdep
operator|->
name|pc_regnum
operator|=
name|SPARC64_PC_REGNUM
expr_stmt|;
name|tdep
operator|->
name|npc_regnum
operator|=
name|SPARC64_NPC_REGNUM
expr_stmt|;
comment|/* This is what all the fuss is about.  */
name|set_gdbarch_long_bit
argument_list|(
name|gdbarch
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|set_gdbarch_long_long_bit
argument_list|(
name|gdbarch
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|set_gdbarch_ptr_bit
argument_list|(
name|gdbarch
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|set_gdbarch_num_regs
argument_list|(
name|gdbarch
argument_list|,
name|SPARC64_NUM_REGS
argument_list|)
expr_stmt|;
name|set_gdbarch_register_name
argument_list|(
name|gdbarch
argument_list|,
name|sparc64_register_name
argument_list|)
expr_stmt|;
name|set_gdbarch_register_type
argument_list|(
name|gdbarch
argument_list|,
name|sparc64_register_type
argument_list|)
expr_stmt|;
name|set_gdbarch_num_pseudo_regs
argument_list|(
name|gdbarch
argument_list|,
name|SPARC64_NUM_PSEUDO_REGS
argument_list|)
expr_stmt|;
name|set_gdbarch_pseudo_register_read
argument_list|(
name|gdbarch
argument_list|,
name|sparc64_pseudo_register_read
argument_list|)
expr_stmt|;
name|set_gdbarch_pseudo_register_write
argument_list|(
name|gdbarch
argument_list|,
name|sparc64_pseudo_register_write
argument_list|)
expr_stmt|;
comment|/* Register numbers of various important registers.  */
name|set_gdbarch_pc_regnum
argument_list|(
name|gdbarch
argument_list|,
name|SPARC64_PC_REGNUM
argument_list|)
expr_stmt|;
comment|/* %pc */
comment|/* Call dummy code.  */
name|set_gdbarch_call_dummy_location
argument_list|(
name|gdbarch
argument_list|,
name|AT_ENTRY_POINT
argument_list|)
expr_stmt|;
name|set_gdbarch_push_dummy_code
argument_list|(
name|gdbarch
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|set_gdbarch_push_dummy_call
argument_list|(
name|gdbarch
argument_list|,
name|sparc64_push_dummy_call
argument_list|)
expr_stmt|;
name|set_gdbarch_return_value
argument_list|(
name|gdbarch
argument_list|,
name|sparc64_return_value
argument_list|)
expr_stmt|;
name|set_gdbarch_stabs_argument_has_addr
argument_list|(
name|gdbarch
argument_list|,
name|default_stabs_argument_has_addr
argument_list|)
expr_stmt|;
name|set_gdbarch_skip_prologue
argument_list|(
name|gdbarch
argument_list|,
name|sparc64_skip_prologue
argument_list|)
expr_stmt|;
name|frame_unwind_append_sniffer
argument_list|(
name|gdbarch
argument_list|,
name|sparc64_frame_sniffer
argument_list|)
expr_stmt|;
name|frame_base_set_default
argument_list|(
name|gdbarch
argument_list|,
operator|&
name|sparc64_frame_base
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Helper functions for dealing with register sets.  */
end_comment

begin_define
define|#
directive|define
name|TSTATE_CWP
value|0x000000000000001fULL
end_define

begin_define
define|#
directive|define
name|TSTATE_ICC
value|0x0000000f00000000ULL
end_define

begin_define
define|#
directive|define
name|TSTATE_XCC
value|0x000000f000000000ULL
end_define

begin_define
define|#
directive|define
name|PSR_S
value|0x00000080
end_define

begin_define
define|#
directive|define
name|PSR_ICC
value|0x00f00000
end_define

begin_define
define|#
directive|define
name|PSR_VERS
value|0x0f000000
end_define

begin_define
define|#
directive|define
name|PSR_IMPL
value|0xf0000000
end_define

begin_define
define|#
directive|define
name|PSR_V8PLUS
value|0xff000000
end_define

begin_define
define|#
directive|define
name|PSR_XCC
value|0x000f0000
end_define

begin_function
name|void
name|sparc64_supply_gregset
parameter_list|(
specifier|const
name|struct
name|sparc_gregset
modifier|*
name|gregset
parameter_list|,
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|int
name|regnum
parameter_list|,
specifier|const
name|void
modifier|*
name|gregs
parameter_list|)
block|{
name|int
name|sparc32
init|=
operator|(
name|gdbarch_ptr_bit
argument_list|(
name|current_gdbarch
argument_list|)
operator|==
literal|32
operator|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|regs
init|=
name|gregs
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|sparc32
condition|)
block|{
if|if
condition|(
name|regnum
operator|==
name|SPARC32_PSR_REGNUM
operator|||
name|regnum
operator|==
operator|-
literal|1
condition|)
block|{
name|int
name|offset
init|=
name|gregset
operator|->
name|r_tstate_offset
decl_stmt|;
name|ULONGEST
name|tstate
decl_stmt|,
name|psr
decl_stmt|;
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|tstate
operator|=
name|extract_unsigned_integer
argument_list|(
name|regs
operator|+
name|offset
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|psr
operator|=
operator|(
operator|(
name|tstate
operator|&
name|TSTATE_CWP
operator|)
operator||
name|PSR_S
operator||
operator|(
operator|(
name|tstate
operator|&
name|TSTATE_ICC
operator|)
operator|>>
literal|12
operator|)
operator||
operator|(
operator|(
name|tstate
operator|&
name|TSTATE_XCC
operator|)
operator|>>
literal|20
operator|)
operator||
name|PSR_V8PLUS
operator|)
expr_stmt|;
name|store_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|,
name|psr
argument_list|)
expr_stmt|;
name|regcache_raw_supply
argument_list|(
name|regcache
argument_list|,
name|SPARC32_PSR_REGNUM
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|regnum
operator|==
name|SPARC32_PC_REGNUM
operator|||
name|regnum
operator|==
operator|-
literal|1
condition|)
name|regcache_raw_supply
argument_list|(
name|regcache
argument_list|,
name|SPARC32_PC_REGNUM
argument_list|,
name|regs
operator|+
name|gregset
operator|->
name|r_pc_offset
operator|+
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|regnum
operator|==
name|SPARC32_NPC_REGNUM
operator|||
name|regnum
operator|==
operator|-
literal|1
condition|)
name|regcache_raw_supply
argument_list|(
name|regcache
argument_list|,
name|SPARC32_NPC_REGNUM
argument_list|,
name|regs
operator|+
name|gregset
operator|->
name|r_npc_offset
operator|+
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|regnum
operator|==
name|SPARC32_Y_REGNUM
operator|||
name|regnum
operator|==
operator|-
literal|1
condition|)
block|{
name|int
name|offset
init|=
name|gregset
operator|->
name|r_y_offset
operator|+
literal|8
operator|-
name|gregset
operator|->
name|r_y_size
decl_stmt|;
name|regcache_raw_supply
argument_list|(
name|regcache
argument_list|,
name|SPARC32_Y_REGNUM
argument_list|,
name|regs
operator|+
name|offset
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|regnum
operator|==
name|SPARC64_STATE_REGNUM
operator|||
name|regnum
operator|==
operator|-
literal|1
condition|)
name|regcache_raw_supply
argument_list|(
name|regcache
argument_list|,
name|SPARC64_STATE_REGNUM
argument_list|,
name|regs
operator|+
name|gregset
operator|->
name|r_tstate_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|regnum
operator|==
name|SPARC64_PC_REGNUM
operator|||
name|regnum
operator|==
operator|-
literal|1
condition|)
name|regcache_raw_supply
argument_list|(
name|regcache
argument_list|,
name|SPARC64_PC_REGNUM
argument_list|,
name|regs
operator|+
name|gregset
operator|->
name|r_pc_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|regnum
operator|==
name|SPARC64_NPC_REGNUM
operator|||
name|regnum
operator|==
operator|-
literal|1
condition|)
name|regcache_raw_supply
argument_list|(
name|regcache
argument_list|,
name|SPARC64_NPC_REGNUM
argument_list|,
name|regs
operator|+
name|gregset
operator|->
name|r_npc_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|regnum
operator|==
name|SPARC64_Y_REGNUM
operator|||
name|regnum
operator|==
operator|-
literal|1
condition|)
block|{
name|char
name|buf
index|[
literal|8
index|]
decl_stmt|;
name|memset
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buf
operator|+
literal|8
operator|-
name|gregset
operator|->
name|r_y_size
argument_list|,
name|regs
operator|+
name|gregset
operator|->
name|r_y_offset
argument_list|,
name|gregset
operator|->
name|r_y_size
argument_list|)
expr_stmt|;
name|regcache_raw_supply
argument_list|(
name|regcache
argument_list|,
name|SPARC64_Y_REGNUM
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|regnum
operator|==
name|SPARC64_FPRS_REGNUM
operator|||
name|regnum
operator|==
operator|-
literal|1
operator|)
operator|&&
name|gregset
operator|->
name|r_fprs_offset
operator|!=
operator|-
literal|1
condition|)
name|regcache_raw_supply
argument_list|(
name|regcache
argument_list|,
name|SPARC64_FPRS_REGNUM
argument_list|,
name|regs
operator|+
name|gregset
operator|->
name|r_fprs_offset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|regnum
operator|==
name|SPARC_G0_REGNUM
operator|||
name|regnum
operator|==
operator|-
literal|1
condition|)
name|regcache_raw_supply
argument_list|(
name|regcache
argument_list|,
name|SPARC_G0_REGNUM
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|regnum
operator|>=
name|SPARC_G1_REGNUM
operator|&&
name|regnum
operator|<=
name|SPARC_O7_REGNUM
operator|)
operator|||
name|regnum
operator|==
operator|-
literal|1
condition|)
block|{
name|int
name|offset
init|=
name|gregset
operator|->
name|r_g1_offset
decl_stmt|;
if|if
condition|(
name|sparc32
condition|)
name|offset
operator|+=
literal|4
expr_stmt|;
for|for
control|(
name|i
operator|=
name|SPARC_G1_REGNUM
init|;
name|i
operator|<=
name|SPARC_O7_REGNUM
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|regnum
operator|==
name|i
operator|||
name|regnum
operator|==
operator|-
literal|1
condition|)
name|regcache_raw_supply
argument_list|(
name|regcache
argument_list|,
name|i
argument_list|,
name|regs
operator|+
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|8
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|regnum
operator|>=
name|SPARC_L0_REGNUM
operator|&&
name|regnum
operator|<=
name|SPARC_I7_REGNUM
operator|)
operator|||
name|regnum
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* Not all of the register set variants include Locals and          Inputs.  For those that don't, we read them off the stack.  */
if|if
condition|(
name|gregset
operator|->
name|r_l0_offset
operator|==
operator|-
literal|1
condition|)
block|{
name|ULONGEST
name|sp
decl_stmt|;
name|regcache_cooked_read_unsigned
argument_list|(
name|regcache
argument_list|,
name|SPARC_SP_REGNUM
argument_list|,
operator|&
name|sp
argument_list|)
expr_stmt|;
name|sparc_supply_rwindow
argument_list|(
name|regcache
argument_list|,
name|sp
argument_list|,
name|regnum
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|offset
init|=
name|gregset
operator|->
name|r_l0_offset
decl_stmt|;
if|if
condition|(
name|sparc32
condition|)
name|offset
operator|+=
literal|4
expr_stmt|;
for|for
control|(
name|i
operator|=
name|SPARC_L0_REGNUM
init|;
name|i
operator|<=
name|SPARC_I7_REGNUM
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|regnum
operator|==
name|i
operator|||
name|regnum
operator|==
operator|-
literal|1
condition|)
name|regcache_raw_supply
argument_list|(
name|regcache
argument_list|,
name|i
argument_list|,
name|regs
operator|+
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|8
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
name|void
name|sparc64_collect_gregset
parameter_list|(
specifier|const
name|struct
name|sparc_gregset
modifier|*
name|gregset
parameter_list|,
specifier|const
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|int
name|regnum
parameter_list|,
name|void
modifier|*
name|gregs
parameter_list|)
block|{
name|int
name|sparc32
init|=
operator|(
name|gdbarch_ptr_bit
argument_list|(
name|current_gdbarch
argument_list|)
operator|==
literal|32
operator|)
decl_stmt|;
name|char
modifier|*
name|regs
init|=
name|gregs
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|sparc32
condition|)
block|{
if|if
condition|(
name|regnum
operator|==
name|SPARC32_PSR_REGNUM
operator|||
name|regnum
operator|==
operator|-
literal|1
condition|)
block|{
name|int
name|offset
init|=
name|gregset
operator|->
name|r_tstate_offset
decl_stmt|;
name|ULONGEST
name|tstate
decl_stmt|,
name|psr
decl_stmt|;
name|char
name|buf
index|[
literal|8
index|]
decl_stmt|;
name|tstate
operator|=
name|extract_unsigned_integer
argument_list|(
name|regs
operator|+
name|offset
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|regcache_raw_collect
argument_list|(
name|regcache
argument_list|,
name|SPARC32_PSR_REGNUM
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|psr
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|tstate
operator||=
operator|(
name|psr
operator|&
name|PSR_ICC
operator|)
operator|<<
literal|12
expr_stmt|;
if|if
condition|(
operator|(
name|psr
operator|&
operator|(
name|PSR_VERS
operator||
name|PSR_IMPL
operator|)
operator|)
operator|==
name|PSR_V8PLUS
condition|)
name|tstate
operator||=
operator|(
name|psr
operator|&
name|PSR_XCC
operator|)
operator|<<
literal|20
expr_stmt|;
name|store_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|8
argument_list|,
name|tstate
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|regs
operator|+
name|offset
argument_list|,
name|buf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|regnum
operator|==
name|SPARC32_PC_REGNUM
operator|||
name|regnum
operator|==
operator|-
literal|1
condition|)
name|regcache_raw_collect
argument_list|(
name|regcache
argument_list|,
name|SPARC32_PC_REGNUM
argument_list|,
name|regs
operator|+
name|gregset
operator|->
name|r_pc_offset
operator|+
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|regnum
operator|==
name|SPARC32_NPC_REGNUM
operator|||
name|regnum
operator|==
operator|-
literal|1
condition|)
name|regcache_raw_collect
argument_list|(
name|regcache
argument_list|,
name|SPARC32_NPC_REGNUM
argument_list|,
name|regs
operator|+
name|gregset
operator|->
name|r_npc_offset
operator|+
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|regnum
operator|==
name|SPARC32_Y_REGNUM
operator|||
name|regnum
operator|==
operator|-
literal|1
condition|)
block|{
name|int
name|offset
init|=
name|gregset
operator|->
name|r_y_offset
operator|+
literal|8
operator|-
name|gregset
operator|->
name|r_y_size
decl_stmt|;
name|regcache_raw_collect
argument_list|(
name|regcache
argument_list|,
name|SPARC32_Y_REGNUM
argument_list|,
name|regs
operator|+
name|offset
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|regnum
operator|==
name|SPARC64_STATE_REGNUM
operator|||
name|regnum
operator|==
operator|-
literal|1
condition|)
name|regcache_raw_collect
argument_list|(
name|regcache
argument_list|,
name|SPARC64_STATE_REGNUM
argument_list|,
name|regs
operator|+
name|gregset
operator|->
name|r_tstate_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|regnum
operator|==
name|SPARC64_PC_REGNUM
operator|||
name|regnum
operator|==
operator|-
literal|1
condition|)
name|regcache_raw_collect
argument_list|(
name|regcache
argument_list|,
name|SPARC64_PC_REGNUM
argument_list|,
name|regs
operator|+
name|gregset
operator|->
name|r_pc_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|regnum
operator|==
name|SPARC64_NPC_REGNUM
operator|||
name|regnum
operator|==
operator|-
literal|1
condition|)
name|regcache_raw_collect
argument_list|(
name|regcache
argument_list|,
name|SPARC64_NPC_REGNUM
argument_list|,
name|regs
operator|+
name|gregset
operator|->
name|r_npc_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|regnum
operator|==
name|SPARC64_Y_REGNUM
operator|||
name|regnum
operator|==
operator|-
literal|1
condition|)
block|{
name|char
name|buf
index|[
literal|8
index|]
decl_stmt|;
name|regcache_raw_collect
argument_list|(
name|regcache
argument_list|,
name|SPARC64_Y_REGNUM
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|regs
operator|+
name|gregset
operator|->
name|r_y_offset
argument_list|,
name|buf
operator|+
literal|8
operator|-
name|gregset
operator|->
name|r_y_size
argument_list|,
name|gregset
operator|->
name|r_y_size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|regnum
operator|==
name|SPARC64_FPRS_REGNUM
operator|||
name|regnum
operator|==
operator|-
literal|1
operator|)
operator|&&
name|gregset
operator|->
name|r_fprs_offset
operator|!=
operator|-
literal|1
condition|)
name|regcache_raw_collect
argument_list|(
name|regcache
argument_list|,
name|SPARC64_FPRS_REGNUM
argument_list|,
name|regs
operator|+
name|gregset
operator|->
name|r_fprs_offset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|regnum
operator|>=
name|SPARC_G1_REGNUM
operator|&&
name|regnum
operator|<=
name|SPARC_O7_REGNUM
operator|)
operator|||
name|regnum
operator|==
operator|-
literal|1
condition|)
block|{
name|int
name|offset
init|=
name|gregset
operator|->
name|r_g1_offset
decl_stmt|;
if|if
condition|(
name|sparc32
condition|)
name|offset
operator|+=
literal|4
expr_stmt|;
comment|/* %g0 is always zero.  */
for|for
control|(
name|i
operator|=
name|SPARC_G1_REGNUM
init|;
name|i
operator|<=
name|SPARC_O7_REGNUM
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|regnum
operator|==
name|i
operator|||
name|regnum
operator|==
operator|-
literal|1
condition|)
name|regcache_raw_collect
argument_list|(
name|regcache
argument_list|,
name|i
argument_list|,
name|regs
operator|+
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|8
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|regnum
operator|>=
name|SPARC_L0_REGNUM
operator|&&
name|regnum
operator|<=
name|SPARC_I7_REGNUM
operator|)
operator|||
name|regnum
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* Not all of the register set variants include Locals and          Inputs.  For those that don't, we read them off the stack.  */
if|if
condition|(
name|gregset
operator|->
name|r_l0_offset
operator|!=
operator|-
literal|1
condition|)
block|{
name|int
name|offset
init|=
name|gregset
operator|->
name|r_l0_offset
decl_stmt|;
if|if
condition|(
name|sparc32
condition|)
name|offset
operator|+=
literal|4
expr_stmt|;
for|for
control|(
name|i
operator|=
name|SPARC_L0_REGNUM
init|;
name|i
operator|<=
name|SPARC_I7_REGNUM
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|regnum
operator|==
name|i
operator|||
name|regnum
operator|==
operator|-
literal|1
condition|)
name|regcache_raw_collect
argument_list|(
name|regcache
argument_list|,
name|i
argument_list|,
name|regs
operator|+
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|8
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
name|void
name|sparc64_supply_fpregset
parameter_list|(
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|int
name|regnum
parameter_list|,
specifier|const
name|void
modifier|*
name|fpregs
parameter_list|)
block|{
name|int
name|sparc32
init|=
operator|(
name|gdbarch_ptr_bit
argument_list|(
name|current_gdbarch
argument_list|)
operator|==
literal|32
operator|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|regs
init|=
name|fpregs
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|regnum
operator|==
operator|(
name|SPARC_F0_REGNUM
operator|+
name|i
operator|)
operator|||
name|regnum
operator|==
operator|-
literal|1
condition|)
name|regcache_raw_supply
argument_list|(
name|regcache
argument_list|,
name|SPARC_F0_REGNUM
operator|+
name|i
argument_list|,
name|regs
operator|+
operator|(
name|i
operator|*
literal|4
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sparc32
condition|)
block|{
if|if
condition|(
name|regnum
operator|==
name|SPARC32_FSR_REGNUM
operator|||
name|regnum
operator|==
operator|-
literal|1
condition|)
name|regcache_raw_supply
argument_list|(
name|regcache
argument_list|,
name|SPARC32_FSR_REGNUM
argument_list|,
name|regs
operator|+
operator|(
literal|32
operator|*
literal|4
operator|)
operator|+
operator|(
literal|16
operator|*
literal|8
operator|)
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|regnum
operator|==
operator|(
name|SPARC64_F32_REGNUM
operator|+
name|i
operator|)
operator|||
name|regnum
operator|==
operator|-
literal|1
condition|)
name|regcache_raw_supply
argument_list|(
name|regcache
argument_list|,
name|SPARC64_F32_REGNUM
operator|+
name|i
argument_list|,
name|regs
operator|+
operator|(
literal|32
operator|*
literal|4
operator|)
operator|+
operator|(
name|i
operator|*
literal|8
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|regnum
operator|==
name|SPARC64_FSR_REGNUM
operator|||
name|regnum
operator|==
operator|-
literal|1
condition|)
name|regcache_raw_supply
argument_list|(
name|regcache
argument_list|,
name|SPARC64_FSR_REGNUM
argument_list|,
name|regs
operator|+
operator|(
literal|32
operator|*
literal|4
operator|)
operator|+
operator|(
literal|16
operator|*
literal|8
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|sparc64_collect_fpregset
parameter_list|(
specifier|const
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|int
name|regnum
parameter_list|,
name|void
modifier|*
name|fpregs
parameter_list|)
block|{
name|int
name|sparc32
init|=
operator|(
name|gdbarch_ptr_bit
argument_list|(
name|current_gdbarch
argument_list|)
operator|==
literal|32
operator|)
decl_stmt|;
name|char
modifier|*
name|regs
init|=
name|fpregs
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|regnum
operator|==
operator|(
name|SPARC_F0_REGNUM
operator|+
name|i
operator|)
operator|||
name|regnum
operator|==
operator|-
literal|1
condition|)
name|regcache_raw_collect
argument_list|(
name|regcache
argument_list|,
name|SPARC_F0_REGNUM
operator|+
name|i
argument_list|,
name|regs
operator|+
operator|(
name|i
operator|*
literal|4
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sparc32
condition|)
block|{
if|if
condition|(
name|regnum
operator|==
name|SPARC32_FSR_REGNUM
operator|||
name|regnum
operator|==
operator|-
literal|1
condition|)
name|regcache_raw_collect
argument_list|(
name|regcache
argument_list|,
name|SPARC32_FSR_REGNUM
argument_list|,
name|regs
operator|+
operator|(
literal|32
operator|*
literal|4
operator|)
operator|+
operator|(
literal|16
operator|*
literal|8
operator|)
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|regnum
operator|==
operator|(
name|SPARC64_F32_REGNUM
operator|+
name|i
operator|)
operator|||
name|regnum
operator|==
operator|-
literal|1
condition|)
name|regcache_raw_collect
argument_list|(
name|regcache
argument_list|,
name|SPARC64_F32_REGNUM
operator|+
name|i
argument_list|,
name|regs
operator|+
operator|(
literal|32
operator|*
literal|4
operator|)
operator|+
operator|(
name|i
operator|*
literal|8
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|regnum
operator|==
name|SPARC64_FSR_REGNUM
operator|||
name|regnum
operator|==
operator|-
literal|1
condition|)
name|regcache_raw_collect
argument_list|(
name|regcache
argument_list|,
name|SPARC64_FSR_REGNUM
argument_list|,
name|regs
operator|+
operator|(
literal|32
operator|*
literal|4
operator|)
operator|+
operator|(
literal|16
operator|*
literal|8
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

