begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Read dbx symbol tables and convert to internal format, for GDB.    Copyright 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996    Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This module provides three functions: dbx_symfile_init,    which initializes to read a symbol file; dbx_new_init, which     discards existing cached information when all symbols are being    discarded; and dbx_symfile_read, which reads a symbol table    from a file.     dbx_symfile_read only does the minimum work necessary for letting the    user "name" things symbolically; it does not read the entire symtab.    Instead, it reads the external and static symbols and puts them in partial    symbol tables.  When more extensive information is requested of a    file, the corresponding partial symbol table is mutated into a full    fledged symbol table by going back and reading the symbols    for real.  dbx_psymtab_to_symtab() is the function that does this */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USG
argument_list|)
operator|||
name|defined
argument_list|(
name|__CYGNUSCLIB__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|NO_SYS_FILE
end_ifndef

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"gdb_stat.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"breakpoint.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_comment
comment|/* for bfd stuff */
end_comment

begin_include
include|#
directive|include
file|"libaout.h"
end_include

begin_comment
comment|/* FIXME Secret internal BFD stuff for a.out */
end_comment

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"buildsym.h"
end_include

begin_include
include|#
directive|include
file|"stabsread.h"
end_include

begin_include
include|#
directive|include
file|"gdb-stabs.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_comment
comment|/* Needed inside partial-stab.h */
end_comment

begin_include
include|#
directive|include
file|"complaints.h"
end_include

begin_include
include|#
directive|include
file|"aout/aout64.h"
end_include

begin_include
include|#
directive|include
file|"aout/stab_gnu.h"
end_include

begin_comment
comment|/* We always use GNU stabs, not native, now */
end_comment

begin_escape
end_escape

begin_comment
comment|/* We put a pointer to this structure in the read_symtab_private field    of the psymtab.  */
end_comment

begin_struct
struct|struct
name|symloc
block|{
comment|/* Offset within the file symbol table of first local symbol for this      file.  */
name|int
name|ldsymoff
decl_stmt|;
comment|/* Length (in bytes) of the section of the symbol table devoted to      this file's symbols (actually, the section bracketed may contain      more than just this file's symbols).  If ldsymlen is 0, the only      reason for this thing's existence is the dependency list.  Nothing      else will happen when it is read in.  */
name|int
name|ldsymlen
decl_stmt|;
comment|/* The size of each symbol in the symbol file (in external form).  */
name|int
name|symbol_size
decl_stmt|;
comment|/* Further information needed to locate the symbols if they are in      an ELF file.  */
name|int
name|symbol_offset
decl_stmt|;
name|int
name|string_offset
decl_stmt|;
name|int
name|file_string_offset
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|LDSYMOFF
parameter_list|(
name|p
parameter_list|)
value|(((struct symloc *)((p)->read_symtab_private))->ldsymoff)
end_define

begin_define
define|#
directive|define
name|LDSYMLEN
parameter_list|(
name|p
parameter_list|)
value|(((struct symloc *)((p)->read_symtab_private))->ldsymlen)
end_define

begin_define
define|#
directive|define
name|SYMLOC
parameter_list|(
name|p
parameter_list|)
value|((struct symloc *)((p)->read_symtab_private))
end_define

begin_define
define|#
directive|define
name|SYMBOL_SIZE
parameter_list|(
name|p
parameter_list|)
value|(SYMLOC(p)->symbol_size)
end_define

begin_define
define|#
directive|define
name|SYMBOL_OFFSET
parameter_list|(
name|p
parameter_list|)
value|(SYMLOC(p)->symbol_offset)
end_define

begin_define
define|#
directive|define
name|STRING_OFFSET
parameter_list|(
name|p
parameter_list|)
value|(SYMLOC(p)->string_offset)
end_define

begin_define
define|#
directive|define
name|FILE_STRING_OFFSET
parameter_list|(
name|p
parameter_list|)
value|(SYMLOC(p)->file_string_offset)
end_define

begin_escape
end_escape

begin_comment
comment|/* Macro to determine which symbols to ignore when reading the first symbol    of a file.  Some machines override this definition. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|IGNORE_SYMBOL
end_ifndef

begin_comment
comment|/* This code is used on Ultrix systems.  Ignore it */
end_comment

begin_define
define|#
directive|define
name|IGNORE_SYMBOL
parameter_list|(
name|type
parameter_list|)
value|(type == (int)N_NSYMS)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Remember what we deduced to be the source language of this psymtab. */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|language
name|psymtab_language
init|=
name|language_unknown
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means give verbose info on gdb action.  From main.c.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|info_verbose
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The BFD for this file -- implicit parameter to next_symbol_text.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd
modifier|*
name|symfile_bfd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The size of each symbol in the symbol file (in external form).    This is set by dbx_symfile_read when building psymtabs, and by    dbx_psymtab_to_symtab when building symtabs.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|symbol_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is the offset of the symbol table in the executable file */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|symbol_table_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is the offset of the string table in the executable file */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|string_table_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For elf+stab executables, the n_strx field is not a simple index    into the string table.  Instead, each .o file has a base offset    in the string table, and the associated symbols contain offsets    from this base.  The following two variables contain the base    offset for the current and next .o files. */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|file_string_table_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|next_file_string_table_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* .o and NLM files contain unrelocated addresses which are based at 0.  When    non-zero, this flag disables some of the special cases for Solaris elf+stab    text addresses at location 0. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|symfile_relocatable
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If this is nonzero, N_LBRAC, N_RBRAC, and N_SLINE entries are relative      to the function start address.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|block_address_function_relative
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* The lowest text address we have yet encountered.  This is needed    because in an a.out file, there is no header field which tells us    what address the program is actually going to be loaded at, so we    need to make guesses based on the symbols (which *are* relocated to    reflect the address it will be loaded at).  */
end_comment

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|lowest_text_address
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Complaints about the symbols we have encountered.  */
end_comment

begin_decl_stmt
name|struct
name|complaint
name|lbrac_complaint
init|=
block|{
literal|"bad block start address patched"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|string_table_offset_complaint
init|=
block|{
literal|"bad string table offset in symbol %d"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|unknown_symtype_complaint
init|=
block|{
literal|"unknown symbol type %s"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|unknown_symchar_complaint
init|=
block|{
literal|"unknown symbol descriptor `%c'"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|lbrac_rbrac_complaint
init|=
block|{
literal|"block start larger than block end"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|lbrac_unmatched_complaint
init|=
block|{
literal|"unmatched N_LBRAC before symtab pos %d"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|lbrac_mismatch_complaint
init|=
block|{
literal|"N_LBRAC/N_RBRAC symbol mismatch at symtab pos %d"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|repeated_header_complaint
init|=
block|{
literal|"\"repeated\" header file %s not previously seen, at symtab pos %d"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* During initial symbol readin, we need to have a structure to keep    track of which psymtabs have which bincls in them.  This structure    is used during readin to setup the list of dependencies within each    partial symbol table. */
end_comment

begin_struct
struct|struct
name|header_file_location
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Name of header file */
name|int
name|instance
decl_stmt|;
comment|/* See above */
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
comment|/* Partial symtab that has the 				   BINCL/EINCL defs for this file */
block|}
struct|;
end_struct

begin_comment
comment|/* The actual list and controling variables */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|header_file_location
modifier|*
name|bincl_list
decl_stmt|,
modifier|*
name|next_bincl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|bincls_allocated
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Local function prototypes */
end_comment

begin_decl_stmt
specifier|static
name|void
name|free_header_files
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_header_files
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|read_ofile_symtab
name|PARAMS
argument_list|(
operator|(
expr|struct
name|partial_symtab
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dbx_psymtab_to_symtab
name|PARAMS
argument_list|(
operator|(
expr|struct
name|partial_symtab
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dbx_psymtab_to_symtab_1
name|PARAMS
argument_list|(
operator|(
expr|struct
name|partial_symtab
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|read_dbx_dynamic_symtab
name|PARAMS
argument_list|(
operator|(
expr|struct
name|section_offsets
operator|*
operator|,
expr|struct
name|objfile
operator|*
name|objfile
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|read_dbx_symtab
name|PARAMS
argument_list|(
operator|(
expr|struct
name|section_offsets
operator|*
operator|,
expr|struct
name|objfile
operator|*
operator|,
name|CORE_ADDR
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_bincl_list
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|partial_symtab
modifier|*
name|find_corresponding_bincl_psymtab
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_bincl_to_list
name|PARAMS
argument_list|(
operator|(
expr|struct
name|partial_symtab
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_bincl_list
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|dbx_next_symbol_text
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fill_symbuf
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dbx_symfile_init
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dbx_new_init
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dbx_symfile_read
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|,
expr|struct
name|section_offsets
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dbx_symfile_finish
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|record_minimal_symbol
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|CORE_ADDR
operator|,
name|int
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_new_header_file
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_old_header_file
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_this_object_header_file
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Free up old header file tables */
end_comment

begin_function
specifier|static
name|void
name|free_header_files
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|header_files
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_header_files
condition|;
name|i
operator|++
control|)
block|{
name|free
argument_list|(
name|header_files
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|header_files
argument_list|)
expr_stmt|;
name|header_files
operator|=
name|NULL
expr_stmt|;
name|n_header_files
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|this_object_header_files
condition|)
block|{
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|this_object_header_files
argument_list|)
expr_stmt|;
name|this_object_header_files
operator|=
name|NULL
expr_stmt|;
block|}
name|n_allocated_header_files
operator|=
literal|0
expr_stmt|;
name|n_allocated_this_object_header_files
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Allocate new header file tables */
end_comment

begin_function
specifier|static
name|void
name|init_header_files
parameter_list|()
block|{
name|n_header_files
operator|=
literal|0
expr_stmt|;
name|n_allocated_header_files
operator|=
literal|10
expr_stmt|;
name|header_files
operator|=
operator|(
expr|struct
name|header_file
operator|*
operator|)
name|xmalloc
argument_list|(
literal|10
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|header_file
argument_list|)
argument_list|)
expr_stmt|;
name|n_allocated_this_object_header_files
operator|=
literal|10
expr_stmt|;
name|this_object_header_files
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
literal|10
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add header file number I for this object file    at the next successive FILENUM.  */
end_comment

begin_function
specifier|static
name|void
name|add_this_object_header_file
parameter_list|(
name|i
parameter_list|)
name|int
name|i
decl_stmt|;
block|{
if|if
condition|(
name|n_this_object_header_files
operator|==
name|n_allocated_this_object_header_files
condition|)
block|{
name|n_allocated_this_object_header_files
operator|*=
literal|2
expr_stmt|;
name|this_object_header_files
operator|=
operator|(
name|int
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|this_object_header_files
argument_list|,
name|n_allocated_this_object_header_files
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|this_object_header_files
index|[
name|n_this_object_header_files
operator|++
index|]
operator|=
name|i
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add to this file an "old" header file, one already seen in    a previous object file.  NAME is the header file's name.    INSTANCE is its instance code, to select among multiple    symbol tables for the same header file.  */
end_comment

begin_function
specifier|static
name|void
name|add_old_header_file
parameter_list|(
name|name
parameter_list|,
name|instance
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|instance
decl_stmt|;
block|{
specifier|register
name|struct
name|header_file
modifier|*
name|p
init|=
name|header_files
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_header_files
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|STREQ
argument_list|(
name|p
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|name
argument_list|)
operator|&&
name|instance
operator|==
name|p
index|[
name|i
index|]
operator|.
name|instance
condition|)
block|{
name|add_this_object_header_file
argument_list|(
name|i
argument_list|)
expr_stmt|;
return|return;
block|}
name|complain
argument_list|(
operator|&
name|repeated_header_complaint
argument_list|,
name|name
argument_list|,
name|symnum
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add to this file a "new" header file: definitions for its types follow.    NAME is the header file's name.    Most often this happens only once for each distinct header file,    but not necessarily.  If it happens more than once, INSTANCE has    a different value each time, and references to the header file    use INSTANCE values to select among them.     dbx output contains "begin" and "end" markers for each new header file,    but at this level we just need to know which files there have been;    so we record the file when its "begin" is seen and ignore the "end".  */
end_comment

begin_function
specifier|static
name|void
name|add_new_header_file
parameter_list|(
name|name
parameter_list|,
name|instance
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|instance
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Make sure there is room for one more header file.  */
if|if
condition|(
name|n_header_files
operator|==
name|n_allocated_header_files
condition|)
block|{
name|n_allocated_header_files
operator|*=
literal|2
expr_stmt|;
name|header_files
operator|=
operator|(
expr|struct
name|header_file
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|header_files
argument_list|,
operator|(
name|n_allocated_header_files
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|header_file
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Create an entry for this header file.  */
name|i
operator|=
name|n_header_files
operator|++
expr_stmt|;
name|header_files
index|[
name|i
index|]
operator|.
name|name
operator|=
name|savestring
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|header_files
index|[
name|i
index|]
operator|.
name|instance
operator|=
name|instance
expr_stmt|;
name|header_files
index|[
name|i
index|]
operator|.
name|length
operator|=
literal|10
expr_stmt|;
name|header_files
index|[
name|i
index|]
operator|.
name|vector
operator|=
operator|(
expr|struct
name|type
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
literal|10
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|header_files
index|[
name|i
index|]
operator|.
name|vector
argument_list|,
literal|0
argument_list|,
literal|10
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|add_this_object_header_file
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static struct type ** explicit_lookup_type (real_filenum, index)      int real_filenum, index; {   register struct header_file *f =&header_files[real_filenum];    if (index>= f->length)     {       f->length *= 2;       f->vector = (struct type **) 	xrealloc (f->vector, f->length * sizeof (struct type *));       memset (&f->vector[f->length / 2], 	     '\0', f->length * sizeof (struct type *) / 2);     }   return&f->vector[index]; }
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_function
specifier|static
name|void
name|record_minimal_symbol
parameter_list|(
name|name
parameter_list|,
name|address
parameter_list|,
name|type
parameter_list|,
name|objfile
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|CORE_ADDR
name|address
decl_stmt|;
name|int
name|type
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|enum
name|minimal_symbol_type
name|ms_type
decl_stmt|;
name|int
name|section
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|N_TEXT
operator||
name|N_EXT
case|:
name|ms_type
operator|=
name|mst_text
expr_stmt|;
name|section
operator|=
name|SECT_OFF_TEXT
expr_stmt|;
break|break;
case|case
name|N_DATA
operator||
name|N_EXT
case|:
name|ms_type
operator|=
name|mst_data
expr_stmt|;
name|section
operator|=
name|SECT_OFF_DATA
expr_stmt|;
break|break;
case|case
name|N_BSS
operator||
name|N_EXT
case|:
name|ms_type
operator|=
name|mst_bss
expr_stmt|;
name|section
operator|=
name|SECT_OFF_BSS
expr_stmt|;
break|break;
case|case
name|N_ABS
operator||
name|N_EXT
case|:
name|ms_type
operator|=
name|mst_abs
expr_stmt|;
name|section
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|N_SETV
case|case
name|N_SETV
operator||
name|N_EXT
case|:
name|ms_type
operator|=
name|mst_data
expr_stmt|;
name|section
operator|=
name|SECT_OFF_DATA
expr_stmt|;
break|break;
case|case
name|N_SETV
case|:
comment|/* I don't think this type actually exists; since a N_SETV is the result 	 of going over many .o files, it doesn't make sense to have one 	 file local.  */
name|ms_type
operator|=
name|mst_file_data
expr_stmt|;
name|section
operator|=
name|SECT_OFF_DATA
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|N_TEXT
case|:
case|case
name|N_NBTEXT
case|:
case|case
name|N_FN
case|:
case|case
name|N_FN_SEQ
case|:
name|ms_type
operator|=
name|mst_file_text
expr_stmt|;
name|section
operator|=
name|SECT_OFF_TEXT
expr_stmt|;
break|break;
case|case
name|N_DATA
case|:
name|ms_type
operator|=
name|mst_file_data
expr_stmt|;
comment|/* Check for __DYNAMIC, which is used by Sun shared libraries.  	 Record it as global even if it's local, not global, so 	 lookup_minimal_symbol can find it.  We don't check symbol_leading_char 	 because for SunOS4 it always is '_'.  */
if|if
condition|(
name|name
index|[
literal|8
index|]
operator|==
literal|'C'
operator|&&
name|STREQ
argument_list|(
literal|"__DYNAMIC"
argument_list|,
name|name
argument_list|)
condition|)
name|ms_type
operator|=
name|mst_data
expr_stmt|;
comment|/* Same with virtual function tables, both global and static.  */
block|{
name|char
modifier|*
name|tempstring
init|=
name|name
decl_stmt|;
if|if
condition|(
name|tempstring
index|[
literal|0
index|]
operator|==
name|bfd_get_symbol_leading_char
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|)
condition|)
operator|++
name|tempstring
expr_stmt|;
if|if
condition|(
name|VTBL_PREFIX_P
argument_list|(
operator|(
name|tempstring
operator|)
argument_list|)
condition|)
name|ms_type
operator|=
name|mst_data
expr_stmt|;
block|}
name|section
operator|=
name|SECT_OFF_DATA
expr_stmt|;
break|break;
case|case
name|N_BSS
case|:
name|ms_type
operator|=
name|mst_file_bss
expr_stmt|;
name|section
operator|=
name|SECT_OFF_BSS
expr_stmt|;
break|break;
default|default:
name|ms_type
operator|=
name|mst_unknown
expr_stmt|;
name|section
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|ms_type
operator|==
name|mst_file_text
operator|||
name|ms_type
operator|==
name|mst_text
operator|)
operator|&&
name|address
operator|<
name|lowest_text_address
condition|)
name|lowest_text_address
operator|=
name|address
expr_stmt|;
name|prim_record_minimal_symbol_and_info
argument_list|(
name|obsavestring
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|)
argument_list|,
name|address
argument_list|,
name|ms_type
argument_list|,
name|NULL
argument_list|,
name|section
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Scan and build partial symbols for a symbol file.    We have been initialized by a call to dbx_symfile_init, which     put all the relevant info into a "struct dbx_symfile_info",    hung off the objfile structure.     SECTION_OFFSETS contains offsets relative to which the symbols in the    various sections are (depending where the sections were actually loaded).    MAINLINE is true if we are reading the main symbol    table (as opposed to a shared lib or dynamically loaded file).  */
end_comment

begin_function
specifier|static
name|void
name|dbx_symfile_read
parameter_list|(
name|objfile
parameter_list|,
name|section_offsets
parameter_list|,
name|mainline
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|section_offsets
modifier|*
name|section_offsets
decl_stmt|;
name|int
name|mainline
decl_stmt|;
comment|/* FIXME comments above */
block|{
name|bfd
modifier|*
name|sym_bfd
decl_stmt|;
name|int
name|val
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|back_to
decl_stmt|;
name|val
operator|=
name|strlen
argument_list|(
name|objfile
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* .o and .nlm files are relocatables with text, data and bss segs based at      0.  This flag disables special (Solaris stabs-in-elf only) fixups for      symbols with a value of 0.  XXX - This is a Krock.  Solaris stabs-in-elf      should be fixed to determine pst->textlow without using this text seg of      0 fixup crap. */
if|if
condition|(
name|strcmp
argument_list|(
operator|&
name|objfile
operator|->
name|name
index|[
name|val
operator|-
literal|2
index|]
argument_list|,
literal|".o"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
operator|&
name|objfile
operator|->
name|name
index|[
name|val
operator|-
literal|4
index|]
argument_list|,
literal|".nlm"
argument_list|)
operator|==
literal|0
condition|)
name|symfile_relocatable
operator|=
literal|1
expr_stmt|;
comment|/* This is true for Solaris (and all other systems which put stabs      in sections, hopefully, since it would be silly to do things      differently from Solaris), and false for SunOS4 and other a.out      file formats.  */
name|block_address_function_relative
operator|=
operator|(
operator|(
literal|0
operator|==
name|strncmp
argument_list|(
name|bfd_get_target
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|)
argument_list|,
literal|"elf"
argument_list|,
literal|3
argument_list|)
operator|)
operator|||
operator|(
literal|0
operator|==
name|strncmp
argument_list|(
name|bfd_get_target
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|)
argument_list|,
literal|"som"
argument_list|,
literal|3
argument_list|)
operator|)
operator|||
operator|(
literal|0
operator|==
name|strncmp
argument_list|(
name|bfd_get_target
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|)
argument_list|,
literal|"coff"
argument_list|,
literal|4
argument_list|)
operator|)
operator|||
operator|(
literal|0
operator|==
name|strncmp
argument_list|(
name|bfd_get_target
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|)
argument_list|,
literal|"pe"
argument_list|,
literal|2
argument_list|)
operator|)
operator|||
operator|(
literal|0
operator|==
name|strncmp
argument_list|(
name|bfd_get_target
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|)
argument_list|,
literal|"nlm"
argument_list|,
literal|3
argument_list|)
operator|)
operator|)
expr_stmt|;
name|sym_bfd
operator|=
name|objfile
operator|->
name|obfd
expr_stmt|;
name|val
operator|=
name|bfd_seek
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|DBX_SYMTAB_OFFSET
argument_list|(
name|objfile
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|objfile
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* If we are reinitializing, or if we have never loaded syms yet, init */
if|if
condition|(
name|mainline
operator|||
name|objfile
operator|->
name|global_psymbols
operator|.
name|size
operator|==
literal|0
operator|||
name|objfile
operator|->
name|static_psymbols
operator|.
name|size
operator|==
literal|0
condition|)
name|init_psymbol_list
argument_list|(
name|objfile
argument_list|,
name|DBX_SYMCOUNT
argument_list|(
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
name|symbol_size
operator|=
name|DBX_SYMBOL_SIZE
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
name|symbol_table_offset
operator|=
name|DBX_SYMTAB_OFFSET
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
name|pending_blocks
operator|=
literal|0
expr_stmt|;
name|back_to
operator|=
name|make_cleanup
argument_list|(
name|really_free_pendings
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|init_minimal_symbol_collection
argument_list|()
expr_stmt|;
name|make_cleanup
argument_list|(
name|discard_minimal_symbols
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Now that the symbol table data of the executable file are all in core,      process them and define symbols accordingly.  */
name|read_dbx_symtab
argument_list|(
name|section_offsets
argument_list|,
name|objfile
argument_list|,
name|DBX_TEXT_ADDR
argument_list|(
name|objfile
argument_list|)
argument_list|,
name|DBX_TEXT_SIZE
argument_list|(
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Add the dynamic symbols.  */
name|read_dbx_dynamic_symtab
argument_list|(
name|section_offsets
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* Install any minimal symbols that have been collected as the current      minimal symbols for this objfile. */
name|install_minimal_symbols
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|back_to
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize anything that needs initializing when a completely new    symbol file is specified (not just adding some symbols from another    file, e.g. a shared library).  */
end_comment

begin_function
specifier|static
name|void
name|dbx_new_init
parameter_list|(
name|ignore
parameter_list|)
name|struct
name|objfile
modifier|*
name|ignore
decl_stmt|;
block|{
name|stabsread_new_init
argument_list|()
expr_stmt|;
name|buildsym_new_init
argument_list|()
expr_stmt|;
name|init_header_files
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* dbx_symfile_init ()    is the dbx-specific initialization routine for reading symbols.    It is passed a struct objfile which contains, among other things,    the BFD for the file whose symbols are being read, and a slot for a pointer    to "private data" which we fill with goodies.     We read the string table into malloc'd space and stash a pointer to it.     Since BFD doesn't know how to read debug symbols in a format-independent    way (and may never do so...), we have to do it ourselves.  We will never    be called unless this is an a.out (or very similar) file.     FIXME, there should be a cleaner peephole into the BFD environment here.  */
end_comment

begin_define
define|#
directive|define
name|DBX_STRINGTAB_SIZE_SIZE
value|sizeof(long)
end_define

begin_comment
comment|/* FIXME */
end_comment

begin_function
specifier|static
name|void
name|dbx_symfile_init
parameter_list|(
name|objfile
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|int
name|val
decl_stmt|;
name|bfd
modifier|*
name|sym_bfd
init|=
name|objfile
operator|->
name|obfd
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|bfd_get_filename
argument_list|(
name|sym_bfd
argument_list|)
decl_stmt|;
name|asection
modifier|*
name|text_sect
decl_stmt|;
name|unsigned
name|char
name|size_temp
index|[
name|DBX_STRINGTAB_SIZE_SIZE
index|]
decl_stmt|;
comment|/* Allocate struct to keep track of the symfile */
name|objfile
operator|->
name|sym_stab_info
operator|=
operator|(
name|PTR
operator|)
name|xmmalloc
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dbx_symfile_info
argument_list|)
argument_list|)
expr_stmt|;
comment|/* FIXME POKING INSIDE BFD DATA STRUCTURES */
define|#
directive|define
name|STRING_TABLE_OFFSET
value|(sym_bfd->origin + obj_str_filepos (sym_bfd))
define|#
directive|define
name|SYMBOL_TABLE_OFFSET
value|(sym_bfd->origin + obj_sym_filepos (sym_bfd))
comment|/* FIXME POKING INSIDE BFD DATA STRUCTURES */
name|DBX_SYMFILE_INFO
argument_list|(
name|objfile
argument_list|)
operator|->
name|stab_section_info
operator|=
name|NULL
expr_stmt|;
name|text_sect
operator|=
name|bfd_get_section_by_name
argument_list|(
name|sym_bfd
argument_list|,
literal|".text"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|text_sect
condition|)
name|error
argument_list|(
literal|"Can't find .text section in symbol file"
argument_list|)
expr_stmt|;
name|DBX_TEXT_ADDR
argument_list|(
name|objfile
argument_list|)
operator|=
name|bfd_section_vma
argument_list|(
name|sym_bfd
argument_list|,
name|text_sect
argument_list|)
expr_stmt|;
name|DBX_TEXT_SIZE
argument_list|(
name|objfile
argument_list|)
operator|=
name|bfd_section_size
argument_list|(
name|sym_bfd
argument_list|,
name|text_sect
argument_list|)
expr_stmt|;
name|DBX_SYMBOL_SIZE
argument_list|(
name|objfile
argument_list|)
operator|=
name|obj_symbol_entry_size
argument_list|(
name|sym_bfd
argument_list|)
expr_stmt|;
name|DBX_SYMCOUNT
argument_list|(
name|objfile
argument_list|)
operator|=
name|bfd_get_symcount
argument_list|(
name|sym_bfd
argument_list|)
expr_stmt|;
name|DBX_SYMTAB_OFFSET
argument_list|(
name|objfile
argument_list|)
operator|=
name|SYMBOL_TABLE_OFFSET
expr_stmt|;
comment|/* Read the string table and stash it away in the psymbol_obstack.  It is      only needed as long as we need to expand psymbols into full symbols,      so when we blow away the psymbol the string table goes away as well.      Note that gdb used to use the results of attempting to malloc the      string table, based on the size it read, as a form of sanity check      for botched byte swapping, on the theory that a byte swapped string      table size would be so totally bogus that the malloc would fail.  Now      that we put in on the psymbol_obstack, we can't do this since gdb gets      a fatal error (out of virtual memory) if the size is bogus.  We can      however at least check to see if the size is less than the size of      the size field itself, or larger than the size of the entire file.      Note that all valid string tables have a size greater than zero, since      the bytes used to hold the size are included in the count. */
if|if
condition|(
name|STRING_TABLE_OFFSET
operator|==
literal|0
condition|)
block|{
comment|/* It appears that with the existing bfd code, STRING_TABLE_OFFSET 	 will never be zero, even when there is no string table.  This 	 would appear to be a bug in bfd. */
name|DBX_STRINGTAB_SIZE
argument_list|(
name|objfile
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DBX_STRINGTAB
argument_list|(
name|objfile
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|val
operator|=
name|bfd_seek
argument_list|(
name|sym_bfd
argument_list|,
name|STRING_TABLE_OFFSET
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|PTR
operator|)
name|size_temp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|size_temp
argument_list|)
argument_list|)
expr_stmt|;
name|val
operator|=
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|size_temp
argument_list|,
sizeof|sizeof
argument_list|(
name|size_temp
argument_list|)
argument_list|,
literal|1
argument_list|,
name|sym_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
block|{
name|perror_with_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|val
operator|==
literal|0
condition|)
block|{
comment|/* With the existing bfd code, STRING_TABLE_OFFSET will be set to 	     EOF if there is no string table, and attempting to read the size 	     from EOF will read zero bytes. */
name|DBX_STRINGTAB_SIZE
argument_list|(
name|objfile
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DBX_STRINGTAB
argument_list|(
name|objfile
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* Read some data that would appear to be the string table size. 	     If there really is a string table, then it is probably the right 	     size.  Byteswap if necessary and validate the size.  Note that 	     the minimum is DBX_STRINGTAB_SIZE_SIZE.  If we just read some 	     random data that happened to be at STRING_TABLE_OFFSET, because 	     bfd can't tell us there is no string table, the sanity checks may 	     or may not catch this. */
name|DBX_STRINGTAB_SIZE
argument_list|(
name|objfile
argument_list|)
operator|=
name|bfd_h_get_32
argument_list|(
name|sym_bfd
argument_list|,
name|size_temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|DBX_STRINGTAB_SIZE
argument_list|(
name|objfile
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
name|size_temp
argument_list|)
operator|||
name|DBX_STRINGTAB_SIZE
argument_list|(
name|objfile
argument_list|)
operator|>
name|bfd_get_size
argument_list|(
name|sym_bfd
argument_list|)
condition|)
name|error
argument_list|(
literal|"ridiculous string table size (%d bytes)."
argument_list|,
name|DBX_STRINGTAB_SIZE
argument_list|(
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
name|DBX_STRINGTAB
argument_list|(
name|objfile
argument_list|)
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|psymbol_obstack
argument_list|,
name|DBX_STRINGTAB_SIZE
argument_list|(
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
name|OBJSTAT
argument_list|(
name|objfile
argument_list|,
name|sz_strtab
operator|+=
name|DBX_STRINGTAB_SIZE
argument_list|(
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now read in the string table in one big gulp.  */
name|val
operator|=
name|bfd_seek
argument_list|(
name|sym_bfd
argument_list|,
name|STRING_TABLE_OFFSET
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|val
operator|=
name|bfd_read
argument_list|(
name|DBX_STRINGTAB
argument_list|(
name|objfile
argument_list|)
argument_list|,
name|DBX_STRINGTAB_SIZE
argument_list|(
name|objfile
argument_list|)
argument_list|,
literal|1
argument_list|,
name|sym_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|DBX_STRINGTAB_SIZE
argument_list|(
name|objfile
argument_list|)
condition|)
name|perror_with_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Perform any local cleanups required when we are done with a particular    objfile.  I.E, we are in the process of discarding all symbol information    for an objfile, freeing up all memory held for it, and unlinking the    objfile struct from the global list of known objfiles. */
end_comment

begin_function
specifier|static
name|void
name|dbx_symfile_finish
parameter_list|(
name|objfile
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
if|if
condition|(
name|objfile
operator|->
name|sym_stab_info
operator|!=
name|NULL
condition|)
block|{
name|mfree
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
name|objfile
operator|->
name|sym_stab_info
argument_list|)
expr_stmt|;
block|}
name|free_header_files
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Buffer for reading the symbol table entries.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|internal_nlist
name|symbuf
index|[
literal|4096
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|symbuf_idx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|symbuf_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name of last function encountered.  Used in Solaris to approximate    object file boundaries.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|last_function_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The address in memory of the string table of the object file we are    reading (which might not be the "main" object file, but might be a    shared library or some other dynamically loaded thing).  This is    set by read_dbx_symtab when building psymtabs, and by    read_ofile_symtab when building symtabs, and is used only by    next_symbol_text.  FIXME: If that is true, we don't need it when    building psymtabs, right?  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|stringtab_global
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These variables are used to control fill_symbuf when the stabs    symbols are not contiguous (as may be the case when a COFF file is    linked using --split-by-reloc).  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|stab_section_list
modifier|*
name|symbuf_sections
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|symbuf_left
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|symbuf_read
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Refill the symbol table input buffer    and set the variables that control fetching entries from it.    Reports an error if no data available.    This function can read past the end of the symbol table    (into the string table) but this does no harm.  */
end_comment

begin_function
specifier|static
name|void
name|fill_symbuf
parameter_list|(
name|sym_bfd
parameter_list|)
name|bfd
modifier|*
name|sym_bfd
decl_stmt|;
block|{
name|unsigned
name|int
name|count
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
if|if
condition|(
name|symbuf_sections
operator|==
name|NULL
condition|)
name|count
operator|=
sizeof|sizeof
argument_list|(
name|symbuf
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|symbuf_left
operator|<=
literal|0
condition|)
block|{
name|file_ptr
name|filepos
init|=
name|symbuf_sections
operator|->
name|section
operator|->
name|filepos
decl_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|sym_bfd
argument_list|,
name|filepos
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
name|perror_with_name
argument_list|(
name|bfd_get_filename
argument_list|(
name|sym_bfd
argument_list|)
argument_list|)
expr_stmt|;
name|symbuf_left
operator|=
name|bfd_section_size
argument_list|(
name|sym_bfd
argument_list|,
name|symbuf_sections
operator|->
name|section
argument_list|)
expr_stmt|;
name|symbol_table_offset
operator|=
name|filepos
operator|-
name|symbuf_read
expr_stmt|;
name|symbuf_sections
operator|=
name|symbuf_sections
operator|->
name|next
expr_stmt|;
block|}
name|count
operator|=
name|symbuf_left
expr_stmt|;
if|if
condition|(
name|count
operator|>
sizeof|sizeof
argument_list|(
name|symbuf
argument_list|)
condition|)
name|count
operator|=
sizeof|sizeof
argument_list|(
name|symbuf
argument_list|)
expr_stmt|;
block|}
name|nbytes
operator|=
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|symbuf
argument_list|,
name|count
argument_list|,
literal|1
argument_list|,
name|sym_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbytes
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|bfd_get_filename
argument_list|(
name|sym_bfd
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|nbytes
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Premature end of file reading symbol table"
argument_list|)
expr_stmt|;
name|symbuf_end
operator|=
name|nbytes
operator|/
name|symbol_size
expr_stmt|;
name|symbuf_idx
operator|=
literal|0
expr_stmt|;
name|symbuf_left
operator|-=
name|nbytes
expr_stmt|;
name|symbuf_read
operator|+=
name|nbytes
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|SWAP_SYMBOL
parameter_list|(
name|symp
parameter_list|,
name|abfd
parameter_list|)
define|\
value|{ \     (symp)->n_strx = bfd_h_get_32(abfd,			\ 				(unsigned char *)&(symp)->n_strx);	\     (symp)->n_desc = bfd_h_get_16 (abfd,			\ 				(unsigned char *)&(symp)->n_desc);  	\     (symp)->n_value = bfd_h_get_32 (abfd,			\ 				(unsigned char *)&(symp)->n_value); 	\   }
end_define

begin_comment
comment|/* Invariant: The symbol pointed to by symbuf_idx is the first one    that hasn't been swapped.  Swap the symbol at the same time    that symbuf_idx is incremented.  */
end_comment

begin_comment
comment|/* dbx allows the text of a symbol name to be continued into the    next symbol name!  When such a continuation is encountered    (a \ at the end of the text of a name)    call this function to get the continuation.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|dbx_next_symbol_text
parameter_list|(
name|objfile
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
if|if
condition|(
name|symbuf_idx
operator|==
name|symbuf_end
condition|)
name|fill_symbuf
argument_list|(
name|symfile_bfd
argument_list|)
expr_stmt|;
name|symnum
operator|++
expr_stmt|;
name|SWAP_SYMBOL
argument_list|(
operator|&
name|symbuf
index|[
name|symbuf_idx
index|]
argument_list|,
name|symfile_bfd
argument_list|)
expr_stmt|;
name|OBJSTAT
argument_list|(
name|objfile
argument_list|,
name|n_stabs
operator|++
argument_list|)
expr_stmt|;
return|return
name|symbuf
index|[
name|symbuf_idx
operator|++
index|]
operator|.
name|n_strx
operator|+
name|stringtab_global
operator|+
name|file_string_table_offset
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Initialize the list of bincls to contain none and have some    allocated.  */
end_comment

begin_function
specifier|static
name|void
name|init_bincl_list
parameter_list|(
name|number
parameter_list|,
name|objfile
parameter_list|)
name|int
name|number
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|bincls_allocated
operator|=
name|number
expr_stmt|;
name|next_bincl
operator|=
name|bincl_list
operator|=
operator|(
expr|struct
name|header_file_location
operator|*
operator|)
name|xmmalloc
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
name|bincls_allocated
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|header_file_location
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a bincl to the list.  */
end_comment

begin_function
specifier|static
name|void
name|add_bincl_to_list
parameter_list|(
name|pst
parameter_list|,
name|name
parameter_list|,
name|instance
parameter_list|)
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|instance
decl_stmt|;
block|{
if|if
condition|(
name|next_bincl
operator|>=
name|bincl_list
operator|+
name|bincls_allocated
condition|)
block|{
name|int
name|offset
init|=
name|next_bincl
operator|-
name|bincl_list
decl_stmt|;
name|bincls_allocated
operator|*=
literal|2
expr_stmt|;
name|bincl_list
operator|=
operator|(
expr|struct
name|header_file_location
operator|*
operator|)
name|xmrealloc
argument_list|(
name|pst
operator|->
name|objfile
operator|->
name|md
argument_list|,
operator|(
name|char
operator|*
operator|)
name|bincl_list
argument_list|,
name|bincls_allocated
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|header_file_location
argument_list|)
argument_list|)
expr_stmt|;
name|next_bincl
operator|=
name|bincl_list
operator|+
name|offset
expr_stmt|;
block|}
name|next_bincl
operator|->
name|pst
operator|=
name|pst
expr_stmt|;
name|next_bincl
operator|->
name|instance
operator|=
name|instance
expr_stmt|;
name|next_bincl
operator|++
operator|->
name|name
operator|=
name|name
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a name, value pair, find the corresponding    bincl in the list.  Return the partial symtab associated    with that header_file_location.  */
end_comment

begin_function
specifier|static
name|struct
name|partial_symtab
modifier|*
name|find_corresponding_bincl_psymtab
parameter_list|(
name|name
parameter_list|,
name|instance
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|instance
decl_stmt|;
block|{
name|struct
name|header_file_location
modifier|*
name|bincl
decl_stmt|;
for|for
control|(
name|bincl
operator|=
name|bincl_list
init|;
name|bincl
operator|<
name|next_bincl
condition|;
name|bincl
operator|++
control|)
if|if
condition|(
name|bincl
operator|->
name|instance
operator|==
name|instance
operator|&&
name|STREQ
argument_list|(
name|name
argument_list|,
name|bincl
operator|->
name|name
argument_list|)
condition|)
return|return
name|bincl
operator|->
name|pst
return|;
name|complain
argument_list|(
operator|&
name|repeated_header_complaint
argument_list|,
name|name
argument_list|,
name|symnum
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|partial_symtab
operator|*
operator|)
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Free the storage allocated for the bincl list.  */
end_comment

begin_function
specifier|static
name|void
name|free_bincl_list
parameter_list|(
name|objfile
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|mfree
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
operator|(
name|PTR
operator|)
name|bincl_list
argument_list|)
expr_stmt|;
name|bincls_allocated
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Scan a SunOs dynamic symbol table for symbols of interest and    add them to the minimal symbol table.  */
end_comment

begin_function
specifier|static
name|void
name|read_dbx_dynamic_symtab
parameter_list|(
name|section_offsets
parameter_list|,
name|objfile
parameter_list|)
name|struct
name|section_offsets
modifier|*
name|section_offsets
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|bfd
modifier|*
name|abfd
init|=
name|objfile
operator|->
name|obfd
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|back_to
decl_stmt|;
name|int
name|counter
decl_stmt|;
name|long
name|dynsym_size
decl_stmt|;
name|long
name|dynsym_count
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|dynsyms
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symptr
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|relptr
decl_stmt|;
name|long
name|dynrel_size
decl_stmt|;
name|long
name|dynrel_count
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|dynrels
decl_stmt|;
name|CORE_ADDR
name|sym_value
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Check that the symbol file has dynamic symbols that we know about.      bfd_arch_unknown can happen if we are reading a sun3 symbol file      on a sun4 host (and vice versa) and bfd is not configured      --with-target=all.  This would trigger an assertion in bfd/sunos.c,      so we ignore the dynamic symbols in this case.  */
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|abfd
argument_list|)
operator|!=
name|bfd_target_aout_flavour
operator|||
operator|(
name|bfd_get_file_flags
argument_list|(
name|abfd
argument_list|)
operator|&
name|DYNAMIC
operator|)
operator|==
literal|0
operator|||
name|bfd_get_arch
argument_list|(
name|abfd
argument_list|)
operator|==
name|bfd_arch_unknown
condition|)
return|return;
name|dynsym_size
operator|=
name|bfd_get_dynamic_symtab_upper_bound
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|dynsym_size
operator|<
literal|0
condition|)
return|return;
name|dynsyms
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|dynsym_size
argument_list|)
expr_stmt|;
name|back_to
operator|=
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|dynsyms
argument_list|)
expr_stmt|;
name|dynsym_count
operator|=
name|bfd_canonicalize_dynamic_symtab
argument_list|(
name|abfd
argument_list|,
name|dynsyms
argument_list|)
expr_stmt|;
if|if
condition|(
name|dynsym_count
operator|<
literal|0
condition|)
block|{
name|do_cleanups
argument_list|(
name|back_to
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Enter dynamic symbols into the minimal symbol table      if this is a stripped executable.  */
if|if
condition|(
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|symptr
operator|=
name|dynsyms
expr_stmt|;
for|for
control|(
name|counter
operator|=
literal|0
init|;
name|counter
operator|<
name|dynsym_count
condition|;
name|counter
operator|++
operator|,
name|symptr
operator|++
control|)
block|{
name|asymbol
modifier|*
name|sym
init|=
operator|*
name|symptr
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|int
name|type
decl_stmt|;
name|sec
operator|=
name|bfd_get_section
argument_list|(
name|sym
argument_list|)
expr_stmt|;
comment|/* BFD symbols are section relative.  */
name|sym_value
operator|=
name|sym
operator|->
name|value
operator|+
name|sec
operator|->
name|vma
expr_stmt|;
if|if
condition|(
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|&
name|SEC_CODE
condition|)
block|{
name|sym_value
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
expr_stmt|;
name|type
operator|=
name|N_TEXT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|&
name|SEC_DATA
condition|)
block|{
name|sym_value
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_DATA
argument_list|)
expr_stmt|;
name|type
operator|=
name|N_DATA
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|&
name|SEC_ALLOC
condition|)
block|{
name|sym_value
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_BSS
argument_list|)
expr_stmt|;
name|type
operator|=
name|N_BSS
expr_stmt|;
block|}
else|else
continue|continue;
if|if
condition|(
name|sym
operator|->
name|flags
operator|&
name|BSF_GLOBAL
condition|)
name|type
operator||=
name|N_EXT
expr_stmt|;
name|record_minimal_symbol
argument_list|(
operator|(
name|char
operator|*
operator|)
name|bfd_asymbol_name
argument_list|(
name|sym
argument_list|)
argument_list|,
name|sym_value
argument_list|,
name|type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Symbols from shared libraries have a dynamic relocation entry      that points to the associated slot in the procedure linkage table.      We make a mininal symbol table entry with type mst_solib_trampoline      at the address in the procedure linkage table.  */
name|dynrel_size
operator|=
name|bfd_get_dynamic_reloc_upper_bound
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|dynrel_size
operator|<
literal|0
condition|)
block|{
name|do_cleanups
argument_list|(
name|back_to
argument_list|)
expr_stmt|;
return|return;
block|}
name|dynrels
operator|=
operator|(
name|arelent
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|dynrel_size
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|dynrels
argument_list|)
expr_stmt|;
name|dynrel_count
operator|=
name|bfd_canonicalize_dynamic_reloc
argument_list|(
name|abfd
argument_list|,
name|dynrels
argument_list|,
name|dynsyms
argument_list|)
expr_stmt|;
if|if
condition|(
name|dynrel_count
operator|<
literal|0
condition|)
block|{
name|do_cleanups
argument_list|(
name|back_to
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|counter
operator|=
literal|0
operator|,
name|relptr
operator|=
name|dynrels
init|;
name|counter
operator|<
name|dynrel_count
condition|;
name|counter
operator|++
operator|,
name|relptr
operator|++
control|)
block|{
name|arelent
modifier|*
name|rel
init|=
operator|*
name|relptr
decl_stmt|;
name|CORE_ADDR
name|address
init|=
name|rel
operator|->
name|address
operator|+
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_DATA
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|bfd_get_arch
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
case|case
name|bfd_arch_sparc
case|:
if|if
condition|(
name|rel
operator|->
name|howto
operator|->
name|type
operator|!=
name|RELOC_JMP_SLOT
condition|)
continue|continue;
break|break;
case|case
name|bfd_arch_m68k
case|:
comment|/* `16' is the type BFD produces for a jump table relocation.  */
if|if
condition|(
name|rel
operator|->
name|howto
operator|->
name|type
operator|!=
literal|16
condition|)
continue|continue;
comment|/* Adjust address in the jump table to point to 	     the start of the bsr instruction.  */
name|address
operator|-=
literal|2
expr_stmt|;
break|break;
default|default:
continue|continue;
block|}
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|bfd_asymbol_name
argument_list|(
operator|*
name|rel
operator|->
name|sym_ptr_ptr
argument_list|)
expr_stmt|;
name|prim_record_minimal_symbol
argument_list|(
name|obsavestring
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|)
argument_list|,
name|address
argument_list|,
name|mst_solib_trampoline
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
name|do_cleanups
argument_list|(
name|back_to
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given pointers to an a.out symbol table in core containing dbx    style data, setup partial_symtab's describing each source file for    which debugging information is available.    SYMFILE_NAME is the name of the file we are reading from    and SECTION_OFFSETS is the set of offsets for the various sections    of the file (a set of zeros if the mainline program).  */
end_comment

begin_function
specifier|static
name|void
name|read_dbx_symtab
parameter_list|(
name|section_offsets
parameter_list|,
name|objfile
parameter_list|,
name|text_addr
parameter_list|,
name|text_size
parameter_list|)
name|struct
name|section_offsets
modifier|*
name|section_offsets
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|CORE_ADDR
name|text_addr
decl_stmt|;
name|int
name|text_size
decl_stmt|;
block|{
specifier|register
name|struct
name|internal_nlist
modifier|*
name|bufp
init|=
literal|0
decl_stmt|;
comment|/* =0 avoids gcc -Wall glitch */
specifier|register
name|char
modifier|*
name|namestring
decl_stmt|;
name|int
name|nsl
decl_stmt|;
name|int
name|past_first_source_file
init|=
literal|0
decl_stmt|;
name|CORE_ADDR
name|last_o_file_start
init|=
literal|0
decl_stmt|;
name|CORE_ADDR
name|last_function_start
init|=
literal|0
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|back_to
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
comment|/* Current partial symtab */
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
comment|/* List of current psymtab's include files */
name|char
modifier|*
modifier|*
name|psymtab_include_list
decl_stmt|;
name|int
name|includes_allocated
decl_stmt|;
name|int
name|includes_used
decl_stmt|;
comment|/* Index within current psymtab dependency list */
name|struct
name|partial_symtab
modifier|*
modifier|*
name|dependency_list
decl_stmt|;
name|int
name|dependencies_used
decl_stmt|,
name|dependencies_allocated
decl_stmt|;
comment|/* FIXME.  We probably want to change stringtab_global rather than add this      while processing every symbol entry.  FIXME.  */
name|file_string_table_offset
operator|=
literal|0
expr_stmt|;
name|next_file_string_table_offset
operator|=
literal|0
expr_stmt|;
name|stringtab_global
operator|=
name|DBX_STRINGTAB
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
name|pst
operator|=
operator|(
expr|struct
name|partial_symtab
operator|*
operator|)
literal|0
expr_stmt|;
name|includes_allocated
operator|=
literal|30
expr_stmt|;
name|includes_used
operator|=
literal|0
expr_stmt|;
name|psymtab_include_list
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|alloca
argument_list|(
name|includes_allocated
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|dependencies_allocated
operator|=
literal|30
expr_stmt|;
name|dependencies_used
operator|=
literal|0
expr_stmt|;
name|dependency_list
operator|=
operator|(
expr|struct
name|partial_symtab
operator|*
operator|*
operator|)
name|alloca
argument_list|(
name|dependencies_allocated
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|partial_symtab
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Init bincl list */
name|init_bincl_list
argument_list|(
literal|20
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|back_to
operator|=
name|make_cleanup
argument_list|(
name|free_bincl_list
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|last_source_file
operator|=
name|NULL
expr_stmt|;
name|lowest_text_address
operator|=
operator|(
name|CORE_ADDR
operator|)
operator|-
literal|1
expr_stmt|;
name|symfile_bfd
operator|=
name|objfile
operator|->
name|obfd
expr_stmt|;
comment|/* For next_text_symbol */
name|abfd
operator|=
name|objfile
operator|->
name|obfd
expr_stmt|;
name|symbuf_end
operator|=
name|symbuf_idx
operator|=
literal|0
expr_stmt|;
name|next_symbol_text_func
operator|=
name|dbx_next_symbol_text
expr_stmt|;
for|for
control|(
name|symnum
operator|=
literal|0
init|;
name|symnum
operator|<
name|DBX_SYMCOUNT
argument_list|(
name|objfile
argument_list|)
condition|;
name|symnum
operator|++
control|)
block|{
comment|/* Get the symbol for this run and pull out some info */
name|QUIT
expr_stmt|;
comment|/* allow this to be interruptable */
if|if
condition|(
name|symbuf_idx
operator|==
name|symbuf_end
condition|)
name|fill_symbuf
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|bufp
operator|=
operator|&
name|symbuf
index|[
name|symbuf_idx
operator|++
index|]
expr_stmt|;
comment|/*        * Special case to speed up readin.        */
if|if
condition|(
name|bufp
operator|->
name|n_type
operator|==
operator|(
name|unsigned
name|char
operator|)
name|N_SLINE
condition|)
continue|continue;
name|SWAP_SYMBOL
argument_list|(
name|bufp
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|OBJSTAT
argument_list|(
name|objfile
argument_list|,
name|n_stabs
operator|++
argument_list|)
expr_stmt|;
comment|/* Ok.  There is a lot of code duplicated in the rest of this          switch statement (for efficiency reasons).  Since I don't          like duplicating code, I will do my penance here, and          describe the code which is duplicated:  	 *) The assignment to namestring. 	 *) The call to strchr. 	 *) The addition of a partial symbol the the two partial 	    symbol lists.  This last is a large section of code, so 	    I've imbedded it in the following macro. 	 */
comment|/* Set namestring based on bufp.  If the string table index is invalid,     give a fake name, and print a single error message per symbol file read,    rather than abort the symbol reading or flood the user with messages.  */
comment|/*FIXME: Too many adds and indirections in here for the inner loop.  */
define|#
directive|define
name|SET_NAMESTRING
parameter_list|()
define|\
value|if (((unsigned)bufp->n_strx + file_string_table_offset)>=		\       DBX_STRINGTAB_SIZE (objfile)) {					\     complain (&string_table_offset_complaint, symnum);			\     namestring = "<bad string table offset>";				\   } else								\     namestring = bufp->n_strx + file_string_table_offset +		\ 		 DBX_STRINGTAB (objfile)
define|#
directive|define
name|CUR_SYMBOL_TYPE
value|bufp->n_type
define|#
directive|define
name|CUR_SYMBOL_VALUE
value|bufp->n_value
define|#
directive|define
name|DBXREAD_ONLY
define|#
directive|define
name|START_PSYMTAB
parameter_list|(
name|ofile
parameter_list|,
name|secoff
parameter_list|,
name|fname
parameter_list|,
name|low
parameter_list|,
name|symoff
parameter_list|,
name|global_syms
parameter_list|,
name|static_syms
parameter_list|)
define|\
value|start_psymtab(ofile, secoff, fname, low, symoff, global_syms, static_syms)
define|#
directive|define
name|END_PSYMTAB
parameter_list|(
name|pst
parameter_list|,
name|ilist
parameter_list|,
name|ninc
parameter_list|,
name|c_off
parameter_list|,
name|c_text
parameter_list|,
name|dep_list
parameter_list|,
name|n_deps
parameter_list|)
define|\
value|end_psymtab(pst,ilist,ninc,c_off,c_text,dep_list,n_deps)
include|#
directive|include
file|"partial-stab.h"
block|}
comment|/* If there's stuff to be cleaned up, clean it up.  */
if|if
condition|(
name|DBX_SYMCOUNT
argument_list|(
name|objfile
argument_list|)
operator|>
literal|0
comment|/* We have some syms */
comment|/*FIXME, does this have a bug at start address 0? */
operator|&&
name|last_o_file_start
operator|&&
name|objfile
operator|->
name|ei
operator|.
name|entry_point
operator|<
name|bufp
operator|->
name|n_value
operator|&&
name|objfile
operator|->
name|ei
operator|.
name|entry_point
operator|>=
name|last_o_file_start
condition|)
block|{
name|objfile
operator|->
name|ei
operator|.
name|entry_file_lowpc
operator|=
name|last_o_file_start
expr_stmt|;
name|objfile
operator|->
name|ei
operator|.
name|entry_file_highpc
operator|=
name|bufp
operator|->
name|n_value
expr_stmt|;
block|}
if|if
condition|(
name|pst
condition|)
block|{
name|end_psymtab
argument_list|(
name|pst
argument_list|,
name|psymtab_include_list
argument_list|,
name|includes_used
argument_list|,
name|symnum
operator|*
name|symbol_size
argument_list|,
operator|(
name|lowest_text_address
operator|==
operator|(
name|CORE_ADDR
operator|)
operator|-
literal|1
condition|?
operator|(
name|text_addr
operator|+
name|section_offsets
operator|->
name|offsets
index|[
name|SECT_OFF_TEXT
index|]
operator|)
else|:
name|lowest_text_address
operator|)
operator|+
name|text_size
argument_list|,
name|dependency_list
argument_list|,
name|dependencies_used
argument_list|)
expr_stmt|;
block|}
name|do_cleanups
argument_list|(
name|back_to
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Allocate and partially fill a partial symtab.  It will be    completely filled at the end of the symbol list.     SYMFILE_NAME is the name of the symbol-file we are reading from, and ADDR    is the address relative to which its symbols are (incremental) or 0    (normal). */
end_comment

begin_function
name|struct
name|partial_symtab
modifier|*
name|start_psymtab
parameter_list|(
name|objfile
parameter_list|,
name|section_offsets
parameter_list|,
name|filename
parameter_list|,
name|textlow
parameter_list|,
name|ldsymoff
parameter_list|,
name|global_syms
parameter_list|,
name|static_syms
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|section_offsets
modifier|*
name|section_offsets
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|CORE_ADDR
name|textlow
decl_stmt|;
name|int
name|ldsymoff
decl_stmt|;
name|struct
name|partial_symbol
modifier|*
modifier|*
name|global_syms
decl_stmt|;
name|struct
name|partial_symbol
modifier|*
modifier|*
name|static_syms
decl_stmt|;
block|{
name|struct
name|partial_symtab
modifier|*
name|result
init|=
name|start_psymtab_common
argument_list|(
name|objfile
argument_list|,
name|section_offsets
argument_list|,
name|filename
argument_list|,
name|textlow
argument_list|,
name|global_syms
argument_list|,
name|static_syms
argument_list|)
decl_stmt|;
name|result
operator|->
name|read_symtab_private
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|psymbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symloc
argument_list|)
argument_list|)
expr_stmt|;
name|LDSYMOFF
argument_list|(
name|result
argument_list|)
operator|=
name|ldsymoff
expr_stmt|;
name|result
operator|->
name|read_symtab
operator|=
name|dbx_psymtab_to_symtab
expr_stmt|;
name|SYMBOL_SIZE
argument_list|(
name|result
argument_list|)
operator|=
name|symbol_size
expr_stmt|;
name|SYMBOL_OFFSET
argument_list|(
name|result
argument_list|)
operator|=
name|symbol_table_offset
expr_stmt|;
name|STRING_OFFSET
argument_list|(
name|result
argument_list|)
operator|=
name|string_table_offset
expr_stmt|;
name|FILE_STRING_OFFSET
argument_list|(
name|result
argument_list|)
operator|=
name|file_string_table_offset
expr_stmt|;
comment|/* If we're handling an ELF file, drag some section-relocation info      for this source file out of the ELF symbol table, to compensate for      Sun brain death.  This replaces the section_offsets in this psymtab,      if successful.  */
name|elfstab_offset_sections
argument_list|(
name|objfile
argument_list|,
name|result
argument_list|)
expr_stmt|;
comment|/* Deduce the source language from the filename for this psymtab. */
name|psymtab_language
operator|=
name|deduce_language_from_filename
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Close off the current usage of PST.      Returns PST or NULL if the partial symtab was empty and thrown away.     FIXME:  List variables and peculiarities of same.  */
end_comment

begin_function
name|struct
name|partial_symtab
modifier|*
name|end_psymtab
parameter_list|(
name|pst
parameter_list|,
name|include_list
parameter_list|,
name|num_includes
parameter_list|,
name|capping_symbol_offset
parameter_list|,
name|capping_text
parameter_list|,
name|dependency_list
parameter_list|,
name|number_dependencies
parameter_list|)
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
name|char
modifier|*
modifier|*
name|include_list
decl_stmt|;
name|int
name|num_includes
decl_stmt|;
name|int
name|capping_symbol_offset
decl_stmt|;
name|CORE_ADDR
name|capping_text
decl_stmt|;
name|struct
name|partial_symtab
modifier|*
modifier|*
name|dependency_list
decl_stmt|;
name|int
name|number_dependencies
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
init|=
name|pst
operator|->
name|objfile
decl_stmt|;
if|if
condition|(
name|capping_symbol_offset
operator|!=
operator|-
literal|1
condition|)
name|LDSYMLEN
argument_list|(
name|pst
argument_list|)
operator|=
name|capping_symbol_offset
operator|-
name|LDSYMOFF
argument_list|(
name|pst
argument_list|)
expr_stmt|;
name|pst
operator|->
name|texthigh
operator|=
name|capping_text
expr_stmt|;
ifdef|#
directive|ifdef
name|SOFUN_ADDRESS_MAYBE_MISSING
comment|/* Under Solaris, the N_SO symbols always have a value of 0,      instead of the usual address of the .o file.  Therefore,      we have to do some tricks to fill in texthigh and textlow.      The first trick is in partial-stab.h: if we see a static      or global function, and the textlow for the current pst      is still 0, then we use that function's address for       the textlow of the pst.  */
comment|/* Now, to fill in texthigh, we remember the last function seen      in the .o file (also in partial-stab.h).  Also, there's a hack in      bfd/elf.c and gdb/elfread.c to pass the ELF st_size field      to here via the misc_info field.  Therefore, we can fill in      a reliable texthigh by taking the address plus size of the      last function in the file.  */
if|if
condition|(
name|pst
operator|->
name|texthigh
operator|==
literal|0
operator|&&
name|last_function_name
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|n
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|minsym
decl_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|last_function_name
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|p
operator|=
name|last_function_name
expr_stmt|;
name|n
operator|=
name|p
operator|-
name|last_function_name
expr_stmt|;
name|p
operator|=
name|alloca
argument_list|(
name|n
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|p
argument_list|,
name|last_function_name
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|p
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
name|minsym
operator|=
name|lookup_minimal_symbol
argument_list|(
name|p
argument_list|,
name|pst
operator|->
name|filename
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|minsym
condition|)
name|pst
operator|->
name|texthigh
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|minsym
argument_list|)
operator|+
operator|(
name|long
operator|)
name|MSYMBOL_INFO
argument_list|(
name|minsym
argument_list|)
expr_stmt|;
name|last_function_name
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* this test will be true if the last .o file is only data */
if|if
condition|(
name|pst
operator|->
name|textlow
operator|==
literal|0
condition|)
comment|/* This loses if the text section really starts at address zero        (generally true when we are debugging a .o file, for example).        That is why this whole thing is inside SOFUN_ADDRESS_MAYBE_MISSING.  */
name|pst
operator|->
name|textlow
operator|=
name|pst
operator|->
name|texthigh
expr_stmt|;
comment|/* If we know our own starting text address, then walk through all other      psymtabs for this objfile, and if any didn't know their ending text      address, set it to our starting address.  Take care to not set our      own ending address to our starting address, nor to set addresses on      `dependency' files that have both textlow and texthigh zero.  */
if|if
condition|(
name|pst
operator|->
name|textlow
condition|)
block|{
name|struct
name|partial_symtab
modifier|*
name|p1
decl_stmt|;
name|ALL_OBJFILE_PSYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|p1
argument_list|)
block|{
if|if
condition|(
name|p1
operator|->
name|texthigh
operator|==
literal|0
operator|&&
name|p1
operator|->
name|textlow
operator|!=
literal|0
operator|&&
name|p1
operator|!=
name|pst
condition|)
block|{
name|p1
operator|->
name|texthigh
operator|=
name|pst
operator|->
name|textlow
expr_stmt|;
comment|/* if this file has only data, then make textlow match texthigh */
if|if
condition|(
name|p1
operator|->
name|textlow
operator|==
literal|0
condition|)
name|p1
operator|->
name|textlow
operator|=
name|p1
operator|->
name|texthigh
expr_stmt|;
block|}
block|}
block|}
comment|/* End of kludge for patching Solaris textlow and texthigh.  */
endif|#
directive|endif
comment|/* SOFUN_ADDRESS_MAYBE_MISSING.  */
name|pst
operator|->
name|n_global_syms
operator|=
name|objfile
operator|->
name|global_psymbols
operator|.
name|next
operator|-
operator|(
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
operator|+
name|pst
operator|->
name|globals_offset
operator|)
expr_stmt|;
name|pst
operator|->
name|n_static_syms
operator|=
name|objfile
operator|->
name|static_psymbols
operator|.
name|next
operator|-
operator|(
name|objfile
operator|->
name|static_psymbols
operator|.
name|list
operator|+
name|pst
operator|->
name|statics_offset
operator|)
expr_stmt|;
name|pst
operator|->
name|number_of_dependencies
operator|=
name|number_dependencies
expr_stmt|;
if|if
condition|(
name|number_dependencies
condition|)
block|{
name|pst
operator|->
name|dependencies
operator|=
operator|(
expr|struct
name|partial_symtab
operator|*
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|psymbol_obstack
argument_list|,
name|number_dependencies
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|partial_symtab
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|pst
operator|->
name|dependencies
argument_list|,
name|dependency_list
argument_list|,
name|number_dependencies
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|partial_symtab
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|pst
operator|->
name|dependencies
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_includes
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|partial_symtab
modifier|*
name|subpst
init|=
name|allocate_psymtab
argument_list|(
name|include_list
index|[
name|i
index|]
argument_list|,
name|objfile
argument_list|)
decl_stmt|;
name|subpst
operator|->
name|section_offsets
operator|=
name|pst
operator|->
name|section_offsets
expr_stmt|;
name|subpst
operator|->
name|read_symtab_private
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|psymbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symloc
argument_list|)
argument_list|)
expr_stmt|;
name|LDSYMOFF
argument_list|(
name|subpst
argument_list|)
operator|=
name|LDSYMLEN
argument_list|(
name|subpst
argument_list|)
operator|=
name|subpst
operator|->
name|textlow
operator|=
name|subpst
operator|->
name|texthigh
operator|=
literal|0
expr_stmt|;
comment|/* We could save slight bits of space by only making one of these, 	 shared by the entire set of include files.  FIXME-someday.  */
name|subpst
operator|->
name|dependencies
operator|=
operator|(
expr|struct
name|partial_symtab
operator|*
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|psymbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|partial_symtab
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|subpst
operator|->
name|dependencies
index|[
literal|0
index|]
operator|=
name|pst
expr_stmt|;
name|subpst
operator|->
name|number_of_dependencies
operator|=
literal|1
expr_stmt|;
name|subpst
operator|->
name|globals_offset
operator|=
name|subpst
operator|->
name|n_global_syms
operator|=
name|subpst
operator|->
name|statics_offset
operator|=
name|subpst
operator|->
name|n_static_syms
operator|=
literal|0
expr_stmt|;
name|subpst
operator|->
name|readin
operator|=
literal|0
expr_stmt|;
name|subpst
operator|->
name|symtab
operator|=
literal|0
expr_stmt|;
name|subpst
operator|->
name|read_symtab
operator|=
name|pst
operator|->
name|read_symtab
expr_stmt|;
block|}
name|sort_pst_symbols
argument_list|(
name|pst
argument_list|)
expr_stmt|;
comment|/* If there is already a psymtab or symtab for a file of this name, remove it.      (If there is a symtab, more drastic things also happen.)      This happens in VxWorks.  */
name|free_named_symtabs
argument_list|(
name|pst
operator|->
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_includes
operator|==
literal|0
operator|&&
name|number_dependencies
operator|==
literal|0
operator|&&
name|pst
operator|->
name|n_global_syms
operator|==
literal|0
operator|&&
name|pst
operator|->
name|n_static_syms
operator|==
literal|0
condition|)
block|{
comment|/* Throw away this psymtab, it's empty.  We can't deallocate it, since 	 it is on the obstack, but we can forget to chain it on the list.  */
comment|/* Empty psymtabs happen as a result of header files which don't have 	 any symbols in them.  There can be a lot of them.  But this check 	 is wrong, in that a psymtab with N_SLINE entries but nothing else 	 is not empty, but we don't realize that.  Fixing that without slowing 	 things down might be tricky.  */
name|struct
name|partial_symtab
modifier|*
name|prev_pst
decl_stmt|;
comment|/* First, snip it out of the psymtab chain */
if|if
condition|(
name|pst
operator|->
name|objfile
operator|->
name|psymtabs
operator|==
name|pst
condition|)
name|pst
operator|->
name|objfile
operator|->
name|psymtabs
operator|=
name|pst
operator|->
name|next
expr_stmt|;
else|else
for|for
control|(
name|prev_pst
operator|=
name|pst
operator|->
name|objfile
operator|->
name|psymtabs
init|;
name|prev_pst
condition|;
name|prev_pst
operator|=
name|pst
operator|->
name|next
control|)
if|if
condition|(
name|prev_pst
operator|->
name|next
operator|==
name|pst
condition|)
name|prev_pst
operator|->
name|next
operator|=
name|pst
operator|->
name|next
expr_stmt|;
comment|/* Next, put it on a free list for recycling */
name|pst
operator|->
name|next
operator|=
name|pst
operator|->
name|objfile
operator|->
name|free_psymtabs
expr_stmt|;
name|pst
operator|->
name|objfile
operator|->
name|free_psymtabs
operator|=
name|pst
expr_stmt|;
comment|/* Indicate that psymtab was thrown away.  */
name|pst
operator|=
operator|(
expr|struct
name|partial_symtab
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
return|return
name|pst
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|dbx_psymtab_to_symtab_1
parameter_list|(
name|pst
parameter_list|)
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
block|{
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|pst
condition|)
return|return;
if|if
condition|(
name|pst
operator|->
name|readin
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Psymtab for %s already read in.  Shouldn't happen.\n"
argument_list|,
name|pst
operator|->
name|filename
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Read in all partial symtabs on which this one is dependent */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pst
operator|->
name|number_of_dependencies
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|pst
operator|->
name|dependencies
index|[
name|i
index|]
operator|->
name|readin
condition|)
block|{
comment|/* Inform about additional files that need to be read in.  */
if|if
condition|(
name|info_verbose
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|" "
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"and "
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%s..."
argument_list|,
name|pst
operator|->
name|dependencies
index|[
name|i
index|]
operator|->
name|filename
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
comment|/* Flush output */
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
name|dbx_psymtab_to_symtab_1
argument_list|(
name|pst
operator|->
name|dependencies
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LDSYMLEN
argument_list|(
name|pst
argument_list|)
condition|)
comment|/* Otherwise it's a dummy */
block|{
comment|/* Init stuff necessary for reading in symbols */
name|stabsread_init
argument_list|()
expr_stmt|;
name|buildsym_init
argument_list|()
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|really_free_pendings
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|file_string_table_offset
operator|=
name|FILE_STRING_OFFSET
argument_list|(
name|pst
argument_list|)
expr_stmt|;
name|symbol_size
operator|=
name|SYMBOL_SIZE
argument_list|(
name|pst
argument_list|)
expr_stmt|;
comment|/* Read in this file's symbols */
name|bfd_seek
argument_list|(
name|pst
operator|->
name|objfile
operator|->
name|obfd
argument_list|,
name|SYMBOL_OFFSET
argument_list|(
name|pst
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|read_ofile_symtab
argument_list|(
name|pst
argument_list|)
expr_stmt|;
name|sort_symtab_syms
argument_list|(
name|pst
operator|->
name|symtab
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
name|pst
operator|->
name|readin
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read in all of the symbols for a given psymtab for real.    Be verbose about it if the user wants that.  */
end_comment

begin_function
specifier|static
name|void
name|dbx_psymtab_to_symtab
parameter_list|(
name|pst
parameter_list|)
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
block|{
name|bfd
modifier|*
name|sym_bfd
decl_stmt|;
if|if
condition|(
operator|!
name|pst
condition|)
return|return;
if|if
condition|(
name|pst
operator|->
name|readin
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Psymtab for %s already read in.  Shouldn't happen.\n"
argument_list|,
name|pst
operator|->
name|filename
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|LDSYMLEN
argument_list|(
name|pst
argument_list|)
operator|||
name|pst
operator|->
name|number_of_dependencies
condition|)
block|{
comment|/* Print the message now, before reading the string table, 	 to avoid disconcerting pauses.  */
if|if
condition|(
name|info_verbose
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Reading in symbols for %s..."
argument_list|,
name|pst
operator|->
name|filename
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
name|sym_bfd
operator|=
name|pst
operator|->
name|objfile
operator|->
name|obfd
expr_stmt|;
name|next_symbol_text_func
operator|=
name|dbx_next_symbol_text
expr_stmt|;
name|dbx_psymtab_to_symtab_1
argument_list|(
name|pst
argument_list|)
expr_stmt|;
comment|/* Match with global symbols.  This only needs to be done once,          after all of the symtabs and dependencies have been read in.   */
name|scan_file_globals
argument_list|(
name|pst
operator|->
name|objfile
argument_list|)
expr_stmt|;
comment|/* Finish up the debug error message.  */
if|if
condition|(
name|info_verbose
condition|)
name|printf_filtered
argument_list|(
literal|"done.\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Read in a defined section of a specific object file's symbols. */
end_comment

begin_function
specifier|static
name|void
name|read_ofile_symtab
parameter_list|(
name|pst
parameter_list|)
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|namestring
decl_stmt|;
specifier|register
name|struct
name|internal_nlist
modifier|*
name|bufp
decl_stmt|;
name|unsigned
name|char
name|type
decl_stmt|;
name|unsigned
name|max_symnum
decl_stmt|;
specifier|register
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|int
name|sym_offset
decl_stmt|;
comment|/* Offset to start of symbols to read */
name|int
name|sym_size
decl_stmt|;
comment|/* Size of symbols to read */
name|CORE_ADDR
name|text_offset
decl_stmt|;
comment|/* Start of text segment for symbols */
name|int
name|text_size
decl_stmt|;
comment|/* Size of text segment for symbols */
name|struct
name|section_offsets
modifier|*
name|section_offsets
decl_stmt|;
name|objfile
operator|=
name|pst
operator|->
name|objfile
expr_stmt|;
name|sym_offset
operator|=
name|LDSYMOFF
argument_list|(
name|pst
argument_list|)
expr_stmt|;
name|sym_size
operator|=
name|LDSYMLEN
argument_list|(
name|pst
argument_list|)
expr_stmt|;
name|text_offset
operator|=
name|pst
operator|->
name|textlow
expr_stmt|;
name|text_size
operator|=
name|pst
operator|->
name|texthigh
operator|-
name|pst
operator|->
name|textlow
expr_stmt|;
name|section_offsets
operator|=
name|pst
operator|->
name|section_offsets
expr_stmt|;
name|current_objfile
operator|=
name|objfile
expr_stmt|;
name|subfile_stack
operator|=
name|NULL
expr_stmt|;
name|stringtab_global
operator|=
name|DBX_STRINGTAB
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
name|last_source_file
operator|=
name|NULL
expr_stmt|;
name|abfd
operator|=
name|objfile
operator|->
name|obfd
expr_stmt|;
name|symfile_bfd
operator|=
name|objfile
operator|->
name|obfd
expr_stmt|;
comment|/* Implicit param to next_text_symbol */
name|symbuf_end
operator|=
name|symbuf_idx
operator|=
literal|0
expr_stmt|;
comment|/* It is necessary to actually read one symbol *before* the start      of this symtab's symbols, because the GCC_COMPILED_FLAG_SYMBOL      occurs before the N_SO symbol.       Detecting this in read_dbx_symtab      would slow down initial readin, so we look for it here instead.  */
if|if
condition|(
operator|!
name|processing_acc_compilation
operator|&&
name|sym_offset
operator|>=
operator|(
name|int
operator|)
name|symbol_size
condition|)
block|{
name|bfd_seek
argument_list|(
name|symfile_bfd
argument_list|,
name|sym_offset
operator|-
name|symbol_size
argument_list|,
name|SEEK_CUR
argument_list|)
expr_stmt|;
name|fill_symbuf
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|bufp
operator|=
operator|&
name|symbuf
index|[
name|symbuf_idx
operator|++
index|]
expr_stmt|;
name|SWAP_SYMBOL
argument_list|(
name|bufp
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|OBJSTAT
argument_list|(
name|objfile
argument_list|,
name|n_stabs
operator|++
argument_list|)
expr_stmt|;
name|SET_NAMESTRING
argument_list|()
expr_stmt|;
name|processing_gcc_compilation
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bufp
operator|->
name|n_type
operator|==
name|N_TEXT
condition|)
block|{
specifier|const
name|char
modifier|*
name|tempstring
init|=
name|namestring
decl_stmt|;
if|if
condition|(
name|STREQ
argument_list|(
name|namestring
argument_list|,
name|GCC_COMPILED_FLAG_SYMBOL
argument_list|)
condition|)
name|processing_gcc_compilation
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|namestring
argument_list|,
name|GCC2_COMPILED_FLAG_SYMBOL
argument_list|)
condition|)
name|processing_gcc_compilation
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|tempstring
index|[
literal|0
index|]
operator|==
name|bfd_get_symbol_leading_char
argument_list|(
name|symfile_bfd
argument_list|)
condition|)
operator|++
name|tempstring
expr_stmt|;
if|if
condition|(
name|STREQN
argument_list|(
name|tempstring
argument_list|,
literal|"__gnu_compiled"
argument_list|,
literal|14
argument_list|)
condition|)
name|processing_gcc_compilation
operator|=
literal|2
expr_stmt|;
block|}
comment|/* Try to select a C++ demangling based on the compilation unit 	 producer. */
if|if
condition|(
name|processing_gcc_compilation
condition|)
block|{
if|if
condition|(
name|AUTO_DEMANGLING
condition|)
block|{
name|set_demangling_style
argument_list|(
name|GNU_DEMANGLING_STYLE_STRING
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* The N_SO starting this symtab is the first symbol, so we 	 better not check the symbol before it.  I'm not this can 	 happen, but it doesn't hurt to check for it.  */
name|bfd_seek
argument_list|(
name|symfile_bfd
argument_list|,
name|sym_offset
argument_list|,
name|SEEK_CUR
argument_list|)
expr_stmt|;
name|processing_gcc_compilation
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|symbuf_idx
operator|==
name|symbuf_end
condition|)
name|fill_symbuf
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|bufp
operator|=
operator|&
name|symbuf
index|[
name|symbuf_idx
index|]
expr_stmt|;
if|if
condition|(
name|bufp
operator|->
name|n_type
operator|!=
operator|(
name|unsigned
name|char
operator|)
name|N_SO
condition|)
name|error
argument_list|(
literal|"First symbol in segment of executable not a source symbol"
argument_list|)
expr_stmt|;
name|max_symnum
operator|=
name|sym_size
operator|/
name|symbol_size
expr_stmt|;
for|for
control|(
name|symnum
operator|=
literal|0
init|;
name|symnum
operator|<
name|max_symnum
condition|;
name|symnum
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
comment|/* Allow this to be interruptable */
if|if
condition|(
name|symbuf_idx
operator|==
name|symbuf_end
condition|)
name|fill_symbuf
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|bufp
operator|=
operator|&
name|symbuf
index|[
name|symbuf_idx
operator|++
index|]
expr_stmt|;
name|SWAP_SYMBOL
argument_list|(
name|bufp
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|OBJSTAT
argument_list|(
name|objfile
argument_list|,
name|n_stabs
operator|++
argument_list|)
expr_stmt|;
name|type
operator|=
name|bufp
operator|->
name|n_type
expr_stmt|;
name|SET_NAMESTRING
argument_list|()
expr_stmt|;
if|if
condition|(
name|type
operator|&
name|N_STAB
condition|)
block|{
name|process_one_symbol
argument_list|(
name|type
argument_list|,
name|bufp
operator|->
name|n_desc
argument_list|,
name|bufp
operator|->
name|n_value
argument_list|,
name|namestring
argument_list|,
name|section_offsets
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
comment|/* We skip checking for a new .o or -l file; that should never          happen in this routine. */
elseif|else
if|if
condition|(
name|type
operator|==
name|N_TEXT
condition|)
block|{
comment|/* I don't think this code will ever be executed, because 	     the GCC_COMPILED_FLAG_SYMBOL usually is right before 	     the N_SO symbol which starts this source file. 	     However, there is no reason not to accept 	     the GCC_COMPILED_FLAG_SYMBOL anywhere.  */
if|if
condition|(
name|STREQ
argument_list|(
name|namestring
argument_list|,
name|GCC_COMPILED_FLAG_SYMBOL
argument_list|)
condition|)
name|processing_gcc_compilation
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|namestring
argument_list|,
name|GCC2_COMPILED_FLAG_SYMBOL
argument_list|)
condition|)
name|processing_gcc_compilation
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|AUTO_DEMANGLING
condition|)
block|{
name|set_demangling_style
argument_list|(
name|GNU_DEMANGLING_STYLE_STRING
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|type
operator|&
name|N_EXT
operator|||
name|type
operator|==
operator|(
name|unsigned
name|char
operator|)
name|N_TEXT
operator|||
name|type
operator|==
operator|(
name|unsigned
name|char
operator|)
name|N_NBTEXT
condition|)
block|{
comment|/* Global symbol: see if we came across a dbx defintion for 	     a corresponding symbol.  If so, store the value.  Remove 	     syms from the chain when their values are stored, but 	     search the whole chain, as there may be several syms from 	     different files with the same name. */
comment|/* This is probably not true.  Since the files will be read 	     in one at a time, each reference to a global symbol will 	     be satisfied in each file as it appears. So we skip this 	     section. */
empty_stmt|;
block|}
block|}
name|current_objfile
operator|=
name|NULL
expr_stmt|;
comment|/* In a Solaris elf file, this variable, which comes from the      value of the N_SO symbol, will still be 0.  Luckily, text_offset,      which comes from pst->textlow is correct. */
if|if
condition|(
name|last_source_start_addr
operator|==
literal|0
condition|)
name|last_source_start_addr
operator|=
name|text_offset
expr_stmt|;
comment|/* In reordered executables last_source_start_addr may not be the      lower bound for this symtab, instead use text_offset which comes      from pst->textlow which is correct.  */
if|if
condition|(
name|last_source_start_addr
operator|>
name|text_offset
condition|)
name|last_source_start_addr
operator|=
name|text_offset
expr_stmt|;
name|pst
operator|->
name|symtab
operator|=
name|end_symtab
argument_list|(
name|text_offset
operator|+
name|text_size
argument_list|,
name|objfile
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
expr_stmt|;
name|end_stabs
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This handles a single symbol from the symbol-file, building symbols    into a GDB symtab.  It takes these arguments and an implicit argument.     TYPE is the type field of the ".stab" symbol entry.    DESC is the desc field of the ".stab" entry.    VALU is the value field of the ".stab" entry.    NAME is the symbol name, in our address space.    SECTION_OFFSETS is a set of amounts by which the sections of this object           file were relocated when it was loaded into memory.           All symbols that refer 	  to memory locations need to be offset by these amounts.    OBJFILE is the object file from which we are reading symbols.  	       It is used in end_symtab.  */
end_comment

begin_function
name|void
name|process_one_symbol
parameter_list|(
name|type
parameter_list|,
name|desc
parameter_list|,
name|valu
parameter_list|,
name|name
parameter_list|,
name|section_offsets
parameter_list|,
name|objfile
parameter_list|)
name|int
name|type
decl_stmt|,
name|desc
decl_stmt|;
name|CORE_ADDR
name|valu
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|section_offsets
modifier|*
name|section_offsets
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|SUN_FIXED_LBRAC_BUG
comment|/* If SUN_FIXED_LBRAC_BUG is defined, then it tells us whether we need      to correct the address of N_LBRAC's.  If it is not defined, then      we never need to correct the addresses.  */
comment|/* This records the last pc address we've seen.  We depend on there being      an SLINE or FUN or SO before the first LBRAC, since the variable does      not get reset in between reads of different symbol files.  */
specifier|static
name|CORE_ADDR
name|last_pc_address
decl_stmt|;
endif|#
directive|endif
specifier|register
name|struct
name|context_stack
modifier|*
name|new
decl_stmt|;
comment|/* This remembers the address of the start of a function.  It is used      because in Solaris 2, N_LBRAC, N_RBRAC, and N_SLINE entries are      relative to the current function's start address.  On systems      other than Solaris 2, this just holds the SECT_OFF_TEXT value, and is      used to relocate these symbol types rather than SECTION_OFFSETS.  */
specifier|static
name|CORE_ADDR
name|function_start_offset
decl_stmt|;
comment|/* If this is nonzero, we've seen a non-gcc N_OPT symbol for this source      file.  Used to detect the SunPRO solaris compiler.  */
specifier|static
name|int
name|n_opt_found
decl_stmt|;
comment|/* The stab type used for the definition of the last function.      N_STSYM or N_GSYM for SunOS4 acc; N_FUN for other compilers.  */
specifier|static
name|int
name|function_stab_type
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|block_address_function_relative
condition|)
comment|/* N_LBRAC, N_RBRAC and N_SLINE entries are not relative to the        function start address, so just use the text offset.  */
name|function_start_offset
operator|=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
expr_stmt|;
comment|/* Something is wrong if we see real data before      seeing a source file name.  */
if|if
condition|(
name|last_source_file
operator|==
name|NULL
operator|&&
name|type
operator|!=
operator|(
name|unsigned
name|char
operator|)
name|N_SO
condition|)
block|{
comment|/* Ignore any symbols which appear before an N_SO symbol.  Currently 	 no one puts symbols there, but we should deal gracefully with the 	 case.  A complain()t might be in order (if !IGNORE_SYMBOL (type)), 	 but this should not be an error ().  */
return|return;
block|}
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|N_FUN
case|:
case|case
name|N_FNAME
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|""
argument_list|)
condition|)
block|{
comment|/* This N_FUN marks the end of a function.  This closes off the 	     current block.  */
name|within_function
operator|=
literal|0
expr_stmt|;
name|new
operator|=
name|pop_context
argument_list|()
expr_stmt|;
comment|/* Make a block for the local symbols within.  */
name|finish_block
argument_list|(
name|new
operator|->
name|name
argument_list|,
operator|&
name|local_symbols
argument_list|,
name|new
operator|->
name|old_blocks
argument_list|,
name|function_start_offset
argument_list|,
name|function_start_offset
operator|+
name|valu
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Relocate for dynamic loading */
name|valu
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
expr_stmt|;
goto|goto
name|define_a_symbol
goto|;
case|case
name|N_LBRAC
case|:
comment|/* This "symbol" just indicates the start of an inner lexical 	 context within a function.  */
comment|/* Ignore extra outermost context from SunPRO cc and acc.  */
if|if
condition|(
name|n_opt_found
operator|&&
name|desc
operator|==
literal|1
condition|)
break|break;
if|#
directive|if
name|defined
argument_list|(
name|BLOCK_ADDRESS_ABSOLUTE
argument_list|)
comment|/* Relocate for dynamic loading (?).  */
name|valu
operator|+=
name|function_start_offset
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|block_address_function_relative
condition|)
comment|/* Relocate for Sun ELF acc fn-relative syms.  */
name|valu
operator|+=
name|function_start_offset
expr_stmt|;
else|else
comment|/* On most machines, the block addresses are relative to the 	   N_SO, the linker did not relocate them (sigh).  */
name|valu
operator|+=
name|last_source_start_addr
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SUN_FIXED_LBRAC_BUG
if|if
condition|(
operator|!
name|SUN_FIXED_LBRAC_BUG
operator|&&
name|valu
operator|<
name|last_pc_address
condition|)
block|{
comment|/* Patch current LBRAC pc value to match last handy pc value */
name|complain
argument_list|(
operator|&
name|lbrac_complaint
argument_list|)
expr_stmt|;
name|valu
operator|=
name|last_pc_address
expr_stmt|;
block|}
endif|#
directive|endif
name|new
operator|=
name|push_context
argument_list|(
name|desc
argument_list|,
name|valu
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_RBRAC
case|:
comment|/* This "symbol" just indicates the end of an inner lexical 	 context that was started with N_LBRAC.  */
comment|/* Ignore extra outermost context from SunPRO cc and acc.  */
if|if
condition|(
name|n_opt_found
operator|&&
name|desc
operator|==
literal|1
condition|)
break|break;
if|#
directive|if
name|defined
argument_list|(
name|BLOCK_ADDRESS_ABSOLUTE
argument_list|)
comment|/* Relocate for dynamic loading (?).  */
name|valu
operator|+=
name|function_start_offset
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|block_address_function_relative
condition|)
comment|/* Relocate for Sun ELF acc fn-relative syms.  */
name|valu
operator|+=
name|function_start_offset
expr_stmt|;
else|else
comment|/* On most machines, the block addresses are relative to the 	   N_SO, the linker did not relocate them (sigh).  */
name|valu
operator|+=
name|last_source_start_addr
expr_stmt|;
endif|#
directive|endif
name|new
operator|=
name|pop_context
argument_list|()
expr_stmt|;
if|if
condition|(
name|desc
operator|!=
name|new
operator|->
name|depth
condition|)
name|complain
argument_list|(
operator|&
name|lbrac_mismatch_complaint
argument_list|,
name|symnum
argument_list|)
expr_stmt|;
comment|/* Some compilers put the variable decls inside of an          LBRAC/RBRAC block.  This macro should be nonzero if this 	 is true.  DESC is N_DESC from the N_RBRAC symbol. 	 GCC_P is true if we've detected the GCC_COMPILED_SYMBOL 	 or the GCC2_COMPILED_SYMBOL.  */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|VARIABLES_INSIDE_BLOCK
argument_list|)
define|#
directive|define
name|VARIABLES_INSIDE_BLOCK
parameter_list|(
name|desc
parameter_list|,
name|gcc_p
parameter_list|)
value|0
endif|#
directive|endif
comment|/* Can only use new->locals as local symbols here if we're in          gcc or on a machine that puts them before the lbrack.  */
if|if
condition|(
operator|!
name|VARIABLES_INSIDE_BLOCK
argument_list|(
name|desc
argument_list|,
name|processing_gcc_compilation
argument_list|)
condition|)
name|local_symbols
operator|=
name|new
operator|->
name|locals
expr_stmt|;
if|if
condition|(
name|context_stack_depth
operator|>
operator|!
name|VARIABLES_INSIDE_BLOCK
argument_list|(
name|desc
argument_list|,
name|processing_gcc_compilation
argument_list|)
condition|)
block|{
comment|/* This is not the outermost LBRAC...RBRAC pair in the function, 	     its local symbols preceded it, and are the ones just recovered 	     from the context stack.  Define the block for them (but don't 	     bother if the block contains no symbols.  Should we complain 	     on blocks without symbols?  I can't think of any useful purpose 	     for them).  */
if|if
condition|(
name|local_symbols
operator|!=
name|NULL
condition|)
block|{
comment|/* Muzzle a compiler bug that makes end< start.  (which 		 compilers?  Is this ever harmful?).  */
if|if
condition|(
name|new
operator|->
name|start_addr
operator|>
name|valu
condition|)
block|{
name|complain
argument_list|(
operator|&
name|lbrac_rbrac_complaint
argument_list|)
expr_stmt|;
name|new
operator|->
name|start_addr
operator|=
name|valu
expr_stmt|;
block|}
comment|/* Make a block for the local symbols within.  */
name|finish_block
argument_list|(
literal|0
argument_list|,
operator|&
name|local_symbols
argument_list|,
name|new
operator|->
name|old_blocks
argument_list|,
name|new
operator|->
name|start_addr
argument_list|,
name|valu
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* This is the outermost LBRAC...RBRAC pair.  There is no 	     need to do anything; leave the symbols that preceded it 	     to be attached to the function's own block.  We need to 	     indicate that we just moved outside of the function.  */
name|within_function
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|VARIABLES_INSIDE_BLOCK
argument_list|(
name|desc
argument_list|,
name|processing_gcc_compilation
argument_list|)
condition|)
comment|/* Now pop locals of block just finished.  */
name|local_symbols
operator|=
name|new
operator|->
name|locals
expr_stmt|;
break|break;
case|case
name|N_FN
case|:
case|case
name|N_FN_SEQ
case|:
comment|/* This kind of symbol indicates the start of an object file.  */
comment|/* Relocate for dynamic loading */
name|valu
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_SO
case|:
comment|/* This type of symbol indicates the start of data 	 for one source file. 	 Finish the symbol table of the previous source file 	 (if any) and start accumulating a new symbol table.  */
comment|/* Relocate for dynamic loading */
name|valu
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
expr_stmt|;
name|n_opt_found
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|SUN_FIXED_LBRAC_BUG
name|last_pc_address
operator|=
name|valu
expr_stmt|;
comment|/* Save for SunOS bug circumcision */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PCC_SOL_BROKEN
comment|/* pcc bug, occasionally puts out SO for SOL.  */
if|if
condition|(
name|context_stack_depth
operator|>
literal|0
condition|)
block|{
name|start_subfile
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
if|if
condition|(
name|last_source_file
condition|)
block|{
comment|/* Check if previous symbol was also an N_SO (with some 	     sanity checks).  If so, that one was actually the directory 	     name, and the current one is the real file name. 	     Patch things up. */
if|if
condition|(
name|previous_stab_code
operator|==
operator|(
name|unsigned
name|char
operator|)
name|N_SO
condition|)
block|{
name|patch_subfile_names
argument_list|(
name|current_subfile
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
comment|/* Ignore repeated SOs */
block|}
name|end_symtab
argument_list|(
name|valu
argument_list|,
name|objfile
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
expr_stmt|;
name|end_stabs
argument_list|()
expr_stmt|;
block|}
comment|/* Null name means this just marks the end of text for this .o file. 	 Don't start a new symtab in this case.  */
if|if
condition|(
operator|*
name|name
operator|==
literal|'\000'
condition|)
break|break;
name|start_stabs
argument_list|()
expr_stmt|;
name|start_symtab
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|,
name|valu
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_SOL
case|:
comment|/* This type of symbol indicates the start of data for 	 a sub-source-file, one whose contents were copied or 	 included in the compilation of the main source file 	 (whose name was given in the N_SO symbol.)  */
comment|/* Relocate for dynamic loading */
name|valu
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
expr_stmt|;
name|start_subfile
argument_list|(
name|name
argument_list|,
name|current_subfile
operator|->
name|dirname
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_BINCL
case|:
name|push_subfile
argument_list|()
expr_stmt|;
name|add_new_header_file
argument_list|(
name|name
argument_list|,
name|valu
argument_list|)
expr_stmt|;
name|start_subfile
argument_list|(
name|name
argument_list|,
name|current_subfile
operator|->
name|dirname
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_EINCL
case|:
name|start_subfile
argument_list|(
name|pop_subfile
argument_list|()
argument_list|,
name|current_subfile
operator|->
name|dirname
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_EXCL
case|:
name|add_old_header_file
argument_list|(
name|name
argument_list|,
name|valu
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_SLINE
case|:
comment|/* This type of "symbol" really just records 	 one line-number -- core-address correspondence. 	 Enter it in the line list for this symbol table.  */
comment|/* Relocate for dynamic loading and for ELF acc fn-relative syms.  */
name|valu
operator|+=
name|function_start_offset
expr_stmt|;
ifdef|#
directive|ifdef
name|SUN_FIXED_LBRAC_BUG
name|last_pc_address
operator|=
name|valu
expr_stmt|;
comment|/* Save for SunOS bug circumcision */
endif|#
directive|endif
name|record_line
argument_list|(
name|current_subfile
argument_list|,
name|desc
argument_list|,
name|valu
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_BCOMM
case|:
name|common_block_start
argument_list|(
name|name
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_ECOMM
case|:
name|common_block_end
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
break|break;
comment|/* The following symbol types need to have the appropriate offset added        to their value; then we process symbol definitions in the name.  */
case|case
name|N_STSYM
case|:
comment|/* Static symbol in data seg */
case|case
name|N_LCSYM
case|:
comment|/* Static symbol in BSS seg */
case|case
name|N_ROSYM
case|:
comment|/* Static symbol in Read-only data seg */
comment|/* HORRID HACK DEPT.  However, it's Sun's furgin' fault. 	Solaris2's stabs-in-elf makes *most* symbols relative 	but leaves a few absolute (at least for Solaris 2.1 and version 	2.0.1 of the SunPRO compiler).  N_STSYM and friends sit on the fence. 	.stab "foo:S...",N_STSYM 	is absolute (ld relocates it) 	.stab "foo:V...",N_STSYM	is relative (section base subtracted). 	This leaves us no choice but to search for the 'S' or 'V'... 	(or pass the whole section_offsets stuff down ONE MORE function 	call level, which we really don't want to do).  */
block|{
name|char
modifier|*
name|p
decl_stmt|;
comment|/* .o files and NLMs have non-zero text seg offsets, but don't need 	   their static syms offset in this fashion.  XXX - This is really a 	   crock that should be fixed in the solib handling code so that I 	   don't have to work around it here. */
if|if
condition|(
operator|!
name|symfile_relocatable
condition|)
block|{
name|p
operator|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
literal|0
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'S'
condition|)
block|{
comment|/* The linker relocated it.  We don't want to add an 		   elfstab_offset_sections-type offset, but we *do* want 		   to add whatever solib.c passed to symbol_file_add as 		   addr (this is known to affect SunOS4, and I suspect ELF 		   too).  Since elfstab_offset_sections currently does not 		   muck with the text offset (there is no Ttext.text 		   symbol), we can get addr from the text offset.  If 		   elfstab_offset_sections ever starts dealing with the 		   text offset, and we still need to do this, we need to 		   invent a SECT_OFF_ADDR_KLUDGE or something.  */
name|valu
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
expr_stmt|;
goto|goto
name|define_a_symbol
goto|;
block|}
block|}
comment|/* Since it's not the kludge case, re-dispatch to the right handler. */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|N_STSYM
case|:
goto|goto
name|case_N_STSYM
goto|;
case|case
name|N_LCSYM
case|:
goto|goto
name|case_N_LCSYM
goto|;
case|case
name|N_ROSYM
case|:
goto|goto
name|case_N_ROSYM
goto|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
name|case_N_STSYM
label|:
comment|/* Static symbol in data seg */
case|case
name|N_DSLINE
case|:
comment|/* Source line number, data seg */
name|valu
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_DATA
argument_list|)
expr_stmt|;
goto|goto
name|define_a_symbol
goto|;
name|case_N_LCSYM
label|:
comment|/* Static symbol in BSS seg */
case|case
name|N_BSLINE
case|:
comment|/* Source line number, bss seg */
comment|/*   N_BROWS:	overlaps with N_BSLINE */
name|valu
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_BSS
argument_list|)
expr_stmt|;
goto|goto
name|define_a_symbol
goto|;
name|case_N_ROSYM
label|:
comment|/* Static symbol in Read-only data seg */
name|valu
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_RODATA
argument_list|)
expr_stmt|;
goto|goto
name|define_a_symbol
goto|;
case|case
name|N_ENTRY
case|:
comment|/* Alternate entry point */
comment|/* Relocate for dynamic loading */
name|valu
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
expr_stmt|;
goto|goto
name|define_a_symbol
goto|;
comment|/* The following symbol types we don't know how to process.  Handle        them in a "default" way, but complain to people who care.  */
default|default:
case|case
name|N_CATCH
case|:
comment|/* Exception handler catcher */
case|case
name|N_EHDECL
case|:
comment|/* Exception handler name */
case|case
name|N_PC
case|:
comment|/* Global symbol in Pascal */
case|case
name|N_M2C
case|:
comment|/* Modula-2 compilation unit */
comment|/*   N_MOD2:	overlaps with N_EHDECL */
case|case
name|N_SCOPE
case|:
comment|/* Modula-2 scope information */
case|case
name|N_ECOML
case|:
comment|/* End common (local name) */
case|case
name|N_NBTEXT
case|:
comment|/* Gould Non-Base-Register symbols??? */
case|case
name|N_NBDATA
case|:
case|case
name|N_NBBSS
case|:
case|case
name|N_NBSTS
case|:
case|case
name|N_NBLCS
case|:
name|complain
argument_list|(
operator|&
name|unknown_symtype_complaint
argument_list|,
name|local_hex_string
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
comment|/* The following symbol types don't need the address field relocated,        since it is either unused, or is absolute.  */
name|define_a_symbol
label|:
case|case
name|N_GSYM
case|:
comment|/* Global variable */
case|case
name|N_NSYMS
case|:
comment|/* Number of symbols (ultrix) */
case|case
name|N_NOMAP
case|:
comment|/* No map?  (ultrix) */
case|case
name|N_RSYM
case|:
comment|/* Register variable */
case|case
name|N_DEFD
case|:
comment|/* Modula-2 GNU module dependency */
case|case
name|N_SSYM
case|:
comment|/* Struct or union element */
case|case
name|N_LSYM
case|:
comment|/* Local symbol in stack */
case|case
name|N_PSYM
case|:
comment|/* Parameter variable */
case|case
name|N_LENG
case|:
comment|/* Length of preceding symbol type */
if|if
condition|(
name|name
condition|)
block|{
name|int
name|deftype
decl_stmt|;
name|char
modifier|*
name|colon_pos
init|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|':'
argument_list|)
decl_stmt|;
if|if
condition|(
name|colon_pos
operator|==
name|NULL
condition|)
name|deftype
operator|=
literal|'\0'
expr_stmt|;
else|else
name|deftype
operator|=
name|colon_pos
index|[
literal|1
index|]
expr_stmt|;
switch|switch
condition|(
name|deftype
condition|)
block|{
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
name|function_stab_type
operator|=
name|type
expr_stmt|;
ifdef|#
directive|ifdef
name|SOFUN_ADDRESS_MAYBE_MISSING
comment|/* Deal with the SunPRO 3.0 compiler which omits the address                  from N_FUN symbols.  */
if|if
condition|(
name|type
operator|==
name|N_FUN
operator|&&
name|valu
operator|==
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
condition|)
block|{
name|struct
name|minimal_symbol
modifier|*
name|msym
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|n
decl_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|p
operator|=
name|name
expr_stmt|;
name|n
operator|=
name|p
operator|-
name|name
expr_stmt|;
name|p
operator|=
name|alloca
argument_list|(
name|n
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|p
argument_list|,
name|name
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|p
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
name|msym
operator|=
name|lookup_minimal_symbol
argument_list|(
name|p
argument_list|,
name|last_source_file
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|msym
condition|)
name|valu
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msym
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SUN_FIXED_LBRAC_BUG
comment|/* The Sun acc compiler, under SunOS4, puts out 		 functions with N_GSYM or N_STSYM.  The problem is 		 that the address of the symbol is no good (for N_GSYM 		 it doesn't even attept an address; for N_STSYM it 		 puts out an address but then it gets relocated 		 relative to the data segment, not the text segment). 		 Currently we can't fix this up later as we do for 		 some types of symbol in scan_file_globals. 		 Fortunately we do have a way of finding the address - 		 we know that the value in last_pc_address is either 		 the one we want (if we're dealing with the first 		 function in an object file), or somewhere in the 		 previous function. This means that we can use the 		 minimal symbol table to get the address.  */
comment|/* Starting with release 3.0, the Sun acc compiler, 		 under SunOS4, puts out functions with N_FUN and a value 		 of zero. This gets relocated to the start of the text 		 segment of the module, which is no good either. 		 Under SunOS4 we can deal with this as N_SLINE and N_SO 		 entries contain valid absolute addresses. 		 Release 3.0 acc also puts out N_OPT entries, which makes 		 it possible to discern acc from cc or gcc.  */
if|if
condition|(
name|type
operator|==
name|N_GSYM
operator|||
name|type
operator|==
name|N_STSYM
operator|||
operator|(
name|type
operator|==
name|N_FUN
operator|&&
name|n_opt_found
operator|&&
operator|!
name|block_address_function_relative
operator|)
condition|)
block|{
name|struct
name|minimal_symbol
modifier|*
name|m
decl_stmt|;
name|int
name|l
init|=
name|colon_pos
operator|-
name|name
decl_stmt|;
name|m
operator|=
name|lookup_minimal_symbol_by_pc
argument_list|(
name|last_pc_address
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|&&
name|STREQN
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|m
argument_list|)
argument_list|,
name|name
argument_list|,
name|l
argument_list|)
operator|&&
name|SYMBOL_NAME
argument_list|(
name|m
argument_list|)
index|[
name|l
index|]
operator|==
literal|'\0'
condition|)
comment|/* last_pc_address was in this function */
name|valu
operator|=
name|SYMBOL_VALUE
argument_list|(
name|m
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|m
operator|&&
name|SYMBOL_NAME
argument_list|(
name|m
operator|+
literal|1
argument_list|)
operator|&&
name|STREQN
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|m
operator|+
literal|1
argument_list|)
argument_list|,
name|name
argument_list|,
name|l
argument_list|)
operator|&&
name|SYMBOL_NAME
argument_list|(
name|m
operator|+
literal|1
argument_list|)
index|[
name|l
index|]
operator|==
literal|'\0'
condition|)
comment|/* last_pc_address was in last function */
name|valu
operator|=
name|SYMBOL_VALUE
argument_list|(
name|m
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
comment|/* Not found - use last_pc_address (for finish_block) */
name|valu
operator|=
name|last_pc_address
expr_stmt|;
block|}
name|last_pc_address
operator|=
name|valu
expr_stmt|;
comment|/* Save for SunOS bug circumcision */
endif|#
directive|endif
if|if
condition|(
name|block_address_function_relative
condition|)
comment|/* For Solaris 2.0 compilers, the block addresses and 		   N_SLINE's are relative to the start of the 		   function.  On normal systems, and when using gcc on 		   Solaris 2.0, these addresses are just absolute, or 		   relative to the N_SO, depending on 		   BLOCK_ADDRESS_ABSOLUTE.  */
name|function_start_offset
operator|=
name|valu
expr_stmt|;
name|within_function
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|context_stack_depth
operator|>
literal|0
condition|)
block|{
name|new
operator|=
name|pop_context
argument_list|()
expr_stmt|;
comment|/* Make a block for the local symbols within.  */
name|finish_block
argument_list|(
name|new
operator|->
name|name
argument_list|,
operator|&
name|local_symbols
argument_list|,
name|new
operator|->
name|old_blocks
argument_list|,
name|new
operator|->
name|start_addr
argument_list|,
name|valu
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
comment|/* Stack must be empty now.  */
if|if
condition|(
name|context_stack_depth
operator|!=
literal|0
condition|)
name|complain
argument_list|(
operator|&
name|lbrac_unmatched_complaint
argument_list|,
name|symnum
argument_list|)
expr_stmt|;
name|new
operator|=
name|push_context
argument_list|(
literal|0
argument_list|,
name|valu
argument_list|)
expr_stmt|;
name|new
operator|->
name|name
operator|=
name|define_symbol
argument_list|(
name|valu
argument_list|,
name|name
argument_list|,
name|desc
argument_list|,
name|type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
default|default:
name|define_symbol
argument_list|(
name|valu
argument_list|,
name|name
argument_list|,
name|desc
argument_list|,
name|type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
break|break;
comment|/* We use N_OPT to carry the gcc2_compiled flag.  Sun uses it        for a bunch of other flags, too.  Someday we may parse their        flags; for now we ignore theirs and hope they'll ignore ours.  */
case|case
name|N_OPT
case|:
comment|/* Solaris 2:  Compiler options */
if|if
condition|(
name|name
condition|)
block|{
if|if
condition|(
name|STREQ
argument_list|(
name|name
argument_list|,
name|GCC2_COMPILED_FLAG_SYMBOL
argument_list|)
condition|)
block|{
name|processing_gcc_compilation
operator|=
literal|2
expr_stmt|;
if|#
directive|if
literal|1
comment|/* Works, but is experimental.  -fnf */
if|if
condition|(
name|AUTO_DEMANGLING
condition|)
block|{
name|set_demangling_style
argument_list|(
name|GNU_DEMANGLING_STYLE_STRING
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
else|else
name|n_opt_found
operator|=
literal|1
expr_stmt|;
block|}
break|break;
comment|/* The following symbol types can be ignored.  */
case|case
name|N_OBJ
case|:
comment|/* Solaris 2:  Object file dir and name */
comment|/*   N_UNDF: 		   Solaris 2:  file separator mark */
comment|/*   N_UNDF: -- we will never encounter it, since we only process one 		    file's symbols at once.  */
case|case
name|N_ENDM
case|:
comment|/* Solaris 2:  End of module */
case|case
name|N_MAIN
case|:
comment|/* Name of main routine.  */
break|break;
block|}
name|previous_stab_code
operator|=
name|type
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* FIXME: The only difference between this and elfstab_build_psymtabs    is the call to install_minimal_symbols for elf, and the support for    split sections.  If the differences are really that small, the code    should be shared.  */
end_comment

begin_comment
comment|/* Scan and build partial symbols for an coff symbol file.    The coff file has already been processed to get its minimal symbols.     This routine is the equivalent of dbx_symfile_init and dbx_symfile_read    rolled into one.     OBJFILE is the object file we are reading symbols from.    ADDR is the address relative to which the symbols are (e.g.    the base address of the text segment).    MAINLINE is true if we are reading the main symbol    table (as opposed to a shared lib or dynamically loaded file).    TEXTADDR is the address of the text section.    TEXTSIZE is the size of the text section.    STABSECTS is the list of .stab sections in OBJFILE.    STABSTROFFSET and STABSTRSIZE define the location in OBJFILE where the    .stabstr section exists.     This routine is mostly copied from dbx_symfile_init and dbx_symfile_read,    adjusted for coff details. */
end_comment

begin_function
name|void
name|coffstab_build_psymtabs
parameter_list|(
name|objfile
parameter_list|,
name|section_offsets
parameter_list|,
name|mainline
parameter_list|,
name|textaddr
parameter_list|,
name|textsize
parameter_list|,
name|stabsects
parameter_list|,
name|stabstroffset
parameter_list|,
name|stabstrsize
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|section_offsets
modifier|*
name|section_offsets
decl_stmt|;
name|int
name|mainline
decl_stmt|;
name|CORE_ADDR
name|textaddr
decl_stmt|;
name|unsigned
name|int
name|textsize
decl_stmt|;
name|struct
name|stab_section_list
modifier|*
name|stabsects
decl_stmt|;
name|file_ptr
name|stabstroffset
decl_stmt|;
name|unsigned
name|int
name|stabstrsize
decl_stmt|;
block|{
name|int
name|val
decl_stmt|;
name|bfd
modifier|*
name|sym_bfd
init|=
name|objfile
operator|->
name|obfd
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|bfd_get_filename
argument_list|(
name|sym_bfd
argument_list|)
decl_stmt|;
name|struct
name|dbx_symfile_info
modifier|*
name|info
decl_stmt|;
name|unsigned
name|int
name|stabsize
decl_stmt|;
comment|/* There is already a dbx_symfile_info allocated by our caller.      It might even contain some info from the coff symtab to help us.  */
name|info
operator|=
operator|(
expr|struct
name|dbx_symfile_info
operator|*
operator|)
name|objfile
operator|->
name|sym_stab_info
expr_stmt|;
name|DBX_TEXT_ADDR
argument_list|(
name|objfile
argument_list|)
operator|=
name|textaddr
expr_stmt|;
name|DBX_TEXT_SIZE
argument_list|(
name|objfile
argument_list|)
operator|=
name|textsize
expr_stmt|;
define|#
directive|define
name|COFF_STABS_SYMBOL_SIZE
value|12
comment|/* XXX FIXME XXX */
name|DBX_SYMBOL_SIZE
argument_list|(
name|objfile
argument_list|)
operator|=
name|COFF_STABS_SYMBOL_SIZE
expr_stmt|;
name|DBX_STRINGTAB_SIZE
argument_list|(
name|objfile
argument_list|)
operator|=
name|stabstrsize
expr_stmt|;
if|if
condition|(
name|stabstrsize
operator|>
name|bfd_get_size
argument_list|(
name|sym_bfd
argument_list|)
condition|)
name|error
argument_list|(
literal|"ridiculous string table size: %d bytes"
argument_list|,
name|stabstrsize
argument_list|)
expr_stmt|;
name|DBX_STRINGTAB
argument_list|(
name|objfile
argument_list|)
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|psymbol_obstack
argument_list|,
name|stabstrsize
operator|+
literal|1
argument_list|)
expr_stmt|;
name|OBJSTAT
argument_list|(
name|objfile
argument_list|,
name|sz_strtab
operator|+=
name|stabstrsize
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Now read in the string table in one big gulp.  */
name|val
operator|=
name|bfd_seek
argument_list|(
name|sym_bfd
argument_list|,
name|stabstroffset
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|val
operator|=
name|bfd_read
argument_list|(
name|DBX_STRINGTAB
argument_list|(
name|objfile
argument_list|)
argument_list|,
name|stabstrsize
argument_list|,
literal|1
argument_list|,
name|sym_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|stabstrsize
condition|)
name|perror_with_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|stabsread_new_init
argument_list|()
expr_stmt|;
name|buildsym_new_init
argument_list|()
expr_stmt|;
name|free_header_files
argument_list|()
expr_stmt|;
name|init_header_files
argument_list|()
expr_stmt|;
name|processing_acc_compilation
operator|=
literal|1
expr_stmt|;
comment|/* In a coff file, we've already installed the minimal symbols that came      from the coff (non-stab) symbol table, so always act like an      incremental load here. */
if|if
condition|(
name|stabsects
operator|->
name|next
operator|==
name|NULL
condition|)
block|{
name|stabsize
operator|=
name|bfd_section_size
argument_list|(
name|sym_bfd
argument_list|,
name|stabsects
operator|->
name|section
argument_list|)
expr_stmt|;
name|DBX_SYMCOUNT
argument_list|(
name|objfile
argument_list|)
operator|=
name|stabsize
operator|/
name|DBX_SYMBOL_SIZE
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
name|DBX_SYMTAB_OFFSET
argument_list|(
name|objfile
argument_list|)
operator|=
name|stabsects
operator|->
name|section
operator|->
name|filepos
expr_stmt|;
block|}
else|else
block|{
name|struct
name|stab_section_list
modifier|*
name|stabsect
decl_stmt|;
name|DBX_SYMCOUNT
argument_list|(
name|objfile
argument_list|)
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|stabsect
operator|=
name|stabsects
init|;
name|stabsect
operator|!=
name|NULL
condition|;
name|stabsect
operator|=
name|stabsect
operator|->
name|next
control|)
block|{
name|stabsize
operator|=
name|bfd_section_size
argument_list|(
name|sym_bfd
argument_list|,
name|stabsect
operator|->
name|section
argument_list|)
expr_stmt|;
name|DBX_SYMCOUNT
argument_list|(
name|objfile
argument_list|)
operator|+=
name|stabsize
operator|/
name|DBX_SYMBOL_SIZE
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
block|}
name|DBX_SYMTAB_OFFSET
argument_list|(
name|objfile
argument_list|)
operator|=
name|stabsects
operator|->
name|section
operator|->
name|filepos
expr_stmt|;
name|symbuf_sections
operator|=
name|stabsects
operator|->
name|next
expr_stmt|;
name|symbuf_left
operator|=
name|bfd_section_size
argument_list|(
name|sym_bfd
argument_list|,
name|stabsects
operator|->
name|section
argument_list|)
expr_stmt|;
name|symbuf_read
operator|=
literal|0
expr_stmt|;
block|}
name|dbx_symfile_read
argument_list|(
name|objfile
argument_list|,
name|section_offsets
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Scan and build partial symbols for an ELF symbol file.    This ELF file has already been processed to get its minimal symbols,    and any DWARF symbols that were in it.     This routine is the equivalent of dbx_symfile_init and dbx_symfile_read    rolled into one.     OBJFILE is the object file we are reading symbols from.    ADDR is the address relative to which the symbols are (e.g.    the base address of the text segment).    MAINLINE is true if we are reading the main symbol    table (as opposed to a shared lib or dynamically loaded file).    STABOFFSET and STABSIZE define the location in OBJFILE where the .stab    section exists.    STABSTROFFSET and STABSTRSIZE define the location in OBJFILE where the    .stabstr section exists.     This routine is mostly copied from dbx_symfile_init and dbx_symfile_read,    adjusted for elf details. */
end_comment

begin_function
name|void
name|elfstab_build_psymtabs
parameter_list|(
name|objfile
parameter_list|,
name|section_offsets
parameter_list|,
name|mainline
parameter_list|,
name|staboffset
parameter_list|,
name|stabsize
parameter_list|,
name|stabstroffset
parameter_list|,
name|stabstrsize
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|section_offsets
modifier|*
name|section_offsets
decl_stmt|;
name|int
name|mainline
decl_stmt|;
name|file_ptr
name|staboffset
decl_stmt|;
name|unsigned
name|int
name|stabsize
decl_stmt|;
name|file_ptr
name|stabstroffset
decl_stmt|;
name|unsigned
name|int
name|stabstrsize
decl_stmt|;
block|{
name|int
name|val
decl_stmt|;
name|bfd
modifier|*
name|sym_bfd
init|=
name|objfile
operator|->
name|obfd
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|bfd_get_filename
argument_list|(
name|sym_bfd
argument_list|)
decl_stmt|;
name|struct
name|dbx_symfile_info
modifier|*
name|info
decl_stmt|;
name|asection
modifier|*
name|text_sect
decl_stmt|;
comment|/* There is already a dbx_symfile_info allocated by our caller.      It might even contain some info from the ELF symtab to help us.  */
name|info
operator|=
operator|(
expr|struct
name|dbx_symfile_info
operator|*
operator|)
name|objfile
operator|->
name|sym_stab_info
expr_stmt|;
name|text_sect
operator|=
name|bfd_get_section_by_name
argument_list|(
name|sym_bfd
argument_list|,
literal|".text"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|text_sect
condition|)
name|error
argument_list|(
literal|"Can't find .text section in symbol file"
argument_list|)
expr_stmt|;
name|DBX_TEXT_ADDR
argument_list|(
name|objfile
argument_list|)
operator|=
name|bfd_section_vma
argument_list|(
name|sym_bfd
argument_list|,
name|text_sect
argument_list|)
expr_stmt|;
name|DBX_TEXT_SIZE
argument_list|(
name|objfile
argument_list|)
operator|=
name|bfd_section_size
argument_list|(
name|sym_bfd
argument_list|,
name|text_sect
argument_list|)
expr_stmt|;
define|#
directive|define
name|ELF_STABS_SYMBOL_SIZE
value|12
comment|/* XXX FIXME XXX */
name|DBX_SYMBOL_SIZE
argument_list|(
name|objfile
argument_list|)
operator|=
name|ELF_STABS_SYMBOL_SIZE
expr_stmt|;
name|DBX_SYMCOUNT
argument_list|(
name|objfile
argument_list|)
operator|=
name|stabsize
operator|/
name|DBX_SYMBOL_SIZE
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
name|DBX_STRINGTAB_SIZE
argument_list|(
name|objfile
argument_list|)
operator|=
name|stabstrsize
expr_stmt|;
name|DBX_SYMTAB_OFFSET
argument_list|(
name|objfile
argument_list|)
operator|=
name|staboffset
expr_stmt|;
if|if
condition|(
name|stabstrsize
operator|>
name|bfd_get_size
argument_list|(
name|sym_bfd
argument_list|)
condition|)
name|error
argument_list|(
literal|"ridiculous string table size: %d bytes"
argument_list|,
name|stabstrsize
argument_list|)
expr_stmt|;
name|DBX_STRINGTAB
argument_list|(
name|objfile
argument_list|)
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|psymbol_obstack
argument_list|,
name|stabstrsize
operator|+
literal|1
argument_list|)
expr_stmt|;
name|OBJSTAT
argument_list|(
name|objfile
argument_list|,
name|sz_strtab
operator|+=
name|stabstrsize
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Now read in the string table in one big gulp.  */
name|val
operator|=
name|bfd_seek
argument_list|(
name|sym_bfd
argument_list|,
name|stabstroffset
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|val
operator|=
name|bfd_read
argument_list|(
name|DBX_STRINGTAB
argument_list|(
name|objfile
argument_list|)
argument_list|,
name|stabstrsize
argument_list|,
literal|1
argument_list|,
name|sym_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|stabstrsize
condition|)
name|perror_with_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|stabsread_new_init
argument_list|()
expr_stmt|;
name|buildsym_new_init
argument_list|()
expr_stmt|;
name|free_header_files
argument_list|()
expr_stmt|;
name|init_header_files
argument_list|()
expr_stmt|;
name|install_minimal_symbols
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
name|processing_acc_compilation
operator|=
literal|1
expr_stmt|;
comment|/* In an elf file, we've already installed the minimal symbols that came      from the elf (non-stab) symbol table, so always act like an      incremental load here. */
name|dbx_symfile_read
argument_list|(
name|objfile
argument_list|,
name|section_offsets
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Scan and build partial symbols for a file with special sections for stabs    and stabstrings.  The file has already been processed to get its minimal    symbols, and any other symbols that might be necessary to resolve GSYMs.     This routine is the equivalent of dbx_symfile_init and dbx_symfile_read    rolled into one.     OBJFILE is the object file we are reading symbols from.    ADDR is the address relative to which the symbols are (e.g. the base address 	of the text segment).    MAINLINE is true if we are reading the main symbol table (as opposed to a 	    shared lib or dynamically loaded file).    STAB_NAME is the name of the section that contains the stabs.    STABSTR_NAME is the name of the section that contains the stab strings.     This routine is mostly copied from dbx_symfile_init and dbx_symfile_read. */
end_comment

begin_function
name|void
name|stabsect_build_psymtabs
parameter_list|(
name|objfile
parameter_list|,
name|section_offsets
parameter_list|,
name|mainline
parameter_list|,
name|stab_name
parameter_list|,
name|stabstr_name
parameter_list|,
name|text_name
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|section_offsets
modifier|*
name|section_offsets
decl_stmt|;
name|int
name|mainline
decl_stmt|;
name|char
modifier|*
name|stab_name
decl_stmt|;
name|char
modifier|*
name|stabstr_name
decl_stmt|;
name|char
modifier|*
name|text_name
decl_stmt|;
block|{
name|int
name|val
decl_stmt|;
name|bfd
modifier|*
name|sym_bfd
init|=
name|objfile
operator|->
name|obfd
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|bfd_get_filename
argument_list|(
name|sym_bfd
argument_list|)
decl_stmt|;
name|asection
modifier|*
name|stabsect
decl_stmt|;
name|asection
modifier|*
name|stabstrsect
decl_stmt|;
name|asection
modifier|*
name|text_sect
decl_stmt|;
name|stabsect
operator|=
name|bfd_get_section_by_name
argument_list|(
name|sym_bfd
argument_list|,
name|stab_name
argument_list|)
expr_stmt|;
name|stabstrsect
operator|=
name|bfd_get_section_by_name
argument_list|(
name|sym_bfd
argument_list|,
name|stabstr_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stabsect
condition|)
return|return;
if|if
condition|(
operator|!
name|stabstrsect
condition|)
name|error
argument_list|(
literal|"stabsect_build_psymtabs:  Found stabs (%s), but not string section (%s)"
argument_list|,
name|stab_name
argument_list|,
name|stabstr_name
argument_list|)
expr_stmt|;
name|objfile
operator|->
name|sym_stab_info
operator|=
operator|(
name|PTR
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|dbx_symfile_info
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|DBX_SYMFILE_INFO
argument_list|(
name|objfile
argument_list|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dbx_symfile_info
argument_list|)
argument_list|)
expr_stmt|;
name|text_sect
operator|=
name|bfd_get_section_by_name
argument_list|(
name|sym_bfd
argument_list|,
name|text_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|text_sect
condition|)
name|error
argument_list|(
literal|"Can't find %s section in symbol file"
argument_list|,
name|text_name
argument_list|)
expr_stmt|;
name|DBX_TEXT_ADDR
argument_list|(
name|objfile
argument_list|)
operator|=
name|bfd_section_vma
argument_list|(
name|sym_bfd
argument_list|,
name|text_sect
argument_list|)
expr_stmt|;
name|DBX_TEXT_SIZE
argument_list|(
name|objfile
argument_list|)
operator|=
name|bfd_section_size
argument_list|(
name|sym_bfd
argument_list|,
name|text_sect
argument_list|)
expr_stmt|;
name|DBX_SYMBOL_SIZE
argument_list|(
name|objfile
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|external_nlist
argument_list|)
expr_stmt|;
name|DBX_SYMCOUNT
argument_list|(
name|objfile
argument_list|)
operator|=
name|bfd_section_size
argument_list|(
name|sym_bfd
argument_list|,
name|stabsect
argument_list|)
operator|/
name|DBX_SYMBOL_SIZE
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
name|DBX_STRINGTAB_SIZE
argument_list|(
name|objfile
argument_list|)
operator|=
name|bfd_section_size
argument_list|(
name|sym_bfd
argument_list|,
name|stabstrsect
argument_list|)
expr_stmt|;
name|DBX_SYMTAB_OFFSET
argument_list|(
name|objfile
argument_list|)
operator|=
name|stabsect
operator|->
name|filepos
expr_stmt|;
comment|/* XXX - FIXME: POKING INSIDE BFD DATA STRUCTURES */
if|if
condition|(
name|DBX_STRINGTAB_SIZE
argument_list|(
name|objfile
argument_list|)
operator|>
name|bfd_get_size
argument_list|(
name|sym_bfd
argument_list|)
condition|)
name|error
argument_list|(
literal|"ridiculous string table size: %d bytes"
argument_list|,
name|DBX_STRINGTAB_SIZE
argument_list|(
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
name|DBX_STRINGTAB
argument_list|(
name|objfile
argument_list|)
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|psymbol_obstack
argument_list|,
name|DBX_STRINGTAB_SIZE
argument_list|(
name|objfile
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|OBJSTAT
argument_list|(
name|objfile
argument_list|,
name|sz_strtab
operator|+=
name|DBX_STRINGTAB_SIZE
argument_list|(
name|objfile
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Now read in the string table in one big gulp.  */
name|val
operator|=
name|bfd_get_section_contents
argument_list|(
name|sym_bfd
argument_list|,
comment|/* bfd */
name|stabstrsect
argument_list|,
comment|/* bfd section */
name|DBX_STRINGTAB
argument_list|(
name|objfile
argument_list|)
argument_list|,
comment|/* input buffer */
literal|0
argument_list|,
comment|/* offset into section */
name|DBX_STRINGTAB_SIZE
argument_list|(
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
comment|/* amount to read */
if|if
condition|(
operator|!
name|val
condition|)
name|perror_with_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|stabsread_new_init
argument_list|()
expr_stmt|;
name|buildsym_new_init
argument_list|()
expr_stmt|;
name|free_header_files
argument_list|()
expr_stmt|;
name|init_header_files
argument_list|()
expr_stmt|;
name|install_minimal_symbols
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
comment|/* Now, do an incremental load */
name|processing_acc_compilation
operator|=
literal|1
expr_stmt|;
name|dbx_symfile_read
argument_list|(
name|objfile
argument_list|,
name|section_offsets
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Parse the user's idea of an offset for dynamic linking, into our idea    of how to represent it for fast symbol reading.  */
end_comment

begin_function
specifier|static
name|struct
name|section_offsets
modifier|*
name|dbx_symfile_offsets
parameter_list|(
name|objfile
parameter_list|,
name|addr
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
block|{
name|struct
name|section_offsets
modifier|*
name|section_offsets
decl_stmt|;
name|int
name|i
decl_stmt|;
name|objfile
operator|->
name|num_sections
operator|=
name|SECT_OFF_MAX
expr_stmt|;
name|section_offsets
operator|=
operator|(
expr|struct
name|section_offsets
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|psymbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|section_offsets
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|section_offsets
operator|->
name|offsets
argument_list|)
operator|*
operator|(
name|SECT_OFF_MAX
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SECT_OFF_MAX
condition|;
name|i
operator|++
control|)
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|i
argument_list|)
operator|=
name|addr
expr_stmt|;
return|return
name|section_offsets
return|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|struct
name|sym_fns
name|aout_sym_fns
init|=
block|{
name|bfd_target_aout_flavour
block|,
name|dbx_new_init
block|,
comment|/* sym_new_init: init anything gbl to entire symtab */
name|dbx_symfile_init
block|,
comment|/* sym_init: read initial info, setup for sym_read() */
name|dbx_symfile_read
block|,
comment|/* sym_read: read a symbol file into symtab */
name|dbx_symfile_finish
block|,
comment|/* sym_finish: finished with file, cleanup */
name|dbx_symfile_offsets
block|,
comment|/* sym_offsets: parse user's offsets to internal form */
name|NULL
comment|/* next: pointer to next struct sym_fns */
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|_initialize_dbxread
parameter_list|()
block|{
name|add_symtab_fns
argument_list|(
operator|&
name|aout_sym_fns
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

