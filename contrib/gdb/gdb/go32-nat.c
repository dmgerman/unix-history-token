begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Native debugging support for Intel x86 running DJGPP.    Copyright 1997, 1999, 2000, 2001 Free Software Foundation, Inc.    Written by Robert Hoehne.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"gdb_wait.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"floatformat.h"
end_include

begin_include
include|#
directive|include
file|"buildsym.h"
end_include

begin_include
include|#
directive|include
file|"i387-tdep.h"
end_include

begin_include
include|#
directive|include
file|"i386-tdep.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/* might be required for __DJGPP_MINOR__ */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/utsname.h>
end_include

begin_include
include|#
directive|include
file|<io.h>
end_include

begin_include
include|#
directive|include
file|<dos.h>
end_include

begin_include
include|#
directive|include
file|<dpmi.h>
end_include

begin_include
include|#
directive|include
file|<go32.h>
end_include

begin_include
include|#
directive|include
file|<sys/farptr.h>
end_include

begin_include
include|#
directive|include
file|<debug/v2load.h>
end_include

begin_include
include|#
directive|include
file|<debug/dbgcom.h>
end_include

begin_if
if|#
directive|if
name|__DJGPP_MINOR__
operator|>
literal|2
end_if

begin_include
include|#
directive|include
file|<debug/redir.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|__DJGPP_MINOR__
operator|<
literal|3
end_if

begin_comment
comment|/* This code will be provided from DJGPP 2.03 on. Until then I code it    here */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|unsigned
name|short
name|sig0
decl_stmt|;
name|unsigned
name|short
name|sig1
decl_stmt|;
name|unsigned
name|short
name|sig2
decl_stmt|;
name|unsigned
name|short
name|sig3
decl_stmt|;
name|unsigned
name|short
name|exponent
range|:
literal|15
decl_stmt|;
name|unsigned
name|short
name|sign
range|:
literal|1
decl_stmt|;
block|}
name|NPXREG
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|unsigned
name|int
name|control
decl_stmt|;
name|unsigned
name|int
name|status
decl_stmt|;
name|unsigned
name|int
name|tag
decl_stmt|;
name|unsigned
name|int
name|eip
decl_stmt|;
name|unsigned
name|int
name|cs
decl_stmt|;
name|unsigned
name|int
name|dataptr
decl_stmt|;
name|unsigned
name|int
name|datasel
decl_stmt|;
name|NPXREG
name|reg
index|[
literal|8
index|]
decl_stmt|;
block|}
name|NPX
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|NPX
name|npx
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|save_npx
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Save the FPU of the debugged program */
end_comment

begin_function_decl
specifier|static
name|void
name|load_npx
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Restore the FPU of the debugged program */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* Store the contents of the NPX in the global variable `npx'.  */
end_comment

begin_comment
comment|/* *INDENT-OFF* */
end_comment

begin_function
specifier|static
name|void
name|save_npx
parameter_list|(
name|void
parameter_list|)
block|{
asm|asm ("inb    $0xa0, %%al  \n\        testb $0x20, %%al    \n\        jz 1f 	    	    \n\        xorb %%al, %%al	    \n\        outb %%al, $0xf0     \n\        movb $0x20, %%al	    \n\        outb %%al, $0xa0     \n\        outb %%al, $0x20     \n\ 1:     	       	   	    \n\        fnsave %0	    \n\        fwait " :     "=m" (npx) :
comment|/* No input */
asm|:     "%eax");
block|}
end_function

begin_comment
comment|/* *INDENT-ON* */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* Reload the contents of the NPX from the global variable `npx'.  */
end_comment

begin_function
specifier|static
name|void
name|load_npx
parameter_list|(
name|void
parameter_list|)
block|{
asm|asm ("frstor %0":"=m" (npx));
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* Stubs for the missing redirection functions.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|command
decl_stmt|;
name|int
name|redirected
decl_stmt|;
block|}
name|cmdline_t
typedef|;
end_typedef

begin_function
name|void
name|redir_cmdline_delete
parameter_list|(
name|cmdline_t
modifier|*
name|ptr
parameter_list|)
block|{
name|ptr
operator|->
name|redirected
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|int
name|redir_cmdline_parse
parameter_list|(
specifier|const
name|char
modifier|*
name|args
parameter_list|,
name|cmdline_t
modifier|*
name|ptr
parameter_list|)
block|{
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|int
name|redir_to_child
parameter_list|(
name|cmdline_t
modifier|*
name|ptr
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|redir_to_debugger
parameter_list|(
name|cmdline_t
modifier|*
name|ptr
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|redir_debug_init
parameter_list|(
name|cmdline_t
modifier|*
name|ptr
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __DJGPP_MINOR< 3 */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|wp_insert
block|,
name|wp_remove
block|,
name|wp_count
block|}
name|wp_op
typedef|;
end_typedef

begin_comment
comment|/* This holds the current reference counts for each debug register.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|dr_ref_count
index|[
literal|4
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SOME_PID
value|42
end_define

begin_decl_stmt
specifier|static
name|int
name|prog_has_started
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|go32_open
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|from_tty
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|go32_close
parameter_list|(
name|int
name|quitting
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|go32_attach
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|go32_detach
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|go32_resume
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
name|int
name|step
parameter_list|,
name|enum
name|target_signal
name|siggnal
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ptid_t
name|go32_wait
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
name|struct
name|target_waitstatus
modifier|*
name|status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|go32_fetch_registers
parameter_list|(
name|int
name|regno
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|store_register
parameter_list|(
name|int
name|regno
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|go32_store_registers
parameter_list|(
name|int
name|regno
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|go32_prepare_to_store
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|go32_xfer_memory
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|write
parameter_list|,
name|struct
name|mem_attrib
modifier|*
name|attrib
parameter_list|,
name|struct
name|target_ops
modifier|*
name|target
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|go32_files_info
parameter_list|(
name|struct
name|target_ops
modifier|*
name|target
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|go32_stop
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|go32_kill_inferior
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|go32_create_inferior
parameter_list|(
name|char
modifier|*
name|exec_file
parameter_list|,
name|char
modifier|*
name|args
parameter_list|,
name|char
modifier|*
modifier|*
name|env
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|go32_mourn_inferior
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|go32_can_run
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|target_ops
name|go32_ops
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|go32_terminal_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|go32_terminal_inferior
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|go32_terminal_ours
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|r_ofs
parameter_list|(
name|x
parameter_list|)
value|(offsetof(TSS,x))
end_define

begin_struct
specifier|static
struct|struct
block|{
name|size_t
name|tss_ofs
decl_stmt|;
name|size_t
name|size
decl_stmt|;
block|}
name|regno_mapping
index|[]
init|=
block|{
block|{
name|r_ofs
argument_list|(
name|tss_eax
argument_list|)
block|,
literal|4
block|}
block|,
comment|/* normal registers, from a_tss */
block|{
name|r_ofs
argument_list|(
name|tss_ecx
argument_list|)
block|,
literal|4
block|}
block|,
block|{
name|r_ofs
argument_list|(
name|tss_edx
argument_list|)
block|,
literal|4
block|}
block|,
block|{
name|r_ofs
argument_list|(
name|tss_ebx
argument_list|)
block|,
literal|4
block|}
block|,
block|{
name|r_ofs
argument_list|(
name|tss_esp
argument_list|)
block|,
literal|4
block|}
block|,
block|{
name|r_ofs
argument_list|(
name|tss_ebp
argument_list|)
block|,
literal|4
block|}
block|,
block|{
name|r_ofs
argument_list|(
name|tss_esi
argument_list|)
block|,
literal|4
block|}
block|,
block|{
name|r_ofs
argument_list|(
name|tss_edi
argument_list|)
block|,
literal|4
block|}
block|,
block|{
name|r_ofs
argument_list|(
name|tss_eip
argument_list|)
block|,
literal|4
block|}
block|,
block|{
name|r_ofs
argument_list|(
name|tss_eflags
argument_list|)
block|,
literal|4
block|}
block|,
block|{
name|r_ofs
argument_list|(
name|tss_cs
argument_list|)
block|,
literal|2
block|}
block|,
block|{
name|r_ofs
argument_list|(
name|tss_ss
argument_list|)
block|,
literal|2
block|}
block|,
block|{
name|r_ofs
argument_list|(
name|tss_ds
argument_list|)
block|,
literal|2
block|}
block|,
block|{
name|r_ofs
argument_list|(
name|tss_es
argument_list|)
block|,
literal|2
block|}
block|,
block|{
name|r_ofs
argument_list|(
name|tss_fs
argument_list|)
block|,
literal|2
block|}
block|,
block|{
name|r_ofs
argument_list|(
name|tss_gs
argument_list|)
block|,
literal|2
block|}
block|,
block|{
literal|0
block|,
literal|10
block|}
block|,
comment|/* 8 FP registers, from npx.reg[] */
block|{
literal|1
block|,
literal|10
block|}
block|,
block|{
literal|2
block|,
literal|10
block|}
block|,
block|{
literal|3
block|,
literal|10
block|}
block|,
block|{
literal|4
block|,
literal|10
block|}
block|,
block|{
literal|5
block|,
literal|10
block|}
block|,
block|{
literal|6
block|,
literal|10
block|}
block|,
block|{
literal|7
block|,
literal|10
block|}
block|,
comment|/* The order of the next 7 registers must be consistent 	   with their numbering in config/i386/tm-i386.h, which see.  */
block|{
literal|0
block|,
literal|2
block|}
block|,
comment|/* control word, from npx */
block|{
literal|4
block|,
literal|2
block|}
block|,
comment|/* status word, from npx */
block|{
literal|8
block|,
literal|2
block|}
block|,
comment|/* tag word, from npx */
block|{
literal|16
block|,
literal|2
block|}
block|,
comment|/* last FP exception CS from npx */
block|{
literal|12
block|,
literal|4
block|}
block|,
comment|/* last FP exception EIP from npx */
block|{
literal|24
block|,
literal|2
block|}
block|,
comment|/* last FP exception operand selector from npx */
block|{
literal|20
block|,
literal|4
block|}
block|,
comment|/* last FP exception operand offset from npx */
block|{
literal|18
block|,
literal|2
block|}
comment|/* last FP opcode from npx */
block|}
struct|;
end_struct

begin_struct
specifier|static
struct|struct
block|{
name|int
name|go32_sig
decl_stmt|;
name|enum
name|target_signal
name|gdb_sig
decl_stmt|;
block|}
name|sig_map
index|[]
init|=
block|{
block|{
literal|0
block|,
name|TARGET_SIGNAL_FPE
block|}
block|,
block|{
literal|1
block|,
name|TARGET_SIGNAL_TRAP
block|}
block|,
comment|/* Exception 2 is triggered by the NMI.  DJGPP handles it as SIGILL,      but I think SIGBUS is better, since the NMI is usually activated      as a result of a memory parity check failure.  */
block|{
literal|2
block|,
name|TARGET_SIGNAL_BUS
block|}
block|,
block|{
literal|3
block|,
name|TARGET_SIGNAL_TRAP
block|}
block|,
block|{
literal|4
block|,
name|TARGET_SIGNAL_FPE
block|}
block|,
block|{
literal|5
block|,
name|TARGET_SIGNAL_SEGV
block|}
block|,
block|{
literal|6
block|,
name|TARGET_SIGNAL_ILL
block|}
block|,
block|{
literal|7
block|,
name|TARGET_SIGNAL_EMT
block|}
block|,
comment|/* no-coprocessor exception */
block|{
literal|8
block|,
name|TARGET_SIGNAL_SEGV
block|}
block|,
block|{
literal|9
block|,
name|TARGET_SIGNAL_SEGV
block|}
block|,
block|{
literal|10
block|,
name|TARGET_SIGNAL_BUS
block|}
block|,
block|{
literal|11
block|,
name|TARGET_SIGNAL_SEGV
block|}
block|,
block|{
literal|12
block|,
name|TARGET_SIGNAL_SEGV
block|}
block|,
block|{
literal|13
block|,
name|TARGET_SIGNAL_SEGV
block|}
block|,
block|{
literal|14
block|,
name|TARGET_SIGNAL_SEGV
block|}
block|,
block|{
literal|16
block|,
name|TARGET_SIGNAL_FPE
block|}
block|,
block|{
literal|17
block|,
name|TARGET_SIGNAL_BUS
block|}
block|,
block|{
literal|31
block|,
name|TARGET_SIGNAL_ILL
block|}
block|,
block|{
literal|0x1b
block|,
name|TARGET_SIGNAL_INT
block|}
block|,
block|{
literal|0x75
block|,
name|TARGET_SIGNAL_FPE
block|}
block|,
block|{
literal|0x78
block|,
name|TARGET_SIGNAL_ALRM
block|}
block|,
block|{
literal|0x79
block|,
name|TARGET_SIGNAL_INT
block|}
block|,
block|{
literal|0x7a
block|,
name|TARGET_SIGNAL_QUIT
block|}
block|,
block|{
operator|-
literal|1
block|,
name|TARGET_SIGNAL_LAST
block|}
block|}
struct|;
end_struct

begin_struct
specifier|static
struct|struct
block|{
name|enum
name|target_signal
name|gdb_sig
decl_stmt|;
name|int
name|djgpp_excepno
decl_stmt|;
block|}
name|excepn_map
index|[]
init|=
block|{
block|{
name|TARGET_SIGNAL_0
block|,
operator|-
literal|1
block|}
block|,
block|{
name|TARGET_SIGNAL_ILL
block|,
literal|6
block|}
block|,
comment|/* Invalid Opcode */
block|{
name|TARGET_SIGNAL_EMT
block|,
literal|7
block|}
block|,
comment|/* triggers SIGNOFP */
block|{
name|TARGET_SIGNAL_SEGV
block|,
literal|13
block|}
block|,
comment|/* GPF */
block|{
name|TARGET_SIGNAL_BUS
block|,
literal|17
block|}
block|,
comment|/* Alignment Check */
comment|/* The rest are fake exceptions, see dpmiexcp.c in djlsr*.zip for      details.  */
block|{
name|TARGET_SIGNAL_TERM
block|,
literal|0x1b
block|}
block|,
comment|/* triggers Ctrl-Break type of SIGINT */
block|{
name|TARGET_SIGNAL_FPE
block|,
literal|0x75
block|}
block|,
block|{
name|TARGET_SIGNAL_INT
block|,
literal|0x79
block|}
block|,
block|{
name|TARGET_SIGNAL_QUIT
block|,
literal|0x7a
block|}
block|,
block|{
name|TARGET_SIGNAL_ALRM
block|,
literal|0x78
block|}
block|,
comment|/* triggers SIGTIMR */
block|{
name|TARGET_SIGNAL_PROF
block|,
literal|0x78
block|}
block|,
block|{
name|TARGET_SIGNAL_LAST
block|,
operator|-
literal|1
block|}
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|go32_open
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|printf_unfiltered
argument_list|(
literal|"Done.  Use the \"run\" command to run the program.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|go32_close
parameter_list|(
name|int
name|quitting
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|void
name|go32_attach
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|error
argument_list|(
literal|"\ You cannot attach to a running program on this platform.\n\ Use the `run' command to run DJGPP programs."
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|go32_detach
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{ }
end_function

begin_decl_stmt
specifier|static
name|int
name|resume_is_step
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|resume_signal
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|go32_resume
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
name|int
name|step
parameter_list|,
name|enum
name|target_signal
name|siggnal
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|resume_is_step
operator|=
name|step
expr_stmt|;
if|if
condition|(
name|siggnal
operator|!=
name|TARGET_SIGNAL_0
operator|&&
name|siggnal
operator|!=
name|TARGET_SIGNAL_TRAP
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|resume_signal
operator|=
operator|-
literal|1
init|;
name|excepn_map
index|[
name|i
index|]
operator|.
name|gdb_sig
operator|!=
name|TARGET_SIGNAL_LAST
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|excepn_map
index|[
name|i
index|]
operator|.
name|gdb_sig
operator|==
name|siggnal
condition|)
block|{
name|resume_signal
operator|=
name|excepn_map
index|[
name|i
index|]
operator|.
name|djgpp_excepno
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|resume_signal
operator|==
operator|-
literal|1
condition|)
name|printf_unfiltered
argument_list|(
literal|"Cannot deliver signal %s on this platform.\n"
argument_list|,
name|target_signal_to_name
argument_list|(
name|siggnal
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|char
name|child_cwd
index|[
name|FILENAME_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|ptid_t
name|go32_wait
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
name|struct
name|target_waitstatus
modifier|*
name|status
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|char
name|saved_opcode
decl_stmt|;
name|unsigned
name|long
name|INT3_addr
init|=
literal|0
decl_stmt|;
name|int
name|stepping_over_INT
init|=
literal|0
decl_stmt|;
name|a_tss
operator|.
name|tss_eflags
operator|&=
literal|0xfeff
expr_stmt|;
comment|/* reset the single-step flag (TF) */
if|if
condition|(
name|resume_is_step
condition|)
block|{
comment|/* If the next instruction is INT xx or INTO, we need to handle 	 them specially.  Intel manuals say that these instructions 	 reset the single-step flag (a.k.a. TF).  However, it seems 	 that, at least in the DPMI environment, and at least when 	 stepping over the DPMI interrupt 31h, the problem is having 	 TF set at all when INT 31h is executed: the debuggee either 	 crashes (and takes the system with it) or is killed by a 	 SIGTRAP.  	 So we need to emulate single-step mode: we put an INT3 opcode 	 right after the INT xx instruction, let the debuggee run 	 until it hits INT3 and stops, then restore the original 	 instruction which we overwrote with the INT3 opcode, and back 	 up the debuggee's EIP to that instruction.  */
name|read_child
argument_list|(
name|a_tss
operator|.
name|tss_eip
argument_list|,
operator|&
name|saved_opcode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|saved_opcode
operator|==
literal|0xCD
operator|||
name|saved_opcode
operator|==
literal|0xCE
condition|)
block|{
name|unsigned
name|char
name|INT3_opcode
init|=
literal|0xCC
decl_stmt|;
name|INT3_addr
operator|=
name|saved_opcode
operator|==
literal|0xCD
condition|?
name|a_tss
operator|.
name|tss_eip
operator|+
literal|2
else|:
name|a_tss
operator|.
name|tss_eip
operator|+
literal|1
expr_stmt|;
name|stepping_over_INT
operator|=
literal|1
expr_stmt|;
name|read_child
argument_list|(
name|INT3_addr
argument_list|,
operator|&
name|saved_opcode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|write_child
argument_list|(
name|INT3_addr
argument_list|,
operator|&
name|INT3_opcode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|a_tss
operator|.
name|tss_eflags
operator||=
literal|0x0100
expr_stmt|;
comment|/* normal instruction: set TF */
block|}
comment|/* The special value FFFFh in tss_trap indicates to run_child that      tss_irqn holds a signal to be delivered to the debuggee.  */
if|if
condition|(
name|resume_signal
operator|<=
operator|-
literal|1
condition|)
block|{
name|a_tss
operator|.
name|tss_trap
operator|=
literal|0
expr_stmt|;
name|a_tss
operator|.
name|tss_irqn
operator|=
literal|0xff
expr_stmt|;
block|}
else|else
block|{
name|a_tss
operator|.
name|tss_trap
operator|=
literal|0xffff
expr_stmt|;
comment|/* run_child looks for this */
name|a_tss
operator|.
name|tss_irqn
operator|=
name|resume_signal
expr_stmt|;
block|}
comment|/* The child might change working directory behind our back.  The      GDB users won't like the side effects of that when they work with      relative file names, and GDB might be confused by its current      directory not being in sync with the truth.  So we always make a      point of changing back to where GDB thinks is its cwd, when we      return control to the debugger, but restore child's cwd before we      run it.  */
comment|/* Initialize child_cwd, before the first call to run_child and not      in the initialization, so the child get also the changed directory      set with the gdb-command "cd ..." */
if|if
condition|(
operator|!
operator|*
name|child_cwd
condition|)
comment|/* Initialize child's cwd with the current one.  */
name|getcwd
argument_list|(
name|child_cwd
argument_list|,
sizeof|sizeof
argument_list|(
name|child_cwd
argument_list|)
argument_list|)
expr_stmt|;
name|chdir
argument_list|(
name|child_cwd
argument_list|)
expr_stmt|;
if|#
directive|if
name|__DJGPP_MINOR__
operator|<
literal|3
name|load_npx
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|run_child
argument_list|()
expr_stmt|;
if|#
directive|if
name|__DJGPP_MINOR__
operator|<
literal|3
name|save_npx
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* Did we step over an INT xx instruction?  */
if|if
condition|(
name|stepping_over_INT
operator|&&
name|a_tss
operator|.
name|tss_eip
operator|==
name|INT3_addr
operator|+
literal|1
condition|)
block|{
comment|/* Restore the original opcode.  */
name|a_tss
operator|.
name|tss_eip
operator|--
expr_stmt|;
comment|/* EIP points *after* the INT3 instruction */
name|write_child
argument_list|(
name|a_tss
operator|.
name|tss_eip
argument_list|,
operator|&
name|saved_opcode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Simulate a TRAP exception.  */
name|a_tss
operator|.
name|tss_irqn
operator|=
literal|1
expr_stmt|;
name|a_tss
operator|.
name|tss_eflags
operator||=
literal|0x0100
expr_stmt|;
block|}
name|getcwd
argument_list|(
name|child_cwd
argument_list|,
sizeof|sizeof
argument_list|(
name|child_cwd
argument_list|)
argument_list|)
expr_stmt|;
comment|/* in case it has changed */
name|chdir
argument_list|(
name|current_directory
argument_list|)
expr_stmt|;
if|if
condition|(
name|a_tss
operator|.
name|tss_irqn
operator|==
literal|0x21
condition|)
block|{
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_EXITED
expr_stmt|;
name|status
operator|->
name|value
operator|.
name|integer
operator|=
name|a_tss
operator|.
name|tss_eax
operator|&
literal|0xff
expr_stmt|;
block|}
else|else
block|{
name|status
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_UNKNOWN
expr_stmt|;
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_STOPPED
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|sig_map
index|[
name|i
index|]
operator|.
name|go32_sig
operator|!=
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|a_tss
operator|.
name|tss_irqn
operator|==
name|sig_map
index|[
name|i
index|]
operator|.
name|go32_sig
condition|)
block|{
if|#
directive|if
name|__DJGPP_MINOR__
operator|<
literal|3
if|if
condition|(
operator|(
name|status
operator|->
name|value
operator|.
name|sig
operator|=
name|sig_map
index|[
name|i
index|]
operator|.
name|gdb_sig
operator|)
operator|!=
name|TARGET_SIGNAL_TRAP
condition|)
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_SIGNALLED
expr_stmt|;
else|#
directive|else
name|status
operator|->
name|value
operator|.
name|sig
operator|=
name|sig_map
index|[
name|i
index|]
operator|.
name|gdb_sig
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
block|}
block|}
return|return
name|pid_to_ptid
argument_list|(
name|SOME_PID
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fetch_register
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
if|if
condition|(
name|regno
operator|<
name|FP0_REGNUM
condition|)
name|supply_register
argument_list|(
name|regno
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|a_tss
operator|+
name|regno_mapping
index|[
name|regno
index|]
operator|.
name|tss_ofs
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i386_fp_regnum_p
argument_list|(
name|regno
argument_list|)
operator|||
name|i386_fpc_regnum_p
argument_list|(
name|regno
argument_list|)
condition|)
name|i387_supply_fsave
argument_list|(
name|current_regcache
argument_list|,
name|regno
argument_list|,
operator|&
name|npx
argument_list|)
expr_stmt|;
else|else
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"Invalid register no. %d in fetch_register."
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|go32_fetch_registers
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
if|if
condition|(
name|regno
operator|>=
literal|0
condition|)
name|fetch_register
argument_list|(
name|regno
argument_list|)
expr_stmt|;
else|else
block|{
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FP0_REGNUM
condition|;
name|regno
operator|++
control|)
name|fetch_register
argument_list|(
name|regno
argument_list|)
expr_stmt|;
name|i387_supply_fsave
argument_list|(
name|current_regcache
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|npx
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|store_register
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
if|if
condition|(
name|regno
operator|<
name|FP0_REGNUM
condition|)
name|regcache_collect
argument_list|(
name|regno
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|a_tss
operator|+
name|regno_mapping
index|[
name|regno
index|]
operator|.
name|tss_ofs
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i386_fp_regnum_p
argument_list|(
name|regno
argument_list|)
operator|||
name|i386_fpc_regnum_p
argument_list|(
name|regno
argument_list|)
condition|)
name|i387_fill_fsave
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|npx
argument_list|,
name|regno
argument_list|)
expr_stmt|;
else|else
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"Invalid register no. %d in store_register."
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|go32_store_registers
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
name|unsigned
name|r
decl_stmt|;
if|if
condition|(
name|regno
operator|>=
literal|0
condition|)
name|store_register
argument_list|(
name|regno
argument_list|)
expr_stmt|;
else|else
block|{
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
name|FP0_REGNUM
condition|;
name|r
operator|++
control|)
name|store_register
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|i387_fill_fsave
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|npx
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|go32_prepare_to_store
parameter_list|(
name|void
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|int
name|go32_xfer_memory
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|write
parameter_list|,
name|struct
name|mem_attrib
modifier|*
name|attrib
parameter_list|,
name|struct
name|target_ops
modifier|*
name|target
parameter_list|)
block|{
if|if
condition|(
name|write
condition|)
block|{
if|if
condition|(
name|write_child
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
else|else
block|{
return|return
name|len
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|read_child
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
else|else
block|{
return|return
name|len
return|;
block|}
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|cmdline_t
name|child_cmd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* parsed child's command line kept here */
end_comment

begin_function
specifier|static
name|void
name|go32_files_info
parameter_list|(
name|struct
name|target_ops
modifier|*
name|target
parameter_list|)
block|{
name|printf_unfiltered
argument_list|(
literal|"You are running a DJGPP V2 program.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|go32_stop
parameter_list|(
name|void
parameter_list|)
block|{
name|normal_stop
argument_list|()
expr_stmt|;
name|cleanup_client
argument_list|()
expr_stmt|;
name|inferior_ptid
operator|=
name|null_ptid
expr_stmt|;
name|prog_has_started
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|go32_kill_inferior
parameter_list|(
name|void
parameter_list|)
block|{
name|redir_cmdline_delete
argument_list|(
operator|&
name|child_cmd
argument_list|)
expr_stmt|;
name|resume_signal
operator|=
operator|-
literal|1
expr_stmt|;
name|resume_is_step
operator|=
literal|0
expr_stmt|;
name|unpush_target
argument_list|(
operator|&
name|go32_ops
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|go32_create_inferior
parameter_list|(
name|char
modifier|*
name|exec_file
parameter_list|,
name|char
modifier|*
name|args
parameter_list|,
name|char
modifier|*
modifier|*
name|env
parameter_list|)
block|{
specifier|extern
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
name|jmp_buf
name|start_state
decl_stmt|;
name|char
modifier|*
name|cmdline
decl_stmt|;
name|char
modifier|*
modifier|*
name|env_save
init|=
name|environ
decl_stmt|;
name|size_t
name|cmdlen
decl_stmt|;
comment|/* If no exec file handed to us, get it from the exec-file command -- with      a good, common error message if none is specified.  */
if|if
condition|(
name|exec_file
operator|==
literal|0
condition|)
name|exec_file
operator|=
name|get_exec_file
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|prog_has_started
condition|)
block|{
name|go32_stop
argument_list|()
expr_stmt|;
name|go32_kill_inferior
argument_list|()
expr_stmt|;
block|}
name|resume_signal
operator|=
operator|-
literal|1
expr_stmt|;
name|resume_is_step
operator|=
literal|0
expr_stmt|;
comment|/* Initialize child's cwd as empty to be initialized when starting      the child.  */
operator|*
name|child_cwd
operator|=
literal|0
expr_stmt|;
comment|/* Init command line storage.  */
if|if
condition|(
name|redir_debug_init
argument_list|(
operator|&
name|child_cmd
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"Cannot allocate redirection storage: not enough memory.\n"
argument_list|)
expr_stmt|;
comment|/* Parse the command line and create redirections.  */
if|if
condition|(
name|strpbrk
argument_list|(
name|args
argument_list|,
literal|"<>"
argument_list|)
condition|)
block|{
if|if
condition|(
name|redir_cmdline_parse
argument_list|(
name|args
argument_list|,
operator|&
name|child_cmd
argument_list|)
operator|==
literal|0
condition|)
name|args
operator|=
name|child_cmd
operator|.
name|command
expr_stmt|;
else|else
name|error
argument_list|(
literal|"Syntax error in command line."
argument_list|)
expr_stmt|;
block|}
else|else
name|child_cmd
operator|.
name|command
operator|=
name|xstrdup
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|cmdlen
operator|=
name|strlen
argument_list|(
name|args
argument_list|)
expr_stmt|;
comment|/* v2loadimage passes command lines via DOS memory, so it cannot      possibly handle commands longer than 1MB.  */
if|if
condition|(
name|cmdlen
operator|>
literal|1024
operator|*
literal|1024
condition|)
name|error
argument_list|(
literal|"Command line too long."
argument_list|)
expr_stmt|;
name|cmdline
operator|=
name|xmalloc
argument_list|(
name|cmdlen
operator|+
literal|4
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|cmdline
operator|+
literal|1
argument_list|,
name|args
argument_list|)
expr_stmt|;
comment|/* If the command-line length fits into DOS 126-char limits, use the      DOS command tail format; otherwise, tell v2loadimage to pass it      through a buffer in conventional memory.  */
if|if
condition|(
name|cmdlen
operator|<
literal|127
condition|)
block|{
name|cmdline
index|[
literal|0
index|]
operator|=
name|strlen
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|cmdline
index|[
name|cmdlen
operator|+
literal|1
index|]
operator|=
literal|13
expr_stmt|;
block|}
else|else
name|cmdline
index|[
literal|0
index|]
operator|=
literal|0xff
expr_stmt|;
comment|/* signal v2loadimage it's a long command */
name|environ
operator|=
name|env
expr_stmt|;
if|if
condition|(
name|v2loadimage
argument_list|(
name|exec_file
argument_list|,
name|cmdline
argument_list|,
name|start_state
argument_list|)
condition|)
block|{
name|environ
operator|=
name|env_save
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"Load failed for image %s\n"
argument_list|,
name|exec_file
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|environ
operator|=
name|env_save
expr_stmt|;
name|xfree
argument_list|(
name|cmdline
argument_list|)
expr_stmt|;
name|edi_init
argument_list|(
name|start_state
argument_list|)
expr_stmt|;
if|#
directive|if
name|__DJGPP_MINOR__
operator|<
literal|3
name|save_npx
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|inferior_ptid
operator|=
name|pid_to_ptid
argument_list|(
name|SOME_PID
argument_list|)
expr_stmt|;
name|push_target
argument_list|(
operator|&
name|go32_ops
argument_list|)
expr_stmt|;
name|clear_proceed_status
argument_list|()
expr_stmt|;
name|insert_breakpoints
argument_list|()
expr_stmt|;
name|proceed
argument_list|(
operator|(
name|CORE_ADDR
operator|)
operator|-
literal|1
argument_list|,
name|TARGET_SIGNAL_0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|prog_has_started
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|go32_mourn_inferior
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* We need to make sure all the breakpoint enable bits in the DR7      register are reset when the inferior exits.  Otherwise, if they      rerun the inferior, the uncleared bits may cause random SIGTRAPs,      failure to set more watchpoints, and other calamities.  It would      be nice if GDB itself would take care to remove all breakpoints      at all times, but it doesn't, probably under an assumption that      the OS cleans up when the debuggee exits.  */
name|i386_cleanup_dregs
argument_list|()
expr_stmt|;
name|go32_kill_inferior
argument_list|()
expr_stmt|;
name|generic_mourn_inferior
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|go32_can_run
parameter_list|(
name|void
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Hardware watchpoint support.  */
end_comment

begin_define
define|#
directive|define
name|D_REGS
value|edi.dr
end_define

begin_define
define|#
directive|define
name|CONTROL
value|D_REGS[7]
end_define

begin_define
define|#
directive|define
name|STATUS
value|D_REGS[6]
end_define

begin_comment
comment|/* Pass the address ADDR to the inferior in the I'th debug register.    Here we just store the address in D_REGS, the watchpoint will be    actually set up when go32_wait runs the debuggee.  */
end_comment

begin_function
name|void
name|go32_set_dr
parameter_list|(
name|int
name|i
parameter_list|,
name|CORE_ADDR
name|addr
parameter_list|)
block|{
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|i
operator|>
literal|3
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"Invalid register %d in go32_set_dr.\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|D_REGS
index|[
name|i
index|]
operator|=
name|addr
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pass the value VAL to the inferior in the DR7 debug control    register.  Here we just store the address in D_REGS, the watchpoint    will be actually set up when go32_wait runs the debuggee.  */
end_comment

begin_function
name|void
name|go32_set_dr7
parameter_list|(
name|unsigned
name|val
parameter_list|)
block|{
name|CONTROL
operator|=
name|val
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get the value of the DR6 debug status register from the inferior.    Here we just return the value stored in D_REGS, as we've got it    from the last go32_wait call.  */
end_comment

begin_function
name|unsigned
name|go32_get_dr6
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|STATUS
return|;
block|}
end_function

begin_comment
comment|/* Put the device open on handle FD into either raw or cooked    mode, return 1 if it was in raw mode, zero otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|device_mode
parameter_list|(
name|int
name|fd
parameter_list|,
name|int
name|raw_p
parameter_list|)
block|{
name|int
name|oldmode
decl_stmt|,
name|newmode
decl_stmt|;
name|__dpmi_regs
name|regs
decl_stmt|;
name|regs
operator|.
name|x
operator|.
name|ax
operator|=
literal|0x4400
expr_stmt|;
name|regs
operator|.
name|x
operator|.
name|bx
operator|=
name|fd
expr_stmt|;
name|__dpmi_int
argument_list|(
literal|0x21
argument_list|,
operator|&
name|regs
argument_list|)
expr_stmt|;
if|if
condition|(
name|regs
operator|.
name|x
operator|.
name|flags
operator|&
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|newmode
operator|=
name|oldmode
operator|=
name|regs
operator|.
name|x
operator|.
name|dx
expr_stmt|;
if|if
condition|(
name|raw_p
condition|)
name|newmode
operator||=
literal|0x20
expr_stmt|;
else|else
name|newmode
operator|&=
operator|~
literal|0x20
expr_stmt|;
if|if
condition|(
name|oldmode
operator|&
literal|0x80
condition|)
comment|/* Only for character dev */
block|{
name|regs
operator|.
name|x
operator|.
name|ax
operator|=
literal|0x4401
expr_stmt|;
name|regs
operator|.
name|x
operator|.
name|bx
operator|=
name|fd
expr_stmt|;
name|regs
operator|.
name|x
operator|.
name|dx
operator|=
name|newmode
operator|&
literal|0xff
expr_stmt|;
comment|/* Force upper byte zero, else it fails */
name|__dpmi_int
argument_list|(
literal|0x21
argument_list|,
operator|&
name|regs
argument_list|)
expr_stmt|;
if|if
condition|(
name|regs
operator|.
name|x
operator|.
name|flags
operator|&
literal|1
condition|)
return|return
operator|-
literal|1
return|;
block|}
return|return
operator|(
name|oldmode
operator|&
literal|0x20
operator|)
operator|==
literal|0x20
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|inf_mode_valid
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|inf_terminal_mode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This semaphore is needed because, amazingly enough, GDB calls    target.to_terminal_ours more than once after the inferior stops.    But we need the information from the first call only, since the    second call will always see GDB's own cooked terminal.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|terminal_is_ours
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|go32_terminal_init
parameter_list|(
name|void
parameter_list|)
block|{
name|inf_mode_valid
operator|=
literal|0
expr_stmt|;
comment|/* reinitialize, in case they are restarting child */
name|terminal_is_ours
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|go32_terminal_info
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|printf_unfiltered
argument_list|(
literal|"Inferior's terminal is in %s mode.\n"
argument_list|,
operator|!
name|inf_mode_valid
condition|?
literal|"default"
else|:
name|inf_terminal_mode
condition|?
literal|"raw"
else|:
literal|"cooked"
argument_list|)
expr_stmt|;
if|#
directive|if
name|__DJGPP_MINOR__
operator|>
literal|2
if|if
condition|(
name|child_cmd
operator|.
name|redirection
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DBG_HANDLES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|child_cmd
operator|.
name|redirection
index|[
name|i
index|]
operator|->
name|file_name
condition|)
name|printf_unfiltered
argument_list|(
literal|"\tFile handle %d is redirected to `%s'.\n"
argument_list|,
name|i
argument_list|,
name|child_cmd
operator|.
name|redirection
index|[
name|i
index|]
operator|->
name|file_name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|_get_dev_info
argument_list|(
name|child_cmd
operator|.
name|redirection
index|[
name|i
index|]
operator|->
name|inf_handle
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|printf_unfiltered
argument_list|(
literal|"\tFile handle %d appears to be closed by inferior.\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Mask off the raw/cooked bit when comparing device info words.  */
elseif|else
if|if
condition|(
operator|(
name|_get_dev_info
argument_list|(
name|child_cmd
operator|.
name|redirection
index|[
name|i
index|]
operator|->
name|inf_handle
argument_list|)
operator|&
literal|0xdf
operator|)
operator|!=
operator|(
name|_get_dev_info
argument_list|(
name|i
argument_list|)
operator|&
literal|0xdf
operator|)
condition|)
name|printf_unfiltered
argument_list|(
literal|"\tFile handle %d appears to be redirected by inferior.\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|go32_terminal_inferior
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Redirect standard handles as child wants them.  */
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|redir_to_child
argument_list|(
operator|&
name|child_cmd
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|redir_to_debugger
argument_list|(
operator|&
name|child_cmd
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Cannot redirect standard handles for program: %s."
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* set the console device of the inferior to whatever mode      (raw or cooked) we found it last time */
if|if
condition|(
name|terminal_is_ours
condition|)
block|{
if|if
condition|(
name|inf_mode_valid
condition|)
name|device_mode
argument_list|(
literal|0
argument_list|,
name|inf_terminal_mode
argument_list|)
expr_stmt|;
name|terminal_is_ours
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|go32_terminal_ours
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Switch to cooked mode on the gdb terminal and save the inferior      terminal mode to be restored when it is resumed */
if|if
condition|(
operator|!
name|terminal_is_ours
condition|)
block|{
name|inf_terminal_mode
operator|=
name|device_mode
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|inf_terminal_mode
operator|!=
operator|-
literal|1
condition|)
name|inf_mode_valid
operator|=
literal|1
expr_stmt|;
else|else
comment|/* If device_mode returned -1, we don't know what happens with 	 handle 0 anymore, so make the info invalid.  */
name|inf_mode_valid
operator|=
literal|0
expr_stmt|;
name|terminal_is_ours
operator|=
literal|1
expr_stmt|;
comment|/* Restore debugger's standard handles.  */
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|redir_to_debugger
argument_list|(
operator|&
name|child_cmd
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|redir_to_child
argument_list|(
operator|&
name|child_cmd
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Cannot redirect standard handles for debugger: %s."
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|init_go32_ops
parameter_list|(
name|void
parameter_list|)
block|{
name|go32_ops
operator|.
name|to_shortname
operator|=
literal|"djgpp"
expr_stmt|;
name|go32_ops
operator|.
name|to_longname
operator|=
literal|"djgpp target process"
expr_stmt|;
name|go32_ops
operator|.
name|to_doc
operator|=
literal|"Program loaded by djgpp, when gdb is used as an external debugger"
expr_stmt|;
name|go32_ops
operator|.
name|to_open
operator|=
name|go32_open
expr_stmt|;
name|go32_ops
operator|.
name|to_close
operator|=
name|go32_close
expr_stmt|;
name|go32_ops
operator|.
name|to_attach
operator|=
name|go32_attach
expr_stmt|;
name|go32_ops
operator|.
name|to_detach
operator|=
name|go32_detach
expr_stmt|;
name|go32_ops
operator|.
name|to_resume
operator|=
name|go32_resume
expr_stmt|;
name|go32_ops
operator|.
name|to_wait
operator|=
name|go32_wait
expr_stmt|;
name|go32_ops
operator|.
name|to_fetch_registers
operator|=
name|go32_fetch_registers
expr_stmt|;
name|go32_ops
operator|.
name|to_store_registers
operator|=
name|go32_store_registers
expr_stmt|;
name|go32_ops
operator|.
name|to_prepare_to_store
operator|=
name|go32_prepare_to_store
expr_stmt|;
name|go32_ops
operator|.
name|to_xfer_memory
operator|=
name|go32_xfer_memory
expr_stmt|;
name|go32_ops
operator|.
name|to_files_info
operator|=
name|go32_files_info
expr_stmt|;
name|go32_ops
operator|.
name|to_insert_breakpoint
operator|=
name|memory_insert_breakpoint
expr_stmt|;
name|go32_ops
operator|.
name|to_remove_breakpoint
operator|=
name|memory_remove_breakpoint
expr_stmt|;
name|go32_ops
operator|.
name|to_terminal_init
operator|=
name|go32_terminal_init
expr_stmt|;
name|go32_ops
operator|.
name|to_terminal_inferior
operator|=
name|go32_terminal_inferior
expr_stmt|;
name|go32_ops
operator|.
name|to_terminal_ours_for_output
operator|=
name|go32_terminal_ours
expr_stmt|;
name|go32_ops
operator|.
name|to_terminal_ours
operator|=
name|go32_terminal_ours
expr_stmt|;
name|go32_ops
operator|.
name|to_terminal_info
operator|=
name|go32_terminal_info
expr_stmt|;
name|go32_ops
operator|.
name|to_kill
operator|=
name|go32_kill_inferior
expr_stmt|;
name|go32_ops
operator|.
name|to_create_inferior
operator|=
name|go32_create_inferior
expr_stmt|;
name|go32_ops
operator|.
name|to_mourn_inferior
operator|=
name|go32_mourn_inferior
expr_stmt|;
name|go32_ops
operator|.
name|to_can_run
operator|=
name|go32_can_run
expr_stmt|;
name|go32_ops
operator|.
name|to_stop
operator|=
name|go32_stop
expr_stmt|;
name|go32_ops
operator|.
name|to_stratum
operator|=
name|process_stratum
expr_stmt|;
name|go32_ops
operator|.
name|to_has_all_memory
operator|=
literal|1
expr_stmt|;
name|go32_ops
operator|.
name|to_has_memory
operator|=
literal|1
expr_stmt|;
name|go32_ops
operator|.
name|to_has_stack
operator|=
literal|1
expr_stmt|;
name|go32_ops
operator|.
name|to_has_registers
operator|=
literal|1
expr_stmt|;
name|go32_ops
operator|.
name|to_has_execution
operator|=
literal|1
expr_stmt|;
name|go32_ops
operator|.
name|to_magic
operator|=
name|OPS_MAGIC
expr_stmt|;
comment|/* Initialize child's cwd as empty to be initialized when starting      the child.  */
operator|*
name|child_cwd
operator|=
literal|0
expr_stmt|;
comment|/* Initialize child's command line storage.  */
if|if
condition|(
name|redir_debug_init
argument_list|(
operator|&
name|child_cmd
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"Cannot allocate redirection storage: not enough memory.\n"
argument_list|)
expr_stmt|;
comment|/* We are always processing GCC-compiled programs.  */
name|processing_gcc_compilation
operator|=
literal|2
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|unsigned
name|short
name|windows_major
decl_stmt|,
name|windows_minor
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Compute the version Windows reports via Int 2Fh/AX=1600h.  */
end_comment

begin_function
specifier|static
name|void
name|go32_get_windows_version
parameter_list|(
name|void
parameter_list|)
block|{
name|__dpmi_regs
name|r
decl_stmt|;
name|r
operator|.
name|x
operator|.
name|ax
operator|=
literal|0x1600
expr_stmt|;
name|__dpmi_int
argument_list|(
literal|0x2f
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|.
name|h
operator|.
name|al
operator|>
literal|2
operator|&&
name|r
operator|.
name|h
operator|.
name|al
operator|!=
literal|0x80
operator|&&
name|r
operator|.
name|h
operator|.
name|al
operator|!=
literal|0xff
operator|&&
operator|(
name|r
operator|.
name|h
operator|.
name|al
operator|>
literal|3
operator|||
name|r
operator|.
name|h
operator|.
name|ah
operator|>
literal|0
operator|)
condition|)
block|{
name|windows_major
operator|=
name|r
operator|.
name|h
operator|.
name|al
expr_stmt|;
name|windows_minor
operator|=
name|r
operator|.
name|h
operator|.
name|ah
expr_stmt|;
block|}
else|else
name|windows_major
operator|=
literal|0xff
expr_stmt|;
comment|/* meaning no Windows */
block|}
end_function

begin_comment
comment|/* A subroutine of go32_sysinfo to display memory info.  */
end_comment

begin_function
specifier|static
name|void
name|print_mem
parameter_list|(
name|unsigned
name|long
name|datum
parameter_list|,
specifier|const
name|char
modifier|*
name|header
parameter_list|,
name|int
name|in_pages_p
parameter_list|)
block|{
if|if
condition|(
name|datum
operator|!=
literal|0xffffffffUL
condition|)
block|{
if|if
condition|(
name|in_pages_p
condition|)
name|datum
operator|<<=
literal|12
expr_stmt|;
name|puts_filtered
argument_list|(
name|header
argument_list|)
expr_stmt|;
if|if
condition|(
name|datum
operator|>
literal|1024
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"%lu KB"
argument_list|,
name|datum
operator|>>
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|datum
operator|>
literal|1024
operator|*
literal|1024
condition|)
name|printf_filtered
argument_list|(
literal|" (%lu MB)"
argument_list|,
name|datum
operator|>>
literal|20
argument_list|)
expr_stmt|;
block|}
else|else
name|printf_filtered
argument_list|(
literal|"%lu Bytes"
argument_list|,
name|datum
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Display assorted information about the underlying OS.  */
end_comment

begin_function
specifier|static
name|void
name|go32_sysinfo
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|utsname
name|u
decl_stmt|;
name|char
name|cpuid_vendor
index|[
literal|13
index|]
decl_stmt|;
name|unsigned
name|cpuid_max
init|=
literal|0
decl_stmt|,
name|cpuid_eax
decl_stmt|,
name|cpuid_ebx
decl_stmt|,
name|cpuid_ecx
decl_stmt|,
name|cpuid_edx
decl_stmt|;
name|unsigned
name|true_dos_version
init|=
name|_get_dos_version
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|unsigned
name|advertized_dos_version
init|=
operator|(
operator|(
name|unsigned
name|int
operator|)
name|_osmajor
operator|<<
literal|8
operator|)
operator||
name|_osminor
decl_stmt|;
name|int
name|dpmi_flags
decl_stmt|;
name|char
name|dpmi_vendor_info
index|[
literal|129
index|]
decl_stmt|;
name|int
name|dpmi_vendor_available
init|=
name|__dpmi_get_capabilities
argument_list|(
operator|&
name|dpmi_flags
argument_list|,
name|dpmi_vendor_info
argument_list|)
decl_stmt|;
name|__dpmi_version_ret
name|dpmi_version_data
decl_stmt|;
name|long
name|eflags
decl_stmt|;
name|__dpmi_free_mem_info
name|mem_info
decl_stmt|;
name|__dpmi_regs
name|regs
decl_stmt|;
name|cpuid_vendor
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|uname
argument_list|(
operator|&
name|u
argument_list|)
condition|)
name|strcpy
argument_list|(
name|u
operator|.
name|machine
argument_list|,
literal|"Unknown x86"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|u
operator|.
name|machine
index|[
literal|0
index|]
operator|==
literal|'i'
operator|&&
name|u
operator|.
name|machine
index|[
literal|1
index|]
operator|>
literal|4
condition|)
block|{
comment|/* CPUID with EAX = 0 returns the Vendor ID.  */
asm|__asm__
specifier|__volatile__
asm|("xorl   %%ebx, %%ebx;" 			    "xorl   %%ecx, %%ecx;" 			    "xorl   %%edx, %%edx;" 			    "movl   $0,    %%eax;" 			    "cpuid;" 			    "movl   %%ebx,  %0;" 			    "movl   %%edx,  %1;" 			    "movl   %%ecx,  %2;" 			    "movl   %%eax,  %3;" 			    : "=m" (cpuid_vendor[0]), 			      "=m" (cpuid_vendor[4]), 			      "=m" (cpuid_vendor[8]), 			      "=m" (cpuid_max) 			    : 			    : "%eax", "%ebx", "%ecx", "%edx");
name|cpuid_vendor
index|[
literal|12
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|"CPU Type.......................%s"
argument_list|,
name|u
operator|.
name|machine
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpuid_vendor
index|[
literal|0
index|]
condition|)
name|printf_filtered
argument_list|(
literal|" (%s)"
argument_list|,
name|cpuid_vendor
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* CPUID with EAX = 1 returns processor signature and features.  */
if|if
condition|(
name|cpuid_max
operator|>=
literal|1
condition|)
block|{
specifier|static
name|char
modifier|*
name|brand_name
index|[]
init|=
block|{
literal|""
block|,
literal|" Celeron"
block|,
literal|" III"
block|,
literal|" III Xeon"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|" 4"
block|}
decl_stmt|;
name|char
name|cpu_string
index|[
literal|80
index|]
decl_stmt|;
name|char
name|cpu_brand
index|[
literal|20
index|]
decl_stmt|;
name|unsigned
name|brand_idx
decl_stmt|;
name|int
name|intel_p
init|=
name|strcmp
argument_list|(
name|cpuid_vendor
argument_list|,
literal|"GenuineIntel"
argument_list|)
operator|==
literal|0
decl_stmt|;
name|int
name|amd_p
init|=
name|strcmp
argument_list|(
name|cpuid_vendor
argument_list|,
literal|"AuthenticAMD"
argument_list|)
operator|==
literal|0
decl_stmt|;
name|unsigned
name|cpu_family
decl_stmt|,
name|cpu_model
decl_stmt|;
asm|__asm__
specifier|__volatile__
asm|("movl   $1, %%eax;" 			    "cpuid;" 			    : "=a" (cpuid_eax), 			      "=b" (cpuid_ebx), 			      "=d" (cpuid_edx) 			    : 			    : "%ecx");
name|brand_idx
operator|=
name|cpuid_ebx
operator|&
literal|0xff
expr_stmt|;
name|cpu_family
operator|=
operator|(
name|cpuid_eax
operator|>>
literal|8
operator|)
operator|&
literal|0xf
expr_stmt|;
name|cpu_model
operator|=
operator|(
name|cpuid_eax
operator|>>
literal|4
operator|)
operator|&
literal|0xf
expr_stmt|;
name|cpu_brand
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|intel_p
condition|)
block|{
if|if
condition|(
name|brand_idx
operator|>
literal|0
operator|&&
name|brand_idx
operator|<
sizeof|sizeof
argument_list|(
name|brand_name
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|brand_name
index|[
literal|0
index|]
argument_list|)
operator|&&
operator|*
name|brand_name
index|[
name|brand_idx
index|]
condition|)
name|strcpy
argument_list|(
name|cpu_brand
argument_list|,
name|brand_name
index|[
name|brand_idx
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cpu_family
operator|==
literal|5
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|cpuid_eax
operator|>>
literal|12
operator|)
operator|&
literal|3
operator|)
operator|==
literal|0
operator|&&
name|cpu_model
operator|==
literal|4
condition|)
name|strcpy
argument_list|(
name|cpu_brand
argument_list|,
literal|" MMX"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cpu_model
operator|>
literal|1
operator|&&
operator|(
operator|(
name|cpuid_eax
operator|>>
literal|12
operator|)
operator|&
literal|3
operator|)
operator|==
literal|1
condition|)
name|strcpy
argument_list|(
name|cpu_brand
argument_list|,
literal|" OverDrive"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cpu_model
operator|>
literal|1
operator|&&
operator|(
operator|(
name|cpuid_eax
operator|>>
literal|12
operator|)
operator|&
literal|3
operator|)
operator|==
literal|2
condition|)
name|strcpy
argument_list|(
name|cpu_brand
argument_list|,
literal|" Dual"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cpu_family
operator|==
literal|6
operator|&&
name|cpu_model
operator|<
literal|8
condition|)
block|{
switch|switch
condition|(
name|cpu_model
condition|)
block|{
case|case
literal|1
case|:
name|strcpy
argument_list|(
name|cpu_brand
argument_list|,
literal|" Pro"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|strcpy
argument_list|(
name|cpu_brand
argument_list|,
literal|" II"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|strcpy
argument_list|(
name|cpu_brand
argument_list|,
literal|" II Xeon"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|strcpy
argument_list|(
name|cpu_brand
argument_list|,
literal|" Celeron"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|7
case|:
name|strcpy
argument_list|(
name|cpu_brand
argument_list|,
literal|" III"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|amd_p
condition|)
block|{
switch|switch
condition|(
name|cpu_family
condition|)
block|{
case|case
literal|4
case|:
name|strcpy
argument_list|(
name|cpu_brand
argument_list|,
literal|"486/5x86"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
switch|switch
condition|(
name|cpu_model
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|1
case|:
case|case
literal|2
case|:
case|case
literal|3
case|:
name|strcpy
argument_list|(
name|cpu_brand
argument_list|,
literal|"-K5"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|6
case|:
case|case
literal|7
case|:
name|strcpy
argument_list|(
name|cpu_brand
argument_list|,
literal|"-K6"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|strcpy
argument_list|(
name|cpu_brand
argument_list|,
literal|"-K6-2"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|9
case|:
name|strcpy
argument_list|(
name|cpu_brand
argument_list|,
literal|"-K6-III"
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|6
case|:
switch|switch
condition|(
name|cpu_model
condition|)
block|{
case|case
literal|1
case|:
case|case
literal|2
case|:
case|case
literal|4
case|:
name|strcpy
argument_list|(
name|cpu_brand
argument_list|,
literal|" Athlon"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|strcpy
argument_list|(
name|cpu_brand
argument_list|,
literal|" Duron"
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
block|}
block|}
name|sprintf
argument_list|(
name|cpu_string
argument_list|,
literal|"%s%s Model %d Stepping %d"
argument_list|,
name|intel_p
condition|?
literal|"Pentium"
else|:
operator|(
name|amd_p
condition|?
literal|"AMD"
else|:
literal|"ix86"
operator|)
argument_list|,
name|cpu_brand
argument_list|,
name|cpu_model
argument_list|,
name|cpuid_eax
operator|&
literal|0xf
argument_list|)
expr_stmt|;
name|printfi_filtered
argument_list|(
literal|31
argument_list|,
literal|"%s\n"
argument_list|,
name|cpu_string
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|cpuid_edx
operator|&
operator|(
literal|6
operator||
operator|(
literal|0x0d
operator|<<
literal|23
operator|)
operator|)
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|cpuid_edx
operator|&
literal|1
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|amd_p
operator|&&
operator|(
name|cpuid_edx
operator|&
operator|(
literal|3
operator|<<
literal|30
operator|)
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|puts_filtered
argument_list|(
literal|"CPU Features..................."
argument_list|)
expr_stmt|;
comment|/* We only list features which might be useful in the DPMI 	     environment.  */
if|if
condition|(
operator|(
name|cpuid_edx
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
name|puts_filtered
argument_list|(
literal|"No FPU "
argument_list|)
expr_stmt|;
comment|/* it's unusual to not have an FPU */
if|if
condition|(
operator|(
name|cpuid_edx
operator|&
operator|(
literal|1
operator|<<
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
name|puts_filtered
argument_list|(
literal|"VME "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cpuid_edx
operator|&
operator|(
literal|1
operator|<<
literal|2
operator|)
operator|)
operator|!=
literal|0
condition|)
name|puts_filtered
argument_list|(
literal|"DE "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cpuid_edx
operator|&
operator|(
literal|1
operator|<<
literal|4
operator|)
operator|)
operator|!=
literal|0
condition|)
name|puts_filtered
argument_list|(
literal|"TSC "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cpuid_edx
operator|&
operator|(
literal|1
operator|<<
literal|23
operator|)
operator|)
operator|!=
literal|0
condition|)
name|puts_filtered
argument_list|(
literal|"MMX "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cpuid_edx
operator|&
operator|(
literal|1
operator|<<
literal|25
operator|)
operator|)
operator|!=
literal|0
condition|)
name|puts_filtered
argument_list|(
literal|"SSE "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cpuid_edx
operator|&
operator|(
literal|1
operator|<<
literal|26
operator|)
operator|)
operator|!=
literal|0
condition|)
name|puts_filtered
argument_list|(
literal|"SSE2 "
argument_list|)
expr_stmt|;
if|if
condition|(
name|amd_p
condition|)
block|{
if|if
condition|(
operator|(
name|cpuid_edx
operator|&
operator|(
literal|1
operator|<<
literal|31
operator|)
operator|)
operator|!=
literal|0
condition|)
name|puts_filtered
argument_list|(
literal|"3DNow! "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cpuid_edx
operator|&
operator|(
literal|1
operator|<<
literal|30
operator|)
operator|)
operator|!=
literal|0
condition|)
name|puts_filtered
argument_list|(
literal|"3DNow!Ext"
argument_list|)
expr_stmt|;
block|}
name|puts_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|puts_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"DOS Version....................%s %s.%s"
argument_list|,
name|_os_flavor
argument_list|,
name|u
operator|.
name|release
argument_list|,
name|u
operator|.
name|version
argument_list|)
expr_stmt|;
if|if
condition|(
name|true_dos_version
operator|!=
name|advertized_dos_version
condition|)
name|printf_filtered
argument_list|(
literal|" (disguised as v%d.%d)"
argument_list|,
name|_osmajor
argument_list|,
name|_osminor
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|windows_major
condition|)
name|go32_get_windows_version
argument_list|()
expr_stmt|;
if|if
condition|(
name|windows_major
operator|!=
literal|0xff
condition|)
block|{
specifier|const
name|char
modifier|*
name|windows_flavor
decl_stmt|;
name|printf_filtered
argument_list|(
literal|"Windows Version................%d.%02d (Windows "
argument_list|,
name|windows_major
argument_list|,
name|windows_minor
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|windows_major
condition|)
block|{
case|case
literal|3
case|:
name|windows_flavor
operator|=
literal|"3.X"
expr_stmt|;
break|break;
case|case
literal|4
case|:
switch|switch
condition|(
name|windows_minor
condition|)
block|{
case|case
literal|0
case|:
name|windows_flavor
operator|=
literal|"95, 95A, or 95B"
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|windows_flavor
operator|=
literal|"95B OSR2.1 or 95C OSR2.5"
expr_stmt|;
break|break;
case|case
literal|10
case|:
name|windows_flavor
operator|=
literal|"98 or 98 SE"
expr_stmt|;
break|break;
case|case
literal|90
case|:
name|windows_flavor
operator|=
literal|"ME"
expr_stmt|;
break|break;
default|default:
name|windows_flavor
operator|=
literal|"9X"
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|windows_flavor
operator|=
literal|"??"
expr_stmt|;
break|break;
block|}
name|printf_filtered
argument_list|(
literal|"%s)\n"
argument_list|,
name|windows_flavor
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|true_dos_version
operator|==
literal|0x532
operator|&&
name|advertized_dos_version
operator|==
literal|0x500
condition|)
name|printf_filtered
argument_list|(
literal|"Windows Version................Windows NT or Windows 2000\n"
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dpmi_vendor_available
operator|==
literal|0
condition|)
block|{
comment|/* The DPMI spec says the vendor string should be ASCIIZ, but 	 I don't trust the vendors to follow that...  */
if|if
condition|(
operator|!
name|memchr
argument_list|(
operator|&
name|dpmi_vendor_info
index|[
literal|2
index|]
argument_list|,
literal|0
argument_list|,
literal|126
argument_list|)
condition|)
name|dpmi_vendor_info
index|[
literal|128
index|]
operator|=
literal|'\0'
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"DPMI Host......................%s v%d.%d (capabilities: %#x)\n"
argument_list|,
operator|&
name|dpmi_vendor_info
index|[
literal|2
index|]
argument_list|,
operator|(
name|unsigned
operator|)
name|dpmi_vendor_info
index|[
literal|0
index|]
argument_list|,
operator|(
name|unsigned
operator|)
name|dpmi_vendor_info
index|[
literal|1
index|]
argument_list|,
operator|(
operator|(
name|unsigned
operator|)
name|dpmi_flags
operator|&
literal|0x7f
operator|)
argument_list|)
expr_stmt|;
block|}
name|__dpmi_get_version
argument_list|(
operator|&
name|dpmi_version_data
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"DPMI Version...................%d.%02d\n"
argument_list|,
name|dpmi_version_data
operator|.
name|major
argument_list|,
name|dpmi_version_data
operator|.
name|minor
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"DPMI Info......................%s-bit DPMI, with%s Virtual Memory support\n"
argument_list|,
operator|(
name|dpmi_version_data
operator|.
name|flags
operator|&
literal|1
operator|)
condition|?
literal|"32"
else|:
literal|"16"
argument_list|,
operator|(
name|dpmi_version_data
operator|.
name|flags
operator|&
literal|4
operator|)
condition|?
literal|""
else|:
literal|"out"
argument_list|)
expr_stmt|;
name|printfi_filtered
argument_list|(
literal|31
argument_list|,
literal|"Interrupts reflected to %s mode\n"
argument_list|,
operator|(
name|dpmi_version_data
operator|.
name|flags
operator|&
literal|2
operator|)
condition|?
literal|"V86"
else|:
literal|"Real"
argument_list|)
expr_stmt|;
name|printfi_filtered
argument_list|(
literal|31
argument_list|,
literal|"Processor type: i%d86\n"
argument_list|,
name|dpmi_version_data
operator|.
name|cpu
argument_list|)
expr_stmt|;
name|printfi_filtered
argument_list|(
literal|31
argument_list|,
literal|"PIC base interrupt: Master: %#x  Slave: %#x\n"
argument_list|,
name|dpmi_version_data
operator|.
name|master_pic
argument_list|,
name|dpmi_version_data
operator|.
name|slave_pic
argument_list|)
expr_stmt|;
comment|/* a_tss is only initialized when the debuggee is first run.  */
if|if
condition|(
name|prog_has_started
condition|)
block|{
asm|__asm__
specifier|__volatile__
asm|("pushfl ; popl %0" : "=g" (eflags));
name|printf_filtered
argument_list|(
literal|"Protection.....................Ring %d (in %s), with%s I/O protection\n"
argument_list|,
name|a_tss
operator|.
name|tss_cs
operator|&
literal|3
argument_list|,
operator|(
name|a_tss
operator|.
name|tss_cs
operator|&
literal|4
operator|)
condition|?
literal|"LDT"
else|:
literal|"GDT"
argument_list|,
operator|(
name|a_tss
operator|.
name|tss_cs
operator|&
literal|3
operator|)
operator|>
operator|(
operator|(
name|eflags
operator|>>
literal|12
operator|)
operator|&
literal|3
operator|)
condition|?
literal|""
else|:
literal|"out"
argument_list|)
expr_stmt|;
block|}
name|puts_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|__dpmi_get_free_memory_information
argument_list|(
operator|&
name|mem_info
argument_list|)
expr_stmt|;
name|print_mem
argument_list|(
name|mem_info
operator|.
name|total_number_of_physical_pages
argument_list|,
literal|"DPMI Total Physical Memory....."
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|print_mem
argument_list|(
name|mem_info
operator|.
name|total_number_of_free_pages
argument_list|,
literal|"DPMI Free Physical Memory......"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|print_mem
argument_list|(
name|mem_info
operator|.
name|size_of_paging_file_partition_in_pages
argument_list|,
literal|"DPMI Swap Space................"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|print_mem
argument_list|(
name|mem_info
operator|.
name|linear_address_space_size_in_pages
argument_list|,
literal|"DPMI Total Linear Address Size."
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|print_mem
argument_list|(
name|mem_info
operator|.
name|free_linear_address_space_in_pages
argument_list|,
literal|"DPMI Free Linear Address Size.."
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|print_mem
argument_list|(
name|mem_info
operator|.
name|largest_available_free_block_in_bytes
argument_list|,
literal|"DPMI Largest Free Memory Block."
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|regs
operator|.
name|h
operator|.
name|ah
operator|=
literal|0x48
expr_stmt|;
name|regs
operator|.
name|x
operator|.
name|bx
operator|=
literal|0xffff
expr_stmt|;
name|__dpmi_int
argument_list|(
literal|0x21
argument_list|,
operator|&
name|regs
argument_list|)
expr_stmt|;
name|print_mem
argument_list|(
name|regs
operator|.
name|x
operator|.
name|bx
operator|<<
literal|4
argument_list|,
literal|"Free DOS Memory................"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|regs
operator|.
name|x
operator|.
name|ax
operator|=
literal|0x5800
expr_stmt|;
name|__dpmi_int
argument_list|(
literal|0x21
argument_list|,
operator|&
name|regs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|regs
operator|.
name|x
operator|.
name|flags
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|dos_hilo
index|[]
init|=
block|{
literal|"Low"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|"High"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|"High, then Low"
block|}
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|dos_fit
index|[]
init|=
block|{
literal|"First"
block|,
literal|"Best"
block|,
literal|"Last"
block|}
decl_stmt|;
name|int
name|hilo_idx
init|=
operator|(
name|regs
operator|.
name|x
operator|.
name|ax
operator|>>
literal|4
operator|)
operator|&
literal|0x0f
decl_stmt|;
name|int
name|fit_idx
init|=
name|regs
operator|.
name|x
operator|.
name|ax
operator|&
literal|0x0f
decl_stmt|;
if|if
condition|(
name|hilo_idx
operator|>
literal|8
condition|)
name|hilo_idx
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fit_idx
operator|>
literal|2
condition|)
name|fit_idx
operator|=
literal|0
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"DOS Memory Allocation..........%s memory, %s fit\n"
argument_list|,
name|dos_hilo
index|[
name|hilo_idx
index|]
argument_list|,
name|dos_fit
index|[
name|fit_idx
index|]
argument_list|)
expr_stmt|;
name|regs
operator|.
name|x
operator|.
name|ax
operator|=
literal|0x5802
expr_stmt|;
name|__dpmi_int
argument_list|(
literal|0x21
argument_list|,
operator|&
name|regs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|regs
operator|.
name|x
operator|.
name|flags
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|regs
operator|.
name|h
operator|.
name|al
operator|=
literal|0
expr_stmt|;
name|printfi_filtered
argument_list|(
literal|31
argument_list|,
literal|"UMBs %sin DOS memory chain\n"
argument_list|,
name|regs
operator|.
name|h
operator|.
name|al
operator|==
literal|0
condition|?
literal|"not "
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_struct
struct|struct
name|seg_descr
block|{
name|unsigned
name|short
name|limit0
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
decl_stmt|;
name|unsigned
name|short
name|base0
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
decl_stmt|;
name|unsigned
name|char
name|base1
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
decl_stmt|;
name|unsigned
name|stype
range|:
literal|5
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
decl_stmt|;
name|unsigned
name|dpl
range|:
literal|2
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
decl_stmt|;
name|unsigned
name|present
range|:
literal|1
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
decl_stmt|;
name|unsigned
name|limit1
range|:
literal|4
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
decl_stmt|;
name|unsigned
name|available
range|:
literal|1
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
decl_stmt|;
name|unsigned
name|dummy
range|:
literal|1
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
decl_stmt|;
name|unsigned
name|bit32
range|:
literal|1
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
decl_stmt|;
name|unsigned
name|page_granular
range|:
literal|1
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
decl_stmt|;
name|unsigned
name|char
name|base2
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|gate_descr
block|{
name|unsigned
name|short
name|offset0
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
decl_stmt|;
name|unsigned
name|short
name|selector
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
decl_stmt|;
name|unsigned
name|param_count
range|:
literal|5
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
decl_stmt|;
name|unsigned
name|dummy
range|:
literal|3
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
decl_stmt|;
name|unsigned
name|stype
range|:
literal|5
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
decl_stmt|;
name|unsigned
name|dpl
range|:
literal|2
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
decl_stmt|;
name|unsigned
name|present
range|:
literal|1
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
decl_stmt|;
name|unsigned
name|short
name|offset1
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Read LEN bytes starting at logical address ADDR, and put the result    into DEST.  Return 1 if success, zero if not.  */
end_comment

begin_function
specifier|static
name|int
name|read_memory_region
parameter_list|(
name|unsigned
name|long
name|addr
parameter_list|,
name|void
modifier|*
name|dest
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|unsigned
name|long
name|dos_ds_limit
init|=
name|__dpmi_get_segment_limit
argument_list|(
name|_dos_ds
argument_list|)
decl_stmt|;
name|int
name|retval
init|=
literal|1
decl_stmt|;
comment|/* For the low memory, we can simply use _dos_ds.  */
if|if
condition|(
name|addr
operator|<=
name|dos_ds_limit
operator|-
name|len
condition|)
name|dosmemget
argument_list|(
name|addr
argument_list|,
name|len
argument_list|,
name|dest
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* For memory above 1MB we need to set up a special segment to 	 be able to access that memory.  */
name|int
name|sel
init|=
name|__dpmi_allocate_ldt_descriptors
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|sel
operator|<=
literal|0
condition|)
name|retval
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|int
name|access_rights
init|=
name|__dpmi_get_descriptor_access_rights
argument_list|(
name|sel
argument_list|)
decl_stmt|;
name|size_t
name|segment_limit
init|=
name|len
operator|-
literal|1
decl_stmt|;
comment|/* Make sure the crucial bits in the descriptor access 	     rights are set correctly.  Some DPMI providers might barf 	     if we set the segment limit to something that is not an 	     integral multiple of 4KB pages if the granularity bit is 	     not set to byte-granular, even though the DPMI spec says 	     it's the host's responsibility to set that bit correctly.  */
if|if
condition|(
name|len
operator|>
literal|1024
operator|*
literal|1024
condition|)
block|{
name|access_rights
operator||=
literal|0x8000
expr_stmt|;
comment|/* Page-granular segments should have the low 12 bits of 		 the limit set.  */
name|segment_limit
operator||=
literal|0xfff
expr_stmt|;
block|}
else|else
name|access_rights
operator|&=
operator|~
literal|0x8000
expr_stmt|;
if|if
condition|(
name|__dpmi_set_segment_base_address
argument_list|(
name|sel
argument_list|,
name|addr
argument_list|)
operator|!=
operator|-
literal|1
operator|&&
name|__dpmi_set_descriptor_access_rights
argument_list|(
name|sel
argument_list|,
name|access_rights
argument_list|)
operator|!=
operator|-
literal|1
operator|&&
name|__dpmi_set_segment_limit
argument_list|(
name|sel
argument_list|,
name|segment_limit
argument_list|)
operator|!=
operator|-
literal|1
comment|/* W2K silently fails to set the segment limit, leaving 		 it at zero; this test avoids the resulting crash.  */
operator|&&
name|__dpmi_get_segment_limit
argument_list|(
name|sel
argument_list|)
operator|>=
name|segment_limit
condition|)
name|movedata
argument_list|(
name|sel
argument_list|,
literal|0
argument_list|,
name|_my_ds
argument_list|()
argument_list|,
operator|(
name|unsigned
operator|)
name|dest
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|else
name|retval
operator|=
literal|0
expr_stmt|;
name|__dpmi_free_ldt_descriptor
argument_list|(
name|sel
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Get a segment descriptor stored at index IDX in the descriptor    table whose base address is TABLE_BASE.  Return the descriptor    type, or -1 if failure.  */
end_comment

begin_function
specifier|static
name|int
name|get_descriptor
parameter_list|(
name|unsigned
name|long
name|table_base
parameter_list|,
name|int
name|idx
parameter_list|,
name|void
modifier|*
name|descr
parameter_list|)
block|{
name|unsigned
name|long
name|addr
init|=
name|table_base
operator|+
name|idx
operator|*
literal|8
decl_stmt|;
comment|/* 8 bytes per entry */
if|if
condition|(
name|read_memory_region
argument_list|(
name|addr
argument_list|,
name|descr
argument_list|,
literal|8
argument_list|)
condition|)
return|return
call|(
name|int
call|)
argument_list|(
operator|(
expr|struct
name|seg_descr
operator|*
operator|)
name|descr
argument_list|)
operator|->
name|stype
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_struct
struct|struct
name|dtr_reg
block|{
name|unsigned
name|short
name|limit
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
decl_stmt|;
name|unsigned
name|long
name|base
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Display a segment descriptor stored at index IDX in a descriptor    table whose type is TYPE and whose base address is BASE_ADDR.  If    FORCE is non-zero, display even invalid descriptors.  */
end_comment

begin_function
specifier|static
name|void
name|display_descriptor
parameter_list|(
name|unsigned
name|type
parameter_list|,
name|unsigned
name|long
name|base_addr
parameter_list|,
name|int
name|idx
parameter_list|,
name|int
name|force
parameter_list|)
block|{
name|struct
name|seg_descr
name|descr
decl_stmt|;
name|struct
name|gate_descr
name|gate
decl_stmt|;
comment|/* Get the descriptor from the table.  */
if|if
condition|(
name|idx
operator|==
literal|0
operator|&&
name|type
operator|==
literal|0
condition|)
name|puts_filtered
argument_list|(
literal|"0x000: null descriptor\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|get_descriptor
argument_list|(
name|base_addr
argument_list|,
name|idx
argument_list|,
operator|&
name|descr
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* For each type of descriptor table, this has a bit set if the 	 corresponding type of selectors is valid in that table.  */
specifier|static
name|unsigned
name|allowed_descriptors
index|[]
init|=
block|{
literal|0xffffdafeL
block|,
comment|/* GDT */
literal|0x0000c0e0L
block|,
comment|/* IDT */
literal|0xffffdafaL
comment|/* LDT */
block|}
decl_stmt|;
comment|/* If the program hasn't started yet, assume the debuggee will 	 have the same CPL as the debugger.  */
name|int
name|cpl
init|=
name|prog_has_started
condition|?
operator|(
name|a_tss
operator|.
name|tss_cs
operator|&
literal|3
operator|)
else|:
name|_my_cs
argument_list|()
operator|&
literal|3
decl_stmt|;
name|unsigned
name|long
name|limit
init|=
operator|(
name|descr
operator|.
name|limit1
operator|<<
literal|16
operator|)
operator||
name|descr
operator|.
name|limit0
decl_stmt|;
if|if
condition|(
name|descr
operator|.
name|present
operator|&&
operator|(
name|allowed_descriptors
index|[
name|type
index|]
operator|&
operator|(
literal|1
operator|<<
name|descr
operator|.
name|stype
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"0x%03x: "
argument_list|,
name|type
operator|==
literal|1
condition|?
name|idx
else|:
operator|(
name|idx
operator|*
literal|8
operator|)
operator||
operator|(
name|type
condition|?
operator|(
name|cpl
operator||
literal|4
operator|)
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|descr
operator|.
name|page_granular
condition|)
name|limit
operator|=
operator|(
name|limit
operator|<<
literal|12
operator|)
operator||
literal|0xfff
expr_stmt|;
comment|/* big segment: low 12 bit set */
if|if
condition|(
name|descr
operator|.
name|stype
operator|==
literal|1
operator|||
name|descr
operator|.
name|stype
operator|==
literal|2
operator|||
name|descr
operator|.
name|stype
operator|==
literal|3
operator|||
name|descr
operator|.
name|stype
operator|==
literal|9
operator|||
name|descr
operator|.
name|stype
operator|==
literal|11
operator|||
operator|(
name|descr
operator|.
name|stype
operator|>=
literal|16
operator|&&
name|descr
operator|.
name|stype
operator|<
literal|32
operator|)
condition|)
name|printf_filtered
argument_list|(
literal|"base=0x%02x%02x%04x limit=0x%08lx"
argument_list|,
name|descr
operator|.
name|base2
argument_list|,
name|descr
operator|.
name|base1
argument_list|,
name|descr
operator|.
name|base0
argument_list|,
name|limit
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|descr
operator|.
name|stype
condition|)
block|{
case|case
literal|1
case|:
case|case
literal|3
case|:
name|printf_filtered
argument_list|(
literal|" 16-bit TSS  (task %sactive)"
argument_list|,
name|descr
operator|.
name|stype
operator|==
literal|3
condition|?
literal|""
else|:
literal|"in"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|puts_filtered
argument_list|(
literal|" LDT"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|memcpy
argument_list|(
operator|&
name|gate
argument_list|,
operator|&
name|descr
argument_list|,
sizeof|sizeof
name|gate
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"selector=0x%04x  offs=0x%04x%04x"
argument_list|,
name|gate
operator|.
name|selector
argument_list|,
name|gate
operator|.
name|offset1
argument_list|,
name|gate
operator|.
name|offset0
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" 16-bit Call Gate (params=%d)"
argument_list|,
name|gate
operator|.
name|param_count
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|printf_filtered
argument_list|(
literal|"TSS selector=0x%04x"
argument_list|,
name|descr
operator|.
name|base0
argument_list|)
expr_stmt|;
name|printfi_filtered
argument_list|(
literal|16
argument_list|,
literal|"Task Gate"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|6
case|:
case|case
literal|7
case|:
name|memcpy
argument_list|(
operator|&
name|gate
argument_list|,
operator|&
name|descr
argument_list|,
sizeof|sizeof
name|gate
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"selector=0x%04x  offs=0x%04x%04x"
argument_list|,
name|gate
operator|.
name|selector
argument_list|,
name|gate
operator|.
name|offset1
argument_list|,
name|gate
operator|.
name|offset0
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" 16-bit %s Gate"
argument_list|,
name|descr
operator|.
name|stype
operator|==
literal|6
condition|?
literal|"Interrupt"
else|:
literal|"Trap"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|9
case|:
case|case
literal|11
case|:
name|printf_filtered
argument_list|(
literal|" 32-bit TSS (task %sactive)"
argument_list|,
name|descr
operator|.
name|stype
operator|==
literal|3
condition|?
literal|""
else|:
literal|"in"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|12
case|:
name|memcpy
argument_list|(
operator|&
name|gate
argument_list|,
operator|&
name|descr
argument_list|,
sizeof|sizeof
name|gate
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"selector=0x%04x  offs=0x%04x%04x"
argument_list|,
name|gate
operator|.
name|selector
argument_list|,
name|gate
operator|.
name|offset1
argument_list|,
name|gate
operator|.
name|offset0
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" 32-bit Call Gate (params=%d)"
argument_list|,
name|gate
operator|.
name|param_count
argument_list|)
expr_stmt|;
break|break;
case|case
literal|14
case|:
case|case
literal|15
case|:
name|memcpy
argument_list|(
operator|&
name|gate
argument_list|,
operator|&
name|descr
argument_list|,
sizeof|sizeof
name|gate
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"selector=0x%04x  offs=0x%04x%04x"
argument_list|,
name|gate
operator|.
name|selector
argument_list|,
name|gate
operator|.
name|offset1
argument_list|,
name|gate
operator|.
name|offset0
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" 32-bit %s Gate"
argument_list|,
name|descr
operator|.
name|stype
operator|==
literal|14
condition|?
literal|"Interrupt"
else|:
literal|"Trap"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|16
case|:
comment|/* data segments */
case|case
literal|17
case|:
case|case
literal|18
case|:
case|case
literal|19
case|:
case|case
literal|20
case|:
case|case
literal|21
case|:
case|case
literal|22
case|:
case|case
literal|23
case|:
name|printf_filtered
argument_list|(
literal|" %s-bit Data (%s Exp-%s%s)"
argument_list|,
name|descr
operator|.
name|bit32
condition|?
literal|"32"
else|:
literal|"16"
argument_list|,
name|descr
operator|.
name|stype
operator|&
literal|2
condition|?
literal|"Read/Write,"
else|:
literal|"Read-Only, "
argument_list|,
name|descr
operator|.
name|stype
operator|&
literal|4
condition|?
literal|"down"
else|:
literal|"up"
argument_list|,
name|descr
operator|.
name|stype
operator|&
literal|1
condition|?
literal|""
else|:
literal|", N.Acc"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|24
case|:
comment|/* code segments */
case|case
literal|25
case|:
case|case
literal|26
case|:
case|case
literal|27
case|:
case|case
literal|28
case|:
case|case
literal|29
case|:
case|case
literal|30
case|:
case|case
literal|31
case|:
name|printf_filtered
argument_list|(
literal|" %s-bit Code (%s,  %sConf%s)"
argument_list|,
name|descr
operator|.
name|bit32
condition|?
literal|"32"
else|:
literal|"16"
argument_list|,
name|descr
operator|.
name|stype
operator|&
literal|2
condition|?
literal|"Exec/Read"
else|:
literal|"Exec-Only"
argument_list|,
name|descr
operator|.
name|stype
operator|&
literal|4
condition|?
literal|""
else|:
literal|"N."
argument_list|,
name|descr
operator|.
name|stype
operator|&
literal|1
condition|?
literal|""
else|:
literal|", N.Acc"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf_filtered
argument_list|(
literal|"Unknown type 0x%02x"
argument_list|,
name|descr
operator|.
name|stype
argument_list|)
expr_stmt|;
break|break;
block|}
name|puts_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|force
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"0x%03x: "
argument_list|,
name|type
operator|==
literal|1
condition|?
name|idx
else|:
operator|(
name|idx
operator|*
literal|8
operator|)
operator||
operator|(
name|type
condition|?
operator|(
name|cpl
operator||
literal|4
operator|)
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|descr
operator|.
name|present
condition|)
name|puts_filtered
argument_list|(
literal|"Segment not present\n"
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|"Segment type 0x%02x is invalid in this table\n"
argument_list|,
name|descr
operator|.
name|stype
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|force
condition|)
name|printf_filtered
argument_list|(
literal|"0x%03x: Cannot read this descriptor\n"
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|go32_sldt
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|dtr_reg
name|gdtr
decl_stmt|;
name|unsigned
name|short
name|ldtr
init|=
literal|0
decl_stmt|;
name|int
name|ldt_idx
decl_stmt|;
name|struct
name|seg_descr
name|ldt_descr
decl_stmt|;
name|long
name|ldt_entry
init|=
operator|-
literal|1L
decl_stmt|;
name|int
name|cpl
init|=
operator|(
name|prog_has_started
condition|?
name|a_tss
operator|.
name|tss_cs
else|:
name|_my_cs
argument_list|()
operator|)
operator|&
literal|3
decl_stmt|;
if|if
condition|(
name|arg
operator|&&
operator|*
name|arg
condition|)
block|{
while|while
condition|(
operator|*
name|arg
operator|&&
name|isspace
argument_list|(
operator|*
name|arg
argument_list|)
condition|)
name|arg
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|arg
condition|)
block|{
name|ldt_entry
operator|=
name|parse_and_eval_long
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ldt_entry
operator|<
literal|0
operator|||
operator|(
name|ldt_entry
operator|&
literal|4
operator|)
operator|==
literal|0
operator|||
operator|(
name|ldt_entry
operator|&
literal|3
operator|)
operator|!=
operator|(
name|cpl
operator|&
literal|3
operator|)
condition|)
name|error
argument_list|(
literal|"Invalid LDT entry 0x%03lx."
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|ldt_entry
argument_list|)
expr_stmt|;
block|}
block|}
asm|__asm__
specifier|__volatile__
asm|("sgdt   %0" : "=m" (gdtr) :
comment|/* no inputs */
asm|);
asm|__asm__
specifier|__volatile__
asm|("sldt   %0" : "=m" (ldtr) :
comment|/* no inputs */
asm|);
name|ldt_idx
operator|=
name|ldtr
operator|/
literal|8
expr_stmt|;
if|if
condition|(
name|ldt_idx
operator|==
literal|0
condition|)
name|puts_filtered
argument_list|(
literal|"There is no LDT.\n"
argument_list|)
expr_stmt|;
comment|/* LDT's entry in the GDT must have the type LDT, which is 2.  */
elseif|else
if|if
condition|(
name|get_descriptor
argument_list|(
name|gdtr
operator|.
name|base
argument_list|,
name|ldt_idx
argument_list|,
operator|&
name|ldt_descr
argument_list|)
operator|!=
literal|2
condition|)
name|printf_filtered
argument_list|(
literal|"LDT is present (at %#x), but unreadable by GDB.\n"
argument_list|,
name|ldt_descr
operator|.
name|base0
operator||
operator|(
name|ldt_descr
operator|.
name|base1
operator|<<
literal|16
operator|)
operator||
operator|(
name|ldt_descr
operator|.
name|base2
operator|<<
literal|24
operator|)
argument_list|)
expr_stmt|;
else|else
block|{
name|unsigned
name|base
init|=
name|ldt_descr
operator|.
name|base0
operator||
operator|(
name|ldt_descr
operator|.
name|base1
operator|<<
literal|16
operator|)
operator||
operator|(
name|ldt_descr
operator|.
name|base2
operator|<<
literal|24
operator|)
decl_stmt|;
name|unsigned
name|limit
init|=
name|ldt_descr
operator|.
name|limit0
operator||
operator|(
name|ldt_descr
operator|.
name|limit1
operator|<<
literal|16
operator|)
decl_stmt|;
name|int
name|max_entry
decl_stmt|;
if|if
condition|(
name|ldt_descr
operator|.
name|page_granular
condition|)
comment|/* Page-granular segments must have the low 12 bits of their 	   limit set.  */
name|limit
operator|=
operator|(
name|limit
operator|<<
literal|12
operator|)
operator||
literal|0xfff
expr_stmt|;
comment|/* LDT cannot have more than 8K 8-byte entries, i.e. more than 	 64KB.  */
if|if
condition|(
name|limit
operator|>
literal|0xffff
condition|)
name|limit
operator|=
literal|0xffff
expr_stmt|;
name|max_entry
operator|=
operator|(
name|limit
operator|+
literal|1
operator|)
operator|/
literal|8
expr_stmt|;
if|if
condition|(
name|ldt_entry
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|ldt_entry
operator|>
name|limit
condition|)
name|error
argument_list|(
literal|"Invalid LDT entry %#lx: outside valid limits [0..%#x]"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|ldt_entry
argument_list|,
name|limit
argument_list|)
expr_stmt|;
name|display_descriptor
argument_list|(
name|ldt_descr
operator|.
name|stype
argument_list|,
name|base
argument_list|,
name|ldt_entry
operator|/
literal|8
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_entry
condition|;
name|i
operator|++
control|)
name|display_descriptor
argument_list|(
name|ldt_descr
operator|.
name|stype
argument_list|,
name|base
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|go32_sgdt
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|dtr_reg
name|gdtr
decl_stmt|;
name|long
name|gdt_entry
init|=
operator|-
literal|1L
decl_stmt|;
name|int
name|max_entry
decl_stmt|;
if|if
condition|(
name|arg
operator|&&
operator|*
name|arg
condition|)
block|{
while|while
condition|(
operator|*
name|arg
operator|&&
name|isspace
argument_list|(
operator|*
name|arg
argument_list|)
condition|)
name|arg
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|arg
condition|)
block|{
name|gdt_entry
operator|=
name|parse_and_eval_long
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|gdt_entry
operator|<
literal|0
operator|||
operator|(
name|gdt_entry
operator|&
literal|7
operator|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|"Invalid GDT entry 0x%03lx: not an integral multiple of 8."
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|gdt_entry
argument_list|)
expr_stmt|;
block|}
block|}
asm|__asm__
specifier|__volatile__
asm|("sgdt   %0" : "=m" (gdtr) :
comment|/* no inputs */
asm|);
name|max_entry
operator|=
operator|(
name|gdtr
operator|.
name|limit
operator|+
literal|1
operator|)
operator|/
literal|8
expr_stmt|;
if|if
condition|(
name|gdt_entry
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|gdt_entry
operator|>
name|gdtr
operator|.
name|limit
condition|)
name|error
argument_list|(
literal|"Invalid GDT entry %#lx: outside valid limits [0..%#x]"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|gdt_entry
argument_list|,
name|gdtr
operator|.
name|limit
argument_list|)
expr_stmt|;
name|display_descriptor
argument_list|(
literal|0
argument_list|,
name|gdtr
operator|.
name|base
argument_list|,
name|gdt_entry
operator|/
literal|8
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_entry
condition|;
name|i
operator|++
control|)
name|display_descriptor
argument_list|(
literal|0
argument_list|,
name|gdtr
operator|.
name|base
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|go32_sidt
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|dtr_reg
name|idtr
decl_stmt|;
name|long
name|idt_entry
init|=
operator|-
literal|1L
decl_stmt|;
name|int
name|max_entry
decl_stmt|;
if|if
condition|(
name|arg
operator|&&
operator|*
name|arg
condition|)
block|{
while|while
condition|(
operator|*
name|arg
operator|&&
name|isspace
argument_list|(
operator|*
name|arg
argument_list|)
condition|)
name|arg
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|arg
condition|)
block|{
name|idt_entry
operator|=
name|parse_and_eval_long
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|idt_entry
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"Invalid (negative) IDT entry %ld."
argument_list|,
name|idt_entry
argument_list|)
expr_stmt|;
block|}
block|}
asm|__asm__
specifier|__volatile__
asm|("sidt   %0" : "=m" (idtr) :
comment|/* no inputs */
asm|);
name|max_entry
operator|=
operator|(
name|idtr
operator|.
name|limit
operator|+
literal|1
operator|)
operator|/
literal|8
expr_stmt|;
if|if
condition|(
name|max_entry
operator|>
literal|0x100
condition|)
comment|/* no more than 256 entries */
name|max_entry
operator|=
literal|0x100
expr_stmt|;
if|if
condition|(
name|idt_entry
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|idt_entry
operator|>
name|idtr
operator|.
name|limit
condition|)
name|error
argument_list|(
literal|"Invalid IDT entry %#lx: outside valid limits [0..%#x]"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|idt_entry
argument_list|,
name|idtr
operator|.
name|limit
argument_list|)
expr_stmt|;
name|display_descriptor
argument_list|(
literal|1
argument_list|,
name|idtr
operator|.
name|base
argument_list|,
name|idt_entry
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_entry
condition|;
name|i
operator|++
control|)
name|display_descriptor
argument_list|(
literal|1
argument_list|,
name|idtr
operator|.
name|base
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Cached linear address of the base of the page directory.  For    now, available only under CWSDPMI.  Code based on ideas and    suggestions from Charles Sandmann<sandmann@clio.rice.edu>.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|pdbr
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|unsigned
name|long
name|get_cr3
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|offset
decl_stmt|;
name|unsigned
name|taskreg
decl_stmt|;
name|unsigned
name|long
name|taskbase
decl_stmt|,
name|cr3
decl_stmt|;
name|struct
name|dtr_reg
name|gdtr
decl_stmt|;
if|if
condition|(
name|pdbr
operator|>
literal|0
operator|&&
name|pdbr
operator|<=
literal|0xfffff
condition|)
return|return
name|pdbr
return|;
comment|/* Get the linear address of GDT and the Task Register.  */
asm|__asm__
specifier|__volatile__
asm|("sgdt   %0" : "=m" (gdtr) :
comment|/* no inputs */
asm|);
asm|__asm__
specifier|__volatile__
asm|("str    %0" : "=m" (taskreg) :
comment|/* no inputs */
asm|);
comment|/* Task Register is a segment selector for the TSS of the current      task.  Therefore, it can be used as an index into the GDT to get      at the segment descriptor for the TSS.  To get the index, reset      the low 3 bits of the selector (which give the CPL).  Add 2 to the      offset to point to the 3 low bytes of the base address.  */
name|offset
operator|=
name|gdtr
operator|.
name|base
operator|+
operator|(
name|taskreg
operator|&
literal|0xfff8
operator|)
operator|+
literal|2
expr_stmt|;
comment|/* CWSDPMI's task base is always under the 1MB mark.  */
if|if
condition|(
name|offset
operator|>
literal|0xfffff
condition|)
return|return
literal|0
return|;
name|_farsetsel
argument_list|(
name|_dos_ds
argument_list|)
expr_stmt|;
name|taskbase
operator|=
name|_farnspeekl
argument_list|(
name|offset
argument_list|)
operator|&
literal|0xffffffU
expr_stmt|;
name|taskbase
operator|+=
name|_farnspeekl
argument_list|(
name|offset
operator|+
literal|2
argument_list|)
operator|&
literal|0xff000000U
expr_stmt|;
if|if
condition|(
name|taskbase
operator|>
literal|0xfffff
condition|)
return|return
literal|0
return|;
comment|/* CR3 (a.k.a. PDBR, the Page Directory Base Register) is stored at      offset 1Ch in the TSS.  */
name|cr3
operator|=
name|_farnspeekl
argument_list|(
name|taskbase
operator|+
literal|0x1c
argument_list|)
operator|&
operator|~
literal|0xfff
expr_stmt|;
if|if
condition|(
name|cr3
operator|>
literal|0xfffff
condition|)
block|{
if|#
directive|if
literal|0
comment|/* not fullly supported yet */
comment|/* The Page Directory is in UMBs.  In that case, CWSDPMI puts 	 the first Page Table right below the Page Directory.  Thus, 	 the first Page Table's entry for its own address and the Page 	 Directory entry for that Page Table will hold the same 	 physical address.  The loop below searches the entire UMB 	 range of addresses for such an occurence.  */
block|unsigned long addr, pte_idx;        for (addr = 0xb0000, pte_idx = 0xb0; 	   pte_idx< 0xff; 	   addr += 0x1000, pte_idx++) 	{ 	  if (((_farnspeekl (addr + 4 * pte_idx)& 0xfffff027) == 	       (_farnspeekl (addr + 0x1000)& 0xfffff027))&& ((_farnspeekl (addr + 4 * pte_idx + 4)& 0xfffff000) == cr3)) 	    { 	      cr3 = addr + 0x1000; 	      break; 	    } 	}
endif|#
directive|endif
if|if
condition|(
name|cr3
operator|>
literal|0xfffff
condition|)
name|cr3
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|cr3
return|;
block|}
end_function

begin_comment
comment|/* Return the N'th Page Directory entry.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|get_pde
parameter_list|(
name|int
name|n
parameter_list|)
block|{
name|unsigned
name|long
name|pde
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|pdbr
operator|&&
name|n
operator|>=
literal|0
operator|&&
name|n
operator|<
literal|1024
condition|)
block|{
name|pde
operator|=
name|_farpeekl
argument_list|(
name|_dos_ds
argument_list|,
name|pdbr
operator|+
literal|4
operator|*
name|n
argument_list|)
expr_stmt|;
block|}
return|return
name|pde
return|;
block|}
end_function

begin_comment
comment|/* Return the N'th entry of the Page Table whose Page Directory entry    is PDE.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|get_pte
parameter_list|(
name|unsigned
name|long
name|pde
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|unsigned
name|long
name|pte
init|=
literal|0
decl_stmt|;
comment|/* pde& 0x80 tests the 4MB page bit.  We don't support 4MB      page tables, for now.  */
if|if
condition|(
operator|(
name|pde
operator|&
literal|1
operator|)
operator|&&
operator|!
operator|(
name|pde
operator|&
literal|0x80
operator|)
operator|&&
name|n
operator|>=
literal|0
operator|&&
name|n
operator|<
literal|1024
condition|)
block|{
name|pde
operator|&=
operator|~
literal|0xfff
expr_stmt|;
comment|/* clear non-address bits */
name|pte
operator|=
name|_farpeekl
argument_list|(
name|_dos_ds
argument_list|,
name|pde
operator|+
literal|4
operator|*
name|n
argument_list|)
expr_stmt|;
block|}
return|return
name|pte
return|;
block|}
end_function

begin_comment
comment|/* Display a Page Directory or Page Table entry.  IS_DIR, if non-zero,    says this is a Page Directory entry.  If FORCE is non-zero, display    the entry even if its Present flag is off.  OFF is the offset of the    address from the page's base address.  */
end_comment

begin_function
specifier|static
name|void
name|display_ptable_entry
parameter_list|(
name|unsigned
name|long
name|entry
parameter_list|,
name|int
name|is_dir
parameter_list|,
name|int
name|force
parameter_list|,
name|unsigned
name|off
parameter_list|)
block|{
if|if
condition|(
operator|(
name|entry
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Base=0x%05lx000"
argument_list|,
name|entry
operator|>>
literal|12
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|entry
operator|&
literal|0x100
operator|)
operator|&&
operator|!
name|is_dir
condition|)
name|puts_filtered
argument_list|(
literal|" Global"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|entry
operator|&
literal|0x40
operator|)
operator|&&
operator|!
name|is_dir
condition|)
name|puts_filtered
argument_list|(
literal|" Dirty"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" %sAcc."
argument_list|,
operator|(
name|entry
operator|&
literal|0x20
operator|)
condition|?
literal|""
else|:
literal|"Not-"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" %sCached"
argument_list|,
operator|(
name|entry
operator|&
literal|0x10
operator|)
condition|?
literal|""
else|:
literal|"Not-"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" Write-%s"
argument_list|,
operator|(
name|entry
operator|&
literal|8
operator|)
condition|?
literal|"Thru"
else|:
literal|"Back"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" %s"
argument_list|,
operator|(
name|entry
operator|&
literal|4
operator|)
condition|?
literal|"Usr"
else|:
literal|"Sup"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" Read-%s"
argument_list|,
operator|(
name|entry
operator|&
literal|2
operator|)
condition|?
literal|"Write"
else|:
literal|"Only"
argument_list|)
expr_stmt|;
if|if
condition|(
name|off
condition|)
name|printf_filtered
argument_list|(
literal|" +0x%x"
argument_list|,
name|off
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|force
condition|)
name|printf_filtered
argument_list|(
literal|"Page%s not present or not supported; value=0x%lx.\n"
argument_list|,
name|is_dir
condition|?
literal|" Table"
else|:
literal|""
argument_list|,
name|entry
operator|>>
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|go32_pde
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|long
name|pde_idx
init|=
operator|-
literal|1
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|arg
operator|&&
operator|*
name|arg
condition|)
block|{
while|while
condition|(
operator|*
name|arg
operator|&&
name|isspace
argument_list|(
operator|*
name|arg
argument_list|)
condition|)
name|arg
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|arg
condition|)
block|{
name|pde_idx
operator|=
name|parse_and_eval_long
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|pde_idx
operator|<
literal|0
operator|||
name|pde_idx
operator|>=
literal|1024
condition|)
name|error
argument_list|(
literal|"Entry %ld is outside valid limits [0..1023]."
argument_list|,
name|pde_idx
argument_list|)
expr_stmt|;
block|}
block|}
name|pdbr
operator|=
name|get_cr3
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|pdbr
condition|)
name|puts_filtered
argument_list|(
literal|"Access to Page Directories is not supported on this system.\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pde_idx
operator|>=
literal|0
condition|)
name|display_ptable_entry
argument_list|(
name|get_pde
argument_list|(
name|pde_idx
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|1024
condition|;
name|i
operator|++
control|)
name|display_ptable_entry
argument_list|(
name|get_pde
argument_list|(
name|i
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A helper function to display entries in a Page Table pointed to by    the N'th entry in the Page Directory.  If FORCE is non-zero, say    something even if the Page Table is not accessible.  */
end_comment

begin_function
specifier|static
name|void
name|display_page_table
parameter_list|(
name|long
name|n
parameter_list|,
name|int
name|force
parameter_list|)
block|{
name|unsigned
name|long
name|pde
init|=
name|get_pde
argument_list|(
name|n
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|pde
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
name|printf_filtered
argument_list|(
literal|"Page Table pointed to by Page Directory entry 0x%lx:\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|1024
condition|;
name|i
operator|++
control|)
name|display_ptable_entry
argument_list|(
name|get_pte
argument_list|(
name|pde
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|force
condition|)
name|printf_filtered
argument_list|(
literal|"Page Table not present; value=0x%lx.\n"
argument_list|,
name|pde
operator|>>
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|go32_pte
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|long
name|pde_idx
init|=
operator|-
literal|1L
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|arg
operator|&&
operator|*
name|arg
condition|)
block|{
while|while
condition|(
operator|*
name|arg
operator|&&
name|isspace
argument_list|(
operator|*
name|arg
argument_list|)
condition|)
name|arg
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|arg
condition|)
block|{
name|pde_idx
operator|=
name|parse_and_eval_long
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|pde_idx
operator|<
literal|0
operator|||
name|pde_idx
operator|>=
literal|1024
condition|)
name|error
argument_list|(
literal|"Entry %ld is outside valid limits [0..1023]."
argument_list|,
name|pde_idx
argument_list|)
expr_stmt|;
block|}
block|}
name|pdbr
operator|=
name|get_cr3
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|pdbr
condition|)
name|puts_filtered
argument_list|(
literal|"Access to Page Tables is not supported on this system.\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pde_idx
operator|>=
literal|0
condition|)
name|display_page_table
argument_list|(
name|pde_idx
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|1024
condition|;
name|i
operator|++
control|)
name|display_page_table
argument_list|(
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|go32_pte_for_address
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|CORE_ADDR
name|addr
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|arg
operator|&&
operator|*
name|arg
condition|)
block|{
while|while
condition|(
operator|*
name|arg
operator|&&
name|isspace
argument_list|(
operator|*
name|arg
argument_list|)
condition|)
name|arg
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|arg
condition|)
name|addr
operator|=
name|parse_and_eval_address
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|addr
condition|)
name|error_no_arg
argument_list|(
literal|"linear address"
argument_list|)
expr_stmt|;
name|pdbr
operator|=
name|get_cr3
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|pdbr
condition|)
name|puts_filtered
argument_list|(
literal|"Access to Page Tables is not supported on this system.\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|pde_idx
init|=
operator|(
name|addr
operator|>>
literal|22
operator|)
operator|&
literal|0x3ff
decl_stmt|;
name|int
name|pte_idx
init|=
operator|(
name|addr
operator|>>
literal|12
operator|)
operator|&
literal|0x3ff
decl_stmt|;
name|unsigned
name|offs
init|=
name|addr
operator|&
literal|0xfff
decl_stmt|;
name|printf_filtered
argument_list|(
literal|"Page Table entry for address 0x%llx:\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|addr
argument_list|)
expr_stmt|;
name|display_ptable_entry
argument_list|(
name|get_pte
argument_list|(
name|get_pde
argument_list|(
name|pde_idx
argument_list|)
argument_list|,
name|pte_idx
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|offs
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|cmd_list_element
modifier|*
name|info_dos_cmdlist
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|go32_info_dos_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|help_list
argument_list|(
name|info_dos_cmdlist
argument_list|,
literal|"info dos "
argument_list|,
name|class_info
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_initialize_go32_nat
parameter_list|(
name|void
parameter_list|)
block|{
name|init_go32_ops
argument_list|()
expr_stmt|;
name|add_target
argument_list|(
operator|&
name|go32_ops
argument_list|)
expr_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"dos"
argument_list|,
name|class_info
argument_list|,
name|go32_info_dos_command
argument_list|,
literal|"Print information specific to DJGPP (aka MS-DOS) debugging."
argument_list|,
operator|&
name|info_dos_cmdlist
argument_list|,
literal|"info dos "
argument_list|,
literal|0
argument_list|,
operator|&
name|infolist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"sysinfo"
argument_list|,
name|class_info
argument_list|,
name|go32_sysinfo
argument_list|,
literal|"Display information about the target system, including CPU, OS, DPMI, etc."
argument_list|,
operator|&
name|info_dos_cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"ldt"
argument_list|,
name|class_info
argument_list|,
name|go32_sldt
argument_list|,
literal|"Display entries in the LDT (Local Descriptor Table).\n"
literal|"Entry number (an expression) as an argument means display only that entry."
argument_list|,
operator|&
name|info_dos_cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"gdt"
argument_list|,
name|class_info
argument_list|,
name|go32_sgdt
argument_list|,
literal|"Display entries in the GDT (Global Descriptor Table).\n"
literal|"Entry number (an expression) as an argument means display only that entry."
argument_list|,
operator|&
name|info_dos_cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"idt"
argument_list|,
name|class_info
argument_list|,
name|go32_sidt
argument_list|,
literal|"Display entries in the IDT (Interrupt Descriptor Table).\n"
literal|"Entry number (an expression) as an argument means display only that entry."
argument_list|,
operator|&
name|info_dos_cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"pde"
argument_list|,
name|class_info
argument_list|,
name|go32_pde
argument_list|,
literal|"Display entries in the Page Directory.\n"
literal|"Entry number (an expression) as an argument means display only that entry."
argument_list|,
operator|&
name|info_dos_cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"pte"
argument_list|,
name|class_info
argument_list|,
name|go32_pte
argument_list|,
literal|"Display entries in Page Tables.\n"
literal|"Entry number (an expression) as an argument means display only entries\n"
literal|"from the Page Table pointed to by the specified Page Directory entry."
argument_list|,
operator|&
name|info_dos_cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"address-pte"
argument_list|,
name|class_info
argument_list|,
name|go32_pte_for_address
argument_list|,
literal|"Display a Page Table entry for a linear address.\n"
literal|"The address argument must be a linear address, after adding to\n"
literal|"it the base address of the appropriate segment.\n"
literal|"The base address of variables and functions in the debuggee's data\n"
literal|"or code segment is stored in the variable __djgpp_base_address,\n"
literal|"so use `__djgpp_base_address + (char *)&var' as the argument.\n"
literal|"For other segments, look up their base address in the output of\n"
literal|"the `info dos ldt' command."
argument_list|,
operator|&
name|info_dos_cmdlist
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|pid_t
name|tcgetpgrp
parameter_list|(
name|int
name|fd
parameter_list|)
block|{
if|if
condition|(
name|isatty
argument_list|(
name|fd
argument_list|)
condition|)
return|return
name|SOME_PID
return|;
name|errno
operator|=
name|ENOTTY
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|int
name|tcsetpgrp
parameter_list|(
name|int
name|fd
parameter_list|,
name|pid_t
name|pgid
parameter_list|)
block|{
if|if
condition|(
name|isatty
argument_list|(
name|fd
argument_list|)
operator|&&
name|pgid
operator|==
name|SOME_PID
condition|)
return|return
literal|0
return|;
name|errno
operator|=
name|pgid
operator|==
name|SOME_PID
condition|?
name|ENOTTY
else|:
name|ENOSYS
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

end_unit

