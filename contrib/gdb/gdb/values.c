begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Low level packing and unpacking of values for GDB, the GNU Debugger.    Copyright 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994,    1995, 1996, 1997, 1998, 1999, 2000, 2002.    Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"scm-lang.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_include
include|#
directive|include
file|"doublest.h"
end_include

begin_include
include|#
directive|include
file|"gdb_assert.h"
end_include

begin_comment
comment|/* Prototypes for exported functions. */
end_comment

begin_function_decl
name|void
name|_initialize_values
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Prototypes for local functions. */
end_comment

begin_function_decl
specifier|static
name|struct
name|value
modifier|*
name|value_headof
parameter_list|(
name|struct
name|value
modifier|*
parameter_list|,
name|struct
name|type
modifier|*
parameter_list|,
name|struct
name|type
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|show_values
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|show_convenience
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* The value-history records all the values printed    by print commands during this session.  Each chunk    records 60 consecutive values.  The first chunk on    the chain records the most recent values.    The total number of values is in value_history_count.  */
end_comment

begin_define
define|#
directive|define
name|VALUE_HISTORY_CHUNK
value|60
end_define

begin_struct
struct|struct
name|value_history_chunk
block|{
name|struct
name|value_history_chunk
modifier|*
name|next
decl_stmt|;
name|struct
name|value
modifier|*
name|values
index|[
name|VALUE_HISTORY_CHUNK
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Chain of chunks now in use.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|value_history_chunk
modifier|*
name|value_history_chain
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|value_history_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Abs number of last entry stored */
end_comment

begin_escape
end_escape

begin_comment
comment|/* List of all value objects currently allocated    (except for those released by calls to release_value)    This is so they can be freed after each command.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|value
modifier|*
name|all_values
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Allocate a  value  that has the correct length for type TYPE.  */
end_comment

begin_function
name|struct
name|value
modifier|*
name|allocate_value
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
name|struct
name|value
modifier|*
name|val
decl_stmt|;
name|struct
name|type
modifier|*
name|atype
init|=
name|check_typedef
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|val
operator|=
operator|(
expr|struct
name|value
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|value
argument_list|)
operator|+
name|TYPE_LENGTH
argument_list|(
name|atype
argument_list|)
argument_list|)
expr_stmt|;
name|VALUE_NEXT
argument_list|(
name|val
argument_list|)
operator|=
name|all_values
expr_stmt|;
name|all_values
operator|=
name|val
expr_stmt|;
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
operator|=
name|type
expr_stmt|;
name|VALUE_ENCLOSING_TYPE
argument_list|(
name|val
argument_list|)
operator|=
name|type
expr_stmt|;
name|VALUE_LVAL
argument_list|(
name|val
argument_list|)
operator|=
name|not_lval
expr_stmt|;
name|VALUE_ADDRESS
argument_list|(
name|val
argument_list|)
operator|=
literal|0
expr_stmt|;
name|VALUE_FRAME
argument_list|(
name|val
argument_list|)
operator|=
literal|0
expr_stmt|;
name|VALUE_OFFSET
argument_list|(
name|val
argument_list|)
operator|=
literal|0
expr_stmt|;
name|VALUE_BITPOS
argument_list|(
name|val
argument_list|)
operator|=
literal|0
expr_stmt|;
name|VALUE_BITSIZE
argument_list|(
name|val
argument_list|)
operator|=
literal|0
expr_stmt|;
name|VALUE_REGNO
argument_list|(
name|val
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
name|VALUE_LAZY
argument_list|(
name|val
argument_list|)
operator|=
literal|0
expr_stmt|;
name|VALUE_OPTIMIZED_OUT
argument_list|(
name|val
argument_list|)
operator|=
literal|0
expr_stmt|;
name|VALUE_BFD_SECTION
argument_list|(
name|val
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|VALUE_EMBEDDED_OFFSET
argument_list|(
name|val
argument_list|)
operator|=
literal|0
expr_stmt|;
name|VALUE_POINTED_TO_OFFSET
argument_list|(
name|val
argument_list|)
operator|=
literal|0
expr_stmt|;
name|val
operator|->
name|modifiable
operator|=
literal|1
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Allocate a  value  that has the correct length    for COUNT repetitions type TYPE.  */
end_comment

begin_function
name|struct
name|value
modifier|*
name|allocate_repeat_value
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|int
name|low_bound
init|=
name|current_language
operator|->
name|string_lower_bound
decl_stmt|;
comment|/* ??? */
comment|/* FIXME-type-allocation: need a way to free this type when we are      done with it.  */
name|struct
name|type
modifier|*
name|range_type
init|=
name|create_range_type
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|)
name|NULL
argument_list|,
name|builtin_type_int
argument_list|,
name|low_bound
argument_list|,
name|count
operator|+
name|low_bound
operator|-
literal|1
argument_list|)
decl_stmt|;
comment|/* FIXME-type-allocation: need a way to free this type when we are      done with it.  */
return|return
name|allocate_value
argument_list|(
name|create_array_type
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|)
name|NULL
argument_list|,
name|type
argument_list|,
name|range_type
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return a mark in the value chain.  All values allocated after the    mark is obtained (except for those released) are subject to being freed    if a subsequent value_free_to_mark is passed the mark.  */
end_comment

begin_function
name|struct
name|value
modifier|*
name|value_mark
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|all_values
return|;
block|}
end_function

begin_comment
comment|/* Free all values allocated since MARK was obtained by value_mark    (except for those released).  */
end_comment

begin_function
name|void
name|value_free_to_mark
parameter_list|(
name|struct
name|value
modifier|*
name|mark
parameter_list|)
block|{
name|struct
name|value
modifier|*
name|val
decl_stmt|;
name|struct
name|value
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|val
operator|=
name|all_values
init|;
name|val
operator|&&
name|val
operator|!=
name|mark
condition|;
name|val
operator|=
name|next
control|)
block|{
name|next
operator|=
name|VALUE_NEXT
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|value_free
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
name|all_values
operator|=
name|val
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free all the values that have been allocated (except for those released).    Called after each command, successful or not.  */
end_comment

begin_function
name|void
name|free_all_values
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|value
modifier|*
name|val
decl_stmt|;
name|struct
name|value
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|val
operator|=
name|all_values
init|;
name|val
condition|;
name|val
operator|=
name|next
control|)
block|{
name|next
operator|=
name|VALUE_NEXT
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|value_free
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
name|all_values
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove VAL from the chain all_values    so it will not be freed automatically.  */
end_comment

begin_function
name|void
name|release_value
parameter_list|(
name|struct
name|value
modifier|*
name|val
parameter_list|)
block|{
name|struct
name|value
modifier|*
name|v
decl_stmt|;
if|if
condition|(
name|all_values
operator|==
name|val
condition|)
block|{
name|all_values
operator|=
name|val
operator|->
name|next
expr_stmt|;
return|return;
block|}
for|for
control|(
name|v
operator|=
name|all_values
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|next
control|)
block|{
if|if
condition|(
name|v
operator|->
name|next
operator|==
name|val
condition|)
block|{
name|v
operator|->
name|next
operator|=
name|val
operator|->
name|next
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Release all values up to mark  */
end_comment

begin_function
name|struct
name|value
modifier|*
name|value_release_to_mark
parameter_list|(
name|struct
name|value
modifier|*
name|mark
parameter_list|)
block|{
name|struct
name|value
modifier|*
name|val
decl_stmt|;
name|struct
name|value
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|val
operator|=
name|next
operator|=
name|all_values
init|;
name|next
condition|;
name|next
operator|=
name|VALUE_NEXT
argument_list|(
name|next
argument_list|)
control|)
if|if
condition|(
name|VALUE_NEXT
argument_list|(
name|next
argument_list|)
operator|==
name|mark
condition|)
block|{
name|all_values
operator|=
name|VALUE_NEXT
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|VALUE_NEXT
argument_list|(
name|next
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|val
return|;
block|}
name|all_values
operator|=
literal|0
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Return a copy of the value ARG.    It contains the same contents, for same memory address,    but it's a different block of storage.  */
end_comment

begin_function
name|struct
name|value
modifier|*
name|value_copy
parameter_list|(
name|struct
name|value
modifier|*
name|arg
parameter_list|)
block|{
specifier|register
name|struct
name|type
modifier|*
name|encl_type
init|=
name|VALUE_ENCLOSING_TYPE
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|struct
name|value
modifier|*
name|val
init|=
name|allocate_value
argument_list|(
name|encl_type
argument_list|)
decl_stmt|;
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
operator|=
name|VALUE_TYPE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|VALUE_LVAL
argument_list|(
name|val
argument_list|)
operator|=
name|VALUE_LVAL
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|VALUE_ADDRESS
argument_list|(
name|val
argument_list|)
operator|=
name|VALUE_ADDRESS
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|VALUE_OFFSET
argument_list|(
name|val
argument_list|)
operator|=
name|VALUE_OFFSET
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|VALUE_BITPOS
argument_list|(
name|val
argument_list|)
operator|=
name|VALUE_BITPOS
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|VALUE_BITSIZE
argument_list|(
name|val
argument_list|)
operator|=
name|VALUE_BITSIZE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|VALUE_FRAME
argument_list|(
name|val
argument_list|)
operator|=
name|VALUE_FRAME
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|VALUE_REGNO
argument_list|(
name|val
argument_list|)
operator|=
name|VALUE_REGNO
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|VALUE_LAZY
argument_list|(
name|val
argument_list|)
operator|=
name|VALUE_LAZY
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|VALUE_OPTIMIZED_OUT
argument_list|(
name|val
argument_list|)
operator|=
name|VALUE_OPTIMIZED_OUT
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|VALUE_EMBEDDED_OFFSET
argument_list|(
name|val
argument_list|)
operator|=
name|VALUE_EMBEDDED_OFFSET
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|VALUE_POINTED_TO_OFFSET
argument_list|(
name|val
argument_list|)
operator|=
name|VALUE_POINTED_TO_OFFSET
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|VALUE_BFD_SECTION
argument_list|(
name|val
argument_list|)
operator|=
name|VALUE_BFD_SECTION
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|val
operator|->
name|modifiable
operator|=
name|arg
operator|->
name|modifiable
expr_stmt|;
if|if
condition|(
operator|!
name|VALUE_LAZY
argument_list|(
name|val
argument_list|)
condition|)
block|{
name|memcpy
argument_list|(
name|VALUE_CONTENTS_ALL_RAW
argument_list|(
name|val
argument_list|)
argument_list|,
name|VALUE_CONTENTS_ALL_RAW
argument_list|(
name|arg
argument_list|)
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|VALUE_ENCLOSING_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Access to the value history.  */
end_comment

begin_comment
comment|/* Record a new value in the value history.    Returns the absolute history index of the entry.    Result of -1 indicates the value was not saved; otherwise it is the    value history index of this new item.  */
end_comment

begin_function
name|int
name|record_latest_value
parameter_list|(
name|struct
name|value
modifier|*
name|val
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* We don't want this value to have anything to do with the inferior anymore.      In particular, "set $1 = 50" should not affect the variable from which      the value was taken, and fast watchpoints should be able to assume that      a value on the value history never changes.  */
if|if
condition|(
name|VALUE_LAZY
argument_list|(
name|val
argument_list|)
condition|)
name|value_fetch_lazy
argument_list|(
name|val
argument_list|)
expr_stmt|;
comment|/* We preserve VALUE_LVAL so that the user can find out where it was fetched      from.  This is a bit dubious, because then *&$1 does not just return $1      but the current contents of that location.  c'est la vie...  */
name|val
operator|->
name|modifiable
operator|=
literal|0
expr_stmt|;
name|release_value
argument_list|(
name|val
argument_list|)
expr_stmt|;
comment|/* Here we treat value_history_count as origin-zero      and applying to the value being stored now.  */
name|i
operator|=
name|value_history_count
operator|%
name|VALUE_HISTORY_CHUNK
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|struct
name|value_history_chunk
modifier|*
name|new
init|=
operator|(
expr|struct
name|value_history_chunk
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|value_history_chunk
argument_list|)
argument_list|)
decl_stmt|;
name|memset
argument_list|(
name|new
operator|->
name|values
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|new
operator|->
name|values
argument_list|)
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|value_history_chain
expr_stmt|;
name|value_history_chain
operator|=
name|new
expr_stmt|;
block|}
name|value_history_chain
operator|->
name|values
index|[
name|i
index|]
operator|=
name|val
expr_stmt|;
comment|/* Now we regard value_history_count as origin-one      and applying to the value just stored.  */
return|return
operator|++
name|value_history_count
return|;
block|}
end_function

begin_comment
comment|/* Return a copy of the value in the history with sequence number NUM.  */
end_comment

begin_function
name|struct
name|value
modifier|*
name|access_value_history
parameter_list|(
name|int
name|num
parameter_list|)
block|{
name|struct
name|value_history_chunk
modifier|*
name|chunk
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|absnum
init|=
name|num
decl_stmt|;
if|if
condition|(
name|absnum
operator|<=
literal|0
condition|)
name|absnum
operator|+=
name|value_history_count
expr_stmt|;
if|if
condition|(
name|absnum
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|num
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"The history is empty."
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|num
operator|==
literal|1
condition|)
name|error
argument_list|(
literal|"There is only one value in the history."
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"History does not go back to $$%d."
argument_list|,
operator|-
name|num
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|absnum
operator|>
name|value_history_count
condition|)
name|error
argument_list|(
literal|"History has not yet reached $%d."
argument_list|,
name|absnum
argument_list|)
expr_stmt|;
name|absnum
operator|--
expr_stmt|;
comment|/* Now absnum is always absolute and origin zero.  */
name|chunk
operator|=
name|value_history_chain
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|(
name|value_history_count
operator|-
literal|1
operator|)
operator|/
name|VALUE_HISTORY_CHUNK
operator|-
name|absnum
operator|/
name|VALUE_HISTORY_CHUNK
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
name|chunk
operator|=
name|chunk
operator|->
name|next
expr_stmt|;
return|return
name|value_copy
argument_list|(
name|chunk
operator|->
name|values
index|[
name|absnum
operator|%
name|VALUE_HISTORY_CHUNK
index|]
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Clear the value history entirely.    Must be done when new symbol tables are loaded,    because the type pointers become invalid.  */
end_comment

begin_function
name|void
name|clear_value_history
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|value_history_chunk
modifier|*
name|next
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|struct
name|value
modifier|*
name|val
decl_stmt|;
while|while
condition|(
name|value_history_chain
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|VALUE_HISTORY_CHUNK
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|val
operator|=
name|value_history_chain
operator|->
name|values
index|[
name|i
index|]
operator|)
operator|!=
name|NULL
condition|)
name|xfree
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|next
operator|=
name|value_history_chain
operator|->
name|next
expr_stmt|;
name|xfree
argument_list|(
name|value_history_chain
argument_list|)
expr_stmt|;
name|value_history_chain
operator|=
name|next
expr_stmt|;
block|}
name|value_history_count
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|show_values
parameter_list|(
name|char
modifier|*
name|num_exp
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|struct
name|value
modifier|*
name|val
decl_stmt|;
specifier|static
name|int
name|num
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|num_exp
condition|)
block|{
comment|/* "info history +" should print from the stored position.          "info history<exp>" should print around value number<exp>.  */
if|if
condition|(
name|num_exp
index|[
literal|0
index|]
operator|!=
literal|'+'
operator|||
name|num_exp
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
name|num
operator|=
name|parse_and_eval_long
argument_list|(
name|num_exp
argument_list|)
operator|-
literal|5
expr_stmt|;
block|}
else|else
block|{
comment|/* "info history" means print the last 10 values.  */
name|num
operator|=
name|value_history_count
operator|-
literal|9
expr_stmt|;
block|}
if|if
condition|(
name|num
operator|<=
literal|0
condition|)
name|num
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|num
init|;
name|i
operator|<
name|num
operator|+
literal|10
operator|&&
name|i
operator|<=
name|value_history_count
condition|;
name|i
operator|++
control|)
block|{
name|val
operator|=
name|access_value_history
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"$%d = "
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|value_print
argument_list|(
name|val
argument_list|,
name|gdb_stdout
argument_list|,
literal|0
argument_list|,
name|Val_pretty_default
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* The next "info history +" should start after what we just printed.  */
name|num
operator|+=
literal|10
expr_stmt|;
comment|/* Hitting just return after this command should do the same thing as      "info history +".  If num_exp is null, this is unnecessary, since      "info history +" is not useful after "info history".  */
if|if
condition|(
name|from_tty
operator|&&
name|num_exp
condition|)
block|{
name|num_exp
index|[
literal|0
index|]
operator|=
literal|'+'
expr_stmt|;
name|num_exp
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Internal variables.  These are variables within the debugger    that hold values assigned by debugger commands.    The user refers to them with a '$' prefix    that does not appear in the variable names stored internally.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|internalvar
modifier|*
name|internalvars
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Look up an internal variable with name NAME.  NAME should not    normally include a dollar sign.     If the specified internal variable does not exist,    one is created, with a void value.  */
end_comment

begin_function
name|struct
name|internalvar
modifier|*
name|lookup_internalvar
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|register
name|struct
name|internalvar
modifier|*
name|var
decl_stmt|;
for|for
control|(
name|var
operator|=
name|internalvars
init|;
name|var
condition|;
name|var
operator|=
name|var
operator|->
name|next
control|)
if|if
condition|(
name|STREQ
argument_list|(
name|var
operator|->
name|name
argument_list|,
name|name
argument_list|)
condition|)
return|return
name|var
return|;
name|var
operator|=
operator|(
expr|struct
name|internalvar
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|internalvar
argument_list|)
argument_list|)
expr_stmt|;
name|var
operator|->
name|name
operator|=
name|concat
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|var
operator|->
name|value
operator|=
name|allocate_value
argument_list|(
name|builtin_type_void
argument_list|)
expr_stmt|;
name|release_value
argument_list|(
name|var
operator|->
name|value
argument_list|)
expr_stmt|;
name|var
operator|->
name|next
operator|=
name|internalvars
expr_stmt|;
name|internalvars
operator|=
name|var
expr_stmt|;
return|return
name|var
return|;
block|}
end_function

begin_function
name|struct
name|value
modifier|*
name|value_of_internalvar
parameter_list|(
name|struct
name|internalvar
modifier|*
name|var
parameter_list|)
block|{
name|struct
name|value
modifier|*
name|val
decl_stmt|;
ifdef|#
directive|ifdef
name|IS_TRAPPED_INTERNALVAR
if|if
condition|(
name|IS_TRAPPED_INTERNALVAR
argument_list|(
name|var
operator|->
name|name
argument_list|)
condition|)
return|return
name|VALUE_OF_TRAPPED_INTERNALVAR
argument_list|(
name|var
argument_list|)
return|;
endif|#
directive|endif
name|val
operator|=
name|value_copy
argument_list|(
name|var
operator|->
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|VALUE_LAZY
argument_list|(
name|val
argument_list|)
condition|)
name|value_fetch_lazy
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|VALUE_LVAL
argument_list|(
name|val
argument_list|)
operator|=
name|lval_internalvar
expr_stmt|;
name|VALUE_INTERNALVAR
argument_list|(
name|val
argument_list|)
operator|=
name|var
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
name|void
name|set_internalvar_component
parameter_list|(
name|struct
name|internalvar
modifier|*
name|var
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|bitpos
parameter_list|,
name|int
name|bitsize
parameter_list|,
name|struct
name|value
modifier|*
name|newval
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|addr
init|=
name|VALUE_CONTENTS
argument_list|(
name|var
operator|->
name|value
argument_list|)
operator|+
name|offset
decl_stmt|;
ifdef|#
directive|ifdef
name|IS_TRAPPED_INTERNALVAR
if|if
condition|(
name|IS_TRAPPED_INTERNALVAR
argument_list|(
name|var
operator|->
name|name
argument_list|)
condition|)
name|SET_TRAPPED_INTERNALVAR
argument_list|(
name|var
argument_list|,
name|newval
argument_list|,
name|bitpos
argument_list|,
name|bitsize
argument_list|,
name|offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|bitsize
condition|)
name|modify_field
argument_list|(
name|addr
argument_list|,
name|value_as_long
argument_list|(
name|newval
argument_list|)
argument_list|,
name|bitpos
argument_list|,
name|bitsize
argument_list|)
expr_stmt|;
else|else
name|memcpy
argument_list|(
name|addr
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|newval
argument_list|)
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|newval
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|set_internalvar
parameter_list|(
name|struct
name|internalvar
modifier|*
name|var
parameter_list|,
name|struct
name|value
modifier|*
name|val
parameter_list|)
block|{
name|struct
name|value
modifier|*
name|newval
decl_stmt|;
ifdef|#
directive|ifdef
name|IS_TRAPPED_INTERNALVAR
if|if
condition|(
name|IS_TRAPPED_INTERNALVAR
argument_list|(
name|var
operator|->
name|name
argument_list|)
condition|)
name|SET_TRAPPED_INTERNALVAR
argument_list|(
name|var
argument_list|,
name|val
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|newval
operator|=
name|value_copy
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|newval
operator|->
name|modifiable
operator|=
literal|1
expr_stmt|;
comment|/* Force the value to be fetched from the target now, to avoid problems      later when this internalvar is referenced and the target is gone or      has changed.  */
if|if
condition|(
name|VALUE_LAZY
argument_list|(
name|newval
argument_list|)
condition|)
name|value_fetch_lazy
argument_list|(
name|newval
argument_list|)
expr_stmt|;
comment|/* Begin code which must not call error().  If var->value points to      something free'd, an error() obviously leaves a dangling pointer.      But we also get a danling pointer if var->value points to      something in the value chain (i.e., before release_value is      called), because after the error free_all_values will get called before      long.  */
name|xfree
argument_list|(
name|var
operator|->
name|value
argument_list|)
expr_stmt|;
name|var
operator|->
name|value
operator|=
name|newval
expr_stmt|;
name|release_value
argument_list|(
name|newval
argument_list|)
expr_stmt|;
comment|/* End code which must not call error().  */
block|}
end_function

begin_function
name|char
modifier|*
name|internalvar_name
parameter_list|(
name|struct
name|internalvar
modifier|*
name|var
parameter_list|)
block|{
return|return
name|var
operator|->
name|name
return|;
block|}
end_function

begin_comment
comment|/* Free all internalvars.  Done when new symtabs are loaded,    because that makes the values invalid.  */
end_comment

begin_function
name|void
name|clear_internalvars
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|struct
name|internalvar
modifier|*
name|var
decl_stmt|;
while|while
condition|(
name|internalvars
condition|)
block|{
name|var
operator|=
name|internalvars
expr_stmt|;
name|internalvars
operator|=
name|var
operator|->
name|next
expr_stmt|;
name|xfree
argument_list|(
name|var
operator|->
name|name
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|var
operator|->
name|value
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|var
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|show_convenience
parameter_list|(
name|char
modifier|*
name|ignore
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
specifier|register
name|struct
name|internalvar
modifier|*
name|var
decl_stmt|;
name|int
name|varseen
init|=
literal|0
decl_stmt|;
for|for
control|(
name|var
operator|=
name|internalvars
init|;
name|var
condition|;
name|var
operator|=
name|var
operator|->
name|next
control|)
block|{
ifdef|#
directive|ifdef
name|IS_TRAPPED_INTERNALVAR
if|if
condition|(
name|IS_TRAPPED_INTERNALVAR
argument_list|(
name|var
operator|->
name|name
argument_list|)
condition|)
continue|continue;
endif|#
directive|endif
if|if
condition|(
operator|!
name|varseen
condition|)
block|{
name|varseen
operator|=
literal|1
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|"$%s = "
argument_list|,
name|var
operator|->
name|name
argument_list|)
expr_stmt|;
name|value_print
argument_list|(
name|var
operator|->
name|value
argument_list|,
name|gdb_stdout
argument_list|,
literal|0
argument_list|,
name|Val_pretty_default
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|varseen
condition|)
name|printf_unfiltered
argument_list|(
literal|"No debugger convenience variables now defined.\n\ Convenience variables have names starting with \"$\";\n\ use \"set\" as in \"set $foo = 5\" to define them.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Extract a value as a C number (either long or double).    Knows how to convert fixed values to double, or    floating values to long.    Does not deallocate the value.  */
end_comment

begin_function
name|LONGEST
name|value_as_long
parameter_list|(
name|struct
name|value
modifier|*
name|val
parameter_list|)
block|{
comment|/* This coerces arrays and functions, which is necessary (e.g.      in disassemble_command).  It also dereferences references, which      I suspect is the most logical thing to do.  */
name|COERCE_ARRAY
argument_list|(
name|val
argument_list|)
expr_stmt|;
return|return
name|unpack_long
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|val
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|DOUBLEST
name|value_as_double
parameter_list|(
name|struct
name|value
modifier|*
name|val
parameter_list|)
block|{
name|DOUBLEST
name|foo
decl_stmt|;
name|int
name|inv
decl_stmt|;
name|foo
operator|=
name|unpack_double
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|val
argument_list|)
argument_list|,
operator|&
name|inv
argument_list|)
expr_stmt|;
if|if
condition|(
name|inv
condition|)
name|error
argument_list|(
literal|"Invalid floating value found in program."
argument_list|)
expr_stmt|;
return|return
name|foo
return|;
block|}
end_function

begin_comment
comment|/* Extract a value as a C pointer. Does not deallocate the value.      Note that val's type may not actually be a pointer; value_as_long    handles all the cases.  */
end_comment

begin_function
name|CORE_ADDR
name|value_as_address
parameter_list|(
name|struct
name|value
modifier|*
name|val
parameter_list|)
block|{
comment|/* Assume a CORE_ADDR can fit in a LONGEST (for now).  Not sure      whether we want this to be true eventually.  */
if|#
directive|if
literal|0
comment|/* ADDR_BITS_REMOVE is wrong if we are being called for a      non-address (e.g. argument to "signal", "info break", etc.), or      for pointers to char, in which the low bits *are* significant.  */
block|return ADDR_BITS_REMOVE (value_as_long (val));
else|#
directive|else
comment|/* There are several targets (IA-64, PowerPC, and others) which      don't represent pointers to functions as simply the address of      the function's entry point.  For example, on the IA-64, a      function pointer points to a two-word descriptor, generated by      the linker, which contains the function's entry point, and the      value the IA-64 "global pointer" register should have --- to      support position-independent code.  The linker generates      descriptors only for those functions whose addresses are taken.       On such targets, it's difficult for GDB to convert an arbitrary      function address into a function pointer; it has to either find      an existing descriptor for that function, or call malloc and      build its own.  On some targets, it is impossible for GDB to      build a descriptor at all: the descriptor must contain a jump      instruction; data memory cannot be executed; and code memory      cannot be modified.       Upon entry to this function, if VAL is a value of type `function'      (that is, TYPE_CODE (VALUE_TYPE (val)) == TYPE_CODE_FUNC), then      VALUE_ADDRESS (val) is the address of the function.  This is what      you'll get if you evaluate an expression like `main'.  The call      to COERCE_ARRAY below actually does all the usual unary      conversions, which includes converting values of type `function'      to `pointer to function'.  This is the challenging conversion      discussed above.  Then, `unpack_long' will convert that pointer      back into an address.       So, suppose the user types `disassemble foo' on an architecture      with a strange function pointer representation, on which GDB      cannot build its own descriptors, and suppose further that `foo'      has no linker-built descriptor.  The address->pointer conversion      will signal an error and prevent the command from running, even      though the next step would have been to convert the pointer      directly back into the same address.       The following shortcut avoids this whole mess.  If VAL is a      function, just return its address directly.  */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_FUNC
operator|||
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_METHOD
condition|)
return|return
name|VALUE_ADDRESS
argument_list|(
name|val
argument_list|)
return|;
name|COERCE_ARRAY
argument_list|(
name|val
argument_list|)
expr_stmt|;
comment|/* Some architectures (e.g. Harvard), map instruction and data      addresses onto a single large unified address space.  For      instance: An architecture may consider a large integer in the      range 0x10000000 .. 0x1000ffff to already represent a data      addresses (hence not need a pointer to address conversion) while      a small integer would still need to be converted integer to      pointer to address.  Just assume such architectures handle all      integer conversions in a single function.  */
comment|/* JimB writes:       I think INTEGER_TO_ADDRESS is a good idea as proposed --- but we      must admonish GDB hackers to make sure its behavior matches the      compiler's, whenever possible.       In general, I think GDB should evaluate expressions the same way      the compiler does.  When the user copies an expression out of      their source code and hands it to a `print' command, they should      get the same value the compiler would have computed.  Any      deviation from this rule can cause major confusion and annoyance,      and needs to be justified carefully.  In other words, GDB doesn't      really have the freedom to do these conversions in clever and      useful ways.       AndrewC pointed out that users aren't complaining about how GDB      casts integers to pointers; they are complaining that they can't      take an address from a disassembly listing and give it to `x/i'.      This is certainly important.       Adding an architecture method like INTEGER_TO_ADDRESS certainly      makes it possible for GDB to "get it right" in all circumstances      --- the target has complete control over how things get done, so      people can Do The Right Thing for their target without breaking      anyone else.  The standard doesn't specify how integers get      converted to pointers; usually, the ABI doesn't either, but      ABI-specific code is a more reasonable place to handle it.  */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|!=
name|TYPE_CODE_PTR
operator|&&
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|!=
name|TYPE_CODE_REF
operator|&&
name|INTEGER_TO_ADDRESS_P
argument_list|()
condition|)
return|return
name|INTEGER_TO_ADDRESS
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|val
argument_list|)
argument_list|)
return|;
return|return
name|unpack_long
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|val
argument_list|)
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Unpack raw data (copied from debugee, target byte order) at VALADDR    as a long, or as a double, assuming the raw data is described    by type TYPE.  Knows how to convert different sizes of values    and can convert between fixed and floating point.  We don't assume    any alignment for the raw data.  Return value is in host byte order.     If you want functions and arrays to be coerced to pointers, and    references to be dereferenced, call value_as_long() instead.     C++: It is assumed that the front-end has taken care of    all matters concerning pointers to members.  A pointer    to member which reaches here is considered to be equivalent    to an INT (or some size).  After all, it is only an offset.  */
end_comment

begin_function
name|LONGEST
name|unpack_long
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|char
modifier|*
name|valaddr
parameter_list|)
block|{
specifier|register
name|enum
name|type_code
name|code
init|=
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|register
name|int
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|register
name|int
name|nosign
init|=
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|current_language
operator|->
name|la_language
operator|==
name|language_scm
operator|&&
name|is_scmvalue_type
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|scm_unpack
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|,
name|TYPE_CODE_INT
argument_list|)
return|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|TYPE_CODE_TYPEDEF
case|:
return|return
name|unpack_long
argument_list|(
name|check_typedef
argument_list|(
name|type
argument_list|)
argument_list|,
name|valaddr
argument_list|)
return|;
case|case
name|TYPE_CODE_ENUM
case|:
case|case
name|TYPE_CODE_BOOL
case|:
case|case
name|TYPE_CODE_INT
case|:
case|case
name|TYPE_CODE_CHAR
case|:
case|case
name|TYPE_CODE_RANGE
case|:
if|if
condition|(
name|nosign
condition|)
return|return
name|extract_unsigned_integer
argument_list|(
name|valaddr
argument_list|,
name|len
argument_list|)
return|;
else|else
return|return
name|extract_signed_integer
argument_list|(
name|valaddr
argument_list|,
name|len
argument_list|)
return|;
case|case
name|TYPE_CODE_FLT
case|:
return|return
name|extract_typed_floating
argument_list|(
name|valaddr
argument_list|,
name|type
argument_list|)
return|;
case|case
name|TYPE_CODE_PTR
case|:
case|case
name|TYPE_CODE_REF
case|:
comment|/* Assume a CORE_ADDR can fit in a LONGEST (for now).  Not sure          whether we want this to be true eventually.  */
return|return
name|extract_typed_address
argument_list|(
name|valaddr
argument_list|,
name|type
argument_list|)
return|;
case|case
name|TYPE_CODE_MEMBER
case|:
name|error
argument_list|(
literal|"not implemented: member types in unpack_long"
argument_list|)
expr_stmt|;
default|default:
name|error
argument_list|(
literal|"Value can't be converted to integer."
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
comment|/* Placate lint.  */
block|}
end_function

begin_comment
comment|/* Return a double value from the specified type and address.    INVP points to an int which is set to 0 for valid value,    1 for invalid value (bad float format).  In either case,    the returned double is OK to use.  Argument is in target    format, result is in host format.  */
end_comment

begin_function
name|DOUBLEST
name|unpack_double
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|char
modifier|*
name|valaddr
parameter_list|,
name|int
modifier|*
name|invp
parameter_list|)
block|{
name|enum
name|type_code
name|code
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|nosign
decl_stmt|;
operator|*
name|invp
operator|=
literal|0
expr_stmt|;
comment|/* Assume valid.   */
name|CHECK_TYPEDEF
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|code
operator|=
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|len
operator|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|nosign
operator|=
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|TYPE_CODE_FLT
condition|)
block|{
comment|/* NOTE: cagney/2002-02-19: There was a test here to see if the 	 floating-point value was valid (using the macro 	 INVALID_FLOAT).  That test/macro have been removed.  	 It turns out that only the VAX defined this macro and then 	 only in a non-portable way.  Fixing the portability problem 	 wouldn't help since the VAX floating-point code is also badly 	 bit-rotten.  The target needs to add definitions for the 	 methods TARGET_FLOAT_FORMAT and TARGET_DOUBLE_FORMAT - these 	 exactly describe the target floating-point format.  The 	 problem here is that the corresponding floatformat_vax_f and 	 floatformat_vax_d values these methods should be set to are 	 also not defined either.  Oops!           Hopefully someone will add both the missing floatformat          definitions and floatformat_is_invalid() function.  */
return|return
name|extract_typed_floating
argument_list|(
name|valaddr
argument_list|,
name|type
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|nosign
condition|)
block|{
comment|/* Unsigned -- be sure we compensate for signed LONGEST.  */
return|return
operator|(
name|ULONGEST
operator|)
name|unpack_long
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|)
return|;
block|}
else|else
block|{
comment|/* Signed -- we are OK with unpack_long.  */
return|return
name|unpack_long
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Unpack raw data (copied from debugee, target byte order) at VALADDR    as a CORE_ADDR, assuming the raw data is described by type TYPE.    We don't assume any alignment for the raw data.  Return value is in    host byte order.     If you want functions and arrays to be coerced to pointers, and    references to be dereferenced, call value_as_address() instead.     C++: It is assumed that the front-end has taken care of    all matters concerning pointers to members.  A pointer    to member which reaches here is considered to be equivalent    to an INT (or some size).  After all, it is only an offset.  */
end_comment

begin_function
name|CORE_ADDR
name|unpack_pointer
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|char
modifier|*
name|valaddr
parameter_list|)
block|{
comment|/* Assume a CORE_ADDR can fit in a LONGEST (for now).  Not sure      whether we want this to be true eventually.  */
return|return
name|unpack_long
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Get the value of the FIELDN'th field (which must be static) of TYPE. */
end_comment

begin_function
name|struct
name|value
modifier|*
name|value_static_field
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|int
name|fieldno
parameter_list|)
block|{
name|CORE_ADDR
name|addr
decl_stmt|;
name|asection
modifier|*
name|sect
decl_stmt|;
if|if
condition|(
name|TYPE_FIELD_STATIC_HAS_ADDR
argument_list|(
name|type
argument_list|,
name|fieldno
argument_list|)
condition|)
block|{
name|addr
operator|=
name|TYPE_FIELD_STATIC_PHYSADDR
argument_list|(
name|type
argument_list|,
name|fieldno
argument_list|)
expr_stmt|;
name|sect
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|phys_name
init|=
name|TYPE_FIELD_STATIC_PHYSNAME
argument_list|(
name|type
argument_list|,
name|fieldno
argument_list|)
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
init|=
name|lookup_symbol
argument_list|(
name|phys_name
argument_list|,
literal|0
argument_list|,
name|VAR_NAMESPACE
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|sym
operator|==
name|NULL
condition|)
block|{
comment|/* With some compilers, e.g. HP aCC, static data members are reported 	     as non-debuggable symbols */
name|struct
name|minimal_symbol
modifier|*
name|msym
init|=
name|lookup_minimal_symbol
argument_list|(
name|phys_name
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|msym
condition|)
return|return
name|NULL
return|;
else|else
block|{
name|addr
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msym
argument_list|)
expr_stmt|;
name|sect
operator|=
name|SYMBOL_BFD_SECTION
argument_list|(
name|msym
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Anything static that isn't a constant, has an address */
if|if
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|!=
name|LOC_CONST
condition|)
block|{
name|addr
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|sect
operator|=
name|SYMBOL_BFD_SECTION
argument_list|(
name|sym
argument_list|)
expr_stmt|;
block|}
comment|/* However, static const's do not, the value is already known.  */
else|else
block|{
return|return
name|value_from_longest
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|fieldno
argument_list|)
argument_list|,
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
argument_list|)
return|;
block|}
block|}
name|SET_FIELD_PHYSADDR
argument_list|(
name|TYPE_FIELD
argument_list|(
name|type
argument_list|,
name|fieldno
argument_list|)
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
return|return
name|value_at
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|fieldno
argument_list|)
argument_list|,
name|addr
argument_list|,
name|sect
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Change the enclosing type of a value object VAL to NEW_ENCL_TYPE.      You have to be careful here, since the size of the data area for the value     is set by the length of the enclosing type.  So if NEW_ENCL_TYPE is bigger     than the old enclosing type, you have to allocate more space for the data.      The return value is a pointer to the new version of this value structure. */
end_comment

begin_function
name|struct
name|value
modifier|*
name|value_change_enclosing_type
parameter_list|(
name|struct
name|value
modifier|*
name|val
parameter_list|,
name|struct
name|type
modifier|*
name|new_encl_type
parameter_list|)
block|{
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|new_encl_type
argument_list|)
operator|<=
name|TYPE_LENGTH
argument_list|(
name|VALUE_ENCLOSING_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
condition|)
block|{
name|VALUE_ENCLOSING_TYPE
argument_list|(
name|val
argument_list|)
operator|=
name|new_encl_type
expr_stmt|;
return|return
name|val
return|;
block|}
else|else
block|{
name|struct
name|value
modifier|*
name|new_val
decl_stmt|;
name|struct
name|value
modifier|*
name|prev
decl_stmt|;
name|new_val
operator|=
operator|(
expr|struct
name|value
operator|*
operator|)
name|xrealloc
argument_list|(
name|val
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|value
argument_list|)
operator|+
name|TYPE_LENGTH
argument_list|(
name|new_encl_type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We have to make sure this ends up in the same place in the value 	 chain as the original copy, so it's clean-up behavior is the same.  	 If the value has been released, this is a waste of time, but there 	 is no way to tell that in advance, so... */
if|if
condition|(
name|val
operator|!=
name|all_values
condition|)
block|{
for|for
control|(
name|prev
operator|=
name|all_values
init|;
name|prev
operator|!=
name|NULL
condition|;
name|prev
operator|=
name|prev
operator|->
name|next
control|)
block|{
if|if
condition|(
name|prev
operator|->
name|next
operator|==
name|val
condition|)
block|{
name|prev
operator|->
name|next
operator|=
name|new_val
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return
name|new_val
return|;
block|}
block|}
end_function

begin_comment
comment|/* Given a value ARG1 (offset by OFFSET bytes)    of a struct or union type ARG_TYPE,    extract and return the value of one of its (non-static) fields.    FIELDNO says which field. */
end_comment

begin_function
name|struct
name|value
modifier|*
name|value_primitive_field
parameter_list|(
name|struct
name|value
modifier|*
name|arg1
parameter_list|,
name|int
name|offset
parameter_list|,
specifier|register
name|int
name|fieldno
parameter_list|,
specifier|register
name|struct
name|type
modifier|*
name|arg_type
parameter_list|)
block|{
name|struct
name|value
modifier|*
name|v
decl_stmt|;
specifier|register
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|CHECK_TYPEDEF
argument_list|(
name|arg_type
argument_list|)
expr_stmt|;
name|type
operator|=
name|TYPE_FIELD_TYPE
argument_list|(
name|arg_type
argument_list|,
name|fieldno
argument_list|)
expr_stmt|;
comment|/* Handle packed fields */
if|if
condition|(
name|TYPE_FIELD_BITSIZE
argument_list|(
name|arg_type
argument_list|,
name|fieldno
argument_list|)
condition|)
block|{
name|v
operator|=
name|value_from_longest
argument_list|(
name|type
argument_list|,
name|unpack_field_as_long
argument_list|(
name|arg_type
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|arg1
argument_list|)
operator|+
name|offset
argument_list|,
name|fieldno
argument_list|)
argument_list|)
expr_stmt|;
name|VALUE_BITPOS
argument_list|(
name|v
argument_list|)
operator|=
name|TYPE_FIELD_BITPOS
argument_list|(
name|arg_type
argument_list|,
name|fieldno
argument_list|)
operator|%
literal|8
expr_stmt|;
name|VALUE_BITSIZE
argument_list|(
name|v
argument_list|)
operator|=
name|TYPE_FIELD_BITSIZE
argument_list|(
name|arg_type
argument_list|,
name|fieldno
argument_list|)
expr_stmt|;
name|VALUE_OFFSET
argument_list|(
name|v
argument_list|)
operator|=
name|VALUE_OFFSET
argument_list|(
name|arg1
argument_list|)
operator|+
name|offset
operator|+
name|TYPE_FIELD_BITPOS
argument_list|(
name|arg_type
argument_list|,
name|fieldno
argument_list|)
operator|/
literal|8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fieldno
operator|<
name|TYPE_N_BASECLASSES
argument_list|(
name|arg_type
argument_list|)
condition|)
block|{
comment|/* This field is actually a base subobject, so preserve the          entire object's contents for later references to virtual          bases, etc.  */
name|v
operator|=
name|allocate_value
argument_list|(
name|VALUE_ENCLOSING_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
name|VALUE_TYPE
argument_list|(
name|v
argument_list|)
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|VALUE_LAZY
argument_list|(
name|arg1
argument_list|)
condition|)
name|VALUE_LAZY
argument_list|(
name|v
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
name|memcpy
argument_list|(
name|VALUE_CONTENTS_ALL_RAW
argument_list|(
name|v
argument_list|)
argument_list|,
name|VALUE_CONTENTS_ALL_RAW
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|VALUE_ENCLOSING_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|VALUE_OFFSET
argument_list|(
name|v
argument_list|)
operator|=
name|VALUE_OFFSET
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|VALUE_EMBEDDED_OFFSET
argument_list|(
name|v
argument_list|)
operator|=
name|offset
operator|+
name|VALUE_EMBEDDED_OFFSET
argument_list|(
name|arg1
argument_list|)
operator|+
name|TYPE_FIELD_BITPOS
argument_list|(
name|arg_type
argument_list|,
name|fieldno
argument_list|)
operator|/
literal|8
expr_stmt|;
block|}
else|else
block|{
comment|/* Plain old data member */
name|offset
operator|+=
name|TYPE_FIELD_BITPOS
argument_list|(
name|arg_type
argument_list|,
name|fieldno
argument_list|)
operator|/
literal|8
expr_stmt|;
name|v
operator|=
name|allocate_value
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|VALUE_LAZY
argument_list|(
name|arg1
argument_list|)
condition|)
name|VALUE_LAZY
argument_list|(
name|v
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
name|memcpy
argument_list|(
name|VALUE_CONTENTS_RAW
argument_list|(
name|v
argument_list|)
argument_list|,
name|VALUE_CONTENTS_RAW
argument_list|(
name|arg1
argument_list|)
operator|+
name|offset
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|VALUE_OFFSET
argument_list|(
name|v
argument_list|)
operator|=
name|VALUE_OFFSET
argument_list|(
name|arg1
argument_list|)
operator|+
name|offset
operator|+
name|VALUE_EMBEDDED_OFFSET
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
block|}
name|VALUE_LVAL
argument_list|(
name|v
argument_list|)
operator|=
name|VALUE_LVAL
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|VALUE_LVAL
argument_list|(
name|arg1
argument_list|)
operator|==
name|lval_internalvar
condition|)
name|VALUE_LVAL
argument_list|(
name|v
argument_list|)
operator|=
name|lval_internalvar_component
expr_stmt|;
name|VALUE_ADDRESS
argument_list|(
name|v
argument_list|)
operator|=
name|VALUE_ADDRESS
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|VALUE_REGNO
argument_list|(
name|v
argument_list|)
operator|=
name|VALUE_REGNO
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
comment|/*  VALUE_OFFSET (v) = VALUE_OFFSET (arg1) + offset    + TYPE_FIELD_BITPOS (arg_type, fieldno) / 8; */
return|return
name|v
return|;
block|}
end_function

begin_comment
comment|/* Given a value ARG1 of a struct or union type,    extract and return the value of one of its (non-static) fields.    FIELDNO says which field. */
end_comment

begin_function
name|struct
name|value
modifier|*
name|value_field
parameter_list|(
name|struct
name|value
modifier|*
name|arg1
parameter_list|,
specifier|register
name|int
name|fieldno
parameter_list|)
block|{
return|return
name|value_primitive_field
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|,
name|fieldno
argument_list|,
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return a non-virtual function as a value.    F is the list of member functions which contains the desired method.    J is an index into F which provides the desired method.     We only use the symbol for its address, so be happy with either a    full symbol or a minimal symbol.  */
end_comment

begin_function
name|struct
name|value
modifier|*
name|value_fn_field
parameter_list|(
name|struct
name|value
modifier|*
modifier|*
name|arg1p
parameter_list|,
name|struct
name|fn_field
modifier|*
name|f
parameter_list|,
name|int
name|j
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
name|struct
name|value
modifier|*
name|v
decl_stmt|;
specifier|register
name|struct
name|type
modifier|*
name|ftype
init|=
name|TYPE_FN_FIELD_TYPE
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
decl_stmt|;
name|char
modifier|*
name|physname
init|=
name|TYPE_FN_FIELD_PHYSNAME
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|msym
decl_stmt|;
name|sym
operator|=
name|lookup_symbol
argument_list|(
name|physname
argument_list|,
literal|0
argument_list|,
name|VAR_NAMESPACE
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|!=
name|NULL
condition|)
block|{
name|msym
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|gdb_assert
argument_list|(
name|sym
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|msym
operator|=
name|lookup_minimal_symbol
argument_list|(
name|physname
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|msym
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
block|}
name|v
operator|=
name|allocate_value
argument_list|(
name|ftype
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
condition|)
block|{
name|VALUE_ADDRESS
argument_list|(
name|v
argument_list|)
operator|=
name|BLOCK_START
argument_list|(
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|VALUE_ADDRESS
argument_list|(
name|v
argument_list|)
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msym
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|arg1p
condition|)
block|{
if|if
condition|(
name|type
operator|!=
name|VALUE_TYPE
argument_list|(
operator|*
name|arg1p
argument_list|)
condition|)
operator|*
name|arg1p
operator|=
name|value_ind
argument_list|(
name|value_cast
argument_list|(
name|lookup_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|value_addr
argument_list|(
operator|*
name|arg1p
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Move the `this' pointer according to the offset.          VALUE_OFFSET (*arg1p) += offset;        */
block|}
return|return
name|v
return|;
block|}
end_function

begin_comment
comment|/* ARG is a pointer to an object we know to be at least    a DTYPE.  BTYPE is the most derived basetype that has    already been searched (and need not be searched again).    After looking at the vtables between BTYPE and DTYPE,    return the most derived type we find.  The caller must    be satisfied when the return value == DTYPE.     FIXME-tiemann: should work with dossier entries as well.    NOTICE - djb: I see no good reason at all to keep this function now that    we have RTTI support. It's used in literally one place, and it's    hard to keep this function up to date when it's purpose is served    by value_rtti_type efficiently.    Consider it gone for 5.1. */
end_comment

begin_function
specifier|static
name|struct
name|value
modifier|*
name|value_headof
parameter_list|(
name|struct
name|value
modifier|*
name|in_arg
parameter_list|,
name|struct
name|type
modifier|*
name|btype
parameter_list|,
name|struct
name|type
modifier|*
name|dtype
parameter_list|)
block|{
comment|/* First collect the vtables we must look at for this object.  */
name|struct
name|value
modifier|*
name|arg
decl_stmt|;
name|struct
name|value
modifier|*
name|vtbl
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|char
modifier|*
name|demangled_name
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
name|btype
operator|=
name|TYPE_VPTR_BASETYPE
argument_list|(
name|dtype
argument_list|)
expr_stmt|;
name|CHECK_TYPEDEF
argument_list|(
name|btype
argument_list|)
expr_stmt|;
name|arg
operator|=
name|in_arg
expr_stmt|;
if|if
condition|(
name|btype
operator|!=
name|dtype
condition|)
name|arg
operator|=
name|value_cast
argument_list|(
name|lookup_pointer_type
argument_list|(
name|btype
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_REF
condition|)
block|{
comment|/* 	   * Copy the value, but change the type from (T&) to (T*). 	   * We keep the same location information, which is efficient, 	   * and allows&(&X) to get the location containing the reference. 	   */
name|arg
operator|=
name|value_copy
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|VALUE_TYPE
argument_list|(
name|arg
argument_list|)
operator|=
name|lookup_pointer_type
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|VALUE_ADDRESS
argument_list|(
name|value_field
argument_list|(
name|value_ind
argument_list|(
name|arg
argument_list|)
argument_list|,
name|TYPE_VPTR_FIELDNO
argument_list|(
name|btype
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
name|arg
return|;
name|vtbl
operator|=
name|value_ind
argument_list|(
name|value_field
argument_list|(
name|value_ind
argument_list|(
name|arg
argument_list|)
argument_list|,
name|TYPE_VPTR_FIELDNO
argument_list|(
name|btype
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Turn vtable into typeinfo function */
name|VALUE_OFFSET
argument_list|(
name|vtbl
argument_list|)
operator|+=
literal|4
expr_stmt|;
name|msymbol
operator|=
name|lookup_minimal_symbol_by_pc
argument_list|(
name|value_as_address
argument_list|(
name|value_ind
argument_list|(
name|vtbl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|msymbol
operator|==
name|NULL
operator|||
operator|(
name|demangled_name
operator|=
name|SYMBOL_NAME
argument_list|(
name|msymbol
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* If we expected to find a vtable, but did not, let the user 	     know that we aren't happy, but don't throw an error. 	     FIXME: there has to be a better way to do this.  */
name|struct
name|type
modifier|*
name|error_type
init|=
operator|(
expr|struct
name|type
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|type
argument_list|)
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|error_type
argument_list|,
name|VALUE_TYPE
argument_list|(
name|in_arg
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|error_type
argument_list|)
operator|=
name|savestring
argument_list|(
literal|"suspicious *"
argument_list|,
sizeof|sizeof
argument_list|(
literal|"suspicious *"
argument_list|)
argument_list|)
expr_stmt|;
name|VALUE_TYPE
argument_list|(
name|in_arg
argument_list|)
operator|=
name|error_type
expr_stmt|;
return|return
name|in_arg
return|;
block|}
name|demangled_name
operator|=
name|cplus_demangle
argument_list|(
name|demangled_name
argument_list|,
name|DMGL_ANSI
argument_list|)
expr_stmt|;
operator|*
operator|(
name|strchr
argument_list|(
name|demangled_name
argument_list|,
literal|' '
argument_list|)
operator|)
operator|=
literal|'\0'
expr_stmt|;
name|sym
operator|=
name|lookup_symbol
argument_list|(
name|demangled_name
argument_list|,
literal|0
argument_list|,
name|VAR_NAMESPACE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"could not find type declaration for `%s'"
argument_list|,
name|demangled_name
argument_list|)
expr_stmt|;
name|arg
operator|=
name|in_arg
expr_stmt|;
name|VALUE_TYPE
argument_list|(
name|arg
argument_list|)
operator|=
name|lookup_pointer_type
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|arg
return|;
block|}
end_function

begin_comment
comment|/* ARG is a pointer object of type TYPE.  If TYPE has virtual    function tables, probe ARG's tables (including the vtables    of its baseclasses) to figure out the most derived type that ARG    could actually be a pointer to.  */
end_comment

begin_function
name|struct
name|value
modifier|*
name|value_from_vtable_info
parameter_list|(
name|struct
name|value
modifier|*
name|arg
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
comment|/* Take care of preliminaries.  */
if|if
condition|(
name|TYPE_VPTR_FIELDNO
argument_list|(
name|type
argument_list|)
operator|<
literal|0
condition|)
name|fill_in_vptr_fieldno
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_VPTR_FIELDNO
argument_list|(
name|type
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|value_headof
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|,
name|type
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Unpack a field FIELDNO of the specified TYPE, from the anonymous object at    VALADDR.     Extracting bits depends on endianness of the machine.  Compute the    number of least significant bits to discard.  For big endian machines,    we compute the total number of bits in the anonymous object, subtract    off the bit count from the MSB of the object to the MSB of the    bitfield, then the size of the bitfield, which leaves the LSB discard    count.  For little endian machines, the discard count is simply the    number of bits from the LSB of the anonymous object to the LSB of the    bitfield.     If the field is signed, we also do sign extension. */
end_comment

begin_function
name|LONGEST
name|unpack_field_as_long
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|char
modifier|*
name|valaddr
parameter_list|,
name|int
name|fieldno
parameter_list|)
block|{
name|ULONGEST
name|val
decl_stmt|;
name|ULONGEST
name|valmask
decl_stmt|;
name|int
name|bitpos
init|=
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|fieldno
argument_list|)
decl_stmt|;
name|int
name|bitsize
init|=
name|TYPE_FIELD_BITSIZE
argument_list|(
name|type
argument_list|,
name|fieldno
argument_list|)
decl_stmt|;
name|int
name|lsbcount
decl_stmt|;
name|struct
name|type
modifier|*
name|field_type
decl_stmt|;
name|val
operator|=
name|extract_unsigned_integer
argument_list|(
name|valaddr
operator|+
name|bitpos
operator|/
literal|8
argument_list|,
sizeof|sizeof
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
name|field_type
operator|=
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|fieldno
argument_list|)
expr_stmt|;
name|CHECK_TYPEDEF
argument_list|(
name|field_type
argument_list|)
expr_stmt|;
comment|/* Extract bits.  See comment above. */
if|if
condition|(
name|BITS_BIG_ENDIAN
condition|)
name|lsbcount
operator|=
operator|(
sizeof|sizeof
name|val
operator|*
literal|8
operator|-
name|bitpos
operator|%
literal|8
operator|-
name|bitsize
operator|)
expr_stmt|;
else|else
name|lsbcount
operator|=
operator|(
name|bitpos
operator|%
literal|8
operator|)
expr_stmt|;
name|val
operator|>>=
name|lsbcount
expr_stmt|;
comment|/* If the field does not entirely fill a LONGEST, then zero the sign bits.      If the field is signed, and is negative, then sign extend. */
if|if
condition|(
operator|(
name|bitsize
operator|>
literal|0
operator|)
operator|&&
operator|(
name|bitsize
operator|<
literal|8
operator|*
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|val
argument_list|)
operator|)
condition|)
block|{
name|valmask
operator|=
operator|(
operator|(
operator|(
name|ULONGEST
operator|)
literal|1
operator|)
operator|<<
name|bitsize
operator|)
operator|-
literal|1
expr_stmt|;
name|val
operator|&=
name|valmask
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_UNSIGNED
argument_list|(
name|field_type
argument_list|)
condition|)
block|{
if|if
condition|(
name|val
operator|&
operator|(
name|valmask
operator|^
operator|(
name|valmask
operator|>>
literal|1
operator|)
operator|)
condition|)
block|{
name|val
operator||=
operator|~
name|valmask
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Modify the value of a bitfield.  ADDR points to a block of memory in    target byte order; the bitfield starts in the byte pointed to.  FIELDVAL    is the desired value of the field, in host byte order.  BITPOS and BITSIZE    indicate which bits (in target bit order) comprise the bitfield.  */
end_comment

begin_function
name|void
name|modify_field
parameter_list|(
name|char
modifier|*
name|addr
parameter_list|,
name|LONGEST
name|fieldval
parameter_list|,
name|int
name|bitpos
parameter_list|,
name|int
name|bitsize
parameter_list|)
block|{
name|LONGEST
name|oword
decl_stmt|;
comment|/* If a negative fieldval fits in the field in question, chop      off the sign extension bits.  */
if|if
condition|(
name|bitsize
operator|<
operator|(
literal|8
operator|*
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|fieldval
argument_list|)
operator|)
operator|&&
operator|(
operator|~
name|fieldval
operator|&
operator|~
operator|(
operator|(
literal|1
operator|<<
operator|(
name|bitsize
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
condition|)
name|fieldval
operator|=
name|fieldval
operator|&
operator|(
operator|(
literal|1
operator|<<
name|bitsize
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* Warn if value is too big to fit in the field in question.  */
if|if
condition|(
name|bitsize
operator|<
operator|(
literal|8
operator|*
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|fieldval
argument_list|)
operator|)
operator|&&
literal|0
operator|!=
operator|(
name|fieldval
operator|&
operator|~
operator|(
operator|(
literal|1
operator|<<
name|bitsize
operator|)
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
comment|/* FIXME: would like to include fieldval in the message, but          we don't have a sprintf_longest.  */
name|warning
argument_list|(
literal|"Value does not fit in %d bits."
argument_list|,
name|bitsize
argument_list|)
expr_stmt|;
comment|/* Truncate it, otherwise adjoining fields may be corrupted.  */
name|fieldval
operator|=
name|fieldval
operator|&
operator|(
operator|(
literal|1
operator|<<
name|bitsize
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
block|}
name|oword
operator|=
name|extract_signed_integer
argument_list|(
name|addr
argument_list|,
sizeof|sizeof
name|oword
argument_list|)
expr_stmt|;
comment|/* Shifting for bit field depends on endianness of the target machine.  */
if|if
condition|(
name|BITS_BIG_ENDIAN
condition|)
name|bitpos
operator|=
sizeof|sizeof
argument_list|(
name|oword
argument_list|)
operator|*
literal|8
operator|-
name|bitpos
operator|-
name|bitsize
expr_stmt|;
comment|/* Mask out old value, while avoiding shifts>= size of oword */
if|if
condition|(
name|bitsize
operator|<
literal|8
operator|*
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|oword
argument_list|)
condition|)
name|oword
operator|&=
operator|~
operator|(
operator|(
operator|(
operator|(
operator|(
name|ULONGEST
operator|)
literal|1
operator|)
operator|<<
name|bitsize
operator|)
operator|-
literal|1
operator|)
operator|<<
name|bitpos
operator|)
expr_stmt|;
else|else
name|oword
operator|&=
operator|~
operator|(
operator|(
operator|~
operator|(
name|ULONGEST
operator|)
literal|0
operator|)
operator|<<
name|bitpos
operator|)
expr_stmt|;
name|oword
operator||=
name|fieldval
operator|<<
name|bitpos
expr_stmt|;
name|store_signed_integer
argument_list|(
name|addr
argument_list|,
sizeof|sizeof
name|oword
argument_list|,
name|oword
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Convert C numbers into newly allocated values */
end_comment

begin_function
name|struct
name|value
modifier|*
name|value_from_longest
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
specifier|register
name|LONGEST
name|num
parameter_list|)
block|{
name|struct
name|value
modifier|*
name|val
init|=
name|allocate_value
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|register
name|enum
name|type_code
name|code
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
name|retry
label|:
name|code
operator|=
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|len
operator|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|TYPE_CODE_TYPEDEF
case|:
name|type
operator|=
name|check_typedef
argument_list|(
name|type
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
case|case
name|TYPE_CODE_INT
case|:
case|case
name|TYPE_CODE_CHAR
case|:
case|case
name|TYPE_CODE_ENUM
case|:
case|case
name|TYPE_CODE_BOOL
case|:
case|case
name|TYPE_CODE_RANGE
case|:
name|store_signed_integer
argument_list|(
name|VALUE_CONTENTS_RAW
argument_list|(
name|val
argument_list|)
argument_list|,
name|len
argument_list|,
name|num
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_REF
case|:
case|case
name|TYPE_CODE_PTR
case|:
name|store_typed_address
argument_list|(
name|VALUE_CONTENTS_RAW
argument_list|(
name|val
argument_list|)
argument_list|,
name|type
argument_list|,
operator|(
name|CORE_ADDR
operator|)
name|num
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Unexpected type (%d) encountered for integer constant."
argument_list|,
name|code
argument_list|)
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Create a value representing a pointer of type TYPE to the address    ADDR.  */
end_comment

begin_function
name|struct
name|value
modifier|*
name|value_from_pointer
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|CORE_ADDR
name|addr
parameter_list|)
block|{
name|struct
name|value
modifier|*
name|val
init|=
name|allocate_value
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|store_typed_address
argument_list|(
name|VALUE_CONTENTS_RAW
argument_list|(
name|val
argument_list|)
argument_list|,
name|type
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Create a value for a string constant to be stored locally    (not in the inferior's memory space, but in GDB memory).    This is analogous to value_from_longest, which also does not    use inferior memory.  String shall NOT contain embedded nulls.  */
end_comment

begin_function
name|struct
name|value
modifier|*
name|value_from_string
parameter_list|(
name|char
modifier|*
name|ptr
parameter_list|)
block|{
name|struct
name|value
modifier|*
name|val
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|ptr
argument_list|)
decl_stmt|;
name|int
name|lowbound
init|=
name|current_language
operator|->
name|string_lower_bound
decl_stmt|;
name|struct
name|type
modifier|*
name|rangetype
init|=
name|create_range_type
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|)
name|NULL
argument_list|,
name|builtin_type_int
argument_list|,
name|lowbound
argument_list|,
name|len
operator|+
name|lowbound
operator|-
literal|1
argument_list|)
decl_stmt|;
name|struct
name|type
modifier|*
name|stringtype
init|=
name|create_array_type
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|)
name|NULL
argument_list|,
operator|*
name|current_language
operator|->
name|string_char_type
argument_list|,
name|rangetype
argument_list|)
decl_stmt|;
name|val
operator|=
name|allocate_value
argument_list|(
name|stringtype
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|VALUE_CONTENTS_RAW
argument_list|(
name|val
argument_list|)
argument_list|,
name|ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
name|struct
name|value
modifier|*
name|value_from_double
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|DOUBLEST
name|num
parameter_list|)
block|{
name|struct
name|value
modifier|*
name|val
init|=
name|allocate_value
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|struct
name|type
modifier|*
name|base_type
init|=
name|check_typedef
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|register
name|enum
name|type_code
name|code
init|=
name|TYPE_CODE
argument_list|(
name|base_type
argument_list|)
decl_stmt|;
specifier|register
name|int
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|base_type
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|TYPE_CODE_FLT
condition|)
block|{
name|store_typed_floating
argument_list|(
name|VALUE_CONTENTS_RAW
argument_list|(
name|val
argument_list|)
argument_list|,
name|base_type
argument_list|,
name|num
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"Unexpected type encountered for floating constant."
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Deal with the value that is "about to be returned".  */
end_comment

begin_comment
comment|/* Return the value that a function returning now    would be returning to its caller, assuming its type is VALTYPE.    RETBUF is where we look for what ought to be the contents    of the registers (in raw form).  This is because it is often    desirable to restore old values to those registers    after saving the contents of interest, and then call    this function using the saved values.    struct_return is non-zero when the function in question is    using the structure return conventions on the machine in question;    0 when it is using the value returning conventions (this often    means returning pointer to where structure is vs. returning value). */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|struct
name|value
modifier|*
name|value_being_returned
parameter_list|(
name|struct
name|type
modifier|*
name|valtype
parameter_list|,
name|char
modifier|*
name|retbuf
parameter_list|,
name|int
name|struct_return
parameter_list|)
block|{
name|struct
name|value
modifier|*
name|val
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
comment|/* If this is not defined, just use EXTRACT_RETURN_VALUE instead.  */
if|if
condition|(
name|EXTRACT_STRUCT_VALUE_ADDRESS_P
argument_list|()
condition|)
if|if
condition|(
name|struct_return
condition|)
block|{
name|addr
operator|=
name|EXTRACT_STRUCT_VALUE_ADDRESS
argument_list|(
name|retbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|addr
condition|)
name|error
argument_list|(
literal|"Function return value unknown."
argument_list|)
expr_stmt|;
return|return
name|value_at
argument_list|(
name|valtype
argument_list|,
name|addr
argument_list|,
name|NULL
argument_list|)
return|;
block|}
name|val
operator|=
name|allocate_value
argument_list|(
name|valtype
argument_list|)
expr_stmt|;
name|CHECK_TYPEDEF
argument_list|(
name|valtype
argument_list|)
expr_stmt|;
name|EXTRACT_RETURN_VALUE
argument_list|(
name|valtype
argument_list|,
name|retbuf
argument_list|,
name|VALUE_CONTENTS_RAW
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Should we use EXTRACT_STRUCT_VALUE_ADDRESS instead of    EXTRACT_RETURN_VALUE?  GCC_P is true if compiled with gcc    and TYPE is the type (which is known to be struct, union or array).     On most machines, the struct convention is used unless we are    using gcc and the type is of a special size.  */
end_comment

begin_comment
comment|/* As of about 31 Mar 93, GCC was changed to be compatible with the    native compiler.  GCC 2.3.3 was the last release that did it the    old way.  Since gcc2_compiled was not changed, we have no    way to correctly win in all cases, so we just do the right thing    for gcc1 and for gcc2 after this change.  Thus it loses for gcc    2.0-2.3.3.  This is somewhat unfortunate, but changing gcc2_compiled    would cause more chaos than dealing with some struct returns being    handled wrong.  */
end_comment

begin_function
name|int
name|generic_use_struct_convention
parameter_list|(
name|int
name|gcc_p
parameter_list|,
name|struct
name|type
modifier|*
name|value_type
parameter_list|)
block|{
return|return
operator|!
operator|(
operator|(
name|gcc_p
operator|==
literal|1
operator|)
operator|&&
operator|(
name|TYPE_LENGTH
argument_list|(
name|value_type
argument_list|)
operator|==
literal|1
operator|||
name|TYPE_LENGTH
argument_list|(
name|value_type
argument_list|)
operator|==
literal|2
operator|||
name|TYPE_LENGTH
argument_list|(
name|value_type
argument_list|)
operator|==
literal|4
operator|||
name|TYPE_LENGTH
argument_list|(
name|value_type
argument_list|)
operator|==
literal|8
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if the function specified is using the structure returning    convention on this machine to return arguments, or 0 if it is using    the value returning convention.  FUNCTION is the value representing    the function, FUNCADDR is the address of the function, and VALUE_TYPE    is the type returned by the function.  GCC_P is nonzero if compiled    with GCC.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|using_struct_return
parameter_list|(
name|struct
name|value
modifier|*
name|function
parameter_list|,
name|CORE_ADDR
name|funcaddr
parameter_list|,
name|struct
name|type
modifier|*
name|value_type
parameter_list|,
name|int
name|gcc_p
parameter_list|)
block|{
specifier|register
name|enum
name|type_code
name|code
init|=
name|TYPE_CODE
argument_list|(
name|value_type
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|TYPE_CODE_ERROR
condition|)
name|error
argument_list|(
literal|"Function return type unknown."
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|TYPE_CODE_STRUCT
operator|||
name|code
operator|==
name|TYPE_CODE_UNION
operator|||
name|code
operator|==
name|TYPE_CODE_ARRAY
operator|||
name|RETURN_VALUE_ON_STACK
argument_list|(
name|value_type
argument_list|)
condition|)
return|return
name|USE_STRUCT_CONVENTION
argument_list|(
name|gcc_p
argument_list|,
name|value_type
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Store VAL so it will be returned if a function returns now.    Does not verify that VAL's type matches what the current    function wants to return.  */
end_comment

begin_function
name|void
name|set_return_value
parameter_list|(
name|struct
name|value
modifier|*
name|val
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|type
init|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
decl_stmt|;
specifier|register
name|enum
name|type_code
name|code
init|=
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|TYPE_CODE_ERROR
condition|)
name|error
argument_list|(
literal|"Function return type unknown."
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|TYPE_CODE_STRUCT
operator|||
name|code
operator|==
name|TYPE_CODE_UNION
condition|)
comment|/* FIXME, implement struct return.  */
name|error
argument_list|(
literal|"GDB does not support specifying a struct or union return value."
argument_list|)
expr_stmt|;
name|STORE_RETURN_VALUE
argument_list|(
name|type
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|_initialize_values
parameter_list|(
name|void
parameter_list|)
block|{
name|add_cmd
argument_list|(
literal|"convenience"
argument_list|,
name|no_class
argument_list|,
name|show_convenience
argument_list|,
literal|"Debugger convenience (\"$foo\") variables.\n\ These variables are created when you assign them values;\n\ thus, \"print $foo=1\" gives \"$foo\" the value 1.  Values may be any type.\n\n\ A few convenience variables are given values automatically:\n\ \"$_\"holds the last address examined with \"x\" or \"info lines\",\n\ \"$__\" holds the contents of the last address examined with \"x\"."
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"values"
argument_list|,
name|no_class
argument_list|,
name|show_values
argument_list|,
literal|"Elements of value history around item number IDX (or last ten)."
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

