begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Low level packing and unpacking of values for GDB, the GNU Debugger.    Copyright 1986, 87, 89, 91, 93, 94, 95, 96, 97, 1998    Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"scm-lang.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_comment
comment|/* Prototypes for exported functions. */
end_comment

begin_decl_stmt
name|void
name|_initialize_values
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Prototypes for local functions. */
end_comment

begin_decl_stmt
specifier|static
name|value_ptr
name|value_headof
name|PARAMS
argument_list|(
operator|(
name|value_ptr
operator|,
expr|struct
name|type
operator|*
operator|,
expr|struct
name|type
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|show_values
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|show_convenience
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|vb_match
name|PARAMS
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|,
name|int
operator|,
expr|struct
name|type
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The value-history records all the values printed    by print commands during this session.  Each chunk    records 60 consecutive values.  The first chunk on    the chain records the most recent values.    The total number of values is in value_history_count.  */
end_comment

begin_define
define|#
directive|define
name|VALUE_HISTORY_CHUNK
value|60
end_define

begin_struct
struct|struct
name|value_history_chunk
block|{
name|struct
name|value_history_chunk
modifier|*
name|next
decl_stmt|;
name|value_ptr
name|values
index|[
name|VALUE_HISTORY_CHUNK
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Chain of chunks now in use.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|value_history_chunk
modifier|*
name|value_history_chain
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|value_history_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Abs number of last entry stored */
end_comment

begin_escape
end_escape

begin_comment
comment|/* List of all value objects currently allocated    (except for those released by calls to release_value)    This is so they can be freed after each command.  */
end_comment

begin_decl_stmt
specifier|static
name|value_ptr
name|all_values
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Allocate a  value  that has the correct length for type TYPE.  */
end_comment

begin_function
name|value_ptr
name|allocate_value
parameter_list|(
name|type
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
block|{
specifier|register
name|value_ptr
name|val
decl_stmt|;
name|struct
name|type
modifier|*
name|atype
init|=
name|check_typedef
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|val
operator|=
operator|(
expr|struct
name|value
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|value
argument_list|)
operator|+
name|TYPE_LENGTH
argument_list|(
name|atype
argument_list|)
argument_list|)
expr_stmt|;
name|VALUE_NEXT
argument_list|(
name|val
argument_list|)
operator|=
name|all_values
expr_stmt|;
name|all_values
operator|=
name|val
expr_stmt|;
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
operator|=
name|type
expr_stmt|;
name|VALUE_ENCLOSING_TYPE
argument_list|(
name|val
argument_list|)
operator|=
name|type
expr_stmt|;
name|VALUE_LVAL
argument_list|(
name|val
argument_list|)
operator|=
name|not_lval
expr_stmt|;
name|VALUE_ADDRESS
argument_list|(
name|val
argument_list|)
operator|=
literal|0
expr_stmt|;
name|VALUE_FRAME
argument_list|(
name|val
argument_list|)
operator|=
literal|0
expr_stmt|;
name|VALUE_OFFSET
argument_list|(
name|val
argument_list|)
operator|=
literal|0
expr_stmt|;
name|VALUE_BITPOS
argument_list|(
name|val
argument_list|)
operator|=
literal|0
expr_stmt|;
name|VALUE_BITSIZE
argument_list|(
name|val
argument_list|)
operator|=
literal|0
expr_stmt|;
name|VALUE_REGNO
argument_list|(
name|val
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
name|VALUE_LAZY
argument_list|(
name|val
argument_list|)
operator|=
literal|0
expr_stmt|;
name|VALUE_OPTIMIZED_OUT
argument_list|(
name|val
argument_list|)
operator|=
literal|0
expr_stmt|;
name|VALUE_BFD_SECTION
argument_list|(
name|val
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|VALUE_EMBEDDED_OFFSET
argument_list|(
name|val
argument_list|)
operator|=
literal|0
expr_stmt|;
name|VALUE_POINTED_TO_OFFSET
argument_list|(
name|val
argument_list|)
operator|=
literal|0
expr_stmt|;
name|val
operator|->
name|modifiable
operator|=
literal|1
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Allocate a  value  that has the correct length    for COUNT repetitions type TYPE.  */
end_comment

begin_function
name|value_ptr
name|allocate_repeat_value
parameter_list|(
name|type
parameter_list|,
name|count
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|int
name|count
decl_stmt|;
block|{
name|int
name|low_bound
init|=
name|current_language
operator|->
name|string_lower_bound
decl_stmt|;
comment|/* ??? */
comment|/* FIXME-type-allocation: need a way to free this type when we are      done with it.  */
name|struct
name|type
modifier|*
name|range_type
init|=
name|create_range_type
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|)
name|NULL
argument_list|,
name|builtin_type_int
argument_list|,
name|low_bound
argument_list|,
name|count
operator|+
name|low_bound
operator|-
literal|1
argument_list|)
decl_stmt|;
comment|/* FIXME-type-allocation: need a way to free this type when we are      done with it.  */
return|return
name|allocate_value
argument_list|(
name|create_array_type
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|)
name|NULL
argument_list|,
name|type
argument_list|,
name|range_type
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return a mark in the value chain.  All values allocated after the    mark is obtained (except for those released) are subject to being freed    if a subsequent value_free_to_mark is passed the mark.  */
end_comment

begin_function
name|value_ptr
name|value_mark
parameter_list|()
block|{
return|return
name|all_values
return|;
block|}
end_function

begin_comment
comment|/* Free all values allocated since MARK was obtained by value_mark    (except for those released).  */
end_comment

begin_function
name|void
name|value_free_to_mark
parameter_list|(
name|mark
parameter_list|)
name|value_ptr
name|mark
decl_stmt|;
block|{
name|value_ptr
name|val
decl_stmt|,
name|next
decl_stmt|;
for|for
control|(
name|val
operator|=
name|all_values
init|;
name|val
operator|&&
name|val
operator|!=
name|mark
condition|;
name|val
operator|=
name|next
control|)
block|{
name|next
operator|=
name|VALUE_NEXT
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|value_free
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
name|all_values
operator|=
name|val
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free all the values that have been allocated (except for those released).    Called after each command, successful or not.  */
end_comment

begin_function
name|void
name|free_all_values
parameter_list|()
block|{
specifier|register
name|value_ptr
name|val
decl_stmt|,
name|next
decl_stmt|;
for|for
control|(
name|val
operator|=
name|all_values
init|;
name|val
condition|;
name|val
operator|=
name|next
control|)
block|{
name|next
operator|=
name|VALUE_NEXT
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|value_free
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
name|all_values
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove VAL from the chain all_values    so it will not be freed automatically.  */
end_comment

begin_function
name|void
name|release_value
parameter_list|(
name|val
parameter_list|)
specifier|register
name|value_ptr
name|val
decl_stmt|;
block|{
specifier|register
name|value_ptr
name|v
decl_stmt|;
if|if
condition|(
name|all_values
operator|==
name|val
condition|)
block|{
name|all_values
operator|=
name|val
operator|->
name|next
expr_stmt|;
return|return;
block|}
for|for
control|(
name|v
operator|=
name|all_values
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|next
control|)
block|{
if|if
condition|(
name|v
operator|->
name|next
operator|==
name|val
condition|)
block|{
name|v
operator|->
name|next
operator|=
name|val
operator|->
name|next
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Release all values up to mark  */
end_comment

begin_function
name|value_ptr
name|value_release_to_mark
parameter_list|(
name|mark
parameter_list|)
name|value_ptr
name|mark
decl_stmt|;
block|{
name|value_ptr
name|val
decl_stmt|,
name|next
decl_stmt|;
for|for
control|(
name|val
operator|=
name|next
operator|=
name|all_values
init|;
name|next
condition|;
name|next
operator|=
name|VALUE_NEXT
argument_list|(
name|next
argument_list|)
control|)
if|if
condition|(
name|VALUE_NEXT
argument_list|(
name|next
argument_list|)
operator|==
name|mark
condition|)
block|{
name|all_values
operator|=
name|VALUE_NEXT
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|VALUE_NEXT
argument_list|(
name|next
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|val
return|;
block|}
name|all_values
operator|=
literal|0
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Return a copy of the value ARG.    It contains the same contents, for same memory address,    but it's a different block of storage.  */
end_comment

begin_function
name|value_ptr
name|value_copy
parameter_list|(
name|arg
parameter_list|)
name|value_ptr
name|arg
decl_stmt|;
block|{
specifier|register
name|struct
name|type
modifier|*
name|encl_type
init|=
name|VALUE_ENCLOSING_TYPE
argument_list|(
name|arg
argument_list|)
decl_stmt|;
specifier|register
name|value_ptr
name|val
init|=
name|allocate_value
argument_list|(
name|encl_type
argument_list|)
decl_stmt|;
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
operator|=
name|VALUE_TYPE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|VALUE_LVAL
argument_list|(
name|val
argument_list|)
operator|=
name|VALUE_LVAL
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|VALUE_ADDRESS
argument_list|(
name|val
argument_list|)
operator|=
name|VALUE_ADDRESS
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|VALUE_OFFSET
argument_list|(
name|val
argument_list|)
operator|=
name|VALUE_OFFSET
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|VALUE_BITPOS
argument_list|(
name|val
argument_list|)
operator|=
name|VALUE_BITPOS
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|VALUE_BITSIZE
argument_list|(
name|val
argument_list|)
operator|=
name|VALUE_BITSIZE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|VALUE_FRAME
argument_list|(
name|val
argument_list|)
operator|=
name|VALUE_FRAME
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|VALUE_REGNO
argument_list|(
name|val
argument_list|)
operator|=
name|VALUE_REGNO
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|VALUE_LAZY
argument_list|(
name|val
argument_list|)
operator|=
name|VALUE_LAZY
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|VALUE_OPTIMIZED_OUT
argument_list|(
name|val
argument_list|)
operator|=
name|VALUE_OPTIMIZED_OUT
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|VALUE_EMBEDDED_OFFSET
argument_list|(
name|val
argument_list|)
operator|=
name|VALUE_EMBEDDED_OFFSET
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|VALUE_POINTED_TO_OFFSET
argument_list|(
name|val
argument_list|)
operator|=
name|VALUE_POINTED_TO_OFFSET
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|VALUE_BFD_SECTION
argument_list|(
name|val
argument_list|)
operator|=
name|VALUE_BFD_SECTION
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|val
operator|->
name|modifiable
operator|=
name|arg
operator|->
name|modifiable
expr_stmt|;
if|if
condition|(
operator|!
name|VALUE_LAZY
argument_list|(
name|val
argument_list|)
condition|)
block|{
name|memcpy
argument_list|(
name|VALUE_CONTENTS_ALL_RAW
argument_list|(
name|val
argument_list|)
argument_list|,
name|VALUE_CONTENTS_ALL_RAW
argument_list|(
name|arg
argument_list|)
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|VALUE_ENCLOSING_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Access to the value history.  */
end_comment

begin_comment
comment|/* Record a new value in the value history.    Returns the absolute history index of the entry.    Result of -1 indicates the value was not saved; otherwise it is the    value history index of this new item.  */
end_comment

begin_function
name|int
name|record_latest_value
parameter_list|(
name|val
parameter_list|)
name|value_ptr
name|val
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
comment|/* We don't want this value to have anything to do with the inferior anymore.      In particular, "set $1 = 50" should not affect the variable from which      the value was taken, and fast watchpoints should be able to assume that      a value on the value history never changes.  */
if|if
condition|(
name|VALUE_LAZY
argument_list|(
name|val
argument_list|)
condition|)
name|value_fetch_lazy
argument_list|(
name|val
argument_list|)
expr_stmt|;
comment|/* We preserve VALUE_LVAL so that the user can find out where it was fetched      from.  This is a bit dubious, because then *&$1 does not just return $1      but the current contents of that location.  c'est la vie...  */
name|val
operator|->
name|modifiable
operator|=
literal|0
expr_stmt|;
name|release_value
argument_list|(
name|val
argument_list|)
expr_stmt|;
comment|/* Here we treat value_history_count as origin-zero      and applying to the value being stored now.  */
name|i
operator|=
name|value_history_count
operator|%
name|VALUE_HISTORY_CHUNK
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
specifier|register
name|struct
name|value_history_chunk
modifier|*
name|new
init|=
operator|(
expr|struct
name|value_history_chunk
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|value_history_chunk
argument_list|)
argument_list|)
decl_stmt|;
name|memset
argument_list|(
name|new
operator|->
name|values
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|new
operator|->
name|values
argument_list|)
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|value_history_chain
expr_stmt|;
name|value_history_chain
operator|=
name|new
expr_stmt|;
block|}
name|value_history_chain
operator|->
name|values
index|[
name|i
index|]
operator|=
name|val
expr_stmt|;
comment|/* Now we regard value_history_count as origin-one      and applying to the value just stored.  */
return|return
operator|++
name|value_history_count
return|;
block|}
end_function

begin_comment
comment|/* Return a copy of the value in the history with sequence number NUM.  */
end_comment

begin_function
name|value_ptr
name|access_value_history
parameter_list|(
name|num
parameter_list|)
name|int
name|num
decl_stmt|;
block|{
specifier|register
name|struct
name|value_history_chunk
modifier|*
name|chunk
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|absnum
init|=
name|num
decl_stmt|;
if|if
condition|(
name|absnum
operator|<=
literal|0
condition|)
name|absnum
operator|+=
name|value_history_count
expr_stmt|;
if|if
condition|(
name|absnum
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|num
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"The history is empty."
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|num
operator|==
literal|1
condition|)
name|error
argument_list|(
literal|"There is only one value in the history."
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"History does not go back to $$%d."
argument_list|,
operator|-
name|num
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|absnum
operator|>
name|value_history_count
condition|)
name|error
argument_list|(
literal|"History has not yet reached $%d."
argument_list|,
name|absnum
argument_list|)
expr_stmt|;
name|absnum
operator|--
expr_stmt|;
comment|/* Now absnum is always absolute and origin zero.  */
name|chunk
operator|=
name|value_history_chain
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|(
name|value_history_count
operator|-
literal|1
operator|)
operator|/
name|VALUE_HISTORY_CHUNK
operator|-
name|absnum
operator|/
name|VALUE_HISTORY_CHUNK
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
name|chunk
operator|=
name|chunk
operator|->
name|next
expr_stmt|;
return|return
name|value_copy
argument_list|(
name|chunk
operator|->
name|values
index|[
name|absnum
operator|%
name|VALUE_HISTORY_CHUNK
index|]
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Clear the value history entirely.    Must be done when new symbol tables are loaded,    because the type pointers become invalid.  */
end_comment

begin_function
name|void
name|clear_value_history
parameter_list|()
block|{
specifier|register
name|struct
name|value_history_chunk
modifier|*
name|next
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|value_ptr
name|val
decl_stmt|;
while|while
condition|(
name|value_history_chain
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|VALUE_HISTORY_CHUNK
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|val
operator|=
name|value_history_chain
operator|->
name|values
index|[
name|i
index|]
operator|)
operator|!=
name|NULL
condition|)
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|val
argument_list|)
expr_stmt|;
name|next
operator|=
name|value_history_chain
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|value_history_chain
argument_list|)
expr_stmt|;
name|value_history_chain
operator|=
name|next
expr_stmt|;
block|}
name|value_history_count
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|show_values
parameter_list|(
name|num_exp
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|num_exp
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|value_ptr
name|val
decl_stmt|;
specifier|static
name|int
name|num
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|num_exp
condition|)
block|{
comment|/* "info history +" should print from the stored position. 	   "info history<exp>" should print around value number<exp>.  */
if|if
condition|(
name|num_exp
index|[
literal|0
index|]
operator|!=
literal|'+'
operator|||
name|num_exp
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
name|num
operator|=
name|parse_and_eval_address
argument_list|(
name|num_exp
argument_list|)
operator|-
literal|5
expr_stmt|;
block|}
else|else
block|{
comment|/* "info history" means print the last 10 values.  */
name|num
operator|=
name|value_history_count
operator|-
literal|9
expr_stmt|;
block|}
if|if
condition|(
name|num
operator|<=
literal|0
condition|)
name|num
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|num
init|;
name|i
operator|<
name|num
operator|+
literal|10
operator|&&
name|i
operator|<=
name|value_history_count
condition|;
name|i
operator|++
control|)
block|{
name|val
operator|=
name|access_value_history
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"$%d = "
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|value_print
argument_list|(
name|val
argument_list|,
name|gdb_stdout
argument_list|,
literal|0
argument_list|,
name|Val_pretty_default
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* The next "info history +" should start after what we just printed.  */
name|num
operator|+=
literal|10
expr_stmt|;
comment|/* Hitting just return after this command should do the same thing as      "info history +".  If num_exp is null, this is unnecessary, since      "info history +" is not useful after "info history".  */
if|if
condition|(
name|from_tty
operator|&&
name|num_exp
condition|)
block|{
name|num_exp
index|[
literal|0
index|]
operator|=
literal|'+'
expr_stmt|;
name|num_exp
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Internal variables.  These are variables within the debugger    that hold values assigned by debugger commands.    The user refers to them with a '$' prefix    that does not appear in the variable names stored internally.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|internalvar
modifier|*
name|internalvars
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Look up an internal variable with name NAME.  NAME should not    normally include a dollar sign.     If the specified internal variable does not exist,    one is created, with a void value.  */
end_comment

begin_function
name|struct
name|internalvar
modifier|*
name|lookup_internalvar
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|struct
name|internalvar
modifier|*
name|var
decl_stmt|;
for|for
control|(
name|var
operator|=
name|internalvars
init|;
name|var
condition|;
name|var
operator|=
name|var
operator|->
name|next
control|)
if|if
condition|(
name|STREQ
argument_list|(
name|var
operator|->
name|name
argument_list|,
name|name
argument_list|)
condition|)
return|return
name|var
return|;
name|var
operator|=
operator|(
expr|struct
name|internalvar
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|internalvar
argument_list|)
argument_list|)
expr_stmt|;
name|var
operator|->
name|name
operator|=
name|concat
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|var
operator|->
name|value
operator|=
name|allocate_value
argument_list|(
name|builtin_type_void
argument_list|)
expr_stmt|;
name|release_value
argument_list|(
name|var
operator|->
name|value
argument_list|)
expr_stmt|;
name|var
operator|->
name|next
operator|=
name|internalvars
expr_stmt|;
name|internalvars
operator|=
name|var
expr_stmt|;
return|return
name|var
return|;
block|}
end_function

begin_function
name|value_ptr
name|value_of_internalvar
parameter_list|(
name|var
parameter_list|)
name|struct
name|internalvar
modifier|*
name|var
decl_stmt|;
block|{
specifier|register
name|value_ptr
name|val
decl_stmt|;
ifdef|#
directive|ifdef
name|IS_TRAPPED_INTERNALVAR
if|if
condition|(
name|IS_TRAPPED_INTERNALVAR
argument_list|(
name|var
operator|->
name|name
argument_list|)
condition|)
return|return
name|VALUE_OF_TRAPPED_INTERNALVAR
argument_list|(
name|var
argument_list|)
return|;
endif|#
directive|endif
name|val
operator|=
name|value_copy
argument_list|(
name|var
operator|->
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|VALUE_LAZY
argument_list|(
name|val
argument_list|)
condition|)
name|value_fetch_lazy
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|VALUE_LVAL
argument_list|(
name|val
argument_list|)
operator|=
name|lval_internalvar
expr_stmt|;
name|VALUE_INTERNALVAR
argument_list|(
name|val
argument_list|)
operator|=
name|var
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
name|void
name|set_internalvar_component
parameter_list|(
name|var
parameter_list|,
name|offset
parameter_list|,
name|bitpos
parameter_list|,
name|bitsize
parameter_list|,
name|newval
parameter_list|)
name|struct
name|internalvar
modifier|*
name|var
decl_stmt|;
name|int
name|offset
decl_stmt|,
name|bitpos
decl_stmt|,
name|bitsize
decl_stmt|;
name|value_ptr
name|newval
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|addr
init|=
name|VALUE_CONTENTS
argument_list|(
name|var
operator|->
name|value
argument_list|)
operator|+
name|offset
decl_stmt|;
ifdef|#
directive|ifdef
name|IS_TRAPPED_INTERNALVAR
if|if
condition|(
name|IS_TRAPPED_INTERNALVAR
argument_list|(
name|var
operator|->
name|name
argument_list|)
condition|)
name|SET_TRAPPED_INTERNALVAR
argument_list|(
name|var
argument_list|,
name|newval
argument_list|,
name|bitpos
argument_list|,
name|bitsize
argument_list|,
name|offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|bitsize
condition|)
name|modify_field
argument_list|(
name|addr
argument_list|,
name|value_as_long
argument_list|(
name|newval
argument_list|)
argument_list|,
name|bitpos
argument_list|,
name|bitsize
argument_list|)
expr_stmt|;
else|else
name|memcpy
argument_list|(
name|addr
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|newval
argument_list|)
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|newval
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|set_internalvar
parameter_list|(
name|var
parameter_list|,
name|val
parameter_list|)
name|struct
name|internalvar
modifier|*
name|var
decl_stmt|;
name|value_ptr
name|val
decl_stmt|;
block|{
name|value_ptr
name|newval
decl_stmt|;
ifdef|#
directive|ifdef
name|IS_TRAPPED_INTERNALVAR
if|if
condition|(
name|IS_TRAPPED_INTERNALVAR
argument_list|(
name|var
operator|->
name|name
argument_list|)
condition|)
name|SET_TRAPPED_INTERNALVAR
argument_list|(
name|var
argument_list|,
name|val
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|newval
operator|=
name|value_copy
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|newval
operator|->
name|modifiable
operator|=
literal|1
expr_stmt|;
comment|/* Force the value to be fetched from the target now, to avoid problems      later when this internalvar is referenced and the target is gone or      has changed.  */
if|if
condition|(
name|VALUE_LAZY
argument_list|(
name|newval
argument_list|)
condition|)
name|value_fetch_lazy
argument_list|(
name|newval
argument_list|)
expr_stmt|;
comment|/* Begin code which must not call error().  If var->value points to      something free'd, an error() obviously leaves a dangling pointer.      But we also get a danling pointer if var->value points to      something in the value chain (i.e., before release_value is      called), because after the error free_all_values will get called before      long.  */
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|var
operator|->
name|value
argument_list|)
expr_stmt|;
name|var
operator|->
name|value
operator|=
name|newval
expr_stmt|;
name|release_value
argument_list|(
name|newval
argument_list|)
expr_stmt|;
comment|/* End code which must not call error().  */
block|}
end_function

begin_function
name|char
modifier|*
name|internalvar_name
parameter_list|(
name|var
parameter_list|)
name|struct
name|internalvar
modifier|*
name|var
decl_stmt|;
block|{
return|return
name|var
operator|->
name|name
return|;
block|}
end_function

begin_comment
comment|/* Free all internalvars.  Done when new symtabs are loaded,    because that makes the values invalid.  */
end_comment

begin_function
name|void
name|clear_internalvars
parameter_list|()
block|{
specifier|register
name|struct
name|internalvar
modifier|*
name|var
decl_stmt|;
while|while
condition|(
name|internalvars
condition|)
block|{
name|var
operator|=
name|internalvars
expr_stmt|;
name|internalvars
operator|=
name|var
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|var
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|var
operator|->
name|value
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|var
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|show_convenience
parameter_list|(
name|ignore
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|ignore
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
specifier|register
name|struct
name|internalvar
modifier|*
name|var
decl_stmt|;
name|int
name|varseen
init|=
literal|0
decl_stmt|;
for|for
control|(
name|var
operator|=
name|internalvars
init|;
name|var
condition|;
name|var
operator|=
name|var
operator|->
name|next
control|)
block|{
ifdef|#
directive|ifdef
name|IS_TRAPPED_INTERNALVAR
if|if
condition|(
name|IS_TRAPPED_INTERNALVAR
argument_list|(
name|var
operator|->
name|name
argument_list|)
condition|)
continue|continue;
endif|#
directive|endif
if|if
condition|(
operator|!
name|varseen
condition|)
block|{
name|varseen
operator|=
literal|1
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|"$%s = "
argument_list|,
name|var
operator|->
name|name
argument_list|)
expr_stmt|;
name|value_print
argument_list|(
name|var
operator|->
name|value
argument_list|,
name|gdb_stdout
argument_list|,
literal|0
argument_list|,
name|Val_pretty_default
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|varseen
condition|)
name|printf_unfiltered
argument_list|(
literal|"No debugger convenience variables now defined.\n\ Convenience variables have names starting with \"$\";\n\ use \"set\" as in \"set $foo = 5\" to define them.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Extract a value as a C number (either long or double).    Knows how to convert fixed values to double, or    floating values to long.    Does not deallocate the value.  */
end_comment

begin_function
name|LONGEST
name|value_as_long
parameter_list|(
name|val
parameter_list|)
specifier|register
name|value_ptr
name|val
decl_stmt|;
block|{
comment|/* This coerces arrays and functions, which is necessary (e.g.      in disassemble_command).  It also dereferences references, which      I suspect is the most logical thing to do.  */
name|COERCE_ARRAY
argument_list|(
name|val
argument_list|)
expr_stmt|;
return|return
name|unpack_long
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|val
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|DOUBLEST
name|value_as_double
parameter_list|(
name|val
parameter_list|)
specifier|register
name|value_ptr
name|val
decl_stmt|;
block|{
name|DOUBLEST
name|foo
decl_stmt|;
name|int
name|inv
decl_stmt|;
name|foo
operator|=
name|unpack_double
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|val
argument_list|)
argument_list|,
operator|&
name|inv
argument_list|)
expr_stmt|;
if|if
condition|(
name|inv
condition|)
name|error
argument_list|(
literal|"Invalid floating value found in program."
argument_list|)
expr_stmt|;
return|return
name|foo
return|;
block|}
end_function

begin_comment
comment|/* Extract a value as a C pointer.    Does not deallocate the value.  */
end_comment

begin_function
name|CORE_ADDR
name|value_as_pointer
parameter_list|(
name|val
parameter_list|)
name|value_ptr
name|val
decl_stmt|;
block|{
comment|/* Assume a CORE_ADDR can fit in a LONGEST (for now).  Not sure      whether we want this to be true eventually.  */
if|#
directive|if
literal|0
comment|/* ADDR_BITS_REMOVE is wrong if we are being called for a      non-address (e.g. argument to "signal", "info break", etc.), or      for pointers to char, in which the low bits *are* significant.  */
block|return ADDR_BITS_REMOVE(value_as_long (val));
else|#
directive|else
return|return
name|value_as_long
argument_list|(
name|val
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Unpack raw data (copied from debugee, target byte order) at VALADDR    as a long, or as a double, assuming the raw data is described    by type TYPE.  Knows how to convert different sizes of values    and can convert between fixed and floating point.  We don't assume    any alignment for the raw data.  Return value is in host byte order.     If you want functions and arrays to be coerced to pointers, and    references to be dereferenced, call value_as_long() instead.     C++: It is assumed that the front-end has taken care of    all matters concerning pointers to members.  A pointer    to member which reaches here is considered to be equivalent    to an INT (or some size).  After all, it is only an offset.  */
end_comment

begin_function
name|LONGEST
name|unpack_long
parameter_list|(
name|type
parameter_list|,
name|valaddr
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|char
modifier|*
name|valaddr
decl_stmt|;
block|{
specifier|register
name|enum
name|type_code
name|code
init|=
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|register
name|int
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|register
name|int
name|nosign
init|=
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|current_language
operator|->
name|la_language
operator|==
name|language_scm
operator|&&
name|is_scmvalue_type
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|scm_unpack
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|,
name|TYPE_CODE_INT
argument_list|)
return|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|TYPE_CODE_TYPEDEF
case|:
return|return
name|unpack_long
argument_list|(
name|check_typedef
argument_list|(
name|type
argument_list|)
argument_list|,
name|valaddr
argument_list|)
return|;
case|case
name|TYPE_CODE_ENUM
case|:
case|case
name|TYPE_CODE_BOOL
case|:
case|case
name|TYPE_CODE_INT
case|:
case|case
name|TYPE_CODE_CHAR
case|:
case|case
name|TYPE_CODE_RANGE
case|:
if|if
condition|(
name|nosign
condition|)
return|return
name|extract_unsigned_integer
argument_list|(
name|valaddr
argument_list|,
name|len
argument_list|)
return|;
else|else
return|return
name|extract_signed_integer
argument_list|(
name|valaddr
argument_list|,
name|len
argument_list|)
return|;
case|case
name|TYPE_CODE_FLT
case|:
return|return
name|extract_floating
argument_list|(
name|valaddr
argument_list|,
name|len
argument_list|)
return|;
case|case
name|TYPE_CODE_PTR
case|:
case|case
name|TYPE_CODE_REF
case|:
comment|/* Assume a CORE_ADDR can fit in a LONGEST (for now).  Not sure 	 whether we want this to be true eventually.  */
ifdef|#
directive|ifdef
name|GDB_TARGET_IS_D10V
if|if
condition|(
name|len
operator|==
literal|2
condition|)
return|return
name|D10V_MAKE_DADDR
argument_list|(
name|extract_address
argument_list|(
name|valaddr
argument_list|,
name|len
argument_list|)
argument_list|)
return|;
endif|#
directive|endif
return|return
name|extract_address
argument_list|(
name|valaddr
argument_list|,
name|len
argument_list|)
return|;
case|case
name|TYPE_CODE_MEMBER
case|:
name|error
argument_list|(
literal|"not implemented: member types in unpack_long"
argument_list|)
expr_stmt|;
default|default:
name|error
argument_list|(
literal|"Value can't be converted to integer."
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
comment|/* Placate lint.  */
block|}
end_function

begin_comment
comment|/* Return a double value from the specified type and address.    INVP points to an int which is set to 0 for valid value,    1 for invalid value (bad float format).  In either case,    the returned double is OK to use.  Argument is in target    format, result is in host format.  */
end_comment

begin_function
name|DOUBLEST
name|unpack_double
parameter_list|(
name|type
parameter_list|,
name|valaddr
parameter_list|,
name|invp
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|char
modifier|*
name|valaddr
decl_stmt|;
name|int
modifier|*
name|invp
decl_stmt|;
block|{
name|enum
name|type_code
name|code
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|nosign
decl_stmt|;
operator|*
name|invp
operator|=
literal|0
expr_stmt|;
comment|/* Assume valid.   */
name|CHECK_TYPEDEF
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|code
operator|=
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|len
operator|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|nosign
operator|=
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|TYPE_CODE_FLT
condition|)
block|{
ifdef|#
directive|ifdef
name|INVALID_FLOAT
if|if
condition|(
name|INVALID_FLOAT
argument_list|(
name|valaddr
argument_list|,
name|len
argument_list|)
condition|)
block|{
operator|*
name|invp
operator|=
literal|1
expr_stmt|;
return|return
literal|1.234567891011121314
return|;
block|}
endif|#
directive|endif
return|return
name|extract_floating
argument_list|(
name|valaddr
argument_list|,
name|len
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|nosign
condition|)
block|{
comment|/* Unsigned -- be sure we compensate for signed LONGEST.  */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|||
operator|(
name|_MSC_VER
operator|>
literal|900
operator|)
return|return
operator|(
name|ULONGEST
operator|)
name|unpack_long
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|)
return|;
else|#
directive|else
comment|/* FIXME!!! msvc22 doesn't support unsigned __int64 -> double */
return|return
operator|(
name|LONGEST
operator|)
name|unpack_long
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|)
return|;
endif|#
directive|endif
comment|/* _MSC_VER */
block|}
else|else
block|{
comment|/* Signed -- we are OK with unpack_long.  */
return|return
name|unpack_long
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Unpack raw data (copied from debugee, target byte order) at VALADDR    as a CORE_ADDR, assuming the raw data is described by type TYPE.    We don't assume any alignment for the raw data.  Return value is in    host byte order.     If you want functions and arrays to be coerced to pointers, and    references to be dereferenced, call value_as_pointer() instead.     C++: It is assumed that the front-end has taken care of    all matters concerning pointers to members.  A pointer    to member which reaches here is considered to be equivalent    to an INT (or some size).  After all, it is only an offset.  */
end_comment

begin_function
name|CORE_ADDR
name|unpack_pointer
parameter_list|(
name|type
parameter_list|,
name|valaddr
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|char
modifier|*
name|valaddr
decl_stmt|;
block|{
comment|/* Assume a CORE_ADDR can fit in a LONGEST (for now).  Not sure      whether we want this to be true eventually.  */
return|return
name|unpack_long
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Get the value of the FIELDN'th field (which must be static) of TYPE. */
end_comment

begin_function
name|value_ptr
name|value_static_field
parameter_list|(
name|type
parameter_list|,
name|fieldno
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|int
name|fieldno
decl_stmt|;
block|{
name|CORE_ADDR
name|addr
decl_stmt|;
name|asection
modifier|*
name|sect
decl_stmt|;
if|if
condition|(
name|TYPE_FIELD_STATIC_HAS_ADDR
argument_list|(
name|type
argument_list|,
name|fieldno
argument_list|)
condition|)
block|{
name|addr
operator|=
name|TYPE_FIELD_STATIC_PHYSADDR
argument_list|(
name|type
argument_list|,
name|fieldno
argument_list|)
expr_stmt|;
name|sect
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|phys_name
init|=
name|TYPE_FIELD_STATIC_PHYSNAME
argument_list|(
name|type
argument_list|,
name|fieldno
argument_list|)
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
init|=
name|lookup_symbol
argument_list|(
name|phys_name
argument_list|,
literal|0
argument_list|,
name|VAR_NAMESPACE
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|sym
operator|==
name|NULL
condition|)
block|{
comment|/* With some compilers, e.g. HP aCC, static data members are reported 	     as non-debuggable symbols */
name|struct
name|minimal_symbol
modifier|*
name|msym
init|=
name|lookup_minimal_symbol
argument_list|(
name|phys_name
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|msym
condition|)
return|return
name|NULL
return|;
else|else
block|{
name|addr
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msym
argument_list|)
expr_stmt|;
name|sect
operator|=
name|SYMBOL_BFD_SECTION
argument_list|(
name|msym
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|addr
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|sect
operator|=
name|SYMBOL_BFD_SECTION
argument_list|(
name|sym
argument_list|)
expr_stmt|;
block|}
name|SET_FIELD_PHYSADDR
argument_list|(
name|TYPE_FIELD
argument_list|(
name|type
argument_list|,
name|fieldno
argument_list|)
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
return|return
name|value_at
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|fieldno
argument_list|)
argument_list|,
name|addr
argument_list|,
name|sect
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given a value ARG1 (offset by OFFSET bytes)    of a struct or union type ARG_TYPE,    extract and return the value of one of its (non-static) fields.    FIELDNO says which field. */
end_comment

begin_function
name|value_ptr
name|value_primitive_field
parameter_list|(
name|arg1
parameter_list|,
name|offset
parameter_list|,
name|fieldno
parameter_list|,
name|arg_type
parameter_list|)
specifier|register
name|value_ptr
name|arg1
decl_stmt|;
name|int
name|offset
decl_stmt|;
specifier|register
name|int
name|fieldno
decl_stmt|;
specifier|register
name|struct
name|type
modifier|*
name|arg_type
decl_stmt|;
block|{
specifier|register
name|value_ptr
name|v
decl_stmt|;
specifier|register
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|CHECK_TYPEDEF
argument_list|(
name|arg_type
argument_list|)
expr_stmt|;
name|type
operator|=
name|TYPE_FIELD_TYPE
argument_list|(
name|arg_type
argument_list|,
name|fieldno
argument_list|)
expr_stmt|;
comment|/* Handle packed fields */
if|if
condition|(
name|TYPE_FIELD_BITSIZE
argument_list|(
name|arg_type
argument_list|,
name|fieldno
argument_list|)
condition|)
block|{
name|v
operator|=
name|value_from_longest
argument_list|(
name|type
argument_list|,
name|unpack_field_as_long
argument_list|(
name|arg_type
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|arg1
argument_list|)
operator|+
name|offset
argument_list|,
name|fieldno
argument_list|)
argument_list|)
expr_stmt|;
name|VALUE_BITPOS
argument_list|(
name|v
argument_list|)
operator|=
name|TYPE_FIELD_BITPOS
argument_list|(
name|arg_type
argument_list|,
name|fieldno
argument_list|)
operator|%
literal|8
expr_stmt|;
name|VALUE_BITSIZE
argument_list|(
name|v
argument_list|)
operator|=
name|TYPE_FIELD_BITSIZE
argument_list|(
name|arg_type
argument_list|,
name|fieldno
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fieldno
operator|<
name|TYPE_N_BASECLASSES
argument_list|(
name|arg_type
argument_list|)
condition|)
block|{
comment|/* This field is actually a base subobject, so preserve the          entire object's contents for later references to virtual          bases, etc.  */
name|v
operator|=
name|allocate_value
argument_list|(
name|VALUE_ENCLOSING_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
name|VALUE_TYPE
argument_list|(
name|v
argument_list|)
operator|=
name|arg_type
expr_stmt|;
if|if
condition|(
name|VALUE_LAZY
argument_list|(
name|arg1
argument_list|)
condition|)
name|VALUE_LAZY
argument_list|(
name|v
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
name|memcpy
argument_list|(
name|VALUE_CONTENTS_ALL_RAW
argument_list|(
name|v
argument_list|)
argument_list|,
name|VALUE_CONTENTS_ALL_RAW
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|VALUE_ENCLOSING_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|VALUE_OFFSET
argument_list|(
name|v
argument_list|)
operator|=
name|VALUE_OFFSET
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|VALUE_EMBEDDED_OFFSET
argument_list|(
name|v
argument_list|)
operator|=
name|offset
operator|+
name|VALUE_EMBEDDED_OFFSET
argument_list|(
name|arg1
argument_list|)
operator|+
name|TYPE_FIELD_BITPOS
argument_list|(
name|arg_type
argument_list|,
name|fieldno
argument_list|)
operator|/
literal|8
expr_stmt|;
block|}
else|else
block|{
comment|/* Plain old data member */
name|offset
operator|+=
name|TYPE_FIELD_BITPOS
argument_list|(
name|arg_type
argument_list|,
name|fieldno
argument_list|)
operator|/
literal|8
expr_stmt|;
name|v
operator|=
name|allocate_value
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|VALUE_LAZY
argument_list|(
name|arg1
argument_list|)
condition|)
name|VALUE_LAZY
argument_list|(
name|v
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
name|memcpy
argument_list|(
name|VALUE_CONTENTS_RAW
argument_list|(
name|v
argument_list|)
argument_list|,
name|VALUE_CONTENTS_RAW
argument_list|(
name|arg1
argument_list|)
operator|+
name|offset
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|VALUE_OFFSET
argument_list|(
name|v
argument_list|)
operator|=
name|VALUE_OFFSET
argument_list|(
name|arg1
argument_list|)
operator|+
name|offset
expr_stmt|;
block|}
name|VALUE_LVAL
argument_list|(
name|v
argument_list|)
operator|=
name|VALUE_LVAL
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|VALUE_LVAL
argument_list|(
name|arg1
argument_list|)
operator|==
name|lval_internalvar
condition|)
name|VALUE_LVAL
argument_list|(
name|v
argument_list|)
operator|=
name|lval_internalvar_component
expr_stmt|;
name|VALUE_ADDRESS
argument_list|(
name|v
argument_list|)
operator|=
name|VALUE_ADDRESS
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
comment|/*  VALUE_OFFSET (v) = VALUE_OFFSET (arg1) + offset 		     + TYPE_FIELD_BITPOS (arg_type, fieldno) / 8; */
return|return
name|v
return|;
block|}
end_function

begin_comment
comment|/* Given a value ARG1 of a struct or union type,    extract and return the value of one of its (non-static) fields.    FIELDNO says which field. */
end_comment

begin_function
name|value_ptr
name|value_field
parameter_list|(
name|arg1
parameter_list|,
name|fieldno
parameter_list|)
specifier|register
name|value_ptr
name|arg1
decl_stmt|;
specifier|register
name|int
name|fieldno
decl_stmt|;
block|{
return|return
name|value_primitive_field
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|,
name|fieldno
argument_list|,
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return a non-virtual function as a value.    F is the list of member functions which contains the desired method.    J is an index into F which provides the desired method. */
end_comment

begin_function
name|value_ptr
name|value_fn_field
parameter_list|(
name|arg1p
parameter_list|,
name|f
parameter_list|,
name|j
parameter_list|,
name|type
parameter_list|,
name|offset
parameter_list|)
name|value_ptr
modifier|*
name|arg1p
decl_stmt|;
name|struct
name|fn_field
modifier|*
name|f
decl_stmt|;
name|int
name|j
decl_stmt|;
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|int
name|offset
decl_stmt|;
block|{
specifier|register
name|value_ptr
name|v
decl_stmt|;
specifier|register
name|struct
name|type
modifier|*
name|ftype
init|=
name|TYPE_FN_FIELD_TYPE
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|sym
operator|=
name|lookup_symbol
argument_list|(
name|TYPE_FN_FIELD_PHYSNAME
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VAR_NAMESPACE
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sym
condition|)
return|return
name|NULL
return|;
comment|/* 	error ("Internal error: could not find physical method named %s", 		    TYPE_FN_FIELD_PHYSNAME (f, j)); */
name|v
operator|=
name|allocate_value
argument_list|(
name|ftype
argument_list|)
expr_stmt|;
name|VALUE_ADDRESS
argument_list|(
name|v
argument_list|)
operator|=
name|BLOCK_START
argument_list|(
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|VALUE_TYPE
argument_list|(
name|v
argument_list|)
operator|=
name|ftype
expr_stmt|;
if|if
condition|(
name|arg1p
condition|)
block|{
if|if
condition|(
name|type
operator|!=
name|VALUE_TYPE
argument_list|(
operator|*
name|arg1p
argument_list|)
condition|)
operator|*
name|arg1p
operator|=
name|value_ind
argument_list|(
name|value_cast
argument_list|(
name|lookup_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|value_addr
argument_list|(
operator|*
name|arg1p
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Move the `this' pointer according to the offset.      VALUE_OFFSET (*arg1p) += offset;     */
block|}
return|return
name|v
return|;
block|}
end_function

begin_comment
comment|/* Return a virtual function as a value.    ARG1 is the object which provides the virtual function    table pointer.  *ARG1P is side-effected in calling this function.    F is the list of member functions which contains the desired virtual    function.    J is an index into F which provides the desired virtual function.     TYPE is the type in which F is located.  */
end_comment

begin_function
name|value_ptr
name|value_virtual_fn_field
parameter_list|(
name|arg1p
parameter_list|,
name|f
parameter_list|,
name|j
parameter_list|,
name|type
parameter_list|,
name|offset
parameter_list|)
name|value_ptr
modifier|*
name|arg1p
decl_stmt|;
name|struct
name|fn_field
modifier|*
name|f
decl_stmt|;
name|int
name|j
decl_stmt|;
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|int
name|offset
decl_stmt|;
block|{
name|value_ptr
name|arg1
init|=
operator|*
name|arg1p
decl_stmt|;
name|struct
name|type
modifier|*
name|type1
init|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_HAS_VTABLE
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* Deal with HP/Taligent runtime model for virtual functions */
name|value_ptr
name|vp
decl_stmt|;
name|value_ptr
name|argp
decl_stmt|;
comment|/* arg1 cast to base */
name|CORE_ADDR
name|vfunc_addr
decl_stmt|;
comment|/* address of virtual method */
name|CORE_ADDR
name|coreptr
decl_stmt|;
comment|/* pointer to target address */
name|int
name|class_index
decl_stmt|;
comment|/* which class segment pointer to use */
name|struct
name|type
modifier|*
name|ftype
init|=
name|TYPE_FN_FIELD_TYPE
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
decl_stmt|;
comment|/* method type */
name|argp
operator|=
name|value_cast
argument_list|(
name|type
argument_list|,
operator|*
name|arg1p
argument_list|)
expr_stmt|;
if|if
condition|(
name|VALUE_ADDRESS
argument_list|(
name|argp
argument_list|)
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Address of object is null; object may not have been created."
argument_list|)
expr_stmt|;
comment|/* pai: FIXME -- 32x64 possible problem? */
comment|/* First word (4 bytes) in object layout is the vtable pointer */
name|coreptr
operator|=
operator|*
operator|(
name|CORE_ADDR
operator|*
operator|)
operator|(
name|VALUE_CONTENTS
argument_list|(
name|argp
argument_list|)
operator|)
expr_stmt|;
comment|/* pai: (temp)  */
comment|/* + offset + VALUE_EMBEDDED_OFFSET (argp)); */
if|if
condition|(
operator|!
name|coreptr
condition|)
name|error
argument_list|(
literal|"Virtual table pointer is null for object; object may not have been created."
argument_list|)
expr_stmt|;
comment|/* pai/1997-05-09        * FIXME: The code here currently handles only        * the non-RRBC case of the Taligent/HP runtime spec; when RRBC        * is introduced, the condition for the "if" below will have to        * be changed to be a test for the RRBC case.  */
if|if
condition|(
literal|1
condition|)
block|{
comment|/* Non-RRBC case; the virtual function pointers are stored at fixed            * offsets in the virtual table. */
comment|/* Retrieve the offset in the virtual table from the debug            * info.  The offset of the vfunc's entry is in words from            * the beginning of the vtable; but first we have to adjust            * by HP_ACC_VFUNC_START to account for other entries */
comment|/* pai: FIXME: 32x64 problem here, a word may be 8 bytes in            * which case the multiplier should be 8 and values should be long */
name|vp
operator|=
name|value_at
argument_list|(
name|builtin_type_int
argument_list|,
name|coreptr
operator|+
literal|4
operator|*
operator|(
name|TYPE_FN_FIELD_VOFFSET
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
operator|+
name|HP_ACC_VFUNC_START
operator|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|coreptr
operator|=
operator|*
operator|(
name|CORE_ADDR
operator|*
operator|)
operator|(
name|VALUE_CONTENTS
argument_list|(
name|vp
argument_list|)
operator|)
expr_stmt|;
comment|/* coreptr now contains the address of the virtual function */
comment|/* (Actually, it contains the pointer to the plabel for the function. */
block|}
else|else
block|{
comment|/* RRBC case; the virtual function pointers are found by double            * indirection through the class segment tables. */
comment|/* Choose class segment depending on type we were passed */
name|class_index
operator|=
name|class_index_in_primary_list
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Find class segment pointer.  These are in the vtable slots after            * some other entries, so adjust by HP_ACC_VFUNC_START for that. */
comment|/* pai: FIXME 32x64 problem here, if words are 8 bytes long            * the multiplier below has to be 8 and value should be long. */
name|vp
operator|=
name|value_at
argument_list|(
name|builtin_type_int
argument_list|,
name|coreptr
operator|+
literal|4
operator|*
operator|(
name|HP_ACC_VFUNC_START
operator|+
name|class_index
operator|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Indirect once more, offset by function index */
comment|/* pai: FIXME 32x64 problem here, again multiplier could be 8 and value long */
name|coreptr
operator|=
operator|*
operator|(
name|CORE_ADDR
operator|*
operator|)
operator|(
name|VALUE_CONTENTS
argument_list|(
name|vp
argument_list|)
operator|+
literal|4
operator|*
name|TYPE_FN_FIELD_VOFFSET
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
operator|)
expr_stmt|;
name|vp
operator|=
name|value_at
argument_list|(
name|builtin_type_int
argument_list|,
name|coreptr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|coreptr
operator|=
operator|*
operator|(
name|CORE_ADDR
operator|*
operator|)
operator|(
name|VALUE_CONTENTS
argument_list|(
name|vp
argument_list|)
operator|)
expr_stmt|;
comment|/* coreptr now contains the address of the virtual function */
comment|/* (Actually, it contains the pointer to the plabel for the function.) */
block|}
if|if
condition|(
operator|!
name|coreptr
condition|)
name|error
argument_list|(
literal|"Address of virtual function is null; error in virtual table?"
argument_list|)
expr_stmt|;
comment|/* Wrap this addr in a value and return pointer */
name|vp
operator|=
name|allocate_value
argument_list|(
name|ftype
argument_list|)
expr_stmt|;
name|VALUE_TYPE
argument_list|(
name|vp
argument_list|)
operator|=
name|ftype
expr_stmt|;
name|VALUE_ADDRESS
argument_list|(
name|vp
argument_list|)
operator|=
name|coreptr
expr_stmt|;
comment|/* pai: (temp) do we need the value_ind stuff in value_fn_field? */
return|return
name|vp
return|;
block|}
else|else
block|{
comment|/* Not using HP/Taligent runtime conventions; so try to        * use g++ conventions for virtual table */
name|struct
name|type
modifier|*
name|entry_type
decl_stmt|;
comment|/* First, get the virtual function table pointer.  That comes          with a strange type, so cast it to type `pointer to long' (which          should serve just fine as a function type).  Then, index into          the table, and convert final value to appropriate function type.  */
name|value_ptr
name|entry
decl_stmt|,
name|vfn
decl_stmt|,
name|vtbl
decl_stmt|;
name|value_ptr
name|vi
init|=
name|value_from_longest
argument_list|(
name|builtin_type_int
argument_list|,
operator|(
name|LONGEST
operator|)
name|TYPE_FN_FIELD_VOFFSET
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|type
modifier|*
name|fcontext
init|=
name|TYPE_FN_FIELD_FCONTEXT
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
decl_stmt|;
name|struct
name|type
modifier|*
name|context
decl_stmt|;
if|if
condition|(
name|fcontext
operator|==
name|NULL
condition|)
comment|/* We don't have an fcontext (e.g. the program was compiled with           g++ version 1).  Try to get the vtbl from the TYPE_VPTR_BASETYPE.           This won't work right for multiple inheritance, but at least we           should do as well as GDB 3.x did.  */
name|fcontext
operator|=
name|TYPE_VPTR_BASETYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|context
operator|=
name|lookup_pointer_type
argument_list|(
name|fcontext
argument_list|)
expr_stmt|;
comment|/* Now context is a pointer to the basetype containing the vtbl.  */
if|if
condition|(
name|TYPE_TARGET_TYPE
argument_list|(
name|context
argument_list|)
operator|!=
name|type1
condition|)
block|{
name|value_ptr
name|tmp
init|=
name|value_cast
argument_list|(
name|context
argument_list|,
name|value_addr
argument_list|(
name|arg1
argument_list|)
argument_list|)
decl_stmt|;
name|VALUE_POINTED_TO_OFFSET
argument_list|(
name|tmp
argument_list|)
operator|=
literal|0
expr_stmt|;
name|arg1
operator|=
name|value_ind
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|type1
operator|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|context
operator|=
name|type1
expr_stmt|;
comment|/* Now context is the basetype containing the vtbl.  */
comment|/* This type may have been defined before its virtual function table          was.  If so, fill in the virtual function table entry for the          type now.  */
if|if
condition|(
name|TYPE_VPTR_FIELDNO
argument_list|(
name|context
argument_list|)
operator|<
literal|0
condition|)
name|fill_in_vptr_fieldno
argument_list|(
name|context
argument_list|)
expr_stmt|;
comment|/* The virtual function table is now an array of structures          which have the form { int16 offset, delta; void *pfn; }.  */
name|vtbl
operator|=
name|value_primitive_field
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|,
name|TYPE_VPTR_FIELDNO
argument_list|(
name|context
argument_list|)
argument_list|,
name|TYPE_VPTR_BASETYPE
argument_list|(
name|context
argument_list|)
argument_list|)
expr_stmt|;
comment|/* With older versions of g++, the vtbl field pointed to an array 	 of structures.  Nowadays it points directly to the structure. */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|vtbl
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_PTR
operator|&&
name|TYPE_CODE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|vtbl
argument_list|)
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_ARRAY
condition|)
block|{
comment|/* Handle the case where the vtbl field points to an 	     array of structures. */
name|vtbl
operator|=
name|value_ind
argument_list|(
name|vtbl
argument_list|)
expr_stmt|;
comment|/* Index into the virtual function table.  This is hard-coded because 	     looking up a field is not cheap, and it may be important to save 	     time, e.g. if the user has set a conditional breakpoint calling 	     a virtual function.  */
name|entry
operator|=
name|value_subscript
argument_list|(
name|vtbl
argument_list|,
name|vi
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Handle the case where the vtbl field points directly to a structure. */
name|vtbl
operator|=
name|value_add
argument_list|(
name|vtbl
argument_list|,
name|vi
argument_list|)
expr_stmt|;
name|entry
operator|=
name|value_ind
argument_list|(
name|vtbl
argument_list|)
expr_stmt|;
block|}
name|entry_type
operator|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|entry_type
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
condition|)
block|{
comment|/* Move the `this' pointer according to the virtual function table. */
name|VALUE_OFFSET
argument_list|(
name|arg1
argument_list|)
operator|+=
name|value_as_long
argument_list|(
name|value_field
argument_list|(
name|entry
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|VALUE_LAZY
argument_list|(
name|arg1
argument_list|)
condition|)
block|{
name|VALUE_LAZY
argument_list|(
name|arg1
argument_list|)
operator|=
literal|1
expr_stmt|;
name|value_fetch_lazy
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
block|}
name|vfn
operator|=
name|value_field
argument_list|(
name|entry
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|entry_type
argument_list|)
operator|==
name|TYPE_CODE_PTR
condition|)
name|vfn
operator|=
name|entry
expr_stmt|;
else|else
name|error
argument_list|(
literal|"I'm confused:  virtual function table has bad type"
argument_list|)
expr_stmt|;
comment|/* Reinstantiate the function pointer with the correct type.  */
name|VALUE_TYPE
argument_list|(
name|vfn
argument_list|)
operator|=
name|lookup_pointer_type
argument_list|(
name|TYPE_FN_FIELD_TYPE
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|arg1p
operator|=
name|arg1
expr_stmt|;
return|return
name|vfn
return|;
block|}
block|}
end_function

begin_comment
comment|/* ARG is a pointer to an object we know to be at least    a DTYPE.  BTYPE is the most derived basetype that has    already been searched (and need not be searched again).    After looking at the vtables between BTYPE and DTYPE,    return the most derived type we find.  The caller must    be satisfied when the return value == DTYPE.     FIXME-tiemann: should work with dossier entries as well.  */
end_comment

begin_function
specifier|static
name|value_ptr
name|value_headof
parameter_list|(
name|in_arg
parameter_list|,
name|btype
parameter_list|,
name|dtype
parameter_list|)
name|value_ptr
name|in_arg
decl_stmt|;
name|struct
name|type
modifier|*
name|btype
decl_stmt|,
decl|*
name|dtype
decl_stmt|;
end_function

begin_block
block|{
comment|/* First collect the vtables we must look at for this object.  */
comment|/* FIXME-tiemann: right now, just look at top-most vtable.  */
name|value_ptr
name|arg
decl_stmt|,
name|vtbl
decl_stmt|,
name|entry
decl_stmt|,
name|best_entry
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nelems
decl_stmt|;
name|int
name|offset
decl_stmt|,
name|best_offset
init|=
literal|0
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|CORE_ADDR
name|pc_for_sym
decl_stmt|;
name|char
modifier|*
name|demangled_name
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
name|btype
operator|=
name|TYPE_VPTR_BASETYPE
argument_list|(
name|dtype
argument_list|)
expr_stmt|;
name|CHECK_TYPEDEF
argument_list|(
name|btype
argument_list|)
expr_stmt|;
name|arg
operator|=
name|in_arg
expr_stmt|;
if|if
condition|(
name|btype
operator|!=
name|dtype
condition|)
name|arg
operator|=
name|value_cast
argument_list|(
name|lookup_pointer_type
argument_list|(
name|btype
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|vtbl
operator|=
name|value_ind
argument_list|(
name|value_field
argument_list|(
name|value_ind
argument_list|(
name|arg
argument_list|)
argument_list|,
name|TYPE_VPTR_FIELDNO
argument_list|(
name|btype
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check that VTBL looks like it points to a virtual function table.  */
name|msymbol
operator|=
name|lookup_minimal_symbol_by_pc
argument_list|(
name|VALUE_ADDRESS
argument_list|(
name|vtbl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|msymbol
operator|==
name|NULL
operator|||
operator|(
name|demangled_name
operator|=
name|SYMBOL_NAME
argument_list|(
name|msymbol
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|!
name|VTBL_PREFIX_P
argument_list|(
name|demangled_name
argument_list|)
condition|)
block|{
comment|/* If we expected to find a vtable, but did not, let the user 	 know that we aren't happy, but don't throw an error. 	 FIXME: there has to be a better way to do this.  */
name|struct
name|type
modifier|*
name|error_type
init|=
operator|(
expr|struct
name|type
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|type
argument_list|)
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|error_type
argument_list|,
name|VALUE_TYPE
argument_list|(
name|in_arg
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|error_type
argument_list|)
operator|=
name|savestring
argument_list|(
literal|"suspicious *"
argument_list|,
sizeof|sizeof
argument_list|(
literal|"suspicious *"
argument_list|)
argument_list|)
expr_stmt|;
name|VALUE_TYPE
argument_list|(
name|in_arg
argument_list|)
operator|=
name|error_type
expr_stmt|;
return|return
name|in_arg
return|;
block|}
comment|/* Now search through the virtual function table.  */
name|entry
operator|=
name|value_ind
argument_list|(
name|vtbl
argument_list|)
expr_stmt|;
name|nelems
operator|=
name|longest_to_int
argument_list|(
name|value_as_long
argument_list|(
name|value_field
argument_list|(
name|entry
argument_list|,
literal|2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|nelems
condition|;
name|i
operator|++
control|)
block|{
name|entry
operator|=
name|value_subscript
argument_list|(
name|vtbl
argument_list|,
name|value_from_longest
argument_list|(
name|builtin_type_int
argument_list|,
operator|(
name|LONGEST
operator|)
name|i
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This won't work if we're using thunks. */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|entry
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|TYPE_CODE_STRUCT
condition|)
break|break;
name|offset
operator|=
name|longest_to_int
argument_list|(
name|value_as_long
argument_list|(
name|value_field
argument_list|(
name|entry
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we use '<=' we can handle single inheritance        * where all offsets are zero - just use the first entry found. */
if|if
condition|(
name|offset
operator|<=
name|best_offset
condition|)
block|{
name|best_offset
operator|=
name|offset
expr_stmt|;
name|best_entry
operator|=
name|entry
expr_stmt|;
block|}
block|}
comment|/* Move the pointer according to BEST_ENTRY's offset, and figure      out what type we should return as the new pointer.  */
if|if
condition|(
name|best_entry
operator|==
literal|0
condition|)
block|{
comment|/* An alternative method (which should no longer be necessary).        * But we leave it in for future use, when we will hopefully        * have optimizes the vtable to use thunks instead of offsets. */
comment|/* Use the name of vtable itself to extract a base type. */
name|demangled_name
operator|+=
literal|4
expr_stmt|;
comment|/* Skip _vt$ prefix. */
block|}
else|else
block|{
name|pc_for_sym
operator|=
name|value_as_pointer
argument_list|(
name|value_field
argument_list|(
name|best_entry
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|sym
operator|=
name|find_pc_function
argument_list|(
name|pc_for_sym
argument_list|)
expr_stmt|;
name|demangled_name
operator|=
name|cplus_demangle
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|DMGL_ANSI
argument_list|)
expr_stmt|;
operator|*
operator|(
name|strchr
argument_list|(
name|demangled_name
argument_list|,
literal|':'
argument_list|)
operator|)
operator|=
literal|'\0'
expr_stmt|;
block|}
name|sym
operator|=
name|lookup_symbol
argument_list|(
name|demangled_name
argument_list|,
literal|0
argument_list|,
name|VAR_NAMESPACE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"could not find type declaration for `%s'"
argument_list|,
name|demangled_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|best_entry
condition|)
block|{
name|free
argument_list|(
name|demangled_name
argument_list|)
expr_stmt|;
name|arg
operator|=
name|value_add
argument_list|(
name|value_cast
argument_list|(
name|builtin_type_int
argument_list|,
name|arg
argument_list|)
argument_list|,
name|value_field
argument_list|(
name|best_entry
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|arg
operator|=
name|in_arg
expr_stmt|;
name|VALUE_TYPE
argument_list|(
name|arg
argument_list|)
operator|=
name|lookup_pointer_type
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|arg
return|;
block|}
end_block

begin_comment
comment|/* ARG is a pointer object of type TYPE.  If TYPE has virtual    function tables, probe ARG's tables (including the vtables    of its baseclasses) to figure out the most derived type that ARG    could actually be a pointer to.  */
end_comment

begin_function
name|value_ptr
name|value_from_vtable_info
parameter_list|(
name|arg
parameter_list|,
name|type
parameter_list|)
name|value_ptr
name|arg
decl_stmt|;
name|struct
name|type
modifier|*
name|type
decl_stmt|;
block|{
comment|/* Take care of preliminaries.  */
if|if
condition|(
name|TYPE_VPTR_FIELDNO
argument_list|(
name|type
argument_list|)
operator|<
literal|0
condition|)
name|fill_in_vptr_fieldno
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_VPTR_FIELDNO
argument_list|(
name|type
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|value_headof
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|,
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if the INDEXth field of TYPE is a virtual baseclass    pointer which is for the base class whose type is BASECLASS.  */
end_comment

begin_function
specifier|static
name|int
name|vb_match
parameter_list|(
name|type
parameter_list|,
name|index
parameter_list|,
name|basetype
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|int
name|index
decl_stmt|;
name|struct
name|type
modifier|*
name|basetype
decl_stmt|;
block|{
name|struct
name|type
modifier|*
name|fieldtype
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|index
argument_list|)
decl_stmt|;
name|char
modifier|*
name|field_class_name
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|*
name|name
operator|!=
literal|'_'
condition|)
return|return
literal|0
return|;
comment|/* gcc 2.4 uses _vb$.  */
if|if
condition|(
name|name
index|[
literal|1
index|]
operator|==
literal|'v'
operator|&&
name|name
index|[
literal|2
index|]
operator|==
literal|'b'
operator|&&
name|is_cplus_marker
argument_list|(
name|name
index|[
literal|3
index|]
argument_list|)
condition|)
name|field_class_name
operator|=
name|name
operator|+
literal|4
expr_stmt|;
comment|/* gcc 2.5 will use __vb_.  */
if|if
condition|(
name|name
index|[
literal|1
index|]
operator|==
literal|'_'
operator|&&
name|name
index|[
literal|2
index|]
operator|==
literal|'v'
operator|&&
name|name
index|[
literal|3
index|]
operator|==
literal|'b'
operator|&&
name|name
index|[
literal|4
index|]
operator|==
literal|'_'
condition|)
name|field_class_name
operator|=
name|name
operator|+
literal|5
expr_stmt|;
if|if
condition|(
name|field_class_name
operator|==
name|NULL
condition|)
comment|/* This field is not a virtual base class pointer.  */
return|return
literal|0
return|;
comment|/* It's a virtual baseclass pointer, now we just need to find out whether      it is for this baseclass.  */
name|fieldtype
operator|=
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|fieldtype
operator|==
name|NULL
operator|||
name|TYPE_CODE
argument_list|(
name|fieldtype
argument_list|)
operator|!=
name|TYPE_CODE_PTR
condition|)
comment|/* "Can't happen".  */
return|return
literal|0
return|;
comment|/* What we check for is that either the types are equal (needed for      nameless types) or have the same name.  This is ugly, and a more      elegant solution should be devised (which would probably just push      the ugliness into symbol reading unless we change the stabs format).  */
if|if
condition|(
name|TYPE_TARGET_TYPE
argument_list|(
name|fieldtype
argument_list|)
operator|==
name|basetype
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|basetype
argument_list|)
operator|!=
name|NULL
operator|&&
name|TYPE_NAME
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|fieldtype
argument_list|)
argument_list|)
operator|!=
name|NULL
operator|&&
name|STREQ
argument_list|(
name|TYPE_NAME
argument_list|(
name|basetype
argument_list|)
argument_list|,
name|TYPE_NAME
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|fieldtype
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Compute the offset of the baseclass which is    the INDEXth baseclass of class TYPE,    for value at VALADDR (in host) at ADDRESS (in target).    The result is the offset of the baseclass value relative    to (the address of)(ARG) + OFFSET.     -1 is returned on error. */
end_comment

begin_function
name|int
name|baseclass_offset
parameter_list|(
name|type
parameter_list|,
name|index
parameter_list|,
name|valaddr
parameter_list|,
name|address
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|int
name|index
decl_stmt|;
name|char
modifier|*
name|valaddr
decl_stmt|;
name|CORE_ADDR
name|address
decl_stmt|;
block|{
name|struct
name|type
modifier|*
name|basetype
init|=
name|TYPE_BASECLASS
argument_list|(
name|type
argument_list|,
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
name|BASETYPE_VIA_VIRTUAL
argument_list|(
name|type
argument_list|,
name|index
argument_list|)
condition|)
block|{
comment|/* Must hunt for the pointer to this virtual baseclass.  */
specifier|register
name|int
name|i
decl_stmt|,
name|len
init|=
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|register
name|int
name|n_baseclasses
init|=
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
decl_stmt|;
comment|/* First look for the virtual baseclass pointer 	 in the fields.  */
for|for
control|(
name|i
operator|=
name|n_baseclasses
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|vb_match
argument_list|(
name|type
argument_list|,
name|i
argument_list|,
name|basetype
argument_list|)
condition|)
block|{
name|CORE_ADDR
name|addr
init|=
name|unpack_pointer
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|valaddr
operator|+
operator|(
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
operator|/
literal|8
operator|)
argument_list|)
decl_stmt|;
return|return
name|addr
operator|-
operator|(
name|LONGEST
operator|)
name|address
return|;
block|}
block|}
comment|/* Not in the fields, so try looking through the baseclasses.  */
for|for
control|(
name|i
operator|=
name|index
operator|+
literal|1
init|;
name|i
operator|<
name|n_baseclasses
condition|;
name|i
operator|++
control|)
block|{
name|int
name|boffset
init|=
name|baseclass_offset
argument_list|(
name|type
argument_list|,
name|i
argument_list|,
name|valaddr
argument_list|,
name|address
argument_list|)
decl_stmt|;
if|if
condition|(
name|boffset
condition|)
return|return
name|boffset
return|;
block|}
comment|/* Not found.  */
return|return
operator|-
literal|1
return|;
block|}
comment|/* Baseclass is easily computed.  */
return|return
name|TYPE_BASECLASS_BITPOS
argument_list|(
name|type
argument_list|,
name|index
argument_list|)
operator|/
literal|8
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Unpack a field FIELDNO of the specified TYPE, from the anonymous object at    VALADDR.     Extracting bits depends on endianness of the machine.  Compute the    number of least significant bits to discard.  For big endian machines,    we compute the total number of bits in the anonymous object, subtract    off the bit count from the MSB of the object to the MSB of the    bitfield, then the size of the bitfield, which leaves the LSB discard    count.  For little endian machines, the discard count is simply the    number of bits from the LSB of the anonymous object to the LSB of the    bitfield.     If the field is signed, we also do sign extension. */
end_comment

begin_function
name|LONGEST
name|unpack_field_as_long
parameter_list|(
name|type
parameter_list|,
name|valaddr
parameter_list|,
name|fieldno
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|char
modifier|*
name|valaddr
decl_stmt|;
name|int
name|fieldno
decl_stmt|;
block|{
name|ULONGEST
name|val
decl_stmt|;
name|ULONGEST
name|valmask
decl_stmt|;
name|int
name|bitpos
init|=
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|fieldno
argument_list|)
decl_stmt|;
name|int
name|bitsize
init|=
name|TYPE_FIELD_BITSIZE
argument_list|(
name|type
argument_list|,
name|fieldno
argument_list|)
decl_stmt|;
name|int
name|lsbcount
decl_stmt|;
name|struct
name|type
modifier|*
name|field_type
decl_stmt|;
name|val
operator|=
name|extract_unsigned_integer
argument_list|(
name|valaddr
operator|+
name|bitpos
operator|/
literal|8
argument_list|,
sizeof|sizeof
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
name|field_type
operator|=
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|fieldno
argument_list|)
expr_stmt|;
name|CHECK_TYPEDEF
argument_list|(
name|field_type
argument_list|)
expr_stmt|;
comment|/* Extract bits.  See comment above. */
if|if
condition|(
name|BITS_BIG_ENDIAN
condition|)
name|lsbcount
operator|=
operator|(
sizeof|sizeof
name|val
operator|*
literal|8
operator|-
name|bitpos
operator|%
literal|8
operator|-
name|bitsize
operator|)
expr_stmt|;
else|else
name|lsbcount
operator|=
operator|(
name|bitpos
operator|%
literal|8
operator|)
expr_stmt|;
name|val
operator|>>=
name|lsbcount
expr_stmt|;
comment|/* If the field does not entirely fill a LONGEST, then zero the sign bits.      If the field is signed, and is negative, then sign extend. */
if|if
condition|(
operator|(
name|bitsize
operator|>
literal|0
operator|)
operator|&&
operator|(
name|bitsize
operator|<
literal|8
operator|*
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|val
argument_list|)
operator|)
condition|)
block|{
name|valmask
operator|=
operator|(
operator|(
operator|(
name|ULONGEST
operator|)
literal|1
operator|)
operator|<<
name|bitsize
operator|)
operator|-
literal|1
expr_stmt|;
name|val
operator|&=
name|valmask
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_UNSIGNED
argument_list|(
name|field_type
argument_list|)
condition|)
block|{
if|if
condition|(
name|val
operator|&
operator|(
name|valmask
operator|^
operator|(
name|valmask
operator|>>
literal|1
operator|)
operator|)
condition|)
block|{
name|val
operator||=
operator|~
name|valmask
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Modify the value of a bitfield.  ADDR points to a block of memory in    target byte order; the bitfield starts in the byte pointed to.  FIELDVAL    is the desired value of the field, in host byte order.  BITPOS and BITSIZE    indicate which bits (in target bit order) comprise the bitfield.  */
end_comment

begin_function
name|void
name|modify_field
parameter_list|(
name|addr
parameter_list|,
name|fieldval
parameter_list|,
name|bitpos
parameter_list|,
name|bitsize
parameter_list|)
name|char
modifier|*
name|addr
decl_stmt|;
name|LONGEST
name|fieldval
decl_stmt|;
name|int
name|bitpos
decl_stmt|,
name|bitsize
decl_stmt|;
block|{
name|LONGEST
name|oword
decl_stmt|;
comment|/* If a negative fieldval fits in the field in question, chop      off the sign extension bits.  */
if|if
condition|(
name|bitsize
operator|<
operator|(
literal|8
operator|*
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|fieldval
argument_list|)
operator|)
operator|&&
operator|(
operator|~
name|fieldval
operator|&
operator|~
operator|(
operator|(
literal|1
operator|<<
operator|(
name|bitsize
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
condition|)
name|fieldval
operator|=
name|fieldval
operator|&
operator|(
operator|(
literal|1
operator|<<
name|bitsize
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* Warn if value is too big to fit in the field in question.  */
if|if
condition|(
name|bitsize
operator|<
operator|(
literal|8
operator|*
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|fieldval
argument_list|)
operator|)
operator|&&
literal|0
operator|!=
operator|(
name|fieldval
operator|&
operator|~
operator|(
operator|(
literal|1
operator|<<
name|bitsize
operator|)
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
comment|/* FIXME: would like to include fieldval in the message, but 	 we don't have a sprintf_longest.  */
name|warning
argument_list|(
literal|"Value does not fit in %d bits."
argument_list|,
name|bitsize
argument_list|)
expr_stmt|;
comment|/* Truncate it, otherwise adjoining fields may be corrupted.  */
name|fieldval
operator|=
name|fieldval
operator|&
operator|(
operator|(
literal|1
operator|<<
name|bitsize
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
block|}
name|oword
operator|=
name|extract_signed_integer
argument_list|(
name|addr
argument_list|,
sizeof|sizeof
name|oword
argument_list|)
expr_stmt|;
comment|/* Shifting for bit field depends on endianness of the target machine.  */
if|if
condition|(
name|BITS_BIG_ENDIAN
condition|)
name|bitpos
operator|=
sizeof|sizeof
argument_list|(
name|oword
argument_list|)
operator|*
literal|8
operator|-
name|bitpos
operator|-
name|bitsize
expr_stmt|;
comment|/* Mask out old value, while avoiding shifts>= size of oword */
if|if
condition|(
name|bitsize
operator|<
literal|8
operator|*
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|oword
argument_list|)
condition|)
name|oword
operator|&=
operator|~
operator|(
operator|(
operator|(
operator|(
operator|(
name|ULONGEST
operator|)
literal|1
operator|)
operator|<<
name|bitsize
operator|)
operator|-
literal|1
operator|)
operator|<<
name|bitpos
operator|)
expr_stmt|;
else|else
name|oword
operator|&=
operator|~
operator|(
operator|(
operator|~
operator|(
name|ULONGEST
operator|)
literal|0
operator|)
operator|<<
name|bitpos
operator|)
expr_stmt|;
name|oword
operator||=
name|fieldval
operator|<<
name|bitpos
expr_stmt|;
name|store_signed_integer
argument_list|(
name|addr
argument_list|,
sizeof|sizeof
name|oword
argument_list|,
name|oword
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Convert C numbers into newly allocated values */
end_comment

begin_function
name|value_ptr
name|value_from_longest
parameter_list|(
name|type
parameter_list|,
name|num
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
specifier|register
name|LONGEST
name|num
decl_stmt|;
block|{
specifier|register
name|value_ptr
name|val
init|=
name|allocate_value
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|register
name|enum
name|type_code
name|code
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
name|retry
label|:
name|code
operator|=
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|len
operator|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|TYPE_CODE_TYPEDEF
case|:
name|type
operator|=
name|check_typedef
argument_list|(
name|type
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
case|case
name|TYPE_CODE_INT
case|:
case|case
name|TYPE_CODE_CHAR
case|:
case|case
name|TYPE_CODE_ENUM
case|:
case|case
name|TYPE_CODE_BOOL
case|:
case|case
name|TYPE_CODE_RANGE
case|:
name|store_signed_integer
argument_list|(
name|VALUE_CONTENTS_RAW
argument_list|(
name|val
argument_list|)
argument_list|,
name|len
argument_list|,
name|num
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_REF
case|:
case|case
name|TYPE_CODE_PTR
case|:
comment|/* This assumes that all pointers of a given length 	 have the same form.  */
name|store_address
argument_list|(
name|VALUE_CONTENTS_RAW
argument_list|(
name|val
argument_list|)
argument_list|,
name|len
argument_list|,
operator|(
name|CORE_ADDR
operator|)
name|num
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Unexpected type (%d) encountered for integer constant."
argument_list|,
name|code
argument_list|)
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
end_function

begin_function
name|value_ptr
name|value_from_double
parameter_list|(
name|type
parameter_list|,
name|num
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|DOUBLEST
name|num
decl_stmt|;
block|{
specifier|register
name|value_ptr
name|val
init|=
name|allocate_value
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|struct
name|type
modifier|*
name|base_type
init|=
name|check_typedef
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|register
name|enum
name|type_code
name|code
init|=
name|TYPE_CODE
argument_list|(
name|base_type
argument_list|)
decl_stmt|;
specifier|register
name|int
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|base_type
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|TYPE_CODE_FLT
condition|)
block|{
name|store_floating
argument_list|(
name|VALUE_CONTENTS_RAW
argument_list|(
name|val
argument_list|)
argument_list|,
name|len
argument_list|,
name|num
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"Unexpected type encountered for floating constant."
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Deal with the value that is "about to be returned".  */
end_comment

begin_comment
comment|/* Return the value that a function returning now    would be returning to its caller, assuming its type is VALTYPE.    RETBUF is where we look for what ought to be the contents    of the registers (in raw form).  This is because it is often    desirable to restore old values to those registers    after saving the contents of interest, and then call    this function using the saved values.    struct_return is non-zero when the function in question is    using the structure return conventions on the machine in question;    0 when it is using the value returning conventions (this often    means returning pointer to where structure is vs. returning value). */
end_comment

begin_function
name|value_ptr
name|value_being_returned
parameter_list|(
name|valtype
parameter_list|,
name|retbuf
parameter_list|,
name|struct_return
parameter_list|)
specifier|register
name|struct
name|type
modifier|*
name|valtype
decl_stmt|;
name|char
name|retbuf
index|[
name|REGISTER_BYTES
index|]
decl_stmt|;
name|int
name|struct_return
decl_stmt|;
comment|/*ARGSUSED*/
block|{
specifier|register
name|value_ptr
name|val
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|EXTRACT_STRUCT_VALUE_ADDRESS
argument_list|)
comment|/* If this is not defined, just use EXTRACT_RETURN_VALUE instead.  */
if|if
condition|(
name|struct_return
condition|)
block|{
name|addr
operator|=
name|EXTRACT_STRUCT_VALUE_ADDRESS
argument_list|(
name|retbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|addr
condition|)
name|error
argument_list|(
literal|"Function return value unknown"
argument_list|)
expr_stmt|;
return|return
name|value_at
argument_list|(
name|valtype
argument_list|,
name|addr
argument_list|,
name|NULL
argument_list|)
return|;
block|}
endif|#
directive|endif
name|val
operator|=
name|allocate_value
argument_list|(
name|valtype
argument_list|)
expr_stmt|;
name|CHECK_TYPEDEF
argument_list|(
name|valtype
argument_list|)
expr_stmt|;
name|EXTRACT_RETURN_VALUE
argument_list|(
name|valtype
argument_list|,
name|retbuf
argument_list|,
name|VALUE_CONTENTS_RAW
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Should we use EXTRACT_STRUCT_VALUE_ADDRESS instead of    EXTRACT_RETURN_VALUE?  GCC_P is true if compiled with gcc    and TYPE is the type (which is known to be struct, union or array).     On most machines, the struct convention is used unless we are    using gcc and the type is of a special size.  */
end_comment

begin_comment
comment|/* As of about 31 Mar 93, GCC was changed to be compatible with the    native compiler.  GCC 2.3.3 was the last release that did it the    old way.  Since gcc2_compiled was not changed, we have no    way to correctly win in all cases, so we just do the right thing    for gcc1 and for gcc2 after this change.  Thus it loses for gcc    2.0-2.3.3.  This is somewhat unfortunate, but changing gcc2_compiled    would cause more chaos than dealing with some struct returns being    handled wrong.  */
end_comment

begin_function
name|int
name|generic_use_struct_convention
parameter_list|(
name|gcc_p
parameter_list|,
name|value_type
parameter_list|)
name|int
name|gcc_p
decl_stmt|;
name|struct
name|type
modifier|*
name|value_type
decl_stmt|;
block|{
return|return
operator|!
operator|(
operator|(
name|gcc_p
operator|==
literal|1
operator|)
operator|&&
operator|(
name|TYPE_LENGTH
argument_list|(
name|value_type
argument_list|)
operator|==
literal|1
operator|||
name|TYPE_LENGTH
argument_list|(
name|value_type
argument_list|)
operator|==
literal|2
operator|||
name|TYPE_LENGTH
argument_list|(
name|value_type
argument_list|)
operator|==
literal|4
operator|||
name|TYPE_LENGTH
argument_list|(
name|value_type
argument_list|)
operator|==
literal|8
operator|)
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|USE_STRUCT_CONVENTION
end_ifndef

begin_define
define|#
directive|define
name|USE_STRUCT_CONVENTION
parameter_list|(
name|gcc_p
parameter_list|,
name|type
parameter_list|)
value|generic_use_struct_convention (gcc_p, type)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Some fundamental types (such as long double) are returned on the stack for    certain architectures.  This macro should return true for any type besides    struct, union or array that gets returned on the stack.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|RETURN_VALUE_ON_STACK
end_ifndef

begin_define
define|#
directive|define
name|RETURN_VALUE_ON_STACK
parameter_list|(
name|TYPE
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Return true if the function specified is using the structure returning    convention on this machine to return arguments, or 0 if it is using    the value returning convention.  FUNCTION is the value representing    the function, FUNCADDR is the address of the function, and VALUE_TYPE    is the type returned by the function.  GCC_P is nonzero if compiled    with GCC.  */
end_comment

begin_function
name|int
name|using_struct_return
parameter_list|(
name|function
parameter_list|,
name|funcaddr
parameter_list|,
name|value_type
parameter_list|,
name|gcc_p
parameter_list|)
name|value_ptr
name|function
decl_stmt|;
name|CORE_ADDR
name|funcaddr
decl_stmt|;
name|struct
name|type
modifier|*
name|value_type
decl_stmt|;
name|int
name|gcc_p
decl_stmt|;
comment|/*ARGSUSED*/
block|{
specifier|register
name|enum
name|type_code
name|code
init|=
name|TYPE_CODE
argument_list|(
name|value_type
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|TYPE_CODE_ERROR
condition|)
name|error
argument_list|(
literal|"Function return type unknown."
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|TYPE_CODE_STRUCT
operator|||
name|code
operator|==
name|TYPE_CODE_UNION
operator|||
name|code
operator|==
name|TYPE_CODE_ARRAY
operator|||
name|RETURN_VALUE_ON_STACK
argument_list|(
name|value_type
argument_list|)
condition|)
return|return
name|USE_STRUCT_CONVENTION
argument_list|(
name|gcc_p
argument_list|,
name|value_type
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Store VAL so it will be returned if a function returns now.    Does not verify that VAL's type matches what the current    function wants to return.  */
end_comment

begin_function
name|void
name|set_return_value
parameter_list|(
name|val
parameter_list|)
name|value_ptr
name|val
decl_stmt|;
block|{
name|struct
name|type
modifier|*
name|type
init|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
decl_stmt|;
specifier|register
name|enum
name|type_code
name|code
init|=
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|TYPE_CODE_ERROR
condition|)
name|error
argument_list|(
literal|"Function return type unknown."
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|TYPE_CODE_STRUCT
operator|||
name|code
operator|==
name|TYPE_CODE_UNION
condition|)
comment|/* FIXME, implement struct return.  */
name|error
argument_list|(
literal|"GDB does not support specifying a struct or union return value."
argument_list|)
expr_stmt|;
name|STORE_RETURN_VALUE
argument_list|(
name|type
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|_initialize_values
parameter_list|()
block|{
name|add_cmd
argument_list|(
literal|"convenience"
argument_list|,
name|no_class
argument_list|,
name|show_convenience
argument_list|,
literal|"Debugger convenience (\"$foo\") variables.\n\ These variables are created when you assign them values;\n\ thus, \"print $foo=1\" gives \"$foo\" the value 1.  Values may be any type.\n\n\ A few convenience variables are given values automatically:\n\ \"$_\"holds the last address examined with \"x\" or \"info lines\",\n\ \"$__\" holds the contents of the last address examined with \"x\"."
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"values"
argument_list|,
name|no_class
argument_list|,
name|show_values
argument_list|,
literal|"Elements of value history around item number IDX (or last ten)."
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

