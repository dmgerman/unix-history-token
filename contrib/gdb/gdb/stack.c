begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Print and select stack frames for GDB, the GNU debugger.     Copyright 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994,    1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004 Free    Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"source.h"
end_include

begin_include
include|#
directive|include
file|"breakpoint.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"annotate.h"
end_include

begin_include
include|#
directive|include
file|"ui-out.h"
end_include

begin_include
include|#
directive|include
file|"block.h"
end_include

begin_include
include|#
directive|include
file|"stack.h"
end_include

begin_include
include|#
directive|include
file|"gdb_assert.h"
end_include

begin_include
include|#
directive|include
file|"dictionary.h"
end_include

begin_include
include|#
directive|include
file|"reggroups.h"
end_include

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_comment
comment|/* Prototypes for exported functions. */
end_comment

begin_function_decl
name|void
name|args_info
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|locals_info
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
function_decl|(
modifier|*
name|selected_frame_level_changed_hook
function_decl|)
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|_initialize_stack
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Prototypes for local functions. */
end_comment

begin_function_decl
specifier|static
name|void
name|down_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|down_silently_base
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|down_silently_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|up_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|up_silently_base
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|up_silently_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|frame_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|current_frame_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_frame_arg_vars
parameter_list|(
name|struct
name|frame_info
modifier|*
parameter_list|,
name|struct
name|ui_file
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|catch_info
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|args_plus_locals_info
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_frame_label_vars
parameter_list|(
name|struct
name|frame_info
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|ui_file
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_frame_local_vars
parameter_list|(
name|struct
name|frame_info
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|ui_file
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|print_block_frame_labels
parameter_list|(
name|struct
name|block
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|struct
name|ui_file
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|print_block_frame_locals
parameter_list|(
name|struct
name|block
modifier|*
parameter_list|,
name|struct
name|frame_info
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|ui_file
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_frame
parameter_list|(
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|,
name|int
name|level
parameter_list|,
name|int
name|source
parameter_list|,
name|int
name|args
parameter_list|,
name|struct
name|symtab_and_line
name|sal
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|backtrace_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|frame_info
modifier|*
name|parse_frame_specification
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|frame_info
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|int
name|addressprint
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print addresses, or stay symbolic only? */
end_comment

begin_comment
comment|/* Zero means do things normally; we are interacting directly with the    user.  One means print the full filename and linenumber when a    frame is printed, and do so in a format emacs18/emacs19.22 can    parse.  Two means print similar annotations, but in many more    cases and in a slightly different syntax.  */
end_comment

begin_decl_stmt
name|int
name|annotation_level
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_struct
struct|struct
name|print_stack_frame_args
block|{
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
name|int
name|level
decl_stmt|;
name|int
name|source
decl_stmt|;
name|int
name|args
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Show or print the frame arguments.    Pass the args the way catch_errors wants them.  */
end_comment

begin_function_decl
specifier|static
name|int
name|print_stack_frame_stub
parameter_list|(
name|void
modifier|*
name|args
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|print_stack_frame_stub
parameter_list|(
name|void
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|print_stack_frame_args
modifier|*
name|p
init|=
operator|(
expr|struct
name|print_stack_frame_args
operator|*
operator|)
name|args
decl_stmt|;
name|print_frame_info
argument_list|(
name|p
operator|->
name|fi
argument_list|,
name|p
operator|->
name|level
argument_list|,
name|p
operator|->
name|source
argument_list|,
name|p
operator|->
name|args
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Show or print a stack frame briefly.  FRAME_INFI should be the frame info    and LEVEL should be its level in the stack (or -1 for level not defined).    This prints the level, the function executing, the arguments,    and the file name and line number.    If the pc is not at the beginning of the source line,    the actual pc is printed at the beginning.     If SOURCE is 1, print the source line as well.    If SOURCE is -1, print ONLY the source line.  */
end_comment

begin_function
name|void
name|print_stack_frame
parameter_list|(
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|,
name|int
name|level
parameter_list|,
name|int
name|source
parameter_list|)
block|{
name|struct
name|print_stack_frame_args
name|args
decl_stmt|;
name|args
operator|.
name|fi
operator|=
name|fi
expr_stmt|;
name|args
operator|.
name|level
operator|=
name|level
expr_stmt|;
name|args
operator|.
name|source
operator|=
name|source
expr_stmt|;
name|args
operator|.
name|args
operator|=
literal|1
expr_stmt|;
name|catch_errors
argument_list|(
name|print_stack_frame_stub
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|args
argument_list|,
literal|""
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|print_args_args
block|{
name|struct
name|symbol
modifier|*
name|func
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
name|struct
name|ui_file
modifier|*
name|stream
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|print_args_stub
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Print nameless args on STREAM.    FI is the frameinfo for this frame, START is the offset    of the first nameless arg, and NUM is the number of nameless args to    print.  FIRST is nonzero if this is the first argument (not just    the first nameless arg).  */
end_comment

begin_function
specifier|static
name|void
name|print_frame_nameless_args
parameter_list|(
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|,
name|long
name|start
parameter_list|,
name|int
name|num
parameter_list|,
name|int
name|first
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|CORE_ADDR
name|argsaddr
decl_stmt|;
name|long
name|arg_value
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
name|argsaddr
operator|=
name|get_frame_args_address
argument_list|(
name|fi
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|argsaddr
condition|)
return|return;
name|arg_value
operator|=
name|read_memory_integer
argument_list|(
name|argsaddr
operator|+
name|start
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|first
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%ld"
argument_list|,
name|arg_value
argument_list|)
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
name|start
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print the arguments of a stack frame, given the function FUNC    running in that frame (as a symbol), the info on the frame,    and the number of args according to the stack frame (or -1 if unknown).  */
end_comment

begin_comment
comment|/* References here and elsewhere to "number of args according to the    stack frame" appear in all cases to refer to "number of ints of args    according to the stack frame".  At least for VAX, i386, isi.  */
end_comment

begin_function
specifier|static
name|void
name|print_frame_args
parameter_list|(
name|struct
name|symbol
modifier|*
name|func
parameter_list|,
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|,
name|int
name|num
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|)
block|{
name|struct
name|block
modifier|*
name|b
init|=
name|NULL
decl_stmt|;
name|int
name|first
init|=
literal|1
decl_stmt|;
name|struct
name|dict_iterator
name|iter
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|struct
name|value
modifier|*
name|val
decl_stmt|;
comment|/* Offset of next stack argument beyond the one we have seen that is      at the highest offset.      -1 if we haven't come to a stack argument yet.  */
name|long
name|highest_offset
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|arg_size
decl_stmt|;
comment|/* Number of ints of arguments that we have printed so far.  */
name|int
name|args_printed
init|=
literal|0
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|,
modifier|*
name|list_chain
decl_stmt|;
name|struct
name|ui_stream
modifier|*
name|stb
decl_stmt|;
name|stb
operator|=
name|ui_out_stream_new
argument_list|(
name|uiout
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup_ui_out_stream_delete
argument_list|(
name|stb
argument_list|)
expr_stmt|;
if|if
condition|(
name|func
condition|)
block|{
name|b
operator|=
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|func
argument_list|)
expr_stmt|;
name|ALL_BLOCK_SYMBOLS
argument_list|(
argument|b
argument_list|,
argument|iter
argument_list|,
argument|sym
argument_list|)
block|{
name|QUIT
expr_stmt|;
comment|/* Keep track of the highest stack argument offset seen, and 	     skip over any kinds of symbols we don't care about.  */
switch|switch
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
condition|)
block|{
case|case
name|LOC_ARG
case|:
case|case
name|LOC_REF_ARG
case|:
block|{
name|long
name|current_offset
init|=
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
decl_stmt|;
name|arg_size
operator|=
name|TYPE_LENGTH
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Compute address of next argument by adding the size of 		   this argument and rounding to an int boundary.  */
name|current_offset
operator|=
operator|(
operator|(
name|current_offset
operator|+
name|arg_size
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
comment|/* If this is the highest offset seen yet, set highest_offset.  */
if|if
condition|(
name|highest_offset
operator|==
operator|-
literal|1
operator|||
operator|(
name|current_offset
operator|>
name|highest_offset
operator|)
condition|)
name|highest_offset
operator|=
name|current_offset
expr_stmt|;
comment|/* Add the number of ints we're about to print to args_printed.  */
name|args_printed
operator|+=
operator|(
name|arg_size
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
block|}
comment|/* We care about types of symbols, but don't need to keep track of 		 stack offsets in them.  */
case|case
name|LOC_REGPARM
case|:
case|case
name|LOC_REGPARM_ADDR
case|:
case|case
name|LOC_LOCAL_ARG
case|:
case|case
name|LOC_BASEREG_ARG
case|:
case|case
name|LOC_COMPUTED_ARG
case|:
break|break;
comment|/* Other types of symbols we just skip over.  */
default|default:
continue|continue;
block|}
comment|/* We have to look up the symbol because arguments can have 	     two entries (one a parameter, one a local) and the one we 	     want is the local, which lookup_symbol will find for us. 	     This includes gcc1 (not gcc2) on the sparc when passing a 	     small structure and gcc2 when the argument type is float 	     and it is passed as a double and converted to float by 	     the prologue (in the latter case the type of the LOC_ARG 	     symbol is double and the type of the LOC_LOCAL symbol is 	     float).  */
comment|/* But if the parameter name is null, don't try it. 	     Null parameter names occur on the RS/6000, for traceback tables. 	     FIXME, should we even print them?  */
if|if
condition|(
operator|*
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
condition|)
block|{
name|struct
name|symbol
modifier|*
name|nsym
decl_stmt|;
name|nsym
operator|=
name|lookup_symbol
argument_list|(
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|b
argument_list|,
name|VAR_DOMAIN
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
operator|(
expr|struct
name|symtab
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|SYMBOL_CLASS
argument_list|(
name|nsym
argument_list|)
operator|==
name|LOC_REGISTER
condition|)
block|{
comment|/* There is a LOC_ARG/LOC_REGISTER pair.  This means that 		     it was passed on the stack and loaded into a register, 		     or passed in a register and stored in a stack slot. 		     GDB 3.x used the LOC_ARG; GDB 4.0-4.11 used the LOC_REGISTER.  		     Reasons for using the LOC_ARG: 		     (1) because find_saved_registers may be slow for remote 		     debugging, 		     (2) because registers are often re-used and stack slots 		     rarely (never?) are.  Therefore using the stack slot is 		     much less likely to print garbage.  		     Reasons why we might want to use the LOC_REGISTER: 		     (1) So that the backtrace prints the same value as 		     "print foo".  I see no compelling reason why this needs 		     to be the case; having the backtrace print the value which 		     was passed in, and "print foo" print the value as modified 		     within the called function, makes perfect sense to me.  		     Additional note:  It might be nice if "info args" displayed 		     both values. 		     One more note:  There is a case with sparc structure passing 		     where we need to use the LOC_REGISTER, but this is dealt with 		     by creating a single LOC_REGPARM in symbol reading.  */
comment|/* Leave sym (the LOC_ARG) alone.  */
empty_stmt|;
block|}
else|else
name|sym
operator|=
name|nsym
expr_stmt|;
block|}
comment|/* Print the current arg.  */
if|if
condition|(
operator|!
name|first
condition|)
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|ui_out_wrap_hint
argument_list|(
name|uiout
argument_list|,
literal|"    "
argument_list|)
expr_stmt|;
name|annotate_arg_begin
argument_list|()
expr_stmt|;
name|list_chain
operator|=
name|make_cleanup_ui_out_tuple_begin_end
argument_list|(
name|uiout
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fprintf_symbol_filtered
argument_list|(
name|stb
operator|->
name|stream
argument_list|,
name|SYMBOL_PRINT_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|SYMBOL_LANGUAGE
argument_list|(
name|sym
argument_list|)
argument_list|,
name|DMGL_PARAMS
operator||
name|DMGL_ANSI
argument_list|)
expr_stmt|;
name|ui_out_field_stream
argument_list|(
name|uiout
argument_list|,
literal|"name"
argument_list|,
name|stb
argument_list|)
expr_stmt|;
name|annotate_arg_name_end
argument_list|()
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|"="
argument_list|)
expr_stmt|;
comment|/* Avoid value_print because it will deref ref parameters.  We just 	     want to print their addresses.  Print ??? for args whose address 	     we do not know.  We pass 2 as "recurse" to val_print because our 	     standard indentation here is 4 spaces, and val_print indents 	     2 for each recurse.  */
name|val
operator|=
name|read_var_value
argument_list|(
name|sym
argument_list|,
name|fi
argument_list|)
expr_stmt|;
name|annotate_arg_value
argument_list|(
name|val
operator|==
name|NULL
condition|?
name|NULL
else|:
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|)
block|{
name|val_print
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|val
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VALUE_ADDRESS
argument_list|(
name|val
argument_list|)
argument_list|,
name|stb
operator|->
name|stream
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
name|Val_no_prettyprint
argument_list|)
expr_stmt|;
name|ui_out_field_stream
argument_list|(
name|uiout
argument_list|,
literal|"value"
argument_list|,
name|stb
argument_list|)
expr_stmt|;
block|}
else|else
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|"???"
argument_list|)
expr_stmt|;
comment|/* Invoke ui_out_tuple_end.  */
name|do_cleanups
argument_list|(
name|list_chain
argument_list|)
expr_stmt|;
name|annotate_arg_end
argument_list|()
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Don't print nameless args in situations where we don't know      enough about the stack to find them.  */
if|if
condition|(
name|num
operator|!=
operator|-
literal|1
condition|)
block|{
name|long
name|start
decl_stmt|;
if|if
condition|(
name|highest_offset
operator|==
operator|-
literal|1
condition|)
name|start
operator|=
name|FRAME_ARGS_SKIP
expr_stmt|;
else|else
name|start
operator|=
name|highest_offset
expr_stmt|;
name|print_frame_nameless_args
argument_list|(
name|fi
argument_list|,
name|start
argument_list|,
name|num
operator|-
name|args_printed
argument_list|,
name|first
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pass the args the way catch_errors wants them.  */
end_comment

begin_function
specifier|static
name|int
name|print_args_stub
parameter_list|(
name|void
modifier|*
name|args
parameter_list|)
block|{
name|int
name|numargs
decl_stmt|;
name|struct
name|print_args_args
modifier|*
name|p
init|=
operator|(
expr|struct
name|print_args_args
operator|*
operator|)
name|args
decl_stmt|;
if|if
condition|(
name|FRAME_NUM_ARGS_P
argument_list|()
condition|)
block|{
name|numargs
operator|=
name|FRAME_NUM_ARGS
argument_list|(
name|p
operator|->
name|fi
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
name|numargs
operator|>=
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|numargs
operator|=
operator|-
literal|1
expr_stmt|;
name|print_frame_args
argument_list|(
name|p
operator|->
name|func
argument_list|,
name|p
operator|->
name|fi
argument_list|,
name|numargs
argument_list|,
name|p
operator|->
name|stream
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Print information about a frame for frame "fi" at level "level".    Used in "where" output, also used to emit breakpoint or step    messages.      LEVEL is the level of the frame, or -1 if it is the    innermost frame but we don't want to print the level.      The meaning of the SOURCE argument is:     SRC_LINE: Print only source line    LOCATION: Print only location     LOC_AND_SRC: Print location and source line.  */
end_comment

begin_function
name|void
name|print_frame_info
parameter_list|(
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|,
name|int
name|level
parameter_list|,
name|int
name|source
parameter_list|,
name|int
name|args
parameter_list|)
block|{
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|int
name|source_print
decl_stmt|;
name|int
name|location_print
decl_stmt|;
if|if
condition|(
name|get_frame_type
argument_list|(
name|fi
argument_list|)
operator|==
name|DUMMY_FRAME
operator|||
name|get_frame_type
argument_list|(
name|fi
argument_list|)
operator|==
name|SIGTRAMP_FRAME
condition|)
block|{
name|struct
name|cleanup
modifier|*
name|uiout_cleanup
init|=
name|make_cleanup_ui_out_tuple_begin_end
argument_list|(
name|uiout
argument_list|,
literal|"frame"
argument_list|)
decl_stmt|;
name|annotate_frame_begin
argument_list|(
name|level
operator|==
operator|-
literal|1
condition|?
literal|0
else|:
name|level
argument_list|,
name|get_frame_pc
argument_list|(
name|fi
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Do this regardless of SOURCE because we don't have any source          to list for this frame.  */
if|if
condition|(
name|level
operator|>=
literal|0
condition|)
block|{
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|"#"
argument_list|)
expr_stmt|;
name|ui_out_field_fmt_int
argument_list|(
name|uiout
argument_list|,
literal|2
argument_list|,
name|ui_left
argument_list|,
literal|"level"
argument_list|,
name|level
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ui_out_is_mi_like_p
argument_list|(
name|uiout
argument_list|)
condition|)
block|{
name|annotate_frame_address
argument_list|()
expr_stmt|;
name|ui_out_field_core_addr
argument_list|(
name|uiout
argument_list|,
literal|"addr"
argument_list|,
name|get_frame_pc
argument_list|(
name|fi
argument_list|)
argument_list|)
expr_stmt|;
name|annotate_frame_address_end
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|get_frame_type
argument_list|(
name|fi
argument_list|)
operator|==
name|DUMMY_FRAME
condition|)
block|{
name|annotate_function_call
argument_list|()
expr_stmt|;
name|ui_out_field_string
argument_list|(
name|uiout
argument_list|,
literal|"func"
argument_list|,
literal|"<function called from gdb>"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|get_frame_type
argument_list|(
name|fi
argument_list|)
operator|==
name|SIGTRAMP_FRAME
condition|)
block|{
name|annotate_signal_handler_caller
argument_list|()
expr_stmt|;
name|ui_out_field_string
argument_list|(
name|uiout
argument_list|,
literal|"func"
argument_list|,
literal|"<signal handler called>"
argument_list|)
expr_stmt|;
block|}
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|annotate_frame_end
argument_list|()
expr_stmt|;
name|do_cleanups
argument_list|(
name|uiout_cleanup
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If fi is not the innermost frame, that normally means that fi->pc      points to *after* the call instruction, and we want to get the      line containing the call, never the next line.  But if the next      frame is a SIGTRAMP_FRAME or a DUMMY_FRAME, then the next frame      was not entered as the result of a call, and we want to get the      line containing fi->pc.  */
name|find_frame_sal
argument_list|(
name|fi
argument_list|,
operator|&
name|sal
argument_list|)
expr_stmt|;
name|location_print
operator|=
operator|(
name|source
operator|==
name|LOCATION
operator|||
name|source
operator|==
name|LOC_AND_ADDRESS
operator|||
name|source
operator|==
name|SRC_AND_LOC
operator|)
expr_stmt|;
if|if
condition|(
name|location_print
operator|||
operator|!
name|sal
operator|.
name|symtab
condition|)
name|print_frame
argument_list|(
name|fi
argument_list|,
name|level
argument_list|,
name|source
argument_list|,
name|args
argument_list|,
name|sal
argument_list|)
expr_stmt|;
name|source_print
operator|=
operator|(
name|source
operator|==
name|SRC_LINE
operator|||
name|source
operator|==
name|SRC_AND_LOC
operator|)
expr_stmt|;
if|if
condition|(
name|sal
operator|.
name|symtab
condition|)
name|set_current_source_symtab_and_line
argument_list|(
operator|&
name|sal
argument_list|)
expr_stmt|;
if|if
condition|(
name|source_print
operator|&&
name|sal
operator|.
name|symtab
condition|)
block|{
name|struct
name|symtab_and_line
name|cursal
decl_stmt|;
name|int
name|done
init|=
literal|0
decl_stmt|;
name|int
name|mid_statement
init|=
operator|(
name|source
operator|==
name|SRC_LINE
operator|)
operator|&&
operator|(
name|get_frame_pc
argument_list|(
name|fi
argument_list|)
operator|!=
name|sal
operator|.
name|pc
operator|)
decl_stmt|;
if|if
condition|(
name|annotation_level
condition|)
name|done
operator|=
name|identify_source_line
argument_list|(
name|sal
operator|.
name|symtab
argument_list|,
name|sal
operator|.
name|line
argument_list|,
name|mid_statement
argument_list|,
name|get_frame_pc
argument_list|(
name|fi
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|done
condition|)
block|{
if|if
condition|(
name|print_frame_info_listing_hook
condition|)
name|print_frame_info_listing_hook
argument_list|(
name|sal
operator|.
name|symtab
argument_list|,
name|sal
operator|.
name|line
argument_list|,
name|sal
operator|.
name|line
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* We used to do this earlier, but that is clearly 		 wrong. This function is used by many different 		 parts of gdb, including normal_stop in infrun.c, 		 which uses this to print out the current PC 		 when we stepi/nexti into the middle of a source 		 line. Only the command line really wants this 		 behavior. Other UIs probably would like the 		 ability to decide for themselves if it is desired. */
if|if
condition|(
name|addressprint
operator|&&
name|mid_statement
condition|)
block|{
name|ui_out_field_core_addr
argument_list|(
name|uiout
argument_list|,
literal|"addr"
argument_list|,
name|get_frame_pc
argument_list|(
name|fi
argument_list|)
argument_list|)
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|"\t"
argument_list|)
expr_stmt|;
block|}
name|print_source_lines
argument_list|(
name|sal
operator|.
name|symtab
argument_list|,
name|sal
operator|.
name|line
argument_list|,
name|sal
operator|.
name|line
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Make sure we have at least a default source file */
name|set_default_source_symtab_and_line
argument_list|()
expr_stmt|;
name|cursal
operator|=
name|get_current_source_symtab_and_line
argument_list|()
expr_stmt|;
name|cursal
operator|.
name|line
operator|=
name|max
argument_list|(
name|sal
operator|.
name|line
operator|-
name|get_lines_to_list
argument_list|()
operator|/
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|set_current_source_symtab_and_line
argument_list|(
operator|&
name|cursal
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|source
operator|!=
literal|0
condition|)
name|set_default_breakpoint
argument_list|(
literal|1
argument_list|,
name|get_frame_pc
argument_list|(
name|fi
argument_list|)
argument_list|,
name|sal
operator|.
name|symtab
argument_list|,
name|sal
operator|.
name|line
argument_list|)
expr_stmt|;
name|annotate_frame_end
argument_list|()
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_frame
parameter_list|(
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|,
name|int
name|level
parameter_list|,
name|int
name|source
parameter_list|,
name|int
name|args
parameter_list|,
name|struct
name|symtab_and_line
name|sal
parameter_list|)
block|{
name|struct
name|symbol
modifier|*
name|func
decl_stmt|;
name|char
modifier|*
name|funname
init|=
literal|0
decl_stmt|;
name|enum
name|language
name|funlang
init|=
name|language_unknown
decl_stmt|;
name|struct
name|ui_stream
modifier|*
name|stb
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|list_chain
decl_stmt|;
name|stb
operator|=
name|ui_out_stream_new
argument_list|(
name|uiout
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup_ui_out_stream_delete
argument_list|(
name|stb
argument_list|)
expr_stmt|;
name|func
operator|=
name|find_pc_function
argument_list|(
name|get_frame_address_in_block
argument_list|(
name|fi
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|func
condition|)
block|{
comment|/* In certain pathological cases, the symtabs give the wrong          function (when we are in the first function in a file which          is compiled without debugging symbols, the previous function          is compiled with debugging symbols, and the "foo.o" symbol          that is supposed to tell us where the file with debugging symbols          ends has been truncated by ar because it is longer than 15          characters).  This also occurs if the user uses asm() to create          a function but not stabs for it (in a file compiled -g).           So look in the minimal symbol tables as well, and if it comes          up with a larger address for the function use that instead.          I don't think this can ever cause any problems; there shouldn't          be any minimal symbols in the middle of a function; if this is          ever changed many parts of GDB will need to be changed (and we'll          create a find_pc_minimal_function or some such).  */
name|struct
name|minimal_symbol
modifier|*
name|msymbol
init|=
name|lookup_minimal_symbol_by_pc
argument_list|(
name|get_frame_address_in_block
argument_list|(
name|fi
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|msymbol
operator|!=
name|NULL
operator|&&
operator|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
operator|>
name|BLOCK_START
argument_list|(
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|func
argument_list|)
argument_list|)
operator|)
condition|)
block|{
if|#
directive|if
literal|0
comment|/* There is no particular reason to think the line number 	     information is wrong.  Someone might have just put in 	     a label with asm() but left the line numbers alone.  */
comment|/* In this case we have no way of knowing the source file 	     and line number, so don't print them.  */
block|sal.symtab = 0;
endif|#
directive|endif
comment|/* We also don't know anything about the function besides 	     its address and name.  */
name|func
operator|=
literal|0
expr_stmt|;
name|funname
operator|=
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|msymbol
argument_list|)
expr_stmt|;
name|funlang
operator|=
name|SYMBOL_LANGUAGE
argument_list|(
name|msymbol
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* I'd like to use SYMBOL_PRINT_NAME() here, to display the 	     demangled name that we already have stored in the symbol 	     table, but we stored a version with DMGL_PARAMS turned 	     on, and here we don't want to display parameters. So call 	     the demangler again, with DMGL_ANSI only. (Yes, I know 	     that printf_symbol_filtered() will again try to demangle 	     the name on the fly, but the issue is that if 	     cplus_demangle() fails here, it'll fail there too. So we 	     want to catch the failure ("demangled==NULL" case below) 	     here, while we still have our hands on the function 	     symbol.) */
name|char
modifier|*
name|demangled
decl_stmt|;
name|funname
operator|=
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|func
argument_list|)
expr_stmt|;
name|funlang
operator|=
name|SYMBOL_LANGUAGE
argument_list|(
name|func
argument_list|)
expr_stmt|;
if|if
condition|(
name|funlang
operator|==
name|language_cplus
condition|)
block|{
name|demangled
operator|=
name|cplus_demangle
argument_list|(
name|funname
argument_list|,
name|DMGL_ANSI
argument_list|)
expr_stmt|;
if|if
condition|(
name|demangled
operator|==
name|NULL
condition|)
comment|/* If the demangler fails, try the demangled name from 		   the symbol table. This'll have parameters, but 		   that's preferable to diplaying a mangled name. */
name|funname
operator|=
name|SYMBOL_PRINT_NAME
argument_list|(
name|func
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|struct
name|minimal_symbol
modifier|*
name|msymbol
init|=
name|lookup_minimal_symbol_by_pc
argument_list|(
name|get_frame_address_in_block
argument_list|(
name|fi
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|msymbol
operator|!=
name|NULL
condition|)
block|{
name|funname
operator|=
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|msymbol
argument_list|)
expr_stmt|;
name|funlang
operator|=
name|SYMBOL_LANGUAGE
argument_list|(
name|msymbol
argument_list|)
expr_stmt|;
block|}
block|}
name|annotate_frame_begin
argument_list|(
name|level
operator|==
operator|-
literal|1
condition|?
literal|0
else|:
name|level
argument_list|,
name|get_frame_pc
argument_list|(
name|fi
argument_list|)
argument_list|)
expr_stmt|;
name|list_chain
operator|=
name|make_cleanup_ui_out_tuple_begin_end
argument_list|(
name|uiout
argument_list|,
literal|"frame"
argument_list|)
expr_stmt|;
if|if
condition|(
name|level
operator|>=
literal|0
condition|)
block|{
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|"#"
argument_list|)
expr_stmt|;
name|ui_out_field_fmt_int
argument_list|(
name|uiout
argument_list|,
literal|2
argument_list|,
name|ui_left
argument_list|,
literal|"level"
argument_list|,
name|level
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|addressprint
condition|)
if|if
condition|(
name|get_frame_pc
argument_list|(
name|fi
argument_list|)
operator|!=
name|sal
operator|.
name|pc
operator|||
operator|!
name|sal
operator|.
name|symtab
operator|||
name|source
operator|==
name|LOC_AND_ADDRESS
condition|)
block|{
name|annotate_frame_address
argument_list|()
expr_stmt|;
name|ui_out_field_core_addr
argument_list|(
name|uiout
argument_list|,
literal|"addr"
argument_list|,
name|get_frame_pc
argument_list|(
name|fi
argument_list|)
argument_list|)
expr_stmt|;
name|annotate_frame_address_end
argument_list|()
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|" in "
argument_list|)
expr_stmt|;
block|}
name|annotate_frame_function_name
argument_list|()
expr_stmt|;
name|fprintf_symbol_filtered
argument_list|(
name|stb
operator|->
name|stream
argument_list|,
name|funname
condition|?
name|funname
else|:
literal|"??"
argument_list|,
name|funlang
argument_list|,
name|DMGL_ANSI
argument_list|)
expr_stmt|;
name|ui_out_field_stream
argument_list|(
name|uiout
argument_list|,
literal|"func"
argument_list|,
name|stb
argument_list|)
expr_stmt|;
name|ui_out_wrap_hint
argument_list|(
name|uiout
argument_list|,
literal|"   "
argument_list|)
expr_stmt|;
name|annotate_frame_args
argument_list|()
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|" ("
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
condition|)
block|{
name|struct
name|print_args_args
name|args
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|args_list_chain
decl_stmt|;
name|args
operator|.
name|fi
operator|=
name|fi
expr_stmt|;
name|args
operator|.
name|func
operator|=
name|func
expr_stmt|;
name|args
operator|.
name|stream
operator|=
name|gdb_stdout
expr_stmt|;
name|args_list_chain
operator|=
name|make_cleanup_ui_out_list_begin_end
argument_list|(
name|uiout
argument_list|,
literal|"args"
argument_list|)
expr_stmt|;
name|catch_errors
argument_list|(
name|print_args_stub
argument_list|,
operator|&
name|args
argument_list|,
literal|""
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
expr_stmt|;
comment|/* FIXME: args must be a list. If one argument is a string it will 		 have " that will not be properly escaped.  */
comment|/* Invoke ui_out_tuple_end.  */
name|do_cleanups
argument_list|(
name|args_list_chain
argument_list|)
expr_stmt|;
name|QUIT
expr_stmt|;
block|}
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sal
operator|.
name|symtab
operator|&&
name|sal
operator|.
name|symtab
operator|->
name|filename
condition|)
block|{
name|annotate_frame_source_begin
argument_list|()
expr_stmt|;
name|ui_out_wrap_hint
argument_list|(
name|uiout
argument_list|,
literal|"   "
argument_list|)
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|" at "
argument_list|)
expr_stmt|;
name|annotate_frame_source_file
argument_list|()
expr_stmt|;
name|ui_out_field_string
argument_list|(
name|uiout
argument_list|,
literal|"file"
argument_list|,
name|sal
operator|.
name|symtab
operator|->
name|filename
argument_list|)
expr_stmt|;
name|annotate_frame_source_file_end
argument_list|()
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|annotate_frame_source_line
argument_list|()
expr_stmt|;
name|ui_out_field_int
argument_list|(
name|uiout
argument_list|,
literal|"line"
argument_list|,
name|sal
operator|.
name|line
argument_list|)
expr_stmt|;
name|annotate_frame_source_end
argument_list|()
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PC_SOLIB
if|if
condition|(
operator|!
name|funname
operator|||
operator|(
operator|!
name|sal
operator|.
name|symtab
operator|||
operator|!
name|sal
operator|.
name|symtab
operator|->
name|filename
operator|)
condition|)
block|{
name|char
modifier|*
name|lib
init|=
name|PC_SOLIB
argument_list|(
name|get_frame_pc
argument_list|(
name|fi
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|lib
condition|)
block|{
name|annotate_frame_where
argument_list|()
expr_stmt|;
name|ui_out_wrap_hint
argument_list|(
name|uiout
argument_list|,
literal|"  "
argument_list|)
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|" from "
argument_list|)
expr_stmt|;
name|ui_out_field_string
argument_list|(
name|uiout
argument_list|,
literal|"from"
argument_list|,
name|lib
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* PC_SOLIB */
comment|/* do_cleanups will call ui_out_tuple_end() for us.  */
name|do_cleanups
argument_list|(
name|list_chain
argument_list|)
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Show the frame info.  If this is the tui, it will be shown in     the source display otherwise, nothing is done */
end_comment

begin_function
name|void
name|show_stack_frame
parameter_list|(
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|)
block|{ }
end_function

begin_escape
end_escape

begin_comment
comment|/* Read a frame specification in whatever the appropriate format is.    Call error() if the specification is in any way invalid (i.e.    this function never returns NULL).  */
end_comment

begin_function
name|struct
name|frame_info
modifier|*
name|parse_frame_specification
parameter_list|(
name|char
modifier|*
name|frame_exp
parameter_list|)
block|{
name|int
name|numargs
init|=
literal|0
decl_stmt|;
define|#
directive|define
name|MAXARGS
value|4
name|CORE_ADDR
name|args
index|[
name|MAXARGS
index|]
decl_stmt|;
name|int
name|level
decl_stmt|;
if|if
condition|(
name|frame_exp
condition|)
block|{
name|char
modifier|*
name|addr_string
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|tmp_cleanup
decl_stmt|;
while|while
condition|(
operator|*
name|frame_exp
operator|==
literal|' '
condition|)
name|frame_exp
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|frame_exp
condition|)
block|{
if|if
condition|(
name|numargs
operator|>
name|MAXARGS
condition|)
name|error
argument_list|(
literal|"Too many args in frame specification"
argument_list|)
expr_stmt|;
comment|/* Parse an argument.  */
for|for
control|(
name|p
operator|=
name|frame_exp
init|;
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|' '
condition|;
name|p
operator|++
control|)
empty_stmt|;
name|addr_string
operator|=
name|savestring
argument_list|(
name|frame_exp
argument_list|,
name|p
operator|-
name|frame_exp
argument_list|)
expr_stmt|;
block|{
name|struct
name|value
modifier|*
name|vp
decl_stmt|;
name|tmp_cleanup
operator|=
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|addr_string
argument_list|)
expr_stmt|;
comment|/* NOTE: we call parse_and_eval and then both 	       value_as_long and value_as_address rather than calling 	       parse_and_eval_long and parse_and_eval_address because 	       of the issue of potential side effects from evaluating 	       the expression.  */
name|vp
operator|=
name|parse_and_eval
argument_list|(
name|addr_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|numargs
operator|==
literal|0
condition|)
name|level
operator|=
name|value_as_long
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|args
index|[
name|numargs
operator|++
index|]
operator|=
name|value_as_address
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|tmp_cleanup
argument_list|)
expr_stmt|;
block|}
comment|/* Skip spaces, move to possible next arg.  */
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
condition|)
name|p
operator|++
expr_stmt|;
name|frame_exp
operator|=
name|p
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|numargs
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
name|deprecated_selected_frame
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"No selected frame."
argument_list|)
expr_stmt|;
return|return
name|deprecated_selected_frame
return|;
comment|/* NOTREACHED */
case|case
literal|1
case|:
block|{
name|struct
name|frame_info
modifier|*
name|fid
init|=
name|find_relative_frame
argument_list|(
name|get_current_frame
argument_list|()
argument_list|,
operator|&
name|level
argument_list|)
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|tfid
decl_stmt|;
if|if
condition|(
name|level
operator|==
literal|0
condition|)
comment|/* find_relative_frame was successful */
return|return
name|fid
return|;
comment|/* If SETUP_ARBITRARY_FRAME is defined, then frame specifications 	   take at least 2 addresses.  It is important to detect this case 	   here so that "frame 100" does not give a confusing error message 	   like "frame specification requires two addresses".  This of course 	   does not solve the "frame 100" problem for machines on which 	   a frame specification can be made with one address.  To solve 	   that, we need a new syntax for a specifying a frame by address. 	   I think the cleanest syntax is $frame(0x45) ($frame(0x23,0x45) for 	   two args, etc.), but people might think that is too much typing, 	   so I guess *0x23,0x45 would be a possible alternative (commas 	   really should be used instead of spaces to delimit; using spaces 	   normally works in an expression).  */
ifdef|#
directive|ifdef
name|SETUP_ARBITRARY_FRAME
name|error
argument_list|(
literal|"No frame %s"
argument_list|,
name|paddr_d
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If (s)he specifies the frame with an address, he deserves what 	   (s)he gets.  Still, give the highest one that matches.  */
for|for
control|(
name|fid
operator|=
name|get_current_frame
argument_list|()
init|;
name|fid
operator|&&
name|get_frame_base
argument_list|(
name|fid
argument_list|)
operator|!=
name|args
index|[
literal|0
index|]
condition|;
name|fid
operator|=
name|get_prev_frame
argument_list|(
name|fid
argument_list|)
control|)
empty_stmt|;
if|if
condition|(
name|fid
condition|)
while|while
condition|(
operator|(
name|tfid
operator|=
name|get_prev_frame
argument_list|(
name|fid
argument_list|)
operator|)
operator|&&
operator|(
name|get_frame_base
argument_list|(
name|tfid
argument_list|)
operator|==
name|args
index|[
literal|0
index|]
operator|)
condition|)
name|fid
operator|=
name|tfid
expr_stmt|;
comment|/* We couldn't identify the frame as an existing frame, but 	   perhaps we can create one with a single argument.  */
block|}
default|default:
ifdef|#
directive|ifdef
name|SETUP_ARBITRARY_FRAME
return|return
name|SETUP_ARBITRARY_FRAME
argument_list|(
name|numargs
argument_list|,
name|args
argument_list|)
return|;
else|#
directive|else
comment|/* Usual case.  Do it here rather than have everyone supply          a SETUP_ARBITRARY_FRAME that does this.  */
if|if
condition|(
name|numargs
operator|==
literal|1
condition|)
return|return
name|create_new_frame
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
return|;
name|error
argument_list|(
literal|"Too many args in frame specification"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NOTREACHED */
block|}
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/* Print verbosely the selected frame or the frame at address ADDR.    This means absolutely all information in the frame is printed.  */
end_comment

begin_function
specifier|static
name|void
name|frame_info
parameter_list|(
name|char
modifier|*
name|addr_exp
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|struct
name|symbol
modifier|*
name|func
decl_stmt|;
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|calling_frame_info
decl_stmt|;
name|int
name|i
decl_stmt|,
name|count
decl_stmt|,
name|numregs
decl_stmt|;
name|char
modifier|*
name|funname
init|=
literal|0
decl_stmt|;
name|enum
name|language
name|funlang
init|=
name|language_unknown
decl_stmt|;
specifier|const
name|char
modifier|*
name|pc_regname
decl_stmt|;
if|if
condition|(
operator|!
name|target_has_stack
condition|)
name|error
argument_list|(
literal|"No stack."
argument_list|)
expr_stmt|;
comment|/* Name of the value returned by get_frame_pc().  Per comments, "pc"      is not a good name.  */
if|if
condition|(
name|PC_REGNUM
operator|>=
literal|0
condition|)
comment|/* OK, this is weird.  The PC_REGNUM hardware register's value can        easily not match that of the internal value returned by        get_frame_pc().  */
name|pc_regname
operator|=
name|REGISTER_NAME
argument_list|(
name|PC_REGNUM
argument_list|)
expr_stmt|;
else|else
comment|/* But then, this is weird to.  Even without PC_REGNUM, an        architectures will often have a hardware register called "pc",        and that register's value, again, can easily not match        get_frame_pc().  */
name|pc_regname
operator|=
literal|"pc"
expr_stmt|;
name|fi
operator|=
name|parse_frame_specification
argument_list|(
name|addr_exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fi
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Invalid frame specified."
argument_list|)
expr_stmt|;
name|find_frame_sal
argument_list|(
name|fi
argument_list|,
operator|&
name|sal
argument_list|)
expr_stmt|;
name|func
operator|=
name|get_frame_function
argument_list|(
name|fi
argument_list|)
expr_stmt|;
comment|/* FIXME: cagney/2002-11-28: Why bother?  Won't sal.symtab contain      the same value.  */
name|s
operator|=
name|find_pc_symtab
argument_list|(
name|get_frame_pc
argument_list|(
name|fi
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|func
condition|)
block|{
comment|/* I'd like to use SYMBOL_PRINT_NAME() here, to display        * the demangled name that we already have stored in        * the symbol table, but we stored a version with        * DMGL_PARAMS turned on, and here we don't want        * to display parameters. So call the demangler again,        * with DMGL_ANSI only. RT        * (Yes, I know that printf_symbol_filtered() will        * again try to demangle the name on the fly, but        * the issue is that if cplus_demangle() fails here,        * it'll fail there too. So we want to catch the failure        * ("demangled==NULL" case below) here, while we still        * have our hands on the function symbol.)        */
name|char
modifier|*
name|demangled
decl_stmt|;
name|funname
operator|=
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|func
argument_list|)
expr_stmt|;
name|funlang
operator|=
name|SYMBOL_LANGUAGE
argument_list|(
name|func
argument_list|)
expr_stmt|;
if|if
condition|(
name|funlang
operator|==
name|language_cplus
condition|)
block|{
name|demangled
operator|=
name|cplus_demangle
argument_list|(
name|funname
argument_list|,
name|DMGL_ANSI
argument_list|)
expr_stmt|;
comment|/* If the demangler fails, try the demangled name 	   * from the symbol table. This'll have parameters, 	   * but that's preferable to diplaying a mangled name. 	   */
if|if
condition|(
name|demangled
operator|==
name|NULL
condition|)
name|funname
operator|=
name|SYMBOL_PRINT_NAME
argument_list|(
name|func
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|struct
name|minimal_symbol
modifier|*
name|msymbol
init|=
name|lookup_minimal_symbol_by_pc
argument_list|(
name|get_frame_pc
argument_list|(
name|fi
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|msymbol
operator|!=
name|NULL
condition|)
block|{
name|funname
operator|=
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|msymbol
argument_list|)
expr_stmt|;
name|funlang
operator|=
name|SYMBOL_LANGUAGE
argument_list|(
name|msymbol
argument_list|)
expr_stmt|;
block|}
block|}
name|calling_frame_info
operator|=
name|get_prev_frame
argument_list|(
name|fi
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|addr_exp
operator|&&
name|frame_relative_level
argument_list|(
name|deprecated_selected_frame
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Stack level %d, frame at "
argument_list|,
name|frame_relative_level
argument_list|(
name|deprecated_selected_frame
argument_list|)
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|get_frame_base
argument_list|(
name|fi
argument_list|)
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|":\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf_filtered
argument_list|(
literal|"Stack frame at "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|get_frame_base
argument_list|(
name|fi
argument_list|)
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|":\n"
argument_list|)
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|" %s = "
argument_list|,
name|pc_regname
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|get_frame_pc
argument_list|(
name|fi
argument_list|)
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|"   "
argument_list|)
expr_stmt|;
if|if
condition|(
name|funname
condition|)
block|{
name|printf_filtered
argument_list|(
literal|" in "
argument_list|)
expr_stmt|;
name|fprintf_symbol_filtered
argument_list|(
name|gdb_stdout
argument_list|,
name|funname
argument_list|,
name|funlang
argument_list|,
name|DMGL_ANSI
operator||
name|DMGL_PARAMS
argument_list|)
expr_stmt|;
block|}
name|wrap_here
argument_list|(
literal|"   "
argument_list|)
expr_stmt|;
if|if
condition|(
name|sal
operator|.
name|symtab
condition|)
name|printf_filtered
argument_list|(
literal|" (%s:%d)"
argument_list|,
name|sal
operator|.
name|symtab
operator|->
name|filename
argument_list|,
name|sal
operator|.
name|line
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
literal|"; "
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|"    "
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"saved %s "
argument_list|,
name|pc_regname
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|frame_pc_unwind
argument_list|(
name|fi
argument_list|)
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|{
name|int
name|frameless
decl_stmt|;
name|frameless
operator|=
operator|(
name|DEPRECATED_FRAMELESS_FUNCTION_INVOCATION_P
argument_list|()
operator|&&
name|DEPRECATED_FRAMELESS_FUNCTION_INVOCATION
argument_list|(
name|fi
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|frameless
condition|)
name|printf_filtered
argument_list|(
literal|" (FRAMELESS),"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|calling_frame_info
condition|)
block|{
name|printf_filtered
argument_list|(
literal|" called by frame at "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|get_frame_base
argument_list|(
name|calling_frame_info
argument_list|)
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|get_next_frame
argument_list|(
name|fi
argument_list|)
operator|&&
name|calling_frame_info
condition|)
name|puts_filtered
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|"   "
argument_list|)
expr_stmt|;
if|if
condition|(
name|get_next_frame
argument_list|(
name|fi
argument_list|)
condition|)
block|{
name|printf_filtered
argument_list|(
literal|" caller of frame at "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|get_frame_base
argument_list|(
name|get_next_frame
argument_list|(
name|fi
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|get_next_frame
argument_list|(
name|fi
argument_list|)
operator|||
name|calling_frame_info
condition|)
name|puts_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
condition|)
name|printf_filtered
argument_list|(
literal|" source language %s.\n"
argument_list|,
name|language_str
argument_list|(
name|s
operator|->
name|language
argument_list|)
argument_list|)
expr_stmt|;
block|{
comment|/* Address of the argument list for this frame, or 0.  */
name|CORE_ADDR
name|arg_list
init|=
name|get_frame_args_address
argument_list|(
name|fi
argument_list|)
decl_stmt|;
comment|/* Number of args for this frame, or -1 if unknown.  */
name|int
name|numargs
decl_stmt|;
if|if
condition|(
name|arg_list
operator|==
literal|0
condition|)
name|printf_filtered
argument_list|(
literal|" Arglist at unknown address.\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|printf_filtered
argument_list|(
literal|" Arglist at "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|arg_list
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|","
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|FRAME_NUM_ARGS_P
argument_list|()
condition|)
block|{
name|numargs
operator|=
operator|-
literal|1
expr_stmt|;
name|puts_filtered
argument_list|(
literal|" args: "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|numargs
operator|=
name|FRAME_NUM_ARGS
argument_list|(
name|fi
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
name|numargs
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|numargs
operator|==
literal|0
condition|)
name|puts_filtered
argument_list|(
literal|" no args."
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|numargs
operator|==
literal|1
condition|)
name|puts_filtered
argument_list|(
literal|" 1 arg: "
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|" %d args: "
argument_list|,
name|numargs
argument_list|)
expr_stmt|;
block|}
name|print_frame_args
argument_list|(
name|func
argument_list|,
name|fi
argument_list|,
name|numargs
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|{
comment|/* Address of the local variables for this frame, or 0.  */
name|CORE_ADDR
name|arg_list
init|=
name|get_frame_locals_address
argument_list|(
name|fi
argument_list|)
decl_stmt|;
if|if
condition|(
name|arg_list
operator|==
literal|0
condition|)
name|printf_filtered
argument_list|(
literal|" Locals at unknown address,"
argument_list|)
expr_stmt|;
else|else
block|{
name|printf_filtered
argument_list|(
literal|" Locals at "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|arg_list
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|DEPRECATED_FRAME_INIT_SAVED_REGS_P
argument_list|()
operator|&&
name|deprecated_get_frame_saved_regs
argument_list|(
name|fi
argument_list|)
operator|==
name|NULL
condition|)
name|DEPRECATED_FRAME_INIT_SAVED_REGS
argument_list|(
name|fi
argument_list|)
expr_stmt|;
comment|/* Print as much information as possible on the location of all the      registers.  */
block|{
name|enum
name|lval_type
name|lval
decl_stmt|;
name|int
name|optimized
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|int
name|realnum
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|need_nl
init|=
literal|1
decl_stmt|;
comment|/* The sp is special; what's displayed isn't the save address, but        the value of the previous frame's sp.  This is a legacy thing,        at one stage the frame cached the previous frame's SP instead        of its address, hence it was easiest to just display the cached        value.  */
if|if
condition|(
name|SP_REGNUM
operator|>=
literal|0
condition|)
block|{
comment|/* Find out the location of the saved stack pointer with out            actually evaluating it.  */
name|frame_register_unwind
argument_list|(
name|fi
argument_list|,
name|SP_REGNUM
argument_list|,
operator|&
name|optimized
argument_list|,
operator|&
name|lval
argument_list|,
operator|&
name|addr
argument_list|,
operator|&
name|realnum
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|optimized
operator|&&
name|lval
operator|==
name|not_lval
condition|)
block|{
name|char
name|value
index|[
name|MAX_REGISTER_SIZE
index|]
decl_stmt|;
name|CORE_ADDR
name|sp
decl_stmt|;
name|frame_register_unwind
argument_list|(
name|fi
argument_list|,
name|SP_REGNUM
argument_list|,
operator|&
name|optimized
argument_list|,
operator|&
name|lval
argument_list|,
operator|&
name|addr
argument_list|,
operator|&
name|realnum
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|/* NOTE: cagney/2003-05-22: This is assuming that the                stack pointer was packed as an unsigned integer.  That                may or may not be valid.  */
name|sp
operator|=
name|extract_unsigned_integer
argument_list|(
name|value
argument_list|,
name|DEPRECATED_REGISTER_RAW_SIZE
argument_list|(
name|SP_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" Previous frame's sp is "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|sp
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|need_nl
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|optimized
operator|&&
name|lval
operator|==
name|lval_memory
condition|)
block|{
name|printf_filtered
argument_list|(
literal|" Previous frame's sp at "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|need_nl
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|optimized
operator|&&
name|lval
operator|==
name|lval_register
condition|)
block|{
name|printf_filtered
argument_list|(
literal|" Previous frame's sp in %s\n"
argument_list|,
name|REGISTER_NAME
argument_list|(
name|realnum
argument_list|)
argument_list|)
expr_stmt|;
name|need_nl
operator|=
literal|0
expr_stmt|;
block|}
comment|/* else keep quiet.  */
block|}
name|count
operator|=
literal|0
expr_stmt|;
name|numregs
operator|=
name|NUM_REGS
operator|+
name|NUM_PSEUDO_REGS
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numregs
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|i
operator|!=
name|SP_REGNUM
operator|&&
name|gdbarch_register_reggroup_p
argument_list|(
name|current_gdbarch
argument_list|,
name|i
argument_list|,
name|all_reggroup
argument_list|)
condition|)
block|{
comment|/* Find out the location of the saved register without              fetching the corresponding value.  */
name|frame_register_unwind
argument_list|(
name|fi
argument_list|,
name|i
argument_list|,
operator|&
name|optimized
argument_list|,
operator|&
name|lval
argument_list|,
operator|&
name|addr
argument_list|,
operator|&
name|realnum
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* For moment, only display registers that were saved on the 	     stack.  */
if|if
condition|(
operator|!
name|optimized
operator|&&
name|lval
operator|==
name|lval_memory
condition|)
block|{
if|if
condition|(
name|count
operator|==
literal|0
condition|)
name|puts_filtered
argument_list|(
literal|" Saved registers:\n "
argument_list|)
expr_stmt|;
else|else
name|puts_filtered
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" %s at "
argument_list|,
name|REGISTER_NAME
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|count
operator|||
name|need_nl
condition|)
name|puts_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Set a limit on the number of frames printed by default in a    backtrace.  */
end_comment

begin_endif
unit|static int backtrace_limit;  static void set_backtrace_limit_command (char *count_exp, int from_tty) {   int count = parse_and_eval_long (count_exp);    if (count< 0)     error ("Negative argument not meaningful as backtrace limit.");    backtrace_limit = count; }  static void backtrace_limit_info (char *arg, int from_tty) {   if (arg)     error ("\"Info backtrace-limit\" takes no arguments.");    printf_unfiltered ("Backtrace limit: %d.\n", backtrace_limit); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* Print briefly all stack frames or just the innermost COUNT frames.  */
end_comment

begin_function_decl
specifier|static
name|void
name|backtrace_command_1
parameter_list|(
name|char
modifier|*
name|count_exp
parameter_list|,
name|int
name|show_locals
parameter_list|,
name|int
name|from_tty
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|backtrace_command_1
parameter_list|(
name|char
modifier|*
name|count_exp
parameter_list|,
name|int
name|show_locals
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|trailing
decl_stmt|;
name|int
name|trailing_level
decl_stmt|;
if|if
condition|(
operator|!
name|target_has_stack
condition|)
name|error
argument_list|(
literal|"No stack."
argument_list|)
expr_stmt|;
comment|/* The following code must do two things.  First, it must      set the variable TRAILING to the frame from which we should start      printing.  Second, it must set the variable count to the number      of frames which we should print, or -1 if all of them.  */
name|trailing
operator|=
name|get_current_frame
argument_list|()
expr_stmt|;
comment|/* The target can be in a state where there is no valid frames      (e.g., just connected). */
if|if
condition|(
name|trailing
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"No stack."
argument_list|)
expr_stmt|;
name|trailing_level
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|count_exp
condition|)
block|{
name|count
operator|=
name|parse_and_eval_long
argument_list|(
name|count_exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
name|struct
name|frame_info
modifier|*
name|current
decl_stmt|;
name|count
operator|=
operator|-
name|count
expr_stmt|;
name|current
operator|=
name|trailing
expr_stmt|;
while|while
condition|(
name|current
operator|&&
name|count
operator|--
condition|)
block|{
name|QUIT
expr_stmt|;
name|current
operator|=
name|get_prev_frame
argument_list|(
name|current
argument_list|)
expr_stmt|;
block|}
comment|/* Will stop when CURRENT reaches the top of the stack.  TRAILING 	     will be COUNT below it.  */
while|while
condition|(
name|current
condition|)
block|{
name|QUIT
expr_stmt|;
name|trailing
operator|=
name|get_prev_frame
argument_list|(
name|trailing
argument_list|)
expr_stmt|;
name|current
operator|=
name|get_prev_frame
argument_list|(
name|current
argument_list|)
expr_stmt|;
name|trailing_level
operator|++
expr_stmt|;
block|}
name|count
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
else|else
name|count
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|info_verbose
condition|)
block|{
name|struct
name|partial_symtab
modifier|*
name|ps
decl_stmt|;
comment|/* Read in symbols for all of the frames.  Need to do this in          a separate pass so that "Reading in symbols for xxx" messages          don't screw up the appearance of the backtrace.  Also          if people have strong opinions against reading symbols for          backtrace this may have to be an option.  */
name|i
operator|=
name|count
expr_stmt|;
for|for
control|(
name|fi
operator|=
name|trailing
init|;
name|fi
operator|!=
name|NULL
operator|&&
name|i
operator|--
condition|;
name|fi
operator|=
name|get_prev_frame
argument_list|(
name|fi
argument_list|)
control|)
block|{
name|QUIT
expr_stmt|;
name|ps
operator|=
name|find_pc_psymtab
argument_list|(
name|get_frame_address_in_block
argument_list|(
name|fi
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ps
condition|)
name|PSYMTAB_TO_SYMTAB
argument_list|(
name|ps
argument_list|)
expr_stmt|;
comment|/* Force syms to come in */
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|fi
operator|=
name|trailing
init|;
name|fi
operator|&&
name|count
operator|--
condition|;
name|i
operator|++
operator|,
name|fi
operator|=
name|get_prev_frame
argument_list|(
name|fi
argument_list|)
control|)
block|{
name|QUIT
expr_stmt|;
comment|/* Don't use print_stack_frame; if an error() occurs it probably          means further attempts to backtrace would fail (on the other          hand, perhaps the code does or could be fixed to make sure          the frame->prev field gets set to NULL in that case).  */
name|print_frame_info
argument_list|(
name|fi
argument_list|,
name|trailing_level
operator|+
name|i
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|show_locals
condition|)
name|print_frame_local_vars
argument_list|(
name|fi
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
comment|/* If we've stopped before the end, mention that.  */
if|if
condition|(
name|fi
operator|&&
name|from_tty
condition|)
name|printf_filtered
argument_list|(
literal|"(More stack frames follow...)\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|backtrace_command
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|cleanup
modifier|*
name|old_chain
init|=
operator|(
expr|struct
name|cleanup
operator|*
operator|)
name|NULL
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
name|int
name|argIndicatingFullTrace
init|=
operator|(
operator|-
literal|1
operator|)
decl_stmt|,
name|totArgLen
init|=
literal|0
decl_stmt|,
name|argc
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|argPtr
init|=
name|arg
decl_stmt|;
if|if
condition|(
name|arg
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|;
name|argv
operator|=
name|buildargv
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup_freeargv
argument_list|(
name|argv
argument_list|)
expr_stmt|;
name|argc
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|argv
index|[
name|i
index|]
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
operator|(
name|j
operator|<
name|strlen
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
operator|)
condition|;
name|j
operator|++
control|)
name|argv
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|tolower
argument_list|(
name|argv
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|argIndicatingFullTrace
operator|<
literal|0
operator|&&
name|subset_compare
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"full"
argument_list|)
condition|)
name|argIndicatingFullTrace
operator|=
name|argc
expr_stmt|;
else|else
block|{
name|argc
operator|++
expr_stmt|;
name|totArgLen
operator|+=
name|strlen
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|totArgLen
operator|+=
name|argc
expr_stmt|;
if|if
condition|(
name|argIndicatingFullTrace
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|totArgLen
operator|>
literal|0
condition|)
block|{
name|argPtr
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|totArgLen
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|argPtr
condition|)
name|nomem
argument_list|(
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|memset
argument_list|(
name|argPtr
argument_list|,
literal|0
argument_list|,
name|totArgLen
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
operator|(
name|argc
operator|+
literal|1
operator|)
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|!=
name|argIndicatingFullTrace
condition|)
block|{
name|strcat
argument_list|(
name|argPtr
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|argPtr
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
name|argPtr
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
block|}
name|backtrace_command_1
argument_list|(
name|argPtr
argument_list|,
operator|(
name|argIndicatingFullTrace
operator|>=
literal|0
operator|)
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
if|if
condition|(
name|argIndicatingFullTrace
operator|>=
literal|0
operator|&&
name|totArgLen
operator|>
literal|0
condition|)
name|xfree
argument_list|(
name|argPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_chain
condition|)
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_function_decl
specifier|static
name|void
name|backtrace_full_command
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|backtrace_full_command
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|backtrace_command_1
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print the local variables of a block B active in FRAME.    Return 1 if any variables were printed; 0 otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|print_block_frame_locals
parameter_list|(
name|struct
name|block
modifier|*
name|b
parameter_list|,
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|,
name|int
name|num_tabs
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|)
block|{
name|struct
name|dict_iterator
name|iter
decl_stmt|;
name|int
name|j
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|int
name|values_printed
init|=
literal|0
decl_stmt|;
name|ALL_BLOCK_SYMBOLS
argument_list|(
argument|b
argument_list|,
argument|iter
argument_list|,
argument|sym
argument_list|)
block|{
switch|switch
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
condition|)
block|{
case|case
name|LOC_LOCAL
case|:
case|case
name|LOC_REGISTER
case|:
case|case
name|LOC_STATIC
case|:
case|case
name|LOC_BASEREG
case|:
case|case
name|LOC_COMPUTED
case|:
name|values_printed
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|num_tabs
condition|;
name|j
operator|++
control|)
name|fputs_filtered
argument_list|(
literal|"\t"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
name|SYMBOL_PRINT_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|" = "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|print_variable_value
argument_list|(
name|sym
argument_list|,
name|fi
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Ignore symbols which are not locals.  */
break|break;
block|}
block|}
return|return
name|values_printed
return|;
block|}
end_function

begin_comment
comment|/* Same, but print labels.  */
end_comment

begin_function
specifier|static
name|int
name|print_block_frame_labels
parameter_list|(
name|struct
name|block
modifier|*
name|b
parameter_list|,
name|int
modifier|*
name|have_default
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|)
block|{
name|struct
name|dict_iterator
name|iter
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|int
name|values_printed
init|=
literal|0
decl_stmt|;
name|ALL_BLOCK_SYMBOLS
argument_list|(
argument|b
argument_list|,
argument|iter
argument_list|,
argument|sym
argument_list|)
block|{
if|if
condition|(
name|DEPRECATED_STREQ
argument_list|(
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
literal|"default"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|have_default
condition|)
continue|continue;
operator|*
name|have_default
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_LABEL
condition|)
block|{
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|sal
operator|=
name|find_pc_line
argument_list|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|values_printed
operator|=
literal|1
expr_stmt|;
name|fputs_filtered
argument_list|(
name|SYMBOL_PRINT_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|addressprint
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym
argument_list|)
argument_list|,
literal|1
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" in file %s, line %d\n"
argument_list|,
name|sal
operator|.
name|symtab
operator|->
name|filename
argument_list|,
name|sal
operator|.
name|line
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|values_printed
return|;
block|}
end_function

begin_comment
comment|/* Print on STREAM all the local variables in frame FRAME,    including all the blocks active in that frame    at its current pc.     Returns 1 if the job was done,    or 0 if nothing was printed because we have no info    on the function running in FRAME.  */
end_comment

begin_function
specifier|static
name|void
name|print_frame_local_vars
parameter_list|(
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|,
name|int
name|num_tabs
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|)
block|{
name|struct
name|block
modifier|*
name|block
init|=
name|get_frame_block
argument_list|(
name|fi
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|values_printed
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|block
operator|==
literal|0
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"No symbol table info available.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|block
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|print_block_frame_locals
argument_list|(
name|block
argument_list|,
name|fi
argument_list|,
name|num_tabs
argument_list|,
name|stream
argument_list|)
condition|)
name|values_printed
operator|=
literal|1
expr_stmt|;
comment|/* After handling the function's top-level block, stop.          Don't continue to its superblock, the block of          per-file symbols.  */
if|if
condition|(
name|BLOCK_FUNCTION
argument_list|(
name|block
argument_list|)
condition|)
break|break;
name|block
operator|=
name|BLOCK_SUPERBLOCK
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|values_printed
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"No locals.\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Same, but print labels.  */
end_comment

begin_function
specifier|static
name|void
name|print_frame_label_vars
parameter_list|(
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|,
name|int
name|this_level_only
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|)
block|{
name|struct
name|blockvector
modifier|*
name|bl
decl_stmt|;
name|struct
name|block
modifier|*
name|block
init|=
name|get_frame_block
argument_list|(
name|fi
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|values_printed
init|=
literal|0
decl_stmt|;
name|int
name|index
decl_stmt|,
name|have_default
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|blocks_printed
decl_stmt|;
name|CORE_ADDR
name|pc
init|=
name|get_frame_pc
argument_list|(
name|fi
argument_list|)
decl_stmt|;
if|if
condition|(
name|block
operator|==
literal|0
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"No symbol table info available.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|bl
operator|=
name|blockvector_for_pc
argument_list|(
name|BLOCK_END
argument_list|(
name|block
argument_list|)
operator|-
literal|4
argument_list|,
operator|&
name|index
argument_list|)
expr_stmt|;
name|blocks_printed
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|BLOCKVECTOR_NBLOCKS
argument_list|(
name|bl
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|blocks_printed
argument_list|,
literal|0
argument_list|,
name|BLOCKVECTOR_NBLOCKS
argument_list|(
name|bl
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|block
operator|!=
literal|0
condition|)
block|{
name|CORE_ADDR
name|end
init|=
name|BLOCK_END
argument_list|(
name|block
argument_list|)
operator|-
literal|4
decl_stmt|;
name|int
name|last_index
decl_stmt|;
if|if
condition|(
name|bl
operator|!=
name|blockvector_for_pc
argument_list|(
name|end
argument_list|,
operator|&
name|index
argument_list|)
condition|)
name|error
argument_list|(
literal|"blockvector blotch"
argument_list|)
expr_stmt|;
if|if
condition|(
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bl
argument_list|,
name|index
argument_list|)
operator|!=
name|block
condition|)
name|error
argument_list|(
literal|"blockvector botch"
argument_list|)
expr_stmt|;
name|last_index
operator|=
name|BLOCKVECTOR_NBLOCKS
argument_list|(
name|bl
argument_list|)
expr_stmt|;
name|index
operator|+=
literal|1
expr_stmt|;
comment|/* Don't print out blocks that have gone by.  */
while|while
condition|(
name|index
operator|<
name|last_index
operator|&&
name|BLOCK_END
argument_list|(
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bl
argument_list|,
name|index
argument_list|)
argument_list|)
operator|<
name|pc
condition|)
name|index
operator|++
expr_stmt|;
while|while
condition|(
name|index
operator|<
name|last_index
operator|&&
name|BLOCK_END
argument_list|(
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bl
argument_list|,
name|index
argument_list|)
argument_list|)
operator|<
name|end
condition|)
block|{
if|if
condition|(
name|blocks_printed
index|[
name|index
index|]
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|print_block_frame_labels
argument_list|(
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bl
argument_list|,
name|index
argument_list|)
argument_list|,
operator|&
name|have_default
argument_list|,
name|stream
argument_list|)
condition|)
name|values_printed
operator|=
literal|1
expr_stmt|;
name|blocks_printed
index|[
name|index
index|]
operator|=
literal|1
expr_stmt|;
block|}
name|index
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|have_default
condition|)
return|return;
if|if
condition|(
name|values_printed
operator|&&
name|this_level_only
condition|)
return|return;
comment|/* After handling the function's top-level block, stop.          Don't continue to its superblock, the block of          per-file symbols.  */
if|if
condition|(
name|BLOCK_FUNCTION
argument_list|(
name|block
argument_list|)
condition|)
break|break;
name|block
operator|=
name|BLOCK_SUPERBLOCK
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|values_printed
operator|&&
operator|!
name|this_level_only
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"No catches.\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|locals_info
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
if|if
condition|(
operator|!
name|deprecated_selected_frame
condition|)
name|error
argument_list|(
literal|"No frame selected."
argument_list|)
expr_stmt|;
name|print_frame_local_vars
argument_list|(
name|deprecated_selected_frame
argument_list|,
literal|0
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|catch_info
parameter_list|(
name|char
modifier|*
name|ignore
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|symtab_and_line
modifier|*
name|sal
decl_stmt|;
comment|/* Check for target support for exception handling */
name|sal
operator|=
name|target_enable_exception_callback
argument_list|(
name|EX_EVENT_CATCH
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sal
condition|)
block|{
comment|/* Currently not handling this */
comment|/* Ideally, here we should interact with the C++ runtime          system to find the list of active handlers, etc. */
name|fprintf_filtered
argument_list|(
name|gdb_stdout
argument_list|,
literal|"Info catch not supported with this target/compiler combination.\n"
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (!deprecated_selected_frame) 	error ("No frame selected.");
endif|#
directive|endif
block|}
else|else
block|{
comment|/* Assume g++ compiled code -- old v 4.16 behaviour */
if|if
condition|(
operator|!
name|deprecated_selected_frame
condition|)
name|error
argument_list|(
literal|"No frame selected."
argument_list|)
expr_stmt|;
name|print_frame_label_vars
argument_list|(
name|deprecated_selected_frame
argument_list|,
literal|0
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|print_frame_arg_vars
parameter_list|(
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|)
block|{
name|struct
name|symbol
modifier|*
name|func
init|=
name|get_frame_function
argument_list|(
name|fi
argument_list|)
decl_stmt|;
name|struct
name|block
modifier|*
name|b
decl_stmt|;
name|struct
name|dict_iterator
name|iter
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|,
modifier|*
name|sym2
decl_stmt|;
name|int
name|values_printed
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|func
operator|==
literal|0
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"No symbol table info available.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|b
operator|=
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|func
argument_list|)
expr_stmt|;
name|ALL_BLOCK_SYMBOLS
argument_list|(
argument|b
argument_list|,
argument|iter
argument_list|,
argument|sym
argument_list|)
block|{
switch|switch
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
condition|)
block|{
case|case
name|LOC_ARG
case|:
case|case
name|LOC_LOCAL_ARG
case|:
case|case
name|LOC_REF_ARG
case|:
case|case
name|LOC_REGPARM
case|:
case|case
name|LOC_REGPARM_ADDR
case|:
case|case
name|LOC_BASEREG_ARG
case|:
case|case
name|LOC_COMPUTED_ARG
case|:
name|values_printed
operator|=
literal|1
expr_stmt|;
name|fputs_filtered
argument_list|(
name|SYMBOL_PRINT_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|" = "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
comment|/* We have to look up the symbol because arguments can have 	     two entries (one a parameter, one a local) and the one we 	     want is the local, which lookup_symbol will find for us. 	     This includes gcc1 (not gcc2) on the sparc when passing a 	     small structure and gcc2 when the argument type is float 	     and it is passed as a double and converted to float by 	     the prologue (in the latter case the type of the LOC_ARG 	     symbol is double and the type of the LOC_LOCAL symbol is 	     float).  There are also LOC_ARG/LOC_REGISTER pairs which 	     are not combined in symbol-reading.  */
name|sym2
operator|=
name|lookup_symbol
argument_list|(
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|b
argument_list|,
name|VAR_DOMAIN
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
operator|(
expr|struct
name|symtab
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|print_variable_value
argument_list|(
name|sym2
argument_list|,
name|fi
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Don't worry about things which aren't arguments.  */
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|values_printed
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"No arguments.\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|args_info
parameter_list|(
name|char
modifier|*
name|ignore
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
if|if
condition|(
operator|!
name|deprecated_selected_frame
condition|)
name|error
argument_list|(
literal|"No frame selected."
argument_list|)
expr_stmt|;
name|print_frame_arg_vars
argument_list|(
name|deprecated_selected_frame
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|args_plus_locals_info
parameter_list|(
name|char
modifier|*
name|ignore
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|args_info
argument_list|(
name|ignore
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
name|locals_info
argument_list|(
name|ignore
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Select frame FI.  Also print the stack frame and show the source if    this is the tui version.  */
end_comment

begin_function
specifier|static
name|void
name|select_and_print_frame
parameter_list|(
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|)
block|{
name|select_frame
argument_list|(
name|fi
argument_list|)
expr_stmt|;
if|if
condition|(
name|fi
condition|)
block|{
name|print_stack_frame
argument_list|(
name|fi
argument_list|,
name|frame_relative_level
argument_list|(
name|fi
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the symbol-block in which the selected frame is executing.    Can return zero under various legitimate circumstances.     If ADDR_IN_BLOCK is non-zero, set *ADDR_IN_BLOCK to the relevant    code address within the block returned.  We use this to decide    which macros are in scope.  */
end_comment

begin_function
name|struct
name|block
modifier|*
name|get_selected_block
parameter_list|(
name|CORE_ADDR
modifier|*
name|addr_in_block
parameter_list|)
block|{
if|if
condition|(
operator|!
name|target_has_stack
condition|)
return|return
literal|0
return|;
comment|/* NOTE: cagney/2002-11-28: Why go to all this effort to not create      a selected/current frame?  Perhaphs this function is called,      indirectly, by WFI in "infrun.c" where avoiding the creation of      an inner most frame is very important (it slows down single      step).  I suspect, though that this was true in the deep dark      past but is no longer the case.  A mindless look at all the      callers tends to support this theory.  I think we should be able      to assume that there is always a selcted frame.  */
comment|/* gdb_assert (deprecated_selected_frame != NULL); So, do you feel      lucky? */
if|if
condition|(
operator|!
name|deprecated_selected_frame
condition|)
block|{
name|CORE_ADDR
name|pc
init|=
name|read_pc
argument_list|()
decl_stmt|;
if|if
condition|(
name|addr_in_block
operator|!=
name|NULL
condition|)
operator|*
name|addr_in_block
operator|=
name|pc
expr_stmt|;
return|return
name|block_for_pc
argument_list|(
name|pc
argument_list|)
return|;
block|}
return|return
name|get_frame_block
argument_list|(
name|deprecated_selected_frame
argument_list|,
name|addr_in_block
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Find a frame a certain number of levels away from FRAME.    LEVEL_OFFSET_PTR points to an int containing the number of levels.    Positive means go to earlier frames (up); negative, the reverse.    The int that contains the number of levels is counted toward    zero as the frames for those levels are found.    If the top or bottom frame is reached, that frame is returned,    but the final value of *LEVEL_OFFSET_PTR is nonzero and indicates    how much farther the original request asked to go.  */
end_comment

begin_function
name|struct
name|frame_info
modifier|*
name|find_relative_frame
parameter_list|(
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|,
name|int
modifier|*
name|level_offset_ptr
parameter_list|)
block|{
name|struct
name|frame_info
modifier|*
name|prev
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|frame1
decl_stmt|;
comment|/* Going up is simple: just do get_prev_frame enough times      or until initial frame is reached.  */
while|while
condition|(
operator|*
name|level_offset_ptr
operator|>
literal|0
condition|)
block|{
name|prev
operator|=
name|get_prev_frame
argument_list|(
name|frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
operator|==
literal|0
condition|)
break|break;
operator|(
operator|*
name|level_offset_ptr
operator|)
operator|--
expr_stmt|;
name|frame
operator|=
name|prev
expr_stmt|;
block|}
comment|/* Going down is just as simple.  */
if|if
condition|(
operator|*
name|level_offset_ptr
operator|<
literal|0
condition|)
block|{
while|while
condition|(
operator|*
name|level_offset_ptr
operator|<
literal|0
condition|)
block|{
name|frame1
operator|=
name|get_next_frame
argument_list|(
name|frame
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|frame1
condition|)
break|break;
name|frame
operator|=
name|frame1
expr_stmt|;
operator|(
operator|*
name|level_offset_ptr
operator|)
operator|++
expr_stmt|;
block|}
block|}
return|return
name|frame
return|;
block|}
end_function

begin_comment
comment|/* The "select_frame" command.  With no arg, NOP.    With arg LEVEL_EXP, select the frame at level LEVEL if it is a    valid level.  Otherwise, treat level_exp as an address expression    and select it.  See parse_frame_specification for more info on proper    frame expressions. */
end_comment

begin_function
name|void
name|select_frame_command
parameter_list|(
name|char
modifier|*
name|level_exp
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|frame_info
modifier|*
name|frame
decl_stmt|;
name|int
name|level
init|=
name|frame_relative_level
argument_list|(
name|deprecated_selected_frame
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|target_has_stack
condition|)
name|error
argument_list|(
literal|"No stack."
argument_list|)
expr_stmt|;
name|frame
operator|=
name|parse_frame_specification
argument_list|(
name|level_exp
argument_list|)
expr_stmt|;
name|select_frame
argument_list|(
name|frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|level
operator|!=
name|frame_relative_level
argument_list|(
name|deprecated_selected_frame
argument_list|)
condition|)
name|selected_frame_level_changed_event
argument_list|(
name|frame_relative_level
argument_list|(
name|deprecated_selected_frame
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The "frame" command.  With no arg, print selected frame briefly.    With arg, behaves like select_frame and then prints the selected    frame.  */
end_comment

begin_function
name|void
name|frame_command
parameter_list|(
name|char
modifier|*
name|level_exp
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|select_frame_command
argument_list|(
name|level_exp
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
name|print_stack_frame
argument_list|(
name|deprecated_selected_frame
argument_list|,
name|frame_relative_level
argument_list|(
name|deprecated_selected_frame
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The XDB Compatibility command to print the current frame. */
end_comment

begin_function
specifier|static
name|void
name|current_frame_command
parameter_list|(
name|char
modifier|*
name|level_exp
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
if|if
condition|(
name|target_has_stack
operator|==
literal|0
operator|||
name|deprecated_selected_frame
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No stack."
argument_list|)
expr_stmt|;
name|print_stack_frame
argument_list|(
name|deprecated_selected_frame
argument_list|,
name|frame_relative_level
argument_list|(
name|deprecated_selected_frame
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Select the frame up one or COUNT stack levels    from the previously selected frame, and print it briefly.  */
end_comment

begin_function
specifier|static
name|void
name|up_silently_base
parameter_list|(
name|char
modifier|*
name|count_exp
parameter_list|)
block|{
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
name|int
name|count
init|=
literal|1
decl_stmt|,
name|count1
decl_stmt|;
if|if
condition|(
name|count_exp
condition|)
name|count
operator|=
name|parse_and_eval_long
argument_list|(
name|count_exp
argument_list|)
expr_stmt|;
name|count1
operator|=
name|count
expr_stmt|;
if|if
condition|(
name|target_has_stack
operator|==
literal|0
operator|||
name|deprecated_selected_frame
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No stack."
argument_list|)
expr_stmt|;
name|fi
operator|=
name|find_relative_frame
argument_list|(
name|deprecated_selected_frame
argument_list|,
operator|&
name|count1
argument_list|)
expr_stmt|;
if|if
condition|(
name|count1
operator|!=
literal|0
operator|&&
name|count_exp
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Initial frame selected; you cannot go up."
argument_list|)
expr_stmt|;
name|select_frame
argument_list|(
name|fi
argument_list|)
expr_stmt|;
name|selected_frame_level_changed_event
argument_list|(
name|frame_relative_level
argument_list|(
name|deprecated_selected_frame
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|up_silently_command
parameter_list|(
name|char
modifier|*
name|count_exp
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|up_silently_base
argument_list|(
name|count_exp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|up_command
parameter_list|(
name|char
modifier|*
name|count_exp
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|up_silently_base
argument_list|(
name|count_exp
argument_list|)
expr_stmt|;
name|print_stack_frame
argument_list|(
name|deprecated_selected_frame
argument_list|,
name|frame_relative_level
argument_list|(
name|deprecated_selected_frame
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Select the frame down one or COUNT stack levels    from the previously selected frame, and print it briefly.  */
end_comment

begin_function
specifier|static
name|void
name|down_silently_base
parameter_list|(
name|char
modifier|*
name|count_exp
parameter_list|)
block|{
name|struct
name|frame_info
modifier|*
name|frame
decl_stmt|;
name|int
name|count
init|=
operator|-
literal|1
decl_stmt|,
name|count1
decl_stmt|;
if|if
condition|(
name|count_exp
condition|)
name|count
operator|=
operator|-
name|parse_and_eval_long
argument_list|(
name|count_exp
argument_list|)
expr_stmt|;
name|count1
operator|=
name|count
expr_stmt|;
if|if
condition|(
name|target_has_stack
operator|==
literal|0
operator|||
name|deprecated_selected_frame
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No stack."
argument_list|)
expr_stmt|;
name|frame
operator|=
name|find_relative_frame
argument_list|(
name|deprecated_selected_frame
argument_list|,
operator|&
name|count1
argument_list|)
expr_stmt|;
if|if
condition|(
name|count1
operator|!=
literal|0
operator|&&
name|count_exp
operator|==
literal|0
condition|)
block|{
comment|/* We only do this if count_exp is not specified.  That way "down"          means to really go down (and let me know if that is          impossible), but "down 9999" can be used to mean go all the way          down without getting an error.  */
name|error
argument_list|(
literal|"Bottom (i.e., innermost) frame selected; you cannot go down."
argument_list|)
expr_stmt|;
block|}
name|select_frame
argument_list|(
name|frame
argument_list|)
expr_stmt|;
name|selected_frame_level_changed_event
argument_list|(
name|frame_relative_level
argument_list|(
name|deprecated_selected_frame
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|down_silently_command
parameter_list|(
name|char
modifier|*
name|count_exp
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|down_silently_base
argument_list|(
name|count_exp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|down_command
parameter_list|(
name|char
modifier|*
name|count_exp
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|down_silently_base
argument_list|(
name|count_exp
argument_list|)
expr_stmt|;
name|print_stack_frame
argument_list|(
name|deprecated_selected_frame
argument_list|,
name|frame_relative_level
argument_list|(
name|deprecated_selected_frame
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|return_command
parameter_list|(
name|char
modifier|*
name|retval_exp
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|symbol
modifier|*
name|thisfun
decl_stmt|;
name|struct
name|value
modifier|*
name|return_value
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|query_prefix
init|=
literal|""
decl_stmt|;
comment|/* FIXME: cagney/2003-10-20: Perform a minimal existance test on the      target.  If that fails, error out.  For the moment don't rely on      get_selected_frame as it's error message is the the singularly      obscure "No registers".  */
if|if
condition|(
operator|!
name|target_has_registers
condition|)
name|error
argument_list|(
literal|"No selected frame."
argument_list|)
expr_stmt|;
name|thisfun
operator|=
name|get_frame_function
argument_list|(
name|get_selected_frame
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Compute the return value.  If the computation triggers an error,      let it bail.  If the return type can't be handled, set      RETURN_VALUE to NULL, and QUERY_PREFIX to an informational      message.  */
if|if
condition|(
name|retval_exp
condition|)
block|{
name|struct
name|type
modifier|*
name|return_type
init|=
name|NULL
decl_stmt|;
comment|/* Compute the return value.  Should the computation fail, this          call throws an error.  */
name|return_value
operator|=
name|parse_and_eval
argument_list|(
name|retval_exp
argument_list|)
expr_stmt|;
comment|/* Cast return value to the return type of the function.  Should          the cast fail, this call throws an error.  */
if|if
condition|(
name|thisfun
operator|!=
name|NULL
condition|)
name|return_type
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|thisfun
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|return_type
operator|==
name|NULL
condition|)
name|return_type
operator|=
name|builtin_type_int
expr_stmt|;
name|return_value
operator|=
name|value_cast
argument_list|(
name|return_type
argument_list|,
name|return_value
argument_list|)
expr_stmt|;
comment|/* Make sure the value is fully evaluated.  It may live in the          stack frame we're about to pop.  */
if|if
condition|(
name|VALUE_LAZY
argument_list|(
name|return_value
argument_list|)
condition|)
name|value_fetch_lazy
argument_list|(
name|return_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|return_type
argument_list|)
operator|==
name|TYPE_CODE_VOID
condition|)
comment|/* If the return-type is "void", don't try to find the            return-value's location.  However, do still evaluate the            return expression so that, even when the expression result            is discarded, side effects such as "return i++" still            occure.  */
name|return_value
operator|=
name|NULL
expr_stmt|;
comment|/* FIXME: cagney/2004-01-17: If the architecture implements both          return_value and extract_returned_value_address, should allow          "return" to work - don't set return_value to NULL.  */
elseif|else
if|if
condition|(
operator|!
name|gdbarch_return_value_p
argument_list|(
name|current_gdbarch
argument_list|)
operator|&&
operator|(
name|TYPE_CODE
argument_list|(
name|return_type
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
operator|||
name|TYPE_CODE
argument_list|(
name|return_type
argument_list|)
operator|==
name|TYPE_CODE_UNION
operator|)
condition|)
block|{
comment|/* NOTE: cagney/2003-10-20: Compatibility hack for legacy 	     code.  Old architectures don't expect STORE_RETURN_VALUE 	     to be called with with a small struct that needs to be 	     stored in registers.  Don't start doing it now.  */
name|query_prefix
operator|=
literal|"\ A structure or union return type is not supported by this architecture.\n\ If you continue, the return value that you specified will be ignored.\n"
expr_stmt|;
name|return_value
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|using_struct_return
argument_list|(
name|return_type
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|query_prefix
operator|=
literal|"\ The location at which to store the function's return value is unknown.\n\ If you continue, the return value that you specified will be ignored.\n"
expr_stmt|;
name|return_value
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* Does an interactive user really want to do this?  Include      information, such as how well GDB can handle the return value, in      the query message.  */
if|if
condition|(
name|from_tty
condition|)
block|{
name|int
name|confirmed
decl_stmt|;
if|if
condition|(
name|thisfun
operator|==
name|NULL
condition|)
name|confirmed
operator|=
name|query
argument_list|(
literal|"%sMake selected stack frame return now? "
argument_list|,
name|query_prefix
argument_list|)
expr_stmt|;
else|else
name|confirmed
operator|=
name|query
argument_list|(
literal|"%sMake %s return now? "
argument_list|,
name|query_prefix
argument_list|,
name|SYMBOL_PRINT_NAME
argument_list|(
name|thisfun
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|confirmed
condition|)
name|error
argument_list|(
literal|"Not confirmed"
argument_list|)
expr_stmt|;
block|}
comment|/* NOTE: cagney/2003-01-18: Is this silly?  Rather than pop each      frame in turn, should this code just go straight to the relevant      frame and pop that?  */
comment|/* First discard all frames inner-to the selected frame (making the      selected frame current).  */
block|{
name|struct
name|frame_id
name|selected_id
init|=
name|get_frame_id
argument_list|(
name|get_selected_frame
argument_list|()
argument_list|)
decl_stmt|;
while|while
condition|(
operator|!
name|frame_id_eq
argument_list|(
name|selected_id
argument_list|,
name|get_frame_id
argument_list|(
name|get_current_frame
argument_list|()
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|frame_id_inner
argument_list|(
name|selected_id
argument_list|,
name|get_frame_id
argument_list|(
name|get_current_frame
argument_list|()
argument_list|)
argument_list|)
condition|)
comment|/* Caught in the safety net, oops!  We've gone way past the              selected frame.  */
name|error
argument_list|(
literal|"Problem while popping stack frames (corrupt stack?)"
argument_list|)
expr_stmt|;
name|frame_pop
argument_list|(
name|get_current_frame
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Second discard the selected frame (which is now also the current      frame).  */
name|frame_pop
argument_list|(
name|get_current_frame
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Store RETURN_VAUE in the just-returned register set.  */
if|if
condition|(
name|return_value
operator|!=
name|NULL
condition|)
block|{
name|struct
name|type
modifier|*
name|return_type
init|=
name|VALUE_TYPE
argument_list|(
name|return_value
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|gdbarch_return_value_p
argument_list|(
name|current_gdbarch
argument_list|)
condition|)
block|{
name|STORE_RETURN_VALUE
argument_list|(
name|return_type
argument_list|,
name|current_regcache
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|return_value
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* FIXME: cagney/2004-01-17: If extract_returned_value_address          is available and the function is using          RETURN_VALUE_STRUCT_CONVENTION, should use it to find the          address of the returned value so that it can be assigned.  */
else|else
block|{
name|gdb_assert
argument_list|(
name|gdbarch_return_value
argument_list|(
name|current_gdbarch
argument_list|,
name|return_type
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|==
name|RETURN_VALUE_REGISTER_CONVENTION
argument_list|)
expr_stmt|;
name|gdbarch_return_value
argument_list|(
name|current_gdbarch
argument_list|,
name|return_type
argument_list|,
name|current_regcache
argument_list|,
name|NULL
comment|/*read*/
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|return_value
argument_list|)
comment|/*write*/
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If we are at the end of a call dummy now, pop the dummy frame      too.  */
comment|/* NOTE: cagney/2003-01-18: Is this silly?  Instead of popping all      the frames in sequence, should this code just pop the dummy frame      directly?  */
ifdef|#
directive|ifdef
name|DEPRECATED_CALL_DUMMY_HAS_COMPLETED
comment|/* Since all up-to-date architectures return direct to the dummy      breakpoint address, a dummy frame has, by definition, always      completed.  Hence this method is no longer needed.  */
if|if
condition|(
name|DEPRECATED_CALL_DUMMY_HAS_COMPLETED
argument_list|(
name|read_pc
argument_list|()
argument_list|,
name|read_sp
argument_list|()
argument_list|,
name|get_frame_base
argument_list|(
name|get_current_frame
argument_list|()
argument_list|)
argument_list|)
condition|)
name|frame_pop
argument_list|(
name|get_current_frame
argument_list|()
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|get_frame_type
argument_list|(
name|get_current_frame
argument_list|()
argument_list|)
operator|==
name|DUMMY_FRAME
condition|)
name|frame_pop
argument_list|(
name|get_current_frame
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If interactive, print the frame that is now current.  */
if|if
condition|(
name|from_tty
condition|)
name|frame_command
argument_list|(
literal|"0"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|select_frame_command
argument_list|(
literal|"0"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Sets the scope to input function name, provided that the    function is within the current stack frame */
end_comment

begin_struct
struct|struct
name|function_bounds
block|{
name|CORE_ADDR
name|low
decl_stmt|,
name|high
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|void
name|func_command
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|func_command
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|frame_info
modifier|*
name|fp
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
name|struct
name|symtabs_and_lines
name|sals
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|level
init|=
literal|1
decl_stmt|;
name|struct
name|function_bounds
modifier|*
name|func_bounds
init|=
operator|(
expr|struct
name|function_bounds
operator|*
operator|)
name|NULL
decl_stmt|;
if|if
condition|(
name|arg
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
return|return;
name|fp
operator|=
name|parse_frame_specification
argument_list|(
literal|"0"
argument_list|)
expr_stmt|;
name|sals
operator|=
name|decode_line_spec
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|func_bounds
operator|=
operator|(
expr|struct
name|function_bounds
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|function_bounds
argument_list|)
operator|*
name|sals
operator|.
name|nelts
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|sals
operator|.
name|nelts
operator|&&
operator|!
name|found
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sals
operator|.
name|sals
index|[
name|i
index|]
operator|.
name|pc
operator|==
operator|(
name|CORE_ADDR
operator|)
literal|0
operator|||
name|find_pc_partial_function
argument_list|(
name|sals
operator|.
name|sals
index|[
name|i
index|]
operator|.
name|pc
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|func_bounds
index|[
name|i
index|]
operator|.
name|low
argument_list|,
operator|&
name|func_bounds
index|[
name|i
index|]
operator|.
name|high
argument_list|)
operator|==
literal|0
condition|)
block|{
name|func_bounds
index|[
name|i
index|]
operator|.
name|low
operator|=
name|func_bounds
index|[
name|i
index|]
operator|.
name|high
operator|=
operator|(
name|CORE_ADDR
operator|)
name|NULL
expr_stmt|;
block|}
block|}
do|do
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|sals
operator|.
name|nelts
operator|&&
operator|!
name|found
operator|)
condition|;
name|i
operator|++
control|)
name|found
operator|=
operator|(
name|get_frame_pc
argument_list|(
name|fp
argument_list|)
operator|>=
name|func_bounds
index|[
name|i
index|]
operator|.
name|low
operator|&&
name|get_frame_pc
argument_list|(
name|fp
argument_list|)
operator|<
name|func_bounds
index|[
name|i
index|]
operator|.
name|high
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|level
operator|=
literal|1
expr_stmt|;
name|fp
operator|=
name|find_relative_frame
argument_list|(
name|fp
argument_list|,
operator|&
name|level
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|!
name|found
operator|&&
name|level
operator|==
literal|0
condition|)
do|;
if|if
condition|(
name|func_bounds
condition|)
name|xfree
argument_list|(
name|func_bounds
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|found
condition|)
name|printf_filtered
argument_list|(
literal|"'%s' not within current stack frame.\n"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fp
operator|!=
name|deprecated_selected_frame
condition|)
name|select_and_print_frame
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Gets the language of the current frame.  */
end_comment

begin_function
name|enum
name|language
name|get_frame_language
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
name|enum
name|language
name|flang
decl_stmt|;
comment|/* The language of the current frame */
if|if
condition|(
name|deprecated_selected_frame
condition|)
block|{
comment|/* We determine the current frame language by looking up its          associated symtab.  To retrieve this symtab, we use the frame PC.          However we cannot use the frame pc as is, because it usually points          to the instruction following the "call", which is sometimes the first          instruction of another function.  So we rely on          get_frame_address_in_block(), it provides us with a PC which is          guaranteed to be inside the frame's code block.  */
name|s
operator|=
name|find_pc_symtab
argument_list|(
name|get_frame_address_in_block
argument_list|(
name|deprecated_selected_frame
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
condition|)
name|flang
operator|=
name|s
operator|->
name|language
expr_stmt|;
else|else
name|flang
operator|=
name|language_unknown
expr_stmt|;
block|}
else|else
name|flang
operator|=
name|language_unknown
expr_stmt|;
return|return
name|flang
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|_initialize_stack
parameter_list|(
name|void
parameter_list|)
block|{
if|#
directive|if
literal|0
block|backtrace_limit = 30;
endif|#
directive|endif
name|add_com
argument_list|(
literal|"return"
argument_list|,
name|class_stack
argument_list|,
name|return_command
argument_list|,
literal|"Make selected stack frame return to its caller.\n\ Control remains in the debugger, but when you continue\n\ execution will resume in the frame above the one now selected.\n\ If an argument is given, it is an expression for the value to return."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"up"
argument_list|,
name|class_stack
argument_list|,
name|up_command
argument_list|,
literal|"Select and print stack frame that called this one.\n\ An argument says how many frames up to go."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"up-silently"
argument_list|,
name|class_support
argument_list|,
name|up_silently_command
argument_list|,
literal|"Same as the `up' command, but does not print anything.\n\ This is useful in command scripts."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"down"
argument_list|,
name|class_stack
argument_list|,
name|down_command
argument_list|,
literal|"Select and print stack frame called by this one.\n\ An argument says how many frames down to go."
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"do"
argument_list|,
literal|"down"
argument_list|,
name|class_stack
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"dow"
argument_list|,
literal|"down"
argument_list|,
name|class_stack
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"down-silently"
argument_list|,
name|class_support
argument_list|,
name|down_silently_command
argument_list|,
literal|"Same as the `down' command, but does not print anything.\n\ This is useful in command scripts."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"frame"
argument_list|,
name|class_stack
argument_list|,
name|frame_command
argument_list|,
literal|"Select and print a stack frame.\n\ With no argument, print the selected stack frame.  (See also \"info frame\").\n\ An argument specifies the frame to select.\n\ It can be a stack frame number or the address of the frame.\n\ With argument, nothing is printed if input is coming from\n\ a command file or a user-defined command."
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"f"
argument_list|,
literal|"frame"
argument_list|,
name|class_stack
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|xdb_commands
condition|)
block|{
name|add_com
argument_list|(
literal|"L"
argument_list|,
name|class_stack
argument_list|,
name|current_frame_command
argument_list|,
literal|"Print the current stack frame.\n"
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"V"
argument_list|,
literal|"frame"
argument_list|,
name|class_stack
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|add_com
argument_list|(
literal|"select-frame"
argument_list|,
name|class_stack
argument_list|,
name|select_frame_command
argument_list|,
literal|"Select a stack frame without printing anything.\n\ An argument specifies the frame to select.\n\ It can be a stack frame number or the address of the frame.\n"
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"backtrace"
argument_list|,
name|class_stack
argument_list|,
name|backtrace_command
argument_list|,
literal|"Print backtrace of all stack frames, or innermost COUNT frames.\n\ With a negative argument, print outermost -COUNT frames.\n\ Use of the 'full' qualifier also prints the values of the local variables.\n"
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"bt"
argument_list|,
literal|"backtrace"
argument_list|,
name|class_stack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|xdb_commands
condition|)
block|{
name|add_com_alias
argument_list|(
literal|"t"
argument_list|,
literal|"backtrace"
argument_list|,
name|class_stack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"T"
argument_list|,
name|class_stack
argument_list|,
name|backtrace_full_command
argument_list|,
literal|"Print backtrace of all stack frames, or innermost COUNT frames \n\ and the values of the local variables.\n\ With a negative argument, print outermost -COUNT frames.\n\ Usage: T<count>\n"
argument_list|)
expr_stmt|;
block|}
name|add_com_alias
argument_list|(
literal|"where"
argument_list|,
literal|"backtrace"
argument_list|,
name|class_alias
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"stack"
argument_list|,
name|backtrace_command
argument_list|,
literal|"Backtrace of the stack, or innermost COUNT frames."
argument_list|)
expr_stmt|;
name|add_info_alias
argument_list|(
literal|"s"
argument_list|,
literal|"stack"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"frame"
argument_list|,
name|frame_info
argument_list|,
literal|"All about selected stack frame, or frame at ADDR."
argument_list|)
expr_stmt|;
name|add_info_alias
argument_list|(
literal|"f"
argument_list|,
literal|"frame"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"locals"
argument_list|,
name|locals_info
argument_list|,
literal|"Local variables of current stack frame."
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"args"
argument_list|,
name|args_info
argument_list|,
literal|"Argument variables of current stack frame."
argument_list|)
expr_stmt|;
if|if
condition|(
name|xdb_commands
condition|)
name|add_com
argument_list|(
literal|"l"
argument_list|,
name|class_info
argument_list|,
name|args_plus_locals_info
argument_list|,
literal|"Argument and local variables of current stack frame."
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbx_commands
condition|)
name|add_com
argument_list|(
literal|"func"
argument_list|,
name|class_stack
argument_list|,
name|func_command
argument_list|,
literal|"Select the stack frame that contains<func>.\nUsage: func<name>\n"
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"catch"
argument_list|,
name|catch_info
argument_list|,
literal|"Exceptions that can be caught in the current stack frame."
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|add_cmd ("backtrace-limit", class_stack, set_backtrace_limit_command,   "Specify maximum number of frames for \"backtrace\" to print by default.",&setlist);   add_info ("backtrace-limit", backtrace_limit_info,      "The maximum number of frames for \"backtrace\" to print by default.");
endif|#
directive|endif
block|}
end_function

end_unit

