begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Print and select stack frames for GDB, the GNU debugger.    Copyright 1986, 1987, 1989, 1991, 1992, 1993, 1994, 1995, 1996    Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"breakpoint.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"annotate.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_decl_stmt
specifier|static
name|void
name|return_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|down_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|down_silently_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|up_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|up_silently_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|frame_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|select_frame_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|args_info
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_frame_arg_vars
name|PARAMS
argument_list|(
operator|(
expr|struct
name|frame_info
operator|*
operator|,
name|GDB_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|catch_info
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|locals_info
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_frame_label_vars
name|PARAMS
argument_list|(
operator|(
expr|struct
name|frame_info
operator|*
operator|,
name|int
operator|,
name|GDB_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_frame_local_vars
name|PARAMS
argument_list|(
operator|(
expr|struct
name|frame_info
operator|*
operator|,
name|GDB_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|print_block_frame_labels
name|PARAMS
argument_list|(
operator|(
expr|struct
name|block
operator|*
operator|,
name|int
operator|*
operator|,
name|GDB_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|print_block_frame_locals
name|PARAMS
argument_list|(
operator|(
expr|struct
name|block
operator|*
operator|,
expr|struct
name|frame_info
operator|*
operator|,
name|GDB_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|backtrace_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|frame_info
modifier|*
name|parse_frame_specification
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|frame_info
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|addressprint
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print addresses, or stay symbolic only? */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|info_verbose
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Verbosity of symbol reading msgs */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|lines_to_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # of lines "list" command shows by default */
end_comment

begin_comment
comment|/* The "selected" stack frame is used by default for local and arg access.    May be zero, for no selected frame.  */
end_comment

begin_decl_stmt
name|struct
name|frame_info
modifier|*
name|selected_frame
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Level of the selected frame:    0 for innermost, 1 for its caller, ...    or -1 for frame specified by address with no defined level.  */
end_comment

begin_decl_stmt
name|int
name|selected_frame_level
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Zero means do things normally; we are interacting directly with the    user.  One means print the full filename and linenumber when a    frame is printed, and do so in a format emacs18/emacs19.22 can    parse.  Two means print similar annotations, but in many more    cases and in a slightly different syntax.  */
end_comment

begin_decl_stmt
name|int
name|annotation_level
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_struct
struct|struct
name|print_stack_frame_args
block|{
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
name|int
name|level
decl_stmt|;
name|int
name|source
decl_stmt|;
name|int
name|args
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|print_stack_frame_stub
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pass the args the way catch_errors wants them.  */
end_comment

begin_function
specifier|static
name|int
name|print_stack_frame_stub
parameter_list|(
name|args
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
block|{
name|struct
name|print_stack_frame_args
modifier|*
name|p
init|=
operator|(
expr|struct
name|print_stack_frame_args
operator|*
operator|)
name|args
decl_stmt|;
name|print_frame_info
argument_list|(
name|p
operator|->
name|fi
argument_list|,
name|p
operator|->
name|level
argument_list|,
name|p
operator|->
name|source
argument_list|,
name|p
operator|->
name|args
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Print a stack frame briefly.  FRAME_INFI should be the frame info    and LEVEL should be its level in the stack (or -1 for level not defined).    This prints the level, the function executing, the arguments,    and the file name and line number.    If the pc is not at the beginning of the source line,    the actual pc is printed at the beginning.     If SOURCE is 1, print the source line as well.    If SOURCE is -1, print ONLY the source line.  */
end_comment

begin_function
name|void
name|print_stack_frame
parameter_list|(
name|fi
parameter_list|,
name|level
parameter_list|,
name|source
parameter_list|)
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
name|int
name|level
decl_stmt|;
name|int
name|source
decl_stmt|;
block|{
name|struct
name|print_stack_frame_args
name|args
decl_stmt|;
name|args
operator|.
name|fi
operator|=
name|fi
expr_stmt|;
name|args
operator|.
name|level
operator|=
name|level
expr_stmt|;
name|args
operator|.
name|source
operator|=
name|source
expr_stmt|;
name|args
operator|.
name|args
operator|=
literal|1
expr_stmt|;
name|catch_errors
argument_list|(
name|print_stack_frame_stub
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|args
argument_list|,
literal|""
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|print_args_args
block|{
name|struct
name|symbol
modifier|*
name|func
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|print_args_stub
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pass the args the way catch_errors wants them.  */
end_comment

begin_function
specifier|static
name|int
name|print_args_stub
parameter_list|(
name|args
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
block|{
name|int
name|numargs
decl_stmt|;
name|struct
name|print_args_args
modifier|*
name|p
init|=
operator|(
expr|struct
name|print_args_args
operator|*
operator|)
name|args
decl_stmt|;
name|FRAME_NUM_ARGS
argument_list|(
name|numargs
argument_list|,
operator|(
name|p
operator|->
name|fi
operator|)
argument_list|)
expr_stmt|;
name|print_frame_args
argument_list|(
name|p
operator|->
name|func
argument_list|,
name|p
operator|->
name|fi
argument_list|,
name|numargs
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* LEVEL is the level of the frame, or -1 if it is the innermost frame    but we don't want to print the level.  */
end_comment

begin_function
name|void
name|print_frame_info
parameter_list|(
name|fi
parameter_list|,
name|level
parameter_list|,
name|source
parameter_list|,
name|args
parameter_list|)
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
specifier|register
name|int
name|level
decl_stmt|;
name|int
name|source
decl_stmt|;
name|int
name|args
decl_stmt|;
block|{
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|struct
name|symbol
modifier|*
name|func
decl_stmt|;
specifier|register
name|char
modifier|*
name|funname
init|=
literal|0
decl_stmt|;
name|enum
name|language
name|funlang
init|=
name|language_unknown
decl_stmt|;
if|#
directive|if
literal|0
block|char buf[MAX_REGISTER_RAW_SIZE];   CORE_ADDR sp;
comment|/* On the 68k, this spends too much time in m68k_find_saved_regs.  */
comment|/* Get the value of SP_REGNUM relative to the frame.  */
block|get_saved_register (buf, (int *)NULL, (CORE_ADDR *)NULL, 		      FRAME_INFO_ID (fi), SP_REGNUM, (enum lval_type *)NULL);   sp = extract_address (buf, REGISTER_RAW_SIZE (SP_REGNUM));
comment|/* This is not a perfect test, because if a function alloca's some      memory, puts some code there, and then jumps into it, then the test      will succeed even though there is no call dummy.  Probably best is      to check for a bp_call_dummy breakpoint.  */
block|if (PC_IN_CALL_DUMMY (fi->pc, sp, fi->frame))
else|#
directive|else
if|if
condition|(
name|frame_in_dummy
argument_list|(
name|fi
argument_list|)
condition|)
endif|#
directive|endif
block|{
name|annotate_frame_begin
argument_list|(
name|level
operator|==
operator|-
literal|1
condition|?
literal|0
else|:
name|level
argument_list|,
name|fi
operator|->
name|pc
argument_list|)
expr_stmt|;
comment|/* Do this regardless of SOURCE because we don't have any source 	 to list for this frame.  */
if|if
condition|(
name|level
operator|>=
literal|0
condition|)
name|printf_filtered
argument_list|(
literal|"#%-2d "
argument_list|,
name|level
argument_list|)
expr_stmt|;
name|annotate_function_call
argument_list|()
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"<function called from gdb>\n"
argument_list|)
expr_stmt|;
name|annotate_frame_end
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|fi
operator|->
name|signal_handler_caller
condition|)
block|{
name|annotate_frame_begin
argument_list|(
name|level
operator|==
operator|-
literal|1
condition|?
literal|0
else|:
name|level
argument_list|,
name|fi
operator|->
name|pc
argument_list|)
expr_stmt|;
comment|/* Do this regardless of SOURCE because we don't have any source 	 to list for this frame.  */
if|if
condition|(
name|level
operator|>=
literal|0
condition|)
name|printf_filtered
argument_list|(
literal|"#%-2d "
argument_list|,
name|level
argument_list|)
expr_stmt|;
name|annotate_signal_handler_caller
argument_list|()
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"<signal handler called>\n"
argument_list|)
expr_stmt|;
name|annotate_frame_end
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* If fi is not the innermost frame, that normally means that fi->pc      points to *after* the call instruction, and we want to get the line      containing the call, never the next line.  But if the next frame is      a signal_handler_caller or a dummy frame, then the next frame was      not entered as the result of a call, and we want to get the line      containing fi->pc.  */
name|sal
operator|=
name|find_pc_line
argument_list|(
name|fi
operator|->
name|pc
argument_list|,
name|fi
operator|->
name|next
operator|!=
name|NULL
operator|&&
operator|!
name|fi
operator|->
name|next
operator|->
name|signal_handler_caller
operator|&&
operator|!
name|frame_in_dummy
argument_list|(
name|fi
operator|->
name|next
argument_list|)
argument_list|)
expr_stmt|;
name|func
operator|=
name|find_pc_function
argument_list|(
name|fi
operator|->
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|func
condition|)
block|{
comment|/* In certain pathological cases, the symtabs give the wrong 	 function (when we are in the first function in a file which 	 is compiled without debugging symbols, the previous function 	 is compiled with debugging symbols, and the "foo.o" symbol 	 that is supposed to tell us where the file with debugging symbols 	 ends has been truncated by ar because it is longer than 15 	 characters).  This also occurs if the user uses asm() to create 	 a function but not stabs for it (in a file compiled -g).  	 So look in the minimal symbol tables as well, and if it comes 	 up with a larger address for the function use that instead. 	 I don't think this can ever cause any problems; there shouldn't 	 be any minimal symbols in the middle of a function; if this is 	 ever changed many parts of GDB will need to be changed (and we'll 	 create a find_pc_minimal_function or some such).  */
name|struct
name|minimal_symbol
modifier|*
name|msymbol
init|=
name|lookup_minimal_symbol_by_pc
argument_list|(
name|fi
operator|->
name|pc
argument_list|)
decl_stmt|;
if|if
condition|(
name|msymbol
operator|!=
name|NULL
operator|&&
operator|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
operator|>
name|BLOCK_START
argument_list|(
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|func
argument_list|)
argument_list|)
operator|)
condition|)
block|{
if|#
directive|if
literal|0
comment|/* There is no particular reason to think the line number 	     information is wrong.  Someone might have just put in 	     a label with asm() but left the line numbers alone.  */
comment|/* In this case we have no way of knowing the source file 	     and line number, so don't print them.  */
block|sal.symtab = 0;
endif|#
directive|endif
comment|/* We also don't know anything about the function besides 	     its address and name.  */
name|func
operator|=
literal|0
expr_stmt|;
name|funname
operator|=
name|SYMBOL_NAME
argument_list|(
name|msymbol
argument_list|)
expr_stmt|;
name|funlang
operator|=
name|SYMBOL_LANGUAGE
argument_list|(
name|msymbol
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|funname
operator|=
name|SYMBOL_NAME
argument_list|(
name|func
argument_list|)
expr_stmt|;
name|funlang
operator|=
name|SYMBOL_LANGUAGE
argument_list|(
name|func
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|find_pc_section
argument_list|(
name|fi
operator|->
name|pc
argument_list|)
condition|)
block|{
name|struct
name|minimal_symbol
modifier|*
name|msymbol
init|=
name|lookup_minimal_symbol_by_pc
argument_list|(
name|fi
operator|->
name|pc
argument_list|)
decl_stmt|;
if|if
condition|(
name|msymbol
operator|!=
name|NULL
condition|)
block|{
name|funname
operator|=
name|SYMBOL_NAME
argument_list|(
name|msymbol
argument_list|)
expr_stmt|;
name|funlang
operator|=
name|SYMBOL_LANGUAGE
argument_list|(
name|msymbol
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|source
operator|>=
literal|0
operator|||
operator|!
name|sal
operator|.
name|symtab
condition|)
block|{
name|annotate_frame_begin
argument_list|(
name|level
operator|==
operator|-
literal|1
condition|?
literal|0
else|:
name|level
argument_list|,
name|fi
operator|->
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|level
operator|>=
literal|0
condition|)
name|printf_filtered
argument_list|(
literal|"#%-2d "
argument_list|,
name|level
argument_list|)
expr_stmt|;
if|if
condition|(
name|addressprint
condition|)
if|if
condition|(
name|fi
operator|->
name|pc
operator|!=
name|sal
operator|.
name|pc
operator|||
operator|!
name|sal
operator|.
name|symtab
condition|)
block|{
name|annotate_frame_address
argument_list|()
expr_stmt|;
name|print_address_numeric
argument_list|(
name|fi
operator|->
name|pc
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|annotate_frame_address_end
argument_list|()
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" in "
argument_list|)
expr_stmt|;
block|}
name|annotate_frame_function_name
argument_list|()
expr_stmt|;
name|fprintf_symbol_filtered
argument_list|(
name|gdb_stdout
argument_list|,
name|funname
condition|?
name|funname
else|:
literal|"??"
argument_list|,
name|funlang
argument_list|,
name|DMGL_ANSI
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|"   "
argument_list|)
expr_stmt|;
name|annotate_frame_args
argument_list|()
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|" ("
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
condition|)
block|{
name|struct
name|print_args_args
name|args
decl_stmt|;
name|args
operator|.
name|fi
operator|=
name|fi
expr_stmt|;
name|args
operator|.
name|func
operator|=
name|func
expr_stmt|;
name|catch_errors
argument_list|(
name|print_args_stub
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|args
argument_list|,
literal|""
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
expr_stmt|;
name|QUIT
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sal
operator|.
name|symtab
operator|&&
name|sal
operator|.
name|symtab
operator|->
name|filename
condition|)
block|{
name|annotate_frame_source_begin
argument_list|()
expr_stmt|;
name|wrap_here
argument_list|(
literal|"   "
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" at "
argument_list|)
expr_stmt|;
name|annotate_frame_source_file
argument_list|()
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%s"
argument_list|,
name|sal
operator|.
name|symtab
operator|->
name|filename
argument_list|)
expr_stmt|;
name|annotate_frame_source_file_end
argument_list|()
expr_stmt|;
name|printf_filtered
argument_list|(
literal|":"
argument_list|)
expr_stmt|;
name|annotate_frame_source_line
argument_list|()
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%d"
argument_list|,
name|sal
operator|.
name|line
argument_list|)
expr_stmt|;
name|annotate_frame_source_end
argument_list|()
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PC_LOAD_SEGMENT
comment|/* If we couldn't print out function name but if can figure out what         load segment this pc value is from, at least print out some info 	about its load segment. */
if|if
condition|(
operator|!
name|funname
condition|)
block|{
name|annotate_frame_where
argument_list|()
expr_stmt|;
name|wrap_here
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" from %s"
argument_list|,
name|PC_LOAD_SEGMENT
argument_list|(
name|fi
operator|->
name|pc
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PC_SOLIB
if|if
condition|(
operator|!
name|funname
condition|)
block|{
name|char
modifier|*
name|lib
init|=
name|PC_SOLIB
argument_list|(
name|fi
operator|->
name|pc
argument_list|)
decl_stmt|;
if|if
condition|(
name|lib
condition|)
block|{
name|annotate_frame_where
argument_list|()
expr_stmt|;
name|wrap_here
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" from %s"
argument_list|,
name|lib
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|source
operator|!=
literal|0
operator|)
operator|&&
name|sal
operator|.
name|symtab
condition|)
block|{
name|int
name|done
init|=
literal|0
decl_stmt|;
name|int
name|mid_statement
init|=
name|source
operator|<
literal|0
operator|&&
name|fi
operator|->
name|pc
operator|!=
name|sal
operator|.
name|pc
decl_stmt|;
if|if
condition|(
name|annotation_level
condition|)
name|done
operator|=
name|identify_source_line
argument_list|(
name|sal
operator|.
name|symtab
argument_list|,
name|sal
operator|.
name|line
argument_list|,
name|mid_statement
argument_list|,
name|fi
operator|->
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|done
condition|)
block|{
if|if
condition|(
name|addressprint
operator|&&
name|mid_statement
condition|)
block|{
name|print_address_numeric
argument_list|(
name|fi
operator|->
name|pc
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|print_frame_info_listing_hook
condition|)
name|print_frame_info_listing_hook
argument_list|(
name|sal
operator|.
name|symtab
argument_list|,
name|sal
operator|.
name|line
argument_list|,
name|sal
operator|.
name|line
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|print_source_lines
argument_list|(
name|sal
operator|.
name|symtab
argument_list|,
name|sal
operator|.
name|line
argument_list|,
name|sal
operator|.
name|line
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|current_source_line
operator|=
name|max
argument_list|(
name|sal
operator|.
name|line
operator|-
name|lines_to_list
operator|/
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|source
operator|!=
literal|0
condition|)
name|set_default_breakpoint
argument_list|(
literal|1
argument_list|,
name|fi
operator|->
name|pc
argument_list|,
name|sal
operator|.
name|symtab
argument_list|,
name|sal
operator|.
name|line
argument_list|)
expr_stmt|;
name|annotate_frame_end
argument_list|()
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read a frame specification in whatever the appropriate format is.    Call error() if the specification is in any way invalid (i.e.    this function never returns NULL).  */
end_comment

begin_function
specifier|static
name|struct
name|frame_info
modifier|*
name|parse_frame_specification
parameter_list|(
name|frame_exp
parameter_list|)
name|char
modifier|*
name|frame_exp
decl_stmt|;
block|{
name|int
name|numargs
init|=
literal|0
decl_stmt|;
define|#
directive|define
name|MAXARGS
value|4
name|CORE_ADDR
name|args
index|[
name|MAXARGS
index|]
decl_stmt|;
if|if
condition|(
name|frame_exp
condition|)
block|{
name|char
modifier|*
name|addr_string
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|tmp_cleanup
decl_stmt|;
while|while
condition|(
operator|*
name|frame_exp
operator|==
literal|' '
condition|)
name|frame_exp
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|frame_exp
condition|)
block|{
if|if
condition|(
name|numargs
operator|>
name|MAXARGS
condition|)
name|error
argument_list|(
literal|"Too many args in frame specification"
argument_list|)
expr_stmt|;
comment|/* Parse an argument.  */
for|for
control|(
name|p
operator|=
name|frame_exp
init|;
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|' '
condition|;
name|p
operator|++
control|)
empty_stmt|;
name|addr_string
operator|=
name|savestring
argument_list|(
name|frame_exp
argument_list|,
name|p
operator|-
name|frame_exp
argument_list|)
expr_stmt|;
block|{
name|tmp_cleanup
operator|=
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|addr_string
argument_list|)
expr_stmt|;
name|args
index|[
name|numargs
operator|++
index|]
operator|=
name|parse_and_eval_address
argument_list|(
name|addr_string
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|tmp_cleanup
argument_list|)
expr_stmt|;
block|}
comment|/* Skip spaces, move to possible next arg.  */
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
condition|)
name|p
operator|++
expr_stmt|;
name|frame_exp
operator|=
name|p
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|numargs
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
name|selected_frame
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"No selected frame."
argument_list|)
expr_stmt|;
return|return
name|selected_frame
return|;
comment|/* NOTREACHED */
case|case
literal|1
case|:
block|{
name|int
name|level
init|=
name|args
index|[
literal|0
index|]
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|fid
init|=
name|find_relative_frame
argument_list|(
name|get_current_frame
argument_list|()
argument_list|,
operator|&
name|level
argument_list|)
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|tfid
decl_stmt|;
if|if
condition|(
name|level
operator|==
literal|0
condition|)
comment|/* find_relative_frame was successful */
return|return
name|fid
return|;
comment|/* If SETUP_ARBITRARY_FRAME is defined, then frame specifications 	   take at least 2 addresses.  It is important to detect this case 	   here so that "frame 100" does not give a confusing error message 	   like "frame specification requires two addresses".  This of course 	   does not solve the "frame 100" problem for machines on which 	   a frame specification can be made with one address.  To solve 	   that, we need a new syntax for a specifying a frame by address. 	   I think the cleanest syntax is $frame(0x45) ($frame(0x23,0x45) for 	   two args, etc.), but people might think that is too much typing, 	   so I guess *0x23,0x45 would be a possible alternative (commas 	   really should be used instead of spaces to delimit; using spaces 	   normally works in an expression).  */
ifdef|#
directive|ifdef
name|SETUP_ARBITRARY_FRAME
name|error
argument_list|(
literal|"No frame %d"
argument_list|,
name|args
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If (s)he specifies the frame with an address, he deserves what 	   (s)he gets.  Still, give the highest one that matches.  */
for|for
control|(
name|fid
operator|=
name|get_current_frame
argument_list|()
init|;
name|fid
operator|&&
name|fid
operator|->
name|frame
operator|!=
name|args
index|[
literal|0
index|]
condition|;
name|fid
operator|=
name|get_prev_frame
argument_list|(
name|fid
argument_list|)
control|)
empty_stmt|;
if|if
condition|(
name|fid
condition|)
while|while
condition|(
operator|(
name|tfid
operator|=
name|get_prev_frame
argument_list|(
name|fid
argument_list|)
operator|)
operator|&&
operator|(
name|tfid
operator|->
name|frame
operator|==
name|args
index|[
literal|0
index|]
operator|)
condition|)
name|fid
operator|=
name|tfid
expr_stmt|;
comment|/* We couldn't identify the frame as an existing frame, but 	   perhaps we can create one with a single argument.  */
block|}
default|default:
ifdef|#
directive|ifdef
name|SETUP_ARBITRARY_FRAME
return|return
name|SETUP_ARBITRARY_FRAME
argument_list|(
name|numargs
argument_list|,
name|args
argument_list|)
return|;
else|#
directive|else
comment|/* Usual case.  Do it here rather than have everyone supply 	 a SETUP_ARBITRARY_FRAME that does this.  */
if|if
condition|(
name|numargs
operator|==
literal|1
condition|)
return|return
name|create_new_frame
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
return|;
name|error
argument_list|(
literal|"Too many args in frame specification"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NOTREACHED */
block|}
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/* FRAME_ARGS_ADDRESS_CORRECT is just like FRAME_ARGS_ADDRESS except    that if it is unsure about the answer, it returns 0    instead of guessing (this happens on the VAX and i960, for example).     On most machines, we never have to guess about the args address,    so FRAME_ARGS_ADDRESS{,_CORRECT} are the same.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|FRAME_ARGS_ADDRESS_CORRECT
argument_list|)
end_if

begin_define
define|#
directive|define
name|FRAME_ARGS_ADDRESS_CORRECT
value|FRAME_ARGS_ADDRESS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Print verbosely the selected frame or the frame at address ADDR.    This means absolutely all information in the frame is printed.  */
end_comment

begin_function
specifier|static
name|void
name|frame_info
parameter_list|(
name|addr_exp
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|addr_exp
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
name|struct
name|frame_saved_regs
name|fsr
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|struct
name|symbol
modifier|*
name|func
decl_stmt|;
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|calling_frame_info
decl_stmt|;
name|int
name|i
decl_stmt|,
name|count
decl_stmt|,
name|numregs
decl_stmt|;
name|char
modifier|*
name|funname
init|=
literal|0
decl_stmt|;
name|enum
name|language
name|funlang
init|=
name|language_unknown
decl_stmt|;
if|if
condition|(
operator|!
name|target_has_stack
condition|)
name|error
argument_list|(
literal|"No stack."
argument_list|)
expr_stmt|;
name|fi
operator|=
name|parse_frame_specification
argument_list|(
name|addr_exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fi
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Invalid frame specified."
argument_list|)
expr_stmt|;
name|sal
operator|=
name|find_pc_line
argument_list|(
name|fi
operator|->
name|pc
argument_list|,
name|fi
operator|->
name|next
operator|!=
name|NULL
operator|&&
operator|!
name|fi
operator|->
name|next
operator|->
name|signal_handler_caller
operator|&&
operator|!
name|frame_in_dummy
argument_list|(
name|fi
operator|->
name|next
argument_list|)
argument_list|)
expr_stmt|;
name|func
operator|=
name|get_frame_function
argument_list|(
name|fi
argument_list|)
expr_stmt|;
name|s
operator|=
name|find_pc_symtab
argument_list|(
name|fi
operator|->
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|func
condition|)
block|{
name|funname
operator|=
name|SYMBOL_NAME
argument_list|(
name|func
argument_list|)
expr_stmt|;
name|funlang
operator|=
name|SYMBOL_LANGUAGE
argument_list|(
name|func
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|struct
name|minimal_symbol
modifier|*
name|msymbol
init|=
name|lookup_minimal_symbol_by_pc
argument_list|(
name|fi
operator|->
name|pc
argument_list|)
decl_stmt|;
if|if
condition|(
name|msymbol
operator|!=
name|NULL
condition|)
block|{
name|funname
operator|=
name|SYMBOL_NAME
argument_list|(
name|msymbol
argument_list|)
expr_stmt|;
name|funlang
operator|=
name|SYMBOL_LANGUAGE
argument_list|(
name|msymbol
argument_list|)
expr_stmt|;
block|}
block|}
name|calling_frame_info
operator|=
name|get_prev_frame
argument_list|(
name|fi
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|addr_exp
operator|&&
name|selected_frame_level
operator|>=
literal|0
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Stack level %d, frame at "
argument_list|,
name|selected_frame_level
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|fi
operator|->
name|frame
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|":\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf_filtered
argument_list|(
literal|"Stack frame at "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|fi
operator|->
name|frame
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|":\n"
argument_list|)
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|" %s = "
argument_list|,
name|reg_names
index|[
name|PC_REGNUM
index|]
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|fi
operator|->
name|pc
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|"   "
argument_list|)
expr_stmt|;
if|if
condition|(
name|funname
condition|)
block|{
name|printf_filtered
argument_list|(
literal|" in "
argument_list|)
expr_stmt|;
name|fprintf_symbol_filtered
argument_list|(
name|gdb_stdout
argument_list|,
name|funname
argument_list|,
name|funlang
argument_list|,
name|DMGL_ANSI
operator||
name|DMGL_PARAMS
argument_list|)
expr_stmt|;
block|}
name|wrap_here
argument_list|(
literal|"   "
argument_list|)
expr_stmt|;
if|if
condition|(
name|sal
operator|.
name|symtab
condition|)
name|printf_filtered
argument_list|(
literal|" (%s:%d)"
argument_list|,
name|sal
operator|.
name|symtab
operator|->
name|filename
argument_list|,
name|sal
operator|.
name|line
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
literal|"; "
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|"    "
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"saved %s "
argument_list|,
name|reg_names
index|[
name|PC_REGNUM
index|]
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|FRAME_SAVED_PC
argument_list|(
name|fi
argument_list|)
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|{
name|int
name|frameless
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|FRAMELESS_FUNCTION_INVOCATION
name|FRAMELESS_FUNCTION_INVOCATION
argument_list|(
name|fi
argument_list|,
name|frameless
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|frameless
condition|)
name|printf_filtered
argument_list|(
literal|" (FRAMELESS),"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|calling_frame_info
condition|)
block|{
name|printf_filtered
argument_list|(
literal|" called by frame at "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|calling_frame_info
operator|->
name|frame
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fi
operator|->
name|next
operator|&&
name|calling_frame_info
condition|)
name|puts_filtered
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|"   "
argument_list|)
expr_stmt|;
if|if
condition|(
name|fi
operator|->
name|next
condition|)
block|{
name|printf_filtered
argument_list|(
literal|" caller of frame at "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|fi
operator|->
name|next
operator|->
name|frame
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fi
operator|->
name|next
operator|||
name|calling_frame_info
condition|)
name|puts_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
condition|)
name|printf_filtered
argument_list|(
literal|" source language %s.\n"
argument_list|,
name|language_str
argument_list|(
name|s
operator|->
name|language
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PRINT_EXTRA_FRAME_INFO
name|PRINT_EXTRA_FRAME_INFO
argument_list|(
name|fi
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|{
comment|/* Address of the argument list for this frame, or 0.  */
name|CORE_ADDR
name|arg_list
init|=
name|FRAME_ARGS_ADDRESS_CORRECT
argument_list|(
name|fi
argument_list|)
decl_stmt|;
comment|/* Number of args for this frame, or -1 if unknown.  */
name|int
name|numargs
decl_stmt|;
if|if
condition|(
name|arg_list
operator|==
literal|0
condition|)
name|printf_filtered
argument_list|(
literal|" Arglist at unknown address.\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|printf_filtered
argument_list|(
literal|" Arglist at "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|arg_list
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|FRAME_NUM_ARGS
argument_list|(
name|numargs
argument_list|,
name|fi
argument_list|)
expr_stmt|;
if|if
condition|(
name|numargs
operator|<
literal|0
condition|)
name|puts_filtered
argument_list|(
literal|" args: "
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|numargs
operator|==
literal|0
condition|)
name|puts_filtered
argument_list|(
literal|" no args."
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|numargs
operator|==
literal|1
condition|)
name|puts_filtered
argument_list|(
literal|" 1 arg: "
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|" %d args: "
argument_list|,
name|numargs
argument_list|)
expr_stmt|;
name|print_frame_args
argument_list|(
name|func
argument_list|,
name|fi
argument_list|,
name|numargs
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|{
comment|/* Address of the local variables for this frame, or 0.  */
name|CORE_ADDR
name|arg_list
init|=
name|FRAME_LOCALS_ADDRESS
argument_list|(
name|fi
argument_list|)
decl_stmt|;
if|if
condition|(
name|arg_list
operator|==
literal|0
condition|)
name|printf_filtered
argument_list|(
literal|" Locals at unknown address,"
argument_list|)
expr_stmt|;
else|else
block|{
name|printf_filtered
argument_list|(
literal|" Locals at "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|arg_list
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
block|}
if|#
directive|if
name|defined
argument_list|(
name|FRAME_FIND_SAVED_REGS
argument_list|)
name|get_frame_saved_regs
argument_list|(
name|fi
argument_list|,
operator|&
name|fsr
argument_list|)
expr_stmt|;
comment|/* The sp is special; what's returned isn't the save address, but      actually the value of the previous frame's sp.  */
name|printf_filtered
argument_list|(
literal|" Previous frame's sp is "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|fsr
operator|.
name|regs
index|[
name|SP_REGNUM
index|]
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|numregs
operator|=
name|ARCH_NUM_REGS
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numregs
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|fsr
operator|.
name|regs
index|[
name|i
index|]
operator|&&
name|i
operator|!=
name|SP_REGNUM
condition|)
block|{
if|if
condition|(
name|count
operator|==
literal|0
condition|)
name|puts_filtered
argument_list|(
literal|" Saved registers:\n "
argument_list|)
expr_stmt|;
else|else
name|puts_filtered
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" %s at "
argument_list|,
name|reg_names
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|fsr
operator|.
name|regs
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|count
condition|)
name|puts_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Have FRAME_FIND_SAVED_REGS.  */
comment|/* We could get some information about saved registers by calling      get_saved_register on each register.  Which info goes with which frame      is necessarily lost, however, and I suspect that the users don't care      whether they get the info.  */
name|puts_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Have FRAME_FIND_SAVED_REGS.  */
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Set a limit on the number of frames printed by default in a    backtrace.  */
end_comment

begin_endif
unit|static int backtrace_limit;  static void set_backtrace_limit_command (count_exp, from_tty)      char *count_exp;      int from_tty; {   int count = parse_and_eval_address (count_exp);    if (count< 0)     error ("Negative argument not meaningful as backtrace limit.");    backtrace_limit = count; }  static void backtrace_limit_info (arg, from_tty)      char *arg;      int from_tty; {   if (arg)     error ("\"Info backtrace-limit\" takes no arguments.");    printf_unfiltered ("Backtrace limit: %d.\n", backtrace_limit); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* Print briefly all stack frames or just the innermost COUNT frames.  */
end_comment

begin_function
specifier|static
name|void
name|backtrace_command
parameter_list|(
name|count_exp
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|count_exp
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
specifier|register
name|int
name|count
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|frame_info
modifier|*
name|trailing
decl_stmt|;
specifier|register
name|int
name|trailing_level
decl_stmt|;
if|if
condition|(
operator|!
name|target_has_stack
condition|)
name|error
argument_list|(
literal|"No stack."
argument_list|)
expr_stmt|;
comment|/* The following code must do two things.  First, it must      set the variable TRAILING to the frame from which we should start      printing.  Second, it must set the variable count to the number      of frames which we should print, or -1 if all of them.  */
name|trailing
operator|=
name|get_current_frame
argument_list|()
expr_stmt|;
name|trailing_level
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|count_exp
condition|)
block|{
name|count
operator|=
name|parse_and_eval_address
argument_list|(
name|count_exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
name|struct
name|frame_info
modifier|*
name|current
decl_stmt|;
name|count
operator|=
operator|-
name|count
expr_stmt|;
name|current
operator|=
name|trailing
expr_stmt|;
while|while
condition|(
name|current
operator|&&
name|count
operator|--
condition|)
block|{
name|QUIT
expr_stmt|;
name|current
operator|=
name|get_prev_frame
argument_list|(
name|current
argument_list|)
expr_stmt|;
block|}
comment|/* Will stop when CURRENT reaches the top of the stack.  TRAILING 	     will be COUNT below it.  */
while|while
condition|(
name|current
condition|)
block|{
name|QUIT
expr_stmt|;
name|trailing
operator|=
name|get_prev_frame
argument_list|(
name|trailing
argument_list|)
expr_stmt|;
name|current
operator|=
name|get_prev_frame
argument_list|(
name|current
argument_list|)
expr_stmt|;
name|trailing_level
operator|++
expr_stmt|;
block|}
name|count
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
else|else
name|count
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|info_verbose
condition|)
block|{
name|struct
name|partial_symtab
modifier|*
name|ps
decl_stmt|;
comment|/* Read in symbols for all of the frames.  Need to do this in 	 a separate pass so that "Reading in symbols for xxx" messages 	 don't screw up the appearance of the backtrace.  Also 	 if people have strong opinions against reading symbols for 	 backtrace this may have to be an option.  */
name|i
operator|=
name|count
expr_stmt|;
for|for
control|(
name|fi
operator|=
name|trailing
init|;
name|fi
operator|!=
name|NULL
operator|&&
name|i
operator|--
condition|;
name|fi
operator|=
name|get_prev_frame
argument_list|(
name|fi
argument_list|)
control|)
block|{
name|QUIT
expr_stmt|;
name|ps
operator|=
name|find_pc_psymtab
argument_list|(
name|fi
operator|->
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ps
condition|)
name|PSYMTAB_TO_SYMTAB
argument_list|(
name|ps
argument_list|)
expr_stmt|;
comment|/* Force syms to come in */
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|fi
operator|=
name|trailing
init|;
name|fi
operator|&&
name|count
operator|--
condition|;
name|i
operator|++
operator|,
name|fi
operator|=
name|get_prev_frame
argument_list|(
name|fi
argument_list|)
control|)
block|{
name|QUIT
expr_stmt|;
comment|/* Don't use print_stack_frame; if an error() occurs it probably 	 means further attempts to backtrace would fail (on the other 	 hand, perhaps the code does or could be fixed to make sure 	 the frame->prev field gets set to NULL in that case).  */
name|print_frame_info
argument_list|(
name|fi
argument_list|,
name|trailing_level
operator|+
name|i
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* If we've stopped before the end, mention that.  */
if|if
condition|(
name|fi
operator|&&
name|from_tty
condition|)
name|printf_filtered
argument_list|(
literal|"(More stack frames follow...)\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print the local variables of a block B active in FRAME.    Return 1 if any variables were printed; 0 otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|print_block_frame_locals
parameter_list|(
name|b
parameter_list|,
name|fi
parameter_list|,
name|stream
parameter_list|)
name|struct
name|block
modifier|*
name|b
decl_stmt|;
specifier|register
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
specifier|register
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|int
name|nsyms
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
specifier|register
name|int
name|values_printed
init|=
literal|0
decl_stmt|;
name|nsyms
operator|=
name|BLOCK_NSYMS
argument_list|(
name|b
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsyms
condition|;
name|i
operator|++
control|)
block|{
name|sym
operator|=
name|BLOCK_SYM
argument_list|(
name|b
argument_list|,
name|i
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
condition|)
block|{
case|case
name|LOC_LOCAL
case|:
case|case
name|LOC_REGISTER
case|:
case|case
name|LOC_STATIC
case|:
case|case
name|LOC_BASEREG
case|:
name|values_printed
operator|=
literal|1
expr_stmt|;
name|fputs_filtered
argument_list|(
name|SYMBOL_SOURCE_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|" = "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|print_variable_value
argument_list|(
name|sym
argument_list|,
name|fi
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Ignore symbols which are not locals.  */
break|break;
block|}
block|}
return|return
name|values_printed
return|;
block|}
end_function

begin_comment
comment|/* Same, but print labels.  */
end_comment

begin_function
specifier|static
name|int
name|print_block_frame_labels
parameter_list|(
name|b
parameter_list|,
name|have_default
parameter_list|,
name|stream
parameter_list|)
name|struct
name|block
modifier|*
name|b
decl_stmt|;
name|int
modifier|*
name|have_default
decl_stmt|;
specifier|register
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|int
name|nsyms
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
specifier|register
name|int
name|values_printed
init|=
literal|0
decl_stmt|;
name|nsyms
operator|=
name|BLOCK_NSYMS
argument_list|(
name|b
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsyms
condition|;
name|i
operator|++
control|)
block|{
name|sym
operator|=
name|BLOCK_SYM
argument_list|(
name|b
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|STREQ
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
literal|"default"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|have_default
condition|)
continue|continue;
operator|*
name|have_default
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_LABEL
condition|)
block|{
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|sal
operator|=
name|find_pc_line
argument_list|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|values_printed
operator|=
literal|1
expr_stmt|;
name|fputs_filtered
argument_list|(
name|SYMBOL_SOURCE_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|addressprint
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym
argument_list|)
argument_list|,
literal|1
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" in file %s, line %d\n"
argument_list|,
name|sal
operator|.
name|symtab
operator|->
name|filename
argument_list|,
name|sal
operator|.
name|line
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|values_printed
return|;
block|}
end_function

begin_comment
comment|/* Print on STREAM all the local variables in frame FRAME,    including all the blocks active in that frame    at its current pc.     Returns 1 if the job was done,    or 0 if nothing was printed because we have no info    on the function running in FRAME.  */
end_comment

begin_function
specifier|static
name|void
name|print_frame_local_vars
parameter_list|(
name|fi
parameter_list|,
name|stream
parameter_list|)
specifier|register
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
specifier|register
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
block|{
specifier|register
name|struct
name|block
modifier|*
name|block
init|=
name|get_frame_block
argument_list|(
name|fi
argument_list|)
decl_stmt|;
specifier|register
name|int
name|values_printed
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|block
operator|==
literal|0
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"No symbol table info available.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|block
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|print_block_frame_locals
argument_list|(
name|block
argument_list|,
name|fi
argument_list|,
name|stream
argument_list|)
condition|)
name|values_printed
operator|=
literal|1
expr_stmt|;
comment|/* After handling the function's top-level block, stop. 	 Don't continue to its superblock, the block of 	 per-file symbols.  */
if|if
condition|(
name|BLOCK_FUNCTION
argument_list|(
name|block
argument_list|)
condition|)
break|break;
name|block
operator|=
name|BLOCK_SUPERBLOCK
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|values_printed
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"No locals.\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Same, but print labels.  */
end_comment

begin_function
specifier|static
name|void
name|print_frame_label_vars
parameter_list|(
name|fi
parameter_list|,
name|this_level_only
parameter_list|,
name|stream
parameter_list|)
specifier|register
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
name|int
name|this_level_only
decl_stmt|;
specifier|register
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
block|{
specifier|register
name|struct
name|blockvector
modifier|*
name|bl
decl_stmt|;
specifier|register
name|struct
name|block
modifier|*
name|block
init|=
name|get_frame_block
argument_list|(
name|fi
argument_list|)
decl_stmt|;
specifier|register
name|int
name|values_printed
init|=
literal|0
decl_stmt|;
name|int
name|index
decl_stmt|,
name|have_default
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|blocks_printed
decl_stmt|;
name|CORE_ADDR
name|pc
init|=
name|fi
operator|->
name|pc
decl_stmt|;
if|if
condition|(
name|block
operator|==
literal|0
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"No symbol table info available.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|bl
operator|=
name|blockvector_for_pc
argument_list|(
name|BLOCK_END
argument_list|(
name|block
argument_list|)
operator|-
literal|4
argument_list|,
operator|&
name|index
argument_list|)
expr_stmt|;
name|blocks_printed
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|BLOCKVECTOR_NBLOCKS
argument_list|(
name|bl
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|blocks_printed
argument_list|,
literal|0
argument_list|,
name|BLOCKVECTOR_NBLOCKS
argument_list|(
name|bl
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|block
operator|!=
literal|0
condition|)
block|{
name|CORE_ADDR
name|end
init|=
name|BLOCK_END
argument_list|(
name|block
argument_list|)
operator|-
literal|4
decl_stmt|;
name|int
name|last_index
decl_stmt|;
if|if
condition|(
name|bl
operator|!=
name|blockvector_for_pc
argument_list|(
name|end
argument_list|,
operator|&
name|index
argument_list|)
condition|)
name|error
argument_list|(
literal|"blockvector blotch"
argument_list|)
expr_stmt|;
if|if
condition|(
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bl
argument_list|,
name|index
argument_list|)
operator|!=
name|block
condition|)
name|error
argument_list|(
literal|"blockvector botch"
argument_list|)
expr_stmt|;
name|last_index
operator|=
name|BLOCKVECTOR_NBLOCKS
argument_list|(
name|bl
argument_list|)
expr_stmt|;
name|index
operator|+=
literal|1
expr_stmt|;
comment|/* Don't print out blocks that have gone by.  */
while|while
condition|(
name|index
operator|<
name|last_index
operator|&&
name|BLOCK_END
argument_list|(
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bl
argument_list|,
name|index
argument_list|)
argument_list|)
operator|<
name|pc
condition|)
name|index
operator|++
expr_stmt|;
while|while
condition|(
name|index
operator|<
name|last_index
operator|&&
name|BLOCK_END
argument_list|(
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bl
argument_list|,
name|index
argument_list|)
argument_list|)
operator|<
name|end
condition|)
block|{
if|if
condition|(
name|blocks_printed
index|[
name|index
index|]
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|print_block_frame_labels
argument_list|(
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bl
argument_list|,
name|index
argument_list|)
argument_list|,
operator|&
name|have_default
argument_list|,
name|stream
argument_list|)
condition|)
name|values_printed
operator|=
literal|1
expr_stmt|;
name|blocks_printed
index|[
name|index
index|]
operator|=
literal|1
expr_stmt|;
block|}
name|index
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|have_default
condition|)
return|return;
if|if
condition|(
name|values_printed
operator|&&
name|this_level_only
condition|)
return|return;
comment|/* After handling the function's top-level block, stop. 	 Don't continue to its superblock, the block of 	 per-file symbols.  */
if|if
condition|(
name|BLOCK_FUNCTION
argument_list|(
name|block
argument_list|)
condition|)
break|break;
name|block
operator|=
name|BLOCK_SUPERBLOCK
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|values_printed
operator|&&
operator|!
name|this_level_only
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"No catches.\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|locals_info
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|selected_frame
condition|)
name|error
argument_list|(
literal|"No frame selected."
argument_list|)
expr_stmt|;
name|print_frame_local_vars
argument_list|(
name|selected_frame
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|catch_info
parameter_list|(
name|ignore
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|ignore
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|selected_frame
condition|)
name|error
argument_list|(
literal|"No frame selected."
argument_list|)
expr_stmt|;
name|print_frame_label_vars
argument_list|(
name|selected_frame
argument_list|,
literal|0
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_frame_arg_vars
parameter_list|(
name|fi
parameter_list|,
name|stream
parameter_list|)
specifier|register
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
specifier|register
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|struct
name|symbol
modifier|*
name|func
init|=
name|get_frame_function
argument_list|(
name|fi
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|block
modifier|*
name|b
decl_stmt|;
name|int
name|nsyms
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|,
modifier|*
name|sym2
decl_stmt|;
specifier|register
name|int
name|values_printed
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|func
operator|==
literal|0
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"No symbol table info available.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|b
operator|=
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|func
argument_list|)
expr_stmt|;
name|nsyms
operator|=
name|BLOCK_NSYMS
argument_list|(
name|b
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsyms
condition|;
name|i
operator|++
control|)
block|{
name|sym
operator|=
name|BLOCK_SYM
argument_list|(
name|b
argument_list|,
name|i
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
condition|)
block|{
case|case
name|LOC_ARG
case|:
case|case
name|LOC_LOCAL_ARG
case|:
case|case
name|LOC_REF_ARG
case|:
case|case
name|LOC_REGPARM
case|:
case|case
name|LOC_REGPARM_ADDR
case|:
case|case
name|LOC_BASEREG_ARG
case|:
name|values_printed
operator|=
literal|1
expr_stmt|;
name|fputs_filtered
argument_list|(
name|SYMBOL_SOURCE_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|" = "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
comment|/* We have to look up the symbol because arguments can have 	     two entries (one a parameter, one a local) and the one we 	     want is the local, which lookup_symbol will find for us. 	     This includes gcc1 (not gcc2) on the sparc when passing a 	     small structure and gcc2 when the argument type is float 	     and it is passed as a double and converted to float by 	     the prologue (in the latter case the type of the LOC_ARG 	     symbol is double and the type of the LOC_LOCAL symbol is 	     float).  There are also LOC_ARG/LOC_REGISTER pairs which 	     are not combined in symbol-reading.  */
name|sym2
operator|=
name|lookup_symbol
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|b
argument_list|,
name|VAR_NAMESPACE
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
operator|(
expr|struct
name|symtab
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|print_variable_value
argument_list|(
name|sym2
argument_list|,
name|fi
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Don't worry about things which aren't arguments.  */
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|values_printed
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"No arguments.\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|args_info
parameter_list|(
name|ignore
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|ignore
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|selected_frame
condition|)
name|error
argument_list|(
literal|"No frame selected."
argument_list|)
expr_stmt|;
name|print_frame_arg_vars
argument_list|(
name|selected_frame
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Select frame FI, and note that its stack level is LEVEL.    LEVEL may be -1 if an actual level number is not known.  */
end_comment

begin_function
name|void
name|select_frame
parameter_list|(
name|fi
parameter_list|,
name|level
parameter_list|)
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
name|int
name|level
decl_stmt|;
block|{
specifier|register
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
name|selected_frame
operator|=
name|fi
expr_stmt|;
name|selected_frame_level
operator|=
name|level
expr_stmt|;
comment|/* Ensure that symbols for this frame are read in.  Also, determine the      source language of this frame, and switch to it if desired.  */
if|if
condition|(
name|fi
condition|)
block|{
name|s
operator|=
name|find_pc_symtab
argument_list|(
name|fi
operator|->
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|&&
name|s
operator|->
name|language
operator|!=
name|current_language
operator|->
name|la_language
operator|&&
name|s
operator|->
name|language
operator|!=
name|language_unknown
operator|&&
name|language_mode
operator|==
name|language_mode_auto
condition|)
block|{
name|set_language
argument_list|(
name|s
operator|->
name|language
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Store the selected frame and its level into *FRAMEP and *LEVELP.    If there is no selected frame, *FRAMEP is set to NULL.  */
end_comment

begin_function
name|void
name|record_selected_frame
parameter_list|(
name|frameaddrp
parameter_list|,
name|levelp
parameter_list|)
name|CORE_ADDR
modifier|*
name|frameaddrp
decl_stmt|;
name|int
modifier|*
name|levelp
decl_stmt|;
block|{
operator|*
name|frameaddrp
operator|=
name|selected_frame
condition|?
name|selected_frame
operator|->
name|frame
else|:
literal|0
expr_stmt|;
operator|*
name|levelp
operator|=
name|selected_frame_level
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the symbol-block in which the selected frame is executing.    Can return zero under various legitimate circumstances.  */
end_comment

begin_function
name|struct
name|block
modifier|*
name|get_selected_block
parameter_list|()
block|{
if|if
condition|(
operator|!
name|target_has_stack
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|selected_frame
condition|)
return|return
name|get_current_block
argument_list|()
return|;
return|return
name|get_frame_block
argument_list|(
name|selected_frame
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Find a frame a certain number of levels away from FRAME.    LEVEL_OFFSET_PTR points to an int containing the number of levels.    Positive means go to earlier frames (up); negative, the reverse.    The int that contains the number of levels is counted toward    zero as the frames for those levels are found.    If the top or bottom frame is reached, that frame is returned,    but the final value of *LEVEL_OFFSET_PTR is nonzero and indicates    how much farther the original request asked to go.  */
end_comment

begin_function
name|struct
name|frame_info
modifier|*
name|find_relative_frame
parameter_list|(
name|frame
parameter_list|,
name|level_offset_ptr
parameter_list|)
specifier|register
name|struct
name|frame_info
modifier|*
name|frame
decl_stmt|;
specifier|register
name|int
modifier|*
name|level_offset_ptr
decl_stmt|;
block|{
specifier|register
name|struct
name|frame_info
modifier|*
name|prev
decl_stmt|;
specifier|register
name|struct
name|frame_info
modifier|*
name|frame1
decl_stmt|;
comment|/* Going up is simple: just do get_prev_frame enough times      or until initial frame is reached.  */
while|while
condition|(
operator|*
name|level_offset_ptr
operator|>
literal|0
condition|)
block|{
name|prev
operator|=
name|get_prev_frame
argument_list|(
name|frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
operator|==
literal|0
condition|)
break|break;
operator|(
operator|*
name|level_offset_ptr
operator|)
operator|--
expr_stmt|;
name|frame
operator|=
name|prev
expr_stmt|;
block|}
comment|/* Going down is just as simple.  */
if|if
condition|(
operator|*
name|level_offset_ptr
operator|<
literal|0
condition|)
block|{
while|while
condition|(
operator|*
name|level_offset_ptr
operator|<
literal|0
condition|)
block|{
name|frame1
operator|=
name|get_next_frame
argument_list|(
name|frame
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|frame1
condition|)
break|break;
name|frame
operator|=
name|frame1
expr_stmt|;
operator|(
operator|*
name|level_offset_ptr
operator|)
operator|++
expr_stmt|;
block|}
block|}
return|return
name|frame
return|;
block|}
end_function

begin_comment
comment|/* The "select_frame" command.  With no arg, NOP.    With arg LEVEL_EXP, select the frame at level LEVEL if it is a    valid level.  Otherwise, treat level_exp as an address expression    and select it.  See parse_frame_specification for more info on proper    frame expressions. */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|select_frame_command
parameter_list|(
name|level_exp
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|level_exp
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
specifier|register
name|struct
name|frame_info
modifier|*
name|frame
decl_stmt|,
modifier|*
name|frame1
decl_stmt|;
name|unsigned
name|int
name|level
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|target_has_stack
condition|)
name|error
argument_list|(
literal|"No stack."
argument_list|)
expr_stmt|;
name|frame
operator|=
name|parse_frame_specification
argument_list|(
name|level_exp
argument_list|)
expr_stmt|;
comment|/* Try to figure out what level this frame is.  But if there is      no current stack, don't error out -- let the user set one.  */
name|frame1
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|get_current_frame
argument_list|()
condition|)
block|{
for|for
control|(
name|frame1
operator|=
name|get_prev_frame
argument_list|(
literal|0
argument_list|)
init|;
name|frame1
operator|&&
name|frame1
operator|!=
name|frame
condition|;
name|frame1
operator|=
name|get_prev_frame
argument_list|(
name|frame1
argument_list|)
control|)
name|level
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|frame1
condition|)
name|level
operator|=
literal|0
expr_stmt|;
name|select_frame
argument_list|(
name|frame
argument_list|,
name|level
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The "frame" command.  With no arg, print selected frame briefly.    With arg, behaves like select_frame and then prints the selected    frame.  */
end_comment

begin_function
specifier|static
name|void
name|frame_command
parameter_list|(
name|level_exp
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|level_exp
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|select_frame_command
argument_list|(
name|level_exp
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
name|print_stack_frame
argument_list|(
name|selected_frame
argument_list|,
name|selected_frame_level
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Select the frame up one or COUNT stack levels    from the previously selected frame, and print it briefly.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|up_silently_command
parameter_list|(
name|count_exp
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|count_exp
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
specifier|register
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
name|int
name|count
init|=
literal|1
decl_stmt|,
name|count1
decl_stmt|;
if|if
condition|(
name|count_exp
condition|)
name|count
operator|=
name|parse_and_eval_address
argument_list|(
name|count_exp
argument_list|)
expr_stmt|;
name|count1
operator|=
name|count
expr_stmt|;
if|if
condition|(
name|target_has_stack
operator|==
literal|0
operator|||
name|selected_frame
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No stack."
argument_list|)
expr_stmt|;
name|fi
operator|=
name|find_relative_frame
argument_list|(
name|selected_frame
argument_list|,
operator|&
name|count1
argument_list|)
expr_stmt|;
if|if
condition|(
name|count1
operator|!=
literal|0
operator|&&
name|count_exp
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Initial frame selected; you cannot go up."
argument_list|)
expr_stmt|;
name|select_frame
argument_list|(
name|fi
argument_list|,
name|selected_frame_level
operator|+
name|count
operator|-
name|count1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|up_command
parameter_list|(
name|count_exp
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|count_exp
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|up_silently_command
argument_list|(
name|count_exp
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
name|print_stack_frame
argument_list|(
name|selected_frame
argument_list|,
name|selected_frame_level
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Select the frame down one or COUNT stack levels    from the previously selected frame, and print it briefly.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|down_silently_command
parameter_list|(
name|count_exp
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|count_exp
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
specifier|register
name|struct
name|frame_info
modifier|*
name|frame
decl_stmt|;
name|int
name|count
init|=
operator|-
literal|1
decl_stmt|,
name|count1
decl_stmt|;
if|if
condition|(
name|count_exp
condition|)
name|count
operator|=
operator|-
name|parse_and_eval_address
argument_list|(
name|count_exp
argument_list|)
expr_stmt|;
name|count1
operator|=
name|count
expr_stmt|;
if|if
condition|(
name|target_has_stack
operator|==
literal|0
operator|||
name|selected_frame
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No stack."
argument_list|)
expr_stmt|;
name|frame
operator|=
name|find_relative_frame
argument_list|(
name|selected_frame
argument_list|,
operator|&
name|count1
argument_list|)
expr_stmt|;
if|if
condition|(
name|count1
operator|!=
literal|0
operator|&&
name|count_exp
operator|==
literal|0
condition|)
block|{
comment|/* We only do this if count_exp is not specified.  That way "down" 	 means to really go down (and let me know if that is 	 impossible), but "down 9999" can be used to mean go all the way 	 down without getting an error.  */
name|error
argument_list|(
literal|"Bottom (i.e., innermost) frame selected; you cannot go down."
argument_list|)
expr_stmt|;
block|}
name|select_frame
argument_list|(
name|frame
argument_list|,
name|selected_frame_level
operator|+
name|count
operator|-
name|count1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|down_command
parameter_list|(
name|count_exp
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|count_exp
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|down_silently_command
argument_list|(
name|count_exp
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
name|print_stack_frame
argument_list|(
name|selected_frame
argument_list|,
name|selected_frame_level
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|return_command
parameter_list|(
name|retval_exp
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|retval_exp
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|struct
name|symbol
modifier|*
name|thisfun
decl_stmt|;
name|CORE_ADDR
name|selected_frame_addr
decl_stmt|;
name|CORE_ADDR
name|selected_frame_pc
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|frame
decl_stmt|;
name|value_ptr
name|return_value
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|selected_frame
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"No selected frame."
argument_list|)
expr_stmt|;
name|thisfun
operator|=
name|get_frame_function
argument_list|(
name|selected_frame
argument_list|)
expr_stmt|;
name|selected_frame_addr
operator|=
name|FRAME_FP
argument_list|(
name|selected_frame
argument_list|)
expr_stmt|;
name|selected_frame_pc
operator|=
name|selected_frame
operator|->
name|pc
expr_stmt|;
comment|/* Compute the return value (if any -- possibly getting errors here).  */
if|if
condition|(
name|retval_exp
condition|)
block|{
name|struct
name|type
modifier|*
name|return_type
init|=
name|NULL
decl_stmt|;
name|return_value
operator|=
name|parse_and_eval
argument_list|(
name|retval_exp
argument_list|)
expr_stmt|;
comment|/* Cast return value to the return type of the function.  */
if|if
condition|(
name|thisfun
operator|!=
name|NULL
condition|)
name|return_type
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|thisfun
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|return_type
operator|==
name|NULL
condition|)
name|return_type
operator|=
name|builtin_type_int
expr_stmt|;
name|return_value
operator|=
name|value_cast
argument_list|(
name|return_type
argument_list|,
name|return_value
argument_list|)
expr_stmt|;
comment|/* Make sure we have fully evaluated it, since 	 it might live in the stack frame we're about to pop.  */
if|if
condition|(
name|VALUE_LAZY
argument_list|(
name|return_value
argument_list|)
condition|)
name|value_fetch_lazy
argument_list|(
name|return_value
argument_list|)
expr_stmt|;
block|}
comment|/* If interactive, require confirmation.  */
if|if
condition|(
name|from_tty
condition|)
block|{
if|if
condition|(
name|thisfun
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|query
argument_list|(
literal|"Make %s return now? "
argument_list|,
name|SYMBOL_SOURCE_NAME
argument_list|(
name|thisfun
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"Not confirmed."
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|query
argument_list|(
literal|"Make selected stack frame return now? "
argument_list|)
condition|)
name|error
argument_list|(
literal|"Not confirmed."
argument_list|)
expr_stmt|;
block|}
comment|/* Do the real work.  Pop until the specified frame is current.  We      use this method because the selected_frame is not valid after      a POP_FRAME.  The pc comparison makes this work even if the      selected frame shares its fp with another frame.  */
while|while
condition|(
name|selected_frame_addr
operator|!=
operator|(
name|frame
operator|=
name|get_current_frame
argument_list|()
operator|)
operator|->
name|frame
operator|||
name|selected_frame_pc
operator|!=
name|frame
operator|->
name|pc
condition|)
name|POP_FRAME
expr_stmt|;
comment|/* Then pop that frame.  */
name|POP_FRAME
expr_stmt|;
comment|/* Compute the return value (if any) and store in the place      for return values.  */
if|if
condition|(
name|retval_exp
condition|)
name|set_return_value
argument_list|(
name|return_value
argument_list|)
expr_stmt|;
comment|/* If interactive, print the frame that is now current.  */
if|if
condition|(
name|from_tty
condition|)
name|frame_command
argument_list|(
literal|"0"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|select_frame_command
argument_list|(
literal|"0"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Gets the language of the current frame.  */
end_comment

begin_function
name|enum
name|language
name|get_frame_language
parameter_list|()
block|{
specifier|register
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
name|enum
name|language
name|flang
decl_stmt|;
comment|/* The language of the current frame */
if|if
condition|(
name|selected_frame
condition|)
block|{
name|s
operator|=
name|find_pc_symtab
argument_list|(
name|selected_frame
operator|->
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
condition|)
name|flang
operator|=
name|s
operator|->
name|language
expr_stmt|;
else|else
name|flang
operator|=
name|language_unknown
expr_stmt|;
block|}
else|else
name|flang
operator|=
name|language_unknown
expr_stmt|;
return|return
name|flang
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|_initialize_stack
parameter_list|()
block|{
if|#
directive|if
literal|0
block|backtrace_limit = 30;
endif|#
directive|endif
name|add_com
argument_list|(
literal|"return"
argument_list|,
name|class_stack
argument_list|,
name|return_command
argument_list|,
literal|"Make selected stack frame return to its caller.\n\ Control remains in the debugger, but when you continue\n\ execution will resume in the frame above the one now selected.\n\ If an argument is given, it is an expression for the value to return."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"up"
argument_list|,
name|class_stack
argument_list|,
name|up_command
argument_list|,
literal|"Select and print stack frame that called this one.\n\ An argument says how many frames up to go."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"up-silently"
argument_list|,
name|class_support
argument_list|,
name|up_silently_command
argument_list|,
literal|"Same as the `up' command, but does not print anything.\n\ This is useful in command scripts."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"down"
argument_list|,
name|class_stack
argument_list|,
name|down_command
argument_list|,
literal|"Select and print stack frame called by this one.\n\ An argument says how many frames down to go."
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"do"
argument_list|,
literal|"down"
argument_list|,
name|class_stack
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"dow"
argument_list|,
literal|"down"
argument_list|,
name|class_stack
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"down-silently"
argument_list|,
name|class_support
argument_list|,
name|down_silently_command
argument_list|,
literal|"Same as the `down' command, but does not print anything.\n\ This is useful in command scripts."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"frame"
argument_list|,
name|class_stack
argument_list|,
name|frame_command
argument_list|,
literal|"Select and print a stack frame.\n\ With no argument, print the selected stack frame.  (See also \"info frame\").\n\ An argument specifies the frame to select.\n\ It can be a stack frame number or the address of the frame.\n\ With argument, nothing is printed if input is coming from\n\ a command file or a user-defined command."
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"f"
argument_list|,
literal|"frame"
argument_list|,
name|class_stack
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"select-frame"
argument_list|,
name|class_stack
argument_list|,
name|select_frame_command
argument_list|,
literal|"Select a stack frame without printing anything.\n\ An argument specifies the frame to select.\n\ It can be a stack frame number or the address of the frame.\n"
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"backtrace"
argument_list|,
name|class_stack
argument_list|,
name|backtrace_command
argument_list|,
literal|"Print backtrace of all stack frames, or innermost COUNT frames.\n\ With a negative argument, print outermost -COUNT frames."
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"bt"
argument_list|,
literal|"backtrace"
argument_list|,
name|class_stack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"where"
argument_list|,
literal|"backtrace"
argument_list|,
name|class_alias
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"stack"
argument_list|,
name|backtrace_command
argument_list|,
literal|"Backtrace of the stack, or innermost COUNT frames."
argument_list|)
expr_stmt|;
name|add_info_alias
argument_list|(
literal|"s"
argument_list|,
literal|"stack"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"frame"
argument_list|,
name|frame_info
argument_list|,
literal|"All about selected stack frame, or frame at ADDR."
argument_list|)
expr_stmt|;
name|add_info_alias
argument_list|(
literal|"f"
argument_list|,
literal|"frame"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"locals"
argument_list|,
name|locals_info
argument_list|,
literal|"Local variables of current stack frame."
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"args"
argument_list|,
name|args_info
argument_list|,
literal|"Argument variables of current stack frame."
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"catch"
argument_list|,
name|catch_info
argument_list|,
literal|"Exceptions that can be caught in the current stack frame."
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|add_cmd ("backtrace-limit", class_stack, set_backtrace_limit_command,  	   "Specify maximum number of frames for \"backtrace\" to print by default.",&setlist);   add_info ("backtrace-limit", backtrace_limit_info, 	    "The maximum number of frames for \"backtrace\" to print by default.");
endif|#
directive|endif
block|}
end_function

end_unit

