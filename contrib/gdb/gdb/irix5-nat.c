begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Native support for the SGI Iris running IRIX version 5, for GDB.    Copyright 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996    Free Software Foundation, Inc.    Contributed by Alessandro Forin(af@cs.cmu.edu) at CMU    and by Per Bothner(bothner@cs.wisc.edu) at U.Wisconsin.    Implemented for Irix 4.x by Garrett A. Wollman.    Modified for Irix 5.x by Ian Lance Taylor.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/procfs.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_comment
comment|/* For JB_XXX.  */
end_comment

begin_comment
comment|/* Size of elements in jmpbuf */
end_comment

begin_define
define|#
directive|define
name|JB_ELEMENT_SIZE
value|4
end_define

begin_comment
comment|/*  * See the comment in m68k-tdep.c regarding the utility of these functions.  *  * These definitions are from the MIPS SVR4 ABI, so they may work for  * any MIPS SVR4 target.  */
end_comment

begin_function
name|void
name|supply_gregset
parameter_list|(
name|gregsetp
parameter_list|)
name|gregset_t
modifier|*
name|gregsetp
decl_stmt|;
block|{
specifier|register
name|int
name|regi
decl_stmt|;
specifier|register
name|greg_t
modifier|*
name|regp
init|=
operator|&
operator|(
operator|*
name|gregsetp
operator|)
index|[
literal|0
index|]
decl_stmt|;
specifier|static
name|char
name|zerobuf
index|[
name|MAX_REGISTER_RAW_SIZE
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
for|for
control|(
name|regi
operator|=
literal|0
init|;
name|regi
operator|<=
name|CTX_RA
condition|;
name|regi
operator|++
control|)
name|supply_register
argument_list|(
name|regi
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
name|regi
operator|)
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|PC_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
name|CTX_EPC
operator|)
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|HI_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
name|CTX_MDHI
operator|)
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|LO_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
name|CTX_MDLO
operator|)
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|CAUSE_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
name|CTX_CAUSE
operator|)
argument_list|)
expr_stmt|;
comment|/* Fill inaccessible registers with zero.  */
name|supply_register
argument_list|(
name|BADVADDR_REGNUM
argument_list|,
name|zerobuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fill_gregset
parameter_list|(
name|gregsetp
parameter_list|,
name|regno
parameter_list|)
name|gregset_t
modifier|*
name|gregsetp
decl_stmt|;
name|int
name|regno
decl_stmt|;
block|{
name|int
name|regi
decl_stmt|;
specifier|register
name|greg_t
modifier|*
name|regp
init|=
operator|&
operator|(
operator|*
name|gregsetp
operator|)
index|[
literal|0
index|]
decl_stmt|;
for|for
control|(
name|regi
operator|=
literal|0
init|;
name|regi
operator|<=
name|CTX_RA
condition|;
name|regi
operator|++
control|)
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|regno
operator|==
name|regi
operator|)
condition|)
operator|*
operator|(
name|regp
operator|+
name|regi
operator|)
operator|=
operator|*
operator|(
name|greg_t
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|regi
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|regno
operator|==
name|PC_REGNUM
operator|)
condition|)
operator|*
operator|(
name|regp
operator|+
name|CTX_EPC
operator|)
operator|=
operator|*
operator|(
name|greg_t
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|PC_REGNUM
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|regno
operator|==
name|CAUSE_REGNUM
operator|)
condition|)
operator|*
operator|(
name|regp
operator|+
name|CTX_CAUSE
operator|)
operator|=
operator|*
operator|(
name|greg_t
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|CAUSE_REGNUM
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|regno
operator|==
name|HI_REGNUM
operator|)
condition|)
operator|*
operator|(
name|regp
operator|+
name|CTX_MDHI
operator|)
operator|=
operator|*
operator|(
name|greg_t
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|HI_REGNUM
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|regno
operator|==
name|LO_REGNUM
operator|)
condition|)
operator|*
operator|(
name|regp
operator|+
name|CTX_MDLO
operator|)
operator|=
operator|*
operator|(
name|greg_t
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|LO_REGNUM
argument_list|)
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Now we do the same thing for floating-point registers.  * We don't bother to condition on FP0_REGNUM since any  * reasonable MIPS configuration has an R3010 in it.  *  * Again, see the comments in m68k-tdep.c.  */
end_comment

begin_function
name|void
name|supply_fpregset
parameter_list|(
name|fpregsetp
parameter_list|)
name|fpregset_t
modifier|*
name|fpregsetp
decl_stmt|;
block|{
specifier|register
name|int
name|regi
decl_stmt|;
specifier|static
name|char
name|zerobuf
index|[
name|MAX_REGISTER_RAW_SIZE
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
for|for
control|(
name|regi
operator|=
literal|0
init|;
name|regi
operator|<
literal|32
condition|;
name|regi
operator|++
control|)
name|supply_register
argument_list|(
name|FP0_REGNUM
operator|+
name|regi
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|fpregsetp
operator|->
name|fp_r
operator|.
name|fp_regs
index|[
name|regi
index|]
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|FCRCS_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|fpregsetp
operator|->
name|fp_csr
argument_list|)
expr_stmt|;
comment|/* FIXME: how can we supply FCRIR_REGNUM?  SGI doesn't tell us. */
name|supply_register
argument_list|(
name|FCRIR_REGNUM
argument_list|,
name|zerobuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fill_fpregset
parameter_list|(
name|fpregsetp
parameter_list|,
name|regno
parameter_list|)
name|fpregset_t
modifier|*
name|fpregsetp
decl_stmt|;
name|int
name|regno
decl_stmt|;
block|{
name|int
name|regi
decl_stmt|;
name|char
modifier|*
name|from
decl_stmt|,
modifier|*
name|to
decl_stmt|;
for|for
control|(
name|regi
operator|=
name|FP0_REGNUM
init|;
name|regi
operator|<
name|FP0_REGNUM
operator|+
literal|32
condition|;
name|regi
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|regno
operator|==
name|regi
operator|)
condition|)
block|{
name|from
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|regi
argument_list|)
index|]
expr_stmt|;
name|to
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|fpregsetp
operator|->
name|fp_r
operator|.
name|fp_regs
index|[
name|regi
operator|-
name|FP0_REGNUM
index|]
operator|)
expr_stmt|;
name|memcpy
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regi
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|regno
operator|==
name|FCRCS_REGNUM
operator|)
condition|)
name|fpregsetp
operator|->
name|fp_csr
operator|=
operator|*
operator|(
name|unsigned
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|FCRCS_REGNUM
argument_list|)
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Figure out where the longjmp will land.    We expect the first arg to be a pointer to the jmp_buf structure from which    we extract the pc (JB_PC) that we will land at.  The pc is copied into PC.    This routine returns true on success. */
end_comment

begin_function
name|int
name|get_longjmp_target
parameter_list|(
name|pc
parameter_list|)
name|CORE_ADDR
modifier|*
name|pc
decl_stmt|;
block|{
name|char
name|buf
index|[
name|TARGET_PTR_BIT
operator|/
name|TARGET_CHAR_BIT
index|]
decl_stmt|;
name|CORE_ADDR
name|jb_addr
decl_stmt|;
name|jb_addr
operator|=
name|read_register
argument_list|(
name|A0_REGNUM
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_read_memory
argument_list|(
name|jb_addr
operator|+
name|JB_PC
operator|*
name|JB_ELEMENT_SIZE
argument_list|,
name|buf
argument_list|,
name|TARGET_PTR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|)
condition|)
return|return
literal|0
return|;
operator|*
name|pc
operator|=
name|extract_address
argument_list|(
name|buf
argument_list|,
name|TARGET_PTR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fetch_core_registers
parameter_list|(
name|core_reg_sect
parameter_list|,
name|core_reg_size
parameter_list|,
name|which
parameter_list|,
name|reg_addr
parameter_list|)
name|char
modifier|*
name|core_reg_sect
decl_stmt|;
name|unsigned
name|core_reg_size
decl_stmt|;
name|int
name|which
decl_stmt|;
comment|/* Unused */
name|unsigned
name|int
name|reg_addr
decl_stmt|;
comment|/* Unused */
block|{
if|if
condition|(
name|core_reg_size
operator|!=
name|REGISTER_BYTES
condition|)
block|{
name|warning
argument_list|(
literal|"wrong size gregset struct in core file"
argument_list|)
expr_stmt|;
return|return;
block|}
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|registers
argument_list|,
name|core_reg_sect
argument_list|,
name|core_reg_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Irix 5 uses what appears to be a unique form of shared library    support.  This is a copy of solib.c modified for Irix 5.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_comment
comment|/*<obj.h> includes<sym.h> and<symconst.h>, which causes conflicts    with our versions of those files included by tm-mips.h.  Prevent<obj.h> from including them with some appropriate defines.  */
end_comment

begin_define
define|#
directive|define
name|__SYM_H__
end_define

begin_define
define|#
directive|define
name|__SYMCONST_H__
end_define

begin_include
include|#
directive|include
file|<obj.h>
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"gnu-regex.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_comment
comment|/* The symbol which starts off the list of shared libraries.  */
end_comment

begin_define
define|#
directive|define
name|DEBUG_BASE
value|"__rld_obj_head"
end_define

begin_comment
comment|/* How to get the loaded address of a shared library.  */
end_comment

begin_define
define|#
directive|define
name|LM_ADDR
parameter_list|(
name|so
parameter_list|)
value|((so)->lm.o_praw)
end_define

begin_decl_stmt
name|char
name|shadow_contents
index|[
name|BREAKPOINT_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Stash old bkpt addr contents */
end_comment

begin_struct
struct|struct
name|so_list
block|{
name|struct
name|so_list
modifier|*
name|next
decl_stmt|;
comment|/* next structure in linked list */
name|struct
name|obj_list
name|ll
decl_stmt|;
name|struct
name|obj
name|lm
decl_stmt|;
comment|/* copy of link map from inferior */
name|struct
name|obj_list
modifier|*
name|lladdr
decl_stmt|;
comment|/* addr in inferior lm was read from */
name|CORE_ADDR
name|lmend
decl_stmt|;
comment|/* upper addr bound of mapped object */
name|char
name|symbols_loaded
decl_stmt|;
comment|/* flag: symbols read in yet? */
name|char
name|from_tty
decl_stmt|;
comment|/* flag: print msgs? */
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
comment|/* objfile for loaded lib */
name|struct
name|section_table
modifier|*
name|sections
decl_stmt|;
name|struct
name|section_table
modifier|*
name|sections_end
decl_stmt|;
name|struct
name|section_table
modifier|*
name|textsection
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|so_list
modifier|*
name|so_list_head
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of known shared objects */
end_comment

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|debug_base
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Base of dynamic linker structures */
end_comment

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|breakpoint_addr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Address where end bkpt is set */
end_comment

begin_comment
comment|/* Local function prototypes */
end_comment

begin_decl_stmt
specifier|static
name|void
name|sharedlibrary_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|enable_break
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|disable_break
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|info_sharedlibrary_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|symbol_add_stub
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|so_list
modifier|*
name|find_solib
name|PARAMS
argument_list|(
operator|(
expr|struct
name|so_list
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|obj_list
modifier|*
name|first_link_map_member
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|locate_base
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|solib_map_sections
name|PARAMS
argument_list|(
operator|(
expr|struct
name|so_list
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  LOCAL FUNCTION  	solib_map_sections -- open bfd and build sections for shared lib  SYNOPSIS  	static void solib_map_sections (struct so_list *so)  DESCRIPTION  	Given a pointer to one of the shared objects in our list 	of mapped objects, use the recorded name to open a bfd 	descriptor for the object, build a section table, and then 	relocate all the section addresses by the base address at 	which the shared object was mapped.  FIXMES  	In most (all?) cases the shared object file name recorded in the 	dynamic linkage tables will be a fully qualified pathname.  For 	cases where it isn't, do we really mimic the systems search 	mechanism correctly in the below code (particularly the tilde 	expansion stuff?).  */
end_comment

begin_function
specifier|static
name|void
name|solib_map_sections
parameter_list|(
name|so
parameter_list|)
name|struct
name|so_list
modifier|*
name|so
decl_stmt|;
block|{
name|char
modifier|*
name|filename
decl_stmt|;
name|char
modifier|*
name|scratch_pathname
decl_stmt|;
name|int
name|scratch_chan
decl_stmt|;
name|struct
name|section_table
modifier|*
name|p
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|CORE_ADDR
name|offset
decl_stmt|;
name|filename
operator|=
name|tilde_expand
argument_list|(
name|so
operator|->
name|lm
operator|.
name|o_path
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|scratch_chan
operator|=
name|openp
argument_list|(
name|getenv
argument_list|(
literal|"PATH"
argument_list|)
argument_list|,
literal|1
argument_list|,
name|filename
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|,
operator|&
name|scratch_pathname
argument_list|)
expr_stmt|;
if|if
condition|(
name|scratch_chan
operator|<
literal|0
condition|)
block|{
name|scratch_chan
operator|=
name|openp
argument_list|(
name|getenv
argument_list|(
literal|"LD_LIBRARY_PATH"
argument_list|)
argument_list|,
literal|1
argument_list|,
name|filename
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|,
operator|&
name|scratch_pathname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|scratch_chan
operator|<
literal|0
condition|)
block|{
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
comment|/* Leave scratch_pathname allocated.  abfd->name will point to it.  */
name|abfd
operator|=
name|bfd_fdopenr
argument_list|(
name|scratch_pathname
argument_list|,
name|gnutarget
argument_list|,
name|scratch_chan
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|abfd
condition|)
block|{
name|close
argument_list|(
name|scratch_chan
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Could not open `%s' as an executable file: %s"
argument_list|,
name|scratch_pathname
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Leave bfd open, core_xfer_memory and "info files" need it.  */
name|so
operator|->
name|abfd
operator|=
name|abfd
expr_stmt|;
name|abfd
operator|->
name|cacheable
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_check_format
argument_list|(
name|abfd
argument_list|,
name|bfd_object
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"\"%s\": not in executable format: %s."
argument_list|,
name|scratch_pathname
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|build_section_table
argument_list|(
name|abfd
argument_list|,
operator|&
name|so
operator|->
name|sections
argument_list|,
operator|&
name|so
operator|->
name|sections_end
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"Can't find the file sections in `%s': %s"
argument_list|,
name|bfd_get_filename
argument_list|(
name|exec_bfd
argument_list|)
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Irix 5 shared objects are pre-linked to particular addresses      although the dynamic linker may have to relocate them if the      address ranges of the libraries used by the main program clash.      The offset is the difference between the address where the object      is mapped and the binding address of the shared library.  */
name|offset
operator|=
operator|(
name|CORE_ADDR
operator|)
name|LM_ADDR
argument_list|(
name|so
argument_list|)
operator|-
name|so
operator|->
name|lm
operator|.
name|o_base_address
expr_stmt|;
for|for
control|(
name|p
operator|=
name|so
operator|->
name|sections
init|;
name|p
operator|<
name|so
operator|->
name|sections_end
condition|;
name|p
operator|++
control|)
block|{
comment|/* Relocate the section binding addresses as recorded in the shared 	 object's file by the offset to get the address to which the 	 object was actually mapped.  */
name|p
operator|->
name|addr
operator|+=
name|offset
expr_stmt|;
name|p
operator|->
name|endaddr
operator|+=
name|offset
expr_stmt|;
name|so
operator|->
name|lmend
operator|=
operator|(
name|CORE_ADDR
operator|)
name|max
argument_list|(
name|p
operator|->
name|endaddr
argument_list|,
name|so
operator|->
name|lmend
argument_list|)
expr_stmt|;
if|if
condition|(
name|STREQ
argument_list|(
name|p
operator|->
name|the_bfd_section
operator|->
name|name
argument_list|,
literal|".text"
argument_list|)
condition|)
block|{
name|so
operator|->
name|textsection
operator|=
name|p
expr_stmt|;
block|}
block|}
comment|/* Free the file names, close the file now.  */
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	locate_base -- locate the base address of dynamic linker structs  SYNOPSIS  	CORE_ADDR locate_base (void)  DESCRIPTION  	For both the SunOS and SVR4 shared library implementations, if the 	inferior executable has been linked dynamically, there is a single 	address somewhere in the inferior's data space which is the key to 	locating all of the dynamic linker's runtime structures.  This 	address is the value of the symbol defined by the macro DEBUG_BASE. 	The job of this function is to find and return that address, or to 	return 0 if there is no such address (the executable is statically 	linked for example).  	For SunOS, the job is almost trivial, since the dynamic linker and 	all of it's structures are statically linked to the executable at 	link time.  Thus the symbol for the address we are looking for has 	already been added to the minimal symbol table for the executable's 	objfile at the time the symbol file's symbols were read, and all we 	have to do is look it up there.  Note that we explicitly do NOT want 	to find the copies in the shared library.  	The SVR4 version is much more complicated because the dynamic linker 	and it's structures are located in the shared C library, which gets 	run as the executable's "interpreter" by the kernel.  We have to go 	to a lot more work to discover the address of DEBUG_BASE.  Because 	of this complexity, we cache the value we find and return that value 	on subsequent invocations.  Note there is no copy in the executable 	symbol tables.  	Irix 5 is basically like SunOS.  	Note that we can assume nothing about the process state at the time 	we need to find this address.  We may be stopped on the first instruc- 	tion of the interpreter (C shared library), the first instruction of 	the executable itself, or somewhere else entirely (if we attached 	to the process for example).   */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|locate_base
parameter_list|()
block|{
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
name|CORE_ADDR
name|address
init|=
literal|0
decl_stmt|;
name|msymbol
operator|=
name|lookup_minimal_symbol
argument_list|(
name|DEBUG_BASE
argument_list|,
name|NULL
argument_list|,
name|symfile_objfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|msymbol
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|address
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|address
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	first_link_map_member -- locate first member in dynamic linker's map  SYNOPSIS  	static struct link_map *first_link_map_member (void)  DESCRIPTION  	Read in a copy of the first member in the inferior's dynamic 	link map from the inferior's dynamic linker structures, and return 	a pointer to the copy in our address space. */
end_comment

begin_function
specifier|static
name|struct
name|obj_list
modifier|*
name|first_link_map_member
parameter_list|()
block|{
name|struct
name|obj_list
modifier|*
name|lm
decl_stmt|;
name|struct
name|obj_list
name|s
decl_stmt|;
name|read_memory
argument_list|(
name|debug_base
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|lm
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|obj_list
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lm
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* The first entry in the list is the object file we are debugging,      so skip it.  */
name|read_memory
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|lm
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|s
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|obj_list
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|s
operator|.
name|next
return|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	find_solib -- step through list of shared objects  SYNOPSIS  	struct so_list *find_solib (struct so_list *so_list_ptr)  DESCRIPTION  	This module contains the routine which finds the names of any 	loaded "images" in the current process. The argument in must be 	NULL on the first call, and then the returned value must be passed 	in on subsequent calls. This provides the capability to "step" down 	the list of loaded objects. On the last object, a NULL value is 	returned.  */
end_comment

begin_function
specifier|static
name|struct
name|so_list
modifier|*
name|find_solib
parameter_list|(
name|so_list_ptr
parameter_list|)
name|struct
name|so_list
modifier|*
name|so_list_ptr
decl_stmt|;
comment|/* Last lm or NULL for first one */
block|{
name|struct
name|so_list
modifier|*
name|so_list_next
init|=
name|NULL
decl_stmt|;
name|struct
name|obj_list
modifier|*
name|lm
init|=
name|NULL
decl_stmt|;
name|struct
name|so_list
modifier|*
name|new
decl_stmt|;
if|if
condition|(
name|so_list_ptr
operator|==
name|NULL
condition|)
block|{
comment|/* We are setting up for a new scan through the loaded images. */
if|if
condition|(
operator|(
name|so_list_next
operator|=
name|so_list_head
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* We have not already read in the dynamic linking structures 	     from the inferior, lookup the address of the base structure. */
name|debug_base
operator|=
name|locate_base
argument_list|()
expr_stmt|;
if|if
condition|(
name|debug_base
operator|!=
literal|0
condition|)
block|{
comment|/* Read the base structure in and find the address of the first 		 link map list member. */
name|lm
operator|=
name|first_link_map_member
argument_list|()
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* We have been called before, and are in the process of walking 	 the shared library list.  Advance to the next shared object. */
if|if
condition|(
operator|(
name|lm
operator|=
name|so_list_ptr
operator|->
name|ll
operator|.
name|next
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* We have hit the end of the list, so check to see if any were 	     added, but be quiet if we can't read from the target any more. */
name|int
name|status
init|=
name|target_read_memory
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|so_list_ptr
operator|->
name|lladdr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|so_list_ptr
operator|->
name|ll
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|obj_list
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
block|{
name|lm
operator|=
name|so_list_ptr
operator|->
name|ll
operator|.
name|next
expr_stmt|;
block|}
else|else
block|{
name|lm
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|so_list_next
operator|=
name|so_list_ptr
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|so_list_next
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|lm
operator|!=
name|NULL
operator|)
condition|)
block|{
name|int
name|errcode
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
comment|/* Get next link map structure from inferior image and build a local 	 abbreviated load_map structure */
name|new
operator|=
operator|(
expr|struct
name|so_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|so_list
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|new
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|so_list
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|lladdr
operator|=
name|lm
expr_stmt|;
comment|/* Add the new node as the next node in the list, or as the root 	 node if this is the first one. */
if|if
condition|(
name|so_list_ptr
operator|!=
name|NULL
condition|)
block|{
name|so_list_ptr
operator|->
name|next
operator|=
name|new
expr_stmt|;
block|}
else|else
block|{
name|so_list_head
operator|=
name|new
expr_stmt|;
block|}
name|so_list_next
operator|=
name|new
expr_stmt|;
name|read_memory
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|lm
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|new
operator|->
name|ll
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|obj_list
argument_list|)
argument_list|)
expr_stmt|;
name|read_memory
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|new
operator|->
name|ll
operator|.
name|data
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|new
operator|->
name|lm
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|obj
argument_list|)
argument_list|)
expr_stmt|;
name|target_read_string
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|new
operator|->
name|lm
operator|.
name|o_path
argument_list|,
operator|&
name|buffer
argument_list|,
name|INT_MAX
argument_list|,
operator|&
name|errcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|errcode
operator|!=
literal|0
condition|)
name|memory_error
argument_list|(
name|errcode
argument_list|,
operator|(
name|CORE_ADDR
operator|)
name|new
operator|->
name|lm
operator|.
name|o_path
argument_list|)
expr_stmt|;
name|new
operator|->
name|lm
operator|.
name|o_path
operator|=
name|buffer
expr_stmt|;
name|solib_map_sections
argument_list|(
name|new
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|so_list_next
operator|)
return|;
block|}
end_function

begin_comment
comment|/* A small stub to get us past the arg-passing pinhole of catch_errors.  */
end_comment

begin_function
specifier|static
name|int
name|symbol_add_stub
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
specifier|register
name|struct
name|so_list
modifier|*
name|so
init|=
operator|(
expr|struct
name|so_list
operator|*
operator|)
name|arg
decl_stmt|;
comment|/* catch_errs bogon */
name|so
operator|->
name|objfile
operator|=
name|symbol_file_add
argument_list|(
name|so
operator|->
name|lm
operator|.
name|o_path
argument_list|,
name|so
operator|->
name|from_tty
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|so
operator|->
name|textsection
operator|->
name|addr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  GLOBAL FUNCTION  	solib_add -- add a shared library file to the symtab and section list  SYNOPSIS  	void solib_add (char *arg_string, int from_tty, 			struct target_ops *target)  DESCRIPTION  */
end_comment

begin_function
name|void
name|solib_add
parameter_list|(
name|arg_string
parameter_list|,
name|from_tty
parameter_list|,
name|target
parameter_list|)
name|char
modifier|*
name|arg_string
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
name|struct
name|target_ops
modifier|*
name|target
decl_stmt|;
block|{
specifier|register
name|struct
name|so_list
modifier|*
name|so
init|=
name|NULL
decl_stmt|;
comment|/* link map state variable */
comment|/* Last shared library that we read.  */
name|struct
name|so_list
modifier|*
name|so_last
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|re_err
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|old
decl_stmt|;
if|if
condition|(
operator|(
name|re_err
operator|=
name|re_comp
argument_list|(
name|arg_string
condition|?
name|arg_string
else|:
literal|"."
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"Invalid regexp: %s"
argument_list|,
name|re_err
argument_list|)
expr_stmt|;
block|}
comment|/* Add the shared library sections to the section table of the      specified target, if any.  */
if|if
condition|(
name|target
condition|)
block|{
comment|/* Count how many new section_table entries there are.  */
name|so
operator|=
name|NULL
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|so
operator|=
name|find_solib
argument_list|(
name|so
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|so
operator|->
name|lm
operator|.
name|o_path
index|[
literal|0
index|]
condition|)
block|{
name|count
operator|+=
name|so
operator|->
name|sections_end
operator|-
name|so
operator|->
name|sections
expr_stmt|;
block|}
block|}
if|if
condition|(
name|count
condition|)
block|{
name|int
name|update_coreops
decl_stmt|;
comment|/* We must update the to_sections field in the core_ops structure 	     here, otherwise we dereference a potential dangling pointer 	     for each call to target_read/write_memory within this routine.  */
name|update_coreops
operator|=
name|core_ops
operator|.
name|to_sections
operator|==
name|target
operator|->
name|to_sections
expr_stmt|;
comment|/* Reallocate the target's section table including the new size.  */
if|if
condition|(
name|target
operator|->
name|to_sections
condition|)
block|{
name|old
operator|=
name|target
operator|->
name|to_sections_end
operator|-
name|target
operator|->
name|to_sections
expr_stmt|;
name|target
operator|->
name|to_sections
operator|=
operator|(
expr|struct
name|section_table
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|target
operator|->
name|to_sections
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|section_table
argument_list|)
operator|)
operator|*
operator|(
name|count
operator|+
name|old
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|old
operator|=
literal|0
expr_stmt|;
name|target
operator|->
name|to_sections
operator|=
operator|(
expr|struct
name|section_table
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|section_table
argument_list|)
operator|)
operator|*
name|count
argument_list|)
expr_stmt|;
block|}
name|target
operator|->
name|to_sections_end
operator|=
name|target
operator|->
name|to_sections
operator|+
operator|(
name|count
operator|+
name|old
operator|)
expr_stmt|;
comment|/* Update the to_sections field in the core_ops structure 	     if needed.  */
if|if
condition|(
name|update_coreops
condition|)
block|{
name|core_ops
operator|.
name|to_sections
operator|=
name|target
operator|->
name|to_sections
expr_stmt|;
name|core_ops
operator|.
name|to_sections_end
operator|=
name|target
operator|->
name|to_sections_end
expr_stmt|;
block|}
comment|/* Add these section table entries to the target's table.  */
while|while
condition|(
operator|(
name|so
operator|=
name|find_solib
argument_list|(
name|so
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|so
operator|->
name|lm
operator|.
name|o_path
index|[
literal|0
index|]
condition|)
block|{
name|count
operator|=
name|so
operator|->
name|sections_end
operator|-
name|so
operator|->
name|sections
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|target
operator|->
name|to_sections
operator|+
name|old
operator|)
argument_list|,
name|so
operator|->
name|sections
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|section_table
argument_list|)
operator|)
operator|*
name|count
argument_list|)
expr_stmt|;
name|old
operator|+=
name|count
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Now add the symbol files.  */
while|while
condition|(
operator|(
name|so
operator|=
name|find_solib
argument_list|(
name|so
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|so
operator|->
name|lm
operator|.
name|o_path
index|[
literal|0
index|]
operator|&&
name|re_exec
argument_list|(
name|so
operator|->
name|lm
operator|.
name|o_path
argument_list|)
condition|)
block|{
name|so
operator|->
name|from_tty
operator|=
name|from_tty
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|symbols_loaded
condition|)
block|{
if|if
condition|(
name|from_tty
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"Symbols already loaded for %s\n"
argument_list|,
name|so
operator|->
name|lm
operator|.
name|o_path
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|catch_errors
argument_list|(
name|symbol_add_stub
argument_list|,
operator|(
name|char
operator|*
operator|)
name|so
argument_list|,
literal|"Error while reading shared library symbols:\n"
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
condition|)
block|{
name|so_last
operator|=
name|so
expr_stmt|;
name|so
operator|->
name|symbols_loaded
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/* Getting new symbols may change our opinion about what is      frameless.  */
if|if
condition|(
name|so_last
condition|)
name|reinit_frame_cache
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	info_sharedlibrary_command -- code for "info sharedlibrary"  SYNOPSIS  	static void info_sharedlibrary_command ()  DESCRIPTION  	Walk through the shared library list and print information 	about each attached library. */
end_comment

begin_function
specifier|static
name|void
name|info_sharedlibrary_command
parameter_list|(
name|ignore
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|ignore
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
specifier|register
name|struct
name|so_list
modifier|*
name|so
init|=
name|NULL
decl_stmt|;
comment|/* link map state variable */
name|int
name|header_done
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|exec_bfd
operator|==
name|NULL
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"No exec file.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
operator|(
name|so
operator|=
name|find_solib
argument_list|(
name|so
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|so
operator|->
name|lm
operator|.
name|o_path
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
operator|!
name|header_done
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"%-12s%-12s%-12s%s\n"
argument_list|,
literal|"From"
argument_list|,
literal|"To"
argument_list|,
literal|"Syms Read"
argument_list|,
literal|"Shared Object Library"
argument_list|)
expr_stmt|;
name|header_done
operator|++
expr_stmt|;
block|}
name|printf_unfiltered
argument_list|(
literal|"%-12s"
argument_list|,
name|local_hex_string_custom
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|LM_ADDR
argument_list|(
name|so
argument_list|)
argument_list|,
literal|"08l"
argument_list|)
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"%-12s"
argument_list|,
name|local_hex_string_custom
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|so
operator|->
name|lmend
argument_list|,
literal|"08l"
argument_list|)
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"%-12s"
argument_list|,
name|so
operator|->
name|symbols_loaded
condition|?
literal|"Yes"
else|:
literal|"No"
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"%s\n"
argument_list|,
name|so
operator|->
name|lm
operator|.
name|o_path
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|so_list_head
operator|==
name|NULL
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"No shared libraries loaded at this time.\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  GLOBAL FUNCTION  	solib_address -- check to see if an address is in a shared lib  SYNOPSIS  	char *solib_address (CORE_ADDR address)  DESCRIPTION  	Provides a hook for other gdb routines to discover whether or 	not a particular address is within the mapped address space of 	a shared library.  Any address between the base mapping address 	and the first address beyond the end of the last mapping, is 	considered to be within the shared library address space, for 	our purposes.  	For example, this routine is called at one point to disable 	breakpoints which are in shared libraries that are not currently 	mapped in.  */
end_comment

begin_function
name|char
modifier|*
name|solib_address
parameter_list|(
name|address
parameter_list|)
name|CORE_ADDR
name|address
decl_stmt|;
block|{
specifier|register
name|struct
name|so_list
modifier|*
name|so
init|=
literal|0
decl_stmt|;
comment|/* link map state variable */
while|while
condition|(
operator|(
name|so
operator|=
name|find_solib
argument_list|(
name|so
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|so
operator|->
name|lm
operator|.
name|o_path
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
operator|(
name|address
operator|>=
operator|(
name|CORE_ADDR
operator|)
name|LM_ADDR
argument_list|(
name|so
argument_list|)
operator|)
operator|&&
operator|(
name|address
operator|<
operator|(
name|CORE_ADDR
operator|)
name|so
operator|->
name|lmend
operator|)
condition|)
return|return
operator|(
name|so
operator|->
name|lm
operator|.
name|o_path
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Called by free_all_symtabs */
end_comment

begin_function
name|void
name|clear_solib
parameter_list|()
block|{
name|struct
name|so_list
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|bfd_filename
decl_stmt|;
while|while
condition|(
name|so_list_head
condition|)
block|{
if|if
condition|(
name|so_list_head
operator|->
name|sections
condition|)
block|{
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|so_list_head
operator|->
name|sections
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|so_list_head
operator|->
name|abfd
condition|)
block|{
name|bfd_filename
operator|=
name|bfd_get_filename
argument_list|(
name|so_list_head
operator|->
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_close
argument_list|(
name|so_list_head
operator|->
name|abfd
argument_list|)
condition|)
name|warning
argument_list|(
literal|"cannot close \"%s\": %s"
argument_list|,
name|bfd_filename
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* This happens for the executable on SVR4.  */
name|bfd_filename
operator|=
name|NULL
expr_stmt|;
name|next
operator|=
name|so_list_head
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|bfd_filename
condition|)
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|bfd_filename
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|so_list_head
operator|->
name|lm
operator|.
name|o_path
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|so_list_head
argument_list|)
expr_stmt|;
name|so_list_head
operator|=
name|next
expr_stmt|;
block|}
name|debug_base
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	disable_break -- remove the "mapping changed" breakpoint  SYNOPSIS  	static int disable_break ()  DESCRIPTION  	Removes the breakpoint that gets hit when the dynamic linker 	completes a mapping change.  */
end_comment

begin_function
specifier|static
name|int
name|disable_break
parameter_list|()
block|{
name|int
name|status
init|=
literal|1
decl_stmt|;
comment|/* Note that breakpoint address and original contents are in our address      space, so we just need to write the original contents back. */
if|if
condition|(
name|memory_remove_breakpoint
argument_list|(
name|breakpoint_addr
argument_list|,
name|shadow_contents
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|status
operator|=
literal|0
expr_stmt|;
block|}
comment|/* For the SVR4 version, we always know the breakpoint address.  For the      SunOS version we don't know it until the above code is executed.      Grumble if we are stopped anywhere besides the breakpoint address. */
if|if
condition|(
name|stop_pc
operator|!=
name|breakpoint_addr
condition|)
block|{
name|warning
argument_list|(
literal|"stopped at unknown breakpoint while handling shared libraries"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	enable_break -- arrange for dynamic linker to hit breakpoint  SYNOPSIS  	int enable_break (void)  DESCRIPTION  	This functions inserts a breakpoint at the entry point of the 	main executable, where all shared libraries are mapped in. */
end_comment

begin_function
specifier|static
name|int
name|enable_break
parameter_list|()
block|{
if|if
condition|(
name|symfile_objfile
operator|!=
name|NULL
operator|&&
name|target_insert_breakpoint
argument_list|(
name|symfile_objfile
operator|->
name|ei
operator|.
name|entry_point
argument_list|,
name|shadow_contents
argument_list|)
operator|==
literal|0
condition|)
block|{
name|breakpoint_addr
operator|=
name|symfile_objfile
operator|->
name|ei
operator|.
name|entry_point
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*    GLOBAL FUNCTION    	solib_create_inferior_hook -- shared library startup support    SYNOPSIS    	void solib_create_inferior_hook()    DESCRIPTION    	When gdb starts up the inferior, it nurses it along (through the 	shell) until it is ready to execute it's first instruction.  At this 	point, this function gets called via expansion of the macro 	SOLIB_CREATE_INFERIOR_HOOK.  	For SunOS executables, this first instruction is typically the 	one at "_start", or a similar text label, regardless of whether 	the executable is statically or dynamically linked.  The runtime 	startup code takes care of dynamically linking in any shared 	libraries, once gdb allows the inferior to continue.  	For SVR4 executables, this first instruction is either the first 	instruction in the dynamic linker (for dynamically linked 	executables) or the instruction at "start" for statically linked 	executables.  For dynamically linked executables, the system 	first exec's /lib/libc.so.N, which contains the dynamic linker, 	and starts it running.  The dynamic linker maps in any needed 	shared libraries, maps in the actual user executable, and then 	jumps to "start" in the user executable.  	For both SunOS shared libraries, and SVR4 shared libraries, we 	can arrange to cooperate with the dynamic linker to discover the 	names of shared libraries that are dynamically linked, and the 	base addresses to which they are linked.  	This function is responsible for discovering those names and 	addresses, and saving sufficient information about them to allow 	their symbols to be read at a later time.  FIXME  	Between enable_break() and disable_break(), this code does not 	properly handle hitting breakpoints which the user might have 	set in the startup code or in the dynamic linker itself.  Proper 	handling will probably have to wait until the implementation is 	changed to use the "breakpoint handler function" method.  	Also, what if child has exit()ed?  Must exit loop somehow.   */
end_comment

begin_function
name|void
name|solib_create_inferior_hook
parameter_list|()
block|{
if|if
condition|(
operator|!
name|enable_break
argument_list|()
condition|)
block|{
name|warning
argument_list|(
literal|"shared library handler failed to enable breakpoint"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Now run the target.  It will eventually hit the breakpoint, at      which point all of the libraries will have been mapped in and we      can go groveling around in the dynamic linker structures to find      out what we need to know about them. */
name|clear_proceed_status
argument_list|()
expr_stmt|;
name|stop_soon_quietly
operator|=
literal|1
expr_stmt|;
name|stop_signal
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|target_resume
argument_list|(
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|stop_signal
argument_list|)
expr_stmt|;
name|wait_for_inferior
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|stop_signal
operator|!=
name|SIGTRAP
condition|)
do|;
comment|/* We are now either at the "mapping complete" breakpoint (or somewhere      else, a condition we aren't prepared to deal with anyway), so adjust      the PC as necessary after a breakpoint, disable the breakpoint, and      add any shared libraries that were mapped in. */
if|if
condition|(
name|DECR_PC_AFTER_BREAK
condition|)
block|{
name|stop_pc
operator|-=
name|DECR_PC_AFTER_BREAK
expr_stmt|;
name|write_register
argument_list|(
name|PC_REGNUM
argument_list|,
name|stop_pc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|disable_break
argument_list|()
condition|)
block|{
name|warning
argument_list|(
literal|"shared library handler failed to disable breakpoint"
argument_list|)
expr_stmt|;
block|}
comment|/*  solib_add will call reinit_frame_cache.       But we are stopped in the startup code and we might not have symbols       for the startup code, so heuristic_proc_start could be called       and will put out an annoying warning.       Delaying the resetting of stop_soon_quietly until after symbol loading       suppresses the warning.  */
if|if
condition|(
name|auto_solib_add
condition|)
name|solib_add
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|target_ops
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|stop_soon_quietly
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	sharedlibrary_command -- handle command to explicitly add library  SYNOPSIS  	static void sharedlibrary_command (char *args, int from_tty)  DESCRIPTION  */
end_comment

begin_function
specifier|static
name|void
name|sharedlibrary_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|dont_repeat
argument_list|()
expr_stmt|;
name|solib_add
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|,
operator|(
expr|struct
name|target_ops
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_initialize_solib
parameter_list|()
block|{
name|add_com
argument_list|(
literal|"sharedlibrary"
argument_list|,
name|class_files
argument_list|,
name|sharedlibrary_command
argument_list|,
literal|"Load shared object library symbols for files matching REGEXP."
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"sharedlibrary"
argument_list|,
name|info_sharedlibrary_command
argument_list|,
literal|"Status of loaded shared object libraries."
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"auto-solib-add"
argument_list|,
name|class_support
argument_list|,
name|var_zinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|auto_solib_add
argument_list|,
literal|"Set autoloading of shared library symbols.\n\ If nonzero, symbols from all shared object libraries will be loaded\n\ automatically when the inferior begins execution or when the dynamic linker\n\ informs gdb that a new library has been loaded.  Otherwise, symbols\n\ must be loaded manually, using `sharedlibrary'."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Register that we are able to handle irix5 core file formats.    This really is bfd_target_unknown_flavour */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|core_fns
name|irix5_core_fns
init|=
block|{
name|bfd_target_unknown_flavour
block|,
name|fetch_core_registers
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|_initialize_core_irix5
parameter_list|()
block|{
name|add_core_fns
argument_list|(
operator|&
name|irix5_core_fns
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

