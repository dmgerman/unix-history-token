begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Native support for the SGI Iris running IRIX version 5, for GDB.    Copyright 1988, 89, 90, 91, 92, 93, 94, 95, 96, 98, 1999    Free Software Foundation, Inc.    Contributed by Alessandro Forin(af@cs.cmu.edu) at CMU    and by Per Bothner(bothner@cs.wisc.edu) at U.Wisconsin.    Implemented for Irix 4.x by Garrett A. Wollman.    Modified for Irix 5.x by Ian Lance Taylor.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/procfs.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_comment
comment|/* For JB_XXX.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|fetch_core_registers
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|unsigned
name|int
operator|,
name|int
operator|,
name|CORE_ADDR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size of elements in jmpbuf */
end_comment

begin_define
define|#
directive|define
name|JB_ELEMENT_SIZE
value|4
end_define

begin_comment
comment|/*  * See the comment in m68k-tdep.c regarding the utility of these functions.  *  * These definitions are from the MIPS SVR4 ABI, so they may work for  * any MIPS SVR4 target.  */
end_comment

begin_function
name|void
name|supply_gregset
parameter_list|(
name|gregsetp
parameter_list|)
name|gregset_t
modifier|*
name|gregsetp
decl_stmt|;
block|{
specifier|register
name|int
name|regi
decl_stmt|;
specifier|register
name|greg_t
modifier|*
name|regp
init|=
operator|&
operator|(
operator|*
name|gregsetp
operator|)
index|[
literal|0
index|]
decl_stmt|;
name|int
name|gregoff
init|=
sizeof|sizeof
argument_list|(
name|greg_t
argument_list|)
operator|-
name|MIPS_REGSIZE
decl_stmt|;
specifier|static
name|char
name|zerobuf
index|[
name|MAX_REGISTER_RAW_SIZE
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
for|for
control|(
name|regi
operator|=
literal|0
init|;
name|regi
operator|<=
name|CTX_RA
condition|;
name|regi
operator|++
control|)
name|supply_register
argument_list|(
name|regi
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
name|regi
operator|)
operator|+
name|gregoff
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|PC_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
name|CTX_EPC
operator|)
operator|+
name|gregoff
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|HI_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
name|CTX_MDHI
operator|)
operator|+
name|gregoff
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|LO_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
name|CTX_MDLO
operator|)
operator|+
name|gregoff
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|CAUSE_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
name|CTX_CAUSE
operator|)
operator|+
name|gregoff
argument_list|)
expr_stmt|;
comment|/* Fill inaccessible registers with zero.  */
name|supply_register
argument_list|(
name|BADVADDR_REGNUM
argument_list|,
name|zerobuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fill_gregset
parameter_list|(
name|gregsetp
parameter_list|,
name|regno
parameter_list|)
name|gregset_t
modifier|*
name|gregsetp
decl_stmt|;
name|int
name|regno
decl_stmt|;
block|{
name|int
name|regi
decl_stmt|;
specifier|register
name|greg_t
modifier|*
name|regp
init|=
operator|&
operator|(
operator|*
name|gregsetp
operator|)
index|[
literal|0
index|]
decl_stmt|;
comment|/* Under Irix6, if GDB is built with N32 ABI and is debugging an O32      executable, we have to sign extend the registers to 64 bits before      filling in the gregset structure.  */
for|for
control|(
name|regi
operator|=
literal|0
init|;
name|regi
operator|<=
name|CTX_RA
condition|;
name|regi
operator|++
control|)
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|regno
operator|==
name|regi
operator|)
condition|)
operator|*
operator|(
name|regp
operator|+
name|regi
operator|)
operator|=
name|extract_signed_integer
argument_list|(
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|regi
argument_list|)
index|]
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regi
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|regno
operator|==
name|PC_REGNUM
operator|)
condition|)
operator|*
operator|(
name|regp
operator|+
name|CTX_EPC
operator|)
operator|=
name|extract_signed_integer
argument_list|(
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|PC_REGNUM
argument_list|)
index|]
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|PC_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|regno
operator|==
name|CAUSE_REGNUM
operator|)
condition|)
operator|*
operator|(
name|regp
operator|+
name|CTX_CAUSE
operator|)
operator|=
name|extract_signed_integer
argument_list|(
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|CAUSE_REGNUM
argument_list|)
index|]
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|CAUSE_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|regno
operator|==
name|HI_REGNUM
operator|)
condition|)
operator|*
operator|(
name|regp
operator|+
name|CTX_MDHI
operator|)
operator|=
name|extract_signed_integer
argument_list|(
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|HI_REGNUM
argument_list|)
index|]
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|HI_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|regno
operator|==
name|LO_REGNUM
operator|)
condition|)
operator|*
operator|(
name|regp
operator|+
name|CTX_MDLO
operator|)
operator|=
name|extract_signed_integer
argument_list|(
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|LO_REGNUM
argument_list|)
index|]
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|LO_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Now we do the same thing for floating-point registers.  * We don't bother to condition on FP0_REGNUM since any  * reasonable MIPS configuration has an R3010 in it.  *  * Again, see the comments in m68k-tdep.c.  */
end_comment

begin_function
name|void
name|supply_fpregset
parameter_list|(
name|fpregsetp
parameter_list|)
name|fpregset_t
modifier|*
name|fpregsetp
decl_stmt|;
block|{
specifier|register
name|int
name|regi
decl_stmt|;
specifier|static
name|char
name|zerobuf
index|[
name|MAX_REGISTER_RAW_SIZE
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
comment|/* FIXME, this is wrong for the N32 ABI which has 64 bit FP regs. */
for|for
control|(
name|regi
operator|=
literal|0
init|;
name|regi
operator|<
literal|32
condition|;
name|regi
operator|++
control|)
name|supply_register
argument_list|(
name|FP0_REGNUM
operator|+
name|regi
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|fpregsetp
operator|->
name|fp_r
operator|.
name|fp_regs
index|[
name|regi
index|]
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|FCRCS_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|fpregsetp
operator|->
name|fp_csr
argument_list|)
expr_stmt|;
comment|/* FIXME: how can we supply FCRIR_REGNUM?  SGI doesn't tell us. */
name|supply_register
argument_list|(
name|FCRIR_REGNUM
argument_list|,
name|zerobuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fill_fpregset
parameter_list|(
name|fpregsetp
parameter_list|,
name|regno
parameter_list|)
name|fpregset_t
modifier|*
name|fpregsetp
decl_stmt|;
name|int
name|regno
decl_stmt|;
block|{
name|int
name|regi
decl_stmt|;
name|char
modifier|*
name|from
decl_stmt|,
modifier|*
name|to
decl_stmt|;
comment|/* FIXME, this is wrong for the N32 ABI which has 64 bit FP regs. */
for|for
control|(
name|regi
operator|=
name|FP0_REGNUM
init|;
name|regi
operator|<
name|FP0_REGNUM
operator|+
literal|32
condition|;
name|regi
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|regno
operator|==
name|regi
operator|)
condition|)
block|{
name|from
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|regi
argument_list|)
index|]
expr_stmt|;
name|to
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|fpregsetp
operator|->
name|fp_r
operator|.
name|fp_regs
index|[
name|regi
operator|-
name|FP0_REGNUM
index|]
operator|)
expr_stmt|;
name|memcpy
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regi
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|regno
operator|==
name|FCRCS_REGNUM
operator|)
condition|)
name|fpregsetp
operator|->
name|fp_csr
operator|=
operator|*
operator|(
name|unsigned
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|FCRCS_REGNUM
argument_list|)
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Figure out where the longjmp will land.    We expect the first arg to be a pointer to the jmp_buf structure from which    we extract the pc (JB_PC) that we will land at.  The pc is copied into PC.    This routine returns true on success. */
end_comment

begin_function
name|int
name|get_longjmp_target
parameter_list|(
name|pc
parameter_list|)
name|CORE_ADDR
modifier|*
name|pc
decl_stmt|;
block|{
name|char
name|buf
index|[
name|TARGET_PTR_BIT
operator|/
name|TARGET_CHAR_BIT
index|]
decl_stmt|;
name|CORE_ADDR
name|jb_addr
decl_stmt|;
name|jb_addr
operator|=
name|read_register
argument_list|(
name|A0_REGNUM
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_read_memory
argument_list|(
name|jb_addr
operator|+
name|JB_PC
operator|*
name|JB_ELEMENT_SIZE
argument_list|,
name|buf
argument_list|,
name|TARGET_PTR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|)
condition|)
return|return
literal|0
return|;
operator|*
name|pc
operator|=
name|extract_address
argument_list|(
name|buf
argument_list|,
name|TARGET_PTR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fetch_core_registers
parameter_list|(
name|core_reg_sect
parameter_list|,
name|core_reg_size
parameter_list|,
name|which
parameter_list|,
name|reg_addr
parameter_list|)
name|char
modifier|*
name|core_reg_sect
decl_stmt|;
name|unsigned
name|core_reg_size
decl_stmt|;
name|int
name|which
decl_stmt|;
comment|/* Unused */
name|CORE_ADDR
name|reg_addr
decl_stmt|;
comment|/* Unused */
block|{
if|if
condition|(
name|core_reg_size
operator|==
name|REGISTER_BYTES
condition|)
block|{
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|registers
argument_list|,
name|core_reg_sect
argument_list|,
name|core_reg_size
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|MIPS_REGSIZE
operator|==
literal|4
operator|&&
name|core_reg_size
operator|==
operator|(
literal|2
operator|*
name|MIPS_REGSIZE
operator|)
operator|*
name|NUM_REGS
condition|)
block|{
comment|/* This is a core file from a N32 executable, 64 bits are saved 	 for all registers.  */
name|char
modifier|*
name|srcp
init|=
name|core_reg_sect
decl_stmt|;
name|char
modifier|*
name|dstp
init|=
name|registers
decl_stmt|;
name|int
name|regno
decl_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|NUM_REGS
condition|;
name|regno
operator|++
control|)
block|{
if|if
condition|(
name|regno
operator|>=
name|FP0_REGNUM
operator|&&
name|regno
operator|<
operator|(
name|FP0_REGNUM
operator|+
literal|32
operator|)
condition|)
block|{
comment|/* FIXME, this is wrong, N32 has 64 bit FP regs, but GDB 		 currently assumes that they are 32 bit.  */
operator|*
name|dstp
operator|++
operator|=
operator|*
name|srcp
operator|++
expr_stmt|;
operator|*
name|dstp
operator|++
operator|=
operator|*
name|srcp
operator|++
expr_stmt|;
operator|*
name|dstp
operator|++
operator|=
operator|*
name|srcp
operator|++
expr_stmt|;
operator|*
name|dstp
operator|++
operator|=
operator|*
name|srcp
operator|++
expr_stmt|;
if|if
condition|(
name|REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
operator|==
literal|4
condition|)
block|{
comment|/* copying 4 bytes from eight bytes? 		     I don't see how this can be right...  */
name|srcp
operator|+=
literal|4
expr_stmt|;
block|}
else|else
block|{
comment|/* copy all 8 bytes (sizeof(double)) */
operator|*
name|dstp
operator|++
operator|=
operator|*
name|srcp
operator|++
expr_stmt|;
operator|*
name|dstp
operator|++
operator|=
operator|*
name|srcp
operator|++
expr_stmt|;
operator|*
name|dstp
operator|++
operator|=
operator|*
name|srcp
operator|++
expr_stmt|;
operator|*
name|dstp
operator|++
operator|=
operator|*
name|srcp
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|srcp
operator|+=
literal|4
expr_stmt|;
operator|*
name|dstp
operator|++
operator|=
operator|*
name|srcp
operator|++
expr_stmt|;
operator|*
name|dstp
operator|++
operator|=
operator|*
name|srcp
operator|++
expr_stmt|;
operator|*
name|dstp
operator|++
operator|=
operator|*
name|srcp
operator|++
expr_stmt|;
operator|*
name|dstp
operator|++
operator|=
operator|*
name|srcp
operator|++
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|warning
argument_list|(
literal|"wrong size gregset struct in core file"
argument_list|)
expr_stmt|;
return|return;
block|}
name|registers_fetched
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Irix 5 uses what appears to be a unique form of shared library    support.  This is a copy of solib.c modified for Irix 5.  */
end_comment

begin_comment
comment|/* FIXME: Most of this code could be merged with osfsolib.c and solib.c    by using next_link_map_member and xfer_link_map_member in solib.c.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_comment
comment|/*<obj.h> includes<sym.h> and<symconst.h>, which causes conflicts    with our versions of those files included by tm-mips.h.  Prevent<obj.h> from including them with some appropriate defines.  */
end_comment

begin_define
define|#
directive|define
name|__SYM_H__
end_define

begin_define
define|#
directive|define
name|__SYMCONST_H__
end_define

begin_include
include|#
directive|include
file|<obj.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_OBJLIST_H
end_ifdef

begin_include
include|#
directive|include
file|<objlist.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NEW_OBJ_INFO_MAGIC
end_ifdef

begin_define
define|#
directive|define
name|HANDLE_NEW_OBJ_LIST
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"gnu-regex.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_comment
comment|/* The symbol which starts off the list of shared libraries.  */
end_comment

begin_define
define|#
directive|define
name|DEBUG_BASE
value|"__rld_obj_head"
end_define

begin_comment
comment|/* Irix 6.x introduces a new variant of object lists.    To be able to debug O32 executables under Irix 6, we have to handle both    variants.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|OBJ_LIST_OLD
block|,
comment|/* Pre Irix 6.x object list.  */
name|OBJ_LIST_32
block|,
comment|/* 32 Bit Elf32_Obj_Info.  */
name|OBJ_LIST_64
comment|/* 64 Bit Elf64_Obj_Info, FIXME not yet implemented.  */
block|}
name|obj_list_variant
typedef|;
end_typedef

begin_comment
comment|/* Define our own link_map structure.    This will help to share code with osfsolib.c and solib.c.  */
end_comment

begin_struct
struct|struct
name|link_map
block|{
name|obj_list_variant
name|l_variant
decl_stmt|;
comment|/* which variant of object list */
name|CORE_ADDR
name|l_lladdr
decl_stmt|;
comment|/* addr in inferior list was read from */
name|CORE_ADDR
name|l_next
decl_stmt|;
comment|/* address of next object list entry */
block|}
struct|;
end_struct

begin_comment
comment|/* Irix 5 shared objects are pre-linked to particular addresses    although the dynamic linker may have to relocate them if the    address ranges of the libraries used by the main program clash.    The offset is the difference between the address where the object    is mapped and the binding address of the shared library.  */
end_comment

begin_define
define|#
directive|define
name|LM_OFFSET
parameter_list|(
name|so
parameter_list|)
value|((so) -> offset)
end_define

begin_comment
comment|/* Loaded address of shared library.  */
end_comment

begin_define
define|#
directive|define
name|LM_ADDR
parameter_list|(
name|so
parameter_list|)
value|((so) -> lmstart)
end_define

begin_decl_stmt
name|char
name|shadow_contents
index|[
name|BREAKPOINT_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Stash old bkpt addr contents */
end_comment

begin_struct
struct|struct
name|so_list
block|{
name|struct
name|so_list
modifier|*
name|next
decl_stmt|;
comment|/* next structure in linked list */
name|struct
name|link_map
name|lm
decl_stmt|;
name|CORE_ADDR
name|offset
decl_stmt|;
comment|/* prelink to load address offset */
name|char
modifier|*
name|so_name
decl_stmt|;
comment|/* shared object lib name */
name|CORE_ADDR
name|lmstart
decl_stmt|;
comment|/* lower addr bound of mapped object */
name|CORE_ADDR
name|lmend
decl_stmt|;
comment|/* upper addr bound of mapped object */
name|char
name|symbols_loaded
decl_stmt|;
comment|/* flag: symbols read in yet? */
name|char
name|from_tty
decl_stmt|;
comment|/* flag: print msgs? */
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
comment|/* objfile for loaded lib */
name|struct
name|section_table
modifier|*
name|sections
decl_stmt|;
name|struct
name|section_table
modifier|*
name|sections_end
decl_stmt|;
name|struct
name|section_table
modifier|*
name|textsection
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|so_list
modifier|*
name|so_list_head
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of known shared objects */
end_comment

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|debug_base
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Base of dynamic linker structures */
end_comment

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|breakpoint_addr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Address where end bkpt is set */
end_comment

begin_comment
comment|/* Local function prototypes */
end_comment

begin_decl_stmt
specifier|static
name|void
name|sharedlibrary_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|enable_break
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|disable_break
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|info_sharedlibrary_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|symbol_add_stub
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|so_list
modifier|*
name|find_solib
name|PARAMS
argument_list|(
operator|(
expr|struct
name|so_list
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|link_map
modifier|*
name|first_link_map_member
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|link_map
modifier|*
name|next_link_map_member
name|PARAMS
argument_list|(
operator|(
expr|struct
name|so_list
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|xfer_link_map_member
name|PARAMS
argument_list|(
operator|(
expr|struct
name|so_list
operator|*
operator|,
expr|struct
name|link_map
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|locate_base
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|solib_map_sections
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  LOCAL FUNCTION  	solib_map_sections -- open bfd and build sections for shared lib  SYNOPSIS  	static int solib_map_sections (struct so_list *so)  DESCRIPTION  	Given a pointer to one of the shared objects in our list 	of mapped objects, use the recorded name to open a bfd 	descriptor for the object, build a section table, and then 	relocate all the section addresses by the base address at 	which the shared object was mapped.  FIXMES  	In most (all?) cases the shared object file name recorded in the 	dynamic linkage tables will be a fully qualified pathname.  For 	cases where it isn't, do we really mimic the systems search 	mechanism correctly in the below code (particularly the tilde 	expansion stuff?).  */
end_comment

begin_function
specifier|static
name|int
name|solib_map_sections
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|so_list
modifier|*
name|so
init|=
operator|(
expr|struct
name|so_list
operator|*
operator|)
name|arg
decl_stmt|;
comment|/* catch_errors bogon */
name|char
modifier|*
name|filename
decl_stmt|;
name|char
modifier|*
name|scratch_pathname
decl_stmt|;
name|int
name|scratch_chan
decl_stmt|;
name|struct
name|section_table
modifier|*
name|p
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|filename
operator|=
name|tilde_expand
argument_list|(
name|so
operator|->
name|so_name
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|scratch_chan
operator|=
name|openp
argument_list|(
name|getenv
argument_list|(
literal|"PATH"
argument_list|)
argument_list|,
literal|1
argument_list|,
name|filename
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|,
operator|&
name|scratch_pathname
argument_list|)
expr_stmt|;
if|if
condition|(
name|scratch_chan
operator|<
literal|0
condition|)
block|{
name|scratch_chan
operator|=
name|openp
argument_list|(
name|getenv
argument_list|(
literal|"LD_LIBRARY_PATH"
argument_list|)
argument_list|,
literal|1
argument_list|,
name|filename
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|,
operator|&
name|scratch_pathname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|scratch_chan
operator|<
literal|0
condition|)
block|{
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
comment|/* Leave scratch_pathname allocated.  abfd->name will point to it.  */
name|abfd
operator|=
name|bfd_fdopenr
argument_list|(
name|scratch_pathname
argument_list|,
name|gnutarget
argument_list|,
name|scratch_chan
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|abfd
condition|)
block|{
name|close
argument_list|(
name|scratch_chan
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Could not open `%s' as an executable file: %s"
argument_list|,
name|scratch_pathname
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Leave bfd open, core_xfer_memory and "info files" need it.  */
name|so
operator|->
name|abfd
operator|=
name|abfd
expr_stmt|;
name|abfd
operator|->
name|cacheable
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_check_format
argument_list|(
name|abfd
argument_list|,
name|bfd_object
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"\"%s\": not in executable format: %s."
argument_list|,
name|scratch_pathname
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|build_section_table
argument_list|(
name|abfd
argument_list|,
operator|&
name|so
operator|->
name|sections
argument_list|,
operator|&
name|so
operator|->
name|sections_end
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"Can't find the file sections in `%s': %s"
argument_list|,
name|bfd_get_filename
argument_list|(
name|exec_bfd
argument_list|)
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|p
operator|=
name|so
operator|->
name|sections
init|;
name|p
operator|<
name|so
operator|->
name|sections_end
condition|;
name|p
operator|++
control|)
block|{
comment|/* Relocate the section binding addresses as recorded in the shared 	 object's file by the offset to get the address to which the 	 object was actually mapped.  */
name|p
operator|->
name|addr
operator|+=
name|LM_OFFSET
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|p
operator|->
name|endaddr
operator|+=
name|LM_OFFSET
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|so
operator|->
name|lmend
operator|=
operator|(
name|CORE_ADDR
operator|)
name|max
argument_list|(
name|p
operator|->
name|endaddr
argument_list|,
name|so
operator|->
name|lmend
argument_list|)
expr_stmt|;
if|if
condition|(
name|STREQ
argument_list|(
name|p
operator|->
name|the_bfd_section
operator|->
name|name
argument_list|,
literal|".text"
argument_list|)
condition|)
block|{
name|so
operator|->
name|textsection
operator|=
name|p
expr_stmt|;
block|}
block|}
comment|/* Free the file names, close the file now.  */
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	locate_base -- locate the base address of dynamic linker structs  SYNOPSIS  	CORE_ADDR locate_base (void)  DESCRIPTION  	For both the SunOS and SVR4 shared library implementations, if the 	inferior executable has been linked dynamically, there is a single 	address somewhere in the inferior's data space which is the key to 	locating all of the dynamic linker's runtime structures.  This 	address is the value of the symbol defined by the macro DEBUG_BASE. 	The job of this function is to find and return that address, or to 	return 0 if there is no such address (the executable is statically 	linked for example).  	For SunOS, the job is almost trivial, since the dynamic linker and 	all of it's structures are statically linked to the executable at 	link time.  Thus the symbol for the address we are looking for has 	already been added to the minimal symbol table for the executable's 	objfile at the time the symbol file's symbols were read, and all we 	have to do is look it up there.  Note that we explicitly do NOT want 	to find the copies in the shared library.  	The SVR4 version is much more complicated because the dynamic linker 	and it's structures are located in the shared C library, which gets 	run as the executable's "interpreter" by the kernel.  We have to go 	to a lot more work to discover the address of DEBUG_BASE.  Because 	of this complexity, we cache the value we find and return that value 	on subsequent invocations.  Note there is no copy in the executable 	symbol tables.  	Irix 5 is basically like SunOS.  	Note that we can assume nothing about the process state at the time 	we need to find this address.  We may be stopped on the first instruc- 	tion of the interpreter (C shared library), the first instruction of 	the executable itself, or somewhere else entirely (if we attached 	to the process for example).   */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|locate_base
parameter_list|()
block|{
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
name|CORE_ADDR
name|address
init|=
literal|0
decl_stmt|;
name|msymbol
operator|=
name|lookup_minimal_symbol
argument_list|(
name|DEBUG_BASE
argument_list|,
name|NULL
argument_list|,
name|symfile_objfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|msymbol
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|address
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|address
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	first_link_map_member -- locate first member in dynamic linker's map  SYNOPSIS  	static struct link_map *first_link_map_member (void)  DESCRIPTION  	Read in a copy of the first member in the inferior's dynamic 	link map from the inferior's dynamic linker structures, and return 	a pointer to the link map descriptor. */
end_comment

begin_function
specifier|static
name|struct
name|link_map
modifier|*
name|first_link_map_member
parameter_list|()
block|{
name|struct
name|obj_list
modifier|*
name|listp
decl_stmt|;
name|struct
name|obj_list
name|list_old
decl_stmt|;
name|struct
name|link_map
modifier|*
name|lm
decl_stmt|;
specifier|static
name|struct
name|link_map
name|first_lm
decl_stmt|;
name|CORE_ADDR
name|lladdr
decl_stmt|;
name|CORE_ADDR
name|next_lladdr
decl_stmt|;
comment|/* We have not already read in the dynamic linking structures      from the inferior, lookup the address of the base structure. */
name|debug_base
operator|=
name|locate_base
argument_list|()
expr_stmt|;
if|if
condition|(
name|debug_base
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
comment|/* Get address of first list entry.  */
name|read_memory
argument_list|(
name|debug_base
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|listp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|obj_list
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|listp
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* Get first list entry.  */
name|lladdr
operator|=
operator|(
name|CORE_ADDR
operator|)
name|listp
expr_stmt|;
name|read_memory
argument_list|(
name|lladdr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|list_old
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|obj_list
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The first entry in the list is the object file we are debugging,      so skip it.  */
name|next_lladdr
operator|=
operator|(
name|CORE_ADDR
operator|)
name|list_old
operator|.
name|next
expr_stmt|;
ifdef|#
directive|ifdef
name|HANDLE_NEW_OBJ_LIST
if|if
condition|(
name|list_old
operator|.
name|data
operator|==
name|NEW_OBJ_INFO_MAGIC
condition|)
block|{
name|Elf32_Obj_Info
name|list_32
decl_stmt|;
name|read_memory
argument_list|(
name|lladdr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|list_32
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf32_Obj_Info
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|list_32
operator|.
name|oi_size
operator|!=
sizeof|sizeof
argument_list|(
name|Elf32_Obj_Info
argument_list|)
condition|)
return|return
name|NULL
return|;
name|next_lladdr
operator|=
operator|(
name|CORE_ADDR
operator|)
name|list_32
operator|.
name|oi_next
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|next_lladdr
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
name|first_lm
operator|.
name|l_lladdr
operator|=
name|next_lladdr
expr_stmt|;
name|lm
operator|=
operator|&
name|first_lm
expr_stmt|;
return|return
name|lm
return|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	next_link_map_member -- locate next member in dynamic linker's map  SYNOPSIS  	static struct link_map *next_link_map_member (so_list_ptr)  DESCRIPTION  	Read in a copy of the next member in the inferior's dynamic 	link map from the inferior's dynamic linker structures, and return 	a pointer to the link map descriptor. */
end_comment

begin_function
specifier|static
name|struct
name|link_map
modifier|*
name|next_link_map_member
parameter_list|(
name|so_list_ptr
parameter_list|)
name|struct
name|so_list
modifier|*
name|so_list_ptr
decl_stmt|;
block|{
name|struct
name|link_map
modifier|*
name|lm
init|=
operator|&
name|so_list_ptr
operator|->
name|lm
decl_stmt|;
name|CORE_ADDR
name|next_lladdr
init|=
name|lm
operator|->
name|l_next
decl_stmt|;
specifier|static
name|struct
name|link_map
name|next_lm
decl_stmt|;
if|if
condition|(
name|next_lladdr
operator|==
literal|0
condition|)
block|{
comment|/* We have hit the end of the list, so check to see if any were 	 added, but be quiet if we can't read from the target any more. */
name|int
name|status
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|lm
operator|->
name|l_variant
operator|==
name|OBJ_LIST_OLD
condition|)
block|{
name|struct
name|obj_list
name|list_old
decl_stmt|;
name|status
operator|=
name|target_read_memory
argument_list|(
name|lm
operator|->
name|l_lladdr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|list_old
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|obj_list
argument_list|)
argument_list|)
expr_stmt|;
name|next_lladdr
operator|=
operator|(
name|CORE_ADDR
operator|)
name|list_old
operator|.
name|next
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HANDLE_NEW_OBJ_LIST
elseif|else
if|if
condition|(
name|lm
operator|->
name|l_variant
operator|==
name|OBJ_LIST_32
condition|)
block|{
name|Elf32_Obj_Info
name|list_32
decl_stmt|;
name|status
operator|=
name|target_read_memory
argument_list|(
name|lm
operator|->
name|l_lladdr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|list_32
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf32_Obj_Info
argument_list|)
argument_list|)
expr_stmt|;
name|next_lladdr
operator|=
operator|(
name|CORE_ADDR
operator|)
name|list_32
operator|.
name|oi_next
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|status
operator|!=
literal|0
operator|||
name|next_lladdr
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
block|}
name|next_lm
operator|.
name|l_lladdr
operator|=
name|next_lladdr
expr_stmt|;
name|lm
operator|=
operator|&
name|next_lm
expr_stmt|;
return|return
name|lm
return|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	xfer_link_map_member -- set local variables from dynamic linker's map  SYNOPSIS  	static void xfer_link_map_member (so_list_ptr, lm)  DESCRIPTION  	Read in a copy of the requested member in the inferior's dynamic 	link map from the inferior's dynamic linker structures, and fill 	in the necessary so_list_ptr elements. */
end_comment

begin_function
specifier|static
name|void
name|xfer_link_map_member
parameter_list|(
name|so_list_ptr
parameter_list|,
name|lm
parameter_list|)
name|struct
name|so_list
modifier|*
name|so_list_ptr
decl_stmt|;
name|struct
name|link_map
modifier|*
name|lm
decl_stmt|;
block|{
name|struct
name|obj_list
name|list_old
decl_stmt|;
name|CORE_ADDR
name|lladdr
init|=
name|lm
operator|->
name|l_lladdr
decl_stmt|;
name|struct
name|link_map
modifier|*
name|new_lm
init|=
operator|&
name|so_list_ptr
operator|->
name|lm
decl_stmt|;
name|int
name|errcode
decl_stmt|;
name|read_memory
argument_list|(
name|lladdr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|list_old
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|obj_list
argument_list|)
argument_list|)
expr_stmt|;
name|new_lm
operator|->
name|l_variant
operator|=
name|OBJ_LIST_OLD
expr_stmt|;
name|new_lm
operator|->
name|l_lladdr
operator|=
name|lladdr
expr_stmt|;
name|new_lm
operator|->
name|l_next
operator|=
operator|(
name|CORE_ADDR
operator|)
name|list_old
operator|.
name|next
expr_stmt|;
ifdef|#
directive|ifdef
name|HANDLE_NEW_OBJ_LIST
if|if
condition|(
name|list_old
operator|.
name|data
operator|==
name|NEW_OBJ_INFO_MAGIC
condition|)
block|{
name|Elf32_Obj_Info
name|list_32
decl_stmt|;
name|read_memory
argument_list|(
name|lladdr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|list_32
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf32_Obj_Info
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|list_32
operator|.
name|oi_size
operator|!=
sizeof|sizeof
argument_list|(
name|Elf32_Obj_Info
argument_list|)
condition|)
return|return;
name|new_lm
operator|->
name|l_variant
operator|=
name|OBJ_LIST_32
expr_stmt|;
name|new_lm
operator|->
name|l_next
operator|=
operator|(
name|CORE_ADDR
operator|)
name|list_32
operator|.
name|oi_next
expr_stmt|;
name|target_read_string
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|list_32
operator|.
name|oi_pathname
argument_list|,
operator|&
name|so_list_ptr
operator|->
name|so_name
argument_list|,
name|list_32
operator|.
name|oi_pathname_len
operator|+
literal|1
argument_list|,
operator|&
name|errcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|errcode
operator|!=
literal|0
condition|)
name|memory_error
argument_list|(
name|errcode
argument_list|,
operator|(
name|CORE_ADDR
operator|)
name|list_32
operator|.
name|oi_pathname
argument_list|)
expr_stmt|;
name|LM_ADDR
argument_list|(
name|so_list_ptr
argument_list|)
operator|=
operator|(
name|CORE_ADDR
operator|)
name|list_32
operator|.
name|oi_ehdr
expr_stmt|;
name|LM_OFFSET
argument_list|(
name|so_list_ptr
argument_list|)
operator|=
operator|(
name|CORE_ADDR
operator|)
name|list_32
operator|.
name|oi_ehdr
operator|-
operator|(
name|CORE_ADDR
operator|)
name|list_32
operator|.
name|oi_orig_ehdr
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
if|#
directive|if
name|defined
argument_list|(
name|_MIPS_SIM_NABI32
argument_list|)
operator|&&
name|_MIPS_SIM
operator|==
name|_MIPS_SIM_NABI32
comment|/* If we are compiling GDB under N32 ABI, the alignments in 	 the obj struct are different from the O32 ABI and we will get 	 wrong values when accessing the struct. 	 As a workaround we use fixed values which are good for 	 Irix 6.2.  */
name|char
name|buf
index|[
literal|432
index|]
decl_stmt|;
name|read_memory
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|list_old
operator|.
name|data
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|target_read_string
argument_list|(
name|extract_address
argument_list|(
operator|&
name|buf
index|[
literal|236
index|]
argument_list|,
literal|4
argument_list|)
argument_list|,
operator|&
name|so_list_ptr
operator|->
name|so_name
argument_list|,
name|INT_MAX
argument_list|,
operator|&
name|errcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|errcode
operator|!=
literal|0
condition|)
name|memory_error
argument_list|(
name|errcode
argument_list|,
name|extract_address
argument_list|(
operator|&
name|buf
index|[
literal|236
index|]
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|LM_ADDR
argument_list|(
name|so_list_ptr
argument_list|)
operator|=
name|extract_address
argument_list|(
operator|&
name|buf
index|[
literal|196
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|LM_OFFSET
argument_list|(
name|so_list_ptr
argument_list|)
operator|=
name|extract_address
argument_list|(
operator|&
name|buf
index|[
literal|196
index|]
argument_list|,
literal|4
argument_list|)
operator|-
name|extract_address
argument_list|(
operator|&
name|buf
index|[
literal|248
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
else|#
directive|else
name|struct
name|obj
name|obj_old
decl_stmt|;
name|read_memory
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|list_old
operator|.
name|data
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|obj_old
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|obj
argument_list|)
argument_list|)
expr_stmt|;
name|target_read_string
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|obj_old
operator|.
name|o_path
argument_list|,
operator|&
name|so_list_ptr
operator|->
name|so_name
argument_list|,
name|INT_MAX
argument_list|,
operator|&
name|errcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|errcode
operator|!=
literal|0
condition|)
name|memory_error
argument_list|(
name|errcode
argument_list|,
operator|(
name|CORE_ADDR
operator|)
name|obj_old
operator|.
name|o_path
argument_list|)
expr_stmt|;
name|LM_ADDR
argument_list|(
name|so_list_ptr
argument_list|)
operator|=
operator|(
name|CORE_ADDR
operator|)
name|obj_old
operator|.
name|o_praw
expr_stmt|;
name|LM_OFFSET
argument_list|(
name|so_list_ptr
argument_list|)
operator|=
operator|(
name|CORE_ADDR
operator|)
name|obj_old
operator|.
name|o_praw
operator|-
name|obj_old
operator|.
name|o_base_address
expr_stmt|;
endif|#
directive|endif
block|}
name|catch_errors
argument_list|(
name|solib_map_sections
argument_list|,
operator|(
name|char
operator|*
operator|)
name|so_list_ptr
argument_list|,
literal|"Error while mapping shared library sections:\n"
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	find_solib -- step through list of shared objects  SYNOPSIS  	struct so_list *find_solib (struct so_list *so_list_ptr)  DESCRIPTION  	This module contains the routine which finds the names of any 	loaded "images" in the current process. The argument in must be 	NULL on the first call, and then the returned value must be passed 	in on subsequent calls. This provides the capability to "step" down 	the list of loaded objects. On the last object, a NULL value is 	returned.  */
end_comment

begin_function
specifier|static
name|struct
name|so_list
modifier|*
name|find_solib
parameter_list|(
name|so_list_ptr
parameter_list|)
name|struct
name|so_list
modifier|*
name|so_list_ptr
decl_stmt|;
comment|/* Last lm or NULL for first one */
block|{
name|struct
name|so_list
modifier|*
name|so_list_next
init|=
name|NULL
decl_stmt|;
name|struct
name|link_map
modifier|*
name|lm
init|=
name|NULL
decl_stmt|;
name|struct
name|so_list
modifier|*
name|new
decl_stmt|;
if|if
condition|(
name|so_list_ptr
operator|==
name|NULL
condition|)
block|{
comment|/* We are setting up for a new scan through the loaded images. */
if|if
condition|(
operator|(
name|so_list_next
operator|=
name|so_list_head
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* Find the first link map list member. */
name|lm
operator|=
name|first_link_map_member
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* We have been called before, and are in the process of walking 	 the shared library list.  Advance to the next shared object. */
name|lm
operator|=
name|next_link_map_member
argument_list|(
name|so_list_ptr
argument_list|)
expr_stmt|;
name|so_list_next
operator|=
name|so_list_ptr
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|so_list_next
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|lm
operator|!=
name|NULL
operator|)
condition|)
block|{
name|new
operator|=
operator|(
expr|struct
name|so_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|so_list
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|new
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|so_list
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Add the new node as the next node in the list, or as the root 	 node if this is the first one. */
if|if
condition|(
name|so_list_ptr
operator|!=
name|NULL
condition|)
block|{
name|so_list_ptr
operator|->
name|next
operator|=
name|new
expr_stmt|;
block|}
else|else
block|{
name|so_list_head
operator|=
name|new
expr_stmt|;
block|}
name|so_list_next
operator|=
name|new
expr_stmt|;
name|xfer_link_map_member
argument_list|(
name|new
argument_list|,
name|lm
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|so_list_next
operator|)
return|;
block|}
end_function

begin_comment
comment|/* A small stub to get us past the arg-passing pinhole of catch_errors.  */
end_comment

begin_function
specifier|static
name|int
name|symbol_add_stub
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
specifier|register
name|struct
name|so_list
modifier|*
name|so
init|=
operator|(
expr|struct
name|so_list
operator|*
operator|)
name|arg
decl_stmt|;
comment|/* catch_errs bogon */
name|CORE_ADDR
name|text_addr
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|so
operator|->
name|textsection
condition|)
name|text_addr
operator|=
name|so
operator|->
name|textsection
operator|->
name|addr
expr_stmt|;
elseif|else
if|if
condition|(
name|so
operator|->
name|abfd
operator|!=
name|NULL
condition|)
block|{
name|asection
modifier|*
name|lowest_sect
decl_stmt|;
comment|/* If we didn't find a mapped non zero sized .text section, set up 	 text_addr so that the relocation in symbol_file_add does no harm.  */
name|lowest_sect
operator|=
name|bfd_get_section_by_name
argument_list|(
name|so
operator|->
name|abfd
argument_list|,
literal|".text"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lowest_sect
operator|==
name|NULL
condition|)
name|bfd_map_over_sections
argument_list|(
name|so
operator|->
name|abfd
argument_list|,
name|find_lowest_section
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|lowest_sect
argument_list|)
expr_stmt|;
if|if
condition|(
name|lowest_sect
condition|)
name|text_addr
operator|=
name|bfd_section_vma
argument_list|(
name|so
operator|->
name|abfd
argument_list|,
name|lowest_sect
argument_list|)
operator|+
name|LM_OFFSET
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
name|so
operator|->
name|objfile
operator|=
name|symbol_file_add
argument_list|(
name|so
operator|->
name|so_name
argument_list|,
name|so
operator|->
name|from_tty
argument_list|,
name|text_addr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  GLOBAL FUNCTION  	solib_add -- add a shared library file to the symtab and section list  SYNOPSIS  	void solib_add (char *arg_string, int from_tty, 			struct target_ops *target)  DESCRIPTION  */
end_comment

begin_function
name|void
name|solib_add
parameter_list|(
name|arg_string
parameter_list|,
name|from_tty
parameter_list|,
name|target
parameter_list|)
name|char
modifier|*
name|arg_string
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
name|struct
name|target_ops
modifier|*
name|target
decl_stmt|;
block|{
specifier|register
name|struct
name|so_list
modifier|*
name|so
init|=
name|NULL
decl_stmt|;
comment|/* link map state variable */
comment|/* Last shared library that we read.  */
name|struct
name|so_list
modifier|*
name|so_last
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|re_err
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|old
decl_stmt|;
if|if
condition|(
operator|(
name|re_err
operator|=
name|re_comp
argument_list|(
name|arg_string
condition|?
name|arg_string
else|:
literal|"."
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"Invalid regexp: %s"
argument_list|,
name|re_err
argument_list|)
expr_stmt|;
block|}
comment|/* Add the shared library sections to the section table of the      specified target, if any.  */
if|if
condition|(
name|target
condition|)
block|{
comment|/* Count how many new section_table entries there are.  */
name|so
operator|=
name|NULL
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|so
operator|=
name|find_solib
argument_list|(
name|so
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|so
operator|->
name|so_name
index|[
literal|0
index|]
condition|)
block|{
name|count
operator|+=
name|so
operator|->
name|sections_end
operator|-
name|so
operator|->
name|sections
expr_stmt|;
block|}
block|}
if|if
condition|(
name|count
condition|)
block|{
name|int
name|update_coreops
decl_stmt|;
comment|/* We must update the to_sections field in the core_ops structure 	     here, otherwise we dereference a potential dangling pointer 	     for each call to target_read/write_memory within this routine.  */
name|update_coreops
operator|=
name|core_ops
operator|.
name|to_sections
operator|==
name|target
operator|->
name|to_sections
expr_stmt|;
comment|/* Reallocate the target's section table including the new size.  */
if|if
condition|(
name|target
operator|->
name|to_sections
condition|)
block|{
name|old
operator|=
name|target
operator|->
name|to_sections_end
operator|-
name|target
operator|->
name|to_sections
expr_stmt|;
name|target
operator|->
name|to_sections
operator|=
operator|(
expr|struct
name|section_table
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|target
operator|->
name|to_sections
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|section_table
argument_list|)
operator|)
operator|*
operator|(
name|count
operator|+
name|old
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|old
operator|=
literal|0
expr_stmt|;
name|target
operator|->
name|to_sections
operator|=
operator|(
expr|struct
name|section_table
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|section_table
argument_list|)
operator|)
operator|*
name|count
argument_list|)
expr_stmt|;
block|}
name|target
operator|->
name|to_sections_end
operator|=
name|target
operator|->
name|to_sections
operator|+
operator|(
name|count
operator|+
name|old
operator|)
expr_stmt|;
comment|/* Update the to_sections field in the core_ops structure 	     if needed.  */
if|if
condition|(
name|update_coreops
condition|)
block|{
name|core_ops
operator|.
name|to_sections
operator|=
name|target
operator|->
name|to_sections
expr_stmt|;
name|core_ops
operator|.
name|to_sections_end
operator|=
name|target
operator|->
name|to_sections_end
expr_stmt|;
block|}
comment|/* Add these section table entries to the target's table.  */
while|while
condition|(
operator|(
name|so
operator|=
name|find_solib
argument_list|(
name|so
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|so
operator|->
name|so_name
index|[
literal|0
index|]
condition|)
block|{
name|count
operator|=
name|so
operator|->
name|sections_end
operator|-
name|so
operator|->
name|sections
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|target
operator|->
name|to_sections
operator|+
name|old
operator|)
argument_list|,
name|so
operator|->
name|sections
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|section_table
argument_list|)
operator|)
operator|*
name|count
argument_list|)
expr_stmt|;
name|old
operator|+=
name|count
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Now add the symbol files.  */
while|while
condition|(
operator|(
name|so
operator|=
name|find_solib
argument_list|(
name|so
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|so
operator|->
name|so_name
index|[
literal|0
index|]
operator|&&
name|re_exec
argument_list|(
name|so
operator|->
name|so_name
argument_list|)
condition|)
block|{
name|so
operator|->
name|from_tty
operator|=
name|from_tty
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|symbols_loaded
condition|)
block|{
if|if
condition|(
name|from_tty
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"Symbols already loaded for %s\n"
argument_list|,
name|so
operator|->
name|so_name
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|catch_errors
argument_list|(
name|symbol_add_stub
argument_list|,
operator|(
name|char
operator|*
operator|)
name|so
argument_list|,
literal|"Error while reading shared library symbols:\n"
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
condition|)
block|{
name|so_last
operator|=
name|so
expr_stmt|;
name|so
operator|->
name|symbols_loaded
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/* Getting new symbols may change our opinion about what is      frameless.  */
if|if
condition|(
name|so_last
condition|)
name|reinit_frame_cache
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	info_sharedlibrary_command -- code for "info sharedlibrary"  SYNOPSIS  	static void info_sharedlibrary_command ()  DESCRIPTION  	Walk through the shared library list and print information 	about each attached library. */
end_comment

begin_function
specifier|static
name|void
name|info_sharedlibrary_command
parameter_list|(
name|ignore
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|ignore
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
specifier|register
name|struct
name|so_list
modifier|*
name|so
init|=
name|NULL
decl_stmt|;
comment|/* link map state variable */
name|int
name|header_done
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|exec_bfd
operator|==
name|NULL
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"No exec file.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
operator|(
name|so
operator|=
name|find_solib
argument_list|(
name|so
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|so
operator|->
name|so_name
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
operator|!
name|header_done
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"%-12s%-12s%-12s%s\n"
argument_list|,
literal|"From"
argument_list|,
literal|"To"
argument_list|,
literal|"Syms Read"
argument_list|,
literal|"Shared Object Library"
argument_list|)
expr_stmt|;
name|header_done
operator|++
expr_stmt|;
block|}
name|printf_unfiltered
argument_list|(
literal|"%-12s"
argument_list|,
name|local_hex_string_custom
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|LM_ADDR
argument_list|(
name|so
argument_list|)
argument_list|,
literal|"08l"
argument_list|)
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"%-12s"
argument_list|,
name|local_hex_string_custom
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|so
operator|->
name|lmend
argument_list|,
literal|"08l"
argument_list|)
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"%-12s"
argument_list|,
name|so
operator|->
name|symbols_loaded
condition|?
literal|"Yes"
else|:
literal|"No"
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"%s\n"
argument_list|,
name|so
operator|->
name|so_name
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|so_list_head
operator|==
name|NULL
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"No shared libraries loaded at this time.\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  GLOBAL FUNCTION  	solib_address -- check to see if an address is in a shared lib  SYNOPSIS  	char *solib_address (CORE_ADDR address)  DESCRIPTION  	Provides a hook for other gdb routines to discover whether or 	not a particular address is within the mapped address space of 	a shared library.  Any address between the base mapping address 	and the first address beyond the end of the last mapping, is 	considered to be within the shared library address space, for 	our purposes.  	For example, this routine is called at one point to disable 	breakpoints which are in shared libraries that are not currently 	mapped in.  */
end_comment

begin_function
name|char
modifier|*
name|solib_address
parameter_list|(
name|address
parameter_list|)
name|CORE_ADDR
name|address
decl_stmt|;
block|{
specifier|register
name|struct
name|so_list
modifier|*
name|so
init|=
literal|0
decl_stmt|;
comment|/* link map state variable */
while|while
condition|(
operator|(
name|so
operator|=
name|find_solib
argument_list|(
name|so
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|so
operator|->
name|so_name
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
operator|(
name|address
operator|>=
operator|(
name|CORE_ADDR
operator|)
name|LM_ADDR
argument_list|(
name|so
argument_list|)
operator|)
operator|&&
operator|(
name|address
operator|<
operator|(
name|CORE_ADDR
operator|)
name|so
operator|->
name|lmend
operator|)
condition|)
return|return
operator|(
name|so
operator|->
name|so_name
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Called by free_all_symtabs */
end_comment

begin_function
name|void
name|clear_solib
parameter_list|()
block|{
name|struct
name|so_list
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|bfd_filename
decl_stmt|;
name|disable_breakpoints_in_shlibs
argument_list|(
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|so_list_head
condition|)
block|{
if|if
condition|(
name|so_list_head
operator|->
name|sections
condition|)
block|{
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|so_list_head
operator|->
name|sections
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|so_list_head
operator|->
name|abfd
condition|)
block|{
name|bfd_filename
operator|=
name|bfd_get_filename
argument_list|(
name|so_list_head
operator|->
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_close
argument_list|(
name|so_list_head
operator|->
name|abfd
argument_list|)
condition|)
name|warning
argument_list|(
literal|"cannot close \"%s\": %s"
argument_list|,
name|bfd_filename
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* This happens for the executable on SVR4.  */
name|bfd_filename
operator|=
name|NULL
expr_stmt|;
name|next
operator|=
name|so_list_head
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|bfd_filename
condition|)
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|bfd_filename
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|so_list_head
operator|->
name|so_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|so_list_head
argument_list|)
expr_stmt|;
name|so_list_head
operator|=
name|next
expr_stmt|;
block|}
name|debug_base
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	disable_break -- remove the "mapping changed" breakpoint  SYNOPSIS  	static int disable_break ()  DESCRIPTION  	Removes the breakpoint that gets hit when the dynamic linker 	completes a mapping change.  */
end_comment

begin_function
specifier|static
name|int
name|disable_break
parameter_list|()
block|{
name|int
name|status
init|=
literal|1
decl_stmt|;
comment|/* Note that breakpoint address and original contents are in our address      space, so we just need to write the original contents back. */
if|if
condition|(
name|memory_remove_breakpoint
argument_list|(
name|breakpoint_addr
argument_list|,
name|shadow_contents
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|status
operator|=
literal|0
expr_stmt|;
block|}
comment|/* For the SVR4 version, we always know the breakpoint address.  For the      SunOS version we don't know it until the above code is executed.      Grumble if we are stopped anywhere besides the breakpoint address. */
if|if
condition|(
name|stop_pc
operator|!=
name|breakpoint_addr
condition|)
block|{
name|warning
argument_list|(
literal|"stopped at unknown breakpoint while handling shared libraries"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	enable_break -- arrange for dynamic linker to hit breakpoint  SYNOPSIS  	int enable_break (void)  DESCRIPTION  	This functions inserts a breakpoint at the entry point of the 	main executable, where all shared libraries are mapped in. */
end_comment

begin_function
specifier|static
name|int
name|enable_break
parameter_list|()
block|{
if|if
condition|(
name|symfile_objfile
operator|!=
name|NULL
operator|&&
name|target_insert_breakpoint
argument_list|(
name|symfile_objfile
operator|->
name|ei
operator|.
name|entry_point
argument_list|,
name|shadow_contents
argument_list|)
operator|==
literal|0
condition|)
block|{
name|breakpoint_addr
operator|=
name|symfile_objfile
operator|->
name|ei
operator|.
name|entry_point
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*    GLOBAL FUNCTION    	solib_create_inferior_hook -- shared library startup support    SYNOPSIS    	void solib_create_inferior_hook()    DESCRIPTION    	When gdb starts up the inferior, it nurses it along (through the 	shell) until it is ready to execute it's first instruction.  At this 	point, this function gets called via expansion of the macro 	SOLIB_CREATE_INFERIOR_HOOK.  	For SunOS executables, this first instruction is typically the 	one at "_start", or a similar text label, regardless of whether 	the executable is statically or dynamically linked.  The runtime 	startup code takes care of dynamically linking in any shared 	libraries, once gdb allows the inferior to continue.  	For SVR4 executables, this first instruction is either the first 	instruction in the dynamic linker (for dynamically linked 	executables) or the instruction at "start" for statically linked 	executables.  For dynamically linked executables, the system 	first exec's /lib/libc.so.N, which contains the dynamic linker, 	and starts it running.  The dynamic linker maps in any needed 	shared libraries, maps in the actual user executable, and then 	jumps to "start" in the user executable.  	For both SunOS shared libraries, and SVR4 shared libraries, we 	can arrange to cooperate with the dynamic linker to discover the 	names of shared libraries that are dynamically linked, and the 	base addresses to which they are linked.  	This function is responsible for discovering those names and 	addresses, and saving sufficient information about them to allow 	their symbols to be read at a later time.  FIXME  	Between enable_break() and disable_break(), this code does not 	properly handle hitting breakpoints which the user might have 	set in the startup code or in the dynamic linker itself.  Proper 	handling will probably have to wait until the implementation is 	changed to use the "breakpoint handler function" method.  	Also, what if child has exit()ed?  Must exit loop somehow.   */
end_comment

begin_function
name|void
name|solib_create_inferior_hook
parameter_list|()
block|{
if|if
condition|(
operator|!
name|enable_break
argument_list|()
condition|)
block|{
name|warning
argument_list|(
literal|"shared library handler failed to enable breakpoint"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Now run the target.  It will eventually hit the breakpoint, at      which point all of the libraries will have been mapped in and we      can go groveling around in the dynamic linker structures to find      out what we need to know about them. */
name|clear_proceed_status
argument_list|()
expr_stmt|;
name|stop_soon_quietly
operator|=
literal|1
expr_stmt|;
name|stop_signal
operator|=
name|TARGET_SIGNAL_0
expr_stmt|;
do|do
block|{
name|target_resume
argument_list|(
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|stop_signal
argument_list|)
expr_stmt|;
name|wait_for_inferior
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|stop_signal
operator|!=
name|TARGET_SIGNAL_TRAP
condition|)
do|;
comment|/* We are now either at the "mapping complete" breakpoint (or somewhere      else, a condition we aren't prepared to deal with anyway), so adjust      the PC as necessary after a breakpoint, disable the breakpoint, and      add any shared libraries that were mapped in. */
if|if
condition|(
name|DECR_PC_AFTER_BREAK
condition|)
block|{
name|stop_pc
operator|-=
name|DECR_PC_AFTER_BREAK
expr_stmt|;
name|write_register
argument_list|(
name|PC_REGNUM
argument_list|,
name|stop_pc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|disable_break
argument_list|()
condition|)
block|{
name|warning
argument_list|(
literal|"shared library handler failed to disable breakpoint"
argument_list|)
expr_stmt|;
block|}
comment|/*  solib_add will call reinit_frame_cache.       But we are stopped in the startup code and we might not have symbols       for the startup code, so heuristic_proc_start could be called       and will put out an annoying warning.       Delaying the resetting of stop_soon_quietly until after symbol loading       suppresses the warning.  */
if|if
condition|(
name|auto_solib_add
condition|)
name|solib_add
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|target_ops
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|stop_soon_quietly
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	sharedlibrary_command -- handle command to explicitly add library  SYNOPSIS  	static void sharedlibrary_command (char *args, int from_tty)  DESCRIPTION  */
end_comment

begin_function
specifier|static
name|void
name|sharedlibrary_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|dont_repeat
argument_list|()
expr_stmt|;
name|solib_add
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|,
operator|(
expr|struct
name|target_ops
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_initialize_solib
parameter_list|()
block|{
name|add_com
argument_list|(
literal|"sharedlibrary"
argument_list|,
name|class_files
argument_list|,
name|sharedlibrary_command
argument_list|,
literal|"Load shared object library symbols for files matching REGEXP."
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"sharedlibrary"
argument_list|,
name|info_sharedlibrary_command
argument_list|,
literal|"Status of loaded shared object libraries."
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"auto-solib-add"
argument_list|,
name|class_support
argument_list|,
name|var_zinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|auto_solib_add
argument_list|,
literal|"Set autoloading of shared library symbols.\n\ If nonzero, symbols from all shared object libraries will be loaded\n\ automatically when the inferior begins execution or when the dynamic linker\n\ informs gdb that a new library has been loaded.  Otherwise, symbols\n\ must be loaded manually, using `sharedlibrary'."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Register that we are able to handle irix5 core file formats.    This really is bfd_target_unknown_flavour */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|core_fns
name|irix5_core_fns
init|=
block|{
name|bfd_target_unknown_flavour
block|,
name|fetch_core_registers
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|_initialize_core_irix5
parameter_list|()
block|{
name|add_core_fns
argument_list|(
operator|&
name|irix5_core_fns
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

