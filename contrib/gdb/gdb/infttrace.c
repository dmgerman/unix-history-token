begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Low level Unix child interface to ttrace, for GDB when running under HP-UX.    Copyright 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996    Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"wait.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_comment
comment|/* Some hackery to work around a use of the #define name NO_FLAGS  * in both gdb and HPUX (bfd.h and /usr/include/machine/vmparam.h).  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|NO_FLAGS
end_ifdef

begin_define
define|#
directive|define
name|INFTTRACE_TEMP_HACK
value|NO_FLAGS
end_define

begin_undef
undef|#
directive|undef
name|NO_FLAGS
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/ttrace.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|NO_PTRACE_H
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|PTRACE_IN_WRONG_PLACE
end_ifdef

begin_include
include|#
directive|include
file|<ptrace.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/ptrace.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NO_PTRACE_H */
end_comment

begin_comment
comment|/* Second half of the hackery above.  Non-ANSI C, so  * we can't use "#error", alas.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|NO_FLAGS
end_ifdef

begin_if
if|#
directive|if
operator|(
name|NO_FLAGS
operator|!=
name|INFTTRACE_TEMP_HACK
operator|)
end_if

begin_comment
comment|/* #error "Hackery to remove warning didn't work right" */
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Ok, new def'n of NO_FLAGS is same as old one; no action needed. */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* #error "Didn't get expected re-definition of NO_FLAGS" */
end_comment

begin_define
define|#
directive|define
name|NO_FLAGS
value|INFTTRACE_TEMP_HACK
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|PT_SETTRC
argument_list|)
end_if

begin_define
define|#
directive|define
name|PT_SETTRC
value|0
end_define

begin_comment
comment|/* Make process traceable by parent */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|PT_READ_I
argument_list|)
end_if

begin_define
define|#
directive|define
name|PT_READ_I
value|1
end_define

begin_comment
comment|/* Read word from text space */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|PT_READ_D
argument_list|)
end_if

begin_define
define|#
directive|define
name|PT_READ_D
value|2
end_define

begin_comment
comment|/* Read word from data space */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|PT_READ_U
argument_list|)
end_if

begin_define
define|#
directive|define
name|PT_READ_U
value|3
end_define

begin_comment
comment|/* Read word from kernel user struct */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|PT_WRITE_I
argument_list|)
end_if

begin_define
define|#
directive|define
name|PT_WRITE_I
value|4
end_define

begin_comment
comment|/* Write word to text space */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|PT_WRITE_D
argument_list|)
end_if

begin_define
define|#
directive|define
name|PT_WRITE_D
value|5
end_define

begin_comment
comment|/* Write word to data space */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|PT_WRITE_U
argument_list|)
end_if

begin_define
define|#
directive|define
name|PT_WRITE_U
value|6
end_define

begin_comment
comment|/* Write word to kernel user struct */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|PT_CONTINUE
argument_list|)
end_if

begin_define
define|#
directive|define
name|PT_CONTINUE
value|7
end_define

begin_comment
comment|/* Continue after signal */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|PT_STEP
argument_list|)
end_if

begin_define
define|#
directive|define
name|PT_STEP
value|9
end_define

begin_comment
comment|/* Set flag for single stepping */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|PT_KILL
argument_list|)
end_if

begin_define
define|#
directive|define
name|PT_KILL
value|8
end_define

begin_comment
comment|/* Send child a SIGKILL signal */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PT_ATTACH
end_ifndef

begin_define
define|#
directive|define
name|PT_ATTACH
value|PTRACE_ATTACH
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PT_DETACH
end_ifndef

begin_define
define|#
directive|define
name|PT_DETACH
value|PTRACE_DETACH
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|NO_SYS_FILE
end_ifndef

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This semaphore is used to coordinate the child and parent processes    after a fork(), and before an exec() by the child.  See parent_attach_all    for details.    */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|parent_channel
index|[
literal|2
index|]
decl_stmt|;
comment|/* Parent "talks" to [1], child "listens" to [0] */
name|int
name|child_channel
index|[
literal|2
index|]
decl_stmt|;
comment|/* Child "talks" to [1], parent "listens" to [0] */
block|}
name|startup_semaphore_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|SEM_TALK
value|(1)
end_define

begin_define
define|#
directive|define
name|SEM_LISTEN
value|(0)
end_define

begin_decl_stmt
specifier|static
name|startup_semaphore_t
name|startup_semaphore
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* See can_touch_threads_of_process for details. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|vforking_child_pid
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|vfork_in_flight
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* To support PREPARE_TO_PROCEED (hppa_prepare_to_proceed).  */
end_comment

begin_decl_stmt
specifier|static
name|pid_t
name|old_gdb_pid
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|pid_t
name|reported_pid
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reported_bpt
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 if ok as results of a ttrace or ttrace_wait call, 0 otherwise.  */
end_comment

begin_define
define|#
directive|define
name|TT_OK
parameter_list|(
name|_status
parameter_list|,
name|_errno
parameter_list|)
define|\
value|(((_status) == 1)&& ((_errno) == 0))
end_define

begin_define
define|#
directive|define
name|TTRACE_ARG_TYPE
value|uint64_t
end_define

begin_comment
comment|/* When supplied as the "addr" operand, ttrace interprets this    to mean, "from the current address".    */
end_comment

begin_define
define|#
directive|define
name|TT_USE_CURRENT_PC
value|((TTRACE_ARG_TYPE) TT_NOPC)
end_define

begin_comment
comment|/* When supplied as the "addr", "data" or "addr2" operand for most    requests, ttrace interprets this to mean, "pay no heed to this    argument".    */
end_comment

begin_define
define|#
directive|define
name|TT_NIL
value|((TTRACE_ARG_TYPE) TT_NULLARG)
end_define

begin_comment
comment|/* This is capable of holding the value of a 32-bit register.  The    value is always left-aligned in the buffer; i.e., [0] contains    the most-significant byte of the register's value, and [sizeof(reg)]    contains the least-significant value.     ??rehrauer: Yes, this assumes that an int is 32-bits on HP-UX, and    that registers are 32-bits on HP-UX.  The latter assumption changes    with PA2.0.    */
end_comment

begin_typedef
typedef|typedef
name|int
name|register_value_t
typedef|;
end_typedef

begin_comment
comment|/********************************************************************                   How this works:     1.  Thread numbers     The rest of GDB sees threads as being things with different    "pid" (process id) values.  See "thread.c" for details.  The    separate threads will be seen and reacted to if infttrace passes    back different pid values (for _events_).  See wait_for_inferior    in inftarg.c.     So infttrace is going to use thread ids externally, pretending    they are process ids, and keep track internally so that it can    use the real process id (and thread id) when calling ttrace.     The data structure that supports this is a linked list of the    current threads.  Since at some date infttrace will have to    deal with multiple processes, each list element records its    corresponding pid, rather than having a single global.     Note that the list is only approximately current; that's ok, as    it's up to date when we need it (we hope!).  Also, it can contain    dead threads, as there's no harm if it does.     The approach taken here is to bury the translation from external    to internal inside "call_ttrace" and a few other places.     There are some wrinkles:     o  When GDB forks itself to create the debug target process,       there's only a pid of 0 around in the child, so the       TT_PROC_SETTRC operation uses a more direct call to ttrace;       Similiarly, the initial setting of the event mask happens       early as  well, and so is also special-cased, and an attach       uses a real pid;     o  We define an unthreaded application as having a "pseudo"       thread;     o  To keep from confusing the rest of GDB, we don't switch       the PID for the pseudo thread to a TID.  A table will help:        Rest of GDB sees these PIDs:     pid   tid1  tid2  tid3 ...                                                Our thread list stores:          pid   pid   pid   pid  ...                                        tid0  tid1  tid2  tid3              Ttrace sees these TIDS:          tid0  tid1  tid2  tid3 ...        Both pid and tid0 will map to tid0, as there are infttrace.c-internal       calls to ttrace using tid0.     2. Step and Continue     Since we're implementing the "stop the world" model, sub-model    "other threads run during step", we have some stuff to do:     o  User steps require continuing all threads other than the       one the user is stepping;     o  Internal debugger steps (such as over a breakpoint or watchpoint,       but not out of a library load thunk) require stepping only       the selected thread; this means that we have to report the       step finish on that thread, which can lead to complications;     o  When a thread is created, it is created running, rather       than stopped--so we have to stop it.     The OS doesn't guarantee the stopped thread list will be stable,    no does it guarantee where on the stopped thread list a thread    that is single-stepped will wind up: it's possible that it will    be off the list for a while, it's possible the step will complete    and it will be re-posted to the end...     This means we have to scan the stopped thread list, build up    a work-list, and then run down the work list; we can't do the    step/continue during the scan.     3. Buffering events     Then there's the issue of waiting for an event.  We do this by    noticing how many events are reported at the end of each wait.    From then on, we "fake" all resumes and steps, returning instantly,    and don't do another wait.  Once all pending events are reported,    we can really resume again.     To keep this hidden, all the routines which know about tids and    pids or real events and simulated ones are static (file-local).     This code can make lots of calls to ttrace, in particular it    can spin down the list of thread states more than once.  If this    becomes a performance hit, the spin could be done once and the    various "tsp" blocks saved, keeping all later spins in this    process.     The O/S doesn't promise to keep the list straight, and so we must    re-scan a lot.  By observation, it looks like a single-step/wait    puts the stepped thread at the end of the list but doesn't change    it otherwise.  **************************************************************** */
end_comment

begin_comment
comment|/* Uncomment these to turn on various debugging output */
end_comment

begin_comment
comment|/* #define THREAD_DEBUG */
end_comment

begin_comment
comment|/* #define WAIT_BUFFER_DEBUG */
end_comment

begin_comment
comment|/* #define PARANOIA */
end_comment

begin_define
define|#
directive|define
name|INFTTRACE_ALL_THREADS
value|(-1)
end_define

begin_define
define|#
directive|define
name|INFTTRACE_STEP
value|(1)
end_define

begin_define
define|#
directive|define
name|INFTTRACE_CONTINUE
value|(0)
end_define

begin_comment
comment|/* FIX: this is used in inftarg.c/child_wait, in a hack.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|not_same_real_pid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is used to count buffered events.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|more_events_left
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Process state.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
name|process_state_enum
block|{
name|STOPPED
block|,
name|FAKE_STEPPING
block|,
name|FAKE_CONTINUE
block|,
comment|/* For later use */
name|RUNNING
block|,
name|FORKING
block|,
name|VFORKING
block|}
name|process_state_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|process_state_t
name|process_state
init|=
name|STOPPED
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* User-specified stepping modality.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
name|stepping_mode_enum
block|{
name|DO_DEFAULT
block|,
comment|/* ...which is a continue! */
name|DO_STEP
block|,
name|DO_CONTINUE
block|}
name|stepping_mode_t
typedef|;
end_typedef

begin_comment
comment|/* Action to take on an attach, depends on  * what kind (user command, fork, vfork).  *  * At the moment, this is either:  *  * o  continue with a SIGTRAP signal, or  *  * o  leave stopped.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
name|attach_continue_enum
block|{
name|DO_ATTACH_CONTINUE
block|,
name|DONT_ATTACH_CONTINUE
block|}
name|attach_continue_t
typedef|;
end_typedef

begin_comment
comment|/* This flag is true if we are doing a step-over-bpt  * with buffered events.  We will have to be sure to  * report the right thread, as otherwise the spaghetti  * code in "infrun.c/wait_for_inferior" will get  * confused.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|doing_fake_step
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|lwpid_t
name|fake_step_tid
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/****************************************************  * Thread information structure routines and types. *  ****************************************************  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|thread_info_struct
block|{
name|int
name|am_pseudo
decl_stmt|;
comment|/* This is a pseudo-thread for the process. */
name|int
name|pid
decl_stmt|;
comment|/* Process ID */
name|lwpid_t
name|tid
decl_stmt|;
comment|/* Thread  ID */
name|int
name|handled
decl_stmt|;
comment|/* 1 if a buffered event was handled. */
name|int
name|seen
decl_stmt|;
comment|/* 1 if this thread was seen on a traverse. */
name|int
name|terminated
decl_stmt|;
comment|/* 1 if thread has terminated. */
name|int
name|have_signal
decl_stmt|;
comment|/* 1 if signal to be sent */
name|enum
name|target_signal
name|signal_value
decl_stmt|;
comment|/* Signal to send */
name|int
name|have_start
decl_stmt|;
comment|/* 1 if alternate starting address */
name|stepping_mode_t
name|stepping_mode
decl_stmt|;
comment|/* Whether to step or continue */
name|CORE_ADDR
name|start
decl_stmt|;
comment|/* Where to start */
name|int
name|have_state
decl_stmt|;
comment|/* 1 if the event state has been set */
name|ttstate_t
name|last_stop_state
decl_stmt|;
comment|/* The most recently-waited event for this thread. */
name|struct
name|thread_info_struct
modifier|*
name|next
decl_stmt|;
comment|/* All threads are linked via this field. */
name|struct
name|thread_info_struct
modifier|*
name|next_pseudo
decl_stmt|;
comment|/* All pseudo-threads are linked via this field. */
block|}
name|thread_info
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|thread_info_header_struct
block|{
name|int
name|count
decl_stmt|;
name|thread_info
modifier|*
name|head
decl_stmt|;
name|thread_info
modifier|*
name|head_pseudo
decl_stmt|;
block|}
name|thread_info_header
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|thread_info_header
name|thread_head
init|=
block|{
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|thread_info_header
name|deleted_threads
init|=
block|{
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|saved_real_pid
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_escape
end_escape

begin_comment
comment|/*************************************************  *          Debugging support functions          *  *************************************************  */
end_comment

begin_function
name|CORE_ADDR
name|get_raw_pc
parameter_list|(
name|ttid
parameter_list|)
name|lwpid_t
name|ttid
decl_stmt|;
block|{
name|unsigned
name|long
name|pc_val
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|int
name|res
decl_stmt|;
name|offset
operator|=
name|register_addr
argument_list|(
name|PC_REGNUM
argument_list|,
name|U_REGS_OFFSET
argument_list|)
expr_stmt|;
name|res
operator|=
name|read_from_register_save_state
argument_list|(
name|ttid
argument_list|,
operator|(
name|TTRACE_ARG_TYPE
operator|)
name|offset
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pc_val
argument_list|,
sizeof|sizeof
argument_list|(
name|pc_val
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|<=
literal|0
condition|)
block|{
return|return
operator|(
name|CORE_ADDR
operator|)
name|pc_val
return|;
block|}
else|else
block|{
return|return
operator|(
name|CORE_ADDR
operator|)
literal|0
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|get_printable_name_of_stepping_mode
parameter_list|(
name|mode
parameter_list|)
name|stepping_mode_t
name|mode
decl_stmt|;
block|{
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|DO_DEFAULT
case|:
return|return
literal|"DO_DEFAULT"
return|;
case|case
name|DO_STEP
case|:
return|return
literal|"DO_STEP"
return|;
case|case
name|DO_CONTINUE
case|:
return|return
literal|"DO_CONTINUE"
return|;
default|default:
return|return
literal|"?unknown mode?"
return|;
block|}
block|}
end_function

begin_comment
comment|/* This function returns a pointer to a string describing the  * ttrace event being reported.  */
end_comment

begin_function
name|char
modifier|*
name|get_printable_name_of_ttrace_event
parameter_list|(
name|event
parameter_list|)
name|ttevents_t
name|event
decl_stmt|;
block|{
comment|/* This enumeration is "gappy", so don't use a table. */
switch|switch
condition|(
name|event
condition|)
block|{
case|case
name|TTEVT_NONE
case|:
return|return
literal|"TTEVT_NONE"
return|;
case|case
name|TTEVT_SIGNAL
case|:
return|return
literal|"TTEVT_SIGNAL"
return|;
case|case
name|TTEVT_FORK
case|:
return|return
literal|"TTEVT_FORK"
return|;
case|case
name|TTEVT_EXEC
case|:
return|return
literal|"TTEVT_EXEC"
return|;
case|case
name|TTEVT_EXIT
case|:
return|return
literal|"TTEVT_EXIT"
return|;
case|case
name|TTEVT_VFORK
case|:
return|return
literal|"TTEVT_VFORK"
return|;
case|case
name|TTEVT_SYSCALL_RETURN
case|:
return|return
literal|"TTEVT_SYSCALL_RETURN"
return|;
case|case
name|TTEVT_LWP_CREATE
case|:
return|return
literal|"TTEVT_LWP_CREATE"
return|;
case|case
name|TTEVT_LWP_TERMINATE
case|:
return|return
literal|"TTEVT_LWP_TERMINATE"
return|;
case|case
name|TTEVT_LWP_EXIT
case|:
return|return
literal|"TTEVT_LWP_EXIT"
return|;
case|case
name|TTEVT_LWP_ABORT_SYSCALL
case|:
return|return
literal|"TTEVT_LWP_ABORT_SYSCALL"
return|;
case|case
name|TTEVT_SYSCALL_ENTRY
case|:
return|return
literal|"TTEVT_SYSCALL_ENTRY"
return|;
case|case
name|TTEVT_SYSCALL_RESTART
case|:
return|return
literal|"TTEVT_SYSCALL_RESTART"
return|;
default|default :
return|return
literal|"?new event?"
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This function translates the ttrace request enumeration into  * a character string that is its printable (aka "human readable")  * name.  */
end_comment

begin_function
name|char
modifier|*
name|get_printable_name_of_ttrace_request
parameter_list|(
name|request
parameter_list|)
name|ttreq_t
name|request
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|IS_TTRACE_REQ
argument_list|(
name|request
argument_list|)
condition|)
return|return
literal|"?bad req?"
return|;
comment|/* This enumeration is "gappy", so don't use a table. */
switch|switch
condition|(
name|request
condition|)
block|{
case|case
name|TT_PROC_SETTRC
case|:
return|return
literal|"TT_PROC_SETTRC"
return|;
case|case
name|TT_PROC_ATTACH
case|:
return|return
literal|"TT_PROC_ATTACH"
return|;
case|case
name|TT_PROC_DETACH
case|:
return|return
literal|"TT_PROC_DETACH"
return|;
case|case
name|TT_PROC_RDTEXT
case|:
return|return
literal|"TT_PROC_RDTEXT"
return|;
case|case
name|TT_PROC_WRTEXT
case|:
return|return
literal|"TT_PROC_WRTEXT"
return|;
case|case
name|TT_PROC_RDDATA
case|:
return|return
literal|"TT_PROC_RDDATA"
return|;
case|case
name|TT_PROC_WRDATA
case|:
return|return
literal|"TT_PROC_WRDATA"
return|;
case|case
name|TT_PROC_STOP
case|:
return|return
literal|"TT_PROC_STOP"
return|;
case|case
name|TT_PROC_CONTINUE
case|:
return|return
literal|"TT_PROC_CONTINUE"
return|;
case|case
name|TT_PROC_GET_PATHNAME
case|:
return|return
literal|"TT_PROC_GET_PATHNAME"
return|;
case|case
name|TT_PROC_GET_EVENT_MASK
case|:
return|return
literal|"TT_PROC_GET_EVENT_MASK"
return|;
case|case
name|TT_PROC_SET_EVENT_MASK
case|:
return|return
literal|"TT_PROC_SET_EVENT_MASK"
return|;
case|case
name|TT_PROC_GET_FIRST_LWP_STATE
case|:
return|return
literal|"TT_PROC_GET_FIRST_LWP_STATE"
return|;
case|case
name|TT_PROC_GET_NEXT_LWP_STATE
case|:
return|return
literal|"TT_PROC_GET_NEXT_LWP_STATE"
return|;
case|case
name|TT_PROC_EXIT
case|:
return|return
literal|"TT_PROC_EXIT"
return|;
case|case
name|TT_PROC_GET_MPROTECT
case|:
return|return
literal|"TT_PROC_GET_MPROTECT"
return|;
case|case
name|TT_PROC_SET_MPROTECT
case|:
return|return
literal|"TT_PROC_SET_MPROTECT"
return|;
case|case
name|TT_PROC_SET_SCBM
case|:
return|return
literal|"TT_PROC_SET_SCBM"
return|;
case|case
name|TT_LWP_STOP
case|:
return|return
literal|"TT_LWP_STOP"
return|;
case|case
name|TT_LWP_CONTINUE
case|:
return|return
literal|"TT_LWP_CONTINUE"
return|;
case|case
name|TT_LWP_SINGLE
case|:
return|return
literal|"TT_LWP_SINGLE"
return|;
case|case
name|TT_LWP_RUREGS
case|:
return|return
literal|"TT_LWP_RUREGS"
return|;
case|case
name|TT_LWP_WUREGS
case|:
return|return
literal|"TT_LWP_WUREGS"
return|;
case|case
name|TT_LWP_GET_EVENT_MASK
case|:
return|return
literal|"TT_LWP_GET_EVENT_MASK"
return|;
case|case
name|TT_LWP_SET_EVENT_MASK
case|:
return|return
literal|"TT_LWP_SET_EVENT_MASK"
return|;
case|case
name|TT_LWP_GET_STATE
case|:
return|return
literal|"TT_LWP_GET_STATE"
return|;
default|default :
return|return
literal|"?new req?"
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This function translates the process state enumeration into  * a character string that is its printable (aka "human readable")  * name.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|get_printable_name_of_process_state
parameter_list|(
name|process_state
parameter_list|)
name|process_state_t
name|process_state
decl_stmt|;
block|{
switch|switch
condition|(
name|process_state
condition|)
block|{
case|case
name|STOPPED
case|:
return|return
literal|"STOPPED"
return|;
case|case
name|FAKE_STEPPING
case|:
return|return
literal|"FAKE_STEPPING"
return|;
case|case
name|RUNNING
case|:
return|return
literal|"RUNNING"
return|;
case|case
name|FORKING
case|:
return|return
literal|"FORKING"
return|;
case|case
name|VFORKING
case|:
return|return
literal|"VFORKING"
return|;
default|default:
return|return
literal|"?some unknown state?"
return|;
block|}
block|}
end_function

begin_comment
comment|/* Set a ttrace thread state to a safe, initial state.  */
end_comment

begin_function
specifier|static
name|void
name|clear_ttstate_t
parameter_list|(
name|tts
parameter_list|)
name|ttstate_t
modifier|*
name|tts
decl_stmt|;
block|{
name|tts
operator|->
name|tts_pid
operator|=
literal|0
expr_stmt|;
name|tts
operator|->
name|tts_lwpid
operator|=
literal|0
expr_stmt|;
name|tts
operator|->
name|tts_user_tid
operator|=
literal|0
expr_stmt|;
name|tts
operator|->
name|tts_event
operator|=
name|TTEVT_NONE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy ttrace thread state TTS_FROM into TTS_TO.  */
end_comment

begin_function
specifier|static
name|void
name|copy_ttstate_t
parameter_list|(
name|tts_to
parameter_list|,
name|tts_from
parameter_list|)
name|ttstate_t
modifier|*
name|tts_to
decl_stmt|;
name|ttstate_t
modifier|*
name|tts_from
decl_stmt|;
block|{
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tts_to
argument_list|,
operator|(
name|char
operator|*
operator|)
name|tts_from
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tts_to
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Are there any live threads we know about?  */
end_comment

begin_function
specifier|static
name|int
name|any_thread_records
parameter_list|()
block|{
return|return
operator|(
name|thread_head
operator|.
name|count
operator|>
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Create, fill in and link in a thread descriptor.  */
end_comment

begin_function
specifier|static
name|thread_info
modifier|*
name|create_thread_info
parameter_list|(
name|pid
parameter_list|,
name|tid
parameter_list|)
name|int
name|pid
decl_stmt|;
name|lwpid_t
name|tid
decl_stmt|;
block|{
name|thread_info
modifier|*
name|new_p
decl_stmt|;
name|thread_info
modifier|*
name|p
decl_stmt|;
name|int
name|thread_count_of_pid
decl_stmt|;
name|new_p
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|thread_info
argument_list|)
argument_list|)
expr_stmt|;
name|new_p
operator|->
name|pid
operator|=
name|pid
expr_stmt|;
name|new_p
operator|->
name|tid
operator|=
name|tid
expr_stmt|;
name|new_p
operator|->
name|have_signal
operator|=
literal|0
expr_stmt|;
name|new_p
operator|->
name|have_start
operator|=
literal|0
expr_stmt|;
name|new_p
operator|->
name|have_state
operator|=
literal|0
expr_stmt|;
name|clear_ttstate_t
argument_list|(
operator|&
name|new_p
operator|->
name|last_stop_state
argument_list|)
expr_stmt|;
name|new_p
operator|->
name|am_pseudo
operator|=
literal|0
expr_stmt|;
name|new_p
operator|->
name|handled
operator|=
literal|0
expr_stmt|;
name|new_p
operator|->
name|seen
operator|=
literal|0
expr_stmt|;
name|new_p
operator|->
name|terminated
operator|=
literal|0
expr_stmt|;
name|new_p
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|new_p
operator|->
name|next_pseudo
operator|=
name|NULL
expr_stmt|;
name|new_p
operator|->
name|stepping_mode
operator|=
name|DO_DEFAULT
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|thread_head
operator|.
name|count
condition|)
block|{
ifdef|#
directive|ifdef
name|THREAD_DEBUG
if|if
condition|(
name|debug_on
condition|)
name|printf
argument_list|(
literal|"First thread, pid %d tid %d!\n"
argument_list|,
name|pid
argument_list|,
name|tid
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|saved_real_pid
operator|=
name|inferior_pid
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|THREAD_DEBUG
if|if
condition|(
name|debug_on
condition|)
name|printf
argument_list|(
literal|"Subsequent thread, pid %d tid %d\n"
argument_list|,
name|pid
argument_list|,
name|tid
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Another day, another thread...      */
name|thread_head
operator|.
name|count
operator|++
expr_stmt|;
comment|/* The new thread always goes at the head of the list.      */
name|new_p
operator|->
name|next
operator|=
name|thread_head
operator|.
name|head
expr_stmt|;
name|thread_head
operator|.
name|head
operator|=
name|new_p
expr_stmt|;
comment|/* Is this the "pseudo" thread of a process?  It is if there's      * no other thread for this process on the list.  (Note that this      * accomodates multiple processes, such as we see even for simple      * cases like forking "non-threaded" programs.)      */
name|p
operator|=
name|thread_head
operator|.
name|head
expr_stmt|;
name|thread_count_of_pid
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|p
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|pid
operator|==
name|new_p
operator|->
name|pid
condition|)
name|thread_count_of_pid
operator|++
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
block|}
comment|/* Did we see any other threads for this pid?  (Recall that we just      * added this thread to the list...)      */
if|if
condition|(
name|thread_count_of_pid
operator|==
literal|1
condition|)
block|{
name|new_p
operator|->
name|am_pseudo
operator|=
literal|1
expr_stmt|;
name|new_p
operator|->
name|next_pseudo
operator|=
name|thread_head
operator|.
name|head_pseudo
expr_stmt|;
name|thread_head
operator|.
name|head_pseudo
operator|=
name|new_p
expr_stmt|;
block|}
return|return
name|new_p
return|;
block|}
end_function

begin_comment
comment|/* Get rid of our thread info.  */
end_comment

begin_function
specifier|static
name|void
name|clear_thread_info
parameter_list|()
block|{
name|thread_info
modifier|*
name|p
decl_stmt|;
name|thread_info
modifier|*
name|q
decl_stmt|;
ifdef|#
directive|ifdef
name|THREAD_DEBUG
if|if
condition|(
name|debug_on
condition|)
name|printf
argument_list|(
literal|"Clearing all thread info\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|p
operator|=
name|thread_head
operator|.
name|head
expr_stmt|;
while|while
condition|(
name|p
condition|)
block|{
name|q
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
name|thread_head
operator|.
name|head
operator|=
name|NULL
expr_stmt|;
name|thread_head
operator|.
name|head_pseudo
operator|=
name|NULL
expr_stmt|;
name|thread_head
operator|.
name|count
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|deleted_threads
operator|.
name|head
expr_stmt|;
while|while
condition|(
name|p
condition|)
block|{
name|q
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
name|deleted_threads
operator|.
name|head
operator|=
name|NULL
expr_stmt|;
name|deleted_threads
operator|.
name|head_pseudo
operator|=
name|NULL
expr_stmt|;
name|deleted_threads
operator|.
name|count
operator|=
literal|0
expr_stmt|;
comment|/* No threads, so can't have pending events.      */
name|more_events_left
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a tid, find the thread block for it.  */
end_comment

begin_function
specifier|static
name|thread_info
modifier|*
name|find_thread_info
parameter_list|(
name|tid
parameter_list|)
name|lwpid_t
name|tid
decl_stmt|;
block|{
name|thread_info
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|thread_head
operator|.
name|head
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|p
operator|->
name|tid
operator|==
name|tid
condition|)
block|{
return|return
name|p
return|;
block|}
block|}
for|for
control|(
name|p
operator|=
name|deleted_threads
operator|.
name|head
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|p
operator|->
name|tid
operator|==
name|tid
condition|)
block|{
return|return
name|p
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* For any but the pseudo thread, this maps to the  * thread ID.  For the pseudo thread, if you pass either  * the thread id or the PID, you get the pseudo thread ID.  *  * We have to be prepared for core gdb to ask about  * deleted threads.  We do the map, but we don't like it.  */
end_comment

begin_function
specifier|static
name|lwpid_t
name|map_from_gdb_tid
parameter_list|(
name|gdb_tid
parameter_list|)
name|lwpid_t
name|gdb_tid
decl_stmt|;
block|{
name|thread_info
modifier|*
name|p
decl_stmt|;
comment|/* First assume gdb_tid really is a tid, and try to find a      * matching entry on the threads list.      */
for|for
control|(
name|p
operator|=
name|thread_head
operator|.
name|head
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|p
operator|->
name|tid
operator|==
name|gdb_tid
condition|)
return|return
name|gdb_tid
return|;
block|}
comment|/* It doesn't appear to be a tid; perhaps it's really a pid?      * Try to find a "pseudo" thread entry on the threads list.      */
for|for
control|(
name|p
operator|=
name|thread_head
operator|.
name|head_pseudo
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next_pseudo
control|)
block|{
if|if
condition|(
name|p
operator|->
name|pid
operator|==
name|gdb_tid
condition|)
return|return
name|p
operator|->
name|tid
return|;
block|}
comment|/* Perhaps it's the tid of a deleted thread we may still      * have some knowledge of?      */
for|for
control|(
name|p
operator|=
name|deleted_threads
operator|.
name|head
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|p
operator|->
name|tid
operator|==
name|gdb_tid
condition|)
return|return
name|gdb_tid
return|;
block|}
comment|/* Or perhaps it's the pid of a deleted process we may still      * have knowledge of?      */
for|for
control|(
name|p
operator|=
name|deleted_threads
operator|.
name|head_pseudo
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next_pseudo
control|)
block|{
if|if
condition|(
name|p
operator|->
name|pid
operator|==
name|gdb_tid
condition|)
return|return
name|p
operator|->
name|tid
return|;
block|}
return|return
literal|0
return|;
comment|/* Error? */
block|}
end_function

begin_comment
comment|/* Map the other way: from a real tid to the  * "pid" known by core gdb.  This tid may be  * for a thread that just got deleted, so we  * also need to consider deleted threads.  */
end_comment

begin_function
specifier|static
name|lwpid_t
name|map_to_gdb_tid
parameter_list|(
name|real_tid
parameter_list|)
name|lwpid_t
name|real_tid
decl_stmt|;
block|{
name|thread_info
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|thread_head
operator|.
name|head
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|p
operator|->
name|tid
operator|==
name|real_tid
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|am_pseudo
condition|)
return|return
name|p
operator|->
name|pid
return|;
else|else
return|return
name|real_tid
return|;
block|}
block|}
for|for
control|(
name|p
operator|=
name|deleted_threads
operator|.
name|head
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|p
operator|->
name|tid
operator|==
name|real_tid
condition|)
if|if
condition|(
name|p
operator|->
name|am_pseudo
condition|)
return|return
name|p
operator|->
name|pid
return|;
comment|/* Error? */
else|else
return|return
name|real_tid
return|;
block|}
return|return
literal|0
return|;
comment|/* Error?  Never heard of this thread! */
block|}
end_function

begin_comment
comment|/* Do any threads have saved signals?  */
end_comment

begin_function
specifier|static
name|int
name|saved_signals_exist
parameter_list|()
block|{
name|thread_info
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|thread_head
operator|.
name|head
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|p
operator|->
name|have_signal
condition|)
block|{
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Is this the tid for the zero-th thread?  */
end_comment

begin_function
specifier|static
name|int
name|is_pseudo_thread
parameter_list|(
name|tid
parameter_list|)
name|lwpid_t
name|tid
decl_stmt|;
block|{
name|thread_info
modifier|*
name|p
init|=
name|find_thread_info
argument_list|(
name|tid
argument_list|)
decl_stmt|;
if|if
condition|(
name|NULL
operator|==
name|p
operator|||
name|p
operator|->
name|terminated
condition|)
return|return
literal|0
return|;
else|else
return|return
name|p
operator|->
name|am_pseudo
return|;
block|}
end_function

begin_comment
comment|/* Is this thread terminated?  */
end_comment

begin_function
specifier|static
name|int
name|is_terminated
parameter_list|(
name|tid
parameter_list|)
name|lwpid_t
name|tid
decl_stmt|;
block|{
name|thread_info
modifier|*
name|p
init|=
name|find_thread_info
argument_list|(
name|tid
argument_list|)
decl_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|p
condition|)
return|return
name|p
operator|->
name|terminated
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Is this pid a real PID or a TID?  */
end_comment

begin_function
specifier|static
name|int
name|is_process_id
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
name|lwpid_t
name|tid
decl_stmt|;
name|thread_info
modifier|*
name|tinfo
decl_stmt|;
name|pid_t
name|this_pid
decl_stmt|;
name|int
name|this_pid_count
decl_stmt|;
comment|/* What does PID really represent?    */
name|tid
operator|=
name|map_from_gdb_tid
argument_list|(
name|pid
argument_list|)
expr_stmt|;
if|if
condition|(
name|tid
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Actually, is probably an error... */
name|tinfo
operator|=
name|find_thread_info
argument_list|(
name|tid
argument_list|)
expr_stmt|;
comment|/* Does it appear to be a true thread?    */
if|if
condition|(
operator|!
name|tinfo
operator|->
name|am_pseudo
condition|)
return|return
literal|0
return|;
comment|/* Else, it looks like it may be a process.  See if there's any other    * threads with the same process ID, though.  If there are, then TID    * just happens to be the first thread of several for this process.    */
name|this_pid
operator|=
name|tinfo
operator|->
name|pid
expr_stmt|;
name|this_pid_count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|tinfo
operator|=
name|thread_head
operator|.
name|head
init|;
name|tinfo
condition|;
name|tinfo
operator|=
name|tinfo
operator|->
name|next
control|)
block|{
if|if
condition|(
name|tinfo
operator|->
name|pid
operator|==
name|this_pid
condition|)
name|this_pid_count
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|this_pid_count
operator|==
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Add a thread to our info.  Prevent duplicate entries.  */
end_comment

begin_function
specifier|static
name|thread_info
modifier|*
name|add_tthread
parameter_list|(
name|pid
parameter_list|,
name|tid
parameter_list|)
name|int
name|pid
decl_stmt|;
name|lwpid_t
name|tid
decl_stmt|;
block|{
name|thread_info
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|find_thread_info
argument_list|(
name|tid
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|p
condition|)
name|p
operator|=
name|create_thread_info
argument_list|(
name|pid
argument_list|,
name|tid
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Notice that a thread was deleted.  */
end_comment

begin_function
specifier|static
name|void
name|del_tthread
parameter_list|(
name|tid
parameter_list|)
name|lwpid_t
name|tid
decl_stmt|;
block|{
name|thread_info
modifier|*
name|p
decl_stmt|;
name|thread_info
modifier|*
name|chase
decl_stmt|;
if|if
condition|(
name|thread_head
operator|.
name|count
operator|<=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Internal error in thread database."
argument_list|)
expr_stmt|;
return|return;
block|}
name|chase
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|p
operator|=
name|thread_head
operator|.
name|head
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|p
operator|->
name|tid
operator|==
name|tid
condition|)
block|{
ifdef|#
directive|ifdef
name|THREAD_DEBUG
if|if
condition|(
name|debug_on
condition|)
name|printf
argument_list|(
literal|"Delete here: %d \n"
argument_list|,
name|tid
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|p
operator|->
name|am_pseudo
condition|)
block|{
comment|/*                 * Deleting a main thread is ok if we're doing                 * a parent-follow on a child; this is odd but                 * not wrong.  It apparently _doesn't_ happen                 * on the child-follow, as we don't just delete                 * the pseudo while keeping the rest of the                 * threads around--instead, we clear out the whole                 * thread list at once.                 */
name|thread_info
modifier|*
name|q
decl_stmt|;
name|thread_info
modifier|*
name|q_chase
decl_stmt|;
name|q_chase
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|q
operator|=
name|thread_head
operator|.
name|head_pseudo
init|;
name|q
condition|;
name|q
operator|=
name|q
operator|->
name|next
control|)
block|{
if|if
condition|(
name|q
operator|==
name|p
condition|)
block|{
comment|/* Remove from pseudo list.                          */
if|if
condition|(
name|q_chase
operator|==
name|NULL
condition|)
name|thread_head
operator|.
name|head_pseudo
operator|=
name|p
operator|->
name|next_pseudo
expr_stmt|;
else|else
name|q_chase
operator|->
name|next
operator|=
name|p
operator|->
name|next_pseudo
expr_stmt|;
block|}
else|else
name|q_chase
operator|=
name|q
expr_stmt|;
block|}
block|}
comment|/* Remove from live list.             */
name|thread_head
operator|.
name|count
operator|--
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|chase
condition|)
name|thread_head
operator|.
name|head
operator|=
name|p
operator|->
name|next
expr_stmt|;
else|else
name|chase
operator|->
name|next
operator|=
name|p
operator|->
name|next
expr_stmt|;
comment|/* Add to deleted thread list.             */
name|p
operator|->
name|next
operator|=
name|deleted_threads
operator|.
name|head
expr_stmt|;
name|deleted_threads
operator|.
name|head
operator|=
name|p
expr_stmt|;
name|deleted_threads
operator|.
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|am_pseudo
condition|)
block|{
name|p
operator|->
name|next_pseudo
operator|=
name|deleted_threads
operator|.
name|head_pseudo
expr_stmt|;
name|deleted_threads
operator|.
name|head_pseudo
operator|=
name|p
expr_stmt|;
block|}
name|p
operator|->
name|terminated
operator|=
literal|1
expr_stmt|;
return|return;
block|}
else|else
name|chase
operator|=
name|p
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Get the pid for this tid. (Has to be a real TID!).  */
end_comment

begin_function
specifier|static
name|int
name|get_pid_for
parameter_list|(
name|tid
parameter_list|)
name|lwpid_t
name|tid
decl_stmt|;
block|{
name|thread_info
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|thread_head
operator|.
name|head
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|p
operator|->
name|tid
operator|==
name|tid
condition|)
block|{
return|return
name|p
operator|->
name|pid
return|;
block|}
block|}
for|for
control|(
name|p
operator|=
name|deleted_threads
operator|.
name|head
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|p
operator|->
name|tid
operator|==
name|tid
condition|)
block|{
return|return
name|p
operator|->
name|pid
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Note that this thread's current event has been handled.  */
end_comment

begin_function
specifier|static
name|void
name|set_handled
parameter_list|(
name|pid
parameter_list|,
name|tid
parameter_list|)
name|int
name|pid
decl_stmt|;
name|lwpid_t
name|tid
decl_stmt|;
block|{
name|thread_info
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|find_thread_info
argument_list|(
name|tid
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|p
condition|)
name|p
operator|=
name|add_tthread
argument_list|(
name|pid
argument_list|,
name|tid
argument_list|)
expr_stmt|;
name|p
operator|->
name|handled
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Was this thread's current event handled?  */
end_comment

begin_function
specifier|static
name|int
name|was_handled
parameter_list|(
name|tid
parameter_list|)
name|lwpid_t
name|tid
decl_stmt|;
block|{
name|thread_info
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|find_thread_info
argument_list|(
name|tid
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|p
condition|)
return|return
name|p
operator|->
name|handled
return|;
return|return
literal|0
return|;
comment|/* New threads have not been handled */
block|}
end_function

begin_comment
comment|/* Set this thread to unhandled.  */
end_comment

begin_function
specifier|static
name|void
name|clear_handled
parameter_list|(
name|tid
parameter_list|)
name|lwpid_t
name|tid
decl_stmt|;
block|{
name|thread_info
modifier|*
name|p
decl_stmt|;
ifdef|#
directive|ifdef
name|WAIT_BUFFER_DEBUG
if|if
condition|(
name|debug_on
condition|)
name|printf
argument_list|(
literal|"clear_handled %d\n"
argument_list|,
operator|(
name|int
operator|)
name|tid
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|p
operator|=
name|find_thread_info
argument_list|(
name|tid
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Internal error: No thread state to clear?"
argument_list|)
expr_stmt|;
name|p
operator|->
name|handled
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set all threads to unhandled.  */
end_comment

begin_function
specifier|static
name|void
name|clear_all_handled
parameter_list|()
block|{
name|thread_info
modifier|*
name|p
decl_stmt|;
ifdef|#
directive|ifdef
name|WAIT_BUFFER_DEBUG
if|if
condition|(
name|debug_on
condition|)
name|printf
argument_list|(
literal|"clear_all_handled\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|p
operator|=
name|thread_head
operator|.
name|head
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|p
operator|->
name|handled
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|p
operator|=
name|deleted_threads
operator|.
name|head
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|p
operator|->
name|handled
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Set this thread to default stepping mode.  */
end_comment

begin_function
specifier|static
name|void
name|clear_stepping_mode
parameter_list|(
name|tid
parameter_list|)
name|lwpid_t
name|tid
decl_stmt|;
block|{
name|thread_info
modifier|*
name|p
decl_stmt|;
ifdef|#
directive|ifdef
name|WAIT_BUFFER_DEBUG
if|if
condition|(
name|debug_on
condition|)
name|printf
argument_list|(
literal|"clear_stepping_mode %d\n"
argument_list|,
operator|(
name|int
operator|)
name|tid
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|p
operator|=
name|find_thread_info
argument_list|(
name|tid
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Internal error: No thread state to clear?"
argument_list|)
expr_stmt|;
name|p
operator|->
name|stepping_mode
operator|=
name|DO_DEFAULT
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set all threads to do default continue on resume.  */
end_comment

begin_function
specifier|static
name|void
name|clear_all_stepping_mode
parameter_list|()
block|{
name|thread_info
modifier|*
name|p
decl_stmt|;
ifdef|#
directive|ifdef
name|WAIT_BUFFER_DEBUG
if|if
condition|(
name|debug_on
condition|)
name|printf
argument_list|(
literal|"clear_all_stepping_mode\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|p
operator|=
name|thread_head
operator|.
name|head
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|p
operator|->
name|stepping_mode
operator|=
name|DO_DEFAULT
expr_stmt|;
block|}
for|for
control|(
name|p
operator|=
name|deleted_threads
operator|.
name|head
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|p
operator|->
name|stepping_mode
operator|=
name|DO_DEFAULT
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Set all threads to unseen on this pass.  */
end_comment

begin_function
specifier|static
name|void
name|set_all_unseen
parameter_list|()
block|{
name|thread_info
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|thread_head
operator|.
name|head
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|p
operator|->
name|seen
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|THREAD_DEBUG
argument_list|)
operator|||
name|defined
argument_list|(
name|PARANOIA
argument_list|)
operator|)
end_if

begin_comment
comment|/* debugging routine.  */
end_comment

begin_function
specifier|static
name|void
name|print_tthread
parameter_list|(
name|p
parameter_list|)
name|thread_info
modifier|*
name|p
decl_stmt|;
block|{
name|printf
argument_list|(
literal|" Thread pid %d, tid %d"
argument_list|,
name|p
operator|->
name|pid
argument_list|,
name|p
operator|->
name|tid
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|have_state
condition|)
name|printf
argument_list|(
literal|", event is %s"
argument_list|,
name|get_printable_name_of_ttrace_event
argument_list|(
name|p
operator|->
name|last_stop_state
operator|.
name|tts_event
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|am_pseudo
condition|)
name|printf
argument_list|(
literal|", pseudo thread"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|have_signal
condition|)
name|printf
argument_list|(
literal|", have signal 0x%x"
argument_list|,
name|p
operator|->
name|signal_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|have_start
condition|)
name|printf
argument_list|(
literal|", have start at 0x%x"
argument_list|,
name|p
operator|->
name|start
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", step is %s"
argument_list|,
name|get_printable_name_of_stepping_mode
argument_list|(
name|p
operator|->
name|stepping_mode
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|handled
condition|)
name|printf
argument_list|(
literal|", handled"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|", not handled"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|seen
condition|)
name|printf
argument_list|(
literal|", seen"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|", not seen"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_tthreads
parameter_list|()
block|{
name|thread_info
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|thread_head
operator|.
name|count
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"Thread list is empty\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"Thread list has "
argument_list|)
expr_stmt|;
if|if
condition|(
name|thread_head
operator|.
name|count
operator|==
literal|1
condition|)
name|printf
argument_list|(
literal|"1 entry:\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%d entries:\n"
argument_list|,
name|thread_head
operator|.
name|count
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|thread_head
operator|.
name|head
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|print_tthread
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|deleted_threads
operator|.
name|count
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"Deleted thread list is empty\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"Deleted thread list has "
argument_list|)
expr_stmt|;
if|if
condition|(
name|deleted_threads
operator|.
name|count
operator|==
literal|1
condition|)
name|printf
argument_list|(
literal|"1 entry:\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%d entries:\n"
argument_list|,
name|deleted_threads
operator|.
name|count
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|deleted_threads
operator|.
name|head
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|print_tthread
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Update the thread list based on the "seen" bits.  */
end_comment

begin_function
specifier|static
name|void
name|update_thread_list
parameter_list|()
block|{
name|thread_info
modifier|*
name|p
decl_stmt|;
name|thread_info
modifier|*
name|chase
decl_stmt|;
name|chase
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|p
operator|=
name|thread_head
operator|.
name|head
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
comment|/* Is this an "unseen" thread which really happens to be a process?          If so, is it inferior_pid and is a vfork in flight?  If yes to          all, then DON'T REMOVE IT!  We're in the midst of moving a vfork          operation, which is a multiple step thing, to the point where we          can touch the parent again.  We've most likely stopped to examine          the child at a late stage in the vfork, and if we're not following          the child, we'd best not treat the parent as a dead "thread"...          */
if|if
condition|(
operator|(
operator|!
name|p
operator|->
name|seen
operator|)
operator|&&
name|p
operator|->
name|am_pseudo
operator|&&
name|vfork_in_flight
operator|&&
operator|(
name|p
operator|->
name|pid
operator|!=
name|vforking_child_pid
operator|)
condition|)
name|p
operator|->
name|seen
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|p
operator|->
name|seen
condition|)
block|{
comment|/* Remove this one              */
ifdef|#
directive|ifdef
name|THREAD_DEBUG
if|if
condition|(
name|debug_on
condition|)
name|printf
argument_list|(
literal|"Delete unseen thread: %d \n"
argument_list|,
name|p
operator|->
name|tid
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|del_tthread
argument_list|(
name|p
operator|->
name|tid
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/************************************************  *            O/S call wrappers                 *  ************************************************  */
end_comment

begin_comment
comment|/* This function simply calls ttrace with the given arguments.    * It exists so that all calls to ttrace are isolated.  All  * parameters should be as specified by "man 2 ttrace".  *  * No other "raw" calls to ttrace should exist in this module.  */
end_comment

begin_function
specifier|static
name|int
name|call_real_ttrace
parameter_list|(
name|request
parameter_list|,
name|pid
parameter_list|,
name|tid
parameter_list|,
name|addr
parameter_list|,
name|data
parameter_list|,
name|addr2
parameter_list|)
name|ttreq_t
name|request
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
name|lwpid_t
name|tid
decl_stmt|;
name|TTRACE_ARG_TYPE
name|addr
decl_stmt|,
name|data
decl_stmt|,
name|addr2
decl_stmt|;
block|{
name|int
name|tt_status
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|tt_status
operator|=
name|ttrace
argument_list|(
name|request
argument_list|,
name|pid
argument_list|,
name|tid
argument_list|,
name|addr
argument_list|,
name|data
argument_list|,
name|addr2
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|THREAD_DEBUG
if|if
condition|(
name|errno
condition|)
block|{
comment|/* Don't bother for a known benign error: if you ask for the      * first thread state, but there is only one thread and it's      * not stopped, ttrace complains.      *      * We have this inside the #ifdef because our caller will do      * this check for real.      */
if|if
condition|(
name|request
operator|!=
name|TT_PROC_GET_FIRST_LWP_STATE
operator|||
name|errno
operator|!=
name|EPROTO
condition|)
block|{
if|if
condition|(
name|debug_on
condition|)
name|printf
argument_list|(
literal|"TT fail for %s, with pid %d, tid %d, status %d \n"
argument_list|,
name|get_printable_name_of_ttrace_request
argument_list|(
name|request
argument_list|)
argument_list|,
name|pid
argument_list|,
name|tid
argument_list|,
name|tt_status
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|#
directive|if
literal|0
comment|/* ??rehrauer: It would probably be most robust to catch and report    * failed requests here.  However, some clients of this interface    * seem to expect to catch& deal with them, so we'd best not.    */
block|if (errno) {     strcpy (reason_for_failure, "ttrace (");     strcat (reason_for_failure, get_printable_name_of_ttrace_request (request));     strcat (reason_for_failure, ")");     printf( "ttrace error, errno = %d\n", errno );     perror_with_name (reason_for_failure);   }
endif|#
directive|endif
return|return
name|tt_status
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This function simply calls ttrace_wait with the given arguments.    * It exists so that all calls to ttrace_wait are isolated.  *  * No "raw" calls to ttrace_wait should exist elsewhere.  */
end_comment

begin_function
specifier|static
name|int
name|call_real_ttrace_wait
parameter_list|(
name|pid
parameter_list|,
name|tid
parameter_list|,
name|option
parameter_list|,
name|tsp
parameter_list|,
name|tsp_size
parameter_list|)
name|int
name|pid
decl_stmt|;
name|lwpid_t
name|tid
decl_stmt|;
name|ttwopt_t
name|option
decl_stmt|;
name|ttstate_t
modifier|*
name|tsp
decl_stmt|;
name|size_t
name|tsp_size
decl_stmt|;
block|{
name|int
name|ttw_status
decl_stmt|;
name|thread_info
modifier|*
name|tinfo
init|=
name|NULL
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|ttw_status
operator|=
name|ttrace_wait
argument_list|(
name|pid
argument_list|,
name|tid
argument_list|,
name|option
argument_list|,
name|tsp
argument_list|,
name|tsp_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
block|{
ifdef|#
directive|ifdef
name|THREAD_DEBUG
if|if
condition|(
name|debug_on
condition|)
name|printf
argument_list|(
literal|"TW fail with pid %d, tid %d \n"
argument_list|,
name|pid
argument_list|,
name|tid
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|perror_with_name
argument_list|(
literal|"ttrace wait"
argument_list|)
expr_stmt|;
block|}
return|return
name|ttw_status
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A process may have one or more kernel threads, of which all or    none may be stopped.  This function returns the ID of the first    kernel thread in a stopped state, or 0 if none are stopped.     This function can be used with get_process_next_stopped_thread_id    to iterate over the IDs of all stopped threads of this process.  */
end_comment

begin_function
specifier|static
name|lwpid_t
name|get_process_first_stopped_thread_id
parameter_list|(
name|pid
parameter_list|,
name|thread_state
parameter_list|)
name|int
name|pid
decl_stmt|;
name|ttstate_t
modifier|*
name|thread_state
decl_stmt|;
block|{
name|int
name|tt_status
decl_stmt|;
name|tt_status
operator|=
name|call_real_ttrace
argument_list|(
name|TT_PROC_GET_FIRST_LWP_STATE
argument_list|,
operator|(
name|pid_t
operator|)
name|pid
argument_list|,
operator|(
name|lwpid_t
operator|)
name|TT_NIL
argument_list|,
operator|(
name|TTRACE_ARG_TYPE
operator|)
name|thread_state
argument_list|,
operator|(
name|TTRACE_ARG_TYPE
operator|)
sizeof|sizeof
argument_list|(
operator|*
name|thread_state
argument_list|)
argument_list|,
name|TT_NIL
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EPROTO
condition|)
block|{
comment|/* This is an error we can handle: there isn't any stopped          * thread.  This happens when we're re-starting the application          * and it has only one thread.  GET_NEXT handles the case of          * no more stopped threads well; GET_FIRST doesn't.  (A ttrace          * "feature".)          */
name|tt_status
operator|=
literal|1
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
name|perror_with_name
argument_list|(
literal|"ttrace"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tt_status
operator|<
literal|0
condition|)
comment|/* Failed somehow.      */
return|return
literal|0
return|;
return|return
name|thread_state
operator|->
name|tts_lwpid
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This function returns the ID of the "next" kernel thread in a    stopped state, or 0 if there are none.  "Next" refers to the    thread following that of the last successful call to this    function or to get_process_first_stopped_thread_id, using    the value of thread_state returned by that call.     This function can be used with get_process_first_stopped_thread_id    to iterate over the IDs of all stopped threads of this process.  */
end_comment

begin_function
specifier|static
name|lwpid_t
name|get_process_next_stopped_thread_id
parameter_list|(
name|pid
parameter_list|,
name|thread_state
parameter_list|)
name|int
name|pid
decl_stmt|;
name|ttstate_t
modifier|*
name|thread_state
decl_stmt|;
block|{
name|int
name|tt_status
decl_stmt|;
name|tt_status
operator|=
name|call_real_ttrace
argument_list|(
name|TT_PROC_GET_NEXT_LWP_STATE
argument_list|,
operator|(
name|pid_t
operator|)
name|pid
argument_list|,
operator|(
name|lwpid_t
operator|)
name|TT_NIL
argument_list|,
operator|(
name|TTRACE_ARG_TYPE
operator|)
name|thread_state
argument_list|,
operator|(
name|TTRACE_ARG_TYPE
operator|)
sizeof|sizeof
argument_list|(
operator|*
name|thread_state
argument_list|)
argument_list|,
name|TT_NIL
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
name|perror_with_name
argument_list|(
literal|"ttrace"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tt_status
operator|<
literal|0
condition|)
comment|/* Failed      */
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|tt_status
operator|==
literal|0
condition|)
block|{
comment|/* End of list, no next state.  Don't return the      * tts_lwpid, as it's a meaningless "240".      *      * This is an HPUX "feature".      */
return|return
literal|0
return|;
block|}
return|return
name|thread_state
operator|->
name|tts_lwpid
return|;
block|}
end_function

begin_comment
comment|/* ??rehrauer: Eventually this function perhaps should be calling    pid_to_thread_id.  However, that function currently does nothing    for HP-UX.  Even then, I'm not clear whether that function    will return a "kernel" thread ID, or a "user" thread ID.  If    the former, we can just call it here.  If the latter, we must    map from the "user" tid to a "kernel" tid.     NOTE: currently not called.  */
end_comment

begin_function
specifier|static
name|lwpid_t
name|get_active_tid_of_pid
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
name|ttstate_t
name|thread_state
decl_stmt|;
return|return
name|get_process_first_stopped_thread_id
argument_list|(
name|pid
argument_list|,
operator|&
name|thread_state
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* This function returns 1 if tt_request is a ttrace request that  * operates upon all threads of a (i.e., the entire) process.  */
end_comment

begin_function
name|int
name|is_process_ttrace_request
parameter_list|(
name|tt_request
parameter_list|)
name|ttreq_t
name|tt_request
decl_stmt|;
block|{
return|return
name|IS_TTRACE_PROCREQ
argument_list|(
name|tt_request
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This function translates a thread ttrace request into  * the equivalent process request for a one-thread process.  */
end_comment

begin_function
specifier|static
name|ttreq_t
name|make_process_version
parameter_list|(
name|request
parameter_list|)
name|ttreq_t
name|request
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|IS_TTRACE_REQ
argument_list|(
name|request
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"Internal error, bad ttrace request made\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
switch|switch
condition|(
name|request
condition|)
block|{
case|case
name|TT_LWP_STOP
case|:
return|return
name|TT_PROC_STOP
return|;
case|case
name|TT_LWP_CONTINUE
case|:
return|return
name|TT_PROC_CONTINUE
return|;
case|case
name|TT_LWP_GET_EVENT_MASK
case|:
return|return
name|TT_PROC_GET_EVENT_MASK
return|;
case|case
name|TT_LWP_SET_EVENT_MASK
case|:
return|return
name|TT_PROC_SET_EVENT_MASK
return|;
case|case
name|TT_LWP_SINGLE
case|:
case|case
name|TT_LWP_RUREGS
case|:
case|case
name|TT_LWP_WUREGS
case|:
case|case
name|TT_LWP_GET_STATE
case|:
return|return
operator|-
literal|1
return|;
comment|/* No equivalent */
default|default :
return|return
name|request
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This function translates the "pid" used by the rest of  * gdb to a real pid and a tid.  It then calls "call_real_ttrace"  * with the given arguments.  *  * In general, other parts of this module should call this  * function when they are dealing with external users, who only  * have tids to pass (but they call it "pid" for historical  * reasons).  */
end_comment

begin_function
specifier|static
name|int
name|call_ttrace
parameter_list|(
name|request
parameter_list|,
name|gdb_tid
parameter_list|,
name|addr
parameter_list|,
name|data
parameter_list|,
name|addr2
parameter_list|)
name|ttreq_t
name|request
decl_stmt|;
name|int
name|gdb_tid
decl_stmt|;
name|TTRACE_ARG_TYPE
name|addr
decl_stmt|,
name|data
decl_stmt|,
name|addr2
decl_stmt|;
block|{
name|lwpid_t
name|real_tid
decl_stmt|;
name|int
name|real_pid
decl_stmt|;
name|ttreq_t
name|new_request
decl_stmt|;
name|int
name|tt_status
decl_stmt|;
name|char
name|reason_for_failure
index|[
literal|100
index|]
decl_stmt|;
comment|/* Arbitrary size, should be big enough. */
ifdef|#
directive|ifdef
name|THREAD_DEBUG
name|int
name|is_interesting
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TT_LWP_RUREGS
operator|==
name|request
condition|)
block|{
name|is_interesting
operator|=
literal|1
expr_stmt|;
comment|/* Adjust code here as desired */
block|}
if|if
condition|(
name|is_interesting
operator|&&
literal|0
operator|&&
name|debug_on
condition|)
block|{
if|if
condition|(
operator|!
name|is_process_ttrace_request
argument_list|(
name|request
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"TT: Thread request, tid is %d"
argument_list|,
name|gdb_tid
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"== SINGLE at %x"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"TT: Process request, tid is %d\n"
argument_list|,
name|gdb_tid
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"==! SINGLE at %x"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* The initial SETTRC and SET_EVENT_MASK calls (and all others    * which happen before any threads get set up) should go    * directly to "call_real_ttrace", so they don't happen here.    *    * But hardware watchpoints do a SET_EVENT_MASK, so we can't    * rule them out....    */
ifdef|#
directive|ifdef
name|THREAD_DEBUG
if|if
condition|(
name|request
operator|==
name|TT_PROC_SETTRC
operator|&&
name|debug_on
condition|)
name|printf
argument_list|(
literal|"Unexpected call for TT_PROC_SETTRC\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Sometimes we get called with a bogus tid (e.g., if a    * thread has terminated, we return 0; inftarg later asks    * whether the thread has exited/forked/vforked).    */
if|if
condition|(
name|gdb_tid
operator|==
literal|0
condition|)
block|{
name|errno
operator|=
name|ESRCH
expr_stmt|;
comment|/* ttrace's response would probably be "No such process". */
return|return
operator|-
literal|1
return|;
block|}
comment|/* All other cases should be able to expect that there are    * thread records.    */
if|if
condition|(
operator|!
name|any_thread_records
argument_list|()
condition|)
block|{
ifdef|#
directive|ifdef
name|THREAD_DEBUG
if|if
condition|(
name|debug_on
condition|)
name|warning
argument_list|(
literal|"No thread records for ttrace call"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|errno
operator|=
name|ESRCH
expr_stmt|;
comment|/* ttrace's response would be "No such process". */
return|return
operator|-
literal|1
return|;
block|}
comment|/* OK, now the task is to translate the incoming tid into    * a pid/tid pair.    */
name|real_tid
operator|=
name|map_from_gdb_tid
argument_list|(
name|gdb_tid
argument_list|)
expr_stmt|;
name|real_pid
operator|=
name|get_pid_for
argument_list|(
name|real_tid
argument_list|)
expr_stmt|;
comment|/* Now check the result.  "Real_pid" is NULL if our list    * didn't find it.  We have some tricks we can play to fix    * this, however.    */
if|if
condition|(
literal|0
operator|==
name|real_pid
condition|)
block|{
name|ttstate_t
name|thread_state
decl_stmt|;
ifdef|#
directive|ifdef
name|THREAD_DEBUG
if|if
condition|(
name|debug_on
condition|)
name|printf
argument_list|(
literal|"No saved pid for tid %d\n"
argument_list|,
name|gdb_tid
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|is_process_ttrace_request
argument_list|(
name|request
argument_list|)
condition|)
block|{
comment|/* Ok, we couldn't get a tid.  Try to translate to          * the equivalent process operation.  We expect this          * NOT to happen, so this is a desparation-type          * move.  It can happen if there is an internal          * error and so no "wait()" call is ever done.          */
name|new_request
operator|=
name|make_process_version
argument_list|(
name|request
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_request
operator|==
operator|-
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|THREAD_DEBUG
if|if
condition|(
name|debug_on
condition|)
name|printf
argument_list|(
literal|"...and couldn't make process version of thread operation\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Use hacky saved pid, which won't always be correct              * in the multi-process future.  Use tid as thread,              * probably dooming this to failure.  FIX!              */
if|if
condition|(
name|saved_real_pid
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|THREAD_DEBUG
if|if
condition|(
name|debug_on
condition|)
name|printf
argument_list|(
literal|"...using saved pid %d\n"
argument_list|,
name|saved_real_pid
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|real_pid
operator|=
name|saved_real_pid
expr_stmt|;
name|real_tid
operator|=
name|gdb_tid
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"Unable to perform thread operation"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Sucessfully translated this to a process request,              * which needs no thread value.              */
name|real_pid
operator|=
name|gdb_tid
expr_stmt|;
name|real_tid
operator|=
literal|0
expr_stmt|;
name|request
operator|=
name|new_request
expr_stmt|;
ifdef|#
directive|ifdef
name|THREAD_DEBUG
if|if
condition|(
name|debug_on
condition|)
block|{
name|printf
argument_list|(
literal|"Translated thread request to process request\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|saved_real_pid
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"...but there's no saved pid\n"
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|gdb_tid
operator|!=
name|saved_real_pid
condition|)
name|printf
argument_list|(
literal|"...but have the wrong pid (%d rather than %d)\n"
argument_list|,
name|gdb_tid
argument_list|,
name|saved_real_pid
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
comment|/* Translated to a process request */
block|}
comment|/* Is a process request */
else|else
block|{
comment|/* We have to have a thread.  Ooops.          */
name|error
argument_list|(
literal|"Thread request with no threads (%s)"
argument_list|,
name|get_printable_name_of_ttrace_request
argument_list|(
name|request
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Ttrace doesn't like to see tid values on process requests,    * even if we have the right one.    */
if|if
condition|(
name|is_process_ttrace_request
argument_list|(
name|request
argument_list|)
condition|)
block|{
name|real_tid
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|THREAD_DEBUG
if|if
condition|(
name|is_interesting
operator|&&
literal|0
operator|&&
name|debug_on
condition|)
block|{
name|printf
argument_list|(
literal|"    now tid %d, pid %d\n"
argument_list|,
name|real_tid
argument_list|,
name|real_pid
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    request is %s\n"
argument_list|,
name|get_printable_name_of_ttrace_request
argument_list|(
name|request
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Finally, the (almost) real call.    */
name|tt_status
operator|=
name|call_real_ttrace
argument_list|(
name|request
argument_list|,
name|real_pid
argument_list|,
name|real_tid
argument_list|,
name|addr
argument_list|,
name|data
argument_list|,
name|addr2
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|THREAD_DEBUG
if|if
condition|(
name|is_interesting
operator|&&
name|debug_on
condition|)
block|{
if|if
condition|(
operator|!
name|TT_OK
argument_list|(
name|tt_status
argument_list|,
name|errno
argument_list|)
operator|&&
operator|!
operator|(
name|tt_status
operator|==
literal|0
operator|&
name|errno
operator|==
literal|0
operator|)
condition|)
name|printf
argument_list|(
literal|" got error (errno==%d, status==%d)\n"
argument_list|,
name|errno
argument_list|,
name|tt_status
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|tt_status
return|;
block|}
end_function

begin_comment
comment|/* Stop all the threads of a process.  *  * NOTE: use of TT_PROC_STOP can cause a thread with a real event  *       to get a TTEVT_NONE event, discarding the old event.  Be  *       very careful, and only call TT_PROC_STOP when you mean it!  */
end_comment

begin_function
specifier|static
name|void
name|stop_all_threads_of_process
parameter_list|(
name|real_pid
parameter_list|)
name|pid_t
name|real_pid
decl_stmt|;
block|{
name|int
name|ttw_status
decl_stmt|;
name|ttw_status
operator|=
name|call_real_ttrace
argument_list|(
name|TT_PROC_STOP
argument_list|,
operator|(
name|pid_t
operator|)
name|real_pid
argument_list|,
operator|(
name|lwpid_t
operator|)
name|TT_NIL
argument_list|,
operator|(
name|TTRACE_ARG_TYPE
operator|)
name|TT_NIL
argument_list|,
operator|(
name|TTRACE_ARG_TYPE
operator|)
name|TT_NIL
argument_list|,
name|TT_NIL
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
name|perror_with_name
argument_list|(
literal|"ttrace stop of other threads"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Under some circumstances, it's unsafe to attempt to stop, or even    query the state of, a process' threads.     In ttrace-based HP-UX, an example is a vforking child process.  The    vforking parent and child are somewhat fragile, w/r/t what we can do    what we can do to them with ttrace, until after the child exits or    execs, or until the parent's vfork event is delivered.  Until that    time, we must not try to stop the process' threads, or inquire how    many there are, or even alter its data segments, or it typically dies    with a SIGILL.  Sigh.     This function returns 1 if this stopped process, and the event that    we're told was responsible for its current stopped state, cannot safely    have its threads examined.    */
end_comment

begin_define
define|#
directive|define
name|CHILD_VFORKED
parameter_list|(
name|evt
parameter_list|,
name|pid
parameter_list|)
define|\
value|(((evt) == TTEVT_VFORK)&& ((pid) != inferior_pid))
end_define

begin_define
define|#
directive|define
name|CHILD_URPED
parameter_list|(
name|evt
parameter_list|,
name|pid
parameter_list|)
define|\
value|((((evt) == TTEVT_EXEC) || ((evt) == TTEVT_EXIT))&& ((pid) != vforking_child_pid))
end_define

begin_define
define|#
directive|define
name|PARENT_VFORKED
parameter_list|(
name|evt
parameter_list|,
name|pid
parameter_list|)
define|\
value|(((evt) == TTEVT_VFORK)&& ((pid) == inferior_pid))
end_define

begin_function
specifier|static
name|int
name|can_touch_threads_of_process
parameter_list|(
name|pid
parameter_list|,
name|stopping_event
parameter_list|)
name|int
name|pid
decl_stmt|;
name|ttevents_t
name|stopping_event
decl_stmt|;
block|{
if|if
condition|(
name|CHILD_VFORKED
argument_list|(
name|stopping_event
argument_list|,
name|pid
argument_list|)
condition|)
block|{
name|vforking_child_pid
operator|=
name|pid
expr_stmt|;
name|vfork_in_flight
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vfork_in_flight
operator|&&
operator|(
name|PARENT_VFORKED
argument_list|(
name|stopping_event
argument_list|,
name|pid
argument_list|)
operator|||
name|CHILD_URPED
argument_list|(
name|stopping_event
argument_list|,
name|pid
argument_list|)
operator|)
condition|)
block|{
name|vfork_in_flight
operator|=
literal|0
expr_stmt|;
name|vforking_child_pid
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|!
name|vfork_in_flight
return|;
block|}
end_function

begin_comment
comment|/* If we can find an as-yet-unhandled thread state of a  * stopped thread of this process return 1 and set "tsp".  * Return 0 if we can't.  *  * If this function is used when the threads of PIS haven't  * been stopped, undefined behaviour is guaranteed!  */
end_comment

begin_function
specifier|static
name|int
name|select_stopped_thread_of_process
parameter_list|(
name|pid
parameter_list|,
name|tsp
parameter_list|)
name|int
name|pid
decl_stmt|;
name|ttstate_t
modifier|*
name|tsp
decl_stmt|;
block|{
name|lwpid_t
name|candidate_tid
decl_stmt|,
name|tid
decl_stmt|;
name|ttstate_t
name|candidate_tstate
decl_stmt|,
name|tstate
decl_stmt|;
comment|/* If we're not allowed to touch the process now, then just    * return the current value of *TSP.    *    * This supports "vfork".  It's ok, really, to double the    * current event (the child EXEC, we hope!).    */
if|if
condition|(
operator|!
name|can_touch_threads_of_process
argument_list|(
name|pid
argument_list|,
name|tsp
operator|->
name|tts_event
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Decide which of (possibly more than one) events to    * return as the first one.  We scan them all so that    * we always return the result of a fake-step first.    */
name|candidate_tid
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|tid
operator|=
name|get_process_first_stopped_thread_id
argument_list|(
name|pid
argument_list|,
operator|&
name|tstate
argument_list|)
init|;
name|tid
operator|!=
literal|0
condition|;
name|tid
operator|=
name|get_process_next_stopped_thread_id
argument_list|(
name|pid
argument_list|,
operator|&
name|tstate
argument_list|)
control|)
block|{
comment|/* TTEVT_NONE events are uninteresting to our clients.  They're        * an artifact of our "stop the world" model--the thread is        * stopped because we stopped it.        */
if|if
condition|(
name|tstate
operator|.
name|tts_event
operator|==
name|TTEVT_NONE
condition|)
block|{
name|set_handled
argument_list|(
name|pid
argument_list|,
name|tstate
operator|.
name|tts_lwpid
argument_list|)
expr_stmt|;
block|}
comment|/* Did we just single-step a single thread, without letting any        * of the others run?  Is this an event for that thread?        *        * If so, we believe our client would prefer to see this event        * over any others.  (Typically the client wants to just push        * one thread a little farther forward, and then go around        * checking for what all threads are doing.)        */
elseif|else
if|if
condition|(
name|doing_fake_step
operator|&&
operator|(
name|tstate
operator|.
name|tts_lwpid
operator|==
name|fake_step_tid
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|WAIT_BUFFER_DEBUG
comment|/* It's possible here to see either a SIGTRAP (due to            * successful completion of a step) or a SYSCALL_ENTRY            * (due to a step completion with active hardware            * watchpoints).            */
if|if
condition|(
name|debug_on
condition|)
name|printf
argument_list|(
literal|"Ending fake step with tid %d, state %s\n"
argument_list|,
name|tstate
operator|.
name|tts_lwpid
argument_list|,
name|get_printable_name_of_ttrace_event
argument_list|(
name|tstate
operator|.
name|tts_event
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Remember this one, and throw away any previous            * candidate.            */
name|candidate_tid
operator|=
name|tstate
operator|.
name|tts_lwpid
expr_stmt|;
name|candidate_tstate
operator|=
name|tstate
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|FORGET_DELETED_BPTS
comment|/* We can't just do this, as if we do, and then wind        * up the loop with no unhandled events, we need to        * handle that case--the appropriate reaction is to        * just continue, but there's no easy way to do that.        *        * Better to put this in the ttrace_wait call--if, when        * we fake a wait, we update our events based on the        * breakpoint_here_pc call and find there are no more events,        * then we better continue and so on.        *        * Or we could put it in the next/continue fake.        * But it has to go in the buffering code, not in the        * real go/wait code.        */
elseif|else
if|if
condition|(
operator|(
name|TTEVT_SIGNAL
operator|==
name|tstate
operator|.
name|tts_event
operator|)
operator|&&
operator|(
literal|5
operator|==
name|tstate
operator|.
name|tts_u
operator|.
name|tts_signal
operator|.
name|tts_signo
operator|)
operator|&&
operator|(
literal|0
operator|!=
name|get_raw_pc
argument_list|(
name|tstate
operator|.
name|tts_lwpid
argument_list|)
operator|)
operator|&&
operator|!
name|breakpoint_here_p
argument_list|(
name|get_raw_pc
argument_list|(
name|tstate
operator|.
name|tts_lwpid
argument_list|)
argument_list|)
condition|)
block|{
comment|/*            * If the user deleted a breakpoint while this            * breakpoint-hit event was buffered, we can forget            * it now.            */
ifdef|#
directive|ifdef
name|WAIT_BUFFER_DEBUG
if|if
condition|(
name|debug_on
condition|)
name|printf
argument_list|(
literal|"Forgetting deleted bp hit for thread %d\n"
argument_list|,
name|tstate
operator|.
name|tts_lwpid
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|set_handled
argument_list|(
name|pid
argument_list|,
name|tstate
operator|.
name|tts_lwpid
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Else, is this the first "unhandled" event?  If so,        * we believe our client wants to see it (if we don't        * see a fake-step later on in the scan).        */
elseif|else
if|if
condition|(
operator|!
name|was_handled
argument_list|(
name|tstate
operator|.
name|tts_lwpid
argument_list|)
operator|&&
name|candidate_tid
operator|==
literal|0
condition|)
block|{
name|candidate_tid
operator|=
name|tstate
operator|.
name|tts_lwpid
expr_stmt|;
name|candidate_tstate
operator|=
name|tstate
expr_stmt|;
block|}
comment|/* This is either an event that has already been "handled",        * and thus we believe is uninteresting to our client, or we        * already have a candidate event.  Ignore it...        */
block|}
comment|/* What do we report?    */
if|if
condition|(
name|doing_fake_step
condition|)
block|{
if|if
condition|(
name|candidate_tid
operator|==
name|fake_step_tid
condition|)
block|{
comment|/* Fake step.            */
name|tstate
operator|=
name|candidate_tstate
expr_stmt|;
block|}
else|else
block|{
name|warning
argument_list|(
literal|"Internal error: fake-step failed to complete."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|candidate_tid
operator|!=
literal|0
condition|)
block|{
comment|/* Found a candidate unhandled event.        */
name|tstate
operator|=
name|candidate_tstate
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tid
operator|!=
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"Internal error in call of ttrace_wait."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|warning
argument_list|(
literal|"Internal error: no unhandled thread event to select"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|copy_ttstate_t
argument_list|(
name|tsp
argument_list|,
operator|&
name|tstate
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* End of select_stopped_thread_of_process */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PARANOIA
end_ifdef

begin_comment
comment|/* Check our internal thread data against the real thing.  */
end_comment

begin_function
specifier|static
name|void
name|check_thread_consistency
parameter_list|(
name|real_pid
parameter_list|)
name|pid_t
name|real_pid
decl_stmt|;
block|{
name|int
name|tid
decl_stmt|;
comment|/* really lwpid_t */
name|ttstate_t
name|tstate
decl_stmt|;
name|thread_info
modifier|*
name|p
decl_stmt|;
comment|/* Spin down the O/S list of threads, checking that they      * match what we've got.      */
for|for
control|(
name|tid
operator|=
name|get_process_first_stopped_thread_id
argument_list|(
name|real_pid
argument_list|,
operator|&
name|tstate
argument_list|)
init|;
name|tid
operator|!=
literal|0
condition|;
name|tid
operator|=
name|get_process_next_stopped_thread_id
argument_list|(
name|real_pid
argument_list|,
operator|&
name|tstate
argument_list|)
control|)
block|{
name|p
operator|=
name|find_thread_info
argument_list|(
name|tid
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|p
condition|)
block|{
name|warning
argument_list|(
literal|"No internal thread data for thread %d."
argument_list|,
name|tid
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|p
operator|->
name|seen
condition|)
block|{
name|warning
argument_list|(
literal|"Inconsistent internal thread data for thread %d."
argument_list|,
name|tid
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|terminated
condition|)
block|{
name|warning
argument_list|(
literal|"Thread %d is not terminated, internal error."
argument_list|,
name|tid
argument_list|)
expr_stmt|;
continue|continue;
block|}
define|#
directive|define
name|TT_COMPARE
parameter_list|(
name|fld
parameter_list|)
define|\
value|tstate.fld != p->last_stop_state.fld
if|if
condition|(
name|p
operator|->
name|have_state
condition|)
block|{
if|if
condition|(
name|TT_COMPARE
argument_list|(
name|tts_pid
argument_list|)
operator|||
name|TT_COMPARE
argument_list|(
name|tts_lwpid
argument_list|)
operator|||
name|TT_COMPARE
argument_list|(
name|tts_user_tid
argument_list|)
operator|||
name|TT_COMPARE
argument_list|(
name|tts_event
argument_list|)
operator|||
name|TT_COMPARE
argument_list|(
name|tts_flags
argument_list|)
operator|||
name|TT_COMPARE
argument_list|(
name|tts_scno
argument_list|)
operator|||
name|TT_COMPARE
argument_list|(
name|tts_scnargs
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"Internal thread data for thread %d is wrong."
argument_list|,
name|tid
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PARANOIA */
end_comment

begin_escape
end_escape

begin_comment
comment|/* This function wraps calls to "call_real_ttrace_wait" so  * that a actual wait is only done when all pending events  * have been reported.  *  * Note that typically it is called with a pid of "0", i.e.   * the "don't care" value.  *  * Return value is the status of the pseudo wait.  */
end_comment

begin_function
specifier|static
name|int
name|call_ttrace_wait
parameter_list|(
name|pid
parameter_list|,
name|option
parameter_list|,
name|tsp
parameter_list|,
name|tsp_size
parameter_list|)
name|int
name|pid
decl_stmt|;
name|ttwopt_t
name|option
decl_stmt|;
name|ttstate_t
modifier|*
name|tsp
decl_stmt|;
name|size_t
name|tsp_size
decl_stmt|;
block|{
comment|/* This holds the actual, for-real, true process ID.    */
specifier|static
name|int
name|real_pid
decl_stmt|;
comment|/* As an argument to ttrace_wait, zero pid    * means "Any process", and zero tid means    * "Any thread of the specified process".    */
name|int
name|wait_pid
init|=
literal|0
decl_stmt|;
name|lwpid_t
name|wait_tid
init|=
literal|0
decl_stmt|;
name|lwpid_t
name|real_tid
decl_stmt|;
name|int
name|ttw_status
init|=
literal|0
decl_stmt|;
comment|/* To be returned */
name|thread_info
modifier|*
name|tinfo
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|pid
operator|!=
literal|0
condition|)
block|{
comment|/* Unexpected case.        */
ifdef|#
directive|ifdef
name|THREAD_DEBUG
if|if
condition|(
name|debug_on
condition|)
name|printf
argument_list|(
literal|"TW: Pid to wait on is %d\n"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|any_thread_records
argument_list|()
condition|)
name|error
argument_list|(
literal|"No thread records for ttrace call w. specific pid"
argument_list|)
expr_stmt|;
comment|/* OK, now the task is to translate the incoming tid into        * a pid/tid pair.        */
name|real_tid
operator|=
name|map_from_gdb_tid
argument_list|(
name|pid
argument_list|)
expr_stmt|;
name|real_pid
operator|=
name|get_pid_for
argument_list|(
name|real_tid
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|THREAD_DEBUG
if|if
condition|(
name|debug_on
condition|)
name|printf
argument_list|(
literal|"==TW: real pid %d, real tid %d\n"
argument_list|,
name|real_pid
argument_list|,
name|real_tid
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Sanity checks and set-up.    *                             Process State    *    *                        Stopped   Running    Fake-step  (v)Fork    *                      \________________________________________    *                      |    *  No buffered events  |  error     wait       wait      wait    *                      |    *  Buffered events     |  debuffer  error      wait      debuffer (?)    *    */
if|if
condition|(
name|more_events_left
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|process_state
operator|==
name|RUNNING
condition|)
block|{
comment|/* OK--normal call of ttrace_wait with no buffered events.            */
empty_stmt|;
block|}
elseif|else
if|if
condition|(
name|process_state
operator|==
name|FAKE_STEPPING
condition|)
block|{
comment|/* Ok--call of ttrace_wait to support            * fake stepping with no buffered events.            *            * But we better be fake-stepping!            */
if|if
condition|(
operator|!
name|doing_fake_step
condition|)
block|{
name|warning
argument_list|(
literal|"Inconsistent thread state."
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|process_state
operator|==
name|FORKING
operator|)
operator|||
operator|(
name|process_state
operator|==
name|VFORKING
operator|)
condition|)
block|{
comment|/* Ok--there are two processes, so waiting            * for the second while the first is stopped            * is ok.  Handled bits stay as they were.            */
empty_stmt|;
block|}
elseif|else
if|if
condition|(
name|process_state
operator|==
name|STOPPED
condition|)
block|{
name|warning
argument_list|(
literal|"Process not running at wait call."
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* No known state.            */
name|warning
argument_list|(
literal|"Inconsistent process state."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* More events left        */
if|if
condition|(
name|process_state
operator|==
name|STOPPED
condition|)
block|{
comment|/* OK--buffered events being unbuffered.            */
empty_stmt|;
block|}
elseif|else
if|if
condition|(
name|process_state
operator|==
name|RUNNING
condition|)
block|{
comment|/* An error--shouldn't have buffered events            * when running.            */
name|warning
argument_list|(
literal|"Trying to continue with buffered events:"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|process_state
operator|==
name|FAKE_STEPPING
condition|)
block|{
comment|/*            * Better be fake-stepping!            */
if|if
condition|(
operator|!
name|doing_fake_step
condition|)
block|{
name|warning
argument_list|(
literal|"Losing buffered thread events!\n"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|process_state
operator|==
name|FORKING
operator|)
operator|||
operator|(
name|process_state
operator|==
name|VFORKING
operator|)
condition|)
block|{
comment|/* Ok--there are two processes, so waiting            * for the second while the first is stopped            * is ok.  Handled bits stay as they were.            */
empty_stmt|;
block|}
else|else
name|warning
argument_list|(
literal|"Process in unknown state with buffered events."
argument_list|)
expr_stmt|;
block|}
comment|/* Sometimes we have to wait for a particular thread    * (if we're stepping over a bpt).  In that case, we    * _know_ it's going to complete the single-step we    * asked for (because we're only doing the step under    * certain very well-understood circumstances), so it    * can't block.    */
if|if
condition|(
name|doing_fake_step
condition|)
block|{
name|wait_tid
operator|=
name|fake_step_tid
expr_stmt|;
name|wait_pid
operator|=
name|get_pid_for
argument_list|(
name|fake_step_tid
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|WAIT_BUFFER_DEBUG
if|if
condition|(
name|debug_on
condition|)
name|printf
argument_list|(
literal|"Doing a wait after a fake-step for %d, pid %d\n"
argument_list|,
name|wait_tid
argument_list|,
name|wait_pid
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|more_events_left
operator|==
literal|0
comment|/* No buffered events, need real ones. */
operator|||
name|process_state
operator|!=
name|STOPPED
condition|)
block|{
comment|/* If there are no buffered events, and so we need        * real ones, or if we are FORKING, VFORKING,         * FAKE_STEPPING or RUNNING, and thus have to do        * a real wait, then do a real wait.        */
ifdef|#
directive|ifdef
name|WAIT_BUFFER_DEBUG
comment|/* Normal case... */
if|if
condition|(
name|debug_on
condition|)
name|printf
argument_list|(
literal|"TW: do it for real; pid %d, tid %d\n"
argument_list|,
name|wait_pid
argument_list|,
name|wait_tid
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* The actual wait call.        */
name|ttw_status
operator|=
name|call_real_ttrace_wait
argument_list|(
name|wait_pid
argument_list|,
name|wait_tid
argument_list|,
name|option
argument_list|,
name|tsp
argument_list|,
name|tsp_size
argument_list|)
expr_stmt|;
comment|/* Note that the routines we'll call will be using "call_real_ttrace",        * not "call_ttrace", and thus need the real pid rather than the pseudo-tid        * the rest of the world uses (which is actually the tid).        */
name|real_pid
operator|=
name|tsp
operator|->
name|tts_pid
expr_stmt|;
comment|/* For most events: Stop the world!        *        * It's sometimes not safe to stop all threads of a process.        * Sometimes it's not even safe to ask for the thread state        * of a process!        */
if|if
condition|(
name|can_touch_threads_of_process
argument_list|(
name|real_pid
argument_list|,
name|tsp
operator|->
name|tts_event
argument_list|)
condition|)
block|{
comment|/* If we're really only stepping a single thread, then don't            * try to stop all the others -- we only do this single-stepping            * business when all others were already stopped...and the stop            * would mess up other threads' events.            *            * Similiarly, if there are other threads with events,            * don't do the stop.            */
if|if
condition|(
operator|!
name|doing_fake_step
condition|)
block|{
if|if
condition|(
name|more_events_left
operator|>
literal|0
condition|)
name|warning
argument_list|(
literal|"Internal error in stopping process"
argument_list|)
expr_stmt|;
name|stop_all_threads_of_process
argument_list|(
name|real_pid
argument_list|)
expr_stmt|;
comment|/* At this point, we could scan and update_thread_list(),              * and only use the local list for the rest of the              * module! We'd get rid of the scans in the various              * continue routines (adding one in attach).  It'd              * be great--UPGRADE ME!              */
block|}
block|}
ifdef|#
directive|ifdef
name|PARANOIA
elseif|else
if|if
condition|(
name|debug_on
condition|)
block|{
if|if
condition|(
name|more_events_left
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"== Can't stop process; more events!\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"== Can't stop process!\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|process_state
operator|=
name|STOPPED
expr_stmt|;
ifdef|#
directive|ifdef
name|WAIT_BUFFER_DEBUG
if|if
condition|(
name|debug_on
condition|)
name|printf
argument_list|(
literal|"Process set to STOPPED\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* Fake a call to ttrace_wait.  The process must be        * STOPPED, as we aren't going to do any wait.        */
ifdef|#
directive|ifdef
name|WAIT_BUFFER_DEBUG
if|if
condition|(
name|debug_on
condition|)
name|printf
argument_list|(
literal|"TW: fake it\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|process_state
operator|!=
name|STOPPED
condition|)
block|{
name|warning
argument_list|(
literal|"Process not stopped at wait call, in state '%s'.\n"
argument_list|,
name|get_printable_name_of_process_state
argument_list|(
name|process_state
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|doing_fake_step
condition|)
name|error
argument_list|(
literal|"Internal error in stepping over breakpoint"
argument_list|)
expr_stmt|;
name|ttw_status
operator|=
literal|0
expr_stmt|;
comment|/* Faking it is always successful! */
block|}
comment|/* End of fake or not? if */
comment|/* Pick an event to pass to our caller.  Be paranoid.    */
if|if
condition|(
operator|!
name|select_stopped_thread_of_process
argument_list|(
name|real_pid
argument_list|,
name|tsp
argument_list|)
condition|)
name|warning
argument_list|(
literal|"Can't find event, using previous event."
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tsp
operator|->
name|tts_event
operator|==
name|TTEVT_NONE
condition|)
name|warning
argument_list|(
literal|"Internal error: no thread has a real event."
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|doing_fake_step
condition|)
block|{
if|if
condition|(
name|fake_step_tid
operator|!=
name|tsp
operator|->
name|tts_lwpid
condition|)
name|warning
argument_list|(
literal|"Internal error in stepping over breakpoint."
argument_list|)
expr_stmt|;
comment|/* This wait clears the (current) fake-step if there was one.        */
name|doing_fake_step
operator|=
literal|0
expr_stmt|;
name|fake_step_tid
operator|=
literal|0
expr_stmt|;
block|}
comment|/* We now have a correct tsp and ttw_status for the thread    * which we want to report.  So it's "handled"!  This call    * will add it to our list if it's not there already.    */
name|set_handled
argument_list|(
name|real_pid
argument_list|,
name|tsp
operator|->
name|tts_lwpid
argument_list|)
expr_stmt|;
comment|/* Save a copy of the ttrace state of this thread, in our local      thread descriptor.       This caches the state.  The implementation of queries like      target_has_execd can then use this cached state, rather than      be forced to make an explicit ttrace call to get it.       (Guard against the condition that this is the first time we've      waited on, i.e., seen this thread, and so haven't yet entered      it into our list of threads.)    */
name|tinfo
operator|=
name|find_thread_info
argument_list|(
name|tsp
operator|->
name|tts_lwpid
argument_list|)
expr_stmt|;
if|if
condition|(
name|tinfo
operator|!=
name|NULL
condition|)
block|{
name|copy_ttstate_t
argument_list|(
operator|&
name|tinfo
operator|->
name|last_stop_state
argument_list|,
name|tsp
argument_list|)
expr_stmt|;
name|tinfo
operator|->
name|have_state
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|ttw_status
return|;
block|}
end_function

begin_comment
comment|/* call_ttrace_wait */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CHILD_REPORTED_EXEC_EVENTS_PER_EXEC_CALL
argument_list|)
end_if

begin_function
name|int
name|child_reported_exec_events_per_exec_call
parameter_list|()
block|{
return|return
literal|1
return|;
comment|/* ttrace reports the event once per call. */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Our implementation of hardware watchpoints involves making memory    pages write-protected.  We must remember a page's original permissions,    and we must also know when it is appropriate to restore a page's    permissions to its original state.     We use a "dictionary" of hardware-watched pages to do this.  Each    hardware-watched page is recorded in the dictionary.  Each page's    dictionary entry contains the original permissions and a reference    count.  Pages are hashed into the dictionary by their start address.     When hardware watchpoint is set on page X for the first time, page X    is added to the dictionary with a reference count of 1.  If other    hardware watchpoints are subsequently set on page X, its reference    count is incremented.  When hardware watchpoints are removed from    page X, its reference count is decremented.  If a page's reference    count drops to 0, it's permissions are restored and the page's entry    is thrown out of the dictionary.    */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|memory_page
block|{
name|CORE_ADDR
name|page_start
decl_stmt|;
name|int
name|reference_count
decl_stmt|;
name|int
name|original_permissions
decl_stmt|;
name|struct
name|memory_page
modifier|*
name|next
decl_stmt|;
name|struct
name|memory_page
modifier|*
name|previous
decl_stmt|;
block|}
name|memory_page_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|MEMORY_PAGE_DICTIONARY_BUCKET_COUNT
value|128
end_define

begin_struct
specifier|static
struct|struct
block|{
name|LONGEST
name|page_count
decl_stmt|;
name|int
name|page_size
decl_stmt|;
name|int
name|page_protections_allowed
decl_stmt|;
comment|/* These are just the heads of chains of actual page descriptors. */
name|memory_page_t
name|buckets
index|[
name|MEMORY_PAGE_DICTIONARY_BUCKET_COUNT
index|]
decl_stmt|;
block|}
name|memory_page_dictionary
struct|;
end_struct

begin_function
specifier|static
name|void
name|require_memory_page_dictionary
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
comment|/* Is the memory page dictionary ready for use?  If so, we're done. */
if|if
condition|(
name|memory_page_dictionary
operator|.
name|page_count
operator|>=
operator|(
name|LONGEST
operator|)
literal|0
condition|)
return|return;
comment|/* Else, initialize it. */
name|memory_page_dictionary
operator|.
name|page_count
operator|=
operator|(
name|LONGEST
operator|)
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MEMORY_PAGE_DICTIONARY_BUCKET_COUNT
condition|;
name|i
operator|++
control|)
block|{
name|memory_page_dictionary
operator|.
name|buckets
index|[
name|i
index|]
operator|.
name|page_start
operator|=
operator|(
name|CORE_ADDR
operator|)
literal|0
expr_stmt|;
name|memory_page_dictionary
operator|.
name|buckets
index|[
name|i
index|]
operator|.
name|reference_count
operator|=
literal|0
expr_stmt|;
name|memory_page_dictionary
operator|.
name|buckets
index|[
name|i
index|]
operator|.
name|next
operator|=
name|NULL
expr_stmt|;
name|memory_page_dictionary
operator|.
name|buckets
index|[
name|i
index|]
operator|.
name|previous
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|retire_memory_page_dictionary
parameter_list|()
block|{
name|memory_page_dictionary
operator|.
name|page_count
operator|=
operator|(
name|LONGEST
operator|)
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write-protect the memory page that starts at this address.     Returns the original permissions of the page.  */
end_comment

begin_function
specifier|static
name|int
name|write_protect_page
parameter_list|(
name|pid
parameter_list|,
name|page_start
parameter_list|)
name|int
name|pid
decl_stmt|;
name|CORE_ADDR
name|page_start
decl_stmt|;
block|{
name|int
name|tt_status
decl_stmt|;
name|int
name|original_permissions
decl_stmt|;
name|int
name|new_permissions
decl_stmt|;
name|tt_status
operator|=
name|call_ttrace
argument_list|(
name|TT_PROC_GET_MPROTECT
argument_list|,
name|pid
argument_list|,
operator|(
name|TTRACE_ARG_TYPE
operator|)
name|page_start
argument_list|,
name|TT_NIL
argument_list|,
operator|(
name|TTRACE_ARG_TYPE
operator|)
operator|&
name|original_permissions
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|||
operator|(
name|tt_status
operator|<
literal|0
operator|)
condition|)
block|{
return|return
literal|0
return|;
comment|/* What else can we do? */
block|}
comment|/* We'll also write-protect the page now, if that's allowed. */
if|if
condition|(
name|memory_page_dictionary
operator|.
name|page_protections_allowed
condition|)
block|{
name|new_permissions
operator|=
name|original_permissions
operator|&
operator|~
name|PROT_WRITE
expr_stmt|;
name|tt_status
operator|=
name|call_ttrace
argument_list|(
name|TT_PROC_SET_MPROTECT
argument_list|,
name|pid
argument_list|,
operator|(
name|TTRACE_ARG_TYPE
operator|)
name|page_start
argument_list|,
operator|(
name|TTRACE_ARG_TYPE
operator|)
name|memory_page_dictionary
operator|.
name|page_size
argument_list|,
operator|(
name|TTRACE_ARG_TYPE
operator|)
name|new_permissions
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|||
operator|(
name|tt_status
operator|<
literal|0
operator|)
condition|)
block|{
return|return
literal|0
return|;
comment|/* What else can we do? */
block|}
block|}
return|return
name|original_permissions
return|;
block|}
end_function

begin_comment
comment|/* Unwrite-protect the memory page that starts at this address, restoring    (what we must assume are) its original permissions.    */
end_comment

begin_function
specifier|static
name|void
name|unwrite_protect_page
parameter_list|(
name|pid
parameter_list|,
name|page_start
parameter_list|,
name|original_permissions
parameter_list|)
name|int
name|pid
decl_stmt|;
name|CORE_ADDR
name|page_start
decl_stmt|;
name|int
name|original_permissions
decl_stmt|;
block|{
name|int
name|tt_status
decl_stmt|;
name|tt_status
operator|=
name|call_ttrace
argument_list|(
name|TT_PROC_SET_MPROTECT
argument_list|,
name|pid
argument_list|,
operator|(
name|TTRACE_ARG_TYPE
operator|)
name|page_start
argument_list|,
operator|(
name|TTRACE_ARG_TYPE
operator|)
name|memory_page_dictionary
operator|.
name|page_size
argument_list|,
operator|(
name|TTRACE_ARG_TYPE
operator|)
name|original_permissions
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|||
operator|(
name|tt_status
operator|<
literal|0
operator|)
condition|)
block|{
return|return;
comment|/* What else can we do? */
block|}
block|}
end_function

begin_comment
comment|/* Memory page-protections are used to implement "hardware" watchpoints    on HP-UX.     For every memory page that is currently being watched (i.e., that    presently should be write-protected), write-protect it.    */
end_comment

begin_function
name|void
name|hppa_enable_page_protection_events
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
name|int
name|bucket
decl_stmt|;
name|memory_page_dictionary
operator|.
name|page_protections_allowed
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|bucket
operator|=
literal|0
init|;
name|bucket
operator|<
name|MEMORY_PAGE_DICTIONARY_BUCKET_COUNT
condition|;
name|bucket
operator|++
control|)
block|{
name|memory_page_t
modifier|*
name|page
decl_stmt|;
name|page
operator|=
name|memory_page_dictionary
operator|.
name|buckets
index|[
name|bucket
index|]
operator|.
name|next
expr_stmt|;
while|while
condition|(
name|page
operator|!=
name|NULL
condition|)
block|{
name|page
operator|->
name|original_permissions
operator|=
name|write_protect_page
argument_list|(
name|pid
argument_list|,
name|page
operator|->
name|page_start
argument_list|)
expr_stmt|;
name|page
operator|=
name|page
operator|->
name|next
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Memory page-protections are used to implement "hardware" watchpoints    on HP-UX.     For every memory page that is currently being watched (i.e., that    presently is or should be write-protected), un-write-protect it.    */
end_comment

begin_function
name|void
name|hppa_disable_page_protection_events
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
name|int
name|bucket
decl_stmt|;
for|for
control|(
name|bucket
operator|=
literal|0
init|;
name|bucket
operator|<
name|MEMORY_PAGE_DICTIONARY_BUCKET_COUNT
condition|;
name|bucket
operator|++
control|)
block|{
name|memory_page_t
modifier|*
name|page
decl_stmt|;
name|page
operator|=
name|memory_page_dictionary
operator|.
name|buckets
index|[
name|bucket
index|]
operator|.
name|next
expr_stmt|;
while|while
condition|(
name|page
operator|!=
name|NULL
condition|)
block|{
name|unwrite_protect_page
argument_list|(
name|pid
argument_list|,
name|page
operator|->
name|page_start
argument_list|,
name|page
operator|->
name|original_permissions
argument_list|)
expr_stmt|;
name|page
operator|=
name|page
operator|->
name|next
expr_stmt|;
block|}
block|}
name|memory_page_dictionary
operator|.
name|page_protections_allowed
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Count the number of outstanding events.  At this  * point, we have selected one thread and its event  * as the one to be "reported" upwards to core gdb.  * That thread is already marked as "handled".  *  * Note: we could just scan our own thread list.  FIXME!  */
end_comment

begin_function
specifier|static
name|int
name|count_unhandled_events
parameter_list|(
name|real_pid
parameter_list|,
name|real_tid
parameter_list|)
name|int
name|real_pid
decl_stmt|;
name|lwpid_t
name|real_tid
decl_stmt|;
block|{
name|ttstate_t
name|tstate
decl_stmt|;
name|lwpid_t
name|ttid
decl_stmt|;
name|int
name|events_left
decl_stmt|;
comment|/* Ok, find out how many threads have real events to report.    */
name|events_left
operator|=
literal|0
expr_stmt|;
name|ttid
operator|=
name|get_process_first_stopped_thread_id
argument_list|(
name|real_pid
argument_list|,
operator|&
name|tstate
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|THREAD_DEBUG
if|if
condition|(
name|debug_on
condition|)
block|{
if|if
condition|(
name|ttid
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"Process %d has no threads\n"
argument_list|,
name|real_pid
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"Process %d has these threads:\n"
argument_list|,
name|real_pid
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
while|while
condition|(
name|ttid
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|tstate
operator|.
name|tts_event
operator|!=
name|TTEVT_NONE
operator|&&
operator|!
name|was_handled
argument_list|(
name|ttid
argument_list|)
condition|)
block|{
comment|/* TTEVT_NONE implies we just stopped it ourselves            * because we're the stop-the-world guys, so it's            * not an event from our point of view.            *            * If "was_handled" is true, this is an event we            * already handled, so don't count it.            *            * Note that we don't count the thread with the            * currently-reported event, as it's already marked            * as handled.            */
name|events_left
operator|++
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|THREAD_DEBUG
argument_list|)
operator|||
name|defined
argument_list|(
name|WAIT_BUFFER_DEBUG
argument_list|)
if|if
condition|(
name|debug_on
condition|)
block|{
if|if
condition|(
name|ttid
operator|==
name|real_tid
condition|)
name|printf
argument_list|(
literal|"*"
argument_list|)
expr_stmt|;
comment|/* Thread we're reporting */
else|else
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
if|if
condition|(
name|tstate
operator|.
name|tts_event
operator|!=
name|TTEVT_NONE
condition|)
name|printf
argument_list|(
literal|"+"
argument_list|)
expr_stmt|;
comment|/* Thread with a real event */
else|else
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
if|if
condition|(
name|was_handled
argument_list|(
name|ttid
argument_list|)
condition|)
name|printf
argument_list|(
literal|"h"
argument_list|)
expr_stmt|;
comment|/* Thread has been handled */
else|else
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %d, with event %s"
argument_list|,
name|ttid
argument_list|,
name|get_printable_name_of_ttrace_event
argument_list|(
name|tstate
operator|.
name|tts_event
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tstate
operator|.
name|tts_event
operator|==
name|TTEVT_SIGNAL
operator|&&
literal|5
operator|==
name|tstate
operator|.
name|tts_u
operator|.
name|tts_signal
operator|.
name|tts_signo
condition|)
block|{
name|CORE_ADDR
name|pc_val
decl_stmt|;
name|pc_val
operator|=
name|get_raw_pc
argument_list|(
name|ttid
argument_list|)
expr_stmt|;
if|if
condition|(
name|pc_val
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|" breakpoint at 0x%x\n"
argument_list|,
name|pc_val
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" bpt, can't fetch pc.\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|ttid
operator|=
name|get_process_next_stopped_thread_id
argument_list|(
name|real_pid
argument_list|,
operator|&
name|tstate
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|THREAD_DEBUG
argument_list|)
operator|||
name|defined
argument_list|(
name|WAIT_BUFFER_DEBUG
argument_list|)
if|if
condition|(
name|debug_on
condition|)
if|if
condition|(
name|events_left
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"There are thus %d pending events\n"
argument_list|,
name|events_left
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|events_left
return|;
block|}
end_function

begin_comment
comment|/* This function is provided as a sop to clients that are calling  * ptrace_wait to wait for a process to stop.  (see the  * implementation of child_wait.)  Return value is the pid for  * the event that ended the wait.  *  * Note: used by core gdb and so uses the pseudo-pid (really tid).  */
end_comment

begin_function
name|int
name|ptrace_wait
parameter_list|(
name|pid
parameter_list|,
name|status
parameter_list|)
name|int
name|pid
decl_stmt|;
name|int
modifier|*
name|status
decl_stmt|;
block|{
name|ttstate_t
name|tsp
decl_stmt|;
name|int
name|ttwait_return
decl_stmt|;
name|int
name|real_pid
decl_stmt|;
name|ttstate_t
name|state
decl_stmt|;
name|lwpid_t
name|real_tid
decl_stmt|;
name|int
name|return_pid
decl_stmt|;
comment|/* The ptrace implementation of this also ignores pid.    */
operator|*
name|status
operator|=
literal|0
expr_stmt|;
name|ttwait_return
operator|=
name|call_ttrace_wait
argument_list|(
literal|0
argument_list|,
name|TTRACE_WAITOK
argument_list|,
operator|&
name|tsp
argument_list|,
sizeof|sizeof
argument_list|(
name|tsp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ttwait_return
operator|<
literal|0
condition|)
block|{
comment|/* ??rehrauer: It appears that if our inferior exits and we          haven't asked for exit events, that we're not getting any          indication save a negative return from ttrace_wait and an          errno set to ESRCH?          */
if|if
condition|(
name|errno
operator|==
name|ESRCH
condition|)
block|{
operator|*
name|status
operator|=
literal|0
expr_stmt|;
comment|/* WIFEXITED */
return|return
name|inferior_pid
return|;
block|}
name|warning
argument_list|(
literal|"Call of ttrace_wait returned with errno %d."
argument_list|,
name|errno
argument_list|)
expr_stmt|;
operator|*
name|status
operator|=
name|ttwait_return
expr_stmt|;
return|return
name|inferior_pid
return|;
block|}
name|real_pid
operator|=
name|tsp
operator|.
name|tts_pid
expr_stmt|;
name|real_tid
operator|=
name|tsp
operator|.
name|tts_lwpid
expr_stmt|;
comment|/* One complication is that the "tts_event" structure has    * a set of flags, and more than one can be set.  So we    * either have to force an order (as we do here), or handle    * more than one flag at a time.    */
if|if
condition|(
name|tsp
operator|.
name|tts_event
operator|&
name|TTEVT_LWP_CREATE
condition|)
block|{
comment|/* Unlike what you might expect, this event is reported in       * the _creating_ thread, and the _created_ thread (whose tid       * we have) is still running.  So we have to stop it.  This       * has already been done in "call_ttrace_wait", but should we       * ever abandon the "stop-the-world" model, here's the command       * to use:       *       *    call_ttrace( TT_LWP_STOP, real_tid, TT_NIL, TT_NIL, TT_NIL );       *       * Note that this would depend on being called _after_ "add_tthread"       * below for the tid-to-pid translation to be done in "call_ttrace".       */
ifdef|#
directive|ifdef
name|THREAD_DEBUG
if|if
condition|(
name|debug_on
condition|)
name|printf
argument_list|(
literal|"New thread: pid %d, tid %d, creator tid %d\n"
argument_list|,
name|real_pid
argument_list|,
name|tsp
operator|.
name|tts_u
operator|.
name|tts_thread
operator|.
name|tts_target_lwpid
argument_list|,
name|real_tid
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Now we have to return the tid of the created thread, not       * the creating thread, or "wait_for_inferior" won't know we       * have a new "process" (thread).  Plus we should record it       * right, too.       */
name|real_tid
operator|=
name|tsp
operator|.
name|tts_u
operator|.
name|tts_thread
operator|.
name|tts_target_lwpid
expr_stmt|;
name|add_tthread
argument_list|(
name|real_pid
argument_list|,
name|real_tid
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|tsp
operator|.
name|tts_event
operator|&
name|TTEVT_LWP_TERMINATE
operator|)
operator|||
operator|(
name|tsp
operator|.
name|tts_event
operator|&
name|TTEVT_LWP_EXIT
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|THREAD_DEBUG
if|if
condition|(
name|debug_on
condition|)
name|printf
argument_list|(
literal|"Thread dies: %d\n"
argument_list|,
name|real_tid
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|del_tthread
argument_list|(
name|real_tid
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tsp
operator|.
name|tts_event
operator|&
name|TTEVT_EXEC
condition|)
block|{
ifdef|#
directive|ifdef
name|THREAD_DEBUG
if|if
condition|(
name|debug_on
condition|)
name|printf
argument_list|(
literal|"Pid %d has zero'th thread %d; inferior pid is %d\n"
argument_list|,
name|real_pid
argument_list|,
name|real_tid
argument_list|,
name|inferior_pid
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|add_tthread
argument_list|(
name|real_pid
argument_list|,
name|real_tid
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|THREAD_DEBUG
elseif|else
if|if
condition|(
name|debug_on
condition|)
block|{
name|printf
argument_list|(
literal|"Process-level event %s, using tid %d\n"
argument_list|,
name|get_printable_name_of_ttrace_event
argument_list|(
name|tsp
operator|.
name|tts_event
argument_list|)
argument_list|,
name|real_tid
argument_list|)
expr_stmt|;
comment|/* OK to do this, as "add_tthread" won't add       * duplicate entries.  Also OK not to do it,       * as this event isn't one which can change the       * thread state.       */
name|add_tthread
argument_list|(
name|real_pid
argument_list|,
name|real_tid
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* How many events are left to report later?    * In a non-stop-the-world model, this isn't needed.    *    * Note that it's not always safe to query the thread state of a process,    * which is what count_unhandled_events does.  (If unsafe, we're left with    * no other resort than to assume that no more events remain...)    */
if|if
condition|(
name|can_touch_threads_of_process
argument_list|(
name|real_pid
argument_list|,
name|tsp
operator|.
name|tts_event
argument_list|)
condition|)
name|more_events_left
operator|=
name|count_unhandled_events
argument_list|(
name|real_pid
argument_list|,
name|real_tid
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|more_events_left
operator|>
literal|0
condition|)
name|warning
argument_list|(
literal|"Vfork or fork causing loss of %d buffered events."
argument_list|,
name|more_events_left
argument_list|)
expr_stmt|;
name|more_events_left
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Attempt to translate the ttrace_wait-returned status into the      ptrace equivalent.       ??rehrauer: This is somewhat fragile.  We really ought to rewrite      clients that expect to pick apart a ptrace wait status, to use      something a little more abstract.      */
if|if
condition|(
operator|(
name|tsp
operator|.
name|tts_event
operator|&
name|TTEVT_EXEC
operator|)
operator|||
operator|(
name|tsp
operator|.
name|tts_event
operator|&
name|TTEVT_FORK
operator|)
operator|||
operator|(
name|tsp
operator|.
name|tts_event
operator|&
name|TTEVT_VFORK
operator|)
condition|)
block|{
comment|/* Forks come in pairs (parent and child), so core gdb        * will do two waits.  Be ready to notice this.        */
if|if
condition|(
name|tsp
operator|.
name|tts_event
operator|&
name|TTEVT_FORK
condition|)
block|{
name|process_state
operator|=
name|FORKING
expr_stmt|;
ifdef|#
directive|ifdef
name|WAIT_BUFFER_DEBUG
if|if
condition|(
name|debug_on
condition|)
name|printf
argument_list|(
literal|"Process set to FORKING\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|tsp
operator|.
name|tts_event
operator|&
name|TTEVT_VFORK
condition|)
block|{
name|process_state
operator|=
name|VFORKING
expr_stmt|;
ifdef|#
directive|ifdef
name|WAIT_BUFFER_DEBUG
if|if
condition|(
name|debug_on
condition|)
name|printf
argument_list|(
literal|"Process set to VFORKING\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Make an exec or fork look like a breakpoint.  Definitely a hack,          but I don't think non HP-UX-specific clients really carefully          inspect the first events they get after inferior startup, so          it probably almost doesn't matter what we claim this is.          */
ifdef|#
directive|ifdef
name|THREAD_DEBUG
if|if
condition|(
name|debug_on
condition|)
name|printf
argument_list|(
literal|"..a process 'event'\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Also make fork and exec events look like bpts, so they can be caught.       */
operator|*
name|status
operator|=
literal|0177
operator||
operator|(
name|_SIGTRAP
operator|<<
literal|8
operator|)
expr_stmt|;
block|}
comment|/* Special-cases: We ask for syscall entry and exit events to implement      "fast" (aka "hardware") watchpoints.       When we get a syscall entry, we want to disable page-protections,      and resume the inferior; this isn't an event we wish for      wait_for_inferior to see.  Note that we must resume ONLY the      thread that reported the syscall entry; we don't want to allow      other threads to run with the page protections off, as they might      then be able to write to watch memory without it being caught.       When we get a syscall exit, we want to reenable page-protections,      but we don't want to resume the inferior; this is an event we wish      wait_for_inferior to see.  Make it look like the signal we normally      get for a single-step completion.  This should cause wait_for_inferior      to evaluate whether any watchpoint triggered.       Or rather, that's what we'd LIKE to do for syscall exit; we can't,      due to some HP-UX "features".  Some syscalls have problems with      write-protections on some pages, and some syscalls seem to have      pending writes to those pages at the time we're getting the return      event.  So, we'll single-step the inferior to get out of the syscall,      and then reenable protections.       Note that we're intentionally allowing the syscall exit case to      fall through into the succeeding cases, as sometimes we single-      step out of one syscall only to immediately enter another...    */
elseif|else
if|if
condition|(
operator|(
name|tsp
operator|.
name|tts_event
operator|&
name|TTEVT_SYSCALL_ENTRY
operator|)
operator|||
operator|(
name|tsp
operator|.
name|tts_event
operator|&
name|TTEVT_SYSCALL_RETURN
operator|)
condition|)
block|{
comment|/* Make a syscall event look like a breakpoint.  Same comments          as for exec& fork events.          */
ifdef|#
directive|ifdef
name|THREAD_DEBUG
if|if
condition|(
name|debug_on
condition|)
name|printf
argument_list|(
literal|"..a syscall 'event'\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Also make syscall events look like bpts, so they can be caught.       */
operator|*
name|status
operator|=
literal|0177
operator||
operator|(
name|_SIGTRAP
operator|<<
literal|8
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|tsp
operator|.
name|tts_event
operator|&
name|TTEVT_LWP_CREATE
operator|)
operator|||
operator|(
name|tsp
operator|.
name|tts_event
operator|&
name|TTEVT_LWP_TERMINATE
operator|)
operator|||
operator|(
name|tsp
operator|.
name|tts_event
operator|&
name|TTEVT_LWP_EXIT
operator|)
condition|)
block|{
comment|/* Make a thread event look like a breakpoint.  Same comments        * as for exec& fork events.        */
ifdef|#
directive|ifdef
name|THREAD_DEBUG
if|if
condition|(
name|debug_on
condition|)
name|printf
argument_list|(
literal|"..a thread 'event'\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Also make thread events look like bpts, so they can be caught.       */
operator|*
name|status
operator|=
literal|0177
operator||
operator|(
name|_SIGTRAP
operator|<<
literal|8
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|tsp
operator|.
name|tts_event
operator|&
name|TTEVT_EXIT
operator|)
condition|)
block|{
comment|/* WIFEXITED */
ifdef|#
directive|ifdef
name|THREAD_DEBUG
if|if
condition|(
name|debug_on
condition|)
name|printf
argument_list|(
literal|"..an exit\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Prevent rest of gdb from thinking this is        * a new thread if for some reason it's never        * seen the main thread before.        */
name|inferior_pid
operator|=
name|map_to_gdb_tid
argument_list|(
name|real_tid
argument_list|)
expr_stmt|;
comment|/* HACK, FIX */
operator|*
name|status
operator|=
literal|0
operator||
operator|(
name|tsp
operator|.
name|tts_u
operator|.
name|tts_exit
operator|.
name|tts_exitcode
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tsp
operator|.
name|tts_event
operator|&
name|TTEVT_SIGNAL
condition|)
block|{
comment|/* WIFSTOPPED */
ifdef|#
directive|ifdef
name|THREAD_DEBUG
if|if
condition|(
name|debug_on
condition|)
name|printf
argument_list|(
literal|"..a signal, %d\n"
argument_list|,
name|tsp
operator|.
name|tts_u
operator|.
name|tts_signal
operator|.
name|tts_signo
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|status
operator|=
literal|0177
operator||
operator|(
name|tsp
operator|.
name|tts_u
operator|.
name|tts_signal
operator|.
name|tts_signo
operator|<<
literal|8
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* !WIFSTOPPED */
comment|/* This means the process or thread terminated.  But we should've          caught an explicit exit/termination above.  So warn (this is          really an internal error) and claim the process or thread          terminated with a SIGTRAP.        */
name|warning
argument_list|(
literal|"process_wait: unknown process state"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|THREAD_DEBUG
if|if
condition|(
name|debug_on
condition|)
name|printf
argument_list|(
literal|"Process-level event %s, using tid %d\n"
argument_list|,
name|get_printable_name_of_ttrace_event
argument_list|(
name|tsp
operator|.
name|tts_event
argument_list|)
argument_list|,
name|real_tid
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|status
operator|=
name|_SIGTRAP
expr_stmt|;
block|}
name|target_post_wait
argument_list|(
name|tsp
operator|.
name|tts_pid
argument_list|,
operator|*
name|status
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|THREAD_DEBUG
if|if
condition|(
name|debug_on
condition|)
name|printf
argument_list|(
literal|"Done waiting, pid is %d, tid %d\n"
argument_list|,
name|real_pid
argument_list|,
name|real_tid
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* All code external to this module uses the tid, but calls    * it "pid".  There's some tweaking so that the outside sees    * the first thread as having the same number as the starting    * pid.    */
name|return_pid
operator|=
name|map_to_gdb_tid
argument_list|(
name|real_tid
argument_list|)
expr_stmt|;
comment|/* Remember this for later use in "hppa_prepare_to_proceed".    */
name|old_gdb_pid
operator|=
name|inferior_pid
expr_stmt|;
name|reported_pid
operator|=
name|return_pid
expr_stmt|;
name|reported_bpt
operator|=
operator|(
operator|(
name|tsp
operator|.
name|tts_event
operator|&
name|TTEVT_SIGNAL
operator|)
operator|&&
operator|(
literal|5
operator|==
name|tsp
operator|.
name|tts_u
operator|.
name|tts_signal
operator|.
name|tts_signo
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|real_tid
operator|==
literal|0
operator|||
name|return_pid
operator|==
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"Internal error: process-wait failed."
argument_list|)
expr_stmt|;
block|}
return|return
name|return_pid
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This function causes the caller's process to be traced by its    parent.  This is intended to be called after GDB forks itself,    and before the child execs the target.  Despite the name, it    is called by the child.     Note that HP-UX ttrace is rather funky in how this is done.    If the parent wants to get the initial exec event of a child,    it must set the ttrace event mask of the child to include execs.    (The child cannot do this itself.)  This must be done after the    child is forked, but before it execs.     To coordinate the parent and child, we implement a semaphore using    pipes.  After SETTRC'ing itself, the child tells the parent that    it is now traceable by the parent, and waits for the parent's    acknowledgement.  The parent can then set the child's event mask,    and notify the child that it can now exec.     (The acknowledgement by parent happens as a result of a call to    child_acknowledge_created_inferior.)  */
end_comment

begin_function
name|int
name|parent_attach_all
parameter_list|()
block|{
name|int
name|tt_status
decl_stmt|;
comment|/* We need a memory home for a constant, to pass it to ttrace.      The value of the constant is arbitrary, so long as both      parent and child use the same value.  Might as well use the      "magic" constant provided by ttrace...    */
name|uint64_t
name|tc_magic_child
init|=
name|TT_VERSION
decl_stmt|;
name|uint64_t
name|tc_magic_parent
init|=
literal|0
decl_stmt|;
name|tt_status
operator|=
name|call_real_ttrace
argument_list|(
name|TT_PROC_SETTRC
argument_list|,
operator|(
name|int
operator|)
name|TT_NIL
argument_list|,
operator|(
name|lwpid_t
operator|)
name|TT_NIL
argument_list|,
name|TT_NIL
argument_list|,
operator|(
name|TTRACE_ARG_TYPE
operator|)
name|TT_VERSION
argument_list|,
name|TT_NIL
argument_list|)
expr_stmt|;
if|if
condition|(
name|tt_status
operator|<
literal|0
condition|)
return|return
name|tt_status
return|;
comment|/* Notify the parent that we're potentially ready to exec(). */
name|write
argument_list|(
name|startup_semaphore
operator|.
name|child_channel
index|[
name|SEM_TALK
index|]
argument_list|,
operator|&
name|tc_magic_child
argument_list|,
sizeof|sizeof
argument_list|(
name|tc_magic_child
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Wait for acknowledgement from the parent. */
name|read
argument_list|(
name|startup_semaphore
operator|.
name|parent_channel
index|[
name|SEM_LISTEN
index|]
argument_list|,
operator|&
name|tc_magic_parent
argument_list|,
sizeof|sizeof
argument_list|(
name|tc_magic_parent
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tc_magic_child
operator|!=
name|tc_magic_parent
condition|)
name|warning
argument_list|(
literal|"mismatched semaphore magic"
argument_list|)
expr_stmt|;
comment|/* Discard our copy of the semaphore. */
operator|(
name|void
operator|)
name|close
argument_list|(
name|startup_semaphore
operator|.
name|parent_channel
index|[
name|SEM_LISTEN
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|startup_semaphore
operator|.
name|parent_channel
index|[
name|SEM_TALK
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|startup_semaphore
operator|.
name|child_channel
index|[
name|SEM_LISTEN
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|startup_semaphore
operator|.
name|child_channel
index|[
name|SEM_TALK
index|]
argument_list|)
expr_stmt|;
return|return
name|tt_status
return|;
block|}
end_function

begin_comment
comment|/* Despite being file-local, this routine is dealing with  * actual process IDs, not thread ids.  That's because it's  * called before the first "wait" call, and there's no map  * yet from tids to pids.  *  * When it is called, a forked child is running, but waiting on  * the semaphore.  If you stop the child and re-start it,  * things get confused, so don't do that!  An attached child is  * stopped.  *  * Since this is called after either attach or run, we  * have to be the common part of both.  */
end_comment

begin_function
specifier|static
name|void
name|require_notification_of_events
parameter_list|(
name|real_pid
parameter_list|)
name|int
name|real_pid
decl_stmt|;
block|{
name|int
name|tt_status
decl_stmt|;
name|ttevent_t
name|notifiable_events
decl_stmt|;
name|lwpid_t
name|tid
decl_stmt|;
name|ttstate_t
name|thread_state
decl_stmt|;
ifdef|#
directive|ifdef
name|THREAD_DEBUG
if|if
condition|(
name|debug_on
condition|)
name|printf
argument_list|(
literal|"Require notif, pid is %d\n"
argument_list|,
name|real_pid
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Temporary HACK: tell inftarg.c/child_wait to not    * loop until pids are the same.    */
name|not_same_real_pid
operator|=
literal|0
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|notifiable_events
operator|.
name|tte_signals
argument_list|)
expr_stmt|;
name|notifiable_events
operator|.
name|tte_opts
operator|=
name|TTEO_NONE
expr_stmt|;
comment|/* This ensures that forked children inherit their parent's    * event mask, which we're setting here.    *    * NOTE: if you debug gdb with itself, then the ultimate    *       debuggee gets flags set by the outermost gdb, as    *       a child of a child will still inherit.    */
name|notifiable_events
operator|.
name|tte_opts
operator||=
name|TTEO_PROC_INHERIT
expr_stmt|;
name|notifiable_events
operator|.
name|tte_events
operator|=
name|TTEVT_DEFAULT
expr_stmt|;
name|notifiable_events
operator|.
name|tte_events
operator||=
name|TTEVT_SIGNAL
expr_stmt|;
name|notifiable_events
operator|.
name|tte_events
operator||=
name|TTEVT_EXEC
expr_stmt|;
name|notifiable_events
operator|.
name|tte_events
operator||=
name|TTEVT_EXIT
expr_stmt|;
name|notifiable_events
operator|.
name|tte_events
operator||=
name|TTEVT_FORK
expr_stmt|;
name|notifiable_events
operator|.
name|tte_events
operator||=
name|TTEVT_VFORK
expr_stmt|;
name|notifiable_events
operator|.
name|tte_events
operator||=
name|TTEVT_LWP_CREATE
expr_stmt|;
name|notifiable_events
operator|.
name|tte_events
operator||=
name|TTEVT_LWP_EXIT
expr_stmt|;
name|notifiable_events
operator|.
name|tte_events
operator||=
name|TTEVT_LWP_TERMINATE
expr_stmt|;
name|tt_status
operator|=
name|call_real_ttrace
argument_list|(
name|TT_PROC_SET_EVENT_MASK
argument_list|,
name|real_pid
argument_list|,
operator|(
name|lwpid_t
operator|)
name|TT_NIL
argument_list|,
operator|(
name|TTRACE_ARG_TYPE
operator|)
operator|&
name|notifiable_events
argument_list|,
operator|(
name|TTRACE_ARG_TYPE
operator|)
sizeof|sizeof
argument_list|(
name|notifiable_events
argument_list|)
argument_list|,
name|TT_NIL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|require_notification_of_exec_events
parameter_list|(
name|real_pid
parameter_list|)
name|int
name|real_pid
decl_stmt|;
block|{
name|int
name|tt_status
decl_stmt|;
name|ttevent_t
name|notifiable_events
decl_stmt|;
name|lwpid_t
name|tid
decl_stmt|;
name|ttstate_t
name|thread_state
decl_stmt|;
ifdef|#
directive|ifdef
name|THREAD_DEBUG
if|if
condition|(
name|debug_on
condition|)
name|printf
argument_list|(
literal|"Require notif, pid is %d\n"
argument_list|,
name|real_pid
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Temporary HACK: tell inftarg.c/child_wait to not    * loop until pids are the same.    */
name|not_same_real_pid
operator|=
literal|0
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|notifiable_events
operator|.
name|tte_signals
argument_list|)
expr_stmt|;
name|notifiable_events
operator|.
name|tte_opts
operator|=
name|TTEO_NOSTRCCHLD
expr_stmt|;
comment|/* This ensures that forked children don't inherit their parent's    * event mask, which we're setting here.    */
name|notifiable_events
operator|.
name|tte_opts
operator|&=
operator|~
name|TTEO_PROC_INHERIT
expr_stmt|;
name|notifiable_events
operator|.
name|tte_events
operator|=
name|TTEVT_DEFAULT
expr_stmt|;
name|notifiable_events
operator|.
name|tte_events
operator||=
name|TTEVT_EXEC
expr_stmt|;
name|notifiable_events
operator|.
name|tte_events
operator||=
name|TTEVT_EXIT
expr_stmt|;
name|tt_status
operator|=
name|call_real_ttrace
argument_list|(
name|TT_PROC_SET_EVENT_MASK
argument_list|,
name|real_pid
argument_list|,
operator|(
name|lwpid_t
operator|)
name|TT_NIL
argument_list|,
operator|(
name|TTRACE_ARG_TYPE
operator|)
operator|&
name|notifiable_events
argument_list|,
operator|(
name|TTRACE_ARG_TYPE
operator|)
sizeof|sizeof
argument_list|(
name|notifiable_events
argument_list|)
argument_list|,
name|TT_NIL
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This function is called by the parent process, with pid being the  * ID of the child process, after the debugger has forked.  */
end_comment

begin_function
name|void
name|child_acknowledge_created_inferior
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
comment|/* We need a memory home for a constant, to pass it to ttrace.      The value of the constant is arbitrary, so long as both      parent and child use the same value.  Might as well use the      "magic" constant provided by ttrace...      */
name|uint64_t
name|tc_magic_parent
init|=
name|TT_VERSION
decl_stmt|;
name|uint64_t
name|tc_magic_child
init|=
literal|0
decl_stmt|;
comment|/* Wait for the child to tell us that it has forked. */
name|read
argument_list|(
name|startup_semaphore
operator|.
name|child_channel
index|[
name|SEM_LISTEN
index|]
argument_list|,
operator|&
name|tc_magic_child
argument_list|,
sizeof|sizeof
argument_list|(
name|tc_magic_child
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Clear thread info now.  We'd like to do this in    * "require...", but that messes up attach.    */
name|clear_thread_info
argument_list|()
expr_stmt|;
comment|/* Tell the "rest of gdb" that the initial thread exists.    * This isn't really a hack.  Other thread-based versions    * of gdb (e.g. gnu-nat.c) seem to do the same thing.    *    * Q: Why don't we also add this thread to the local    *    list via "add_tthread"?    *    * A: Because we don't know the tid, and can't stop the    *    the process safely to ask what it is.  Anyway, we'll    *    add it when it gets the EXEC event.    */
name|add_thread
argument_list|(
name|pid
argument_list|)
expr_stmt|;
comment|/* in thread.c */
comment|/* We can now set the child's ttrace event mask.    */
name|require_notification_of_exec_events
argument_list|(
name|pid
argument_list|)
expr_stmt|;
comment|/* Tell ourselves that the process is running.    */
name|process_state
operator|=
name|RUNNING
expr_stmt|;
comment|/* Notify the child that it can exec. */
name|write
argument_list|(
name|startup_semaphore
operator|.
name|parent_channel
index|[
name|SEM_TALK
index|]
argument_list|,
operator|&
name|tc_magic_parent
argument_list|,
sizeof|sizeof
argument_list|(
name|tc_magic_parent
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Discard our copy of the semaphore. */
operator|(
name|void
operator|)
name|close
argument_list|(
name|startup_semaphore
operator|.
name|parent_channel
index|[
name|SEM_LISTEN
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|startup_semaphore
operator|.
name|parent_channel
index|[
name|SEM_TALK
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|startup_semaphore
operator|.
name|child_channel
index|[
name|SEM_LISTEN
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|startup_semaphore
operator|.
name|child_channel
index|[
name|SEM_TALK
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * arrange for notification of all events by  * calling require_notification_of_events.  */
end_comment

begin_function
name|void
name|child_post_startup_inferior
parameter_list|(
name|real_pid
parameter_list|)
name|int
name|real_pid
decl_stmt|;
block|{
name|require_notification_of_events
argument_list|(
name|real_pid
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* From here on, we should expect tids rather than pids.  */
end_comment

begin_function
specifier|static
name|void
name|hppa_enable_catch_fork
parameter_list|(
name|tid
parameter_list|)
name|int
name|tid
decl_stmt|;
block|{
name|int
name|tt_status
decl_stmt|;
name|ttevent_t
name|ttrace_events
decl_stmt|;
comment|/* Get the set of events that are currently enabled.    */
name|tt_status
operator|=
name|call_ttrace
argument_list|(
name|TT_PROC_GET_EVENT_MASK
argument_list|,
name|tid
argument_list|,
operator|(
name|TTRACE_ARG_TYPE
operator|)
operator|&
name|ttrace_events
argument_list|,
operator|(
name|TTRACE_ARG_TYPE
operator|)
sizeof|sizeof
argument_list|(
name|ttrace_events
argument_list|)
argument_list|,
name|TT_NIL
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
name|perror_with_name
argument_list|(
literal|"ttrace"
argument_list|)
expr_stmt|;
comment|/* Add forks to that set. */
name|ttrace_events
operator|.
name|tte_events
operator||=
name|TTEVT_FORK
expr_stmt|;
ifdef|#
directive|ifdef
name|THREAD_DEBUG
if|if
condition|(
name|debug_on
condition|)
name|printf
argument_list|(
literal|"enable fork, tid is %d\n"
argument_list|,
name|tid
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tt_status
operator|=
name|call_ttrace
argument_list|(
name|TT_PROC_SET_EVENT_MASK
argument_list|,
name|tid
argument_list|,
operator|(
name|TTRACE_ARG_TYPE
operator|)
operator|&
name|ttrace_events
argument_list|,
operator|(
name|TTRACE_ARG_TYPE
operator|)
sizeof|sizeof
argument_list|(
name|ttrace_events
argument_list|)
argument_list|,
name|TT_NIL
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
name|perror_with_name
argument_list|(
literal|"ttrace"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hppa_disable_catch_fork
parameter_list|(
name|tid
parameter_list|)
name|int
name|tid
decl_stmt|;
block|{
name|int
name|tt_status
decl_stmt|;
name|ttevent_t
name|ttrace_events
decl_stmt|;
comment|/* Get the set of events that are currently enabled.    */
name|tt_status
operator|=
name|call_ttrace
argument_list|(
name|TT_PROC_GET_EVENT_MASK
argument_list|,
name|tid
argument_list|,
operator|(
name|TTRACE_ARG_TYPE
operator|)
operator|&
name|ttrace_events
argument_list|,
operator|(
name|TTRACE_ARG_TYPE
operator|)
sizeof|sizeof
argument_list|(
name|ttrace_events
argument_list|)
argument_list|,
name|TT_NIL
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
name|perror_with_name
argument_list|(
literal|"ttrace"
argument_list|)
expr_stmt|;
comment|/* Remove forks from that set. */
name|ttrace_events
operator|.
name|tte_events
operator|&=
operator|~
name|TTEVT_FORK
expr_stmt|;
ifdef|#
directive|ifdef
name|THREAD_DEBUG
if|if
condition|(
name|debug_on
condition|)
name|printf
argument_list|(
literal|"disable fork, tid is %d\n"
argument_list|,
name|tid
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tt_status
operator|=
name|call_ttrace
argument_list|(
name|TT_PROC_SET_EVENT_MASK
argument_list|,
name|tid
argument_list|,
operator|(
name|TTRACE_ARG_TYPE
operator|)
operator|&
name|ttrace_events
argument_list|,
operator|(
name|TTRACE_ARG_TYPE
operator|)
sizeof|sizeof
argument_list|(
name|ttrace_events
argument_list|)
argument_list|,
name|TT_NIL
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
name|perror_with_name
argument_list|(
literal|"ttrace"
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CHILD_INSERT_FORK_CATCHPOINT
argument_list|)
end_if

begin_function
name|int
name|child_insert_fork_catchpoint
parameter_list|(
name|tid
parameter_list|)
name|int
name|tid
decl_stmt|;
block|{
comment|/* Enable reporting of fork events from the kernel. */
comment|/* ??rehrauer: For the moment, we're always enabling these events,      and just ignoring them if there's no catchpoint to catch them.      */
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CHILD_REMOVE_FORK_CATCHPOINT
argument_list|)
end_if

begin_function
name|int
name|child_remove_fork_catchpoint
parameter_list|(
name|tid
parameter_list|)
name|int
name|tid
decl_stmt|;
block|{
comment|/* Disable reporting of fork events from the kernel. */
comment|/* ??rehrauer: For the moment, we're always enabling these events,      and just ignoring them if there's no catchpoint to catch them.      */
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|hppa_enable_catch_vfork
parameter_list|(
name|tid
parameter_list|)
name|int
name|tid
decl_stmt|;
block|{
name|int
name|tt_status
decl_stmt|;
name|ttevent_t
name|ttrace_events
decl_stmt|;
comment|/* Get the set of events that are currently enabled.    */
name|tt_status
operator|=
name|call_ttrace
argument_list|(
name|TT_PROC_GET_EVENT_MASK
argument_list|,
name|tid
argument_list|,
operator|(
name|TTRACE_ARG_TYPE
operator|)
operator|&
name|ttrace_events
argument_list|,
operator|(
name|TTRACE_ARG_TYPE
operator|)
sizeof|sizeof
argument_list|(
name|ttrace_events
argument_list|)
argument_list|,
name|TT_NIL
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
name|perror_with_name
argument_list|(
literal|"ttrace"
argument_list|)
expr_stmt|;
comment|/* Add vforks to that set. */
name|ttrace_events
operator|.
name|tte_events
operator||=
name|TTEVT_VFORK
expr_stmt|;
ifdef|#
directive|ifdef
name|THREAD_DEBUG
if|if
condition|(
name|debug_on
condition|)
name|printf
argument_list|(
literal|"enable vfork, tid is %d\n"
argument_list|,
name|tid
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tt_status
operator|=
name|call_ttrace
argument_list|(
name|TT_PROC_SET_EVENT_MASK
argument_list|,
name|tid
argument_list|,
operator|(
name|TTRACE_ARG_TYPE
operator|)
operator|&
name|ttrace_events
argument_list|,
operator|(
name|TTRACE_ARG_TYPE
operator|)
sizeof|sizeof
argument_list|(
name|ttrace_events
argument_list|)
argument_list|,
name|TT_NIL
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
name|perror_with_name
argument_list|(
literal|"ttrace"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hppa_disable_catch_vfork
parameter_list|(
name|tid
parameter_list|)
name|int
name|tid
decl_stmt|;
block|{
name|int
name|tt_status
decl_stmt|;
name|ttevent_t
name|ttrace_events
decl_stmt|;
comment|/* Get the set of events that are currently enabled. */
name|tt_status
operator|=
name|call_ttrace
argument_list|(
name|TT_PROC_GET_EVENT_MASK
argument_list|,
name|tid
argument_list|,
operator|(
name|TTRACE_ARG_TYPE
operator|)
operator|&
name|ttrace_events
argument_list|,
operator|(
name|TTRACE_ARG_TYPE
operator|)
sizeof|sizeof
argument_list|(
name|ttrace_events
argument_list|)
argument_list|,
name|TT_NIL
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
name|perror_with_name
argument_list|(
literal|"ttrace"
argument_list|)
expr_stmt|;
comment|/* Remove vforks from that set. */
name|ttrace_events
operator|.
name|tte_events
operator|&=
operator|~
name|TTEVT_VFORK
expr_stmt|;
ifdef|#
directive|ifdef
name|THREAD_DEBUG
if|if
condition|(
name|debug_on
condition|)
name|printf
argument_list|(
literal|"disable vfork, tid is %d\n"
argument_list|,
name|tid
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tt_status
operator|=
name|call_ttrace
argument_list|(
name|TT_PROC_SET_EVENT_MASK
argument_list|,
name|tid
argument_list|,
operator|(
name|TTRACE_ARG_TYPE
operator|)
operator|&
name|ttrace_events
argument_list|,
operator|(
name|TTRACE_ARG_TYPE
operator|)
sizeof|sizeof
argument_list|(
name|ttrace_events
argument_list|)
argument_list|,
name|TT_NIL
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
name|perror_with_name
argument_list|(
literal|"ttrace"
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CHILD_INSERT_VFORK_CATCHPOINT
argument_list|)
end_if

begin_function
name|int
name|child_insert_vfork_catchpoint
parameter_list|(
name|tid
parameter_list|)
name|int
name|tid
decl_stmt|;
block|{
comment|/* Enable reporting of vfork events from the kernel. */
comment|/* ??rehrauer: For the moment, we're always enabling these events,      and just ignoring them if there's no catchpoint to catch them.      */
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CHILD_REMOVE_VFORK_CATCHPOINT
argument_list|)
end_if

begin_function
name|int
name|child_remove_vfork_catchpoint
parameter_list|(
name|tid
parameter_list|)
name|int
name|tid
decl_stmt|;
block|{
comment|/* Disable reporting of vfork events from the kernel. */
comment|/* ??rehrauer: For the moment, we're always enabling these events,      and just ignoring them if there's no catchpoint to catch them.      */
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CHILD_HAS_FORKED
argument_list|)
end_if

begin_comment
comment|/* Q: Do we need to map the returned process ID to a thread ID?  *  * A: I don't think so--here we want a _real_ pid.  Any later  *    operations will call "require_notification_of_events" and  *    start the mapping.  */
end_comment

begin_function
name|int
name|child_has_forked
parameter_list|(
name|tid
parameter_list|,
name|childpid
parameter_list|)
name|int
name|tid
decl_stmt|;
name|int
modifier|*
name|childpid
decl_stmt|;
block|{
name|int
name|tt_status
decl_stmt|;
name|ttstate_t
name|ttrace_state
decl_stmt|;
name|thread_info
modifier|*
name|tinfo
decl_stmt|;
comment|/* Do we have cached thread state that we can consult?  If so, use it. */
name|tinfo
operator|=
name|find_thread_info
argument_list|(
name|map_from_gdb_tid
argument_list|(
name|tid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tinfo
operator|!=
name|NULL
condition|)
block|{
name|copy_ttstate_t
argument_list|(
operator|&
name|ttrace_state
argument_list|,
operator|&
name|tinfo
operator|->
name|last_stop_state
argument_list|)
expr_stmt|;
block|}
comment|/* Nope, must read the thread's current state */
else|else
block|{
name|tt_status
operator|=
name|call_ttrace
argument_list|(
name|TT_LWP_GET_STATE
argument_list|,
name|tid
argument_list|,
operator|(
name|TTRACE_ARG_TYPE
operator|)
operator|&
name|ttrace_state
argument_list|,
operator|(
name|TTRACE_ARG_TYPE
operator|)
sizeof|sizeof
argument_list|(
name|ttrace_state
argument_list|)
argument_list|,
name|TT_NIL
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
name|perror_with_name
argument_list|(
literal|"ttrace"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tt_status
operator|<
literal|0
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|ttrace_state
operator|.
name|tts_event
operator|&
name|TTEVT_FORK
condition|)
block|{
operator|*
name|childpid
operator|=
name|ttrace_state
operator|.
name|tts_u
operator|.
name|tts_fork
operator|.
name|tts_fpid
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CHILD_HAS_VFORKED
argument_list|)
end_if

begin_comment
comment|/* See child_has_forked for pid discussion.  */
end_comment

begin_function
name|int
name|child_has_vforked
parameter_list|(
name|tid
parameter_list|,
name|childpid
parameter_list|)
name|int
name|tid
decl_stmt|;
name|int
modifier|*
name|childpid
decl_stmt|;
block|{
name|int
name|tt_status
decl_stmt|;
name|ttstate_t
name|ttrace_state
decl_stmt|;
name|thread_info
modifier|*
name|tinfo
decl_stmt|;
comment|/* Do we have cached thread state that we can consult?  If so, use it. */
name|tinfo
operator|=
name|find_thread_info
argument_list|(
name|map_from_gdb_tid
argument_list|(
name|tid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tinfo
operator|!=
name|NULL
condition|)
name|copy_ttstate_t
argument_list|(
operator|&
name|ttrace_state
argument_list|,
operator|&
name|tinfo
operator|->
name|last_stop_state
argument_list|)
expr_stmt|;
comment|/* Nope, must read the thread's current state */
else|else
block|{
name|tt_status
operator|=
name|call_ttrace
argument_list|(
name|TT_LWP_GET_STATE
argument_list|,
name|tid
argument_list|,
operator|(
name|TTRACE_ARG_TYPE
operator|)
operator|&
name|ttrace_state
argument_list|,
operator|(
name|TTRACE_ARG_TYPE
operator|)
sizeof|sizeof
argument_list|(
name|ttrace_state
argument_list|)
argument_list|,
name|TT_NIL
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
name|perror_with_name
argument_list|(
literal|"ttrace"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tt_status
operator|<
literal|0
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|ttrace_state
operator|.
name|tts_event
operator|&
name|TTEVT_VFORK
condition|)
block|{
operator|*
name|childpid
operator|=
name|ttrace_state
operator|.
name|tts_u
operator|.
name|tts_fork
operator|.
name|tts_fpid
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CHILD_CAN_FOLLOW_VFORK_PRIOR_TO_EXEC
argument_list|)
end_if

begin_function
name|int
name|child_can_follow_vfork_prior_to_exec
parameter_list|()
block|{
comment|/* ttrace does allow this.       ??rehrauer: However, I had major-league problems trying to      convince wait_for_inferior to handle that case.  Perhaps when      it is rewritten to grok multiple processes in an explicit way...      */
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CHILD_INSERT_EXEC_CATCHPOINT
argument_list|)
end_if

begin_function
name|int
name|child_insert_exec_catchpoint
parameter_list|(
name|tid
parameter_list|)
name|int
name|tid
decl_stmt|;
block|{
comment|/* Enable reporting of exec events from the kernel. */
comment|/* ??rehrauer: For the moment, we're always enabling these events,      and just ignoring them if there's no catchpoint to catch them.      */
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CHILD_REMOVE_EXEC_CATCHPOINT
argument_list|)
end_if

begin_function
name|int
name|child_remove_exec_catchpoint
parameter_list|(
name|tid
parameter_list|)
name|int
name|tid
decl_stmt|;
block|{
comment|/* Disable reporting of execevents from the kernel. */
comment|/* ??rehrauer: For the moment, we're always enabling these events,      and just ignoring them if there's no catchpoint to catch them.      */
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CHILD_HAS_EXECD
argument_list|)
end_if

begin_function
name|int
name|child_has_execd
parameter_list|(
name|tid
parameter_list|,
name|execd_pathname
parameter_list|)
name|int
name|tid
decl_stmt|;
name|char
modifier|*
modifier|*
name|execd_pathname
decl_stmt|;
block|{
name|int
name|tt_status
decl_stmt|;
name|ttstate_t
name|ttrace_state
decl_stmt|;
name|thread_info
modifier|*
name|tinfo
decl_stmt|;
comment|/* Do we have cached thread state that we can consult?  If so, use it. */
name|tinfo
operator|=
name|find_thread_info
argument_list|(
name|map_from_gdb_tid
argument_list|(
name|tid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tinfo
operator|!=
name|NULL
condition|)
name|copy_ttstate_t
argument_list|(
operator|&
name|ttrace_state
argument_list|,
operator|&
name|tinfo
operator|->
name|last_stop_state
argument_list|)
expr_stmt|;
comment|/* Nope, must read the thread's current state */
else|else
block|{
name|tt_status
operator|=
name|call_ttrace
argument_list|(
name|TT_LWP_GET_STATE
argument_list|,
name|tid
argument_list|,
operator|(
name|TTRACE_ARG_TYPE
operator|)
operator|&
name|ttrace_state
argument_list|,
operator|(
name|TTRACE_ARG_TYPE
operator|)
sizeof|sizeof
argument_list|(
name|ttrace_state
argument_list|)
argument_list|,
name|TT_NIL
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
name|perror_with_name
argument_list|(
literal|"ttrace"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tt_status
operator|<
literal|0
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|ttrace_state
operator|.
name|tts_event
operator|&
name|TTEVT_EXEC
condition|)
block|{
comment|/* See child_pid_to_exec_file in this file: this is a macro.        */
name|char
modifier|*
name|exec_file
init|=
name|target_pid_to_exec_file
argument_list|(
name|tid
argument_list|)
decl_stmt|;
operator|*
name|execd_pathname
operator|=
name|savestring
argument_list|(
name|exec_file
argument_list|,
name|strlen
argument_list|(
name|exec_file
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CHILD_HAS_SYSCALL_EVENT
argument_list|)
end_if

begin_function
name|int
name|child_has_syscall_event
parameter_list|(
name|pid
parameter_list|,
name|kind
parameter_list|,
name|syscall_id
parameter_list|)
name|int
name|pid
decl_stmt|;
name|enum
name|target_waitkind
modifier|*
name|kind
decl_stmt|;
name|int
modifier|*
name|syscall_id
decl_stmt|;
block|{
name|int
name|tt_status
decl_stmt|;
name|ttstate_t
name|ttrace_state
decl_stmt|;
name|thread_info
modifier|*
name|tinfo
decl_stmt|;
comment|/* Do we have cached thread state that we can consult?  If so, use it. */
name|tinfo
operator|=
name|find_thread_info
argument_list|(
name|map_from_gdb_tid
argument_list|(
name|pid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tinfo
operator|!=
name|NULL
condition|)
name|copy_ttstate_t
argument_list|(
operator|&
name|ttrace_state
argument_list|,
operator|&
name|tinfo
operator|->
name|last_stop_state
argument_list|)
expr_stmt|;
comment|/* Nope, must read the thread's current state */
else|else
block|{
name|tt_status
operator|=
name|call_ttrace
argument_list|(
name|TT_LWP_GET_STATE
argument_list|,
name|pid
argument_list|,
operator|(
name|TTRACE_ARG_TYPE
operator|)
operator|&
name|ttrace_state
argument_list|,
operator|(
name|TTRACE_ARG_TYPE
operator|)
sizeof|sizeof
argument_list|(
name|ttrace_state
argument_list|)
argument_list|,
name|TT_NIL
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
name|perror_with_name
argument_list|(
literal|"ttrace"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tt_status
operator|<
literal|0
condition|)
return|return
literal|0
return|;
block|}
operator|*
name|kind
operator|=
name|TARGET_WAITKIND_SPURIOUS
expr_stmt|;
comment|/* Until proven otherwise... */
operator|*
name|syscall_id
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|ttrace_state
operator|.
name|tts_event
operator|&
name|TTEVT_SYSCALL_ENTRY
condition|)
operator|*
name|kind
operator|=
name|TARGET_WAITKIND_SYSCALL_ENTRY
expr_stmt|;
elseif|else
if|if
condition|(
name|ttrace_state
operator|.
name|tts_event
operator|&
name|TTEVT_SYSCALL_RETURN
condition|)
operator|*
name|kind
operator|=
name|TARGET_WAITKIND_SYSCALL_RETURN
expr_stmt|;
else|else
return|return
literal|0
return|;
operator|*
name|syscall_id
operator|=
name|ttrace_state
operator|.
name|tts_scno
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CHILD_THREAD_ALIVE
argument_list|)
end_if

begin_comment
comment|/* Check to see if the given thread is alive.  *  * We'll trust the thread list, as the more correct  * approach of stopping the process and spinning down  * the OS's thread list is _very_ expensive.  *  * May need a FIXME for that reason.  */
end_comment

begin_function
name|int
name|child_thread_alive
parameter_list|(
name|gdb_tid
parameter_list|)
name|lwpid_t
name|gdb_tid
decl_stmt|;
block|{
name|lwpid_t
name|tid
decl_stmt|;
comment|/* This spins down the lists twice.     * Possible peformance improvement here!     */
name|tid
operator|=
name|map_from_gdb_tid
argument_list|(
name|gdb_tid
argument_list|)
expr_stmt|;
return|return
operator|!
name|is_terminated
argument_list|(
name|tid
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* This function attempts to read the specified number of bytes from the    save_state_t that is our view into the hardware registers, starting at    ss_offset, and ending at ss_offset + sizeof_buf - 1     If this function succeeds, it deposits the fetched bytes into buf,    and returns 0.     If it fails, it returns a negative result.  The contents of buf are    undefined it this function fails.    */
end_comment

begin_function
name|int
name|read_from_register_save_state
parameter_list|(
name|tid
parameter_list|,
name|ss_offset
parameter_list|,
name|buf
parameter_list|,
name|sizeof_buf
parameter_list|)
name|int
name|tid
decl_stmt|;
name|TTRACE_ARG_TYPE
name|ss_offset
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|sizeof_buf
decl_stmt|;
block|{
name|int
name|tt_status
decl_stmt|;
name|register_value_t
name|register_value
init|=
literal|0
decl_stmt|;
name|tt_status
operator|=
name|call_ttrace
argument_list|(
name|TT_LWP_RUREGS
argument_list|,
name|tid
argument_list|,
name|ss_offset
argument_list|,
operator|(
name|TTRACE_ARG_TYPE
operator|)
name|sizeof_buf
argument_list|,
operator|(
name|TTRACE_ARG_TYPE
operator|)
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|tt_status
operator|==
literal|1
condition|)
comment|/* Map ttrace's version of success to our version.        * Sometime ttrace returns 0, but that's ok here.        */
return|return
literal|0
return|;
return|return
name|tt_status
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This function attempts to write the specified number of bytes to the    save_state_t that is our view into the hardware registers, starting at    ss_offset, and ending at ss_offset + sizeof_buf - 1     If this function succeeds, it deposits the bytes in buf, and returns 0.     If it fails, it returns a negative result.  The contents of the save_state_t    are undefined it this function fails.    */
end_comment

begin_function
name|int
name|write_to_register_save_state
parameter_list|(
name|tid
parameter_list|,
name|ss_offset
parameter_list|,
name|buf
parameter_list|,
name|sizeof_buf
parameter_list|)
name|int
name|tid
decl_stmt|;
name|TTRACE_ARG_TYPE
name|ss_offset
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|sizeof_buf
decl_stmt|;
block|{
name|int
name|tt_status
decl_stmt|;
name|register_value_t
name|register_value
init|=
literal|0
decl_stmt|;
name|tt_status
operator|=
name|call_ttrace
argument_list|(
name|TT_LWP_WUREGS
argument_list|,
name|tid
argument_list|,
name|ss_offset
argument_list|,
operator|(
name|TTRACE_ARG_TYPE
operator|)
name|sizeof_buf
argument_list|,
operator|(
name|TTRACE_ARG_TYPE
operator|)
name|buf
argument_list|)
expr_stmt|;
return|return
name|tt_status
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This function is a sop to the largeish number of direct calls    to call_ptrace that exist in other files.  Rather than create    functions whose name abstracts away from ptrace, and change all    the present callers of call_ptrace, we'll do the expedient (and    perhaps only practical) thing.     Note HP-UX explicitly disallows a mix of ptrace& ttrace on a traced    process.  Thus, we must translate all ptrace requests into their    process-specific, ttrace equivalents.    */
end_comment

begin_function
name|int
name|call_ptrace
parameter_list|(
name|pt_request
parameter_list|,
name|gdb_tid
parameter_list|,
name|addr
parameter_list|,
name|data
parameter_list|)
name|int
name|pt_request
decl_stmt|;
name|int
name|gdb_tid
decl_stmt|;
name|PTRACE_ARG3_TYPE
name|addr
decl_stmt|;
name|int
name|data
decl_stmt|;
block|{
name|ttreq_t
name|tt_request
decl_stmt|;
name|TTRACE_ARG_TYPE
name|tt_addr
init|=
operator|(
name|TTRACE_ARG_TYPE
operator|)
name|addr
decl_stmt|;
name|TTRACE_ARG_TYPE
name|tt_data
init|=
operator|(
name|TTRACE_ARG_TYPE
operator|)
name|data
decl_stmt|;
name|TTRACE_ARG_TYPE
name|tt_addr2
init|=
name|TT_NIL
decl_stmt|;
name|int
name|tt_status
decl_stmt|;
name|register_value_t
name|register_value
decl_stmt|;
name|int
name|read_buf
decl_stmt|;
comment|/* Perform the necessary argument translation.  Note that some      cases are funky enough in the ttrace realm that we handle them      very specially.    */
switch|switch
condition|(
name|pt_request
condition|)
block|{
comment|/* The following cases cannot conveniently be handled conveniently          by merely adjusting the ptrace arguments and feeding into the          generic call to ttrace at the bottom of this function.           Note that because all branches of this switch end in "return",          there's no need for any "break" statements.          */
case|case
name|PT_SETTRC
case|:
return|return
name|parent_attach_all
argument_list|()
return|;
case|case
name|PT_RUREGS
case|:
name|tt_status
operator|=
name|read_from_register_save_state
argument_list|(
name|gdb_tid
argument_list|,
name|tt_addr
argument_list|,
operator|&
name|register_value
argument_list|,
sizeof|sizeof
argument_list|(
name|register_value
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tt_status
operator|<
literal|0
condition|)
return|return
name|tt_status
return|;
return|return
name|register_value
return|;
case|case
name|PT_WUREGS
case|:
name|register_value
operator|=
operator|(
name|int
operator|)
name|tt_data
expr_stmt|;
name|tt_status
operator|=
name|write_to_register_save_state
argument_list|(
name|gdb_tid
argument_list|,
name|tt_addr
argument_list|,
operator|&
name|register_value
argument_list|,
sizeof|sizeof
argument_list|(
name|register_value
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|tt_status
return|;
break|break;
case|case
name|PT_READ_I
case|:
name|tt_status
operator|=
name|call_ttrace
argument_list|(
name|TT_PROC_RDTEXT
argument_list|,
comment|/* Implicit 4-byte xfer becomes block-xfer. */
name|gdb_tid
argument_list|,
name|tt_addr
argument_list|,
operator|(
name|TTRACE_ARG_TYPE
operator|)
literal|4
argument_list|,
operator|(
name|TTRACE_ARG_TYPE
operator|)
operator|&
name|read_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|tt_status
operator|<
literal|0
condition|)
return|return
name|tt_status
return|;
return|return
name|read_buf
return|;
case|case
name|PT_READ_D
case|:
name|tt_status
operator|=
name|call_ttrace
argument_list|(
name|TT_PROC_RDDATA
argument_list|,
comment|/* Implicit 4-byte xfer becomes block-xfer. */
name|gdb_tid
argument_list|,
name|tt_addr
argument_list|,
operator|(
name|TTRACE_ARG_TYPE
operator|)
literal|4
argument_list|,
operator|(
name|TTRACE_ARG_TYPE
operator|)
operator|&
name|read_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|tt_status
operator|<
literal|0
condition|)
return|return
name|tt_status
return|;
return|return
name|read_buf
return|;
case|case
name|PT_ATTACH
case|:
name|tt_status
operator|=
name|call_real_ttrace
argument_list|(
name|TT_PROC_ATTACH
argument_list|,
name|map_from_gdb_tid
argument_list|(
name|gdb_tid
argument_list|)
argument_list|,
operator|(
name|lwpid_t
operator|)
name|TT_NIL
argument_list|,
name|tt_addr
argument_list|,
operator|(
name|TTRACE_ARG_TYPE
operator|)
name|TT_VERSION
argument_list|,
name|tt_addr2
argument_list|)
expr_stmt|;
if|if
condition|(
name|tt_status
operator|<
literal|0
condition|)
return|return
name|tt_status
return|;
return|return
name|tt_status
return|;
comment|/* The following cases are handled by merely adjusting the ptrace          arguments and feeding into the generic call to ttrace.          */
case|case
name|PT_DETACH
case|:
name|tt_request
operator|=
name|TT_PROC_DETACH
expr_stmt|;
break|break;
case|case
name|PT_WRITE_I
case|:
name|tt_request
operator|=
name|TT_PROC_WRTEXT
expr_stmt|;
comment|/* Translates 4-byte xfer to block-xfer. */
name|tt_data
operator|=
literal|4
expr_stmt|;
comment|/* This many bytes. */
name|tt_addr2
operator|=
operator|(
name|TTRACE_ARG_TYPE
operator|)
operator|&
name|data
expr_stmt|;
comment|/* Address of xfer source. */
break|break;
case|case
name|PT_WRITE_D
case|:
name|tt_request
operator|=
name|TT_PROC_WRDATA
expr_stmt|;
comment|/* Translates 4-byte xfer to block-xfer. */
name|tt_data
operator|=
literal|4
expr_stmt|;
comment|/* This many bytes. */
name|tt_addr2
operator|=
operator|(
name|TTRACE_ARG_TYPE
operator|)
operator|&
name|data
expr_stmt|;
comment|/* Address of xfer source. */
break|break;
case|case
name|PT_RDTEXT
case|:
name|tt_request
operator|=
name|TT_PROC_RDTEXT
expr_stmt|;
break|break;
case|case
name|PT_RDDATA
case|:
name|tt_request
operator|=
name|TT_PROC_RDDATA
expr_stmt|;
break|break;
case|case
name|PT_WRTEXT
case|:
name|tt_request
operator|=
name|TT_PROC_WRTEXT
expr_stmt|;
break|break;
case|case
name|PT_WRDATA
case|:
name|tt_request
operator|=
name|TT_PROC_WRDATA
expr_stmt|;
break|break;
case|case
name|PT_CONTINUE
case|:
name|tt_request
operator|=
name|TT_PROC_CONTINUE
expr_stmt|;
break|break;
case|case
name|PT_STEP
case|:
name|tt_request
operator|=
name|TT_LWP_SINGLE
expr_stmt|;
comment|/* Should not be making this request? */
break|break;
case|case
name|PT_KILL
case|:
name|tt_request
operator|=
name|TT_PROC_EXIT
expr_stmt|;
break|break;
case|case
name|PT_GET_PROCESS_PATHNAME
case|:
name|tt_request
operator|=
name|TT_PROC_GET_PATHNAME
expr_stmt|;
break|break;
default|default :
name|tt_request
operator|=
name|pt_request
expr_stmt|;
comment|/* Let ttrace be the one to complain. */
break|break;
block|}
return|return
name|call_ttrace
argument_list|(
name|tt_request
argument_list|,
name|gdb_tid
argument_list|,
name|tt_addr
argument_list|,
name|tt_data
argument_list|,
name|tt_addr2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Kill that pesky process!  */
end_comment

begin_function
name|void
name|kill_inferior
parameter_list|()
block|{
name|int
name|tid
decl_stmt|;
name|int
name|wait_status
decl_stmt|;
name|thread_info
modifier|*
name|t
decl_stmt|;
name|thread_info
modifier|*
modifier|*
name|paranoia
decl_stmt|;
name|int
name|para_count
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|inferior_pid
operator|==
literal|0
condition|)
return|return;
comment|/* Walk the list of "threads", some of which are "pseudo threads",      aka "processes".  For each that is NOT inferior_pid, stop it,      and detach it.       You see, we may not have just a single process to kill.  If we're      restarting or quitting or detaching just after the inferior has      forked, then we've actually two processes to clean up.       But we can't just call target_mourn_inferior() for each, since that      zaps the target vector.      */
name|paranoia
operator|=
operator|(
name|thread_info
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|thread_head
operator|.
name|count
operator|*
sizeof|sizeof
argument_list|(
name|thread_info
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|para_count
operator|=
literal|0
expr_stmt|;
name|t
operator|=
name|thread_head
operator|.
name|head
expr_stmt|;
while|while
condition|(
name|t
condition|)
block|{
name|paranoia
index|[
name|para_count
index|]
operator|=
name|t
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|para_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|t
operator|->
name|next
operator|==
name|paranoia
index|[
name|i
index|]
condition|)
block|{
name|warning
argument_list|(
literal|"Bad data in gdb's thread data; repairing."
argument_list|)
expr_stmt|;
name|t
operator|->
name|next
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|para_count
operator|++
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|am_pseudo
operator|&&
operator|(
name|t
operator|->
name|pid
operator|!=
name|inferior_pid
operator|)
condition|)
block|{
comment|/* TT_PROC_STOP doesn't require a subsequent ttrace_wait, as it          * generates no event.          */
name|call_ttrace
argument_list|(
name|TT_PROC_STOP
argument_list|,
name|t
operator|->
name|pid
argument_list|,
name|TT_NIL
argument_list|,
name|TT_NIL
argument_list|,
name|TT_NIL
argument_list|)
expr_stmt|;
name|call_ttrace
argument_list|(
name|TT_PROC_DETACH
argument_list|,
name|t
operator|->
name|pid
argument_list|,
name|TT_NIL
argument_list|,
operator|(
name|TTRACE_ARG_TYPE
operator|)
name|TARGET_SIGNAL_0
argument_list|,
name|TT_NIL
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|t
operator|->
name|next
expr_stmt|;
block|}
name|free
argument_list|(
name|paranoia
argument_list|)
expr_stmt|;
name|call_ttrace
argument_list|(
name|TT_PROC_STOP
argument_list|,
name|inferior_pid
argument_list|,
name|TT_NIL
argument_list|,
name|TT_NIL
argument_list|,
name|TT_NIL
argument_list|)
expr_stmt|;
name|target_mourn_inferior
argument_list|()
expr_stmt|;
name|clear_thread_info
argument_list|()
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|CHILD_RESUME
end_ifndef

begin_comment
comment|/* Sanity check a thread about to be continued.  */
end_comment

begin_function
specifier|static
name|void
name|thread_dropping_event_check
parameter_list|(
name|p
parameter_list|)
name|thread_info
modifier|*
name|p
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|p
operator|->
name|handled
condition|)
block|{
comment|/*          * This seems to happen when we "next" over a          * "fork()" while following the parent.  If it's          * the FORK event, that's ok.  If it's a SIGNAL          * in the unfollowed child, that's ok to--but          * how can we know that's what's going on?          *          * FIXME!          */
if|if
condition|(
name|p
operator|->
name|have_state
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|last_stop_state
operator|.
name|tts_event
operator|==
name|TTEVT_FORK
condition|)
block|{
comment|/* Ok */
empty_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|last_stop_state
operator|.
name|tts_event
operator|==
name|TTEVT_SIGNAL
condition|)
block|{
comment|/* Ok, close eyes and let it happen.                   */
empty_stmt|;
block|}
else|else
block|{
comment|/* This shouldn't happen--we're dropping a                   * real event.                   */
name|warning
argument_list|(
literal|"About to continue process %d, thread %d with unhandled event %s."
argument_list|,
name|p
operator|->
name|pid
argument_list|,
name|p
operator|->
name|tid
argument_list|,
name|get_printable_name_of_ttrace_event
argument_list|(
name|p
operator|->
name|last_stop_state
operator|.
name|tts_event
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PARANOIA
if|if
condition|(
name|debug_on
condition|)
name|print_tthread
argument_list|(
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
else|else
block|{
comment|/* No saved state, have to assume it failed.              */
name|warning
argument_list|(
literal|"About to continue process %d, thread %d with unhandled event."
argument_list|,
name|p
operator|->
name|pid
argument_list|,
name|p
operator|->
name|tid
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PARANOIA
if|if
condition|(
name|debug_on
condition|)
name|print_tthread
argument_list|(
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
end_function

begin_comment
comment|/* thread_dropping_event_check */
end_comment

begin_comment
comment|/* Use a loop over the threads to continue all the threads but  * the one specified, which is to be stepped.  */
end_comment

begin_function
specifier|static
name|void
name|threads_continue_all_but_one
parameter_list|(
name|gdb_tid
parameter_list|,
name|signal
parameter_list|)
name|lwpid_t
name|gdb_tid
decl_stmt|;
name|int
name|signal
decl_stmt|;
block|{
name|thread_info
modifier|*
name|p
decl_stmt|;
name|int
name|thread_signal
decl_stmt|;
name|lwpid_t
name|real_tid
decl_stmt|;
name|lwpid_t
name|scan_tid
decl_stmt|;
name|ttstate_t
name|state
decl_stmt|;
name|int
name|real_pid
decl_stmt|;
ifdef|#
directive|ifdef
name|THREAD_DEBUG
if|if
condition|(
name|debug_on
condition|)
name|printf
argument_list|(
literal|"Using loop over threads to step/resume with signals\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* First update the thread list.      */
name|set_all_unseen
argument_list|()
expr_stmt|;
name|real_tid
operator|=
name|map_from_gdb_tid
argument_list|(
name|gdb_tid
argument_list|)
expr_stmt|;
name|real_pid
operator|=
name|get_pid_for
argument_list|(
name|real_tid
argument_list|)
expr_stmt|;
name|scan_tid
operator|=
name|get_process_first_stopped_thread_id
argument_list|(
name|real_pid
argument_list|,
operator|&
name|state
argument_list|)
expr_stmt|;
while|while
condition|(
literal|0
operator|!=
name|scan_tid
condition|)
block|{
ifdef|#
directive|ifdef
name|THREAD_DEBUG
comment|/* FIX: later should check state is stopped;          * state.tts_flags& TTS_STATEMASK == TTS_WASSUSPENDED          */
if|if
condition|(
name|debug_on
condition|)
if|if
condition|(
name|state
operator|.
name|tts_flags
operator|&
name|TTS_STATEMASK
operator|!=
name|TTS_WASSUSPENDED
condition|)
name|printf
argument_list|(
literal|"About to continue non-stopped thread %d\n"
argument_list|,
name|scan_tid
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|p
operator|=
name|find_thread_info
argument_list|(
name|scan_tid
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|p
condition|)
block|{
name|add_tthread
argument_list|(
name|real_pid
argument_list|,
name|scan_tid
argument_list|)
expr_stmt|;
name|p
operator|=
name|find_thread_info
argument_list|(
name|scan_tid
argument_list|)
expr_stmt|;
comment|/* This is either a newly-created thread or the              * result of a fork; in either case there's no              * actual event to worry about.              */
name|p
operator|->
name|handled
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|state
operator|.
name|tts_event
operator|!=
name|TTEVT_NONE
condition|)
block|{
comment|/* Oops, do need to worry!                  */
name|warning
argument_list|(
literal|"Unexpected thread with \"%s\" event."
argument_list|,
name|get_printable_name_of_ttrace_event
argument_list|(
name|state
operator|.
name|tts_event
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|scan_tid
operator|!=
name|p
operator|->
name|tid
condition|)
name|error
argument_list|(
literal|"Bad data in thread database."
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|THREAD_DEBUG
if|if
condition|(
name|debug_on
condition|)
if|if
condition|(
name|p
operator|->
name|terminated
condition|)
name|printf
argument_list|(
literal|"Why are we continuing a dead thread?\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|p
operator|->
name|seen
operator|=
literal|1
expr_stmt|;
name|scan_tid
operator|=
name|get_process_next_stopped_thread_id
argument_list|(
name|real_pid
argument_list|,
operator|&
name|state
argument_list|)
expr_stmt|;
block|}
comment|/* Remove unseen threads.      */
name|update_thread_list
argument_list|()
expr_stmt|;
comment|/* Now run down the thread list and continue or step.      */
for|for
control|(
name|p
operator|=
name|thread_head
operator|.
name|head
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
comment|/* Sanity check.          */
name|thread_dropping_event_check
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* Pass the correct signals along.          */
if|if
condition|(
name|p
operator|->
name|have_signal
condition|)
block|{
name|thread_signal
operator|=
name|p
operator|->
name|signal_value
expr_stmt|;
name|p
operator|->
name|have_signal
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|thread_signal
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|tid
operator|!=
name|real_tid
condition|)
block|{
comment|/*              * Not the thread of interest, so continue it              * as the user expects.              */
if|if
condition|(
name|p
operator|->
name|stepping_mode
operator|==
name|DO_STEP
condition|)
block|{
comment|/* Just step this thread.                  */
name|call_ttrace
argument_list|(
name|TT_LWP_SINGLE
argument_list|,
name|p
operator|->
name|tid
argument_list|,
name|TT_USE_CURRENT_PC
argument_list|,
operator|(
name|TTRACE_ARG_TYPE
operator|)
name|target_signal_to_host
argument_list|(
name|signal
argument_list|)
argument_list|,
name|TT_NIL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Regular continue (default case).                  */
name|call_ttrace
argument_list|(
name|TT_LWP_CONTINUE
argument_list|,
name|p
operator|->
name|tid
argument_list|,
name|TT_USE_CURRENT_PC
argument_list|,
operator|(
name|TTRACE_ARG_TYPE
operator|)
name|target_signal_to_host
argument_list|(
name|thread_signal
argument_list|)
argument_list|,
name|TT_NIL
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Step the thread of interest.             */
name|call_ttrace
argument_list|(
name|TT_LWP_SINGLE
argument_list|,
name|real_tid
argument_list|,
name|TT_USE_CURRENT_PC
argument_list|,
operator|(
name|TTRACE_ARG_TYPE
operator|)
name|target_signal_to_host
argument_list|(
name|signal
argument_list|)
argument_list|,
name|TT_NIL
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Loop over threads */
block|}
end_function

begin_comment
comment|/* End threads_continue_all_but_one */
end_comment

begin_comment
comment|/* Use a loop over the threads to continue all the threads.  * This is done when a signal must be sent to any of the threads.  */
end_comment

begin_function
specifier|static
name|void
name|threads_continue_all_with_signals
parameter_list|(
name|gdb_tid
parameter_list|,
name|signal
parameter_list|)
name|lwpid_t
name|gdb_tid
decl_stmt|;
name|int
name|signal
decl_stmt|;
block|{
name|thread_info
modifier|*
name|p
decl_stmt|;
name|int
name|thread_signal
decl_stmt|;
name|lwpid_t
name|real_tid
decl_stmt|;
name|lwpid_t
name|scan_tid
decl_stmt|;
name|ttstate_t
name|state
decl_stmt|;
name|int
name|real_pid
decl_stmt|;
ifdef|#
directive|ifdef
name|THREAD_DEBUG
if|if
condition|(
name|debug_on
condition|)
name|printf
argument_list|(
literal|"Using loop over threads to resume with signals\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Scan and update thread list.      */
name|set_all_unseen
argument_list|()
expr_stmt|;
name|real_tid
operator|=
name|map_from_gdb_tid
argument_list|(
name|gdb_tid
argument_list|)
expr_stmt|;
name|real_pid
operator|=
name|get_pid_for
argument_list|(
name|real_tid
argument_list|)
expr_stmt|;
name|scan_tid
operator|=
name|get_process_first_stopped_thread_id
argument_list|(
name|real_pid
argument_list|,
operator|&
name|state
argument_list|)
expr_stmt|;
while|while
condition|(
literal|0
operator|!=
name|scan_tid
condition|)
block|{
ifdef|#
directive|ifdef
name|THREAD_DEBUG
if|if
condition|(
name|debug_on
condition|)
if|if
condition|(
name|state
operator|.
name|tts_flags
operator|&
name|TTS_STATEMASK
operator|!=
name|TTS_WASSUSPENDED
condition|)
name|warning
argument_list|(
literal|"About to continue non-stopped thread %d\n"
argument_list|,
name|scan_tid
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|p
operator|=
name|find_thread_info
argument_list|(
name|scan_tid
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|p
condition|)
block|{
name|add_tthread
argument_list|(
name|real_pid
argument_list|,
name|scan_tid
argument_list|)
expr_stmt|;
name|p
operator|=
name|find_thread_info
argument_list|(
name|scan_tid
argument_list|)
expr_stmt|;
comment|/* This is either a newly-created thread or the              * result of a fork; in either case there's no              * actual event to worry about.              */
name|p
operator|->
name|handled
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|state
operator|.
name|tts_event
operator|!=
name|TTEVT_NONE
condition|)
block|{
comment|/* Oops, do need to worry!                  */
name|warning
argument_list|(
literal|"Unexpected thread with \"%s\" event."
argument_list|,
name|get_printable_name_of_ttrace_event
argument_list|(
name|state
operator|.
name|tts_event
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|THREAD_DEBUG
if|if
condition|(
name|debug_on
condition|)
if|if
condition|(
name|p
operator|->
name|terminated
condition|)
name|printf
argument_list|(
literal|"Why are we continuing a dead thread? (1)\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|p
operator|->
name|seen
operator|=
literal|1
expr_stmt|;
name|scan_tid
operator|=
name|get_process_next_stopped_thread_id
argument_list|(
name|real_pid
argument_list|,
operator|&
name|state
argument_list|)
expr_stmt|;
block|}
comment|/* Remove unseen threads from our list.      */
name|update_thread_list
argument_list|()
expr_stmt|;
comment|/* Continue the threads.      */
for|for
control|(
name|p
operator|=
name|thread_head
operator|.
name|head
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
comment|/* Sanity check.          */
name|thread_dropping_event_check
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* Pass the correct signals along.          */
if|if
condition|(
name|p
operator|->
name|tid
operator|==
name|real_tid
condition|)
block|{
name|thread_signal
operator|=
name|signal
expr_stmt|;
name|p
operator|->
name|have_signal
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|have_signal
condition|)
block|{
name|thread_signal
operator|=
name|p
operator|->
name|signal_value
expr_stmt|;
name|p
operator|->
name|have_signal
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|thread_signal
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|stepping_mode
operator|==
name|DO_STEP
condition|)
block|{
name|call_ttrace
argument_list|(
name|TT_LWP_SINGLE
argument_list|,
name|p
operator|->
name|tid
argument_list|,
name|TT_USE_CURRENT_PC
argument_list|,
operator|(
name|TTRACE_ARG_TYPE
operator|)
name|target_signal_to_host
argument_list|(
name|signal
argument_list|)
argument_list|,
name|TT_NIL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Continue this thread (default case).              */
name|call_ttrace
argument_list|(
name|TT_LWP_CONTINUE
argument_list|,
name|p
operator|->
name|tid
argument_list|,
name|TT_USE_CURRENT_PC
argument_list|,
operator|(
name|TTRACE_ARG_TYPE
operator|)
name|target_signal_to_host
argument_list|(
name|thread_signal
argument_list|)
argument_list|,
name|TT_NIL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* End threads_continue_all_with_signals */
end_comment

begin_comment
comment|/* Step one thread only.    */
end_comment

begin_function
specifier|static
name|void
name|thread_fake_step
parameter_list|(
name|tid
parameter_list|,
name|signal
parameter_list|)
name|lwpid_t
name|tid
decl_stmt|;
name|enum
name|target_signal
name|signal
decl_stmt|;
block|{
name|thread_info
modifier|*
name|p
decl_stmt|;
ifdef|#
directive|ifdef
name|THREAD_DEBUG
if|if
condition|(
name|debug_on
condition|)
block|{
name|printf
argument_list|(
literal|"Doing a fake-step over a bpt, etc. for %d\n"
argument_list|,
name|tid
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_terminated
argument_list|(
name|tid
argument_list|)
condition|)
name|printf
argument_list|(
literal|"Why are we continuing a dead thread? (4)\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|doing_fake_step
condition|)
name|warning
argument_list|(
literal|"Step while step already in progress."
argument_list|)
expr_stmt|;
comment|/* See if there's a saved signal value for this      * thread to be passed on, but no current signal.      */
name|p
operator|=
name|find_thread_info
argument_list|(
name|tid
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|have_signal
operator|&&
name|signal
operator|==
name|NULL
condition|)
block|{
comment|/* Pass on a saved signal.              */
name|signal
operator|=
name|p
operator|->
name|signal_value
expr_stmt|;
block|}
name|p
operator|->
name|have_signal
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|p
operator|->
name|handled
condition|)
name|warning
argument_list|(
literal|"Internal error: continuing unhandled thread."
argument_list|)
expr_stmt|;
name|call_ttrace
argument_list|(
name|TT_LWP_SINGLE
argument_list|,
name|tid
argument_list|,
name|TT_USE_CURRENT_PC
argument_list|,
operator|(
name|TTRACE_ARG_TYPE
operator|)
name|target_signal_to_host
argument_list|(
name|signal
argument_list|)
argument_list|,
name|TT_NIL
argument_list|)
expr_stmt|;
comment|/* Do bookkeeping so "call_ttrace_wait" knows it has to wait      * for this thread only, and clear any saved signal info.      */
name|doing_fake_step
operator|=
literal|1
expr_stmt|;
name|fake_step_tid
operator|=
name|tid
expr_stmt|;
block|}
end_function

begin_comment
comment|/* End thread_fake_step */
end_comment

begin_comment
comment|/* Continue one thread when a signal must be sent to it.  */
end_comment

begin_function
specifier|static
name|void
name|threads_continue_one_with_signal
parameter_list|(
name|gdb_tid
parameter_list|,
name|signal
parameter_list|)
name|lwpid_t
name|gdb_tid
decl_stmt|;
name|int
name|signal
decl_stmt|;
block|{
name|thread_info
modifier|*
name|p
decl_stmt|;
name|lwpid_t
name|real_tid
decl_stmt|;
name|int
name|real_pid
decl_stmt|;
ifdef|#
directive|ifdef
name|THREAD_DEBUG
if|if
condition|(
name|debug_on
condition|)
name|printf
argument_list|(
literal|"Continuing one thread with a signal\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|real_tid
operator|=
name|map_from_gdb_tid
argument_list|(
name|gdb_tid
argument_list|)
expr_stmt|;
name|real_pid
operator|=
name|get_pid_for
argument_list|(
name|real_tid
argument_list|)
expr_stmt|;
name|p
operator|=
name|find_thread_info
argument_list|(
name|real_tid
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|p
condition|)
block|{
name|add_tthread
argument_list|(
name|real_pid
argument_list|,
name|real_tid
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|THREAD_DEBUG
if|if
condition|(
name|debug_on
condition|)
if|if
condition|(
name|p
operator|->
name|terminated
condition|)
name|printf
argument_list|(
literal|"Why are we continuing a dead thread? (2)\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|p
operator|->
name|handled
condition|)
name|warning
argument_list|(
literal|"Internal error: continuing unhandled thread."
argument_list|)
expr_stmt|;
name|p
operator|->
name|have_signal
operator|=
literal|0
expr_stmt|;
name|call_ttrace
argument_list|(
name|TT_LWP_CONTINUE
argument_list|,
name|gdb_tid
argument_list|,
name|TT_USE_CURRENT_PC
argument_list|,
operator|(
name|TTRACE_ARG_TYPE
operator|)
name|target_signal_to_host
argument_list|(
name|signal
argument_list|)
argument_list|,
name|TT_NIL
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|CHILD_RESUME
end_ifndef

begin_comment
comment|/* Resume execution of the inferior process.  *  * This routine is in charge of setting the "handled" bits.   *  *   If STEP is zero,      continue it.  *   If STEP is nonzero,   single-step it.  *     *   If SIGNAL is nonzero, give it that signal.  *  *   If TID is -1,         apply to all threads.  *   If TID is not -1,     apply to specified thread.  *     *           STEP  *      \      !0                        0  *  TID  \________________________________________________  *       |  *   -1  |   Step current            Continue all threads  *       |   thread and              (but which gets any  *       |   continue others         signal?--We look at  *       |                           "inferior_pid")  *       |  *    N  |   Step _this_ thread      Continue _this_ thread  *       |   and leave others        and leave others   *       |   stopped; internally     stopped; used only for  *       |   used by gdb, never      hardware watchpoints  *       |   a user command.         and attach, never a  *       |                           user command.  */
end_comment

begin_function
name|void
name|child_resume
parameter_list|(
name|gdb_tid
parameter_list|,
name|step
parameter_list|,
name|signal
parameter_list|)
name|lwpid_t
name|gdb_tid
decl_stmt|;
name|int
name|step
decl_stmt|;
name|enum
name|target_signal
name|signal
decl_stmt|;
block|{
name|int
name|resume_all_threads
decl_stmt|;
name|lwpid_t
name|tid
decl_stmt|;
name|process_state_t
name|new_process_state
decl_stmt|;
name|resume_all_threads
operator|=
operator|(
name|gdb_tid
operator|==
name|INFTTRACE_ALL_THREADS
operator|)
operator|||
operator|(
name|vfork_in_flight
operator|)
expr_stmt|;
if|if
condition|(
name|resume_all_threads
condition|)
block|{
comment|/* Resume all threads, but first pick a tid value      * so we can get the pid when in call_ttrace doing      * the map.      */
if|if
condition|(
name|vfork_in_flight
condition|)
name|tid
operator|=
name|vforking_child_pid
expr_stmt|;
else|else
name|tid
operator|=
name|map_from_gdb_tid
argument_list|(
name|inferior_pid
argument_list|)
expr_stmt|;
block|}
else|else
name|tid
operator|=
name|map_from_gdb_tid
argument_list|(
name|gdb_tid
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|THREAD_DEBUG
if|if
condition|(
name|debug_on
condition|)
block|{
if|if
condition|(
name|more_events_left
condition|)
name|printf
argument_list|(
literal|"More events; "
argument_list|)
expr_stmt|;
if|if
condition|(
name|signal
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"Sending signal %d; "
argument_list|,
name|signal
argument_list|)
expr_stmt|;
if|if
condition|(
name|resume_all_threads
condition|)
block|{
if|if
condition|(
name|step
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"Continue process %d\n"
argument_list|,
name|tid
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"Step/continue thread %d\n"
argument_list|,
name|tid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|step
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"Continue thread %d\n"
argument_list|,
name|tid
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"Step just thread %d\n"
argument_list|,
name|tid
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vfork_in_flight
condition|)
name|printf
argument_list|(
literal|"Vfork in flight\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|process_state
operator|==
name|RUNNING
condition|)
name|warning
argument_list|(
literal|"Internal error in resume logic; doing resume or step anyway."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|step
comment|/* Asked to continue...       */
operator|&&
name|resume_all_threads
comment|/* whole process..            */
operator|&&
name|signal
operator|!=
literal|0
comment|/* with a signal...           */
operator|&&
name|more_events_left
operator|>
literal|0
condition|)
block|{
comment|/* but we can't yet--save it! */
comment|/* Continue with signal means we have to set the pending        * signal value for this thread.        */
name|thread_info
modifier|*
name|k
decl_stmt|;
ifdef|#
directive|ifdef
name|THREAD_DEBUG
if|if
condition|(
name|debug_on
condition|)
name|printf
argument_list|(
literal|"Saving signal %d for thread %d\n"
argument_list|,
name|signal
argument_list|,
name|tid
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|k
operator|=
name|find_thread_info
argument_list|(
name|tid
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|!=
name|NULL
condition|)
block|{
name|k
operator|->
name|have_signal
operator|=
literal|1
expr_stmt|;
name|k
operator|->
name|signal_value
operator|=
name|signal
expr_stmt|;
ifdef|#
directive|ifdef
name|THREAD_DEBUG
if|if
condition|(
name|debug_on
condition|)
if|if
condition|(
name|k
operator|->
name|terminated
condition|)
name|printf
argument_list|(
literal|"Why are we continuing a dead thread? (3)\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|THREAD_DEBUG
elseif|else
if|if
condition|(
name|debug_on
condition|)
block|{
name|printf
argument_list|(
literal|"No thread info for tid %d\n"
argument_list|,
name|tid
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
comment|/* Are we faking this "continue" or "step"?    *    * We used to do steps by continuing all the threads for     * which the events had been handled already.  While    * conceptually nicer (hides it all in a lower level), this    * can lead to starvation and a hang (e.g. all but one thread    * are unhandled at a breakpoint just before a "join" operation,    * and one thread is in the join, and the user wants to step that    * thread).    */
if|if
condition|(
name|resume_all_threads
comment|/* Whole process, therefore user command */
operator|&&
name|more_events_left
operator|>
literal|0
condition|)
block|{
comment|/* But we can't do this yet--fake it! */
name|thread_info
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|!
name|step
condition|)
block|{
comment|/* No need to do any notes on a per-thread            * basis--we're done!            */
ifdef|#
directive|ifdef
name|WAIT_BUFFER_DEBUG
if|if
condition|(
name|debug_on
condition|)
name|printf
argument_list|(
literal|"Faking a process resume.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|WAIT_BUFFER_DEBUG
if|if
condition|(
name|debug_on
condition|)
name|printf
argument_list|(
literal|"Faking a process step.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|p
operator|=
name|find_thread_info
argument_list|(
name|tid
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|warning
argument_list|(
literal|"No thread information for tid %d, 'next' command ignored.\n"
argument_list|,
name|tid
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|THREAD_DEBUG
if|if
condition|(
name|debug_on
condition|)
if|if
condition|(
name|p
operator|->
name|terminated
condition|)
name|printf
argument_list|(
literal|"Why are we continuing a dead thread? (3.5)\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|p
operator|->
name|stepping_mode
operator|!=
name|DO_DEFAULT
condition|)
block|{
name|warning
argument_list|(
literal|"Step or continue command applied to thread which is already stepping or continuing; command ignored."
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|step
condition|)
name|p
operator|->
name|stepping_mode
operator|=
name|DO_STEP
expr_stmt|;
else|else
name|p
operator|->
name|stepping_mode
operator|=
name|DO_CONTINUE
expr_stmt|;
return|return;
block|}
comment|/* Have thread info */
block|}
comment|/* Must fake step or go */
comment|/* Execept for fake-steps, from here on we know we are    * going to wind up with a running process which will    * need a real wait.    */
name|new_process_state
operator|=
name|RUNNING
expr_stmt|;
comment|/* An address of TT_USE_CURRENT_PC tells ttrace to continue from where    * it was.  (If GDB wanted it to start some other way, we have already    * written a new PC value to the child.)    *    * If this system does not support PT_STEP, a higher level function will    * have called single_step() to transmute the step request into a    * continue request (by setting breakpoints on all possible successor    * instructions), so we don't have to worry about that here.    */
if|if
condition|(
name|step
condition|)
block|{
if|if
condition|(
name|resume_all_threads
condition|)
block|{
comment|/*            * Regular user step: other threads get a "continue".            */
name|threads_continue_all_but_one
argument_list|(
name|tid
argument_list|,
name|signal
argument_list|)
expr_stmt|;
name|clear_all_handled
argument_list|()
expr_stmt|;
name|clear_all_stepping_mode
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* "Fake step": gdb is stepping one thread over a            * breakpoint, watchpoint, or out of a library load            * event, etc.  The rest just stay where they are.            *            * Also used when there are pending events: we really            * step the current thread, but leave the rest stopped.            * Users can't request this, but "wait_for_inferior"            * does--a lot!            */
name|thread_fake_step
argument_list|(
name|tid
argument_list|,
name|signal
argument_list|)
expr_stmt|;
comment|/* Clear the "handled" state of this thread, because            * we'll soon get a new event for it.  Other events            * stay as they were.            */
name|clear_handled
argument_list|(
name|tid
argument_list|)
expr_stmt|;
name|clear_stepping_mode
argument_list|(
name|tid
argument_list|)
expr_stmt|;
name|new_process_state
operator|=
name|FAKE_STEPPING
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* TT_LWP_CONTINUE can pass signals to threads,        * TT_PROC_CONTINUE can't.  So if there are any        * signals to pass, we have to use the (slower)        * loop over the stopped threads.        *        * Equally, if we have to not continue some threads,        * due to saved events, we have to use the loop.        */
if|if
condition|(
operator|(
name|signal
operator|!=
literal|0
operator|)
operator|||
name|saved_signals_exist
argument_list|()
condition|)
block|{
if|if
condition|(
name|resume_all_threads
condition|)
block|{
ifdef|#
directive|ifdef
name|THREAD_DEBUG
if|if
condition|(
name|debug_on
condition|)
name|printf
argument_list|(
literal|"Doing a continue by loop of all threads\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|threads_continue_all_with_signals
argument_list|(
name|tid
argument_list|,
name|signal
argument_list|)
expr_stmt|;
name|clear_all_handled
argument_list|()
expr_stmt|;
name|clear_all_stepping_mode
argument_list|()
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|THREAD_DEBUG
name|printf
argument_list|(
literal|"Doing a continue w/signal of just thread %d\n"
argument_list|,
name|tid
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|threads_continue_one_with_signal
argument_list|(
name|tid
argument_list|,
name|signal
argument_list|)
expr_stmt|;
comment|/* Clear the "handled" state of this thread, because                * we'll soon get a new event for it.  Other events                * can stay as they were.                */
name|clear_handled
argument_list|(
name|tid
argument_list|)
expr_stmt|;
name|clear_stepping_mode
argument_list|(
name|tid
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* No signals to send.            */
if|if
condition|(
name|resume_all_threads
condition|)
block|{
ifdef|#
directive|ifdef
name|THREAD_DEBUG
if|if
condition|(
name|debug_on
condition|)
name|printf
argument_list|(
literal|"Doing a continue by process of process %d\n"
argument_list|,
name|tid
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|more_events_left
operator|>
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"Losing buffered events on continue."
argument_list|)
expr_stmt|;
name|more_events_left
operator|=
literal|0
expr_stmt|;
block|}
name|call_ttrace
argument_list|(
name|TT_PROC_CONTINUE
argument_list|,
name|tid
argument_list|,
name|TT_NIL
argument_list|,
name|TT_NIL
argument_list|,
name|TT_NIL
argument_list|)
expr_stmt|;
name|clear_all_handled
argument_list|()
expr_stmt|;
name|clear_all_stepping_mode
argument_list|()
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|THREAD_DEBUG
if|if
condition|(
name|debug_on
condition|)
block|{
name|printf
argument_list|(
literal|"Doing a continue of just thread %d\n"
argument_list|,
name|tid
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_terminated
argument_list|(
name|tid
argument_list|)
condition|)
name|printf
argument_list|(
literal|"Why are we continuing a dead thread? (5)\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|call_ttrace
argument_list|(
name|TT_LWP_CONTINUE
argument_list|,
name|tid
argument_list|,
name|TT_NIL
argument_list|,
name|TT_NIL
argument_list|,
name|TT_NIL
argument_list|)
expr_stmt|;
comment|/* Clear the "handled" state of this thread, because                * we'll soon get a new event for it.  Other events                * can stay as they were.                */
name|clear_handled
argument_list|(
name|tid
argument_list|)
expr_stmt|;
name|clear_stepping_mode
argument_list|(
name|tid
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|process_state
operator|=
name|new_process_state
expr_stmt|;
ifdef|#
directive|ifdef
name|WAIT_BUFFER_DEBUG
if|if
condition|(
name|debug_on
condition|)
name|printf
argument_list|(
literal|"Process set to %s\n"
argument_list|,
name|get_printable_name_of_process_state
argument_list|(
name|process_state
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CHILD_RESUME */
end_comment

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|ATTACH_DETACH
end_ifdef

begin_comment
comment|/*  * Like it says.  *  * One worry is that we may not be attaching to "inferior_pid"  * and thus may not want to clear out our data.  FIXME?  *   */
end_comment

begin_function
specifier|static
name|void
name|update_thread_state_after_attach
parameter_list|(
name|pid
parameter_list|,
name|kind_of_go
parameter_list|)
name|int
name|pid
decl_stmt|;
name|attach_continue_t
name|kind_of_go
decl_stmt|;
block|{
name|int
name|tt_status
decl_stmt|;
name|ttstate_t
name|thread_state
decl_stmt|;
name|lwpid_t
name|a_thread
decl_stmt|;
name|lwpid_t
name|tid
decl_stmt|;
comment|/* The process better be stopped.    */
if|if
condition|(
name|process_state
operator|!=
name|STOPPED
operator|&&
name|process_state
operator|!=
name|VFORKING
condition|)
name|warning
argument_list|(
literal|"Internal error attaching."
argument_list|)
expr_stmt|;
comment|/* Clear out old tthread info and start over.  This has the    * side effect of ensuring that the TRAP is reported as being    * in the right thread (re-mapped from tid to pid).    *    * It's because we need to add the tthread _now_ that we    * need to call "clear_thread_info" _now_, and that's why    * "require_notification_of_events" doesn't clear the thread    * info (it's called later than this routine).    */
name|clear_thread_info
argument_list|()
expr_stmt|;
name|a_thread
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|tid
operator|=
name|get_process_first_stopped_thread_id
argument_list|(
name|pid
argument_list|,
operator|&
name|thread_state
argument_list|)
init|;
name|tid
operator|!=
literal|0
condition|;
name|tid
operator|=
name|get_process_next_stopped_thread_id
argument_list|(
name|pid
argument_list|,
operator|&
name|thread_state
argument_list|)
control|)
block|{
name|thread_info
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|a_thread
operator|==
literal|0
condition|)
block|{
name|a_thread
operator|=
name|tid
expr_stmt|;
ifdef|#
directive|ifdef
name|THREAD_DEBUG
if|if
condition|(
name|debug_on
condition|)
name|printf
argument_list|(
literal|"Attaching to process %d, thread %d\n"
argument_list|,
name|pid
argument_list|,
name|a_thread
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Tell ourselves and the "rest of gdb" that this thread        * exists.        *        * This isn't really a hack.  Other thread-based versions        * of gdb (e.g. gnu-nat.c) seem to do the same thing.        *        * We don't need to do mapping here, as we know this        * is the first thread and thus gets the real pid        * (and is "inferior_pid").        *        * NOTE: it probably isn't the originating thread,        *       but that doesn't matter (we hope!).        */
name|add_tthread
argument_list|(
name|pid
argument_list|,
name|tid
argument_list|)
expr_stmt|;
name|p
operator|=
name|find_thread_info
argument_list|(
name|tid
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|p
condition|)
comment|/* ?We just added it! */
name|error
argument_list|(
literal|"Internal error adding a thread on attach."
argument_list|)
expr_stmt|;
name|copy_ttstate_t
argument_list|(
operator|&
name|p
operator|->
name|last_stop_state
argument_list|,
name|thread_state
argument_list|)
expr_stmt|;
name|p
operator|->
name|have_state
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|DO_ATTACH_CONTINUE
operator|==
name|kind_of_go
condition|)
block|{
comment|/*            * If we are going to CONTINUE afterwards,            * raising a SIGTRAP, don't bother trying to            * handle this event.  But check first!            */
switch|switch
condition|(
name|p
operator|->
name|last_stop_state
operator|.
name|tts_event
condition|)
block|{
case|case
name|TTEVT_NONE
case|:
comment|/* Ok to set this handled.               */
break|break;
default|default:
name|warning
argument_list|(
literal|"Internal error; skipping event %s on process %d, thread %d."
argument_list|,
name|get_printable_name_of_ttrace_event
argument_list|(
name|p
operator|->
name|last_stop_state
operator|.
name|tts_event
argument_list|)
argument_list|,
name|p
operator|->
name|pid
argument_list|,
name|p
operator|->
name|tid
argument_list|)
expr_stmt|;
block|}
name|set_handled
argument_list|(
name|pid
argument_list|,
name|tid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* There will be no "continue" opertion, so the            * process remains stopped.  Don't set any events            * handled except the "gimmies".            */
switch|switch
condition|(
name|p
operator|->
name|last_stop_state
operator|.
name|tts_event
condition|)
block|{
case|case
name|TTEVT_NONE
case|:
comment|/* Ok to ignore this.                */
name|set_handled
argument_list|(
name|pid
argument_list|,
name|tid
argument_list|)
expr_stmt|;
break|break;
case|case
name|TTEVT_EXEC
case|:
case|case
name|TTEVT_FORK
case|:
comment|/* Expected "other" FORK or EXEC event from a                * fork or vfork.                */
break|break;
default|default:
name|printf
argument_list|(
literal|"Internal error: failed to handle event %s on process %d, thread %d."
argument_list|,
name|get_printable_name_of_ttrace_event
argument_list|(
name|p
operator|->
name|last_stop_state
operator|.
name|tts_event
argument_list|)
argument_list|,
name|p
operator|->
name|pid
argument_list|,
name|p
operator|->
name|tid
argument_list|)
expr_stmt|;
block|}
block|}
name|add_thread
argument_list|(
name|tid
argument_list|)
expr_stmt|;
comment|/* in thread.c */
block|}
ifdef|#
directive|ifdef
name|PARANOIA
if|if
condition|(
name|debug_on
condition|)
name|print_tthreads
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* One mustn't call ttrace_wait() after attaching via ttrace,      'cause the process is stopped already.            However, the upper layers of gdb's execution control will      want to wait after attaching (but not after forks, in      which case they will be doing a "target_resume", anticipating      a later TTEVT_EXEC or TTEVT_FORK event).       To make this attach() implementation more compatible with      others, we'll make the attached-to process raise a SIGTRAP.       Issue: this continues only one thread.  That could be      dangerous if the thread is blocked--the process won't run      and no trap will be raised.  FIX! (check state.tts_flags?      need one that's either TTS_WASRUNNING--but we've stopped      it and made it TTS_WASSUSPENDED.  Hum...FIXME!)    */
if|if
condition|(
name|DO_ATTACH_CONTINUE
operator|==
name|kind_of_go
condition|)
block|{
name|tt_status
operator|=
name|call_real_ttrace
argument_list|(
name|TT_LWP_CONTINUE
argument_list|,
name|pid
argument_list|,
name|a_thread
argument_list|,
name|TT_USE_CURRENT_PC
argument_list|,
operator|(
name|TTRACE_ARG_TYPE
operator|)
name|target_signal_to_host
argument_list|(
name|TARGET_SIGNAL_TRAP
argument_list|)
argument_list|,
name|TT_NIL
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
name|perror_with_name
argument_list|(
literal|"ttrace"
argument_list|)
expr_stmt|;
name|clear_handled
argument_list|(
name|a_thread
argument_list|)
expr_stmt|;
comment|/* So TRAP will be reported. */
comment|/* Now running.        */
name|process_state
operator|=
name|RUNNING
expr_stmt|;
block|}
name|attach_flag
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ATTACH_DETACH */
end_comment

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|ATTACH_DETACH
end_ifdef

begin_comment
comment|/* Start debugging the process whose number is PID.  * (A _real_ pid).  */
end_comment

begin_function
name|int
name|attach
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
name|int
name|tt_status
decl_stmt|;
name|tt_status
operator|=
name|call_real_ttrace
argument_list|(
name|TT_PROC_ATTACH
argument_list|,
name|pid
argument_list|,
operator|(
name|lwpid_t
operator|)
name|TT_NIL
argument_list|,
name|TT_NIL
argument_list|,
operator|(
name|TTRACE_ARG_TYPE
operator|)
name|TT_VERSION
argument_list|,
name|TT_NIL
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
name|perror_with_name
argument_list|(
literal|"ttrace attach"
argument_list|)
expr_stmt|;
comment|/* If successful, the process is now stopped.    */
name|process_state
operator|=
name|STOPPED
expr_stmt|;
comment|/* Our caller ("attach_command" in "infcmd.c")    * expects to do a "wait_for_inferior" after    * the attach, so make sure the inferior is    * running when we're done.    */
name|update_thread_state_after_attach
argument_list|(
name|pid
argument_list|,
name|DO_ATTACH_CONTINUE
argument_list|)
expr_stmt|;
return|return
name|pid
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CHILD_POST_ATTACH
argument_list|)
end_if

begin_function
name|void
name|child_post_attach
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|THREAD_DEBUG
if|if
condition|(
name|debug_on
condition|)
name|printf
argument_list|(
literal|"child-post-attach call\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|require_notification_of_events
argument_list|(
name|pid
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Stop debugging the process whose number is PID    and continue it with signal number SIGNAL.    SIGNAL = 0 means just continue it.  */
end_comment

begin_function
name|void
name|detach
parameter_list|(
name|signal
parameter_list|)
name|int
name|signal
decl_stmt|;
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|call_ttrace
argument_list|(
name|TT_PROC_DETACH
argument_list|,
name|inferior_pid
argument_list|,
name|TT_NIL
argument_list|,
operator|(
name|TTRACE_ARG_TYPE
operator|)
name|signal
argument_list|,
name|TT_NIL
argument_list|)
expr_stmt|;
name|attach_flag
operator|=
literal|0
expr_stmt|;
name|clear_thread_info
argument_list|()
expr_stmt|;
comment|/* Process-state? */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ATTACH_DETACH */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Default the type of the ttrace transfer to int.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|TTRACE_XFER_TYPE
end_ifndef

begin_define
define|#
directive|define
name|TTRACE_XFER_TYPE
value|int
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|_initialize_kernel_u_addr
parameter_list|()
block|{ }
end_function

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CHILD_XFER_MEMORY
argument_list|)
end_if

begin_comment
comment|/* NOTE! I tried using TTRACE_READDATA, etc., to read and write memory    in the NEW_SUN_TTRACE case.    It ought to be straightforward.  But it appears that writing did    not write the data that I specified.  I cannot understand where    it got the data that it actually did write.  */
end_comment

begin_comment
comment|/* Copy LEN bytes to or from inferior's memory starting at MEMADDR    to debugger memory starting at MYADDR.   Copy to inferior if    WRITE is nonzero.       Returns the length copied, which is either the LEN argument or zero.    This xfer function does not do partial moves, since child_ops    doesn't allow memory operations to cross below us in the target stack    anyway.  */
end_comment

begin_function
name|int
name|child_xfer_memory
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|,
name|write
parameter_list|,
name|target
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|write
decl_stmt|;
name|struct
name|target_ops
modifier|*
name|target
decl_stmt|;
comment|/* ignored */
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Round starting address down to longword boundary.  */
specifier|register
name|CORE_ADDR
name|addr
init|=
name|memaddr
operator|&
operator|-
sizeof|sizeof
argument_list|(
name|TTRACE_XFER_TYPE
argument_list|)
decl_stmt|;
comment|/* Round ending address up; get number of longwords that makes.  */
specifier|register
name|int
name|count
init|=
operator|(
operator|(
operator|(
name|memaddr
operator|+
name|len
operator|)
operator|-
name|addr
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|TTRACE_XFER_TYPE
argument_list|)
operator|-
literal|1
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|TTRACE_XFER_TYPE
argument_list|)
decl_stmt|;
comment|/* Allocate buffer of that many longwords.  */
specifier|register
name|TTRACE_XFER_TYPE
modifier|*
name|buffer
init|=
operator|(
name|TTRACE_XFER_TYPE
operator|*
operator|)
name|alloca
argument_list|(
name|count
operator|*
sizeof|sizeof
argument_list|(
name|TTRACE_XFER_TYPE
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|write
condition|)
block|{
comment|/* Fill start and end extra bytes of buffer with existing memory data.  */
if|if
condition|(
name|addr
operator|!=
name|memaddr
operator|||
name|len
operator|<
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|TTRACE_XFER_TYPE
argument_list|)
condition|)
block|{
comment|/* Need part of initial word -- fetch it.  */
name|buffer
index|[
literal|0
index|]
operator|=
name|call_ttrace
argument_list|(
name|TT_LWP_RDTEXT
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|TTRACE_ARG_TYPE
operator|)
name|addr
argument_list|,
name|TT_NIL
argument_list|,
name|TT_NIL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|>
literal|1
condition|)
comment|/* FIXME, avoid if even boundary */
block|{
name|buffer
index|[
name|count
operator|-
literal|1
index|]
operator|=
name|call_ttrace
argument_list|(
name|TT_LWP_RDTEXT
argument_list|,
name|inferior_pid
argument_list|,
operator|(
call|(
name|TTRACE_ARG_TYPE
call|)
argument_list|(
name|addr
operator|+
operator|(
name|count
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|TTRACE_XFER_TYPE
argument_list|)
argument_list|)
operator|)
argument_list|,
name|TT_NIL
argument_list|,
name|TT_NIL
argument_list|)
expr_stmt|;
block|}
comment|/* Copy data to be written over corresponding part of buffer */
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buffer
operator|+
operator|(
name|memaddr
operator|&
operator|(
sizeof|sizeof
argument_list|(
name|TTRACE_XFER_TYPE
argument_list|)
operator|-
literal|1
operator|)
operator|)
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Write the entire buffer.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|addr
operator|+=
sizeof|sizeof
argument_list|(
name|TTRACE_XFER_TYPE
argument_list|)
control|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|call_ttrace
argument_list|(
name|TT_LWP_WRDATA
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|TTRACE_ARG_TYPE
operator|)
name|addr
argument_list|,
operator|(
name|TTRACE_ARG_TYPE
operator|)
name|buffer
index|[
name|i
index|]
argument_list|,
name|TT_NIL
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
block|{
comment|/* Using the appropriate one (I or D) is necessary for 		 Gould NP1, at least.  */
name|errno
operator|=
literal|0
expr_stmt|;
name|call_ttrace
argument_list|(
name|TT_LWP_WRTEXT
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|TTRACE_ARG_TYPE
operator|)
name|addr
argument_list|,
operator|(
name|TTRACE_ARG_TYPE
operator|)
name|buffer
index|[
name|i
index|]
argument_list|,
name|TT_NIL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|errno
condition|)
return|return
literal|0
return|;
block|}
block|}
else|else
block|{
comment|/* Read all the longwords */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|addr
operator|+=
sizeof|sizeof
argument_list|(
name|TTRACE_XFER_TYPE
argument_list|)
control|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|buffer
index|[
name|i
index|]
operator|=
name|call_ttrace
argument_list|(
name|TT_LWP_RDTEXT
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|TTRACE_ARG_TYPE
operator|)
name|addr
argument_list|,
name|TT_NIL
argument_list|,
name|TT_NIL
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
return|return
literal|0
return|;
name|QUIT
expr_stmt|;
block|}
comment|/* Copy appropriate bytes out of the buffer.  */
name|memcpy
argument_list|(
name|myaddr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buffer
operator|+
operator|(
name|memaddr
operator|&
operator|(
sizeof|sizeof
argument_list|(
name|TTRACE_XFER_TYPE
argument_list|)
operator|-
literal|1
operator|)
operator|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
return|return
name|len
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|udot_info
parameter_list|()
block|{
name|int
name|udot_off
decl_stmt|;
comment|/* Offset into user struct */
name|int
name|udot_val
decl_stmt|;
comment|/* Value from user struct at udot_off */
name|char
name|mess
index|[
literal|128
index|]
decl_stmt|;
comment|/* For messages */
if|if
condition|(
operator|!
name|target_has_execution
condition|)
block|{
name|error
argument_list|(
literal|"The program is not being run."
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|KERNEL_U_SIZE
argument_list|)
comment|/* Adding support for this command is easy.  Typically you just add a      routine, called "kernel_u_size" that returns the size of the user      struct, to the appropriate *-nat.c file and then add to the native      config file "#define KERNEL_U_SIZE kernel_u_size()" */
name|error
argument_list|(
literal|"Don't know how large ``struct user'' is in this version of gdb."
argument_list|)
expr_stmt|;
else|#
directive|else
for|for
control|(
name|udot_off
operator|=
literal|0
init|;
name|udot_off
operator|<
name|KERNEL_U_SIZE
condition|;
name|udot_off
operator|+=
sizeof|sizeof
argument_list|(
name|udot_val
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
name|udot_off
operator|%
literal|24
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|udot_off
operator|>
literal|0
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|"%04x:"
argument_list|,
name|udot_off
argument_list|)
expr_stmt|;
block|}
name|udot_val
operator|=
name|call_ttrace
argument_list|(
name|TT_LWP_RUREGS
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|TTRACE_ARG_TYPE
operator|)
name|udot_off
argument_list|,
name|TT_NIL
argument_list|,
name|TT_NIL
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|mess
argument_list|,
literal|"\nreading user struct at offset 0x%x"
argument_list|,
name|udot_off
argument_list|)
expr_stmt|;
name|perror_with_name
argument_list|(
name|mess
argument_list|)
expr_stmt|;
block|}
comment|/* Avoid using nonportable (?) "*" in print specs */
name|printf_filtered
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|==
literal|4
condition|?
literal|" 0x%08x"
else|:
literal|" 0x%16x"
argument_list|,
name|udot_val
argument_list|)
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined (CHILD_XFER_MEMORY).  */
end_comment

begin_comment
comment|/* TTrace version of "target_pid_to_exec_file"  */
end_comment

begin_function
name|char
modifier|*
name|child_pid_to_exec_file
parameter_list|(
name|tid
parameter_list|)
name|int
name|tid
decl_stmt|;
block|{
specifier|static
name|char
name|exec_file_buffer
index|[
literal|1024
index|]
decl_stmt|;
name|int
name|tt_status
decl_stmt|;
name|CORE_ADDR
name|top_of_stack
decl_stmt|;
name|char
name|four_chars
index|[
literal|4
index|]
decl_stmt|;
name|int
name|name_index
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|done
decl_stmt|;
name|int
name|saved_inferior_pid
decl_stmt|;
comment|/* As of 10.x HP-UX, there's an explicit request to get the    *pathname.    */
name|tt_status
operator|=
name|call_ttrace
argument_list|(
name|TT_PROC_GET_PATHNAME
argument_list|,
name|tid
argument_list|,
operator|(
name|TTRACE_ARG_TYPE
operator|)
name|exec_file_buffer
argument_list|,
operator|(
name|TTRACE_ARG_TYPE
operator|)
sizeof|sizeof
argument_list|(
name|exec_file_buffer
argument_list|)
operator|-
literal|1
argument_list|,
name|TT_NIL
argument_list|)
expr_stmt|;
if|if
condition|(
name|tt_status
operator|>=
literal|0
condition|)
return|return
name|exec_file_buffer
return|;
comment|/* ??rehrauer: The above request may or may not be broken.  It      doesn't seem to work when I use it.  But, it may be designed      to only work immediately after an exec event occurs.  (I'm      waiting for COSL to explain.)       In any case, if it fails, try a really, truly amazingly gross      hack that DDE uses, of pawing through the process' data      segment to find the pathname.      */
name|top_of_stack
operator|=
literal|0x7b03a000
expr_stmt|;
name|name_index
operator|=
literal|0
expr_stmt|;
name|done
operator|=
literal|0
expr_stmt|;
comment|/* On the chance that pid != inferior_pid, set inferior_pid      to pid, so that (grrrr!) implicit uses of inferior_pid get      the right id.      */
name|saved_inferior_pid
operator|=
name|inferior_pid
expr_stmt|;
name|inferior_pid
operator|=
name|tid
expr_stmt|;
comment|/* Try to grab a null-terminated string. */
while|while
condition|(
operator|!
name|done
condition|)
block|{
if|if
condition|(
name|target_read_memory
argument_list|(
name|top_of_stack
argument_list|,
name|four_chars
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|inferior_pid
operator|=
name|saved_inferior_pid
expr_stmt|;
return|return
name|NULL
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|exec_file_buffer
index|[
name|name_index
operator|++
index|]
operator|=
name|four_chars
index|[
name|i
index|]
expr_stmt|;
name|done
operator|=
operator|(
name|four_chars
index|[
name|i
index|]
operator|==
literal|'\0'
operator|)
expr_stmt|;
if|if
condition|(
name|done
condition|)
break|break;
block|}
name|top_of_stack
operator|+=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|exec_file_buffer
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|inferior_pid
operator|=
name|saved_inferior_pid
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|inferior_pid
operator|=
name|saved_inferior_pid
expr_stmt|;
return|return
name|exec_file_buffer
return|;
block|}
end_function

begin_function
name|void
name|pre_fork_inferior
parameter_list|()
block|{
name|int
name|status
decl_stmt|;
name|status
operator|=
name|pipe
argument_list|(
name|startup_semaphore
operator|.
name|parent_channel
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|<
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"error getting parent pipe for startup semaphore"
argument_list|)
expr_stmt|;
return|return;
block|}
name|status
operator|=
name|pipe
argument_list|(
name|startup_semaphore
operator|.
name|child_channel
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|<
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"error getting child pipe for startup semaphore"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_comment
comment|/* Called via #define REQUIRE_ATTACH from inftarg.c,  * ultimately from "follow_inferior_fork" in infrun.c,  * itself called from "resume".  *  * This seems to be intended to attach after a fork or  * vfork, while "attach" is used to attach to a pid  * given by the user.  The check for an existing attach  * seems odd--it always fails in our test system.  */
end_comment

begin_function
name|int
name|hppa_require_attach
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
name|int
name|tt_status
decl_stmt|;
name|CORE_ADDR
name|pc
decl_stmt|;
name|CORE_ADDR
name|pc_addr
decl_stmt|;
name|unsigned
name|int
name|regs_offset
decl_stmt|;
name|process_state_t
name|old_process_state
init|=
name|process_state
decl_stmt|;
comment|/* Are we already attached?  There appears to be no explicit    * way to answer this via ttrace, so we try something which    * should be innocuous if we are attached.  If that fails,    * then we assume we're not attached, and so attempt to make    * it so.    */
name|errno
operator|=
literal|0
expr_stmt|;
name|tt_status
operator|=
name|call_real_ttrace
argument_list|(
name|TT_PROC_STOP
argument_list|,
name|pid
argument_list|,
operator|(
name|lwpid_t
operator|)
name|TT_NIL
argument_list|,
operator|(
name|TTRACE_ARG_TYPE
operator|)
name|TT_NIL
argument_list|,
operator|(
name|TTRACE_ARG_TYPE
operator|)
name|TT_NIL
argument_list|,
name|TT_NIL
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
block|{
comment|/* No change to process-state!        */
name|errno
operator|=
literal|0
expr_stmt|;
name|pid
operator|=
name|attach
argument_list|(
name|pid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* If successful, the process is now stopped.  But if       * we're VFORKING, the parent is still running, so don't       * change the process state.       */
if|if
condition|(
name|process_state
operator|!=
name|VFORKING
condition|)
name|process_state
operator|=
name|STOPPED
expr_stmt|;
comment|/* If we were already attached, you'd think that we       * would need to start going again--but you'd be wrong,       * as the fork-following code is actually in the middle       * of the "resume" routine in in "infrun.c" and so       * will (almost) immediately do a resume.       *       * On the other hand, if we are VFORKING, which means       * that the child and the parent share a process for a       * while, we know that "resume" won't be resuming       * until the child EXEC event is seen.  But we still       * don't want to continue, as the event is already       * there waiting.       */
name|update_thread_state_after_attach
argument_list|(
name|pid
argument_list|,
name|DONT_ATTACH_CONTINUE
argument_list|)
expr_stmt|;
block|}
comment|/* STOP succeeded */
return|return
name|pid
return|;
block|}
end_function

begin_function
name|int
name|hppa_require_detach
parameter_list|(
name|pid
parameter_list|,
name|signal
parameter_list|)
name|int
name|pid
decl_stmt|;
name|int
name|signal
decl_stmt|;
block|{
name|int
name|tt_status
decl_stmt|;
comment|/* If signal is non-zero, we must pass the signal on to the active      thread prior to detaching.  We do this by continuing the threads      with the signal.    */
if|if
condition|(
name|signal
operator|!=
literal|0
condition|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|threads_continue_all_with_signals
argument_list|(
name|pid
argument_list|,
name|signal
argument_list|)
expr_stmt|;
block|}
name|errno
operator|=
literal|0
expr_stmt|;
name|tt_status
operator|=
name|call_ttrace
argument_list|(
name|TT_PROC_DETACH
argument_list|,
name|pid
argument_list|,
name|TT_NIL
argument_list|,
name|TT_NIL
argument_list|,
name|TT_NIL
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
comment|/* Ignore any errors. */
comment|/* process_state? */
return|return
name|pid
return|;
block|}
end_function

begin_comment
comment|/* Given the starting address of a memory page, hash it to a bucket in    the memory page dictionary.    */
end_comment

begin_function
specifier|static
name|int
name|get_dictionary_bucket_of_page
parameter_list|(
name|page_start
parameter_list|)
name|CORE_ADDR
name|page_start
decl_stmt|;
block|{
name|int
name|hash
decl_stmt|;
name|hash
operator|=
operator|(
name|page_start
operator|/
name|memory_page_dictionary
operator|.
name|page_size
operator|)
expr_stmt|;
name|hash
operator|=
name|hash
operator|%
name|MEMORY_PAGE_DICTIONARY_BUCKET_COUNT
expr_stmt|;
return|return
name|hash
return|;
block|}
end_function

begin_comment
comment|/* Given a memory page's starting address, get (i.e., find an existing    or create a new) dictionary entry for the page.  The page will be    write-protected when this function returns, but may have a reference    count of 0 (if the page was newly-added to the dictionary).    */
end_comment

begin_function
specifier|static
name|memory_page_t
modifier|*
name|get_dictionary_entry_of_page
parameter_list|(
name|pid
parameter_list|,
name|page_start
parameter_list|)
name|int
name|pid
decl_stmt|;
name|CORE_ADDR
name|page_start
decl_stmt|;
block|{
name|int
name|bucket
decl_stmt|;
name|memory_page_t
modifier|*
name|page
init|=
name|NULL
decl_stmt|;
name|memory_page_t
modifier|*
name|previous_page
init|=
name|NULL
decl_stmt|;
comment|/* We're going to be using the dictionary now, than-kew. */
name|require_memory_page_dictionary
argument_list|(
name|pid
argument_list|)
expr_stmt|;
comment|/* Try to find an existing dictionary entry for this page.  Hash      on the page's starting address.      */
name|bucket
operator|=
name|get_dictionary_bucket_of_page
argument_list|(
name|page_start
argument_list|)
expr_stmt|;
name|page
operator|=
operator|&
name|memory_page_dictionary
operator|.
name|buckets
index|[
name|bucket
index|]
expr_stmt|;
while|while
condition|(
name|page
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|page
operator|->
name|page_start
operator|==
name|page_start
condition|)
break|break;
name|previous_page
operator|=
name|page
expr_stmt|;
name|page
operator|=
name|page
operator|->
name|next
expr_stmt|;
block|}
comment|/* Did we find a dictionary entry for this page?  If not, then      add it to the dictionary now.      */
if|if
condition|(
name|page
operator|==
name|NULL
condition|)
block|{
comment|/* Create a new entry. */
name|page
operator|=
operator|(
name|memory_page_t
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|memory_page_t
argument_list|)
argument_list|)
expr_stmt|;
name|page
operator|->
name|page_start
operator|=
name|page_start
expr_stmt|;
name|page
operator|->
name|reference_count
operator|=
literal|0
expr_stmt|;
name|page
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|page
operator|->
name|previous
operator|=
name|NULL
expr_stmt|;
comment|/* We'll write-protect the page now, if that's allowed. */
name|page
operator|->
name|original_permissions
operator|=
name|write_protect_page
argument_list|(
name|pid
argument_list|,
name|page_start
argument_list|)
expr_stmt|;
comment|/* Add the new entry to the dictionary. */
name|page
operator|->
name|previous
operator|=
name|previous_page
expr_stmt|;
name|previous_page
operator|->
name|next
operator|=
name|page
expr_stmt|;
name|memory_page_dictionary
operator|.
name|page_count
operator|++
expr_stmt|;
block|}
return|return
name|page
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|remove_dictionary_entry_of_page
parameter_list|(
name|pid
parameter_list|,
name|page
parameter_list|)
name|int
name|pid
decl_stmt|;
name|memory_page_t
modifier|*
name|page
decl_stmt|;
block|{
comment|/* Restore the page's original permissions. */
name|unwrite_protect_page
argument_list|(
name|pid
argument_list|,
name|page
operator|->
name|page_start
argument_list|,
name|page
operator|->
name|original_permissions
argument_list|)
expr_stmt|;
comment|/* Kick the page out of the dictionary. */
if|if
condition|(
name|page
operator|->
name|previous
operator|!=
name|NULL
condition|)
name|page
operator|->
name|previous
operator|->
name|next
operator|=
name|page
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|page
operator|->
name|next
operator|!=
name|NULL
condition|)
name|page
operator|->
name|next
operator|->
name|previous
operator|=
name|page
operator|->
name|previous
expr_stmt|;
comment|/* Just in case someone retains a handle to this after it's freed. */
name|page
operator|->
name|page_start
operator|=
operator|(
name|CORE_ADDR
operator|)
literal|0
expr_stmt|;
name|memory_page_dictionary
operator|.
name|page_count
operator|--
expr_stmt|;
name|free
argument_list|(
name|page
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hppa_enable_syscall_events
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
name|int
name|tt_status
decl_stmt|;
name|ttevent_t
name|ttrace_events
decl_stmt|;
comment|/* Get the set of events that are currently enabled. */
name|tt_status
operator|=
name|call_ttrace
argument_list|(
name|TT_PROC_GET_EVENT_MASK
argument_list|,
name|pid
argument_list|,
operator|(
name|TTRACE_ARG_TYPE
operator|)
operator|&
name|ttrace_events
argument_list|,
operator|(
name|TTRACE_ARG_TYPE
operator|)
sizeof|sizeof
argument_list|(
name|ttrace_events
argument_list|)
argument_list|,
name|TT_NIL
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
name|perror_with_name
argument_list|(
literal|"ttrace"
argument_list|)
expr_stmt|;
comment|/* Add syscall events to that set. */
name|ttrace_events
operator|.
name|tte_events
operator||=
name|TTEVT_SYSCALL_ENTRY
expr_stmt|;
name|ttrace_events
operator|.
name|tte_events
operator||=
name|TTEVT_SYSCALL_RETURN
expr_stmt|;
name|tt_status
operator|=
name|call_ttrace
argument_list|(
name|TT_PROC_SET_EVENT_MASK
argument_list|,
name|pid
argument_list|,
operator|(
name|TTRACE_ARG_TYPE
operator|)
operator|&
name|ttrace_events
argument_list|,
operator|(
name|TTRACE_ARG_TYPE
operator|)
sizeof|sizeof
argument_list|(
name|ttrace_events
argument_list|)
argument_list|,
name|TT_NIL
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
name|perror_with_name
argument_list|(
literal|"ttrace"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hppa_disable_syscall_events
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
name|int
name|tt_status
decl_stmt|;
name|ttevent_t
name|ttrace_events
decl_stmt|;
comment|/* Get the set of events that are currently enabled. */
name|tt_status
operator|=
name|call_ttrace
argument_list|(
name|TT_PROC_GET_EVENT_MASK
argument_list|,
name|pid
argument_list|,
operator|(
name|TTRACE_ARG_TYPE
operator|)
operator|&
name|ttrace_events
argument_list|,
operator|(
name|TTRACE_ARG_TYPE
operator|)
sizeof|sizeof
argument_list|(
name|ttrace_events
argument_list|)
argument_list|,
name|TT_NIL
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
name|perror_with_name
argument_list|(
literal|"ttrace"
argument_list|)
expr_stmt|;
comment|/* Remove syscall events from that set. */
name|ttrace_events
operator|.
name|tte_events
operator|&=
operator|~
name|TTEVT_SYSCALL_ENTRY
expr_stmt|;
name|ttrace_events
operator|.
name|tte_events
operator|&=
operator|~
name|TTEVT_SYSCALL_RETURN
expr_stmt|;
name|tt_status
operator|=
name|call_ttrace
argument_list|(
name|TT_PROC_SET_EVENT_MASK
argument_list|,
name|pid
argument_list|,
operator|(
name|TTRACE_ARG_TYPE
operator|)
operator|&
name|ttrace_events
argument_list|,
operator|(
name|TTRACE_ARG_TYPE
operator|)
sizeof|sizeof
argument_list|(
name|ttrace_events
argument_list|)
argument_list|,
name|TT_NIL
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
name|perror_with_name
argument_list|(
literal|"ttrace"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The address range beginning with START and ending with START+LEN-1    (inclusive) is to be watched via page-protection by a new watchpoint.    Set protection for all pages that overlap that range.     Note that our caller sets TYPE to:      0 for a bp_hardware_watchpoint,      1 for a bp_read_watchpoint,      2 for a bp_access_watchpoint     (Yes, this is intentionally (though lord only knows why) different    from the TYPE that is passed to hppa_remove_hw_watchpoint.)    */
end_comment

begin_function
name|int
name|hppa_insert_hw_watchpoint
parameter_list|(
name|pid
parameter_list|,
name|start
parameter_list|,
name|len
parameter_list|,
name|type
parameter_list|)
name|int
name|pid
decl_stmt|;
name|CORE_ADDR
name|start
decl_stmt|;
name|LONGEST
name|len
decl_stmt|;
name|int
name|type
decl_stmt|;
block|{
name|CORE_ADDR
name|page_start
decl_stmt|;
name|int
name|dictionary_was_empty
decl_stmt|;
name|int
name|page_size
decl_stmt|;
name|int
name|page_id
decl_stmt|;
name|LONGEST
name|range_size_in_pages
decl_stmt|;
if|if
condition|(
name|type
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|"read or access hardware watchpoints not supported on HP-UX"
argument_list|)
expr_stmt|;
comment|/* Examine all pages in the address range. */
name|require_memory_page_dictionary
argument_list|()
expr_stmt|;
name|dictionary_was_empty
operator|=
operator|(
name|memory_page_dictionary
operator|.
name|page_count
operator|==
operator|(
name|LONGEST
operator|)
literal|0
operator|)
expr_stmt|;
name|page_size
operator|=
name|memory_page_dictionary
operator|.
name|page_size
expr_stmt|;
name|page_start
operator|=
operator|(
name|start
operator|/
name|page_size
operator|)
operator|*
name|page_size
expr_stmt|;
name|range_size_in_pages
operator|=
operator|(
operator|(
name|LONGEST
operator|)
name|len
operator|+
operator|(
name|LONGEST
operator|)
name|page_size
operator|-
literal|1
operator|)
operator|/
operator|(
name|LONGEST
operator|)
name|page_size
expr_stmt|;
for|for
control|(
name|page_id
operator|=
literal|0
init|;
name|page_id
operator|<
name|range_size_in_pages
condition|;
name|page_id
operator|++
operator|,
name|page_start
operator|+=
name|page_size
control|)
block|{
name|memory_page_t
modifier|*
name|page
decl_stmt|;
comment|/* This gets the page entered into the dictionary if it was          not already entered.          */
name|page
operator|=
name|get_dictionary_entry_of_page
argument_list|(
name|pid
argument_list|,
name|page_start
argument_list|)
expr_stmt|;
name|page
operator|->
name|reference_count
operator|++
expr_stmt|;
block|}
comment|/* Our implementation depends on seeing calls to kernel code, for the      following reason.  Here we ask to be notified of syscalls.       When a protected page is accessed by user code, HP-UX raises a SIGBUS.      Fine.       But when kernel code accesses the page, it doesn't give a SIGBUS.      Rather, the system call that touched the page fails, with errno=EFAULT.      Not good for us.       We could accomodate this "feature" by asking to be notified of syscall      entries& exits; upon getting an entry event, disabling page-protections;      upon getting an exit event, reenabling page-protections and then checking      if any watchpoints triggered.       However, this turns out to be a real performance loser.  syscalls are      usually a frequent occurrence.  Having to unprotect-reprotect all watched      pages, and also to then read all watched memory locations and compare for      triggers, can be quite expensive.       Instead, we'll only ask to be notified of syscall exits.  When we get      one, we'll check whether errno is set.  If not, or if it's not EFAULT,      we can just continue the inferior.       If errno is set upon syscall exit to EFAULT, we must perform some fairly      hackish stuff to determine whether the failure really was due to a      page-protect trap on a watched location.      */
if|if
condition|(
name|dictionary_was_empty
condition|)
name|hppa_enable_syscall_events
argument_list|(
name|pid
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* The address range beginning with START and ending with START+LEN-1    (inclusive) was being watched via page-protection by a watchpoint    which has been removed.  Remove protection for all pages that    overlap that range, which are not also being watched by other    watchpoints.    */
end_comment

begin_function
name|int
name|hppa_remove_hw_watchpoint
parameter_list|(
name|pid
parameter_list|,
name|start
parameter_list|,
name|len
parameter_list|,
name|type
parameter_list|)
name|int
name|pid
decl_stmt|;
name|CORE_ADDR
name|start
decl_stmt|;
name|LONGEST
name|len
decl_stmt|;
name|enum
name|bptype
name|type
decl_stmt|;
block|{
name|CORE_ADDR
name|page_start
decl_stmt|;
name|int
name|dictionary_is_empty
decl_stmt|;
name|int
name|page_size
decl_stmt|;
name|int
name|page_id
decl_stmt|;
name|LONGEST
name|range_size_in_pages
decl_stmt|;
if|if
condition|(
name|type
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|"read or access hardware watchpoints not supported on HP-UX"
argument_list|)
expr_stmt|;
comment|/* Examine all pages in the address range. */
name|require_memory_page_dictionary
argument_list|()
expr_stmt|;
name|page_size
operator|=
name|memory_page_dictionary
operator|.
name|page_size
expr_stmt|;
name|page_start
operator|=
operator|(
name|start
operator|/
name|page_size
operator|)
operator|*
name|page_size
expr_stmt|;
name|range_size_in_pages
operator|=
operator|(
operator|(
name|LONGEST
operator|)
name|len
operator|+
operator|(
name|LONGEST
operator|)
name|page_size
operator|-
literal|1
operator|)
operator|/
operator|(
name|LONGEST
operator|)
name|page_size
expr_stmt|;
for|for
control|(
name|page_id
operator|=
literal|0
init|;
name|page_id
operator|<
name|range_size_in_pages
condition|;
name|page_id
operator|++
operator|,
name|page_start
operator|+=
name|page_size
control|)
block|{
name|memory_page_t
modifier|*
name|page
decl_stmt|;
name|page
operator|=
name|get_dictionary_entry_of_page
argument_list|(
name|pid
argument_list|,
name|page_start
argument_list|)
expr_stmt|;
name|page
operator|->
name|reference_count
operator|--
expr_stmt|;
comment|/* Was this the last reference of this page?  If so, then we          must scrub the entry from the dictionary, and also restore          the page's original permissions.          */
if|if
condition|(
name|page
operator|->
name|reference_count
operator|==
literal|0
condition|)
name|remove_dictionary_entry_of_page
argument_list|(
name|pid
argument_list|,
name|page
argument_list|)
expr_stmt|;
block|}
name|dictionary_is_empty
operator|=
operator|(
name|memory_page_dictionary
operator|.
name|page_count
operator|==
operator|(
name|LONGEST
operator|)
literal|0
operator|)
expr_stmt|;
comment|/* If write protections are currently disallowed, then that implies that      wait_for_inferior believes that the inferior is within a system call.      Since we want to see both syscall entry and return, it's clearly not      good to disable syscall events in this state!       ??rehrauer: Yeah, it'd be better if we had a specific flag that said,      "inferior is between syscall events now".  Oh well.      */
if|if
condition|(
name|dictionary_is_empty
operator|&&
name|memory_page_dictionary
operator|.
name|page_protections_allowed
condition|)
name|hppa_disable_syscall_events
argument_list|(
name|pid
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Could we implement a watchpoint of this type via our available    hardware support?     This query does not consider whether a particular address range    could be so watched, but just whether support is generally available    for such things.  See hppa_range_profitable_for_hw_watchpoint for a    query that answers whether a particular range should be watched via    hardware support.    */
end_comment

begin_function
name|int
name|hppa_can_use_hw_watchpoint
parameter_list|(
name|type
parameter_list|,
name|cnt
parameter_list|,
name|ot
parameter_list|)
name|enum
name|bptype
name|type
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|enum
name|bptype
name|ot
decl_stmt|;
block|{
return|return
operator|(
name|type
operator|==
name|bp_hardware_watchpoint
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Assuming we could set a hardware watchpoint on this address, do    we think it would be profitable ("a good idea") to do so?  If not,    we can always set a regular (aka single-step& test) watchpoint    on the address...    */
end_comment

begin_function
name|int
name|hppa_range_profitable_for_hw_watchpoint
parameter_list|(
name|pid
parameter_list|,
name|start
parameter_list|,
name|len
parameter_list|)
name|int
name|pid
decl_stmt|;
name|CORE_ADDR
name|start
decl_stmt|;
name|LONGEST
name|len
decl_stmt|;
block|{
name|int
name|range_is_stack_based
decl_stmt|;
name|int
name|range_is_accessible
decl_stmt|;
name|CORE_ADDR
name|page_start
decl_stmt|;
name|int
name|page_size
decl_stmt|;
name|int
name|page
decl_stmt|;
name|LONGEST
name|range_size_in_pages
decl_stmt|;
comment|/* ??rehrauer: For now, say that all addresses are potentially      profitable.  Possibly later we'll want to test the address      for "stackness"?      */
name|range_is_stack_based
operator|=
literal|0
expr_stmt|;
comment|/* If any page in the range is inaccessible, then we cannot      really use hardware watchpointing, even though our client      thinks we can.  In that case, it's actually an error to      attempt to use hw watchpoints, so we'll tell our client      that the range is "unprofitable", and hope that they listen...      */
name|range_is_accessible
operator|=
literal|1
expr_stmt|;
comment|/* Until proven otherwise. */
comment|/* Examine all pages in the address range. */
name|errno
operator|=
literal|0
expr_stmt|;
name|page_size
operator|=
name|sysconf
argument_list|(
name|_SC_PAGE_SIZE
argument_list|)
expr_stmt|;
comment|/* If we can't determine page size, we're hosed.  Tell our      client it's unprofitable to use hw watchpoints for this      range.      */
if|if
condition|(
name|errno
operator|||
operator|(
name|page_size
operator|<=
literal|0
operator|)
condition|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
name|page_start
operator|=
operator|(
name|start
operator|/
name|page_size
operator|)
operator|*
name|page_size
expr_stmt|;
name|range_size_in_pages
operator|=
name|len
operator|/
operator|(
name|LONGEST
operator|)
name|page_size
expr_stmt|;
for|for
control|(
name|page
operator|=
literal|0
init|;
name|page
operator|<
name|range_size_in_pages
condition|;
name|page
operator|++
operator|,
name|page_start
operator|+=
name|page_size
control|)
block|{
name|int
name|tt_status
decl_stmt|;
name|int
name|page_permissions
decl_stmt|;
comment|/* Is this page accessible? */
name|errno
operator|=
literal|0
expr_stmt|;
name|tt_status
operator|=
name|call_ttrace
argument_list|(
name|TT_PROC_GET_MPROTECT
argument_list|,
name|pid
argument_list|,
operator|(
name|TTRACE_ARG_TYPE
operator|)
name|page_start
argument_list|,
name|TT_NIL
argument_list|,
operator|(
name|TTRACE_ARG_TYPE
operator|)
operator|&
name|page_permissions
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|||
operator|(
name|tt_status
operator|<
literal|0
operator|)
condition|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|range_is_accessible
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* Yes, go for another... */
block|}
return|return
operator|(
operator|!
name|range_is_stack_based
operator|&&
name|range_is_accessible
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|hppa_pid_or_tid_to_str
parameter_list|(
name|id
parameter_list|)
name|pid_t
name|id
decl_stmt|;
block|{
specifier|static
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
comment|/* Static because address returned. */
comment|/* Does this appear to be a process?  If so, print it that way. */
if|if
condition|(
name|is_process_id
argument_list|(
name|id
argument_list|)
condition|)
return|return
name|hppa_pid_to_str
argument_list|(
name|id
argument_list|)
return|;
comment|/* Else, print both the GDB thread number and the system thread id. */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"thread %d ("
argument_list|,
name|pid_to_thread_id
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
name|hppa_tid_to_str
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
literal|")\0"
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If the current pid is not the pid this module reported  * from "ptrace_wait" with the most recent event, then the  * user has switched threads.  *  * If the last reported event was a breakpoint, then return  * the old thread id, else return 0.  */
end_comment

begin_function
name|pid_t
name|hppa_switched_threads
parameter_list|(
name|gdb_pid
parameter_list|)
name|pid_t
name|gdb_pid
decl_stmt|;
block|{
if|if
condition|(
name|gdb_pid
operator|==
name|old_gdb_pid
condition|)
block|{
comment|/*        * Core gdb is working with the same pid that it        * was before we reported the last event.  This        * is ok: e.g. we reported hitting a thread-specific        * breakpoint, but we were reporting the wrong        * thread, so the core just ignored the event.        *        * No thread switch has happened.        */
return|return
operator|(
name|pid_t
operator|)
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|gdb_pid
operator|==
name|reported_pid
condition|)
block|{
comment|/*        * Core gdb is working with the pid we reported, so        * any continue or step will be able to figure out        * that it needs to step over any hit breakpoints        * without our (i.e. PREPARE_TO_PROCEED's) help.        */
return|return
operator|(
name|pid_t
operator|)
literal|0
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|reported_bpt
condition|)
block|{
comment|/*         * The core switched, but we didn't just report a         * breakpoint, so there's no just-hit breakpoint         * instruction at "reported_pid"'s PC, and thus there         * is no need to step over it.         */
return|return
operator|(
name|pid_t
operator|)
literal|0
return|;
block|}
else|else
block|{
comment|/* There's been a real switch, and we reported         * a hit breakpoint.  Let "hppa_prepare_to_proceed"         * know, so it can see whether the breakpoint is         * still active.         */
return|return
name|reported_pid
return|;
block|}
comment|/* Keep compiler happy with an obvious return at the end.    */
return|return
operator|(
name|pid_t
operator|)
literal|0
return|;
block|}
end_function

begin_function
name|void
name|hppa_ensure_vforking_parent_remains_stopped
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
comment|/* Nothing to do when using ttrace.  Only the ptrace-based implementation      must do real work.    */
block|}
end_function

begin_function
name|int
name|hppa_resume_execd_vforking_child_to_get_parent_vfork
parameter_list|()
block|{
return|return
literal|0
return|;
comment|/* No, the parent vfork is available now. */
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|_initialize_infttrace
parameter_list|()
block|{
comment|/* Initialize the ttrace-based hardware watchpoint implementation. */
name|memory_page_dictionary
operator|.
name|page_count
operator|=
operator|(
name|LONGEST
operator|)
operator|-
literal|1
expr_stmt|;
name|memory_page_dictionary
operator|.
name|page_protections_allowed
operator|=
literal|1
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|memory_page_dictionary
operator|.
name|page_size
operator|=
name|sysconf
argument_list|(
name|_SC_PAGE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|||
operator|(
name|memory_page_dictionary
operator|.
name|page_size
operator|<=
literal|0
operator|)
condition|)
name|perror_with_name
argument_list|(
literal|"sysconf"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

