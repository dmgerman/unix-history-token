begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* *INDENT-OFF* */
end_comment

begin_comment
comment|/* ATTR_FORMAT confuses indent, avoid running it for now */
end_comment

begin_comment
comment|/* Basic, host-specific, and target-specific definitions for GDB.    Copyright 1986, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996,    1997, 1998, 1999, 2000, 2001, 2002    Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DEFS_H
end_ifndef

begin_define
define|#
directive|define
name|DEFS_H
end_define

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_comment
comment|/* Generated by configure */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_comment
comment|/* System call error return status */
end_comment

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STDDEF_H
end_ifdef

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_comment
comment|/* for size_t */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Just in case they're not defined in stdio.h. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SEEK_SET
end_ifndef

begin_define
define|#
directive|define
name|SEEK_SET
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SEEK_CUR
end_ifndef

begin_define
define|#
directive|define
name|SEEK_CUR
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* First include ansidecl.h so we can use the various macro definitions    here and in all subsequent file inclusions.  */
end_comment

begin_include
include|#
directive|include
file|"ansidecl.h"
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_comment
comment|/* for va_list */
end_comment

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"progress.h"
end_include

begin_comment
comment|/* For BFD64 and bfd_vma.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_comment
comment|/* The target is partially multi-arched.  Both "tm.h" and the    multi-arch vector provide definitions.  "tm.h" normally overrides    the multi-arch vector (but there are a few exceptions).  */
end_comment

begin_define
define|#
directive|define
name|GDB_MULTI_ARCH_PARTIAL
value|1
end_define

begin_comment
comment|/* The target is partially multi-arched. Both the multi-arch vector    and "tm.h" provide definitions. "tm.h" cannot override a definition    provided by the multi-arch vector.  It is detected as a compilation    error.     This setting is only useful during a multi-arch conversion. */
end_comment

begin_define
define|#
directive|define
name|GDB_MULTI_ARCH_TM
value|2
end_define

begin_comment
comment|/* The target is pure multi-arch.  The MULTI-ARCH vector provides all    definitions.  "tm.h" is linked to an empty file. */
end_comment

begin_define
define|#
directive|define
name|GDB_MULTI_ARCH_PURE
value|3
end_define

begin_comment
comment|/* An address in the program being debugged.  Host byte order.  Rather    than duplicate all the logic in BFD which figures out what type    this is (long, long long, etc.) and whether it needs to be 64    bits (the host/target interactions are subtle), we just use    bfd_vma.  */
end_comment

begin_typedef
typedef|typedef
name|bfd_vma
name|CORE_ADDR
typedef|;
end_typedef

begin_comment
comment|/* This is to make sure that LONGEST is at least as big as CORE_ADDR.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LONGEST
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|BFD64
end_ifdef

begin_define
define|#
directive|define
name|LONGEST
value|BFD_HOST_64_BIT
end_define

begin_define
define|#
directive|define
name|ULONGEST
value|BFD_HOST_U_64_BIT
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* No BFD64 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CC_HAS_LONG_LONG
end_ifdef

begin_define
define|#
directive|define
name|LONGEST
value|long long
end_define

begin_define
define|#
directive|define
name|ULONGEST
value|unsigned long long
end_define

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|BFD_HOST_64_BIT
end_ifdef

begin_comment
comment|/* BFD_HOST_64_BIT is defined for some hosts that don't have long long    (e.g. i386-windows) so try it.  */
end_comment

begin_define
define|#
directive|define
name|LONGEST
value|BFD_HOST_64_BIT
end_define

begin_define
define|#
directive|define
name|ULONGEST
value|BFD_HOST_U_64_BIT
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|LONGEST
value|long
end_define

begin_define
define|#
directive|define
name|ULONGEST
value|unsigned long
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* No BFD64 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! LONGEST */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|min
end_ifndef

begin_define
define|#
directive|define
name|min
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)< (b) ? (a) : (b))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|max
end_ifndef

begin_define
define|#
directive|define
name|max
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)> (b) ? (a) : (b))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Macros to do string compares.     NOTE: cagney/2000-03-14:     While old code can continue to refer to these macros, new code is    probably better off using strcmp() directly vis: ``strcmp() == 0''    and ``strcmp() != 0''.     This is because modern compilers can directly inline strcmp()    making the original justification for these macros - avoid function    call overhead by pre-testing the first characters    (``*X==*Y?...:0'') - redundant.     ``Even if [...] testing the first character does have a modest    performance improvement, I'd rather that whenever a performance    issue is found that we spend the effort on algorithmic    optimizations than micro-optimizing.'' J.T. */
end_comment

begin_define
define|#
directive|define
name|STREQ
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(*(a) == *(b) ? !strcmp ((a), (b)) : 0)
end_define

begin_define
define|#
directive|define
name|STREQN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|(*(a) == *(b) ? !strncmp ((a), (b), (c)) : 0)
end_define

begin_comment
comment|/* The character GNU C++ uses to build identifiers that must be unique from    the program's identifiers (such as $this and $$vptr).  */
end_comment

begin_define
define|#
directive|define
name|CPLUS_MARKER
value|'$'
end_define

begin_comment
comment|/* May be overridden to '.' for SysV */
end_comment

begin_comment
comment|/* Check if a character is one of the commonly used C++ marker characters.  */
end_comment

begin_function_decl
specifier|extern
name|int
name|is_cplus_marker
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* use tui interface if non-zero */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|tui_version
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* enable xdb commands if set */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|xdb_commands
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* enable dbx commands if set */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|dbx_commands
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|quit_flag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|immediate_quit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|sevenbit_strings
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|void
name|quit
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* FIXME: cagney/2000-03-13: It has been suggested that the peformance    benefits of having a ``QUIT'' macro rather than a function are    marginal.  If the overhead of a QUIT function call is proving    significant then its calling frequency should probably be reduced    [kingdon].  A profile analyzing the current situtation is    needed. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|QUIT
end_ifdef

begin_comment
comment|/* do twice to force compiler warning */
end_comment

begin_define
define|#
directive|define
name|QUIT_FIXME
value|"FIXME"
end_define

begin_define
define|#
directive|define
name|QUIT_FIXME
value|"ignoring redefinition of QUIT"
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|QUIT
value|{ \   if (quit_flag) quit (); \   if (interactive_hook) interactive_hook (); \   PROGRESS (1); \ }
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Languages represented in the symbol table and elsewhere.    This should probably be in language.h, but since enum's can't    be forward declared to satisfy opaque references before their    actual definition, needs to be here. */
end_comment

begin_enum
enum|enum
name|language
block|{
name|language_unknown
block|,
comment|/* Language not known */
name|language_auto
block|,
comment|/* Placeholder for automatic setting */
name|language_c
block|,
comment|/* C */
name|language_cplus
block|,
comment|/* C++ */
name|language_java
block|,
comment|/* Java */
name|language_chill
block|,
comment|/* Chill */
name|language_fortran
block|,
comment|/* Fortran */
name|language_m2
block|,
comment|/* Modula-2 */
name|language_asm
block|,
comment|/* Assembly language */
name|language_scm
block|,
comment|/* Scheme / Guile */
name|language_pascal
comment|/* Pascal */
block|}
enum|;
end_enum

begin_enum
enum|enum
name|precision_type
block|{
name|single_precision
block|,
name|double_precision
block|,
name|unspecified_precision
block|}
enum|;
end_enum

begin_comment
comment|/* The numbering of these signals is chosen to match traditional unix    signals (insofar as various unices use the same numbers, anyway).    It is also the numbering of the GDB remote protocol.  Other remote    protocols, if they use a different numbering, should make sure to    translate appropriately.     Since these numbers have actually made it out into other software    (stubs, etc.), you mustn't disturb the assigned numbering.  If you    need to add new signals here, add them to the end of the explicitly    numbered signals.     This is based strongly on Unix/POSIX signals for several reasons:    (1) This set of signals represents a widely-accepted attempt to    represent events of this sort in a portable fashion, (2) we want a    signal to make it from wait to child_wait to the user intact, (3) many    remote protocols use a similar encoding.  However, it is    recognized that this set of signals has limitations (such as not    distinguishing between various kinds of SIGSEGV, or not    distinguishing hitting a breakpoint from finishing a single step).    So in the future we may get around this either by adding additional    signals for breakpoint, single-step, etc., or by adding signal    codes; the latter seems more in the spirit of what BSD, System V,    etc. are doing to address these issues.  */
end_comment

begin_comment
comment|/* For an explanation of what each signal means, see    target_signal_to_string.  */
end_comment

begin_enum
enum|enum
name|target_signal
block|{
comment|/* Used some places (e.g. stop_signal) to record the concept that        there is no signal.  */
name|TARGET_SIGNAL_0
init|=
literal|0
block|,
name|TARGET_SIGNAL_FIRST
init|=
literal|0
block|,
name|TARGET_SIGNAL_HUP
init|=
literal|1
block|,
name|TARGET_SIGNAL_INT
init|=
literal|2
block|,
name|TARGET_SIGNAL_QUIT
init|=
literal|3
block|,
name|TARGET_SIGNAL_ILL
init|=
literal|4
block|,
name|TARGET_SIGNAL_TRAP
init|=
literal|5
block|,
name|TARGET_SIGNAL_ABRT
init|=
literal|6
block|,
name|TARGET_SIGNAL_EMT
init|=
literal|7
block|,
name|TARGET_SIGNAL_FPE
init|=
literal|8
block|,
name|TARGET_SIGNAL_KILL
init|=
literal|9
block|,
name|TARGET_SIGNAL_BUS
init|=
literal|10
block|,
name|TARGET_SIGNAL_SEGV
init|=
literal|11
block|,
name|TARGET_SIGNAL_SYS
init|=
literal|12
block|,
name|TARGET_SIGNAL_PIPE
init|=
literal|13
block|,
name|TARGET_SIGNAL_ALRM
init|=
literal|14
block|,
name|TARGET_SIGNAL_TERM
init|=
literal|15
block|,
name|TARGET_SIGNAL_URG
init|=
literal|16
block|,
name|TARGET_SIGNAL_STOP
init|=
literal|17
block|,
name|TARGET_SIGNAL_TSTP
init|=
literal|18
block|,
name|TARGET_SIGNAL_CONT
init|=
literal|19
block|,
name|TARGET_SIGNAL_CHLD
init|=
literal|20
block|,
name|TARGET_SIGNAL_TTIN
init|=
literal|21
block|,
name|TARGET_SIGNAL_TTOU
init|=
literal|22
block|,
name|TARGET_SIGNAL_IO
init|=
literal|23
block|,
name|TARGET_SIGNAL_XCPU
init|=
literal|24
block|,
name|TARGET_SIGNAL_XFSZ
init|=
literal|25
block|,
name|TARGET_SIGNAL_VTALRM
init|=
literal|26
block|,
name|TARGET_SIGNAL_PROF
init|=
literal|27
block|,
name|TARGET_SIGNAL_WINCH
init|=
literal|28
block|,
name|TARGET_SIGNAL_LOST
init|=
literal|29
block|,
name|TARGET_SIGNAL_USR1
init|=
literal|30
block|,
name|TARGET_SIGNAL_USR2
init|=
literal|31
block|,
name|TARGET_SIGNAL_PWR
init|=
literal|32
block|,
comment|/* Similar to SIGIO.  Perhaps they should have the same number.  */
name|TARGET_SIGNAL_POLL
init|=
literal|33
block|,
name|TARGET_SIGNAL_WIND
init|=
literal|34
block|,
name|TARGET_SIGNAL_PHONE
init|=
literal|35
block|,
name|TARGET_SIGNAL_WAITING
init|=
literal|36
block|,
name|TARGET_SIGNAL_LWP
init|=
literal|37
block|,
name|TARGET_SIGNAL_DANGER
init|=
literal|38
block|,
name|TARGET_SIGNAL_GRANT
init|=
literal|39
block|,
name|TARGET_SIGNAL_RETRACT
init|=
literal|40
block|,
name|TARGET_SIGNAL_MSG
init|=
literal|41
block|,
name|TARGET_SIGNAL_SOUND
init|=
literal|42
block|,
name|TARGET_SIGNAL_SAK
init|=
literal|43
block|,
name|TARGET_SIGNAL_PRIO
init|=
literal|44
block|,
name|TARGET_SIGNAL_REALTIME_33
init|=
literal|45
block|,
name|TARGET_SIGNAL_REALTIME_34
init|=
literal|46
block|,
name|TARGET_SIGNAL_REALTIME_35
init|=
literal|47
block|,
name|TARGET_SIGNAL_REALTIME_36
init|=
literal|48
block|,
name|TARGET_SIGNAL_REALTIME_37
init|=
literal|49
block|,
name|TARGET_SIGNAL_REALTIME_38
init|=
literal|50
block|,
name|TARGET_SIGNAL_REALTIME_39
init|=
literal|51
block|,
name|TARGET_SIGNAL_REALTIME_40
init|=
literal|52
block|,
name|TARGET_SIGNAL_REALTIME_41
init|=
literal|53
block|,
name|TARGET_SIGNAL_REALTIME_42
init|=
literal|54
block|,
name|TARGET_SIGNAL_REALTIME_43
init|=
literal|55
block|,
name|TARGET_SIGNAL_REALTIME_44
init|=
literal|56
block|,
name|TARGET_SIGNAL_REALTIME_45
init|=
literal|57
block|,
name|TARGET_SIGNAL_REALTIME_46
init|=
literal|58
block|,
name|TARGET_SIGNAL_REALTIME_47
init|=
literal|59
block|,
name|TARGET_SIGNAL_REALTIME_48
init|=
literal|60
block|,
name|TARGET_SIGNAL_REALTIME_49
init|=
literal|61
block|,
name|TARGET_SIGNAL_REALTIME_50
init|=
literal|62
block|,
name|TARGET_SIGNAL_REALTIME_51
init|=
literal|63
block|,
name|TARGET_SIGNAL_REALTIME_52
init|=
literal|64
block|,
name|TARGET_SIGNAL_REALTIME_53
init|=
literal|65
block|,
name|TARGET_SIGNAL_REALTIME_54
init|=
literal|66
block|,
name|TARGET_SIGNAL_REALTIME_55
init|=
literal|67
block|,
name|TARGET_SIGNAL_REALTIME_56
init|=
literal|68
block|,
name|TARGET_SIGNAL_REALTIME_57
init|=
literal|69
block|,
name|TARGET_SIGNAL_REALTIME_58
init|=
literal|70
block|,
name|TARGET_SIGNAL_REALTIME_59
init|=
literal|71
block|,
name|TARGET_SIGNAL_REALTIME_60
init|=
literal|72
block|,
name|TARGET_SIGNAL_REALTIME_61
init|=
literal|73
block|,
name|TARGET_SIGNAL_REALTIME_62
init|=
literal|74
block|,
name|TARGET_SIGNAL_REALTIME_63
init|=
literal|75
block|,
comment|/* Used internally by Solaris threads.  See signal(5) on Solaris.  */
name|TARGET_SIGNAL_CANCEL
init|=
literal|76
block|,
comment|/* Yes, this pains me, too.  But LynxOS didn't have SIG32, and now        GNU/Linux does, and we can't disturb the numbering, since it's        part of the remote protocol.  Note that in some GDB's        TARGET_SIGNAL_REALTIME_32 is number 76.  */
name|TARGET_SIGNAL_REALTIME_32
block|,
comment|/* Yet another pain, IRIX 6 has SIG64. */
name|TARGET_SIGNAL_REALTIME_64
block|,
comment|/* Yet another pain, GNU/Linux MIPS might go up to 128. */
name|TARGET_SIGNAL_REALTIME_65
block|,
name|TARGET_SIGNAL_REALTIME_66
block|,
name|TARGET_SIGNAL_REALTIME_67
block|,
name|TARGET_SIGNAL_REALTIME_68
block|,
name|TARGET_SIGNAL_REALTIME_69
block|,
name|TARGET_SIGNAL_REALTIME_70
block|,
name|TARGET_SIGNAL_REALTIME_71
block|,
name|TARGET_SIGNAL_REALTIME_72
block|,
name|TARGET_SIGNAL_REALTIME_73
block|,
name|TARGET_SIGNAL_REALTIME_74
block|,
name|TARGET_SIGNAL_REALTIME_75
block|,
name|TARGET_SIGNAL_REALTIME_76
block|,
name|TARGET_SIGNAL_REALTIME_77
block|,
name|TARGET_SIGNAL_REALTIME_78
block|,
name|TARGET_SIGNAL_REALTIME_79
block|,
name|TARGET_SIGNAL_REALTIME_80
block|,
name|TARGET_SIGNAL_REALTIME_81
block|,
name|TARGET_SIGNAL_REALTIME_82
block|,
name|TARGET_SIGNAL_REALTIME_83
block|,
name|TARGET_SIGNAL_REALTIME_84
block|,
name|TARGET_SIGNAL_REALTIME_85
block|,
name|TARGET_SIGNAL_REALTIME_86
block|,
name|TARGET_SIGNAL_REALTIME_87
block|,
name|TARGET_SIGNAL_REALTIME_88
block|,
name|TARGET_SIGNAL_REALTIME_89
block|,
name|TARGET_SIGNAL_REALTIME_90
block|,
name|TARGET_SIGNAL_REALTIME_91
block|,
name|TARGET_SIGNAL_REALTIME_92
block|,
name|TARGET_SIGNAL_REALTIME_93
block|,
name|TARGET_SIGNAL_REALTIME_94
block|,
name|TARGET_SIGNAL_REALTIME_95
block|,
name|TARGET_SIGNAL_REALTIME_96
block|,
name|TARGET_SIGNAL_REALTIME_97
block|,
name|TARGET_SIGNAL_REALTIME_98
block|,
name|TARGET_SIGNAL_REALTIME_99
block|,
name|TARGET_SIGNAL_REALTIME_100
block|,
name|TARGET_SIGNAL_REALTIME_101
block|,
name|TARGET_SIGNAL_REALTIME_102
block|,
name|TARGET_SIGNAL_REALTIME_103
block|,
name|TARGET_SIGNAL_REALTIME_104
block|,
name|TARGET_SIGNAL_REALTIME_105
block|,
name|TARGET_SIGNAL_REALTIME_106
block|,
name|TARGET_SIGNAL_REALTIME_107
block|,
name|TARGET_SIGNAL_REALTIME_108
block|,
name|TARGET_SIGNAL_REALTIME_109
block|,
name|TARGET_SIGNAL_REALTIME_110
block|,
name|TARGET_SIGNAL_REALTIME_111
block|,
name|TARGET_SIGNAL_REALTIME_112
block|,
name|TARGET_SIGNAL_REALTIME_113
block|,
name|TARGET_SIGNAL_REALTIME_114
block|,
name|TARGET_SIGNAL_REALTIME_115
block|,
name|TARGET_SIGNAL_REALTIME_116
block|,
name|TARGET_SIGNAL_REALTIME_117
block|,
name|TARGET_SIGNAL_REALTIME_118
block|,
name|TARGET_SIGNAL_REALTIME_119
block|,
name|TARGET_SIGNAL_REALTIME_120
block|,
name|TARGET_SIGNAL_REALTIME_121
block|,
name|TARGET_SIGNAL_REALTIME_122
block|,
name|TARGET_SIGNAL_REALTIME_123
block|,
name|TARGET_SIGNAL_REALTIME_124
block|,
name|TARGET_SIGNAL_REALTIME_125
block|,
name|TARGET_SIGNAL_REALTIME_126
block|,
name|TARGET_SIGNAL_REALTIME_127
block|,
if|#
directive|if
name|defined
argument_list|(
name|MACH
argument_list|)
operator|||
name|defined
argument_list|(
name|__MACH__
argument_list|)
comment|/* Mach exceptions */
name|TARGET_EXC_BAD_ACCESS
block|,
name|TARGET_EXC_BAD_INSTRUCTION
block|,
name|TARGET_EXC_ARITHMETIC
block|,
name|TARGET_EXC_EMULATION
block|,
name|TARGET_EXC_SOFTWARE
block|,
name|TARGET_EXC_BREAKPOINT
block|,
endif|#
directive|endif
name|TARGET_SIGNAL_INFO
block|,
comment|/* Some signal we don't know about.  */
name|TARGET_SIGNAL_UNKNOWN
block|,
comment|/* Use whatever signal we use when one is not specifically specified        (for passing to proceed and so on).  */
name|TARGET_SIGNAL_DEFAULT
block|,
comment|/* Last and unused enum value, for sizing arrays, etc.  */
name|TARGET_SIGNAL_LAST
block|}
enum|;
end_enum

begin_comment
comment|/* the cleanup list records things that have to be undone    if an error happens (descriptors to be closed, memory to be freed, etc.)    Each link in the chain records a function to call and an    argument to give it.     Use make_cleanup to add an element to the cleanup chain.    Use do_cleanups to do all cleanup actions back to a given    point in the chain.  Use discard_cleanups to remove cleanups    from the chain back to a given point, not doing them.  */
end_comment

begin_struct
struct|struct
name|cleanup
block|{
name|struct
name|cleanup
modifier|*
name|next
decl_stmt|;
name|void
function_decl|(
modifier|*
name|function
function_decl|)
parameter_list|(
name|PTR
parameter_list|)
function_decl|;
name|PTR
name|arg
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The ability to declare that a function never returns is useful, but    not really required to compile GDB successfully, so the NORETURN and    ATTR_NORETURN macros normally expand into nothing.  */
end_comment

begin_comment
comment|/* If compiling with older versions of GCC, a function may be declared    "volatile" to indicate that it does not return.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NORETURN
end_ifndef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
expr|\
operator|&&
operator|(
name|__GNUC__
operator|==
literal|1
operator|||
operator|(
name|__GNUC__
operator|==
literal|2
operator|&&
name|__GNUC_MINOR__
operator|<
literal|7
operator|)
operator|)
end_if

begin_define
define|#
directive|define
name|NORETURN
value|volatile
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|NORETURN
end_define

begin_comment
comment|/* nothing */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* GCC 2.5 and later versions define a function attribute "noreturn",    which is the preferred way to declare that a function never returns.    However GCC 2.7 appears to be the first version in which this fully    works everywhere we use it. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ATTR_NORETURN
end_ifndef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
operator|(
name|__GNUC__
operator|>
literal|2
operator|||
operator|(
name|__GNUC__
operator|==
literal|2
operator|&&
name|__GNUC_MINOR__
operator|>=
literal|7
operator|)
operator|)
end_if

begin_define
define|#
directive|define
name|ATTR_NORETURN
value|__attribute__ ((noreturn))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ATTR_NORETURN
end_define

begin_comment
comment|/* nothing */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ATTR_FORMAT
end_ifndef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
operator|(
name|__GNUC__
operator|>
literal|2
operator|||
operator|(
name|__GNUC__
operator|==
literal|2
operator|&&
name|__GNUC_MINOR__
operator|>=
literal|4
operator|)
operator|)
end_if

begin_define
define|#
directive|define
name|ATTR_FORMAT
parameter_list|(
name|type
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|)
value|__attribute__ ((format(type, x, y)))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ATTR_FORMAT
parameter_list|(
name|type
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|)
end_define

begin_comment
comment|/* nothing */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Needed for various prototypes */
end_comment

begin_struct_decl
struct_decl|struct
name|symtab
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|breakpoint
struct_decl|;
end_struct_decl

begin_comment
comment|/* From blockframe.c */
end_comment

begin_function_decl
specifier|extern
name|int
name|inside_entry_func
parameter_list|(
name|CORE_ADDR
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|inside_entry_file
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|inside_main_func
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* From ch-lang.c, for the moment. (FIXME) */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|chill_demangle
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* From utils.c */
end_comment

begin_function_decl
specifier|extern
name|void
name|initialize_utils
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|notice_quit
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|strcmp_iw
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|subset_compare
parameter_list|(
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|safe_strerror
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|init_malloc
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|request_quit
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|do_cleanups
parameter_list|(
name|struct
name|cleanup
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|do_final_cleanups
parameter_list|(
name|struct
name|cleanup
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|do_my_cleanups
parameter_list|(
name|struct
name|cleanup
modifier|*
modifier|*
parameter_list|,
name|struct
name|cleanup
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|do_run_cleanups
parameter_list|(
name|struct
name|cleanup
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|do_exec_cleanups
parameter_list|(
name|struct
name|cleanup
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|do_exec_error_cleanups
parameter_list|(
name|struct
name|cleanup
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|discard_cleanups
parameter_list|(
name|struct
name|cleanup
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|discard_final_cleanups
parameter_list|(
name|struct
name|cleanup
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|discard_exec_error_cleanups
parameter_list|(
name|struct
name|cleanup
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|discard_my_cleanups
parameter_list|(
name|struct
name|cleanup
modifier|*
modifier|*
parameter_list|,
name|struct
name|cleanup
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* NOTE: cagney/2000-03-04: This typedef is strictly for the    make_cleanup function declarations below. Do not use this typedef    as a cast when passing functions into the make_cleanup() code.    Instead either use a bounce function or add a wrapper function.    Calling a f(char*) function with f(void*) is non-portable. */
end_comment

begin_typedef
typedef|typedef
name|void
function_decl|(
name|make_cleanup_ftype
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_function_decl
specifier|extern
name|struct
name|cleanup
modifier|*
name|make_cleanup
parameter_list|(
name|make_cleanup_ftype
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|struct
name|cleanup
modifier|*
name|make_cleanup_freeargv
parameter_list|(
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_struct_decl
struct_decl|struct
name|ui_file
struct_decl|;
end_struct_decl

begin_function_decl
specifier|extern
name|struct
name|cleanup
modifier|*
name|make_cleanup_ui_file_delete
parameter_list|(
name|struct
name|ui_file
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|struct
name|cleanup
modifier|*
name|make_cleanup_close
parameter_list|(
name|int
name|fd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|struct
name|cleanup
modifier|*
name|make_cleanup_bfd_close
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|struct
name|cleanup
modifier|*
name|make_final_cleanup
parameter_list|(
name|make_cleanup_ftype
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|struct
name|cleanup
modifier|*
name|make_my_cleanup
parameter_list|(
name|struct
name|cleanup
modifier|*
modifier|*
parameter_list|,
name|make_cleanup_ftype
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|struct
name|cleanup
modifier|*
name|make_run_cleanup
parameter_list|(
name|make_cleanup_ftype
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|struct
name|cleanup
modifier|*
name|make_exec_cleanup
parameter_list|(
name|make_cleanup_ftype
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|struct
name|cleanup
modifier|*
name|make_exec_error_cleanup
parameter_list|(
name|make_cleanup_ftype
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|struct
name|cleanup
modifier|*
name|save_cleanups
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|struct
name|cleanup
modifier|*
name|save_final_cleanups
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|struct
name|cleanup
modifier|*
name|save_my_cleanups
parameter_list|(
name|struct
name|cleanup
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|restore_cleanups
parameter_list|(
name|struct
name|cleanup
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|restore_final_cleanups
parameter_list|(
name|struct
name|cleanup
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|restore_my_cleanups
parameter_list|(
name|struct
name|cleanup
modifier|*
modifier|*
parameter_list|,
name|struct
name|cleanup
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|free_current_contents
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|null_cleanup
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|myread
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|query
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
function_decl|ATTR_FORMAT
parameter_list|(
name|printf
parameter_list|,
function_decl|1
operator|,
function_decl|2
end_function_decl

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|extern
name|void
name|init_page_info
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|CORE_ADDR
name|host_pointer_to_address
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
modifier|*
name|address_to_host_pointer
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|gdb_realpath
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* From demangle.c */
end_comment

begin_function_decl
specifier|extern
name|void
name|set_demangling_style
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* From tm.h */
end_comment

begin_struct_decl
struct_decl|struct
name|type
struct_decl|;
end_struct_decl

begin_typedef
typedef|typedef
name|int
function_decl|(
name|use_struct_convention_fn
function_decl|)
parameter_list|(
name|int
name|gcc_p
parameter_list|,
name|struct
name|type
modifier|*
name|value_type
parameter_list|)
function_decl|;
end_typedef

begin_decl_stmt
specifier|extern
name|use_struct_convention_fn
name|generic_use_struct_convention
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
name|unsigned
name|char
modifier|*
function_decl|(
name|breakpoint_from_pc_fn
function_decl|)
parameter_list|(
name|CORE_ADDR
modifier|*
name|pcptr
parameter_list|,
name|int
modifier|*
name|lenptr
parameter_list|)
function_decl|;
end_typedef

begin_escape
end_escape

begin_comment
comment|/* Annotation stuff.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|annotation_level
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* in stack.c */
end_comment

begin_escape
end_escape

begin_function_decl
specifier|extern
name|void
name|begin_line
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|wrap_here
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|reinitialize_more_filter
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Normal results */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|ui_file
modifier|*
name|gdb_stdout
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Serious error notifications */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|ui_file
modifier|*
name|gdb_stderr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Log/debug/trace messages that should bypass normal stdout/stderr    filtering.  For momement, always call this stream using    *_unfiltered. In the very near future that restriction shall be    removed - either call shall be unfiltered. (cagney 1999-06-13). */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|ui_file
modifier|*
name|gdb_stdlog
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Target output that should bypass normal stdout/stderr filtering.    For momement, always call this stream using *_unfiltered. In the    very near future that restriction shall be removed - either call    shall be unfiltered. (cagney 1999-07-02). */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|ui_file
modifier|*
name|gdb_stdtarg
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|TUI
argument_list|)
end_if

begin_include
include|#
directive|include
file|"tui.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ui-file.h"
end_include

begin_comment
comment|/* More generic printf like operations.  Filtered versions may return    non-locally on error.  */
end_comment

begin_function_decl
specifier|extern
name|void
name|fputs_filtered
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|struct
name|ui_file
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|fputs_unfiltered
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|struct
name|ui_file
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|fputc_filtered
parameter_list|(
name|int
name|c
parameter_list|,
name|struct
name|ui_file
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|fputc_unfiltered
parameter_list|(
name|int
name|c
parameter_list|,
name|struct
name|ui_file
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|putchar_filtered
parameter_list|(
name|int
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|putchar_unfiltered
parameter_list|(
name|int
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|puts_filtered
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|puts_unfiltered
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|puts_debug
parameter_list|(
name|char
modifier|*
name|prefix
parameter_list|,
name|char
modifier|*
name|string
parameter_list|,
name|char
modifier|*
name|suffix
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|vprintf_filtered
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|va_list
parameter_list|)
function_decl|ATTR_FORMAT
parameter_list|(
name|printf
parameter_list|,
function_decl|1
operator|,
function_decl|0
end_function_decl

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|extern
name|void
name|vfprintf_filtered
parameter_list|(
name|struct
name|ui_file
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|va_list
parameter_list|)
function_decl|ATTR_FORMAT
parameter_list|(
name|printf
parameter_list|,
function_decl|2
operator|,
function_decl|0
end_function_decl

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|extern
name|void
name|fprintf_filtered
parameter_list|(
name|struct
name|ui_file
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
function_decl|ATTR_FORMAT
parameter_list|(
name|printf
parameter_list|,
function_decl|2
operator|,
function_decl|3
end_function_decl

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|extern
name|void
name|fprintfi_filtered
parameter_list|(
name|int
parameter_list|,
name|struct
name|ui_file
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
function_decl|ATTR_FORMAT
parameter_list|(
name|printf
parameter_list|,
function_decl|3
operator|,
function_decl|4
end_function_decl

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|extern
name|void
name|printf_filtered
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
function_decl|ATTR_FORMAT
parameter_list|(
name|printf
parameter_list|,
function_decl|1
operator|,
function_decl|2
end_function_decl

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|extern
name|void
name|printfi_filtered
parameter_list|(
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
function_decl|ATTR_FORMAT
parameter_list|(
name|printf
parameter_list|,
function_decl|2
operator|,
function_decl|3
end_function_decl

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|extern
name|void
name|vprintf_unfiltered
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|va_list
parameter_list|)
function_decl|ATTR_FORMAT
parameter_list|(
name|printf
parameter_list|,
function_decl|1
operator|,
function_decl|0
end_function_decl

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|extern
name|void
name|vfprintf_unfiltered
parameter_list|(
name|struct
name|ui_file
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|va_list
parameter_list|)
function_decl|ATTR_FORMAT
parameter_list|(
name|printf
parameter_list|,
function_decl|2
operator|,
function_decl|0
end_function_decl

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|extern
name|void
name|fprintf_unfiltered
parameter_list|(
name|struct
name|ui_file
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
function_decl|ATTR_FORMAT
parameter_list|(
name|printf
parameter_list|,
function_decl|2
operator|,
function_decl|3
end_function_decl

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|extern
name|void
name|printf_unfiltered
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
function_decl|ATTR_FORMAT
parameter_list|(
name|printf
parameter_list|,
function_decl|1
operator|,
function_decl|2
end_function_decl

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|extern
name|void
name|print_spaces
parameter_list|(
name|int
parameter_list|,
name|struct
name|ui_file
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|print_spaces_filtered
parameter_list|(
name|int
parameter_list|,
name|struct
name|ui_file
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|n_spaces
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|fputstr_filtered
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|int
name|quotr
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|fputstr_unfiltered
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|int
name|quotr
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|fputstrn_unfiltered
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|int
name|n
parameter_list|,
name|int
name|quotr
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Display the host ADDR on STREAM formatted as ``0x%x''. */
end_comment

begin_function_decl
specifier|extern
name|void
name|gdb_print_host_address
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Convert a CORE_ADDR into a HEX string.  paddr() is like %08lx.    paddr_nz() is like %lx.  paddr_u() is like %lu. paddr_width() is    for ``%*''. */
end_comment

begin_function_decl
specifier|extern
name|int
name|strlen_paddr
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|paddr
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|paddr_nz
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|paddr_u
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|paddr_d
parameter_list|(
name|LONGEST
name|addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|phex
parameter_list|(
name|ULONGEST
name|l
parameter_list|,
name|int
name|sizeof_l
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|phex_nz
parameter_list|(
name|ULONGEST
name|l
parameter_list|,
name|int
name|sizeof_l
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Like paddr() only print/scan raw CORE_ADDR.  The output from    core_addr_to_string() can be passed direct to    string_to_core_addr().  */
end_comment

begin_function_decl
specifier|extern
specifier|const
name|char
modifier|*
name|core_addr_to_string
parameter_list|(
specifier|const
name|CORE_ADDR
name|addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
specifier|const
name|char
modifier|*
name|core_addr_to_string_nz
parameter_list|(
specifier|const
name|CORE_ADDR
name|addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|CORE_ADDR
name|string_to_core_addr
parameter_list|(
specifier|const
name|char
modifier|*
name|my_string
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|fprintf_symbol_filtered
parameter_list|(
name|struct
name|ui_file
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|enum
name|language
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|NORETURN
name|void
name|perror_with_name
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
name|ATTR_NORETURN
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|void
name|print_sys_errmsg
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* From regex.c or libc.  BSD 4.4 declares this with the argument type as    "const char *" in unistd.h, so we can't declare the argument    as "char *".  */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|re_comp
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* From symfile.c */
end_comment

begin_function_decl
specifier|extern
name|void
name|symbol_file_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Remote targets may wish to use this as their load function.  */
end_comment

begin_function_decl
specifier|extern
name|void
name|generic_load
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|from_tty
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Summarise a download */
end_comment

begin_function_decl
specifier|extern
name|void
name|print_transfer_performance
parameter_list|(
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|unsigned
name|long
name|data_count
parameter_list|,
name|unsigned
name|long
name|write_count
parameter_list|,
name|unsigned
name|long
name|time_count
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* From top.c */
end_comment

begin_typedef
typedef|typedef
name|void
name|initialize_file_ftype
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_typedef

begin_function_decl
specifier|extern
name|char
modifier|*
name|skip_quoted
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|gdb_readline
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|command_line_input
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|print_prompt
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|input_from_terminal_p
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|int
name|info_verbose
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* From printcmd.c */
end_comment

begin_function_decl
specifier|extern
name|void
name|set_next_address
parameter_list|(
name|CORE_ADDR
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|print_address_symbolic
parameter_list|(
name|CORE_ADDR
parameter_list|,
name|struct
name|ui_file
modifier|*
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|build_address_symbolic
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|int
name|do_demangle
parameter_list|,
name|char
modifier|*
modifier|*
name|name
parameter_list|,
name|int
modifier|*
name|offset
parameter_list|,
name|char
modifier|*
modifier|*
name|filename
parameter_list|,
name|int
modifier|*
name|line
parameter_list|,
name|int
modifier|*
name|unmapped
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|print_address_numeric
parameter_list|(
name|CORE_ADDR
parameter_list|,
name|int
parameter_list|,
name|struct
name|ui_file
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|print_address
parameter_list|(
name|CORE_ADDR
parameter_list|,
name|struct
name|ui_file
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* From source.c */
end_comment

begin_function_decl
specifier|extern
name|int
name|openp
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|source_full_path_of
parameter_list|(
name|char
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|mod_path
parameter_list|(
name|char
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|directory_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|init_source_path
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|symtab_to_filename
parameter_list|(
name|struct
name|symtab
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* From exec.c */
end_comment

begin_function_decl
specifier|extern
name|void
name|exec_set_section_offsets
parameter_list|(
name|bfd_signed_vma
name|text_off
parameter_list|,
name|bfd_signed_vma
name|data_off
parameter_list|,
name|bfd_signed_vma
name|bss_off
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Take over the 'find_mapped_memory' vector from exec.c. */
end_comment

begin_function_decl
specifier|extern
name|void
name|exec_set_find_memory_regions
parameter_list|(
name|int
function_decl|(
modifier|*
function_decl|)
parameter_list|(
name|int
function_decl|(
modifier|*
function_decl|)
parameter_list|(
name|CORE_ADDR
parameter_list|,
name|unsigned
name|long
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* From findvar.c */
end_comment

begin_function_decl
specifier|extern
name|int
name|read_relative_register_raw_bytes
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Possible lvalue types.  Like enum language, this should be in    value.h, but needs to be here for the same reason. */
end_comment

begin_enum
enum|enum
name|lval_type
block|{
comment|/* Not an lval. */
name|not_lval
block|,
comment|/* In memory.  Could be a saved register.  */
name|lval_memory
block|,
comment|/* In a register.  */
name|lval_register
block|,
comment|/* In a gdb internal variable.  */
name|lval_internalvar
block|,
comment|/* Part of a gdb internal variable (structure field).  */
name|lval_internalvar_component
block|,
comment|/* In a register series in a frame not the current one, which may have been        partially saved or saved in different places (otherwise would be        lval_register or lval_memory).  */
name|lval_reg_frame_relative
block|}
enum|;
end_enum

begin_struct_decl
struct_decl|struct
name|frame_info
struct_decl|;
end_struct_decl

begin_comment
comment|/* From readline (but not in any readline .h files).  */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|tilde_expand
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Control types for commands */
end_comment

begin_enum
enum|enum
name|misc_command_type
block|{
name|ok_command
block|,
name|end_command
block|,
name|else_command
block|,
name|nop_command
block|}
enum|;
end_enum

begin_enum
enum|enum
name|command_control_type
block|{
name|simple_control
block|,
name|break_control
block|,
name|continue_control
block|,
name|while_control
block|,
name|if_control
block|,
name|invalid_control
block|}
enum|;
end_enum

begin_comment
comment|/* Structure for saved commands lines    (for breakpoints, defined commands, etc).  */
end_comment

begin_struct
struct|struct
name|command_line
block|{
name|struct
name|command_line
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|;
name|enum
name|command_control_type
name|control_type
decl_stmt|;
name|int
name|body_count
decl_stmt|;
name|struct
name|command_line
modifier|*
modifier|*
name|body_list
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|extern
name|struct
name|command_line
modifier|*
name|read_command_lines
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|free_command_lines
parameter_list|(
name|struct
name|command_line
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* To continue the execution commands when running gdb asynchronously.     A continuation structure contains a pointer to a function to be called     to finish the command, once the target has stopped. Such mechanism is    used bt the finish and until commands, and in the remote protocol    when opening an extended-remote connection. */
end_comment

begin_struct
struct|struct
name|continuation_arg
block|{
name|struct
name|continuation_arg
modifier|*
name|next
decl_stmt|;
union|union
name|continuation_data
block|{
name|void
modifier|*
name|pointer
decl_stmt|;
name|int
name|integer
decl_stmt|;
name|long
name|longint
decl_stmt|;
block|}
name|data
union|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|continuation
block|{
name|void
function_decl|(
modifier|*
name|continuation_hook
function_decl|)
parameter_list|(
name|struct
name|continuation_arg
modifier|*
parameter_list|)
function_decl|;
name|struct
name|continuation_arg
modifier|*
name|arg_list
decl_stmt|;
name|struct
name|continuation
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* In infrun.c. */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|continuation
modifier|*
name|cmd_continuation
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used only by the step_1 function. */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|continuation
modifier|*
name|intermediate_continuation
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* From utils.c */
end_comment

begin_function_decl
specifier|extern
name|void
name|add_continuation
parameter_list|(
name|void
function_decl|(
modifier|*
function_decl|)
parameter_list|(
name|struct
name|continuation_arg
modifier|*
parameter_list|)
parameter_list|,
name|struct
name|continuation_arg
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|do_all_continuations
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|discard_all_continuations
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|add_intermediate_continuation
parameter_list|(
name|void
function_decl|(
modifier|*
function_decl|)
parameter_list|(
name|struct
name|continuation_arg
modifier|*
parameter_list|)
parameter_list|,
name|struct
name|continuation_arg
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|do_all_intermediate_continuations
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|discard_all_intermediate_continuations
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* String containing the current directory (what getwd would return).  */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|current_directory
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default radixes for input and output.  Only some values supported.  */
end_comment

begin_decl_stmt
specifier|extern
name|unsigned
name|input_radix
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|unsigned
name|output_radix
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Possibilities for prettyprint parameters to routines which print    things.  Like enum language, this should be in value.h, but needs    to be here for the same reason.  FIXME:  If we can eliminate this    as an arg to LA_VAL_PRINT, then we can probably move it back to    value.h. */
end_comment

begin_enum
enum|enum
name|val_prettyprint
block|{
name|Val_no_prettyprint
init|=
literal|0
block|,
name|Val_prettyprint
block|,
comment|/* Use the default setting which the user has specified.  */
name|Val_pretty_default
block|}
enum|;
end_enum

begin_comment
comment|/* The ptid struct is a collection of the various "ids" necessary    for identifying the inferior.  This consists of the process id    (pid), thread id (tid), and other fields necessary for uniquely    identifying the inferior process/thread being debugged.  When    manipulating ptids, the constructors, accessors, and predicate    declared in inferior.h should be used.  These are as follows:        ptid_build	- Make a new ptid from a pid, lwp, and tid.       pid_to_ptid	- Make a new ptid from just a pid.       ptid_get_pid	- Fetch the pid component of a ptid.       ptid_get_lwp	- Fetch the lwp component of a ptid.       ptid_get_tid	- Fetch the tid component of a ptid.       ptid_equal	- Test to see if two ptids are equal.     Please do NOT access the struct ptid members directly (except, of    course, in the implementation of the above ptid manipulation    functions).  */
end_comment

begin_struct
struct|struct
name|ptid
block|{
comment|/* Process id */
name|int
name|pid
decl_stmt|;
comment|/* Lightweight process id */
name|long
name|lwp
decl_stmt|;
comment|/* Thread id */
name|long
name|tid
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|ptid
name|ptid_t
typedef|;
end_typedef

begin_escape
end_escape

begin_comment
comment|/* Optional host machine definition.  Pure autoconf targets will not    need a "xm.h" file.  This will be a symlink to one of the xm-*.h    files, built by the `configure' script.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|GDB_XM_FILE
end_ifdef

begin_include
include|#
directive|include
file|"xm.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Optional native machine support.  Non-native (and possibly pure    multi-arch) targets do not need a "nm.h" file.  This will be a    symlink to one of the nm-*.h files, built by the `configure'    script.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|GDB_NM_FILE
end_ifdef

begin_include
include|#
directive|include
file|"nm.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Optional target machine definition.  Pure multi-arch configurations    do not need a "tm.h" file.  This will be a symlink to one of the    tm-*.h files, built by the `configure' script.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|GDB_TM_FILE
end_ifdef

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* GDB_MULTI_ARCH is normally set by configure.in using information    from configure.tgt or the config/%/%.mt Makefile fragment.  Since    some targets have defined it in their "tm.h" file, delay providing    a default definition until after "tm.h" has been included.. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|GDB_MULTI_ARCH
end_ifndef

begin_define
define|#
directive|define
name|GDB_MULTI_ARCH
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* If the xm.h file did not define the mode string used to open the    files, assume that binary files are opened the same way as text    files */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|FOPEN_RB
end_ifndef

begin_include
include|#
directive|include
file|"fopen-same.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Defaults for system-wide constants (if not defined by xm.h, we fake it).    FIXME: Assumes 2's complement arithmetic */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|UINT_MAX
argument_list|)
end_if

begin_define
define|#
directive|define
name|UINT_MAX
value|((unsigned int)(~0))
end_define

begin_comment
comment|/* 0xFFFFFFFF for 32-bits */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|INT_MAX
argument_list|)
end_if

begin_define
define|#
directive|define
name|INT_MAX
value|((int)(UINT_MAX>> 1))
end_define

begin_comment
comment|/* 0x7FFFFFFF for 32-bits */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|INT_MIN
argument_list|)
end_if

begin_define
define|#
directive|define
name|INT_MIN
value|((int)((int) ~0 ^ INT_MAX))
end_define

begin_comment
comment|/* 0x80000000 for 32-bits */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|ULONG_MAX
argument_list|)
end_if

begin_define
define|#
directive|define
name|ULONG_MAX
value|((unsigned long)(~0L))
end_define

begin_comment
comment|/* 0xFFFFFFFF for 32-bits */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|LONG_MAX
argument_list|)
end_if

begin_define
define|#
directive|define
name|LONG_MAX
value|((long)(ULONG_MAX>> 1))
end_define

begin_comment
comment|/* 0x7FFFFFFF for 32-bits */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|ULONGEST_MAX
argument_list|)
end_if

begin_define
define|#
directive|define
name|ULONGEST_MAX
value|(~(ULONGEST)0)
end_define

begin_comment
comment|/* 0xFFFFFFFFFFFFFFFF for 64-bits */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|LONGEST_MAX
argument_list|)
end_if

begin_comment
comment|/* 0x7FFFFFFFFFFFFFFF for 64-bits */
end_comment

begin_define
define|#
directive|define
name|LONGEST_MAX
value|((LONGEST)(ULONGEST_MAX>> 1))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Convert a LONGEST to an int.  This is used in contexts (e.g. number of    arguments to a function, number in a value history, register number, etc.)    where the value must not be larger than can fit in an int.  */
end_comment

begin_function_decl
specifier|extern
name|int
name|longest_to_int
parameter_list|(
name|LONGEST
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Assorted functions we can declare, now that const and volatile are     defined.  */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|savestring
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|msavestring
parameter_list|(
name|void
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|mstrsave
parameter_list|(
name|void
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Robust versions of same.  Throw an internal error when no memory,    guard against stray NULL arguments. */
end_comment

begin_function_decl
specifier|extern
name|void
modifier|*
name|xmmalloc
parameter_list|(
name|void
modifier|*
name|md
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
modifier|*
name|xmrealloc
parameter_list|(
name|void
modifier|*
name|md
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
modifier|*
name|xmcalloc
parameter_list|(
name|void
modifier|*
name|md
parameter_list|,
name|size_t
name|number
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|xmfree
parameter_list|(
name|void
modifier|*
name|md
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* xmalloc(), xrealloc() and xcalloc() have already been declared in    "libiberty.h". */
end_comment

begin_function_decl
specifier|extern
name|void
name|xfree
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Like asprintf/vasprintf but get an internal_error if the call    fails. */
end_comment

begin_function_decl
specifier|extern
name|void
name|xasprintf
parameter_list|(
name|char
modifier|*
modifier|*
name|ret
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
function_decl|ATTR_FORMAT
parameter_list|(
name|printf
parameter_list|,
function_decl|2
operator|,
function_decl|3
end_function_decl

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|extern
name|void
name|xvasprintf
parameter_list|(
name|char
modifier|*
modifier|*
name|ret
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|va_list
name|ap
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|parse_escape
parameter_list|(
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Message to be printed before the error message, when an error occurs.  */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|error_pre_print
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Message to be printed before the error message, when an error occurs.  */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|quit_pre_print
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Message to be printed before the warning message, when a warning occurs.  */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|warning_pre_print
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|NORETURN
name|void
name|verror
argument_list|(
specifier|const
name|char
operator|*
name|fmt
argument_list|,
name|va_list
name|ap
argument_list|)
name|ATTR_NORETURN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|NORETURN
name|void
name|error
argument_list|(
specifier|const
name|char
operator|*
name|fmt
argument_list|,
operator|...
argument_list|)
name|ATTR_NORETURN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|NORETURN
name|void
name|error_stream
argument_list|(
expr|struct
name|ui_file
operator|*
argument_list|)
name|ATTR_NORETURN
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Returns a freshly allocate buffer containing the last error    message.  */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|error_last_message
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|NORETURN
name|void
name|internal_verror
argument_list|(
specifier|const
name|char
operator|*
name|file
argument_list|,
name|int
name|line
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|va_list
name|ap
argument_list|)
name|ATTR_NORETURN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|NORETURN
name|void
name|internal_error
argument_list|(
specifier|const
name|char
operator|*
name|file
argument_list|,
name|int
name|line
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
operator|...
argument_list|)
name|ATTR_NORETURN
name|ATTR_FORMAT
argument_list|(
name|printf
argument_list|,
literal|3
argument_list|,
literal|4
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|NORETURN
name|void
name|nomem
argument_list|(
name|long
argument_list|)
name|ATTR_NORETURN
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Reasons for calling throw_exception().  NOTE: all reason values    must be less than zero.  enum value 0 is reserved for internal use    as the return value from an initial setjmp().  The function    catch_exceptions() reserves values>= 0 as legal results from its    wrapped function.  */
end_comment

begin_enum
enum|enum
name|return_reason
block|{
comment|/* User interrupt.  */
name|RETURN_QUIT
init|=
operator|-
literal|2
block|,
comment|/* Any other error.  */
name|RETURN_ERROR
block|}
enum|;
end_enum

begin_define
define|#
directive|define
name|ALL_CLEANUPS
value|((struct cleanup *)0)
end_define

begin_define
define|#
directive|define
name|RETURN_MASK
parameter_list|(
name|reason
parameter_list|)
value|(1<< (int)(-reason))
end_define

begin_define
define|#
directive|define
name|RETURN_MASK_QUIT
value|RETURN_MASK (RETURN_QUIT)
end_define

begin_define
define|#
directive|define
name|RETURN_MASK_ERROR
value|RETURN_MASK (RETURN_ERROR)
end_define

begin_define
define|#
directive|define
name|RETURN_MASK_ALL
value|(RETURN_MASK_QUIT | RETURN_MASK_ERROR)
end_define

begin_typedef
typedef|typedef
name|int
name|return_mask
typedef|;
end_typedef

begin_comment
comment|/* Throw an exception of type RETURN_REASON.  Will execute a LONG JUMP    to the inner most containing exception handler established using    catch_exceptions() (or the legacy catch_errors()).     Code normally throws an exception using error() et.al.  For various    reaons, GDB also contains code that throws an exception directly.    For instance, the remote*.c targets contain CNTRL-C signal handlers    that propogate the QUIT event up the exception chain.  ``This could    be a good thing or a dangerous thing.'' -- the Existential Wombat.  */
end_comment

begin_decl_stmt
specifier|extern
name|NORETURN
name|void
name|throw_exception
argument_list|(
expr|enum
name|return_reason
argument_list|)
name|ATTR_NORETURN
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Call FUNC(UIOUT, FUNC_ARGS) but wrapped within an exception    handler.  If an exception (enum return_reason) is thrown using    throw_exception() than all cleanups installed since    catch_exceptions() was entered are invoked, the (-ve) exception    value is then returned by catch_exceptions.  If FUNC() returns    normally (with a postive or zero return value) then that value is    returned by catch_exceptions().  It is an internal_error() for    FUNC() to return a negative value.     For the period of the FUNC() call: UIOUT is installed as the output    builder; ERRSTRING is installed as the error/quit message; and a    new cleanup_chain is established.  The old values are restored    before catch_exceptions() returns.     FIXME; cagney/2001-08-13: The need to override the global UIOUT    builder variable should just go away.     This function superseeds catch_errors().     This function uses SETJMP() and LONGJUMP().  */
end_comment

begin_struct_decl
struct_decl|struct
name|ui_out
struct_decl|;
end_struct_decl

begin_typedef
typedef|typedef
name|int
function_decl|(
name|catch_exceptions_ftype
function_decl|)
parameter_list|(
name|struct
name|ui_out
modifier|*
name|ui_out
parameter_list|,
name|void
modifier|*
name|args
parameter_list|)
function_decl|;
end_typedef

begin_function_decl
specifier|extern
name|int
name|catch_exceptions
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
name|catch_exceptions_ftype
modifier|*
name|func
parameter_list|,
name|void
modifier|*
name|func_args
parameter_list|,
name|char
modifier|*
name|errstring
parameter_list|,
name|return_mask
name|mask
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* If CATCH_ERRORS_FTYPE throws an error, catch_errors() returns zero    otherwize the result from CATCH_ERRORS_FTYPE is returned. It is    probably useful for CATCH_ERRORS_FTYPE to always return a non-zero    value. It's unfortunate that, catch_errors() does not return an    indication of the exact exception that it caught - quit_flag might    help.     This function is superseeded by catch_exceptions().  */
end_comment

begin_typedef
typedef|typedef
name|int
function_decl|(
name|catch_errors_ftype
function_decl|)
parameter_list|(
name|PTR
parameter_list|)
function_decl|;
end_typedef

begin_function_decl
specifier|extern
name|int
name|catch_errors
parameter_list|(
name|catch_errors_ftype
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|return_mask
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Template to catch_errors() that wraps calls to command    functions. */
end_comment

begin_typedef
typedef|typedef
name|void
function_decl|(
name|catch_command_errors_ftype
function_decl|)
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_typedef

begin_function_decl
specifier|extern
name|int
name|catch_command_errors
parameter_list|(
name|catch_command_errors_ftype
modifier|*
name|func
parameter_list|,
name|char
modifier|*
name|command
parameter_list|,
name|int
name|from_tty
parameter_list|,
name|return_mask
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|warning
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
function_decl|ATTR_FORMAT
parameter_list|(
name|printf
parameter_list|,
function_decl|1
operator|,
function_decl|2
end_function_decl

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|extern
name|void
name|vwarning
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|va_list
name|args
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Global functions from other, non-gdb GNU thingies.    Libiberty thingies are no longer declared here.  We include libiberty.h    above, instead.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|GETENV_PROVIDED
end_ifndef

begin_function_decl
specifier|extern
name|char
modifier|*
name|getenv
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* From other system libraries */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STDDEF_H
end_ifdef

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STDLIB_H
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|min
end_ifndef

begin_define
define|#
directive|define
name|min
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)< (b) ? (a) : (b))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|max
end_ifndef

begin_define
define|#
directive|define
name|max
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)> (b) ? (a) : (b))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* We take the address of fclose later, but some stdio's forget    to declare this.  We can't always declare it since there's    no way to declare the parameters without upsetting some compiler    somewhere. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|FCLOSE_PROVIDED
end_ifndef

begin_function_decl
specifier|extern
name|int
name|fclose
parameter_list|(
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|atof
end_ifndef

begin_function_decl
specifier|extern
name|double
name|atof
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* X3.159-1989  4.10.1.1 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Various possibilities for alloca.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|alloca
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_define
define|#
directive|define
name|alloca
value|__builtin_alloca
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Not GNU C */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ALLOCA_H
end_ifdef

begin_include
include|#
directive|include
file|<alloca.h>
end_include

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|_AIX
end_ifdef

begin_pragma
pragma|#
directive|pragma
name|alloca
end_pragma

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* We need to be careful not to declare this in a way which conflicts with    bison.  Bison never declares it as char *, but under various circumstances    (like __hpux) we need to use void *.  */
end_comment

begin_function_decl
specifier|extern
name|void
modifier|*
name|alloca
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Not _AIX */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Not HAVE_ALLOCA_H */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Not GNU C */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* alloca not defined */
end_comment

begin_comment
comment|/* Dynamic target-system-dependent parameters for GDB. */
end_comment

begin_include
include|#
directive|include
file|"gdbarch.h"
end_include

begin_if
if|#
directive|if
operator|(
name|GDB_MULTI_ARCH
operator|==
literal|0
operator|)
end_if

begin_comment
comment|/* Multi-arch targets _should_ be including "arch-utils.h" directly    into their *-tdep.c file.  This is a prop to help old non-    multi-arch targets to continue to compile. */
end_comment

begin_include
include|#
directive|include
file|"arch-utils.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Static target-system-dependent parameters for GDB. */
end_comment

begin_comment
comment|/* Number of bits in a char or unsigned char for the target machine.    Just like CHAR_BIT in<limits.h> but describes the target machine.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|TARGET_CHAR_BIT
argument_list|)
end_if

begin_define
define|#
directive|define
name|TARGET_CHAR_BIT
value|8
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* If we picked up a copy of CHAR_BIT from a configuration file    (which may get it by including<limits.h>) then use it to set    the number of bits in a host char.  If not, use the same size    as the target. */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CHAR_BIT
argument_list|)
end_if

begin_define
define|#
directive|define
name|HOST_CHAR_BIT
value|CHAR_BIT
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|HOST_CHAR_BIT
value|TARGET_CHAR_BIT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The bit byte-order has to do just with numbering of bits in    debugging symbols and such.  Conceptually, it's quite separate    from byte/word byte order.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|BITS_BIG_ENDIAN
argument_list|)
end_if

begin_define
define|#
directive|define
name|BITS_BIG_ENDIAN
value|(TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* In findvar.c.  */
end_comment

begin_function_decl
specifier|extern
name|LONGEST
name|extract_signed_integer
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|ULONGEST
name|extract_unsigned_integer
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|extract_long_unsigned_integer
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|LONGEST
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|CORE_ADDR
name|extract_address
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|CORE_ADDR
name|extract_typed_address
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|store_signed_integer
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|LONGEST
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|store_unsigned_integer
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|ULONGEST
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|store_address
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|LONGEST
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|store_typed_address
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|CORE_ADDR
name|addr
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* From valops.c */
end_comment

begin_function_decl
specifier|extern
name|CORE_ADDR
name|push_bytes
parameter_list|(
name|CORE_ADDR
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|CORE_ADDR
name|push_word
parameter_list|(
name|CORE_ADDR
parameter_list|,
name|ULONGEST
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|int
name|watchdog
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Hooks for alternate command interfaces.  */
end_comment

begin_comment
comment|/* The name of the interpreter if specified on the command line. */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|interpreter_p
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If a given interpreter matches INTERPRETER_P then it should update    command_loop_hook and init_ui_hook with the per-interpreter    implementation. */
end_comment

begin_comment
comment|/* FIXME: command_loop_hook and init_ui_hook should be moved here. */
end_comment

begin_struct_decl
struct_decl|struct
name|target_waitstatus
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|cmd_list_element
struct_decl|;
end_struct_decl

begin_comment
comment|/* Should the asynchronous variant of the interpreter (using the    event-loop) be enabled? */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|event_loop_p
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|void
function_decl|(
modifier|*
name|init_ui_hook
function_decl|)
parameter_list|(
name|char
modifier|*
name|argv0
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
function_decl|(
modifier|*
name|command_loop_hook
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
function_decl|(
modifier|*
name|show_load_progress
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
name|section
parameter_list|,
name|unsigned
name|long
name|section_sent
parameter_list|,
name|unsigned
name|long
name|section_size
parameter_list|,
name|unsigned
name|long
name|total_sent
parameter_list|,
name|unsigned
name|long
name|total_size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
function_decl|(
modifier|*
name|print_frame_info_listing_hook
function_decl|)
parameter_list|(
name|struct
name|symtab
modifier|*
name|s
parameter_list|,
name|int
name|line
parameter_list|,
name|int
name|stopline
parameter_list|,
name|int
name|noerror
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|struct
name|frame_info
modifier|*
name|parse_frame_specification
parameter_list|(
name|char
modifier|*
name|frame_exp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
function_decl|(
modifier|*
name|query_hook
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|va_list
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
function_decl|(
modifier|*
name|warning_hook
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|va_list
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
function_decl|(
modifier|*
name|flush_hook
function_decl|)
parameter_list|(
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
function_decl|(
modifier|*
name|create_breakpoint_hook
function_decl|)
parameter_list|(
name|struct
name|breakpoint
modifier|*
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
function_decl|(
modifier|*
name|delete_breakpoint_hook
function_decl|)
parameter_list|(
name|struct
name|breakpoint
modifier|*
name|bpt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
function_decl|(
modifier|*
name|modify_breakpoint_hook
function_decl|)
parameter_list|(
name|struct
name|breakpoint
modifier|*
name|bpt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
function_decl|(
modifier|*
name|interactive_hook
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
function_decl|(
modifier|*
name|registers_changed_hook
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
function_decl|(
modifier|*
name|readline_begin_hook
function_decl|)
parameter_list|(
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
function_decl|(
modifier|*
name|readline_hook
function_decl|)
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
function_decl|(
modifier|*
name|readline_end_hook
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
function_decl|(
modifier|*
name|register_changed_hook
function_decl|)
parameter_list|(
name|int
name|regno
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
function_decl|(
modifier|*
name|memory_changed_hook
function_decl|)
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
function_decl|(
modifier|*
name|context_hook
function_decl|)
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|ptid_t
function_decl|(
modifier|*
name|target_wait_hook
function_decl|)
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
name|struct
name|target_waitstatus
modifier|*
name|status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
function_decl|(
modifier|*
name|attach_hook
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
function_decl|(
modifier|*
name|detach_hook
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
function_decl|(
modifier|*
name|call_command_hook
function_decl|)
parameter_list|(
name|struct
name|cmd_list_element
modifier|*
name|c
parameter_list|,
name|char
modifier|*
name|cmd
parameter_list|,
name|int
name|from_tty
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
function_decl|(
modifier|*
name|set_hook
function_decl|)
parameter_list|(
name|struct
name|cmd_list_element
modifier|*
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|NORETURN
name|void
argument_list|(
operator|*
name|error_hook
argument_list|)
argument_list|(
name|void
argument_list|)
name|ATTR_NORETURN
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|void
function_decl|(
modifier|*
name|error_begin_hook
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
function_decl|(
modifier|*
name|ui_load_progress_hook
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
name|section
parameter_list|,
name|unsigned
name|long
name|num
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Inhibit window interface if non-zero. */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|use_windows
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Symbolic definitions of filename-related things.  */
end_comment

begin_comment
comment|/* FIXME, this doesn't work very well if host and executable    filesystems conventions are different.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DIRNAME_SEPARATOR
end_ifndef

begin_define
define|#
directive|define
name|DIRNAME_SEPARATOR
value|':'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SLASH_STRING
end_ifndef

begin_define
define|#
directive|define
name|SLASH_STRING
value|"/"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__MSDOS__
end_ifdef

begin_define
define|#
directive|define
name|CANT_FORK
end_define

begin_define
define|#
directive|define
name|GLOBAL_CURDIR
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Provide default definitions of PIDGET, TIDGET, and MERGEPID.    The name ``TIDGET'' is a historical accident.  Many uses of TIDGET    in the code actually refer to a lightweight process id, i.e,    something that can be considered a process id in its own right for    certain purposes.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PIDGET
end_ifndef

begin_define
define|#
directive|define
name|PIDGET
parameter_list|(
name|PTID
parameter_list|)
value|(ptid_get_pid (PTID))
end_define

begin_define
define|#
directive|define
name|TIDGET
parameter_list|(
name|PTID
parameter_list|)
value|(ptid_get_lwp (PTID))
end_define

begin_define
define|#
directive|define
name|MERGEPID
parameter_list|(
name|PID
parameter_list|,
name|TID
parameter_list|)
value|ptid_build (PID, TID, 0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Define well known filenos if the system does not define them.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|STDIN_FILENO
end_ifndef

begin_define
define|#
directive|define
name|STDIN_FILENO
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|STDOUT_FILENO
end_ifndef

begin_define
define|#
directive|define
name|STDOUT_FILENO
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|STDERR_FILENO
end_ifndef

begin_define
define|#
directive|define
name|STDERR_FILENO
value|2
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* If this definition isn't overridden by the header files, assume    that isatty and fileno exist on this system.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ISATTY
end_ifndef

begin_define
define|#
directive|define
name|ISATTY
parameter_list|(
name|FP
parameter_list|)
value|(isatty (fileno (FP)))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* #ifndef DEFS_H */
end_comment

end_unit

