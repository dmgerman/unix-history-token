begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Basic, host-specific, and target-specific definitions for GDB.    Copyright (C) 1986, 1989, 1991, 1992, 1993, 1994, 1995, 1996    Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DEFS_H
end_ifndef

begin_define
define|#
directive|define
name|DEFS_H
end_define

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_comment
comment|/* Generated by configure */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_comment
comment|/* System call error return status */
end_comment

begin_comment
comment|/* Just in case they're not defined in stdio.h. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SEEK_SET
end_ifndef

begin_define
define|#
directive|define
name|SEEK_SET
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SEEK_CUR
end_ifndef

begin_define
define|#
directive|define
name|SEEK_CUR
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* First include ansidecl.h so we can use the various macro definitions    here and in all subsequent file inclusions.  */
end_comment

begin_include
include|#
directive|include
file|"ansidecl.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|ANSI_PROTOTYPES
end_ifdef

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_comment
comment|/* libiberty.h can't declare this one, but evidently we can.  */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|strsignal
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|"progress.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|NO_MMALLOC
end_ifndef

begin_include
include|#
directive|include
file|"mmalloc.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* For BFD64 and bfd_vma.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_comment
comment|/* An address in the program being debugged.  Host byte order.  Rather    than duplicate all the logic in BFD which figures out what type    this is (long, long long, etc.) and whether it needs to be 64    bits (the host/target interactions are subtle), we just use    bfd_vma.  */
end_comment

begin_typedef
typedef|typedef
name|bfd_vma
name|CORE_ADDR
typedef|;
end_typedef

begin_define
define|#
directive|define
name|min
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)< (b) ? (a) : (b))
end_define

begin_define
define|#
directive|define
name|max
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)> (b) ? (a) : (b))
end_define

begin_comment
comment|/* Gdb does *lots* of string compares.  Use macros to speed them up by    avoiding function calls if the first characters are not the same. */
end_comment

begin_define
define|#
directive|define
name|STRCMP
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(*(a) == *(b) ? strcmp ((a), (b)) : (int)*(a) - (int)*(b))
end_define

begin_define
define|#
directive|define
name|STREQ
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(*(a) == *(b) ? !strcmp ((a), (b)) : 0)
end_define

begin_define
define|#
directive|define
name|STREQN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|(*(a) == *(b) ? !strncmp ((a), (b), (c)) : 0)
end_define

begin_comment
comment|/* The character GNU C++ uses to build identifiers that must be unique from    the program's identifiers (such as $this and $$vptr).  */
end_comment

begin_define
define|#
directive|define
name|CPLUS_MARKER
value|'$'
end_define

begin_comment
comment|/* May be overridden to '.' for SysV */
end_comment

begin_comment
comment|/* Check if a character is one of the commonly used C++ marker characters.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|is_cplus_marker
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|quit_flag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|immediate_quit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|sevenbit_strings
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|quit
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|QUIT
value|{ \   if (quit_flag) quit (); \   if (interactive_hook) interactive_hook (); \   PROGRESS (1); \ }
end_define

begin_comment
comment|/* Command classes are top-level categories into which commands are broken    down for "help" purposes.      Notes on classes: class_alias is for alias commands which are not    abbreviations of the original command.  class-pseudo is for commands    which are not really commands nor help topics ("stop").  */
end_comment

begin_enum
enum|enum
name|command_class
block|{
comment|/* Special args to help_list */
name|all_classes
init|=
operator|-
literal|2
block|,
name|all_commands
init|=
operator|-
literal|1
block|,
comment|/* Classes of commands */
name|no_class
init|=
operator|-
literal|1
block|,
name|class_run
init|=
literal|0
block|,
name|class_vars
block|,
name|class_stack
block|,
name|class_files
block|,
name|class_support
block|,
name|class_info
block|,
name|class_breakpoint
block|,
name|class_alias
block|,
name|class_obscure
block|,
name|class_user
block|,
name|class_maintenance
block|,
name|class_pseudo
block|}
enum|;
end_enum

begin_comment
comment|/* Languages represented in the symbol table and elsewhere.    This should probably be in language.h, but since enum's can't    be forward declared to satisfy opaque references before their    actual definition, needs to be here. */
end_comment

begin_enum
enum|enum
name|language
block|{
name|language_unknown
block|,
comment|/* Language not known */
name|language_auto
block|,
comment|/* Placeholder for automatic setting */
name|language_c
block|,
comment|/* C */
name|language_cplus
block|,
comment|/* C++ */
name|language_chill
block|,
comment|/* Chill */
name|language_fortran
block|,
comment|/* Fortran */
name|language_m2
block|,
comment|/* Modula-2 */
name|language_asm
block|,
comment|/* Assembly language */
name|language_scm
comment|/* Scheme / Guile */
block|}
enum|;
end_enum

begin_comment
comment|/* the cleanup list records things that have to be undone    if an error happens (descriptors to be closed, memory to be freed, etc.)    Each link in the chain records a function to call and an    argument to give it.     Use make_cleanup to add an element to the cleanup chain.    Use do_cleanups to do all cleanup actions back to a given    point in the chain.  Use discard_cleanups to remove cleanups    from the chain back to a given point, not doing them.  */
end_comment

begin_struct
struct|struct
name|cleanup
block|{
name|struct
name|cleanup
modifier|*
name|next
decl_stmt|;
name|void
argument_list|(
argument|*function
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|)
argument_list|)
expr_stmt|;
name|PTR
name|arg
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The ability to declare that a function never returns is useful, but    not really required to compile GDB successfully, so the NORETURN and    ATTR_NORETURN macros normally expand into nothing.  */
end_comment

begin_comment
comment|/* If compiling with older versions of GCC, a function may be declared    "volatile" to indicate that it does not return.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NORETURN
end_ifndef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
expr|\
operator|&&
operator|(
name|__GNUC__
operator|==
literal|1
operator|||
operator|(
name|__GNUC__
operator|==
literal|2
operator|&&
name|__GNUC_MINOR__
operator|<
literal|7
operator|)
operator|)
end_if

begin_define
define|#
directive|define
name|NORETURN
value|volatile
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|NORETURN
end_define

begin_comment
comment|/* nothing */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* GCC 2.5 and later versions define a function attribute "noreturn",    which is the preferred way to declare that a function never returns.    However GCC 2.7 appears to be the first version in which this fully    works everywhere we use it. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ATTR_NORETURN
end_ifndef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
name|__GNUC__
operator|>=
literal|2
operator|&&
name|__GNUC_MINOR__
operator|>=
literal|7
end_if

begin_define
define|#
directive|define
name|ATTR_NORETURN
value|__attribute__ ((noreturn))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ATTR_NORETURN
end_define

begin_comment
comment|/* nothing */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ATTR_FORMAT
end_ifndef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
name|__GNUC__
operator|>=
literal|2
operator|&&
name|__GNUC_MINOR__
operator|>=
literal|4
operator|&&
name|defined
argument_list|(
name|__ANSI_PROTOTYPES
argument_list|)
end_if

begin_define
define|#
directive|define
name|ATTR_FORMAT
parameter_list|(
name|type
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|)
value|__attribute__ ((format(type, x, y)))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ATTR_FORMAT
parameter_list|(
name|type
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|)
end_define

begin_comment
comment|/* nothing */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Needed for various prototypes */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_struct_decl
struct_decl|struct
name|symtab
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|breakpoint
struct_decl|;
end_struct_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* From blockframe.c */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|inside_entry_func
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|inside_entry_file
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
name|addr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|inside_main_func
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
name|pc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* From ch-lang.c, for the moment. (FIXME) */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|chill_demangle
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* From utils.c */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|strcmp_iw
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|safe_strerror
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|safe_strsignal
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|init_malloc
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|request_quit
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|do_cleanups
name|PARAMS
argument_list|(
operator|(
expr|struct
name|cleanup
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|discard_cleanups
name|PARAMS
argument_list|(
operator|(
expr|struct
name|cleanup
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The bare make_cleanup function is one of those rare beasts that    takes almost any type of function as the first arg and anything that    will fit in a "void *" as the second arg.     Should be, once all calls and called-functions are cleaned up: extern struct cleanup * make_cleanup PARAMS ((void (*function) (void *), void *));     Until then, lint and/or various type-checking compiler options will    complain about make_cleanup calls.  It'd be wrong to just cast things,    since the type actually passed when the function is called would be    wrong.  */
end_comment

begin_function_decl
specifier|extern
name|struct
name|cleanup
modifier|*
name|make_cleanup
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|struct
name|cleanup
modifier|*
name|save_cleanups
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|restore_cleanups
name|PARAMS
argument_list|(
operator|(
expr|struct
name|cleanup
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|free_current_contents
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|null_cleanup
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|myread
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|query
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
name|ATTR_FORMAT
argument_list|(
name|printf
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Annotation stuff.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|annotation_level
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* in stack.c */
end_comment

begin_escape
end_escape

begin_decl_stmt
specifier|extern
name|void
name|begin_line
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|wrap_here
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|reinitialize_more_filter
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
name|FILE
name|GDB_FILE
typedef|;
end_typedef

begin_define
define|#
directive|define
name|gdb_stdout
value|stdout
end_define

begin_define
define|#
directive|define
name|gdb_stderr
value|stderr
end_define

begin_decl_stmt
specifier|extern
name|void
name|gdb_flush
name|PARAMS
argument_list|(
operator|(
name|GDB_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|GDB_FILE
modifier|*
name|gdb_fopen
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|name
operator|,
name|char
operator|*
name|mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|fputs_filtered
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|GDB_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|fputs_unfiltered
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|GDB_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|fputc_unfiltered
name|PARAMS
argument_list|(
operator|(
name|int
name|c
operator|,
name|GDB_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|putchar_unfiltered
name|PARAMS
argument_list|(
operator|(
name|int
name|c
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|puts_filtered
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|puts_unfiltered
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|vprintf_filtered
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|va_list
operator|)
argument_list|)
name|ATTR_FORMAT
argument_list|(
name|printf
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|vfprintf_filtered
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|va_list
operator|)
argument_list|)
name|ATTR_FORMAT
argument_list|(
name|printf
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|fprintf_filtered
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
name|ATTR_FORMAT
argument_list|(
name|printf
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|fprintfi_filtered
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|FILE
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
name|ATTR_FORMAT
argument_list|(
name|printf
argument_list|,
literal|3
argument_list|,
literal|4
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|printf_filtered
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
name|ATTR_FORMAT
argument_list|(
name|printf
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|printfi_filtered
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
specifier|const
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
name|ATTR_FORMAT
argument_list|(
name|printf
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|vprintf_unfiltered
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|va_list
operator|)
argument_list|)
name|ATTR_FORMAT
argument_list|(
name|printf
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|vfprintf_unfiltered
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|va_list
operator|)
argument_list|)
name|ATTR_FORMAT
argument_list|(
name|printf
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|fprintf_unfiltered
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
name|ATTR_FORMAT
argument_list|(
name|printf
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|printf_unfiltered
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
name|ATTR_FORMAT
argument_list|(
name|printf
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|print_spaces
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|GDB_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|print_spaces_filtered
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|GDB_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|n_spaces
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|gdb_printchar
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|GDB_FILE
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|gdb_print_address
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|,
name|GDB_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|fprintf_symbol_filtered
name|PARAMS
argument_list|(
operator|(
name|GDB_FILE
operator|*
operator|,
name|char
operator|*
operator|,
expr|enum
name|language
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|perror_with_name
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|print_sys_errmsg
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* From regex.c or libc.  BSD 4.4 declares this with the argument type as    "const char *" in unistd.h, so we can't declare the argument    as "char *".  */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|re_comp
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* From symfile.c */
end_comment

begin_decl_stmt
specifier|extern
name|void
name|symbol_file_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* From top.c */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|skip_quoted
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|gdb_readline
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|command_line_input
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|print_prompt
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|input_from_terminal_p
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|info_verbose
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* From printcmd.c */
end_comment

begin_decl_stmt
specifier|extern
name|void
name|set_next_address
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|print_address_symbolic
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
operator|,
name|GDB_FILE
operator|*
operator|,
name|int
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|print_address_numeric
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
operator|,
name|int
operator|,
name|GDB_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|print_address
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
operator|,
name|GDB_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* From source.c */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|openp
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|mod_path
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|directory_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|init_source_path
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|symtab_to_filename
name|PARAMS
argument_list|(
operator|(
expr|struct
name|symtab
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* From findvar.c */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|read_relative_register_raw_bytes
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* From readline (but not in any readline .h files).  */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|tilde_expand
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Control types for commands */
end_comment

begin_enum
enum|enum
name|misc_command_type
block|{
name|ok_command
block|,
name|end_command
block|,
name|else_command
block|,
name|nop_command
block|}
enum|;
end_enum

begin_enum
enum|enum
name|command_control_type
block|{
name|simple_control
block|,
name|break_control
block|,
name|continue_control
block|,
name|while_control
block|,
name|if_control
block|,
name|invalid_control
block|}
enum|;
end_enum

begin_comment
comment|/* Structure for saved commands lines    (for breakpoints, defined commands, etc).  */
end_comment

begin_struct
struct|struct
name|command_line
block|{
name|struct
name|command_line
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|;
name|enum
name|command_control_type
name|control_type
decl_stmt|;
name|int
name|body_count
decl_stmt|;
name|struct
name|command_line
modifier|*
modifier|*
name|body_list
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|extern
name|struct
name|command_line
modifier|*
name|read_command_lines
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|free_command_lines
name|PARAMS
argument_list|(
operator|(
expr|struct
name|command_line
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* String containing the current directory (what getwd would return).  */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|current_directory
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default radixes for input and output.  Only some values supported.  */
end_comment

begin_decl_stmt
specifier|extern
name|unsigned
name|input_radix
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|unsigned
name|output_radix
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Possibilities for prettyprint parameters to routines which print    things.  Like enum language, this should be in value.h, but needs    to be here for the same reason.  FIXME:  If we can eliminate this    as an arg to LA_VAL_PRINT, then we can probably move it back to    value.h. */
end_comment

begin_enum
enum|enum
name|val_prettyprint
block|{
name|Val_no_prettyprint
init|=
literal|0
block|,
name|Val_prettyprint
block|,
comment|/* Use the default setting which the user has specified.  */
name|Val_pretty_default
block|}
enum|;
end_enum

begin_escape
end_escape

begin_comment
comment|/* Host machine definition.  This will be a symlink to one of the    xm-*.h files, built by the `configure' script.  */
end_comment

begin_include
include|#
directive|include
file|"xm.h"
end_include

begin_comment
comment|/* Native machine support.  This will be a symlink to one of the    nm-*.h files, built by the `configure' script.  */
end_comment

begin_include
include|#
directive|include
file|"nm.h"
end_include

begin_comment
comment|/* Target machine definition.  This will be a symlink to one of the    tm-*.h files, built by the `configure' script.  */
end_comment

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_comment
comment|/* If the xm.h file did not define the mode string used to open the    files, assume that binary files are opened the same way as text    files */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|FOPEN_RB
end_ifndef

begin_include
include|#
directive|include
file|"fopen-same.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Allow things in gdb to be declared "const".  If compiling ANSI, it  * just works.  If compiling with gcc but non-ansi, redefine to __const__.  * If non-ansi, non-gcc, then eliminate "const" entirely, making those  * objects be read-write rather than read-only.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|const
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|__STDC__
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_define
define|#
directive|define
name|const
value|__const__
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|const
end_define

begin_comment
comment|/*nothing*/
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* GNUC */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* STDC */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* const */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|volatile
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|__STDC__
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_define
define|#
directive|define
name|volatile
value|__volatile__
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|volatile
end_define

begin_comment
comment|/*nothing*/
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* GNUC */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* STDC */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* volatile */
end_comment

begin_comment
comment|/* Defaults for system-wide constants (if not defined by xm.h, we fake it).  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|UINT_MAX
argument_list|)
end_if

begin_define
define|#
directive|define
name|UINT_MAX
value|((unsigned int)(~0))
end_define

begin_comment
comment|/* 0xFFFFFFFF for 32-bits */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|INT_MAX
argument_list|)
end_if

begin_define
define|#
directive|define
name|INT_MAX
value|((int)(UINT_MAX>> 1))
end_define

begin_comment
comment|/* 0x7FFFFFFF for 32-bits */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|INT_MIN
argument_list|)
end_if

begin_define
define|#
directive|define
name|INT_MIN
value|(-INT_MAX - 1)
end_define

begin_comment
comment|/* 0x80000000 for 32-bits */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|ULONG_MAX
argument_list|)
end_if

begin_define
define|#
directive|define
name|ULONG_MAX
value|((unsigned long)(~0L))
end_define

begin_comment
comment|/* 0xFFFFFFFF for 32-bits */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|LONG_MAX
argument_list|)
end_if

begin_define
define|#
directive|define
name|LONG_MAX
value|((long)(ULONG_MAX>> 1))
end_define

begin_comment
comment|/* 0x7FFFFFFF for 32-bits */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|BFD64
end_ifdef

begin_comment
comment|/* This is to make sure that LONGEST is at least as big as CORE_ADDR.  */
end_comment

begin_define
define|#
directive|define
name|LONGEST
value|BFD_HOST_64_BIT
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* No BFD64 */
end_comment

begin_comment
comment|/* If all compilers for this host support "long long" and we want to    use it for LONGEST (the performance hit is about 10% on a testsuite    run based on one DECstation test), then the xm.h file can define    CC_HAS_LONG_LONG.     Using GCC 1.39 on BSDI with long long causes about 700 new    testsuite failures.  Using long long for LONGEST on the DECstation    causes 3 new FAILs in the testsuite and many heuristic fencepost    warnings.  These are not investigated, but a first guess would be    that the BSDI problems are GCC bugs in long long support and the    latter are GDB bugs.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CC_HAS_LONG_LONG
end_ifndef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
name|defined
argument_list|(
name|FORCE_LONG_LONG
argument_list|)
end_if

begin_define
define|#
directive|define
name|CC_HAS_LONG_LONG
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LONGEST should not be a typedef, because "unsigned LONGEST" needs to work.    CC_HAS_LONG_LONG is defined if the host compiler supports "long long"    variables and we wish to make use of that support.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LONGEST
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|CC_HAS_LONG_LONG
end_ifdef

begin_define
define|#
directive|define
name|LONGEST
value|long long
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|LONGEST
value|long
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* No BFD64 */
end_comment

begin_comment
comment|/* Convert a LONGEST to an int.  This is used in contexts (e.g. number of    arguments to a function, number in a value history, register number, etc.)    where the value must not be larger than can fit in an int.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|longest_to_int
name|PARAMS
argument_list|(
operator|(
name|LONGEST
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Assorted functions we can declare, now that const and volatile are     defined.  */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|savestring
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|msavestring
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|strsave
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|mstrsave
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|PTR
name|xmmalloc
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|PTR
name|xmrealloc
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
name|PTR
operator|,
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|parse_escape
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|reg_names
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Message to be printed before the error message, when an error occurs.  */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|error_pre_print
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Message to be printed before the error message, when an error occurs.  */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|quit_pre_print
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Message to be printed before the warning message, when a warning occurs.  */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|warning_pre_print
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|NORETURN
name|void
name|error
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
name|ATTR_NORETURN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|error_begin
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|NORETURN
name|void
name|fatal
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
name|ATTR_NORETURN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|NORETURN
name|void
name|nomem
name|PARAMS
argument_list|(
operator|(
name|long
operator|)
argument_list|)
name|ATTR_NORETURN
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Reasons for calling return_to_top_level.  */
end_comment

begin_enum
enum|enum
name|return_reason
block|{
comment|/* User interrupt.  */
name|RETURN_QUIT
block|,
comment|/* Any other error.  */
name|RETURN_ERROR
block|}
enum|;
end_enum

begin_define
define|#
directive|define
name|RETURN_MASK_QUIT
value|(1<< (int)RETURN_QUIT)
end_define

begin_define
define|#
directive|define
name|RETURN_MASK_ERROR
value|(1<< (int)RETURN_ERROR)
end_define

begin_define
define|#
directive|define
name|RETURN_MASK_ALL
value|(RETURN_MASK_QUIT | RETURN_MASK_ERROR)
end_define

begin_typedef
typedef|typedef
name|int
name|return_mask
typedef|;
end_typedef

begin_decl_stmt
specifier|extern
name|NORETURN
name|void
name|return_to_top_level
name|PARAMS
argument_list|(
operator|(
expr|enum
name|return_reason
operator|)
argument_list|)
name|ATTR_NORETURN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|catch_errors
name|PARAMS
argument_list|(
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
name|char
operator|*
argument_list|)
operator|,
name|void
operator|*
operator|,
name|char
operator|*
operator|,
name|return_mask
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|warning_begin
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|warning
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
name|ATTR_FORMAT
argument_list|(
name|printf
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Global functions from other, non-gdb GNU thingies.    Libiberty thingies are no longer declared here.  We include libiberty.h    above, instead.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|GETENV_PROVIDED
end_ifndef

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|getenv
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* From other system libraries */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* We take the address of fclose later, but some stdio's forget    to declare this.  We can't always declare it since there's    no way to declare the parameters without upsetting some compiler    somewhere. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|FCLOSE_PROVIDED
end_ifndef

begin_function_decl
specifier|extern
name|int
name|fclose
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|atof
end_ifndef

begin_function_decl
specifier|extern
name|double
name|atof
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MALLOC_INCOMPATIBLE
end_ifndef

begin_function_decl
specifier|extern
name|PTR
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|PTR
name|realloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|free
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MALLOC_INCOMPATIBLE */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__WIN32__
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|strchr
end_ifndef

begin_function_decl
specifier|extern
name|char
modifier|*
name|strchr
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|strrchr
end_ifndef

begin_function_decl
specifier|extern
name|char
modifier|*
name|strrchr
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|strstr
end_ifndef

begin_function_decl
specifier|extern
name|char
modifier|*
name|strstr
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|strtok
end_ifndef

begin_function_decl
specifier|extern
name|char
modifier|*
name|strtok
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|strerror
end_ifndef

begin_function_decl
specifier|extern
name|char
modifier|*
name|strerror
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !__WIN32__ */
end_comment

begin_comment
comment|/* Various possibilities for alloca.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|alloca
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_define
define|#
directive|define
name|alloca
value|__builtin_alloca
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Not GNU C */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|sparc
end_ifdef

begin_include
include|#
directive|include
file|<alloca.h>
end_include

begin_comment
comment|/* NOTE:  Doesn't declare alloca() */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* We need to be careful not to declare this in a way which conflicts with    bison.  Bison never declares it as char *, but under various circumstances    (like __hpux) we need to use void *.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__STDC__
argument_list|)
operator|||
name|defined
argument_list|(
name|__hpux
argument_list|)
end_if

begin_function_decl
specifier|extern
name|void
modifier|*
name|alloca
parameter_list|()
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Don't use void *.  */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|alloca
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Don't use void *.  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Not GNU C */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* alloca not defined */
end_comment

begin_comment
comment|/* HOST_BYTE_ORDER must be defined to one of these.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ENDIAN_H
end_ifdef

begin_include
include|#
directive|include
file|<endian.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|BIG_ENDIAN
argument_list|)
end_if

begin_define
define|#
directive|define
name|BIG_ENDIAN
value|4321
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|LITTLE_ENDIAN
argument_list|)
end_if

begin_define
define|#
directive|define
name|LITTLE_ENDIAN
value|1234
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Target-system-dependent parameters for GDB. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TARGET_BYTE_ORDER_SELECTABLE
end_ifdef

begin_comment
comment|/* The target endianness is selectable at runtime.  Define    TARGET_BYTE_ORDER to be a variable.  The user can use the `set    endian' command to change it.  */
end_comment

begin_undef
undef|#
directive|undef
name|TARGET_BYTE_ORDER
end_undef

begin_define
define|#
directive|define
name|TARGET_BYTE_ORDER
value|target_byte_order
end_define

begin_decl_stmt
specifier|extern
name|int
name|target_byte_order
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|void
name|set_endian_from_file
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of bits in a char or unsigned char for the target machine.    Just like CHAR_BIT in<limits.h> but describes the target machine.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|TARGET_CHAR_BIT
argument_list|)
end_if

begin_define
define|#
directive|define
name|TARGET_CHAR_BIT
value|8
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Number of bits in a short or unsigned short for the target machine. */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|TARGET_SHORT_BIT
argument_list|)
end_if

begin_define
define|#
directive|define
name|TARGET_SHORT_BIT
value|(2 * TARGET_CHAR_BIT)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Number of bits in an int or unsigned int for the target machine. */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|TARGET_INT_BIT
argument_list|)
end_if

begin_define
define|#
directive|define
name|TARGET_INT_BIT
value|(4 * TARGET_CHAR_BIT)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Number of bits in a long or unsigned long for the target machine. */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|TARGET_LONG_BIT
argument_list|)
end_if

begin_define
define|#
directive|define
name|TARGET_LONG_BIT
value|(4 * TARGET_CHAR_BIT)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Number of bits in a long long or unsigned long long for the target machine. */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|TARGET_LONG_LONG_BIT
argument_list|)
end_if

begin_define
define|#
directive|define
name|TARGET_LONG_LONG_BIT
value|(2 * TARGET_LONG_BIT)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Number of bits in a float for the target machine. */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|TARGET_FLOAT_BIT
argument_list|)
end_if

begin_define
define|#
directive|define
name|TARGET_FLOAT_BIT
value|(4 * TARGET_CHAR_BIT)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Number of bits in a double for the target machine. */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|TARGET_DOUBLE_BIT
argument_list|)
end_if

begin_define
define|#
directive|define
name|TARGET_DOUBLE_BIT
value|(8 * TARGET_CHAR_BIT)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Number of bits in a long double for the target machine.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|TARGET_LONG_DOUBLE_BIT
argument_list|)
end_if

begin_define
define|#
directive|define
name|TARGET_LONG_DOUBLE_BIT
value|(2 * TARGET_DOUBLE_BIT)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Number of bits in a pointer for the target machine */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|TARGET_PTR_BIT
argument_list|)
end_if

begin_define
define|#
directive|define
name|TARGET_PTR_BIT
value|TARGET_INT_BIT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* If we picked up a copy of CHAR_BIT from a configuration file    (which may get it by including<limits.h>) then use it to set    the number of bits in a host char.  If not, use the same size    as the target. */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CHAR_BIT
argument_list|)
end_if

begin_define
define|#
directive|define
name|HOST_CHAR_BIT
value|CHAR_BIT
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|HOST_CHAR_BIT
value|TARGET_CHAR_BIT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The bit byte-order has to do just with numbering of bits in    debugging symbols and such.  Conceptually, it's quite separate    from byte/word byte order.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|BITS_BIG_ENDIAN
argument_list|)
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|TARGET_BYTE_ORDER_SELECTABLE
end_ifndef

begin_if
if|#
directive|if
name|TARGET_BYTE_ORDER
operator|==
name|BIG_ENDIAN
end_if

begin_define
define|#
directive|define
name|BITS_BIG_ENDIAN
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Big endian.  */
end_comment

begin_if
if|#
directive|if
name|TARGET_BYTE_ORDER
operator|==
name|LITTLE_ENDIAN
end_if

begin_define
define|#
directive|define
name|BITS_BIG_ENDIAN
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Little endian.  */
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* defined (TARGET_BYTE_ORDER_SELECTABLE) */
end_comment

begin_define
define|#
directive|define
name|BITS_BIG_ENDIAN
value|(TARGET_BYTE_ORDER == BIG_ENDIAN)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined (TARGET_BYTE_ORDER_SELECTABLE) */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BITS_BIG_ENDIAN not defined.  */
end_comment

begin_comment
comment|/* In findvar.c.  */
end_comment

begin_decl_stmt
specifier|extern
name|LONGEST
name|extract_signed_integer
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|unsigned
name|LONGEST
name|extract_unsigned_integer
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|extract_long_unsigned_integer
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|,
name|int
operator|,
name|LONGEST
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|CORE_ADDR
name|extract_address
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|store_signed_integer
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|,
name|int
operator|,
name|LONGEST
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|store_unsigned_integer
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|,
name|int
operator|,
name|unsigned
name|LONGEST
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|store_address
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|,
name|int
operator|,
name|CORE_ADDR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Use `long double' if the host compiler supports it.  (Note that this is not    necessarily any longer than `double'.  On SunOS/gcc, it's the same as    double.)  This is necessary because GDB internally converts all floating    point values to the widest type supported by the host.     There are problems however, when the target `long double' is longer than the    host's `long double'.  In general, we'll probably reduce the precision of    any such values and print a warning.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LONG_DOUBLE
end_ifdef

begin_typedef
typedef|typedef
name|long
name|double
name|DOUBLEST
typedef|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|double
name|DOUBLEST
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|DOUBLEST
name|extract_floating
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|store_floating
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|,
name|int
operator|,
name|DOUBLEST
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* On some machines there are bits in addresses which are not really    part of the address, but are used by the kernel, the hardware, etc.    for special purposes.  ADDR_BITS_REMOVE takes out any such bits    so we get a "real" address such as one would find in a symbol    table.  This is used only for addresses of instructions, and even then    I'm not sure it's used in all contexts.  It exists to deal with there    being a few stray bits in the PC which would mislead us, not as some sort    of generic thing to handle alignment or segmentation (it's possible it    should be in TARGET_READ_PC instead).  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|ADDR_BITS_REMOVE
argument_list|)
end_if

begin_define
define|#
directive|define
name|ADDR_BITS_REMOVE
parameter_list|(
name|addr
parameter_list|)
value|(addr)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* No ADDR_BITS_REMOVE.  */
end_comment

begin_comment
comment|/* From valops.c */
end_comment

begin_decl_stmt
specifier|extern
name|CORE_ADDR
name|push_bytes
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|CORE_ADDR
name|push_word
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
operator|,
name|unsigned
name|LONGEST
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Some parts of gdb might be considered optional, in the sense that they    are not essential for being able to build a working, usable debugger    for a specific environment.  For example, the maintenance commands    are there for the benefit of gdb maintainers.  As another example,    some environments really don't need gdb's that are able to read N    different object file formats.  In order to make it possible (but    not necessarily recommended) to build "stripped down" versions of    gdb, the following defines control selective compilation of those    parts of gdb which can be safely left out when necessary.  Note that    the default is to include everything. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MAINTENANCE_CMDS
end_ifndef

begin_define
define|#
directive|define
name|MAINTENANCE_CMDS
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|MAINTENANCE_CMDS
end_ifdef

begin_decl_stmt
specifier|extern
name|int
name|watchdog
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"dis-asm.h"
end_include

begin_comment
comment|/* Get defs for disassemble_info */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|dis_asm_read_memory
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
name|memaddr
operator|,
name|bfd_byte
operator|*
name|myaddr
operator|,
name|int
name|len
operator|,
name|disassemble_info
operator|*
name|info
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|dis_asm_memory_error
name|PARAMS
argument_list|(
operator|(
name|int
name|status
operator|,
name|bfd_vma
name|memaddr
operator|,
name|disassemble_info
operator|*
name|info
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|dis_asm_print_address
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
name|addr
operator|,
name|disassemble_info
operator|*
name|info
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_extern
extern|extern int (*tm_print_insn
end_extern

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
name|disassemble_info
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Hooks for alternate command interfaces.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_struct_decl
struct_decl|struct
name|target_waitstatus
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|cmd_list_element
struct_decl|;
end_struct_decl

begin_endif
endif|#
directive|endif
end_endif

begin_extern
extern|extern void (*init_ui_hook
end_extern

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_extern
extern|extern void (*command_loop_hook
end_extern

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_extern
extern|extern void (*fputs_unfiltered_hook
end_extern

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|linebuffer
operator|,
name|FILE
operator|*
name|stream
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_extern
extern|extern void (*print_frame_info_listing_hook
end_extern

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
expr|struct
name|symtab
operator|*
name|s
operator|,
name|int
name|line
operator|,
name|int
name|stopline
operator|,
name|int
name|noerror
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_extern
extern|extern int (*query_hook
end_extern

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_extern
extern|extern void (*flush_hook
end_extern

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
name|stream
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_extern
extern|extern void (*create_breakpoint_hook
end_extern

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
expr|struct
name|breakpoint
operator|*
name|b
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_extern
extern|extern void (*delete_breakpoint_hook
end_extern

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
expr|struct
name|breakpoint
operator|*
name|bpt
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_extern
extern|extern void (*modify_breakpoint_hook
end_extern

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
expr|struct
name|breakpoint
operator|*
name|bpt
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_extern
extern|extern void (*target_output_hook
end_extern

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_extern
extern|extern void (*interactive_hook
end_extern

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_extern
extern|extern void (*registers_changed_hook
end_extern

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_extern
extern|extern int (*target_wait_hook
end_extern

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|int
name|pid
operator|,
expr|struct
name|target_waitstatus
operator|*
name|status
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_extern
extern|extern void (*call_command_hook
end_extern

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
expr|struct
name|cmd_list_element
operator|*
name|c
operator|,
name|char
operator|*
name|cmd
operator|,
name|int
name|from_tty
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|extern
name|NORETURN
name|void
argument_list|(
operator|*
name|error_hook
argument_list|)
name|PARAMS
argument_list|(
operator|(
operator|)
argument_list|)
name|ATTR_NORETURN
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Inhibit window interface if non-zero. */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|use_windows
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Symbolic definitions of filename-related things.  */
end_comment

begin_comment
comment|/* FIXME, this doesn't work very well if host and executable    filesystems conventions are different.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DIRNAME_SEPARATOR
end_ifndef

begin_define
define|#
directive|define
name|DIRNAME_SEPARATOR
value|':'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SLASH_P
end_ifndef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__GO32__
argument_list|)
operator|||
name|defined
argument_list|(
name|__WIN32__
argument_list|)
end_if

begin_define
define|#
directive|define
name|SLASH_P
parameter_list|(
name|X
parameter_list|)
value|((X)=='\\')
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SLASH_P
parameter_list|(
name|X
parameter_list|)
value|((X)=='/')
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SLASH_CHAR
end_ifndef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__GO32__
argument_list|)
operator|||
name|defined
argument_list|(
name|__WIN32__
argument_list|)
end_if

begin_define
define|#
directive|define
name|SLASH_CHAR
value|'\\'
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SLASH_CHAR
value|'/'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SLASH_STRING
end_ifndef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__GO32__
argument_list|)
operator|||
name|defined
argument_list|(
name|__WIN32__
argument_list|)
end_if

begin_define
define|#
directive|define
name|SLASH_STRING
value|"\\"
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SLASH_STRING
value|"/"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ROOTED_P
end_ifndef

begin_define
define|#
directive|define
name|ROOTED_P
parameter_list|(
name|X
parameter_list|)
value|(SLASH_P((X)[0]))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* #ifndef DEFS_H */
end_comment

end_unit

