begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Basic, host-specific, and target-specific definitions for GDB.    Copyright (C) 1986, 89, 91, 92, 93, 94, 95, 96, 98, 1999    Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DEFS_H
end_ifndef

begin_define
define|#
directive|define
name|DEFS_H
end_define

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_comment
comment|/* Generated by configure */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_comment
comment|/* System call error return status */
end_comment

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STDDEF_H
end_ifdef

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_comment
comment|/* for size_t */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Just in case they're not defined in stdio.h. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SEEK_SET
end_ifndef

begin_define
define|#
directive|define
name|SEEK_SET
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SEEK_CUR
end_ifndef

begin_define
define|#
directive|define
name|SEEK_CUR
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* First include ansidecl.h so we can use the various macro definitions    here and in all subsequent file inclusions.  */
end_comment

begin_include
include|#
directive|include
file|"ansidecl.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|ANSI_PROTOTYPES
end_ifdef

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_comment
comment|/* libiberty.h can't declare this one, but evidently we can.  */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|strsignal
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|"progress.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USE_MMALLOC
end_ifdef

begin_include
include|#
directive|include
file|"mmalloc.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* For BFD64 and bfd_vma.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_comment
comment|/* An address in the program being debugged.  Host byte order.  Rather    than duplicate all the logic in BFD which figures out what type    this is (long, long long, etc.) and whether it needs to be 64    bits (the host/target interactions are subtle), we just use    bfd_vma.  */
end_comment

begin_typedef
typedef|typedef
name|bfd_vma
name|CORE_ADDR
typedef|;
end_typedef

begin_ifndef
ifndef|#
directive|ifndef
name|min
end_ifndef

begin_define
define|#
directive|define
name|min
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)< (b) ? (a) : (b))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|max
end_ifndef

begin_define
define|#
directive|define
name|max
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)> (b) ? (a) : (b))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Gdb does *lots* of string compares.  Use macros to speed them up by    avoiding function calls if the first characters are not the same. */
end_comment

begin_define
define|#
directive|define
name|STRCMP
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(*(a) == *(b) ? strcmp ((a), (b)) : (int)*(a) - (int)*(b))
end_define

begin_define
define|#
directive|define
name|STREQ
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(*(a) == *(b) ? !strcmp ((a), (b)) : 0)
end_define

begin_define
define|#
directive|define
name|STREQN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|(*(a) == *(b) ? !strncmp ((a), (b), (c)) : 0)
end_define

begin_comment
comment|/* The character GNU C++ uses to build identifiers that must be unique from    the program's identifiers (such as $this and $$vptr).  */
end_comment

begin_define
define|#
directive|define
name|CPLUS_MARKER
value|'$'
end_define

begin_comment
comment|/* May be overridden to '.' for SysV */
end_comment

begin_comment
comment|/* Check if a character is one of the commonly used C++ marker characters.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|is_cplus_marker
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* use tui interface if non-zero */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|tui_version
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|TUI
argument_list|)
end_if

begin_comment
comment|/* all invocations of TUIDO should have two sets of parens */
end_comment

begin_define
define|#
directive|define
name|TUIDO
parameter_list|(
name|x
parameter_list|)
value|tuiDo x
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|TUIDO
parameter_list|(
name|x
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* enable xdb commands if set */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|xdb_commands
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* enable dbx commands if set */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|dbx_commands
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|quit_flag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|immediate_quit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|sevenbit_strings
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|quit
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|QUIT
end_ifdef

begin_comment
comment|/* do twice to force compiler warning */
end_comment

begin_define
define|#
directive|define
name|QUIT_FIXME
value|"FIXME"
end_define

begin_define
define|#
directive|define
name|QUIT_FIXME
value|"ignoring redefinition of QUIT"
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|QUIT
value|{ \   if (quit_flag) quit (); \   if (interactive_hook) interactive_hook (); \   PROGRESS (1); \ }
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Command classes are top-level categories into which commands are broken    down for "help" purposes.      Notes on classes: class_alias is for alias commands which are not    abbreviations of the original command.  class-pseudo is for commands    which are not really commands nor help topics ("stop").  */
end_comment

begin_enum
enum|enum
name|command_class
block|{
comment|/* Special args to help_list */
name|all_classes
init|=
operator|-
literal|2
block|,
name|all_commands
init|=
operator|-
literal|1
block|,
comment|/* Classes of commands */
name|no_class
init|=
operator|-
literal|1
block|,
name|class_run
init|=
literal|0
block|,
name|class_vars
block|,
name|class_stack
block|,
name|class_files
block|,
name|class_support
block|,
name|class_info
block|,
name|class_breakpoint
block|,
name|class_trace
block|,
name|class_alias
block|,
name|class_obscure
block|,
name|class_user
block|,
name|class_maintenance
block|,
name|class_pseudo
block|,
name|class_tui
block|,
name|class_xdb
block|}
enum|;
end_enum

begin_comment
comment|/* Languages represented in the symbol table and elsewhere.    This should probably be in language.h, but since enum's can't    be forward declared to satisfy opaque references before their    actual definition, needs to be here. */
end_comment

begin_enum
enum|enum
name|language
block|{
name|language_unknown
block|,
comment|/* Language not known */
name|language_auto
block|,
comment|/* Placeholder for automatic setting */
name|language_c
block|,
comment|/* C */
name|language_cplus
block|,
comment|/* C++ */
name|language_java
block|,
comment|/* Java */
name|language_chill
block|,
comment|/* Chill */
name|language_fortran
block|,
comment|/* Fortran */
name|language_m2
block|,
comment|/* Modula-2 */
name|language_asm
block|,
comment|/* Assembly language */
name|language_scm
comment|/* Scheme / Guile */
block|}
enum|;
end_enum

begin_enum
enum|enum
name|precision_type
block|{
name|single_precision
block|,
name|double_precision
block|,
name|unspecified_precision
block|}
enum|;
end_enum

begin_comment
comment|/* the cleanup list records things that have to be undone    if an error happens (descriptors to be closed, memory to be freed, etc.)    Each link in the chain records a function to call and an    argument to give it.     Use make_cleanup to add an element to the cleanup chain.    Use do_cleanups to do all cleanup actions back to a given    point in the chain.  Use discard_cleanups to remove cleanups    from the chain back to a given point, not doing them.  */
end_comment

begin_struct
struct|struct
name|cleanup
block|{
name|struct
name|cleanup
modifier|*
name|next
decl_stmt|;
name|void
argument_list|(
argument|*function
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|)
argument_list|)
expr_stmt|;
name|PTR
name|arg
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The ability to declare that a function never returns is useful, but    not really required to compile GDB successfully, so the NORETURN and    ATTR_NORETURN macros normally expand into nothing.  */
end_comment

begin_comment
comment|/* If compiling with older versions of GCC, a function may be declared    "volatile" to indicate that it does not return.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NORETURN
end_ifndef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
expr|\
operator|&&
operator|(
name|__GNUC__
operator|==
literal|1
operator|||
operator|(
name|__GNUC__
operator|==
literal|2
operator|&&
name|__GNUC_MINOR__
operator|<
literal|7
operator|)
operator|)
end_if

begin_define
define|#
directive|define
name|NORETURN
value|volatile
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|NORETURN
end_define

begin_comment
comment|/* nothing */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* GCC 2.5 and later versions define a function attribute "noreturn",    which is the preferred way to declare that a function never returns.    However GCC 2.7 appears to be the first version in which this fully    works everywhere we use it. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ATTR_NORETURN
end_ifndef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
name|__GNUC__
operator|>=
literal|2
operator|&&
name|__GNUC_MINOR__
operator|>=
literal|7
end_if

begin_define
define|#
directive|define
name|ATTR_NORETURN
value|__attribute__ ((noreturn))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ATTR_NORETURN
end_define

begin_comment
comment|/* nothing */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ATTR_FORMAT
end_ifndef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
name|__GNUC__
operator|>=
literal|2
operator|&&
name|__GNUC_MINOR__
operator|>=
literal|4
operator|&&
name|defined
argument_list|(
name|__ANSI_PROTOTYPES
argument_list|)
end_if

begin_define
define|#
directive|define
name|ATTR_FORMAT
parameter_list|(
name|type
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|)
value|__attribute__ ((format(type, x, y)))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ATTR_FORMAT
parameter_list|(
name|type
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|)
end_define

begin_comment
comment|/* nothing */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Needed for various prototypes */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_struct_decl
struct_decl|struct
name|symtab
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|breakpoint
struct_decl|;
end_struct_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* From blockframe.c */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|inside_entry_func
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|inside_entry_file
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
name|addr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|inside_main_func
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
name|pc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* From ch-lang.c, for the moment. (FIXME) */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|chill_demangle
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* From utils.c */
end_comment

begin_decl_stmt
specifier|extern
name|void
name|notice_quit
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|strcmp_iw
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|safe_strerror
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|safe_strsignal
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|init_malloc
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|request_quit
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|do_cleanups
name|PARAMS
argument_list|(
operator|(
expr|struct
name|cleanup
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|do_final_cleanups
name|PARAMS
argument_list|(
operator|(
expr|struct
name|cleanup
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|do_my_cleanups
name|PARAMS
argument_list|(
operator|(
expr|struct
name|cleanup
operator|*
operator|*
operator|,
expr|struct
name|cleanup
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|do_run_cleanups
name|PARAMS
argument_list|(
operator|(
expr|struct
name|cleanup
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|discard_cleanups
name|PARAMS
argument_list|(
operator|(
expr|struct
name|cleanup
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|discard_final_cleanups
name|PARAMS
argument_list|(
operator|(
expr|struct
name|cleanup
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|discard_my_cleanups
name|PARAMS
argument_list|(
operator|(
expr|struct
name|cleanup
operator|*
operator|*
operator|,
expr|struct
name|cleanup
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
name|void
argument_list|(
argument|*make_cleanup_func
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
expr_stmt|;
end_typedef

begin_decl_stmt
specifier|extern
name|struct
name|cleanup
modifier|*
name|make_cleanup
name|PARAMS
argument_list|(
operator|(
name|make_cleanup_func
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|cleanup
modifier|*
name|make_final_cleanup
name|PARAMS
argument_list|(
operator|(
name|make_cleanup_func
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|cleanup
modifier|*
name|make_my_cleanup
name|PARAMS
argument_list|(
operator|(
expr|struct
name|cleanup
operator|*
operator|*
operator|,
name|make_cleanup_func
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|cleanup
modifier|*
name|make_run_cleanup
name|PARAMS
argument_list|(
operator|(
name|make_cleanup_func
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|cleanup
modifier|*
name|save_cleanups
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|cleanup
modifier|*
name|save_final_cleanups
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|cleanup
modifier|*
name|save_my_cleanups
name|PARAMS
argument_list|(
operator|(
expr|struct
name|cleanup
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|restore_cleanups
name|PARAMS
argument_list|(
operator|(
expr|struct
name|cleanup
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|restore_final_cleanups
name|PARAMS
argument_list|(
operator|(
expr|struct
name|cleanup
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|restore_my_cleanups
name|PARAMS
argument_list|(
operator|(
expr|struct
name|cleanup
operator|*
operator|*
operator|,
expr|struct
name|cleanup
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|free_current_contents
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|null_cleanup
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|myread
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|query
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
name|ATTR_FORMAT
argument_list|(
name|printf
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|USE_MMALLOC
argument_list|)
end_if

begin_decl_stmt
specifier|extern
name|PTR
name|mmalloc
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|PTR
name|mrealloc
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
name|PTR
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|mfree
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* From demangle.c */
end_comment

begin_decl_stmt
specifier|extern
name|void
name|set_demangling_style
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* From tm.h */
end_comment

begin_struct_decl
struct_decl|struct
name|type
struct_decl|;
end_struct_decl

begin_typedef
typedef|typedef
name|int
argument_list|(
argument|use_struct_convention_fn
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|int
name|gcc_p
operator|,
expr|struct
name|type
operator|*
name|value_type
operator|)
argument_list|)
expr_stmt|;
end_typedef

begin_decl_stmt
specifier|extern
name|use_struct_convention_fn
name|generic_use_struct_convention
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
name|unsigned
name|char
modifier|*
parameter_list|(
name|breakpoint_from_pc_fn
parameter_list|)
function_decl|PARAMS
parameter_list|(
function_decl|(
name|CORE_ADDR
modifier|*
name|pcptr
function_decl|,
name|int
modifier|*
name|lenptr
function_decl|)
typedef|);
end_typedef

begin_escape
end_escape

begin_comment
comment|/* Annotation stuff.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|annotation_level
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* in stack.c */
end_comment

begin_escape
end_escape

begin_decl_stmt
specifier|extern
name|void
name|begin_line
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|wrap_here
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|reinitialize_more_filter
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* new */
end_comment

begin_enum
enum|enum
name|streamtype
block|{
name|afile
block|,
name|astring
block|}
enum|;
end_enum

begin_comment
comment|/* new */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|tui_stream
block|{
name|enum
name|streamtype
name|ts_streamtype
decl_stmt|;
name|FILE
modifier|*
name|ts_filestream
decl_stmt|;
name|char
modifier|*
name|ts_strbuf
decl_stmt|;
name|int
name|ts_buflen
decl_stmt|;
block|}
name|GDB_FILE
typedef|;
end_typedef

begin_decl_stmt
specifier|extern
name|GDB_FILE
modifier|*
name|gdb_stdout
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|GDB_FILE
modifier|*
name|gdb_stderr
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_define
unit|typedef FILE GDB_FILE;
define|#
directive|define
name|gdb_stdout
value|stdout
end_define

begin_define
define|#
directive|define
name|gdb_stderr
value|stderr
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|TUI
argument_list|)
end_if

begin_include
include|#
directive|include
file|"tui.h"
end_include

begin_include
include|#
directive|include
file|"tuiCommand.h"
end_include

begin_include
include|#
directive|include
file|"tuiData.h"
end_include

begin_include
include|#
directive|include
file|"tuiIO.h"
end_include

begin_include
include|#
directive|include
file|"tuiLayout.h"
end_include

begin_include
include|#
directive|include
file|"tuiWin.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|void
name|gdb_fclose
name|PARAMS
argument_list|(
operator|(
name|GDB_FILE
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|gdb_flush
name|PARAMS
argument_list|(
operator|(
name|GDB_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|GDB_FILE
modifier|*
name|gdb_fopen
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|name
operator|,
name|char
operator|*
name|mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|fputs_filtered
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|GDB_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|fputs_unfiltered
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|GDB_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|fputc_filtered
name|PARAMS
argument_list|(
operator|(
name|int
name|c
operator|,
name|GDB_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|fputc_unfiltered
name|PARAMS
argument_list|(
operator|(
name|int
name|c
operator|,
name|GDB_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|putchar_unfiltered
name|PARAMS
argument_list|(
operator|(
name|int
name|c
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|puts_filtered
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|puts_unfiltered
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|puts_debug
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|prefix
operator|,
name|char
operator|*
name|string
operator|,
name|char
operator|*
name|suffix
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|vprintf_filtered
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|va_list
operator|)
argument_list|)
name|ATTR_FORMAT
argument_list|(
name|printf
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|vfprintf_filtered
name|PARAMS
argument_list|(
operator|(
name|GDB_FILE
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|va_list
operator|)
argument_list|)
name|ATTR_FORMAT
argument_list|(
name|printf
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|fprintf_filtered
name|PARAMS
argument_list|(
operator|(
name|GDB_FILE
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
name|ATTR_FORMAT
argument_list|(
name|printf
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|fprintfi_filtered
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|GDB_FILE
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
name|ATTR_FORMAT
argument_list|(
name|printf
argument_list|,
literal|3
argument_list|,
literal|4
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|printf_filtered
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
name|ATTR_FORMAT
argument_list|(
name|printf
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|printfi_filtered
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
specifier|const
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
name|ATTR_FORMAT
argument_list|(
name|printf
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|vprintf_unfiltered
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|va_list
operator|)
argument_list|)
name|ATTR_FORMAT
argument_list|(
name|printf
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|vfprintf_unfiltered
name|PARAMS
argument_list|(
operator|(
name|GDB_FILE
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|va_list
operator|)
argument_list|)
name|ATTR_FORMAT
argument_list|(
name|printf
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|fprintf_unfiltered
name|PARAMS
argument_list|(
operator|(
name|GDB_FILE
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
name|ATTR_FORMAT
argument_list|(
name|printf
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|printf_unfiltered
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
name|ATTR_FORMAT
argument_list|(
name|printf
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|gdb_file_isatty
name|PARAMS
argument_list|(
operator|(
name|GDB_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|GDB_FILE
modifier|*
name|gdb_file_init_astring
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|gdb_file_deallocate
name|PARAMS
argument_list|(
operator|(
name|GDB_FILE
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|gdb_file_get_strbuf
name|PARAMS
argument_list|(
operator|(
name|GDB_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|gdb_file_adjust_strbuf
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|GDB_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|print_spaces
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|GDB_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|print_spaces_filtered
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|GDB_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|n_spaces
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|gdb_printchar
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|GDB_FILE
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|gdb_print_address
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|,
name|GDB_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
name|bfd_vma
name|t_addr
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|bfd_vma
name|t_reg
typedef|;
end_typedef

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|paddr
name|PARAMS
argument_list|(
operator|(
name|t_addr
name|addr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|preg
name|PARAMS
argument_list|(
operator|(
name|t_reg
name|reg
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|paddr_nz
name|PARAMS
argument_list|(
operator|(
name|t_addr
name|addr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|preg_nz
name|PARAMS
argument_list|(
operator|(
name|t_reg
name|reg
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|fprintf_symbol_filtered
name|PARAMS
argument_list|(
operator|(
name|GDB_FILE
operator|*
operator|,
name|char
operator|*
operator|,
expr|enum
name|language
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|NORETURN
name|void
name|perror_with_name
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
name|ATTR_NORETURN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|print_sys_errmsg
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* From regex.c or libc.  BSD 4.4 declares this with the argument type as    "const char *" in unistd.h, so we can't declare the argument    as "char *".  */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|re_comp
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* From symfile.c */
end_comment

begin_decl_stmt
specifier|extern
name|void
name|symbol_file_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* From top.c */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|skip_quoted
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|gdb_readline
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|command_line_input
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|print_prompt
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|input_from_terminal_p
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|info_verbose
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* From printcmd.c */
end_comment

begin_decl_stmt
specifier|extern
name|void
name|set_next_address
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|print_address_symbolic
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
operator|,
name|GDB_FILE
operator|*
operator|,
name|int
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|print_address_numeric
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
operator|,
name|int
operator|,
name|GDB_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|print_address
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
operator|,
name|GDB_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* From source.c */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|openp
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|source_full_path_of
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|mod_path
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|directory_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|init_source_path
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|symtab_to_filename
name|PARAMS
argument_list|(
operator|(
expr|struct
name|symtab
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* From findvar.c */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|read_relative_register_raw_bytes
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Control types for commands */
end_comment

begin_enum
enum|enum
name|misc_command_type
block|{
name|ok_command
block|,
name|end_command
block|,
name|else_command
block|,
name|nop_command
block|}
enum|;
end_enum

begin_enum
enum|enum
name|command_control_type
block|{
name|simple_control
block|,
name|break_control
block|,
name|continue_control
block|,
name|while_control
block|,
name|if_control
block|,
name|invalid_control
block|}
enum|;
end_enum

begin_comment
comment|/* Structure for saved commands lines    (for breakpoints, defined commands, etc).  */
end_comment

begin_struct
struct|struct
name|command_line
block|{
name|struct
name|command_line
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|;
name|enum
name|command_control_type
name|control_type
decl_stmt|;
name|int
name|body_count
decl_stmt|;
name|struct
name|command_line
modifier|*
modifier|*
name|body_list
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|extern
name|struct
name|command_line
modifier|*
name|read_command_lines
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|free_command_lines
name|PARAMS
argument_list|(
operator|(
expr|struct
name|command_line
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* String containing the current directory (what getwd would return).  */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|current_directory
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default radixes for input and output.  Only some values supported.  */
end_comment

begin_decl_stmt
specifier|extern
name|unsigned
name|input_radix
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|unsigned
name|output_radix
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Possibilities for prettyprint parameters to routines which print    things.  Like enum language, this should be in value.h, but needs    to be here for the same reason.  FIXME:  If we can eliminate this    as an arg to LA_VAL_PRINT, then we can probably move it back to    value.h. */
end_comment

begin_enum
enum|enum
name|val_prettyprint
block|{
name|Val_no_prettyprint
init|=
literal|0
block|,
name|Val_prettyprint
block|,
comment|/* Use the default setting which the user has specified.  */
name|Val_pretty_default
block|}
enum|;
end_enum

begin_escape
end_escape

begin_comment
comment|/* Host machine definition.  This will be a symlink to one of the    xm-*.h files, built by the `configure' script.  */
end_comment

begin_include
include|#
directive|include
file|"xm.h"
end_include

begin_comment
comment|/* Native machine support.  This will be a symlink to one of the    nm-*.h files, built by the `configure' script.  */
end_comment

begin_include
include|#
directive|include
file|"nm.h"
end_include

begin_comment
comment|/* Target machine definition.  This will be a symlink to one of the    tm-*.h files, built by the `configure' script.  */
end_comment

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_comment
comment|/* If the xm.h file did not define the mode string used to open the    files, assume that binary files are opened the same way as text    files */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|FOPEN_RB
end_ifndef

begin_include
include|#
directive|include
file|"fopen-same.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Microsoft C can't deal with const pointers */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_MSC_VER
end_ifdef

begin_define
define|#
directive|define
name|CONST_PTR
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CONST_PTR
value|const
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Allow things in gdb to be declared "volatile".  If compiling ANSI, it  * just works.  If compiling with gcc but non-ansi, redefine to __volatile__.  * If non-ansi, non-gcc, then eliminate "volatile" entirely, making those  * objects be read-write rather than read-only.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|volatile
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|__STDC__
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_define
define|#
directive|define
name|volatile
value|__volatile__
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|volatile
end_define

begin_comment
comment|/*nothing*/
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* GNUC */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* STDC */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* volatile */
end_comment

begin_comment
comment|/* Defaults for system-wide constants (if not defined by xm.h, we fake it).    FIXME: Assumes 2's complement arithmetic */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|UINT_MAX
argument_list|)
end_if

begin_define
define|#
directive|define
name|UINT_MAX
value|((unsigned int)(~0))
end_define

begin_comment
comment|/* 0xFFFFFFFF for 32-bits */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|INT_MAX
argument_list|)
end_if

begin_define
define|#
directive|define
name|INT_MAX
value|((int)(UINT_MAX>> 1))
end_define

begin_comment
comment|/* 0x7FFFFFFF for 32-bits */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|INT_MIN
argument_list|)
end_if

begin_define
define|#
directive|define
name|INT_MIN
value|((int)((int) ~0 ^ INT_MAX))
end_define

begin_comment
comment|/* 0x80000000 for 32-bits */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|ULONG_MAX
argument_list|)
end_if

begin_define
define|#
directive|define
name|ULONG_MAX
value|((unsigned long)(~0L))
end_define

begin_comment
comment|/* 0xFFFFFFFF for 32-bits */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|LONG_MAX
argument_list|)
end_if

begin_define
define|#
directive|define
name|LONG_MAX
value|((long)(ULONG_MAX>> 1))
end_define

begin_comment
comment|/* 0x7FFFFFFF for 32-bits */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LONGEST
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|BFD64
end_ifdef

begin_comment
comment|/* This is to make sure that LONGEST is at least as big as CORE_ADDR.  */
end_comment

begin_define
define|#
directive|define
name|LONGEST
value|BFD_HOST_64_BIT
end_define

begin_define
define|#
directive|define
name|ULONGEST
value|BFD_HOST_U_64_BIT
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* No BFD64 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CC_HAS_LONG_LONG
end_ifdef

begin_define
define|#
directive|define
name|LONGEST
value|long long
end_define

begin_define
define|#
directive|define
name|ULONGEST
value|unsigned long long
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* BFD_HOST_64_BIT is defined for some hosts that don't have long long    (e.g. i386-windows) so try it.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BFD_HOST_64_BIT
end_ifdef

begin_define
define|#
directive|define
name|LONGEST
value|BFD_HOST_64_BIT
end_define

begin_define
define|#
directive|define
name|ULONGEST
value|BFD_HOST_U_64_BIT
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|LONGEST
value|long
end_define

begin_define
define|#
directive|define
name|ULONGEST
value|unsigned long
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* No BFD64 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! LONGEST */
end_comment

begin_comment
comment|/* Convert a LONGEST to an int.  This is used in contexts (e.g. number of    arguments to a function, number in a value history, register number, etc.)    where the value must not be larger than can fit in an int.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|longest_to_int
name|PARAMS
argument_list|(
operator|(
name|LONGEST
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Assorted functions we can declare, now that const and volatile are     defined.  */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|savestring
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|msavestring
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|strsave
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|mstrsave
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|_MSC_VER
end_ifdef

begin_comment
comment|/* FIXME; was long, but this causes compile errors in msvc if already defined */
end_comment

begin_decl_stmt
specifier|extern
name|PTR
name|xmmalloc
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|PTR
name|xmrealloc
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
name|PTR
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|extern
name|PTR
name|xmmalloc
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|PTR
name|xmrealloc
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
name|PTR
operator|,
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|int
name|parse_escape
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* compat - handle old targets that just define REGISTER_NAMES */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|REGISTER_NAME
end_ifndef

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|gdb_register_names
index|[]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|REGISTER_NAME
parameter_list|(
name|i
parameter_list|)
value|gdb_register_names[i]
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Message to be printed before the error message, when an error occurs.  */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|error_pre_print
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Message to be printed before the error message, when an error occurs.  */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|quit_pre_print
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Message to be printed before the warning message, when a warning occurs.  */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|warning_pre_print
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|NORETURN
name|void
name|error
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
name|ATTR_NORETURN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|error_begin
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|NORETURN
name|void
name|fatal
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
name|ATTR_NORETURN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|NORETURN
name|void
name|nomem
name|PARAMS
argument_list|(
operator|(
name|long
operator|)
argument_list|)
name|ATTR_NORETURN
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Reasons for calling return_to_top_level.  */
end_comment

begin_enum
enum|enum
name|return_reason
block|{
comment|/* User interrupt.  */
name|RETURN_QUIT
block|,
comment|/* Any other error.  */
name|RETURN_ERROR
block|}
enum|;
end_enum

begin_define
define|#
directive|define
name|RETURN_MASK_QUIT
value|(1<< (int)RETURN_QUIT)
end_define

begin_define
define|#
directive|define
name|RETURN_MASK_ERROR
value|(1<< (int)RETURN_ERROR)
end_define

begin_define
define|#
directive|define
name|RETURN_MASK_ALL
value|(RETURN_MASK_QUIT | RETURN_MASK_ERROR)
end_define

begin_typedef
typedef|typedef
name|int
name|return_mask
typedef|;
end_typedef

begin_decl_stmt
specifier|extern
name|NORETURN
name|void
name|return_to_top_level
name|PARAMS
argument_list|(
operator|(
expr|enum
name|return_reason
operator|)
argument_list|)
name|ATTR_NORETURN
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
name|int
argument_list|(
argument|catch_errors_ftype
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|)
argument_list|)
expr_stmt|;
end_typedef

begin_decl_stmt
specifier|extern
name|int
name|catch_errors
name|PARAMS
argument_list|(
operator|(
name|catch_errors_ftype
operator|*
operator|,
name|PTR
operator|,
name|char
operator|*
operator|,
name|return_mask
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|warning_begin
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|warning
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
name|ATTR_FORMAT
argument_list|(
name|printf
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Global functions from other, non-gdb GNU thingies.    Libiberty thingies are no longer declared here.  We include libiberty.h    above, instead.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|GETENV_PROVIDED
end_ifndef

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|getenv
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* From other system libraries */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STDDEF_H
end_ifdef

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STDLIB_H
end_ifdef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__cplusplus
argument_list|)
end_if

begin_comment
comment|/* msvc defines these in stdlib.h for c code */
end_comment

begin_undef
undef|#
directive|undef
name|min
end_undef

begin_undef
undef|#
directive|undef
name|max
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|min
end_ifndef

begin_define
define|#
directive|define
name|min
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)< (b) ? (a) : (b))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|max
end_ifndef

begin_define
define|#
directive|define
name|max
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)> (b) ? (a) : (b))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* We take the address of fclose later, but some stdio's forget    to declare this.  We can't always declare it since there's    no way to declare the parameters without upsetting some compiler    somewhere. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|FCLOSE_PROVIDED
end_ifndef

begin_decl_stmt
specifier|extern
name|int
name|fclose
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|atof
end_ifndef

begin_decl_stmt
specifier|extern
name|double
name|atof
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* X3.159-1989  4.10.1.1 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MALLOC_INCOMPATIBLE
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|NEED_DECLARATION_MALLOC
end_ifdef

begin_function_decl
specifier|extern
name|PTR
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NEED_DECLARATION_REALLOC
end_ifdef

begin_function_decl
specifier|extern
name|PTR
name|realloc
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NEED_DECLARATION_FREE
end_ifdef

begin_function_decl
specifier|extern
name|void
name|free
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MALLOC_INCOMPATIBLE */
end_comment

begin_comment
comment|/* Various possibilities for alloca.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|alloca
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_define
define|#
directive|define
name|alloca
value|__builtin_alloca
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Not GNU C */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ALLOCA_H
end_ifdef

begin_include
include|#
directive|include
file|<alloca.h>
end_include

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|_AIX
end_ifdef

begin_pragma
pragma|#
directive|pragma
name|alloca
end_pragma

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* We need to be careful not to declare this in a way which conflicts with    bison.  Bison never declares it as char *, but under various circumstances    (like __hpux) we need to use void *.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__STDC__
argument_list|)
operator|||
name|defined
argument_list|(
name|__hpux
argument_list|)
end_if

begin_function_decl
specifier|extern
name|void
modifier|*
name|alloca
parameter_list|()
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Don't use void *.  */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|alloca
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Don't use void *.  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Not _AIX */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Not HAVE_ALLOCA_H */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Not GNU C */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* alloca not defined */
end_comment

begin_comment
comment|/* HOST_BYTE_ORDER must be defined to one of these.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ENDIAN_H
end_ifdef

begin_include
include|#
directive|include
file|<endian.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|BIG_ENDIAN
argument_list|)
end_if

begin_define
define|#
directive|define
name|BIG_ENDIAN
value|4321
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|LITTLE_ENDIAN
argument_list|)
end_if

begin_define
define|#
directive|define
name|LITTLE_ENDIAN
value|1234
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Dynamic target-system-dependent parameters for GDB. */
end_comment

begin_include
include|#
directive|include
file|"gdbarch.h"
end_include

begin_comment
comment|/* Static target-system-dependent parameters for GDB. */
end_comment

begin_comment
comment|/* Number of bits in a char or unsigned char for the target machine.    Just like CHAR_BIT in<limits.h> but describes the target machine.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|TARGET_CHAR_BIT
argument_list|)
end_if

begin_define
define|#
directive|define
name|TARGET_CHAR_BIT
value|8
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Number of bits in a short or unsigned short for the target machine. */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|TARGET_SHORT_BIT
argument_list|)
end_if

begin_define
define|#
directive|define
name|TARGET_SHORT_BIT
value|(2 * TARGET_CHAR_BIT)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Number of bits in an int or unsigned int for the target machine. */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|TARGET_INT_BIT
argument_list|)
end_if

begin_define
define|#
directive|define
name|TARGET_INT_BIT
value|(4 * TARGET_CHAR_BIT)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Number of bits in a long or unsigned long for the target machine. */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|TARGET_LONG_BIT
argument_list|)
end_if

begin_define
define|#
directive|define
name|TARGET_LONG_BIT
value|(4 * TARGET_CHAR_BIT)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Number of bits in a long long or unsigned long long for the target machine. */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|TARGET_LONG_LONG_BIT
argument_list|)
end_if

begin_define
define|#
directive|define
name|TARGET_LONG_LONG_BIT
value|(2 * TARGET_LONG_BIT)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Number of bits in a float for the target machine. */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|TARGET_FLOAT_BIT
argument_list|)
end_if

begin_define
define|#
directive|define
name|TARGET_FLOAT_BIT
value|(4 * TARGET_CHAR_BIT)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Number of bits in a double for the target machine. */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|TARGET_DOUBLE_BIT
argument_list|)
end_if

begin_define
define|#
directive|define
name|TARGET_DOUBLE_BIT
value|(8 * TARGET_CHAR_BIT)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Number of bits in a long double for the target machine.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|TARGET_LONG_DOUBLE_BIT
argument_list|)
end_if

begin_define
define|#
directive|define
name|TARGET_LONG_DOUBLE_BIT
value|(2 * TARGET_DOUBLE_BIT)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Number of bits in a pointer for the target machine */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|TARGET_PTR_BIT
argument_list|)
end_if

begin_define
define|#
directive|define
name|TARGET_PTR_BIT
value|TARGET_INT_BIT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* If we picked up a copy of CHAR_BIT from a configuration file    (which may get it by including<limits.h>) then use it to set    the number of bits in a host char.  If not, use the same size    as the target. */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CHAR_BIT
argument_list|)
end_if

begin_define
define|#
directive|define
name|HOST_CHAR_BIT
value|CHAR_BIT
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|HOST_CHAR_BIT
value|TARGET_CHAR_BIT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The bit byte-order has to do just with numbering of bits in    debugging symbols and such.  Conceptually, it's quite separate    from byte/word byte order.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|BITS_BIG_ENDIAN
argument_list|)
end_if

begin_define
define|#
directive|define
name|BITS_BIG_ENDIAN
value|(TARGET_BYTE_ORDER == BIG_ENDIAN)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* In findvar.c.  */
end_comment

begin_decl_stmt
specifier|extern
name|LONGEST
name|extract_signed_integer
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|ULONGEST
name|extract_unsigned_integer
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|extract_long_unsigned_integer
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|,
name|int
operator|,
name|LONGEST
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|CORE_ADDR
name|extract_address
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|store_signed_integer
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
name|int
operator|,
name|LONGEST
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|store_unsigned_integer
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
name|int
operator|,
name|ULONGEST
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|store_address
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
name|int
operator|,
name|LONGEST
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Setup definitions for host and target floating point formats.  We need to    consider the format for `float', `double', and `long double' for both target    and host.  We need to do this so that we know what kind of conversions need    to be done when converting target numbers to and from the hosts DOUBLEST    data type.  */
end_comment

begin_comment
comment|/* This is used to indicate that we don't know the format of the floating point    number.  Typically, this is useful for native ports, where the actual format    is irrelevant, since no conversions will be taking place.  */
end_comment

begin_decl_stmt
specifier|extern
specifier|const
name|struct
name|floatformat
name|floatformat_unknown
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|HOST_BYTE_ORDER
operator|==
name|BIG_ENDIAN
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|HOST_FLOAT_FORMAT
end_ifndef

begin_define
define|#
directive|define
name|HOST_FLOAT_FORMAT
value|&floatformat_ieee_single_big
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|HOST_DOUBLE_FORMAT
end_ifndef

begin_define
define|#
directive|define
name|HOST_DOUBLE_FORMAT
value|&floatformat_ieee_double_big
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* LITTLE_ENDIAN */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HOST_FLOAT_FORMAT
end_ifndef

begin_define
define|#
directive|define
name|HOST_FLOAT_FORMAT
value|&floatformat_ieee_single_little
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|HOST_DOUBLE_FORMAT
end_ifndef

begin_define
define|#
directive|define
name|HOST_DOUBLE_FORMAT
value|&floatformat_ieee_double_little
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|HOST_LONG_DOUBLE_FORMAT
end_ifndef

begin_define
define|#
directive|define
name|HOST_LONG_DOUBLE_FORMAT
value|&floatformat_unknown
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TARGET_FLOAT_FORMAT
end_ifndef

begin_define
define|#
directive|define
name|TARGET_FLOAT_FORMAT
value|(TARGET_BYTE_ORDER == BIG_ENDIAN \ 			     ?&floatformat_ieee_single_big \ 			     :&floatformat_ieee_single_little)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TARGET_DOUBLE_FORMAT
end_ifndef

begin_define
define|#
directive|define
name|TARGET_DOUBLE_FORMAT
value|(TARGET_BYTE_ORDER == BIG_ENDIAN \ 			      ?&floatformat_ieee_double_big \ 			      :&floatformat_ieee_double_little)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TARGET_LONG_DOUBLE_FORMAT
end_ifndef

begin_define
define|#
directive|define
name|TARGET_LONG_DOUBLE_FORMAT
value|&floatformat_unknown
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Use `long double' if the host compiler supports it.  (Note that this is not    necessarily any longer than `double'.  On SunOS/gcc, it's the same as    double.)  This is necessary because GDB internally converts all floating    point values to the widest type supported by the host.     There are problems however, when the target `long double' is longer than the    host's `long double'.  In general, we'll probably reduce the precision of    any such values and print a warning.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LONG_DOUBLE
end_ifdef

begin_typedef
typedef|typedef
name|long
name|double
name|DOUBLEST
typedef|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|double
name|DOUBLEST
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|void
name|floatformat_to_doublest
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|floatformat
operator|*
operator|,
name|char
operator|*
operator|,
name|DOUBLEST
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|floatformat_from_doublest
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|floatformat
operator|*
operator|,
name|DOUBLEST
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|DOUBLEST
name|extract_floating
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|store_floating
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|,
name|int
operator|,
name|DOUBLEST
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* On some machines there are bits in addresses which are not really    part of the address, but are used by the kernel, the hardware, etc.    for special purposes.  ADDR_BITS_REMOVE takes out any such bits    so we get a "real" address such as one would find in a symbol    table.  This is used only for addresses of instructions, and even then    I'm not sure it's used in all contexts.  It exists to deal with there    being a few stray bits in the PC which would mislead us, not as some sort    of generic thing to handle alignment or segmentation (it's possible it    should be in TARGET_READ_PC instead).  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|ADDR_BITS_REMOVE
argument_list|)
end_if

begin_define
define|#
directive|define
name|ADDR_BITS_REMOVE
parameter_list|(
name|addr
parameter_list|)
value|(addr)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* No ADDR_BITS_REMOVE.  */
end_comment

begin_comment
comment|/* From valops.c */
end_comment

begin_decl_stmt
specifier|extern
name|CORE_ADDR
name|push_bytes
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|CORE_ADDR
name|push_word
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
operator|,
name|ULONGEST
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Some parts of gdb might be considered optional, in the sense that they    are not essential for being able to build a working, usable debugger    for a specific environment.  For example, the maintenance commands    are there for the benefit of gdb maintainers.  As another example,    some environments really don't need gdb's that are able to read N    different object file formats.  In order to make it possible (but    not necessarily recommended) to build "stripped down" versions of    gdb, the following defines control selective compilation of those    parts of gdb which can be safely left out when necessary.  Note that    the default is to include everything. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MAINTENANCE_CMDS
end_ifndef

begin_define
define|#
directive|define
name|MAINTENANCE_CMDS
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|MAINTENANCE_CMDS
end_ifdef

begin_decl_stmt
specifier|extern
name|int
name|watchdog
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Hooks for alternate command interfaces.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_struct_decl
struct_decl|struct
name|target_waitstatus
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|cmd_list_element
struct_decl|;
end_struct_decl

begin_endif
endif|#
directive|endif
end_endif

begin_extern
extern|extern void (*init_ui_hook
end_extern

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|argv0
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_extern
extern|extern void (*command_loop_hook
end_extern

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_extern
extern|extern void (*fputs_unfiltered_hook
end_extern

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|linebuffer
operator|,
name|GDB_FILE
operator|*
name|stream
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_extern
extern|extern void (*print_frame_info_listing_hook
end_extern

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
expr|struct
name|symtab
operator|*
name|s
operator|,
name|int
name|line
operator|,
name|int
name|stopline
operator|,
name|int
name|noerror
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|extern
name|struct
name|frame_info
modifier|*
name|parse_frame_specification
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|frame_exp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_extern
extern|extern int  (*query_hook
end_extern

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|va_list
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_extern
extern|extern void (*warning_hook
end_extern

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|va_list
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_extern
extern|extern void (*flush_hook
end_extern

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|GDB_FILE
operator|*
name|stream
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_extern
extern|extern void (*create_breakpoint_hook
end_extern

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
expr|struct
name|breakpoint
operator|*
name|b
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_extern
extern|extern void (*delete_breakpoint_hook
end_extern

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
expr|struct
name|breakpoint
operator|*
name|bpt
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_extern
extern|extern void (*modify_breakpoint_hook
end_extern

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
expr|struct
name|breakpoint
operator|*
name|bpt
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_extern
extern|extern void (*target_output_hook
end_extern

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_extern
extern|extern void (*interactive_hook
end_extern

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_extern
extern|extern void (*registers_changed_hook
end_extern

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_extern
extern|extern void (*readline_begin_hook
end_extern

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_extern
extern|extern char * (*readline_hook
end_extern

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_extern
extern|extern void (*readline_end_hook
end_extern

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_extern
extern|extern void (*register_changed_hook
end_extern

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|int
name|regno
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_extern
extern|extern void (*memory_changed_hook
end_extern

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
name|addr
operator|,
name|int
name|len
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_extern
extern|extern void (*context_hook
end_extern

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_extern
extern|extern int (*target_wait_hook
end_extern

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|int
name|pid
operator|,
expr|struct
name|target_waitstatus
operator|*
name|status
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_extern
extern|extern void (*call_command_hook
end_extern

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
expr|struct
name|cmd_list_element
operator|*
name|c
operator|,
name|char
operator|*
name|cmd
operator|,
name|int
name|from_tty
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|extern
name|NORETURN
name|void
argument_list|(
operator|*
name|error_hook
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
name|ATTR_NORETURN
decl_stmt|;
end_decl_stmt

begin_extern
extern|extern void (*error_begin_hook
end_extern

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Inhibit window interface if non-zero. */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|use_windows
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Symbolic definitions of filename-related things.  */
end_comment

begin_comment
comment|/* FIXME, this doesn't work very well if host and executable    filesystems conventions are different.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DIRNAME_SEPARATOR
end_ifndef

begin_define
define|#
directive|define
name|DIRNAME_SEPARATOR
value|':'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SLASH_P
end_ifndef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__GO32__
argument_list|)
operator|||
name|defined
argument_list|(
name|_WIN32
argument_list|)
end_if

begin_define
define|#
directive|define
name|SLASH_P
parameter_list|(
name|X
parameter_list|)
value|((X)=='\\')
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SLASH_P
parameter_list|(
name|X
parameter_list|)
value|((X)=='/')
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SLASH_CHAR
end_ifndef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__GO32__
argument_list|)
operator|||
name|defined
argument_list|(
name|_WIN32
argument_list|)
end_if

begin_define
define|#
directive|define
name|SLASH_CHAR
value|'\\'
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SLASH_CHAR
value|'/'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SLASH_STRING
end_ifndef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__GO32__
argument_list|)
operator|||
name|defined
argument_list|(
name|_WIN32
argument_list|)
end_if

begin_define
define|#
directive|define
name|SLASH_STRING
value|"\\"
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SLASH_STRING
value|"/"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ROOTED_P
end_ifndef

begin_define
define|#
directive|define
name|ROOTED_P
parameter_list|(
name|X
parameter_list|)
value|(SLASH_P((X)[0]))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* On some systems, PIDGET is defined to extract the inferior pid from    an internal pid that has the thread id and pid in seperate bit    fields.  If not defined, then just use the entire internal pid as    the actual pid. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PIDGET
end_ifndef

begin_define
define|#
directive|define
name|PIDGET
parameter_list|(
name|pid
parameter_list|)
value|(pid)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* If under Cygwin, provide backwards compatibility with older    Cygwin compilers that don't define the current cpp define. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__CYGWIN32__
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|__CYGWIN__
end_ifndef

begin_define
define|#
directive|define
name|__CYGWIN__
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* #ifndef DEFS_H */
end_comment

end_unit

