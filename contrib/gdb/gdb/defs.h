begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* *INDENT-OFF* */
end_comment

begin_comment
comment|/* ATTR_FORMAT confuses indent, avoid running it for now */
end_comment

begin_comment
comment|/* Basic, host-specific, and target-specific definitions for GDB.    Copyright 1986, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996,    1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004    Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DEFS_H
end_ifndef

begin_define
define|#
directive|define
name|DEFS_H
end_define

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_comment
comment|/* Generated by configure.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_comment
comment|/* System call error return status.  */
end_comment

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STDDEF_H
end_ifdef

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_comment
comment|/* For size_t.  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* First include ansidecl.h so we can use the various macro definitions    here and in all subsequent file inclusions.  */
end_comment

begin_include
include|#
directive|include
file|"ansidecl.h"
end_include

begin_include
include|#
directive|include
file|"gdb_locale.h"
end_include

begin_comment
comment|/* For ``enum target_signal''.  */
end_comment

begin_include
include|#
directive|include
file|"gdb/signals.h"
end_include

begin_comment
comment|/* Just in case they're not defined in stdio.h.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SEEK_SET
end_ifndef

begin_define
define|#
directive|define
name|SEEK_SET
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SEEK_CUR
end_ifndef

begin_define
define|#
directive|define
name|SEEK_CUR
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_comment
comment|/* For va_list.  */
end_comment

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_comment
comment|/* For BFD64 and bfd_vma.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_comment
comment|/* The target is partially multi-arched.  Both "tm.h" and the    multi-arch vector provide definitions.  "tm.h" normally overrides    the multi-arch vector (but there are a few exceptions).  */
end_comment

begin_define
define|#
directive|define
name|GDB_MULTI_ARCH_PARTIAL
value|1
end_define

begin_comment
comment|/* The target is partially multi-arched. Both the multi-arch vector    and "tm.h" provide definitions. "tm.h" cannot override a definition    provided by the multi-arch vector.  It is detected as a compilation    error.     This setting is only useful during a multi-arch conversion. */
end_comment

begin_define
define|#
directive|define
name|GDB_MULTI_ARCH_TM
value|2
end_define

begin_comment
comment|/* The target is pure multi-arch.  The MULTI-ARCH vector provides all    definitions.  "tm.h" is linked to an empty file. */
end_comment

begin_define
define|#
directive|define
name|GDB_MULTI_ARCH_PURE
value|3
end_define

begin_comment
comment|/* An address in the program being debugged.  Host byte order.  Rather    than duplicate all the logic in BFD which figures out what type    this is (long, long long, etc.) and whether it needs to be 64    bits (the host/target interactions are subtle), we just use    bfd_vma.  */
end_comment

begin_typedef
typedef|typedef
name|bfd_vma
name|CORE_ADDR
typedef|;
end_typedef

begin_comment
comment|/* This is to make sure that LONGEST is at least as big as CORE_ADDR.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LONGEST
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|BFD64
end_ifdef

begin_define
define|#
directive|define
name|LONGEST
value|BFD_HOST_64_BIT
end_define

begin_define
define|#
directive|define
name|ULONGEST
value|BFD_HOST_U_64_BIT
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* No BFD64 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CC_HAS_LONG_LONG
end_ifdef

begin_define
define|#
directive|define
name|LONGEST
value|long long
end_define

begin_define
define|#
directive|define
name|ULONGEST
value|unsigned long long
end_define

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|BFD_HOST_64_BIT
end_ifdef

begin_comment
comment|/* BFD_HOST_64_BIT is defined for some hosts that don't have long long    (e.g. i386-windows) so try it.  */
end_comment

begin_define
define|#
directive|define
name|LONGEST
value|BFD_HOST_64_BIT
end_define

begin_define
define|#
directive|define
name|ULONGEST
value|BFD_HOST_U_64_BIT
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|LONGEST
value|long
end_define

begin_define
define|#
directive|define
name|ULONGEST
value|unsigned long
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* No BFD64 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! LONGEST */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|min
end_ifndef

begin_define
define|#
directive|define
name|min
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)< (b) ? (a) : (b))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|max
end_ifndef

begin_define
define|#
directive|define
name|max
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)> (b) ? (a) : (b))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Macros to do string compares.     NOTE: cagney/2000-03-14:     While old code can continue to refer to these macros, new code is    probably better off using strcmp() directly vis: ``strcmp() == 0''    and ``strcmp() != 0''.     This is because modern compilers can directly inline strcmp()    making the original justification for these macros - avoid function    call overhead by pre-testing the first characters    (``*X==*Y?...:0'') - redundant.     ``Even if [...] testing the first character does have a modest    performance improvement, I'd rather that whenever a performance    issue is found that we spend the effort on algorithmic    optimizations than micro-optimizing.'' J.T. */
end_comment

begin_comment
comment|/* NOTE: cagney/2003-11-23: All instances of STREQ[N] covered by    testing GDB on a stabs system have been replaced by equivalent    str[n]cmp calls.  To avoid the possability of introducing bugs when    making untested changes, the remaining references were deprecated    rather than replaced.  */
end_comment

begin_comment
comment|/* DISCLAIMER: cagney/2003-11-23: Simplified definition of these    macros so that they just map directly onto strcmp equivalent.  I'm    not responsible for any breakage due to code that relied on the old    underlying implementation.  */
end_comment

begin_define
define|#
directive|define
name|DEPRECATED_STREQ
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(strcmp ((a), (b)) == 0)
end_define

begin_define
define|#
directive|define
name|DEPRECATED_STREQN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|(strncmp ((a), (b), (c)) == 0)
end_define

begin_comment
comment|/* Check if a character is one of the commonly used C++ marker characters.  */
end_comment

begin_function_decl
specifier|extern
name|int
name|is_cplus_marker
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* enable xdb commands if set */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|xdb_commands
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* enable dbx commands if set */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|dbx_commands
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* System root path, used to find libraries etc.  */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|gdb_sysroot
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|quit_flag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|immediate_quit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|sevenbit_strings
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|void
name|quit
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* FIXME: cagney/2000-03-13: It has been suggested that the peformance    benefits of having a ``QUIT'' macro rather than a function are    marginal.  If the overhead of a QUIT function call is proving    significant then its calling frequency should probably be reduced    [kingdon].  A profile analyzing the current situtation is    needed. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|QUIT
end_ifdef

begin_comment
comment|/* do twice to force compiler warning */
end_comment

begin_define
define|#
directive|define
name|QUIT_FIXME
value|"FIXME"
end_define

begin_define
define|#
directive|define
name|QUIT_FIXME
value|"ignoring redefinition of QUIT"
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|QUIT
value|{ \   if (quit_flag) quit (); \   if (interactive_hook) interactive_hook (); \ }
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Languages represented in the symbol table and elsewhere.    This should probably be in language.h, but since enum's can't    be forward declared to satisfy opaque references before their    actual definition, needs to be here. */
end_comment

begin_enum
enum|enum
name|language
block|{
name|language_unknown
block|,
comment|/* Language not known */
name|language_auto
block|,
comment|/* Placeholder for automatic setting */
name|language_c
block|,
comment|/* C */
name|language_cplus
block|,
comment|/* C++ */
name|language_objc
block|,
comment|/* Objective-C */
name|language_java
block|,
comment|/* Java */
name|language_fortran
block|,
comment|/* Fortran */
name|language_m2
block|,
comment|/* Modula-2 */
name|language_asm
block|,
comment|/* Assembly language */
name|language_scm
block|,
comment|/* Scheme / Guile */
name|language_pascal
block|,
comment|/* Pascal */
name|language_minimal
comment|/* All other languages, minimal support only */
block|}
enum|;
end_enum

begin_enum
enum|enum
name|precision_type
block|{
name|single_precision
block|,
name|double_precision
block|,
name|unspecified_precision
block|}
enum|;
end_enum

begin_comment
comment|/* A generic, not quite boolean, enumeration.  */
end_comment

begin_enum
enum|enum
name|auto_boolean
block|{
name|AUTO_BOOLEAN_TRUE
block|,
name|AUTO_BOOLEAN_FALSE
block|,
name|AUTO_BOOLEAN_AUTO
block|}
enum|;
end_enum

begin_comment
comment|/* Potential ways that a function can return a value of a given type.  */
end_comment

begin_enum
enum|enum
name|return_value_convention
block|{
comment|/* Where the return value has been squeezed into one or more      registers.  */
name|RETURN_VALUE_REGISTER_CONVENTION
block|,
comment|/* Commonly known as the "struct return convention".  The caller      passes an additional hidden first parameter to the caller.  That      parameter contains the address at which the value being returned      should be stored.  While typically, and historically, used for      large structs, this is convention is applied to values of many      different types.  */
name|RETURN_VALUE_STRUCT_CONVENTION
block|}
enum|;
end_enum

begin_comment
comment|/* the cleanup list records things that have to be undone    if an error happens (descriptors to be closed, memory to be freed, etc.)    Each link in the chain records a function to call and an    argument to give it.     Use make_cleanup to add an element to the cleanup chain.    Use do_cleanups to do all cleanup actions back to a given    point in the chain.  Use discard_cleanups to remove cleanups    from the chain back to a given point, not doing them.  */
end_comment

begin_struct
struct|struct
name|cleanup
block|{
name|struct
name|cleanup
modifier|*
name|next
decl_stmt|;
name|void
function_decl|(
modifier|*
name|function
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
name|void
modifier|*
name|arg
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The ability to declare that a function never returns is useful, but    not really required to compile GDB successfully, so the NORETURN and    ATTR_NORETURN macros normally expand into nothing.  */
end_comment

begin_comment
comment|/* If compiling with older versions of GCC, a function may be declared    "volatile" to indicate that it does not return.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NORETURN
end_ifndef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
expr|\
operator|&&
operator|(
name|__GNUC__
operator|==
literal|1
operator|||
operator|(
name|__GNUC__
operator|==
literal|2
operator|&&
name|__GNUC_MINOR__
operator|<
literal|7
operator|)
operator|)
end_if

begin_define
define|#
directive|define
name|NORETURN
value|volatile
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|NORETURN
end_define

begin_comment
comment|/* nothing */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* GCC 2.5 and later versions define a function attribute "noreturn",    which is the preferred way to declare that a function never returns.    However GCC 2.7 appears to be the first version in which this fully    works everywhere we use it. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ATTR_NORETURN
end_ifndef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
operator|(
name|__GNUC__
operator|>
literal|2
operator|||
operator|(
name|__GNUC__
operator|==
literal|2
operator|&&
name|__GNUC_MINOR__
operator|>=
literal|7
operator|)
operator|)
end_if

begin_define
define|#
directive|define
name|ATTR_NORETURN
value|__attribute__ ((noreturn))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ATTR_NORETURN
end_define

begin_comment
comment|/* nothing */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ATTR_FORMAT
end_ifndef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
operator|(
name|__GNUC__
operator|>
literal|2
operator|||
operator|(
name|__GNUC__
operator|==
literal|2
operator|&&
name|__GNUC_MINOR__
operator|>=
literal|4
operator|)
operator|)
end_if

begin_define
define|#
directive|define
name|ATTR_FORMAT
parameter_list|(
name|type
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|)
value|__attribute__ ((format(type, x, y)))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ATTR_FORMAT
parameter_list|(
name|type
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|)
end_define

begin_comment
comment|/* nothing */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Be conservative and use enum bitfields only with GCC.    This is copied from gcc 3.3.1, system.h.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
operator|(
name|__GNUC__
operator|>=
literal|2
operator|)
end_if

begin_define
define|#
directive|define
name|ENUM_BITFIELD
parameter_list|(
name|TYPE
parameter_list|)
value|enum TYPE
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ENUM_BITFIELD
parameter_list|(
name|TYPE
parameter_list|)
value|unsigned int
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Needed for various prototypes */
end_comment

begin_struct_decl
struct_decl|struct
name|symtab
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|breakpoint
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|frame_info
struct_decl|;
end_struct_decl

begin_comment
comment|/* From blockframe.c */
end_comment

begin_function_decl
specifier|extern
name|int
name|inside_entry_func
parameter_list|(
name|struct
name|frame_info
modifier|*
name|this_frame
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|deprecated_inside_entry_file
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|inside_main_func
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* From utils.c */
end_comment

begin_function_decl
specifier|extern
name|void
name|initialize_utils
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|notice_quit
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|strcmp_iw
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|strcmp_iw_ordered
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|streq
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|subset_compare
parameter_list|(
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|safe_strerror
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|init_malloc
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|request_quit
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|do_cleanups
parameter_list|(
name|struct
name|cleanup
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|do_final_cleanups
parameter_list|(
name|struct
name|cleanup
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|do_run_cleanups
parameter_list|(
name|struct
name|cleanup
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|do_exec_cleanups
parameter_list|(
name|struct
name|cleanup
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|do_exec_error_cleanups
parameter_list|(
name|struct
name|cleanup
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|discard_cleanups
parameter_list|(
name|struct
name|cleanup
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|discard_final_cleanups
parameter_list|(
name|struct
name|cleanup
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|discard_exec_error_cleanups
parameter_list|(
name|struct
name|cleanup
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|discard_my_cleanups
parameter_list|(
name|struct
name|cleanup
modifier|*
modifier|*
parameter_list|,
name|struct
name|cleanup
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* NOTE: cagney/2000-03-04: This typedef is strictly for the    make_cleanup function declarations below. Do not use this typedef    as a cast when passing functions into the make_cleanup() code.    Instead either use a bounce function or add a wrapper function.    Calling a f(char*) function with f(void*) is non-portable. */
end_comment

begin_typedef
typedef|typedef
name|void
function_decl|(
name|make_cleanup_ftype
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_function_decl
specifier|extern
name|struct
name|cleanup
modifier|*
name|make_cleanup
parameter_list|(
name|make_cleanup_ftype
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|struct
name|cleanup
modifier|*
name|make_cleanup_freeargv
parameter_list|(
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_struct_decl
struct_decl|struct
name|ui_file
struct_decl|;
end_struct_decl

begin_function_decl
specifier|extern
name|struct
name|cleanup
modifier|*
name|make_cleanup_ui_file_delete
parameter_list|(
name|struct
name|ui_file
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|struct
name|cleanup
modifier|*
name|make_cleanup_close
parameter_list|(
name|int
name|fd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|struct
name|cleanup
modifier|*
name|make_cleanup_bfd_close
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|struct
name|cleanup
modifier|*
name|make_final_cleanup
parameter_list|(
name|make_cleanup_ftype
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|struct
name|cleanup
modifier|*
name|make_my_cleanup
parameter_list|(
name|struct
name|cleanup
modifier|*
modifier|*
parameter_list|,
name|make_cleanup_ftype
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|struct
name|cleanup
modifier|*
name|make_run_cleanup
parameter_list|(
name|make_cleanup_ftype
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|struct
name|cleanup
modifier|*
name|make_exec_cleanup
parameter_list|(
name|make_cleanup_ftype
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|struct
name|cleanup
modifier|*
name|make_exec_error_cleanup
parameter_list|(
name|make_cleanup_ftype
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|struct
name|cleanup
modifier|*
name|save_cleanups
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|struct
name|cleanup
modifier|*
name|save_final_cleanups
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|struct
name|cleanup
modifier|*
name|save_my_cleanups
parameter_list|(
name|struct
name|cleanup
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|restore_cleanups
parameter_list|(
name|struct
name|cleanup
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|restore_final_cleanups
parameter_list|(
name|struct
name|cleanup
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|restore_my_cleanups
parameter_list|(
name|struct
name|cleanup
modifier|*
modifier|*
parameter_list|,
name|struct
name|cleanup
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|free_current_contents
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|null_cleanup
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|myread
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|query
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
function_decl|ATTR_FORMAT
parameter_list|(
name|printf
parameter_list|,
function_decl|1
operator|,
function_decl|2
end_function_decl

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|extern
name|int
name|nquery
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
function_decl|ATTR_FORMAT
parameter_list|(
name|printf
parameter_list|,
function_decl|1
operator|,
function_decl|2
end_function_decl

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|extern
name|int
name|yquery
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
function_decl|ATTR_FORMAT
parameter_list|(
name|printf
parameter_list|,
function_decl|1
operator|,
function_decl|2
end_function_decl

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|extern
name|void
name|init_page_info
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|gdb_realpath
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|xfullpath
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|unsigned
name|long
name|gnu_debuglink_crc32
parameter_list|(
name|unsigned
name|long
name|crc
parameter_list|,
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* From demangle.c */
end_comment

begin_function_decl
specifier|extern
name|void
name|set_demangling_style
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* From tm.h */
end_comment

begin_struct_decl
struct_decl|struct
name|type
struct_decl|;
end_struct_decl

begin_typedef
typedef|typedef
name|int
function_decl|(
name|use_struct_convention_fn
function_decl|)
parameter_list|(
name|int
name|gcc_p
parameter_list|,
name|struct
name|type
modifier|*
name|value_type
parameter_list|)
function_decl|;
end_typedef

begin_decl_stmt
specifier|extern
name|use_struct_convention_fn
name|generic_use_struct_convention
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Annotation stuff.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|annotation_level
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* in stack.c */
end_comment

begin_escape
end_escape

begin_function_decl
specifier|extern
name|void
name|begin_line
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|wrap_here
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|reinitialize_more_filter
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Normal results */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|ui_file
modifier|*
name|gdb_stdout
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Input stream */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|ui_file
modifier|*
name|gdb_stdin
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Serious error notifications */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|ui_file
modifier|*
name|gdb_stderr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Log/debug/trace messages that should bypass normal stdout/stderr    filtering.  For moment, always call this stream using    *_unfiltered. In the very near future that restriction shall be    removed - either call shall be unfiltered. (cagney 1999-06-13). */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|ui_file
modifier|*
name|gdb_stdlog
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Target output that should bypass normal stdout/stderr filtering.    For moment, always call this stream using *_unfiltered. In the    very near future that restriction shall be removed - either call    shall be unfiltered. (cagney 1999-07-02). */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|ui_file
modifier|*
name|gdb_stdtarg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|ui_file
modifier|*
name|gdb_stdtargerr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|ui_file
modifier|*
name|gdb_stdtargin
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|"ui-file.h"
end_include

begin_comment
comment|/* More generic printf like operations.  Filtered versions may return    non-locally on error.  */
end_comment

begin_function_decl
specifier|extern
name|void
name|fputs_filtered
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|struct
name|ui_file
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|fputs_unfiltered
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|struct
name|ui_file
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|fputc_filtered
parameter_list|(
name|int
name|c
parameter_list|,
name|struct
name|ui_file
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|fputc_unfiltered
parameter_list|(
name|int
name|c
parameter_list|,
name|struct
name|ui_file
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|putchar_filtered
parameter_list|(
name|int
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|putchar_unfiltered
parameter_list|(
name|int
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|puts_filtered
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|puts_unfiltered
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|puts_filtered_tabular
parameter_list|(
name|char
modifier|*
name|string
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|right
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|puts_debug
parameter_list|(
name|char
modifier|*
name|prefix
parameter_list|,
name|char
modifier|*
name|string
parameter_list|,
name|char
modifier|*
name|suffix
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|vprintf_filtered
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|va_list
parameter_list|)
function_decl|ATTR_FORMAT
parameter_list|(
name|printf
parameter_list|,
function_decl|1
operator|,
function_decl|0
end_function_decl

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|extern
name|void
name|vfprintf_filtered
parameter_list|(
name|struct
name|ui_file
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|va_list
parameter_list|)
function_decl|ATTR_FORMAT
parameter_list|(
name|printf
parameter_list|,
function_decl|2
operator|,
function_decl|0
end_function_decl

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|extern
name|void
name|fprintf_filtered
parameter_list|(
name|struct
name|ui_file
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
function_decl|ATTR_FORMAT
parameter_list|(
name|printf
parameter_list|,
function_decl|2
operator|,
function_decl|3
end_function_decl

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|extern
name|void
name|fprintfi_filtered
parameter_list|(
name|int
parameter_list|,
name|struct
name|ui_file
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
function_decl|ATTR_FORMAT
parameter_list|(
name|printf
parameter_list|,
function_decl|3
operator|,
function_decl|4
end_function_decl

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|extern
name|void
name|printf_filtered
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
function_decl|ATTR_FORMAT
parameter_list|(
name|printf
parameter_list|,
function_decl|1
operator|,
function_decl|2
end_function_decl

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|extern
name|void
name|printfi_filtered
parameter_list|(
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
function_decl|ATTR_FORMAT
parameter_list|(
name|printf
parameter_list|,
function_decl|2
operator|,
function_decl|3
end_function_decl

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|extern
name|void
name|vprintf_unfiltered
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|va_list
parameter_list|)
function_decl|ATTR_FORMAT
parameter_list|(
name|printf
parameter_list|,
function_decl|1
operator|,
function_decl|0
end_function_decl

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|extern
name|void
name|vfprintf_unfiltered
parameter_list|(
name|struct
name|ui_file
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|va_list
parameter_list|)
function_decl|ATTR_FORMAT
parameter_list|(
name|printf
parameter_list|,
function_decl|2
operator|,
function_decl|0
end_function_decl

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|extern
name|void
name|fprintf_unfiltered
parameter_list|(
name|struct
name|ui_file
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
function_decl|ATTR_FORMAT
parameter_list|(
name|printf
parameter_list|,
function_decl|2
operator|,
function_decl|3
end_function_decl

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|extern
name|void
name|printf_unfiltered
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
function_decl|ATTR_FORMAT
parameter_list|(
name|printf
parameter_list|,
function_decl|1
operator|,
function_decl|2
end_function_decl

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|extern
name|void
name|print_spaces
parameter_list|(
name|int
parameter_list|,
name|struct
name|ui_file
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|print_spaces_filtered
parameter_list|(
name|int
parameter_list|,
name|struct
name|ui_file
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|n_spaces
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|fputstr_filtered
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|int
name|quotr
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|fputstr_unfiltered
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|int
name|quotr
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|fputstrn_unfiltered
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|int
name|n
parameter_list|,
name|int
name|quotr
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Display the host ADDR on STREAM formatted as ``0x%x''. */
end_comment

begin_function_decl
specifier|extern
name|void
name|gdb_print_host_address
parameter_list|(
specifier|const
name|void
modifier|*
name|addr
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Convert a CORE_ADDR into a HEX string.  paddr() is like %08lx.    paddr_nz() is like %lx.  paddr_u() is like %lu. paddr_width() is    for ``%*''. */
end_comment

begin_function_decl
specifier|extern
name|int
name|strlen_paddr
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|paddr
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|paddr_nz
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|paddr_u
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|paddr_d
parameter_list|(
name|LONGEST
name|addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|phex
parameter_list|(
name|ULONGEST
name|l
parameter_list|,
name|int
name|sizeof_l
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|phex_nz
parameter_list|(
name|ULONGEST
name|l
parameter_list|,
name|int
name|sizeof_l
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Like paddr() only print/scan raw CORE_ADDR.  The output from    core_addr_to_string() can be passed direct to    string_to_core_addr().  */
end_comment

begin_function_decl
specifier|extern
specifier|const
name|char
modifier|*
name|core_addr_to_string
parameter_list|(
specifier|const
name|CORE_ADDR
name|addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
specifier|const
name|char
modifier|*
name|core_addr_to_string_nz
parameter_list|(
specifier|const
name|CORE_ADDR
name|addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|CORE_ADDR
name|string_to_core_addr
parameter_list|(
specifier|const
name|char
modifier|*
name|my_string
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|fprintf_symbol_filtered
parameter_list|(
name|struct
name|ui_file
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|enum
name|language
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|NORETURN
name|void
name|perror_with_name
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
name|ATTR_NORETURN
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|void
name|print_sys_errmsg
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* From regex.c or libc.  BSD 4.4 declares this with the argument type as    "const char *" in unistd.h, so we can't declare the argument    as "char *".  */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|re_comp
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* From symfile.c */
end_comment

begin_function_decl
specifier|extern
name|void
name|symbol_file_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Remote targets may wish to use this as their load function.  */
end_comment

begin_function_decl
specifier|extern
name|void
name|generic_load
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|from_tty
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Summarise a download */
end_comment

begin_function_decl
specifier|extern
name|void
name|print_transfer_performance
parameter_list|(
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|unsigned
name|long
name|data_count
parameter_list|,
name|unsigned
name|long
name|write_count
parameter_list|,
name|unsigned
name|long
name|time_count
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* From top.c */
end_comment

begin_typedef
typedef|typedef
name|void
name|initialize_file_ftype
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_typedef

begin_function_decl
specifier|extern
name|char
modifier|*
name|skip_quoted
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|gdb_readline
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|gdb_readline_wrapper
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|command_line_input
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|print_prompt
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|input_from_terminal_p
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|int
name|info_verbose
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* From printcmd.c */
end_comment

begin_function_decl
specifier|extern
name|void
name|set_next_address
parameter_list|(
name|CORE_ADDR
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|print_address_symbolic
parameter_list|(
name|CORE_ADDR
parameter_list|,
name|struct
name|ui_file
modifier|*
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|build_address_symbolic
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|int
name|do_demangle
parameter_list|,
name|char
modifier|*
modifier|*
name|name
parameter_list|,
name|int
modifier|*
name|offset
parameter_list|,
name|char
modifier|*
modifier|*
name|filename
parameter_list|,
name|int
modifier|*
name|line
parameter_list|,
name|int
modifier|*
name|unmapped
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|print_address_numeric
parameter_list|(
name|CORE_ADDR
parameter_list|,
name|int
parameter_list|,
name|struct
name|ui_file
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|print_address
parameter_list|(
name|CORE_ADDR
parameter_list|,
name|struct
name|ui_file
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* From source.c */
end_comment

begin_function_decl
specifier|extern
name|int
name|openp
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|source_full_path_of
parameter_list|(
name|char
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|mod_path
parameter_list|(
name|char
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|add_path
parameter_list|(
name|char
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|directory_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|source_path
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|void
name|init_source_path
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|init_last_source_visited
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|symtab_to_filename
parameter_list|(
name|struct
name|symtab
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* From exec.c */
end_comment

begin_function_decl
specifier|extern
name|void
name|exec_set_section_offsets
parameter_list|(
name|bfd_signed_vma
name|text_off
parameter_list|,
name|bfd_signed_vma
name|data_off
parameter_list|,
name|bfd_signed_vma
name|bss_off
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Take over the 'find_mapped_memory' vector from exec.c. */
end_comment

begin_function_decl
specifier|extern
name|void
name|exec_set_find_memory_regions
parameter_list|(
name|int
function_decl|(
modifier|*
function_decl|)
parameter_list|(
name|int
function_decl|(
modifier|*
function_decl|)
parameter_list|(
name|CORE_ADDR
parameter_list|,
name|unsigned
name|long
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Possible lvalue types.  Like enum language, this should be in    value.h, but needs to be here for the same reason. */
end_comment

begin_enum
enum|enum
name|lval_type
block|{
comment|/* Not an lval. */
name|not_lval
block|,
comment|/* In memory.  Could be a saved register.  */
name|lval_memory
block|,
comment|/* In a register.  */
name|lval_register
block|,
comment|/* In a gdb internal variable.  */
name|lval_internalvar
block|,
comment|/* Part of a gdb internal variable (structure field).  */
name|lval_internalvar_component
block|,
comment|/* In a register series in a frame not the current one, which may have been        partially saved or saved in different places (otherwise would be        lval_register or lval_memory).  */
name|lval_reg_frame_relative
block|}
enum|;
end_enum

begin_comment
comment|/* Control types for commands */
end_comment

begin_enum
enum|enum
name|misc_command_type
block|{
name|ok_command
block|,
name|end_command
block|,
name|else_command
block|,
name|nop_command
block|}
enum|;
end_enum

begin_enum
enum|enum
name|command_control_type
block|{
name|simple_control
block|,
name|break_control
block|,
name|continue_control
block|,
name|while_control
block|,
name|if_control
block|,
name|invalid_control
block|}
enum|;
end_enum

begin_comment
comment|/* Structure for saved commands lines    (for breakpoints, defined commands, etc).  */
end_comment

begin_struct
struct|struct
name|command_line
block|{
name|struct
name|command_line
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|;
name|enum
name|command_control_type
name|control_type
decl_stmt|;
name|int
name|body_count
decl_stmt|;
name|struct
name|command_line
modifier|*
modifier|*
name|body_list
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|extern
name|struct
name|command_line
modifier|*
name|read_command_lines
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|free_command_lines
parameter_list|(
name|struct
name|command_line
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* To continue the execution commands when running gdb asynchronously.     A continuation structure contains a pointer to a function to be called     to finish the command, once the target has stopped. Such mechanism is    used bt the finish and until commands, and in the remote protocol    when opening an extended-remote connection. */
end_comment

begin_struct
struct|struct
name|continuation_arg
block|{
name|struct
name|continuation_arg
modifier|*
name|next
decl_stmt|;
union|union
name|continuation_data
block|{
name|void
modifier|*
name|pointer
decl_stmt|;
name|int
name|integer
decl_stmt|;
name|long
name|longint
decl_stmt|;
block|}
name|data
union|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|continuation
block|{
name|void
function_decl|(
modifier|*
name|continuation_hook
function_decl|)
parameter_list|(
name|struct
name|continuation_arg
modifier|*
parameter_list|)
function_decl|;
name|struct
name|continuation_arg
modifier|*
name|arg_list
decl_stmt|;
name|struct
name|continuation
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* In infrun.c. */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|continuation
modifier|*
name|cmd_continuation
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used only by the step_1 function. */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|continuation
modifier|*
name|intermediate_continuation
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* From utils.c */
end_comment

begin_function_decl
specifier|extern
name|void
name|add_continuation
parameter_list|(
name|void
function_decl|(
modifier|*
function_decl|)
parameter_list|(
name|struct
name|continuation_arg
modifier|*
parameter_list|)
parameter_list|,
name|struct
name|continuation_arg
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|do_all_continuations
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|discard_all_continuations
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|add_intermediate_continuation
parameter_list|(
name|void
function_decl|(
modifier|*
function_decl|)
parameter_list|(
name|struct
name|continuation_arg
modifier|*
parameter_list|)
parameter_list|,
name|struct
name|continuation_arg
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|do_all_intermediate_continuations
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|discard_all_intermediate_continuations
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* String containing the current directory (what getwd would return).  */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|current_directory
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default radixes for input and output.  Only some values supported.  */
end_comment

begin_decl_stmt
specifier|extern
name|unsigned
name|input_radix
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|unsigned
name|output_radix
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Possibilities for prettyprint parameters to routines which print    things.  Like enum language, this should be in value.h, but needs    to be here for the same reason.  FIXME:  If we can eliminate this    as an arg to LA_VAL_PRINT, then we can probably move it back to    value.h. */
end_comment

begin_enum
enum|enum
name|val_prettyprint
block|{
name|Val_no_prettyprint
init|=
literal|0
block|,
name|Val_prettyprint
block|,
comment|/* Use the default setting which the user has specified.  */
name|Val_pretty_default
block|}
enum|;
end_enum

begin_comment
comment|/* The ptid struct is a collection of the various "ids" necessary    for identifying the inferior.  This consists of the process id    (pid), thread id (tid), and other fields necessary for uniquely    identifying the inferior process/thread being debugged.  When    manipulating ptids, the constructors, accessors, and predicate    declared in inferior.h should be used.  These are as follows:        ptid_build	- Make a new ptid from a pid, lwp, and tid.       pid_to_ptid	- Make a new ptid from just a pid.       ptid_get_pid	- Fetch the pid component of a ptid.       ptid_get_lwp	- Fetch the lwp component of a ptid.       ptid_get_tid	- Fetch the tid component of a ptid.       ptid_equal	- Test to see if two ptids are equal.     Please do NOT access the struct ptid members directly (except, of    course, in the implementation of the above ptid manipulation    functions).  */
end_comment

begin_struct
struct|struct
name|ptid
block|{
comment|/* Process id */
name|int
name|pid
decl_stmt|;
comment|/* Lightweight process id */
name|long
name|lwp
decl_stmt|;
comment|/* Thread id */
name|long
name|tid
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|ptid
name|ptid_t
typedef|;
end_typedef

begin_escape
end_escape

begin_comment
comment|/* Optional host machine definition.  Pure autoconf targets will not    need a "xm.h" file.  This will be a symlink to one of the xm-*.h    files, built by the `configure' script.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|GDB_XM_FILE
end_ifdef

begin_include
include|#
directive|include
file|"xm.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Optional native machine support.  Non-native (and possibly pure    multi-arch) targets do not need a "nm.h" file.  This will be a    symlink to one of the nm-*.h files, built by the `configure'    script.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|GDB_NM_FILE
end_ifdef

begin_include
include|#
directive|include
file|"nm.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Optional target machine definition.  Pure multi-arch configurations    do not need a "tm.h" file.  This will be a symlink to one of the    tm-*.h files, built by the `configure' script.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|GDB_TM_FILE
end_ifdef

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* If the xm.h file did not define the mode string used to open the    files, assume that binary files are opened the same way as text    files */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|FOPEN_RB
end_ifndef

begin_include
include|#
directive|include
file|"fopen-same.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Defaults for system-wide constants (if not defined by xm.h, we fake it).    FIXME: Assumes 2's complement arithmetic */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|UINT_MAX
argument_list|)
end_if

begin_define
define|#
directive|define
name|UINT_MAX
value|((unsigned int)(~0))
end_define

begin_comment
comment|/* 0xFFFFFFFF for 32-bits */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|INT_MAX
argument_list|)
end_if

begin_define
define|#
directive|define
name|INT_MAX
value|((int)(UINT_MAX>> 1))
end_define

begin_comment
comment|/* 0x7FFFFFFF for 32-bits */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|INT_MIN
argument_list|)
end_if

begin_define
define|#
directive|define
name|INT_MIN
value|((int)((int) ~0 ^ INT_MAX))
end_define

begin_comment
comment|/* 0x80000000 for 32-bits */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|ULONG_MAX
argument_list|)
end_if

begin_define
define|#
directive|define
name|ULONG_MAX
value|((unsigned long)(~0L))
end_define

begin_comment
comment|/* 0xFFFFFFFF for 32-bits */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|LONG_MAX
argument_list|)
end_if

begin_define
define|#
directive|define
name|LONG_MAX
value|((long)(ULONG_MAX>> 1))
end_define

begin_comment
comment|/* 0x7FFFFFFF for 32-bits */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|ULONGEST_MAX
argument_list|)
end_if

begin_define
define|#
directive|define
name|ULONGEST_MAX
value|(~(ULONGEST)0)
end_define

begin_comment
comment|/* 0xFFFFFFFFFFFFFFFF for 64-bits */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|LONGEST_MAX
argument_list|)
end_if

begin_comment
comment|/* 0x7FFFFFFFFFFFFFFF for 64-bits */
end_comment

begin_define
define|#
directive|define
name|LONGEST_MAX
value|((LONGEST)(ULONGEST_MAX>> 1))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Convert a LONGEST to an int.  This is used in contexts (e.g. number of    arguments to a function, number in a value history, register number, etc.)    where the value must not be larger than can fit in an int.  */
end_comment

begin_function_decl
specifier|extern
name|int
name|longest_to_int
parameter_list|(
name|LONGEST
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Assorted functions we can declare, now that const and volatile are     defined.  */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|savestring
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|msavestring
parameter_list|(
name|void
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|mstrsave
parameter_list|(
name|void
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Robust versions of same.  Throw an internal error when no memory,    guard against stray NULL arguments. */
end_comment

begin_function_decl
specifier|extern
name|void
modifier|*
name|xmmalloc
parameter_list|(
name|void
modifier|*
name|md
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
modifier|*
name|xmrealloc
parameter_list|(
name|void
modifier|*
name|md
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
modifier|*
name|xmcalloc
parameter_list|(
name|void
modifier|*
name|md
parameter_list|,
name|size_t
name|number
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|xmfree
parameter_list|(
name|void
modifier|*
name|md
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* xmalloc(), xrealloc() and xcalloc() have already been declared in    "libiberty.h". */
end_comment

begin_function_decl
specifier|extern
name|void
name|xfree
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Utility macros to allocate typed memory.  Avoids errors like:    struct foo *foo = xmalloc (sizeof struct bar); and memset (foo,    sizeof (struct foo), 0).  */
end_comment

begin_define
define|#
directive|define
name|XZALLOC
parameter_list|(
name|TYPE
parameter_list|)
value|((TYPE*) memset (xmalloc (sizeof (TYPE)), 0, sizeof (TYPE)))
end_define

begin_define
define|#
directive|define
name|XMALLOC
parameter_list|(
name|TYPE
parameter_list|)
value|((TYPE*) xmalloc (sizeof (TYPE)))
end_define

begin_define
define|#
directive|define
name|XCALLOC
parameter_list|(
name|NMEMB
parameter_list|,
name|TYPE
parameter_list|)
value|((TYPE*) xcalloc ((NMEMB), sizeof (TYPE)))
end_define

begin_comment
comment|/* Like asprintf/vasprintf but get an internal_error if the call    fails. */
end_comment

begin_function_decl
specifier|extern
name|void
name|xasprintf
parameter_list|(
name|char
modifier|*
modifier|*
name|ret
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
function_decl|ATTR_FORMAT
parameter_list|(
name|printf
parameter_list|,
function_decl|2
operator|,
function_decl|3
end_function_decl

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|extern
name|void
name|xvasprintf
parameter_list|(
name|char
modifier|*
modifier|*
name|ret
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|va_list
name|ap
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Like asprintf, but return the string, throw an error if no memory.  */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|xstrprintf
parameter_list|(
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
function_decl|ATTR_FORMAT
parameter_list|(
name|printf
parameter_list|,
function_decl|1
operator|,
function_decl|2
end_function_decl

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|extern
name|int
name|parse_escape
parameter_list|(
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Message to be printed before the error message, when an error occurs.  */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|error_pre_print
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Message to be printed before the error message, when an error occurs.  */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|quit_pre_print
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Message to be printed before the warning message, when a warning occurs.  */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|warning_pre_print
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|NORETURN
name|void
name|verror
argument_list|(
specifier|const
name|char
operator|*
name|fmt
argument_list|,
name|va_list
name|ap
argument_list|)
name|ATTR_NORETURN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|NORETURN
name|void
name|error
argument_list|(
specifier|const
name|char
operator|*
name|fmt
argument_list|,
operator|...
argument_list|)
name|ATTR_NORETURN
name|ATTR_FORMAT
argument_list|(
name|printf
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|NORETURN
name|void
name|error_silent
argument_list|(
specifier|const
name|char
operator|*
name|fmt
argument_list|,
operator|...
argument_list|)
name|ATTR_NORETURN
name|ATTR_FORMAT
argument_list|(
name|printf
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|NORETURN
name|void
name|error_stream
argument_list|(
expr|struct
name|ui_file
operator|*
argument_list|)
name|ATTR_NORETURN
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize the error buffer.  */
end_comment

begin_function_decl
specifier|extern
name|void
name|error_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Returns a freshly allocate buffer containing the last error    message.  */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|error_last_message
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Output arbitrary error message.  */
end_comment

begin_function_decl
specifier|extern
name|void
name|error_output_message
parameter_list|(
name|char
modifier|*
name|pre_print
parameter_list|,
name|char
modifier|*
name|msg
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|NORETURN
name|void
name|internal_verror
argument_list|(
specifier|const
name|char
operator|*
name|file
argument_list|,
name|int
name|line
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|va_list
name|ap
argument_list|)
name|ATTR_NORETURN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|NORETURN
name|void
name|internal_error
argument_list|(
specifier|const
name|char
operator|*
name|file
argument_list|,
name|int
name|line
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
operator|...
argument_list|)
name|ATTR_NORETURN
name|ATTR_FORMAT
argument_list|(
name|printf
argument_list|,
literal|3
argument_list|,
literal|4
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|void
name|internal_vwarning
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|va_list
name|ap
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|internal_warning
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
function_decl|ATTR_FORMAT
parameter_list|(
name|printf
parameter_list|,
function_decl|3
operator|,
function_decl|4
end_function_decl

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_decl_stmt
specifier|extern
name|NORETURN
name|void
name|nomem
argument_list|(
name|long
argument_list|)
name|ATTR_NORETURN
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Reasons for calling throw_exception().  NOTE: all reason values    must be less than zero.  enum value 0 is reserved for internal use    as the return value from an initial setjmp().  The function    catch_exceptions() reserves values>= 0 as legal results from its    wrapped function.  */
end_comment

begin_enum
enum|enum
name|return_reason
block|{
comment|/* User interrupt.  */
name|RETURN_QUIT
init|=
operator|-
literal|2
block|,
comment|/* Any other error.  */
name|RETURN_ERROR
block|}
enum|;
end_enum

begin_define
define|#
directive|define
name|ALL_CLEANUPS
value|((struct cleanup *)0)
end_define

begin_define
define|#
directive|define
name|RETURN_MASK
parameter_list|(
name|reason
parameter_list|)
value|(1<< (int)(-reason))
end_define

begin_define
define|#
directive|define
name|RETURN_MASK_QUIT
value|RETURN_MASK (RETURN_QUIT)
end_define

begin_define
define|#
directive|define
name|RETURN_MASK_ERROR
value|RETURN_MASK (RETURN_ERROR)
end_define

begin_define
define|#
directive|define
name|RETURN_MASK_ALL
value|(RETURN_MASK_QUIT | RETURN_MASK_ERROR)
end_define

begin_typedef
typedef|typedef
name|int
name|return_mask
typedef|;
end_typedef

begin_comment
comment|/* Throw an exception of type RETURN_REASON.  Will execute a LONG JUMP    to the inner most containing exception handler established using    catch_exceptions() (or the legacy catch_errors()).     Code normally throws an exception using error() et.al.  For various    reaons, GDB also contains code that throws an exception directly.    For instance, the remote*.c targets contain CNTRL-C signal handlers    that propogate the QUIT event up the exception chain.  ``This could    be a good thing or a dangerous thing.'' -- the Existential Wombat.  */
end_comment

begin_decl_stmt
specifier|extern
name|NORETURN
name|void
name|throw_exception
argument_list|(
expr|enum
name|return_reason
argument_list|)
name|ATTR_NORETURN
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Call FUNC(UIOUT, FUNC_ARGS) but wrapped within an exception    handler.  If an exception (enum return_reason) is thrown using    throw_exception() than all cleanups installed since    catch_exceptions() was entered are invoked, the (-ve) exception    value is then returned by catch_exceptions.  If FUNC() returns    normally (with a postive or zero return value) then that value is    returned by catch_exceptions().  It is an internal_error() for    FUNC() to return a negative value.     For the period of the FUNC() call: UIOUT is installed as the output    builder; ERRSTRING is installed as the error/quit message; and a    new cleanup_chain is established.  The old values are restored    before catch_exceptions() returns.     The variant catch_exceptions_with_msg() is the same as    catch_exceptions() but adds the ability to return an allocated    copy of the gdb error message.  This is used when a silent error is     issued and the caller wants to manually issue the error message.     FIXME; cagney/2001-08-13: The need to override the global UIOUT    builder variable should just go away.     This function superseeds catch_errors().     This function uses SETJMP() and LONGJUMP().  */
end_comment

begin_struct_decl
struct_decl|struct
name|ui_out
struct_decl|;
end_struct_decl

begin_typedef
typedef|typedef
name|int
function_decl|(
name|catch_exceptions_ftype
function_decl|)
parameter_list|(
name|struct
name|ui_out
modifier|*
name|ui_out
parameter_list|,
name|void
modifier|*
name|args
parameter_list|)
function_decl|;
end_typedef

begin_function_decl
specifier|extern
name|int
name|catch_exceptions
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
name|catch_exceptions_ftype
modifier|*
name|func
parameter_list|,
name|void
modifier|*
name|func_args
parameter_list|,
name|char
modifier|*
name|errstring
parameter_list|,
name|return_mask
name|mask
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|catch_exceptions_with_msg
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
name|catch_exceptions_ftype
modifier|*
name|func
parameter_list|,
name|void
modifier|*
name|func_args
parameter_list|,
name|char
modifier|*
name|errstring
parameter_list|,
name|char
modifier|*
modifier|*
name|gdberrmsg
parameter_list|,
name|return_mask
name|mask
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* If CATCH_ERRORS_FTYPE throws an error, catch_errors() returns zero    otherwize the result from CATCH_ERRORS_FTYPE is returned. It is    probably useful for CATCH_ERRORS_FTYPE to always return a non-zero    value. It's unfortunate that, catch_errors() does not return an    indication of the exact exception that it caught - quit_flag might    help.     This function is superseeded by catch_exceptions().  */
end_comment

begin_typedef
typedef|typedef
name|int
function_decl|(
name|catch_errors_ftype
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_function_decl
specifier|extern
name|int
name|catch_errors
parameter_list|(
name|catch_errors_ftype
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|return_mask
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Template to catch_errors() that wraps calls to command    functions. */
end_comment

begin_typedef
typedef|typedef
name|void
function_decl|(
name|catch_command_errors_ftype
function_decl|)
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_typedef

begin_function_decl
specifier|extern
name|int
name|catch_command_errors
parameter_list|(
name|catch_command_errors_ftype
modifier|*
name|func
parameter_list|,
name|char
modifier|*
name|command
parameter_list|,
name|int
name|from_tty
parameter_list|,
name|return_mask
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|warning
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
function_decl|ATTR_FORMAT
parameter_list|(
name|printf
parameter_list|,
function_decl|1
operator|,
function_decl|2
end_function_decl

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|extern
name|void
name|vwarning
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|va_list
name|args
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* List of known OS ABIs.  If you change this, make sure to update the    table in osabi.c.  */
end_comment

begin_enum
enum|enum
name|gdb_osabi
block|{
name|GDB_OSABI_UNINITIALIZED
init|=
operator|-
literal|1
block|,
comment|/* For struct gdbarch_info.  */
name|GDB_OSABI_UNKNOWN
init|=
literal|0
block|,
comment|/* keep this zero */
name|GDB_OSABI_SVR4
block|,
name|GDB_OSABI_HURD
block|,
name|GDB_OSABI_SOLARIS
block|,
name|GDB_OSABI_OSF1
block|,
name|GDB_OSABI_LINUX
block|,
name|GDB_OSABI_FREEBSD_AOUT
block|,
name|GDB_OSABI_FREEBSD_ELF
block|,
name|GDB_OSABI_NETBSD_AOUT
block|,
name|GDB_OSABI_NETBSD_ELF
block|,
name|GDB_OSABI_OPENBSD_ELF
block|,
name|GDB_OSABI_WINCE
block|,
name|GDB_OSABI_GO32
block|,
name|GDB_OSABI_NETWARE
block|,
name|GDB_OSABI_IRIX
block|,
name|GDB_OSABI_LYNXOS
block|,
name|GDB_OSABI_INTERIX
block|,
name|GDB_OSABI_HPUX_ELF
block|,
name|GDB_OSABI_HPUX_SOM
block|,
name|GDB_OSABI_ARM_EABI_V1
block|,
name|GDB_OSABI_ARM_EABI_V2
block|,
name|GDB_OSABI_ARM_APCS
block|,
name|GDB_OSABI_QNXNTO
block|,
name|GDB_OSABI_CYGWIN
block|,
name|GDB_OSABI_INVALID
comment|/* keep this last */
block|}
enum|;
end_enum

begin_comment
comment|/* Global functions from other, non-gdb GNU thingies.    Libiberty thingies are no longer declared here.  We include libiberty.h    above, instead.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|GETENV_PROVIDED
end_ifndef

begin_function_decl
specifier|extern
name|char
modifier|*
name|getenv
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* From other system libraries */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STDDEF_H
end_ifdef

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STDLIB_H
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|min
end_ifndef

begin_define
define|#
directive|define
name|min
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)< (b) ? (a) : (b))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|max
end_ifndef

begin_define
define|#
directive|define
name|max
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)> (b) ? (a) : (b))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* We take the address of fclose later, but some stdio's forget    to declare this.  We can't always declare it since there's    no way to declare the parameters without upsetting some compiler    somewhere. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|FCLOSE_PROVIDED
end_ifndef

begin_function_decl
specifier|extern
name|int
name|fclose
parameter_list|(
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|atof
end_ifndef

begin_function_decl
specifier|extern
name|double
name|atof
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* X3.159-1989  4.10.1.1 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Various possibilities for alloca.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|alloca
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_define
define|#
directive|define
name|alloca
value|__builtin_alloca
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Not GNU C */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ALLOCA_H
end_ifdef

begin_include
include|#
directive|include
file|<alloca.h>
end_include

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|_AIX
end_ifdef

begin_pragma
pragma|#
directive|pragma
name|alloca
end_pragma

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* We need to be careful not to declare this in a way which conflicts with    bison.  Bison never declares it as char *, but under various circumstances    (like __hpux) we need to use void *.  */
end_comment

begin_function_decl
specifier|extern
name|void
modifier|*
name|alloca
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Not _AIX */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Not HAVE_ALLOCA_H */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Not GNU C */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* alloca not defined */
end_comment

begin_comment
comment|/* Is GDB multi-arch?  If there's a "tm.h" file, it is not.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|GDB_MULTI_ARCH
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|GDB_TM_FILE
end_ifdef

begin_define
define|#
directive|define
name|GDB_MULTI_ARCH
value|GDB_MULTI_ARCH_PARTIAL
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|GDB_MULTI_ARCH
value|GDB_MULTI_ARCH_PURE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Dynamic target-system-dependent parameters for GDB. */
end_comment

begin_include
include|#
directive|include
file|"gdbarch.h"
end_include

begin_comment
comment|/* Maximum size of a register.  Something small, but large enough for    all known ISAs.  If it turns out to be too small, make it bigger.  */
end_comment

begin_enum
enum|enum
block|{
name|MAX_REGISTER_SIZE
init|=
literal|16
block|}
enum|;
end_enum

begin_comment
comment|/* Static target-system-dependent parameters for GDB. */
end_comment

begin_comment
comment|/* Number of bits in a char or unsigned char for the target machine.    Just like CHAR_BIT in<limits.h> but describes the target machine.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|TARGET_CHAR_BIT
argument_list|)
end_if

begin_define
define|#
directive|define
name|TARGET_CHAR_BIT
value|8
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* If we picked up a copy of CHAR_BIT from a configuration file    (which may get it by including<limits.h>) then use it to set    the number of bits in a host char.  If not, use the same size    as the target. */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CHAR_BIT
argument_list|)
end_if

begin_define
define|#
directive|define
name|HOST_CHAR_BIT
value|CHAR_BIT
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|HOST_CHAR_BIT
value|TARGET_CHAR_BIT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The bit byte-order has to do just with numbering of bits in    debugging symbols and such.  Conceptually, it's quite separate    from byte/word byte order.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|BITS_BIG_ENDIAN
argument_list|)
end_if

begin_define
define|#
directive|define
name|BITS_BIG_ENDIAN
value|(TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* In findvar.c.  */
end_comment

begin_function_decl
specifier|extern
name|LONGEST
name|extract_signed_integer
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|ULONGEST
name|extract_unsigned_integer
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|extract_long_unsigned_integer
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|LONGEST
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|CORE_ADDR
name|extract_typed_address
parameter_list|(
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|store_signed_integer
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|LONGEST
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|store_unsigned_integer
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|ULONGEST
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|store_typed_address
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|CORE_ADDR
name|addr
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* From valops.c */
end_comment

begin_function_decl
specifier|extern
name|CORE_ADDR
name|push_bytes
parameter_list|(
name|CORE_ADDR
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|CORE_ADDR
name|push_word
parameter_list|(
name|CORE_ADDR
parameter_list|,
name|ULONGEST
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|int
name|watchdog
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Hooks for alternate command interfaces.  */
end_comment

begin_comment
comment|/* The name of the interpreter if specified on the command line. */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|interpreter_p
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If a given interpreter matches INTERPRETER_P then it should update    command_loop_hook and init_ui_hook with the per-interpreter    implementation. */
end_comment

begin_comment
comment|/* FIXME: command_loop_hook and init_ui_hook should be moved here. */
end_comment

begin_struct_decl
struct_decl|struct
name|target_waitstatus
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|cmd_list_element
struct_decl|;
end_struct_decl

begin_comment
comment|/* Should the asynchronous variant of the interpreter (using the    event-loop) be enabled? */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|event_loop_p
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|void
function_decl|(
modifier|*
name|init_ui_hook
function_decl|)
parameter_list|(
name|char
modifier|*
name|argv0
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
function_decl|(
modifier|*
name|command_loop_hook
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
function_decl|(
modifier|*
name|show_load_progress
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
name|section
parameter_list|,
name|unsigned
name|long
name|section_sent
parameter_list|,
name|unsigned
name|long
name|section_size
parameter_list|,
name|unsigned
name|long
name|total_sent
parameter_list|,
name|unsigned
name|long
name|total_size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
function_decl|(
modifier|*
name|print_frame_info_listing_hook
function_decl|)
parameter_list|(
name|struct
name|symtab
modifier|*
name|s
parameter_list|,
name|int
name|line
parameter_list|,
name|int
name|stopline
parameter_list|,
name|int
name|noerror
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|struct
name|frame_info
modifier|*
name|parse_frame_specification
parameter_list|(
name|char
modifier|*
name|frame_exp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
function_decl|(
modifier|*
name|query_hook
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|va_list
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
function_decl|(
modifier|*
name|warning_hook
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|va_list
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
function_decl|(
modifier|*
name|flush_hook
function_decl|)
parameter_list|(
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
function_decl|(
modifier|*
name|create_breakpoint_hook
function_decl|)
parameter_list|(
name|struct
name|breakpoint
modifier|*
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
function_decl|(
modifier|*
name|delete_breakpoint_hook
function_decl|)
parameter_list|(
name|struct
name|breakpoint
modifier|*
name|bpt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
function_decl|(
modifier|*
name|modify_breakpoint_hook
function_decl|)
parameter_list|(
name|struct
name|breakpoint
modifier|*
name|bpt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
function_decl|(
modifier|*
name|interactive_hook
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
function_decl|(
modifier|*
name|registers_changed_hook
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
function_decl|(
modifier|*
name|readline_begin_hook
function_decl|)
parameter_list|(
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
function_decl|(
modifier|*
name|readline_hook
function_decl|)
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
function_decl|(
modifier|*
name|readline_end_hook
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
function_decl|(
modifier|*
name|register_changed_hook
function_decl|)
parameter_list|(
name|int
name|regno
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
function_decl|(
modifier|*
name|memory_changed_hook
function_decl|)
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
function_decl|(
modifier|*
name|context_hook
function_decl|)
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|ptid_t
function_decl|(
modifier|*
name|target_wait_hook
function_decl|)
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
name|struct
name|target_waitstatus
modifier|*
name|status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
function_decl|(
modifier|*
name|attach_hook
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
function_decl|(
modifier|*
name|detach_hook
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
function_decl|(
modifier|*
name|call_command_hook
function_decl|)
parameter_list|(
name|struct
name|cmd_list_element
modifier|*
name|c
parameter_list|,
name|char
modifier|*
name|cmd
parameter_list|,
name|int
name|from_tty
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
function_decl|(
modifier|*
name|set_hook
function_decl|)
parameter_list|(
name|struct
name|cmd_list_element
modifier|*
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|NORETURN
name|void
argument_list|(
operator|*
name|error_hook
argument_list|)
argument_list|(
name|void
argument_list|)
name|ATTR_NORETURN
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|void
function_decl|(
modifier|*
name|error_begin_hook
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
function_decl|(
modifier|*
name|ui_load_progress_hook
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
name|section
parameter_list|,
name|unsigned
name|long
name|num
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Inhibit window interface if non-zero. */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|use_windows
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Symbolic definitions of filename-related things.  */
end_comment

begin_comment
comment|/* FIXME, this doesn't work very well if host and executable    filesystems conventions are different.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DIRNAME_SEPARATOR
end_ifndef

begin_define
define|#
directive|define
name|DIRNAME_SEPARATOR
value|':'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SLASH_STRING
end_ifndef

begin_define
define|#
directive|define
name|SLASH_STRING
value|"/"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__MSDOS__
end_ifdef

begin_define
define|#
directive|define
name|CANT_FORK
end_define

begin_define
define|#
directive|define
name|GLOBAL_CURDIR
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Provide default definitions of PIDGET, TIDGET, and MERGEPID.    The name ``TIDGET'' is a historical accident.  Many uses of TIDGET    in the code actually refer to a lightweight process id, i.e,    something that can be considered a process id in its own right for    certain purposes.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PIDGET
end_ifndef

begin_define
define|#
directive|define
name|PIDGET
parameter_list|(
name|PTID
parameter_list|)
value|(ptid_get_pid (PTID))
end_define

begin_define
define|#
directive|define
name|TIDGET
parameter_list|(
name|PTID
parameter_list|)
value|(ptid_get_lwp (PTID))
end_define

begin_define
define|#
directive|define
name|MERGEPID
parameter_list|(
name|PID
parameter_list|,
name|TID
parameter_list|)
value|ptid_build (PID, TID, 0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Define well known filenos if the system does not define them.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|STDIN_FILENO
end_ifndef

begin_define
define|#
directive|define
name|STDIN_FILENO
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|STDOUT_FILENO
end_ifndef

begin_define
define|#
directive|define
name|STDOUT_FILENO
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|STDERR_FILENO
end_ifndef

begin_define
define|#
directive|define
name|STDERR_FILENO
value|2
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* If this definition isn't overridden by the header files, assume    that isatty and fileno exist on this system.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ISATTY
end_ifndef

begin_define
define|#
directive|define
name|ISATTY
parameter_list|(
name|FP
parameter_list|)
value|(isatty (fileno (FP)))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Ensure that V is aligned to an N byte boundary (B's assumed to be a    power of 2).  Round up/down when necessary.  Examples of correct    use include:     addr = align_up (addr, 8); -- VALUE needs 8 byte alignment    write_memory (addr, value, len);    addr += len;     and:     sp = align_down (sp - len, 16); -- Keep SP 16 byte aligned    write_memory (sp, value, len);     Note that uses such as:     write_memory (addr, value, len);    addr += align_up (len, 8);     and:     sp -= align_up (len, 8);    write_memory (sp, value, len);     are typically not correct as they don't ensure that the address (SP    or ADDR) is correctly aligned (relying on previous alignment to    keep things right).  This is also why the methods are called    "align_..." instead of "round_..." as the latter reads better with    this incorrect coding style.  */
end_comment

begin_function_decl
specifier|extern
name|ULONGEST
name|align_up
parameter_list|(
name|ULONGEST
name|v
parameter_list|,
name|int
name|n
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|ULONGEST
name|align_down
parameter_list|(
name|ULONGEST
name|v
parameter_list|,
name|int
name|n
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* #ifndef DEFS_H */
end_comment

end_unit

