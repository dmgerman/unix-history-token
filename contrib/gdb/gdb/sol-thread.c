begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Low level interface for debugging Solaris threads for GDB, the GNU debugger.    Copyright 1996, 1997, 1998 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This module implements a sort of half target that sits between the    machine-independent parts of GDB and the /proc interface (procfs.c) to    provide access to the Solaris user-mode thread implementation.     Solaris threads are true user-mode threads, which are invoked via the thr_*    and pthread_* (native and Posix respectivly) interfaces.  These are mostly    implemented in user-space, with all thread context kept in various    structures that live in the user's heap.  These should not be confused with    lightweight processes (LWPs), which are implemented by the kernel, and    scheduled without explicit intervention by the process.     Just to confuse things a little, Solaris threads (both native and Posix) are    actually implemented using LWPs.  In general, there are going to be more    threads than LWPs.  There is no fixed correspondence between a thread and an    LWP.  When a thread wants to run, it gets scheduled onto the first available    LWP and can therefore migrate from one LWP to another as time goes on.  A    sleeping thread may not be associated with an LWP at all!     To make it possible to mess with threads, Sun provides a library called    libthread_db.so.1 (not to be confused with libthread_db.so.0, which doesn't    have a published interface).  This interface has an upper part, which it    provides, and a lower part which I provide.  The upper part consists of the    td_* routines, which allow me to find all the threads, query their state,    etc...  The lower part consists of all of the ps_*, which are used by the    td_* routines to read/write memory, manipulate LWPs, lookup symbols, etc...    The ps_* routines actually do most of their work by calling functions in    procfs.c.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|<thread.h>
end_include

begin_include
include|#
directive|include
file|<proc_service.h>
end_include

begin_include
include|#
directive|include
file|<thread_db.h>
end_include

begin_include
include|#
directive|include
file|"gdbthread.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<dlfcn.h>
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_decl_stmt
specifier|extern
name|struct
name|target_ops
name|sol_thread_ops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward declaration */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|target_ops
name|sol_core_ops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward declaration */
end_comment

begin_comment
comment|/* place to store core_ops before we overwrite it */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|target_ops
name|orig_core_ops
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|target_ops
name|sol_thread_ops
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|target_ops
name|sol_core_ops
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|procfs_suppress_run
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|target_ops
name|procfs_ops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* target vector for procfs.c */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|target_ops
name|core_ops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* target vector for corelow.c */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|procfs_pid_to_str
name|PARAMS
argument_list|(
operator|(
name|int
name|pid
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Note that these prototypes differ slightly from those used in procfs.c    for of two reasons.  One, we can't use gregset_t, as that's got a whole    different meaning under Solaris (also, see above).  Two, we can't use the    pointer form here as these are actually arrays of ints (for Sparc's at    least), and are automatically coerced into pointers to ints when used as    parameters.  That makes it impossible to avoid a compiler warning when    passing pr{g fp}regset_t's from a parameter to an argument of one of    these functions.  */
end_comment

begin_decl_stmt
specifier|extern
name|void
name|supply_gregset
name|PARAMS
argument_list|(
operator|(
specifier|const
name|prgregset_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|fill_gregset
name|PARAMS
argument_list|(
operator|(
name|prgregset_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|supply_fpregset
name|PARAMS
argument_list|(
operator|(
specifier|const
name|prfpregset_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|fill_fpregset
name|PARAMS
argument_list|(
operator|(
name|prfpregset_t
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This struct is defined by us, but mainly used for the proc_service interface.    We don't have much use for it, except as a handy place to get a real pid    for memory accesses.  */
end_comment

begin_struct
struct|struct
name|ps_prochandle
block|{
name|pid_t
name|pid
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|string_map
block|{
name|int
name|num
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|ps_prochandle
name|main_ph
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|td_thragent_t
modifier|*
name|main_ta
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sol_thread_active
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cleanup
modifier|*
name|save_inferior_pid
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|restore_inferior_pid
name|PARAMS
argument_list|(
operator|(
name|int
name|pid
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|td_err_string
name|PARAMS
argument_list|(
operator|(
name|td_err_e
name|errcode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|td_state_string
name|PARAMS
argument_list|(
operator|(
name|td_thr_state_e
name|statecode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|thread_to_lwp
name|PARAMS
argument_list|(
operator|(
name|int
name|thread_id
operator|,
name|int
name|default_lwp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sol_thread_resume
name|PARAMS
argument_list|(
operator|(
name|int
name|pid
operator|,
name|int
name|step
operator|,
expr|enum
name|target_signal
name|signo
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|lwp_to_thread
name|PARAMS
argument_list|(
operator|(
name|int
name|lwp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sol_thread_alive
name|PARAMS
argument_list|(
operator|(
name|int
name|pid
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sol_core_close
name|PARAMS
argument_list|(
operator|(
name|int
name|quitting
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_sol_thread_ops
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_sol_core_ops
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|THREAD_FLAG
value|0x80000000
end_define

begin_define
define|#
directive|define
name|is_thread
parameter_list|(
name|ARG
parameter_list|)
value|(((ARG)& THREAD_FLAG) != 0)
end_define

begin_define
define|#
directive|define
name|is_lwp
parameter_list|(
name|ARG
parameter_list|)
value|(((ARG)& THREAD_FLAG) == 0)
end_define

begin_define
define|#
directive|define
name|GET_LWP
parameter_list|(
name|LWP_ID
parameter_list|)
value|(TIDGET(LWP_ID))
end_define

begin_define
define|#
directive|define
name|GET_THREAD
parameter_list|(
name|THREAD_ID
parameter_list|)
value|(((THREAD_ID)>> 16)& 0x7fff)
end_define

begin_define
define|#
directive|define
name|BUILD_LWP
parameter_list|(
name|LWP_ID
parameter_list|,
name|PID
parameter_list|)
value|((LWP_ID)<< 16 | (PID))
end_define

begin_define
define|#
directive|define
name|BUILD_THREAD
parameter_list|(
name|THREAD_ID
parameter_list|,
name|PID
parameter_list|)
value|(THREAD_FLAG | BUILD_LWP (THREAD_ID, PID))
end_define

begin_comment
comment|/* Pointers to routines from lithread_db resolved by dlopen() */
end_comment

begin_function_decl
specifier|static
name|void
function_decl|(
modifier|*
name|p_td_log
function_decl|)
parameter_list|(
specifier|const
name|int
name|on_off
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|p_td_ta_new
function_decl|)
parameter_list|(
specifier|const
name|struct
name|ps_prochandle
modifier|*
name|ph_p
parameter_list|,
name|td_thragent_t
modifier|*
modifier|*
name|ta_pp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|p_td_ta_delete
function_decl|)
parameter_list|(
name|td_thragent_t
modifier|*
name|ta_p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|p_td_init
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|p_td_ta_get_ph
function_decl|)
parameter_list|(
specifier|const
name|td_thragent_t
modifier|*
name|ta_p
parameter_list|,
name|struct
name|ps_prochandle
modifier|*
modifier|*
name|ph_pp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|p_td_ta_get_nthreads
function_decl|)
parameter_list|(
specifier|const
name|td_thragent_t
modifier|*
name|ta_p
parameter_list|,
name|int
modifier|*
name|nthread_p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|p_td_ta_tsd_iter
function_decl|)
parameter_list|(
specifier|const
name|td_thragent_t
modifier|*
name|ta_p
parameter_list|,
name|td_key_iter_f
modifier|*
name|cb
parameter_list|,
name|void
modifier|*
name|cbdata_p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|p_td_ta_thr_iter
function_decl|)
parameter_list|(
specifier|const
name|td_thragent_t
modifier|*
name|ta_p
parameter_list|,
name|td_thr_iter_f
modifier|*
name|cb
parameter_list|,
name|void
modifier|*
name|cbdata_p
parameter_list|,
name|td_thr_state_e
name|state
parameter_list|,
name|int
name|ti_pri
parameter_list|,
name|sigset_t
modifier|*
name|ti_sigmask_p
parameter_list|,
name|unsigned
name|ti_user_flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|p_td_thr_validate
function_decl|)
parameter_list|(
specifier|const
name|td_thrhandle_t
modifier|*
name|th_p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|p_td_thr_tsd
function_decl|)
parameter_list|(
specifier|const
name|td_thrhandle_t
modifier|*
name|th_p
parameter_list|,
specifier|const
name|thread_key_t
name|key
parameter_list|,
name|void
modifier|*
modifier|*
name|data_pp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|p_td_thr_get_info
function_decl|)
parameter_list|(
specifier|const
name|td_thrhandle_t
modifier|*
name|th_p
parameter_list|,
name|td_thrinfo_t
modifier|*
name|ti_p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|p_td_thr_getfpregs
function_decl|)
parameter_list|(
specifier|const
name|td_thrhandle_t
modifier|*
name|th_p
parameter_list|,
name|prfpregset_t
modifier|*
name|fpregset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|p_td_thr_getxregsize
function_decl|)
parameter_list|(
specifier|const
name|td_thrhandle_t
modifier|*
name|th_p
parameter_list|,
name|int
modifier|*
name|xregsize
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|p_td_thr_getxregs
function_decl|)
parameter_list|(
specifier|const
name|td_thrhandle_t
modifier|*
name|th_p
parameter_list|,
specifier|const
name|caddr_t
name|xregset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|p_td_thr_sigsetmask
function_decl|)
parameter_list|(
specifier|const
name|td_thrhandle_t
modifier|*
name|th_p
parameter_list|,
specifier|const
name|sigset_t
name|ti_sigmask
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|p_td_thr_setprio
function_decl|)
parameter_list|(
specifier|const
name|td_thrhandle_t
modifier|*
name|th_p
parameter_list|,
specifier|const
name|int
name|ti_pri
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|p_td_thr_setsigpending
function_decl|)
parameter_list|(
specifier|const
name|td_thrhandle_t
modifier|*
name|th_p
parameter_list|,
specifier|const
name|uchar_t
name|ti_pending_flag
parameter_list|,
specifier|const
name|sigset_t
name|ti_pending
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|p_td_thr_setfpregs
function_decl|)
parameter_list|(
specifier|const
name|td_thrhandle_t
modifier|*
name|th_p
parameter_list|,
specifier|const
name|prfpregset_t
modifier|*
name|fpregset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|p_td_thr_setxregs
function_decl|)
parameter_list|(
specifier|const
name|td_thrhandle_t
modifier|*
name|th_p
parameter_list|,
specifier|const
name|caddr_t
name|xregset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|p_td_ta_map_id2thr
function_decl|)
parameter_list|(
specifier|const
name|td_thragent_t
modifier|*
name|ta_p
parameter_list|,
name|thread_t
name|tid
parameter_list|,
name|td_thrhandle_t
modifier|*
name|th_p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|p_td_ta_map_lwp2thr
function_decl|)
parameter_list|(
specifier|const
name|td_thragent_t
modifier|*
name|ta_p
parameter_list|,
name|lwpid_t
name|lwpid
parameter_list|,
name|td_thrhandle_t
modifier|*
name|th_p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|p_td_thr_getgregs
function_decl|)
parameter_list|(
specifier|const
name|td_thrhandle_t
modifier|*
name|th_p
parameter_list|,
name|prgregset_t
name|regset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|p_td_thr_setgregs
function_decl|)
parameter_list|(
specifier|const
name|td_thrhandle_t
modifier|*
name|th_p
parameter_list|,
specifier|const
name|prgregset_t
name|regset
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/*  LOCAL FUNCTION  	td_err_string - Convert a thread_db error code to a string  SYNOPSIS  	char * td_err_string (errcode)  DESCRIPTION  	Return the thread_db error string associated with errcode.  If errcode 	is unknown, then return a message.   */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|td_err_string
parameter_list|(
name|errcode
parameter_list|)
name|td_err_e
name|errcode
decl_stmt|;
block|{
specifier|static
name|struct
name|string_map
name|td_err_table
index|[]
init|=
block|{
block|{
name|TD_OK
block|,
literal|"generic \"call succeeded\""
block|}
block|,
block|{
name|TD_ERR
block|,
literal|"generic error."
block|}
block|,
block|{
name|TD_NOTHR
block|,
literal|"no thread can be found to satisfy query"
block|}
block|,
block|{
name|TD_NOSV
block|,
literal|"no synch. variable can be found to satisfy query"
block|}
block|,
block|{
name|TD_NOLWP
block|,
literal|"no lwp can be found to satisfy query"
block|}
block|,
block|{
name|TD_BADPH
block|,
literal|"invalid process handle"
block|}
block|,
block|{
name|TD_BADTH
block|,
literal|"invalid thread handle"
block|}
block|,
block|{
name|TD_BADSH
block|,
literal|"invalid synchronization handle"
block|}
block|,
block|{
name|TD_BADTA
block|,
literal|"invalid thread agent"
block|}
block|,
block|{
name|TD_BADKEY
block|,
literal|"invalid key"
block|}
block|,
block|{
name|TD_NOMSG
block|,
literal|"td_thr_event_getmsg() called when there was no message"
block|}
block|,
block|{
name|TD_NOFPREGS
block|,
literal|"FPU register set not available for given thread"
block|}
block|,
block|{
name|TD_NOLIBTHREAD
block|,
literal|"application not linked with libthread"
block|}
block|,
block|{
name|TD_NOEVENT
block|,
literal|"requested event is not supported"
block|}
block|,
block|{
name|TD_NOCAPAB
block|,
literal|"capability not available"
block|}
block|,
block|{
name|TD_DBERR
block|,
literal|"Debugger service failed"
block|}
block|,
block|{
name|TD_NOAPLIC
block|,
literal|"Operation not applicable to"
block|}
block|,
block|{
name|TD_NOTSD
block|,
literal|"No thread specific data for this thread"
block|}
block|,
block|{
name|TD_MALLOC
block|,
literal|"Malloc failed"
block|}
block|,
block|{
name|TD_PARTIALREG
block|,
literal|"Only part of register set was writen/read"
block|}
block|,
block|{
name|TD_NOXREGS
block|,
literal|"X register set not available for given thread"
block|}
block|}
decl_stmt|;
specifier|const
name|int
name|td_err_size
init|=
sizeof|sizeof
name|td_err_table
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|string_map
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|static
name|char
name|buf
index|[
literal|50
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|td_err_size
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|td_err_table
index|[
name|i
index|]
operator|.
name|num
operator|==
name|errcode
condition|)
return|return
name|td_err_table
index|[
name|i
index|]
operator|.
name|str
return|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"Unknown thread_db error code: %d"
argument_list|,
name|errcode
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  LOCAL FUNCTION  	td_state_string - Convert a thread_db state code to a string  SYNOPSIS  	char * td_state_string (statecode)  DESCRIPTION  	Return the thread_db state string associated with statecode.  If 	statecode is unknown, then return a message.   */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|td_state_string
parameter_list|(
name|statecode
parameter_list|)
name|td_thr_state_e
name|statecode
decl_stmt|;
block|{
specifier|static
name|struct
name|string_map
name|td_thr_state_table
index|[]
init|=
block|{
block|{
name|TD_THR_ANY_STATE
block|,
literal|"any state"
block|}
block|,
block|{
name|TD_THR_UNKNOWN
block|,
literal|"unknown"
block|}
block|,
block|{
name|TD_THR_STOPPED
block|,
literal|"stopped"
block|}
block|,
block|{
name|TD_THR_RUN
block|,
literal|"run"
block|}
block|,
block|{
name|TD_THR_ACTIVE
block|,
literal|"active"
block|}
block|,
block|{
name|TD_THR_ZOMBIE
block|,
literal|"zombie"
block|}
block|,
block|{
name|TD_THR_SLEEP
block|,
literal|"sleep"
block|}
block|,
block|{
name|TD_THR_STOPPED_ASLEEP
block|,
literal|"stopped asleep"
block|}
block|}
decl_stmt|;
specifier|const
name|int
name|td_thr_state_table_size
init|=
sizeof|sizeof
name|td_thr_state_table
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|string_map
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|static
name|char
name|buf
index|[
literal|50
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|td_thr_state_table_size
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|td_thr_state_table
index|[
name|i
index|]
operator|.
name|num
operator|==
name|statecode
condition|)
return|return
name|td_thr_state_table
index|[
name|i
index|]
operator|.
name|str
return|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"Unknown thread_db state code: %d"
argument_list|,
name|statecode
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  LOCAL FUNCTION  	thread_to_lwp - Convert a Posix or Solaris thread id to a LWP id.  SYNOPSIS  	int thread_to_lwp (thread_id, default_lwp)  DESCRIPTION  	This function converts a Posix or Solaris thread id to a lightweight 	process id.  If thread_id is non-existent, that's an error.  If it's 	an inactive thread, then we return default_lwp.  NOTES  	This function probably shouldn't call error()...   */
end_comment

begin_function
specifier|static
name|int
name|thread_to_lwp
parameter_list|(
name|thread_id
parameter_list|,
name|default_lwp
parameter_list|)
name|int
name|thread_id
decl_stmt|;
name|int
name|default_lwp
decl_stmt|;
block|{
name|td_thrinfo_t
name|ti
decl_stmt|;
name|td_thrhandle_t
name|th
decl_stmt|;
name|td_err_e
name|val
decl_stmt|;
if|if
condition|(
name|is_lwp
argument_list|(
name|thread_id
argument_list|)
condition|)
return|return
name|thread_id
return|;
comment|/* It's already an LWP id */
comment|/* It's a thread.  Convert to lwp */
name|val
operator|=
name|p_td_ta_map_id2thr
argument_list|(
name|main_ta
argument_list|,
name|GET_THREAD
argument_list|(
name|thread_id
argument_list|)
argument_list|,
operator|&
name|th
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|TD_NOTHR
condition|)
return|return
operator|-
literal|1
return|;
comment|/* thread must have terminated */
elseif|else
if|if
condition|(
name|val
operator|!=
name|TD_OK
condition|)
name|error
argument_list|(
literal|"thread_to_lwp: td_ta_map_id2thr %s"
argument_list|,
name|td_err_string
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
name|val
operator|=
name|p_td_thr_get_info
argument_list|(
operator|&
name|th
argument_list|,
operator|&
name|ti
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|TD_NOTHR
condition|)
return|return
operator|-
literal|1
return|;
comment|/* thread must have terminated */
elseif|else
if|if
condition|(
name|val
operator|!=
name|TD_OK
condition|)
name|error
argument_list|(
literal|"thread_to_lwp: td_thr_get_info: %s"
argument_list|,
name|td_err_string
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ti
operator|.
name|ti_state
operator|!=
name|TD_THR_ACTIVE
condition|)
block|{
if|if
condition|(
name|default_lwp
operator|!=
operator|-
literal|1
condition|)
return|return
name|default_lwp
return|;
name|error
argument_list|(
literal|"thread_to_lwp: thread state not active: %s"
argument_list|,
name|td_state_string
argument_list|(
name|ti
operator|.
name|ti_state
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|BUILD_LWP
argument_list|(
name|ti
operator|.
name|ti_lid
argument_list|,
name|PIDGET
argument_list|(
name|thread_id
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  LOCAL FUNCTION  	lwp_to_thread - Convert a LWP id to a Posix or Solaris thread id.  SYNOPSIS  	int lwp_to_thread (lwp_id)  DESCRIPTION  	This function converts a lightweight process id to a Posix or Solaris 	thread id.  If thread_id is non-existent, that's an error.  NOTES  	This function probably shouldn't call error()...   */
end_comment

begin_function
specifier|static
name|int
name|lwp_to_thread
parameter_list|(
name|lwp
parameter_list|)
name|int
name|lwp
decl_stmt|;
block|{
name|td_thrinfo_t
name|ti
decl_stmt|;
name|td_thrhandle_t
name|th
decl_stmt|;
name|td_err_e
name|val
decl_stmt|;
if|if
condition|(
name|is_thread
argument_list|(
name|lwp
argument_list|)
condition|)
return|return
name|lwp
return|;
comment|/* It's already a thread id */
comment|/* It's an lwp.  Convert it to a thread id.  */
if|if
condition|(
operator|!
name|sol_thread_alive
argument_list|(
name|lwp
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* defunct lwp */
name|val
operator|=
name|p_td_ta_map_lwp2thr
argument_list|(
name|main_ta
argument_list|,
name|GET_LWP
argument_list|(
name|lwp
argument_list|)
argument_list|,
operator|&
name|th
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|TD_NOTHR
condition|)
return|return
operator|-
literal|1
return|;
comment|/* thread must have terminated */
elseif|else
if|if
condition|(
name|val
operator|!=
name|TD_OK
condition|)
name|error
argument_list|(
literal|"lwp_to_thread: td_ta_map_lwp2thr: %s."
argument_list|,
name|td_err_string
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
name|val
operator|=
name|p_td_thr_validate
argument_list|(
operator|&
name|th
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|TD_NOTHR
condition|)
return|return
name|lwp
return|;
comment|/* libthread doesn't know about it, just return lwp */
elseif|else
if|if
condition|(
name|val
operator|!=
name|TD_OK
condition|)
name|error
argument_list|(
literal|"lwp_to_thread: td_thr_validate: %s."
argument_list|,
name|td_err_string
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
name|val
operator|=
name|p_td_thr_get_info
argument_list|(
operator|&
name|th
argument_list|,
operator|&
name|ti
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|TD_NOTHR
condition|)
return|return
operator|-
literal|1
return|;
comment|/* thread must have terminated */
elseif|else
if|if
condition|(
name|val
operator|!=
name|TD_OK
condition|)
name|error
argument_list|(
literal|"lwp_to_thread: td_thr_get_info: %s."
argument_list|,
name|td_err_string
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|BUILD_THREAD
argument_list|(
name|ti
operator|.
name|ti_tid
argument_list|,
name|PIDGET
argument_list|(
name|lwp
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  LOCAL FUNCTION  	save_inferior_pid - Save inferior_pid on the cleanup list 	restore_inferior_pid - Restore inferior_pid from the cleanup list  SYNOPSIS  	struct cleanup *save_inferior_pid () 	void restore_inferior_pid (int pid)  DESCRIPTION  	These two functions act in unison to restore inferior_pid in 	case of an error.  NOTES  	inferior_pid is a global variable that needs to be changed by many of 	these routines before calling functions in procfs.c.  In order to 	guarantee that inferior_pid gets restored (in case of errors), you 	need to call save_inferior_pid before changing it.  At the end of the 	function, you should invoke do_cleanups to restore it.   */
end_comment

begin_function
specifier|static
name|struct
name|cleanup
modifier|*
name|save_inferior_pid
parameter_list|()
block|{
return|return
name|make_cleanup
argument_list|(
name|restore_inferior_pid
argument_list|,
name|inferior_pid
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|restore_inferior_pid
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
name|inferior_pid
operator|=
name|pid
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Most target vector functions from here on actually just pass through to    procfs.c, as they don't need to do anything specific for threads.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|sol_thread_open
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|procfs_ops
operator|.
name|to_open
argument_list|(
name|arg
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Attach to process PID, then initialize for debugging it    and wait for the trace-trap that results from attaching.  */
end_comment

begin_function
specifier|static
name|void
name|sol_thread_attach
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|procfs_ops
operator|.
name|to_attach
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
comment|/* Must get symbols from solibs before libthread_db can run! */
name|SOLIB_ADD
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|from_tty
argument_list|,
operator|(
expr|struct
name|target_ops
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sol_thread_active
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"sol-thread active.\n"
argument_list|)
expr_stmt|;
name|main_ph
operator|.
name|pid
operator|=
name|inferior_pid
expr_stmt|;
comment|/* Save for xfer_memory */
name|push_target
argument_list|(
operator|&
name|sol_thread_ops
argument_list|)
expr_stmt|;
name|inferior_pid
operator|=
name|lwp_to_thread
argument_list|(
name|inferior_pid
argument_list|)
expr_stmt|;
if|if
condition|(
name|inferior_pid
operator|==
operator|-
literal|1
condition|)
name|inferior_pid
operator|=
name|main_ph
operator|.
name|pid
expr_stmt|;
else|else
name|add_thread
argument_list|(
name|inferior_pid
argument_list|)
expr_stmt|;
block|}
comment|/* XXX - might want to iterate over all the threads and register them. */
block|}
end_function

begin_comment
comment|/* Take a program previously attached to and detaches it.    The program resumes execution and will no longer stop    on signals, etc.  We'd better not have left any breakpoints    in the program or it'll die when it hits one.  For this    to work, it may be necessary for the process to have been    previously attached.  It *might* work if the program was    started via the normal ptrace (PTRACE_TRACEME).  */
end_comment

begin_function
specifier|static
name|void
name|sol_thread_detach
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|unpush_target
argument_list|(
operator|&
name|sol_thread_ops
argument_list|)
expr_stmt|;
name|procfs_ops
operator|.
name|to_detach
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Resume execution of process PID.  If STEP is nozero, then    just single step it.  If SIGNAL is nonzero, restart it with that    signal activated.  We may have to convert pid from a thread-id to an LWP id    for procfs.  */
end_comment

begin_function
specifier|static
name|void
name|sol_thread_resume
parameter_list|(
name|pid
parameter_list|,
name|step
parameter_list|,
name|signo
parameter_list|)
name|int
name|pid
decl_stmt|;
name|int
name|step
decl_stmt|;
name|enum
name|target_signal
name|signo
decl_stmt|;
block|{
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|old_chain
operator|=
name|save_inferior_pid
argument_list|()
expr_stmt|;
name|inferior_pid
operator|=
name|thread_to_lwp
argument_list|(
name|inferior_pid
argument_list|,
name|main_ph
operator|.
name|pid
argument_list|)
expr_stmt|;
if|if
condition|(
name|inferior_pid
operator|==
operator|-
literal|1
condition|)
name|inferior_pid
operator|=
name|procfs_first_available
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|!=
operator|-
literal|1
condition|)
block|{
name|int
name|save_pid
init|=
name|pid
decl_stmt|;
name|pid
operator|=
name|thread_to_lwp
argument_list|(
name|pid
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|==
operator|-
literal|2
condition|)
comment|/* Inactive thread */
name|error
argument_list|(
literal|"This version of Solaris can't start inactive threads."
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_verbose
operator|&&
name|pid
operator|==
operator|-
literal|1
condition|)
name|warning
argument_list|(
literal|"Specified thread %d seems to have terminated"
argument_list|,
name|GET_THREAD
argument_list|(
name|save_pid
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|procfs_ops
operator|.
name|to_resume
argument_list|(
name|pid
argument_list|,
name|step
argument_list|,
name|signo
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Wait for any threads to stop.  We may have to convert PID from a thread id    to a LWP id, and vice versa on the way out.  */
end_comment

begin_function
specifier|static
name|int
name|sol_thread_wait
parameter_list|(
name|pid
parameter_list|,
name|ourstatus
parameter_list|)
name|int
name|pid
decl_stmt|;
name|struct
name|target_waitstatus
modifier|*
name|ourstatus
decl_stmt|;
block|{
name|int
name|rtnval
decl_stmt|;
name|int
name|save_pid
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|save_pid
operator|=
name|inferior_pid
expr_stmt|;
name|old_chain
operator|=
name|save_inferior_pid
argument_list|()
expr_stmt|;
name|inferior_pid
operator|=
name|thread_to_lwp
argument_list|(
name|inferior_pid
argument_list|,
name|main_ph
operator|.
name|pid
argument_list|)
expr_stmt|;
if|if
condition|(
name|inferior_pid
operator|==
operator|-
literal|1
condition|)
name|inferior_pid
operator|=
name|procfs_first_available
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|!=
operator|-
literal|1
condition|)
block|{
name|int
name|save_pid
init|=
name|pid
decl_stmt|;
name|pid
operator|=
name|thread_to_lwp
argument_list|(
name|pid
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|==
operator|-
literal|2
condition|)
comment|/* Inactive thread */
name|error
argument_list|(
literal|"This version of Solaris can't start inactive threads."
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_verbose
operator|&&
name|pid
operator|==
operator|-
literal|1
condition|)
name|warning
argument_list|(
literal|"Specified thread %d seems to have terminated"
argument_list|,
name|GET_THREAD
argument_list|(
name|save_pid
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|rtnval
operator|=
name|procfs_ops
operator|.
name|to_wait
argument_list|(
name|pid
argument_list|,
name|ourstatus
argument_list|)
expr_stmt|;
if|if
condition|(
name|ourstatus
operator|->
name|kind
operator|!=
name|TARGET_WAITKIND_EXITED
condition|)
block|{
comment|/* Map the LWP of interest back to the appropriate thread ID */
name|rtnval
operator|=
name|lwp_to_thread
argument_list|(
name|rtnval
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtnval
operator|==
operator|-
literal|1
condition|)
name|rtnval
operator|=
name|save_pid
expr_stmt|;
comment|/* See if we have a new thread */
if|if
condition|(
name|is_thread
argument_list|(
name|rtnval
argument_list|)
operator|&&
name|rtnval
operator|!=
name|save_pid
operator|&&
operator|!
name|in_thread_list
argument_list|(
name|rtnval
argument_list|)
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"[New %s]\n"
argument_list|,
name|target_pid_to_str
argument_list|(
name|rtnval
argument_list|)
argument_list|)
expr_stmt|;
name|add_thread
argument_list|(
name|rtnval
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* During process initialization, we may get here without the thread package      being initialized, since that can only happen after we've found the shared      libs.  */
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
name|rtnval
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sol_thread_fetch_registers
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
name|thread_t
name|thread
decl_stmt|;
name|td_thrhandle_t
name|thandle
decl_stmt|;
name|td_err_e
name|val
decl_stmt|;
name|prgregset_t
name|gregset
decl_stmt|;
name|prfpregset_t
name|fpregset
decl_stmt|;
if|#
directive|if
literal|0
block|int xregsize;   caddr_t xregset;
endif|#
directive|endif
if|if
condition|(
operator|!
name|is_thread
argument_list|(
name|inferior_pid
argument_list|)
condition|)
block|{
comment|/* LWP: pass the request on to procfs.c */
if|if
condition|(
name|target_has_execution
condition|)
name|procfs_ops
operator|.
name|to_fetch_registers
argument_list|(
name|regno
argument_list|)
expr_stmt|;
else|else
name|orig_core_ops
operator|.
name|to_fetch_registers
argument_list|(
name|regno
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Solaris thread: convert inferior_pid into a td_thrhandle_t */
name|thread
operator|=
name|GET_THREAD
argument_list|(
name|inferior_pid
argument_list|)
expr_stmt|;
if|if
condition|(
name|thread
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"sol_thread_fetch_registers:  thread == 0"
argument_list|)
expr_stmt|;
name|val
operator|=
name|p_td_ta_map_id2thr
argument_list|(
name|main_ta
argument_list|,
name|thread
argument_list|,
operator|&
name|thandle
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|TD_OK
condition|)
name|error
argument_list|(
literal|"sol_thread_fetch_registers: td_ta_map_id2thr: %s"
argument_list|,
name|td_err_string
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get the integer regs */
name|val
operator|=
name|p_td_thr_getgregs
argument_list|(
operator|&
name|thandle
argument_list|,
name|gregset
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|TD_OK
operator|&&
name|val
operator|!=
name|TD_PARTIALREG
condition|)
name|error
argument_list|(
literal|"sol_thread_fetch_registers: td_thr_getgregs %s"
argument_list|,
name|td_err_string
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
comment|/* For the sparc, TD_PARTIALREG means that only i0->i7, l0->l7, pc and sp      are saved (by a thread context switch).  */
comment|/* And, now the fp regs */
name|val
operator|=
name|p_td_thr_getfpregs
argument_list|(
operator|&
name|thandle
argument_list|,
operator|&
name|fpregset
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|TD_OK
operator|&&
name|val
operator|!=
name|TD_NOFPREGS
condition|)
name|error
argument_list|(
literal|"sol_thread_fetch_registers: td_thr_getfpregs %s"
argument_list|,
name|td_err_string
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Note that we must call supply_{g fp}regset *after* calling the td routines    because the td routines call ps_lget* which affect the values stored in the    registers array.  */
name|supply_gregset
argument_list|(
name|gregset
argument_list|)
expr_stmt|;
name|supply_fpregset
argument_list|(
operator|&
name|fpregset
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* thread_db doesn't seem to handle this right */
block|val = td_thr_getxregsize (&thandle,&xregsize);   if (val != TD_OK&& val != TD_NOXREGS)     error ("sol_thread_fetch_registers: td_thr_getxregsize %s", 	   td_err_string (val));    if (val == TD_OK)     {       xregset = alloca (xregsize);       val = td_thr_getxregs (&thandle, xregset);       if (val != TD_OK) 	error ("sol_thread_fetch_registers: td_thr_getxregs %s", 	       td_err_string (val));     }
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|sol_thread_store_registers
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
name|thread_t
name|thread
decl_stmt|;
name|td_thrhandle_t
name|thandle
decl_stmt|;
name|td_err_e
name|val
decl_stmt|;
name|prgregset_t
name|regset
decl_stmt|;
name|prfpregset_t
name|fpregset
decl_stmt|;
if|#
directive|if
literal|0
block|int xregsize;   caddr_t xregset;
endif|#
directive|endif
if|if
condition|(
operator|!
name|is_thread
argument_list|(
name|inferior_pid
argument_list|)
condition|)
block|{
comment|/* LWP: pass the request on to procfs.c */
name|procfs_ops
operator|.
name|to_store_registers
argument_list|(
name|regno
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Solaris thread: convert inferior_pid into a td_thrhandle_t */
name|thread
operator|=
name|GET_THREAD
argument_list|(
name|inferior_pid
argument_list|)
expr_stmt|;
name|val
operator|=
name|p_td_ta_map_id2thr
argument_list|(
name|main_ta
argument_list|,
name|thread
argument_list|,
operator|&
name|thandle
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|TD_OK
condition|)
name|error
argument_list|(
literal|"sol_thread_store_registers: td_ta_map_id2thr %s"
argument_list|,
name|td_err_string
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* Not writing all the regs */
comment|/* save new register value */
name|char
name|old_value
index|[
name|REGISTER_SIZE
index|]
decl_stmt|;
name|memcpy
argument_list|(
name|old_value
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|regno
argument_list|)
index|]
argument_list|,
name|REGISTER_SIZE
argument_list|)
expr_stmt|;
name|val
operator|=
name|p_td_thr_getgregs
argument_list|(
operator|&
name|thandle
argument_list|,
name|regset
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|TD_OK
condition|)
name|error
argument_list|(
literal|"sol_thread_store_registers: td_thr_getgregs %s"
argument_list|,
name|td_err_string
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
name|val
operator|=
name|p_td_thr_getfpregs
argument_list|(
operator|&
name|thandle
argument_list|,
operator|&
name|fpregset
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|TD_OK
condition|)
name|error
argument_list|(
literal|"sol_thread_store_registers: td_thr_getfpregs %s"
argument_list|,
name|td_err_string
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
comment|/* restore new register value */
name|memcpy
argument_list|(
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|regno
argument_list|)
index|]
argument_list|,
name|old_value
argument_list|,
name|REGISTER_SIZE
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* thread_db doesn't seem to handle this right */
block|val = td_thr_getxregsize (&thandle,&xregsize);       if (val != TD_OK&& val != TD_NOXREGS) 	error ("sol_thread_store_registers: td_thr_getxregsize %s", 	       td_err_string (val));        if (val == TD_OK) 	{ 	  xregset = alloca (xregsize); 	  val = td_thr_getxregs (&thandle, xregset); 	  if (val != TD_OK) 	    error ("sol_thread_store_registers: td_thr_getxregs %s", 		   td_err_string (val)); 	}
endif|#
directive|endif
block|}
name|fill_gregset
argument_list|(
name|regset
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|fill_fpregset
argument_list|(
operator|&
name|fpregset
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|val
operator|=
name|p_td_thr_setgregs
argument_list|(
operator|&
name|thandle
argument_list|,
name|regset
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|TD_OK
condition|)
name|error
argument_list|(
literal|"sol_thread_store_registers: td_thr_setgregs %s"
argument_list|,
name|td_err_string
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
name|val
operator|=
name|p_td_thr_setfpregs
argument_list|(
operator|&
name|thandle
argument_list|,
operator|&
name|fpregset
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|TD_OK
condition|)
name|error
argument_list|(
literal|"sol_thread_store_registers: td_thr_setfpregs %s"
argument_list|,
name|td_err_string
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* thread_db doesn't seem to handle this right */
block|val = td_thr_getxregsize (&thandle,&xregsize);   if (val != TD_OK&& val != TD_NOXREGS)     error ("sol_thread_store_registers: td_thr_getxregsize %s", 	   td_err_string (val));
comment|/* Should probably do something about writing the xregs here, but what are      they? */
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Get ready to modify the registers array.  On machines which store    individual registers, this doesn't need to do anything.  On machines    which store all the registers in one fell swoop, this makes sure    that registers contains all the registers from the program being    debugged.  */
end_comment

begin_function
specifier|static
name|void
name|sol_thread_prepare_to_store
parameter_list|()
block|{
name|procfs_ops
operator|.
name|to_prepare_to_store
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|sol_thread_xfer_memory
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|,
name|dowrite
parameter_list|,
name|target
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|dowrite
decl_stmt|;
name|struct
name|target_ops
modifier|*
name|target
decl_stmt|;
comment|/* ignored */
block|{
name|int
name|retval
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|old_chain
operator|=
name|save_inferior_pid
argument_list|()
expr_stmt|;
if|if
condition|(
name|is_thread
argument_list|(
name|inferior_pid
argument_list|)
operator|||
comment|/* A thread */
operator|!
name|target_thread_alive
argument_list|(
name|inferior_pid
argument_list|)
condition|)
comment|/* An lwp, but not alive */
name|inferior_pid
operator|=
name|procfs_first_available
argument_list|()
expr_stmt|;
comment|/* Find any live lwp.  */
comment|/* Note: don't need to call switch_to_thread; we're just reading memory.  */
if|if
condition|(
name|target_has_execution
condition|)
name|retval
operator|=
name|procfs_ops
operator|.
name|to_xfer_memory
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|,
name|dowrite
argument_list|,
name|target
argument_list|)
expr_stmt|;
else|else
name|retval
operator|=
name|orig_core_ops
operator|.
name|to_xfer_memory
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|,
name|dowrite
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Print status information about what we're accessing.  */
end_comment

begin_function
specifier|static
name|void
name|sol_thread_files_info
parameter_list|(
name|ignore
parameter_list|)
name|struct
name|target_ops
modifier|*
name|ignore
decl_stmt|;
block|{
name|procfs_ops
operator|.
name|to_files_info
argument_list|(
name|ignore
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sol_thread_kill_inferior
parameter_list|()
block|{
name|procfs_ops
operator|.
name|to_kill
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sol_thread_notice_signals
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
name|procfs_ops
operator|.
name|to_notice_signals
argument_list|(
name|PIDGET
argument_list|(
name|pid
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fork an inferior process, and start debugging it with /proc.  */
end_comment

begin_function
specifier|static
name|void
name|sol_thread_create_inferior
parameter_list|(
name|exec_file
parameter_list|,
name|allargs
parameter_list|,
name|env
parameter_list|)
name|char
modifier|*
name|exec_file
decl_stmt|;
name|char
modifier|*
name|allargs
decl_stmt|;
name|char
modifier|*
modifier|*
name|env
decl_stmt|;
block|{
name|procfs_ops
operator|.
name|to_create_inferior
argument_list|(
name|exec_file
argument_list|,
name|allargs
argument_list|,
name|env
argument_list|)
expr_stmt|;
if|if
condition|(
name|sol_thread_active
operator|&&
name|inferior_pid
operator|!=
literal|0
condition|)
block|{
name|main_ph
operator|.
name|pid
operator|=
name|inferior_pid
expr_stmt|;
comment|/* Save for xfer_memory */
name|push_target
argument_list|(
operator|&
name|sol_thread_ops
argument_list|)
expr_stmt|;
name|inferior_pid
operator|=
name|lwp_to_thread
argument_list|(
name|inferior_pid
argument_list|)
expr_stmt|;
if|if
condition|(
name|inferior_pid
operator|==
operator|-
literal|1
condition|)
name|inferior_pid
operator|=
name|main_ph
operator|.
name|pid
expr_stmt|;
name|add_thread
argument_list|(
name|inferior_pid
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This routine is called whenever a new symbol table is read in, or when all    symbol tables are removed.  libthread_db can only be initialized when it    finds the right variables in libthread.so.  Since it's a shared library,    those variables don't show up until the library gets mapped and the symbol    table is read in.  */
end_comment

begin_function
name|void
name|sol_thread_new_objfile
parameter_list|(
name|objfile
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|td_err_e
name|val
decl_stmt|;
if|if
condition|(
operator|!
name|objfile
condition|)
block|{
name|sol_thread_active
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* don't do anything if init failed to resolve the libthread_db library */
if|if
condition|(
operator|!
name|procfs_suppress_run
condition|)
return|return;
comment|/* Now, initialize the thread debugging library.  This needs to be done after      the shared libraries are located because it needs information from the      user's thread library.  */
name|val
operator|=
name|p_td_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|TD_OK
condition|)
name|error
argument_list|(
literal|"target_new_objfile: td_init: %s"
argument_list|,
name|td_err_string
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
name|val
operator|=
name|p_td_ta_new
argument_list|(
operator|&
name|main_ph
argument_list|,
operator|&
name|main_ta
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|TD_NOLIBTHREAD
condition|)
return|return;
elseif|else
if|if
condition|(
name|val
operator|!=
name|TD_OK
condition|)
name|error
argument_list|(
literal|"target_new_objfile: td_ta_new: %s"
argument_list|,
name|td_err_string
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
name|sol_thread_active
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clean up after the inferior dies.  */
end_comment

begin_function
specifier|static
name|void
name|sol_thread_mourn_inferior
parameter_list|()
block|{
name|unpush_target
argument_list|(
operator|&
name|sol_thread_ops
argument_list|)
expr_stmt|;
name|procfs_ops
operator|.
name|to_mourn_inferior
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Mark our target-struct as eligible for stray "run" and "attach" commands.  */
end_comment

begin_function
specifier|static
name|int
name|sol_thread_can_run
parameter_list|()
block|{
return|return
name|procfs_suppress_run
return|;
block|}
end_function

begin_comment
comment|/*   LOCAL FUNCTION  	sol_thread_alive     - test thread for "aliveness"  SYNOPSIS  	static bool sol_thread_alive (int pid);  DESCRIPTION  	returns true if thread still active in inferior.   */
end_comment

begin_function
specifier|static
name|int
name|sol_thread_alive
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
if|if
condition|(
name|is_thread
argument_list|(
name|pid
argument_list|)
condition|)
comment|/* non-kernel thread */
block|{
name|td_err_e
name|val
decl_stmt|;
name|td_thrhandle_t
name|th
decl_stmt|;
name|pid
operator|=
name|GET_THREAD
argument_list|(
name|pid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|=
name|p_td_ta_map_id2thr
argument_list|(
name|main_ta
argument_list|,
name|pid
argument_list|,
operator|&
name|th
argument_list|)
operator|)
operator|!=
name|TD_OK
condition|)
return|return
literal|0
return|;
comment|/* thread not found */
if|if
condition|(
operator|(
name|val
operator|=
name|p_td_thr_validate
argument_list|(
operator|&
name|th
argument_list|)
operator|)
operator|!=
name|TD_OK
condition|)
return|return
literal|0
return|;
comment|/* thread not valid */
return|return
literal|1
return|;
comment|/* known thread: return true */
block|}
else|else
comment|/* kernel thread (LWP): let procfs test it */
block|{
if|if
condition|(
name|target_has_execution
condition|)
return|return
name|procfs_ops
operator|.
name|to_thread_alive
argument_list|(
name|pid
argument_list|)
return|;
else|else
return|return
name|orig_core_ops
operator|.
name|to_thread_alive
argument_list|(
name|pid
argument_list|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sol_thread_stop
parameter_list|()
block|{
name|procfs_ops
operator|.
name|to_stop
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* These routines implement the lower half of the thread_db interface.  Ie: the    ps_* routines.  */
end_comment

begin_comment
comment|/* Various versions of<proc_service.h> have slightly    different function prototypes.  In particular, we have        NEWER		    	OLDER       struct ps_prochandle *  	const struct ps_prochandle *       void*			char*       const void*		char*       int			size_t     Which one you have depends on solaris version and what    patches you've applied.  On the theory that there are    only two major variants, we have configure check the    prototype of ps_pdwrite (), and use that info to make    appropriate typedefs here. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PROC_SERVICE_IS_OLD
end_ifdef

begin_typedef
typedef|typedef
specifier|const
name|struct
name|ps_prochandle
modifier|*
name|gdb_ps_prochandle_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|char
modifier|*
name|gdb_ps_read_buf_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|char
modifier|*
name|gdb_ps_write_buf_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|int
name|gdb_ps_size_t
typedef|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|struct
name|ps_prochandle
modifier|*
name|gdb_ps_prochandle_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|void
modifier|*
name|gdb_ps_read_buf_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
specifier|const
name|void
modifier|*
name|gdb_ps_write_buf_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|size_t
name|gdb_ps_size_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The next four routines are called by thread_db to tell us to stop and stop    a particular process or lwp.  Since GDB ensures that these are all stopped    by the time we call anything in thread_db, these routines need to do    nothing.  */
end_comment

begin_function
name|ps_err_e
name|ps_pstop
parameter_list|(
name|gdb_ps_prochandle_t
name|ph
parameter_list|)
block|{
return|return
name|PS_OK
return|;
block|}
end_function

begin_function
name|ps_err_e
name|ps_pcontinue
parameter_list|(
name|gdb_ps_prochandle_t
name|ph
parameter_list|)
block|{
return|return
name|PS_OK
return|;
block|}
end_function

begin_function
name|ps_err_e
name|ps_lstop
parameter_list|(
name|gdb_ps_prochandle_t
name|ph
parameter_list|,
name|lwpid_t
name|lwpid
parameter_list|)
block|{
return|return
name|PS_OK
return|;
block|}
end_function

begin_function
name|ps_err_e
name|ps_lcontinue
parameter_list|(
name|gdb_ps_prochandle_t
name|ph
parameter_list|,
name|lwpid_t
name|lwpid
parameter_list|)
block|{
return|return
name|PS_OK
return|;
block|}
end_function

begin_function
name|ps_err_e
name|ps_pglobal_lookup
parameter_list|(
name|gdb_ps_prochandle_t
name|ph
parameter_list|,
specifier|const
name|char
modifier|*
name|ld_object_name
parameter_list|,
specifier|const
name|char
modifier|*
name|ld_symbol_name
parameter_list|,
name|paddr_t
modifier|*
name|ld_symbol_addr
parameter_list|)
block|{
name|struct
name|minimal_symbol
modifier|*
name|ms
decl_stmt|;
name|ms
operator|=
name|lookup_minimal_symbol
argument_list|(
name|ld_symbol_name
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ms
condition|)
return|return
name|PS_NOSYM
return|;
operator|*
name|ld_symbol_addr
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|ms
argument_list|)
expr_stmt|;
return|return
name|PS_OK
return|;
block|}
end_function

begin_comment
comment|/* Common routine for reading and writing memory.  */
end_comment

begin_function
specifier|static
name|ps_err_e
name|rw_common
parameter_list|(
name|int
name|dowrite
parameter_list|,
specifier|const
name|struct
name|ps_prochandle
modifier|*
name|ph
parameter_list|,
name|paddr_t
name|addr
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|old_chain
operator|=
name|save_inferior_pid
argument_list|()
expr_stmt|;
if|if
condition|(
name|is_thread
argument_list|(
name|inferior_pid
argument_list|)
operator|||
comment|/* A thread */
operator|!
name|target_thread_alive
argument_list|(
name|inferior_pid
argument_list|)
condition|)
comment|/* An lwp, but not alive */
name|inferior_pid
operator|=
name|procfs_first_available
argument_list|()
expr_stmt|;
comment|/* Find any live lwp.  */
comment|/* Note: don't need to call switch_to_thread; we're just reading memory.  */
while|while
condition|(
name|size
operator|>
literal|0
condition|)
block|{
name|int
name|cc
decl_stmt|;
if|if
condition|(
name|target_has_execution
condition|)
name|cc
operator|=
name|procfs_ops
operator|.
name|to_xfer_memory
argument_list|(
name|addr
argument_list|,
name|buf
argument_list|,
name|size
argument_list|,
name|dowrite
argument_list|,
operator|&
name|procfs_ops
argument_list|)
expr_stmt|;
else|else
name|cc
operator|=
name|orig_core_ops
operator|.
name|to_xfer_memory
argument_list|(
name|addr
argument_list|,
name|buf
argument_list|,
name|size
argument_list|,
name|dowrite
argument_list|,
operator|&
name|core_ops
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|dowrite
operator|==
literal|0
condition|)
name|print_sys_errmsg
argument_list|(
literal|"rw_common (): read"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
else|else
name|print_sys_errmsg
argument_list|(
literal|"rw_common (): write"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
name|PS_ERR
return|;
block|}
name|size
operator|-=
name|cc
expr_stmt|;
name|buf
operator|+=
name|cc
expr_stmt|;
block|}
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
name|PS_OK
return|;
block|}
end_function

begin_function
name|ps_err_e
name|ps_pdread
parameter_list|(
name|gdb_ps_prochandle_t
name|ph
parameter_list|,
name|paddr_t
name|addr
parameter_list|,
name|gdb_ps_read_buf_t
name|buf
parameter_list|,
name|gdb_ps_size_t
name|size
parameter_list|)
block|{
return|return
name|rw_common
argument_list|(
literal|0
argument_list|,
name|ph
argument_list|,
name|addr
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
return|;
block|}
end_function

begin_function
name|ps_err_e
name|ps_pdwrite
parameter_list|(
name|gdb_ps_prochandle_t
name|ph
parameter_list|,
name|paddr_t
name|addr
parameter_list|,
name|gdb_ps_write_buf_t
name|buf
parameter_list|,
name|gdb_ps_size_t
name|size
parameter_list|)
block|{
return|return
name|rw_common
argument_list|(
literal|1
argument_list|,
name|ph
argument_list|,
name|addr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|size
argument_list|)
return|;
block|}
end_function

begin_function
name|ps_err_e
name|ps_ptread
parameter_list|(
name|gdb_ps_prochandle_t
name|ph
parameter_list|,
name|paddr_t
name|addr
parameter_list|,
name|gdb_ps_read_buf_t
name|buf
parameter_list|,
name|gdb_ps_size_t
name|size
parameter_list|)
block|{
return|return
name|rw_common
argument_list|(
literal|0
argument_list|,
name|ph
argument_list|,
name|addr
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
return|;
block|}
end_function

begin_function
name|ps_err_e
name|ps_ptwrite
parameter_list|(
name|gdb_ps_prochandle_t
name|ph
parameter_list|,
name|paddr_t
name|addr
parameter_list|,
name|gdb_ps_write_buf_t
name|buf
parameter_list|,
name|gdb_ps_size_t
name|size
parameter_list|)
block|{
return|return
name|rw_common
argument_list|(
literal|1
argument_list|,
name|ph
argument_list|,
name|addr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|size
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Get integer regs */
end_comment

begin_function
name|ps_err_e
name|ps_lgetregs
parameter_list|(
name|gdb_ps_prochandle_t
name|ph
parameter_list|,
name|lwpid_t
name|lwpid
parameter_list|,
name|prgregset_t
name|gregset
parameter_list|)
block|{
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|old_chain
operator|=
name|save_inferior_pid
argument_list|()
expr_stmt|;
name|inferior_pid
operator|=
name|BUILD_LWP
argument_list|(
name|lwpid
argument_list|,
name|PIDGET
argument_list|(
name|inferior_pid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_has_execution
condition|)
name|procfs_ops
operator|.
name|to_fetch_registers
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|orig_core_ops
operator|.
name|to_fetch_registers
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fill_gregset
argument_list|(
name|gregset
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
name|PS_OK
return|;
block|}
end_function

begin_comment
comment|/* Set integer regs */
end_comment

begin_function
name|ps_err_e
name|ps_lsetregs
parameter_list|(
name|gdb_ps_prochandle_t
name|ph
parameter_list|,
name|lwpid_t
name|lwpid
parameter_list|,
specifier|const
name|prgregset_t
name|gregset
parameter_list|)
block|{
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|old_chain
operator|=
name|save_inferior_pid
argument_list|()
expr_stmt|;
name|inferior_pid
operator|=
name|BUILD_LWP
argument_list|(
name|lwpid
argument_list|,
name|PIDGET
argument_list|(
name|inferior_pid
argument_list|)
argument_list|)
expr_stmt|;
name|supply_gregset
argument_list|(
name|gregset
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_has_execution
condition|)
name|procfs_ops
operator|.
name|to_store_registers
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|orig_core_ops
operator|.
name|to_store_registers
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
name|PS_OK
return|;
block|}
end_function

begin_function
name|void
name|ps_plog
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vfprintf_filtered
argument_list|(
name|gdb_stderr
argument_list|,
name|fmt
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get size of extra register set.  Currently a noop.  */
end_comment

begin_function
name|ps_err_e
name|ps_lgetxregsize
parameter_list|(
name|gdb_ps_prochandle_t
name|ph
parameter_list|,
name|lwpid_t
name|lwpid
parameter_list|,
name|int
modifier|*
name|xregsize
parameter_list|)
block|{
if|#
directive|if
literal|0
block|int lwp_fd;   int regsize;   ps_err_e val;    val = get_lwp_fd (ph, lwpid,&lwp_fd);   if (val != PS_OK)     return val;    if (ioctl (lwp_fd, PIOCGXREGSIZE,&regsize))     {       if (errno == EINVAL) 	return PS_NOFREGS;
comment|/* XXX Wrong code, but this is the closest 				   thing in proc_service.h  */
block|print_sys_errmsg ("ps_lgetxregsize (): PIOCGXREGSIZE", errno);       return PS_ERR;     }
endif|#
directive|endif
return|return
name|PS_OK
return|;
block|}
end_function

begin_comment
comment|/* Get extra register set.  Currently a noop.  */
end_comment

begin_function
name|ps_err_e
name|ps_lgetxregs
parameter_list|(
name|gdb_ps_prochandle_t
name|ph
parameter_list|,
name|lwpid_t
name|lwpid
parameter_list|,
name|caddr_t
name|xregset
parameter_list|)
block|{
if|#
directive|if
literal|0
block|int lwp_fd;   ps_err_e val;    val = get_lwp_fd (ph, lwpid,&lwp_fd);   if (val != PS_OK)     return val;    if (ioctl (lwp_fd, PIOCGXREG, xregset))     {       print_sys_errmsg ("ps_lgetxregs (): PIOCGXREG", errno);       return PS_ERR;     }
endif|#
directive|endif
return|return
name|PS_OK
return|;
block|}
end_function

begin_comment
comment|/* Set extra register set.  Currently a noop.  */
end_comment

begin_function
name|ps_err_e
name|ps_lsetxregs
parameter_list|(
name|gdb_ps_prochandle_t
name|ph
parameter_list|,
name|lwpid_t
name|lwpid
parameter_list|,
name|caddr_t
name|xregset
parameter_list|)
block|{
if|#
directive|if
literal|0
block|int lwp_fd;   ps_err_e val;    val = get_lwp_fd (ph, lwpid,&lwp_fd);   if (val != PS_OK)     return val;    if (ioctl (lwp_fd, PIOCSXREG, xregset))     {       print_sys_errmsg ("ps_lsetxregs (): PIOCSXREG", errno);       return PS_ERR;     }
endif|#
directive|endif
return|return
name|PS_OK
return|;
block|}
end_function

begin_comment
comment|/* Get floating-point regs.  */
end_comment

begin_function
name|ps_err_e
name|ps_lgetfpregs
parameter_list|(
name|gdb_ps_prochandle_t
name|ph
parameter_list|,
name|lwpid_t
name|lwpid
parameter_list|,
name|prfpregset_t
modifier|*
name|fpregset
parameter_list|)
block|{
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|old_chain
operator|=
name|save_inferior_pid
argument_list|()
expr_stmt|;
name|inferior_pid
operator|=
name|BUILD_LWP
argument_list|(
name|lwpid
argument_list|,
name|PIDGET
argument_list|(
name|inferior_pid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_has_execution
condition|)
name|procfs_ops
operator|.
name|to_fetch_registers
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|orig_core_ops
operator|.
name|to_fetch_registers
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fill_fpregset
argument_list|(
name|fpregset
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
name|PS_OK
return|;
block|}
end_function

begin_comment
comment|/* Set floating-point regs.  */
end_comment

begin_function
name|ps_err_e
name|ps_lsetfpregs
parameter_list|(
name|gdb_ps_prochandle_t
name|ph
parameter_list|,
name|lwpid_t
name|lwpid
parameter_list|,
specifier|const
name|prfpregset_t
modifier|*
name|fpregset
parameter_list|)
block|{
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|old_chain
operator|=
name|save_inferior_pid
argument_list|()
expr_stmt|;
name|inferior_pid
operator|=
name|BUILD_LWP
argument_list|(
name|lwpid
argument_list|,
name|PIDGET
argument_list|(
name|inferior_pid
argument_list|)
argument_list|)
expr_stmt|;
name|supply_fpregset
argument_list|(
name|fpregset
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_has_execution
condition|)
name|procfs_ops
operator|.
name|to_store_registers
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|orig_core_ops
operator|.
name|to_store_registers
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
name|PS_OK
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|TM_I386SOL2_H
end_ifdef

begin_comment
comment|/* Get local descriptor table.  */
end_comment

begin_include
include|#
directive|include
file|<sys/procfs.h>
end_include

begin_include
include|#
directive|include
file|<sys/reg.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysi86.h>
end_include

begin_decl_stmt
specifier|static
name|int
name|nldt_allocated
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ssd
modifier|*
name|ldt_bufp
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
name|ps_err_e
name|ps_lgetLDT
parameter_list|(
name|gdb_ps_prochandle_t
name|ph
parameter_list|,
name|lwpid_t
name|lwpid
parameter_list|,
name|struct
name|ssd
modifier|*
name|pldt
parameter_list|)
block|{
name|gregset_t
name|gregset
decl_stmt|;
name|int
name|lwp_fd
decl_stmt|;
name|ps_err_e
name|val
decl_stmt|;
name|int
name|nldt
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Get procfs file descriptor for the LWP.  */
name|lwp_fd
operator|=
name|procfs_get_pid_fd
argument_list|(
name|BUILD_LWP
argument_list|(
name|lwpid
argument_list|,
name|PIDGET
argument_list|(
name|inferior_pid
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lwp_fd
operator|<
literal|0
condition|)
return|return
name|PS_BADLID
return|;
comment|/* Fetch registers und LDT descriptors.  */
if|if
condition|(
name|ioctl
argument_list|(
name|lwp_fd
argument_list|,
name|PIOCGREG
argument_list|,
operator|&
name|gregset
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
name|PS_ERR
return|;
if|if
condition|(
name|ioctl
argument_list|(
name|lwp_fd
argument_list|,
name|PIOCNLDT
argument_list|,
operator|&
name|nldt
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
name|PS_ERR
return|;
if|if
condition|(
name|nldt_allocated
operator|<
name|nldt
condition|)
block|{
name|ldt_bufp
operator|=
operator|(
expr|struct
name|ssd
operator|*
operator|)
name|xrealloc
argument_list|(
name|ldt_bufp
argument_list|,
operator|(
name|nldt
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ssd
argument_list|)
argument_list|)
expr_stmt|;
name|nldt_allocated
operator|=
name|nldt
expr_stmt|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|lwp_fd
argument_list|,
name|PIOCLDT
argument_list|,
name|ldt_bufp
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
name|PS_ERR
return|;
comment|/* Search LDT for the LWP via register GS.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nldt
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ldt_bufp
index|[
name|i
index|]
operator|.
name|sel
operator|==
operator|(
name|gregset
index|[
name|GS
index|]
operator|&
literal|0xffff
operator|)
condition|)
block|{
operator|*
name|pldt
operator|=
name|ldt_bufp
index|[
name|i
index|]
expr_stmt|;
return|return
name|PS_OK
return|;
block|}
block|}
comment|/* LDT not found.  */
return|return
name|PS_ERR
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TM_I386SOL2_H */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Convert a pid to printable form. */
end_comment

begin_function
name|char
modifier|*
name|solaris_pid_to_str
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
specifier|static
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
comment|/* in case init failed to resolve the libthread_db library */
if|if
condition|(
operator|!
name|procfs_suppress_run
condition|)
return|return
name|procfs_pid_to_str
argument_list|(
name|pid
argument_list|)
return|;
if|if
condition|(
name|is_thread
argument_list|(
name|pid
argument_list|)
condition|)
block|{
name|int
name|lwp
decl_stmt|;
name|lwp
operator|=
name|thread_to_lwp
argument_list|(
name|pid
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|lwp
operator|==
operator|-
literal|1
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"Thread %d (defunct)"
argument_list|,
name|GET_THREAD
argument_list|(
name|pid
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|lwp
operator|!=
operator|-
literal|2
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"Thread %d (LWP %d)"
argument_list|,
name|GET_THREAD
argument_list|(
name|pid
argument_list|)
argument_list|,
name|GET_LWP
argument_list|(
name|lwp
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"Thread %d        "
argument_list|,
name|GET_THREAD
argument_list|(
name|pid
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_LWP
argument_list|(
name|pid
argument_list|)
operator|!=
literal|0
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"LWP    %d        "
argument_list|,
name|GET_LWP
argument_list|(
name|pid
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"process %d    "
argument_list|,
name|PIDGET
argument_list|(
name|pid
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Worker bee for find_new_threads    Callback function that gets called once per USER thread (i.e., not    kernel) thread. */
end_comment

begin_function
specifier|static
name|int
name|sol_find_new_threads_callback
parameter_list|(
name|th
parameter_list|,
name|ignored
parameter_list|)
specifier|const
name|td_thrhandle_t
modifier|*
name|th
decl_stmt|;
name|void
modifier|*
name|ignored
decl_stmt|;
block|{
name|td_err_e
name|retval
decl_stmt|;
name|td_thrinfo_t
name|ti
decl_stmt|;
name|int
name|pid
decl_stmt|;
if|if
condition|(
operator|(
name|retval
operator|=
name|p_td_thr_get_info
argument_list|(
name|th
argument_list|,
operator|&
name|ti
argument_list|)
operator|)
operator|!=
name|TD_OK
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|pid
operator|=
name|BUILD_THREAD
argument_list|(
name|ti
operator|.
name|ti_tid
argument_list|,
name|PIDGET
argument_list|(
name|inferior_pid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|in_thread_list
argument_list|(
name|pid
argument_list|)
condition|)
name|add_thread
argument_list|(
name|pid
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|sol_find_new_threads
parameter_list|()
block|{
comment|/* don't do anything if init failed to resolve the libthread_db library */
if|if
condition|(
operator|!
name|procfs_suppress_run
condition|)
return|return;
if|if
condition|(
name|inferior_pid
operator|==
operator|-
literal|1
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"No process.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|p_td_ta_thr_iter
argument_list|(
name|main_ta
argument_list|,
name|sol_find_new_threads_callback
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|,
name|TD_THR_ANY_STATE
argument_list|,
name|TD_THR_LOWEST_PRIORITY
argument_list|,
name|TD_SIGNO_MASK
argument_list|,
name|TD_THR_ANY_USER_FLAGS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sol_core_open
parameter_list|(
name|filename
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|orig_core_ops
operator|.
name|to_open
argument_list|(
name|filename
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sol_core_close
parameter_list|(
name|quitting
parameter_list|)
name|int
name|quitting
decl_stmt|;
block|{
name|orig_core_ops
operator|.
name|to_close
argument_list|(
name|quitting
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sol_core_detach
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|unpush_target
argument_list|(
operator|&
name|core_ops
argument_list|)
expr_stmt|;
name|orig_core_ops
operator|.
name|to_detach
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sol_core_files_info
parameter_list|(
name|t
parameter_list|)
name|struct
name|target_ops
modifier|*
name|t
decl_stmt|;
block|{
name|orig_core_ops
operator|.
name|to_files_info
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|MAINTENANCE_CMDS
end_ifdef

begin_comment
comment|/* Worker bee for info sol-thread command.  This is a callback function that    gets called once for each Solaris thread (ie. not kernel thread) in the     inferior.  Print anything interesting that we can think of.  */
end_comment

begin_function
specifier|static
name|int
name|info_cb
parameter_list|(
name|th
parameter_list|,
name|s
parameter_list|)
specifier|const
name|td_thrhandle_t
modifier|*
name|th
decl_stmt|;
name|void
modifier|*
name|s
decl_stmt|;
block|{
name|td_err_e
name|ret
decl_stmt|;
name|td_thrinfo_t
name|ti
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|msym
decl_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|p_td_thr_get_info
argument_list|(
name|th
argument_list|,
operator|&
name|ti
argument_list|)
operator|)
operator|==
name|TD_OK
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"%s thread #%d, lwp %d, "
argument_list|,
name|ti
operator|.
name|ti_type
operator|==
name|TD_THR_SYSTEM
condition|?
literal|"system"
else|:
literal|"user  "
argument_list|,
name|ti
operator|.
name|ti_tid
argument_list|,
name|ti
operator|.
name|ti_lid
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ti
operator|.
name|ti_state
condition|)
block|{
default|default:
case|case
name|TD_THR_UNKNOWN
case|:
name|printf_filtered
argument_list|(
literal|"<unknown state>"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TD_THR_STOPPED
case|:
name|printf_filtered
argument_list|(
literal|"(stopped)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TD_THR_RUN
case|:
name|printf_filtered
argument_list|(
literal|"(run)    "
argument_list|)
expr_stmt|;
break|break;
case|case
name|TD_THR_ACTIVE
case|:
name|printf_filtered
argument_list|(
literal|"(active) "
argument_list|)
expr_stmt|;
break|break;
case|case
name|TD_THR_ZOMBIE
case|:
name|printf_filtered
argument_list|(
literal|"(zombie) "
argument_list|)
expr_stmt|;
break|break;
case|case
name|TD_THR_SLEEP
case|:
name|printf_filtered
argument_list|(
literal|"(asleep) "
argument_list|)
expr_stmt|;
break|break;
case|case
name|TD_THR_STOPPED_ASLEEP
case|:
name|printf_filtered
argument_list|(
literal|"(stopped asleep)"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Print thr_create start function: */
if|if
condition|(
name|ti
operator|.
name|ti_startfunc
operator|!=
literal|0
condition|)
if|if
condition|(
name|msym
operator|=
name|lookup_minimal_symbol_by_pc
argument_list|(
name|ti
operator|.
name|ti_startfunc
argument_list|)
condition|)
name|printf_filtered
argument_list|(
literal|"   startfunc: %s\n"
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|msym
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|"   startfunc: 0x%08x\n"
argument_list|,
name|ti
operator|.
name|ti_startfunc
argument_list|)
expr_stmt|;
comment|/* If thread is asleep, print function that went to sleep: */
if|if
condition|(
name|ti
operator|.
name|ti_state
operator|==
name|TD_THR_SLEEP
condition|)
if|if
condition|(
name|msym
operator|=
name|lookup_minimal_symbol_by_pc
argument_list|(
name|ti
operator|.
name|ti_pc
argument_list|)
condition|)
name|printf_filtered
argument_list|(
literal|" - Sleep func: %s\n"
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|msym
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|" - Sleep func: 0x%08x\n"
argument_list|,
name|ti
operator|.
name|ti_startfunc
argument_list|)
expr_stmt|;
comment|/* Wrap up line, if necessary */
if|if
condition|(
name|ti
operator|.
name|ti_state
operator|!=
name|TD_THR_SLEEP
operator|&&
name|ti
operator|.
name|ti_startfunc
operator|==
literal|0
condition|)
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* don't you hate counting newlines? */
block|}
else|else
name|warning
argument_list|(
literal|"info sol-thread: failed to get info for thread."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* List some state about each Solaris user thread in the inferior.  */
end_comment

begin_function
specifier|static
name|void
name|info_solthreads
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|p_td_ta_thr_iter
argument_list|(
name|main_ta
argument_list|,
name|info_cb
argument_list|,
name|args
argument_list|,
name|TD_THR_ANY_STATE
argument_list|,
name|TD_THR_LOWEST_PRIORITY
argument_list|,
name|TD_SIGNO_MASK
argument_list|,
name|TD_THR_ANY_USER_FLAGS
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MAINTENANCE_CMDS */
end_comment

begin_function
specifier|static
name|int
name|ignore
parameter_list|(
name|addr
parameter_list|,
name|contents
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
name|char
modifier|*
name|contents
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|init_sol_thread_ops
parameter_list|()
block|{
name|sol_thread_ops
operator|.
name|to_shortname
operator|=
literal|"solaris-threads"
expr_stmt|;
name|sol_thread_ops
operator|.
name|to_longname
operator|=
literal|"Solaris threads and pthread."
expr_stmt|;
name|sol_thread_ops
operator|.
name|to_doc
operator|=
literal|"Solaris threads and pthread support."
expr_stmt|;
name|sol_thread_ops
operator|.
name|to_open
operator|=
name|sol_thread_open
expr_stmt|;
name|sol_thread_ops
operator|.
name|to_close
operator|=
literal|0
expr_stmt|;
name|sol_thread_ops
operator|.
name|to_attach
operator|=
name|sol_thread_attach
expr_stmt|;
name|sol_thread_ops
operator|.
name|to_detach
operator|=
name|sol_thread_detach
expr_stmt|;
name|sol_thread_ops
operator|.
name|to_resume
operator|=
name|sol_thread_resume
expr_stmt|;
name|sol_thread_ops
operator|.
name|to_wait
operator|=
name|sol_thread_wait
expr_stmt|;
name|sol_thread_ops
operator|.
name|to_fetch_registers
operator|=
name|sol_thread_fetch_registers
expr_stmt|;
name|sol_thread_ops
operator|.
name|to_store_registers
operator|=
name|sol_thread_store_registers
expr_stmt|;
name|sol_thread_ops
operator|.
name|to_prepare_to_store
operator|=
name|sol_thread_prepare_to_store
expr_stmt|;
name|sol_thread_ops
operator|.
name|to_xfer_memory
operator|=
name|sol_thread_xfer_memory
expr_stmt|;
name|sol_thread_ops
operator|.
name|to_files_info
operator|=
name|sol_thread_files_info
expr_stmt|;
name|sol_thread_ops
operator|.
name|to_insert_breakpoint
operator|=
name|memory_insert_breakpoint
expr_stmt|;
name|sol_thread_ops
operator|.
name|to_remove_breakpoint
operator|=
name|memory_remove_breakpoint
expr_stmt|;
name|sol_thread_ops
operator|.
name|to_terminal_init
operator|=
name|terminal_init_inferior
expr_stmt|;
name|sol_thread_ops
operator|.
name|to_terminal_inferior
operator|=
name|terminal_inferior
expr_stmt|;
name|sol_thread_ops
operator|.
name|to_terminal_ours_for_output
operator|=
name|terminal_ours_for_output
expr_stmt|;
name|sol_thread_ops
operator|.
name|to_terminal_ours
operator|=
name|terminal_ours
expr_stmt|;
name|sol_thread_ops
operator|.
name|to_terminal_info
operator|=
name|child_terminal_info
expr_stmt|;
name|sol_thread_ops
operator|.
name|to_kill
operator|=
name|sol_thread_kill_inferior
expr_stmt|;
name|sol_thread_ops
operator|.
name|to_load
operator|=
literal|0
expr_stmt|;
name|sol_thread_ops
operator|.
name|to_lookup_symbol
operator|=
literal|0
expr_stmt|;
name|sol_thread_ops
operator|.
name|to_create_inferior
operator|=
name|sol_thread_create_inferior
expr_stmt|;
name|sol_thread_ops
operator|.
name|to_mourn_inferior
operator|=
name|sol_thread_mourn_inferior
expr_stmt|;
name|sol_thread_ops
operator|.
name|to_can_run
operator|=
name|sol_thread_can_run
expr_stmt|;
name|sol_thread_ops
operator|.
name|to_notice_signals
operator|=
name|sol_thread_notice_signals
expr_stmt|;
name|sol_thread_ops
operator|.
name|to_thread_alive
operator|=
name|sol_thread_alive
expr_stmt|;
name|sol_thread_ops
operator|.
name|to_stop
operator|=
name|sol_thread_stop
expr_stmt|;
name|sol_thread_ops
operator|.
name|to_stratum
operator|=
name|process_stratum
expr_stmt|;
name|sol_thread_ops
operator|.
name|to_has_all_memory
operator|=
literal|1
expr_stmt|;
name|sol_thread_ops
operator|.
name|to_has_memory
operator|=
literal|1
expr_stmt|;
name|sol_thread_ops
operator|.
name|to_has_stack
operator|=
literal|1
expr_stmt|;
name|sol_thread_ops
operator|.
name|to_has_registers
operator|=
literal|1
expr_stmt|;
name|sol_thread_ops
operator|.
name|to_has_execution
operator|=
literal|1
expr_stmt|;
name|sol_thread_ops
operator|.
name|to_has_thread_control
operator|=
name|tc_none
expr_stmt|;
name|sol_thread_ops
operator|.
name|to_sections
operator|=
literal|0
expr_stmt|;
name|sol_thread_ops
operator|.
name|to_sections_end
operator|=
literal|0
expr_stmt|;
name|sol_thread_ops
operator|.
name|to_magic
operator|=
name|OPS_MAGIC
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|init_sol_core_ops
parameter_list|()
block|{
name|sol_core_ops
operator|.
name|to_shortname
operator|=
literal|"solaris-core"
expr_stmt|;
name|sol_core_ops
operator|.
name|to_longname
operator|=
literal|"Solaris core threads and pthread."
expr_stmt|;
name|sol_core_ops
operator|.
name|to_doc
operator|=
literal|"Solaris threads and pthread support for core files."
expr_stmt|;
name|sol_core_ops
operator|.
name|to_open
operator|=
name|sol_core_open
expr_stmt|;
name|sol_core_ops
operator|.
name|to_close
operator|=
name|sol_core_close
expr_stmt|;
name|sol_core_ops
operator|.
name|to_attach
operator|=
name|sol_thread_attach
expr_stmt|;
name|sol_core_ops
operator|.
name|to_detach
operator|=
name|sol_core_detach
expr_stmt|;
comment|/* sol_core_ops.to_resume  = 0; */
comment|/* sol_core_ops.to_wait  = 0;	 */
name|sol_core_ops
operator|.
name|to_fetch_registers
operator|=
name|sol_thread_fetch_registers
expr_stmt|;
comment|/* sol_core_ops.to_store_registers  = 0; */
comment|/* sol_core_ops.to_prepare_to_store  = 0; */
name|sol_core_ops
operator|.
name|to_xfer_memory
operator|=
name|sol_thread_xfer_memory
expr_stmt|;
name|sol_core_ops
operator|.
name|to_files_info
operator|=
name|sol_core_files_info
expr_stmt|;
name|sol_core_ops
operator|.
name|to_insert_breakpoint
operator|=
name|ignore
expr_stmt|;
name|sol_core_ops
operator|.
name|to_remove_breakpoint
operator|=
name|ignore
expr_stmt|;
comment|/* sol_core_ops.to_terminal_init  = 0; */
comment|/* sol_core_ops.to_terminal_inferior  = 0; */
comment|/* sol_core_ops.to_terminal_ours_for_output  = 0; */
comment|/* sol_core_ops.to_terminal_ours  = 0; */
comment|/* sol_core_ops.to_terminal_info  = 0; */
comment|/* sol_core_ops.to_kill  = 0; */
comment|/* sol_core_ops.to_load  = 0; */
comment|/* sol_core_ops.to_lookup_symbol  = 0; */
name|sol_core_ops
operator|.
name|to_create_inferior
operator|=
name|sol_thread_create_inferior
expr_stmt|;
name|sol_core_ops
operator|.
name|to_stratum
operator|=
name|core_stratum
expr_stmt|;
name|sol_core_ops
operator|.
name|to_has_all_memory
operator|=
literal|0
expr_stmt|;
name|sol_core_ops
operator|.
name|to_has_memory
operator|=
literal|1
expr_stmt|;
name|sol_core_ops
operator|.
name|to_has_stack
operator|=
literal|1
expr_stmt|;
name|sol_core_ops
operator|.
name|to_has_registers
operator|=
literal|1
expr_stmt|;
name|sol_core_ops
operator|.
name|to_has_execution
operator|=
literal|0
expr_stmt|;
name|sol_core_ops
operator|.
name|to_has_thread_control
operator|=
name|tc_none
expr_stmt|;
name|sol_core_ops
operator|.
name|to_sections
operator|=
literal|0
expr_stmt|;
name|sol_core_ops
operator|.
name|to_sections_end
operator|=
literal|0
expr_stmt|;
name|sol_core_ops
operator|.
name|to_magic
operator|=
name|OPS_MAGIC
expr_stmt|;
block|}
end_function

begin_comment
comment|/* we suppress the call to add_target of core_ops in corelow because    if there are two targets in the stratum core_stratum, find_core_target    won't know which one to return.  see corelow.c for an additonal    comment on coreops_suppress_target. */
end_comment

begin_decl_stmt
name|int
name|coreops_suppress_target
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|_initialize_sol_thread
parameter_list|()
block|{
name|void
modifier|*
name|dlhandle
decl_stmt|;
name|init_sol_thread_ops
argument_list|()
expr_stmt|;
name|init_sol_core_ops
argument_list|()
expr_stmt|;
name|dlhandle
operator|=
name|dlopen
argument_list|(
literal|"libthread_db.so.1"
argument_list|,
name|RTLD_NOW
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dlhandle
condition|)
goto|goto
name|die
goto|;
define|#
directive|define
name|resolve
parameter_list|(
name|X
parameter_list|)
define|\
value|if (!(p_##X = dlsym (dlhandle, #X))) \     goto die;
name|resolve
argument_list|(
name|td_log
argument_list|)
expr_stmt|;
name|resolve
argument_list|(
name|td_ta_new
argument_list|)
expr_stmt|;
name|resolve
argument_list|(
name|td_ta_delete
argument_list|)
expr_stmt|;
name|resolve
argument_list|(
name|td_init
argument_list|)
expr_stmt|;
name|resolve
argument_list|(
name|td_ta_get_ph
argument_list|)
expr_stmt|;
name|resolve
argument_list|(
name|td_ta_get_nthreads
argument_list|)
expr_stmt|;
name|resolve
argument_list|(
name|td_ta_tsd_iter
argument_list|)
expr_stmt|;
name|resolve
argument_list|(
name|td_ta_thr_iter
argument_list|)
expr_stmt|;
name|resolve
argument_list|(
name|td_thr_validate
argument_list|)
expr_stmt|;
name|resolve
argument_list|(
name|td_thr_tsd
argument_list|)
expr_stmt|;
name|resolve
argument_list|(
name|td_thr_get_info
argument_list|)
expr_stmt|;
name|resolve
argument_list|(
name|td_thr_getfpregs
argument_list|)
expr_stmt|;
name|resolve
argument_list|(
name|td_thr_getxregsize
argument_list|)
expr_stmt|;
name|resolve
argument_list|(
name|td_thr_getxregs
argument_list|)
expr_stmt|;
name|resolve
argument_list|(
name|td_thr_sigsetmask
argument_list|)
expr_stmt|;
name|resolve
argument_list|(
name|td_thr_setprio
argument_list|)
expr_stmt|;
name|resolve
argument_list|(
name|td_thr_setsigpending
argument_list|)
expr_stmt|;
name|resolve
argument_list|(
name|td_thr_setfpregs
argument_list|)
expr_stmt|;
name|resolve
argument_list|(
name|td_thr_setxregs
argument_list|)
expr_stmt|;
name|resolve
argument_list|(
name|td_ta_map_id2thr
argument_list|)
expr_stmt|;
name|resolve
argument_list|(
name|td_ta_map_lwp2thr
argument_list|)
expr_stmt|;
name|resolve
argument_list|(
name|td_thr_getgregs
argument_list|)
expr_stmt|;
name|resolve
argument_list|(
name|td_thr_setgregs
argument_list|)
expr_stmt|;
name|add_target
argument_list|(
operator|&
name|sol_thread_ops
argument_list|)
expr_stmt|;
name|procfs_suppress_run
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|MAINTENANCE_CMDS
name|add_cmd
argument_list|(
literal|"sol-threads"
argument_list|,
name|class_maintenance
argument_list|,
name|info_solthreads
argument_list|,
literal|"Show info on Solaris user threads.\n"
argument_list|,
operator|&
name|maintenanceinfolist
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MAINTENANCE_CMDS */
name|memcpy
argument_list|(
operator|&
name|orig_core_ops
argument_list|,
operator|&
name|core_ops
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|target_ops
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|core_ops
argument_list|,
operator|&
name|sol_core_ops
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|target_ops
argument_list|)
argument_list|)
expr_stmt|;
name|add_target
argument_list|(
operator|&
name|core_ops
argument_list|)
expr_stmt|;
return|return;
name|die
label|:
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"[GDB will not be able to debug user-mode threads: %s]\n"
argument_list|,
name|dlerror
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|dlhandle
condition|)
name|dlclose
argument_list|(
name|dlhandle
argument_list|)
expr_stmt|;
comment|/* allow the user to debug non-threaded core files */
name|add_target
argument_list|(
operator|&
name|core_ops
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

end_unit

