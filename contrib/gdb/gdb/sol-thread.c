begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Low level interface for debugging Solaris threads for GDB, the GNU debugger.    Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002    Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This module implements a sort of half target that sits between the    machine-independent parts of GDB and the /proc interface (procfs.c) to    provide access to the Solaris user-mode thread implementation.     Solaris threads are true user-mode threads, which are invoked via the thr_*    and pthread_* (native and Posix respectivly) interfaces.  These are mostly    implemented in user-space, with all thread context kept in various    structures that live in the user's heap.  These should not be confused with    lightweight processes (LWPs), which are implemented by the kernel, and    scheduled without explicit intervention by the process.     Just to confuse things a little, Solaris threads (both native and Posix) are    actually implemented using LWPs.  In general, there are going to be more    threads than LWPs.  There is no fixed correspondence between a thread and an    LWP.  When a thread wants to run, it gets scheduled onto the first available    LWP and can therefore migrate from one LWP to another as time goes on.  A    sleeping thread may not be associated with an LWP at all!     To make it possible to mess with threads, Sun provides a library called    libthread_db.so.1 (not to be confused with libthread_db.so.0, which doesn't    have a published interface).  This interface has an upper part, which it    provides, and a lower part which I provide.  The upper part consists of the    td_* routines, which allow me to find all the threads, query their state,    etc...  The lower part consists of all of the ps_*, which are used by the    td_* routines to read/write memory, manipulate LWPs, lookup symbols, etc...    The ps_* routines actually do most of their work by calling functions in    procfs.c.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|<thread.h>
end_include

begin_include
include|#
directive|include
file|<proc_service.h>
end_include

begin_include
include|#
directive|include
file|<thread_db.h>
end_include

begin_include
include|#
directive|include
file|"gdbthread.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<dlfcn.h>
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_decl_stmt
specifier|extern
name|struct
name|target_ops
name|sol_thread_ops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward declaration */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|target_ops
name|sol_core_ops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward declaration */
end_comment

begin_comment
comment|/* place to store core_ops before we overwrite it */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|target_ops
name|orig_core_ops
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|target_ops
name|sol_thread_ops
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|target_ops
name|sol_core_ops
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|procfs_suppress_run
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|target_ops
name|procfs_ops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* target vector for procfs.c */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|target_ops
name|core_ops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* target vector for corelow.c */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|procfs_pid_to_str
parameter_list|(
name|ptid_t
name|ptid
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Prototypes for supply_gregset etc. */
end_comment

begin_include
include|#
directive|include
file|"gregset.h"
end_include

begin_comment
comment|/* This struct is defined by us, but mainly used for the proc_service interface.    We don't have much use for it, except as a handy place to get a real pid    for memory accesses.  */
end_comment

begin_struct
struct|struct
name|ps_prochandle
block|{
name|ptid_t
name|ptid
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|string_map
block|{
name|int
name|num
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|ps_prochandle
name|main_ph
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|td_thragent_t
modifier|*
name|main_ta
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sol_thread_active
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|char
modifier|*
name|td_err_string
parameter_list|(
name|td_err_e
name|errcode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|td_state_string
parameter_list|(
name|td_thr_state_e
name|statecode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ptid_t
name|thread_to_lwp
parameter_list|(
name|ptid_t
name|thread_id
parameter_list|,
name|int
name|default_lwp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sol_thread_resume
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
name|int
name|step
parameter_list|,
name|enum
name|target_signal
name|signo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ptid_t
name|lwp_to_thread
parameter_list|(
name|ptid_t
name|lwp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sol_thread_alive
parameter_list|(
name|ptid_t
name|ptid
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sol_core_close
parameter_list|(
name|int
name|quitting
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|init_sol_thread_ops
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|init_sol_core_ops
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Default definitions: These must be defined in tm.h     if they are to be shared with a process module such as procfs.  */
end_comment

begin_define
define|#
directive|define
name|GET_PID
parameter_list|(
name|ptid
parameter_list|)
value|ptid_get_pid (ptid)
end_define

begin_define
define|#
directive|define
name|GET_LWP
parameter_list|(
name|ptid
parameter_list|)
value|ptid_get_lwp (ptid)
end_define

begin_define
define|#
directive|define
name|GET_THREAD
parameter_list|(
name|ptid
parameter_list|)
value|ptid_get_tid (ptid)
end_define

begin_define
define|#
directive|define
name|is_lwp
parameter_list|(
name|ptid
parameter_list|)
value|(GET_LWP (ptid) != 0)
end_define

begin_define
define|#
directive|define
name|is_thread
parameter_list|(
name|ptid
parameter_list|)
value|(GET_THREAD (ptid) != 0)
end_define

begin_define
define|#
directive|define
name|BUILD_LWP
parameter_list|(
name|lwp
parameter_list|,
name|pid
parameter_list|)
value|ptid_build (pid, lwp, 0)
end_define

begin_define
define|#
directive|define
name|BUILD_THREAD
parameter_list|(
name|tid
parameter_list|,
name|pid
parameter_list|)
value|ptid_build (pid, 0, tid)
end_define

begin_comment
comment|/* Pointers to routines from lithread_db resolved by dlopen() */
end_comment

begin_function_decl
specifier|static
name|void
function_decl|(
modifier|*
name|p_td_log
function_decl|)
parameter_list|(
specifier|const
name|int
name|on_off
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|p_td_ta_new
function_decl|)
parameter_list|(
specifier|const
name|struct
name|ps_prochandle
modifier|*
name|ph_p
parameter_list|,
name|td_thragent_t
modifier|*
modifier|*
name|ta_pp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|p_td_ta_delete
function_decl|)
parameter_list|(
name|td_thragent_t
modifier|*
name|ta_p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|p_td_init
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|p_td_ta_get_ph
function_decl|)
parameter_list|(
specifier|const
name|td_thragent_t
modifier|*
name|ta_p
parameter_list|,
name|struct
name|ps_prochandle
modifier|*
modifier|*
name|ph_pp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|p_td_ta_get_nthreads
function_decl|)
parameter_list|(
specifier|const
name|td_thragent_t
modifier|*
name|ta_p
parameter_list|,
name|int
modifier|*
name|nthread_p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|p_td_ta_tsd_iter
function_decl|)
parameter_list|(
specifier|const
name|td_thragent_t
modifier|*
name|ta_p
parameter_list|,
name|td_key_iter_f
modifier|*
name|cb
parameter_list|,
name|void
modifier|*
name|cbdata_p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|p_td_ta_thr_iter
function_decl|)
parameter_list|(
specifier|const
name|td_thragent_t
modifier|*
name|ta_p
parameter_list|,
name|td_thr_iter_f
modifier|*
name|cb
parameter_list|,
name|void
modifier|*
name|cbdata_p
parameter_list|,
name|td_thr_state_e
name|state
parameter_list|,
name|int
name|ti_pri
parameter_list|,
name|sigset_t
modifier|*
name|ti_sigmask_p
parameter_list|,
name|unsigned
name|ti_user_flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|p_td_thr_validate
function_decl|)
parameter_list|(
specifier|const
name|td_thrhandle_t
modifier|*
name|th_p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|p_td_thr_tsd
function_decl|)
parameter_list|(
specifier|const
name|td_thrhandle_t
modifier|*
name|th_p
parameter_list|,
specifier|const
name|thread_key_t
name|key
parameter_list|,
name|void
modifier|*
modifier|*
name|data_pp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|p_td_thr_get_info
function_decl|)
parameter_list|(
specifier|const
name|td_thrhandle_t
modifier|*
name|th_p
parameter_list|,
name|td_thrinfo_t
modifier|*
name|ti_p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|p_td_thr_getfpregs
function_decl|)
parameter_list|(
specifier|const
name|td_thrhandle_t
modifier|*
name|th_p
parameter_list|,
name|prfpregset_t
modifier|*
name|fpregset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|p_td_thr_getxregsize
function_decl|)
parameter_list|(
specifier|const
name|td_thrhandle_t
modifier|*
name|th_p
parameter_list|,
name|int
modifier|*
name|xregsize
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|p_td_thr_getxregs
function_decl|)
parameter_list|(
specifier|const
name|td_thrhandle_t
modifier|*
name|th_p
parameter_list|,
specifier|const
name|caddr_t
name|xregset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|p_td_thr_sigsetmask
function_decl|)
parameter_list|(
specifier|const
name|td_thrhandle_t
modifier|*
name|th_p
parameter_list|,
specifier|const
name|sigset_t
name|ti_sigmask
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|p_td_thr_setprio
function_decl|)
parameter_list|(
specifier|const
name|td_thrhandle_t
modifier|*
name|th_p
parameter_list|,
specifier|const
name|int
name|ti_pri
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|p_td_thr_setsigpending
function_decl|)
parameter_list|(
specifier|const
name|td_thrhandle_t
modifier|*
name|th_p
parameter_list|,
specifier|const
name|uchar_t
name|ti_pending_flag
parameter_list|,
specifier|const
name|sigset_t
name|ti_pending
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|p_td_thr_setfpregs
function_decl|)
parameter_list|(
specifier|const
name|td_thrhandle_t
modifier|*
name|th_p
parameter_list|,
specifier|const
name|prfpregset_t
modifier|*
name|fpregset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|p_td_thr_setxregs
function_decl|)
parameter_list|(
specifier|const
name|td_thrhandle_t
modifier|*
name|th_p
parameter_list|,
specifier|const
name|caddr_t
name|xregset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|p_td_ta_map_id2thr
function_decl|)
parameter_list|(
specifier|const
name|td_thragent_t
modifier|*
name|ta_p
parameter_list|,
name|thread_t
name|tid
parameter_list|,
name|td_thrhandle_t
modifier|*
name|th_p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|p_td_ta_map_lwp2thr
function_decl|)
parameter_list|(
specifier|const
name|td_thragent_t
modifier|*
name|ta_p
parameter_list|,
name|lwpid_t
name|lwpid
parameter_list|,
name|td_thrhandle_t
modifier|*
name|th_p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|p_td_thr_getgregs
function_decl|)
parameter_list|(
specifier|const
name|td_thrhandle_t
modifier|*
name|th_p
parameter_list|,
name|prgregset_t
name|regset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|p_td_thr_setgregs
function_decl|)
parameter_list|(
specifier|const
name|td_thrhandle_t
modifier|*
name|th_p
parameter_list|,
specifier|const
name|prgregset_t
name|regset
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*     LOCAL FUNCTION     td_err_string - Convert a thread_db error code to a string     SYNOPSIS     char * td_err_string (errcode)     DESCRIPTION     Return the thread_db error string associated with errcode.  If errcode    is unknown, then return a message.   */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|td_err_string
parameter_list|(
name|td_err_e
name|errcode
parameter_list|)
block|{
specifier|static
name|struct
name|string_map
name|td_err_table
index|[]
init|=
block|{
block|{
name|TD_OK
block|,
literal|"generic \"call succeeded\""
block|}
block|,
block|{
name|TD_ERR
block|,
literal|"generic error."
block|}
block|,
block|{
name|TD_NOTHR
block|,
literal|"no thread can be found to satisfy query"
block|}
block|,
block|{
name|TD_NOSV
block|,
literal|"no synch. variable can be found to satisfy query"
block|}
block|,
block|{
name|TD_NOLWP
block|,
literal|"no lwp can be found to satisfy query"
block|}
block|,
block|{
name|TD_BADPH
block|,
literal|"invalid process handle"
block|}
block|,
block|{
name|TD_BADTH
block|,
literal|"invalid thread handle"
block|}
block|,
block|{
name|TD_BADSH
block|,
literal|"invalid synchronization handle"
block|}
block|,
block|{
name|TD_BADTA
block|,
literal|"invalid thread agent"
block|}
block|,
block|{
name|TD_BADKEY
block|,
literal|"invalid key"
block|}
block|,
block|{
name|TD_NOMSG
block|,
literal|"td_thr_event_getmsg() called when there was no message"
block|}
block|,
block|{
name|TD_NOFPREGS
block|,
literal|"FPU register set not available for given thread"
block|}
block|,
block|{
name|TD_NOLIBTHREAD
block|,
literal|"application not linked with libthread"
block|}
block|,
block|{
name|TD_NOEVENT
block|,
literal|"requested event is not supported"
block|}
block|,
block|{
name|TD_NOCAPAB
block|,
literal|"capability not available"
block|}
block|,
block|{
name|TD_DBERR
block|,
literal|"Debugger service failed"
block|}
block|,
block|{
name|TD_NOAPLIC
block|,
literal|"Operation not applicable to"
block|}
block|,
block|{
name|TD_NOTSD
block|,
literal|"No thread specific data for this thread"
block|}
block|,
block|{
name|TD_MALLOC
block|,
literal|"Malloc failed"
block|}
block|,
block|{
name|TD_PARTIALREG
block|,
literal|"Only part of register set was written/read"
block|}
block|,
block|{
name|TD_NOXREGS
block|,
literal|"X register set not available for given thread"
block|}
block|}
decl_stmt|;
specifier|const
name|int
name|td_err_size
init|=
sizeof|sizeof
name|td_err_table
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|string_map
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|static
name|char
name|buf
index|[
literal|50
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|td_err_size
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|td_err_table
index|[
name|i
index|]
operator|.
name|num
operator|==
name|errcode
condition|)
return|return
name|td_err_table
index|[
name|i
index|]
operator|.
name|str
return|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"Unknown thread_db error code: %d"
argument_list|,
name|errcode
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*     LOCAL FUNCTION     td_state_string - Convert a thread_db state code to a string     SYNOPSIS     char * td_state_string (statecode)     DESCRIPTION     Return the thread_db state string associated with statecode.  If    statecode is unknown, then return a message.   */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|td_state_string
parameter_list|(
name|td_thr_state_e
name|statecode
parameter_list|)
block|{
specifier|static
name|struct
name|string_map
name|td_thr_state_table
index|[]
init|=
block|{
block|{
name|TD_THR_ANY_STATE
block|,
literal|"any state"
block|}
block|,
block|{
name|TD_THR_UNKNOWN
block|,
literal|"unknown"
block|}
block|,
block|{
name|TD_THR_STOPPED
block|,
literal|"stopped"
block|}
block|,
block|{
name|TD_THR_RUN
block|,
literal|"run"
block|}
block|,
block|{
name|TD_THR_ACTIVE
block|,
literal|"active"
block|}
block|,
block|{
name|TD_THR_ZOMBIE
block|,
literal|"zombie"
block|}
block|,
block|{
name|TD_THR_SLEEP
block|,
literal|"sleep"
block|}
block|,
block|{
name|TD_THR_STOPPED_ASLEEP
block|,
literal|"stopped asleep"
block|}
block|}
decl_stmt|;
specifier|const
name|int
name|td_thr_state_table_size
init|=
sizeof|sizeof
name|td_thr_state_table
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|string_map
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|static
name|char
name|buf
index|[
literal|50
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|td_thr_state_table_size
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|td_thr_state_table
index|[
name|i
index|]
operator|.
name|num
operator|==
name|statecode
condition|)
return|return
name|td_thr_state_table
index|[
name|i
index|]
operator|.
name|str
return|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"Unknown thread_db state code: %d"
argument_list|,
name|statecode
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*     LOCAL FUNCTION     thread_to_lwp - Convert a Posix or Solaris thread id to a LWP id.     SYNOPSIS     tpid_t thread_to_lwp (thread_id, default_lwp)     DESCRIPTION     This function converts a Posix or Solaris thread id to a lightweight    process id.  If thread_id is non-existent, that's an error.  If it's    an inactive thread, then we return default_lwp.     NOTES     This function probably shouldn't call error()...   */
end_comment

begin_function
specifier|static
name|ptid_t
name|thread_to_lwp
parameter_list|(
name|ptid_t
name|thread_id
parameter_list|,
name|int
name|default_lwp
parameter_list|)
block|{
name|td_thrinfo_t
name|ti
decl_stmt|;
name|td_thrhandle_t
name|th
decl_stmt|;
name|td_err_e
name|val
decl_stmt|;
if|if
condition|(
name|is_lwp
argument_list|(
name|thread_id
argument_list|)
condition|)
return|return
name|thread_id
return|;
comment|/* It's already an LWP id */
comment|/* It's a thread.  Convert to lwp */
name|val
operator|=
name|p_td_ta_map_id2thr
argument_list|(
name|main_ta
argument_list|,
name|GET_THREAD
argument_list|(
name|thread_id
argument_list|)
argument_list|,
operator|&
name|th
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|TD_NOTHR
condition|)
return|return
name|pid_to_ptid
argument_list|(
operator|-
literal|1
argument_list|)
return|;
comment|/* thread must have terminated */
elseif|else
if|if
condition|(
name|val
operator|!=
name|TD_OK
condition|)
name|error
argument_list|(
literal|"thread_to_lwp: td_ta_map_id2thr %s"
argument_list|,
name|td_err_string
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
name|val
operator|=
name|p_td_thr_get_info
argument_list|(
operator|&
name|th
argument_list|,
operator|&
name|ti
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|TD_NOTHR
condition|)
return|return
name|pid_to_ptid
argument_list|(
operator|-
literal|1
argument_list|)
return|;
comment|/* thread must have terminated */
elseif|else
if|if
condition|(
name|val
operator|!=
name|TD_OK
condition|)
name|error
argument_list|(
literal|"thread_to_lwp: td_thr_get_info: %s"
argument_list|,
name|td_err_string
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ti
operator|.
name|ti_state
operator|!=
name|TD_THR_ACTIVE
condition|)
block|{
if|if
condition|(
name|default_lwp
operator|!=
operator|-
literal|1
condition|)
return|return
name|pid_to_ptid
argument_list|(
name|default_lwp
argument_list|)
return|;
name|error
argument_list|(
literal|"thread_to_lwp: thread state not active: %s"
argument_list|,
name|td_state_string
argument_list|(
name|ti
operator|.
name|ti_state
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|BUILD_LWP
argument_list|(
name|ti
operator|.
name|ti_lid
argument_list|,
name|PIDGET
argument_list|(
name|thread_id
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*     LOCAL FUNCTION     lwp_to_thread - Convert a LWP id to a Posix or Solaris thread id.     SYNOPSIS     int lwp_to_thread (lwp_id)     DESCRIPTION     This function converts a lightweight process id to a Posix or Solaris    thread id.  If thread_id is non-existent, that's an error.     NOTES     This function probably shouldn't call error()...   */
end_comment

begin_function
specifier|static
name|ptid_t
name|lwp_to_thread
parameter_list|(
name|ptid_t
name|lwp
parameter_list|)
block|{
name|td_thrinfo_t
name|ti
decl_stmt|;
name|td_thrhandle_t
name|th
decl_stmt|;
name|td_err_e
name|val
decl_stmt|;
if|if
condition|(
name|is_thread
argument_list|(
name|lwp
argument_list|)
condition|)
return|return
name|lwp
return|;
comment|/* It's already a thread id */
comment|/* It's an lwp.  Convert it to a thread id.  */
if|if
condition|(
operator|!
name|sol_thread_alive
argument_list|(
name|lwp
argument_list|)
condition|)
return|return
name|pid_to_ptid
argument_list|(
operator|-
literal|1
argument_list|)
return|;
comment|/* defunct lwp */
name|val
operator|=
name|p_td_ta_map_lwp2thr
argument_list|(
name|main_ta
argument_list|,
name|GET_LWP
argument_list|(
name|lwp
argument_list|)
argument_list|,
operator|&
name|th
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|TD_NOTHR
condition|)
return|return
name|pid_to_ptid
argument_list|(
operator|-
literal|1
argument_list|)
return|;
comment|/* thread must have terminated */
elseif|else
if|if
condition|(
name|val
operator|!=
name|TD_OK
condition|)
name|error
argument_list|(
literal|"lwp_to_thread: td_ta_map_lwp2thr: %s."
argument_list|,
name|td_err_string
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
name|val
operator|=
name|p_td_thr_validate
argument_list|(
operator|&
name|th
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|TD_NOTHR
condition|)
return|return
name|lwp
return|;
comment|/* libthread doesn't know about it; 				   just return lwp */
elseif|else
if|if
condition|(
name|val
operator|!=
name|TD_OK
condition|)
name|error
argument_list|(
literal|"lwp_to_thread: td_thr_validate: %s."
argument_list|,
name|td_err_string
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
name|val
operator|=
name|p_td_thr_get_info
argument_list|(
operator|&
name|th
argument_list|,
operator|&
name|ti
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|TD_NOTHR
condition|)
return|return
name|pid_to_ptid
argument_list|(
operator|-
literal|1
argument_list|)
return|;
comment|/* thread must have terminated */
elseif|else
if|if
condition|(
name|val
operator|!=
name|TD_OK
condition|)
name|error
argument_list|(
literal|"lwp_to_thread: td_thr_get_info: %s."
argument_list|,
name|td_err_string
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|BUILD_THREAD
argument_list|(
name|ti
operator|.
name|ti_tid
argument_list|,
name|PIDGET
argument_list|(
name|lwp
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Most target vector functions from here on actually just pass through to    procfs.c, as they don't need to do anything specific for threads.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|sol_thread_open
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|procfs_ops
operator|.
name|to_open
argument_list|(
name|arg
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Attach to process PID, then initialize for debugging it    and wait for the trace-trap that results from attaching.  */
end_comment

begin_function
specifier|static
name|void
name|sol_thread_attach
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|procfs_ops
operator|.
name|to_attach
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
comment|/* Must get symbols from solibs before libthread_db can run! */
name|SOLIB_ADD
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|from_tty
argument_list|,
operator|(
expr|struct
name|target_ops
operator|*
operator|)
literal|0
argument_list|,
name|auto_solib_add
argument_list|)
expr_stmt|;
if|if
condition|(
name|sol_thread_active
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"sol-thread active.\n"
argument_list|)
expr_stmt|;
name|main_ph
operator|.
name|ptid
operator|=
name|inferior_ptid
expr_stmt|;
comment|/* Save for xfer_memory */
name|push_target
argument_list|(
operator|&
name|sol_thread_ops
argument_list|)
expr_stmt|;
name|inferior_ptid
operator|=
name|lwp_to_thread
argument_list|(
name|inferior_ptid
argument_list|)
expr_stmt|;
if|if
condition|(
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|inferior_ptid
operator|=
name|main_ph
operator|.
name|ptid
expr_stmt|;
else|else
name|add_thread
argument_list|(
name|inferior_ptid
argument_list|)
expr_stmt|;
block|}
comment|/* XXX - might want to iterate over all the threads and register them. */
block|}
end_function

begin_comment
comment|/* Take a program previously attached to and detaches it.    The program resumes execution and will no longer stop    on signals, etc.  We'd better not have left any breakpoints    in the program or it'll die when it hits one.  For this    to work, it may be necessary for the process to have been    previously attached.  It *might* work if the program was    started via the normal ptrace (PTRACE_TRACEME).  */
end_comment

begin_function
specifier|static
name|void
name|sol_thread_detach
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|inferior_ptid
operator|=
name|pid_to_ptid
argument_list|(
name|PIDGET
argument_list|(
name|main_ph
operator|.
name|ptid
argument_list|)
argument_list|)
expr_stmt|;
name|unpush_target
argument_list|(
operator|&
name|sol_thread_ops
argument_list|)
expr_stmt|;
name|procfs_ops
operator|.
name|to_detach
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Resume execution of process PID.  If STEP is nozero, then    just single step it.  If SIGNAL is nonzero, restart it with that    signal activated.  We may have to convert pid from a thread-id to an LWP id    for procfs.  */
end_comment

begin_function
specifier|static
name|void
name|sol_thread_resume
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
name|int
name|step
parameter_list|,
name|enum
name|target_signal
name|signo
parameter_list|)
block|{
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|old_chain
operator|=
name|save_inferior_ptid
argument_list|()
expr_stmt|;
name|inferior_ptid
operator|=
name|thread_to_lwp
argument_list|(
name|inferior_ptid
argument_list|,
name|PIDGET
argument_list|(
name|main_ph
operator|.
name|ptid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|inferior_ptid
operator|=
name|procfs_first_available
argument_list|()
expr_stmt|;
if|if
condition|(
name|PIDGET
argument_list|(
name|ptid
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|ptid_t
name|save_ptid
init|=
name|ptid
decl_stmt|;
name|ptid
operator|=
name|thread_to_lwp
argument_list|(
name|ptid
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|PIDGET
argument_list|(
name|ptid
argument_list|)
operator|==
operator|-
literal|2
condition|)
comment|/* Inactive thread */
name|error
argument_list|(
literal|"This version of Solaris can't start inactive threads."
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_verbose
operator|&&
name|PIDGET
argument_list|(
name|ptid
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|warning
argument_list|(
literal|"Specified thread %ld seems to have terminated"
argument_list|,
name|GET_THREAD
argument_list|(
name|save_ptid
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|procfs_ops
operator|.
name|to_resume
argument_list|(
name|ptid
argument_list|,
name|step
argument_list|,
name|signo
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Wait for any threads to stop.  We may have to convert PID from a thread id    to a LWP id, and vice versa on the way out.  */
end_comment

begin_function
specifier|static
name|ptid_t
name|sol_thread_wait
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
name|struct
name|target_waitstatus
modifier|*
name|ourstatus
parameter_list|)
block|{
name|ptid_t
name|rtnval
decl_stmt|;
name|ptid_t
name|save_ptid
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|save_ptid
operator|=
name|inferior_ptid
expr_stmt|;
name|old_chain
operator|=
name|save_inferior_ptid
argument_list|()
expr_stmt|;
name|inferior_ptid
operator|=
name|thread_to_lwp
argument_list|(
name|inferior_ptid
argument_list|,
name|PIDGET
argument_list|(
name|main_ph
operator|.
name|ptid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|inferior_ptid
operator|=
name|procfs_first_available
argument_list|()
expr_stmt|;
if|if
condition|(
name|PIDGET
argument_list|(
name|ptid
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|ptid_t
name|save_ptid
init|=
name|ptid
decl_stmt|;
name|ptid
operator|=
name|thread_to_lwp
argument_list|(
name|ptid
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|PIDGET
argument_list|(
name|ptid
argument_list|)
operator|==
operator|-
literal|2
condition|)
comment|/* Inactive thread */
name|error
argument_list|(
literal|"This version of Solaris can't start inactive threads."
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_verbose
operator|&&
name|PIDGET
argument_list|(
name|ptid
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|warning
argument_list|(
literal|"Specified thread %ld seems to have terminated"
argument_list|,
name|GET_THREAD
argument_list|(
name|save_ptid
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|rtnval
operator|=
name|procfs_ops
operator|.
name|to_wait
argument_list|(
name|ptid
argument_list|,
name|ourstatus
argument_list|)
expr_stmt|;
if|if
condition|(
name|ourstatus
operator|->
name|kind
operator|!=
name|TARGET_WAITKIND_EXITED
condition|)
block|{
comment|/* Map the LWP of interest back to the appropriate thread ID */
name|rtnval
operator|=
name|lwp_to_thread
argument_list|(
name|rtnval
argument_list|)
expr_stmt|;
if|if
condition|(
name|PIDGET
argument_list|(
name|rtnval
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|rtnval
operator|=
name|save_ptid
expr_stmt|;
comment|/* See if we have a new thread */
if|if
condition|(
name|is_thread
argument_list|(
name|rtnval
argument_list|)
operator|&&
operator|!
name|ptid_equal
argument_list|(
name|rtnval
argument_list|,
name|save_ptid
argument_list|)
operator|&&
operator|!
name|in_thread_list
argument_list|(
name|rtnval
argument_list|)
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"[New %s]\n"
argument_list|,
name|target_pid_to_str
argument_list|(
name|rtnval
argument_list|)
argument_list|)
expr_stmt|;
name|add_thread
argument_list|(
name|rtnval
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* During process initialization, we may get here without the thread package      being initialized, since that can only happen after we've found the shared      libs.  */
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
name|rtnval
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sol_thread_fetch_registers
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
name|thread_t
name|thread
decl_stmt|;
name|td_thrhandle_t
name|thandle
decl_stmt|;
name|td_err_e
name|val
decl_stmt|;
name|prgregset_t
name|gregset
decl_stmt|;
name|prfpregset_t
name|fpregset
decl_stmt|;
if|#
directive|if
literal|0
block|int xregsize;   caddr_t xregset;
endif|#
directive|endif
if|if
condition|(
operator|!
name|is_thread
argument_list|(
name|inferior_ptid
argument_list|)
condition|)
block|{
comment|/* LWP: pass the request on to procfs.c */
if|if
condition|(
name|target_has_execution
condition|)
name|procfs_ops
operator|.
name|to_fetch_registers
argument_list|(
name|regno
argument_list|)
expr_stmt|;
else|else
name|orig_core_ops
operator|.
name|to_fetch_registers
argument_list|(
name|regno
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Solaris thread: convert inferior_ptid into a td_thrhandle_t */
name|thread
operator|=
name|GET_THREAD
argument_list|(
name|inferior_ptid
argument_list|)
expr_stmt|;
if|if
condition|(
name|thread
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"sol_thread_fetch_registers:  thread == 0"
argument_list|)
expr_stmt|;
name|val
operator|=
name|p_td_ta_map_id2thr
argument_list|(
name|main_ta
argument_list|,
name|thread
argument_list|,
operator|&
name|thandle
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|TD_OK
condition|)
name|error
argument_list|(
literal|"sol_thread_fetch_registers: td_ta_map_id2thr: %s"
argument_list|,
name|td_err_string
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get the integer regs */
name|val
operator|=
name|p_td_thr_getgregs
argument_list|(
operator|&
name|thandle
argument_list|,
name|gregset
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|TD_OK
operator|&&
name|val
operator|!=
name|TD_PARTIALREG
condition|)
name|error
argument_list|(
literal|"sol_thread_fetch_registers: td_thr_getgregs %s"
argument_list|,
name|td_err_string
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
comment|/* For the sparc, TD_PARTIALREG means that only i0->i7, l0->l7, pc and sp      are saved (by a thread context switch).  */
comment|/* And, now the fp regs */
name|val
operator|=
name|p_td_thr_getfpregs
argument_list|(
operator|&
name|thandle
argument_list|,
operator|&
name|fpregset
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|TD_OK
operator|&&
name|val
operator|!=
name|TD_NOFPREGS
condition|)
name|error
argument_list|(
literal|"sol_thread_fetch_registers: td_thr_getfpregs %s"
argument_list|,
name|td_err_string
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Note that we must call supply_{g fp}regset *after* calling the td routines    because the td routines call ps_lget* which affect the values stored in the    registers array.  */
name|supply_gregset
argument_list|(
operator|(
name|gdb_gregset_t
operator|*
operator|)
operator|&
name|gregset
argument_list|)
expr_stmt|;
name|supply_fpregset
argument_list|(
operator|(
name|gdb_fpregset_t
operator|*
operator|)
operator|&
name|fpregset
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* thread_db doesn't seem to handle this right */
block|val = td_thr_getxregsize (&thandle,&xregsize);   if (val != TD_OK&& val != TD_NOXREGS)     error ("sol_thread_fetch_registers: td_thr_getxregsize %s", 	   td_err_string (val));    if (val == TD_OK)     {       xregset = alloca (xregsize);       val = td_thr_getxregs (&thandle, xregset);       if (val != TD_OK) 	error ("sol_thread_fetch_registers: td_thr_getxregs %s", 	       td_err_string (val));     }
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|sol_thread_store_registers
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
name|thread_t
name|thread
decl_stmt|;
name|td_thrhandle_t
name|thandle
decl_stmt|;
name|td_err_e
name|val
decl_stmt|;
name|prgregset_t
name|gregset
decl_stmt|;
name|prfpregset_t
name|fpregset
decl_stmt|;
if|#
directive|if
literal|0
block|int xregsize;   caddr_t xregset;
endif|#
directive|endif
if|if
condition|(
operator|!
name|is_thread
argument_list|(
name|inferior_ptid
argument_list|)
condition|)
block|{
comment|/* LWP: pass the request on to procfs.c */
name|procfs_ops
operator|.
name|to_store_registers
argument_list|(
name|regno
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Solaris thread: convert inferior_ptid into a td_thrhandle_t */
name|thread
operator|=
name|GET_THREAD
argument_list|(
name|inferior_ptid
argument_list|)
expr_stmt|;
name|val
operator|=
name|p_td_ta_map_id2thr
argument_list|(
name|main_ta
argument_list|,
name|thread
argument_list|,
operator|&
name|thandle
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|TD_OK
condition|)
name|error
argument_list|(
literal|"sol_thread_store_registers: td_ta_map_id2thr %s"
argument_list|,
name|td_err_string
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* Not writing all the regs */
comment|/* save new register value */
name|char
modifier|*
name|old_value
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|REGISTER_SIZE
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|old_value
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|regno
argument_list|)
index|]
argument_list|,
name|REGISTER_SIZE
argument_list|)
expr_stmt|;
name|val
operator|=
name|p_td_thr_getgregs
argument_list|(
operator|&
name|thandle
argument_list|,
name|gregset
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|TD_OK
condition|)
name|error
argument_list|(
literal|"sol_thread_store_registers: td_thr_getgregs %s"
argument_list|,
name|td_err_string
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
name|val
operator|=
name|p_td_thr_getfpregs
argument_list|(
operator|&
name|thandle
argument_list|,
operator|&
name|fpregset
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|TD_OK
condition|)
name|error
argument_list|(
literal|"sol_thread_store_registers: td_thr_getfpregs %s"
argument_list|,
name|td_err_string
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
comment|/* restore new register value */
name|memcpy
argument_list|(
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|regno
argument_list|)
index|]
argument_list|,
name|old_value
argument_list|,
name|REGISTER_SIZE
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* thread_db doesn't seem to handle this right */
block|val = td_thr_getxregsize (&thandle,&xregsize);       if (val != TD_OK&& val != TD_NOXREGS) 	error ("sol_thread_store_registers: td_thr_getxregsize %s", 	       td_err_string (val));        if (val == TD_OK) 	{ 	  xregset = alloca (xregsize); 	  val = td_thr_getxregs (&thandle, xregset); 	  if (val != TD_OK) 	    error ("sol_thread_store_registers: td_thr_getxregs %s", 		   td_err_string (val)); 	}
endif|#
directive|endif
block|}
name|fill_gregset
argument_list|(
operator|(
name|gdb_gregset_t
operator|*
operator|)
operator|&
name|gregset
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|fill_fpregset
argument_list|(
operator|(
name|gdb_fpregset_t
operator|*
operator|)
operator|&
name|fpregset
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|val
operator|=
name|p_td_thr_setgregs
argument_list|(
operator|&
name|thandle
argument_list|,
name|gregset
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|TD_OK
condition|)
name|error
argument_list|(
literal|"sol_thread_store_registers: td_thr_setgregs %s"
argument_list|,
name|td_err_string
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
name|val
operator|=
name|p_td_thr_setfpregs
argument_list|(
operator|&
name|thandle
argument_list|,
operator|&
name|fpregset
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|TD_OK
condition|)
name|error
argument_list|(
literal|"sol_thread_store_registers: td_thr_setfpregs %s"
argument_list|,
name|td_err_string
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* thread_db doesn't seem to handle this right */
block|val = td_thr_getxregsize (&thandle,&xregsize);   if (val != TD_OK&& val != TD_NOXREGS)     error ("sol_thread_store_registers: td_thr_getxregsize %s", 	   td_err_string (val));
comment|/* Should probably do something about writing the xregs here, but what are      they? */
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Get ready to modify the registers array.  On machines which store    individual registers, this doesn't need to do anything.  On machines    which store all the registers in one fell swoop, this makes sure    that registers contains all the registers from the program being    debugged.  */
end_comment

begin_function
specifier|static
name|void
name|sol_thread_prepare_to_store
parameter_list|(
name|void
parameter_list|)
block|{
name|procfs_ops
operator|.
name|to_prepare_to_store
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Transfer LEN bytes between GDB address MYADDR and target address    MEMADDR.  If DOWRITE is non-zero, transfer them to the target,    otherwise transfer them from the target.  TARGET is unused.     Returns the number of bytes transferred. */
end_comment

begin_function
specifier|static
name|int
name|sol_thread_xfer_memory
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|dowrite
parameter_list|,
name|struct
name|mem_attrib
modifier|*
name|attrib
parameter_list|,
name|struct
name|target_ops
modifier|*
name|target
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|old_chain
operator|=
name|save_inferior_ptid
argument_list|()
expr_stmt|;
if|if
condition|(
name|is_thread
argument_list|(
name|inferior_ptid
argument_list|)
operator|||
comment|/* A thread */
operator|!
name|target_thread_alive
argument_list|(
name|inferior_ptid
argument_list|)
condition|)
comment|/* An lwp, but not alive */
name|inferior_ptid
operator|=
name|procfs_first_available
argument_list|()
expr_stmt|;
comment|/* Find any live lwp.  */
comment|/* Note: don't need to call switch_to_thread; we're just reading memory.  */
if|if
condition|(
name|target_has_execution
condition|)
name|retval
operator|=
name|procfs_ops
operator|.
name|to_xfer_memory
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|,
name|dowrite
argument_list|,
name|attrib
argument_list|,
name|target
argument_list|)
expr_stmt|;
else|else
name|retval
operator|=
name|orig_core_ops
operator|.
name|to_xfer_memory
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|,
name|dowrite
argument_list|,
name|attrib
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Print status information about what we're accessing.  */
end_comment

begin_function
specifier|static
name|void
name|sol_thread_files_info
parameter_list|(
name|struct
name|target_ops
modifier|*
name|ignore
parameter_list|)
block|{
name|procfs_ops
operator|.
name|to_files_info
argument_list|(
name|ignore
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sol_thread_kill_inferior
parameter_list|(
name|void
parameter_list|)
block|{
name|procfs_ops
operator|.
name|to_kill
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sol_thread_notice_signals
parameter_list|(
name|ptid_t
name|ptid
parameter_list|)
block|{
name|procfs_ops
operator|.
name|to_notice_signals
argument_list|(
name|pid_to_ptid
argument_list|(
name|PIDGET
argument_list|(
name|ptid
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fork an inferior process, and start debugging it with /proc.  */
end_comment

begin_function
specifier|static
name|void
name|sol_thread_create_inferior
parameter_list|(
name|char
modifier|*
name|exec_file
parameter_list|,
name|char
modifier|*
name|allargs
parameter_list|,
name|char
modifier|*
modifier|*
name|env
parameter_list|)
block|{
name|procfs_ops
operator|.
name|to_create_inferior
argument_list|(
name|exec_file
argument_list|,
name|allargs
argument_list|,
name|env
argument_list|)
expr_stmt|;
if|if
condition|(
name|sol_thread_active
operator|&&
operator|!
name|ptid_equal
argument_list|(
name|inferior_ptid
argument_list|,
name|null_ptid
argument_list|)
condition|)
block|{
name|main_ph
operator|.
name|ptid
operator|=
name|inferior_ptid
expr_stmt|;
comment|/* Save for xfer_memory */
name|push_target
argument_list|(
operator|&
name|sol_thread_ops
argument_list|)
expr_stmt|;
name|inferior_ptid
operator|=
name|lwp_to_thread
argument_list|(
name|inferior_ptid
argument_list|)
expr_stmt|;
if|if
condition|(
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|inferior_ptid
operator|=
name|main_ph
operator|.
name|ptid
expr_stmt|;
if|if
condition|(
operator|!
name|in_thread_list
argument_list|(
name|inferior_ptid
argument_list|)
condition|)
name|add_thread
argument_list|(
name|inferior_ptid
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This routine is called whenever a new symbol table is read in, or when all    symbol tables are removed.  libthread_db can only be initialized when it    finds the right variables in libthread.so.  Since it's a shared library,    those variables don't show up until the library gets mapped and the symbol    table is read in.  */
end_comment

begin_comment
comment|/* This new_objfile event is now managed by a chained function pointer.   * It is the callee's responsability to call the next client on the chain.  */
end_comment

begin_comment
comment|/* Saved pointer to previous owner of the new_objfile event. */
end_comment

begin_function_decl
specifier|static
name|void
function_decl|(
modifier|*
name|target_new_objfile_chain
function_decl|)
parameter_list|(
name|struct
name|objfile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|sol_thread_new_objfile
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|td_err_e
name|val
decl_stmt|;
if|if
condition|(
operator|!
name|objfile
condition|)
block|{
name|sol_thread_active
operator|=
literal|0
expr_stmt|;
goto|goto
name|quit
goto|;
block|}
comment|/* don't do anything if init failed to resolve the libthread_db library */
if|if
condition|(
operator|!
name|procfs_suppress_run
condition|)
goto|goto
name|quit
goto|;
comment|/* Now, initialize the thread debugging library.  This needs to be done after      the shared libraries are located because it needs information from the      user's thread library.  */
name|val
operator|=
name|p_td_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|TD_OK
condition|)
block|{
name|warning
argument_list|(
literal|"sol_thread_new_objfile: td_init: %s"
argument_list|,
name|td_err_string
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|quit
goto|;
block|}
name|val
operator|=
name|p_td_ta_new
argument_list|(
operator|&
name|main_ph
argument_list|,
operator|&
name|main_ta
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|TD_NOLIBTHREAD
condition|)
goto|goto
name|quit
goto|;
elseif|else
if|if
condition|(
name|val
operator|!=
name|TD_OK
condition|)
block|{
name|warning
argument_list|(
literal|"sol_thread_new_objfile: td_ta_new: %s"
argument_list|,
name|td_err_string
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|quit
goto|;
block|}
name|sol_thread_active
operator|=
literal|1
expr_stmt|;
name|quit
label|:
comment|/* Call predecessor on chain, if any. */
if|if
condition|(
name|target_new_objfile_chain
condition|)
name|target_new_objfile_chain
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clean up after the inferior dies.  */
end_comment

begin_function
specifier|static
name|void
name|sol_thread_mourn_inferior
parameter_list|(
name|void
parameter_list|)
block|{
name|unpush_target
argument_list|(
operator|&
name|sol_thread_ops
argument_list|)
expr_stmt|;
name|procfs_ops
operator|.
name|to_mourn_inferior
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Mark our target-struct as eligible for stray "run" and "attach" commands.  */
end_comment

begin_function
specifier|static
name|int
name|sol_thread_can_run
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|procfs_suppress_run
return|;
block|}
end_function

begin_comment
comment|/*      LOCAL FUNCTION     sol_thread_alive     - test thread for "aliveness"     SYNOPSIS     static bool sol_thread_alive (ptid_t ptid);     DESCRIPTION     returns true if thread still active in inferior.   */
end_comment

begin_function
specifier|static
name|int
name|sol_thread_alive
parameter_list|(
name|ptid_t
name|ptid
parameter_list|)
block|{
if|if
condition|(
name|is_thread
argument_list|(
name|ptid
argument_list|)
condition|)
comment|/* non-kernel thread */
block|{
name|td_err_e
name|val
decl_stmt|;
name|td_thrhandle_t
name|th
decl_stmt|;
name|int
name|pid
decl_stmt|;
name|pid
operator|=
name|GET_THREAD
argument_list|(
name|ptid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|=
name|p_td_ta_map_id2thr
argument_list|(
name|main_ta
argument_list|,
name|pid
argument_list|,
operator|&
name|th
argument_list|)
operator|)
operator|!=
name|TD_OK
condition|)
return|return
literal|0
return|;
comment|/* thread not found */
if|if
condition|(
operator|(
name|val
operator|=
name|p_td_thr_validate
argument_list|(
operator|&
name|th
argument_list|)
operator|)
operator|!=
name|TD_OK
condition|)
return|return
literal|0
return|;
comment|/* thread not valid */
return|return
literal|1
return|;
comment|/* known thread: return true */
block|}
else|else
comment|/* kernel thread (LWP): let procfs test it */
block|{
if|if
condition|(
name|target_has_execution
condition|)
return|return
name|procfs_ops
operator|.
name|to_thread_alive
argument_list|(
name|ptid
argument_list|)
return|;
else|else
return|return
name|orig_core_ops
operator|.
name|to_thread_alive
argument_list|(
name|ptid
argument_list|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sol_thread_stop
parameter_list|(
name|void
parameter_list|)
block|{
name|procfs_ops
operator|.
name|to_stop
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* These routines implement the lower half of the thread_db interface.  Ie: the    ps_* routines.  */
end_comment

begin_comment
comment|/* Various versions of<proc_service.h> have slightly    different function prototypes.  In particular, we have     NEWER                        OLDER    struct ps_prochandle *       const struct ps_prochandle *    void*                        char*    const void*          char*    int                  size_t     Which one you have depends on solaris version and what    patches you've applied.  On the theory that there are    only two major variants, we have configure check the    prototype of ps_pdwrite (), and use that info to make    appropriate typedefs here. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PROC_SERVICE_IS_OLD
end_ifdef

begin_typedef
typedef|typedef
specifier|const
name|struct
name|ps_prochandle
modifier|*
name|gdb_ps_prochandle_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|char
modifier|*
name|gdb_ps_read_buf_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|char
modifier|*
name|gdb_ps_write_buf_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|int
name|gdb_ps_size_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|paddr_t
name|gdb_ps_addr_t
typedef|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|struct
name|ps_prochandle
modifier|*
name|gdb_ps_prochandle_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|void
modifier|*
name|gdb_ps_read_buf_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
specifier|const
name|void
modifier|*
name|gdb_ps_write_buf_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|size_t
name|gdb_ps_size_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|psaddr_t
name|gdb_ps_addr_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The next four routines are called by thread_db to tell us to stop and stop    a particular process or lwp.  Since GDB ensures that these are all stopped    by the time we call anything in thread_db, these routines need to do    nothing.  */
end_comment

begin_comment
comment|/* Process stop */
end_comment

begin_function
name|ps_err_e
name|ps_pstop
parameter_list|(
name|gdb_ps_prochandle_t
name|ph
parameter_list|)
block|{
return|return
name|PS_OK
return|;
block|}
end_function

begin_comment
comment|/* Process continue */
end_comment

begin_function
name|ps_err_e
name|ps_pcontinue
parameter_list|(
name|gdb_ps_prochandle_t
name|ph
parameter_list|)
block|{
return|return
name|PS_OK
return|;
block|}
end_function

begin_comment
comment|/* LWP stop */
end_comment

begin_function
name|ps_err_e
name|ps_lstop
parameter_list|(
name|gdb_ps_prochandle_t
name|ph
parameter_list|,
name|lwpid_t
name|lwpid
parameter_list|)
block|{
return|return
name|PS_OK
return|;
block|}
end_function

begin_comment
comment|/* LWP continue */
end_comment

begin_function
name|ps_err_e
name|ps_lcontinue
parameter_list|(
name|gdb_ps_prochandle_t
name|ph
parameter_list|,
name|lwpid_t
name|lwpid
parameter_list|)
block|{
return|return
name|PS_OK
return|;
block|}
end_function

begin_comment
comment|/* Looks up the symbol LD_SYMBOL_NAME in the debugger's symbol table.  */
end_comment

begin_function
name|ps_err_e
name|ps_pglobal_lookup
parameter_list|(
name|gdb_ps_prochandle_t
name|ph
parameter_list|,
specifier|const
name|char
modifier|*
name|ld_object_name
parameter_list|,
specifier|const
name|char
modifier|*
name|ld_symbol_name
parameter_list|,
name|gdb_ps_addr_t
modifier|*
name|ld_symbol_addr
parameter_list|)
block|{
name|struct
name|minimal_symbol
modifier|*
name|ms
decl_stmt|;
name|ms
operator|=
name|lookup_minimal_symbol
argument_list|(
name|ld_symbol_name
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ms
condition|)
return|return
name|PS_NOSYM
return|;
operator|*
name|ld_symbol_addr
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|ms
argument_list|)
expr_stmt|;
return|return
name|PS_OK
return|;
block|}
end_function

begin_comment
comment|/* Common routine for reading and writing memory.  */
end_comment

begin_function
specifier|static
name|ps_err_e
name|rw_common
parameter_list|(
name|int
name|dowrite
parameter_list|,
specifier|const
name|struct
name|ps_prochandle
modifier|*
name|ph
parameter_list|,
name|gdb_ps_addr_t
name|addr
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|old_chain
operator|=
name|save_inferior_ptid
argument_list|()
expr_stmt|;
if|if
condition|(
name|is_thread
argument_list|(
name|inferior_ptid
argument_list|)
operator|||
comment|/* A thread */
operator|!
name|target_thread_alive
argument_list|(
name|inferior_ptid
argument_list|)
condition|)
comment|/* An lwp, but not alive */
name|inferior_ptid
operator|=
name|procfs_first_available
argument_list|()
expr_stmt|;
comment|/* Find any live lwp.  */
comment|/* Note: don't need to call switch_to_thread; we're just reading memory.  */
if|#
directive|if
name|defined
argument_list|(
name|__sparcv9
argument_list|)
comment|/* For Sparc64 cross Sparc32, make sure the address has not been      accidentally sign-extended (or whatever) to beyond 32 bits.  */
if|if
condition|(
name|bfd_get_arch_size
argument_list|(
name|exec_bfd
argument_list|)
operator|==
literal|32
condition|)
name|addr
operator|&=
literal|0xffffffff
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|size
operator|>
literal|0
condition|)
block|{
name|int
name|cc
decl_stmt|;
comment|/* FIXME: passing 0 as attrib argument.  */
if|if
condition|(
name|target_has_execution
condition|)
name|cc
operator|=
name|procfs_ops
operator|.
name|to_xfer_memory
argument_list|(
name|addr
argument_list|,
name|buf
argument_list|,
name|size
argument_list|,
name|dowrite
argument_list|,
literal|0
argument_list|,
operator|&
name|procfs_ops
argument_list|)
expr_stmt|;
else|else
name|cc
operator|=
name|orig_core_ops
operator|.
name|to_xfer_memory
argument_list|(
name|addr
argument_list|,
name|buf
argument_list|,
name|size
argument_list|,
name|dowrite
argument_list|,
literal|0
argument_list|,
operator|&
name|core_ops
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|dowrite
operator|==
literal|0
condition|)
name|print_sys_errmsg
argument_list|(
literal|"rw_common (): read"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
else|else
name|print_sys_errmsg
argument_list|(
literal|"rw_common (): write"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
name|PS_ERR
return|;
block|}
elseif|else
if|if
condition|(
name|cc
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|dowrite
operator|==
literal|0
condition|)
name|warning
argument_list|(
literal|"rw_common (): unable to read at addr 0x%lx"
argument_list|,
operator|(
name|long
operator|)
name|addr
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|"rw_common (): unable to write at addr 0x%lx"
argument_list|,
operator|(
name|long
operator|)
name|addr
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
name|PS_ERR
return|;
block|}
name|size
operator|-=
name|cc
expr_stmt|;
name|buf
operator|+=
name|cc
expr_stmt|;
block|}
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
name|PS_OK
return|;
block|}
end_function

begin_comment
comment|/* Copies SIZE bytes from target process .data segment to debugger memory.  */
end_comment

begin_function
name|ps_err_e
name|ps_pdread
parameter_list|(
name|gdb_ps_prochandle_t
name|ph
parameter_list|,
name|gdb_ps_addr_t
name|addr
parameter_list|,
name|gdb_ps_read_buf_t
name|buf
parameter_list|,
name|gdb_ps_size_t
name|size
parameter_list|)
block|{
return|return
name|rw_common
argument_list|(
literal|0
argument_list|,
name|ph
argument_list|,
name|addr
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Copies SIZE bytes from debugger memory .data segment to target process.  */
end_comment

begin_function
name|ps_err_e
name|ps_pdwrite
parameter_list|(
name|gdb_ps_prochandle_t
name|ph
parameter_list|,
name|gdb_ps_addr_t
name|addr
parameter_list|,
name|gdb_ps_write_buf_t
name|buf
parameter_list|,
name|gdb_ps_size_t
name|size
parameter_list|)
block|{
return|return
name|rw_common
argument_list|(
literal|1
argument_list|,
name|ph
argument_list|,
name|addr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|size
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Copies SIZE bytes from target process .text segment to debugger memory.  */
end_comment

begin_function
name|ps_err_e
name|ps_ptread
parameter_list|(
name|gdb_ps_prochandle_t
name|ph
parameter_list|,
name|gdb_ps_addr_t
name|addr
parameter_list|,
name|gdb_ps_read_buf_t
name|buf
parameter_list|,
name|gdb_ps_size_t
name|size
parameter_list|)
block|{
return|return
name|rw_common
argument_list|(
literal|0
argument_list|,
name|ph
argument_list|,
name|addr
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Copies SIZE bytes from debugger memory .text segment to target process.  */
end_comment

begin_function
name|ps_err_e
name|ps_ptwrite
parameter_list|(
name|gdb_ps_prochandle_t
name|ph
parameter_list|,
name|gdb_ps_addr_t
name|addr
parameter_list|,
name|gdb_ps_write_buf_t
name|buf
parameter_list|,
name|gdb_ps_size_t
name|size
parameter_list|)
block|{
return|return
name|rw_common
argument_list|(
literal|1
argument_list|,
name|ph
argument_list|,
name|addr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|size
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Get integer regs for LWP */
end_comment

begin_function
name|ps_err_e
name|ps_lgetregs
parameter_list|(
name|gdb_ps_prochandle_t
name|ph
parameter_list|,
name|lwpid_t
name|lwpid
parameter_list|,
name|prgregset_t
name|gregset
parameter_list|)
block|{
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|old_chain
operator|=
name|save_inferior_ptid
argument_list|()
expr_stmt|;
name|inferior_ptid
operator|=
name|BUILD_LWP
argument_list|(
name|lwpid
argument_list|,
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_has_execution
condition|)
name|procfs_ops
operator|.
name|to_fetch_registers
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|orig_core_ops
operator|.
name|to_fetch_registers
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fill_gregset
argument_list|(
operator|(
name|gdb_gregset_t
operator|*
operator|)
name|gregset
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
name|PS_OK
return|;
block|}
end_function

begin_comment
comment|/* Set integer regs for LWP */
end_comment

begin_function
name|ps_err_e
name|ps_lsetregs
parameter_list|(
name|gdb_ps_prochandle_t
name|ph
parameter_list|,
name|lwpid_t
name|lwpid
parameter_list|,
specifier|const
name|prgregset_t
name|gregset
parameter_list|)
block|{
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|old_chain
operator|=
name|save_inferior_ptid
argument_list|()
expr_stmt|;
name|inferior_ptid
operator|=
name|BUILD_LWP
argument_list|(
name|lwpid
argument_list|,
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|)
expr_stmt|;
name|supply_gregset
argument_list|(
operator|(
name|gdb_gregset_t
operator|*
operator|)
name|gregset
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_has_execution
condition|)
name|procfs_ops
operator|.
name|to_store_registers
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|orig_core_ops
operator|.
name|to_store_registers
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
name|PS_OK
return|;
block|}
end_function

begin_comment
comment|/* Log a message (sends to gdb_stderr).  */
end_comment

begin_function
name|void
name|ps_plog
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vfprintf_filtered
argument_list|(
name|gdb_stderr
argument_list|,
name|fmt
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get size of extra register set.  Currently a noop.  */
end_comment

begin_function
name|ps_err_e
name|ps_lgetxregsize
parameter_list|(
name|gdb_ps_prochandle_t
name|ph
parameter_list|,
name|lwpid_t
name|lwpid
parameter_list|,
name|int
modifier|*
name|xregsize
parameter_list|)
block|{
if|#
directive|if
literal|0
block|int lwp_fd;   int regsize;   ps_err_e val;    val = get_lwp_fd (ph, lwpid,&lwp_fd);   if (val != PS_OK)     return val;    if (ioctl (lwp_fd, PIOCGXREGSIZE,&regsize))     {       if (errno == EINVAL) 	return PS_NOFREGS;
comment|/* XXX Wrong code, but this is the closest 				   thing in proc_service.h  */
block|print_sys_errmsg ("ps_lgetxregsize (): PIOCGXREGSIZE", errno);       return PS_ERR;     }
endif|#
directive|endif
return|return
name|PS_OK
return|;
block|}
end_function

begin_comment
comment|/* Get extra register set.  Currently a noop.  */
end_comment

begin_function
name|ps_err_e
name|ps_lgetxregs
parameter_list|(
name|gdb_ps_prochandle_t
name|ph
parameter_list|,
name|lwpid_t
name|lwpid
parameter_list|,
name|caddr_t
name|xregset
parameter_list|)
block|{
if|#
directive|if
literal|0
block|int lwp_fd;   ps_err_e val;    val = get_lwp_fd (ph, lwpid,&lwp_fd);   if (val != PS_OK)     return val;    if (ioctl (lwp_fd, PIOCGXREG, xregset))     {       print_sys_errmsg ("ps_lgetxregs (): PIOCGXREG", errno);       return PS_ERR;     }
endif|#
directive|endif
return|return
name|PS_OK
return|;
block|}
end_function

begin_comment
comment|/* Set extra register set.  Currently a noop.  */
end_comment

begin_function
name|ps_err_e
name|ps_lsetxregs
parameter_list|(
name|gdb_ps_prochandle_t
name|ph
parameter_list|,
name|lwpid_t
name|lwpid
parameter_list|,
name|caddr_t
name|xregset
parameter_list|)
block|{
if|#
directive|if
literal|0
block|int lwp_fd;   ps_err_e val;    val = get_lwp_fd (ph, lwpid,&lwp_fd);   if (val != PS_OK)     return val;    if (ioctl (lwp_fd, PIOCSXREG, xregset))     {       print_sys_errmsg ("ps_lsetxregs (): PIOCSXREG", errno);       return PS_ERR;     }
endif|#
directive|endif
return|return
name|PS_OK
return|;
block|}
end_function

begin_comment
comment|/* Get floating-point regs for LWP */
end_comment

begin_function
name|ps_err_e
name|ps_lgetfpregs
parameter_list|(
name|gdb_ps_prochandle_t
name|ph
parameter_list|,
name|lwpid_t
name|lwpid
parameter_list|,
name|prfpregset_t
modifier|*
name|fpregset
parameter_list|)
block|{
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|old_chain
operator|=
name|save_inferior_ptid
argument_list|()
expr_stmt|;
name|inferior_ptid
operator|=
name|BUILD_LWP
argument_list|(
name|lwpid
argument_list|,
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_has_execution
condition|)
name|procfs_ops
operator|.
name|to_fetch_registers
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|orig_core_ops
operator|.
name|to_fetch_registers
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fill_fpregset
argument_list|(
operator|(
name|gdb_fpregset_t
operator|*
operator|)
name|fpregset
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
name|PS_OK
return|;
block|}
end_function

begin_comment
comment|/* Set floating-point regs for LWP */
end_comment

begin_function
name|ps_err_e
name|ps_lsetfpregs
parameter_list|(
name|gdb_ps_prochandle_t
name|ph
parameter_list|,
name|lwpid_t
name|lwpid
parameter_list|,
specifier|const
name|prfpregset_t
modifier|*
name|fpregset
parameter_list|)
block|{
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|old_chain
operator|=
name|save_inferior_ptid
argument_list|()
expr_stmt|;
name|inferior_ptid
operator|=
name|BUILD_LWP
argument_list|(
name|lwpid
argument_list|,
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|)
expr_stmt|;
name|supply_fpregset
argument_list|(
operator|(
name|gdb_fpregset_t
operator|*
operator|)
name|fpregset
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_has_execution
condition|)
name|procfs_ops
operator|.
name|to_store_registers
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|orig_core_ops
operator|.
name|to_store_registers
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
name|PS_OK
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|PR_MODEL_LP64
end_ifdef

begin_comment
comment|/* Identify process as 32-bit or 64-bit.    At the moment I'm using bfd to do this.    There might be a more solaris-specific (eg. procfs) method,    but this ought to work.  */
end_comment

begin_function
name|ps_err_e
name|ps_pdmodel
parameter_list|(
name|gdb_ps_prochandle_t
name|ph
parameter_list|,
name|int
modifier|*
name|data_model
parameter_list|)
block|{
if|if
condition|(
name|exec_bfd
operator|==
literal|0
condition|)
operator|*
name|data_model
operator|=
name|PR_MODEL_UNKNOWN
expr_stmt|;
elseif|else
if|if
condition|(
name|bfd_get_arch_size
argument_list|(
name|exec_bfd
argument_list|)
operator|==
literal|32
condition|)
operator|*
name|data_model
operator|=
name|PR_MODEL_ILP32
expr_stmt|;
else|else
operator|*
name|data_model
operator|=
name|PR_MODEL_LP64
expr_stmt|;
return|return
name|PS_OK
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PR_MODEL_LP64 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TM_I386SOL2_H
end_ifdef

begin_comment
comment|/* Reads the local descriptor table of a LWP.  */
end_comment

begin_function
name|ps_err_e
name|ps_lgetLDT
parameter_list|(
name|gdb_ps_prochandle_t
name|ph
parameter_list|,
name|lwpid_t
name|lwpid
parameter_list|,
name|struct
name|ssd
modifier|*
name|pldt
parameter_list|)
block|{
comment|/* NOTE: only used on Solaris, therefore OK to refer to procfs.c */
specifier|extern
name|struct
name|ssd
modifier|*
name|procfs_find_LDT_entry
argument_list|(
name|ptid_t
argument_list|)
decl_stmt|;
name|struct
name|ssd
modifier|*
name|ret
decl_stmt|;
comment|/* FIXME: can't I get the process ID from the prochandle or something?    */
if|if
condition|(
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
operator|<=
literal|0
operator|||
name|lwpid
operator|<=
literal|0
condition|)
return|return
name|PS_BADLID
return|;
name|ret
operator|=
name|procfs_find_LDT_entry
argument_list|(
name|BUILD_LWP
argument_list|(
name|lwpid
argument_list|,
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|memcpy
argument_list|(
name|pldt
argument_list|,
name|ret
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ssd
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|PS_OK
return|;
block|}
else|else
comment|/* LDT not found. */
return|return
name|PS_ERR
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TM_I386SOL2_H */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Convert a pid to printable form. */
end_comment

begin_function
name|char
modifier|*
name|solaris_pid_to_str
parameter_list|(
name|ptid_t
name|ptid
parameter_list|)
block|{
specifier|static
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
comment|/* in case init failed to resolve the libthread_db library */
if|if
condition|(
operator|!
name|procfs_suppress_run
condition|)
return|return
name|procfs_pid_to_str
argument_list|(
name|ptid
argument_list|)
return|;
if|if
condition|(
name|is_thread
argument_list|(
name|ptid
argument_list|)
condition|)
block|{
name|ptid_t
name|lwp
decl_stmt|;
name|lwp
operator|=
name|thread_to_lwp
argument_list|(
name|ptid
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|PIDGET
argument_list|(
name|lwp
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"Thread %ld (defunct)"
argument_list|,
name|GET_THREAD
argument_list|(
name|ptid
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|PIDGET
argument_list|(
name|lwp
argument_list|)
operator|!=
operator|-
literal|2
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"Thread %ld (LWP %ld)"
argument_list|,
name|GET_THREAD
argument_list|(
name|ptid
argument_list|)
argument_list|,
name|GET_LWP
argument_list|(
name|lwp
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"Thread %ld        "
argument_list|,
name|GET_THREAD
argument_list|(
name|ptid
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_LWP
argument_list|(
name|ptid
argument_list|)
operator|!=
literal|0
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"LWP    %ld        "
argument_list|,
name|GET_LWP
argument_list|(
name|ptid
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"process %d    "
argument_list|,
name|PIDGET
argument_list|(
name|ptid
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Worker bee for find_new_threads    Callback function that gets called once per USER thread (i.e., not    kernel) thread. */
end_comment

begin_function
specifier|static
name|int
name|sol_find_new_threads_callback
parameter_list|(
specifier|const
name|td_thrhandle_t
modifier|*
name|th
parameter_list|,
name|void
modifier|*
name|ignored
parameter_list|)
block|{
name|td_err_e
name|retval
decl_stmt|;
name|td_thrinfo_t
name|ti
decl_stmt|;
name|ptid_t
name|ptid
decl_stmt|;
if|if
condition|(
operator|(
name|retval
operator|=
name|p_td_thr_get_info
argument_list|(
name|th
argument_list|,
operator|&
name|ti
argument_list|)
operator|)
operator|!=
name|TD_OK
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|ptid
operator|=
name|BUILD_THREAD
argument_list|(
name|ti
operator|.
name|ti_tid
argument_list|,
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|in_thread_list
argument_list|(
name|ptid
argument_list|)
condition|)
name|add_thread
argument_list|(
name|ptid
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sol_find_new_threads
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* don't do anything if init failed to resolve the libthread_db library */
if|if
condition|(
operator|!
name|procfs_suppress_run
condition|)
return|return;
if|if
condition|(
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"No process.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|procfs_ops
operator|.
name|to_find_new_threads
argument_list|()
expr_stmt|;
comment|/* first find new kernel threads */
name|p_td_ta_thr_iter
argument_list|(
name|main_ta
argument_list|,
name|sol_find_new_threads_callback
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|,
name|TD_THR_ANY_STATE
argument_list|,
name|TD_THR_LOWEST_PRIORITY
argument_list|,
name|TD_SIGNO_MASK
argument_list|,
name|TD_THR_ANY_USER_FLAGS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sol_core_open
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|orig_core_ops
operator|.
name|to_open
argument_list|(
name|filename
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sol_core_close
parameter_list|(
name|int
name|quitting
parameter_list|)
block|{
name|orig_core_ops
operator|.
name|to_close
argument_list|(
name|quitting
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sol_core_detach
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|unpush_target
argument_list|(
operator|&
name|core_ops
argument_list|)
expr_stmt|;
name|orig_core_ops
operator|.
name|to_detach
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sol_core_files_info
parameter_list|(
name|struct
name|target_ops
modifier|*
name|t
parameter_list|)
block|{
name|orig_core_ops
operator|.
name|to_files_info
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Worker bee for info sol-thread command.  This is a callback function that    gets called once for each Solaris thread (ie. not kernel thread) in the     inferior.  Print anything interesting that we can think of.  */
end_comment

begin_function
specifier|static
name|int
name|info_cb
parameter_list|(
specifier|const
name|td_thrhandle_t
modifier|*
name|th
parameter_list|,
name|void
modifier|*
name|s
parameter_list|)
block|{
name|td_err_e
name|ret
decl_stmt|;
name|td_thrinfo_t
name|ti
decl_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|p_td_thr_get_info
argument_list|(
name|th
argument_list|,
operator|&
name|ti
argument_list|)
operator|)
operator|==
name|TD_OK
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"%s thread #%d, lwp %d, "
argument_list|,
name|ti
operator|.
name|ti_type
operator|==
name|TD_THR_SYSTEM
condition|?
literal|"system"
else|:
literal|"user  "
argument_list|,
name|ti
operator|.
name|ti_tid
argument_list|,
name|ti
operator|.
name|ti_lid
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ti
operator|.
name|ti_state
condition|)
block|{
default|default:
case|case
name|TD_THR_UNKNOWN
case|:
name|printf_filtered
argument_list|(
literal|"<unknown state>"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TD_THR_STOPPED
case|:
name|printf_filtered
argument_list|(
literal|"(stopped)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TD_THR_RUN
case|:
name|printf_filtered
argument_list|(
literal|"(run)    "
argument_list|)
expr_stmt|;
break|break;
case|case
name|TD_THR_ACTIVE
case|:
name|printf_filtered
argument_list|(
literal|"(active) "
argument_list|)
expr_stmt|;
break|break;
case|case
name|TD_THR_ZOMBIE
case|:
name|printf_filtered
argument_list|(
literal|"(zombie) "
argument_list|)
expr_stmt|;
break|break;
case|case
name|TD_THR_SLEEP
case|:
name|printf_filtered
argument_list|(
literal|"(asleep) "
argument_list|)
expr_stmt|;
break|break;
case|case
name|TD_THR_STOPPED_ASLEEP
case|:
name|printf_filtered
argument_list|(
literal|"(stopped asleep)"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Print thr_create start function: */
if|if
condition|(
name|ti
operator|.
name|ti_startfunc
operator|!=
literal|0
condition|)
block|{
name|struct
name|minimal_symbol
modifier|*
name|msym
decl_stmt|;
name|msym
operator|=
name|lookup_minimal_symbol_by_pc
argument_list|(
name|ti
operator|.
name|ti_startfunc
argument_list|)
expr_stmt|;
if|if
condition|(
name|msym
condition|)
name|printf_filtered
argument_list|(
literal|"   startfunc: %s\n"
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|msym
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|"   startfunc: 0x%s\n"
argument_list|,
name|paddr
argument_list|(
name|ti
operator|.
name|ti_startfunc
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If thread is asleep, print function that went to sleep: */
if|if
condition|(
name|ti
operator|.
name|ti_state
operator|==
name|TD_THR_SLEEP
condition|)
block|{
name|struct
name|minimal_symbol
modifier|*
name|msym
decl_stmt|;
name|msym
operator|=
name|lookup_minimal_symbol_by_pc
argument_list|(
name|ti
operator|.
name|ti_pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|msym
condition|)
name|printf_filtered
argument_list|(
literal|" - Sleep func: %s\n"
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|msym
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|" - Sleep func: 0x%s\n"
argument_list|,
name|paddr
argument_list|(
name|ti
operator|.
name|ti_startfunc
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Wrap up line, if necessary */
if|if
condition|(
name|ti
operator|.
name|ti_state
operator|!=
name|TD_THR_SLEEP
operator|&&
name|ti
operator|.
name|ti_startfunc
operator|==
literal|0
condition|)
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* don't you hate counting newlines? */
block|}
else|else
name|warning
argument_list|(
literal|"info sol-thread: failed to get info for thread."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* List some state about each Solaris user thread in the inferior.  */
end_comment

begin_function
specifier|static
name|void
name|info_solthreads
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|p_td_ta_thr_iter
argument_list|(
name|main_ta
argument_list|,
name|info_cb
argument_list|,
name|args
argument_list|,
name|TD_THR_ANY_STATE
argument_list|,
name|TD_THR_LOWEST_PRIORITY
argument_list|,
name|TD_SIGNO_MASK
argument_list|,
name|TD_THR_ANY_USER_FLAGS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|sol_find_memory_regions
parameter_list|(
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|CORE_ADDR
parameter_list|,
name|unsigned
name|long
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
return|return
name|procfs_ops
operator|.
name|to_find_memory_regions
argument_list|(
name|func
argument_list|,
name|data
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|sol_make_note_section
parameter_list|(
name|bfd
modifier|*
name|obfd
parameter_list|,
name|int
modifier|*
name|note_size
parameter_list|)
block|{
return|return
name|procfs_ops
operator|.
name|to_make_corefile_notes
argument_list|(
name|obfd
argument_list|,
name|note_size
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ignore
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|char
modifier|*
name|contents
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|init_sol_thread_ops
parameter_list|(
name|void
parameter_list|)
block|{
name|sol_thread_ops
operator|.
name|to_shortname
operator|=
literal|"solaris-threads"
expr_stmt|;
name|sol_thread_ops
operator|.
name|to_longname
operator|=
literal|"Solaris threads and pthread."
expr_stmt|;
name|sol_thread_ops
operator|.
name|to_doc
operator|=
literal|"Solaris threads and pthread support."
expr_stmt|;
name|sol_thread_ops
operator|.
name|to_open
operator|=
name|sol_thread_open
expr_stmt|;
name|sol_thread_ops
operator|.
name|to_close
operator|=
literal|0
expr_stmt|;
name|sol_thread_ops
operator|.
name|to_attach
operator|=
name|sol_thread_attach
expr_stmt|;
name|sol_thread_ops
operator|.
name|to_detach
operator|=
name|sol_thread_detach
expr_stmt|;
name|sol_thread_ops
operator|.
name|to_resume
operator|=
name|sol_thread_resume
expr_stmt|;
name|sol_thread_ops
operator|.
name|to_wait
operator|=
name|sol_thread_wait
expr_stmt|;
name|sol_thread_ops
operator|.
name|to_fetch_registers
operator|=
name|sol_thread_fetch_registers
expr_stmt|;
name|sol_thread_ops
operator|.
name|to_store_registers
operator|=
name|sol_thread_store_registers
expr_stmt|;
name|sol_thread_ops
operator|.
name|to_prepare_to_store
operator|=
name|sol_thread_prepare_to_store
expr_stmt|;
name|sol_thread_ops
operator|.
name|to_xfer_memory
operator|=
name|sol_thread_xfer_memory
expr_stmt|;
name|sol_thread_ops
operator|.
name|to_files_info
operator|=
name|sol_thread_files_info
expr_stmt|;
name|sol_thread_ops
operator|.
name|to_insert_breakpoint
operator|=
name|memory_insert_breakpoint
expr_stmt|;
name|sol_thread_ops
operator|.
name|to_remove_breakpoint
operator|=
name|memory_remove_breakpoint
expr_stmt|;
name|sol_thread_ops
operator|.
name|to_terminal_init
operator|=
name|terminal_init_inferior
expr_stmt|;
name|sol_thread_ops
operator|.
name|to_terminal_inferior
operator|=
name|terminal_inferior
expr_stmt|;
name|sol_thread_ops
operator|.
name|to_terminal_ours_for_output
operator|=
name|terminal_ours_for_output
expr_stmt|;
name|sol_thread_ops
operator|.
name|to_terminal_ours
operator|=
name|terminal_ours
expr_stmt|;
name|sol_thread_ops
operator|.
name|to_terminal_info
operator|=
name|child_terminal_info
expr_stmt|;
name|sol_thread_ops
operator|.
name|to_kill
operator|=
name|sol_thread_kill_inferior
expr_stmt|;
name|sol_thread_ops
operator|.
name|to_load
operator|=
literal|0
expr_stmt|;
name|sol_thread_ops
operator|.
name|to_lookup_symbol
operator|=
literal|0
expr_stmt|;
name|sol_thread_ops
operator|.
name|to_create_inferior
operator|=
name|sol_thread_create_inferior
expr_stmt|;
name|sol_thread_ops
operator|.
name|to_mourn_inferior
operator|=
name|sol_thread_mourn_inferior
expr_stmt|;
name|sol_thread_ops
operator|.
name|to_can_run
operator|=
name|sol_thread_can_run
expr_stmt|;
name|sol_thread_ops
operator|.
name|to_notice_signals
operator|=
name|sol_thread_notice_signals
expr_stmt|;
name|sol_thread_ops
operator|.
name|to_thread_alive
operator|=
name|sol_thread_alive
expr_stmt|;
name|sol_thread_ops
operator|.
name|to_pid_to_str
operator|=
name|solaris_pid_to_str
expr_stmt|;
name|sol_thread_ops
operator|.
name|to_find_new_threads
operator|=
name|sol_find_new_threads
expr_stmt|;
name|sol_thread_ops
operator|.
name|to_stop
operator|=
name|sol_thread_stop
expr_stmt|;
name|sol_thread_ops
operator|.
name|to_stratum
operator|=
name|process_stratum
expr_stmt|;
name|sol_thread_ops
operator|.
name|to_has_all_memory
operator|=
literal|1
expr_stmt|;
name|sol_thread_ops
operator|.
name|to_has_memory
operator|=
literal|1
expr_stmt|;
name|sol_thread_ops
operator|.
name|to_has_stack
operator|=
literal|1
expr_stmt|;
name|sol_thread_ops
operator|.
name|to_has_registers
operator|=
literal|1
expr_stmt|;
name|sol_thread_ops
operator|.
name|to_has_execution
operator|=
literal|1
expr_stmt|;
name|sol_thread_ops
operator|.
name|to_has_thread_control
operator|=
name|tc_none
expr_stmt|;
name|sol_thread_ops
operator|.
name|to_sections
operator|=
literal|0
expr_stmt|;
name|sol_thread_ops
operator|.
name|to_sections_end
operator|=
literal|0
expr_stmt|;
name|sol_thread_ops
operator|.
name|to_find_memory_regions
operator|=
name|sol_find_memory_regions
expr_stmt|;
name|sol_thread_ops
operator|.
name|to_make_corefile_notes
operator|=
name|sol_make_note_section
expr_stmt|;
name|sol_thread_ops
operator|.
name|to_magic
operator|=
name|OPS_MAGIC
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|init_sol_core_ops
parameter_list|(
name|void
parameter_list|)
block|{
name|sol_core_ops
operator|.
name|to_shortname
operator|=
literal|"solaris-core"
expr_stmt|;
name|sol_core_ops
operator|.
name|to_longname
operator|=
literal|"Solaris core threads and pthread."
expr_stmt|;
name|sol_core_ops
operator|.
name|to_doc
operator|=
literal|"Solaris threads and pthread support for core files."
expr_stmt|;
name|sol_core_ops
operator|.
name|to_open
operator|=
name|sol_core_open
expr_stmt|;
name|sol_core_ops
operator|.
name|to_close
operator|=
name|sol_core_close
expr_stmt|;
name|sol_core_ops
operator|.
name|to_attach
operator|=
name|sol_thread_attach
expr_stmt|;
name|sol_core_ops
operator|.
name|to_detach
operator|=
name|sol_core_detach
expr_stmt|;
comment|/* sol_core_ops.to_resume  = 0; */
comment|/* sol_core_ops.to_wait  = 0;  */
name|sol_core_ops
operator|.
name|to_fetch_registers
operator|=
name|sol_thread_fetch_registers
expr_stmt|;
comment|/* sol_core_ops.to_store_registers  = 0; */
comment|/* sol_core_ops.to_prepare_to_store  = 0; */
name|sol_core_ops
operator|.
name|to_xfer_memory
operator|=
name|sol_thread_xfer_memory
expr_stmt|;
name|sol_core_ops
operator|.
name|to_files_info
operator|=
name|sol_core_files_info
expr_stmt|;
name|sol_core_ops
operator|.
name|to_insert_breakpoint
operator|=
name|ignore
expr_stmt|;
name|sol_core_ops
operator|.
name|to_remove_breakpoint
operator|=
name|ignore
expr_stmt|;
comment|/* sol_core_ops.to_terminal_init  = 0; */
comment|/* sol_core_ops.to_terminal_inferior  = 0; */
comment|/* sol_core_ops.to_terminal_ours_for_output  = 0; */
comment|/* sol_core_ops.to_terminal_ours  = 0; */
comment|/* sol_core_ops.to_terminal_info  = 0; */
comment|/* sol_core_ops.to_kill  = 0; */
comment|/* sol_core_ops.to_load  = 0; */
comment|/* sol_core_ops.to_lookup_symbol  = 0; */
name|sol_core_ops
operator|.
name|to_create_inferior
operator|=
name|sol_thread_create_inferior
expr_stmt|;
name|sol_core_ops
operator|.
name|to_stratum
operator|=
name|core_stratum
expr_stmt|;
name|sol_core_ops
operator|.
name|to_has_all_memory
operator|=
literal|0
expr_stmt|;
name|sol_core_ops
operator|.
name|to_has_memory
operator|=
literal|1
expr_stmt|;
name|sol_core_ops
operator|.
name|to_has_stack
operator|=
literal|1
expr_stmt|;
name|sol_core_ops
operator|.
name|to_has_registers
operator|=
literal|1
expr_stmt|;
name|sol_core_ops
operator|.
name|to_has_execution
operator|=
literal|0
expr_stmt|;
name|sol_core_ops
operator|.
name|to_has_thread_control
operator|=
name|tc_none
expr_stmt|;
name|sol_core_ops
operator|.
name|to_thread_alive
operator|=
name|sol_thread_alive
expr_stmt|;
name|sol_core_ops
operator|.
name|to_pid_to_str
operator|=
name|solaris_pid_to_str
expr_stmt|;
comment|/* On Solaris/x86, when debugging a threaded core file from process<n>,      the following causes "info threads" to produce "procfs: couldn't find pid<n> in procinfo list" where<n> is the pid of the process that produced      the core file.  Disable it for now. */
comment|/* sol_core_ops.to_find_new_threads = sol_find_new_threads; */
name|sol_core_ops
operator|.
name|to_sections
operator|=
literal|0
expr_stmt|;
name|sol_core_ops
operator|.
name|to_sections_end
operator|=
literal|0
expr_stmt|;
name|sol_core_ops
operator|.
name|to_magic
operator|=
name|OPS_MAGIC
expr_stmt|;
block|}
end_function

begin_comment
comment|/* we suppress the call to add_target of core_ops in corelow because    if there are two targets in the stratum core_stratum, find_core_target    won't know which one to return.  see corelow.c for an additonal    comment on coreops_suppress_target. */
end_comment

begin_decl_stmt
name|int
name|coreops_suppress_target
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|_initialize_sol_thread
parameter_list|(
name|void
parameter_list|)
block|{
name|void
modifier|*
name|dlhandle
decl_stmt|;
name|init_sol_thread_ops
argument_list|()
expr_stmt|;
name|init_sol_core_ops
argument_list|()
expr_stmt|;
name|dlhandle
operator|=
name|dlopen
argument_list|(
literal|"libthread_db.so.1"
argument_list|,
name|RTLD_NOW
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dlhandle
condition|)
goto|goto
name|die
goto|;
define|#
directive|define
name|resolve
parameter_list|(
name|X
parameter_list|)
define|\
value|if (!(p_##X = dlsym (dlhandle, #X))) \     goto die;
name|resolve
argument_list|(
name|td_log
argument_list|)
expr_stmt|;
name|resolve
argument_list|(
name|td_ta_new
argument_list|)
expr_stmt|;
name|resolve
argument_list|(
name|td_ta_delete
argument_list|)
expr_stmt|;
name|resolve
argument_list|(
name|td_init
argument_list|)
expr_stmt|;
name|resolve
argument_list|(
name|td_ta_get_ph
argument_list|)
expr_stmt|;
name|resolve
argument_list|(
name|td_ta_get_nthreads
argument_list|)
expr_stmt|;
name|resolve
argument_list|(
name|td_ta_tsd_iter
argument_list|)
expr_stmt|;
name|resolve
argument_list|(
name|td_ta_thr_iter
argument_list|)
expr_stmt|;
name|resolve
argument_list|(
name|td_thr_validate
argument_list|)
expr_stmt|;
name|resolve
argument_list|(
name|td_thr_tsd
argument_list|)
expr_stmt|;
name|resolve
argument_list|(
name|td_thr_get_info
argument_list|)
expr_stmt|;
name|resolve
argument_list|(
name|td_thr_getfpregs
argument_list|)
expr_stmt|;
name|resolve
argument_list|(
name|td_thr_getxregsize
argument_list|)
expr_stmt|;
name|resolve
argument_list|(
name|td_thr_getxregs
argument_list|)
expr_stmt|;
name|resolve
argument_list|(
name|td_thr_sigsetmask
argument_list|)
expr_stmt|;
name|resolve
argument_list|(
name|td_thr_setprio
argument_list|)
expr_stmt|;
name|resolve
argument_list|(
name|td_thr_setsigpending
argument_list|)
expr_stmt|;
name|resolve
argument_list|(
name|td_thr_setfpregs
argument_list|)
expr_stmt|;
name|resolve
argument_list|(
name|td_thr_setxregs
argument_list|)
expr_stmt|;
name|resolve
argument_list|(
name|td_ta_map_id2thr
argument_list|)
expr_stmt|;
name|resolve
argument_list|(
name|td_ta_map_lwp2thr
argument_list|)
expr_stmt|;
name|resolve
argument_list|(
name|td_thr_getgregs
argument_list|)
expr_stmt|;
name|resolve
argument_list|(
name|td_thr_setgregs
argument_list|)
expr_stmt|;
name|add_target
argument_list|(
operator|&
name|sol_thread_ops
argument_list|)
expr_stmt|;
name|procfs_suppress_run
operator|=
literal|1
expr_stmt|;
name|add_cmd
argument_list|(
literal|"sol-threads"
argument_list|,
name|class_maintenance
argument_list|,
name|info_solthreads
argument_list|,
literal|"Show info on Solaris user threads.\n"
argument_list|,
operator|&
name|maintenanceinfolist
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|orig_core_ops
argument_list|,
operator|&
name|core_ops
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|target_ops
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|core_ops
argument_list|,
operator|&
name|sol_core_ops
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|target_ops
argument_list|)
argument_list|)
expr_stmt|;
name|add_target
argument_list|(
operator|&
name|core_ops
argument_list|)
expr_stmt|;
comment|/* Hook into new_objfile notification. */
name|target_new_objfile_chain
operator|=
name|target_new_objfile_hook
expr_stmt|;
name|target_new_objfile_hook
operator|=
name|sol_thread_new_objfile
expr_stmt|;
return|return;
name|die
label|:
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"[GDB will not be able to debug user-mode threads: %s]\n"
argument_list|,
name|dlerror
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|dlhandle
condition|)
name|dlclose
argument_list|(
name|dlhandle
argument_list|)
expr_stmt|;
comment|/* allow the user to debug non-threaded core files */
name|add_target
argument_list|(
operator|&
name|core_ops
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

end_unit

