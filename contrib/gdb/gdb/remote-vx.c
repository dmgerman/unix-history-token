begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Memory-access and commands for remote VxWorks processes, for GDB.    Copyright (C) 1990-95, 1997-98, 1999 Free Software Foundation, Inc.    Contributed by Wind River Systems and Cygnus Support.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"wait.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"complaints.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_comment
comment|/* Required by objfiles.h.  */
end_comment

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_comment
comment|/* Required by objfiles.h.  */
end_comment

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"gdb-stabs.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_define
define|#
directive|define
name|malloc
value|bogon_malloc
end_define

begin_comment
comment|/* Sun claims "char *malloc()" not void * */
end_comment

begin_define
define|#
directive|define
name|free
value|bogon_free
end_define

begin_comment
comment|/* Sun claims "int free()" not void */
end_comment

begin_define
define|#
directive|define
name|realloc
value|bogon_realloc
end_define

begin_comment
comment|/* Sun claims "char *realloc()", not void * */
end_comment

begin_include
include|#
directive|include
file|<rpc/rpc.h>
end_include

begin_undef
undef|#
directive|undef
name|malloc
end_undef

begin_undef
undef|#
directive|undef
name|free
end_undef

begin_undef
undef|#
directive|undef
name|realloc
end_undef

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_comment
comment|/* UTek's<rpc/rpc.h> doesn't #incl this */
end_comment

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|"vx-share/ptrace.h"
end_include

begin_include
include|#
directive|include
file|"vx-share/xdr_ptrace.h"
end_include

begin_include
include|#
directive|include
file|"vx-share/xdr_ld.h"
end_include

begin_include
include|#
directive|include
file|"vx-share/xdr_rdb.h"
end_include

begin_include
include|#
directive|include
file|"vx-share/dbgRpcLib.h"
end_include

begin_include
include|#
directive|include
file|<symtab.h>
end_include

begin_comment
comment|/* Maximum number of bytes to transfer in a single    PTRACE_{READ,WRITE}DATA request.  */
end_comment

begin_define
define|#
directive|define
name|VX_MEMXFER_MAX
value|4096
end_define

begin_function_decl
specifier|extern
name|void
name|vx_read_register
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|vx_write_register
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|symbol_file_command
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|int
name|stop_soon_quietly
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for wait_for_inferior */
end_comment

begin_function_decl
specifier|static
name|int
name|net_step
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|net_ptrace_clnt_call
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Forward decl */
end_comment

begin_function_decl
specifier|static
name|enum
name|clnt_stat
name|net_clnt_call
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Forward decl */
end_comment

begin_comment
comment|/* Target ops structure for accessing memory and such over the net */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|target_ops
name|vx_ops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Target ops structure for accessing VxWorks child processes over the net */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|target_ops
name|vx_run_ops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Saved name of target host and called function for "info files".    Both malloc'd.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|vx_host
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|vx_running
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Called function */
end_comment

begin_comment
comment|/* Nonzero means target that is being debugged remotely has a floating    point processor.  */
end_comment

begin_decl_stmt
name|int
name|target_has_fp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default error message when the network is forking up.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rpcerr
index|[]
init|=
literal|"network target debugging:  rpc error"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|CLIENT
modifier|*
name|pClient
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* client used in net debugging */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ptraceSock
init|=
name|RPC_ANYSOCK
decl_stmt|;
end_decl_stmt

begin_function_decl
name|enum
name|clnt_stat
name|net_clnt_call
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|parse_args
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|timeval
name|rpcTimeout
init|=
block|{
literal|10
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|char
modifier|*
name|skip_white_space
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|find_white_space
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Tell the VxWorks target system to download a file.    The load addresses of the text, data, and bss segments are    stored in *pTextAddr, *pDataAddr, and *pBssAddr (respectively).    Returns 0 for success, -1 for failure.  */
end_comment

begin_function
specifier|static
name|int
name|net_load
parameter_list|(
name|filename
parameter_list|,
name|pTextAddr
parameter_list|,
name|pDataAddr
parameter_list|,
name|pBssAddr
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|CORE_ADDR
modifier|*
name|pTextAddr
decl_stmt|;
name|CORE_ADDR
modifier|*
name|pDataAddr
decl_stmt|;
name|CORE_ADDR
modifier|*
name|pBssAddr
decl_stmt|;
block|{
name|enum
name|clnt_stat
name|status
decl_stmt|;
name|struct
name|ldfile
name|ldstruct
decl_stmt|;
name|struct
name|timeval
name|load_timeout
decl_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ldstruct
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|ldstruct
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We invoke clnt_call () here directly, instead of through      net_clnt_call (), because we need to set a large timeout value.      The load on the target side can take quite a while, easily      more than 10 seconds.  The user can kill this call by typing      CTRL-C if there really is a problem with the load.         Do not change the tv_sec value without checking -- select() imposes      a limit of 10**8 on it for no good reason that I can see...  */
name|load_timeout
operator|.
name|tv_sec
operator|=
literal|99999999
expr_stmt|;
comment|/* A large number, effectively inf. */
name|load_timeout
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|status
operator|=
name|clnt_call
argument_list|(
name|pClient
argument_list|,
name|VX_LOAD
argument_list|,
name|xdr_wrapstring
argument_list|,
operator|&
name|filename
argument_list|,
name|xdr_ldfile
argument_list|,
operator|&
name|ldstruct
argument_list|,
name|load_timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|RPC_SUCCESS
condition|)
block|{
if|if
condition|(
operator|*
name|ldstruct
operator|.
name|name
operator|==
literal|0
condition|)
comment|/* load failed on VxWorks side */
return|return
operator|-
literal|1
return|;
operator|*
name|pTextAddr
operator|=
name|ldstruct
operator|.
name|txt_addr
expr_stmt|;
operator|*
name|pDataAddr
operator|=
name|ldstruct
operator|.
name|data_addr
expr_stmt|;
operator|*
name|pBssAddr
operator|=
name|ldstruct
operator|.
name|bss_addr
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* returns 0 if successful, errno if RPC failed or VxWorks complains. */
end_comment

begin_function
specifier|static
name|int
name|net_break
parameter_list|(
name|addr
parameter_list|,
name|procnum
parameter_list|)
name|int
name|addr
decl_stmt|;
name|u_long
name|procnum
decl_stmt|;
block|{
name|enum
name|clnt_stat
name|status
decl_stmt|;
name|int
name|break_status
decl_stmt|;
name|Rptrace
name|ptrace_in
decl_stmt|;
comment|/* XXX This is stupid.  It doesn't need to be a ptrace 			 structure.  How about something smaller? */
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ptrace_in
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|ptrace_in
argument_list|)
argument_list|)
expr_stmt|;
name|break_status
operator|=
literal|0
expr_stmt|;
name|ptrace_in
operator|.
name|addr
operator|=
name|addr
expr_stmt|;
name|ptrace_in
operator|.
name|pid
operator|=
name|inferior_pid
expr_stmt|;
name|status
operator|=
name|net_clnt_call
argument_list|(
name|procnum
argument_list|,
name|xdr_rptrace
argument_list|,
operator|&
name|ptrace_in
argument_list|,
name|xdr_int
argument_list|,
operator|&
name|break_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|RPC_SUCCESS
condition|)
return|return
name|errno
return|;
if|if
condition|(
name|break_status
operator|==
operator|-
literal|1
condition|)
return|return
name|ENOMEM
return|;
return|return
name|break_status
return|;
comment|/* probably (FIXME) zero */
block|}
end_function

begin_comment
comment|/* returns 0 if successful, errno otherwise */
end_comment

begin_function
specifier|static
name|int
name|vx_insert_breakpoint
parameter_list|(
name|addr
parameter_list|)
name|int
name|addr
decl_stmt|;
block|{
return|return
name|net_break
argument_list|(
name|addr
argument_list|,
name|VX_BREAK_ADD
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* returns 0 if successful, errno otherwise */
end_comment

begin_function
specifier|static
name|int
name|vx_remove_breakpoint
parameter_list|(
name|addr
parameter_list|)
name|int
name|addr
decl_stmt|;
block|{
return|return
name|net_break
argument_list|(
name|addr
argument_list|,
name|VX_BREAK_DELETE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Start an inferior process and sets inferior_pid to its pid.    EXEC_FILE is the file to run.    ALLARGS is a string containing the arguments to the program.    ENV is the environment vector to pass.    Returns process id.  Errors reported with error().    On VxWorks, we ignore exec_file.  */
end_comment

begin_function
specifier|static
name|void
name|vx_create_inferior
parameter_list|(
name|exec_file
parameter_list|,
name|args
parameter_list|,
name|env
parameter_list|)
name|char
modifier|*
name|exec_file
decl_stmt|;
name|char
modifier|*
name|args
decl_stmt|;
name|char
modifier|*
modifier|*
name|env
decl_stmt|;
block|{
name|enum
name|clnt_stat
name|status
decl_stmt|;
name|arg_array
name|passArgs
decl_stmt|;
name|TASK_START
name|taskStart
decl_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|passArgs
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|passArgs
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|taskStart
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|taskStart
argument_list|)
argument_list|)
expr_stmt|;
comment|/* parse arguments, put them in passArgs */
name|parse_args
argument_list|(
name|args
argument_list|,
operator|&
name|passArgs
argument_list|)
expr_stmt|;
if|if
condition|(
name|passArgs
operator|.
name|arg_array_len
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"You must specify a function name to run, and arguments if any"
argument_list|)
expr_stmt|;
name|status
operator|=
name|net_clnt_call
argument_list|(
name|PROCESS_START
argument_list|,
name|xdr_arg_array
argument_list|,
operator|&
name|passArgs
argument_list|,
name|xdr_TASK_START
argument_list|,
operator|&
name|taskStart
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|!=
name|RPC_SUCCESS
operator|)
operator|||
operator|(
name|taskStart
operator|.
name|status
operator|==
operator|-
literal|1
operator|)
condition|)
name|error
argument_list|(
literal|"Can't create process on remote target machine"
argument_list|)
expr_stmt|;
comment|/* Save the name of the running function */
name|vx_running
operator|=
name|savestring
argument_list|(
name|passArgs
operator|.
name|arg_array_val
index|[
literal|0
index|]
argument_list|,
name|strlen
argument_list|(
name|passArgs
operator|.
name|arg_array_val
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|push_target
argument_list|(
operator|&
name|vx_run_ops
argument_list|)
expr_stmt|;
name|inferior_pid
operator|=
name|taskStart
operator|.
name|pid
expr_stmt|;
comment|/* We will get a trace trap after one instruction.      Insert breakpoints and continue.  */
name|init_wait_for_inferior
argument_list|()
expr_stmt|;
comment|/* Set up the "saved terminal modes" of the inferior      based on what modes we are starting it with.  */
name|target_terminal_init
argument_list|()
expr_stmt|;
comment|/* Install inferior's terminal modes.  */
name|target_terminal_inferior
argument_list|()
expr_stmt|;
name|stop_soon_quietly
operator|=
literal|1
expr_stmt|;
name|wait_for_inferior
argument_list|()
expr_stmt|;
comment|/* Get the task spawn event */
name|stop_soon_quietly
operator|=
literal|0
expr_stmt|;
comment|/* insert_step_breakpoint ();  FIXME, do we need this?  */
name|proceed
argument_list|(
operator|-
literal|1
argument_list|,
name|TARGET_SIGNAL_DEFAULT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fill ARGSTRUCT in argc/argv form with the arguments from the    argument string ARGSTRING.  */
end_comment

begin_function
specifier|static
name|void
name|parse_args
parameter_list|(
name|arg_string
parameter_list|,
name|arg_struct
parameter_list|)
specifier|register
name|char
modifier|*
name|arg_string
decl_stmt|;
name|arg_array
modifier|*
name|arg_struct
decl_stmt|;
block|{
specifier|register
name|int
name|arg_count
init|=
literal|0
decl_stmt|;
comment|/* number of arguments */
specifier|register
name|int
name|arg_index
init|=
literal|0
decl_stmt|;
specifier|register
name|char
modifier|*
name|p0
decl_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|arg_struct
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|arg_array
argument_list|)
argument_list|)
expr_stmt|;
comment|/* first count how many arguments there are */
name|p0
operator|=
name|arg_string
expr_stmt|;
while|while
condition|(
operator|*
name|p0
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|p0
operator|=
name|skip_white_space
argument_list|(
name|p0
argument_list|)
operator|)
operator|==
literal|'\0'
condition|)
break|break;
name|p0
operator|=
name|find_white_space
argument_list|(
name|p0
argument_list|)
expr_stmt|;
name|arg_count
operator|++
expr_stmt|;
block|}
name|arg_struct
operator|->
name|arg_array_len
operator|=
name|arg_count
expr_stmt|;
name|arg_struct
operator|->
name|arg_array_val
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|arg_count
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* now copy argument strings into arg_struct.  */
while|while
condition|(
operator|*
operator|(
name|arg_string
operator|=
name|skip_white_space
argument_list|(
name|arg_string
argument_list|)
operator|)
condition|)
block|{
name|p0
operator|=
name|find_white_space
argument_list|(
name|arg_string
argument_list|)
expr_stmt|;
name|arg_struct
operator|->
name|arg_array_val
index|[
name|arg_index
operator|++
index|]
operator|=
name|savestring
argument_list|(
name|arg_string
argument_list|,
name|p0
operator|-
name|arg_string
argument_list|)
expr_stmt|;
name|arg_string
operator|=
name|p0
expr_stmt|;
block|}
name|arg_struct
operator|->
name|arg_array_val
index|[
name|arg_count
index|]
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Advance a string pointer across whitespace and return a pointer    to the first non-white character.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|skip_white_space
parameter_list|(
name|p
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
block|{
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Search for the first unquoted whitespace character in a string.    Returns a pointer to the character, or to the null terminator    if no whitespace is found.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|find_white_space
parameter_list|(
name|p
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|)
operator|!=
literal|' '
operator|&&
name|c
operator|!=
literal|'\t'
operator|&&
name|c
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\''
operator|||
name|c
operator|==
literal|'"'
condition|)
block|{
while|while
condition|(
operator|*
operator|++
name|p
operator|!=
name|c
operator|&&
operator|*
name|p
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\\'
condition|)
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|*
name|p
condition|)
break|break;
block|}
name|p
operator|++
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Poll the VxWorks target system for an event related    to the debugged task.    Returns -1 if remote wait failed, task status otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|net_wait
parameter_list|(
name|pEvent
parameter_list|)
name|RDB_EVENT
modifier|*
name|pEvent
decl_stmt|;
block|{
name|int
name|pid
decl_stmt|;
name|enum
name|clnt_stat
name|status
decl_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pEvent
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|RDB_EVENT
argument_list|)
argument_list|)
expr_stmt|;
name|pid
operator|=
name|inferior_pid
expr_stmt|;
name|status
operator|=
name|net_clnt_call
argument_list|(
name|PROCESS_WAIT
argument_list|,
name|xdr_int
argument_list|,
operator|&
name|pid
argument_list|,
name|xdr_RDB_EVENT
argument_list|,
name|pEvent
argument_list|)
expr_stmt|;
comment|/* return (status == RPC_SUCCESS)? pEvent->status: -1; */
if|if
condition|(
name|status
operator|==
name|RPC_SUCCESS
condition|)
return|return
operator|(
operator|(
name|pEvent
operator|->
name|status
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
return|;
elseif|else
if|if
condition|(
name|status
operator|==
name|RPC_TIMEDOUT
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Suspend the remote task.    Returns -1 if suspend fails on target system, 0 otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|net_quit
parameter_list|()
block|{
name|int
name|pid
decl_stmt|;
name|int
name|quit_status
decl_stmt|;
name|enum
name|clnt_stat
name|status
decl_stmt|;
name|quit_status
operator|=
literal|0
expr_stmt|;
comment|/* don't let rdbTask suspend itself by passing a pid of 0 */
if|if
condition|(
operator|(
name|pid
operator|=
name|inferior_pid
operator|)
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|status
operator|=
name|net_clnt_call
argument_list|(
name|VX_TASK_SUSPEND
argument_list|,
name|xdr_int
argument_list|,
operator|&
name|pid
argument_list|,
name|xdr_int
argument_list|,
operator|&
name|quit_status
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|==
name|RPC_SUCCESS
operator|)
condition|?
name|quit_status
else|:
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Read a register or registers from the remote system.  */
end_comment

begin_function
name|void
name|net_read_registers
parameter_list|(
name|reg_buf
parameter_list|,
name|len
parameter_list|,
name|procnum
parameter_list|)
name|char
modifier|*
name|reg_buf
decl_stmt|;
name|int
name|len
decl_stmt|;
name|u_long
name|procnum
decl_stmt|;
block|{
name|int
name|status
decl_stmt|;
name|Rptrace
name|ptrace_in
decl_stmt|;
name|Ptrace_return
name|ptrace_out
decl_stmt|;
name|C_bytes
name|out_data
decl_stmt|;
name|char
name|message
index|[
literal|100
index|]
decl_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ptrace_in
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|ptrace_in
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ptrace_out
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|ptrace_out
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize RPC input argument structure.  */
name|ptrace_in
operator|.
name|pid
operator|=
name|inferior_pid
expr_stmt|;
name|ptrace_in
operator|.
name|info
operator|.
name|ttype
operator|=
name|NOINFO
expr_stmt|;
comment|/* Initialize RPC return value structure.  */
name|out_data
operator|.
name|bytes
operator|=
name|reg_buf
expr_stmt|;
name|out_data
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|ptrace_out
operator|.
name|info
operator|.
name|more_data
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|out_data
expr_stmt|;
comment|/* Call RPC; take an error exit if appropriate.  */
name|status
operator|=
name|net_ptrace_clnt_call
argument_list|(
name|procnum
argument_list|,
operator|&
name|ptrace_in
argument_list|,
operator|&
name|ptrace_out
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
name|error
argument_list|(
name|rpcerr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptrace_out
operator|.
name|status
operator|==
operator|-
literal|1
condition|)
block|{
name|errno
operator|=
name|ptrace_out
operator|.
name|errno_num
expr_stmt|;
name|sprintf
argument_list|(
name|message
argument_list|,
literal|"reading %s registers"
argument_list|,
operator|(
name|procnum
operator|==
name|PTRACE_GETREGS
operator|)
condition|?
literal|"general-purpose"
else|:
literal|"floating-point"
argument_list|)
expr_stmt|;
name|perror_with_name
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Write register values to a VxWorks target.  REG_BUF points to a buffer    containing the raw register values, LEN is the length of REG_BUF in    bytes, and PROCNUM is the RPC procedure number (PTRACE_SETREGS or    PTRACE_SETFPREGS).  An error exit is taken if the RPC call fails or    if an error status is returned by the remote debug server.  This is    a utility routine used by vx_write_register ().  */
end_comment

begin_function
name|void
name|net_write_registers
parameter_list|(
name|reg_buf
parameter_list|,
name|len
parameter_list|,
name|procnum
parameter_list|)
name|char
modifier|*
name|reg_buf
decl_stmt|;
name|int
name|len
decl_stmt|;
name|u_long
name|procnum
decl_stmt|;
block|{
name|int
name|status
decl_stmt|;
name|Rptrace
name|ptrace_in
decl_stmt|;
name|Ptrace_return
name|ptrace_out
decl_stmt|;
name|C_bytes
name|in_data
decl_stmt|;
name|char
name|message
index|[
literal|100
index|]
decl_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ptrace_in
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|ptrace_in
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ptrace_out
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|ptrace_out
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize RPC input argument structure.  */
name|in_data
operator|.
name|bytes
operator|=
name|reg_buf
expr_stmt|;
name|in_data
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|ptrace_in
operator|.
name|pid
operator|=
name|inferior_pid
expr_stmt|;
name|ptrace_in
operator|.
name|info
operator|.
name|ttype
operator|=
name|DATA
expr_stmt|;
name|ptrace_in
operator|.
name|info
operator|.
name|more_data
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|in_data
expr_stmt|;
comment|/* Call RPC; take an error exit if appropriate.  */
name|status
operator|=
name|net_ptrace_clnt_call
argument_list|(
name|procnum
argument_list|,
operator|&
name|ptrace_in
argument_list|,
operator|&
name|ptrace_out
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
name|error
argument_list|(
name|rpcerr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptrace_out
operator|.
name|status
operator|==
operator|-
literal|1
condition|)
block|{
name|errno
operator|=
name|ptrace_out
operator|.
name|errno_num
expr_stmt|;
name|sprintf
argument_list|(
name|message
argument_list|,
literal|"writing %s registers"
argument_list|,
operator|(
name|procnum
operator|==
name|PTRACE_SETREGS
operator|)
condition|?
literal|"general-purpose"
else|:
literal|"floating-point"
argument_list|)
expr_stmt|;
name|perror_with_name
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Prepare to store registers.  Since we will store all of them,    read out their current values now.  */
end_comment

begin_function
specifier|static
name|void
name|vx_prepare_to_store
parameter_list|()
block|{
comment|/* Fetch all registers, if any of them are not yet fetched.  */
name|read_register_bytes
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|,
name|REGISTER_BYTES
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy LEN bytes to or from remote inferior's memory starting at MEMADDR    to debugger memory starting at MYADDR.  WRITE is true if writing to the    inferior.    Result is the number of bytes written or read (zero if error).  The    protocol allows us to return a negative count, indicating that we can't    handle the current address but can handle one N bytes further, but    vxworks doesn't give us that information.  */
end_comment

begin_function
specifier|static
name|int
name|vx_xfer_memory
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|,
name|write
parameter_list|,
name|target
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|write
decl_stmt|;
name|struct
name|target_ops
modifier|*
name|target
decl_stmt|;
comment|/* ignored */
block|{
name|int
name|status
decl_stmt|;
name|Rptrace
name|ptrace_in
decl_stmt|;
name|Ptrace_return
name|ptrace_out
decl_stmt|;
name|C_bytes
name|data
decl_stmt|;
name|enum
name|ptracereq
name|request
decl_stmt|;
name|int
name|nleft
decl_stmt|,
name|nxfer
decl_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ptrace_in
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|ptrace_in
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ptrace_out
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|ptrace_out
argument_list|)
argument_list|)
expr_stmt|;
name|ptrace_in
operator|.
name|pid
operator|=
name|inferior_pid
expr_stmt|;
comment|/* XXX pid unnecessary for READDATA */
name|ptrace_in
operator|.
name|addr
operator|=
operator|(
name|int
operator|)
name|memaddr
expr_stmt|;
comment|/* Where from */
name|ptrace_in
operator|.
name|data
operator|=
name|len
expr_stmt|;
comment|/* How many bytes */
if|if
condition|(
name|write
condition|)
block|{
name|ptrace_in
operator|.
name|info
operator|.
name|ttype
operator|=
name|DATA
expr_stmt|;
name|ptrace_in
operator|.
name|info
operator|.
name|more_data
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|data
expr_stmt|;
name|data
operator|.
name|bytes
operator|=
operator|(
name|caddr_t
operator|)
name|myaddr
expr_stmt|;
comment|/* Where from */
name|data
operator|.
name|len
operator|=
name|len
expr_stmt|;
comment|/* How many bytes (again, for XDR) */
name|request
operator|=
name|PTRACE_WRITEDATA
expr_stmt|;
block|}
else|else
block|{
name|ptrace_out
operator|.
name|info
operator|.
name|more_data
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|data
expr_stmt|;
name|request
operator|=
name|PTRACE_READDATA
expr_stmt|;
block|}
comment|/* Loop until the entire request has been satisfied, transferring      at most VX_MEMXFER_MAX bytes per iteration.  Break from the loop      if an error status is returned by the remote debug server.  */
name|nleft
operator|=
name|len
expr_stmt|;
name|status
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|nleft
operator|>
literal|0
operator|&&
name|status
operator|==
literal|0
condition|)
block|{
name|nxfer
operator|=
name|min
argument_list|(
name|nleft
argument_list|,
name|VX_MEMXFER_MAX
argument_list|)
expr_stmt|;
name|ptrace_in
operator|.
name|addr
operator|=
operator|(
name|int
operator|)
name|memaddr
expr_stmt|;
name|ptrace_in
operator|.
name|data
operator|=
name|nxfer
expr_stmt|;
name|data
operator|.
name|bytes
operator|=
operator|(
name|caddr_t
operator|)
name|myaddr
expr_stmt|;
name|data
operator|.
name|len
operator|=
name|nxfer
expr_stmt|;
comment|/* Request a block from the remote debug server; if RPC fails,          report an error and return to debugger command level.  */
if|if
condition|(
name|net_ptrace_clnt_call
argument_list|(
name|request
argument_list|,
operator|&
name|ptrace_in
argument_list|,
operator|&
name|ptrace_out
argument_list|)
condition|)
name|error
argument_list|(
name|rpcerr
argument_list|)
expr_stmt|;
name|status
operator|=
name|ptrace_out
operator|.
name|status
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
block|{
name|memaddr
operator|+=
name|nxfer
expr_stmt|;
name|myaddr
operator|+=
name|nxfer
expr_stmt|;
name|nleft
operator|-=
name|nxfer
expr_stmt|;
block|}
else|else
block|{
comment|/* A target-side error has ocurred.  Set errno to the error              code chosen by the target so that a later perror () will              say something meaningful.  */
name|errno
operator|=
name|ptrace_out
operator|.
name|errno_num
expr_stmt|;
block|}
block|}
comment|/* Return the number of bytes transferred.  */
return|return
operator|(
name|len
operator|-
name|nleft
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vx_files_info
parameter_list|()
block|{
name|printf_unfiltered
argument_list|(
literal|"\tAttached to host `%s'"
argument_list|,
name|vx_host
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|", which has %sfloating point"
argument_list|,
name|target_has_fp
condition|?
literal|""
else|:
literal|"no "
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|".\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vx_run_files_info
parameter_list|()
block|{
name|printf_unfiltered
argument_list|(
literal|"\tRunning %s VxWorks process %s"
argument_list|,
name|vx_running
condition|?
literal|"child"
else|:
literal|"attached"
argument_list|,
name|local_hex_string
argument_list|(
name|inferior_pid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vx_running
condition|)
name|printf_unfiltered
argument_list|(
literal|", function `%s'"
argument_list|,
name|vx_running
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|".\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vx_resume
parameter_list|(
name|pid
parameter_list|,
name|step
parameter_list|,
name|siggnal
parameter_list|)
name|int
name|pid
decl_stmt|;
name|int
name|step
decl_stmt|;
name|enum
name|target_signal
name|siggnal
decl_stmt|;
block|{
name|int
name|status
decl_stmt|;
name|Rptrace
name|ptrace_in
decl_stmt|;
name|Ptrace_return
name|ptrace_out
decl_stmt|;
name|CORE_ADDR
name|cont_addr
decl_stmt|;
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
name|pid
operator|=
name|inferior_pid
expr_stmt|;
if|if
condition|(
name|siggnal
operator|!=
literal|0
operator|&&
name|siggnal
operator|!=
name|stop_signal
condition|)
name|error
argument_list|(
literal|"Cannot send signals to VxWorks processes"
argument_list|)
expr_stmt|;
comment|/* Set CONT_ADDR to the address at which we are continuing,      or to 1 if we are continuing from where the program stopped.      This conforms to traditional ptrace () usage, but at the same      time has special meaning for the VxWorks remote debug server.      If the address is not 1, the server knows that the target      program is jumping to a new address, which requires special      handling if there is a breakpoint at the new address.  */
name|cont_addr
operator|=
name|read_register
argument_list|(
name|PC_REGNUM
argument_list|)
expr_stmt|;
if|if
condition|(
name|cont_addr
operator|==
name|stop_pc
condition|)
name|cont_addr
operator|=
literal|1
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ptrace_in
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|ptrace_in
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ptrace_out
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|ptrace_out
argument_list|)
argument_list|)
expr_stmt|;
name|ptrace_in
operator|.
name|pid
operator|=
name|pid
expr_stmt|;
name|ptrace_in
operator|.
name|addr
operator|=
name|cont_addr
expr_stmt|;
comment|/* Target side insists on this, or it panics.  */
if|if
condition|(
name|step
condition|)
name|status
operator|=
name|net_step
argument_list|()
expr_stmt|;
else|else
name|status
operator|=
name|net_ptrace_clnt_call
argument_list|(
name|PTRACE_CONT
argument_list|,
operator|&
name|ptrace_in
argument_list|,
operator|&
name|ptrace_out
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
name|error
argument_list|(
name|rpcerr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptrace_out
operator|.
name|status
operator|==
operator|-
literal|1
condition|)
block|{
name|errno
operator|=
name|ptrace_out
operator|.
name|errno_num
expr_stmt|;
name|perror_with_name
argument_list|(
literal|"Resuming remote process"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|vx_mourn_inferior
parameter_list|()
block|{
name|pop_target
argument_list|()
expr_stmt|;
comment|/* Pop back to no-child state */
name|generic_mourn_inferior
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|void
name|vx_add_symbols
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
name|CORE_ADDR
operator|,
name|CORE_ADDR
operator|,
name|CORE_ADDR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|find_sect_args
block|{
name|CORE_ADDR
name|text_start
decl_stmt|;
name|CORE_ADDR
name|data_start
decl_stmt|;
name|CORE_ADDR
name|bss_start
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|void
name|find_sect
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|find_sect
parameter_list|(
name|abfd
parameter_list|,
name|sect
parameter_list|,
name|obj
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sect
decl_stmt|;
name|PTR
name|obj
decl_stmt|;
block|{
name|struct
name|find_sect_args
modifier|*
name|args
init|=
operator|(
expr|struct
name|find_sect_args
operator|*
operator|)
name|obj
decl_stmt|;
if|if
condition|(
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|sect
argument_list|)
operator|&
operator|(
name|SEC_CODE
operator|&
name|SEC_READONLY
operator|)
condition|)
name|args
operator|->
name|text_start
operator|=
name|bfd_get_section_vma
argument_list|(
name|abfd
argument_list|,
name|sect
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|sect
argument_list|)
operator|&
name|SEC_ALLOC
condition|)
block|{
if|if
condition|(
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|sect
argument_list|)
operator|&
name|SEC_LOAD
condition|)
block|{
comment|/* Exclude .ctor and .dtor sections which have SEC_CODE set but not 	     SEC_DATA.  */
if|if
condition|(
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|sect
argument_list|)
operator|&
name|SEC_DATA
condition|)
name|args
operator|->
name|data_start
operator|=
name|bfd_get_section_vma
argument_list|(
name|abfd
argument_list|,
name|sect
argument_list|)
expr_stmt|;
block|}
else|else
name|args
operator|->
name|bss_start
operator|=
name|bfd_get_section_vma
argument_list|(
name|abfd
argument_list|,
name|sect
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|vx_add_symbols
parameter_list|(
name|name
parameter_list|,
name|from_tty
parameter_list|,
name|text_addr
parameter_list|,
name|data_addr
parameter_list|,
name|bss_addr
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
name|CORE_ADDR
name|text_addr
decl_stmt|;
name|CORE_ADDR
name|data_addr
decl_stmt|;
name|CORE_ADDR
name|bss_addr
decl_stmt|;
block|{
name|struct
name|section_offsets
modifier|*
name|offs
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|find_sect_args
name|ss
decl_stmt|;
comment|/* It might be nice to suppress the breakpoint_re_set which happens here      because we are going to do one again after the objfile_relocate.  */
name|objfile
operator|=
name|symbol_file_add
argument_list|(
name|name
argument_list|,
name|from_tty
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* This is a (slightly cheesy) way of superceding the old symbols.  A less      cheesy way would be to find the objfile with the same name and      free_objfile it.  */
name|objfile_to_front
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
name|offs
operator|=
operator|(
expr|struct
name|section_offsets
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|section_offsets
argument_list|)
operator|+
name|objfile
operator|->
name|num_sections
operator|*
sizeof|sizeof
argument_list|(
name|offs
operator|->
name|offsets
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|offs
argument_list|,
name|objfile
operator|->
name|section_offsets
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|section_offsets
argument_list|)
operator|+
name|objfile
operator|->
name|num_sections
operator|*
sizeof|sizeof
argument_list|(
name|offs
operator|->
name|offsets
argument_list|)
argument_list|)
expr_stmt|;
name|ss
operator|.
name|text_start
operator|=
literal|0
expr_stmt|;
name|ss
operator|.
name|data_start
operator|=
literal|0
expr_stmt|;
name|ss
operator|.
name|bss_start
operator|=
literal|0
expr_stmt|;
name|bfd_map_over_sections
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|find_sect
argument_list|,
operator|&
name|ss
argument_list|)
expr_stmt|;
comment|/* Both COFF and b.out frontends use these SECT_OFF_* values.  */
name|ANOFFSET
argument_list|(
name|offs
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
operator|=
name|text_addr
operator|-
name|ss
operator|.
name|text_start
expr_stmt|;
name|ANOFFSET
argument_list|(
name|offs
argument_list|,
name|SECT_OFF_DATA
argument_list|)
operator|=
name|data_addr
operator|-
name|ss
operator|.
name|data_start
expr_stmt|;
name|ANOFFSET
argument_list|(
name|offs
argument_list|,
name|SECT_OFF_BSS
argument_list|)
operator|=
name|bss_addr
operator|-
name|ss
operator|.
name|bss_start
expr_stmt|;
name|objfile_relocate
argument_list|(
name|objfile
argument_list|,
name|offs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function allows the addition of incrementally linked object files.  */
end_comment

begin_function
specifier|static
name|void
name|vx_load_command
parameter_list|(
name|arg_string
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg_string
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|CORE_ADDR
name|text_addr
decl_stmt|;
name|CORE_ADDR
name|data_addr
decl_stmt|;
name|CORE_ADDR
name|bss_addr
decl_stmt|;
if|if
condition|(
name|arg_string
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"The load command takes a file name"
argument_list|)
expr_stmt|;
name|arg_string
operator|=
name|tilde_expand
argument_list|(
name|arg_string
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|arg_string
argument_list|)
expr_stmt|;
name|dont_repeat
argument_list|()
expr_stmt|;
comment|/* Refuse to load the module if a debugged task is running.  Doing so      can have a number of unpleasant consequences to the running task.  */
if|if
condition|(
name|inferior_pid
operator|!=
literal|0
operator|&&
name|target_has_execution
condition|)
block|{
if|if
condition|(
name|query
argument_list|(
literal|"You may not load a module while the target task is running.\n\ Kill the target task? "
argument_list|)
condition|)
name|target_kill
argument_list|()
expr_stmt|;
else|else
name|error
argument_list|(
literal|"Load cancelled."
argument_list|)
expr_stmt|;
block|}
name|QUIT
expr_stmt|;
name|immediate_quit
operator|++
expr_stmt|;
if|if
condition|(
name|net_load
argument_list|(
name|arg_string
argument_list|,
operator|&
name|text_addr
argument_list|,
operator|&
name|data_addr
argument_list|,
operator|&
name|bss_addr
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"Load failed on target machine"
argument_list|)
expr_stmt|;
name|immediate_quit
operator|--
expr_stmt|;
name|vx_add_symbols
argument_list|(
name|arg_string
argument_list|,
name|from_tty
argument_list|,
name|text_addr
argument_list|,
name|data_addr
argument_list|,
name|bss_addr
argument_list|)
expr_stmt|;
comment|/* Getting new symbols may change our opinion about what is      frameless.  */
name|reinit_frame_cache
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Single step the target program at the source or machine level.    Takes an error exit if rpc fails.    Returns -1 if remote single-step operation fails, else 0.  */
end_comment

begin_function
specifier|static
name|int
name|net_step
parameter_list|()
block|{
name|enum
name|clnt_stat
name|status
decl_stmt|;
name|int
name|step_status
decl_stmt|;
name|SOURCE_STEP
name|source_step
decl_stmt|;
name|source_step
operator|.
name|taskId
operator|=
name|inferior_pid
expr_stmt|;
if|if
condition|(
name|step_range_end
condition|)
block|{
name|source_step
operator|.
name|startAddr
operator|=
name|step_range_start
expr_stmt|;
name|source_step
operator|.
name|endAddr
operator|=
name|step_range_end
expr_stmt|;
block|}
else|else
block|{
name|source_step
operator|.
name|startAddr
operator|=
literal|0
expr_stmt|;
name|source_step
operator|.
name|endAddr
operator|=
literal|0
expr_stmt|;
block|}
name|status
operator|=
name|net_clnt_call
argument_list|(
name|VX_SOURCE_STEP
argument_list|,
name|xdr_SOURCE_STEP
argument_list|,
operator|&
name|source_step
argument_list|,
name|xdr_int
argument_list|,
operator|&
name|step_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|RPC_SUCCESS
condition|)
return|return
name|step_status
return|;
else|else
name|error
argument_list|(
name|rpcerr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emulate ptrace using RPC calls to the VxWorks target system.    Returns nonzero (-1) if RPC status to VxWorks is bad, 0 otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|net_ptrace_clnt_call
parameter_list|(
name|request
parameter_list|,
name|pPtraceIn
parameter_list|,
name|pPtraceOut
parameter_list|)
name|enum
name|ptracereq
name|request
decl_stmt|;
name|Rptrace
modifier|*
name|pPtraceIn
decl_stmt|;
name|Ptrace_return
modifier|*
name|pPtraceOut
decl_stmt|;
block|{
name|enum
name|clnt_stat
name|status
decl_stmt|;
name|status
operator|=
name|net_clnt_call
argument_list|(
name|request
argument_list|,
name|xdr_rptrace
argument_list|,
name|pPtraceIn
argument_list|,
name|xdr_ptrace_return
argument_list|,
name|pPtraceOut
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|RPC_SUCCESS
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Query the target for the name of the file from which VxWorks was    booted.  pBootFile is the address of a pointer to the buffer to    receive the file name; if the pointer pointed to by pBootFile is     NULL, memory for the buffer will be allocated by XDR.    Returns -1 if rpc failed, 0 otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|net_get_boot_file
parameter_list|(
name|pBootFile
parameter_list|)
name|char
modifier|*
modifier|*
name|pBootFile
decl_stmt|;
block|{
name|enum
name|clnt_stat
name|status
decl_stmt|;
name|status
operator|=
name|net_clnt_call
argument_list|(
name|VX_BOOT_FILE_INQ
argument_list|,
name|xdr_void
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|xdr_wrapstring
argument_list|,
name|pBootFile
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|==
name|RPC_SUCCESS
operator|)
condition|?
literal|0
else|:
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Fetch a list of loaded object modules from the VxWorks target.    Returns -1 if rpc failed, 0 otherwise    There's no way to check if the returned loadTable is correct.    VxWorks doesn't check it.  */
end_comment

begin_function
specifier|static
name|int
name|net_get_symbols
parameter_list|(
name|pLoadTable
parameter_list|)
name|ldtabl
modifier|*
name|pLoadTable
decl_stmt|;
comment|/* return pointer to ldtabl here */
block|{
name|enum
name|clnt_stat
name|status
decl_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pLoadTable
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ldtabl
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|net_clnt_call
argument_list|(
name|VX_STATE_INQ
argument_list|,
name|xdr_void
argument_list|,
literal|0
argument_list|,
name|xdr_ldtabl
argument_list|,
name|pLoadTable
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|==
name|RPC_SUCCESS
operator|)
condition|?
literal|0
else|:
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Look up a symbol in the VxWorks target's symbol table.    Returns status of symbol read on target side (0=success, -1=fail)    Returns -1 and complain()s if rpc fails.  */
end_comment

begin_decl_stmt
name|struct
name|complaint
name|cant_contact_target
init|=
block|{
literal|"Lost contact with VxWorks target"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|vx_lookup_symbol
parameter_list|(
name|name
parameter_list|,
name|pAddr
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
comment|/* symbol name */
name|CORE_ADDR
modifier|*
name|pAddr
decl_stmt|;
block|{
name|enum
name|clnt_stat
name|status
decl_stmt|;
name|SYMBOL_ADDR
name|symbolAddr
decl_stmt|;
operator|*
name|pAddr
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|symbolAddr
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|symbolAddr
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|net_clnt_call
argument_list|(
name|VX_SYMBOL_INQ
argument_list|,
name|xdr_wrapstring
argument_list|,
operator|&
name|name
argument_list|,
name|xdr_SYMBOL_ADDR
argument_list|,
operator|&
name|symbolAddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|RPC_SUCCESS
condition|)
block|{
name|complain
argument_list|(
operator|&
name|cant_contact_target
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
operator|*
name|pAddr
operator|=
name|symbolAddr
operator|.
name|addr
expr_stmt|;
return|return
name|symbolAddr
operator|.
name|status
return|;
block|}
end_function

begin_comment
comment|/* Check to see if the VxWorks target has a floating point coprocessor.    Returns 1 if target has floating point processor, 0 otherwise.    Calls error() if rpc fails.  */
end_comment

begin_function
specifier|static
name|int
name|net_check_for_fp
parameter_list|()
block|{
name|enum
name|clnt_stat
name|status
decl_stmt|;
name|bool_t
name|fp
init|=
literal|0
decl_stmt|;
comment|/* true if fp processor is present on target board */
name|status
operator|=
name|net_clnt_call
argument_list|(
name|VX_FP_INQUIRE
argument_list|,
name|xdr_void
argument_list|,
literal|0
argument_list|,
name|xdr_bool
argument_list|,
operator|&
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|RPC_SUCCESS
condition|)
name|error
argument_list|(
name|rpcerr
argument_list|)
expr_stmt|;
return|return
operator|(
name|int
operator|)
name|fp
return|;
block|}
end_function

begin_comment
comment|/* Establish an RPC connection with the VxWorks target system.    Calls error () if unable to establish connection.  */
end_comment

begin_function
specifier|static
name|void
name|net_connect
parameter_list|(
name|host
parameter_list|)
name|char
modifier|*
name|host
decl_stmt|;
block|{
name|struct
name|sockaddr_in
name|destAddr
decl_stmt|;
name|struct
name|hostent
modifier|*
name|destHost
decl_stmt|;
name|unsigned
name|long
name|addr
decl_stmt|;
comment|/* Get the internet address for the given host.  Allow a numeric      IP address or a hostname.  */
name|addr
operator|=
name|inet_addr
argument_list|(
name|host
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|==
operator|-
literal|1
condition|)
block|{
name|destHost
operator|=
operator|(
expr|struct
name|hostent
operator|*
operator|)
name|gethostbyname
argument_list|(
name|host
argument_list|)
expr_stmt|;
if|if
condition|(
name|destHost
operator|==
name|NULL
condition|)
comment|/* FIXME: Probably should include hostname here in quotes. 	   For example if the user types "target vxworks vx960 " it should 	   say "Invalid host `vx960 '." not just "Invalid hostname".  */
name|error
argument_list|(
literal|"Invalid hostname.  Couldn't find remote host address."
argument_list|)
expr_stmt|;
name|addr
operator|=
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
name|destHost
operator|->
name|h_addr
expr_stmt|;
block|}
name|memset
argument_list|(
operator|&
name|destAddr
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|destAddr
argument_list|)
argument_list|)
expr_stmt|;
name|destAddr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|addr
expr_stmt|;
name|destAddr
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|destAddr
operator|.
name|sin_port
operator|=
literal|0
expr_stmt|;
comment|/* set to actual port that remote 			           ptrace is listening on.  */
comment|/* Create a tcp client transport on which to issue      calls to the remote ptrace server.  */
name|ptraceSock
operator|=
name|RPC_ANYSOCK
expr_stmt|;
name|pClient
operator|=
name|clnttcp_create
argument_list|(
operator|&
name|destAddr
argument_list|,
name|RDBPROG
argument_list|,
name|RDBVERS
argument_list|,
operator|&
name|ptraceSock
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* FIXME, here is where we deal with different version numbers of the      proto */
if|if
condition|(
name|pClient
operator|==
name|NULL
condition|)
block|{
name|clnt_pcreateerror
argument_list|(
literal|"\tnet_connect"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Couldn't connect to remote target."
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Sleep for the specified number of milliseconds   * (assumed to be less than 1000).  * If select () is interrupted, returns immediately;  * takes an error exit if select () fails for some other reason.  */
end_comment

begin_function
specifier|static
name|void
name|sleep_ms
parameter_list|(
name|ms
parameter_list|)
name|long
name|ms
decl_stmt|;
block|{
name|struct
name|timeval
name|select_timeout
decl_stmt|;
name|int
name|status
decl_stmt|;
name|select_timeout
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|select_timeout
operator|.
name|tv_usec
operator|=
name|ms
operator|*
literal|1000
expr_stmt|;
name|status
operator|=
name|select
argument_list|(
literal|0
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|select_timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|EINTR
condition|)
name|perror_with_name
argument_list|(
literal|"select"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|vx_wait
parameter_list|(
name|pid_to_wait_for
parameter_list|,
name|status
parameter_list|)
name|int
name|pid_to_wait_for
decl_stmt|;
name|struct
name|target_waitstatus
modifier|*
name|status
decl_stmt|;
block|{
specifier|register
name|int
name|pid
decl_stmt|;
name|RDB_EVENT
name|rdbEvent
decl_stmt|;
name|int
name|quit_failed
decl_stmt|;
do|do
block|{
comment|/* If CTRL-C is hit during this loop, 	 suspend the inferior process.  */
name|quit_failed
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|quit_flag
condition|)
block|{
name|quit_failed
operator|=
operator|(
name|net_quit
argument_list|()
operator|==
operator|-
literal|1
operator|)
expr_stmt|;
name|quit_flag
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If a net_quit () or net_wait () call has failed, 	 allow the user to break the connection with the target. 	 We can't simply error () out of this loop, since the  	 data structures representing the state of the inferior 	 are in an inconsistent state.  */
if|if
condition|(
name|quit_failed
operator|||
name|net_wait
argument_list|(
operator|&
name|rdbEvent
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|terminal_ours
argument_list|()
expr_stmt|;
if|if
condition|(
name|query
argument_list|(
literal|"Can't %s.  Disconnect from target system? "
argument_list|,
operator|(
name|quit_failed
operator|)
condition|?
literal|"suspend remote task"
else|:
literal|"get status of remote task"
argument_list|)
condition|)
block|{
name|target_mourn_inferior
argument_list|()
expr_stmt|;
name|error
argument_list|(
literal|"Use the \"target\" command to reconnect."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|terminal_inferior
argument_list|()
expr_stmt|;
continue|continue;
block|}
block|}
name|pid
operator|=
name|rdbEvent
operator|.
name|taskId
expr_stmt|;
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
name|sleep_ms
argument_list|(
literal|200
argument_list|)
expr_stmt|;
comment|/* FIXME Don't kill the network too badly */
block|}
elseif|else
if|if
condition|(
name|pid
operator|!=
name|inferior_pid
condition|)
name|fatal
argument_list|(
literal|"Bad pid for debugged task: %s\n"
argument_list|,
name|local_hex_string
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|pid
argument_list|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|pid
operator|==
literal|0
condition|)
do|;
comment|/* The mostly likely kind.  */
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_STOPPED
expr_stmt|;
switch|switch
condition|(
name|rdbEvent
operator|.
name|eventType
condition|)
block|{
case|case
name|EVENT_EXIT
case|:
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_EXITED
expr_stmt|;
comment|/* FIXME is it possible to distinguish between a 	 normal vs abnormal exit in VxWorks? */
name|status
operator|->
name|value
operator|.
name|integer
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|EVENT_START
case|:
comment|/* Task was just started. */
name|status
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_TRAP
expr_stmt|;
break|break;
case|case
name|EVENT_STOP
case|:
name|status
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_TRAP
expr_stmt|;
comment|/* XXX was it stopped by a signal?  act accordingly */
break|break;
case|case
name|EVENT_BREAK
case|:
comment|/* Breakpoint was hit. */
name|status
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_TRAP
expr_stmt|;
break|break;
case|case
name|EVENT_SUSPEND
case|:
comment|/* Task was suspended, probably by ^C. */
name|status
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_INT
expr_stmt|;
break|break;
case|case
name|EVENT_BUS_ERR
case|:
comment|/* Task made evil nasty reference. */
name|status
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_BUS
expr_stmt|;
break|break;
case|case
name|EVENT_ZERO_DIV
case|:
comment|/* Division by zero */
name|status
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_FPE
expr_stmt|;
break|break;
case|case
name|EVENT_SIGNAL
case|:
ifdef|#
directive|ifdef
name|I80960
name|status
operator|->
name|value
operator|.
name|sig
operator|=
name|i960_fault_to_signal
argument_list|(
name|rdbEvent
operator|.
name|sigType
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Back in the old days, before enum target_signal, this code used 	 to add NSIG to the signal number and claim that PRINT_RANDOM_SIGNAL 	 would take care of it.  But PRINT_RANDOM_SIGNAL has never been 	 defined except on the i960, so I don't really know what we are 	 supposed to do on other architectures.  */
name|status
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_UNKNOWN
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
comment|/* switch */
return|return
name|pid
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|int
name|symbol_stub
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|symbol_file_command
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|add_symbol_stub
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|ldfile
modifier|*
name|pLoadFile
init|=
operator|(
expr|struct
name|ldfile
operator|*
operator|)
name|arg
decl_stmt|;
name|printf_unfiltered
argument_list|(
literal|"\t%s: "
argument_list|,
name|pLoadFile
operator|->
name|name
argument_list|)
expr_stmt|;
name|vx_add_symbols
argument_list|(
name|pLoadFile
operator|->
name|name
argument_list|,
literal|0
argument_list|,
name|pLoadFile
operator|->
name|txt_addr
argument_list|,
name|pLoadFile
operator|->
name|data_addr
argument_list|,
name|pLoadFile
operator|->
name|bss_addr
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"ok\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Target command for VxWorks target systems.     Used in vxgdb.  Takes the name of a remote target machine    running vxWorks and connects to it to initialize remote network    debugging.  */
end_comment

begin_function
specifier|static
name|void
name|vx_open
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
specifier|extern
name|int
name|close
parameter_list|()
function_decl|;
name|char
modifier|*
name|bootFile
decl_stmt|;
specifier|extern
name|char
modifier|*
name|source_path
decl_stmt|;
name|struct
name|ldtabl
name|loadTable
decl_stmt|;
name|struct
name|ldfile
modifier|*
name|pLoadFile
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|extern
name|CLIENT
modifier|*
name|pClient
decl_stmt|;
name|int
name|symbols_added
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|args
condition|)
name|error_no_arg
argument_list|(
literal|"target machine name"
argument_list|)
expr_stmt|;
name|target_preopen
argument_list|(
name|from_tty
argument_list|)
expr_stmt|;
name|unpush_target
argument_list|(
operator|&
name|vx_ops
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"Attaching remote machine across net...\n"
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
comment|/* Allow the user to kill the connect attempt by typing ^C.      Wait until the call to target_has_fp () completes before      disallowing an immediate quit, since even if net_connect ()      is successful, the remote debug server might be hung.  */
name|immediate_quit
operator|++
expr_stmt|;
name|net_connect
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|target_has_fp
operator|=
name|net_check_for_fp
argument_list|()
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Connected to %s.\n"
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|immediate_quit
operator|--
expr_stmt|;
name|push_target
argument_list|(
operator|&
name|vx_ops
argument_list|)
expr_stmt|;
comment|/* Save a copy of the target host's name.  */
name|vx_host
operator|=
name|savestring
argument_list|(
name|args
argument_list|,
name|strlen
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Find out the name of the file from which the target was booted      and load its symbol table.  */
name|printf_filtered
argument_list|(
literal|"Looking in Unix path for all loaded modules:\n"
argument_list|)
expr_stmt|;
name|bootFile
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|net_get_boot_file
argument_list|(
operator|&
name|bootFile
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|bootFile
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"\t%s: "
argument_list|,
name|bootFile
argument_list|)
expr_stmt|;
comment|/* This assumes that the kernel is never relocated.  Hope that is an 	     accurate assumption.  */
if|if
condition|(
name|catch_errors
argument_list|(
name|symbol_stub
argument_list|,
name|bootFile
argument_list|,
literal|"Error while reading symbols from boot file:\n"
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
condition|)
name|puts_filtered
argument_list|(
literal|"ok\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|from_tty
condition|)
name|printf_unfiltered
argument_list|(
literal|"VxWorks kernel symbols not loaded.\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"Can't retrieve boot file name from target machine."
argument_list|)
expr_stmt|;
name|clnt_freeres
argument_list|(
name|pClient
argument_list|,
name|xdr_wrapstring
argument_list|,
operator|&
name|bootFile
argument_list|)
expr_stmt|;
if|if
condition|(
name|net_get_symbols
argument_list|(
operator|&
name|loadTable
argument_list|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|"Can't read loaded modules from target machine"
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|++
name|i
operator|<
name|loadTable
operator|.
name|tbl_size
condition|)
block|{
name|QUIT
expr_stmt|;
comment|/* FIXME, avoids clnt_freeres below:  mem leak */
name|pLoadFile
operator|=
operator|&
name|loadTable
operator|.
name|tbl_ent
index|[
name|i
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|WRS_ORIG
block|{
specifier|register
name|int
name|desc
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|char
modifier|*
name|fullname
init|=
name|NULL
decl_stmt|;
name|desc
operator|=
name|openp
argument_list|(
name|source_path
argument_list|,
literal|0
argument_list|,
name|pLoadFile
operator|->
name|name
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|,
operator|&
name|fullname
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|pLoadFile
operator|->
name|name
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|close
argument_list|,
name|desc
argument_list|)
expr_stmt|;
name|add_file_at_addr
argument_list|(
name|fullname
argument_list|,
name|desc
argument_list|,
name|pLoadFile
operator|->
name|txt_addr
argument_list|,
name|pLoadFile
operator|->
name|data_addr
argument_list|,
name|pLoadFile
operator|->
name|bss_addr
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* FIXME: Is there something better to search than the PATH? (probably 	 not the source path, since source might be in different directories 	 than objects.  */
if|if
condition|(
name|catch_errors
argument_list|(
name|add_symbol_stub
argument_list|,
operator|(
name|char
operator|*
operator|)
name|pLoadFile
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
condition|)
name|symbols_added
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
name|printf_filtered
argument_list|(
literal|"Done.\n"
argument_list|)
expr_stmt|;
name|clnt_freeres
argument_list|(
name|pClient
argument_list|,
name|xdr_ldtabl
argument_list|,
operator|&
name|loadTable
argument_list|)
expr_stmt|;
comment|/* Getting new symbols may change our opinion about what is      frameless.  */
if|if
condition|(
name|symbols_added
condition|)
name|reinit_frame_cache
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Takes a task started up outside of gdb and ``attaches'' to it.    This stops it cold in its tracks and allows us to start tracing it.  */
end_comment

begin_function
specifier|static
name|void
name|vx_attach
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|unsigned
name|long
name|pid
decl_stmt|;
name|char
modifier|*
name|cptr
init|=
literal|0
decl_stmt|;
name|Rptrace
name|ptrace_in
decl_stmt|;
name|Ptrace_return
name|ptrace_out
decl_stmt|;
name|int
name|status
decl_stmt|;
if|if
condition|(
operator|!
name|args
condition|)
name|error_no_arg
argument_list|(
literal|"process-id to attach"
argument_list|)
expr_stmt|;
name|pid
operator|=
name|strtoul
argument_list|(
name|args
argument_list|,
operator|&
name|cptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cptr
operator|==
name|args
operator|)
operator|||
operator|(
operator|*
name|cptr
operator|!=
literal|'\0'
operator|)
condition|)
name|error
argument_list|(
literal|"Invalid process-id -- give a single number in decimal or 0xhex"
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
name|printf_unfiltered
argument_list|(
literal|"Attaching pid %s.\n"
argument_list|,
name|local_hex_string
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|pid
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ptrace_in
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|ptrace_in
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ptrace_out
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|ptrace_out
argument_list|)
argument_list|)
expr_stmt|;
name|ptrace_in
operator|.
name|pid
operator|=
name|pid
expr_stmt|;
name|status
operator|=
name|net_ptrace_clnt_call
argument_list|(
name|PTRACE_ATTACH
argument_list|,
operator|&
name|ptrace_in
argument_list|,
operator|&
name|ptrace_out
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
name|rpcerr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptrace_out
operator|.
name|status
operator|==
operator|-
literal|1
condition|)
block|{
name|errno
operator|=
name|ptrace_out
operator|.
name|errno_num
expr_stmt|;
name|perror_with_name
argument_list|(
literal|"Attaching remote process"
argument_list|)
expr_stmt|;
block|}
comment|/* It worked... */
name|inferior_pid
operator|=
name|pid
expr_stmt|;
name|push_target
argument_list|(
operator|&
name|vx_run_ops
argument_list|)
expr_stmt|;
if|if
condition|(
name|vx_running
condition|)
name|free
argument_list|(
name|vx_running
argument_list|)
expr_stmt|;
name|vx_running
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* detach_command --    takes a program previously attached to and detaches it.    The program resumes execution and will no longer stop    on signals, etc.  We better not have left any breakpoints    in the program or it'll die when it hits one.  For this    to work, it may be necessary for the process to have been    previously attached.  It *might* work if the program was    started via the normal ptrace (PTRACE_TRACEME).  */
end_comment

begin_function
specifier|static
name|void
name|vx_detach
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|Rptrace
name|ptrace_in
decl_stmt|;
name|Ptrace_return
name|ptrace_out
decl_stmt|;
name|int
name|signal
init|=
literal|0
decl_stmt|;
name|int
name|status
decl_stmt|;
if|if
condition|(
name|args
condition|)
name|error
argument_list|(
literal|"Argument given to VxWorks \"detach\"."
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
name|printf_unfiltered
argument_list|(
literal|"Detaching pid %s.\n"
argument_list|,
name|local_hex_string
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|inferior_pid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
condition|)
comment|/* FIXME, should be possible to leave suspended */
name|signal
operator|=
name|atoi
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ptrace_in
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|ptrace_in
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ptrace_out
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|ptrace_out
argument_list|)
argument_list|)
expr_stmt|;
name|ptrace_in
operator|.
name|pid
operator|=
name|inferior_pid
expr_stmt|;
name|status
operator|=
name|net_ptrace_clnt_call
argument_list|(
name|PTRACE_DETACH
argument_list|,
operator|&
name|ptrace_in
argument_list|,
operator|&
name|ptrace_out
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
name|rpcerr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptrace_out
operator|.
name|status
operator|==
operator|-
literal|1
condition|)
block|{
name|errno
operator|=
name|ptrace_out
operator|.
name|errno_num
expr_stmt|;
name|perror_with_name
argument_list|(
literal|"Detaching VxWorks process"
argument_list|)
expr_stmt|;
block|}
name|inferior_pid
operator|=
literal|0
expr_stmt|;
name|pop_target
argument_list|()
expr_stmt|;
comment|/* go back to non-executing VxWorks connection */
block|}
end_function

begin_comment
comment|/* vx_kill -- takes a running task and wipes it out.  */
end_comment

begin_function
specifier|static
name|void
name|vx_kill
parameter_list|()
block|{
name|Rptrace
name|ptrace_in
decl_stmt|;
name|Ptrace_return
name|ptrace_out
decl_stmt|;
name|int
name|status
decl_stmt|;
name|printf_unfiltered
argument_list|(
literal|"Killing pid %s.\n"
argument_list|,
name|local_hex_string
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|inferior_pid
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ptrace_in
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|ptrace_in
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ptrace_out
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|ptrace_out
argument_list|)
argument_list|)
expr_stmt|;
name|ptrace_in
operator|.
name|pid
operator|=
name|inferior_pid
expr_stmt|;
name|status
operator|=
name|net_ptrace_clnt_call
argument_list|(
name|PTRACE_KILL
argument_list|,
operator|&
name|ptrace_in
argument_list|,
operator|&
name|ptrace_out
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
operator|-
literal|1
condition|)
name|warning
argument_list|(
name|rpcerr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ptrace_out
operator|.
name|status
operator|==
operator|-
literal|1
condition|)
block|{
name|errno
operator|=
name|ptrace_out
operator|.
name|errno_num
expr_stmt|;
name|perror_with_name
argument_list|(
literal|"Killing VxWorks process"
argument_list|)
expr_stmt|;
block|}
comment|/* If it gives good status, the process is *gone*, no events remain.      If the kill failed, assume the process is gone anyhow.  */
name|inferior_pid
operator|=
literal|0
expr_stmt|;
name|pop_target
argument_list|()
expr_stmt|;
comment|/* go back to non-executing VxWorks connection */
block|}
end_function

begin_comment
comment|/* Clean up from the VxWorks process target as it goes away.  */
end_comment

begin_function
specifier|static
name|void
name|vx_proc_close
parameter_list|(
name|quitting
parameter_list|)
name|int
name|quitting
decl_stmt|;
block|{
name|inferior_pid
operator|=
literal|0
expr_stmt|;
comment|/* No longer have a process.  */
if|if
condition|(
name|vx_running
condition|)
name|free
argument_list|(
name|vx_running
argument_list|)
expr_stmt|;
name|vx_running
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Make an RPC call to the VxWorks target.    Returns RPC status.  */
end_comment

begin_function
specifier|static
name|enum
name|clnt_stat
name|net_clnt_call
parameter_list|(
name|procNum
parameter_list|,
name|inProc
parameter_list|,
name|in
parameter_list|,
name|outProc
parameter_list|,
name|out
parameter_list|)
name|enum
name|ptracereq
name|procNum
decl_stmt|;
name|xdrproc_t
name|inProc
decl_stmt|;
name|char
modifier|*
name|in
decl_stmt|;
name|xdrproc_t
name|outProc
decl_stmt|;
name|char
modifier|*
name|out
decl_stmt|;
block|{
name|enum
name|clnt_stat
name|status
decl_stmt|;
name|status
operator|=
name|clnt_call
argument_list|(
name|pClient
argument_list|,
name|procNum
argument_list|,
name|inProc
argument_list|,
name|in
argument_list|,
name|outProc
argument_list|,
name|out
argument_list|,
name|rpcTimeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|RPC_SUCCESS
condition|)
name|clnt_perrno
argument_list|(
name|status
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/* Clean up before losing control.  */
end_comment

begin_function
specifier|static
name|void
name|vx_close
parameter_list|(
name|quitting
parameter_list|)
name|int
name|quitting
decl_stmt|;
block|{
if|if
condition|(
name|pClient
condition|)
name|clnt_destroy
argument_list|(
name|pClient
argument_list|)
expr_stmt|;
comment|/* The net connection */
name|pClient
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vx_host
condition|)
name|free
argument_list|(
name|vx_host
argument_list|)
expr_stmt|;
comment|/* The hostname */
name|vx_host
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A vxprocess target should be started via "run" not "target".  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|vx_proc_open
parameter_list|(
name|name
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|error
argument_list|(
literal|"Use the \"run\" command to start a VxWorks process."
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|init_vx_ops
parameter_list|()
block|{
name|vx_ops
operator|.
name|to_shortname
operator|=
literal|"vxworks"
expr_stmt|;
name|vx_ops
operator|.
name|to_longname
operator|=
literal|"VxWorks target memory via RPC over TCP/IP"
expr_stmt|;
name|vx_ops
operator|.
name|to_doc
operator|=
literal|"Use VxWorks target memory.  \n\ Specify the name of the machine to connect to."
expr_stmt|;
name|vx_ops
operator|.
name|to_open
operator|=
name|vx_open
expr_stmt|;
name|vx_ops
operator|.
name|to_close
operator|=
name|vx_close
expr_stmt|;
name|vx_ops
operator|.
name|to_attach
operator|=
name|vx_attach
expr_stmt|;
name|vx_ops
operator|.
name|to_xfer_memory
operator|=
name|vx_xfer_memory
expr_stmt|;
name|vx_ops
operator|.
name|to_files_info
operator|=
name|vx_files_info
expr_stmt|;
name|vx_ops
operator|.
name|to_load
operator|=
name|vx_load_command
expr_stmt|;
name|vx_ops
operator|.
name|to_lookup_symbol
operator|=
name|vx_lookup_symbol
expr_stmt|;
name|vx_ops
operator|.
name|to_create_inferior
operator|=
name|vx_create_inferior
expr_stmt|;
name|vx_ops
operator|.
name|to_stratum
operator|=
name|core_stratum
expr_stmt|;
name|vx_ops
operator|.
name|to_has_all_memory
operator|=
literal|1
expr_stmt|;
name|vx_ops
operator|.
name|to_has_memory
operator|=
literal|1
expr_stmt|;
name|vx_ops
operator|.
name|to_magic
operator|=
name|OPS_MAGIC
expr_stmt|;
comment|/* Always the last thing */
block|}
end_function

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_function
specifier|static
name|void
name|init_vx_run_ops
parameter_list|()
block|{
name|vx_run_ops
operator|.
name|to_shortname
operator|=
literal|"vxprocess"
expr_stmt|;
name|vx_run_ops
operator|.
name|to_longname
operator|=
literal|"VxWorks process"
expr_stmt|;
name|vx_run_ops
operator|.
name|to_doc
operator|=
literal|"VxWorks process; started by the \"run\" command."
expr_stmt|;
name|vx_run_ops
operator|.
name|to_open
operator|=
name|vx_proc_open
expr_stmt|;
name|vx_run_ops
operator|.
name|to_close
operator|=
name|vx_proc_close
expr_stmt|;
name|vx_run_ops
operator|.
name|to_detach
operator|=
name|vx_detach
expr_stmt|;
name|vx_run_ops
operator|.
name|to_resume
operator|=
name|vx_resume
expr_stmt|;
name|vx_run_ops
operator|.
name|to_wait
operator|=
name|vx_wait
expr_stmt|;
name|vx_run_ops
operator|.
name|to_fetch_registers
operator|=
name|vx_read_register
expr_stmt|;
name|vx_run_ops
operator|.
name|to_store_registers
operator|=
name|vx_write_register
expr_stmt|;
name|vx_run_ops
operator|.
name|to_prepare_to_store
operator|=
name|vx_prepare_to_store
expr_stmt|;
name|vx_run_ops
operator|.
name|to_xfer_memory
operator|=
name|vx_xfer_memory
expr_stmt|;
name|vx_run_ops
operator|.
name|to_files_info
operator|=
name|vx_run_files_info
expr_stmt|;
name|vx_run_ops
operator|.
name|to_insert_breakpoint
operator|=
name|vx_insert_breakpoint
expr_stmt|;
name|vx_run_ops
operator|.
name|to_remove_breakpoint
operator|=
name|vx_remove_breakpoint
expr_stmt|;
name|vx_run_ops
operator|.
name|to_kill
operator|=
name|vx_kill
expr_stmt|;
name|vx_run_ops
operator|.
name|to_load
operator|=
name|vx_load_command
expr_stmt|;
name|vx_run_ops
operator|.
name|to_lookup_symbol
operator|=
name|vx_lookup_symbol
expr_stmt|;
name|vx_run_ops
operator|.
name|to_mourn_inferior
operator|=
name|vx_mourn_inferior
expr_stmt|;
name|vx_run_ops
operator|.
name|to_stratum
operator|=
name|process_stratum
expr_stmt|;
name|vx_run_ops
operator|.
name|to_has_memory
operator|=
literal|1
expr_stmt|;
name|vx_run_ops
operator|.
name|to_has_stack
operator|=
literal|1
expr_stmt|;
name|vx_run_ops
operator|.
name|to_has_registers
operator|=
literal|1
expr_stmt|;
name|vx_run_ops
operator|.
name|to_has_execution
operator|=
literal|1
expr_stmt|;
name|vx_run_ops
operator|.
name|to_magic
operator|=
name|OPS_MAGIC
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|_initialize_vx
parameter_list|()
block|{
name|init_vx_ops
argument_list|()
expr_stmt|;
name|add_target
argument_list|(
operator|&
name|vx_ops
argument_list|)
expr_stmt|;
name|init_vx_run_ops
argument_list|()
expr_stmt|;
name|add_target
argument_list|(
operator|&
name|vx_run_ops
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"vxworks-timeout"
argument_list|,
name|class_support
argument_list|,
name|var_uinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|rpcTimeout
operator|.
name|tv_sec
argument_list|,
literal|"Set seconds to wait for rpc calls to return.\n\ Set the number of seconds to wait for rpc calls to return."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

