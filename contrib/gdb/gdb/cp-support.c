begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Helper routines for C++ support in GDB.    Copyright 2002, 2003 Free Software Foundation, Inc.     Contributed by MontaVista Software.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"cp-support.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_include
include|#
directive|include
file|"gdb_assert.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"dictionary.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"block.h"
end_include

begin_include
include|#
directive|include
file|"complaints.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_comment
comment|/* Functions related to demangled name parsing.  */
end_comment

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|find_last_component
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|int
name|cp_find_first_component_aux
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|permissive
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|demangled_name_complaint
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Functions/variables related to overload resolution.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sym_return_val_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sym_return_val_index
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|symbol
modifier|*
modifier|*
name|sym_return_val
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|char
modifier|*
name|remove_params
parameter_list|(
specifier|const
name|char
modifier|*
name|demangled_name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|overload_list_add_symbol
parameter_list|(
name|struct
name|symbol
modifier|*
name|sym
parameter_list|,
specifier|const
name|char
modifier|*
name|oload_name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|make_symbol_overload_list_using
parameter_list|(
specifier|const
name|char
modifier|*
name|func_name
parameter_list|,
specifier|const
name|char
modifier|*
name|namespace
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|make_symbol_overload_list_qualified
parameter_list|(
specifier|const
name|char
modifier|*
name|func_name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|read_in_psymtabs
parameter_list|(
specifier|const
name|char
modifier|*
name|oload_name
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* The list of "maint cplus" commands.  */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|maint_cplus_cmd_list
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The actual commands.  */
end_comment

begin_function_decl
specifier|static
name|void
name|maint_cplus_command
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|first_component_command
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Here are some random pieces of trivia to keep in mind while trying    to take apart demangled names:     - Names can contain function arguments or templates, so the process      has to be, to some extent recursive: maybe keep track of your      depth based on encountering<> and ().     - Parentheses don't just have to happen at the end of a name: they      can occur even if the name in question isn't a function, because      a template argument might be a type that's a function.     - Conversely, even if you're trying to deal with a function, its      demangled name might not end with ')': it could be a const or      volatile class method, in which case it ends with "const" or      "volatile".     - Parentheses are also used in anonymous namespaces: a variable      'foo' in an anonymous namespace gets demangled as "(anonymous      namespace)::foo".     - And operator names can contain parentheses or angle brackets.  */
end_comment

begin_comment
comment|/* FIXME: carlton/2003-03-13: We have several functions here with    overlapping functionality; can we combine them?  Also, do they    handle all the above considerations correctly?  */
end_comment

begin_comment
comment|/* Find the last component of the demangled C++ name NAME.  NAME    must be a method name including arguments, in order to correctly    locate the last component.     This function return a pointer to the first colon before the    last component, or NULL if the name had only one component.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|find_last_component
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|depth
decl_stmt|;
comment|/* Functions can have local classes, so we need to find the      beginning of the last argument list, not the end of the first      one.  */
name|p
operator|=
name|name
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|p
operator|>
name|name
operator|&&
operator|*
name|p
operator|!=
literal|')'
condition|)
name|p
operator|--
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|name
condition|)
return|return
name|NULL
return|;
comment|/* P now points at the `)' at the end of the argument list.  Walk      back to the beginning.  */
name|p
operator|--
expr_stmt|;
name|depth
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|p
operator|>
name|name
operator|&&
name|depth
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'<'
operator|||
operator|*
name|p
operator|==
literal|'('
condition|)
name|depth
operator|--
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'>'
operator|||
operator|*
name|p
operator|==
literal|')'
condition|)
name|depth
operator|++
expr_stmt|;
name|p
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|==
name|name
condition|)
return|return
name|NULL
return|;
while|while
condition|(
name|p
operator|>
name|name
operator|&&
operator|*
name|p
operator|!=
literal|':'
condition|)
name|p
operator|--
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|name
operator|||
name|p
operator|==
name|name
operator|+
literal|1
operator|||
name|p
index|[
operator|-
literal|1
index|]
operator|!=
literal|':'
condition|)
return|return
name|NULL
return|;
return|return
name|p
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return the name of the class containing method PHYSNAME.  */
end_comment

begin_function
name|char
modifier|*
name|class_name_from_physname
parameter_list|(
specifier|const
name|char
modifier|*
name|physname
parameter_list|)
block|{
name|char
modifier|*
name|ret
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|end
decl_stmt|;
name|int
name|depth
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|demangled_name
init|=
name|cplus_demangle
argument_list|(
name|physname
argument_list|,
name|DMGL_ANSI
operator||
name|DMGL_PARAMS
argument_list|)
decl_stmt|;
if|if
condition|(
name|demangled_name
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|end
operator|=
name|find_last_component
argument_list|(
name|demangled_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
operator|!=
name|NULL
condition|)
block|{
name|ret
operator|=
name|xmalloc
argument_list|(
name|end
operator|-
name|demangled_name
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ret
argument_list|,
name|demangled_name
argument_list|,
name|end
operator|-
name|demangled_name
argument_list|)
expr_stmt|;
name|ret
index|[
name|end
operator|-
name|demangled_name
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|xfree
argument_list|(
name|demangled_name
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Return the name of the method whose linkage name is PHYSNAME.  */
end_comment

begin_function
name|char
modifier|*
name|method_name_from_physname
parameter_list|(
specifier|const
name|char
modifier|*
name|physname
parameter_list|)
block|{
name|char
modifier|*
name|ret
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|end
decl_stmt|;
name|int
name|depth
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|demangled_name
init|=
name|cplus_demangle
argument_list|(
name|physname
argument_list|,
name|DMGL_ANSI
operator||
name|DMGL_PARAMS
argument_list|)
decl_stmt|;
if|if
condition|(
name|demangled_name
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|end
operator|=
name|find_last_component
argument_list|(
name|demangled_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/* Skip "::".  */
name|end
operator|=
name|end
operator|+
literal|2
expr_stmt|;
comment|/* Find the argument list, if any.  */
name|args
operator|=
name|strchr
argument_list|(
name|end
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|==
name|NULL
condition|)
name|len
operator|=
name|strlen
argument_list|(
name|end
operator|+
literal|2
argument_list|)
expr_stmt|;
else|else
block|{
name|args
operator|--
expr_stmt|;
while|while
condition|(
operator|*
name|args
operator|==
literal|' '
condition|)
name|args
operator|--
expr_stmt|;
name|len
operator|=
name|args
operator|-
name|end
operator|+
literal|1
expr_stmt|;
block|}
name|ret
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ret
argument_list|,
name|end
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ret
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|xfree
argument_list|(
name|demangled_name
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* This returns the length of first component of NAME, which should be    the demangled name of a C++ variable/function/method/etc.    Specifically, it returns the index of the first colon forming the    boundary of the first component: so, given 'A::foo' or 'A::B::foo'    it returns the 1, and given 'foo', it returns 0.  */
end_comment

begin_comment
comment|/* The character in NAME indexed by the return value is guaranteed to    always be either ':' or '\0'.  */
end_comment

begin_comment
comment|/* NOTE: carlton/2003-03-13: This function is currently only intended    for internal use: it's probably not entirely safe when called on    user-generated input, because some of the 'index += 2' lines in    cp_find_first_component_aux might go past the end of malformed    input.  */
end_comment

begin_function
name|unsigned
name|int
name|cp_find_first_component
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
name|cp_find_first_component_aux
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Helper function for cp_find_first_component.  Like that function,    it returns the length of the first component of NAME, but to make    the recursion easier, it also stops if it reaches an unexpected ')'    or '>' if the value of PERMISSIVE is nonzero.  */
end_comment

begin_comment
comment|/* Let's optimize away calls to strlen("operator").  */
end_comment

begin_define
define|#
directive|define
name|LENGTH_OF_OPERATOR
value|8
end_define

begin_function
specifier|static
name|unsigned
name|int
name|cp_find_first_component_aux
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|permissive
parameter_list|)
block|{
name|unsigned
name|int
name|index
init|=
literal|0
decl_stmt|;
comment|/* Operator names can show up in unexpected places.  Since these can      contain parentheses or angle brackets, they can screw up the      recursion.  But not every string 'operator' is part of an      operater name: e.g. you could have a variable 'cooperator'.  So      this variable tells us whether or not we should treat the string      'operator' as starting an operator.  */
name|int
name|operator_possible
init|=
literal|1
decl_stmt|;
for|for
control|(
init|;
condition|;
operator|++
name|index
control|)
block|{
switch|switch
condition|(
name|name
index|[
name|index
index|]
condition|)
block|{
case|case
literal|'<'
case|:
comment|/* Template; eat it up.  The calls to cp_first_component 	     should only return (I hope!) when they reach the '>' 	     terminating the component or a '::' between two 	     components.  (Hence the '+ 2'.)  */
name|index
operator|+=
literal|1
expr_stmt|;
for|for
control|(
name|index
operator|+=
name|cp_find_first_component_aux
argument_list|(
name|name
operator|+
name|index
argument_list|,
literal|1
argument_list|)
init|;
name|name
index|[
name|index
index|]
operator|!=
literal|'>'
condition|;
name|index
operator|+=
name|cp_find_first_component_aux
argument_list|(
name|name
operator|+
name|index
argument_list|,
literal|1
argument_list|)
control|)
block|{
if|if
condition|(
name|name
index|[
name|index
index|]
operator|!=
literal|':'
condition|)
block|{
name|demangled_name_complaint
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
name|strlen
argument_list|(
name|name
argument_list|)
return|;
block|}
name|index
operator|+=
literal|2
expr_stmt|;
block|}
name|operator_possible
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'('
case|:
comment|/* Similar comment as to '<'.  */
name|index
operator|+=
literal|1
expr_stmt|;
for|for
control|(
name|index
operator|+=
name|cp_find_first_component_aux
argument_list|(
name|name
operator|+
name|index
argument_list|,
literal|1
argument_list|)
init|;
name|name
index|[
name|index
index|]
operator|!=
literal|')'
condition|;
name|index
operator|+=
name|cp_find_first_component_aux
argument_list|(
name|name
operator|+
name|index
argument_list|,
literal|1
argument_list|)
control|)
block|{
if|if
condition|(
name|name
index|[
name|index
index|]
operator|!=
literal|':'
condition|)
block|{
name|demangled_name_complaint
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
name|strlen
argument_list|(
name|name
argument_list|)
return|;
block|}
name|index
operator|+=
literal|2
expr_stmt|;
block|}
name|operator_possible
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
case|case
literal|')'
case|:
if|if
condition|(
name|permissive
condition|)
return|return
name|index
return|;
else|else
block|{
name|demangled_name_complaint
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
name|strlen
argument_list|(
name|name
argument_list|)
return|;
block|}
case|case
literal|'\0'
case|:
case|case
literal|':'
case|:
return|return
name|index
return|;
case|case
literal|'o'
case|:
comment|/* Operator names can screw up the recursion.  */
if|if
condition|(
name|operator_possible
operator|&&
name|strncmp
argument_list|(
name|name
operator|+
name|index
argument_list|,
literal|"operator"
argument_list|,
name|LENGTH_OF_OPERATOR
argument_list|)
operator|==
literal|0
condition|)
block|{
name|index
operator|+=
name|LENGTH_OF_OPERATOR
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
name|name
index|[
name|index
index|]
argument_list|)
condition|)
operator|++
name|index
expr_stmt|;
switch|switch
condition|(
name|name
index|[
name|index
index|]
condition|)
block|{
comment|/* Skip over one less than the appropriate number of 		     characters: the for loop will skip over the last 		     one.  */
case|case
literal|'<'
case|:
if|if
condition|(
name|name
index|[
name|index
operator|+
literal|1
index|]
operator|==
literal|'<'
condition|)
name|index
operator|+=
literal|1
expr_stmt|;
else|else
name|index
operator|+=
literal|0
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
case|case
literal|'-'
case|:
if|if
condition|(
name|name
index|[
name|index
operator|+
literal|1
index|]
operator|==
literal|'>'
condition|)
name|index
operator|+=
literal|1
expr_stmt|;
else|else
name|index
operator|+=
literal|0
expr_stmt|;
break|break;
case|case
literal|'('
case|:
name|index
operator|+=
literal|1
expr_stmt|;
break|break;
default|default:
name|index
operator|+=
literal|0
expr_stmt|;
break|break;
block|}
block|}
name|operator_possible
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|' '
case|:
case|case
literal|','
case|:
case|case
literal|'.'
case|:
case|case
literal|'&'
case|:
case|case
literal|'*'
case|:
comment|/* NOTE: carlton/2003-04-18: I'm not sure what the precise 	     set of relevant characters are here: it's necessary to 	     include any character that can show up before 'operator' 	     in a demangled name, and it's safe to include any 	     character that can't be part of an identifier's name.  */
name|operator_possible
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|operator_possible
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Complain about a demangled name that we don't know how to parse.    NAME is the demangled name in question.  */
end_comment

begin_function
specifier|static
name|void
name|demangled_name_complaint
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"unexpected demangled name '%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If NAME is the fully-qualified name of a C++    function/variable/method/etc., this returns the length of its    entire prefix: all of the namespaces and classes that make up its    name.  Given 'A::foo', it returns 1, given 'A::B::foo', it returns    4, given 'foo', it returns 0.  */
end_comment

begin_function
name|unsigned
name|int
name|cp_entire_prefix_len
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|unsigned
name|int
name|current_len
init|=
name|cp_find_first_component
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|previous_len
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|name
index|[
name|current_len
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|gdb_assert
argument_list|(
name|name
index|[
name|current_len
index|]
operator|==
literal|':'
argument_list|)
expr_stmt|;
name|previous_len
operator|=
name|current_len
expr_stmt|;
comment|/* Skip the '::'.  */
name|current_len
operator|+=
literal|2
expr_stmt|;
name|current_len
operator|+=
name|cp_find_first_component
argument_list|(
name|name
operator|+
name|current_len
argument_list|)
expr_stmt|;
block|}
return|return
name|previous_len
return|;
block|}
end_function

begin_comment
comment|/* If FULL_NAME is the demangled name of a C++ function (including an    arg list, possibly including namespace/class qualifications),    return a new string containing only the function name (without the    arg list/class qualifications).  Otherwise, return NULL.  The    caller is responsible for freeing the memory in question.  */
end_comment

begin_function
name|char
modifier|*
name|cp_func_name
parameter_list|(
specifier|const
name|char
modifier|*
name|full_name
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|previous_component
init|=
name|full_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|next_component
decl_stmt|;
if|if
condition|(
operator|!
name|full_name
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|next_component
operator|=
operator|(
name|previous_component
operator|+
name|cp_find_first_component
argument_list|(
name|previous_component
argument_list|)
operator|)
init|;
operator|*
name|next_component
operator|==
literal|':'
condition|;
name|next_component
operator|=
operator|(
name|previous_component
operator|+
name|cp_find_first_component
argument_list|(
name|previous_component
argument_list|)
operator|)
control|)
block|{
comment|/* Skip '::'.  */
name|previous_component
operator|=
name|next_component
operator|+
literal|2
expr_stmt|;
block|}
return|return
name|remove_params
argument_list|(
name|previous_component
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Overload resolution functions.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|remove_params
parameter_list|(
specifier|const
name|char
modifier|*
name|demangled_name
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|argp
decl_stmt|;
name|char
modifier|*
name|new_name
decl_stmt|;
name|int
name|depth
decl_stmt|;
if|if
condition|(
name|demangled_name
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* First find the end of the arg list.  */
name|argp
operator|=
name|strrchr
argument_list|(
name|demangled_name
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
if|if
condition|(
name|argp
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* Back up to the beginning.  */
name|depth
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|argp
operator|--
operator|>
name|demangled_name
condition|)
block|{
if|if
condition|(
operator|*
name|argp
operator|==
literal|')'
condition|)
name|depth
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|argp
operator|==
literal|'('
condition|)
block|{
name|depth
operator|--
expr_stmt|;
if|if
condition|(
name|depth
operator|==
literal|0
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|depth
operator|!=
literal|0
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"bad demangled name %s\n"
argument_list|,
name|demangled_name
argument_list|)
expr_stmt|;
while|while
condition|(
name|argp
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
operator|&&
name|argp
operator|>
name|demangled_name
condition|)
name|argp
operator|--
expr_stmt|;
name|new_name
operator|=
name|xmalloc
argument_list|(
name|argp
operator|-
name|demangled_name
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|new_name
argument_list|,
name|demangled_name
argument_list|,
name|argp
operator|-
name|demangled_name
argument_list|)
expr_stmt|;
name|new_name
index|[
name|argp
operator|-
name|demangled_name
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|new_name
return|;
block|}
end_function

begin_comment
comment|/* Test to see if SYM is a symbol that we haven't seen corresponding    to a function named OLOAD_NAME.  If so, add it to the current    completion list. */
end_comment

begin_function
specifier|static
name|void
name|overload_list_add_symbol
parameter_list|(
name|struct
name|symbol
modifier|*
name|sym
parameter_list|,
specifier|const
name|char
modifier|*
name|oload_name
parameter_list|)
block|{
name|int
name|newsize
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|sym_name
decl_stmt|;
comment|/* If there is no type information, we can't do anything, so skip */
if|if
condition|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|==
name|NULL
condition|)
return|return;
comment|/* skip any symbols that we've already considered. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sym_return_val_index
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|SYMBOL_LINKAGE_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|SYMBOL_LINKAGE_NAME
argument_list|(
name|sym_return_val
index|[
name|i
index|]
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return;
comment|/* Get the demangled name without parameters */
name|sym_name
operator|=
name|remove_params
argument_list|(
name|SYMBOL_NATURAL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sym_name
condition|)
return|return;
comment|/* skip symbols that cannot match */
if|if
condition|(
name|strcmp
argument_list|(
name|sym_name
argument_list|,
name|oload_name
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|xfree
argument_list|(
name|sym_name
argument_list|)
expr_stmt|;
return|return;
block|}
name|xfree
argument_list|(
name|sym_name
argument_list|)
expr_stmt|;
comment|/* We have a match for an overload instance, so add SYM to the current list    * of overload instances */
if|if
condition|(
name|sym_return_val_index
operator|+
literal|3
operator|>
name|sym_return_val_size
condition|)
block|{
name|newsize
operator|=
operator|(
name|sym_return_val_size
operator|*=
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
operator|*
argument_list|)
expr_stmt|;
name|sym_return_val
operator|=
operator|(
expr|struct
name|symbol
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sym_return_val
argument_list|,
name|newsize
argument_list|)
expr_stmt|;
block|}
name|sym_return_val
index|[
name|sym_return_val_index
operator|++
index|]
operator|=
name|sym
expr_stmt|;
name|sym_return_val
index|[
name|sym_return_val_index
index|]
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a null-terminated list of pointers to function symbols that    are named FUNC_NAME and are visible within NAMESPACE.  */
end_comment

begin_function
name|struct
name|symbol
modifier|*
modifier|*
name|make_symbol_overload_list
parameter_list|(
specifier|const
name|char
modifier|*
name|func_name
parameter_list|,
specifier|const
name|char
modifier|*
name|namespace
parameter_list|)
block|{
name|struct
name|cleanup
modifier|*
name|old_cleanups
decl_stmt|;
name|sym_return_val_size
operator|=
literal|100
expr_stmt|;
name|sym_return_val_index
operator|=
literal|0
expr_stmt|;
name|sym_return_val
operator|=
name|xmalloc
argument_list|(
operator|(
name|sym_return_val_size
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|sym_return_val
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
name|old_cleanups
operator|=
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|sym_return_val
argument_list|)
expr_stmt|;
name|make_symbol_overload_list_using
argument_list|(
name|func_name
argument_list|,
name|namespace
argument_list|)
expr_stmt|;
name|discard_cleanups
argument_list|(
name|old_cleanups
argument_list|)
expr_stmt|;
return|return
name|sym_return_val
return|;
block|}
end_function

begin_comment
comment|/* This applies the using directives to add namespaces to search in,    and then searches for overloads in all of those namespaces.  It    adds the symbols found to sym_return_val.  Arguments are as in    make_symbol_overload_list.  */
end_comment

begin_function
specifier|static
name|void
name|make_symbol_overload_list_using
parameter_list|(
specifier|const
name|char
modifier|*
name|func_name
parameter_list|,
specifier|const
name|char
modifier|*
name|namespace
parameter_list|)
block|{
specifier|const
name|struct
name|using_direct
modifier|*
name|current
decl_stmt|;
comment|/* First, go through the using directives.  If any of them apply,      look in the appropriate namespaces for new functions to match      on.  */
for|for
control|(
name|current
operator|=
name|block_using
argument_list|(
name|get_selected_block
argument_list|(
literal|0
argument_list|)
argument_list|)
init|;
name|current
operator|!=
name|NULL
condition|;
name|current
operator|=
name|current
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|namespace
argument_list|,
name|current
operator|->
name|outer
argument_list|)
operator|==
literal|0
condition|)
block|{
name|make_symbol_overload_list_using
argument_list|(
name|func_name
argument_list|,
name|current
operator|->
name|inner
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now, add names for this namespace.  */
if|if
condition|(
name|namespace
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|make_symbol_overload_list_qualified
argument_list|(
name|func_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|concatenated_name
init|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|namespace
argument_list|)
operator|+
literal|2
operator|+
name|strlen
argument_list|(
name|func_name
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|concatenated_name
argument_list|,
name|namespace
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|concatenated_name
argument_list|,
literal|"::"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|concatenated_name
argument_list|,
name|func_name
argument_list|)
expr_stmt|;
name|make_symbol_overload_list_qualified
argument_list|(
name|concatenated_name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This does the bulk of the work of finding overloaded symbols.    FUNC_NAME is the name of the overloaded function we're looking for    (possibly including namespace info).  */
end_comment

begin_function
specifier|static
name|void
name|make_symbol_overload_list_qualified
parameter_list|(
specifier|const
name|char
modifier|*
name|func_name
parameter_list|)
block|{
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
specifier|const
name|struct
name|block
modifier|*
name|b
decl_stmt|,
modifier|*
name|surrounding_static_block
init|=
literal|0
decl_stmt|;
name|struct
name|dict_iterator
name|iter
decl_stmt|;
specifier|const
name|struct
name|dictionary
modifier|*
name|dict
decl_stmt|;
comment|/* Look through the partial symtabs for all symbols which begin      by matching FUNC_NAME.  Make sure we read that symbol table in. */
name|read_in_psymtabs
argument_list|(
name|func_name
argument_list|)
expr_stmt|;
comment|/* Search upwards from currently selected frame (so that we can      complete on local vars.  */
for|for
control|(
name|b
operator|=
name|get_selected_block
argument_list|(
literal|0
argument_list|)
init|;
name|b
operator|!=
name|NULL
condition|;
name|b
operator|=
name|BLOCK_SUPERBLOCK
argument_list|(
name|b
argument_list|)
control|)
block|{
name|dict
operator|=
name|BLOCK_DICT
argument_list|(
name|b
argument_list|)
expr_stmt|;
for|for
control|(
name|sym
operator|=
name|dict_iter_name_first
argument_list|(
name|dict
argument_list|,
name|func_name
argument_list|,
operator|&
name|iter
argument_list|)
init|;
name|sym
condition|;
name|sym
operator|=
name|dict_iter_name_next
argument_list|(
name|func_name
argument_list|,
operator|&
name|iter
argument_list|)
control|)
block|{
name|overload_list_add_symbol
argument_list|(
name|sym
argument_list|,
name|func_name
argument_list|)
expr_stmt|;
block|}
block|}
name|surrounding_static_block
operator|=
name|block_static_block
argument_list|(
name|get_selected_block
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Go through the symtabs and check the externs and statics for      symbols which match.  */
name|ALL_SYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
block|{
name|QUIT
expr_stmt|;
name|b
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
expr_stmt|;
name|dict
operator|=
name|BLOCK_DICT
argument_list|(
name|b
argument_list|)
expr_stmt|;
for|for
control|(
name|sym
operator|=
name|dict_iter_name_first
argument_list|(
name|dict
argument_list|,
name|func_name
argument_list|,
operator|&
name|iter
argument_list|)
init|;
name|sym
condition|;
name|sym
operator|=
name|dict_iter_name_next
argument_list|(
name|func_name
argument_list|,
operator|&
name|iter
argument_list|)
control|)
block|{
name|overload_list_add_symbol
argument_list|(
name|sym
argument_list|,
name|func_name
argument_list|)
expr_stmt|;
block|}
block|}
name|ALL_SYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
block|{
name|QUIT
expr_stmt|;
name|b
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
argument_list|,
name|STATIC_BLOCK
argument_list|)
expr_stmt|;
comment|/* Don't do this block twice.  */
if|if
condition|(
name|b
operator|==
name|surrounding_static_block
condition|)
continue|continue;
name|dict
operator|=
name|BLOCK_DICT
argument_list|(
name|b
argument_list|)
expr_stmt|;
for|for
control|(
name|sym
operator|=
name|dict_iter_name_first
argument_list|(
name|dict
argument_list|,
name|func_name
argument_list|,
operator|&
name|iter
argument_list|)
init|;
name|sym
condition|;
name|sym
operator|=
name|dict_iter_name_next
argument_list|(
name|func_name
argument_list|,
operator|&
name|iter
argument_list|)
control|)
block|{
name|overload_list_add_symbol
argument_list|(
name|sym
argument_list|,
name|func_name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Look through the partial symtabs for all symbols which begin    by matching FUNC_NAME.  Make sure we read that symbol table in. */
end_comment

begin_function
specifier|static
name|void
name|read_in_psymtabs
parameter_list|(
specifier|const
name|char
modifier|*
name|func_name
parameter_list|)
block|{
name|struct
name|partial_symtab
modifier|*
name|ps
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|ALL_PSYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|ps
argument_list|)
block|{
if|if
condition|(
name|ps
operator|->
name|readin
condition|)
continue|continue;
if|if
condition|(
operator|(
name|lookup_partial_symbol
argument_list|(
name|ps
argument_list|,
name|func_name
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
name|VAR_DOMAIN
argument_list|)
operator|!=
name|NULL
operator|)
operator|||
operator|(
name|lookup_partial_symbol
argument_list|(
name|ps
argument_list|,
name|func_name
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|VAR_DOMAIN
argument_list|)
operator|!=
name|NULL
operator|)
condition|)
name|psymtab_to_symtab
argument_list|(
name|ps
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Lookup the rtti type for a class name. */
end_comment

begin_function
name|struct
name|type
modifier|*
name|cp_lookup_rtti_type
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|block
modifier|*
name|block
parameter_list|)
block|{
name|struct
name|symbol
modifier|*
name|rtti_sym
decl_stmt|;
name|struct
name|type
modifier|*
name|rtti_type
decl_stmt|;
name|rtti_sym
operator|=
name|lookup_symbol
argument_list|(
name|name
argument_list|,
name|block
argument_list|,
name|STRUCT_DOMAIN
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtti_sym
operator|==
name|NULL
condition|)
block|{
name|warning
argument_list|(
literal|"RTTI symbol not found for class '%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|SYMBOL_CLASS
argument_list|(
name|rtti_sym
argument_list|)
operator|!=
name|LOC_TYPEDEF
condition|)
block|{
name|warning
argument_list|(
literal|"RTTI symbol for class '%s' is not a type"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|rtti_type
operator|=
name|SYMBOL_TYPE
argument_list|(
name|rtti_sym
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|rtti_type
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_CLASS
case|:
break|break;
case|case
name|TYPE_CODE_NAMESPACE
case|:
comment|/* chastain/2003-11-26: the symbol tables often contain fake 	 symbols for namespaces with the same name as the struct. 	 This warning is an indication of a bug in the lookup order 	 or a bug in the way that the symbol tables are populated.  */
name|warning
argument_list|(
literal|"RTTI symbol for class '%s' is a namespace"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
default|default:
name|warning
argument_list|(
literal|"RTTI symbol for class '%s' has bad type"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|rtti_type
return|;
block|}
end_function

begin_comment
comment|/* Don't allow just "maintenance cplus".  */
end_comment

begin_function
specifier|static
name|void
name|maint_cplus_command
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|printf_unfiltered
argument_list|(
literal|"\"maintenance cplus\" must be followed by the name of a command.\n"
argument_list|)
expr_stmt|;
name|help_list
argument_list|(
name|maint_cplus_cmd_list
argument_list|,
literal|"maintenance cplus "
argument_list|,
operator|-
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is a front end for cp_find_first_component, for unit testing.    Be careful when using it: see the NOTE above    cp_find_first_component.  */
end_comment

begin_function
specifier|static
name|void
name|first_component_command
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|int
name|len
init|=
name|cp_find_first_component
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|char
modifier|*
name|prefix
init|=
name|alloca
argument_list|(
name|len
operator|+
literal|1
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|prefix
argument_list|,
name|arg
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|prefix
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"%s\n"
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|extern
name|initialize_file_ftype
name|_initialize_cp_support
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -Wmissing-prototypes */
end_comment

begin_function
name|void
name|_initialize_cp_support
parameter_list|(
name|void
parameter_list|)
block|{
name|add_prefix_cmd
argument_list|(
literal|"cplus"
argument_list|,
name|class_maintenance
argument_list|,
name|maint_cplus_command
argument_list|,
literal|"C++ maintenance commands."
argument_list|,
operator|&
name|maint_cplus_cmd_list
argument_list|,
literal|"maintenance cplus "
argument_list|,
literal|0
argument_list|,
operator|&
name|maintenancelist
argument_list|)
expr_stmt|;
name|add_alias_cmd
argument_list|(
literal|"cp"
argument_list|,
literal|"cplus"
argument_list|,
name|class_maintenance
argument_list|,
literal|1
argument_list|,
operator|&
name|maintenancelist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"first_component"
argument_list|,
name|class_maintenance
argument_list|,
name|first_component_command
argument_list|,
literal|"Print the first class/namespace component of NAME."
argument_list|,
operator|&
name|maint_cplus_cmd_list
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

