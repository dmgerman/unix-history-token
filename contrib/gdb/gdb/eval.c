begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Evaluate expressions for GDB.    Copyright 1986, 87, 89, 91, 92, 93, 94, 95, 96, 97, 1998    Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_comment
comment|/* For CAST_IS_CONVERSION */
end_comment

begin_include
include|#
directive|include
file|"f-lang.h"
end_include

begin_comment
comment|/* for array bound stuff */
end_comment

begin_comment
comment|/* Defined in symtab.c */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|hp_som_som_object_present
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is defined in valops.c */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|overload_resolution
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Prototypes for local functions. */
end_comment

begin_decl_stmt
specifier|static
name|value_ptr
name|evaluate_subexp_for_sizeof
name|PARAMS
argument_list|(
operator|(
expr|struct
name|expression
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|value_ptr
name|evaluate_subexp_for_address
name|PARAMS
argument_list|(
operator|(
expr|struct
name|expression
operator|*
operator|,
name|int
operator|*
operator|,
expr|enum
name|noside
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|value_ptr
name|evaluate_subexp
name|PARAMS
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|,
expr|struct
name|expression
operator|*
operator|,
name|int
operator|*
operator|,
expr|enum
name|noside
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|get_label
name|PARAMS
argument_list|(
operator|(
expr|struct
name|expression
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|value_ptr
name|evaluate_struct_tuple
name|PARAMS
argument_list|(
operator|(
name|value_ptr
operator|,
expr|struct
name|expression
operator|*
operator|,
name|int
operator|*
operator|,
expr|enum
name|noside
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|LONGEST
name|init_array_element
name|PARAMS
argument_list|(
operator|(
name|value_ptr
operator|,
name|value_ptr
operator|,
expr|struct
name|expression
operator|*
operator|,
name|int
operator|*
operator|,
expr|enum
name|noside
operator|,
name|LONGEST
operator|,
name|LONGEST
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_function
specifier|inline
endif|#
directive|endif
specifier|static
name|value_ptr
name|evaluate_subexp
parameter_list|(
name|expect_type
parameter_list|,
name|exp
parameter_list|,
name|pos
parameter_list|,
name|noside
parameter_list|)
name|struct
name|type
modifier|*
name|expect_type
decl_stmt|;
specifier|register
name|struct
name|expression
modifier|*
name|exp
decl_stmt|;
specifier|register
name|int
modifier|*
name|pos
decl_stmt|;
name|enum
name|noside
name|noside
decl_stmt|;
block|{
return|return
call|(
modifier|*
name|exp
operator|->
name|language_defn
operator|->
name|evaluate_exp
call|)
argument_list|(
name|expect_type
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Parse the string EXP as a C expression, evaluate it,    and return the result as a number.  */
end_comment

begin_function
name|CORE_ADDR
name|parse_and_eval_address
parameter_list|(
name|exp
parameter_list|)
name|char
modifier|*
name|exp
decl_stmt|;
block|{
name|struct
name|expression
modifier|*
name|expr
init|=
name|parse_expression
argument_list|(
name|exp
argument_list|)
decl_stmt|;
specifier|register
name|CORE_ADDR
name|addr
decl_stmt|;
specifier|register
name|struct
name|cleanup
modifier|*
name|old_chain
init|=
name|make_cleanup
argument_list|(
operator|(
name|make_cleanup_func
operator|)
name|free_current_contents
argument_list|,
operator|&
name|expr
argument_list|)
decl_stmt|;
name|addr
operator|=
name|value_as_pointer
argument_list|(
name|evaluate_expression
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
name|addr
return|;
block|}
end_function

begin_comment
comment|/* Like parse_and_eval_address but takes a pointer to a char * variable    and advanced that variable across the characters parsed.  */
end_comment

begin_function
name|CORE_ADDR
name|parse_and_eval_address_1
parameter_list|(
name|expptr
parameter_list|)
name|char
modifier|*
modifier|*
name|expptr
decl_stmt|;
block|{
name|struct
name|expression
modifier|*
name|expr
init|=
name|parse_exp_1
argument_list|(
name|expptr
argument_list|,
operator|(
expr|struct
name|block
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|register
name|CORE_ADDR
name|addr
decl_stmt|;
specifier|register
name|struct
name|cleanup
modifier|*
name|old_chain
init|=
name|make_cleanup
argument_list|(
operator|(
name|make_cleanup_func
operator|)
name|free_current_contents
argument_list|,
operator|&
name|expr
argument_list|)
decl_stmt|;
name|addr
operator|=
name|value_as_pointer
argument_list|(
name|evaluate_expression
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
name|addr
return|;
block|}
end_function

begin_function
name|value_ptr
name|parse_and_eval
parameter_list|(
name|exp
parameter_list|)
name|char
modifier|*
name|exp
decl_stmt|;
block|{
name|struct
name|expression
modifier|*
name|expr
init|=
name|parse_expression
argument_list|(
name|exp
argument_list|)
decl_stmt|;
specifier|register
name|value_ptr
name|val
decl_stmt|;
specifier|register
name|struct
name|cleanup
modifier|*
name|old_chain
init|=
name|make_cleanup
argument_list|(
operator|(
name|make_cleanup_func
operator|)
name|free_current_contents
argument_list|,
operator|&
name|expr
argument_list|)
decl_stmt|;
name|val
operator|=
name|evaluate_expression
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Parse up to a comma (or to a closeparen)    in the string EXPP as an expression, evaluate it, and return the value.    EXPP is advanced to point to the comma.  */
end_comment

begin_function
name|value_ptr
name|parse_to_comma_and_eval
parameter_list|(
name|expp
parameter_list|)
name|char
modifier|*
modifier|*
name|expp
decl_stmt|;
block|{
name|struct
name|expression
modifier|*
name|expr
init|=
name|parse_exp_1
argument_list|(
name|expp
argument_list|,
operator|(
expr|struct
name|block
operator|*
operator|)
literal|0
argument_list|,
literal|1
argument_list|)
decl_stmt|;
specifier|register
name|value_ptr
name|val
decl_stmt|;
specifier|register
name|struct
name|cleanup
modifier|*
name|old_chain
init|=
name|make_cleanup
argument_list|(
operator|(
name|make_cleanup_func
operator|)
name|free_current_contents
argument_list|,
operator|&
name|expr
argument_list|)
decl_stmt|;
name|val
operator|=
name|evaluate_expression
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Evaluate an expression in internal prefix form    such as is constructed by parse.y.     See expression.h for info on the format of an expression.  */
end_comment

begin_function
name|value_ptr
name|evaluate_expression
parameter_list|(
name|exp
parameter_list|)
name|struct
name|expression
modifier|*
name|exp
decl_stmt|;
block|{
name|int
name|pc
init|=
literal|0
decl_stmt|;
return|return
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
operator|&
name|pc
argument_list|,
name|EVAL_NORMAL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Evaluate an expression, avoiding all memory references    and getting a value whose type alone is correct.  */
end_comment

begin_function
name|value_ptr
name|evaluate_type
parameter_list|(
name|exp
parameter_list|)
name|struct
name|expression
modifier|*
name|exp
decl_stmt|;
block|{
name|int
name|pc
init|=
literal|0
decl_stmt|;
return|return
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
operator|&
name|pc
argument_list|,
name|EVAL_AVOID_SIDE_EFFECTS
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* If the next expression is an OP_LABELED, skips past it,    returning the label.  Otherwise, does nothing and returns NULL. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|get_label
parameter_list|(
name|exp
parameter_list|,
name|pos
parameter_list|)
specifier|register
name|struct
name|expression
modifier|*
name|exp
decl_stmt|;
name|int
modifier|*
name|pos
decl_stmt|;
block|{
if|if
condition|(
name|exp
operator|->
name|elts
index|[
operator|*
name|pos
index|]
operator|.
name|opcode
operator|==
name|OP_LABELED
condition|)
block|{
name|int
name|pc
init|=
operator|(
operator|*
name|pos
operator|)
operator|++
decl_stmt|;
name|char
modifier|*
name|name
init|=
operator|&
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|string
decl_stmt|;
name|int
name|tem
init|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|)
decl_stmt|;
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|3
operator|+
name|BYTES_TO_EXP_ELEM
argument_list|(
name|tem
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|name
return|;
block|}
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* This function evaluates tupes (in Chill) or brace-initializers    (in C/C++) for structure types.  */
end_comment

begin_function
specifier|static
name|value_ptr
name|evaluate_struct_tuple
parameter_list|(
name|struct_val
parameter_list|,
name|exp
parameter_list|,
name|pos
parameter_list|,
name|noside
parameter_list|,
name|nargs
parameter_list|)
name|value_ptr
name|struct_val
decl_stmt|;
specifier|register
name|struct
name|expression
modifier|*
name|exp
decl_stmt|;
specifier|register
name|int
modifier|*
name|pos
decl_stmt|;
name|enum
name|noside
name|noside
decl_stmt|;
name|int
name|nargs
decl_stmt|;
block|{
name|struct
name|type
modifier|*
name|struct_type
init|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|struct_val
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|type
modifier|*
name|substruct_type
init|=
name|struct_type
decl_stmt|;
name|struct
name|type
modifier|*
name|field_type
decl_stmt|;
name|int
name|fieldno
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|variantno
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|subfieldno
init|=
operator|-
literal|1
decl_stmt|;
while|while
condition|(
operator|--
name|nargs
operator|>=
literal|0
condition|)
block|{
name|int
name|pc
init|=
operator|*
name|pos
decl_stmt|;
name|value_ptr
name|val
init|=
name|NULL
decl_stmt|;
name|int
name|nlabels
init|=
literal|0
decl_stmt|;
name|int
name|bitpos
decl_stmt|,
name|bitsize
decl_stmt|;
name|char
modifier|*
name|addr
decl_stmt|;
comment|/* Skip past the labels, and count them. */
while|while
condition|(
name|get_label
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|)
operator|!=
name|NULL
condition|)
name|nlabels
operator|++
expr_stmt|;
do|do
block|{
name|char
modifier|*
name|label
init|=
name|get_label
argument_list|(
name|exp
argument_list|,
operator|&
name|pc
argument_list|)
decl_stmt|;
if|if
condition|(
name|label
condition|)
block|{
for|for
control|(
name|fieldno
operator|=
literal|0
init|;
name|fieldno
operator|<
name|TYPE_NFIELDS
argument_list|(
name|struct_type
argument_list|)
condition|;
name|fieldno
operator|++
control|)
block|{
name|char
modifier|*
name|field_name
init|=
name|TYPE_FIELD_NAME
argument_list|(
name|struct_type
argument_list|,
name|fieldno
argument_list|)
decl_stmt|;
if|if
condition|(
name|field_name
operator|!=
name|NULL
operator|&&
name|STREQ
argument_list|(
name|field_name
argument_list|,
name|label
argument_list|)
condition|)
block|{
name|variantno
operator|=
operator|-
literal|1
expr_stmt|;
name|subfieldno
operator|=
name|fieldno
expr_stmt|;
name|substruct_type
operator|=
name|struct_type
expr_stmt|;
goto|goto
name|found
goto|;
block|}
block|}
for|for
control|(
name|fieldno
operator|=
literal|0
init|;
name|fieldno
operator|<
name|TYPE_NFIELDS
argument_list|(
name|struct_type
argument_list|)
condition|;
name|fieldno
operator|++
control|)
block|{
name|char
modifier|*
name|field_name
init|=
name|TYPE_FIELD_NAME
argument_list|(
name|struct_type
argument_list|,
name|fieldno
argument_list|)
decl_stmt|;
name|field_type
operator|=
name|TYPE_FIELD_TYPE
argument_list|(
name|struct_type
argument_list|,
name|fieldno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|field_name
operator|==
literal|0
operator|||
operator|*
name|field_name
operator|==
literal|'\0'
operator|)
operator|&&
name|TYPE_CODE
argument_list|(
name|field_type
argument_list|)
operator|==
name|TYPE_CODE_UNION
condition|)
block|{
name|variantno
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|variantno
operator|<
name|TYPE_NFIELDS
argument_list|(
name|field_type
argument_list|)
condition|;
name|variantno
operator|++
control|)
block|{
name|substruct_type
operator|=
name|TYPE_FIELD_TYPE
argument_list|(
name|field_type
argument_list|,
name|variantno
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|substruct_type
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
condition|)
block|{
for|for
control|(
name|subfieldno
operator|=
literal|0
init|;
name|subfieldno
operator|<
name|TYPE_NFIELDS
argument_list|(
name|substruct_type
argument_list|)
condition|;
name|subfieldno
operator|++
control|)
block|{
if|if
condition|(
name|STREQ
argument_list|(
name|TYPE_FIELD_NAME
argument_list|(
name|substruct_type
argument_list|,
name|subfieldno
argument_list|)
argument_list|,
name|label
argument_list|)
condition|)
block|{
goto|goto
name|found
goto|;
block|}
block|}
block|}
block|}
block|}
block|}
name|error
argument_list|(
literal|"there is no field named %s"
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|found
label|:
empty_stmt|;
block|}
else|else
block|{
comment|/* Unlabelled tuple element - go to next field. */
if|if
condition|(
name|variantno
operator|>=
literal|0
condition|)
block|{
name|subfieldno
operator|++
expr_stmt|;
if|if
condition|(
name|subfieldno
operator|>=
name|TYPE_NFIELDS
argument_list|(
name|substruct_type
argument_list|)
condition|)
block|{
name|variantno
operator|=
operator|-
literal|1
expr_stmt|;
name|substruct_type
operator|=
name|struct_type
expr_stmt|;
block|}
block|}
if|if
condition|(
name|variantno
operator|<
literal|0
condition|)
block|{
name|fieldno
operator|++
expr_stmt|;
name|subfieldno
operator|=
name|fieldno
expr_stmt|;
if|if
condition|(
name|fieldno
operator|>=
name|TYPE_NFIELDS
argument_list|(
name|struct_type
argument_list|)
condition|)
name|error
argument_list|(
literal|"too many initializers"
argument_list|)
expr_stmt|;
name|field_type
operator|=
name|TYPE_FIELD_TYPE
argument_list|(
name|struct_type
argument_list|,
name|fieldno
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|field_type
argument_list|)
operator|==
name|TYPE_CODE_UNION
operator|&&
name|TYPE_FIELD_NAME
argument_list|(
name|struct_type
argument_list|,
name|fieldno
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'0'
condition|)
name|error
argument_list|(
literal|"don't know which variant you want to set"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Here, struct_type is the type of the inner struct, 	     while substruct_type is the type of the inner struct. 	     These are the same for normal structures, but a variant struct 	     contains anonymous union fields that contain substruct fields. 	     The value fieldno is the index of the top-level (normal or 	     anonymous union) field in struct_field, while the value 	     subfieldno is the index of the actual real (named inner) field 	     in substruct_type. */
name|field_type
operator|=
name|TYPE_FIELD_TYPE
argument_list|(
name|substruct_type
argument_list|,
name|subfieldno
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
name|val
operator|=
name|evaluate_subexp
argument_list|(
name|field_type
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
comment|/* Now actually set the field in struct_val. */
comment|/* Assign val to field fieldno. */
if|if
condition|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
operator|!=
name|field_type
condition|)
name|val
operator|=
name|value_cast
argument_list|(
name|field_type
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|bitsize
operator|=
name|TYPE_FIELD_BITSIZE
argument_list|(
name|substruct_type
argument_list|,
name|subfieldno
argument_list|)
expr_stmt|;
name|bitpos
operator|=
name|TYPE_FIELD_BITPOS
argument_list|(
name|struct_type
argument_list|,
name|fieldno
argument_list|)
expr_stmt|;
if|if
condition|(
name|variantno
operator|>=
literal|0
condition|)
name|bitpos
operator|+=
name|TYPE_FIELD_BITPOS
argument_list|(
name|substruct_type
argument_list|,
name|subfieldno
argument_list|)
expr_stmt|;
name|addr
operator|=
name|VALUE_CONTENTS
argument_list|(
name|struct_val
argument_list|)
operator|+
name|bitpos
operator|/
literal|8
expr_stmt|;
if|if
condition|(
name|bitsize
condition|)
name|modify_field
argument_list|(
name|addr
argument_list|,
name|value_as_long
argument_list|(
name|val
argument_list|)
argument_list|,
name|bitpos
operator|%
literal|8
argument_list|,
name|bitsize
argument_list|)
expr_stmt|;
else|else
name|memcpy
argument_list|(
name|addr
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|val
argument_list|)
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|nlabels
operator|>
literal|0
condition|)
do|;
block|}
return|return
name|struct_val
return|;
block|}
end_function

begin_comment
comment|/* Recursive helper function for setting elements of array tuples for Chill.    The target is ARRAY (which has bounds LOW_BOUND to HIGH_BOUND);    the element value is ELEMENT;    EXP, POS and NOSIDE are as usual.    Evaluates index expresions and sets the specified element(s) of    ARRAY to ELEMENT.    Returns last index value.  */
end_comment

begin_function
specifier|static
name|LONGEST
name|init_array_element
parameter_list|(
name|array
parameter_list|,
name|element
parameter_list|,
name|exp
parameter_list|,
name|pos
parameter_list|,
name|noside
parameter_list|,
name|low_bound
parameter_list|,
name|high_bound
parameter_list|)
name|value_ptr
name|array
decl_stmt|,
name|element
decl_stmt|;
specifier|register
name|struct
name|expression
modifier|*
name|exp
decl_stmt|;
specifier|register
name|int
modifier|*
name|pos
decl_stmt|;
name|enum
name|noside
name|noside
decl_stmt|;
name|LONGEST
name|low_bound
decl_stmt|,
name|high_bound
decl_stmt|;
block|{
name|LONGEST
name|index
decl_stmt|;
name|int
name|element_size
init|=
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|element
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|exp
operator|->
name|elts
index|[
operator|*
name|pos
index|]
operator|.
name|opcode
operator|==
name|BINOP_COMMA
condition|)
block|{
operator|(
operator|*
name|pos
operator|)
operator|++
expr_stmt|;
name|init_array_element
argument_list|(
name|array
argument_list|,
name|element
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|,
name|low_bound
argument_list|,
name|high_bound
argument_list|)
expr_stmt|;
return|return
name|init_array_element
argument_list|(
name|array
argument_list|,
name|element
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|,
name|low_bound
argument_list|,
name|high_bound
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|exp
operator|->
name|elts
index|[
operator|*
name|pos
index|]
operator|.
name|opcode
operator|==
name|BINOP_RANGE
condition|)
block|{
name|LONGEST
name|low
decl_stmt|,
name|high
decl_stmt|;
operator|(
operator|*
name|pos
operator|)
operator|++
expr_stmt|;
name|low
operator|=
name|value_as_long
argument_list|(
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
argument_list|)
expr_stmt|;
name|high
operator|=
name|value_as_long
argument_list|(
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|low
operator|<
name|low_bound
operator|||
name|high
operator|>
name|high_bound
condition|)
name|error
argument_list|(
literal|"tuple range index out of range"
argument_list|)
expr_stmt|;
for|for
control|(
name|index
operator|=
name|low
init|;
name|index
operator|<=
name|high
condition|;
name|index
operator|++
control|)
block|{
name|memcpy
argument_list|(
name|VALUE_CONTENTS_RAW
argument_list|(
name|array
argument_list|)
operator|+
operator|(
name|index
operator|-
name|low_bound
operator|)
operator|*
name|element_size
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|element
argument_list|)
argument_list|,
name|element_size
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|index
operator|=
name|value_as_long
argument_list|(
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|<
name|low_bound
operator|||
name|index
operator|>
name|high_bound
condition|)
name|error
argument_list|(
literal|"tuple index out of range"
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|VALUE_CONTENTS_RAW
argument_list|(
name|array
argument_list|)
operator|+
operator|(
name|index
operator|-
name|low_bound
operator|)
operator|*
name|element_size
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|element
argument_list|)
argument_list|,
name|element_size
argument_list|)
expr_stmt|;
block|}
return|return
name|index
return|;
block|}
end_function

begin_function
name|value_ptr
name|evaluate_subexp_standard
parameter_list|(
name|expect_type
parameter_list|,
name|exp
parameter_list|,
name|pos
parameter_list|,
name|noside
parameter_list|)
name|struct
name|type
modifier|*
name|expect_type
decl_stmt|;
specifier|register
name|struct
name|expression
modifier|*
name|exp
decl_stmt|;
specifier|register
name|int
modifier|*
name|pos
decl_stmt|;
name|enum
name|noside
name|noside
decl_stmt|;
block|{
name|enum
name|exp_opcode
name|op
decl_stmt|;
name|int
name|tem
decl_stmt|,
name|tem2
decl_stmt|,
name|tem3
decl_stmt|;
specifier|register
name|int
name|pc
decl_stmt|,
name|pc2
init|=
literal|0
decl_stmt|,
name|oldpos
decl_stmt|;
specifier|register
name|value_ptr
name|arg1
init|=
name|NULL
decl_stmt|,
name|arg2
init|=
name|NULL
decl_stmt|,
name|arg3
decl_stmt|;
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|int
name|nargs
decl_stmt|;
name|value_ptr
modifier|*
name|argvec
decl_stmt|;
name|int
name|upper
decl_stmt|,
name|lower
decl_stmt|,
name|retcode
decl_stmt|;
name|int
name|code
decl_stmt|;
name|int
name|ix
decl_stmt|;
name|long
name|mem_offset
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|struct
name|type
modifier|*
modifier|*
name|arg_types
decl_stmt|;
name|int
name|save_pos1
decl_stmt|;
comment|/* This expect_type crap should not be used for C.  C expressions do      not have any notion of expected types, never has and (goddess      willing) never will.  The C++ code uses it for some twisted      purpose (I haven't investigated but I suspect it just the usual      combination of Stroustrup figuring out some crazy language      feature and Tiemann figuring out some crazier way to try to      implement it).  CHILL has the tuple stuff; I don't know enough      about CHILL to know whether expected types is the way to do it.      FORTRAN I don't know.  */
if|if
condition|(
name|exp
operator|->
name|language_defn
operator|->
name|la_language
operator|!=
name|language_cplus
operator|&&
name|exp
operator|->
name|language_defn
operator|->
name|la_language
operator|!=
name|language_chill
condition|)
name|expect_type
operator|=
name|NULL_TYPE
expr_stmt|;
name|pc
operator|=
operator|(
operator|*
name|pos
operator|)
operator|++
expr_stmt|;
name|op
operator|=
name|exp
operator|->
name|elts
index|[
name|pc
index|]
operator|.
name|opcode
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|OP_SCOPE
case|:
name|tem
operator|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|4
operator|+
name|BYTES_TO_EXP_ELEM
argument_list|(
name|tem
operator|+
literal|1
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|value_struct_elt_for_reference
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|type
argument_list|,
literal|0
argument_list|,
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|type
argument_list|,
operator|&
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|3
index|]
operator|.
name|string
argument_list|,
name|expect_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg1
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"There is no field named %s"
argument_list|,
operator|&
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|3
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
return|return
name|arg1
return|;
case|case
name|OP_LONG
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|3
expr_stmt|;
return|return
name|value_from_longest
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|type
argument_list|,
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|longconst
argument_list|)
return|;
case|case
name|OP_DOUBLE
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|3
expr_stmt|;
return|return
name|value_from_double
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|type
argument_list|,
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|doubleconst
argument_list|)
return|;
case|case
name|OP_VAR_VALUE
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|3
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
if|if
condition|(
name|noside
operator|==
name|EVAL_AVOID_SIDE_EFFECTS
condition|)
block|{
name|struct
name|symbol
modifier|*
name|sym
init|=
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|symbol
decl_stmt|;
name|enum
name|lval_type
name|lv
decl_stmt|;
switch|switch
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
condition|)
block|{
case|case
name|LOC_CONST
case|:
case|case
name|LOC_LABEL
case|:
case|case
name|LOC_CONST_BYTES
case|:
name|lv
operator|=
name|not_lval
expr_stmt|;
break|break;
case|case
name|LOC_REGISTER
case|:
case|case
name|LOC_REGPARM
case|:
name|lv
operator|=
name|lval_register
expr_stmt|;
break|break;
default|default:
name|lv
operator|=
name|lval_memory
expr_stmt|;
break|break;
block|}
return|return
name|value_zero
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|,
name|lv
argument_list|)
return|;
block|}
else|else
return|return
name|value_of_variable
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|symbol
argument_list|,
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|block
argument_list|)
return|;
case|case
name|OP_LAST
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|2
expr_stmt|;
return|return
name|access_value_history
argument_list|(
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|)
argument_list|)
return|;
case|case
name|OP_REGISTER
case|:
block|{
name|int
name|regno
init|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|)
decl_stmt|;
name|value_ptr
name|val
init|=
name|value_of_register
argument_list|(
name|regno
argument_list|)
decl_stmt|;
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Value of register %s not available."
argument_list|,
name|REGISTER_NAME
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
else|else
return|return
name|val
return|;
block|}
case|case
name|OP_BOOL
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|2
expr_stmt|;
return|return
name|value_from_longest
argument_list|(
name|LA_BOOL_TYPE
argument_list|,
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|)
return|;
case|case
name|OP_INTERNALVAR
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|2
expr_stmt|;
return|return
name|value_of_internalvar
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|internalvar
argument_list|)
return|;
case|case
name|OP_STRING
case|:
name|tem
operator|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|3
operator|+
name|BYTES_TO_EXP_ELEM
argument_list|(
name|tem
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
return|return
name|value_string
argument_list|(
operator|&
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|string
argument_list|,
name|tem
argument_list|)
return|;
case|case
name|OP_BITSTRING
case|:
name|tem
operator|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|3
operator|+
name|BYTES_TO_EXP_ELEM
argument_list|(
operator|(
name|tem
operator|+
name|HOST_CHAR_BIT
operator|-
literal|1
operator|)
operator|/
name|HOST_CHAR_BIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
return|return
name|value_bitstring
argument_list|(
operator|&
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|string
argument_list|,
name|tem
argument_list|)
return|;
break|break;
case|case
name|OP_ARRAY
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|3
expr_stmt|;
name|tem2
operator|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
name|tem3
operator|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
name|nargs
operator|=
name|tem3
operator|-
name|tem2
operator|+
literal|1
expr_stmt|;
name|type
operator|=
name|expect_type
condition|?
name|check_typedef
argument_list|(
name|expect_type
argument_list|)
else|:
name|NULL_TYPE
expr_stmt|;
if|if
condition|(
name|expect_type
operator|!=
name|NULL_TYPE
operator|&&
name|noside
operator|!=
name|EVAL_SKIP
operator|&&
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
condition|)
block|{
name|value_ptr
name|rec
init|=
name|allocate_value
argument_list|(
name|expect_type
argument_list|)
decl_stmt|;
name|memset
argument_list|(
name|VALUE_CONTENTS_RAW
argument_list|(
name|rec
argument_list|)
argument_list|,
literal|'\0'
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|evaluate_struct_tuple
argument_list|(
name|rec
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|,
name|nargs
argument_list|)
return|;
block|}
if|if
condition|(
name|expect_type
operator|!=
name|NULL_TYPE
operator|&&
name|noside
operator|!=
name|EVAL_SKIP
operator|&&
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_ARRAY
condition|)
block|{
name|struct
name|type
modifier|*
name|range_type
init|=
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|struct
name|type
modifier|*
name|element_type
init|=
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|value_ptr
name|array
init|=
name|allocate_value
argument_list|(
name|expect_type
argument_list|)
decl_stmt|;
name|int
name|element_size
init|=
name|TYPE_LENGTH
argument_list|(
name|check_typedef
argument_list|(
name|element_type
argument_list|)
argument_list|)
decl_stmt|;
name|LONGEST
name|low_bound
decl_stmt|,
name|high_bound
decl_stmt|,
name|index
decl_stmt|;
if|if
condition|(
name|get_discrete_bounds
argument_list|(
name|range_type
argument_list|,
operator|&
name|low_bound
argument_list|,
operator|&
name|high_bound
argument_list|)
operator|<
literal|0
condition|)
block|{
name|low_bound
operator|=
literal|0
expr_stmt|;
name|high_bound
operator|=
operator|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|/
name|element_size
operator|)
operator|-
literal|1
expr_stmt|;
block|}
name|index
operator|=
name|low_bound
expr_stmt|;
name|memset
argument_list|(
name|VALUE_CONTENTS_RAW
argument_list|(
name|array
argument_list|)
argument_list|,
literal|0
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|expect_type
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|tem
operator|=
name|nargs
init|;
operator|--
name|nargs
operator|>=
literal|0
condition|;
control|)
block|{
name|value_ptr
name|element
decl_stmt|;
name|int
name|index_pc
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|exp
operator|->
name|elts
index|[
operator|*
name|pos
index|]
operator|.
name|opcode
operator|==
name|BINOP_RANGE
condition|)
block|{
name|index_pc
operator|=
operator|++
operator|(
operator|*
name|pos
operator|)
expr_stmt|;
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|EVAL_SKIP
argument_list|)
expr_stmt|;
block|}
name|element
operator|=
name|evaluate_subexp
argument_list|(
name|element_type
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|VALUE_TYPE
argument_list|(
name|element
argument_list|)
operator|!=
name|element_type
condition|)
name|element
operator|=
name|value_cast
argument_list|(
name|element_type
argument_list|,
name|element
argument_list|)
expr_stmt|;
if|if
condition|(
name|index_pc
condition|)
block|{
name|int
name|continue_pc
init|=
operator|*
name|pos
decl_stmt|;
operator|*
name|pos
operator|=
name|index_pc
expr_stmt|;
name|index
operator|=
name|init_array_element
argument_list|(
name|array
argument_list|,
name|element
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|,
name|low_bound
argument_list|,
name|high_bound
argument_list|)
expr_stmt|;
operator|*
name|pos
operator|=
name|continue_pc
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|index
operator|>
name|high_bound
condition|)
comment|/* to avoid memory corruption */
name|error
argument_list|(
literal|"Too many array elements"
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|VALUE_CONTENTS_RAW
argument_list|(
name|array
argument_list|)
operator|+
operator|(
name|index
operator|-
name|low_bound
operator|)
operator|*
name|element_size
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|element
argument_list|)
argument_list|,
name|element_size
argument_list|)
expr_stmt|;
block|}
name|index
operator|++
expr_stmt|;
block|}
return|return
name|array
return|;
block|}
if|if
condition|(
name|expect_type
operator|!=
name|NULL_TYPE
operator|&&
name|noside
operator|!=
name|EVAL_SKIP
operator|&&
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_SET
condition|)
block|{
name|value_ptr
name|set
init|=
name|allocate_value
argument_list|(
name|expect_type
argument_list|)
decl_stmt|;
name|char
modifier|*
name|valaddr
init|=
name|VALUE_CONTENTS_RAW
argument_list|(
name|set
argument_list|)
decl_stmt|;
name|struct
name|type
modifier|*
name|element_type
init|=
name|TYPE_INDEX_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|struct
name|type
modifier|*
name|check_type
init|=
name|element_type
decl_stmt|;
name|LONGEST
name|low_bound
decl_stmt|,
name|high_bound
decl_stmt|;
comment|/* get targettype of elementtype */
while|while
condition|(
name|TYPE_CODE
argument_list|(
name|check_type
argument_list|)
operator|==
name|TYPE_CODE_RANGE
operator|||
name|TYPE_CODE
argument_list|(
name|check_type
argument_list|)
operator|==
name|TYPE_CODE_TYPEDEF
condition|)
name|check_type
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|check_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|get_discrete_bounds
argument_list|(
name|element_type
argument_list|,
operator|&
name|low_bound
argument_list|,
operator|&
name|high_bound
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"(power)set type with unknown size"
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|valaddr
argument_list|,
literal|'\0'
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|tem
operator|=
literal|0
init|;
name|tem
operator|<
name|nargs
condition|;
name|tem
operator|++
control|)
block|{
name|LONGEST
name|range_low
decl_stmt|,
name|range_high
decl_stmt|;
name|struct
name|type
modifier|*
name|range_low_type
decl_stmt|,
modifier|*
name|range_high_type
decl_stmt|;
name|value_ptr
name|elem_val
decl_stmt|;
if|if
condition|(
name|exp
operator|->
name|elts
index|[
operator|*
name|pos
index|]
operator|.
name|opcode
operator|==
name|BINOP_RANGE
condition|)
block|{
operator|(
operator|*
name|pos
operator|)
operator|++
expr_stmt|;
name|elem_val
operator|=
name|evaluate_subexp
argument_list|(
name|element_type
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
name|range_low_type
operator|=
name|VALUE_TYPE
argument_list|(
name|elem_val
argument_list|)
expr_stmt|;
name|range_low
operator|=
name|value_as_long
argument_list|(
name|elem_val
argument_list|)
expr_stmt|;
name|elem_val
operator|=
name|evaluate_subexp
argument_list|(
name|element_type
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
name|range_high_type
operator|=
name|VALUE_TYPE
argument_list|(
name|elem_val
argument_list|)
expr_stmt|;
name|range_high
operator|=
name|value_as_long
argument_list|(
name|elem_val
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|elem_val
operator|=
name|evaluate_subexp
argument_list|(
name|element_type
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
name|range_low_type
operator|=
name|range_high_type
operator|=
name|VALUE_TYPE
argument_list|(
name|elem_val
argument_list|)
expr_stmt|;
name|range_low
operator|=
name|range_high
operator|=
name|value_as_long
argument_list|(
name|elem_val
argument_list|)
expr_stmt|;
block|}
comment|/* check types of elements to avoid mixture of elements from 		 different types. Also check if type of element is "compatible" 		 with element type of powerset */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|range_low_type
argument_list|)
operator|==
name|TYPE_CODE_RANGE
condition|)
name|range_low_type
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|range_low_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|range_high_type
argument_list|)
operator|==
name|TYPE_CODE_RANGE
condition|)
name|range_high_type
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|range_high_type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TYPE_CODE
argument_list|(
name|range_low_type
argument_list|)
operator|!=
name|TYPE_CODE
argument_list|(
name|range_high_type
argument_list|)
operator|)
operator|||
operator|(
name|TYPE_CODE
argument_list|(
name|range_low_type
argument_list|)
operator|==
name|TYPE_CODE_ENUM
operator|&&
operator|(
name|range_low_type
operator|!=
name|range_high_type
operator|)
operator|)
condition|)
comment|/* different element modes */
name|error
argument_list|(
literal|"POWERSET tuple elements of different mode"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TYPE_CODE
argument_list|(
name|check_type
argument_list|)
operator|!=
name|TYPE_CODE
argument_list|(
name|range_low_type
argument_list|)
operator|)
operator|||
operator|(
name|TYPE_CODE
argument_list|(
name|check_type
argument_list|)
operator|==
name|TYPE_CODE_ENUM
operator|&&
name|range_low_type
operator|!=
name|check_type
operator|)
condition|)
name|error
argument_list|(
literal|"incompatible POWERSET tuple elements"
argument_list|)
expr_stmt|;
if|if
condition|(
name|range_low
operator|>
name|range_high
condition|)
block|{
name|warning
argument_list|(
literal|"empty POWERSET tuple range"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|range_low
operator|<
name|low_bound
operator|||
name|range_high
operator|>
name|high_bound
condition|)
name|error
argument_list|(
literal|"POWERSET tuple element out of range"
argument_list|)
expr_stmt|;
name|range_low
operator|-=
name|low_bound
expr_stmt|;
name|range_high
operator|-=
name|low_bound
expr_stmt|;
for|for
control|(
init|;
name|range_low
operator|<=
name|range_high
condition|;
name|range_low
operator|++
control|)
block|{
name|int
name|bit_index
init|=
operator|(
name|unsigned
operator|)
name|range_low
operator|%
name|TARGET_CHAR_BIT
decl_stmt|;
if|if
condition|(
name|BITS_BIG_ENDIAN
condition|)
name|bit_index
operator|=
name|TARGET_CHAR_BIT
operator|-
literal|1
operator|-
name|bit_index
expr_stmt|;
name|valaddr
index|[
operator|(
name|unsigned
operator|)
name|range_low
operator|/
name|TARGET_CHAR_BIT
index|]
operator||=
literal|1
operator|<<
name|bit_index
expr_stmt|;
block|}
block|}
return|return
name|set
return|;
block|}
name|argvec
operator|=
operator|(
name|value_ptr
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|value_ptr
argument_list|)
operator|*
name|nargs
argument_list|)
expr_stmt|;
for|for
control|(
name|tem
operator|=
literal|0
init|;
name|tem
operator|<
name|nargs
condition|;
name|tem
operator|++
control|)
block|{
comment|/* Ensure that array expressions are coerced into pointer objects. */
name|argvec
index|[
name|tem
index|]
operator|=
name|evaluate_subexp_with_coercion
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
return|return
name|value_array
argument_list|(
name|tem2
argument_list|,
name|tem3
argument_list|,
name|argvec
argument_list|)
return|;
case|case
name|TERNOP_SLICE
case|:
block|{
name|value_ptr
name|array
init|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
decl_stmt|;
name|int
name|lowbound
init|=
name|value_as_long
argument_list|(
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|upper
init|=
name|value_as_long
argument_list|(
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
return|return
name|value_slice
argument_list|(
name|array
argument_list|,
name|lowbound
argument_list|,
name|upper
operator|-
name|lowbound
operator|+
literal|1
argument_list|)
return|;
block|}
case|case
name|TERNOP_SLICE_COUNT
case|:
block|{
name|value_ptr
name|array
init|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
decl_stmt|;
name|int
name|lowbound
init|=
name|value_as_long
argument_list|(
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|length
init|=
name|value_as_long
argument_list|(
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|value_slice
argument_list|(
name|array
argument_list|,
name|lowbound
argument_list|,
name|length
argument_list|)
return|;
block|}
case|case
name|TERNOP_COND
case|:
comment|/* Skip third and second args to evaluate the first one.  */
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|value_logical_not
argument_list|(
name|arg1
argument_list|)
condition|)
block|{
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|EVAL_SKIP
argument_list|)
expr_stmt|;
return|return
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
return|;
block|}
else|else
block|{
name|arg2
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|EVAL_SKIP
argument_list|)
expr_stmt|;
return|return
name|arg2
return|;
block|}
case|case
name|OP_FUNCALL
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|2
expr_stmt|;
name|op
operator|=
name|exp
operator|->
name|elts
index|[
operator|*
name|pos
index|]
operator|.
name|opcode
expr_stmt|;
name|nargs
operator|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
comment|/* Allocate arg vector, including space for the function to be 	 called in argvec[0] and a terminating NULL */
name|argvec
operator|=
operator|(
name|value_ptr
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|value_ptr
argument_list|)
operator|*
operator|(
name|nargs
operator|+
literal|3
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|STRUCTOP_MEMBER
operator|||
name|op
operator|==
name|STRUCTOP_MPTR
condition|)
block|{
name|LONGEST
name|fnptr
decl_stmt|;
comment|/* 1997-08-01 Currently we do not support function invocation              via pointers-to-methods with HP aCC. Pointer does not point              to the function, but possibly to some thunk. */
if|if
condition|(
name|hp_som_som_object_present
condition|)
block|{
name|error
argument_list|(
literal|"Not implemented: function invocation through pointer to method with HP aCC"
argument_list|)
expr_stmt|;
block|}
name|nargs
operator|++
expr_stmt|;
comment|/* First, evaluate the structure into arg2 */
name|pc2
operator|=
operator|(
operator|*
name|pos
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
if|if
condition|(
name|op
operator|==
name|STRUCTOP_MEMBER
condition|)
block|{
name|arg2
operator|=
name|evaluate_subexp_for_address
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|arg2
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
block|}
comment|/* If the function is a virtual function, then the 	     aggregate value (providing the structure) plays 	     its part by providing the vtable.  Otherwise, 	     it is just along for the ride: call the function 	     directly.  */
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
name|fnptr
operator|=
name|value_as_long
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|METHOD_PTR_IS_VIRTUAL
argument_list|(
name|fnptr
argument_list|)
condition|)
block|{
name|int
name|fnoffset
init|=
name|METHOD_PTR_TO_VOFFSET
argument_list|(
name|fnptr
argument_list|)
decl_stmt|;
name|struct
name|type
modifier|*
name|basetype
decl_stmt|;
name|struct
name|type
modifier|*
name|domain_type
init|=
name|TYPE_DOMAIN_TYPE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|basetype
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|domain_type
operator|!=
name|basetype
condition|)
name|arg2
operator|=
name|value_cast
argument_list|(
name|lookup_pointer_type
argument_list|(
name|domain_type
argument_list|)
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
name|basetype
operator|=
name|TYPE_VPTR_BASETYPE
argument_list|(
name|domain_type
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|TYPE_NFN_FIELDS
argument_list|(
name|basetype
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|struct
name|fn_field
modifier|*
name|f
init|=
name|TYPE_FN_FIELDLIST1
argument_list|(
name|basetype
argument_list|,
name|i
argument_list|)
decl_stmt|;
comment|/* If one is virtual, then all are virtual.  */
if|if
condition|(
name|TYPE_FN_FIELD_VIRTUAL_P
argument_list|(
name|f
argument_list|,
literal|0
argument_list|)
condition|)
for|for
control|(
name|j
operator|=
name|TYPE_FN_FIELDLIST_LENGTH
argument_list|(
name|basetype
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
operator|--
name|j
control|)
if|if
condition|(
operator|(
name|int
operator|)
name|TYPE_FN_FIELD_VOFFSET
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
operator|==
name|fnoffset
condition|)
block|{
name|value_ptr
name|temp
init|=
name|value_ind
argument_list|(
name|arg2
argument_list|)
decl_stmt|;
name|arg1
operator|=
name|value_virtual_fn_field
argument_list|(
operator|&
name|temp
argument_list|,
name|f
argument_list|,
name|j
argument_list|,
name|domain_type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|value_addr
argument_list|(
name|temp
argument_list|)
expr_stmt|;
goto|goto
name|got_it
goto|;
block|}
block|}
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"virtual function at index %d not found"
argument_list|,
name|fnoffset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
operator|=
name|lookup_pointer_type
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|got_it
label|:
comment|/* Now, say which argument to start evaluating from */
name|tem
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
name|STRUCTOP_STRUCT
operator|||
name|op
operator|==
name|STRUCTOP_PTR
condition|)
block|{
comment|/* Hair for method invocations */
name|int
name|tem2
decl_stmt|;
name|nargs
operator|++
expr_stmt|;
comment|/* First, evaluate the structure into arg2 */
name|pc2
operator|=
operator|(
operator|*
name|pos
operator|)
operator|++
expr_stmt|;
name|tem2
operator|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc2
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
operator|*
name|pos
operator|+=
literal|3
operator|+
name|BYTES_TO_EXP_ELEM
argument_list|(
name|tem2
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
if|if
condition|(
name|op
operator|==
name|STRUCTOP_STRUCT
condition|)
block|{
comment|/* If v is a variable in a register, and the user types 		 v.method (), this will produce an error, because v has 		 no address.  		 A possible way around this would be to allocate a 		 copy of the variable on the stack, copy in the 		 contents, call the function, and copy out the 		 contents.  I.e. convert this from call by reference 		 to call by copy-return (or whatever it's called). 		 However, this does not work because it is not the 		 same: the method being called could stash a copy of 		 the address, and then future uses through that address 		 (after the method returns) would be expected to 		 use the variable itself, not some copy of it.  */
name|arg2
operator|=
name|evaluate_subexp_for_address
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|arg2
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
block|}
comment|/* Now, say which argument to start evaluating from */
name|tem
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
comment|/* Non-method function call */
name|save_pos1
operator|=
operator|*
name|pos
expr_stmt|;
name|argvec
index|[
literal|0
index|]
operator|=
name|evaluate_subexp_with_coercion
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
name|tem
operator|=
literal|1
expr_stmt|;
name|type
operator|=
name|VALUE_TYPE
argument_list|(
name|argvec
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|&&
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_PTR
condition|)
name|type
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|&&
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_FUNC
condition|)
block|{
for|for
control|(
init|;
name|tem
operator|<=
name|nargs
operator|&&
name|tem
operator|<=
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
condition|;
name|tem
operator|++
control|)
block|{
comment|/* pai: FIXME This seems to be coercing arguments before                    * overload resolution has been done! */
name|argvec
index|[
name|tem
index|]
operator|=
name|evaluate_subexp
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|tem
operator|-
literal|1
argument_list|)
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Evaluate arguments */
for|for
control|(
init|;
name|tem
operator|<=
name|nargs
condition|;
name|tem
operator|++
control|)
block|{
comment|/* Ensure that array expressions are coerced into pointer objects. */
name|argvec
index|[
name|tem
index|]
operator|=
name|evaluate_subexp_with_coercion
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
block|}
comment|/* signal end of arglist */
name|argvec
index|[
name|tem
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|STRUCTOP_STRUCT
operator|||
name|op
operator|==
name|STRUCTOP_PTR
condition|)
block|{
name|int
name|static_memfuncp
decl_stmt|;
name|value_ptr
name|temp
init|=
name|arg2
decl_stmt|;
name|char
name|tstr
index|[
literal|256
index|]
decl_stmt|;
name|struct
name|fn_field
modifier|*
name|fns_ptr
decl_stmt|;
name|int
name|num_fns
decl_stmt|;
name|struct
name|type
modifier|*
name|basetype
decl_stmt|;
name|int
name|boffset
decl_stmt|;
comment|/* Method invocation : stuff "this" as first parameter */
comment|/* pai: this used to have lookup_pointer_type for some reason,            * but temp is already a pointer to the object */
name|argvec
index|[
literal|1
index|]
operator|=
name|value_from_longest
argument_list|(
name|VALUE_TYPE
argument_list|(
name|temp
argument_list|)
argument_list|,
name|VALUE_ADDRESS
argument_list|(
name|temp
argument_list|)
operator|+
name|VALUE_OFFSET
argument_list|(
name|temp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Name of method from expression */
name|strcpy
argument_list|(
name|tstr
argument_list|,
operator|&
name|exp
operator|->
name|elts
index|[
name|pc2
operator|+
literal|2
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|overload_resolution
operator|&&
operator|(
name|exp
operator|->
name|language_defn
operator|->
name|la_language
operator|==
name|language_cplus
operator|)
condition|)
block|{
comment|/* Language is C++, do some overload resolution before evaluation */
name|value_ptr
name|valp
init|=
name|NULL
decl_stmt|;
comment|/* Prepare list of argument types for overload resolution */
name|arg_types
operator|=
operator|(
expr|struct
name|type
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|nargs
operator|*
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|ix
operator|=
literal|1
init|;
name|ix
operator|<=
name|nargs
condition|;
name|ix
operator|++
control|)
name|arg_types
index|[
name|ix
operator|-
literal|1
index|]
operator|=
name|VALUE_TYPE
argument_list|(
name|argvec
index|[
name|ix
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|find_overload_match
argument_list|(
name|arg_types
argument_list|,
name|nargs
argument_list|,
name|tstr
argument_list|,
literal|1
comment|/* method */
argument_list|,
literal|0
comment|/* strict match */
argument_list|,
name|arg2
comment|/* the object */
argument_list|,
name|NULL
argument_list|,
operator|&
name|valp
argument_list|,
name|NULL
argument_list|,
operator|&
name|static_memfuncp
argument_list|)
expr_stmt|;
name|argvec
index|[
literal|1
index|]
operator|=
name|arg2
expr_stmt|;
comment|/* the ``this'' pointer */
name|argvec
index|[
literal|0
index|]
operator|=
name|valp
expr_stmt|;
comment|/* use the method found after overload resolution */
block|}
else|else
comment|/* Non-C++ case -- or no overload resolution */
block|{
name|temp
operator|=
name|arg2
expr_stmt|;
name|argvec
index|[
literal|0
index|]
operator|=
name|value_struct_elt
argument_list|(
operator|&
name|temp
argument_list|,
name|argvec
operator|+
literal|1
argument_list|,
name|tstr
argument_list|,
operator|&
name|static_memfuncp
argument_list|,
name|op
operator|==
name|STRUCTOP_STRUCT
condition|?
literal|"structure"
else|:
literal|"structure pointer"
argument_list|)
expr_stmt|;
name|argvec
index|[
literal|1
index|]
operator|=
name|arg2
expr_stmt|;
comment|/* the ``this'' pointer */
block|}
if|if
condition|(
name|static_memfuncp
condition|)
block|{
name|argvec
index|[
literal|1
index|]
operator|=
name|argvec
index|[
literal|0
index|]
expr_stmt|;
name|nargs
operator|--
expr_stmt|;
name|argvec
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|op
operator|==
name|STRUCTOP_MEMBER
operator|||
name|op
operator|==
name|STRUCTOP_MPTR
condition|)
block|{
name|argvec
index|[
literal|1
index|]
operator|=
name|arg2
expr_stmt|;
name|argvec
index|[
literal|0
index|]
operator|=
name|arg1
expr_stmt|;
block|}
else|else
block|{
comment|/* Non-member function being called */
if|if
condition|(
name|overload_resolution
operator|&&
operator|(
name|exp
operator|->
name|language_defn
operator|->
name|la_language
operator|==
name|language_cplus
operator|)
condition|)
block|{
comment|/* Language is C++, do some overload resolution before evaluation */
name|struct
name|symbol
modifier|*
name|symp
decl_stmt|;
comment|/* Prepare list of argument types for overload resolution */
name|arg_types
operator|=
operator|(
expr|struct
name|type
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|nargs
operator|*
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|ix
operator|=
literal|1
init|;
name|ix
operator|<=
name|nargs
condition|;
name|ix
operator|++
control|)
name|arg_types
index|[
name|ix
operator|-
literal|1
index|]
operator|=
name|VALUE_TYPE
argument_list|(
name|argvec
index|[
name|ix
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|find_overload_match
argument_list|(
name|arg_types
argument_list|,
name|nargs
argument_list|,
name|NULL
comment|/* no need for name */
argument_list|,
literal|0
comment|/* not method */
argument_list|,
literal|0
comment|/* strict match */
argument_list|,
name|NULL
argument_list|,
name|exp
operator|->
name|elts
index|[
literal|5
index|]
operator|.
name|symbol
comment|/* the function */
argument_list|,
name|NULL
argument_list|,
operator|&
name|symp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Now fix the expression being evaluated */
name|exp
operator|->
name|elts
index|[
literal|5
index|]
operator|.
name|symbol
operator|=
name|symp
expr_stmt|;
name|argvec
index|[
literal|0
index|]
operator|=
name|evaluate_subexp_with_coercion
argument_list|(
name|exp
argument_list|,
operator|&
name|save_pos1
argument_list|,
name|noside
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Not C++, or no overload resolution allowed */
comment|/* nothing to be done; argvec already correctly set up */
block|}
block|}
name|do_call_it
label|:
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
if|if
condition|(
name|noside
operator|==
name|EVAL_AVOID_SIDE_EFFECTS
condition|)
block|{
comment|/* If the return type doesn't look like a function type, call an 	     error.  This can happen if somebody tries to turn a variable into 	     a function call. This is here because people often want to 	     call, eg, strcmp, which gdb doesn't know is a function.  If 	     gdb isn't asked for it's opinion (ie. through "whatis"), 	     it won't offer it. */
name|struct
name|type
modifier|*
name|ftype
init|=
name|TYPE_TARGET_TYPE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|argvec
index|[
literal|0
index|]
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|ftype
condition|)
return|return
name|allocate_value
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|argvec
index|[
literal|0
index|]
argument_list|)
argument_list|)
argument_list|)
return|;
else|else
name|error
argument_list|(
literal|"Expression of type other than \"Function returning ...\" used as function"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argvec
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Cannot evaluate function -- may be inlined"
argument_list|)
expr_stmt|;
return|return
name|call_function_by_hand
argument_list|(
name|argvec
index|[
literal|0
index|]
argument_list|,
name|nargs
argument_list|,
name|argvec
operator|+
literal|1
argument_list|)
return|;
comment|/* pai: FIXME save value from call_function_by_hand, then adjust pc by adjust_fn_pc if +ve  */
case|case
name|OP_F77_UNDETERMINED_ARGLIST
case|:
comment|/* Remember that in F77, functions, substring ops and           array subscript operations cannot be disambiguated           at parse time.  We have made all array subscript operations,           substring operations as well as function calls  come here           and we now have to discover what the heck this thing actually was.   	 If it is a function, we process just as if we got an OP_FUNCALL. */
name|nargs
operator|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|2
expr_stmt|;
comment|/* First determine the type code we are dealing with.  */
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
name|type
operator|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|=
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|TYPE_CODE_ARRAY
case|:
goto|goto
name|multi_f77_subscript
goto|;
case|case
name|TYPE_CODE_STRING
case|:
goto|goto
name|op_f77_substr
goto|;
case|case
name|TYPE_CODE_PTR
case|:
case|case
name|TYPE_CODE_FUNC
case|:
comment|/* It's a function call. */
comment|/* Allocate arg vector, including space for the function to be 	     called in argvec[0] and a terminating NULL */
name|argvec
operator|=
operator|(
name|value_ptr
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|value_ptr
argument_list|)
operator|*
operator|(
name|nargs
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
name|argvec
index|[
literal|0
index|]
operator|=
name|arg1
expr_stmt|;
name|tem
operator|=
literal|1
expr_stmt|;
for|for
control|(
init|;
name|tem
operator|<=
name|nargs
condition|;
name|tem
operator|++
control|)
name|argvec
index|[
name|tem
index|]
operator|=
name|evaluate_subexp_with_coercion
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
name|argvec
index|[
name|tem
index|]
operator|=
literal|0
expr_stmt|;
comment|/* signal end of arglist */
goto|goto
name|do_call_it
goto|;
default|default:
name|error
argument_list|(
literal|"Cannot perform substring on this type"
argument_list|)
expr_stmt|;
block|}
name|op_f77_substr
label|:
comment|/* We have a substring operation on our hands here,           let us get the string we will be dealing with */
comment|/* Now evaluate the 'from' and 'to' */
name|arg2
operator|=
name|evaluate_subexp_with_coercion
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|nargs
operator|<
literal|2
condition|)
return|return
name|value_subscript
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
return|;
name|arg3
operator|=
name|evaluate_subexp_with_coercion
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
name|tem2
operator|=
name|value_as_long
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
name|tem3
operator|=
name|value_as_long
argument_list|(
name|arg3
argument_list|)
expr_stmt|;
return|return
name|value_slice
argument_list|(
name|arg1
argument_list|,
name|tem2
argument_list|,
name|tem3
operator|-
name|tem2
operator|+
literal|1
argument_list|)
return|;
case|case
name|OP_COMPLEX
case|:
comment|/* We have a complex number, There should be 2 floating  	 point numbers that compose it */
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
return|return
name|value_literal_complex
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
name|builtin_type_f_complex_s16
argument_list|)
return|;
case|case
name|STRUCTOP_STRUCT
case|:
name|tem
operator|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|3
operator|+
name|BYTES_TO_EXP_ELEM
argument_list|(
name|tem
operator|+
literal|1
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
if|if
condition|(
name|noside
operator|==
name|EVAL_AVOID_SIDE_EFFECTS
condition|)
return|return
name|value_zero
argument_list|(
name|lookup_struct_elt_type
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
operator|&
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|string
argument_list|,
literal|0
argument_list|)
argument_list|,
name|lval_memory
argument_list|)
return|;
else|else
block|{
name|value_ptr
name|temp
init|=
name|arg1
decl_stmt|;
return|return
name|value_struct_elt
argument_list|(
operator|&
name|temp
argument_list|,
name|NULL
argument_list|,
operator|&
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|string
argument_list|,
name|NULL
argument_list|,
literal|"structure"
argument_list|)
return|;
block|}
case|case
name|STRUCTOP_PTR
case|:
name|tem
operator|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|3
operator|+
name|BYTES_TO_EXP_ELEM
argument_list|(
name|tem
operator|+
literal|1
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
if|if
condition|(
name|noside
operator|==
name|EVAL_AVOID_SIDE_EFFECTS
condition|)
return|return
name|value_zero
argument_list|(
name|lookup_struct_elt_type
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
operator|&
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|string
argument_list|,
literal|0
argument_list|)
argument_list|,
name|lval_memory
argument_list|)
return|;
else|else
block|{
name|value_ptr
name|temp
init|=
name|arg1
decl_stmt|;
return|return
name|value_struct_elt
argument_list|(
operator|&
name|temp
argument_list|,
name|NULL
argument_list|,
operator|&
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|string
argument_list|,
name|NULL
argument_list|,
literal|"structure pointer"
argument_list|)
return|;
block|}
case|case
name|STRUCTOP_MEMBER
case|:
name|arg1
operator|=
name|evaluate_subexp_for_address
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
comment|/* With HP aCC, pointers to methods do not point to the function code */
if|if
condition|(
name|hp_som_som_object_present
operator|&&
operator|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_PTR
operator|)
operator|&&
operator|(
name|TYPE_CODE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_METHOD
operator|)
condition|)
name|error
argument_list|(
literal|"Pointers to methods not supported with HP aCC"
argument_list|)
expr_stmt|;
comment|/* 1997-08-19 */
name|mem_offset
operator|=
name|value_as_long
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
goto|goto
name|handle_pointer_to_member
goto|;
case|case
name|STRUCTOP_MPTR
case|:
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
comment|/* With HP aCC, pointers to methods do not point to the function code */
if|if
condition|(
name|hp_som_som_object_present
operator|&&
operator|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_PTR
operator|)
operator|&&
operator|(
name|TYPE_CODE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_METHOD
operator|)
condition|)
name|error
argument_list|(
literal|"Pointers to methods not supported with HP aCC"
argument_list|)
expr_stmt|;
comment|/* 1997-08-19 */
name|mem_offset
operator|=
name|value_as_long
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
name|handle_pointer_to_member
label|:
comment|/* HP aCC generates offsets that have bit #29 set; turn it off to get          a real offset to the member. */
if|if
condition|(
name|hp_som_som_object_present
condition|)
block|{
if|if
condition|(
operator|!
name|mem_offset
condition|)
comment|/* no bias -> really null */
name|error
argument_list|(
literal|"Attempted dereference of null pointer-to-member"
argument_list|)
expr_stmt|;
name|mem_offset
operator|&=
operator|~
literal|0x20000000
expr_stmt|;
block|}
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
name|type
operator|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_CODE_PTR
condition|)
goto|goto
name|bad_pointer_to_member
goto|;
name|type
operator|=
name|check_typedef
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_METHOD
condition|)
name|error
argument_list|(
literal|"not implemented: pointer-to-method in pointer-to-member construct"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_CODE_MEMBER
condition|)
goto|goto
name|bad_pointer_to_member
goto|;
comment|/* Now, convert these values to an address.  */
name|arg1
operator|=
name|value_cast
argument_list|(
name|lookup_pointer_type
argument_list|(
name|TYPE_DOMAIN_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
name|arg3
operator|=
name|value_from_longest
argument_list|(
name|lookup_pointer_type
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|value_as_long
argument_list|(
name|arg1
argument_list|)
operator|+
name|mem_offset
argument_list|)
expr_stmt|;
return|return
name|value_ind
argument_list|(
name|arg3
argument_list|)
return|;
name|bad_pointer_to_member
label|:
name|error
argument_list|(
literal|"non-pointer-to-member value used in pointer-to-member construct"
argument_list|)
expr_stmt|;
case|case
name|BINOP_CONCAT
case|:
name|arg1
operator|=
name|evaluate_subexp_with_coercion
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|evaluate_subexp_with_coercion
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
if|if
condition|(
name|binop_user_defined_p
argument_list|(
name|op
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
condition|)
return|return
name|value_x_binop
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
name|op
argument_list|,
name|OP_NULL
argument_list|,
name|noside
argument_list|)
return|;
else|else
return|return
name|value_concat
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
return|;
case|case
name|BINOP_ASSIGN
case|:
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|evaluate_subexp
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
comment|/* Do special stuff for HP aCC pointers to members */
if|if
condition|(
name|hp_som_som_object_present
condition|)
block|{
comment|/* 1997-08-19 Can't assign HP aCC pointers to methods. No details of              the implementation yet; but the pointer appears to point to a code              sequence (thunk) in memory -- in any case it is *not* the address              of the function as it would be in a naive implementation. */
if|if
condition|(
operator|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_PTR
operator|)
operator|&&
operator|(
name|TYPE_CODE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_METHOD
operator|)
condition|)
name|error
argument_list|(
literal|"Assignment to pointers to methods not implemented with HP aCC"
argument_list|)
expr_stmt|;
comment|/* HP aCC pointers to data members require a constant bias */
if|if
condition|(
operator|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_PTR
operator|)
operator|&&
operator|(
name|TYPE_CODE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_MEMBER
operator|)
condition|)
block|{
name|unsigned
name|int
modifier|*
name|ptr
init|=
operator|(
name|unsigned
name|int
operator|*
operator|)
name|VALUE_CONTENTS
argument_list|(
name|arg2
argument_list|)
decl_stmt|;
comment|/* forces evaluation */
operator|*
name|ptr
operator||=
literal|0x20000000
expr_stmt|;
comment|/* set 29th bit */
block|}
block|}
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
operator|||
name|noside
operator|==
name|EVAL_AVOID_SIDE_EFFECTS
condition|)
return|return
name|arg1
return|;
if|if
condition|(
name|binop_user_defined_p
argument_list|(
name|op
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
condition|)
return|return
name|value_x_binop
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
name|op
argument_list|,
name|OP_NULL
argument_list|,
name|noside
argument_list|)
return|;
else|else
return|return
name|value_assign
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
return|;
case|case
name|BINOP_ASSIGN_MODIFY
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|2
expr_stmt|;
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|evaluate_subexp
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
operator|||
name|noside
operator|==
name|EVAL_AVOID_SIDE_EFFECTS
condition|)
return|return
name|arg1
return|;
name|op
operator|=
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|opcode
expr_stmt|;
if|if
condition|(
name|binop_user_defined_p
argument_list|(
name|op
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
condition|)
return|return
name|value_x_binop
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
name|BINOP_ASSIGN_MODIFY
argument_list|,
name|op
argument_list|,
name|noside
argument_list|)
return|;
elseif|else
if|if
condition|(
name|op
operator|==
name|BINOP_ADD
condition|)
name|arg2
operator|=
name|value_add
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|op
operator|==
name|BINOP_SUB
condition|)
name|arg2
operator|=
name|value_sub
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
else|else
name|arg2
operator|=
name|value_binop
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
name|op
argument_list|)
expr_stmt|;
return|return
name|value_assign
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
return|;
case|case
name|BINOP_ADD
case|:
name|arg1
operator|=
name|evaluate_subexp_with_coercion
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|evaluate_subexp_with_coercion
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
if|if
condition|(
name|binop_user_defined_p
argument_list|(
name|op
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
condition|)
return|return
name|value_x_binop
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
name|op
argument_list|,
name|OP_NULL
argument_list|,
name|noside
argument_list|)
return|;
else|else
return|return
name|value_add
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
return|;
case|case
name|BINOP_SUB
case|:
name|arg1
operator|=
name|evaluate_subexp_with_coercion
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|evaluate_subexp_with_coercion
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
if|if
condition|(
name|binop_user_defined_p
argument_list|(
name|op
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
condition|)
return|return
name|value_x_binop
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
name|op
argument_list|,
name|OP_NULL
argument_list|,
name|noside
argument_list|)
return|;
else|else
return|return
name|value_sub
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
return|;
case|case
name|BINOP_MUL
case|:
case|case
name|BINOP_DIV
case|:
case|case
name|BINOP_REM
case|:
case|case
name|BINOP_MOD
case|:
case|case
name|BINOP_LSH
case|:
case|case
name|BINOP_RSH
case|:
case|case
name|BINOP_BITWISE_AND
case|:
case|case
name|BINOP_BITWISE_IOR
case|:
case|case
name|BINOP_BITWISE_XOR
case|:
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
if|if
condition|(
name|binop_user_defined_p
argument_list|(
name|op
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
condition|)
return|return
name|value_x_binop
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
name|op
argument_list|,
name|OP_NULL
argument_list|,
name|noside
argument_list|)
return|;
elseif|else
if|if
condition|(
name|noside
operator|==
name|EVAL_AVOID_SIDE_EFFECTS
operator|&&
operator|(
name|op
operator|==
name|BINOP_DIV
operator|||
name|op
operator|==
name|BINOP_REM
operator|||
name|op
operator|==
name|BINOP_MOD
operator|)
condition|)
return|return
name|value_zero
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|not_lval
argument_list|)
return|;
else|else
return|return
name|value_binop
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
name|op
argument_list|)
return|;
case|case
name|BINOP_RANGE
case|:
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
name|error
argument_list|(
literal|"':' operator used in invalid context"
argument_list|)
expr_stmt|;
case|case
name|BINOP_SUBSCRIPT
case|:
name|arg1
operator|=
name|evaluate_subexp_with_coercion
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|evaluate_subexp_with_coercion
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
if|if
condition|(
name|binop_user_defined_p
argument_list|(
name|op
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
condition|)
return|return
name|value_x_binop
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
name|op
argument_list|,
name|OP_NULL
argument_list|,
name|noside
argument_list|)
return|;
else|else
block|{
comment|/* If the user attempts to subscript something that is not an 	     array or pointer type (like a plain int variable for example), 	     then report this as an error. */
name|COERCE_REF
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|type
operator|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_CODE_ARRAY
operator|&&
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_CODE_PTR
condition|)
block|{
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
condition|)
name|error
argument_list|(
literal|"cannot subscript something of type `%s'"
argument_list|,
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"cannot subscript requested type"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|noside
operator|==
name|EVAL_AVOID_SIDE_EFFECTS
condition|)
return|return
name|value_zero
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|VALUE_LVAL
argument_list|(
name|arg1
argument_list|)
argument_list|)
return|;
else|else
return|return
name|value_subscript
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
return|;
block|}
case|case
name|BINOP_IN
case|:
name|arg1
operator|=
name|evaluate_subexp_with_coercion
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|evaluate_subexp_with_coercion
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
return|return
name|value_in
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
return|;
case|case
name|MULTI_SUBSCRIPT
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|2
expr_stmt|;
name|nargs
operator|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|evaluate_subexp_with_coercion
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
while|while
condition|(
name|nargs
operator|--
operator|>
literal|0
condition|)
block|{
name|arg2
operator|=
name|evaluate_subexp_with_coercion
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
comment|/* FIXME:  EVAL_SKIP handling may not be correct. */
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
block|{
if|if
condition|(
name|nargs
operator|>
literal|0
condition|)
block|{
continue|continue;
block|}
else|else
block|{
goto|goto
name|nosideret
goto|;
block|}
block|}
comment|/* FIXME:  EVAL_AVOID_SIDE_EFFECTS handling may not be correct. */
if|if
condition|(
name|noside
operator|==
name|EVAL_AVOID_SIDE_EFFECTS
condition|)
block|{
comment|/* If the user attempts to subscript something that has no target 		 type (like a plain int variable for example), then report this 		 as an error. */
name|type
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|NULL
condition|)
block|{
name|arg1
operator|=
name|value_zero
argument_list|(
name|type
argument_list|,
name|VALUE_LVAL
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
name|noside
operator|=
name|EVAL_SKIP
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|error
argument_list|(
literal|"cannot subscript something of type `%s'"
argument_list|,
name|TYPE_NAME
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|binop_user_defined_p
argument_list|(
name|op
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
condition|)
block|{
name|arg1
operator|=
name|value_x_binop
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
name|op
argument_list|,
name|OP_NULL
argument_list|,
name|noside
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|arg1
operator|=
name|value_subscript
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|arg1
operator|)
return|;
name|multi_f77_subscript
label|:
block|{
name|int
name|subscript_array
index|[
name|MAX_FORTRAN_DIMS
operator|+
literal|1
index|]
decl_stmt|;
comment|/* 1-based array of  						    subscripts, max == 7 */
name|int
name|array_size_array
index|[
name|MAX_FORTRAN_DIMS
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|ndimensions
init|=
literal|1
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|type
modifier|*
name|tmp_type
decl_stmt|;
name|int
name|offset_item
decl_stmt|;
comment|/* The array offset where the item lives */
if|if
condition|(
name|nargs
operator|>
name|MAX_FORTRAN_DIMS
condition|)
name|error
argument_list|(
literal|"Too many subscripts for F77 (%d Max)"
argument_list|,
name|MAX_FORTRAN_DIMS
argument_list|)
expr_stmt|;
name|tmp_type
operator|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
name|ndimensions
operator|=
name|calc_f77_array_dims
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|nargs
operator|!=
name|ndimensions
condition|)
name|error
argument_list|(
literal|"Wrong number of subscripts"
argument_list|)
expr_stmt|;
comment|/* Now that we know we have a legal array subscript expression  	   let us actually find out where this element exists in the array. */
name|offset_item
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|nargs
condition|;
name|i
operator|++
control|)
block|{
comment|/* Evaluate each subscript, It must be a legal integer in F77 */
name|arg2
operator|=
name|evaluate_subexp_with_coercion
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
comment|/* Fill in the subscript and array size arrays */
name|subscript_array
index|[
name|i
index|]
operator|=
name|value_as_long
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
name|retcode
operator|=
name|f77_get_dynamic_upperbound
argument_list|(
name|tmp_type
argument_list|,
operator|&
name|upper
argument_list|)
expr_stmt|;
if|if
condition|(
name|retcode
operator|==
name|BOUND_FETCH_ERROR
condition|)
name|error
argument_list|(
literal|"Cannot obtain dynamic upper bound"
argument_list|)
expr_stmt|;
name|retcode
operator|=
name|f77_get_dynamic_lowerbound
argument_list|(
name|tmp_type
argument_list|,
operator|&
name|lower
argument_list|)
expr_stmt|;
if|if
condition|(
name|retcode
operator|==
name|BOUND_FETCH_ERROR
condition|)
name|error
argument_list|(
literal|"Cannot obtain dynamic lower bound"
argument_list|)
expr_stmt|;
name|array_size_array
index|[
name|i
index|]
operator|=
name|upper
operator|-
name|lower
operator|+
literal|1
expr_stmt|;
comment|/* Zero-normalize subscripts so that offsetting will work. */
name|subscript_array
index|[
name|i
index|]
operator|-=
name|lower
expr_stmt|;
comment|/* If we are at the bottom of a multidimensional  	       array type then keep a ptr to the last ARRAY 	       type around for use when calling value_subscript() 	       below. This is done because we pretend to value_subscript 	       that we actually have a one-dimensional array  	       of base element type that we apply a simple  	       offset to. */
if|if
condition|(
name|i
operator|<
name|nargs
condition|)
name|tmp_type
operator|=
name|check_typedef
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|tmp_type
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Now let us calculate the offset for this item */
name|offset_item
operator|=
name|subscript_array
index|[
name|ndimensions
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|ndimensions
operator|-
literal|1
init|;
name|i
operator|>=
literal|1
condition|;
name|i
operator|--
control|)
name|offset_item
operator|=
name|array_size_array
index|[
name|i
index|]
operator|*
name|offset_item
operator|+
name|subscript_array
index|[
name|i
index|]
expr_stmt|;
comment|/* Construct a value node with the value of the offset */
name|arg2
operator|=
name|value_from_longest
argument_list|(
name|builtin_type_f_integer
argument_list|,
name|offset_item
argument_list|)
expr_stmt|;
comment|/* Let us now play a dirty trick: we will take arg1  	   which is a value node pointing to the topmost level 	   of the multidimensional array-set and pretend 	   that it is actually a array of the final element  	   type, this will ensure that value_subscript() 	   returns the correct type value */
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
operator|=
name|tmp_type
expr_stmt|;
return|return
name|value_ind
argument_list|(
name|value_add
argument_list|(
name|value_coerce_array
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|arg2
argument_list|)
argument_list|)
return|;
block|}
case|case
name|BINOP_LOGICAL_AND
case|:
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
block|{
name|arg2
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
goto|goto
name|nosideret
goto|;
block|}
name|oldpos
operator|=
operator|*
name|pos
expr_stmt|;
name|arg2
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|EVAL_AVOID_SIDE_EFFECTS
argument_list|)
expr_stmt|;
operator|*
name|pos
operator|=
name|oldpos
expr_stmt|;
if|if
condition|(
name|binop_user_defined_p
argument_list|(
name|op
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
condition|)
block|{
name|arg2
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
return|return
name|value_x_binop
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
name|op
argument_list|,
name|OP_NULL
argument_list|,
name|noside
argument_list|)
return|;
block|}
else|else
block|{
name|tem
operator|=
name|value_logical_not
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
operator|(
name|tem
condition|?
name|EVAL_SKIP
else|:
name|noside
operator|)
argument_list|)
expr_stmt|;
return|return
name|value_from_longest
argument_list|(
name|LA_BOOL_TYPE
argument_list|,
call|(
name|LONGEST
call|)
argument_list|(
operator|!
name|tem
operator|&&
operator|!
name|value_logical_not
argument_list|(
name|arg2
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
case|case
name|BINOP_LOGICAL_OR
case|:
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
block|{
name|arg2
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
goto|goto
name|nosideret
goto|;
block|}
name|oldpos
operator|=
operator|*
name|pos
expr_stmt|;
name|arg2
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|EVAL_AVOID_SIDE_EFFECTS
argument_list|)
expr_stmt|;
operator|*
name|pos
operator|=
name|oldpos
expr_stmt|;
if|if
condition|(
name|binop_user_defined_p
argument_list|(
name|op
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
condition|)
block|{
name|arg2
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
return|return
name|value_x_binop
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
name|op
argument_list|,
name|OP_NULL
argument_list|,
name|noside
argument_list|)
return|;
block|}
else|else
block|{
name|tem
operator|=
name|value_logical_not
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
operator|(
operator|!
name|tem
condition|?
name|EVAL_SKIP
else|:
name|noside
operator|)
argument_list|)
expr_stmt|;
return|return
name|value_from_longest
argument_list|(
name|LA_BOOL_TYPE
argument_list|,
call|(
name|LONGEST
call|)
argument_list|(
operator|!
name|tem
operator|||
operator|!
name|value_logical_not
argument_list|(
name|arg2
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
case|case
name|BINOP_EQUAL
case|:
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|evaluate_subexp
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
if|if
condition|(
name|binop_user_defined_p
argument_list|(
name|op
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
condition|)
block|{
return|return
name|value_x_binop
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
name|op
argument_list|,
name|OP_NULL
argument_list|,
name|noside
argument_list|)
return|;
block|}
else|else
block|{
name|tem
operator|=
name|value_equal
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
return|return
name|value_from_longest
argument_list|(
name|LA_BOOL_TYPE
argument_list|,
operator|(
name|LONGEST
operator|)
name|tem
argument_list|)
return|;
block|}
case|case
name|BINOP_NOTEQUAL
case|:
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|evaluate_subexp
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
if|if
condition|(
name|binop_user_defined_p
argument_list|(
name|op
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
condition|)
block|{
return|return
name|value_x_binop
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
name|op
argument_list|,
name|OP_NULL
argument_list|,
name|noside
argument_list|)
return|;
block|}
else|else
block|{
name|tem
operator|=
name|value_equal
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
return|return
name|value_from_longest
argument_list|(
name|LA_BOOL_TYPE
argument_list|,
operator|(
name|LONGEST
operator|)
operator|!
name|tem
argument_list|)
return|;
block|}
case|case
name|BINOP_LESS
case|:
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|evaluate_subexp
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
if|if
condition|(
name|binop_user_defined_p
argument_list|(
name|op
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
condition|)
block|{
return|return
name|value_x_binop
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
name|op
argument_list|,
name|OP_NULL
argument_list|,
name|noside
argument_list|)
return|;
block|}
else|else
block|{
name|tem
operator|=
name|value_less
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
return|return
name|value_from_longest
argument_list|(
name|LA_BOOL_TYPE
argument_list|,
operator|(
name|LONGEST
operator|)
name|tem
argument_list|)
return|;
block|}
case|case
name|BINOP_GTR
case|:
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|evaluate_subexp
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
if|if
condition|(
name|binop_user_defined_p
argument_list|(
name|op
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
condition|)
block|{
return|return
name|value_x_binop
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
name|op
argument_list|,
name|OP_NULL
argument_list|,
name|noside
argument_list|)
return|;
block|}
else|else
block|{
name|tem
operator|=
name|value_less
argument_list|(
name|arg2
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
return|return
name|value_from_longest
argument_list|(
name|LA_BOOL_TYPE
argument_list|,
operator|(
name|LONGEST
operator|)
name|tem
argument_list|)
return|;
block|}
case|case
name|BINOP_GEQ
case|:
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|evaluate_subexp
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
if|if
condition|(
name|binop_user_defined_p
argument_list|(
name|op
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
condition|)
block|{
return|return
name|value_x_binop
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
name|op
argument_list|,
name|OP_NULL
argument_list|,
name|noside
argument_list|)
return|;
block|}
else|else
block|{
name|tem
operator|=
name|value_less
argument_list|(
name|arg2
argument_list|,
name|arg1
argument_list|)
operator|||
name|value_equal
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
return|return
name|value_from_longest
argument_list|(
name|LA_BOOL_TYPE
argument_list|,
operator|(
name|LONGEST
operator|)
name|tem
argument_list|)
return|;
block|}
case|case
name|BINOP_LEQ
case|:
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|evaluate_subexp
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
if|if
condition|(
name|binop_user_defined_p
argument_list|(
name|op
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
condition|)
block|{
return|return
name|value_x_binop
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
name|op
argument_list|,
name|OP_NULL
argument_list|,
name|noside
argument_list|)
return|;
block|}
else|else
block|{
name|tem
operator|=
name|value_less
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
operator|||
name|value_equal
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
return|return
name|value_from_longest
argument_list|(
name|LA_BOOL_TYPE
argument_list|,
operator|(
name|LONGEST
operator|)
name|tem
argument_list|)
return|;
block|}
case|case
name|BINOP_REPEAT
case|:
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
name|type
operator|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_CODE_INT
condition|)
name|error
argument_list|(
literal|"Non-integral right operand for \"@\" operator."
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_AVOID_SIDE_EFFECTS
condition|)
block|{
return|return
name|allocate_repeat_value
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|longest_to_int
argument_list|(
name|value_as_long
argument_list|(
name|arg2
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
else|else
return|return
name|value_repeat
argument_list|(
name|arg1
argument_list|,
name|longest_to_int
argument_list|(
name|value_as_long
argument_list|(
name|arg2
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|BINOP_COMMA
case|:
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
return|return
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
return|;
case|case
name|UNOP_NEG
case|:
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
if|if
condition|(
name|unop_user_defined_p
argument_list|(
name|op
argument_list|,
name|arg1
argument_list|)
condition|)
return|return
name|value_x_unop
argument_list|(
name|arg1
argument_list|,
name|op
argument_list|,
name|noside
argument_list|)
return|;
else|else
return|return
name|value_neg
argument_list|(
name|arg1
argument_list|)
return|;
case|case
name|UNOP_COMPLEMENT
case|:
comment|/* C++: check for and handle destructor names.  */
name|op
operator|=
name|exp
operator|->
name|elts
index|[
operator|*
name|pos
index|]
operator|.
name|opcode
expr_stmt|;
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
if|if
condition|(
name|unop_user_defined_p
argument_list|(
name|UNOP_COMPLEMENT
argument_list|,
name|arg1
argument_list|)
condition|)
return|return
name|value_x_unop
argument_list|(
name|arg1
argument_list|,
name|UNOP_COMPLEMENT
argument_list|,
name|noside
argument_list|)
return|;
else|else
return|return
name|value_complement
argument_list|(
name|arg1
argument_list|)
return|;
case|case
name|UNOP_LOGICAL_NOT
case|:
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
if|if
condition|(
name|unop_user_defined_p
argument_list|(
name|op
argument_list|,
name|arg1
argument_list|)
condition|)
return|return
name|value_x_unop
argument_list|(
name|arg1
argument_list|,
name|op
argument_list|,
name|noside
argument_list|)
return|;
else|else
return|return
name|value_from_longest
argument_list|(
name|LA_BOOL_TYPE
argument_list|,
operator|(
name|LONGEST
operator|)
name|value_logical_not
argument_list|(
name|arg1
argument_list|)
argument_list|)
return|;
case|case
name|UNOP_IND
case|:
if|if
condition|(
name|expect_type
operator|&&
name|TYPE_CODE
argument_list|(
name|expect_type
argument_list|)
operator|==
name|TYPE_CODE_PTR
condition|)
name|expect_type
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|check_typedef
argument_list|(
name|expect_type
argument_list|)
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|expect_type
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TYPE_TARGET_TYPE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|TYPE_CODE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_METHOD
operator|)
operator|||
operator|(
name|TYPE_CODE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_MEMBER
operator|)
operator|)
condition|)
name|error
argument_list|(
literal|"Attempt to dereference pointer to member without an object"
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
if|if
condition|(
name|unop_user_defined_p
argument_list|(
name|op
argument_list|,
name|arg1
argument_list|)
condition|)
return|return
name|value_x_unop
argument_list|(
name|arg1
argument_list|,
name|op
argument_list|,
name|noside
argument_list|)
return|;
elseif|else
if|if
condition|(
name|noside
operator|==
name|EVAL_AVOID_SIDE_EFFECTS
condition|)
block|{
name|type
operator|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_PTR
operator|||
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_REF
comment|/* In C you can dereference an array to get the 1st elt.  */
operator|||
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_ARRAY
condition|)
return|return
name|value_zero
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|lval_memory
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_INT
condition|)
comment|/* GDB allows dereferencing an int.  */
return|return
name|value_zero
argument_list|(
name|builtin_type_int
argument_list|,
name|lval_memory
argument_list|)
return|;
else|else
name|error
argument_list|(
literal|"Attempt to take contents of a non-pointer value."
argument_list|)
expr_stmt|;
block|}
return|return
name|value_ind
argument_list|(
name|arg1
argument_list|)
return|;
case|case
name|UNOP_ADDR
case|:
comment|/* C++: check for and handle pointer to members.  */
name|op
operator|=
name|exp
operator|->
name|elts
index|[
operator|*
name|pos
index|]
operator|.
name|opcode
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
block|{
if|if
condition|(
name|op
operator|==
name|OP_SCOPE
condition|)
block|{
name|int
name|temm
init|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|3
index|]
operator|.
name|longconst
argument_list|)
decl_stmt|;
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|3
operator|+
name|BYTES_TO_EXP_ELEM
argument_list|(
name|temm
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|evaluate_subexp
argument_list|(
name|expect_type
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|EVAL_SKIP
argument_list|)
expr_stmt|;
goto|goto
name|nosideret
goto|;
block|}
else|else
block|{
name|value_ptr
name|retvalp
init|=
name|evaluate_subexp_for_address
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
decl_stmt|;
comment|/* If HP aCC object, use bias for pointers to members */
if|if
condition|(
name|hp_som_som_object_present
operator|&&
operator|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|retvalp
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_PTR
operator|)
operator|&&
operator|(
name|TYPE_CODE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|retvalp
argument_list|)
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_MEMBER
operator|)
condition|)
block|{
name|unsigned
name|int
modifier|*
name|ptr
init|=
operator|(
name|unsigned
name|int
operator|*
operator|)
name|VALUE_CONTENTS
argument_list|(
name|retvalp
argument_list|)
decl_stmt|;
comment|/* forces evaluation */
operator|*
name|ptr
operator||=
literal|0x20000000
expr_stmt|;
comment|/* set 29th bit */
block|}
return|return
name|retvalp
return|;
block|}
case|case
name|UNOP_SIZEOF
case|:
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
block|{
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|EVAL_SKIP
argument_list|)
expr_stmt|;
goto|goto
name|nosideret
goto|;
block|}
return|return
name|evaluate_subexp_for_sizeof
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|)
return|;
case|case
name|UNOP_CAST
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|2
expr_stmt|;
name|type
operator|=
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|type
expr_stmt|;
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|type
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
if|if
condition|(
name|type
operator|!=
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
condition|)
name|arg1
operator|=
name|value_cast
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
return|return
name|arg1
return|;
case|case
name|UNOP_MEMVAL
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|2
expr_stmt|;
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|expect_type
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
if|if
condition|(
name|noside
operator|==
name|EVAL_AVOID_SIDE_EFFECTS
condition|)
return|return
name|value_zero
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|type
argument_list|,
name|lval_memory
argument_list|)
return|;
else|else
return|return
name|value_at_lazy
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|type
argument_list|,
name|value_as_pointer
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|NULL
argument_list|)
return|;
case|case
name|UNOP_PREINCREMENT
case|:
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|expect_type
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
operator|||
name|noside
operator|==
name|EVAL_AVOID_SIDE_EFFECTS
condition|)
return|return
name|arg1
return|;
elseif|else
if|if
condition|(
name|unop_user_defined_p
argument_list|(
name|op
argument_list|,
name|arg1
argument_list|)
condition|)
block|{
return|return
name|value_x_unop
argument_list|(
name|arg1
argument_list|,
name|op
argument_list|,
name|noside
argument_list|)
return|;
block|}
else|else
block|{
name|arg2
operator|=
name|value_add
argument_list|(
name|arg1
argument_list|,
name|value_from_longest
argument_list|(
name|builtin_type_char
argument_list|,
operator|(
name|LONGEST
operator|)
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|value_assign
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
return|;
block|}
case|case
name|UNOP_PREDECREMENT
case|:
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|expect_type
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
operator|||
name|noside
operator|==
name|EVAL_AVOID_SIDE_EFFECTS
condition|)
return|return
name|arg1
return|;
elseif|else
if|if
condition|(
name|unop_user_defined_p
argument_list|(
name|op
argument_list|,
name|arg1
argument_list|)
condition|)
block|{
return|return
name|value_x_unop
argument_list|(
name|arg1
argument_list|,
name|op
argument_list|,
name|noside
argument_list|)
return|;
block|}
else|else
block|{
name|arg2
operator|=
name|value_sub
argument_list|(
name|arg1
argument_list|,
name|value_from_longest
argument_list|(
name|builtin_type_char
argument_list|,
operator|(
name|LONGEST
operator|)
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|value_assign
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
return|;
block|}
case|case
name|UNOP_POSTINCREMENT
case|:
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|expect_type
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
operator|||
name|noside
operator|==
name|EVAL_AVOID_SIDE_EFFECTS
condition|)
return|return
name|arg1
return|;
elseif|else
if|if
condition|(
name|unop_user_defined_p
argument_list|(
name|op
argument_list|,
name|arg1
argument_list|)
condition|)
block|{
return|return
name|value_x_unop
argument_list|(
name|arg1
argument_list|,
name|op
argument_list|,
name|noside
argument_list|)
return|;
block|}
else|else
block|{
name|arg2
operator|=
name|value_add
argument_list|(
name|arg1
argument_list|,
name|value_from_longest
argument_list|(
name|builtin_type_char
argument_list|,
operator|(
name|LONGEST
operator|)
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|value_assign
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
return|return
name|arg1
return|;
block|}
case|case
name|UNOP_POSTDECREMENT
case|:
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|expect_type
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
operator|||
name|noside
operator|==
name|EVAL_AVOID_SIDE_EFFECTS
condition|)
return|return
name|arg1
return|;
elseif|else
if|if
condition|(
name|unop_user_defined_p
argument_list|(
name|op
argument_list|,
name|arg1
argument_list|)
condition|)
block|{
return|return
name|value_x_unop
argument_list|(
name|arg1
argument_list|,
name|op
argument_list|,
name|noside
argument_list|)
return|;
block|}
else|else
block|{
name|arg2
operator|=
name|value_sub
argument_list|(
name|arg1
argument_list|,
name|value_from_longest
argument_list|(
name|builtin_type_char
argument_list|,
operator|(
name|LONGEST
operator|)
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|value_assign
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
return|return
name|arg1
return|;
block|}
case|case
name|OP_THIS
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|1
expr_stmt|;
return|return
name|value_of_this
argument_list|(
literal|1
argument_list|)
return|;
case|case
name|OP_TYPE
case|:
name|error
argument_list|(
literal|"Attempt to use a type name as an expression"
argument_list|)
expr_stmt|;
default|default:
comment|/* Removing this case and compiling with gcc -Wall reveals that 	 a lot of cases are hitting this case.  Some of these should 	 probably be removed from expression.h (e.g. do we need a BINOP_SCOPE 	 and an OP_SCOPE?); others are legitimate expressions which are 	 (apparently) not fully implemented.  	 If there are any cases landing here which mean a user error, 	 then they should be separate cases, with more descriptive 	 error messages.  */
name|error
argument_list|(
literal|"\ GDB does not (yet) know how to evaluate that kind of expression"
argument_list|)
expr_stmt|;
block|}
name|nosideret
label|:
return|return
name|value_from_longest
argument_list|(
name|builtin_type_long
argument_list|,
operator|(
name|LONGEST
operator|)
literal|1
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Evaluate a subexpression of EXP, at index *POS,    and return the address of that subexpression.    Advance *POS over the subexpression.    If the subexpression isn't an lvalue, get an error.    NOSIDE may be EVAL_AVOID_SIDE_EFFECTS;    then only the type of the result need be correct.  */
end_comment

begin_function
specifier|static
name|value_ptr
name|evaluate_subexp_for_address
parameter_list|(
name|exp
parameter_list|,
name|pos
parameter_list|,
name|noside
parameter_list|)
specifier|register
name|struct
name|expression
modifier|*
name|exp
decl_stmt|;
specifier|register
name|int
modifier|*
name|pos
decl_stmt|;
name|enum
name|noside
name|noside
decl_stmt|;
block|{
name|enum
name|exp_opcode
name|op
decl_stmt|;
specifier|register
name|int
name|pc
decl_stmt|;
name|struct
name|symbol
modifier|*
name|var
decl_stmt|;
name|pc
operator|=
operator|(
operator|*
name|pos
operator|)
expr_stmt|;
name|op
operator|=
name|exp
operator|->
name|elts
index|[
name|pc
index|]
operator|.
name|opcode
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|UNOP_IND
case|:
operator|(
operator|*
name|pos
operator|)
operator|++
expr_stmt|;
return|return
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
return|;
case|case
name|UNOP_MEMVAL
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|3
expr_stmt|;
return|return
name|value_cast
argument_list|(
name|lookup_pointer_type
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|type
argument_list|)
argument_list|,
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
argument_list|)
return|;
case|case
name|OP_VAR_VALUE
case|:
name|var
operator|=
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|symbol
expr_stmt|;
comment|/* C++: The "address" of a reference should yield the address        * of the object pointed to. Let value_addr() deal with it. */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|var
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_REF
condition|)
goto|goto
name|default_case
goto|;
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_AVOID_SIDE_EFFECTS
condition|)
block|{
name|struct
name|type
modifier|*
name|type
init|=
name|lookup_pointer_type
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|var
argument_list|)
argument_list|)
decl_stmt|;
name|enum
name|address_class
name|sym_class
init|=
name|SYMBOL_CLASS
argument_list|(
name|var
argument_list|)
decl_stmt|;
if|if
condition|(
name|sym_class
operator|==
name|LOC_CONST
operator|||
name|sym_class
operator|==
name|LOC_CONST_BYTES
operator|||
name|sym_class
operator|==
name|LOC_REGISTER
operator|||
name|sym_class
operator|==
name|LOC_REGPARM
condition|)
name|error
argument_list|(
literal|"Attempt to take address of register or constant."
argument_list|)
expr_stmt|;
return|return
name|value_zero
argument_list|(
name|type
argument_list|,
name|not_lval
argument_list|)
return|;
block|}
else|else
return|return
name|locate_var_value
argument_list|(
name|var
argument_list|,
name|block_innermost_frame
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|block
argument_list|)
argument_list|)
return|;
default|default:
name|default_case
label|:
if|if
condition|(
name|noside
operator|==
name|EVAL_AVOID_SIDE_EFFECTS
condition|)
block|{
name|value_ptr
name|x
init|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
decl_stmt|;
if|if
condition|(
name|VALUE_LVAL
argument_list|(
name|x
argument_list|)
operator|==
name|lval_memory
condition|)
return|return
name|value_zero
argument_list|(
name|lookup_pointer_type
argument_list|(
name|VALUE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|not_lval
argument_list|)
return|;
else|else
name|error
argument_list|(
literal|"Attempt to take address of non-lval"
argument_list|)
expr_stmt|;
block|}
return|return
name|value_addr
argument_list|(
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Evaluate like `evaluate_subexp' except coercing arrays to pointers.    When used in contexts where arrays will be coerced anyway, this is    equivalent to `evaluate_subexp' but much faster because it avoids    actually fetching array contents (perhaps obsolete now that we have    VALUE_LAZY).     Note that we currently only do the coercion for C expressions, where    arrays are zero based and the coercion is correct.  For other languages,    with nonzero based arrays, coercion loses.  Use CAST_IS_CONVERSION    to decide if coercion is appropriate.     */
end_comment

begin_function
name|value_ptr
name|evaluate_subexp_with_coercion
parameter_list|(
name|exp
parameter_list|,
name|pos
parameter_list|,
name|noside
parameter_list|)
specifier|register
name|struct
name|expression
modifier|*
name|exp
decl_stmt|;
specifier|register
name|int
modifier|*
name|pos
decl_stmt|;
name|enum
name|noside
name|noside
decl_stmt|;
block|{
specifier|register
name|enum
name|exp_opcode
name|op
decl_stmt|;
specifier|register
name|int
name|pc
decl_stmt|;
specifier|register
name|value_ptr
name|val
decl_stmt|;
name|struct
name|symbol
modifier|*
name|var
decl_stmt|;
name|pc
operator|=
operator|(
operator|*
name|pos
operator|)
expr_stmt|;
name|op
operator|=
name|exp
operator|->
name|elts
index|[
name|pc
index|]
operator|.
name|opcode
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|OP_VAR_VALUE
case|:
name|var
operator|=
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|symbol
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|check_typedef
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|var
argument_list|)
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_ARRAY
operator|&&
name|CAST_IS_CONVERSION
condition|)
block|{
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|4
expr_stmt|;
name|val
operator|=
name|locate_var_value
argument_list|(
name|var
argument_list|,
name|block_innermost_frame
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|block
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|value_cast
argument_list|(
name|lookup_pointer_type
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|var
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|val
argument_list|)
return|;
block|}
comment|/* FALLTHROUGH */
default|default:
return|return
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Evaluate a subexpression of EXP, at index *POS,    and return a value for the size of that subexpression.    Advance *POS over the subexpression.  */
end_comment

begin_function
specifier|static
name|value_ptr
name|evaluate_subexp_for_sizeof
parameter_list|(
name|exp
parameter_list|,
name|pos
parameter_list|)
specifier|register
name|struct
name|expression
modifier|*
name|exp
decl_stmt|;
specifier|register
name|int
modifier|*
name|pos
decl_stmt|;
block|{
name|enum
name|exp_opcode
name|op
decl_stmt|;
specifier|register
name|int
name|pc
decl_stmt|;
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|value_ptr
name|val
decl_stmt|;
name|pc
operator|=
operator|(
operator|*
name|pos
operator|)
expr_stmt|;
name|op
operator|=
name|exp
operator|->
name|elts
index|[
name|pc
index|]
operator|.
name|opcode
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
comment|/* This case is handled specially 	 so that we avoid creating a value for the result type. 	 If the result type is very big, it's desirable not to 	 create a value unnecessarily.  */
case|case
name|UNOP_IND
case|:
operator|(
operator|*
name|pos
operator|)
operator|++
expr_stmt|;
name|val
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|EVAL_AVOID_SIDE_EFFECTS
argument_list|)
expr_stmt|;
name|type
operator|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_CODE_PTR
operator|&&
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_CODE_REF
operator|&&
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_CODE_ARRAY
condition|)
name|error
argument_list|(
literal|"Attempt to take contents of a non-pointer value."
argument_list|)
expr_stmt|;
name|type
operator|=
name|check_typedef
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|value_from_longest
argument_list|(
name|builtin_type_int
argument_list|,
operator|(
name|LONGEST
operator|)
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
case|case
name|UNOP_MEMVAL
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|3
expr_stmt|;
name|type
operator|=
name|check_typedef
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
return|return
name|value_from_longest
argument_list|(
name|builtin_type_int
argument_list|,
operator|(
name|LONGEST
operator|)
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
case|case
name|OP_VAR_VALUE
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|4
expr_stmt|;
name|type
operator|=
name|check_typedef
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|value_from_longest
argument_list|(
name|builtin_type_int
argument_list|,
operator|(
name|LONGEST
operator|)
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
default|default:
name|val
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|EVAL_AVOID_SIDE_EFFECTS
argument_list|)
expr_stmt|;
return|return
name|value_from_longest
argument_list|(
name|builtin_type_int
argument_list|,
operator|(
name|LONGEST
operator|)
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Parse a type expression in the string [P..P+LENGTH). */
end_comment

begin_function
name|struct
name|type
modifier|*
name|parse_and_eval_type
parameter_list|(
name|p
parameter_list|,
name|length
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|length
decl_stmt|;
block|{
name|char
modifier|*
name|tmp
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|length
operator|+
literal|4
argument_list|)
decl_stmt|;
name|struct
name|expression
modifier|*
name|expr
decl_stmt|;
name|tmp
index|[
literal|0
index|]
operator|=
literal|'('
expr_stmt|;
name|memcpy
argument_list|(
name|tmp
operator|+
literal|1
argument_list|,
name|p
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|tmp
index|[
name|length
operator|+
literal|1
index|]
operator|=
literal|')'
expr_stmt|;
name|tmp
index|[
name|length
operator|+
literal|2
index|]
operator|=
literal|'0'
expr_stmt|;
name|tmp
index|[
name|length
operator|+
literal|3
index|]
operator|=
literal|'\0'
expr_stmt|;
name|expr
operator|=
name|parse_expression
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
operator|->
name|elts
index|[
literal|0
index|]
operator|.
name|opcode
operator|!=
name|UNOP_CAST
condition|)
name|error
argument_list|(
literal|"Internal error in eval_type."
argument_list|)
expr_stmt|;
return|return
name|expr
operator|->
name|elts
index|[
literal|1
index|]
operator|.
name|type
return|;
block|}
end_function

begin_function
name|int
name|calc_f77_array_dims
parameter_list|(
name|array_type
parameter_list|)
name|struct
name|type
modifier|*
name|array_type
decl_stmt|;
block|{
name|int
name|ndimen
init|=
literal|1
decl_stmt|;
name|struct
name|type
modifier|*
name|tmp_type
decl_stmt|;
if|if
condition|(
operator|(
name|TYPE_CODE
argument_list|(
name|array_type
argument_list|)
operator|!=
name|TYPE_CODE_ARRAY
operator|)
condition|)
name|error
argument_list|(
literal|"Can't get dimensions for a non-array type"
argument_list|)
expr_stmt|;
name|tmp_type
operator|=
name|array_type
expr_stmt|;
while|while
condition|(
operator|(
name|tmp_type
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|tmp_type
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|tmp_type
argument_list|)
operator|==
name|TYPE_CODE_ARRAY
condition|)
operator|++
name|ndimen
expr_stmt|;
block|}
return|return
name|ndimen
return|;
block|}
end_function

end_unit

