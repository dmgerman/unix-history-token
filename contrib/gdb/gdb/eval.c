begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Evaluate expressions for GDB.     Copyright 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994,    1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003 Free Software    Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_comment
comment|/* For CAST_IS_CONVERSION */
end_comment

begin_include
include|#
directive|include
file|"f-lang.h"
end_include

begin_comment
comment|/* for array bound stuff */
end_comment

begin_include
include|#
directive|include
file|"cp-abi.h"
end_include

begin_include
include|#
directive|include
file|"infcall.h"
end_include

begin_include
include|#
directive|include
file|"objc-lang.h"
end_include

begin_include
include|#
directive|include
file|"block.h"
end_include

begin_include
include|#
directive|include
file|"parser-defs.h"
end_include

begin_comment
comment|/* Defined in symtab.c */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|hp_som_som_object_present
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is defined in valops.c */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|overload_resolution
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* JYG: lookup rtti type of STRUCTOP_PTR when this is set to continue    on with successful lookup for member/method of the rtti type. */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|objectprint
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Prototypes for local functions. */
end_comment

begin_function_decl
specifier|static
name|struct
name|value
modifier|*
name|evaluate_subexp_for_sizeof
parameter_list|(
name|struct
name|expression
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|value
modifier|*
name|evaluate_subexp_for_address
parameter_list|(
name|struct
name|expression
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|enum
name|noside
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|value
modifier|*
name|evaluate_subexp
parameter_list|(
name|struct
name|type
modifier|*
parameter_list|,
name|struct
name|expression
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|enum
name|noside
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|get_label
parameter_list|(
name|struct
name|expression
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|value
modifier|*
name|evaluate_struct_tuple
parameter_list|(
name|struct
name|value
modifier|*
parameter_list|,
name|struct
name|expression
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|enum
name|noside
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|LONGEST
name|init_array_element
parameter_list|(
name|struct
name|value
modifier|*
parameter_list|,
name|struct
name|value
modifier|*
parameter_list|,
name|struct
name|expression
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|enum
name|noside
parameter_list|,
name|LONGEST
parameter_list|,
name|LONGEST
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|struct
name|value
modifier|*
name|evaluate_subexp
parameter_list|(
name|struct
name|type
modifier|*
name|expect_type
parameter_list|,
name|struct
name|expression
modifier|*
name|exp
parameter_list|,
name|int
modifier|*
name|pos
parameter_list|,
name|enum
name|noside
name|noside
parameter_list|)
block|{
return|return
call|(
modifier|*
name|exp
operator|->
name|language_defn
operator|->
name|la_exp_desc
operator|->
name|evaluate_exp
call|)
argument_list|(
name|expect_type
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Parse the string EXP as a C expression, evaluate it,    and return the result as a number.  */
end_comment

begin_function
name|CORE_ADDR
name|parse_and_eval_address
parameter_list|(
name|char
modifier|*
name|exp
parameter_list|)
block|{
name|struct
name|expression
modifier|*
name|expr
init|=
name|parse_expression
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
init|=
name|make_cleanup
argument_list|(
name|free_current_contents
argument_list|,
operator|&
name|expr
argument_list|)
decl_stmt|;
name|addr
operator|=
name|value_as_address
argument_list|(
name|evaluate_expression
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
name|addr
return|;
block|}
end_function

begin_comment
comment|/* Like parse_and_eval_address but takes a pointer to a char * variable    and advanced that variable across the characters parsed.  */
end_comment

begin_function
name|CORE_ADDR
name|parse_and_eval_address_1
parameter_list|(
name|char
modifier|*
modifier|*
name|expptr
parameter_list|)
block|{
name|struct
name|expression
modifier|*
name|expr
init|=
name|parse_exp_1
argument_list|(
name|expptr
argument_list|,
operator|(
expr|struct
name|block
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
init|=
name|make_cleanup
argument_list|(
name|free_current_contents
argument_list|,
operator|&
name|expr
argument_list|)
decl_stmt|;
name|addr
operator|=
name|value_as_address
argument_list|(
name|evaluate_expression
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
name|addr
return|;
block|}
end_function

begin_comment
comment|/* Like parse_and_eval_address, but treats the value of the expression    as an integer, not an address, returns a LONGEST, not a CORE_ADDR */
end_comment

begin_function
name|LONGEST
name|parse_and_eval_long
parameter_list|(
name|char
modifier|*
name|exp
parameter_list|)
block|{
name|struct
name|expression
modifier|*
name|expr
init|=
name|parse_expression
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|LONGEST
name|retval
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
init|=
name|make_cleanup
argument_list|(
name|free_current_contents
argument_list|,
operator|&
name|expr
argument_list|)
decl_stmt|;
name|retval
operator|=
name|value_as_long
argument_list|(
name|evaluate_expression
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|value
modifier|*
name|parse_and_eval
parameter_list|(
name|char
modifier|*
name|exp
parameter_list|)
block|{
name|struct
name|expression
modifier|*
name|expr
init|=
name|parse_expression
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|struct
name|value
modifier|*
name|val
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
init|=
name|make_cleanup
argument_list|(
name|free_current_contents
argument_list|,
operator|&
name|expr
argument_list|)
decl_stmt|;
name|val
operator|=
name|evaluate_expression
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Parse up to a comma (or to a closeparen)    in the string EXPP as an expression, evaluate it, and return the value.    EXPP is advanced to point to the comma.  */
end_comment

begin_function
name|struct
name|value
modifier|*
name|parse_to_comma_and_eval
parameter_list|(
name|char
modifier|*
modifier|*
name|expp
parameter_list|)
block|{
name|struct
name|expression
modifier|*
name|expr
init|=
name|parse_exp_1
argument_list|(
name|expp
argument_list|,
operator|(
expr|struct
name|block
operator|*
operator|)
literal|0
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|struct
name|value
modifier|*
name|val
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
init|=
name|make_cleanup
argument_list|(
name|free_current_contents
argument_list|,
operator|&
name|expr
argument_list|)
decl_stmt|;
name|val
operator|=
name|evaluate_expression
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Evaluate an expression in internal prefix form    such as is constructed by parse.y.     See expression.h for info on the format of an expression.  */
end_comment

begin_function
name|struct
name|value
modifier|*
name|evaluate_expression
parameter_list|(
name|struct
name|expression
modifier|*
name|exp
parameter_list|)
block|{
name|int
name|pc
init|=
literal|0
decl_stmt|;
return|return
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
operator|&
name|pc
argument_list|,
name|EVAL_NORMAL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Evaluate an expression, avoiding all memory references    and getting a value whose type alone is correct.  */
end_comment

begin_function
name|struct
name|value
modifier|*
name|evaluate_type
parameter_list|(
name|struct
name|expression
modifier|*
name|exp
parameter_list|)
block|{
name|int
name|pc
init|=
literal|0
decl_stmt|;
return|return
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
operator|&
name|pc
argument_list|,
name|EVAL_AVOID_SIDE_EFFECTS
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* If the next expression is an OP_LABELED, skips past it,    returning the label.  Otherwise, does nothing and returns NULL. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|get_label
parameter_list|(
name|struct
name|expression
modifier|*
name|exp
parameter_list|,
name|int
modifier|*
name|pos
parameter_list|)
block|{
if|if
condition|(
name|exp
operator|->
name|elts
index|[
operator|*
name|pos
index|]
operator|.
name|opcode
operator|==
name|OP_LABELED
condition|)
block|{
name|int
name|pc
init|=
operator|(
operator|*
name|pos
operator|)
operator|++
decl_stmt|;
name|char
modifier|*
name|name
init|=
operator|&
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|string
decl_stmt|;
name|int
name|tem
init|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|)
decl_stmt|;
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|3
operator|+
name|BYTES_TO_EXP_ELEM
argument_list|(
name|tem
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|name
return|;
block|}
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* This function evaluates tuples (in (the deleted) Chill) or    brace-initializers (in C/C++) for structure types.  */
end_comment

begin_function
specifier|static
name|struct
name|value
modifier|*
name|evaluate_struct_tuple
parameter_list|(
name|struct
name|value
modifier|*
name|struct_val
parameter_list|,
name|struct
name|expression
modifier|*
name|exp
parameter_list|,
name|int
modifier|*
name|pos
parameter_list|,
name|enum
name|noside
name|noside
parameter_list|,
name|int
name|nargs
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|struct_type
init|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|struct_val
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|type
modifier|*
name|substruct_type
init|=
name|struct_type
decl_stmt|;
name|struct
name|type
modifier|*
name|field_type
decl_stmt|;
name|int
name|fieldno
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|variantno
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|subfieldno
init|=
operator|-
literal|1
decl_stmt|;
while|while
condition|(
operator|--
name|nargs
operator|>=
literal|0
condition|)
block|{
name|int
name|pc
init|=
operator|*
name|pos
decl_stmt|;
name|struct
name|value
modifier|*
name|val
init|=
name|NULL
decl_stmt|;
name|int
name|nlabels
init|=
literal|0
decl_stmt|;
name|int
name|bitpos
decl_stmt|,
name|bitsize
decl_stmt|;
name|char
modifier|*
name|addr
decl_stmt|;
comment|/* Skip past the labels, and count them. */
while|while
condition|(
name|get_label
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|)
operator|!=
name|NULL
condition|)
name|nlabels
operator|++
expr_stmt|;
do|do
block|{
name|char
modifier|*
name|label
init|=
name|get_label
argument_list|(
name|exp
argument_list|,
operator|&
name|pc
argument_list|)
decl_stmt|;
if|if
condition|(
name|label
condition|)
block|{
for|for
control|(
name|fieldno
operator|=
literal|0
init|;
name|fieldno
operator|<
name|TYPE_NFIELDS
argument_list|(
name|struct_type
argument_list|)
condition|;
name|fieldno
operator|++
control|)
block|{
name|char
modifier|*
name|field_name
init|=
name|TYPE_FIELD_NAME
argument_list|(
name|struct_type
argument_list|,
name|fieldno
argument_list|)
decl_stmt|;
if|if
condition|(
name|field_name
operator|!=
name|NULL
operator|&&
name|DEPRECATED_STREQ
argument_list|(
name|field_name
argument_list|,
name|label
argument_list|)
condition|)
block|{
name|variantno
operator|=
operator|-
literal|1
expr_stmt|;
name|subfieldno
operator|=
name|fieldno
expr_stmt|;
name|substruct_type
operator|=
name|struct_type
expr_stmt|;
goto|goto
name|found
goto|;
block|}
block|}
for|for
control|(
name|fieldno
operator|=
literal|0
init|;
name|fieldno
operator|<
name|TYPE_NFIELDS
argument_list|(
name|struct_type
argument_list|)
condition|;
name|fieldno
operator|++
control|)
block|{
name|char
modifier|*
name|field_name
init|=
name|TYPE_FIELD_NAME
argument_list|(
name|struct_type
argument_list|,
name|fieldno
argument_list|)
decl_stmt|;
name|field_type
operator|=
name|TYPE_FIELD_TYPE
argument_list|(
name|struct_type
argument_list|,
name|fieldno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|field_name
operator|==
literal|0
operator|||
operator|*
name|field_name
operator|==
literal|'\0'
operator|)
operator|&&
name|TYPE_CODE
argument_list|(
name|field_type
argument_list|)
operator|==
name|TYPE_CODE_UNION
condition|)
block|{
name|variantno
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|variantno
operator|<
name|TYPE_NFIELDS
argument_list|(
name|field_type
argument_list|)
condition|;
name|variantno
operator|++
control|)
block|{
name|substruct_type
operator|=
name|TYPE_FIELD_TYPE
argument_list|(
name|field_type
argument_list|,
name|variantno
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|substruct_type
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
condition|)
block|{
for|for
control|(
name|subfieldno
operator|=
literal|0
init|;
name|subfieldno
operator|<
name|TYPE_NFIELDS
argument_list|(
name|substruct_type
argument_list|)
condition|;
name|subfieldno
operator|++
control|)
block|{
if|if
condition|(
name|DEPRECATED_STREQ
argument_list|(
name|TYPE_FIELD_NAME
argument_list|(
name|substruct_type
argument_list|,
name|subfieldno
argument_list|)
argument_list|,
name|label
argument_list|)
condition|)
block|{
goto|goto
name|found
goto|;
block|}
block|}
block|}
block|}
block|}
block|}
name|error
argument_list|(
literal|"there is no field named %s"
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|found
label|:
empty_stmt|;
block|}
else|else
block|{
comment|/* Unlabelled tuple element - go to next field. */
if|if
condition|(
name|variantno
operator|>=
literal|0
condition|)
block|{
name|subfieldno
operator|++
expr_stmt|;
if|if
condition|(
name|subfieldno
operator|>=
name|TYPE_NFIELDS
argument_list|(
name|substruct_type
argument_list|)
condition|)
block|{
name|variantno
operator|=
operator|-
literal|1
expr_stmt|;
name|substruct_type
operator|=
name|struct_type
expr_stmt|;
block|}
block|}
if|if
condition|(
name|variantno
operator|<
literal|0
condition|)
block|{
name|fieldno
operator|++
expr_stmt|;
name|subfieldno
operator|=
name|fieldno
expr_stmt|;
if|if
condition|(
name|fieldno
operator|>=
name|TYPE_NFIELDS
argument_list|(
name|struct_type
argument_list|)
condition|)
name|error
argument_list|(
literal|"too many initializers"
argument_list|)
expr_stmt|;
name|field_type
operator|=
name|TYPE_FIELD_TYPE
argument_list|(
name|struct_type
argument_list|,
name|fieldno
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|field_type
argument_list|)
operator|==
name|TYPE_CODE_UNION
operator|&&
name|TYPE_FIELD_NAME
argument_list|(
name|struct_type
argument_list|,
name|fieldno
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'0'
condition|)
name|error
argument_list|(
literal|"don't know which variant you want to set"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Here, struct_type is the type of the inner struct, 	     while substruct_type is the type of the inner struct. 	     These are the same for normal structures, but a variant struct 	     contains anonymous union fields that contain substruct fields. 	     The value fieldno is the index of the top-level (normal or 	     anonymous union) field in struct_field, while the value 	     subfieldno is the index of the actual real (named inner) field 	     in substruct_type. */
name|field_type
operator|=
name|TYPE_FIELD_TYPE
argument_list|(
name|substruct_type
argument_list|,
name|subfieldno
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
name|val
operator|=
name|evaluate_subexp
argument_list|(
name|field_type
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
comment|/* Now actually set the field in struct_val. */
comment|/* Assign val to field fieldno. */
if|if
condition|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
operator|!=
name|field_type
condition|)
name|val
operator|=
name|value_cast
argument_list|(
name|field_type
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|bitsize
operator|=
name|TYPE_FIELD_BITSIZE
argument_list|(
name|substruct_type
argument_list|,
name|subfieldno
argument_list|)
expr_stmt|;
name|bitpos
operator|=
name|TYPE_FIELD_BITPOS
argument_list|(
name|struct_type
argument_list|,
name|fieldno
argument_list|)
expr_stmt|;
if|if
condition|(
name|variantno
operator|>=
literal|0
condition|)
name|bitpos
operator|+=
name|TYPE_FIELD_BITPOS
argument_list|(
name|substruct_type
argument_list|,
name|subfieldno
argument_list|)
expr_stmt|;
name|addr
operator|=
name|VALUE_CONTENTS
argument_list|(
name|struct_val
argument_list|)
operator|+
name|bitpos
operator|/
literal|8
expr_stmt|;
if|if
condition|(
name|bitsize
condition|)
name|modify_field
argument_list|(
name|addr
argument_list|,
name|value_as_long
argument_list|(
name|val
argument_list|)
argument_list|,
name|bitpos
operator|%
literal|8
argument_list|,
name|bitsize
argument_list|)
expr_stmt|;
else|else
name|memcpy
argument_list|(
name|addr
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|val
argument_list|)
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|nlabels
operator|>
literal|0
condition|)
do|;
block|}
return|return
name|struct_val
return|;
block|}
end_function

begin_comment
comment|/* Recursive helper function for setting elements of array tuples for    (the deleted) Chill.  The target is ARRAY (which has bounds    LOW_BOUND to HIGH_BOUND); the element value is ELEMENT; EXP, POS    and NOSIDE are as usual.  Evaluates index expresions and sets the    specified element(s) of ARRAY to ELEMENT.  Returns last index    value.  */
end_comment

begin_function
specifier|static
name|LONGEST
name|init_array_element
parameter_list|(
name|struct
name|value
modifier|*
name|array
parameter_list|,
name|struct
name|value
modifier|*
name|element
parameter_list|,
name|struct
name|expression
modifier|*
name|exp
parameter_list|,
name|int
modifier|*
name|pos
parameter_list|,
name|enum
name|noside
name|noside
parameter_list|,
name|LONGEST
name|low_bound
parameter_list|,
name|LONGEST
name|high_bound
parameter_list|)
block|{
name|LONGEST
name|index
decl_stmt|;
name|int
name|element_size
init|=
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|element
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|exp
operator|->
name|elts
index|[
operator|*
name|pos
index|]
operator|.
name|opcode
operator|==
name|BINOP_COMMA
condition|)
block|{
operator|(
operator|*
name|pos
operator|)
operator|++
expr_stmt|;
name|init_array_element
argument_list|(
name|array
argument_list|,
name|element
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|,
name|low_bound
argument_list|,
name|high_bound
argument_list|)
expr_stmt|;
return|return
name|init_array_element
argument_list|(
name|array
argument_list|,
name|element
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|,
name|low_bound
argument_list|,
name|high_bound
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|exp
operator|->
name|elts
index|[
operator|*
name|pos
index|]
operator|.
name|opcode
operator|==
name|BINOP_RANGE
condition|)
block|{
name|LONGEST
name|low
decl_stmt|,
name|high
decl_stmt|;
operator|(
operator|*
name|pos
operator|)
operator|++
expr_stmt|;
name|low
operator|=
name|value_as_long
argument_list|(
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
argument_list|)
expr_stmt|;
name|high
operator|=
name|value_as_long
argument_list|(
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|low
operator|<
name|low_bound
operator|||
name|high
operator|>
name|high_bound
condition|)
name|error
argument_list|(
literal|"tuple range index out of range"
argument_list|)
expr_stmt|;
for|for
control|(
name|index
operator|=
name|low
init|;
name|index
operator|<=
name|high
condition|;
name|index
operator|++
control|)
block|{
name|memcpy
argument_list|(
name|VALUE_CONTENTS_RAW
argument_list|(
name|array
argument_list|)
operator|+
operator|(
name|index
operator|-
name|low_bound
operator|)
operator|*
name|element_size
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|element
argument_list|)
argument_list|,
name|element_size
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|index
operator|=
name|value_as_long
argument_list|(
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|<
name|low_bound
operator|||
name|index
operator|>
name|high_bound
condition|)
name|error
argument_list|(
literal|"tuple index out of range"
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|VALUE_CONTENTS_RAW
argument_list|(
name|array
argument_list|)
operator|+
operator|(
name|index
operator|-
name|low_bound
operator|)
operator|*
name|element_size
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|element
argument_list|)
argument_list|,
name|element_size
argument_list|)
expr_stmt|;
block|}
return|return
name|index
return|;
block|}
end_function

begin_function
name|struct
name|value
modifier|*
name|evaluate_subexp_standard
parameter_list|(
name|struct
name|type
modifier|*
name|expect_type
parameter_list|,
name|struct
name|expression
modifier|*
name|exp
parameter_list|,
name|int
modifier|*
name|pos
parameter_list|,
name|enum
name|noside
name|noside
parameter_list|)
block|{
name|enum
name|exp_opcode
name|op
decl_stmt|;
name|int
name|tem
decl_stmt|,
name|tem2
decl_stmt|,
name|tem3
decl_stmt|;
name|int
name|pc
decl_stmt|,
name|pc2
init|=
literal|0
decl_stmt|,
name|oldpos
decl_stmt|;
name|struct
name|value
modifier|*
name|arg1
init|=
name|NULL
decl_stmt|;
name|struct
name|value
modifier|*
name|arg2
init|=
name|NULL
decl_stmt|;
name|struct
name|value
modifier|*
name|arg3
decl_stmt|;
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|int
name|nargs
decl_stmt|;
name|struct
name|value
modifier|*
modifier|*
name|argvec
decl_stmt|;
name|int
name|upper
decl_stmt|,
name|lower
decl_stmt|,
name|retcode
decl_stmt|;
name|int
name|code
decl_stmt|;
name|int
name|ix
decl_stmt|;
name|long
name|mem_offset
decl_stmt|;
name|struct
name|type
modifier|*
modifier|*
name|arg_types
decl_stmt|;
name|int
name|save_pos1
decl_stmt|;
name|pc
operator|=
operator|(
operator|*
name|pos
operator|)
operator|++
expr_stmt|;
name|op
operator|=
name|exp
operator|->
name|elts
index|[
name|pc
index|]
operator|.
name|opcode
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|OP_SCOPE
case|:
name|tem
operator|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|4
operator|+
name|BYTES_TO_EXP_ELEM
argument_list|(
name|tem
operator|+
literal|1
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|value_aggregate_elt
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|type
argument_list|,
operator|&
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|3
index|]
operator|.
name|string
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg1
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"There is no field named %s"
argument_list|,
operator|&
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|3
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
return|return
name|arg1
return|;
case|case
name|OP_LONG
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|3
expr_stmt|;
return|return
name|value_from_longest
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|type
argument_list|,
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|longconst
argument_list|)
return|;
case|case
name|OP_DOUBLE
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|3
expr_stmt|;
return|return
name|value_from_double
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|type
argument_list|,
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|doubleconst
argument_list|)
return|;
case|case
name|OP_VAR_VALUE
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|3
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
comment|/* JYG: We used to just return value_zero of the symbol type 	 if we're asked to avoid side effects.  Otherwise we return 	 value_of_variable (...).  However I'm not sure if 	 value_of_variable () has any side effect. 	 We need a full value object returned here for whatis_exp () 	 to call evaluate_type () and then pass the full value to 	 value_rtti_target_type () if we are dealing with a pointer 	 or reference to a base class and print object is on. */
return|return
name|value_of_variable
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|symbol
argument_list|,
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|block
argument_list|)
return|;
case|case
name|OP_LAST
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|2
expr_stmt|;
return|return
name|access_value_history
argument_list|(
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|)
argument_list|)
return|;
case|case
name|OP_REGISTER
case|:
block|{
name|int
name|regno
init|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|)
decl_stmt|;
name|struct
name|value
modifier|*
name|val
init|=
name|value_of_register
argument_list|(
name|regno
argument_list|,
name|get_selected_frame
argument_list|()
argument_list|)
decl_stmt|;
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Value of register %s not available."
argument_list|,
name|frame_map_regnum_to_name
argument_list|(
name|get_selected_frame
argument_list|()
argument_list|,
name|regno
argument_list|)
argument_list|)
expr_stmt|;
else|else
return|return
name|val
return|;
block|}
case|case
name|OP_BOOL
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|2
expr_stmt|;
return|return
name|value_from_longest
argument_list|(
name|LA_BOOL_TYPE
argument_list|,
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|)
return|;
case|case
name|OP_INTERNALVAR
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|2
expr_stmt|;
return|return
name|value_of_internalvar
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|internalvar
argument_list|)
return|;
case|case
name|OP_STRING
case|:
name|tem
operator|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|3
operator|+
name|BYTES_TO_EXP_ELEM
argument_list|(
name|tem
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
return|return
name|value_string
argument_list|(
operator|&
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|string
argument_list|,
name|tem
argument_list|)
return|;
case|case
name|OP_OBJC_NSSTRING
case|:
comment|/* Objective C Foundation Class NSString constant.  */
name|tem
operator|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|3
operator|+
name|BYTES_TO_EXP_ELEM
argument_list|(
name|tem
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
block|{
goto|goto
name|nosideret
goto|;
block|}
return|return
operator|(
expr|struct
name|value
operator|*
operator|)
name|value_nsstring
argument_list|(
operator|&
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|string
argument_list|,
name|tem
operator|+
literal|1
argument_list|)
return|;
case|case
name|OP_BITSTRING
case|:
name|tem
operator|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|3
operator|+
name|BYTES_TO_EXP_ELEM
argument_list|(
operator|(
name|tem
operator|+
name|HOST_CHAR_BIT
operator|-
literal|1
operator|)
operator|/
name|HOST_CHAR_BIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
return|return
name|value_bitstring
argument_list|(
operator|&
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|string
argument_list|,
name|tem
argument_list|)
return|;
break|break;
case|case
name|OP_ARRAY
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|3
expr_stmt|;
name|tem2
operator|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
name|tem3
operator|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
name|nargs
operator|=
name|tem3
operator|-
name|tem2
operator|+
literal|1
expr_stmt|;
name|type
operator|=
name|expect_type
condition|?
name|check_typedef
argument_list|(
name|expect_type
argument_list|)
else|:
name|NULL_TYPE
expr_stmt|;
if|if
condition|(
name|expect_type
operator|!=
name|NULL_TYPE
operator|&&
name|noside
operator|!=
name|EVAL_SKIP
operator|&&
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
condition|)
block|{
name|struct
name|value
modifier|*
name|rec
init|=
name|allocate_value
argument_list|(
name|expect_type
argument_list|)
decl_stmt|;
name|memset
argument_list|(
name|VALUE_CONTENTS_RAW
argument_list|(
name|rec
argument_list|)
argument_list|,
literal|'\0'
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|evaluate_struct_tuple
argument_list|(
name|rec
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|,
name|nargs
argument_list|)
return|;
block|}
if|if
condition|(
name|expect_type
operator|!=
name|NULL_TYPE
operator|&&
name|noside
operator|!=
name|EVAL_SKIP
operator|&&
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_ARRAY
condition|)
block|{
name|struct
name|type
modifier|*
name|range_type
init|=
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|struct
name|type
modifier|*
name|element_type
init|=
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|struct
name|value
modifier|*
name|array
init|=
name|allocate_value
argument_list|(
name|expect_type
argument_list|)
decl_stmt|;
name|int
name|element_size
init|=
name|TYPE_LENGTH
argument_list|(
name|check_typedef
argument_list|(
name|element_type
argument_list|)
argument_list|)
decl_stmt|;
name|LONGEST
name|low_bound
decl_stmt|,
name|high_bound
decl_stmt|,
name|index
decl_stmt|;
if|if
condition|(
name|get_discrete_bounds
argument_list|(
name|range_type
argument_list|,
operator|&
name|low_bound
argument_list|,
operator|&
name|high_bound
argument_list|)
operator|<
literal|0
condition|)
block|{
name|low_bound
operator|=
literal|0
expr_stmt|;
name|high_bound
operator|=
operator|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|/
name|element_size
operator|)
operator|-
literal|1
expr_stmt|;
block|}
name|index
operator|=
name|low_bound
expr_stmt|;
name|memset
argument_list|(
name|VALUE_CONTENTS_RAW
argument_list|(
name|array
argument_list|)
argument_list|,
literal|0
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|expect_type
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|tem
operator|=
name|nargs
init|;
operator|--
name|nargs
operator|>=
literal|0
condition|;
control|)
block|{
name|struct
name|value
modifier|*
name|element
decl_stmt|;
name|int
name|index_pc
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|exp
operator|->
name|elts
index|[
operator|*
name|pos
index|]
operator|.
name|opcode
operator|==
name|BINOP_RANGE
condition|)
block|{
name|index_pc
operator|=
operator|++
operator|(
operator|*
name|pos
operator|)
expr_stmt|;
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|EVAL_SKIP
argument_list|)
expr_stmt|;
block|}
name|element
operator|=
name|evaluate_subexp
argument_list|(
name|element_type
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|VALUE_TYPE
argument_list|(
name|element
argument_list|)
operator|!=
name|element_type
condition|)
name|element
operator|=
name|value_cast
argument_list|(
name|element_type
argument_list|,
name|element
argument_list|)
expr_stmt|;
if|if
condition|(
name|index_pc
condition|)
block|{
name|int
name|continue_pc
init|=
operator|*
name|pos
decl_stmt|;
operator|*
name|pos
operator|=
name|index_pc
expr_stmt|;
name|index
operator|=
name|init_array_element
argument_list|(
name|array
argument_list|,
name|element
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|,
name|low_bound
argument_list|,
name|high_bound
argument_list|)
expr_stmt|;
operator|*
name|pos
operator|=
name|continue_pc
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|index
operator|>
name|high_bound
condition|)
comment|/* to avoid memory corruption */
name|error
argument_list|(
literal|"Too many array elements"
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|VALUE_CONTENTS_RAW
argument_list|(
name|array
argument_list|)
operator|+
operator|(
name|index
operator|-
name|low_bound
operator|)
operator|*
name|element_size
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|element
argument_list|)
argument_list|,
name|element_size
argument_list|)
expr_stmt|;
block|}
name|index
operator|++
expr_stmt|;
block|}
return|return
name|array
return|;
block|}
if|if
condition|(
name|expect_type
operator|!=
name|NULL_TYPE
operator|&&
name|noside
operator|!=
name|EVAL_SKIP
operator|&&
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_SET
condition|)
block|{
name|struct
name|value
modifier|*
name|set
init|=
name|allocate_value
argument_list|(
name|expect_type
argument_list|)
decl_stmt|;
name|char
modifier|*
name|valaddr
init|=
name|VALUE_CONTENTS_RAW
argument_list|(
name|set
argument_list|)
decl_stmt|;
name|struct
name|type
modifier|*
name|element_type
init|=
name|TYPE_INDEX_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|struct
name|type
modifier|*
name|check_type
init|=
name|element_type
decl_stmt|;
name|LONGEST
name|low_bound
decl_stmt|,
name|high_bound
decl_stmt|;
comment|/* get targettype of elementtype */
while|while
condition|(
name|TYPE_CODE
argument_list|(
name|check_type
argument_list|)
operator|==
name|TYPE_CODE_RANGE
operator|||
name|TYPE_CODE
argument_list|(
name|check_type
argument_list|)
operator|==
name|TYPE_CODE_TYPEDEF
condition|)
name|check_type
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|check_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|get_discrete_bounds
argument_list|(
name|element_type
argument_list|,
operator|&
name|low_bound
argument_list|,
operator|&
name|high_bound
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"(power)set type with unknown size"
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|valaddr
argument_list|,
literal|'\0'
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|tem
operator|=
literal|0
init|;
name|tem
operator|<
name|nargs
condition|;
name|tem
operator|++
control|)
block|{
name|LONGEST
name|range_low
decl_stmt|,
name|range_high
decl_stmt|;
name|struct
name|type
modifier|*
name|range_low_type
decl_stmt|,
modifier|*
name|range_high_type
decl_stmt|;
name|struct
name|value
modifier|*
name|elem_val
decl_stmt|;
if|if
condition|(
name|exp
operator|->
name|elts
index|[
operator|*
name|pos
index|]
operator|.
name|opcode
operator|==
name|BINOP_RANGE
condition|)
block|{
operator|(
operator|*
name|pos
operator|)
operator|++
expr_stmt|;
name|elem_val
operator|=
name|evaluate_subexp
argument_list|(
name|element_type
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
name|range_low_type
operator|=
name|VALUE_TYPE
argument_list|(
name|elem_val
argument_list|)
expr_stmt|;
name|range_low
operator|=
name|value_as_long
argument_list|(
name|elem_val
argument_list|)
expr_stmt|;
name|elem_val
operator|=
name|evaluate_subexp
argument_list|(
name|element_type
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
name|range_high_type
operator|=
name|VALUE_TYPE
argument_list|(
name|elem_val
argument_list|)
expr_stmt|;
name|range_high
operator|=
name|value_as_long
argument_list|(
name|elem_val
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|elem_val
operator|=
name|evaluate_subexp
argument_list|(
name|element_type
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
name|range_low_type
operator|=
name|range_high_type
operator|=
name|VALUE_TYPE
argument_list|(
name|elem_val
argument_list|)
expr_stmt|;
name|range_low
operator|=
name|range_high
operator|=
name|value_as_long
argument_list|(
name|elem_val
argument_list|)
expr_stmt|;
block|}
comment|/* check types of elements to avoid mixture of elements from 	         different types. Also check if type of element is "compatible" 	         with element type of powerset */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|range_low_type
argument_list|)
operator|==
name|TYPE_CODE_RANGE
condition|)
name|range_low_type
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|range_low_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|range_high_type
argument_list|)
operator|==
name|TYPE_CODE_RANGE
condition|)
name|range_high_type
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|range_high_type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TYPE_CODE
argument_list|(
name|range_low_type
argument_list|)
operator|!=
name|TYPE_CODE
argument_list|(
name|range_high_type
argument_list|)
operator|)
operator|||
operator|(
name|TYPE_CODE
argument_list|(
name|range_low_type
argument_list|)
operator|==
name|TYPE_CODE_ENUM
operator|&&
operator|(
name|range_low_type
operator|!=
name|range_high_type
operator|)
operator|)
condition|)
comment|/* different element modes */
name|error
argument_list|(
literal|"POWERSET tuple elements of different mode"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TYPE_CODE
argument_list|(
name|check_type
argument_list|)
operator|!=
name|TYPE_CODE
argument_list|(
name|range_low_type
argument_list|)
operator|)
operator|||
operator|(
name|TYPE_CODE
argument_list|(
name|check_type
argument_list|)
operator|==
name|TYPE_CODE_ENUM
operator|&&
name|range_low_type
operator|!=
name|check_type
operator|)
condition|)
name|error
argument_list|(
literal|"incompatible POWERSET tuple elements"
argument_list|)
expr_stmt|;
if|if
condition|(
name|range_low
operator|>
name|range_high
condition|)
block|{
name|warning
argument_list|(
literal|"empty POWERSET tuple range"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|range_low
operator|<
name|low_bound
operator|||
name|range_high
operator|>
name|high_bound
condition|)
name|error
argument_list|(
literal|"POWERSET tuple element out of range"
argument_list|)
expr_stmt|;
name|range_low
operator|-=
name|low_bound
expr_stmt|;
name|range_high
operator|-=
name|low_bound
expr_stmt|;
for|for
control|(
init|;
name|range_low
operator|<=
name|range_high
condition|;
name|range_low
operator|++
control|)
block|{
name|int
name|bit_index
init|=
operator|(
name|unsigned
operator|)
name|range_low
operator|%
name|TARGET_CHAR_BIT
decl_stmt|;
if|if
condition|(
name|BITS_BIG_ENDIAN
condition|)
name|bit_index
operator|=
name|TARGET_CHAR_BIT
operator|-
literal|1
operator|-
name|bit_index
expr_stmt|;
name|valaddr
index|[
operator|(
name|unsigned
operator|)
name|range_low
operator|/
name|TARGET_CHAR_BIT
index|]
operator||=
literal|1
operator|<<
name|bit_index
expr_stmt|;
block|}
block|}
return|return
name|set
return|;
block|}
name|argvec
operator|=
operator|(
expr|struct
name|value
operator|*
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|value
operator|*
argument_list|)
operator|*
name|nargs
argument_list|)
expr_stmt|;
for|for
control|(
name|tem
operator|=
literal|0
init|;
name|tem
operator|<
name|nargs
condition|;
name|tem
operator|++
control|)
block|{
comment|/* Ensure that array expressions are coerced into pointer objects. */
name|argvec
index|[
name|tem
index|]
operator|=
name|evaluate_subexp_with_coercion
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
return|return
name|value_array
argument_list|(
name|tem2
argument_list|,
name|tem3
argument_list|,
name|argvec
argument_list|)
return|;
case|case
name|TERNOP_SLICE
case|:
block|{
name|struct
name|value
modifier|*
name|array
init|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
decl_stmt|;
name|int
name|lowbound
init|=
name|value_as_long
argument_list|(
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|upper
init|=
name|value_as_long
argument_list|(
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
return|return
name|value_slice
argument_list|(
name|array
argument_list|,
name|lowbound
argument_list|,
name|upper
operator|-
name|lowbound
operator|+
literal|1
argument_list|)
return|;
block|}
case|case
name|TERNOP_SLICE_COUNT
case|:
block|{
name|struct
name|value
modifier|*
name|array
init|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
decl_stmt|;
name|int
name|lowbound
init|=
name|value_as_long
argument_list|(
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|length
init|=
name|value_as_long
argument_list|(
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|value_slice
argument_list|(
name|array
argument_list|,
name|lowbound
argument_list|,
name|length
argument_list|)
return|;
block|}
case|case
name|TERNOP_COND
case|:
comment|/* Skip third and second args to evaluate the first one.  */
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|value_logical_not
argument_list|(
name|arg1
argument_list|)
condition|)
block|{
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|EVAL_SKIP
argument_list|)
expr_stmt|;
return|return
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
return|;
block|}
else|else
block|{
name|arg2
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|EVAL_SKIP
argument_list|)
expr_stmt|;
return|return
name|arg2
return|;
block|}
case|case
name|OP_OBJC_SELECTOR
case|:
block|{
comment|/* Objective C @selector operator.  */
name|char
modifier|*
name|sel
init|=
operator|&
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|string
decl_stmt|;
name|int
name|len
init|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|)
decl_stmt|;
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|3
operator|+
name|BYTES_TO_EXP_ELEM
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
if|if
condition|(
name|sel
index|[
name|len
index|]
operator|!=
literal|0
condition|)
name|sel
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Make sure it's terminated.  */
return|return
name|value_from_longest
argument_list|(
name|lookup_pointer_type
argument_list|(
name|builtin_type_void
argument_list|)
argument_list|,
name|lookup_child_selector
argument_list|(
name|sel
argument_list|)
argument_list|)
return|;
block|}
case|case
name|OP_OBJC_MSGCALL
case|:
block|{
comment|/* Objective C message (method) call.  */
specifier|static
name|CORE_ADDR
name|responds_selector
init|=
literal|0
decl_stmt|;
specifier|static
name|CORE_ADDR
name|method_selector
init|=
literal|0
decl_stmt|;
name|CORE_ADDR
name|selector
init|=
literal|0
decl_stmt|;
name|int
name|using_gcc
init|=
literal|0
decl_stmt|;
name|int
name|struct_return
init|=
literal|0
decl_stmt|;
name|int
name|sub_no_side
init|=
literal|0
decl_stmt|;
specifier|static
name|struct
name|value
modifier|*
name|msg_send
init|=
name|NULL
decl_stmt|;
specifier|static
name|struct
name|value
modifier|*
name|msg_send_stret
init|=
name|NULL
decl_stmt|;
specifier|static
name|int
name|gnu_runtime
init|=
literal|0
decl_stmt|;
name|struct
name|value
modifier|*
name|target
init|=
name|NULL
decl_stmt|;
name|struct
name|value
modifier|*
name|method
init|=
name|NULL
decl_stmt|;
name|struct
name|value
modifier|*
name|called_method
init|=
name|NULL
decl_stmt|;
name|struct
name|type
modifier|*
name|selector_type
init|=
name|NULL
decl_stmt|;
name|struct
name|value
modifier|*
name|ret
init|=
name|NULL
decl_stmt|;
name|CORE_ADDR
name|addr
init|=
literal|0
decl_stmt|;
name|selector
operator|=
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|longconst
expr_stmt|;
name|nargs
operator|=
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|longconst
expr_stmt|;
name|argvec
operator|=
operator|(
expr|struct
name|value
operator|*
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|value
operator|*
argument_list|)
operator|*
operator|(
name|nargs
operator|+
literal|5
operator|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|3
expr_stmt|;
name|selector_type
operator|=
name|lookup_pointer_type
argument_list|(
name|builtin_type_void
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_AVOID_SIDE_EFFECTS
condition|)
name|sub_no_side
operator|=
name|EVAL_NORMAL
expr_stmt|;
else|else
name|sub_no_side
operator|=
name|noside
expr_stmt|;
name|target
operator|=
name|evaluate_subexp
argument_list|(
name|selector_type
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|sub_no_side
argument_list|)
expr_stmt|;
if|if
condition|(
name|value_as_long
argument_list|(
name|target
argument_list|)
operator|==
literal|0
condition|)
return|return
name|value_from_longest
argument_list|(
name|builtin_type_long
argument_list|,
literal|0
argument_list|)
return|;
if|if
condition|(
name|lookup_minimal_symbol
argument_list|(
literal|"objc_msg_lookup"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
name|gnu_runtime
operator|=
literal|1
expr_stmt|;
comment|/* Find the method dispatch (Apple runtime) or method lookup 	   (GNU runtime) function for Objective-C.  These will be used 	   to lookup the symbol information for the method.  If we 	   can't find any symbol information, then we'll use these to 	   call the method, otherwise we can call the method 	   directly. The msg_send_stret function is used in the special 	   case of a method that returns a structure (Apple runtime  	   only).  */
if|if
condition|(
name|gnu_runtime
condition|)
block|{
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|type
operator|=
name|lookup_pointer_type
argument_list|(
name|builtin_type_void
argument_list|)
expr_stmt|;
name|type
operator|=
name|lookup_function_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|type
operator|=
name|lookup_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|type
operator|=
name|lookup_function_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|type
operator|=
name|lookup_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|msg_send
operator|=
name|find_function_in_inferior
argument_list|(
literal|"objc_msg_lookup"
argument_list|)
expr_stmt|;
name|msg_send_stret
operator|=
name|find_function_in_inferior
argument_list|(
literal|"objc_msg_lookup"
argument_list|)
expr_stmt|;
name|msg_send
operator|=
name|value_from_pointer
argument_list|(
name|type
argument_list|,
name|value_as_address
argument_list|(
name|msg_send
argument_list|)
argument_list|)
expr_stmt|;
name|msg_send_stret
operator|=
name|value_from_pointer
argument_list|(
name|type
argument_list|,
name|value_as_address
argument_list|(
name|msg_send_stret
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|msg_send
operator|=
name|find_function_in_inferior
argument_list|(
literal|"objc_msgSend"
argument_list|)
expr_stmt|;
comment|/* Special dispatcher for methods returning structs */
name|msg_send_stret
operator|=
name|find_function_in_inferior
argument_list|(
literal|"objc_msgSend_stret"
argument_list|)
expr_stmt|;
block|}
comment|/* Verify the target object responds to this method. The 	   standard top-level 'Object' class uses a different name for 	   the verification method than the non-standard, but more 	   often used, 'NSObject' class. Make sure we check for both. */
name|responds_selector
operator|=
name|lookup_child_selector
argument_list|(
literal|"respondsToSelector:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|responds_selector
operator|==
literal|0
condition|)
name|responds_selector
operator|=
name|lookup_child_selector
argument_list|(
literal|"respondsTo:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|responds_selector
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"no 'respondsTo:' or 'respondsToSelector:' method"
argument_list|)
expr_stmt|;
name|method_selector
operator|=
name|lookup_child_selector
argument_list|(
literal|"methodForSelector:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|method_selector
operator|==
literal|0
condition|)
name|method_selector
operator|=
name|lookup_child_selector
argument_list|(
literal|"methodFor:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|method_selector
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"no 'methodFor:' or 'methodForSelector:' method"
argument_list|)
expr_stmt|;
comment|/* Call the verification method, to make sure that the target 	 class implements the desired method. */
name|argvec
index|[
literal|0
index|]
operator|=
name|msg_send
expr_stmt|;
name|argvec
index|[
literal|1
index|]
operator|=
name|target
expr_stmt|;
name|argvec
index|[
literal|2
index|]
operator|=
name|value_from_longest
argument_list|(
name|builtin_type_long
argument_list|,
name|responds_selector
argument_list|)
expr_stmt|;
name|argvec
index|[
literal|3
index|]
operator|=
name|value_from_longest
argument_list|(
name|builtin_type_long
argument_list|,
name|selector
argument_list|)
expr_stmt|;
name|argvec
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|call_function_by_hand
argument_list|(
name|argvec
index|[
literal|0
index|]
argument_list|,
literal|3
argument_list|,
name|argvec
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|gnu_runtime
condition|)
block|{
comment|/* Function objc_msg_lookup returns a pointer.  */
name|argvec
index|[
literal|0
index|]
operator|=
name|ret
expr_stmt|;
name|ret
operator|=
name|call_function_by_hand
argument_list|(
name|argvec
index|[
literal|0
index|]
argument_list|,
literal|3
argument_list|,
name|argvec
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|value_as_long
argument_list|(
name|ret
argument_list|)
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Target does not respond to this message selector."
argument_list|)
expr_stmt|;
comment|/* Call "methodForSelector:" method, to get the address of a 	   function method that implements this selector for this 	   class.  If we can find a symbol at that address, then we 	   know the return type, parameter types etc.  (that's a good 	   thing). */
name|argvec
index|[
literal|0
index|]
operator|=
name|msg_send
expr_stmt|;
name|argvec
index|[
literal|1
index|]
operator|=
name|target
expr_stmt|;
name|argvec
index|[
literal|2
index|]
operator|=
name|value_from_longest
argument_list|(
name|builtin_type_long
argument_list|,
name|method_selector
argument_list|)
expr_stmt|;
name|argvec
index|[
literal|3
index|]
operator|=
name|value_from_longest
argument_list|(
name|builtin_type_long
argument_list|,
name|selector
argument_list|)
expr_stmt|;
name|argvec
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|call_function_by_hand
argument_list|(
name|argvec
index|[
literal|0
index|]
argument_list|,
literal|3
argument_list|,
name|argvec
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|gnu_runtime
condition|)
block|{
name|argvec
index|[
literal|0
index|]
operator|=
name|ret
expr_stmt|;
name|ret
operator|=
name|call_function_by_hand
argument_list|(
name|argvec
index|[
literal|0
index|]
argument_list|,
literal|3
argument_list|,
name|argvec
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* ret should now be the selector.  */
name|addr
operator|=
name|value_as_long
argument_list|(
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
condition|)
block|{
name|struct
name|symbol
modifier|*
name|sym
init|=
name|NULL
decl_stmt|;
comment|/* Is it a high_level symbol?  */
name|sym
operator|=
name|find_pc_function
argument_list|(
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|!=
name|NULL
condition|)
name|method
operator|=
name|value_of_variable
argument_list|(
name|sym
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* If we found a method with symbol information, check to see            if it returns a struct.  Otherwise assume it doesn't.  */
if|if
condition|(
name|method
condition|)
block|{
name|struct
name|block
modifier|*
name|b
decl_stmt|;
name|CORE_ADDR
name|funaddr
decl_stmt|;
name|struct
name|type
modifier|*
name|value_type
decl_stmt|;
name|funaddr
operator|=
name|find_function_addr
argument_list|(
name|method
argument_list|,
operator|&
name|value_type
argument_list|)
expr_stmt|;
name|b
operator|=
name|block_for_pc
argument_list|(
name|funaddr
argument_list|)
expr_stmt|;
comment|/* If compiled without -g, assume GCC 2.  */
name|using_gcc
operator|=
operator|(
name|b
operator|==
name|NULL
condition|?
literal|2
else|:
name|BLOCK_GCC_COMPILED
argument_list|(
name|b
argument_list|)
operator|)
expr_stmt|;
name|CHECK_TYPEDEF
argument_list|(
name|value_type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|value_type
operator|==
name|NULL
operator|)
operator|||
operator|(
name|TYPE_CODE
argument_list|(
name|value_type
argument_list|)
operator|==
name|TYPE_CODE_ERROR
operator|)
condition|)
block|{
if|if
condition|(
name|expect_type
operator|!=
name|NULL
condition|)
name|value_type
operator|=
name|expect_type
expr_stmt|;
block|}
name|struct_return
operator|=
name|using_struct_return
argument_list|(
name|value_type
argument_list|,
name|using_gcc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|expect_type
operator|!=
name|NULL
condition|)
block|{
name|struct_return
operator|=
name|using_struct_return
argument_list|(
name|check_typedef
argument_list|(
name|expect_type
argument_list|)
argument_list|,
name|using_gcc
argument_list|)
expr_stmt|;
block|}
comment|/* Found a function symbol.  Now we will substitute its 	   value in place of the message dispatcher (obj_msgSend), 	   so that we call the method directly instead of thru 	   the dispatcher.  The main reason for doing this is that 	   we can now evaluate the return value and parameter values 	   according to their known data types, in case we need to 	   do things like promotion, dereferencing, special handling 	   of structs and doubles, etc. 	   	   We want to use the type signature of 'method', but still 	   jump to objc_msgSend() or objc_msgSend_stret() to better 	   mimic the behavior of the runtime.  */
if|if
condition|(
name|method
condition|)
block|{
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|method
argument_list|)
argument_list|)
operator|!=
name|TYPE_CODE_FUNC
condition|)
name|error
argument_list|(
literal|"method address has symbol information with non-function type; skipping"
argument_list|)
expr_stmt|;
if|if
condition|(
name|struct_return
condition|)
name|VALUE_ADDRESS
argument_list|(
name|method
argument_list|)
operator|=
name|value_as_address
argument_list|(
name|msg_send_stret
argument_list|)
expr_stmt|;
else|else
name|VALUE_ADDRESS
argument_list|(
name|method
argument_list|)
operator|=
name|value_as_address
argument_list|(
name|msg_send
argument_list|)
expr_stmt|;
name|called_method
operator|=
name|method
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|struct_return
condition|)
name|called_method
operator|=
name|msg_send_stret
expr_stmt|;
else|else
name|called_method
operator|=
name|msg_send
expr_stmt|;
block|}
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
if|if
condition|(
name|noside
operator|==
name|EVAL_AVOID_SIDE_EFFECTS
condition|)
block|{
comment|/* If the return type doesn't look like a function type, 	       call an error.  This can happen if somebody tries to 	       turn a variable into a function call. This is here 	       because people often want to call, eg, strcmp, which 	       gdb doesn't know is a function.  If gdb isn't asked for 	       it's opinion (ie. through "whatis"), it won't offer 	       it. */
name|struct
name|type
modifier|*
name|type
init|=
name|VALUE_TYPE
argument_list|(
name|called_method
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|&&
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_PTR
condition|)
name|type
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|type
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
condition|)
block|{
if|if
condition|(
operator|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_ERROR
operator|)
operator|&&
name|expect_type
condition|)
return|return
name|allocate_value
argument_list|(
name|expect_type
argument_list|)
return|;
else|else
return|return
name|allocate_value
argument_list|(
name|type
argument_list|)
return|;
block|}
else|else
name|error
argument_list|(
literal|"Expression of type other than \"method returning ...\" used as a method"
argument_list|)
expr_stmt|;
block|}
comment|/* Now depending on whether we found a symbol for the method, 	   we will either call the runtime dispatcher or the method 	   directly.  */
name|argvec
index|[
literal|0
index|]
operator|=
name|called_method
expr_stmt|;
name|argvec
index|[
literal|1
index|]
operator|=
name|target
expr_stmt|;
name|argvec
index|[
literal|2
index|]
operator|=
name|value_from_longest
argument_list|(
name|builtin_type_long
argument_list|,
name|selector
argument_list|)
expr_stmt|;
comment|/* User-supplied arguments.  */
for|for
control|(
name|tem
operator|=
literal|0
init|;
name|tem
operator|<
name|nargs
condition|;
name|tem
operator|++
control|)
name|argvec
index|[
name|tem
operator|+
literal|3
index|]
operator|=
name|evaluate_subexp_with_coercion
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
name|argvec
index|[
name|tem
operator|+
literal|3
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|gnu_runtime
operator|&&
operator|(
name|method
operator|!=
name|NULL
operator|)
condition|)
block|{
comment|/* Function objc_msg_lookup returns a pointer.  */
name|VALUE_TYPE
argument_list|(
name|argvec
index|[
literal|0
index|]
argument_list|)
operator|=
name|lookup_function_type
argument_list|(
name|lookup_pointer_type
argument_list|(
name|VALUE_TYPE
argument_list|(
name|argvec
index|[
literal|0
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|argvec
index|[
literal|0
index|]
operator|=
name|call_function_by_hand
argument_list|(
name|argvec
index|[
literal|0
index|]
argument_list|,
name|nargs
operator|+
literal|2
argument_list|,
name|argvec
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|call_function_by_hand
argument_list|(
name|argvec
index|[
literal|0
index|]
argument_list|,
name|nargs
operator|+
literal|2
argument_list|,
name|argvec
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
break|break;
case|case
name|OP_FUNCALL
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|2
expr_stmt|;
name|op
operator|=
name|exp
operator|->
name|elts
index|[
operator|*
name|pos
index|]
operator|.
name|opcode
expr_stmt|;
name|nargs
operator|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
comment|/* Allocate arg vector, including space for the function to be          called in argvec[0] and a terminating NULL */
name|argvec
operator|=
operator|(
expr|struct
name|value
operator|*
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|value
operator|*
argument_list|)
operator|*
operator|(
name|nargs
operator|+
literal|3
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|STRUCTOP_MEMBER
operator|||
name|op
operator|==
name|STRUCTOP_MPTR
condition|)
block|{
name|LONGEST
name|fnptr
decl_stmt|;
comment|/* 1997-08-01 Currently we do not support function invocation 	     via pointers-to-methods with HP aCC. Pointer does not point 	     to the function, but possibly to some thunk. */
if|if
condition|(
name|hp_som_som_object_present
condition|)
block|{
name|error
argument_list|(
literal|"Not implemented: function invocation through pointer to method with HP aCC"
argument_list|)
expr_stmt|;
block|}
name|nargs
operator|++
expr_stmt|;
comment|/* First, evaluate the structure into arg2 */
name|pc2
operator|=
operator|(
operator|*
name|pos
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
if|if
condition|(
name|op
operator|==
name|STRUCTOP_MEMBER
condition|)
block|{
name|arg2
operator|=
name|evaluate_subexp_for_address
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|arg2
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
block|}
comment|/* If the function is a virtual function, then the 	     aggregate value (providing the structure) plays 	     its part by providing the vtable.  Otherwise, 	     it is just along for the ride: call the function 	     directly.  */
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
name|fnptr
operator|=
name|value_as_long
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|METHOD_PTR_IS_VIRTUAL
argument_list|(
name|fnptr
argument_list|)
condition|)
block|{
name|int
name|fnoffset
init|=
name|METHOD_PTR_TO_VOFFSET
argument_list|(
name|fnptr
argument_list|)
decl_stmt|;
name|struct
name|type
modifier|*
name|basetype
decl_stmt|;
name|struct
name|type
modifier|*
name|domain_type
init|=
name|TYPE_DOMAIN_TYPE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|basetype
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|domain_type
operator|!=
name|basetype
condition|)
name|arg2
operator|=
name|value_cast
argument_list|(
name|lookup_pointer_type
argument_list|(
name|domain_type
argument_list|)
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
name|basetype
operator|=
name|TYPE_VPTR_BASETYPE
argument_list|(
name|domain_type
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|TYPE_NFN_FIELDS
argument_list|(
name|basetype
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|struct
name|fn_field
modifier|*
name|f
init|=
name|TYPE_FN_FIELDLIST1
argument_list|(
name|basetype
argument_list|,
name|i
argument_list|)
decl_stmt|;
comment|/* If one is virtual, then all are virtual.  */
if|if
condition|(
name|TYPE_FN_FIELD_VIRTUAL_P
argument_list|(
name|f
argument_list|,
literal|0
argument_list|)
condition|)
for|for
control|(
name|j
operator|=
name|TYPE_FN_FIELDLIST_LENGTH
argument_list|(
name|basetype
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
operator|--
name|j
control|)
if|if
condition|(
operator|(
name|int
operator|)
name|TYPE_FN_FIELD_VOFFSET
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
operator|==
name|fnoffset
condition|)
block|{
name|struct
name|value
modifier|*
name|temp
init|=
name|value_ind
argument_list|(
name|arg2
argument_list|)
decl_stmt|;
name|arg1
operator|=
name|value_virtual_fn_field
argument_list|(
operator|&
name|temp
argument_list|,
name|f
argument_list|,
name|j
argument_list|,
name|domain_type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|value_addr
argument_list|(
name|temp
argument_list|)
expr_stmt|;
goto|goto
name|got_it
goto|;
block|}
block|}
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"virtual function at index %d not found"
argument_list|,
name|fnoffset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
operator|=
name|lookup_pointer_type
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|got_it
label|:
comment|/* Now, say which argument to start evaluating from */
name|tem
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
name|STRUCTOP_STRUCT
operator|||
name|op
operator|==
name|STRUCTOP_PTR
condition|)
block|{
comment|/* Hair for method invocations */
name|int
name|tem2
decl_stmt|;
name|nargs
operator|++
expr_stmt|;
comment|/* First, evaluate the structure into arg2 */
name|pc2
operator|=
operator|(
operator|*
name|pos
operator|)
operator|++
expr_stmt|;
name|tem2
operator|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc2
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
operator|*
name|pos
operator|+=
literal|3
operator|+
name|BYTES_TO_EXP_ELEM
argument_list|(
name|tem2
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
if|if
condition|(
name|op
operator|==
name|STRUCTOP_STRUCT
condition|)
block|{
comment|/* If v is a variable in a register, and the user types 	         v.method (), this will produce an error, because v has 	         no address.  	         A possible way around this would be to allocate a 	         copy of the variable on the stack, copy in the 	         contents, call the function, and copy out the 	         contents.  I.e. convert this from call by reference 	         to call by copy-return (or whatever it's called). 	         However, this does not work because it is not the 	         same: the method being called could stash a copy of 	         the address, and then future uses through that address 	         (after the method returns) would be expected to 	         use the variable itself, not some copy of it.  */
name|arg2
operator|=
name|evaluate_subexp_for_address
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|arg2
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
block|}
comment|/* Now, say which argument to start evaluating from */
name|tem
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
comment|/* Non-method function call */
name|save_pos1
operator|=
operator|*
name|pos
expr_stmt|;
name|argvec
index|[
literal|0
index|]
operator|=
name|evaluate_subexp_with_coercion
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
name|tem
operator|=
literal|1
expr_stmt|;
name|type
operator|=
name|VALUE_TYPE
argument_list|(
name|argvec
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|&&
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_PTR
condition|)
name|type
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|&&
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_FUNC
condition|)
block|{
for|for
control|(
init|;
name|tem
operator|<=
name|nargs
operator|&&
name|tem
operator|<=
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
condition|;
name|tem
operator|++
control|)
block|{
comment|/* pai: FIXME This seems to be coercing arguments before 		   * overload resolution has been done! */
name|argvec
index|[
name|tem
index|]
operator|=
name|evaluate_subexp
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|tem
operator|-
literal|1
argument_list|)
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Evaluate arguments */
for|for
control|(
init|;
name|tem
operator|<=
name|nargs
condition|;
name|tem
operator|++
control|)
block|{
comment|/* Ensure that array expressions are coerced into pointer objects. */
name|argvec
index|[
name|tem
index|]
operator|=
name|evaluate_subexp_with_coercion
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
block|}
comment|/* signal end of arglist */
name|argvec
index|[
name|tem
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|STRUCTOP_STRUCT
operator|||
name|op
operator|==
name|STRUCTOP_PTR
condition|)
block|{
name|int
name|static_memfuncp
decl_stmt|;
name|char
name|tstr
index|[
literal|256
index|]
decl_stmt|;
comment|/* Method invocation : stuff "this" as first parameter */
name|argvec
index|[
literal|1
index|]
operator|=
name|arg2
expr_stmt|;
comment|/* Name of method from expression */
name|strcpy
argument_list|(
name|tstr
argument_list|,
operator|&
name|exp
operator|->
name|elts
index|[
name|pc2
operator|+
literal|2
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|overload_resolution
operator|&&
operator|(
name|exp
operator|->
name|language_defn
operator|->
name|la_language
operator|==
name|language_cplus
operator|)
condition|)
block|{
comment|/* Language is C++, do some overload resolution before evaluation */
name|struct
name|value
modifier|*
name|valp
init|=
name|NULL
decl_stmt|;
comment|/* Prepare list of argument types for overload resolution */
name|arg_types
operator|=
operator|(
expr|struct
name|type
operator|*
operator|*
operator|)
name|alloca
argument_list|(
name|nargs
operator|*
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|ix
operator|=
literal|1
init|;
name|ix
operator|<=
name|nargs
condition|;
name|ix
operator|++
control|)
name|arg_types
index|[
name|ix
operator|-
literal|1
index|]
operator|=
name|VALUE_TYPE
argument_list|(
name|argvec
index|[
name|ix
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|find_overload_match
argument_list|(
name|arg_types
argument_list|,
name|nargs
argument_list|,
name|tstr
argument_list|,
literal|1
comment|/* method */
argument_list|,
literal|0
comment|/* strict match */
argument_list|,
operator|&
name|arg2
comment|/* the object */
argument_list|,
name|NULL
argument_list|,
operator|&
name|valp
argument_list|,
name|NULL
argument_list|,
operator|&
name|static_memfuncp
argument_list|)
expr_stmt|;
name|argvec
index|[
literal|1
index|]
operator|=
name|arg2
expr_stmt|;
comment|/* the ``this'' pointer */
name|argvec
index|[
literal|0
index|]
operator|=
name|valp
expr_stmt|;
comment|/* use the method found after overload resolution */
block|}
else|else
comment|/* Non-C++ case -- or no overload resolution */
block|{
name|struct
name|value
modifier|*
name|temp
init|=
name|arg2
decl_stmt|;
name|argvec
index|[
literal|0
index|]
operator|=
name|value_struct_elt
argument_list|(
operator|&
name|temp
argument_list|,
name|argvec
operator|+
literal|1
argument_list|,
name|tstr
argument_list|,
operator|&
name|static_memfuncp
argument_list|,
name|op
operator|==
name|STRUCTOP_STRUCT
condition|?
literal|"structure"
else|:
literal|"structure pointer"
argument_list|)
expr_stmt|;
comment|/* value_struct_elt updates temp with the correct value 	 	 of the ``this'' pointer if necessary, so modify argvec[1] to 		 reflect any ``this'' changes.  */
name|arg2
operator|=
name|value_from_longest
argument_list|(
name|lookup_pointer_type
argument_list|(
name|VALUE_TYPE
argument_list|(
name|temp
argument_list|)
argument_list|)
argument_list|,
name|VALUE_ADDRESS
argument_list|(
name|temp
argument_list|)
operator|+
name|VALUE_OFFSET
argument_list|(
name|temp
argument_list|)
operator|+
name|VALUE_EMBEDDED_OFFSET
argument_list|(
name|temp
argument_list|)
argument_list|)
expr_stmt|;
name|argvec
index|[
literal|1
index|]
operator|=
name|arg2
expr_stmt|;
comment|/* the ``this'' pointer */
block|}
if|if
condition|(
name|static_memfuncp
condition|)
block|{
name|argvec
index|[
literal|1
index|]
operator|=
name|argvec
index|[
literal|0
index|]
expr_stmt|;
name|nargs
operator|--
expr_stmt|;
name|argvec
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|op
operator|==
name|STRUCTOP_MEMBER
operator|||
name|op
operator|==
name|STRUCTOP_MPTR
condition|)
block|{
name|argvec
index|[
literal|1
index|]
operator|=
name|arg2
expr_stmt|;
name|argvec
index|[
literal|0
index|]
operator|=
name|arg1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
name|OP_VAR_VALUE
condition|)
block|{
comment|/* Non-member function being called */
comment|/* fn: This can only be done for C++ functions.  A C-style function              in a C++ program, for instance, does not have the fields that               are expected here */
if|if
condition|(
name|overload_resolution
operator|&&
operator|(
name|exp
operator|->
name|language_defn
operator|->
name|la_language
operator|==
name|language_cplus
operator|)
condition|)
block|{
comment|/* Language is C++, do some overload resolution before evaluation */
name|struct
name|symbol
modifier|*
name|symp
decl_stmt|;
comment|/* Prepare list of argument types for overload resolution */
name|arg_types
operator|=
operator|(
expr|struct
name|type
operator|*
operator|*
operator|)
name|alloca
argument_list|(
name|nargs
operator|*
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|ix
operator|=
literal|1
init|;
name|ix
operator|<=
name|nargs
condition|;
name|ix
operator|++
control|)
name|arg_types
index|[
name|ix
operator|-
literal|1
index|]
operator|=
name|VALUE_TYPE
argument_list|(
name|argvec
index|[
name|ix
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|find_overload_match
argument_list|(
name|arg_types
argument_list|,
name|nargs
argument_list|,
name|NULL
comment|/* no need for name */
argument_list|,
literal|0
comment|/* not method */
argument_list|,
literal|0
comment|/* strict match */
argument_list|,
name|NULL
argument_list|,
name|exp
operator|->
name|elts
index|[
name|save_pos1
operator|+
literal|2
index|]
operator|.
name|symbol
comment|/* the function */
argument_list|,
name|NULL
argument_list|,
operator|&
name|symp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Now fix the expression being evaluated */
name|exp
operator|->
name|elts
index|[
name|save_pos1
operator|+
literal|2
index|]
operator|.
name|symbol
operator|=
name|symp
expr_stmt|;
name|argvec
index|[
literal|0
index|]
operator|=
name|evaluate_subexp_with_coercion
argument_list|(
name|exp
argument_list|,
operator|&
name|save_pos1
argument_list|,
name|noside
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Not C++, or no overload resolution allowed */
comment|/* nothing to be done; argvec already correctly set up */
block|}
block|}
else|else
block|{
comment|/* It is probably a C-style function */
comment|/* nothing to be done; argvec already correctly set up */
block|}
name|do_call_it
label|:
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
if|if
condition|(
name|argvec
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Cannot evaluate function -- may be inlined"
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_AVOID_SIDE_EFFECTS
condition|)
block|{
comment|/* If the return type doesn't look like a function type, call an 	     error.  This can happen if somebody tries to turn a variable into 	     a function call. This is here because people often want to 	     call, eg, strcmp, which gdb doesn't know is a function.  If 	     gdb isn't asked for it's opinion (ie. through "whatis"), 	     it won't offer it. */
name|struct
name|type
modifier|*
name|ftype
init|=
name|TYPE_TARGET_TYPE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|argvec
index|[
literal|0
index|]
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|ftype
condition|)
return|return
name|allocate_value
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|argvec
index|[
literal|0
index|]
argument_list|)
argument_list|)
argument_list|)
return|;
else|else
name|error
argument_list|(
literal|"Expression of type other than \"Function returning ...\" used as function"
argument_list|)
expr_stmt|;
block|}
return|return
name|call_function_by_hand
argument_list|(
name|argvec
index|[
literal|0
index|]
argument_list|,
name|nargs
argument_list|,
name|argvec
operator|+
literal|1
argument_list|)
return|;
comment|/* pai: FIXME save value from call_function_by_hand, then adjust pc by adjust_fn_pc if +ve  */
case|case
name|OP_F77_UNDETERMINED_ARGLIST
case|:
comment|/* Remember that in F77, functions, substring ops and           array subscript operations cannot be disambiguated           at parse time.  We have made all array subscript operations,           substring operations as well as function calls  come here           and we now have to discover what the heck this thing actually was.            If it is a function, we process just as if we got an OP_FUNCALL. */
name|nargs
operator|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|2
expr_stmt|;
comment|/* First determine the type code we are dealing with.  */
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
name|type
operator|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|=
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|TYPE_CODE_ARRAY
case|:
goto|goto
name|multi_f77_subscript
goto|;
case|case
name|TYPE_CODE_STRING
case|:
goto|goto
name|op_f77_substr
goto|;
case|case
name|TYPE_CODE_PTR
case|:
case|case
name|TYPE_CODE_FUNC
case|:
comment|/* It's a function call. */
comment|/* Allocate arg vector, including space for the function to be 	     called in argvec[0] and a terminating NULL */
name|argvec
operator|=
operator|(
expr|struct
name|value
operator|*
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|value
operator|*
argument_list|)
operator|*
operator|(
name|nargs
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
name|argvec
index|[
literal|0
index|]
operator|=
name|arg1
expr_stmt|;
name|tem
operator|=
literal|1
expr_stmt|;
for|for
control|(
init|;
name|tem
operator|<=
name|nargs
condition|;
name|tem
operator|++
control|)
name|argvec
index|[
name|tem
index|]
operator|=
name|evaluate_subexp_with_coercion
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
name|argvec
index|[
name|tem
index|]
operator|=
literal|0
expr_stmt|;
comment|/* signal end of arglist */
goto|goto
name|do_call_it
goto|;
default|default:
name|error
argument_list|(
literal|"Cannot perform substring on this type"
argument_list|)
expr_stmt|;
block|}
name|op_f77_substr
label|:
comment|/* We have a substring operation on our hands here,           let us get the string we will be dealing with */
comment|/* Now evaluate the 'from' and 'to' */
name|arg2
operator|=
name|evaluate_subexp_with_coercion
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|nargs
operator|<
literal|2
condition|)
return|return
name|value_subscript
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
return|;
name|arg3
operator|=
name|evaluate_subexp_with_coercion
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
name|tem2
operator|=
name|value_as_long
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
name|tem3
operator|=
name|value_as_long
argument_list|(
name|arg3
argument_list|)
expr_stmt|;
return|return
name|value_slice
argument_list|(
name|arg1
argument_list|,
name|tem2
argument_list|,
name|tem3
operator|-
name|tem2
operator|+
literal|1
argument_list|)
return|;
case|case
name|OP_COMPLEX
case|:
comment|/* We have a complex number, There should be 2 floating           point numbers that compose it */
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
return|return
name|value_literal_complex
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
name|builtin_type_f_complex_s16
argument_list|)
return|;
case|case
name|STRUCTOP_STRUCT
case|:
name|tem
operator|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|3
operator|+
name|BYTES_TO_EXP_ELEM
argument_list|(
name|tem
operator|+
literal|1
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
if|if
condition|(
name|noside
operator|==
name|EVAL_AVOID_SIDE_EFFECTS
condition|)
return|return
name|value_zero
argument_list|(
name|lookup_struct_elt_type
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
operator|&
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|string
argument_list|,
literal|0
argument_list|)
argument_list|,
name|lval_memory
argument_list|)
return|;
else|else
block|{
name|struct
name|value
modifier|*
name|temp
init|=
name|arg1
decl_stmt|;
return|return
name|value_struct_elt
argument_list|(
operator|&
name|temp
argument_list|,
name|NULL
argument_list|,
operator|&
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|string
argument_list|,
name|NULL
argument_list|,
literal|"structure"
argument_list|)
return|;
block|}
case|case
name|STRUCTOP_PTR
case|:
name|tem
operator|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|3
operator|+
name|BYTES_TO_EXP_ELEM
argument_list|(
name|tem
operator|+
literal|1
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
comment|/* JYG: if print object is on we need to replace the base type 	 with rtti type in order to continue on with successful 	 lookup of member / method only available in the rtti type. */
block|{
name|struct
name|type
modifier|*
name|type
init|=
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
decl_stmt|;
name|struct
name|type
modifier|*
name|real_type
decl_stmt|;
name|int
name|full
decl_stmt|,
name|top
decl_stmt|,
name|using_enc
decl_stmt|;
if|if
condition|(
name|objectprint
operator|&&
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
operator|&&
operator|(
name|TYPE_CODE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_CLASS
operator|)
condition|)
block|{
name|real_type
operator|=
name|value_rtti_target_type
argument_list|(
name|arg1
argument_list|,
operator|&
name|full
argument_list|,
operator|&
name|top
argument_list|,
operator|&
name|using_enc
argument_list|)
expr_stmt|;
if|if
condition|(
name|real_type
condition|)
block|{
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_PTR
condition|)
name|real_type
operator|=
name|lookup_pointer_type
argument_list|(
name|real_type
argument_list|)
expr_stmt|;
else|else
name|real_type
operator|=
name|lookup_reference_type
argument_list|(
name|real_type
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|value_cast
argument_list|(
name|real_type
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|noside
operator|==
name|EVAL_AVOID_SIDE_EFFECTS
condition|)
return|return
name|value_zero
argument_list|(
name|lookup_struct_elt_type
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
operator|&
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|string
argument_list|,
literal|0
argument_list|)
argument_list|,
name|lval_memory
argument_list|)
return|;
else|else
block|{
name|struct
name|value
modifier|*
name|temp
init|=
name|arg1
decl_stmt|;
return|return
name|value_struct_elt
argument_list|(
operator|&
name|temp
argument_list|,
name|NULL
argument_list|,
operator|&
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|string
argument_list|,
name|NULL
argument_list|,
literal|"structure pointer"
argument_list|)
return|;
block|}
case|case
name|STRUCTOP_MEMBER
case|:
name|arg1
operator|=
name|evaluate_subexp_for_address
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
comment|/* With HP aCC, pointers to methods do not point to the function code */
if|if
condition|(
name|hp_som_som_object_present
operator|&&
operator|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_PTR
operator|)
operator|&&
operator|(
name|TYPE_CODE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_METHOD
operator|)
condition|)
name|error
argument_list|(
literal|"Pointers to methods not supported with HP aCC"
argument_list|)
expr_stmt|;
comment|/* 1997-08-19 */
name|mem_offset
operator|=
name|value_as_long
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
goto|goto
name|handle_pointer_to_member
goto|;
case|case
name|STRUCTOP_MPTR
case|:
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
comment|/* With HP aCC, pointers to methods do not point to the function code */
if|if
condition|(
name|hp_som_som_object_present
operator|&&
operator|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_PTR
operator|)
operator|&&
operator|(
name|TYPE_CODE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_METHOD
operator|)
condition|)
name|error
argument_list|(
literal|"Pointers to methods not supported with HP aCC"
argument_list|)
expr_stmt|;
comment|/* 1997-08-19 */
name|mem_offset
operator|=
name|value_as_long
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
name|handle_pointer_to_member
label|:
comment|/* HP aCC generates offsets that have bit #29 set; turn it off to get          a real offset to the member. */
if|if
condition|(
name|hp_som_som_object_present
condition|)
block|{
if|if
condition|(
operator|!
name|mem_offset
condition|)
comment|/* no bias -> really null */
name|error
argument_list|(
literal|"Attempted dereference of null pointer-to-member"
argument_list|)
expr_stmt|;
name|mem_offset
operator|&=
operator|~
literal|0x20000000
expr_stmt|;
block|}
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
name|type
operator|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_CODE_PTR
condition|)
goto|goto
name|bad_pointer_to_member
goto|;
name|type
operator|=
name|check_typedef
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_METHOD
condition|)
name|error
argument_list|(
literal|"not implemented: pointer-to-method in pointer-to-member construct"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_CODE_MEMBER
condition|)
goto|goto
name|bad_pointer_to_member
goto|;
comment|/* Now, convert these values to an address.  */
name|arg1
operator|=
name|value_cast
argument_list|(
name|lookup_pointer_type
argument_list|(
name|TYPE_DOMAIN_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
name|arg3
operator|=
name|value_from_pointer
argument_list|(
name|lookup_pointer_type
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|value_as_long
argument_list|(
name|arg1
argument_list|)
operator|+
name|mem_offset
argument_list|)
expr_stmt|;
return|return
name|value_ind
argument_list|(
name|arg3
argument_list|)
return|;
name|bad_pointer_to_member
label|:
name|error
argument_list|(
literal|"non-pointer-to-member value used in pointer-to-member construct"
argument_list|)
expr_stmt|;
case|case
name|BINOP_CONCAT
case|:
name|arg1
operator|=
name|evaluate_subexp_with_coercion
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|evaluate_subexp_with_coercion
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
if|if
condition|(
name|binop_user_defined_p
argument_list|(
name|op
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
condition|)
return|return
name|value_x_binop
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
name|op
argument_list|,
name|OP_NULL
argument_list|,
name|noside
argument_list|)
return|;
else|else
return|return
name|value_concat
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
return|;
case|case
name|BINOP_ASSIGN
case|:
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|evaluate_subexp
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
comment|/* Do special stuff for HP aCC pointers to members */
if|if
condition|(
name|hp_som_som_object_present
condition|)
block|{
comment|/* 1997-08-19 Can't assign HP aCC pointers to methods. No details of 	     the implementation yet; but the pointer appears to point to a code 	     sequence (thunk) in memory -- in any case it is *not* the address 	     of the function as it would be in a naive implementation. */
if|if
condition|(
operator|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_PTR
operator|)
operator|&&
operator|(
name|TYPE_CODE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_METHOD
operator|)
condition|)
name|error
argument_list|(
literal|"Assignment to pointers to methods not implemented with HP aCC"
argument_list|)
expr_stmt|;
comment|/* HP aCC pointers to data members require a constant bias */
if|if
condition|(
operator|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_PTR
operator|)
operator|&&
operator|(
name|TYPE_CODE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_MEMBER
operator|)
condition|)
block|{
name|unsigned
name|int
modifier|*
name|ptr
init|=
operator|(
name|unsigned
name|int
operator|*
operator|)
name|VALUE_CONTENTS
argument_list|(
name|arg2
argument_list|)
decl_stmt|;
comment|/* forces evaluation */
operator|*
name|ptr
operator||=
literal|0x20000000
expr_stmt|;
comment|/* set 29th bit */
block|}
block|}
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
operator|||
name|noside
operator|==
name|EVAL_AVOID_SIDE_EFFECTS
condition|)
return|return
name|arg1
return|;
if|if
condition|(
name|binop_user_defined_p
argument_list|(
name|op
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
condition|)
return|return
name|value_x_binop
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
name|op
argument_list|,
name|OP_NULL
argument_list|,
name|noside
argument_list|)
return|;
else|else
return|return
name|value_assign
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
return|;
case|case
name|BINOP_ASSIGN_MODIFY
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|2
expr_stmt|;
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|evaluate_subexp
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
operator|||
name|noside
operator|==
name|EVAL_AVOID_SIDE_EFFECTS
condition|)
return|return
name|arg1
return|;
name|op
operator|=
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|opcode
expr_stmt|;
if|if
condition|(
name|binop_user_defined_p
argument_list|(
name|op
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
condition|)
return|return
name|value_x_binop
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
name|BINOP_ASSIGN_MODIFY
argument_list|,
name|op
argument_list|,
name|noside
argument_list|)
return|;
elseif|else
if|if
condition|(
name|op
operator|==
name|BINOP_ADD
condition|)
name|arg2
operator|=
name|value_add
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|op
operator|==
name|BINOP_SUB
condition|)
name|arg2
operator|=
name|value_sub
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
else|else
name|arg2
operator|=
name|value_binop
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
name|op
argument_list|)
expr_stmt|;
return|return
name|value_assign
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
return|;
case|case
name|BINOP_ADD
case|:
name|arg1
operator|=
name|evaluate_subexp_with_coercion
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|evaluate_subexp_with_coercion
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
if|if
condition|(
name|binop_user_defined_p
argument_list|(
name|op
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
condition|)
return|return
name|value_x_binop
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
name|op
argument_list|,
name|OP_NULL
argument_list|,
name|noside
argument_list|)
return|;
else|else
return|return
name|value_add
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
return|;
case|case
name|BINOP_SUB
case|:
name|arg1
operator|=
name|evaluate_subexp_with_coercion
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|evaluate_subexp_with_coercion
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
if|if
condition|(
name|binop_user_defined_p
argument_list|(
name|op
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
condition|)
return|return
name|value_x_binop
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
name|op
argument_list|,
name|OP_NULL
argument_list|,
name|noside
argument_list|)
return|;
else|else
return|return
name|value_sub
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
return|;
case|case
name|BINOP_MUL
case|:
case|case
name|BINOP_DIV
case|:
case|case
name|BINOP_REM
case|:
case|case
name|BINOP_MOD
case|:
case|case
name|BINOP_LSH
case|:
case|case
name|BINOP_RSH
case|:
case|case
name|BINOP_BITWISE_AND
case|:
case|case
name|BINOP_BITWISE_IOR
case|:
case|case
name|BINOP_BITWISE_XOR
case|:
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
if|if
condition|(
name|binop_user_defined_p
argument_list|(
name|op
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
condition|)
return|return
name|value_x_binop
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
name|op
argument_list|,
name|OP_NULL
argument_list|,
name|noside
argument_list|)
return|;
elseif|else
if|if
condition|(
name|noside
operator|==
name|EVAL_AVOID_SIDE_EFFECTS
operator|&&
operator|(
name|op
operator|==
name|BINOP_DIV
operator|||
name|op
operator|==
name|BINOP_REM
operator|||
name|op
operator|==
name|BINOP_MOD
operator|)
condition|)
return|return
name|value_zero
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|not_lval
argument_list|)
return|;
else|else
return|return
name|value_binop
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
name|op
argument_list|)
return|;
case|case
name|BINOP_RANGE
case|:
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
name|error
argument_list|(
literal|"':' operator used in invalid context"
argument_list|)
expr_stmt|;
case|case
name|BINOP_SUBSCRIPT
case|:
name|arg1
operator|=
name|evaluate_subexp_with_coercion
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|evaluate_subexp_with_coercion
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
if|if
condition|(
name|binop_user_defined_p
argument_list|(
name|op
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
condition|)
return|return
name|value_x_binop
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
name|op
argument_list|,
name|OP_NULL
argument_list|,
name|noside
argument_list|)
return|;
else|else
block|{
comment|/* If the user attempts to subscript something that is not an 	     array or pointer type (like a plain int variable for example), 	     then report this as an error. */
name|COERCE_REF
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|type
operator|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_CODE_ARRAY
operator|&&
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_CODE_PTR
condition|)
block|{
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
condition|)
name|error
argument_list|(
literal|"cannot subscript something of type `%s'"
argument_list|,
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"cannot subscript requested type"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|noside
operator|==
name|EVAL_AVOID_SIDE_EFFECTS
condition|)
return|return
name|value_zero
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|VALUE_LVAL
argument_list|(
name|arg1
argument_list|)
argument_list|)
return|;
else|else
return|return
name|value_subscript
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
return|;
block|}
case|case
name|BINOP_IN
case|:
name|arg1
operator|=
name|evaluate_subexp_with_coercion
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|evaluate_subexp_with_coercion
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
return|return
name|value_in
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
return|;
case|case
name|MULTI_SUBSCRIPT
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|2
expr_stmt|;
name|nargs
operator|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|evaluate_subexp_with_coercion
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
while|while
condition|(
name|nargs
operator|--
operator|>
literal|0
condition|)
block|{
name|arg2
operator|=
name|evaluate_subexp_with_coercion
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
comment|/* FIXME:  EVAL_SKIP handling may not be correct. */
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
block|{
if|if
condition|(
name|nargs
operator|>
literal|0
condition|)
block|{
continue|continue;
block|}
else|else
block|{
goto|goto
name|nosideret
goto|;
block|}
block|}
comment|/* FIXME:  EVAL_AVOID_SIDE_EFFECTS handling may not be correct. */
if|if
condition|(
name|noside
operator|==
name|EVAL_AVOID_SIDE_EFFECTS
condition|)
block|{
comment|/* If the user attempts to subscript something that has no target 	         type (like a plain int variable for example), then report this 	         as an error. */
name|type
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|NULL
condition|)
block|{
name|arg1
operator|=
name|value_zero
argument_list|(
name|type
argument_list|,
name|VALUE_LVAL
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
name|noside
operator|=
name|EVAL_SKIP
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|error
argument_list|(
literal|"cannot subscript something of type `%s'"
argument_list|,
name|TYPE_NAME
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|binop_user_defined_p
argument_list|(
name|op
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
condition|)
block|{
name|arg1
operator|=
name|value_x_binop
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
name|op
argument_list|,
name|OP_NULL
argument_list|,
name|noside
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|arg1
operator|=
name|value_subscript
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|arg1
operator|)
return|;
name|multi_f77_subscript
label|:
block|{
name|int
name|subscript_array
index|[
name|MAX_FORTRAN_DIMS
operator|+
literal|1
index|]
decl_stmt|;
comment|/* 1-based array of  							   subscripts, max == 7 */
name|int
name|array_size_array
index|[
name|MAX_FORTRAN_DIMS
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|ndimensions
init|=
literal|1
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|type
modifier|*
name|tmp_type
decl_stmt|;
name|int
name|offset_item
decl_stmt|;
comment|/* The array offset where the item lives */
if|if
condition|(
name|nargs
operator|>
name|MAX_FORTRAN_DIMS
condition|)
name|error
argument_list|(
literal|"Too many subscripts for F77 (%d Max)"
argument_list|,
name|MAX_FORTRAN_DIMS
argument_list|)
expr_stmt|;
name|tmp_type
operator|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
name|ndimensions
operator|=
name|calc_f77_array_dims
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|nargs
operator|!=
name|ndimensions
condition|)
name|error
argument_list|(
literal|"Wrong number of subscripts"
argument_list|)
expr_stmt|;
comment|/* Now that we know we have a legal array subscript expression  	   let us actually find out where this element exists in the array. */
name|offset_item
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|nargs
condition|;
name|i
operator|++
control|)
block|{
comment|/* Evaluate each subscript, It must be a legal integer in F77 */
name|arg2
operator|=
name|evaluate_subexp_with_coercion
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
comment|/* Fill in the subscript and array size arrays */
name|subscript_array
index|[
name|i
index|]
operator|=
name|value_as_long
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
name|retcode
operator|=
name|f77_get_dynamic_upperbound
argument_list|(
name|tmp_type
argument_list|,
operator|&
name|upper
argument_list|)
expr_stmt|;
if|if
condition|(
name|retcode
operator|==
name|BOUND_FETCH_ERROR
condition|)
name|error
argument_list|(
literal|"Cannot obtain dynamic upper bound"
argument_list|)
expr_stmt|;
name|retcode
operator|=
name|f77_get_dynamic_lowerbound
argument_list|(
name|tmp_type
argument_list|,
operator|&
name|lower
argument_list|)
expr_stmt|;
if|if
condition|(
name|retcode
operator|==
name|BOUND_FETCH_ERROR
condition|)
name|error
argument_list|(
literal|"Cannot obtain dynamic lower bound"
argument_list|)
expr_stmt|;
name|array_size_array
index|[
name|i
index|]
operator|=
name|upper
operator|-
name|lower
operator|+
literal|1
expr_stmt|;
comment|/* Zero-normalize subscripts so that offsetting will work. */
name|subscript_array
index|[
name|i
index|]
operator|-=
name|lower
expr_stmt|;
comment|/* If we are at the bottom of a multidimensional  	       array type then keep a ptr to the last ARRAY 	       type around for use when calling value_subscript() 	       below. This is done because we pretend to value_subscript 	       that we actually have a one-dimensional array  	       of base element type that we apply a simple  	       offset to. */
if|if
condition|(
name|i
operator|<
name|nargs
condition|)
name|tmp_type
operator|=
name|check_typedef
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|tmp_type
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Now let us calculate the offset for this item */
name|offset_item
operator|=
name|subscript_array
index|[
name|ndimensions
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|ndimensions
operator|-
literal|1
init|;
name|i
operator|>=
literal|1
condition|;
name|i
operator|--
control|)
name|offset_item
operator|=
name|array_size_array
index|[
name|i
index|]
operator|*
name|offset_item
operator|+
name|subscript_array
index|[
name|i
index|]
expr_stmt|;
comment|/* Construct a value node with the value of the offset */
name|arg2
operator|=
name|value_from_longest
argument_list|(
name|builtin_type_f_integer
argument_list|,
name|offset_item
argument_list|)
expr_stmt|;
comment|/* Let us now play a dirty trick: we will take arg1  	   which is a value node pointing to the topmost level 	   of the multidimensional array-set and pretend 	   that it is actually a array of the final element  	   type, this will ensure that value_subscript() 	   returns the correct type value */
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
operator|=
name|tmp_type
expr_stmt|;
return|return
name|value_ind
argument_list|(
name|value_add
argument_list|(
name|value_coerce_array
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|arg2
argument_list|)
argument_list|)
return|;
block|}
case|case
name|BINOP_LOGICAL_AND
case|:
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
block|{
name|arg2
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
goto|goto
name|nosideret
goto|;
block|}
name|oldpos
operator|=
operator|*
name|pos
expr_stmt|;
name|arg2
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|EVAL_AVOID_SIDE_EFFECTS
argument_list|)
expr_stmt|;
operator|*
name|pos
operator|=
name|oldpos
expr_stmt|;
if|if
condition|(
name|binop_user_defined_p
argument_list|(
name|op
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
condition|)
block|{
name|arg2
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
return|return
name|value_x_binop
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
name|op
argument_list|,
name|OP_NULL
argument_list|,
name|noside
argument_list|)
return|;
block|}
else|else
block|{
name|tem
operator|=
name|value_logical_not
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
operator|(
name|tem
condition|?
name|EVAL_SKIP
else|:
name|noside
operator|)
argument_list|)
expr_stmt|;
return|return
name|value_from_longest
argument_list|(
name|LA_BOOL_TYPE
argument_list|,
call|(
name|LONGEST
call|)
argument_list|(
operator|!
name|tem
operator|&&
operator|!
name|value_logical_not
argument_list|(
name|arg2
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
case|case
name|BINOP_LOGICAL_OR
case|:
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
block|{
name|arg2
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
goto|goto
name|nosideret
goto|;
block|}
name|oldpos
operator|=
operator|*
name|pos
expr_stmt|;
name|arg2
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|EVAL_AVOID_SIDE_EFFECTS
argument_list|)
expr_stmt|;
operator|*
name|pos
operator|=
name|oldpos
expr_stmt|;
if|if
condition|(
name|binop_user_defined_p
argument_list|(
name|op
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
condition|)
block|{
name|arg2
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
return|return
name|value_x_binop
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
name|op
argument_list|,
name|OP_NULL
argument_list|,
name|noside
argument_list|)
return|;
block|}
else|else
block|{
name|tem
operator|=
name|value_logical_not
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
operator|(
operator|!
name|tem
condition|?
name|EVAL_SKIP
else|:
name|noside
operator|)
argument_list|)
expr_stmt|;
return|return
name|value_from_longest
argument_list|(
name|LA_BOOL_TYPE
argument_list|,
call|(
name|LONGEST
call|)
argument_list|(
operator|!
name|tem
operator|||
operator|!
name|value_logical_not
argument_list|(
name|arg2
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
case|case
name|BINOP_EQUAL
case|:
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|evaluate_subexp
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
if|if
condition|(
name|binop_user_defined_p
argument_list|(
name|op
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
condition|)
block|{
return|return
name|value_x_binop
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
name|op
argument_list|,
name|OP_NULL
argument_list|,
name|noside
argument_list|)
return|;
block|}
else|else
block|{
name|tem
operator|=
name|value_equal
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
return|return
name|value_from_longest
argument_list|(
name|LA_BOOL_TYPE
argument_list|,
operator|(
name|LONGEST
operator|)
name|tem
argument_list|)
return|;
block|}
case|case
name|BINOP_NOTEQUAL
case|:
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|evaluate_subexp
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
if|if
condition|(
name|binop_user_defined_p
argument_list|(
name|op
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
condition|)
block|{
return|return
name|value_x_binop
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
name|op
argument_list|,
name|OP_NULL
argument_list|,
name|noside
argument_list|)
return|;
block|}
else|else
block|{
name|tem
operator|=
name|value_equal
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
return|return
name|value_from_longest
argument_list|(
name|LA_BOOL_TYPE
argument_list|,
operator|(
name|LONGEST
operator|)
operator|!
name|tem
argument_list|)
return|;
block|}
case|case
name|BINOP_LESS
case|:
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|evaluate_subexp
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
if|if
condition|(
name|binop_user_defined_p
argument_list|(
name|op
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
condition|)
block|{
return|return
name|value_x_binop
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
name|op
argument_list|,
name|OP_NULL
argument_list|,
name|noside
argument_list|)
return|;
block|}
else|else
block|{
name|tem
operator|=
name|value_less
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
return|return
name|value_from_longest
argument_list|(
name|LA_BOOL_TYPE
argument_list|,
operator|(
name|LONGEST
operator|)
name|tem
argument_list|)
return|;
block|}
case|case
name|BINOP_GTR
case|:
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|evaluate_subexp
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
if|if
condition|(
name|binop_user_defined_p
argument_list|(
name|op
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
condition|)
block|{
return|return
name|value_x_binop
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
name|op
argument_list|,
name|OP_NULL
argument_list|,
name|noside
argument_list|)
return|;
block|}
else|else
block|{
name|tem
operator|=
name|value_less
argument_list|(
name|arg2
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
return|return
name|value_from_longest
argument_list|(
name|LA_BOOL_TYPE
argument_list|,
operator|(
name|LONGEST
operator|)
name|tem
argument_list|)
return|;
block|}
case|case
name|BINOP_GEQ
case|:
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|evaluate_subexp
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
if|if
condition|(
name|binop_user_defined_p
argument_list|(
name|op
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
condition|)
block|{
return|return
name|value_x_binop
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
name|op
argument_list|,
name|OP_NULL
argument_list|,
name|noside
argument_list|)
return|;
block|}
else|else
block|{
name|tem
operator|=
name|value_less
argument_list|(
name|arg2
argument_list|,
name|arg1
argument_list|)
operator|||
name|value_equal
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
return|return
name|value_from_longest
argument_list|(
name|LA_BOOL_TYPE
argument_list|,
operator|(
name|LONGEST
operator|)
name|tem
argument_list|)
return|;
block|}
case|case
name|BINOP_LEQ
case|:
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|evaluate_subexp
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
if|if
condition|(
name|binop_user_defined_p
argument_list|(
name|op
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
condition|)
block|{
return|return
name|value_x_binop
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
name|op
argument_list|,
name|OP_NULL
argument_list|,
name|noside
argument_list|)
return|;
block|}
else|else
block|{
name|tem
operator|=
name|value_less
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
operator|||
name|value_equal
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
return|return
name|value_from_longest
argument_list|(
name|LA_BOOL_TYPE
argument_list|,
operator|(
name|LONGEST
operator|)
name|tem
argument_list|)
return|;
block|}
case|case
name|BINOP_REPEAT
case|:
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
name|type
operator|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_CODE_INT
condition|)
name|error
argument_list|(
literal|"Non-integral right operand for \"@\" operator."
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_AVOID_SIDE_EFFECTS
condition|)
block|{
return|return
name|allocate_repeat_value
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|longest_to_int
argument_list|(
name|value_as_long
argument_list|(
name|arg2
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
else|else
return|return
name|value_repeat
argument_list|(
name|arg1
argument_list|,
name|longest_to_int
argument_list|(
name|value_as_long
argument_list|(
name|arg2
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|BINOP_COMMA
case|:
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
return|return
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
return|;
case|case
name|UNOP_NEG
case|:
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
if|if
condition|(
name|unop_user_defined_p
argument_list|(
name|op
argument_list|,
name|arg1
argument_list|)
condition|)
return|return
name|value_x_unop
argument_list|(
name|arg1
argument_list|,
name|op
argument_list|,
name|noside
argument_list|)
return|;
else|else
return|return
name|value_neg
argument_list|(
name|arg1
argument_list|)
return|;
case|case
name|UNOP_COMPLEMENT
case|:
comment|/* C++: check for and handle destructor names.  */
name|op
operator|=
name|exp
operator|->
name|elts
index|[
operator|*
name|pos
index|]
operator|.
name|opcode
expr_stmt|;
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
if|if
condition|(
name|unop_user_defined_p
argument_list|(
name|UNOP_COMPLEMENT
argument_list|,
name|arg1
argument_list|)
condition|)
return|return
name|value_x_unop
argument_list|(
name|arg1
argument_list|,
name|UNOP_COMPLEMENT
argument_list|,
name|noside
argument_list|)
return|;
else|else
return|return
name|value_complement
argument_list|(
name|arg1
argument_list|)
return|;
case|case
name|UNOP_LOGICAL_NOT
case|:
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
if|if
condition|(
name|unop_user_defined_p
argument_list|(
name|op
argument_list|,
name|arg1
argument_list|)
condition|)
return|return
name|value_x_unop
argument_list|(
name|arg1
argument_list|,
name|op
argument_list|,
name|noside
argument_list|)
return|;
else|else
return|return
name|value_from_longest
argument_list|(
name|LA_BOOL_TYPE
argument_list|,
operator|(
name|LONGEST
operator|)
name|value_logical_not
argument_list|(
name|arg1
argument_list|)
argument_list|)
return|;
case|case
name|UNOP_IND
case|:
if|if
condition|(
name|expect_type
operator|&&
name|TYPE_CODE
argument_list|(
name|expect_type
argument_list|)
operator|==
name|TYPE_CODE_PTR
condition|)
name|expect_type
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|check_typedef
argument_list|(
name|expect_type
argument_list|)
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|expect_type
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TYPE_TARGET_TYPE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|TYPE_CODE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_METHOD
operator|)
operator|||
operator|(
name|TYPE_CODE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_MEMBER
operator|)
operator|)
condition|)
name|error
argument_list|(
literal|"Attempt to dereference pointer to member without an object"
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
if|if
condition|(
name|unop_user_defined_p
argument_list|(
name|op
argument_list|,
name|arg1
argument_list|)
condition|)
return|return
name|value_x_unop
argument_list|(
name|arg1
argument_list|,
name|op
argument_list|,
name|noside
argument_list|)
return|;
elseif|else
if|if
condition|(
name|noside
operator|==
name|EVAL_AVOID_SIDE_EFFECTS
condition|)
block|{
name|type
operator|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_PTR
operator|||
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_REF
comment|/* In C you can dereference an array to get the 1st elt.  */
operator|||
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_ARRAY
condition|)
return|return
name|value_zero
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|lval_memory
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_INT
condition|)
comment|/* GDB allows dereferencing an int.  */
return|return
name|value_zero
argument_list|(
name|builtin_type_int
argument_list|,
name|lval_memory
argument_list|)
return|;
else|else
name|error
argument_list|(
literal|"Attempt to take contents of a non-pointer value."
argument_list|)
expr_stmt|;
block|}
return|return
name|value_ind
argument_list|(
name|arg1
argument_list|)
return|;
case|case
name|UNOP_ADDR
case|:
comment|/* C++: check for and handle pointer to members.  */
name|op
operator|=
name|exp
operator|->
name|elts
index|[
operator|*
name|pos
index|]
operator|.
name|opcode
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
block|{
if|if
condition|(
name|op
operator|==
name|OP_SCOPE
condition|)
block|{
name|int
name|temm
init|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|3
index|]
operator|.
name|longconst
argument_list|)
decl_stmt|;
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|3
operator|+
name|BYTES_TO_EXP_ELEM
argument_list|(
name|temm
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|EVAL_SKIP
argument_list|)
expr_stmt|;
goto|goto
name|nosideret
goto|;
block|}
else|else
block|{
name|struct
name|value
modifier|*
name|retvalp
init|=
name|evaluate_subexp_for_address
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
decl_stmt|;
comment|/* If HP aCC object, use bias for pointers to members */
if|if
condition|(
name|hp_som_som_object_present
operator|&&
operator|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|retvalp
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_PTR
operator|)
operator|&&
operator|(
name|TYPE_CODE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|retvalp
argument_list|)
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_MEMBER
operator|)
condition|)
block|{
name|unsigned
name|int
modifier|*
name|ptr
init|=
operator|(
name|unsigned
name|int
operator|*
operator|)
name|VALUE_CONTENTS
argument_list|(
name|retvalp
argument_list|)
decl_stmt|;
comment|/* forces evaluation */
operator|*
name|ptr
operator||=
literal|0x20000000
expr_stmt|;
comment|/* set 29th bit */
block|}
return|return
name|retvalp
return|;
block|}
case|case
name|UNOP_SIZEOF
case|:
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
block|{
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|EVAL_SKIP
argument_list|)
expr_stmt|;
goto|goto
name|nosideret
goto|;
block|}
return|return
name|evaluate_subexp_for_sizeof
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|)
return|;
case|case
name|UNOP_CAST
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|2
expr_stmt|;
name|type
operator|=
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|type
expr_stmt|;
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|type
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
if|if
condition|(
name|type
operator|!=
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
condition|)
name|arg1
operator|=
name|value_cast
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
return|return
name|arg1
return|;
case|case
name|UNOP_MEMVAL
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|2
expr_stmt|;
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|expect_type
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
if|if
condition|(
name|noside
operator|==
name|EVAL_AVOID_SIDE_EFFECTS
condition|)
return|return
name|value_zero
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|type
argument_list|,
name|lval_memory
argument_list|)
return|;
else|else
return|return
name|value_at_lazy
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|type
argument_list|,
name|value_as_address
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|NULL
argument_list|)
return|;
case|case
name|UNOP_PREINCREMENT
case|:
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|expect_type
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
operator|||
name|noside
operator|==
name|EVAL_AVOID_SIDE_EFFECTS
condition|)
return|return
name|arg1
return|;
elseif|else
if|if
condition|(
name|unop_user_defined_p
argument_list|(
name|op
argument_list|,
name|arg1
argument_list|)
condition|)
block|{
return|return
name|value_x_unop
argument_list|(
name|arg1
argument_list|,
name|op
argument_list|,
name|noside
argument_list|)
return|;
block|}
else|else
block|{
name|arg2
operator|=
name|value_add
argument_list|(
name|arg1
argument_list|,
name|value_from_longest
argument_list|(
name|builtin_type_char
argument_list|,
operator|(
name|LONGEST
operator|)
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|value_assign
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
return|;
block|}
case|case
name|UNOP_PREDECREMENT
case|:
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|expect_type
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
operator|||
name|noside
operator|==
name|EVAL_AVOID_SIDE_EFFECTS
condition|)
return|return
name|arg1
return|;
elseif|else
if|if
condition|(
name|unop_user_defined_p
argument_list|(
name|op
argument_list|,
name|arg1
argument_list|)
condition|)
block|{
return|return
name|value_x_unop
argument_list|(
name|arg1
argument_list|,
name|op
argument_list|,
name|noside
argument_list|)
return|;
block|}
else|else
block|{
name|arg2
operator|=
name|value_sub
argument_list|(
name|arg1
argument_list|,
name|value_from_longest
argument_list|(
name|builtin_type_char
argument_list|,
operator|(
name|LONGEST
operator|)
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|value_assign
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
return|;
block|}
case|case
name|UNOP_POSTINCREMENT
case|:
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|expect_type
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
operator|||
name|noside
operator|==
name|EVAL_AVOID_SIDE_EFFECTS
condition|)
return|return
name|arg1
return|;
elseif|else
if|if
condition|(
name|unop_user_defined_p
argument_list|(
name|op
argument_list|,
name|arg1
argument_list|)
condition|)
block|{
return|return
name|value_x_unop
argument_list|(
name|arg1
argument_list|,
name|op
argument_list|,
name|noside
argument_list|)
return|;
block|}
else|else
block|{
name|arg2
operator|=
name|value_add
argument_list|(
name|arg1
argument_list|,
name|value_from_longest
argument_list|(
name|builtin_type_char
argument_list|,
operator|(
name|LONGEST
operator|)
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|value_assign
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
return|return
name|arg1
return|;
block|}
case|case
name|UNOP_POSTDECREMENT
case|:
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|expect_type
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
operator|||
name|noside
operator|==
name|EVAL_AVOID_SIDE_EFFECTS
condition|)
return|return
name|arg1
return|;
elseif|else
if|if
condition|(
name|unop_user_defined_p
argument_list|(
name|op
argument_list|,
name|arg1
argument_list|)
condition|)
block|{
return|return
name|value_x_unop
argument_list|(
name|arg1
argument_list|,
name|op
argument_list|,
name|noside
argument_list|)
return|;
block|}
else|else
block|{
name|arg2
operator|=
name|value_sub
argument_list|(
name|arg1
argument_list|,
name|value_from_longest
argument_list|(
name|builtin_type_char
argument_list|,
operator|(
name|LONGEST
operator|)
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|value_assign
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
return|return
name|arg1
return|;
block|}
case|case
name|OP_THIS
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|1
expr_stmt|;
return|return
name|value_of_this
argument_list|(
literal|1
argument_list|)
return|;
case|case
name|OP_OBJC_SELF
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|1
expr_stmt|;
return|return
name|value_of_local
argument_list|(
literal|"self"
argument_list|,
literal|1
argument_list|)
return|;
case|case
name|OP_TYPE
case|:
name|error
argument_list|(
literal|"Attempt to use a type name as an expression"
argument_list|)
expr_stmt|;
default|default:
comment|/* Removing this case and compiling with gcc -Wall reveals that          a lot of cases are hitting this case.  Some of these should          probably be removed from expression.h; others are legitimate          expressions which are (apparently) not fully implemented.           If there are any cases landing here which mean a user error,          then they should be separate cases, with more descriptive          error messages.  */
name|error
argument_list|(
literal|"\ GDB does not (yet) know how to evaluate that kind of expression"
argument_list|)
expr_stmt|;
block|}
name|nosideret
label|:
return|return
name|value_from_longest
argument_list|(
name|builtin_type_long
argument_list|,
operator|(
name|LONGEST
operator|)
literal|1
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Evaluate a subexpression of EXP, at index *POS,    and return the address of that subexpression.    Advance *POS over the subexpression.    If the subexpression isn't an lvalue, get an error.    NOSIDE may be EVAL_AVOID_SIDE_EFFECTS;    then only the type of the result need be correct.  */
end_comment

begin_function
specifier|static
name|struct
name|value
modifier|*
name|evaluate_subexp_for_address
parameter_list|(
name|struct
name|expression
modifier|*
name|exp
parameter_list|,
name|int
modifier|*
name|pos
parameter_list|,
name|enum
name|noside
name|noside
parameter_list|)
block|{
name|enum
name|exp_opcode
name|op
decl_stmt|;
name|int
name|pc
decl_stmt|;
name|struct
name|symbol
modifier|*
name|var
decl_stmt|;
name|pc
operator|=
operator|(
operator|*
name|pos
operator|)
expr_stmt|;
name|op
operator|=
name|exp
operator|->
name|elts
index|[
name|pc
index|]
operator|.
name|opcode
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|UNOP_IND
case|:
operator|(
operator|*
name|pos
operator|)
operator|++
expr_stmt|;
return|return
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
return|;
case|case
name|UNOP_MEMVAL
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|3
expr_stmt|;
return|return
name|value_cast
argument_list|(
name|lookup_pointer_type
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|type
argument_list|)
argument_list|,
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
argument_list|)
return|;
case|case
name|OP_VAR_VALUE
case|:
name|var
operator|=
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|symbol
expr_stmt|;
comment|/* C++: The "address" of a reference should yield the address        * of the object pointed to. Let value_addr() deal with it. */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|var
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_REF
condition|)
goto|goto
name|default_case
goto|;
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_AVOID_SIDE_EFFECTS
condition|)
block|{
name|struct
name|type
modifier|*
name|type
init|=
name|lookup_pointer_type
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|var
argument_list|)
argument_list|)
decl_stmt|;
name|enum
name|address_class
name|sym_class
init|=
name|SYMBOL_CLASS
argument_list|(
name|var
argument_list|)
decl_stmt|;
if|if
condition|(
name|sym_class
operator|==
name|LOC_CONST
operator|||
name|sym_class
operator|==
name|LOC_CONST_BYTES
operator|||
name|sym_class
operator|==
name|LOC_REGISTER
operator|||
name|sym_class
operator|==
name|LOC_REGPARM
condition|)
name|error
argument_list|(
literal|"Attempt to take address of register or constant."
argument_list|)
expr_stmt|;
return|return
name|value_zero
argument_list|(
name|type
argument_list|,
name|not_lval
argument_list|)
return|;
block|}
else|else
return|return
name|locate_var_value
argument_list|(
name|var
argument_list|,
name|block_innermost_frame
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|block
argument_list|)
argument_list|)
return|;
default|default:
name|default_case
label|:
if|if
condition|(
name|noside
operator|==
name|EVAL_AVOID_SIDE_EFFECTS
condition|)
block|{
name|struct
name|value
modifier|*
name|x
init|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
decl_stmt|;
if|if
condition|(
name|VALUE_LVAL
argument_list|(
name|x
argument_list|)
operator|==
name|lval_memory
condition|)
return|return
name|value_zero
argument_list|(
name|lookup_pointer_type
argument_list|(
name|VALUE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|not_lval
argument_list|)
return|;
else|else
name|error
argument_list|(
literal|"Attempt to take address of non-lval"
argument_list|)
expr_stmt|;
block|}
return|return
name|value_addr
argument_list|(
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Evaluate like `evaluate_subexp' except coercing arrays to pointers.    When used in contexts where arrays will be coerced anyway, this is    equivalent to `evaluate_subexp' but much faster because it avoids    actually fetching array contents (perhaps obsolete now that we have    VALUE_LAZY).     Note that we currently only do the coercion for C expressions, where    arrays are zero based and the coercion is correct.  For other languages,    with nonzero based arrays, coercion loses.  Use CAST_IS_CONVERSION    to decide if coercion is appropriate.   */
end_comment

begin_function
name|struct
name|value
modifier|*
name|evaluate_subexp_with_coercion
parameter_list|(
name|struct
name|expression
modifier|*
name|exp
parameter_list|,
name|int
modifier|*
name|pos
parameter_list|,
name|enum
name|noside
name|noside
parameter_list|)
block|{
name|enum
name|exp_opcode
name|op
decl_stmt|;
name|int
name|pc
decl_stmt|;
name|struct
name|value
modifier|*
name|val
decl_stmt|;
name|struct
name|symbol
modifier|*
name|var
decl_stmt|;
name|pc
operator|=
operator|(
operator|*
name|pos
operator|)
expr_stmt|;
name|op
operator|=
name|exp
operator|->
name|elts
index|[
name|pc
index|]
operator|.
name|opcode
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|OP_VAR_VALUE
case|:
name|var
operator|=
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|symbol
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|check_typedef
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|var
argument_list|)
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_ARRAY
operator|&&
name|CAST_IS_CONVERSION
condition|)
block|{
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|4
expr_stmt|;
name|val
operator|=
name|locate_var_value
argument_list|(
name|var
argument_list|,
name|block_innermost_frame
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|block
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|value_cast
argument_list|(
name|lookup_pointer_type
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|check_typedef
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|var
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|val
argument_list|)
return|;
block|}
comment|/* FALLTHROUGH */
default|default:
return|return
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Evaluate a subexpression of EXP, at index *POS,    and return a value for the size of that subexpression.    Advance *POS over the subexpression.  */
end_comment

begin_function
specifier|static
name|struct
name|value
modifier|*
name|evaluate_subexp_for_sizeof
parameter_list|(
name|struct
name|expression
modifier|*
name|exp
parameter_list|,
name|int
modifier|*
name|pos
parameter_list|)
block|{
name|enum
name|exp_opcode
name|op
decl_stmt|;
name|int
name|pc
decl_stmt|;
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|struct
name|value
modifier|*
name|val
decl_stmt|;
name|pc
operator|=
operator|(
operator|*
name|pos
operator|)
expr_stmt|;
name|op
operator|=
name|exp
operator|->
name|elts
index|[
name|pc
index|]
operator|.
name|opcode
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
comment|/* This case is handled specially          so that we avoid creating a value for the result type.          If the result type is very big, it's desirable not to          create a value unnecessarily.  */
case|case
name|UNOP_IND
case|:
operator|(
operator|*
name|pos
operator|)
operator|++
expr_stmt|;
name|val
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|EVAL_AVOID_SIDE_EFFECTS
argument_list|)
expr_stmt|;
name|type
operator|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_CODE_PTR
operator|&&
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_CODE_REF
operator|&&
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_CODE_ARRAY
condition|)
name|error
argument_list|(
literal|"Attempt to take contents of a non-pointer value."
argument_list|)
expr_stmt|;
name|type
operator|=
name|check_typedef
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|value_from_longest
argument_list|(
name|builtin_type_int
argument_list|,
operator|(
name|LONGEST
operator|)
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
case|case
name|UNOP_MEMVAL
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|3
expr_stmt|;
name|type
operator|=
name|check_typedef
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
return|return
name|value_from_longest
argument_list|(
name|builtin_type_int
argument_list|,
operator|(
name|LONGEST
operator|)
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
case|case
name|OP_VAR_VALUE
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|4
expr_stmt|;
name|type
operator|=
name|check_typedef
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|value_from_longest
argument_list|(
name|builtin_type_int
argument_list|,
operator|(
name|LONGEST
operator|)
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
default|default:
name|val
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|EVAL_AVOID_SIDE_EFFECTS
argument_list|)
expr_stmt|;
return|return
name|value_from_longest
argument_list|(
name|builtin_type_int
argument_list|,
operator|(
name|LONGEST
operator|)
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Parse a type expression in the string [P..P+LENGTH). */
end_comment

begin_function
name|struct
name|type
modifier|*
name|parse_and_eval_type
parameter_list|(
name|char
modifier|*
name|p
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|char
modifier|*
name|tmp
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|length
operator|+
literal|4
argument_list|)
decl_stmt|;
name|struct
name|expression
modifier|*
name|expr
decl_stmt|;
name|tmp
index|[
literal|0
index|]
operator|=
literal|'('
expr_stmt|;
name|memcpy
argument_list|(
name|tmp
operator|+
literal|1
argument_list|,
name|p
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|tmp
index|[
name|length
operator|+
literal|1
index|]
operator|=
literal|')'
expr_stmt|;
name|tmp
index|[
name|length
operator|+
literal|2
index|]
operator|=
literal|'0'
expr_stmt|;
name|tmp
index|[
name|length
operator|+
literal|3
index|]
operator|=
literal|'\0'
expr_stmt|;
name|expr
operator|=
name|parse_expression
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
operator|->
name|elts
index|[
literal|0
index|]
operator|.
name|opcode
operator|!=
name|UNOP_CAST
condition|)
name|error
argument_list|(
literal|"Internal error in eval_type."
argument_list|)
expr_stmt|;
return|return
name|expr
operator|->
name|elts
index|[
literal|1
index|]
operator|.
name|type
return|;
block|}
end_function

begin_function
name|int
name|calc_f77_array_dims
parameter_list|(
name|struct
name|type
modifier|*
name|array_type
parameter_list|)
block|{
name|int
name|ndimen
init|=
literal|1
decl_stmt|;
name|struct
name|type
modifier|*
name|tmp_type
decl_stmt|;
if|if
condition|(
operator|(
name|TYPE_CODE
argument_list|(
name|array_type
argument_list|)
operator|!=
name|TYPE_CODE_ARRAY
operator|)
condition|)
name|error
argument_list|(
literal|"Can't get dimensions for a non-array type"
argument_list|)
expr_stmt|;
name|tmp_type
operator|=
name|array_type
expr_stmt|;
while|while
condition|(
operator|(
name|tmp_type
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|tmp_type
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|tmp_type
argument_list|)
operator|==
name|TYPE_CODE_ARRAY
condition|)
operator|++
name|ndimen
expr_stmt|;
block|}
return|return
name|ndimen
return|;
block|}
end_function

end_unit

