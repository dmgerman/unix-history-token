begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* GDB interface to ARM RDI library.     Copyright 1997, 1998, 1999, 2000, 2001, 2002 Free Software    Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"gdb-stabs.h"
end_include

begin_include
include|#
directive|include
file|"gdbthread.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"breakpoint.h"
end_include

begin_include
include|#
directive|include
file|"completer.h"
end_include

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_include
include|#
directive|include
file|"arm-tdep.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"rdi-share/ardi.h"
end_include

begin_include
include|#
directive|include
file|"rdi-share/adp.h"
end_include

begin_include
include|#
directive|include
file|"rdi-share/hsys.h"
end_include

begin_function_decl
specifier|extern
name|int
name|isascii
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Prototypes for local functions */
end_comment

begin_function_decl
specifier|static
name|void
name|arm_rdi_files_info
parameter_list|(
name|struct
name|target_ops
modifier|*
name|ignore
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|arm_rdi_xfer_memory
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|should_write
parameter_list|,
name|struct
name|mem_attrib
modifier|*
name|attrib
parameter_list|,
name|struct
name|target_ops
modifier|*
name|target
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arm_rdi_prepare_to_store
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arm_rdi_fetch_registers
parameter_list|(
name|int
name|regno
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arm_rdi_resume
parameter_list|(
name|ptid_t
name|pid
parameter_list|,
name|int
name|step
parameter_list|,
name|enum
name|target_signal
name|siggnal
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|arm_rdi_start_remote
parameter_list|(
name|char
modifier|*
name|dummy
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arm_rdi_open
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|from_tty
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arm_rdi_create_inferior
parameter_list|(
name|char
modifier|*
name|exec_file
parameter_list|,
name|char
modifier|*
name|args
parameter_list|,
name|char
modifier|*
modifier|*
name|env
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arm_rdi_close
parameter_list|(
name|int
name|quitting
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arm_rdi_store_registers
parameter_list|(
name|int
name|regno
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arm_rdi_mourn
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arm_rdi_send
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ptid_t
name|arm_rdi_wait
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
name|struct
name|target_waitstatus
modifier|*
name|status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arm_rdi_kill
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arm_rdi_detach
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arm_rdi_interrupt
parameter_list|(
name|int
name|signo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arm_rdi_interrupt_twice
parameter_list|(
name|int
name|signo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|interrupt_query
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|arm_rdi_insert_breakpoint
parameter_list|(
name|CORE_ADDR
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|arm_rdi_remove_breakpoint
parameter_list|(
name|CORE_ADDR
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|rdi_error_message
parameter_list|(
name|int
name|err
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|target_signal
name|rdi_error_signal
parameter_list|(
name|int
name|err
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Global variables.  */
end_comment

begin_decl_stmt
name|struct
name|target_ops
name|arm_rdi_ops
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|Dbg_ConfigBlock
name|gdb_config
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|Dbg_HostosInterface
name|gdb_hostif
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|max_load_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|execute_status
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Send heatbeat packets? */
end_comment

begin_decl_stmt
specifier|static
name|int
name|rdi_heartbeat
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Target has ROM at address 0. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|rom_at_zero
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Enable logging? */
end_comment

begin_decl_stmt
specifier|static
name|int
name|log_enable
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name of the log file. Default is "rdi.log". */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|log_filename
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A little list of breakpoints that have been set.  */
end_comment

begin_struct
specifier|static
struct|struct
name|local_bp_list_entry
block|{
name|CORE_ADDR
name|addr
decl_stmt|;
name|PointHandle
name|point
decl_stmt|;
name|struct
name|local_bp_list_entry
modifier|*
name|next
decl_stmt|;
block|}
modifier|*
name|local_bp_list
struct|;
end_struct

begin_escape
end_escape

begin_comment
comment|/* Stub for catch_errors.  */
end_comment

begin_function
specifier|static
name|int
name|arm_rdi_start_remote
parameter_list|(
name|char
modifier|*
name|dummy
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Helper callbacks for the "host interface" structure.  RDI functions call    these to forward output from the target system and so forth.  */
end_comment

begin_function
name|void
name|voiddummy
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stdout
argument_list|,
literal|"void dummy\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|myprint
parameter_list|(
name|PTR
name|arg
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
name|vfprintf_unfiltered
argument_list|(
name|gdb_stdout
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mywritec
parameter_list|(
name|PTR
name|arg
parameter_list|,
name|int
name|c
parameter_list|)
block|{
if|if
condition|(
name|isascii
argument_list|(
name|c
argument_list|)
condition|)
name|fputc_unfiltered
argument_list|(
name|c
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mywrite
parameter_list|(
name|PTR
name|arg
parameter_list|,
name|char
specifier|const
modifier|*
name|buffer
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|e
decl_stmt|;
name|e
operator|=
operator|(
name|char
operator|*
operator|)
name|buffer
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|isascii
argument_list|(
operator|(
name|int
operator|)
operator|*
name|e
argument_list|)
condition|)
block|{
name|fputc_unfiltered
argument_list|(
operator|(
name|int
operator|)
operator|*
name|e
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|e
operator|++
expr_stmt|;
block|}
block|}
return|return
name|len
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mypause
parameter_list|(
name|PTR
name|arg
parameter_list|)
block|{ }
end_function

begin_comment
comment|/* These last two are tricky as we have to handle the special case of    being interrupted more carefully */
end_comment

begin_function
specifier|static
name|int
name|myreadc
parameter_list|(
name|PTR
name|arg
parameter_list|)
block|{
return|return
name|fgetc
argument_list|(
name|stdin
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|mygets
parameter_list|(
name|PTR
name|arg
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|,
name|int
name|len
parameter_list|)
block|{
return|return
name|fgets
argument_list|(
name|buffer
argument_list|,
name|len
argument_list|,
name|stdin
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Prevent multiple calls to angel_RDI_close().  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|closed_already
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Open a connection to a remote debugger.  NAME is the filename used    for communication.  */
end_comment

begin_function
specifier|static
name|void
name|arm_rdi_open
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|int
name|rslt
decl_stmt|,
name|i
decl_stmt|;
name|unsigned
name|long
name|arg1
decl_stmt|,
name|arg2
decl_stmt|;
name|char
modifier|*
name|openArgs
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|devName
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"To open an RDI connection, you need to specify what serial\n\ device is attached to the remote system (e.g. /dev/ttya)."
argument_list|)
expr_stmt|;
comment|/* split name after whitespace, pass tail as arg to open command */
name|devName
operator|=
name|xstrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|devName
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
block|{
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
operator|++
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
condition|)
operator|++
name|p
expr_stmt|;
name|openArgs
operator|=
name|p
expr_stmt|;
block|}
comment|/* Make the basic low-level connection.  */
name|arm_rdi_close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|rslt
operator|=
name|Adp_OpenDevice
argument_list|(
name|devName
argument_list|,
name|openArgs
argument_list|,
name|rdi_heartbeat
argument_list|)
expr_stmt|;
if|if
condition|(
name|rslt
operator|!=
name|adp_ok
condition|)
name|error
argument_list|(
literal|"Could not open device \"%s\""
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|gdb_config
operator|.
name|bytesex
operator|=
literal|2
operator||
operator|(
name|TARGET_BYTE_ORDER
operator|==
name|BFD_ENDIAN_BIG
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
name|gdb_config
operator|.
name|fpe
operator|=
literal|1
expr_stmt|;
name|gdb_config
operator|.
name|rditype
operator|=
literal|2
expr_stmt|;
name|gdb_config
operator|.
name|heartbeat_on
operator|=
literal|1
expr_stmt|;
name|gdb_config
operator|.
name|flags
operator|=
literal|2
expr_stmt|;
name|gdb_hostif
operator|.
name|dbgprint
operator|=
name|myprint
expr_stmt|;
name|gdb_hostif
operator|.
name|dbgpause
operator|=
name|mypause
expr_stmt|;
name|gdb_hostif
operator|.
name|dbgarg
operator|=
name|NULL
expr_stmt|;
name|gdb_hostif
operator|.
name|writec
operator|=
name|mywritec
expr_stmt|;
name|gdb_hostif
operator|.
name|readc
operator|=
name|myreadc
expr_stmt|;
name|gdb_hostif
operator|.
name|write
operator|=
name|mywrite
expr_stmt|;
name|gdb_hostif
operator|.
name|gets
operator|=
name|mygets
expr_stmt|;
name|gdb_hostif
operator|.
name|hostosarg
operator|=
name|NULL
expr_stmt|;
name|gdb_hostif
operator|.
name|reset
operator|=
name|voiddummy
expr_stmt|;
name|rslt
operator|=
name|angel_RDI_open
argument_list|(
literal|10
argument_list|,
operator|&
name|gdb_config
argument_list|,
operator|&
name|gdb_hostif
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rslt
operator|==
name|RDIError_BigEndian
operator|||
name|rslt
operator|==
name|RDIError_LittleEndian
condition|)
empty_stmt|;
comment|/* do nothing, this is the expected return */
elseif|else
if|if
condition|(
name|rslt
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"RDI_open: %s\n"
argument_list|,
name|rdi_error_message
argument_list|(
name|rslt
argument_list|)
argument_list|)
expr_stmt|;
name|Adp_CloseDevice
argument_list|()
expr_stmt|;
name|error
argument_list|(
literal|"RDI_open failed\n"
argument_list|)
expr_stmt|;
block|}
name|rslt
operator|=
name|angel_RDI_info
argument_list|(
name|RDIInfo_Target
argument_list|,
operator|&
name|arg1
argument_list|,
operator|&
name|arg2
argument_list|)
expr_stmt|;
if|if
condition|(
name|rslt
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"RDI_info: %s\n"
argument_list|,
name|rdi_error_message
argument_list|(
name|rslt
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|rslt
operator|=
name|angel_RDI_info
argument_list|(
name|RDIInfo_Points
argument_list|,
operator|&
name|arg1
argument_list|,
operator|&
name|arg2
argument_list|)
expr_stmt|;
if|if
condition|(
name|rslt
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"RDI_info: %s\n"
argument_list|,
name|rdi_error_message
argument_list|(
name|rslt
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|rslt
operator|=
name|angel_RDI_info
argument_list|(
name|RDIInfo_Step
argument_list|,
operator|&
name|arg1
argument_list|,
operator|&
name|arg2
argument_list|)
expr_stmt|;
if|if
condition|(
name|rslt
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"RDI_info: %s\n"
argument_list|,
name|rdi_error_message
argument_list|(
name|rslt
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|rslt
operator|=
name|angel_RDI_info
argument_list|(
name|RDIInfo_CoPro
argument_list|,
operator|&
name|arg1
argument_list|,
operator|&
name|arg2
argument_list|)
expr_stmt|;
if|if
condition|(
name|rslt
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"RDI_info: %s\n"
argument_list|,
name|rdi_error_message
argument_list|(
name|rslt
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|rslt
operator|=
name|angel_RDI_info
argument_list|(
name|RDIInfo_SemiHosting
argument_list|,
operator|&
name|arg1
argument_list|,
operator|&
name|arg2
argument_list|)
expr_stmt|;
if|if
condition|(
name|rslt
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"RDI_info: %s\n"
argument_list|,
name|rdi_error_message
argument_list|(
name|rslt
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|rslt
operator|=
name|angel_RDI_info
argument_list|(
name|RDIInfo_GetLoadSize
argument_list|,
operator|&
name|arg1
argument_list|,
operator|&
name|arg2
argument_list|)
expr_stmt|;
if|if
condition|(
name|rslt
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"RDI_info: %s\n"
argument_list|,
name|rdi_error_message
argument_list|(
name|rslt
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|max_load_size
operator|=
name|arg1
expr_stmt|;
name|push_target
argument_list|(
operator|&
name|arm_rdi_ops
argument_list|)
expr_stmt|;
name|target_fetch_registers
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|rslt
operator|=
name|angel_RDI_open
argument_list|(
literal|1
argument_list|,
operator|&
name|gdb_config
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rslt
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"RDI_open: %s\n"
argument_list|,
name|rdi_error_message
argument_list|(
name|rslt
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|arg1
operator|=
name|rom_at_zero
condition|?
literal|0x0
else|:
literal|0x13b
expr_stmt|;
name|rslt
operator|=
name|angel_RDI_info
argument_list|(
name|RDIVector_Catch
argument_list|,
operator|&
name|arg1
argument_list|,
operator|&
name|arg2
argument_list|)
expr_stmt|;
if|if
condition|(
name|rslt
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"RDI_info: %s\n"
argument_list|,
name|rdi_error_message
argument_list|(
name|rslt
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|arg1
operator|=
operator|(
name|unsigned
name|long
operator|)
literal|""
expr_stmt|;
name|rslt
operator|=
name|angel_RDI_info
argument_list|(
name|RDISet_Cmdline
argument_list|,
operator|&
name|arg1
argument_list|,
operator|&
name|arg2
argument_list|)
expr_stmt|;
if|if
condition|(
name|rslt
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"RDI_info: %s\n"
argument_list|,
name|rdi_error_message
argument_list|(
name|rslt
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Clear out any existing records of breakpoints.  */
block|{
name|struct
name|local_bp_list_entry
modifier|*
name|entry
decl_stmt|,
modifier|*
name|preventry
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|entry
operator|=
name|local_bp_list
init|;
name|entry
operator|!=
name|NULL
condition|;
name|entry
operator|=
name|entry
operator|->
name|next
control|)
block|{
if|if
condition|(
name|preventry
condition|)
name|xfree
argument_list|(
name|preventry
argument_list|)
expr_stmt|;
block|}
block|}
name|printf_filtered
argument_list|(
literal|"Connected to ARM RDI target.\n"
argument_list|)
expr_stmt|;
name|closed_already
operator|=
literal|0
expr_stmt|;
name|inferior_ptid
operator|=
name|pid_to_ptid
argument_list|(
literal|42
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Start an inferior process and set inferior_ptid to its pid.    EXEC_FILE is the file to run.    ARGS is a string containing the arguments to the program.    ENV is the environment vector to pass.  Errors reported with error().    On VxWorks and various standalone systems, we ignore exec_file.  */
end_comment

begin_comment
comment|/* This is called not only when we first attach, but also when the    user types "run" after having attached.  */
end_comment

begin_function
specifier|static
name|void
name|arm_rdi_create_inferior
parameter_list|(
name|char
modifier|*
name|exec_file
parameter_list|,
name|char
modifier|*
name|args
parameter_list|,
name|char
modifier|*
modifier|*
name|env
parameter_list|)
block|{
name|int
name|len
decl_stmt|,
name|rslt
decl_stmt|;
name|unsigned
name|long
name|arg1
decl_stmt|,
name|arg2
decl_stmt|;
name|char
modifier|*
name|arg_buf
decl_stmt|;
name|CORE_ADDR
name|entry_point
decl_stmt|;
if|if
condition|(
name|exec_file
operator|==
literal|0
operator|||
name|exec_bfd
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No executable file specified."
argument_list|)
expr_stmt|;
name|entry_point
operator|=
operator|(
name|CORE_ADDR
operator|)
name|bfd_get_start_address
argument_list|(
name|exec_bfd
argument_list|)
expr_stmt|;
name|arm_rdi_kill
argument_list|()
expr_stmt|;
name|remove_breakpoints
argument_list|()
expr_stmt|;
name|init_wait_for_inferior
argument_list|()
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|exec_file
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|args
argument_list|)
operator|+
literal|1
operator|+
comment|/*slop */
literal|10
expr_stmt|;
name|arg_buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|arg_buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strcat
argument_list|(
name|arg_buf
argument_list|,
name|exec_file
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|arg_buf
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|arg_buf
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|inferior_ptid
operator|=
name|pid_to_ptid
argument_list|(
literal|42
argument_list|)
expr_stmt|;
name|insert_breakpoints
argument_list|()
expr_stmt|;
comment|/* Needed to get correct instruction in cache */
if|if
condition|(
name|env
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
operator|*
name|env
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|env
argument_list|,
literal|"MEMSIZE="
argument_list|,
sizeof|sizeof
argument_list|(
literal|"MEMSIZE="
argument_list|)
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|unsigned
name|long
name|top_of_memory
decl_stmt|;
name|char
modifier|*
name|end_of_num
decl_stmt|;
comment|/* Set up memory limit */
name|top_of_memory
operator|=
name|strtoul
argument_list|(
operator|*
name|env
operator|+
sizeof|sizeof
argument_list|(
literal|"MEMSIZE="
argument_list|)
operator|-
literal|1
argument_list|,
operator|&
name|end_of_num
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Setting top-of-memory to 0x%lx\n"
argument_list|,
name|top_of_memory
argument_list|)
expr_stmt|;
name|rslt
operator|=
name|angel_RDI_info
argument_list|(
name|RDIInfo_SetTopMem
argument_list|,
operator|&
name|top_of_memory
argument_list|,
operator|&
name|arg2
argument_list|)
expr_stmt|;
if|if
condition|(
name|rslt
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"RDI_info: %s\n"
argument_list|,
name|rdi_error_message
argument_list|(
name|rslt
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|env
operator|++
expr_stmt|;
block|}
block|}
name|arg1
operator|=
operator|(
name|unsigned
name|long
operator|)
name|arg_buf
expr_stmt|;
name|rslt
operator|=
name|angel_RDI_info
argument_list|(
name|RDISet_Cmdline
argument_list|,
comment|/*&arg1 */
operator|(
name|unsigned
name|long
operator|*
operator|)
name|arg_buf
argument_list|,
operator|&
name|arg2
argument_list|)
expr_stmt|;
if|if
condition|(
name|rslt
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"RDI_info: %s\n"
argument_list|,
name|rdi_error_message
argument_list|(
name|rslt
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|proceed
argument_list|(
name|entry_point
argument_list|,
name|TARGET_SIGNAL_DEFAULT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This takes a program previously attached to and detaches it.  After    this is done, GDB can be used to debug some other program.  We    better not have left any breakpoints in the target program or it'll    die when it hits one.  */
end_comment

begin_function
specifier|static
name|void
name|arm_rdi_detach
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|pop_target
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clean up connection to a remote debugger.  */
end_comment

begin_function
specifier|static
name|void
name|arm_rdi_close
parameter_list|(
name|int
name|quitting
parameter_list|)
block|{
name|int
name|rslt
decl_stmt|;
if|if
condition|(
operator|!
name|closed_already
condition|)
block|{
name|rslt
operator|=
name|angel_RDI_close
argument_list|()
expr_stmt|;
if|if
condition|(
name|rslt
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"RDI_close: %s\n"
argument_list|,
name|rdi_error_message
argument_list|(
name|rslt
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|closed_already
operator|=
literal|1
expr_stmt|;
name|inferior_ptid
operator|=
name|null_ptid
expr_stmt|;
name|Adp_CloseDevice
argument_list|()
expr_stmt|;
name|generic_mourn_inferior
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Tell the remote machine to resume.  */
end_comment

begin_function
specifier|static
name|void
name|arm_rdi_resume
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
name|int
name|step
parameter_list|,
name|enum
name|target_signal
name|siggnal
parameter_list|)
block|{
name|int
name|rslt
decl_stmt|;
name|PointHandle
name|point
decl_stmt|;
if|if
condition|(
literal|0
comment|/* turn on when hardware supports single-stepping */
condition|)
block|{
name|rslt
operator|=
name|angel_RDI_step
argument_list|(
literal|1
argument_list|,
operator|&
name|point
argument_list|)
expr_stmt|;
if|if
condition|(
name|rslt
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"RDI_step: %s\n"
argument_list|,
name|rdi_error_message
argument_list|(
name|rslt
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|char
name|handle
index|[
literal|4
index|]
decl_stmt|;
name|CORE_ADDR
name|pc
decl_stmt|;
if|if
condition|(
name|step
condition|)
block|{
name|pc
operator|=
name|read_register
argument_list|(
name|ARM_PC_REGNUM
argument_list|)
expr_stmt|;
name|pc
operator|=
name|arm_get_next_pc
argument_list|(
name|pc
argument_list|)
expr_stmt|;
name|arm_rdi_insert_breakpoint
argument_list|(
name|pc
argument_list|,
name|handle
argument_list|)
expr_stmt|;
block|}
name|execute_status
operator|=
name|rslt
operator|=
name|angel_RDI_execute
argument_list|(
operator|&
name|point
argument_list|)
expr_stmt|;
if|if
condition|(
name|rslt
operator|==
name|RDIError_BreakpointReached
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|rslt
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"RDI_execute: %s\n"
argument_list|,
name|rdi_error_message
argument_list|(
name|rslt
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|step
condition|)
block|{
name|arm_rdi_remove_breakpoint
argument_list|(
name|pc
argument_list|,
name|handle
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Send ^C to target to halt it.  Target will respond, and send us a    packet.  */
end_comment

begin_function
specifier|static
name|void
name|arm_rdi_interrupt
parameter_list|(
name|int
name|signo
parameter_list|)
block|{ }
end_function

begin_function_decl
specifier|static
name|void
function_decl|(
modifier|*
name|ofunc
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* The user typed ^C twice.  */
end_comment

begin_function
specifier|static
name|void
name|arm_rdi_interrupt_twice
parameter_list|(
name|int
name|signo
parameter_list|)
block|{ }
end_function

begin_comment
comment|/* Ask the user what to do when an interrupt is received.  */
end_comment

begin_function
specifier|static
name|void
name|interrupt_query
parameter_list|(
name|void
parameter_list|)
block|{ }
end_function

begin_comment
comment|/* Wait until the remote machine stops, then return, storing status in    STATUS just as `wait' would.  Returns "pid" (though it's not clear    what, if anything, that means in the case of this target).  */
end_comment

begin_function
specifier|static
name|ptid_t
name|arm_rdi_wait
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
name|struct
name|target_waitstatus
modifier|*
name|status
parameter_list|)
block|{
name|status
operator|->
name|kind
operator|=
operator|(
name|execute_status
operator|==
name|RDIError_NoError
condition|?
name|TARGET_WAITKIND_EXITED
else|:
name|TARGET_WAITKIND_STOPPED
operator|)
expr_stmt|;
comment|/* convert stopped code from target into right signal */
name|status
operator|->
name|value
operator|.
name|sig
operator|=
name|rdi_error_signal
argument_list|(
name|execute_status
argument_list|)
expr_stmt|;
return|return
name|inferior_ptid
return|;
block|}
end_function

begin_comment
comment|/* Read the remote registers into the block REGS.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|arm_rdi_fetch_registers
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
name|int
name|rslt
decl_stmt|,
name|rdi_regmask
decl_stmt|;
name|unsigned
name|long
name|rawreg
decl_stmt|,
name|rawregs
index|[
literal|32
index|]
decl_stmt|;
name|char
name|cookedreg
index|[
literal|4
index|]
decl_stmt|;
if|if
condition|(
name|regno
operator|==
operator|-
literal|1
condition|)
block|{
name|rslt
operator|=
name|angel_RDI_CPUread
argument_list|(
literal|255
argument_list|,
literal|0x27fff
argument_list|,
name|rawregs
argument_list|)
expr_stmt|;
if|if
condition|(
name|rslt
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"RDI_CPUread: %s\n"
argument_list|,
name|rdi_error_message
argument_list|(
name|rslt
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
literal|15
condition|;
name|regno
operator|++
control|)
block|{
name|store_unsigned_integer
argument_list|(
name|cookedreg
argument_list|,
literal|4
argument_list|,
name|rawregs
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|regno
argument_list|,
operator|(
name|char
operator|*
operator|)
name|cookedreg
argument_list|)
expr_stmt|;
block|}
name|store_unsigned_integer
argument_list|(
name|cookedreg
argument_list|,
literal|4
argument_list|,
name|rawregs
index|[
literal|15
index|]
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|ARM_PS_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
name|cookedreg
argument_list|)
expr_stmt|;
name|arm_rdi_fetch_registers
argument_list|(
name|ARM_PC_REGNUM
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|regno
operator|==
name|ARM_PC_REGNUM
condition|)
name|rdi_regmask
operator|=
name|RDIReg_PC
expr_stmt|;
elseif|else
if|if
condition|(
name|regno
operator|==
name|ARM_PS_REGNUM
condition|)
name|rdi_regmask
operator|=
name|RDIReg_CPSR
expr_stmt|;
elseif|else
if|if
condition|(
name|regno
operator|<
literal|0
operator|||
name|regno
operator|>
literal|15
condition|)
block|{
name|rawreg
operator|=
literal|0
expr_stmt|;
name|supply_register
argument_list|(
name|regno
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|rawreg
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|rdi_regmask
operator|=
literal|1
operator|<<
name|regno
expr_stmt|;
name|rslt
operator|=
name|angel_RDI_CPUread
argument_list|(
literal|255
argument_list|,
name|rdi_regmask
argument_list|,
operator|&
name|rawreg
argument_list|)
expr_stmt|;
if|if
condition|(
name|rslt
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"RDI_CPUread: %s\n"
argument_list|,
name|rdi_error_message
argument_list|(
name|rslt
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|store_unsigned_integer
argument_list|(
name|cookedreg
argument_list|,
literal|4
argument_list|,
name|rawreg
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|regno
argument_list|,
operator|(
name|char
operator|*
operator|)
name|cookedreg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|arm_rdi_prepare_to_store
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Nothing to do.  */
block|}
end_function

begin_comment
comment|/* Store register REGNO, or all registers if REGNO == -1, from the contents    of REGISTERS.  FIXME: ignores errors.  */
end_comment

begin_function
specifier|static
name|void
name|arm_rdi_store_registers
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
name|int
name|rslt
decl_stmt|,
name|rdi_regmask
decl_stmt|;
comment|/* These need to be able to take 'floating point register' contents */
name|unsigned
name|long
name|rawreg
index|[
literal|3
index|]
decl_stmt|,
name|rawerreg
index|[
literal|3
index|]
decl_stmt|;
if|if
condition|(
name|regno
operator|==
operator|-
literal|1
condition|)
block|{
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|NUM_REGS
condition|;
name|regno
operator|++
control|)
name|arm_rdi_store_registers
argument_list|(
name|regno
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|read_register_gen
argument_list|(
name|regno
argument_list|,
operator|(
name|char
operator|*
operator|)
name|rawreg
argument_list|)
expr_stmt|;
comment|/* RDI manipulates data in host byte order, so convert now. */
name|store_unsigned_integer
argument_list|(
name|rawerreg
argument_list|,
literal|4
argument_list|,
name|rawreg
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|==
name|ARM_PC_REGNUM
condition|)
name|rdi_regmask
operator|=
name|RDIReg_PC
expr_stmt|;
elseif|else
if|if
condition|(
name|regno
operator|==
name|ARM_PS_REGNUM
condition|)
name|rdi_regmask
operator|=
name|RDIReg_CPSR
expr_stmt|;
elseif|else
if|if
condition|(
name|regno
operator|<
literal|0
operator|||
name|regno
operator|>
literal|15
condition|)
return|return;
else|else
name|rdi_regmask
operator|=
literal|1
operator|<<
name|regno
expr_stmt|;
name|rslt
operator|=
name|angel_RDI_CPUwrite
argument_list|(
literal|255
argument_list|,
name|rdi_regmask
argument_list|,
name|rawerreg
argument_list|)
expr_stmt|;
if|if
condition|(
name|rslt
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"RDI_CPUwrite: %s\n"
argument_list|,
name|rdi_error_message
argument_list|(
name|rslt
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read or write LEN bytes from inferior memory at MEMADDR,    transferring to or from debugger address MYADDR.  Write to inferior    if SHOULD_WRITE is nonzero.  Returns length of data written or    read; 0 for error.  TARGET is unused.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|arm_rdi_xfer_memory
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|should_write
parameter_list|,
name|struct
name|mem_attrib
modifier|*
name|attrib
parameter_list|,
name|struct
name|target_ops
modifier|*
name|target
parameter_list|)
block|{
name|int
name|rslt
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|should_write
condition|)
block|{
name|rslt
operator|=
name|angel_RDI_write
argument_list|(
name|myaddr
argument_list|,
name|memaddr
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|rslt
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"RDI_write: %s\n"
argument_list|,
name|rdi_error_message
argument_list|(
name|rslt
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|rslt
operator|=
name|angel_RDI_read
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|rslt
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"RDI_read: %s\n"
argument_list|,
name|rdi_error_message
argument_list|(
name|rslt
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
name|len
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Display random info collected from the target.  */
end_comment

begin_function
specifier|static
name|void
name|arm_rdi_files_info
parameter_list|(
name|struct
name|target_ops
modifier|*
name|ignore
parameter_list|)
block|{
name|char
modifier|*
name|file
init|=
literal|"nothing"
decl_stmt|;
name|int
name|rslt
decl_stmt|;
name|unsigned
name|long
name|arg1
decl_stmt|,
name|arg2
decl_stmt|;
name|rslt
operator|=
name|angel_RDI_info
argument_list|(
name|RDIInfo_Target
argument_list|,
operator|&
name|arg1
argument_list|,
operator|&
name|arg2
argument_list|)
expr_stmt|;
if|if
condition|(
name|rslt
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"RDI_info: %s\n"
argument_list|,
name|rdi_error_message
argument_list|(
name|rslt
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|arg1
operator|&
operator|(
literal|1
operator|<<
literal|15
operator|)
condition|)
name|printf_filtered
argument_list|(
literal|"Target supports Thumb code.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg1
operator|&
operator|(
literal|1
operator|<<
literal|14
operator|)
condition|)
name|printf_filtered
argument_list|(
literal|"Target can do profiling.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg1
operator|&
operator|(
literal|1
operator|<<
literal|4
operator|)
condition|)
name|printf_filtered
argument_list|(
literal|"Target is real hardware.\n"
argument_list|)
expr_stmt|;
name|rslt
operator|=
name|angel_RDI_info
argument_list|(
name|RDIInfo_Step
argument_list|,
operator|&
name|arg1
argument_list|,
operator|&
name|arg2
argument_list|)
expr_stmt|;
if|if
condition|(
name|rslt
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"RDI_info: %s\n"
argument_list|,
name|rdi_error_message
argument_list|(
name|rslt
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|"Target can%s single-step.\n"
argument_list|,
operator|(
name|arg1
operator|&
literal|0x4
condition|?
literal|""
else|:
literal|"not"
operator|)
argument_list|)
expr_stmt|;
name|rslt
operator|=
name|angel_RDI_info
argument_list|(
name|RDIInfo_Icebreaker
argument_list|,
operator|&
name|arg1
argument_list|,
operator|&
name|arg2
argument_list|)
expr_stmt|;
if|if
condition|(
name|rslt
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"RDI_info: %s\n"
argument_list|,
name|rdi_error_message
argument_list|(
name|rslt
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|printf_filtered
argument_list|(
literal|"Target includes an EmbeddedICE.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|arm_rdi_kill
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|rslt
decl_stmt|;
name|rslt
operator|=
name|angel_RDI_open
argument_list|(
literal|1
argument_list|,
operator|&
name|gdb_config
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rslt
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"RDI_open: %s\n"
argument_list|,
name|rdi_error_message
argument_list|(
name|rslt
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|arm_rdi_mourn_inferior
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* We remove the inserted breakpoints in case the user wants to      issue another target and load commands to rerun his application;      This is something that wouldn't work on a native target, for instance,      as the process goes away when the inferior exits, but it works with      some remote targets like this one.  That is why this is done here. */
name|remove_breakpoints
argument_list|()
expr_stmt|;
name|unpush_target
argument_list|(
operator|&
name|arm_rdi_ops
argument_list|)
expr_stmt|;
name|generic_mourn_inferior
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* While the RDI library keeps track of its own breakpoints, we need    to remember "handles" so that we can delete them later.  Since    breakpoints get used for stepping, be careful not to leak memory    here.  */
end_comment

begin_function
specifier|static
name|int
name|arm_rdi_insert_breakpoint
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|char
modifier|*
name|contents_cache
parameter_list|)
block|{
name|int
name|rslt
decl_stmt|;
name|PointHandle
name|point
decl_stmt|;
name|struct
name|local_bp_list_entry
modifier|*
name|entry
decl_stmt|;
name|int
name|type
init|=
name|RDIPoint_EQ
decl_stmt|;
if|if
condition|(
name|arm_pc_is_thumb
argument_list|(
name|addr
argument_list|)
operator|||
name|arm_pc_is_thumb_dummy
argument_list|(
name|addr
argument_list|)
condition|)
name|type
operator||=
name|RDIPoint_16Bit
expr_stmt|;
name|rslt
operator|=
name|angel_RDI_setbreak
argument_list|(
name|addr
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
operator|&
name|point
argument_list|)
expr_stmt|;
if|if
condition|(
name|rslt
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"RDI_setbreak: %s\n"
argument_list|,
name|rdi_error_message
argument_list|(
name|rslt
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|entry
operator|=
operator|(
expr|struct
name|local_bp_list_entry
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|local_bp_list_entry
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|addr
operator|=
name|addr
expr_stmt|;
name|entry
operator|->
name|point
operator|=
name|point
expr_stmt|;
name|entry
operator|->
name|next
operator|=
name|local_bp_list
expr_stmt|;
name|local_bp_list
operator|=
name|entry
expr_stmt|;
return|return
name|rslt
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|arm_rdi_remove_breakpoint
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|char
modifier|*
name|contents_cache
parameter_list|)
block|{
name|int
name|rslt
decl_stmt|;
name|PointHandle
name|point
decl_stmt|;
name|struct
name|local_bp_list_entry
modifier|*
name|entry
decl_stmt|,
modifier|*
name|preventry
decl_stmt|;
for|for
control|(
name|entry
operator|=
name|local_bp_list
init|;
name|entry
operator|!=
name|NULL
condition|;
name|entry
operator|=
name|entry
operator|->
name|next
control|)
block|{
if|if
condition|(
name|entry
operator|->
name|addr
operator|==
name|addr
condition|)
block|{
break|break;
block|}
name|preventry
operator|=
name|entry
expr_stmt|;
block|}
if|if
condition|(
name|entry
condition|)
block|{
name|rslt
operator|=
name|angel_RDI_clearbreak
argument_list|(
name|entry
operator|->
name|point
argument_list|)
expr_stmt|;
if|if
condition|(
name|rslt
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"RDI_clearbreak: %s\n"
argument_list|,
name|rdi_error_message
argument_list|(
name|rslt
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Delete the breakpoint entry locally.  */
if|if
condition|(
name|entry
operator|==
name|local_bp_list
condition|)
block|{
name|local_bp_list
operator|=
name|entry
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
name|preventry
operator|->
name|next
operator|=
name|entry
operator|->
name|next
expr_stmt|;
block|}
name|xfree
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|char
modifier|*
name|rdi_error_message
parameter_list|(
name|int
name|err
parameter_list|)
block|{
switch|switch
condition|(
name|err
condition|)
block|{
case|case
name|RDIError_NoError
case|:
return|return
literal|"no error"
return|;
case|case
name|RDIError_Reset
case|:
return|return
literal|"debuggee reset"
return|;
case|case
name|RDIError_UndefinedInstruction
case|:
return|return
literal|"undefined instruction"
return|;
case|case
name|RDIError_SoftwareInterrupt
case|:
return|return
literal|"SWI trapped"
return|;
case|case
name|RDIError_PrefetchAbort
case|:
return|return
literal|"prefetch abort, execution ran into unmapped memory?"
return|;
case|case
name|RDIError_DataAbort
case|:
return|return
literal|"data abort, no memory at specified address?"
return|;
case|case
name|RDIError_AddressException
case|:
return|return
literal|"address exception, access>26bit in 26bit mode"
return|;
case|case
name|RDIError_IRQ
case|:
return|return
literal|"IRQ, interrupt trapped"
return|;
case|case
name|RDIError_FIQ
case|:
return|return
literal|"FIQ, fast interrupt trapped"
return|;
case|case
name|RDIError_Error
case|:
return|return
literal|"a miscellaneous type of error"
return|;
case|case
name|RDIError_BranchThrough0
case|:
return|return
literal|"branch through location 0"
return|;
case|case
name|RDIError_NotInitialised
case|:
return|return
literal|"internal error, RDI_open not called first"
return|;
case|case
name|RDIError_UnableToInitialise
case|:
return|return
literal|"internal error, target world is broken"
return|;
case|case
name|RDIError_WrongByteSex
case|:
return|return
literal|"See Operator: WrongByteSex"
return|;
case|case
name|RDIError_UnableToTerminate
case|:
return|return
literal|"See Operator: Unable to Terminate"
return|;
case|case
name|RDIError_BadInstruction
case|:
return|return
literal|"bad instruction, illegal to execute this instruction"
return|;
case|case
name|RDIError_IllegalInstruction
case|:
return|return
literal|"illegal instruction, the effect of executing it is undefined"
return|;
case|case
name|RDIError_BadCPUStateSetting
case|:
return|return
literal|"internal error, tried to set SPSR of user mode"
return|;
case|case
name|RDIError_UnknownCoPro
case|:
return|return
literal|"unknown co-processor"
return|;
case|case
name|RDIError_UnknownCoProState
case|:
return|return
literal|"cannot execute co-processor request"
return|;
case|case
name|RDIError_BadCoProState
case|:
return|return
literal|"recognizably broken co-processor request"
return|;
case|case
name|RDIError_BadPointType
case|:
return|return
literal|"internal error, bad point yype"
return|;
case|case
name|RDIError_UnimplementedType
case|:
return|return
literal|"internal error, unimplemented type"
return|;
case|case
name|RDIError_BadPointSize
case|:
return|return
literal|"internal error, bad point size"
return|;
case|case
name|RDIError_UnimplementedSize
case|:
return|return
literal|"internal error, unimplemented size"
return|;
case|case
name|RDIError_NoMorePoints
case|:
return|return
literal|"last break/watch point was used"
return|;
case|case
name|RDIError_BreakpointReached
case|:
return|return
literal|"breakpoint reached"
return|;
case|case
name|RDIError_WatchpointAccessed
case|:
return|return
literal|"watchpoint accessed"
return|;
case|case
name|RDIError_NoSuchPoint
case|:
return|return
literal|"attempted to clear non-existent break/watch point"
return|;
case|case
name|RDIError_ProgramFinishedInStep
case|:
return|return
literal|"end of the program reached while stepping"
return|;
case|case
name|RDIError_UserInterrupt
case|:
return|return
literal|"you pressed Escape"
return|;
case|case
name|RDIError_CantSetPoint
case|:
return|return
literal|"no more break/watch points available"
return|;
case|case
name|RDIError_IncompatibleRDILevels
case|:
return|return
literal|"incompatible RDI levels"
return|;
case|case
name|RDIError_LittleEndian
case|:
return|return
literal|"debuggee is little endian"
return|;
case|case
name|RDIError_BigEndian
case|:
return|return
literal|"debuggee is big endian"
return|;
case|case
name|RDIError_SoftInitialiseError
case|:
return|return
literal|"recoverable error in RDI initialization"
return|;
case|case
name|RDIError_InsufficientPrivilege
case|:
return|return
literal|"internal error, supervisor state not accessible to monitor"
return|;
case|case
name|RDIError_UnimplementedMessage
case|:
return|return
literal|"internal error, unimplemented message"
return|;
case|case
name|RDIError_UndefinedMessage
case|:
return|return
literal|"internal error, undefined message"
return|;
default|default:
return|return
literal|"undefined error message, should reset target"
return|;
block|}
block|}
end_function

begin_comment
comment|/* Convert the ARM error messages to signals that GDB knows about.  */
end_comment

begin_function
specifier|static
name|enum
name|target_signal
name|rdi_error_signal
parameter_list|(
name|int
name|err
parameter_list|)
block|{
switch|switch
condition|(
name|err
condition|)
block|{
case|case
name|RDIError_NoError
case|:
return|return
literal|0
return|;
case|case
name|RDIError_Reset
case|:
return|return
name|TARGET_SIGNAL_TERM
return|;
comment|/* ??? */
case|case
name|RDIError_UndefinedInstruction
case|:
return|return
name|TARGET_SIGNAL_ILL
return|;
case|case
name|RDIError_SoftwareInterrupt
case|:
case|case
name|RDIError_PrefetchAbort
case|:
case|case
name|RDIError_DataAbort
case|:
return|return
name|TARGET_SIGNAL_TRAP
return|;
case|case
name|RDIError_AddressException
case|:
return|return
name|TARGET_SIGNAL_SEGV
return|;
case|case
name|RDIError_IRQ
case|:
case|case
name|RDIError_FIQ
case|:
return|return
name|TARGET_SIGNAL_TRAP
return|;
case|case
name|RDIError_Error
case|:
return|return
name|TARGET_SIGNAL_TERM
return|;
case|case
name|RDIError_BranchThrough0
case|:
return|return
name|TARGET_SIGNAL_TRAP
return|;
case|case
name|RDIError_NotInitialised
case|:
case|case
name|RDIError_UnableToInitialise
case|:
case|case
name|RDIError_WrongByteSex
case|:
case|case
name|RDIError_UnableToTerminate
case|:
return|return
name|TARGET_SIGNAL_UNKNOWN
return|;
case|case
name|RDIError_BadInstruction
case|:
case|case
name|RDIError_IllegalInstruction
case|:
return|return
name|TARGET_SIGNAL_ILL
return|;
case|case
name|RDIError_BadCPUStateSetting
case|:
case|case
name|RDIError_UnknownCoPro
case|:
case|case
name|RDIError_UnknownCoProState
case|:
case|case
name|RDIError_BadCoProState
case|:
case|case
name|RDIError_BadPointType
case|:
case|case
name|RDIError_UnimplementedType
case|:
case|case
name|RDIError_BadPointSize
case|:
case|case
name|RDIError_UnimplementedSize
case|:
case|case
name|RDIError_NoMorePoints
case|:
return|return
name|TARGET_SIGNAL_UNKNOWN
return|;
case|case
name|RDIError_BreakpointReached
case|:
case|case
name|RDIError_WatchpointAccessed
case|:
return|return
name|TARGET_SIGNAL_TRAP
return|;
case|case
name|RDIError_NoSuchPoint
case|:
case|case
name|RDIError_ProgramFinishedInStep
case|:
return|return
name|TARGET_SIGNAL_UNKNOWN
return|;
case|case
name|RDIError_UserInterrupt
case|:
return|return
name|TARGET_SIGNAL_INT
return|;
case|case
name|RDIError_IncompatibleRDILevels
case|:
case|case
name|RDIError_LittleEndian
case|:
case|case
name|RDIError_BigEndian
case|:
case|case
name|RDIError_SoftInitialiseError
case|:
case|case
name|RDIError_InsufficientPrivilege
case|:
case|case
name|RDIError_UnimplementedMessage
case|:
case|case
name|RDIError_UndefinedMessage
case|:
default|default:
return|return
name|TARGET_SIGNAL_UNKNOWN
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|arm_rdi_stop
parameter_list|(
name|void
parameter_list|)
block|{
name|angel_RDI_stop_request
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Define the target operations structure.  */
end_comment

begin_function
specifier|static
name|void
name|init_rdi_ops
parameter_list|(
name|void
parameter_list|)
block|{
name|arm_rdi_ops
operator|.
name|to_shortname
operator|=
literal|"rdi"
expr_stmt|;
name|arm_rdi_ops
operator|.
name|to_longname
operator|=
literal|"ARM RDI"
expr_stmt|;
name|arm_rdi_ops
operator|.
name|to_doc
operator|=
literal|"Use a remote ARM-based computer; via the RDI library.\n\ Specify the serial device it is connected to (e.g. /dev/ttya)."
expr_stmt|;
name|arm_rdi_ops
operator|.
name|to_open
operator|=
name|arm_rdi_open
expr_stmt|;
name|arm_rdi_ops
operator|.
name|to_close
operator|=
name|arm_rdi_close
expr_stmt|;
name|arm_rdi_ops
operator|.
name|to_detach
operator|=
name|arm_rdi_detach
expr_stmt|;
name|arm_rdi_ops
operator|.
name|to_resume
operator|=
name|arm_rdi_resume
expr_stmt|;
name|arm_rdi_ops
operator|.
name|to_wait
operator|=
name|arm_rdi_wait
expr_stmt|;
name|arm_rdi_ops
operator|.
name|to_stop
operator|=
name|arm_rdi_stop
expr_stmt|;
name|arm_rdi_ops
operator|.
name|to_fetch_registers
operator|=
name|arm_rdi_fetch_registers
expr_stmt|;
name|arm_rdi_ops
operator|.
name|to_store_registers
operator|=
name|arm_rdi_store_registers
expr_stmt|;
name|arm_rdi_ops
operator|.
name|to_prepare_to_store
operator|=
name|arm_rdi_prepare_to_store
expr_stmt|;
name|arm_rdi_ops
operator|.
name|to_xfer_memory
operator|=
name|arm_rdi_xfer_memory
expr_stmt|;
name|arm_rdi_ops
operator|.
name|to_files_info
operator|=
name|arm_rdi_files_info
expr_stmt|;
name|arm_rdi_ops
operator|.
name|to_insert_breakpoint
operator|=
name|arm_rdi_insert_breakpoint
expr_stmt|;
name|arm_rdi_ops
operator|.
name|to_remove_breakpoint
operator|=
name|arm_rdi_remove_breakpoint
expr_stmt|;
name|arm_rdi_ops
operator|.
name|to_kill
operator|=
name|arm_rdi_kill
expr_stmt|;
name|arm_rdi_ops
operator|.
name|to_load
operator|=
name|generic_load
expr_stmt|;
name|arm_rdi_ops
operator|.
name|to_create_inferior
operator|=
name|arm_rdi_create_inferior
expr_stmt|;
name|arm_rdi_ops
operator|.
name|to_mourn_inferior
operator|=
name|arm_rdi_mourn_inferior
expr_stmt|;
name|arm_rdi_ops
operator|.
name|to_stratum
operator|=
name|process_stratum
expr_stmt|;
name|arm_rdi_ops
operator|.
name|to_has_all_memory
operator|=
literal|1
expr_stmt|;
name|arm_rdi_ops
operator|.
name|to_has_memory
operator|=
literal|1
expr_stmt|;
name|arm_rdi_ops
operator|.
name|to_has_stack
operator|=
literal|1
expr_stmt|;
name|arm_rdi_ops
operator|.
name|to_has_registers
operator|=
literal|1
expr_stmt|;
name|arm_rdi_ops
operator|.
name|to_has_execution
operator|=
literal|1
expr_stmt|;
name|arm_rdi_ops
operator|.
name|to_magic
operator|=
name|OPS_MAGIC
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rdilogfile_command
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
if|if
condition|(
operator|!
name|arg
operator|||
name|strlen
argument_list|(
name|arg
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"rdi log file is '%s'\n"
argument_list|,
name|log_filename
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|log_filename
condition|)
name|xfree
argument_list|(
name|log_filename
argument_list|)
expr_stmt|;
name|log_filename
operator|=
name|xstrdup
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|Adp_SetLogfile
argument_list|(
name|log_filename
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rdilogenable_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
if|if
condition|(
operator|!
name|args
operator|||
name|strlen
argument_list|(
name|args
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"rdi log is %s\n"
argument_list|,
name|log_enable
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|args
argument_list|,
literal|"1"
argument_list|)
operator|||
operator|!
name|strcasecmp
argument_list|(
name|args
argument_list|,
literal|"y"
argument_list|)
operator|||
operator|!
name|strcasecmp
argument_list|(
name|args
argument_list|,
literal|"yes"
argument_list|)
operator|||
operator|!
name|strcasecmp
argument_list|(
name|args
argument_list|,
literal|"on"
argument_list|)
operator|||
operator|!
name|strcasecmp
argument_list|(
name|args
argument_list|,
literal|"t"
argument_list|)
operator|||
operator|!
name|strcasecmp
argument_list|(
name|args
argument_list|,
literal|"true"
argument_list|)
condition|)
name|Adp_SetLogEnable
argument_list|(
name|log_enable
operator|=
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|args
argument_list|,
literal|"0"
argument_list|)
operator|||
operator|!
name|strcasecmp
argument_list|(
name|args
argument_list|,
literal|"n"
argument_list|)
operator|||
operator|!
name|strcasecmp
argument_list|(
name|args
argument_list|,
literal|"no"
argument_list|)
operator|||
operator|!
name|strcasecmp
argument_list|(
name|args
argument_list|,
literal|"off"
argument_list|)
operator|||
operator|!
name|strcasecmp
argument_list|(
name|args
argument_list|,
literal|"f"
argument_list|)
operator|||
operator|!
name|strcasecmp
argument_list|(
name|args
argument_list|,
literal|"false"
argument_list|)
condition|)
name|Adp_SetLogEnable
argument_list|(
name|log_enable
operator|=
literal|0
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|"rdilogenable: unrecognized argument '%s'\n"
literal|"              try y or n\n"
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_initialize_remote_rdi
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
name|init_rdi_ops
argument_list|()
expr_stmt|;
name|add_target
argument_list|(
operator|&
name|arm_rdi_ops
argument_list|)
expr_stmt|;
name|log_filename
operator|=
name|xstrdup
argument_list|(
literal|"rdi.log"
argument_list|)
expr_stmt|;
name|Adp_SetLogfile
argument_list|(
name|log_filename
argument_list|)
expr_stmt|;
name|Adp_SetLogEnable
argument_list|(
name|log_enable
argument_list|)
expr_stmt|;
name|c
operator|=
name|add_cmd
argument_list|(
literal|"rdilogfile"
argument_list|,
name|class_maintenance
argument_list|,
name|rdilogfile_command
argument_list|,
literal|"Set filename for ADP packet log.\n\ This file is used to log Angel Debugger Protocol packets.\n\ With a single argument, sets the logfile name to that value.\n\ Without an argument, shows the current logfile name.\n\ See also: rdilogenable\n"
argument_list|,
operator|&
name|maintenancelist
argument_list|)
expr_stmt|;
name|c
operator|->
name|completer
operator|=
name|filename_completer
expr_stmt|;
name|add_cmd
argument_list|(
literal|"rdilogenable"
argument_list|,
name|class_maintenance
argument_list|,
name|rdilogenable_command
argument_list|,
literal|"Set enable logging of ADP packets.\n\ This will log ADP packets exchanged between gdb and the\n\ rdi target device.\n\ An argument of 1,t,true,y,yes will enable.\n\ An argument of 0,f,false,n,no will disabled.\n\ Withough an argument, it will display current state.\n"
argument_list|,
operator|&
name|maintenancelist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"rdiromatzero"
argument_list|,
name|no_class
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|rom_at_zero
argument_list|,
literal|"Set target has ROM at addr 0.\n\ A true value disables vector catching, false enables vector catching.\n\ This is evaluated at the time the 'target rdi' command is executed\n"
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"rdiheartbeat"
argument_list|,
name|no_class
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|rdi_heartbeat
argument_list|,
literal|"Set enable for ADP heartbeat packets.\n\ I don't know why you would want this. If you enable them,\n\ it will confuse ARM and EPI JTAG interface boxes as well\n\ as the Angel Monitor.\n"
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A little dummy to make linking with the library succeed. */
end_comment

begin_function
name|int
name|Fail
parameter_list|(
name|void
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

end_unit

