begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Print values for GDB, the GNU debugger.    Copyright 1986, 1988, 1989, 1991, 1992, 1993, 1994              Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_include
include|#
directive|include
file|"annotate.h"
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_comment
comment|/* Prototypes for local functions */
end_comment

begin_decl_stmt
specifier|static
name|void
name|print_hex_chars
name|PARAMS
argument_list|(
operator|(
name|GDB_FILE
operator|*
operator|,
name|unsigned
name|char
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|show_print
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_print
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_radix
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|show_radix
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_input_radix
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
expr|struct
name|cmd_list_element
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_input_radix_1
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_output_radix
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
expr|struct
name|cmd_list_element
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_output_radix_1
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Maximum number of chars to print for a string pointer value or vector    contents, or UINT_MAX for no limit.  Note that "set print elements 0"    stores UINT_MAX in print_max, which displays in a show command as    "unlimited". */
end_comment

begin_decl_stmt
name|unsigned
name|int
name|print_max
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|PRINT_MAX_DEFAULT
value|200
end_define

begin_comment
comment|/* Start print_max off at this value. */
end_comment

begin_comment
comment|/* Default input and output radixes, and output format letter.  */
end_comment

begin_decl_stmt
name|unsigned
name|input_radix
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|output_radix
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|output_format
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print repeat counts if there are more than this many repetitions of an    element in an array.  Referenced by the low level language dependent    print routines. */
end_comment

begin_decl_stmt
name|unsigned
name|int
name|repeat_count_threshold
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If nonzero, stops printing of char arrays at first null. */
end_comment

begin_decl_stmt
name|int
name|stop_print_at_null
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Controls pretty printing of structures. */
end_comment

begin_decl_stmt
name|int
name|prettyprint_structs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Controls pretty printing of arrays.  */
end_comment

begin_decl_stmt
name|int
name|prettyprint_arrays
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If nonzero, causes unions inside structures or other unions to be    printed. */
end_comment

begin_decl_stmt
name|int
name|unionprint
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Controls printing of nested unions.  */
end_comment

begin_comment
comment|/* If nonzero, causes machine addresses to be printed in certain contexts. */
end_comment

begin_decl_stmt
name|int
name|addressprint
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Controls printing of machine addresses */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Print data of type TYPE located at VALADDR (within GDB), which came from    the inferior at address ADDRESS, onto stdio stream STREAM according to    FORMAT (a letter, or 0 for natural format using TYPE).     If DEREF_REF is nonzero, then dereference references, otherwise just print    them like pointers.     The PRETTY parameter controls prettyprinting.     If the data are a string pointer, returns the number of string characters    printed.     FIXME:  The data at VALADDR is in target byte order.  If gdb is ever    enhanced to be able to debug more than the single target it was compiled    for (specific CPU type and thus specific target byte ordering), then    either the print routines are going to have to take this into account,    or the data is going to have to be passed into here already converted    to the host byte ordering, whichever is more convenient. */
end_comment

begin_function
name|int
name|val_print
parameter_list|(
name|type
parameter_list|,
name|valaddr
parameter_list|,
name|address
parameter_list|,
name|stream
parameter_list|,
name|format
parameter_list|,
name|deref_ref
parameter_list|,
name|recurse
parameter_list|,
name|pretty
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|char
modifier|*
name|valaddr
decl_stmt|;
name|CORE_ADDR
name|address
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|format
decl_stmt|;
name|int
name|deref_ref
decl_stmt|;
name|int
name|recurse
decl_stmt|;
name|enum
name|val_prettyprint
name|pretty
decl_stmt|;
block|{
name|struct
name|type
modifier|*
name|real_type
init|=
name|check_typedef
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|pretty
operator|==
name|Val_pretty_default
condition|)
block|{
name|pretty
operator|=
name|prettyprint_structs
condition|?
name|Val_prettyprint
else|:
name|Val_no_prettyprint
expr_stmt|;
block|}
name|QUIT
expr_stmt|;
comment|/* Ensure that the type is complete and not just a stub.  If the type is      only a stub and we can't find and substitute its complete type, then      print appropriate string and return.  */
if|if
condition|(
name|TYPE_FLAGS
argument_list|(
name|real_type
argument_list|)
operator|&
name|TYPE_FLAG_STUB
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<incomplete type>"
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|stream
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|LA_VAL_PRINT
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|,
name|address
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|deref_ref
argument_list|,
name|recurse
argument_list|,
name|pretty
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Print the value VAL in C-ish syntax on stream STREAM.    FORMAT is a format-letter, or 0 for print in natural format of data type.    If the object printed is a string pointer, returns    the number of string bytes printed.  */
end_comment

begin_function
name|int
name|value_print
parameter_list|(
name|val
parameter_list|,
name|stream
parameter_list|,
name|format
parameter_list|,
name|pretty
parameter_list|)
name|value_ptr
name|val
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|format
decl_stmt|;
name|enum
name|val_prettyprint
name|pretty
decl_stmt|;
block|{
if|if
condition|(
name|val
operator|==
literal|0
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"<address of value unknown>"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|VALUE_OPTIMIZED_OUT
argument_list|(
name|val
argument_list|)
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"<value optimized out>"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|LA_VALUE_PRINT
argument_list|(
name|val
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|pretty
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Called by various<lang>_val_print routines to print    TYPE_CODE_INT's.  TYPE is the type.  VALADDR is the address of the    value.  STREAM is where to print the value.  */
end_comment

begin_function
name|void
name|val_print_type_code_int
parameter_list|(
name|type
parameter_list|,
name|valaddr
parameter_list|,
name|stream
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|char
modifier|*
name|valaddr
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
block|{
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|>
sizeof|sizeof
argument_list|(
name|LONGEST
argument_list|)
condition|)
block|{
name|LONGEST
name|val
decl_stmt|;
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|&&
name|extract_long_unsigned_integer
argument_list|(
name|valaddr
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|,
operator|&
name|val
argument_list|)
condition|)
block|{
name|print_longest
argument_list|(
name|stream
argument_list|,
literal|'u'
argument_list|,
literal|0
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Signed, or we couldn't turn an unsigned value into a 	     LONGEST.  For signed values, one could assume two's 	     complement (a reasonable assumption, I think) and do 	     better than this.  */
name|print_hex_chars
argument_list|(
name|stream
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|valaddr
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|PRINT_TYPELESS_INTEGER
name|PRINT_TYPELESS_INTEGER
argument_list|(
name|stream
argument_list|,
name|type
argument_list|,
name|unpack_long
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|print_longest
argument_list|(
name|stream
argument_list|,
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|?
literal|'u'
else|:
literal|'d'
argument_list|,
literal|0
argument_list|,
name|unpack_long
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/* Print a number according to FORMAT which is one of d,u,x,o,b,h,w,g.    The raison d'etre of this function is to consolidate printing of LONG_LONG's    into this one function.  Some platforms have long longs but don't have a    printf() that supports "ll" in the format string.  We handle these by seeing    if the number is actually a long, and if not we just bail out and print the    number in hex.  The format chars b,h,w,g are from    print_scalar_formatted().  If USE_LOCAL, format it according to the current    language (this should be used for most integers which GDB prints, the    exception is things like protocols where the format of the integer is    a protocol thing, not a user-visible thing).  */
end_comment

begin_function
name|void
name|print_longest
parameter_list|(
name|stream
parameter_list|,
name|format
parameter_list|,
name|use_local
parameter_list|,
name|val_long
parameter_list|)
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|format
decl_stmt|;
name|int
name|use_local
decl_stmt|;
name|LONGEST
name|val_long
decl_stmt|;
block|{
if|#
directive|if
name|defined
argument_list|(
name|CC_HAS_LONG_LONG
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|PRINTF_HAS_LONG_LONG
argument_list|)
name|long
name|vtop
decl_stmt|,
name|vbot
decl_stmt|;
name|vtop
operator|=
name|val_long
operator|>>
operator|(
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|*
name|HOST_CHAR_BIT
operator|)
expr_stmt|;
name|vbot
operator|=
operator|(
name|long
operator|)
name|val_long
expr_stmt|;
if|if
condition|(
operator|(
name|format
operator|==
literal|'d'
operator|&&
operator|(
name|val_long
operator|<
name|INT_MIN
operator|||
name|val_long
operator|>
name|INT_MAX
operator|)
operator|)
operator|||
operator|(
operator|(
name|format
operator|==
literal|'u'
operator|||
name|format
operator|==
literal|'x'
operator|)
operator|&&
operator|(
name|unsigned
name|long
name|long
operator|)
name|val_long
operator|>
name|UINT_MAX
operator|)
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"0x%lx%08lx"
argument_list|,
name|vtop
argument_list|,
name|vbot
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PRINTF_HAS_LONG_LONG
switch|switch
condition|(
name|format
condition|)
block|{
case|case
literal|'d'
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|use_local
condition|?
name|local_decimal_format_custom
argument_list|(
literal|"ll"
argument_list|)
else|:
literal|"%lld"
argument_list|,
name|val_long
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%llu"
argument_list|,
name|val_long
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|use_local
condition|?
name|local_hex_format_custom
argument_list|(
literal|"ll"
argument_list|)
else|:
literal|"%llx"
argument_list|,
name|val_long
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|use_local
condition|?
name|local_octal_format_custom
argument_list|(
literal|"ll"
argument_list|)
else|:
literal|"%llo"
argument_list|,
name|val_long
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|local_hex_format_custom
argument_list|(
literal|"02ll"
argument_list|)
argument_list|,
name|val_long
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|local_hex_format_custom
argument_list|(
literal|"04ll"
argument_list|)
argument_list|,
name|val_long
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|local_hex_format_custom
argument_list|(
literal|"08ll"
argument_list|)
argument_list|,
name|val_long
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|local_hex_format_custom
argument_list|(
literal|"016ll"
argument_list|)
argument_list|,
name|val_long
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
else|#
directive|else
comment|/* !PRINTF_HAS_LONG_LONG */
comment|/* In the following it is important to coerce (val_long) to a long. It does      nothing if !LONG_LONG, but it will chop off the top half (which we know      we can ignore) if the host supports long longs.  */
switch|switch
condition|(
name|format
condition|)
block|{
case|case
literal|'d'
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|use_local
condition|?
name|local_decimal_format_custom
argument_list|(
literal|"l"
argument_list|)
else|:
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|val_long
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%lu"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|val_long
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|use_local
condition|?
name|local_hex_format_custom
argument_list|(
literal|"l"
argument_list|)
else|:
literal|"%lx"
argument_list|,
operator|(
name|long
operator|)
name|val_long
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|use_local
condition|?
name|local_octal_format_custom
argument_list|(
literal|"l"
argument_list|)
else|:
literal|"%lo"
argument_list|,
operator|(
name|long
operator|)
name|val_long
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|local_hex_format_custom
argument_list|(
literal|"02l"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|val_long
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|local_hex_format_custom
argument_list|(
literal|"04l"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|val_long
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|local_hex_format_custom
argument_list|(
literal|"08l"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|val_long
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|local_hex_format_custom
argument_list|(
literal|"016l"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|val_long
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* !PRINTF_HAS_LONG_LONG */
block|}
end_function

begin_comment
comment|/* This used to be a macro, but I don't think it is called often enough    to merit such treatment.  */
end_comment

begin_comment
comment|/* Convert a LONGEST to an int.  This is used in contexts (e.g. number of    arguments to a function, number in a value history, register number, etc.)    where the value must not be larger than can fit in an int.  */
end_comment

begin_function
name|int
name|longest_to_int
parameter_list|(
name|arg
parameter_list|)
name|LONGEST
name|arg
decl_stmt|;
block|{
comment|/* This check is in case a system header has botched the      definition of INT_MIN, like on BSDI.  */
if|if
condition|(
sizeof|sizeof
argument_list|(
name|LONGEST
argument_list|)
operator|<=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|)
return|return
name|arg
return|;
if|if
condition|(
name|arg
operator|>
name|INT_MAX
operator|||
name|arg
operator|<
name|INT_MIN
condition|)
name|error
argument_list|(
literal|"Value out of range."
argument_list|)
expr_stmt|;
return|return
name|arg
return|;
block|}
end_function

begin_comment
comment|/* Print a floating point value of type TYPE, pointed to in GDB by VALADDR,    on STREAM.  */
end_comment

begin_function
name|void
name|print_floating
parameter_list|(
name|valaddr
parameter_list|,
name|type
parameter_list|,
name|stream
parameter_list|)
name|char
modifier|*
name|valaddr
decl_stmt|;
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|DOUBLEST
name|doub
decl_stmt|;
name|int
name|inv
decl_stmt|;
name|unsigned
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|IEEE_FLOAT
argument_list|)
comment|/* Check for NaN's.  Note that this code does not depend on us being      on an IEEE conforming system.  It only depends on the target      machine using IEEE representation.  This means (a)      cross-debugging works right, and (2) IEEE_FLOAT can (and should)      be defined for systems like the 68881, which uses IEEE      representation, but is not IEEE conforming.  */
block|{
name|unsigned
name|long
name|low
decl_stmt|,
name|high
decl_stmt|;
comment|/* Is the sign bit 0?  */
name|int
name|nonnegative
decl_stmt|;
comment|/* Is it is a NaN (i.e. the exponent is all ones and        the fraction is nonzero)?  */
name|int
name|is_nan
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|4
condition|)
block|{
comment|/* It's single precision.  */
comment|/* Assume that floating point byte order is the same as 	   integer byte order.  */
name|low
operator|=
name|extract_unsigned_integer
argument_list|(
name|valaddr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|nonnegative
operator|=
operator|(
operator|(
name|low
operator|&
literal|0x80000000
operator|)
operator|==
literal|0
operator|)
expr_stmt|;
name|is_nan
operator|=
operator|(
operator|(
operator|(
operator|(
name|low
operator|>>
literal|23
operator|)
operator|&
literal|0xFF
operator|)
operator|==
literal|0xFF
operator|)
operator|&&
literal|0
operator|!=
operator|(
name|low
operator|&
literal|0x7FFFFF
operator|)
operator|)
expr_stmt|;
name|low
operator|&=
literal|0x7fffff
expr_stmt|;
name|high
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|len
operator|==
literal|8
condition|)
block|{
comment|/* It's double precision.  Get the high and low words.  */
comment|/* Assume that floating point byte order is the same as 	   integer byte order.  */
if|if
condition|(
name|TARGET_BYTE_ORDER
operator|==
name|BIG_ENDIAN
condition|)
block|{
name|low
operator|=
name|extract_unsigned_integer
argument_list|(
name|valaddr
operator|+
literal|4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|high
operator|=
name|extract_unsigned_integer
argument_list|(
name|valaddr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|low
operator|=
name|extract_unsigned_integer
argument_list|(
name|valaddr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|high
operator|=
name|extract_unsigned_integer
argument_list|(
name|valaddr
operator|+
literal|4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
name|nonnegative
operator|=
operator|(
operator|(
name|high
operator|&
literal|0x80000000
operator|)
operator|==
literal|0
operator|)
expr_stmt|;
name|is_nan
operator|=
operator|(
operator|(
operator|(
name|high
operator|>>
literal|20
operator|)
operator|&
literal|0x7ff
operator|)
operator|==
literal|0x7ff
operator|&&
operator|!
operator|(
operator|(
operator|(
operator|(
name|high
operator|&
literal|0xfffff
operator|)
operator|==
literal|0
operator|)
operator|)
operator|&&
operator|(
name|low
operator|==
literal|0
operator|)
operator|)
operator|)
expr_stmt|;
name|high
operator|&=
literal|0xfffff
expr_stmt|;
block|}
else|else
comment|/* Extended.  We can't detect NaNs for extendeds yet.  Also note 	 that currently extendeds get nuked to double in 	 REGISTER_CONVERTIBLE.  */
name|is_nan
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|is_nan
condition|)
block|{
comment|/* The meaning of the sign and fraction is not defined by IEEE. 	   But the user might know what they mean.  For example, they 	   (in an implementation-defined manner) distinguish between 	   signaling and quiet NaN's.  */
if|if
condition|(
name|high
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"-NaN(0x%lx%.8lx)"
operator|+
name|nonnegative
argument_list|,
name|high
argument_list|,
name|low
argument_list|)
expr_stmt|;
else|else
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"-NaN(0x%lx)"
operator|+
name|nonnegative
argument_list|,
name|low
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
endif|#
directive|endif
comment|/* IEEE_FLOAT.  */
name|doub
operator|=
name|unpack_double
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|,
operator|&
name|inv
argument_list|)
expr_stmt|;
if|if
condition|(
name|inv
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<invalid float value>"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|len
operator|<
sizeof|sizeof
argument_list|(
name|double
argument_list|)
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%.9g"
argument_list|,
operator|(
name|double
operator|)
name|doub
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|len
operator|==
sizeof|sizeof
argument_list|(
name|double
argument_list|)
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%.17g"
argument_list|,
operator|(
name|double
operator|)
name|doub
argument_list|)
expr_stmt|;
else|else
ifdef|#
directive|ifdef
name|PRINTF_HAS_LONG_DOUBLE
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%.35Lg"
argument_list|,
name|doub
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* This at least wins with values that are representable as doubles */
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%.17g"
argument_list|,
operator|(
name|double
operator|)
name|doub
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* VALADDR points to an integer of LEN bytes.  Print it in hex on stream.  */
end_comment

begin_function
specifier|static
name|void
name|print_hex_chars
parameter_list|(
name|stream
parameter_list|,
name|valaddr
parameter_list|,
name|len
parameter_list|)
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
name|unsigned
name|char
modifier|*
name|valaddr
decl_stmt|;
name|unsigned
name|len
decl_stmt|;
block|{
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
comment|/* FIXME: We should be not printing leading zeroes in most cases.  */
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|local_hex_format_prefix
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_BYTE_ORDER
operator|==
name|BIG_ENDIAN
condition|)
block|{
for|for
control|(
name|p
operator|=
name|valaddr
init|;
name|p
operator|<
name|valaddr
operator|+
name|len
condition|;
name|p
operator|++
control|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%02x"
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|p
operator|=
name|valaddr
operator|+
name|len
operator|-
literal|1
init|;
name|p
operator|>=
name|valaddr
condition|;
name|p
operator|--
control|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%02x"
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|local_hex_format_suffix
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  Called by various<lang>_val_print routines to print elements of an     array in the form "<elem1>,<elem2>,<elem3>, ...".      (FIXME?)  Assumes array element separator is a comma, which is correct     for all languages currently handled.     (FIXME?)  Some languages have a notation for repeated array elements,     perhaps we should try to use that notation when appropriate.     */
end_comment

begin_function
name|void
name|val_print_array_elements
parameter_list|(
name|type
parameter_list|,
name|valaddr
parameter_list|,
name|address
parameter_list|,
name|stream
parameter_list|,
name|format
parameter_list|,
name|deref_ref
parameter_list|,
name|recurse
parameter_list|,
name|pretty
parameter_list|,
name|i
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|char
modifier|*
name|valaddr
decl_stmt|;
name|CORE_ADDR
name|address
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|format
decl_stmt|;
name|int
name|deref_ref
decl_stmt|;
name|int
name|recurse
decl_stmt|;
name|enum
name|val_prettyprint
name|pretty
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
block|{
name|unsigned
name|int
name|things_printed
init|=
literal|0
decl_stmt|;
name|unsigned
name|len
decl_stmt|;
name|struct
name|type
modifier|*
name|elttype
decl_stmt|;
name|unsigned
name|eltlen
decl_stmt|;
comment|/* Position of the array element we are examining to see      whether it is repeated.  */
name|unsigned
name|int
name|rep1
decl_stmt|;
comment|/* Number of repetitions we have detected so far.  */
name|unsigned
name|int
name|reps
decl_stmt|;
name|elttype
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|eltlen
operator|=
name|TYPE_LENGTH
argument_list|(
name|check_typedef
argument_list|(
name|elttype
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|/
name|eltlen
expr_stmt|;
name|annotate_array_section_begin
argument_list|(
name|i
argument_list|,
name|elttype
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|len
operator|&&
name|things_printed
operator|<
name|print_max
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|prettyprint_arrays
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|",\n"
argument_list|)
expr_stmt|;
name|print_spaces_filtered
argument_list|(
literal|2
operator|+
literal|2
operator|*
name|recurse
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
block|}
block|}
name|wrap_here
argument_list|(
name|n_spaces
argument_list|(
literal|2
operator|+
literal|2
operator|*
name|recurse
argument_list|)
argument_list|)
expr_stmt|;
name|rep1
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|reps
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|rep1
operator|<
name|len
operator|)
operator|&&
operator|!
name|memcmp
argument_list|(
name|valaddr
operator|+
name|i
operator|*
name|eltlen
argument_list|,
name|valaddr
operator|+
name|rep1
operator|*
name|eltlen
argument_list|,
name|eltlen
argument_list|)
condition|)
block|{
operator|++
name|reps
expr_stmt|;
operator|++
name|rep1
expr_stmt|;
block|}
if|if
condition|(
name|reps
operator|>
name|repeat_count_threshold
condition|)
block|{
name|val_print
argument_list|(
name|elttype
argument_list|,
name|valaddr
operator|+
name|i
operator|*
name|eltlen
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|deref_ref
argument_list|,
name|recurse
operator|+
literal|1
argument_list|,
name|pretty
argument_list|)
expr_stmt|;
name|annotate_elt_rep
argument_list|(
name|reps
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<repeats %u times>"
argument_list|,
name|reps
argument_list|)
expr_stmt|;
name|annotate_elt_rep_end
argument_list|()
expr_stmt|;
name|i
operator|=
name|rep1
operator|-
literal|1
expr_stmt|;
name|things_printed
operator|+=
name|repeat_count_threshold
expr_stmt|;
block|}
else|else
block|{
name|val_print
argument_list|(
name|elttype
argument_list|,
name|valaddr
operator|+
name|i
operator|*
name|eltlen
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|deref_ref
argument_list|,
name|recurse
operator|+
literal|1
argument_list|,
name|pretty
argument_list|)
expr_stmt|;
name|annotate_elt
argument_list|()
expr_stmt|;
name|things_printed
operator|++
expr_stmt|;
block|}
block|}
name|annotate_array_section_end
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|len
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"..."
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  Print a string from the inferior, starting at ADDR and printing up to LEN     characters, to STREAM.  If LEN is zero, printing stops at the first null     byte, otherwise printing proceeds (including null bytes) until either     print_max or LEN characters have been printed, whichever is smaller. */
end_comment

begin_comment
comment|/* FIXME: All callers supply LEN of zero.  Supplying a non-zero LEN is    pointless, this routine just then becomes a convoluted version of    target_read_memory_partial.  Removing all the LEN stuff would simplify    this routine enormously.     FIXME: Use target_read_string.  */
end_comment

begin_function
name|int
name|val_print_string
parameter_list|(
name|addr
parameter_list|,
name|len
parameter_list|,
name|stream
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|int
name|force_ellipsis
init|=
literal|0
decl_stmt|;
comment|/* Force ellipsis to be printed if nonzero. */
name|int
name|errcode
decl_stmt|;
comment|/* Errno returned from bad reads. */
name|unsigned
name|int
name|fetchlimit
decl_stmt|;
comment|/* Maximum number of bytes to fetch. */
name|unsigned
name|int
name|nfetch
decl_stmt|;
comment|/* Bytes to fetch / bytes fetched. */
name|unsigned
name|int
name|chunksize
decl_stmt|;
comment|/* Size of each fetch, in bytes. */
name|unsigned
name|int
name|bufsize
decl_stmt|;
comment|/* Size of current fetch buffer. */
name|char
modifier|*
name|buffer
init|=
name|NULL
decl_stmt|;
comment|/* Dynamically growable fetch buffer. */
name|char
modifier|*
name|bufptr
decl_stmt|;
comment|/* Pointer to next available byte in buffer. */
name|char
modifier|*
name|limit
decl_stmt|;
comment|/* First location past end of fetch buffer. */
name|struct
name|cleanup
modifier|*
name|old_chain
init|=
name|NULL
decl_stmt|;
comment|/* Top of the old cleanup chain. */
name|char
name|peekchar
decl_stmt|;
comment|/* Place into which we can read one char. */
comment|/* First we need to figure out the limit on the number of characters we are      going to attempt to fetch and print.  This is actually pretty simple.  If      LEN is nonzero, then the limit is the minimum of LEN and print_max.  If      LEN is zero, then the limit is print_max.  This is true regardless of      whether print_max is zero, UINT_MAX (unlimited), or something in between,      because finding the null byte (or available memory) is what actually      limits the fetch. */
name|fetchlimit
operator|=
operator|(
name|len
operator|==
literal|0
condition|?
name|print_max
else|:
name|min
argument_list|(
name|len
argument_list|,
name|print_max
argument_list|)
operator|)
expr_stmt|;
comment|/* Now decide how large of chunks to try to read in one operation.  This      is also pretty simple.  If LEN is nonzero, then we want fetchlimit bytes,      so we might as well read them all in one operation.  If LEN is zero, we      are looking for a null terminator to end the fetching, so we might as      well read in blocks that are large enough to be efficient, but not so      large as to be slow if fetchlimit happens to be large.  So we choose the      minimum of 8 and fetchlimit.  We used to use 200 instead of 8 but      200 is way too big for remote debugging over a serial line.  */
name|chunksize
operator|=
operator|(
name|len
operator|==
literal|0
condition|?
name|min
argument_list|(
literal|8
argument_list|,
name|fetchlimit
argument_list|)
else|:
name|fetchlimit
operator|)
expr_stmt|;
comment|/* Loop until we either have all the characters to print, or we encounter      some error, such as bumping into the end of the address space. */
name|bufsize
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|QUIT
expr_stmt|;
comment|/* Figure out how much to fetch this time, and grow the buffer to fit. */
name|nfetch
operator|=
name|min
argument_list|(
name|chunksize
argument_list|,
name|fetchlimit
operator|-
name|bufsize
argument_list|)
expr_stmt|;
name|bufsize
operator|+=
name|nfetch
expr_stmt|;
if|if
condition|(
name|buffer
operator|==
name|NULL
condition|)
block|{
name|buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|bufsize
argument_list|)
expr_stmt|;
name|bufptr
operator|=
name|buffer
expr_stmt|;
block|}
else|else
block|{
name|discard_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
name|buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|buffer
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
name|bufptr
operator|=
name|buffer
operator|+
name|bufsize
operator|-
name|nfetch
expr_stmt|;
block|}
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
comment|/* Read as much as we can. */
name|nfetch
operator|=
name|target_read_memory_partial
argument_list|(
name|addr
argument_list|,
name|bufptr
argument_list|,
name|nfetch
argument_list|,
operator|&
name|errcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
block|{
name|addr
operator|+=
name|nfetch
expr_stmt|;
name|bufptr
operator|+=
name|nfetch
expr_stmt|;
block|}
else|else
block|{
comment|/* Scan this chunk for the null byte that terminates the string 	   to print.  If found, we don't need to fetch any more.  Note 	   that bufptr is explicitly left pointing at the next character 	   after the null byte, or at the next character after the end of 	   the buffer. */
name|limit
operator|=
name|bufptr
operator|+
name|nfetch
expr_stmt|;
while|while
condition|(
name|bufptr
operator|<
name|limit
condition|)
block|{
operator|++
name|addr
expr_stmt|;
operator|++
name|bufptr
expr_stmt|;
if|if
condition|(
name|bufptr
index|[
operator|-
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* We don't care about any error which happened after 		   the NULL terminator.  */
name|errcode
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
do|while
condition|(
name|errcode
operator|==
literal|0
comment|/* no error */
operator|&&
name|bufsize
operator|<
name|fetchlimit
comment|/* no overrun */
operator|&&
operator|!
operator|(
name|len
operator|==
literal|0
operator|&&
operator|*
operator|(
name|bufptr
operator|-
literal|1
operator|)
operator|==
literal|'\0'
operator|)
condition|)
do|;
comment|/* no null term */
comment|/* bufptr and addr now point immediately beyond the last byte which we      consider part of the string (including a '\0' which ends the string).  */
comment|/* We now have either successfully filled the buffer to fetchlimit, or      terminated early due to an error or finding a null byte when LEN is      zero.  */
if|if
condition|(
name|len
operator|==
literal|0
operator|&&
name|bufptr
operator|>
name|buffer
operator|&&
operator|*
operator|(
name|bufptr
operator|-
literal|1
operator|)
operator|!=
literal|'\0'
condition|)
block|{
comment|/* We didn't find a null terminator we were looking for.  Attempt 	 to peek at the next character.  If not successful, or it is not 	 a null byte, then force ellipsis to be printed.  */
if|if
condition|(
name|target_read_memory
argument_list|(
name|addr
argument_list|,
operator|&
name|peekchar
argument_list|,
literal|1
argument_list|)
operator|!=
literal|0
operator|||
name|peekchar
operator|!=
literal|'\0'
condition|)
block|{
name|force_ellipsis
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|len
operator|!=
literal|0
operator|&&
name|errcode
operator|!=
literal|0
operator|)
operator|||
operator|(
name|len
operator|>
name|bufptr
operator|-
name|buffer
operator|)
condition|)
block|{
comment|/* Getting an error when we have a requested length, or fetching less 	 than the number of characters actually requested, always make us 	 print ellipsis. */
name|force_ellipsis
operator|=
literal|1
expr_stmt|;
block|}
name|QUIT
expr_stmt|;
comment|/* If we get an error before fetching anything, don't print a string.      But if we fetch something and then get an error, print the string      and then the error message.  */
if|if
condition|(
name|errcode
operator|==
literal|0
operator|||
name|bufptr
operator|>
name|buffer
condition|)
block|{
if|if
condition|(
name|addressprint
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|" "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
name|LA_PRINT_STRING
argument_list|(
name|stream
argument_list|,
name|buffer
argument_list|,
name|bufptr
operator|-
name|buffer
argument_list|,
name|force_ellipsis
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|errcode
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|errcode
operator|==
name|EIO
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<Address "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" out of bounds>"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<Error reading address "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|": %s>"
argument_list|,
name|safe_strerror
argument_list|(
name|errcode
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|gdb_flush
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
operator|(
name|bufptr
operator|-
name|buffer
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Validate an input or output radix setting, and make sure the user    knows what they really did here.  Radix setting is confusing, e.g.    setting the input radix to "10" never changes it!  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|set_input_radix
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|,
name|c
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
block|{
name|set_input_radix_1
argument_list|(
name|from_tty
argument_list|,
operator|*
operator|(
name|unsigned
operator|*
operator|)
name|c
operator|->
name|var
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|set_input_radix_1
parameter_list|(
name|from_tty
parameter_list|,
name|radix
parameter_list|)
name|int
name|from_tty
decl_stmt|;
name|unsigned
name|radix
decl_stmt|;
block|{
comment|/* We don't currently disallow any input radix except 0 or 1, which don't      make any mathematical sense.  In theory, we can deal with any input      radix greater than 1, even if we don't have unique digits for every      value from 0 to radix-1, but in practice we lose on large radix values.      We should either fix the lossage or restrict the radix range more.      (FIXME). */
if|if
condition|(
name|radix
operator|<
literal|2
condition|)
block|{
name|error
argument_list|(
literal|"Nonsense input radix ``decimal %u''; input radix unchanged."
argument_list|,
name|radix
argument_list|)
expr_stmt|;
block|}
name|input_radix
operator|=
name|radix
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Input radix now set to decimal %u, hex %x, octal %o.\n"
argument_list|,
name|radix
argument_list|,
name|radix
argument_list|,
name|radix
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|set_output_radix
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|,
name|c
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
block|{
name|set_output_radix_1
argument_list|(
name|from_tty
argument_list|,
operator|*
operator|(
name|unsigned
operator|*
operator|)
name|c
operator|->
name|var
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_output_radix_1
parameter_list|(
name|from_tty
parameter_list|,
name|radix
parameter_list|)
name|int
name|from_tty
decl_stmt|;
name|unsigned
name|radix
decl_stmt|;
block|{
comment|/* Validate the radix and disallow ones that we aren't prepared to      handle correctly, leaving the radix unchanged. */
switch|switch
condition|(
name|radix
condition|)
block|{
case|case
literal|16
case|:
name|output_format
operator|=
literal|'x'
expr_stmt|;
comment|/* hex */
break|break;
case|case
literal|10
case|:
name|output_format
operator|=
literal|0
expr_stmt|;
comment|/* decimal */
break|break;
case|case
literal|8
case|:
name|output_format
operator|=
literal|'o'
expr_stmt|;
comment|/* octal */
break|break;
default|default:
name|error
argument_list|(
literal|"Unsupported output radix ``decimal %u''; output radix unchanged."
argument_list|,
name|radix
argument_list|)
expr_stmt|;
block|}
name|output_radix
operator|=
name|radix
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Output radix now set to decimal %u, hex %x, octal %o.\n"
argument_list|,
name|radix
argument_list|,
name|radix
argument_list|,
name|radix
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Set both the input and output radix at once.  Try to set the output radix    first, since it has the most restrictive range.  An radix that is valid as    an output radix is also valid as an input radix.     It may be useful to have an unusual input radix.  If the user wishes to    set an input radix that is not valid as an output radix, he needs to use    the 'set input-radix' command. */
end_comment

begin_function
specifier|static
name|void
name|set_radix
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|unsigned
name|radix
decl_stmt|;
name|radix
operator|=
operator|(
name|arg
operator|==
name|NULL
operator|)
condition|?
literal|10
else|:
name|parse_and_eval_address
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|set_output_radix_1
argument_list|(
literal|0
argument_list|,
name|radix
argument_list|)
expr_stmt|;
name|set_input_radix_1
argument_list|(
literal|0
argument_list|,
name|radix
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Input and output radices now set to decimal %u, hex %x, octal %o.\n"
argument_list|,
name|radix
argument_list|,
name|radix
argument_list|,
name|radix
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Show both the input and output radices. */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|show_radix
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
if|if
condition|(
name|from_tty
condition|)
block|{
if|if
condition|(
name|input_radix
operator|==
name|output_radix
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Input and output radices set to decimal %u, hex %x, octal %o.\n"
argument_list|,
name|input_radix
argument_list|,
name|input_radix
argument_list|,
name|input_radix
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf_filtered
argument_list|(
literal|"Input radix set to decimal %u, hex %x, octal %o.\n"
argument_list|,
name|input_radix
argument_list|,
name|input_radix
argument_list|,
name|input_radix
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Output radix set to decimal %u, hex %x, octal %o.\n"
argument_list|,
name|output_radix
argument_list|,
name|output_radix
argument_list|,
name|output_radix
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|set_print
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|printf_unfiltered
argument_list|(
literal|"\"set print\" must be followed by the name of a print subcommand.\n"
argument_list|)
expr_stmt|;
name|help_list
argument_list|(
name|setprintlist
argument_list|,
literal|"set print "
argument_list|,
operator|-
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|show_print
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|cmd_show_list
argument_list|(
name|showprintlist
argument_list|,
name|from_tty
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|_initialize_valprint
parameter_list|()
block|{
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"print"
argument_list|,
name|no_class
argument_list|,
name|set_print
argument_list|,
literal|"Generic command for setting how things print."
argument_list|,
operator|&
name|setprintlist
argument_list|,
literal|"set print "
argument_list|,
literal|0
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|add_alias_cmd
argument_list|(
literal|"p"
argument_list|,
literal|"print"
argument_list|,
name|no_class
argument_list|,
literal|1
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
comment|/* prefer set print to set prompt */
name|add_alias_cmd
argument_list|(
literal|"pr"
argument_list|,
literal|"print"
argument_list|,
name|no_class
argument_list|,
literal|1
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"print"
argument_list|,
name|no_class
argument_list|,
name|show_print
argument_list|,
literal|"Generic command for showing print settings."
argument_list|,
operator|&
name|showprintlist
argument_list|,
literal|"show print "
argument_list|,
literal|0
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_alias_cmd
argument_list|(
literal|"p"
argument_list|,
literal|"print"
argument_list|,
name|no_class
argument_list|,
literal|1
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_alias_cmd
argument_list|(
literal|"pr"
argument_list|,
literal|"print"
argument_list|,
name|no_class
argument_list|,
literal|1
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"elements"
argument_list|,
name|no_class
argument_list|,
name|var_uinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|print_max
argument_list|,
literal|"Set limit on string chars or array elements to print.\n\ \"set print elements 0\" causes there to be no limit."
argument_list|,
operator|&
name|setprintlist
argument_list|)
argument_list|,
operator|&
name|showprintlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"null-stop"
argument_list|,
name|no_class
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|stop_print_at_null
argument_list|,
literal|"Set printing of char arrays to stop at first null char."
argument_list|,
operator|&
name|setprintlist
argument_list|)
argument_list|,
operator|&
name|showprintlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"repeats"
argument_list|,
name|no_class
argument_list|,
name|var_uinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|repeat_count_threshold
argument_list|,
literal|"Set threshold for repeated print elements.\n\ \"set print repeats 0\" causes all elements to be individually printed."
argument_list|,
operator|&
name|setprintlist
argument_list|)
argument_list|,
operator|&
name|showprintlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"pretty"
argument_list|,
name|class_support
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|prettyprint_structs
argument_list|,
literal|"Set prettyprinting of structures."
argument_list|,
operator|&
name|setprintlist
argument_list|)
argument_list|,
operator|&
name|showprintlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"union"
argument_list|,
name|class_support
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|unionprint
argument_list|,
literal|"Set printing of unions interior to structures."
argument_list|,
operator|&
name|setprintlist
argument_list|)
argument_list|,
operator|&
name|showprintlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"array"
argument_list|,
name|class_support
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|prettyprint_arrays
argument_list|,
literal|"Set prettyprinting of arrays."
argument_list|,
operator|&
name|setprintlist
argument_list|)
argument_list|,
operator|&
name|showprintlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"address"
argument_list|,
name|class_support
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|addressprint
argument_list|,
literal|"Set printing of addresses."
argument_list|,
operator|&
name|setprintlist
argument_list|)
argument_list|,
operator|&
name|showprintlist
argument_list|)
expr_stmt|;
name|c
operator|=
name|add_set_cmd
argument_list|(
literal|"input-radix"
argument_list|,
name|class_support
argument_list|,
name|var_uinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|input_radix
argument_list|,
literal|"Set default input radix for entering numbers."
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|c
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|c
operator|->
name|function
operator|.
name|sfunc
operator|=
name|set_input_radix
expr_stmt|;
name|c
operator|=
name|add_set_cmd
argument_list|(
literal|"output-radix"
argument_list|,
name|class_support
argument_list|,
name|var_uinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|output_radix
argument_list|,
literal|"Set default output radix for printing of values."
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|c
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|c
operator|->
name|function
operator|.
name|sfunc
operator|=
name|set_output_radix
expr_stmt|;
comment|/* The "set radix" and "show radix" commands are special in that they are      like normal set and show commands but allow two normally independent      variables to be either set or shown with a single command.  So the      usual add_set_cmd() and add_show_from_set() commands aren't really      appropriate. */
name|add_cmd
argument_list|(
literal|"radix"
argument_list|,
name|class_support
argument_list|,
name|set_radix
argument_list|,
literal|"Set default input and output number radices.\n\ Use 'set input-radix' or 'set output-radix' to independently set each.\n\ Without an argument, sets both radices back to the default value of 10."
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"radix"
argument_list|,
name|class_support
argument_list|,
name|show_radix
argument_list|,
literal|"Show the default input and output number radices.\n\ Use 'show input-radix' or 'show output-radix' to independently show each."
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
comment|/* Give people the defaults which they are used to.  */
name|prettyprint_structs
operator|=
literal|0
expr_stmt|;
name|prettyprint_arrays
operator|=
literal|0
expr_stmt|;
name|unionprint
operator|=
literal|1
expr_stmt|;
name|addressprint
operator|=
literal|1
expr_stmt|;
name|print_max
operator|=
name|PRINT_MAX_DEFAULT
expr_stmt|;
block|}
end_function

end_unit

