begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Print values for GDB, the GNU debugger.    Copyright 1986, 1988, 1989, 1991, 1992, 1993, 1994, 1998              Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_include
include|#
directive|include
file|"annotate.h"
end_include

begin_include
include|#
directive|include
file|"valprint.h"
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_comment
comment|/* Prototypes for local functions */
end_comment

begin_decl_stmt
specifier|static
name|void
name|print_hex_chars
name|PARAMS
argument_list|(
operator|(
name|GDB_FILE
operator|*
operator|,
name|unsigned
name|char
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|show_print
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_print
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_radix
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|show_radix
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_input_radix
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
expr|struct
name|cmd_list_element
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_input_radix_1
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_output_radix
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
expr|struct
name|cmd_list_element
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_output_radix_1
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|_initialize_valprint
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Maximum number of chars to print for a string pointer value or vector    contents, or UINT_MAX for no limit.  Note that "set print elements 0"    stores UINT_MAX in print_max, which displays in a show command as    "unlimited". */
end_comment

begin_decl_stmt
name|unsigned
name|int
name|print_max
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|PRINT_MAX_DEFAULT
value|200
end_define

begin_comment
comment|/* Start print_max off at this value. */
end_comment

begin_comment
comment|/* Default input and output radixes, and output format letter.  */
end_comment

begin_decl_stmt
name|unsigned
name|input_radix
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|output_radix
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|output_format
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print repeat counts if there are more than this many repetitions of an    element in an array.  Referenced by the low level language dependent    print routines. */
end_comment

begin_decl_stmt
name|unsigned
name|int
name|repeat_count_threshold
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If nonzero, stops printing of char arrays at first null. */
end_comment

begin_decl_stmt
name|int
name|stop_print_at_null
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Controls pretty printing of structures. */
end_comment

begin_decl_stmt
name|int
name|prettyprint_structs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Controls pretty printing of arrays.  */
end_comment

begin_decl_stmt
name|int
name|prettyprint_arrays
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If nonzero, causes unions inside structures or other unions to be    printed. */
end_comment

begin_decl_stmt
name|int
name|unionprint
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Controls printing of nested unions.  */
end_comment

begin_comment
comment|/* If nonzero, causes machine addresses to be printed in certain contexts. */
end_comment

begin_decl_stmt
name|int
name|addressprint
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Controls printing of machine addresses */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Print data of type TYPE located at VALADDR (within GDB), which came from    the inferior at address ADDRESS, onto stdio stream STREAM according to    FORMAT (a letter, or 0 for natural format using TYPE).     If DEREF_REF is nonzero, then dereference references, otherwise just print    them like pointers.     The PRETTY parameter controls prettyprinting.     If the data are a string pointer, returns the number of string characters    printed.     FIXME:  The data at VALADDR is in target byte order.  If gdb is ever    enhanced to be able to debug more than the single target it was compiled    for (specific CPU type and thus specific target byte ordering), then    either the print routines are going to have to take this into account,    or the data is going to have to be passed into here already converted    to the host byte ordering, whichever is more convenient. */
end_comment

begin_function
name|int
name|val_print
parameter_list|(
name|type
parameter_list|,
name|valaddr
parameter_list|,
name|embedded_offset
parameter_list|,
name|address
parameter_list|,
name|stream
parameter_list|,
name|format
parameter_list|,
name|deref_ref
parameter_list|,
name|recurse
parameter_list|,
name|pretty
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|char
modifier|*
name|valaddr
decl_stmt|;
name|int
name|embedded_offset
decl_stmt|;
name|CORE_ADDR
name|address
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|format
decl_stmt|;
name|int
name|deref_ref
decl_stmt|;
name|int
name|recurse
decl_stmt|;
name|enum
name|val_prettyprint
name|pretty
decl_stmt|;
block|{
name|struct
name|type
modifier|*
name|real_type
init|=
name|check_typedef
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|pretty
operator|==
name|Val_pretty_default
condition|)
block|{
name|pretty
operator|=
name|prettyprint_structs
condition|?
name|Val_prettyprint
else|:
name|Val_no_prettyprint
expr_stmt|;
block|}
name|QUIT
expr_stmt|;
comment|/* Ensure that the type is complete and not just a stub.  If the type is      only a stub and we can't find and substitute its complete type, then      print appropriate string and return.  */
if|if
condition|(
name|TYPE_FLAGS
argument_list|(
name|real_type
argument_list|)
operator|&
name|TYPE_FLAG_STUB
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<incomplete type>"
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|stream
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|LA_VAL_PRINT
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|,
name|embedded_offset
argument_list|,
name|address
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|deref_ref
argument_list|,
name|recurse
argument_list|,
name|pretty
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Print the value VAL in C-ish syntax on stream STREAM.    FORMAT is a format-letter, or 0 for print in natural format of data type.    If the object printed is a string pointer, returns    the number of string bytes printed.  */
end_comment

begin_function
name|int
name|value_print
parameter_list|(
name|val
parameter_list|,
name|stream
parameter_list|,
name|format
parameter_list|,
name|pretty
parameter_list|)
name|value_ptr
name|val
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|format
decl_stmt|;
name|enum
name|val_prettyprint
name|pretty
decl_stmt|;
block|{
if|if
condition|(
name|val
operator|==
literal|0
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"<address of value unknown>"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|VALUE_OPTIMIZED_OUT
argument_list|(
name|val
argument_list|)
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"<value optimized out>"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|LA_VALUE_PRINT
argument_list|(
name|val
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|pretty
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Called by various<lang>_val_print routines to print    TYPE_CODE_INT's.  TYPE is the type.  VALADDR is the address of the    value.  STREAM is where to print the value.  */
end_comment

begin_function
name|void
name|val_print_type_code_int
parameter_list|(
name|type
parameter_list|,
name|valaddr
parameter_list|,
name|stream
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|char
modifier|*
name|valaddr
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
block|{
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|>
sizeof|sizeof
argument_list|(
name|LONGEST
argument_list|)
condition|)
block|{
name|LONGEST
name|val
decl_stmt|;
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|&&
name|extract_long_unsigned_integer
argument_list|(
name|valaddr
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|,
operator|&
name|val
argument_list|)
condition|)
block|{
name|print_longest
argument_list|(
name|stream
argument_list|,
literal|'u'
argument_list|,
literal|0
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Signed, or we couldn't turn an unsigned value into a 	     LONGEST.  For signed values, one could assume two's 	     complement (a reasonable assumption, I think) and do 	     better than this.  */
name|print_hex_chars
argument_list|(
name|stream
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|valaddr
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|PRINT_TYPELESS_INTEGER
name|PRINT_TYPELESS_INTEGER
argument_list|(
name|stream
argument_list|,
name|type
argument_list|,
name|unpack_long
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|print_longest
argument_list|(
name|stream
argument_list|,
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|?
literal|'u'
else|:
literal|'d'
argument_list|,
literal|0
argument_list|,
name|unpack_long
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/* Print a number according to FORMAT which is one of d,u,x,o,b,h,w,g.    The raison d'etre of this function is to consolidate printing of     LONG_LONG's into this one function.  Some platforms have long longs but    don't have a printf() that supports "ll" in the format string.  We handle    these by seeing if the number is representable as either a signed or    unsigned long, depending upon what format is desired, and if not we just    bail out and print the number in hex.     The format chars b,h,w,g are from print_scalar_formatted().  If USE_LOCAL,    format it according to the current language (this should be used for most    integers which GDB prints, the exception is things like protocols where    the format of the integer is a protocol thing, not a user-visible thing).    */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CC_HAS_LONG_LONG
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|PRINTF_HAS_LONG_LONG
argument_list|)
end_if

begin_function
specifier|static
name|void
name|print_decimal
parameter_list|(
name|stream
parameter_list|,
name|sign
parameter_list|,
name|use_local
parameter_list|,
name|val_ulong
parameter_list|)
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
name|char
modifier|*
name|sign
decl_stmt|;
name|int
name|use_local
decl_stmt|;
name|ULONGEST
name|val_ulong
decl_stmt|;
block|{
name|unsigned
name|long
name|temp
index|[
literal|3
index|]
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
do|do
block|{
name|temp
index|[
name|i
index|]
operator|=
name|val_ulong
operator|%
operator|(
literal|1000
operator|*
literal|1000
operator|*
literal|1000
operator|)
expr_stmt|;
name|val_ulong
operator|/=
operator|(
literal|1000
operator|*
literal|1000
operator|*
literal|1000
operator|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|val_ulong
operator|!=
literal|0
operator|&&
name|i
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|temp
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|temp
index|[
literal|0
index|]
argument_list|)
operator|)
condition|)
do|;
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|1
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%s%lu"
argument_list|,
name|sign
argument_list|,
name|temp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%s%lu%09lu"
argument_list|,
name|sign
argument_list|,
name|temp
index|[
literal|1
index|]
argument_list|,
name|temp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%s%lu%09lu%09lu"
argument_list|,
name|sign
argument_list|,
name|temp
index|[
literal|2
index|]
argument_list|,
name|temp
index|[
literal|1
index|]
argument_list|,
name|temp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|print_longest
parameter_list|(
name|stream
parameter_list|,
name|format
parameter_list|,
name|use_local
parameter_list|,
name|val_long
parameter_list|)
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|format
decl_stmt|;
name|int
name|use_local
decl_stmt|;
name|LONGEST
name|val_long
decl_stmt|;
block|{
if|#
directive|if
name|defined
argument_list|(
name|CC_HAS_LONG_LONG
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|PRINTF_HAS_LONG_LONG
argument_list|)
if|if
condition|(
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
name|LONGEST
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|format
condition|)
block|{
case|case
literal|'d'
case|:
block|{
comment|/* Print a signed value, that doesn't fit in a long */
if|if
condition|(
operator|(
name|long
operator|)
name|val_long
operator|!=
name|val_long
condition|)
block|{
if|if
condition|(
name|val_long
operator|<
literal|0
condition|)
name|print_decimal
argument_list|(
name|stream
argument_list|,
literal|"-"
argument_list|,
name|use_local
argument_list|,
operator|-
name|val_long
argument_list|)
expr_stmt|;
else|else
name|print_decimal
argument_list|(
name|stream
argument_list|,
literal|""
argument_list|,
name|use_local
argument_list|,
name|val_long
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
block|}
case|case
literal|'u'
case|:
block|{
comment|/* Print an unsigned value, that doesn't fit in a long */
if|if
condition|(
operator|(
name|unsigned
name|long
operator|)
name|val_long
operator|!=
operator|(
name|ULONGEST
operator|)
name|val_long
condition|)
block|{
name|print_decimal
argument_list|(
name|stream
argument_list|,
literal|""
argument_list|,
name|use_local
argument_list|,
name|val_long
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
block|}
case|case
literal|'x'
case|:
case|case
literal|'o'
case|:
case|case
literal|'b'
case|:
case|case
literal|'h'
case|:
case|case
literal|'w'
case|:
case|case
literal|'g'
case|:
comment|/* Print as unsigned value, must fit completely in unsigned long */
block|{
name|unsigned
name|long
name|temp
init|=
name|val_long
decl_stmt|;
if|if
condition|(
name|temp
operator|!=
name|val_long
condition|)
block|{
comment|/* Urk, can't represent value in long so print in hex. 		   Do shift in two operations so that if sizeof (long) 		   == sizeof (LONGEST) we can avoid warnings from 		   picky compilers about shifts>= the size of the 		   shiftee in bits */
name|unsigned
name|long
name|vbot
init|=
operator|(
name|unsigned
name|long
operator|)
name|val_long
decl_stmt|;
name|LONGEST
name|temp
init|=
operator|(
name|val_long
operator|>>
operator|(
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|*
name|HOST_CHAR_BIT
operator|-
literal|1
operator|)
operator|)
decl_stmt|;
name|unsigned
name|long
name|vtop
init|=
name|temp
operator|>>
literal|1
decl_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"0x%lx%08lx"
argument_list|,
name|vtop
argument_list|,
name|vbot
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
block|}
block|}
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|CC_HAS_LONG_LONG
argument_list|)
operator|&&
name|defined
argument_list|(
name|PRINTF_HAS_LONG_LONG
argument_list|)
switch|switch
condition|(
name|format
condition|)
block|{
case|case
literal|'d'
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|use_local
condition|?
name|local_decimal_format_custom
argument_list|(
literal|"ll"
argument_list|)
else|:
literal|"%lld"
argument_list|,
name|val_long
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%llu"
argument_list|,
name|val_long
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|use_local
condition|?
name|local_hex_format_custom
argument_list|(
literal|"ll"
argument_list|)
else|:
literal|"%llx"
argument_list|,
name|val_long
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|use_local
condition|?
name|local_octal_format_custom
argument_list|(
literal|"ll"
argument_list|)
else|:
literal|"%llo"
argument_list|,
name|val_long
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|local_hex_format_custom
argument_list|(
literal|"02ll"
argument_list|)
argument_list|,
name|val_long
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|local_hex_format_custom
argument_list|(
literal|"04ll"
argument_list|)
argument_list|,
name|val_long
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|local_hex_format_custom
argument_list|(
literal|"08ll"
argument_list|)
argument_list|,
name|val_long
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|local_hex_format_custom
argument_list|(
literal|"016ll"
argument_list|)
argument_list|,
name|val_long
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
else|#
directive|else
comment|/* !CC_HAS_LONG_LONG || !PRINTF_HAS_LONG_LONG*/
comment|/* In the following it is important to coerce (val_long) to a long. It does      nothing if !LONG_LONG, but it will chop off the top half (which we know      we can ignore) if the host supports long longs.  */
switch|switch
condition|(
name|format
condition|)
block|{
case|case
literal|'d'
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|use_local
condition|?
name|local_decimal_format_custom
argument_list|(
literal|"l"
argument_list|)
else|:
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|val_long
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%lu"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|val_long
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|use_local
condition|?
name|local_hex_format_custom
argument_list|(
literal|"l"
argument_list|)
else|:
literal|"%lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|val_long
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|use_local
condition|?
name|local_octal_format_custom
argument_list|(
literal|"l"
argument_list|)
else|:
literal|"%lo"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|val_long
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|local_hex_format_custom
argument_list|(
literal|"02l"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|val_long
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|local_hex_format_custom
argument_list|(
literal|"04l"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|val_long
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|local_hex_format_custom
argument_list|(
literal|"08l"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|val_long
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|local_hex_format_custom
argument_list|(
literal|"016l"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|val_long
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* CC_HAS_LONG_LONG || PRINTF_HAS_LONG_LONG */
block|}
end_function

begin_function
name|void
name|strcat_longest
parameter_list|(
name|format
parameter_list|,
name|use_local
parameter_list|,
name|val_long
parameter_list|,
name|buf
parameter_list|,
name|buflen
parameter_list|)
name|int
name|format
decl_stmt|;
name|int
name|use_local
decl_stmt|;
name|LONGEST
name|val_long
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|buflen
decl_stmt|;
comment|/* ignored, for now */
block|{
if|#
directive|if
name|defined
argument_list|(
name|CC_HAS_LONG_LONG
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|PRINTF_HAS_LONG_LONG
argument_list|)
name|long
name|vtop
decl_stmt|,
name|vbot
decl_stmt|;
name|vtop
operator|=
name|val_long
operator|>>
operator|(
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|*
name|HOST_CHAR_BIT
operator|)
expr_stmt|;
name|vbot
operator|=
operator|(
name|long
operator|)
name|val_long
expr_stmt|;
if|if
condition|(
operator|(
name|format
operator|==
literal|'d'
operator|&&
operator|(
name|val_long
operator|<
name|INT_MIN
operator|||
name|val_long
operator|>
name|INT_MAX
operator|)
operator|)
operator|||
operator|(
operator|(
name|format
operator|==
literal|'u'
operator|||
name|format
operator|==
literal|'x'
operator|)
operator|&&
operator|(
name|unsigned
name|long
name|long
operator|)
name|val_long
operator|>
name|UINT_MAX
operator|)
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"0x%lx%08lx"
argument_list|,
name|vtop
argument_list|,
name|vbot
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PRINTF_HAS_LONG_LONG
switch|switch
condition|(
name|format
condition|)
block|{
case|case
literal|'d'
case|:
name|sprintf
argument_list|(
name|buf
argument_list|,
operator|(
name|use_local
condition|?
name|local_decimal_format_custom
argument_list|(
literal|"ll"
argument_list|)
else|:
literal|"%lld"
operator|)
argument_list|,
name|val_long
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%llu"
argument_list|,
name|val_long
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|sprintf
argument_list|(
name|buf
argument_list|,
operator|(
name|use_local
condition|?
name|local_hex_format_custom
argument_list|(
literal|"ll"
argument_list|)
else|:
literal|"%llx"
operator|)
argument_list|,
name|val_long
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|sprintf
argument_list|(
name|buf
argument_list|,
operator|(
name|use_local
condition|?
name|local_octal_format_custom
argument_list|(
literal|"ll"
argument_list|)
else|:
literal|"%llo"
operator|)
argument_list|,
name|val_long
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|sprintf
argument_list|(
name|buf
argument_list|,
name|local_hex_format_custom
argument_list|(
literal|"02ll"
argument_list|)
argument_list|,
name|val_long
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|sprintf
argument_list|(
name|buf
argument_list|,
name|local_hex_format_custom
argument_list|(
literal|"04ll"
argument_list|)
argument_list|,
name|val_long
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|sprintf
argument_list|(
name|buf
argument_list|,
name|local_hex_format_custom
argument_list|(
literal|"08ll"
argument_list|)
argument_list|,
name|val_long
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|sprintf
argument_list|(
name|buf
argument_list|,
name|local_hex_format_custom
argument_list|(
literal|"016ll"
argument_list|)
argument_list|,
name|val_long
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
else|#
directive|else
comment|/* !PRINTF_HAS_LONG_LONG */
comment|/* In the following it is important to coerce (val_long) to a long. It does      nothing if !LONG_LONG, but it will chop off the top half (which we know      we can ignore) if the host supports long longs.  */
switch|switch
condition|(
name|format
condition|)
block|{
case|case
literal|'d'
case|:
name|sprintf
argument_list|(
name|buf
argument_list|,
operator|(
name|use_local
condition|?
name|local_decimal_format_custom
argument_list|(
literal|"l"
argument_list|)
else|:
literal|"%ld"
operator|)
argument_list|,
operator|(
operator|(
name|long
operator|)
name|val_long
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%lu"
argument_list|,
operator|(
operator|(
name|unsigned
name|long
operator|)
name|val_long
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|sprintf
argument_list|(
name|buf
argument_list|,
operator|(
name|use_local
condition|?
name|local_hex_format_custom
argument_list|(
literal|"l"
argument_list|)
else|:
literal|"%lx"
operator|)
argument_list|,
operator|(
operator|(
name|long
operator|)
name|val_long
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|sprintf
argument_list|(
name|buf
argument_list|,
operator|(
name|use_local
condition|?
name|local_octal_format_custom
argument_list|(
literal|"l"
argument_list|)
else|:
literal|"%lo"
operator|)
argument_list|,
operator|(
operator|(
name|long
operator|)
name|val_long
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|sprintf
argument_list|(
name|buf
argument_list|,
name|local_hex_format_custom
argument_list|(
literal|"02l"
argument_list|)
argument_list|,
operator|(
operator|(
name|long
operator|)
name|val_long
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|sprintf
argument_list|(
name|buf
argument_list|,
name|local_hex_format_custom
argument_list|(
literal|"04l"
argument_list|)
argument_list|,
operator|(
operator|(
name|long
operator|)
name|val_long
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|sprintf
argument_list|(
name|buf
argument_list|,
name|local_hex_format_custom
argument_list|(
literal|"08l"
argument_list|)
argument_list|,
operator|(
operator|(
name|long
operator|)
name|val_long
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|sprintf
argument_list|(
name|buf
argument_list|,
name|local_hex_format_custom
argument_list|(
literal|"016l"
argument_list|)
argument_list|,
operator|(
operator|(
name|long
operator|)
name|val_long
operator|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* !PRINTF_HAS_LONG_LONG */
block|}
end_function

begin_comment
comment|/* This used to be a macro, but I don't think it is called often enough    to merit such treatment.  */
end_comment

begin_comment
comment|/* Convert a LONGEST to an int.  This is used in contexts (e.g. number of    arguments to a function, number in a value history, register number, etc.)    where the value must not be larger than can fit in an int.  */
end_comment

begin_function
name|int
name|longest_to_int
parameter_list|(
name|arg
parameter_list|)
name|LONGEST
name|arg
decl_stmt|;
block|{
comment|/* Let the compiler do the work */
name|int
name|rtnval
init|=
operator|(
name|int
operator|)
name|arg
decl_stmt|;
comment|/* Check for overflows or underflows */
if|if
condition|(
sizeof|sizeof
argument_list|(
name|LONGEST
argument_list|)
operator|>
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|)
block|{
if|if
condition|(
name|rtnval
operator|!=
name|arg
condition|)
block|{
name|error
argument_list|(
literal|"Value out of range."
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|rtnval
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Print a floating point value of type TYPE, pointed to in GDB by VALADDR,    on STREAM.  */
end_comment

begin_function
name|void
name|print_floating
parameter_list|(
name|valaddr
parameter_list|,
name|type
parameter_list|,
name|stream
parameter_list|)
name|char
modifier|*
name|valaddr
decl_stmt|;
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|DOUBLEST
name|doub
decl_stmt|;
name|int
name|inv
decl_stmt|;
name|unsigned
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|IEEE_FLOAT
argument_list|)
comment|/* Check for NaN's.  Note that this code does not depend on us being      on an IEEE conforming system.  It only depends on the target      machine using IEEE representation.  This means (a)      cross-debugging works right, and (2) IEEE_FLOAT can (and should)      be defined for systems like the 68881, which uses IEEE      representation, but is not IEEE conforming.  */
block|{
name|unsigned
name|long
name|low
decl_stmt|,
name|high
decl_stmt|;
comment|/* Is the sign bit 0?  */
name|int
name|nonnegative
decl_stmt|;
comment|/* Is it is a NaN (i.e. the exponent is all ones and        the fraction is nonzero)?  */
name|int
name|is_nan
decl_stmt|;
comment|/* For lint, initialize these two variables to suppress warning: */
name|low
operator|=
name|high
operator|=
name|nonnegative
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|4
condition|)
block|{
comment|/* It's single precision.  */
comment|/* Assume that floating point byte order is the same as 	   integer byte order.  */
name|low
operator|=
name|extract_unsigned_integer
argument_list|(
name|valaddr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|nonnegative
operator|=
operator|(
operator|(
name|low
operator|&
literal|0x80000000
operator|)
operator|==
literal|0
operator|)
expr_stmt|;
name|is_nan
operator|=
operator|(
operator|(
operator|(
operator|(
name|low
operator|>>
literal|23
operator|)
operator|&
literal|0xFF
operator|)
operator|==
literal|0xFF
operator|)
operator|&&
literal|0
operator|!=
operator|(
name|low
operator|&
literal|0x7FFFFF
operator|)
operator|)
expr_stmt|;
name|low
operator|&=
literal|0x7fffff
expr_stmt|;
name|high
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|len
operator|==
literal|8
condition|)
block|{
comment|/* It's double precision.  Get the high and low words.  */
comment|/* Assume that floating point byte order is the same as 	   integer byte order.  */
if|if
condition|(
name|TARGET_BYTE_ORDER
operator|==
name|BIG_ENDIAN
condition|)
block|{
name|low
operator|=
name|extract_unsigned_integer
argument_list|(
name|valaddr
operator|+
literal|4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|high
operator|=
name|extract_unsigned_integer
argument_list|(
name|valaddr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|low
operator|=
name|extract_unsigned_integer
argument_list|(
name|valaddr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|high
operator|=
name|extract_unsigned_integer
argument_list|(
name|valaddr
operator|+
literal|4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
name|nonnegative
operator|=
operator|(
operator|(
name|high
operator|&
literal|0x80000000
operator|)
operator|==
literal|0
operator|)
expr_stmt|;
name|is_nan
operator|=
operator|(
operator|(
operator|(
name|high
operator|>>
literal|20
operator|)
operator|&
literal|0x7ff
operator|)
operator|==
literal|0x7ff
operator|&&
operator|!
operator|(
operator|(
operator|(
operator|(
name|high
operator|&
literal|0xfffff
operator|)
operator|==
literal|0
operator|)
operator|)
operator|&&
operator|(
name|low
operator|==
literal|0
operator|)
operator|)
operator|)
expr_stmt|;
name|high
operator|&=
literal|0xfffff
expr_stmt|;
block|}
else|else
comment|/* Extended.  We can't detect NaNs for extendeds yet.  Also note 	 that currently extendeds get nuked to double in 	 REGISTER_CONVERTIBLE.  */
name|is_nan
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|is_nan
condition|)
block|{
comment|/* The meaning of the sign and fraction is not defined by IEEE. 	   But the user might know what they mean.  For example, they 	   (in an implementation-defined manner) distinguish between 	   signaling and quiet NaN's.  */
if|if
condition|(
name|high
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"-NaN(0x%lx%.8lx)"
operator|+
name|nonnegative
argument_list|,
name|high
argument_list|,
name|low
argument_list|)
expr_stmt|;
else|else
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"-NaN(0x%lx)"
operator|+
name|nonnegative
argument_list|,
name|low
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
endif|#
directive|endif
comment|/* IEEE_FLOAT.  */
name|doub
operator|=
name|unpack_double
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|,
operator|&
name|inv
argument_list|)
expr_stmt|;
if|if
condition|(
name|inv
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<invalid float value>"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|len
operator|<
sizeof|sizeof
argument_list|(
name|double
argument_list|)
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%.9g"
argument_list|,
operator|(
name|double
operator|)
name|doub
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|len
operator|==
sizeof|sizeof
argument_list|(
name|double
argument_list|)
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%.17g"
argument_list|,
operator|(
name|double
operator|)
name|doub
argument_list|)
expr_stmt|;
else|else
ifdef|#
directive|ifdef
name|PRINTF_HAS_LONG_DOUBLE
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%.35Lg"
argument_list|,
name|doub
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* This at least wins with values that are representable as doubles */
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%.17g"
argument_list|,
operator|(
name|double
operator|)
name|doub
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|print_binary_chars
parameter_list|(
name|stream
parameter_list|,
name|valaddr
parameter_list|,
name|len
parameter_list|)
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
name|unsigned
name|char
modifier|*
name|valaddr
decl_stmt|;
name|unsigned
name|len
decl_stmt|;
block|{
define|#
directive|define
name|BITS_IN_BYTES
value|8
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|b
decl_stmt|;
comment|/* Declared "int" so it will be signed.    * This ensures that right shift will shift in zeros.    */
specifier|const
name|int
name|mask
init|=
literal|0x080
decl_stmt|;
comment|/* FIXME: We should be not printing leading zeroes in most cases.  */
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|local_binary_format_prefix
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_BYTE_ORDER
operator|==
name|BIG_ENDIAN
condition|)
block|{
for|for
control|(
name|p
operator|=
name|valaddr
init|;
name|p
operator|<
name|valaddr
operator|+
name|len
condition|;
name|p
operator|++
control|)
block|{
comment|/* Every byte has 8 binary characters; peel off            * and print from the MSB end.            */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|BITS_IN_BYTES
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|&
operator|(
name|mask
operator|>>
name|i
operator|)
condition|)
name|b
operator|=
literal|1
expr_stmt|;
else|else
name|b
operator|=
literal|0
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%1d"
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|p
operator|=
name|valaddr
operator|+
name|len
operator|-
literal|1
init|;
name|p
operator|>=
name|valaddr
condition|;
name|p
operator|--
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|BITS_IN_BYTES
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|&
operator|(
name|mask
operator|>>
name|i
operator|)
condition|)
name|b
operator|=
literal|1
expr_stmt|;
else|else
name|b
operator|=
literal|0
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%1d"
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|local_binary_format_suffix
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* VALADDR points to an integer of LEN bytes.  * Print it in octal on stream or format it in buf.  */
end_comment

begin_function
name|void
name|print_octal_chars
parameter_list|(
name|stream
parameter_list|,
name|valaddr
parameter_list|,
name|len
parameter_list|)
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
name|unsigned
name|char
modifier|*
name|valaddr
decl_stmt|;
name|unsigned
name|len
decl_stmt|;
block|{
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|char
name|octa1
decl_stmt|,
name|octa2
decl_stmt|,
name|octa3
decl_stmt|,
name|carry
decl_stmt|;
name|int
name|cycle
decl_stmt|;
comment|/* FIXME: We should be not printing leading zeroes in most cases.  */
comment|/* Octal is 3 bits, which doesn't fit.  Yuk.  So we have to track    * the extra bits, which cycle every three bytes:    *    * Byte side:       0            1             2          3    *                         |             |            |            |    * bit number   123 456 78 | 9 012 345 6 | 78 901 234 | 567 890 12 |    *    * Octal side:   0   1   carry  3   4  carry ...    *    * Cycle number:    0             1            2    *    * But of course we are printing from the high side, so we have to    * figure out where in the cycle we are so that we end up with no    * left over bits at the end.    */
define|#
directive|define
name|BITS_IN_OCTAL
value|3
define|#
directive|define
name|HIGH_ZERO
value|0340
define|#
directive|define
name|LOW_ZERO
value|0016
define|#
directive|define
name|CARRY_ZERO
value|0003
define|#
directive|define
name|HIGH_ONE
value|0200
define|#
directive|define
name|MID_ONE
value|0160
define|#
directive|define
name|LOW_ONE
value|0016
define|#
directive|define
name|CARRY_ONE
value|0001
define|#
directive|define
name|HIGH_TWO
value|0300
define|#
directive|define
name|MID_TWO
value|0070
define|#
directive|define
name|LOW_TWO
value|0007
comment|/* For 32 we start in cycle 2, with two bits and one bit carry;    * for 64 in cycle in cycle 1, with one bit and a two bit carry.    */
name|cycle
operator|=
operator|(
name|len
operator|*
name|BITS_IN_BYTES
operator|)
operator|%
name|BITS_IN_OCTAL
expr_stmt|;
name|carry
operator|=
literal|0
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|local_octal_format_prefix
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_BYTE_ORDER
operator|==
name|BIG_ENDIAN
condition|)
block|{
for|for
control|(
name|p
operator|=
name|valaddr
init|;
name|p
operator|<
name|valaddr
operator|+
name|len
condition|;
name|p
operator|++
control|)
block|{
switch|switch
condition|(
name|cycle
condition|)
block|{
case|case
literal|0
case|:
comment|/* No carry in, carry out two bits.                   */
name|octa1
operator|=
operator|(
name|HIGH_ZERO
operator|&
operator|*
name|p
operator|)
operator|>>
literal|5
expr_stmt|;
name|octa2
operator|=
operator|(
name|LOW_ZERO
operator|&
operator|*
name|p
operator|)
operator|>>
literal|2
expr_stmt|;
name|carry
operator|=
operator|(
name|CARRY_ZERO
operator|&
operator|*
name|p
operator|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%o"
argument_list|,
name|octa1
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%o"
argument_list|,
name|octa2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* Carry in two bits, carry out one bit.                   */
name|octa1
operator|=
operator|(
name|carry
operator|<<
literal|1
operator|)
operator||
operator|(
operator|(
name|HIGH_ONE
operator|&
operator|*
name|p
operator|)
operator|>>
literal|7
operator|)
expr_stmt|;
name|octa2
operator|=
operator|(
name|MID_ONE
operator|&
operator|*
name|p
operator|)
operator|>>
literal|4
expr_stmt|;
name|octa3
operator|=
operator|(
name|LOW_ONE
operator|&
operator|*
name|p
operator|)
operator|>>
literal|1
expr_stmt|;
name|carry
operator|=
operator|(
name|CARRY_ONE
operator|&
operator|*
name|p
operator|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%o"
argument_list|,
name|octa1
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%o"
argument_list|,
name|octa2
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%o"
argument_list|,
name|octa3
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* Carry in one bit, no carry out.                   */
name|octa1
operator|=
operator|(
name|carry
operator|<<
literal|2
operator|)
operator||
operator|(
operator|(
name|HIGH_TWO
operator|&
operator|*
name|p
operator|)
operator|>>
literal|6
operator|)
expr_stmt|;
name|octa2
operator|=
operator|(
name|MID_TWO
operator|&
operator|*
name|p
operator|)
operator|>>
literal|3
expr_stmt|;
name|octa3
operator|=
operator|(
name|LOW_TWO
operator|&
operator|*
name|p
operator|)
expr_stmt|;
name|carry
operator|=
literal|0
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%o"
argument_list|,
name|octa1
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%o"
argument_list|,
name|octa2
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%o"
argument_list|,
name|octa3
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Internal error in octal conversion;"
argument_list|)
expr_stmt|;
block|}
name|cycle
operator|++
expr_stmt|;
name|cycle
operator|=
name|cycle
operator|%
name|BITS_IN_OCTAL
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|p
operator|=
name|valaddr
operator|+
name|len
operator|-
literal|1
init|;
name|p
operator|>=
name|valaddr
condition|;
name|p
operator|--
control|)
block|{
switch|switch
condition|(
name|cycle
condition|)
block|{
case|case
literal|0
case|:
comment|/* Carry out, no carry in */
name|octa1
operator|=
operator|(
name|HIGH_ZERO
operator|&
operator|*
name|p
operator|)
operator|>>
literal|5
expr_stmt|;
name|octa2
operator|=
operator|(
name|LOW_ZERO
operator|&
operator|*
name|p
operator|)
operator|>>
literal|2
expr_stmt|;
name|carry
operator|=
operator|(
name|CARRY_ZERO
operator|&
operator|*
name|p
operator|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%o"
argument_list|,
name|octa1
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%o"
argument_list|,
name|octa2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* Carry in, carry out */
name|octa1
operator|=
operator|(
name|carry
operator|<<
literal|1
operator|)
operator||
operator|(
operator|(
name|HIGH_ONE
operator|&
operator|*
name|p
operator|)
operator|>>
literal|7
operator|)
expr_stmt|;
name|octa2
operator|=
operator|(
name|MID_ONE
operator|&
operator|*
name|p
operator|)
operator|>>
literal|4
expr_stmt|;
name|octa3
operator|=
operator|(
name|LOW_ONE
operator|&
operator|*
name|p
operator|)
operator|>>
literal|1
expr_stmt|;
name|carry
operator|=
operator|(
name|CARRY_ONE
operator|&
operator|*
name|p
operator|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%o"
argument_list|,
name|octa1
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%o"
argument_list|,
name|octa2
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%o"
argument_list|,
name|octa3
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* Carry in, no carry out */
name|octa1
operator|=
operator|(
name|carry
operator|<<
literal|2
operator|)
operator||
operator|(
operator|(
name|HIGH_TWO
operator|&
operator|*
name|p
operator|)
operator|>>
literal|6
operator|)
expr_stmt|;
name|octa2
operator|=
operator|(
name|MID_TWO
operator|&
operator|*
name|p
operator|)
operator|>>
literal|3
expr_stmt|;
name|octa3
operator|=
operator|(
name|LOW_TWO
operator|&
operator|*
name|p
operator|)
expr_stmt|;
name|carry
operator|=
literal|0
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%o"
argument_list|,
name|octa1
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%o"
argument_list|,
name|octa2
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%o"
argument_list|,
name|octa3
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Internal error in octal conversion;"
argument_list|)
expr_stmt|;
block|}
name|cycle
operator|++
expr_stmt|;
name|cycle
operator|=
name|cycle
operator|%
name|BITS_IN_OCTAL
expr_stmt|;
block|}
block|}
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|local_octal_format_suffix
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* VALADDR points to an integer of LEN bytes.  * Print it in decimal on stream or format it in buf.  */
end_comment

begin_function
name|void
name|print_decimal_chars
parameter_list|(
name|stream
parameter_list|,
name|valaddr
parameter_list|,
name|len
parameter_list|)
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
name|unsigned
name|char
modifier|*
name|valaddr
decl_stmt|;
name|unsigned
name|len
decl_stmt|;
block|{
define|#
directive|define
name|TEN
value|10
define|#
directive|define
name|TWO_TO_FOURTH
value|16
define|#
directive|define
name|CARRY_OUT
parameter_list|(
name|x
parameter_list|)
value|((x) / TEN)
comment|/* extend char to int */
define|#
directive|define
name|CARRY_LEFT
parameter_list|(
name|x
parameter_list|)
value|((x) % TEN)
define|#
directive|define
name|SHIFT
parameter_list|(
name|x
parameter_list|)
value|((x)<< 4)
define|#
directive|define
name|START_P
define|\
value|((TARGET_BYTE_ORDER == BIG_ENDIAN) ? valaddr : valaddr + len - 1)
define|#
directive|define
name|NOT_END_P
define|\
value|((TARGET_BYTE_ORDER == BIG_ENDIAN) ? (p< valaddr + len) : (p>= valaddr))
define|#
directive|define
name|NEXT_P
define|\
value|((TARGET_BYTE_ORDER == BIG_ENDIAN) ? p++ : p-- )
define|#
directive|define
name|LOW_NIBBLE
parameter_list|(
name|x
parameter_list|)
value|( (x)& 0x00F)
define|#
directive|define
name|HIGH_NIBBLE
parameter_list|(
name|x
parameter_list|)
value|(((x)& 0x0F0)>> 4)
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|char
modifier|*
name|digits
decl_stmt|;
name|int
name|carry
decl_stmt|;
name|int
name|decimal_len
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|decimal_digits
decl_stmt|;
name|int
name|dummy
decl_stmt|;
name|int
name|flip
decl_stmt|;
comment|/* Base-ten number is less than twice as many digits    * as the base 16 number, which is 2 digits per byte.    */
name|decimal_len
operator|=
name|len
operator|*
literal|2
operator|*
literal|2
expr_stmt|;
name|digits
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|decimal_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|digits
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Can't allocate memory for conversion to decimal."
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|decimal_len
condition|;
name|i
operator|++
control|)
block|{
name|digits
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|local_decimal_format_prefix
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Ok, we have an unknown number of bytes of data to be printed in    * decimal.    *    * Given a hex number (in nibbles) as XYZ, we start by taking X and    * decemalizing it as "x1 x2" in two decimal nibbles.  Then we multiply    * the nibbles by 16, add Y and re-decimalize.  Repeat with Z.    *    * The trick is that "digits" holds a base-10 number, but sometimes    * the individual digits are> 10.     *    * Outer loop is per nibble (hex digit) of input, from MSD end to    * LSD end.    */
name|decimal_digits
operator|=
literal|0
expr_stmt|;
comment|/* Number of decimal digits so far */
name|p
operator|=
name|START_P
expr_stmt|;
name|flip
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|NOT_END_P
condition|)
block|{
comment|/*        * Multiply current base-ten number by 16 in place.        * Each digit was between 0 and 9, now is between        * 0 and 144.        */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|decimal_digits
condition|;
name|j
operator|++
control|)
block|{
name|digits
index|[
name|j
index|]
operator|=
name|SHIFT
argument_list|(
name|digits
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Take the next nibble off the input and add it to what        * we've got in the LSB position.  Bottom 'digit' is now        * between 0 and 159.        *        * "flip" is used to run this loop twice for each byte.        */
if|if
condition|(
name|flip
operator|==
literal|0
condition|)
block|{
comment|/* Take top nibble.            */
name|digits
index|[
literal|0
index|]
operator|+=
name|HIGH_NIBBLE
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
name|flip
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Take low nibble and bump our pointer "p".            */
name|digits
index|[
literal|0
index|]
operator|+=
name|LOW_NIBBLE
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
name|NEXT_P
expr_stmt|;
name|flip
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Re-decimalize.  We have to do this often enough        * that we don't overflow, but once per nibble is        * overkill.  Easier this way, though.  Note that the        * carry is often larger than 10 (e.g. max initial        * carry out of lowest nibble is 15, could bubble all        * the way up greater than 10).  So we have to do        * the carrying beyond the last current digit.        */
name|carry
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|decimal_len
operator|-
literal|1
condition|;
name|j
operator|++
control|)
block|{
name|digits
index|[
name|j
index|]
operator|+=
name|carry
expr_stmt|;
comment|/* "/" won't handle an unsigned char with            * a value that if signed would be negative.            * So extend to longword int via "dummy".            */
name|dummy
operator|=
name|digits
index|[
name|j
index|]
expr_stmt|;
name|carry
operator|=
name|CARRY_OUT
argument_list|(
name|dummy
argument_list|)
expr_stmt|;
name|digits
index|[
name|j
index|]
operator|=
name|CARRY_LEFT
argument_list|(
name|dummy
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|>=
name|decimal_digits
operator|&&
name|carry
operator|==
literal|0
condition|)
block|{
comment|/*                * All higher digits are 0 and we                * no longer have a carry.                *                * Note: "j" is 0-based, "decimal_digits" is                *       1-based.                */
name|decimal_digits
operator|=
name|j
operator|+
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* Ok, now "digits" is the decimal representation, with    * the "decimal_digits" actual digits.  Print!    */
for|for
control|(
name|i
operator|=
name|decimal_digits
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%1d"
argument_list|,
name|digits
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|digits
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|local_decimal_format_suffix
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* VALADDR points to an integer of LEN bytes.  Print it in hex on stream.  */
end_comment

begin_function
specifier|static
name|void
name|print_hex_chars
parameter_list|(
name|stream
parameter_list|,
name|valaddr
parameter_list|,
name|len
parameter_list|)
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
name|unsigned
name|char
modifier|*
name|valaddr
decl_stmt|;
name|unsigned
name|len
decl_stmt|;
block|{
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
comment|/* FIXME: We should be not printing leading zeroes in most cases.  */
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|local_hex_format_prefix
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_BYTE_ORDER
operator|==
name|BIG_ENDIAN
condition|)
block|{
for|for
control|(
name|p
operator|=
name|valaddr
init|;
name|p
operator|<
name|valaddr
operator|+
name|len
condition|;
name|p
operator|++
control|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%02x"
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|p
operator|=
name|valaddr
operator|+
name|len
operator|-
literal|1
init|;
name|p
operator|>=
name|valaddr
condition|;
name|p
operator|--
control|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%02x"
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|local_hex_format_suffix
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  Called by various<lang>_val_print routines to print elements of an     array in the form "<elem1>,<elem2>,<elem3>, ...".      (FIXME?)  Assumes array element separator is a comma, which is correct     for all languages currently handled.     (FIXME?)  Some languages have a notation for repeated array elements,     perhaps we should try to use that notation when appropriate.     */
end_comment

begin_function
name|void
name|val_print_array_elements
parameter_list|(
name|type
parameter_list|,
name|valaddr
parameter_list|,
name|address
parameter_list|,
name|stream
parameter_list|,
name|format
parameter_list|,
name|deref_ref
parameter_list|,
name|recurse
parameter_list|,
name|pretty
parameter_list|,
name|i
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|char
modifier|*
name|valaddr
decl_stmt|;
name|CORE_ADDR
name|address
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|format
decl_stmt|;
name|int
name|deref_ref
decl_stmt|;
name|int
name|recurse
decl_stmt|;
name|enum
name|val_prettyprint
name|pretty
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
block|{
name|unsigned
name|int
name|things_printed
init|=
literal|0
decl_stmt|;
name|unsigned
name|len
decl_stmt|;
name|struct
name|type
modifier|*
name|elttype
decl_stmt|;
name|unsigned
name|eltlen
decl_stmt|;
comment|/* Position of the array element we are examining to see      whether it is repeated.  */
name|unsigned
name|int
name|rep1
decl_stmt|;
comment|/* Number of repetitions we have detected so far.  */
name|unsigned
name|int
name|reps
decl_stmt|;
name|elttype
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|eltlen
operator|=
name|TYPE_LENGTH
argument_list|(
name|check_typedef
argument_list|(
name|elttype
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|/
name|eltlen
expr_stmt|;
name|annotate_array_section_begin
argument_list|(
name|i
argument_list|,
name|elttype
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|len
operator|&&
name|things_printed
operator|<
name|print_max
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|prettyprint_arrays
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|",\n"
argument_list|)
expr_stmt|;
name|print_spaces_filtered
argument_list|(
literal|2
operator|+
literal|2
operator|*
name|recurse
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
block|}
block|}
name|wrap_here
argument_list|(
name|n_spaces
argument_list|(
literal|2
operator|+
literal|2
operator|*
name|recurse
argument_list|)
argument_list|)
expr_stmt|;
name|rep1
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|reps
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|rep1
operator|<
name|len
operator|)
operator|&&
operator|!
name|memcmp
argument_list|(
name|valaddr
operator|+
name|i
operator|*
name|eltlen
argument_list|,
name|valaddr
operator|+
name|rep1
operator|*
name|eltlen
argument_list|,
name|eltlen
argument_list|)
condition|)
block|{
operator|++
name|reps
expr_stmt|;
operator|++
name|rep1
expr_stmt|;
block|}
if|if
condition|(
name|reps
operator|>
name|repeat_count_threshold
condition|)
block|{
name|val_print
argument_list|(
name|elttype
argument_list|,
name|valaddr
operator|+
name|i
operator|*
name|eltlen
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|deref_ref
argument_list|,
name|recurse
operator|+
literal|1
argument_list|,
name|pretty
argument_list|)
expr_stmt|;
name|annotate_elt_rep
argument_list|(
name|reps
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<repeats %u times>"
argument_list|,
name|reps
argument_list|)
expr_stmt|;
name|annotate_elt_rep_end
argument_list|()
expr_stmt|;
name|i
operator|=
name|rep1
operator|-
literal|1
expr_stmt|;
name|things_printed
operator|+=
name|repeat_count_threshold
expr_stmt|;
block|}
else|else
block|{
name|val_print
argument_list|(
name|elttype
argument_list|,
name|valaddr
operator|+
name|i
operator|*
name|eltlen
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|deref_ref
argument_list|,
name|recurse
operator|+
literal|1
argument_list|,
name|pretty
argument_list|)
expr_stmt|;
name|annotate_elt
argument_list|()
expr_stmt|;
name|things_printed
operator|++
expr_stmt|;
block|}
block|}
name|annotate_array_section_end
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|len
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"..."
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  Print a string from the inferior, starting at ADDR and printing up to LEN     characters, of WIDTH bytes a piece, to STREAM.  If LEN is -1, printing     stops at the first null byte, otherwise printing proceeds (including null     bytes) until either print_max or LEN characters have been printed,     whichever is smaller. */
end_comment

begin_comment
comment|/* FIXME: Use target_read_string.  */
end_comment

begin_function
name|int
name|val_print_string
parameter_list|(
name|addr
parameter_list|,
name|len
parameter_list|,
name|width
parameter_list|,
name|stream
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|width
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|int
name|force_ellipsis
init|=
literal|0
decl_stmt|;
comment|/* Force ellipsis to be printed if nonzero. */
name|int
name|errcode
decl_stmt|;
comment|/* Errno returned from bad reads. */
name|unsigned
name|int
name|fetchlimit
decl_stmt|;
comment|/* Maximum number of chars to print. */
name|unsigned
name|int
name|nfetch
decl_stmt|;
comment|/* Chars to fetch / chars fetched. */
name|unsigned
name|int
name|chunksize
decl_stmt|;
comment|/* Size of each fetch, in chars. */
name|char
modifier|*
name|buffer
init|=
name|NULL
decl_stmt|;
comment|/* Dynamically growable fetch buffer. */
name|char
modifier|*
name|bufptr
decl_stmt|;
comment|/* Pointer to next available byte in buffer. */
name|char
modifier|*
name|limit
decl_stmt|;
comment|/* First location past end of fetch buffer. */
name|struct
name|cleanup
modifier|*
name|old_chain
init|=
name|NULL
decl_stmt|;
comment|/* Top of the old cleanup chain. */
name|int
name|found_nul
decl_stmt|;
comment|/* Non-zero if we found the nul char */
comment|/* First we need to figure out the limit on the number of characters we are      going to attempt to fetch and print.  This is actually pretty simple.  If      LEN>= zero, then the limit is the minimum of LEN and print_max.  If      LEN is -1, then the limit is print_max.  This is true regardless of      whether print_max is zero, UINT_MAX (unlimited), or something in between,      because finding the null byte (or available memory) is what actually      limits the fetch. */
name|fetchlimit
operator|=
operator|(
name|len
operator|==
operator|-
literal|1
condition|?
name|print_max
else|:
name|min
argument_list|(
name|len
argument_list|,
name|print_max
argument_list|)
operator|)
expr_stmt|;
comment|/* Now decide how large of chunks to try to read in one operation.  This      is also pretty simple.  If LEN>= zero, then we want fetchlimit chars,      so we might as well read them all in one operation.  If LEN is -1, we      are looking for a null terminator to end the fetching, so we might as      well read in blocks that are large enough to be efficient, but not so      large as to be slow if fetchlimit happens to be large.  So we choose the      minimum of 8 and fetchlimit.  We used to use 200 instead of 8 but      200 is way too big for remote debugging over a serial line.  */
name|chunksize
operator|=
operator|(
name|len
operator|==
operator|-
literal|1
condition|?
name|min
argument_list|(
literal|8
argument_list|,
name|fetchlimit
argument_list|)
else|:
name|fetchlimit
operator|)
expr_stmt|;
comment|/* Loop until we either have all the characters to print, or we encounter      some error, such as bumping into the end of the address space. */
name|found_nul
operator|=
literal|0
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|null_cleanup
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|len
operator|*
name|width
argument_list|)
expr_stmt|;
name|bufptr
operator|=
name|buffer
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|nfetch
operator|=
name|target_read_memory_partial
argument_list|(
name|addr
argument_list|,
name|bufptr
argument_list|,
name|len
operator|*
name|width
argument_list|,
operator|&
name|errcode
argument_list|)
operator|/
name|width
expr_stmt|;
name|addr
operator|+=
name|nfetch
operator|*
name|width
expr_stmt|;
name|bufptr
operator|+=
name|nfetch
operator|*
name|width
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|len
operator|==
operator|-
literal|1
condition|)
block|{
name|unsigned
name|long
name|bufsize
init|=
literal|0
decl_stmt|;
do|do
block|{
name|QUIT
expr_stmt|;
name|nfetch
operator|=
name|min
argument_list|(
name|chunksize
argument_list|,
name|fetchlimit
operator|-
name|bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
operator|==
name|NULL
condition|)
name|buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|nfetch
operator|*
name|width
argument_list|)
expr_stmt|;
else|else
block|{
name|discard_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
name|buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|buffer
argument_list|,
operator|(
name|nfetch
operator|+
name|bufsize
operator|)
operator|*
name|width
argument_list|)
expr_stmt|;
block|}
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|bufptr
operator|=
name|buffer
operator|+
name|bufsize
operator|*
name|width
expr_stmt|;
name|bufsize
operator|+=
name|nfetch
expr_stmt|;
comment|/* Read as much as we can. */
name|nfetch
operator|=
name|target_read_memory_partial
argument_list|(
name|addr
argument_list|,
name|bufptr
argument_list|,
name|nfetch
operator|*
name|width
argument_list|,
operator|&
name|errcode
argument_list|)
operator|/
name|width
expr_stmt|;
comment|/* Scan this chunk for the null byte that terminates the string 	     to print.  If found, we don't need to fetch any more.  Note 	     that bufptr is explicitly left pointing at the next character 	     after the null byte, or at the next character after the end of 	     the buffer. */
name|limit
operator|=
name|bufptr
operator|+
name|nfetch
operator|*
name|width
expr_stmt|;
while|while
condition|(
name|bufptr
operator|<
name|limit
condition|)
block|{
name|unsigned
name|long
name|c
decl_stmt|;
name|c
operator|=
name|extract_unsigned_integer
argument_list|(
name|bufptr
argument_list|,
name|width
argument_list|)
expr_stmt|;
name|addr
operator|+=
name|width
expr_stmt|;
name|bufptr
operator|+=
name|width
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
comment|/* We don't care about any error which happened after 		     the NULL terminator.  */
name|errcode
operator|=
literal|0
expr_stmt|;
name|found_nul
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
do|while
condition|(
name|errcode
operator|==
literal|0
comment|/* no error */
operator|&&
name|bufptr
operator|-
name|buffer
operator|<
name|fetchlimit
operator|*
name|width
comment|/* no overrun */
operator|&&
operator|!
name|found_nul
condition|)
do|;
comment|/* haven't found nul yet */
block|}
else|else
block|{
comment|/* length of string is really 0! */
name|buffer
operator|=
name|bufptr
operator|=
name|NULL
expr_stmt|;
name|errcode
operator|=
literal|0
expr_stmt|;
block|}
comment|/* bufptr and addr now point immediately beyond the last byte which we      consider part of the string (including a '\0' which ends the string).  */
comment|/* We now have either successfully filled the buffer to fetchlimit, or      terminated early due to an error or finding a null char when LEN is -1. */
if|if
condition|(
name|len
operator|==
operator|-
literal|1
operator|&&
operator|!
name|found_nul
condition|)
block|{
name|char
modifier|*
name|peekbuf
decl_stmt|;
comment|/* We didn't find a null terminator we were looking for.  Attempt 	 to peek at the next character.  If not successful, or it is not 	 a null byte, then force ellipsis to be printed.  */
name|peekbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|width
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_read_memory
argument_list|(
name|addr
argument_list|,
name|peekbuf
argument_list|,
name|width
argument_list|)
operator|==
literal|0
operator|&&
name|extract_unsigned_integer
argument_list|(
name|peekbuf
argument_list|,
name|width
argument_list|)
operator|!=
literal|0
condition|)
name|force_ellipsis
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|len
operator|>=
literal|0
operator|&&
name|errcode
operator|!=
literal|0
operator|)
operator|||
operator|(
name|len
operator|>
operator|(
name|bufptr
operator|-
name|buffer
operator|)
operator|/
name|width
operator|)
condition|)
block|{
comment|/* Getting an error when we have a requested length, or fetching less 	 than the number of characters actually requested, always make us 	 print ellipsis. */
name|force_ellipsis
operator|=
literal|1
expr_stmt|;
block|}
name|QUIT
expr_stmt|;
comment|/* If we get an error before fetching anything, don't print a string.      But if we fetch something and then get an error, print the string      and then the error message.  */
if|if
condition|(
name|errcode
operator|==
literal|0
operator|||
name|bufptr
operator|>
name|buffer
condition|)
block|{
if|if
condition|(
name|addressprint
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|" "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
name|LA_PRINT_STRING
argument_list|(
name|stream
argument_list|,
name|buffer
argument_list|,
operator|(
name|bufptr
operator|-
name|buffer
operator|)
operator|/
name|width
argument_list|,
name|width
argument_list|,
name|force_ellipsis
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|errcode
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|errcode
operator|==
name|EIO
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<Address "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" out of bounds>"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<Error reading address "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|": %s>"
argument_list|,
name|safe_strerror
argument_list|(
name|errcode
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|gdb_flush
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|bufptr
operator|-
name|buffer
operator|)
operator|/
name|width
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Validate an input or output radix setting, and make sure the user    knows what they really did here.  Radix setting is confusing, e.g.    setting the input radix to "10" never changes it!  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|set_input_radix
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|,
name|c
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
block|{
name|set_input_radix_1
argument_list|(
name|from_tty
argument_list|,
operator|*
operator|(
name|unsigned
operator|*
operator|)
name|c
operator|->
name|var
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|set_input_radix_1
parameter_list|(
name|from_tty
parameter_list|,
name|radix
parameter_list|)
name|int
name|from_tty
decl_stmt|;
name|unsigned
name|radix
decl_stmt|;
block|{
comment|/* We don't currently disallow any input radix except 0 or 1, which don't      make any mathematical sense.  In theory, we can deal with any input      radix greater than 1, even if we don't have unique digits for every      value from 0 to radix-1, but in practice we lose on large radix values.      We should either fix the lossage or restrict the radix range more.      (FIXME). */
if|if
condition|(
name|radix
operator|<
literal|2
condition|)
block|{
name|error
argument_list|(
literal|"Nonsense input radix ``decimal %u''; input radix unchanged."
argument_list|,
name|radix
argument_list|)
expr_stmt|;
block|}
name|input_radix
operator|=
name|radix
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Input radix now set to decimal %u, hex %x, octal %o.\n"
argument_list|,
name|radix
argument_list|,
name|radix
argument_list|,
name|radix
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|set_output_radix
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|,
name|c
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
block|{
name|set_output_radix_1
argument_list|(
name|from_tty
argument_list|,
operator|*
operator|(
name|unsigned
operator|*
operator|)
name|c
operator|->
name|var
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_output_radix_1
parameter_list|(
name|from_tty
parameter_list|,
name|radix
parameter_list|)
name|int
name|from_tty
decl_stmt|;
name|unsigned
name|radix
decl_stmt|;
block|{
comment|/* Validate the radix and disallow ones that we aren't prepared to      handle correctly, leaving the radix unchanged. */
switch|switch
condition|(
name|radix
condition|)
block|{
case|case
literal|16
case|:
name|output_format
operator|=
literal|'x'
expr_stmt|;
comment|/* hex */
break|break;
case|case
literal|10
case|:
name|output_format
operator|=
literal|0
expr_stmt|;
comment|/* decimal */
break|break;
case|case
literal|8
case|:
name|output_format
operator|=
literal|'o'
expr_stmt|;
comment|/* octal */
break|break;
default|default:
name|error
argument_list|(
literal|"Unsupported output radix ``decimal %u''; output radix unchanged."
argument_list|,
name|radix
argument_list|)
expr_stmt|;
block|}
name|output_radix
operator|=
name|radix
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Output radix now set to decimal %u, hex %x, octal %o.\n"
argument_list|,
name|radix
argument_list|,
name|radix
argument_list|,
name|radix
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Set both the input and output radix at once.  Try to set the output radix    first, since it has the most restrictive range.  An radix that is valid as    an output radix is also valid as an input radix.     It may be useful to have an unusual input radix.  If the user wishes to    set an input radix that is not valid as an output radix, he needs to use    the 'set input-radix' command. */
end_comment

begin_function
specifier|static
name|void
name|set_radix
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|unsigned
name|radix
decl_stmt|;
name|radix
operator|=
operator|(
name|arg
operator|==
name|NULL
operator|)
condition|?
literal|10
else|:
name|parse_and_eval_address
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|set_output_radix_1
argument_list|(
literal|0
argument_list|,
name|radix
argument_list|)
expr_stmt|;
name|set_input_radix_1
argument_list|(
literal|0
argument_list|,
name|radix
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Input and output radices now set to decimal %u, hex %x, octal %o.\n"
argument_list|,
name|radix
argument_list|,
name|radix
argument_list|,
name|radix
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Show both the input and output radices. */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|show_radix
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
if|if
condition|(
name|from_tty
condition|)
block|{
if|if
condition|(
name|input_radix
operator|==
name|output_radix
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Input and output radices set to decimal %u, hex %x, octal %o.\n"
argument_list|,
name|input_radix
argument_list|,
name|input_radix
argument_list|,
name|input_radix
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf_filtered
argument_list|(
literal|"Input radix set to decimal %u, hex %x, octal %o.\n"
argument_list|,
name|input_radix
argument_list|,
name|input_radix
argument_list|,
name|input_radix
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Output radix set to decimal %u, hex %x, octal %o.\n"
argument_list|,
name|output_radix
argument_list|,
name|output_radix
argument_list|,
name|output_radix
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|set_print
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|printf_unfiltered
argument_list|(
literal|"\"set print\" must be followed by the name of a print subcommand.\n"
argument_list|)
expr_stmt|;
name|help_list
argument_list|(
name|setprintlist
argument_list|,
literal|"set print "
argument_list|,
operator|-
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|show_print
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|cmd_show_list
argument_list|(
name|showprintlist
argument_list|,
name|from_tty
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|_initialize_valprint
parameter_list|()
block|{
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"print"
argument_list|,
name|no_class
argument_list|,
name|set_print
argument_list|,
literal|"Generic command for setting how things print."
argument_list|,
operator|&
name|setprintlist
argument_list|,
literal|"set print "
argument_list|,
literal|0
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|add_alias_cmd
argument_list|(
literal|"p"
argument_list|,
literal|"print"
argument_list|,
name|no_class
argument_list|,
literal|1
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
comment|/* prefer set print to set prompt */
name|add_alias_cmd
argument_list|(
literal|"pr"
argument_list|,
literal|"print"
argument_list|,
name|no_class
argument_list|,
literal|1
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"print"
argument_list|,
name|no_class
argument_list|,
name|show_print
argument_list|,
literal|"Generic command for showing print settings."
argument_list|,
operator|&
name|showprintlist
argument_list|,
literal|"show print "
argument_list|,
literal|0
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_alias_cmd
argument_list|(
literal|"p"
argument_list|,
literal|"print"
argument_list|,
name|no_class
argument_list|,
literal|1
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_alias_cmd
argument_list|(
literal|"pr"
argument_list|,
literal|"print"
argument_list|,
name|no_class
argument_list|,
literal|1
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"elements"
argument_list|,
name|no_class
argument_list|,
name|var_uinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|print_max
argument_list|,
literal|"Set limit on string chars or array elements to print.\n\ \"set print elements 0\" causes there to be no limit."
argument_list|,
operator|&
name|setprintlist
argument_list|)
argument_list|,
operator|&
name|showprintlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"null-stop"
argument_list|,
name|no_class
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|stop_print_at_null
argument_list|,
literal|"Set printing of char arrays to stop at first null char."
argument_list|,
operator|&
name|setprintlist
argument_list|)
argument_list|,
operator|&
name|showprintlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"repeats"
argument_list|,
name|no_class
argument_list|,
name|var_uinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|repeat_count_threshold
argument_list|,
literal|"Set threshold for repeated print elements.\n\ \"set print repeats 0\" causes all elements to be individually printed."
argument_list|,
operator|&
name|setprintlist
argument_list|)
argument_list|,
operator|&
name|showprintlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"pretty"
argument_list|,
name|class_support
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|prettyprint_structs
argument_list|,
literal|"Set prettyprinting of structures."
argument_list|,
operator|&
name|setprintlist
argument_list|)
argument_list|,
operator|&
name|showprintlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"union"
argument_list|,
name|class_support
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|unionprint
argument_list|,
literal|"Set printing of unions interior to structures."
argument_list|,
operator|&
name|setprintlist
argument_list|)
argument_list|,
operator|&
name|showprintlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"array"
argument_list|,
name|class_support
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|prettyprint_arrays
argument_list|,
literal|"Set prettyprinting of arrays."
argument_list|,
operator|&
name|setprintlist
argument_list|)
argument_list|,
operator|&
name|showprintlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"address"
argument_list|,
name|class_support
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|addressprint
argument_list|,
literal|"Set printing of addresses."
argument_list|,
operator|&
name|setprintlist
argument_list|)
argument_list|,
operator|&
name|showprintlist
argument_list|)
expr_stmt|;
name|c
operator|=
name|add_set_cmd
argument_list|(
literal|"input-radix"
argument_list|,
name|class_support
argument_list|,
name|var_uinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|input_radix
argument_list|,
literal|"Set default input radix for entering numbers."
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|c
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|c
operator|->
name|function
operator|.
name|sfunc
operator|=
name|set_input_radix
expr_stmt|;
name|c
operator|=
name|add_set_cmd
argument_list|(
literal|"output-radix"
argument_list|,
name|class_support
argument_list|,
name|var_uinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|output_radix
argument_list|,
literal|"Set default output radix for printing of values."
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|c
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|c
operator|->
name|function
operator|.
name|sfunc
operator|=
name|set_output_radix
expr_stmt|;
comment|/* The "set radix" and "show radix" commands are special in that they are      like normal set and show commands but allow two normally independent      variables to be either set or shown with a single command.  So the      usual add_set_cmd() and add_show_from_set() commands aren't really      appropriate. */
name|add_cmd
argument_list|(
literal|"radix"
argument_list|,
name|class_support
argument_list|,
name|set_radix
argument_list|,
literal|"Set default input and output number radices.\n\ Use 'set input-radix' or 'set output-radix' to independently set each.\n\ Without an argument, sets both radices back to the default value of 10."
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"radix"
argument_list|,
name|class_support
argument_list|,
name|show_radix
argument_list|,
literal|"Show the default input and output number radices.\n\ Use 'show input-radix' or 'show output-radix' to independently show each."
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
comment|/* Give people the defaults which they are used to.  */
name|prettyprint_structs
operator|=
literal|0
expr_stmt|;
name|prettyprint_arrays
operator|=
literal|0
expr_stmt|;
name|unionprint
operator|=
literal|1
expr_stmt|;
name|addressprint
operator|=
literal|1
expr_stmt|;
name|print_max
operator|=
name|PRINT_MAX_DEFAULT
expr_stmt|;
block|}
end_function

end_unit

