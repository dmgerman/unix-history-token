begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Print values for GDB, the GNU debugger.    Copyright 1986, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996,    1997, 1998, 1999, 2000, 2001    Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"annotate.h"
end_include

begin_include
include|#
directive|include
file|"valprint.h"
end_include

begin_include
include|#
directive|include
file|"floatformat.h"
end_include

begin_include
include|#
directive|include
file|"doublest.h"
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_comment
comment|/* Prototypes for local functions */
end_comment

begin_function_decl
specifier|static
name|int
name|partial_memory_read
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|,
name|int
modifier|*
name|errnoptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_hex_chars
parameter_list|(
name|struct
name|ui_file
modifier|*
parameter_list|,
name|unsigned
name|char
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|show_print
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_print
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_radix
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|show_radix
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_input_radix
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_input_radix_1
parameter_list|(
name|int
parameter_list|,
name|unsigned
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_output_radix
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_output_radix_1
parameter_list|(
name|int
parameter_list|,
name|unsigned
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|_initialize_valprint
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Maximum number of chars to print for a string pointer value or vector    contents, or UINT_MAX for no limit.  Note that "set print elements 0"    stores UINT_MAX in print_max, which displays in a show command as    "unlimited". */
end_comment

begin_decl_stmt
name|unsigned
name|int
name|print_max
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|PRINT_MAX_DEFAULT
value|200
end_define

begin_comment
comment|/* Start print_max off at this value. */
end_comment

begin_comment
comment|/* Default input and output radixes, and output format letter.  */
end_comment

begin_decl_stmt
name|unsigned
name|input_radix
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|output_radix
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|output_format
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print repeat counts if there are more than this many repetitions of an    element in an array.  Referenced by the low level language dependent    print routines. */
end_comment

begin_decl_stmt
name|unsigned
name|int
name|repeat_count_threshold
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If nonzero, stops printing of char arrays at first null. */
end_comment

begin_decl_stmt
name|int
name|stop_print_at_null
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Controls pretty printing of structures. */
end_comment

begin_decl_stmt
name|int
name|prettyprint_structs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Controls pretty printing of arrays.  */
end_comment

begin_decl_stmt
name|int
name|prettyprint_arrays
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If nonzero, causes unions inside structures or other unions to be    printed. */
end_comment

begin_decl_stmt
name|int
name|unionprint
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Controls printing of nested unions.  */
end_comment

begin_comment
comment|/* If nonzero, causes machine addresses to be printed in certain contexts. */
end_comment

begin_decl_stmt
name|int
name|addressprint
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Controls printing of machine addresses */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Print data of type TYPE located at VALADDR (within GDB), which came from    the inferior at address ADDRESS, onto stdio stream STREAM according to    FORMAT (a letter, or 0 for natural format using TYPE).     If DEREF_REF is nonzero, then dereference references, otherwise just print    them like pointers.     The PRETTY parameter controls prettyprinting.     If the data are a string pointer, returns the number of string characters    printed.     FIXME:  The data at VALADDR is in target byte order.  If gdb is ever    enhanced to be able to debug more than the single target it was compiled    for (specific CPU type and thus specific target byte ordering), then    either the print routines are going to have to take this into account,    or the data is going to have to be passed into here already converted    to the host byte ordering, whichever is more convenient. */
end_comment

begin_function
name|int
name|val_print
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|char
modifier|*
name|valaddr
parameter_list|,
name|int
name|embedded_offset
parameter_list|,
name|CORE_ADDR
name|address
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|int
name|format
parameter_list|,
name|int
name|deref_ref
parameter_list|,
name|int
name|recurse
parameter_list|,
name|enum
name|val_prettyprint
name|pretty
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|real_type
init|=
name|check_typedef
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|pretty
operator|==
name|Val_pretty_default
condition|)
block|{
name|pretty
operator|=
name|prettyprint_structs
condition|?
name|Val_prettyprint
else|:
name|Val_no_prettyprint
expr_stmt|;
block|}
name|QUIT
expr_stmt|;
comment|/* Ensure that the type is complete and not just a stub.  If the type is      only a stub and we can't find and substitute its complete type, then      print appropriate string and return.  */
if|if
condition|(
name|TYPE_STUB
argument_list|(
name|real_type
argument_list|)
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<incomplete type>"
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|stream
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|LA_VAL_PRINT
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|,
name|embedded_offset
argument_list|,
name|address
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|deref_ref
argument_list|,
name|recurse
argument_list|,
name|pretty
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Print the value VAL in C-ish syntax on stream STREAM.    FORMAT is a format-letter, or 0 for print in natural format of data type.    If the object printed is a string pointer, returns    the number of string bytes printed.  */
end_comment

begin_function
name|int
name|value_print
parameter_list|(
name|struct
name|value
modifier|*
name|val
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|int
name|format
parameter_list|,
name|enum
name|val_prettyprint
name|pretty
parameter_list|)
block|{
if|if
condition|(
name|val
operator|==
literal|0
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"<address of value unknown>"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|VALUE_OPTIMIZED_OUT
argument_list|(
name|val
argument_list|)
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"<value optimized out>"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|LA_VALUE_PRINT
argument_list|(
name|val
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|pretty
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Called by various<lang>_val_print routines to print    TYPE_CODE_INT's.  TYPE is the type.  VALADDR is the address of the    value.  STREAM is where to print the value.  */
end_comment

begin_function
name|void
name|val_print_type_code_int
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|char
modifier|*
name|valaddr
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|)
block|{
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|>
sizeof|sizeof
argument_list|(
name|LONGEST
argument_list|)
condition|)
block|{
name|LONGEST
name|val
decl_stmt|;
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|&&
name|extract_long_unsigned_integer
argument_list|(
name|valaddr
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|,
operator|&
name|val
argument_list|)
condition|)
block|{
name|print_longest
argument_list|(
name|stream
argument_list|,
literal|'u'
argument_list|,
literal|0
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Signed, or we couldn't turn an unsigned value into a 	     LONGEST.  For signed values, one could assume two's 	     complement (a reasonable assumption, I think) and do 	     better than this.  */
name|print_hex_chars
argument_list|(
name|stream
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|valaddr
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|PRINT_TYPELESS_INTEGER
name|PRINT_TYPELESS_INTEGER
argument_list|(
name|stream
argument_list|,
name|type
argument_list|,
name|unpack_long
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|print_longest
argument_list|(
name|stream
argument_list|,
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|?
literal|'u'
else|:
literal|'d'
argument_list|,
literal|0
argument_list|,
name|unpack_long
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/* Print a number according to FORMAT which is one of d,u,x,o,b,h,w,g.    The raison d'etre of this function is to consolidate printing of     LONG_LONG's into this one function.  Some platforms have long longs but    don't have a printf() that supports "ll" in the format string.  We handle    these by seeing if the number is representable as either a signed or    unsigned long, depending upon what format is desired, and if not we just    bail out and print the number in hex.     The format chars b,h,w,g are from print_scalar_formatted().  If USE_LOCAL,    format it according to the current language (this should be used for most    integers which GDB prints, the exception is things like protocols where    the format of the integer is a protocol thing, not a user-visible thing).  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CC_HAS_LONG_LONG
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|PRINTF_HAS_LONG_LONG
argument_list|)
end_if

begin_function_decl
specifier|static
name|void
name|print_decimal
parameter_list|(
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|char
modifier|*
name|sign
parameter_list|,
name|int
name|use_local
parameter_list|,
name|ULONGEST
name|val_ulong
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|print_decimal
parameter_list|(
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|char
modifier|*
name|sign
parameter_list|,
name|int
name|use_local
parameter_list|,
name|ULONGEST
name|val_ulong
parameter_list|)
block|{
name|unsigned
name|long
name|temp
index|[
literal|3
index|]
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
do|do
block|{
name|temp
index|[
name|i
index|]
operator|=
name|val_ulong
operator|%
operator|(
literal|1000
operator|*
literal|1000
operator|*
literal|1000
operator|)
expr_stmt|;
name|val_ulong
operator|/=
operator|(
literal|1000
operator|*
literal|1000
operator|*
literal|1000
operator|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|val_ulong
operator|!=
literal|0
operator|&&
name|i
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|temp
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|temp
index|[
literal|0
index|]
argument_list|)
operator|)
condition|)
do|;
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|1
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%s%lu"
argument_list|,
name|sign
argument_list|,
name|temp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%s%lu%09lu"
argument_list|,
name|sign
argument_list|,
name|temp
index|[
literal|1
index|]
argument_list|,
name|temp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%s%lu%09lu%09lu"
argument_list|,
name|sign
argument_list|,
name|temp
index|[
literal|2
index|]
argument_list|,
name|temp
index|[
literal|1
index|]
argument_list|,
name|temp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
default|default:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"failed internal consistency check"
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|print_longest
parameter_list|(
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|int
name|format
parameter_list|,
name|int
name|use_local
parameter_list|,
name|LONGEST
name|val_long
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|CC_HAS_LONG_LONG
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|PRINTF_HAS_LONG_LONG
argument_list|)
if|if
condition|(
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
name|LONGEST
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|format
condition|)
block|{
case|case
literal|'d'
case|:
block|{
comment|/* Print a signed value, that doesn't fit in a long */
if|if
condition|(
operator|(
name|long
operator|)
name|val_long
operator|!=
name|val_long
condition|)
block|{
if|if
condition|(
name|val_long
operator|<
literal|0
condition|)
name|print_decimal
argument_list|(
name|stream
argument_list|,
literal|"-"
argument_list|,
name|use_local
argument_list|,
operator|-
name|val_long
argument_list|)
expr_stmt|;
else|else
name|print_decimal
argument_list|(
name|stream
argument_list|,
literal|""
argument_list|,
name|use_local
argument_list|,
name|val_long
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
block|}
case|case
literal|'u'
case|:
block|{
comment|/* Print an unsigned value, that doesn't fit in a long */
if|if
condition|(
operator|(
name|unsigned
name|long
operator|)
name|val_long
operator|!=
operator|(
name|ULONGEST
operator|)
name|val_long
condition|)
block|{
name|print_decimal
argument_list|(
name|stream
argument_list|,
literal|""
argument_list|,
name|use_local
argument_list|,
name|val_long
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
block|}
case|case
literal|'x'
case|:
case|case
literal|'o'
case|:
case|case
literal|'b'
case|:
case|case
literal|'h'
case|:
case|case
literal|'w'
case|:
case|case
literal|'g'
case|:
comment|/* Print as unsigned value, must fit completely in unsigned long */
block|{
name|unsigned
name|long
name|temp
init|=
name|val_long
decl_stmt|;
if|if
condition|(
name|temp
operator|!=
name|val_long
condition|)
block|{
comment|/* Urk, can't represent value in long so print in hex. 		   Do shift in two operations so that if sizeof (long) 		   == sizeof (LONGEST) we can avoid warnings from 		   picky compilers about shifts>= the size of the 		   shiftee in bits */
name|unsigned
name|long
name|vbot
init|=
operator|(
name|unsigned
name|long
operator|)
name|val_long
decl_stmt|;
name|LONGEST
name|temp
init|=
operator|(
name|val_long
operator|>>
operator|(
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|*
name|HOST_CHAR_BIT
operator|-
literal|1
operator|)
operator|)
decl_stmt|;
name|unsigned
name|long
name|vtop
init|=
name|temp
operator|>>
literal|1
decl_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"0x%lx%08lx"
argument_list|,
name|vtop
argument_list|,
name|vbot
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
block|}
block|}
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|CC_HAS_LONG_LONG
argument_list|)
operator|&&
name|defined
argument_list|(
name|PRINTF_HAS_LONG_LONG
argument_list|)
switch|switch
condition|(
name|format
condition|)
block|{
case|case
literal|'d'
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|use_local
condition|?
name|local_decimal_format_custom
argument_list|(
literal|"ll"
argument_list|)
else|:
literal|"%lld"
argument_list|,
name|val_long
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%llu"
argument_list|,
name|val_long
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|use_local
condition|?
name|local_hex_format_custom
argument_list|(
literal|"ll"
argument_list|)
else|:
literal|"%llx"
argument_list|,
name|val_long
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|use_local
condition|?
name|local_octal_format_custom
argument_list|(
literal|"ll"
argument_list|)
else|:
literal|"%llo"
argument_list|,
name|val_long
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|local_hex_format_custom
argument_list|(
literal|"02ll"
argument_list|)
argument_list|,
name|val_long
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|local_hex_format_custom
argument_list|(
literal|"04ll"
argument_list|)
argument_list|,
name|val_long
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|local_hex_format_custom
argument_list|(
literal|"08ll"
argument_list|)
argument_list|,
name|val_long
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|local_hex_format_custom
argument_list|(
literal|"016ll"
argument_list|)
argument_list|,
name|val_long
argument_list|)
expr_stmt|;
break|break;
default|default:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"failed internal consistency check"
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* !CC_HAS_LONG_LONG || !PRINTF_HAS_LONG_LONG */
comment|/* In the following it is important to coerce (val_long) to a long. It does      nothing if !LONG_LONG, but it will chop off the top half (which we know      we can ignore) if the host supports long longs.  */
switch|switch
condition|(
name|format
condition|)
block|{
case|case
literal|'d'
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|use_local
condition|?
name|local_decimal_format_custom
argument_list|(
literal|"l"
argument_list|)
else|:
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|val_long
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%lu"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|val_long
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|use_local
condition|?
name|local_hex_format_custom
argument_list|(
literal|"l"
argument_list|)
else|:
literal|"%lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|val_long
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|use_local
condition|?
name|local_octal_format_custom
argument_list|(
literal|"l"
argument_list|)
else|:
literal|"%lo"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|val_long
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|local_hex_format_custom
argument_list|(
literal|"02l"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|val_long
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|local_hex_format_custom
argument_list|(
literal|"04l"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|val_long
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|local_hex_format_custom
argument_list|(
literal|"08l"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|val_long
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|local_hex_format_custom
argument_list|(
literal|"016l"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|val_long
argument_list|)
expr_stmt|;
break|break;
default|default:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"failed internal consistency check"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* CC_HAS_LONG_LONG || PRINTF_HAS_LONG_LONG */
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|void strcat_longest (int format, int use_local, LONGEST val_long, char *buf, 		int buflen) {
comment|/* FIXME: Use buflen to avoid buffer overflow.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CC_HAS_LONG_LONG
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|PRINTF_HAS_LONG_LONG
argument_list|)
end_if

begin_endif
unit|long vtop, vbot;    vtop = val_long>> (sizeof (long) * HOST_CHAR_BIT);   vbot = (long) val_long;    if ((format == 'd'&& (val_long< INT_MIN || val_long> INT_MAX))       || ((format == 'u' || format == 'x')&& (unsigned long long) val_long> UINT_MAX))     {       sprintf (buf, "0x%lx%08lx", vtop, vbot);       return;     }
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|PRINTF_HAS_LONG_LONG
end_ifdef

begin_else
unit|switch (format)     {     case 'd':       sprintf (buf, 	       (use_local ? local_decimal_format_custom ("ll") : "%lld"), 	       val_long);       break;     case 'u':       sprintf (buf, "%llu", val_long);       break;     case 'x':       sprintf (buf, 	       (use_local ? local_hex_format_custom ("ll") : "%llx"),  	       val_long);       break;     case 'o':       sprintf (buf, 	       (use_local ? local_octal_format_custom ("ll") : "%llo"), 	       val_long);       break;     case 'b':       sprintf (buf, local_hex_format_custom ("02ll"), val_long);       break;     case 'h':       sprintf (buf, local_hex_format_custom ("04ll"), val_long);       break;     case 'w':       sprintf (buf, local_hex_format_custom ("08ll"), val_long);       break;     case 'g':       sprintf (buf, local_hex_format_custom ("016ll"), val_long);       break;     default:       internal_error (__FILE__, __LINE__, "failed internal consistency check");     }
else|#
directive|else
end_else

begin_comment
comment|/* !PRINTF_HAS_LONG_LONG */
end_comment

begin_comment
comment|/* In the following it is important to coerce (val_long) to a long. It does      nothing if !LONG_LONG, but it will chop off the top half (which we know      we can ignore) if the host supports long longs.  */
end_comment

begin_endif
unit|switch (format)     {     case 'd':       sprintf (buf, (use_local ? local_decimal_format_custom ("l") : "%ld"), 	       ((long) val_long));       break;     case 'u':       sprintf (buf, "%lu", ((unsigned long) val_long));       break;     case 'x':       sprintf (buf, (use_local ? local_hex_format_custom ("l") : "%lx"), 	       ((long) val_long));       break;     case 'o':       sprintf (buf, (use_local ? local_octal_format_custom ("l") : "%lo"), 	       ((long) val_long));       break;     case 'b':       sprintf (buf, local_hex_format_custom ("02l"), 	       ((long) val_long));       break;     case 'h':       sprintf (buf, local_hex_format_custom ("04l"), 	       ((long) val_long));       break;     case 'w':       sprintf (buf, local_hex_format_custom ("08l"), 	       ((long) val_long));       break;     case 'g':       sprintf (buf, local_hex_format_custom ("016l"), 	       ((long) val_long));       break;     default:       internal_error (__FILE__, __LINE__, "failed internal consistency check");     }
endif|#
directive|endif
end_endif

begin_comment
comment|/* !PRINTF_HAS_LONG_LONG */
end_comment

begin_endif
unit|}
endif|#
directive|endif
end_endif

begin_comment
comment|/* This used to be a macro, but I don't think it is called often enough    to merit such treatment.  */
end_comment

begin_comment
comment|/* Convert a LONGEST to an int.  This is used in contexts (e.g. number of    arguments to a function, number in a value history, register number, etc.)    where the value must not be larger than can fit in an int.  */
end_comment

begin_function
name|int
name|longest_to_int
parameter_list|(
name|LONGEST
name|arg
parameter_list|)
block|{
comment|/* Let the compiler do the work */
name|int
name|rtnval
init|=
operator|(
name|int
operator|)
name|arg
decl_stmt|;
comment|/* Check for overflows or underflows */
if|if
condition|(
sizeof|sizeof
argument_list|(
name|LONGEST
argument_list|)
operator|>
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|)
block|{
if|if
condition|(
name|rtnval
operator|!=
name|arg
condition|)
block|{
name|error
argument_list|(
literal|"Value out of range."
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|rtnval
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Print a floating point value of type TYPE (not always a    TYPE_CODE_FLT), pointed to in GDB by VALADDR, on STREAM.  */
end_comment

begin_function
name|void
name|print_floating
parameter_list|(
name|char
modifier|*
name|valaddr
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|)
block|{
name|DOUBLEST
name|doub
decl_stmt|;
name|int
name|inv
decl_stmt|;
specifier|const
name|struct
name|floatformat
modifier|*
name|fmt
init|=
name|NULL
decl_stmt|;
name|unsigned
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
decl_stmt|;
comment|/* If it is a floating-point, check for obvious problems.  */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_FLT
condition|)
name|fmt
operator|=
name|floatformat_from_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
operator|!=
name|NULL
operator|&&
name|floatformat_is_nan
argument_list|(
name|fmt
argument_list|,
name|valaddr
argument_list|)
condition|)
block|{
if|if
condition|(
name|floatformat_is_negative
argument_list|(
name|fmt
argument_list|,
name|valaddr
argument_list|)
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"nan("
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|local_hex_format_prefix
argument_list|()
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|floatformat_mantissa
argument_list|(
name|fmt
argument_list|,
name|valaddr
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|local_hex_format_suffix
argument_list|()
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* NOTE: cagney/2002-01-15: The TYPE passed into print_floating()      isn't necessarily a TYPE_CODE_FLT.  Consequently, unpack_double      needs to be used as that takes care of any necessary type      conversions.  Such conversions are of course direct to DOUBLEST      and disregard any possible target floating point limitations.      For instance, a u64 would be converted and displayed exactly on a      host with 80 bit DOUBLEST but with loss of information on a host      with 64 bit DOUBLEST.  */
name|doub
operator|=
name|unpack_double
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|,
operator|&
name|inv
argument_list|)
expr_stmt|;
if|if
condition|(
name|inv
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<invalid float value>"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* FIXME: kettenis/2001-01-20: The following code makes too much      assumptions about the host and target floating point format.  */
comment|/* NOTE: cagney/2002-02-03: Since the TYPE of what was passed in may      not necessarially be a TYPE_CODE_FLT, the below ignores that and      instead uses the type's length to determine the precision of the      floating-point value being printed.  */
if|if
condition|(
name|len
operator|<
sizeof|sizeof
argument_list|(
name|double
argument_list|)
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%.9g"
argument_list|,
operator|(
name|double
operator|)
name|doub
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|len
operator|==
sizeof|sizeof
argument_list|(
name|double
argument_list|)
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%.17g"
argument_list|,
operator|(
name|double
operator|)
name|doub
argument_list|)
expr_stmt|;
else|else
ifdef|#
directive|ifdef
name|PRINTF_HAS_LONG_DOUBLE
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%.35Lg"
argument_list|,
name|doub
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* This at least wins with values that are representable as        doubles.  */
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%.17g"
argument_list|,
operator|(
name|double
operator|)
name|doub
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|print_binary_chars
parameter_list|(
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|unsigned
name|char
modifier|*
name|valaddr
parameter_list|,
name|unsigned
name|len
parameter_list|)
block|{
define|#
directive|define
name|BITS_IN_BYTES
value|8
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|int
name|b
decl_stmt|;
comment|/* Declared "int" so it will be signed.    * This ensures that right shift will shift in zeros.    */
specifier|const
name|int
name|mask
init|=
literal|0x080
decl_stmt|;
comment|/* FIXME: We should be not printing leading zeroes in most cases.  */
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|local_binary_format_prefix
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_BYTE_ORDER
operator|==
name|BFD_ENDIAN_BIG
condition|)
block|{
for|for
control|(
name|p
operator|=
name|valaddr
init|;
name|p
operator|<
name|valaddr
operator|+
name|len
condition|;
name|p
operator|++
control|)
block|{
comment|/* Every byte has 8 binary characters; peel off 	   * and print from the MSB end. 	   */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|BITS_IN_BYTES
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|&
operator|(
name|mask
operator|>>
name|i
operator|)
condition|)
name|b
operator|=
literal|1
expr_stmt|;
else|else
name|b
operator|=
literal|0
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%1d"
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|p
operator|=
name|valaddr
operator|+
name|len
operator|-
literal|1
init|;
name|p
operator|>=
name|valaddr
condition|;
name|p
operator|--
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|BITS_IN_BYTES
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|&
operator|(
name|mask
operator|>>
name|i
operator|)
condition|)
name|b
operator|=
literal|1
expr_stmt|;
else|else
name|b
operator|=
literal|0
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%1d"
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|local_binary_format_suffix
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* VALADDR points to an integer of LEN bytes.  * Print it in octal on stream or format it in buf.  */
end_comment

begin_function
name|void
name|print_octal_chars
parameter_list|(
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|unsigned
name|char
modifier|*
name|valaddr
parameter_list|,
name|unsigned
name|len
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|char
name|octa1
decl_stmt|,
name|octa2
decl_stmt|,
name|octa3
decl_stmt|,
name|carry
decl_stmt|;
name|int
name|cycle
decl_stmt|;
comment|/* FIXME: We should be not printing leading zeroes in most cases.  */
comment|/* Octal is 3 bits, which doesn't fit.  Yuk.  So we have to track    * the extra bits, which cycle every three bytes:    *    * Byte side:       0            1             2          3    *                         |             |            |            |    * bit number   123 456 78 | 9 012 345 6 | 78 901 234 | 567 890 12 |    *    * Octal side:   0   1   carry  3   4  carry ...    *    * Cycle number:    0             1            2    *    * But of course we are printing from the high side, so we have to    * figure out where in the cycle we are so that we end up with no    * left over bits at the end.    */
define|#
directive|define
name|BITS_IN_OCTAL
value|3
define|#
directive|define
name|HIGH_ZERO
value|0340
define|#
directive|define
name|LOW_ZERO
value|0016
define|#
directive|define
name|CARRY_ZERO
value|0003
define|#
directive|define
name|HIGH_ONE
value|0200
define|#
directive|define
name|MID_ONE
value|0160
define|#
directive|define
name|LOW_ONE
value|0016
define|#
directive|define
name|CARRY_ONE
value|0001
define|#
directive|define
name|HIGH_TWO
value|0300
define|#
directive|define
name|MID_TWO
value|0070
define|#
directive|define
name|LOW_TWO
value|0007
comment|/* For 32 we start in cycle 2, with two bits and one bit carry;    * for 64 in cycle in cycle 1, with one bit and a two bit carry.    */
name|cycle
operator|=
operator|(
name|len
operator|*
name|BITS_IN_BYTES
operator|)
operator|%
name|BITS_IN_OCTAL
expr_stmt|;
name|carry
operator|=
literal|0
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|local_octal_format_prefix
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_BYTE_ORDER
operator|==
name|BFD_ENDIAN_BIG
condition|)
block|{
for|for
control|(
name|p
operator|=
name|valaddr
init|;
name|p
operator|<
name|valaddr
operator|+
name|len
condition|;
name|p
operator|++
control|)
block|{
switch|switch
condition|(
name|cycle
condition|)
block|{
case|case
literal|0
case|:
comment|/* No carry in, carry out two bits. 	       */
name|octa1
operator|=
operator|(
name|HIGH_ZERO
operator|&
operator|*
name|p
operator|)
operator|>>
literal|5
expr_stmt|;
name|octa2
operator|=
operator|(
name|LOW_ZERO
operator|&
operator|*
name|p
operator|)
operator|>>
literal|2
expr_stmt|;
name|carry
operator|=
operator|(
name|CARRY_ZERO
operator|&
operator|*
name|p
operator|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%o"
argument_list|,
name|octa1
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%o"
argument_list|,
name|octa2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* Carry in two bits, carry out one bit. 	       */
name|octa1
operator|=
operator|(
name|carry
operator|<<
literal|1
operator|)
operator||
operator|(
operator|(
name|HIGH_ONE
operator|&
operator|*
name|p
operator|)
operator|>>
literal|7
operator|)
expr_stmt|;
name|octa2
operator|=
operator|(
name|MID_ONE
operator|&
operator|*
name|p
operator|)
operator|>>
literal|4
expr_stmt|;
name|octa3
operator|=
operator|(
name|LOW_ONE
operator|&
operator|*
name|p
operator|)
operator|>>
literal|1
expr_stmt|;
name|carry
operator|=
operator|(
name|CARRY_ONE
operator|&
operator|*
name|p
operator|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%o"
argument_list|,
name|octa1
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%o"
argument_list|,
name|octa2
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%o"
argument_list|,
name|octa3
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* Carry in one bit, no carry out. 	       */
name|octa1
operator|=
operator|(
name|carry
operator|<<
literal|2
operator|)
operator||
operator|(
operator|(
name|HIGH_TWO
operator|&
operator|*
name|p
operator|)
operator|>>
literal|6
operator|)
expr_stmt|;
name|octa2
operator|=
operator|(
name|MID_TWO
operator|&
operator|*
name|p
operator|)
operator|>>
literal|3
expr_stmt|;
name|octa3
operator|=
operator|(
name|LOW_TWO
operator|&
operator|*
name|p
operator|)
expr_stmt|;
name|carry
operator|=
literal|0
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%o"
argument_list|,
name|octa1
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%o"
argument_list|,
name|octa2
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%o"
argument_list|,
name|octa3
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Internal error in octal conversion;"
argument_list|)
expr_stmt|;
block|}
name|cycle
operator|++
expr_stmt|;
name|cycle
operator|=
name|cycle
operator|%
name|BITS_IN_OCTAL
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|p
operator|=
name|valaddr
operator|+
name|len
operator|-
literal|1
init|;
name|p
operator|>=
name|valaddr
condition|;
name|p
operator|--
control|)
block|{
switch|switch
condition|(
name|cycle
condition|)
block|{
case|case
literal|0
case|:
comment|/* Carry out, no carry in */
name|octa1
operator|=
operator|(
name|HIGH_ZERO
operator|&
operator|*
name|p
operator|)
operator|>>
literal|5
expr_stmt|;
name|octa2
operator|=
operator|(
name|LOW_ZERO
operator|&
operator|*
name|p
operator|)
operator|>>
literal|2
expr_stmt|;
name|carry
operator|=
operator|(
name|CARRY_ZERO
operator|&
operator|*
name|p
operator|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%o"
argument_list|,
name|octa1
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%o"
argument_list|,
name|octa2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* Carry in, carry out */
name|octa1
operator|=
operator|(
name|carry
operator|<<
literal|1
operator|)
operator||
operator|(
operator|(
name|HIGH_ONE
operator|&
operator|*
name|p
operator|)
operator|>>
literal|7
operator|)
expr_stmt|;
name|octa2
operator|=
operator|(
name|MID_ONE
operator|&
operator|*
name|p
operator|)
operator|>>
literal|4
expr_stmt|;
name|octa3
operator|=
operator|(
name|LOW_ONE
operator|&
operator|*
name|p
operator|)
operator|>>
literal|1
expr_stmt|;
name|carry
operator|=
operator|(
name|CARRY_ONE
operator|&
operator|*
name|p
operator|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%o"
argument_list|,
name|octa1
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%o"
argument_list|,
name|octa2
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%o"
argument_list|,
name|octa3
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* Carry in, no carry out */
name|octa1
operator|=
operator|(
name|carry
operator|<<
literal|2
operator|)
operator||
operator|(
operator|(
name|HIGH_TWO
operator|&
operator|*
name|p
operator|)
operator|>>
literal|6
operator|)
expr_stmt|;
name|octa2
operator|=
operator|(
name|MID_TWO
operator|&
operator|*
name|p
operator|)
operator|>>
literal|3
expr_stmt|;
name|octa3
operator|=
operator|(
name|LOW_TWO
operator|&
operator|*
name|p
operator|)
expr_stmt|;
name|carry
operator|=
literal|0
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%o"
argument_list|,
name|octa1
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%o"
argument_list|,
name|octa2
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%o"
argument_list|,
name|octa3
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Internal error in octal conversion;"
argument_list|)
expr_stmt|;
block|}
name|cycle
operator|++
expr_stmt|;
name|cycle
operator|=
name|cycle
operator|%
name|BITS_IN_OCTAL
expr_stmt|;
block|}
block|}
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|local_octal_format_suffix
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* VALADDR points to an integer of LEN bytes.  * Print it in decimal on stream or format it in buf.  */
end_comment

begin_function
name|void
name|print_decimal_chars
parameter_list|(
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|unsigned
name|char
modifier|*
name|valaddr
parameter_list|,
name|unsigned
name|len
parameter_list|)
block|{
define|#
directive|define
name|TEN
value|10
define|#
directive|define
name|TWO_TO_FOURTH
value|16
define|#
directive|define
name|CARRY_OUT
parameter_list|(
name|x
parameter_list|)
value|((x) / TEN)
comment|/* extend char to int */
define|#
directive|define
name|CARRY_LEFT
parameter_list|(
name|x
parameter_list|)
value|((x) % TEN)
define|#
directive|define
name|SHIFT
parameter_list|(
name|x
parameter_list|)
value|((x)<< 4)
define|#
directive|define
name|START_P
define|\
value|((TARGET_BYTE_ORDER == BFD_ENDIAN_BIG) ? valaddr : valaddr + len - 1)
define|#
directive|define
name|NOT_END_P
define|\
value|((TARGET_BYTE_ORDER == BFD_ENDIAN_BIG) ? (p< valaddr + len) : (p>= valaddr))
define|#
directive|define
name|NEXT_P
define|\
value|((TARGET_BYTE_ORDER == BFD_ENDIAN_BIG) ? p++ : p-- )
define|#
directive|define
name|LOW_NIBBLE
parameter_list|(
name|x
parameter_list|)
value|( (x)& 0x00F)
define|#
directive|define
name|HIGH_NIBBLE
parameter_list|(
name|x
parameter_list|)
value|(((x)& 0x0F0)>> 4)
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|char
modifier|*
name|digits
decl_stmt|;
name|int
name|carry
decl_stmt|;
name|int
name|decimal_len
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|decimal_digits
decl_stmt|;
name|int
name|dummy
decl_stmt|;
name|int
name|flip
decl_stmt|;
comment|/* Base-ten number is less than twice as many digits    * as the base 16 number, which is 2 digits per byte.    */
name|decimal_len
operator|=
name|len
operator|*
literal|2
operator|*
literal|2
expr_stmt|;
name|digits
operator|=
name|xmalloc
argument_list|(
name|decimal_len
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|decimal_len
condition|;
name|i
operator|++
control|)
block|{
name|digits
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|local_decimal_format_prefix
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Ok, we have an unknown number of bytes of data to be printed in    * decimal.    *    * Given a hex number (in nibbles) as XYZ, we start by taking X and    * decemalizing it as "x1 x2" in two decimal nibbles.  Then we multiply    * the nibbles by 16, add Y and re-decimalize.  Repeat with Z.    *    * The trick is that "digits" holds a base-10 number, but sometimes    * the individual digits are> 10.     *    * Outer loop is per nibble (hex digit) of input, from MSD end to    * LSD end.    */
name|decimal_digits
operator|=
literal|0
expr_stmt|;
comment|/* Number of decimal digits so far */
name|p
operator|=
name|START_P
expr_stmt|;
name|flip
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|NOT_END_P
condition|)
block|{
comment|/*        * Multiply current base-ten number by 16 in place.        * Each digit was between 0 and 9, now is between        * 0 and 144.        */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|decimal_digits
condition|;
name|j
operator|++
control|)
block|{
name|digits
index|[
name|j
index|]
operator|=
name|SHIFT
argument_list|(
name|digits
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Take the next nibble off the input and add it to what        * we've got in the LSB position.  Bottom 'digit' is now        * between 0 and 159.        *        * "flip" is used to run this loop twice for each byte.        */
if|if
condition|(
name|flip
operator|==
literal|0
condition|)
block|{
comment|/* Take top nibble. 	   */
name|digits
index|[
literal|0
index|]
operator|+=
name|HIGH_NIBBLE
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
name|flip
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Take low nibble and bump our pointer "p". 	   */
name|digits
index|[
literal|0
index|]
operator|+=
name|LOW_NIBBLE
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
name|NEXT_P
expr_stmt|;
name|flip
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Re-decimalize.  We have to do this often enough        * that we don't overflow, but once per nibble is        * overkill.  Easier this way, though.  Note that the        * carry is often larger than 10 (e.g. max initial        * carry out of lowest nibble is 15, could bubble all        * the way up greater than 10).  So we have to do        * the carrying beyond the last current digit.        */
name|carry
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|decimal_len
operator|-
literal|1
condition|;
name|j
operator|++
control|)
block|{
name|digits
index|[
name|j
index|]
operator|+=
name|carry
expr_stmt|;
comment|/* "/" won't handle an unsigned char with 	   * a value that if signed would be negative. 	   * So extend to longword int via "dummy". 	   */
name|dummy
operator|=
name|digits
index|[
name|j
index|]
expr_stmt|;
name|carry
operator|=
name|CARRY_OUT
argument_list|(
name|dummy
argument_list|)
expr_stmt|;
name|digits
index|[
name|j
index|]
operator|=
name|CARRY_LEFT
argument_list|(
name|dummy
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|>=
name|decimal_digits
operator|&&
name|carry
operator|==
literal|0
condition|)
block|{
comment|/* 	       * All higher digits are 0 and we 	       * no longer have a carry. 	       * 	       * Note: "j" is 0-based, "decimal_digits" is 	       *       1-based. 	       */
name|decimal_digits
operator|=
name|j
operator|+
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* Ok, now "digits" is the decimal representation, with    * the "decimal_digits" actual digits.  Print!    */
for|for
control|(
name|i
operator|=
name|decimal_digits
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%1d"
argument_list|,
name|digits
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|xfree
argument_list|(
name|digits
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|local_decimal_format_suffix
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* VALADDR points to an integer of LEN bytes.  Print it in hex on stream.  */
end_comment

begin_function
specifier|static
name|void
name|print_hex_chars
parameter_list|(
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|unsigned
name|char
modifier|*
name|valaddr
parameter_list|,
name|unsigned
name|len
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
comment|/* FIXME: We should be not printing leading zeroes in most cases.  */
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|local_hex_format_prefix
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_BYTE_ORDER
operator|==
name|BFD_ENDIAN_BIG
condition|)
block|{
for|for
control|(
name|p
operator|=
name|valaddr
init|;
name|p
operator|<
name|valaddr
operator|+
name|len
condition|;
name|p
operator|++
control|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%02x"
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|p
operator|=
name|valaddr
operator|+
name|len
operator|-
literal|1
init|;
name|p
operator|>=
name|valaddr
condition|;
name|p
operator|--
control|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%02x"
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|local_hex_format_suffix
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  Called by various<lang>_val_print routines to print elements of an    array in the form "<elem1>,<elem2>,<elem3>, ...".     (FIXME?)  Assumes array element separator is a comma, which is correct    for all languages currently handled.    (FIXME?)  Some languages have a notation for repeated array elements,    perhaps we should try to use that notation when appropriate.  */
end_comment

begin_function
name|void
name|val_print_array_elements
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|char
modifier|*
name|valaddr
parameter_list|,
name|CORE_ADDR
name|address
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|int
name|format
parameter_list|,
name|int
name|deref_ref
parameter_list|,
name|int
name|recurse
parameter_list|,
name|enum
name|val_prettyprint
name|pretty
parameter_list|,
name|unsigned
name|int
name|i
parameter_list|)
block|{
name|unsigned
name|int
name|things_printed
init|=
literal|0
decl_stmt|;
name|unsigned
name|len
decl_stmt|;
name|struct
name|type
modifier|*
name|elttype
decl_stmt|;
name|unsigned
name|eltlen
decl_stmt|;
comment|/* Position of the array element we are examining to see      whether it is repeated.  */
name|unsigned
name|int
name|rep1
decl_stmt|;
comment|/* Number of repetitions we have detected so far.  */
name|unsigned
name|int
name|reps
decl_stmt|;
name|elttype
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|eltlen
operator|=
name|TYPE_LENGTH
argument_list|(
name|check_typedef
argument_list|(
name|elttype
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|/
name|eltlen
expr_stmt|;
name|annotate_array_section_begin
argument_list|(
name|i
argument_list|,
name|elttype
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|len
operator|&&
name|things_printed
operator|<
name|print_max
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|prettyprint_arrays
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|",\n"
argument_list|)
expr_stmt|;
name|print_spaces_filtered
argument_list|(
literal|2
operator|+
literal|2
operator|*
name|recurse
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
block|}
block|}
name|wrap_here
argument_list|(
name|n_spaces
argument_list|(
literal|2
operator|+
literal|2
operator|*
name|recurse
argument_list|)
argument_list|)
expr_stmt|;
name|rep1
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|reps
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|rep1
operator|<
name|len
operator|)
operator|&&
operator|!
name|memcmp
argument_list|(
name|valaddr
operator|+
name|i
operator|*
name|eltlen
argument_list|,
name|valaddr
operator|+
name|rep1
operator|*
name|eltlen
argument_list|,
name|eltlen
argument_list|)
condition|)
block|{
operator|++
name|reps
expr_stmt|;
operator|++
name|rep1
expr_stmt|;
block|}
if|if
condition|(
name|reps
operator|>
name|repeat_count_threshold
condition|)
block|{
name|val_print
argument_list|(
name|elttype
argument_list|,
name|valaddr
operator|+
name|i
operator|*
name|eltlen
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|deref_ref
argument_list|,
name|recurse
operator|+
literal|1
argument_list|,
name|pretty
argument_list|)
expr_stmt|;
name|annotate_elt_rep
argument_list|(
name|reps
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<repeats %u times>"
argument_list|,
name|reps
argument_list|)
expr_stmt|;
name|annotate_elt_rep_end
argument_list|()
expr_stmt|;
name|i
operator|=
name|rep1
operator|-
literal|1
expr_stmt|;
name|things_printed
operator|+=
name|repeat_count_threshold
expr_stmt|;
block|}
else|else
block|{
name|val_print
argument_list|(
name|elttype
argument_list|,
name|valaddr
operator|+
name|i
operator|*
name|eltlen
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|deref_ref
argument_list|,
name|recurse
operator|+
literal|1
argument_list|,
name|pretty
argument_list|)
expr_stmt|;
name|annotate_elt
argument_list|()
expr_stmt|;
name|things_printed
operator|++
expr_stmt|;
block|}
block|}
name|annotate_array_section_end
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|len
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"..."
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Read LEN bytes of target memory at address MEMADDR, placing the    results in GDB's memory at MYADDR.  Returns a count of the bytes    actually read, and optionally an errno value in the location    pointed to by ERRNOPTR if ERRNOPTR is non-null. */
end_comment

begin_comment
comment|/* FIXME: cagney/1999-10-14: Only used by val_print_string.  Can this    function be eliminated.  */
end_comment

begin_function
specifier|static
name|int
name|partial_memory_read
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|,
name|int
modifier|*
name|errnoptr
parameter_list|)
block|{
name|int
name|nread
decl_stmt|;
comment|/* Number of bytes actually read. */
name|int
name|errcode
decl_stmt|;
comment|/* Error from last read. */
comment|/* First try a complete read. */
name|errcode
operator|=
name|target_read_memory
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|errcode
operator|==
literal|0
condition|)
block|{
comment|/* Got it all. */
name|nread
operator|=
name|len
expr_stmt|;
block|}
else|else
block|{
comment|/* Loop, reading one byte at a time until we get as much as we can. */
for|for
control|(
name|errcode
operator|=
literal|0
operator|,
name|nread
operator|=
literal|0
init|;
name|len
operator|>
literal|0
operator|&&
name|errcode
operator|==
literal|0
condition|;
name|nread
operator|++
operator|,
name|len
operator|--
control|)
block|{
name|errcode
operator|=
name|target_read_memory
argument_list|(
name|memaddr
operator|++
argument_list|,
name|myaddr
operator|++
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* If an error, the last read was unsuccessful, so adjust count. */
if|if
condition|(
name|errcode
operator|!=
literal|0
condition|)
block|{
name|nread
operator|--
expr_stmt|;
block|}
block|}
if|if
condition|(
name|errnoptr
operator|!=
name|NULL
condition|)
block|{
operator|*
name|errnoptr
operator|=
name|errcode
expr_stmt|;
block|}
return|return
operator|(
name|nread
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  Print a string from the inferior, starting at ADDR and printing up to LEN    characters, of WIDTH bytes a piece, to STREAM.  If LEN is -1, printing    stops at the first null byte, otherwise printing proceeds (including null    bytes) until either print_max or LEN characters have been printed,    whichever is smaller. */
end_comment

begin_comment
comment|/* FIXME: Use target_read_string.  */
end_comment

begin_function
name|int
name|val_print_string
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|width
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|)
block|{
name|int
name|force_ellipsis
init|=
literal|0
decl_stmt|;
comment|/* Force ellipsis to be printed if nonzero. */
name|int
name|errcode
decl_stmt|;
comment|/* Errno returned from bad reads. */
name|unsigned
name|int
name|fetchlimit
decl_stmt|;
comment|/* Maximum number of chars to print. */
name|unsigned
name|int
name|nfetch
decl_stmt|;
comment|/* Chars to fetch / chars fetched. */
name|unsigned
name|int
name|chunksize
decl_stmt|;
comment|/* Size of each fetch, in chars. */
name|char
modifier|*
name|buffer
init|=
name|NULL
decl_stmt|;
comment|/* Dynamically growable fetch buffer. */
name|char
modifier|*
name|bufptr
decl_stmt|;
comment|/* Pointer to next available byte in buffer. */
name|char
modifier|*
name|limit
decl_stmt|;
comment|/* First location past end of fetch buffer. */
name|struct
name|cleanup
modifier|*
name|old_chain
init|=
name|NULL
decl_stmt|;
comment|/* Top of the old cleanup chain. */
name|int
name|found_nul
decl_stmt|;
comment|/* Non-zero if we found the nul char */
comment|/* First we need to figure out the limit on the number of characters we are      going to attempt to fetch and print.  This is actually pretty simple.  If      LEN>= zero, then the limit is the minimum of LEN and print_max.  If      LEN is -1, then the limit is print_max.  This is true regardless of      whether print_max is zero, UINT_MAX (unlimited), or something in between,      because finding the null byte (or available memory) is what actually      limits the fetch. */
name|fetchlimit
operator|=
operator|(
name|len
operator|==
operator|-
literal|1
condition|?
name|print_max
else|:
name|min
argument_list|(
name|len
argument_list|,
name|print_max
argument_list|)
operator|)
expr_stmt|;
comment|/* Now decide how large of chunks to try to read in one operation.  This      is also pretty simple.  If LEN>= zero, then we want fetchlimit chars,      so we might as well read them all in one operation.  If LEN is -1, we      are looking for a null terminator to end the fetching, so we might as      well read in blocks that are large enough to be efficient, but not so      large as to be slow if fetchlimit happens to be large.  So we choose the      minimum of 8 and fetchlimit.  We used to use 200 instead of 8 but      200 is way too big for remote debugging over a serial line.  */
name|chunksize
operator|=
operator|(
name|len
operator|==
operator|-
literal|1
condition|?
name|min
argument_list|(
literal|8
argument_list|,
name|fetchlimit
argument_list|)
else|:
name|fetchlimit
operator|)
expr_stmt|;
comment|/* Loop until we either have all the characters to print, or we encounter      some error, such as bumping into the end of the address space. */
name|found_nul
operator|=
literal|0
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|null_cleanup
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|len
operator|*
name|width
argument_list|)
expr_stmt|;
name|bufptr
operator|=
name|buffer
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|nfetch
operator|=
name|partial_memory_read
argument_list|(
name|addr
argument_list|,
name|bufptr
argument_list|,
name|len
operator|*
name|width
argument_list|,
operator|&
name|errcode
argument_list|)
operator|/
name|width
expr_stmt|;
name|addr
operator|+=
name|nfetch
operator|*
name|width
expr_stmt|;
name|bufptr
operator|+=
name|nfetch
operator|*
name|width
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|len
operator|==
operator|-
literal|1
condition|)
block|{
name|unsigned
name|long
name|bufsize
init|=
literal|0
decl_stmt|;
do|do
block|{
name|QUIT
expr_stmt|;
name|nfetch
operator|=
name|min
argument_list|(
name|chunksize
argument_list|,
name|fetchlimit
operator|-
name|bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
operator|==
name|NULL
condition|)
name|buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|nfetch
operator|*
name|width
argument_list|)
expr_stmt|;
else|else
block|{
name|discard_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
name|buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|buffer
argument_list|,
operator|(
name|nfetch
operator|+
name|bufsize
operator|)
operator|*
name|width
argument_list|)
expr_stmt|;
block|}
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|bufptr
operator|=
name|buffer
operator|+
name|bufsize
operator|*
name|width
expr_stmt|;
name|bufsize
operator|+=
name|nfetch
expr_stmt|;
comment|/* Read as much as we can. */
name|nfetch
operator|=
name|partial_memory_read
argument_list|(
name|addr
argument_list|,
name|bufptr
argument_list|,
name|nfetch
operator|*
name|width
argument_list|,
operator|&
name|errcode
argument_list|)
operator|/
name|width
expr_stmt|;
comment|/* Scan this chunk for the null byte that terminates the string 	     to print.  If found, we don't need to fetch any more.  Note 	     that bufptr is explicitly left pointing at the next character 	     after the null byte, or at the next character after the end of 	     the buffer. */
name|limit
operator|=
name|bufptr
operator|+
name|nfetch
operator|*
name|width
expr_stmt|;
while|while
condition|(
name|bufptr
operator|<
name|limit
condition|)
block|{
name|unsigned
name|long
name|c
decl_stmt|;
name|c
operator|=
name|extract_unsigned_integer
argument_list|(
name|bufptr
argument_list|,
name|width
argument_list|)
expr_stmt|;
name|addr
operator|+=
name|width
expr_stmt|;
name|bufptr
operator|+=
name|width
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
comment|/* We don't care about any error which happened after 		     the NULL terminator.  */
name|errcode
operator|=
literal|0
expr_stmt|;
name|found_nul
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
do|while
condition|(
name|errcode
operator|==
literal|0
comment|/* no error */
operator|&&
name|bufptr
operator|-
name|buffer
operator|<
name|fetchlimit
operator|*
name|width
comment|/* no overrun */
operator|&&
operator|!
name|found_nul
condition|)
do|;
comment|/* haven't found nul yet */
block|}
else|else
block|{
comment|/* length of string is really 0! */
name|buffer
operator|=
name|bufptr
operator|=
name|NULL
expr_stmt|;
name|errcode
operator|=
literal|0
expr_stmt|;
block|}
comment|/* bufptr and addr now point immediately beyond the last byte which we      consider part of the string (including a '\0' which ends the string).  */
comment|/* We now have either successfully filled the buffer to fetchlimit, or      terminated early due to an error or finding a null char when LEN is -1. */
if|if
condition|(
name|len
operator|==
operator|-
literal|1
operator|&&
operator|!
name|found_nul
condition|)
block|{
name|char
modifier|*
name|peekbuf
decl_stmt|;
comment|/* We didn't find a null terminator we were looking for.  Attempt          to peek at the next character.  If not successful, or it is not          a null byte, then force ellipsis to be printed.  */
name|peekbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|width
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_read_memory
argument_list|(
name|addr
argument_list|,
name|peekbuf
argument_list|,
name|width
argument_list|)
operator|==
literal|0
operator|&&
name|extract_unsigned_integer
argument_list|(
name|peekbuf
argument_list|,
name|width
argument_list|)
operator|!=
literal|0
condition|)
name|force_ellipsis
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|len
operator|>=
literal|0
operator|&&
name|errcode
operator|!=
literal|0
operator|)
operator|||
operator|(
name|len
operator|>
operator|(
name|bufptr
operator|-
name|buffer
operator|)
operator|/
name|width
operator|)
condition|)
block|{
comment|/* Getting an error when we have a requested length, or fetching less          than the number of characters actually requested, always make us          print ellipsis. */
name|force_ellipsis
operator|=
literal|1
expr_stmt|;
block|}
name|QUIT
expr_stmt|;
comment|/* If we get an error before fetching anything, don't print a string.      But if we fetch something and then get an error, print the string      and then the error message.  */
if|if
condition|(
name|errcode
operator|==
literal|0
operator|||
name|bufptr
operator|>
name|buffer
condition|)
block|{
if|if
condition|(
name|addressprint
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|" "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
name|LA_PRINT_STRING
argument_list|(
name|stream
argument_list|,
name|buffer
argument_list|,
operator|(
name|bufptr
operator|-
name|buffer
operator|)
operator|/
name|width
argument_list|,
name|width
argument_list|,
name|force_ellipsis
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|errcode
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|errcode
operator|==
name|EIO
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<Address "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" out of bounds>"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<Error reading address "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|": %s>"
argument_list|,
name|safe_strerror
argument_list|(
name|errcode
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|gdb_flush
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|bufptr
operator|-
name|buffer
operator|)
operator|/
name|width
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Validate an input or output radix setting, and make sure the user    knows what they really did here.  Radix setting is confusing, e.g.    setting the input radix to "10" never changes it!  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|set_input_radix
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
name|c
parameter_list|)
block|{
name|set_input_radix_1
argument_list|(
name|from_tty
argument_list|,
operator|*
operator|(
name|unsigned
operator|*
operator|)
name|c
operator|->
name|var
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|set_input_radix_1
parameter_list|(
name|int
name|from_tty
parameter_list|,
name|unsigned
name|radix
parameter_list|)
block|{
comment|/* We don't currently disallow any input radix except 0 or 1, which don't      make any mathematical sense.  In theory, we can deal with any input      radix greater than 1, even if we don't have unique digits for every      value from 0 to radix-1, but in practice we lose on large radix values.      We should either fix the lossage or restrict the radix range more.      (FIXME). */
if|if
condition|(
name|radix
operator|<
literal|2
condition|)
block|{
name|error
argument_list|(
literal|"Nonsense input radix ``decimal %u''; input radix unchanged."
argument_list|,
name|radix
argument_list|)
expr_stmt|;
block|}
name|input_radix
operator|=
name|radix
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Input radix now set to decimal %u, hex %x, octal %o.\n"
argument_list|,
name|radix
argument_list|,
name|radix
argument_list|,
name|radix
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|set_output_radix
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
name|c
parameter_list|)
block|{
name|set_output_radix_1
argument_list|(
name|from_tty
argument_list|,
operator|*
operator|(
name|unsigned
operator|*
operator|)
name|c
operator|->
name|var
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_output_radix_1
parameter_list|(
name|int
name|from_tty
parameter_list|,
name|unsigned
name|radix
parameter_list|)
block|{
comment|/* Validate the radix and disallow ones that we aren't prepared to      handle correctly, leaving the radix unchanged. */
switch|switch
condition|(
name|radix
condition|)
block|{
case|case
literal|16
case|:
name|output_format
operator|=
literal|'x'
expr_stmt|;
comment|/* hex */
break|break;
case|case
literal|10
case|:
name|output_format
operator|=
literal|0
expr_stmt|;
comment|/* decimal */
break|break;
case|case
literal|8
case|:
name|output_format
operator|=
literal|'o'
expr_stmt|;
comment|/* octal */
break|break;
default|default:
name|error
argument_list|(
literal|"Unsupported output radix ``decimal %u''; output radix unchanged."
argument_list|,
name|radix
argument_list|)
expr_stmt|;
block|}
name|output_radix
operator|=
name|radix
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Output radix now set to decimal %u, hex %x, octal %o.\n"
argument_list|,
name|radix
argument_list|,
name|radix
argument_list|,
name|radix
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Set both the input and output radix at once.  Try to set the output radix    first, since it has the most restrictive range.  An radix that is valid as    an output radix is also valid as an input radix.     It may be useful to have an unusual input radix.  If the user wishes to    set an input radix that is not valid as an output radix, he needs to use    the 'set input-radix' command. */
end_comment

begin_function
specifier|static
name|void
name|set_radix
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|unsigned
name|radix
decl_stmt|;
name|radix
operator|=
operator|(
name|arg
operator|==
name|NULL
operator|)
condition|?
literal|10
else|:
name|parse_and_eval_long
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|set_output_radix_1
argument_list|(
literal|0
argument_list|,
name|radix
argument_list|)
expr_stmt|;
name|set_input_radix_1
argument_list|(
literal|0
argument_list|,
name|radix
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Input and output radices now set to decimal %u, hex %x, octal %o.\n"
argument_list|,
name|radix
argument_list|,
name|radix
argument_list|,
name|radix
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Show both the input and output radices. */
end_comment

begin_comment
comment|/*ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|show_radix
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
if|if
condition|(
name|from_tty
condition|)
block|{
if|if
condition|(
name|input_radix
operator|==
name|output_radix
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Input and output radices set to decimal %u, hex %x, octal %o.\n"
argument_list|,
name|input_radix
argument_list|,
name|input_radix
argument_list|,
name|input_radix
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf_filtered
argument_list|(
literal|"Input radix set to decimal %u, hex %x, octal %o.\n"
argument_list|,
name|input_radix
argument_list|,
name|input_radix
argument_list|,
name|input_radix
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Output radix set to decimal %u, hex %x, octal %o.\n"
argument_list|,
name|output_radix
argument_list|,
name|output_radix
argument_list|,
name|output_radix
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|set_print
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|printf_unfiltered
argument_list|(
literal|"\"set print\" must be followed by the name of a print subcommand.\n"
argument_list|)
expr_stmt|;
name|help_list
argument_list|(
name|setprintlist
argument_list|,
literal|"set print "
argument_list|,
operator|-
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|show_print
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|cmd_show_list
argument_list|(
name|showprintlist
argument_list|,
name|from_tty
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|_initialize_valprint
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"print"
argument_list|,
name|no_class
argument_list|,
name|set_print
argument_list|,
literal|"Generic command for setting how things print."
argument_list|,
operator|&
name|setprintlist
argument_list|,
literal|"set print "
argument_list|,
literal|0
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|add_alias_cmd
argument_list|(
literal|"p"
argument_list|,
literal|"print"
argument_list|,
name|no_class
argument_list|,
literal|1
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
comment|/* prefer set print to set prompt */
name|add_alias_cmd
argument_list|(
literal|"pr"
argument_list|,
literal|"print"
argument_list|,
name|no_class
argument_list|,
literal|1
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"print"
argument_list|,
name|no_class
argument_list|,
name|show_print
argument_list|,
literal|"Generic command for showing print settings."
argument_list|,
operator|&
name|showprintlist
argument_list|,
literal|"show print "
argument_list|,
literal|0
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_alias_cmd
argument_list|(
literal|"p"
argument_list|,
literal|"print"
argument_list|,
name|no_class
argument_list|,
literal|1
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_alias_cmd
argument_list|(
literal|"pr"
argument_list|,
literal|"print"
argument_list|,
name|no_class
argument_list|,
literal|1
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"elements"
argument_list|,
name|no_class
argument_list|,
name|var_uinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|print_max
argument_list|,
literal|"Set limit on string chars or array elements to print.\n\ \"set print elements 0\" causes there to be no limit."
argument_list|,
operator|&
name|setprintlist
argument_list|)
argument_list|,
operator|&
name|showprintlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"null-stop"
argument_list|,
name|no_class
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|stop_print_at_null
argument_list|,
literal|"Set printing of char arrays to stop at first null char."
argument_list|,
operator|&
name|setprintlist
argument_list|)
argument_list|,
operator|&
name|showprintlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"repeats"
argument_list|,
name|no_class
argument_list|,
name|var_uinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|repeat_count_threshold
argument_list|,
literal|"Set threshold for repeated print elements.\n\ \"set print repeats 0\" causes all elements to be individually printed."
argument_list|,
operator|&
name|setprintlist
argument_list|)
argument_list|,
operator|&
name|showprintlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"pretty"
argument_list|,
name|class_support
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|prettyprint_structs
argument_list|,
literal|"Set prettyprinting of structures."
argument_list|,
operator|&
name|setprintlist
argument_list|)
argument_list|,
operator|&
name|showprintlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"union"
argument_list|,
name|class_support
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|unionprint
argument_list|,
literal|"Set printing of unions interior to structures."
argument_list|,
operator|&
name|setprintlist
argument_list|)
argument_list|,
operator|&
name|showprintlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"array"
argument_list|,
name|class_support
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|prettyprint_arrays
argument_list|,
literal|"Set prettyprinting of arrays."
argument_list|,
operator|&
name|setprintlist
argument_list|)
argument_list|,
operator|&
name|showprintlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"address"
argument_list|,
name|class_support
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|addressprint
argument_list|,
literal|"Set printing of addresses."
argument_list|,
operator|&
name|setprintlist
argument_list|)
argument_list|,
operator|&
name|showprintlist
argument_list|)
expr_stmt|;
name|c
operator|=
name|add_set_cmd
argument_list|(
literal|"input-radix"
argument_list|,
name|class_support
argument_list|,
name|var_uinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|input_radix
argument_list|,
literal|"Set default input radix for entering numbers."
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|c
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|set_cmd_sfunc
argument_list|(
name|c
argument_list|,
name|set_input_radix
argument_list|)
expr_stmt|;
name|c
operator|=
name|add_set_cmd
argument_list|(
literal|"output-radix"
argument_list|,
name|class_support
argument_list|,
name|var_uinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|output_radix
argument_list|,
literal|"Set default output radix for printing of values."
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|c
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|set_cmd_sfunc
argument_list|(
name|c
argument_list|,
name|set_output_radix
argument_list|)
expr_stmt|;
comment|/* The "set radix" and "show radix" commands are special in that they are      like normal set and show commands but allow two normally independent      variables to be either set or shown with a single command.  So the      usual add_set_cmd() and add_show_from_set() commands aren't really      appropriate. */
name|add_cmd
argument_list|(
literal|"radix"
argument_list|,
name|class_support
argument_list|,
name|set_radix
argument_list|,
literal|"Set default input and output number radices.\n\ Use 'set input-radix' or 'set output-radix' to independently set each.\n\ Without an argument, sets both radices back to the default value of 10."
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"radix"
argument_list|,
name|class_support
argument_list|,
name|show_radix
argument_list|,
literal|"Show the default input and output number radices.\n\ Use 'show input-radix' or 'show output-radix' to independently show each."
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
comment|/* Give people the defaults which they are used to.  */
name|prettyprint_structs
operator|=
literal|0
expr_stmt|;
name|prettyprint_arrays
operator|=
literal|0
expr_stmt|;
name|unionprint
operator|=
literal|1
expr_stmt|;
name|addressprint
operator|=
literal|1
expr_stmt|;
name|print_max
operator|=
name|PRINT_MAX_DEFAULT
expr_stmt|;
block|}
end_function

end_unit

