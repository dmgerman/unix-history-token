begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Target-dependent code for SPARC.     Copyright 2003, 2004 Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"arch-utils.h"
end_include

begin_include
include|#
directive|include
file|"dis-asm.h"
end_include

begin_include
include|#
directive|include
file|"floatformat.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"frame-base.h"
end_include

begin_include
include|#
directive|include
file|"frame-unwind.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"osabi.h"
end_include

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"gdb_assert.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"sparc-tdep.h"
end_include

begin_struct_decl
struct_decl|struct
name|regset
struct_decl|;
end_struct_decl

begin_comment
comment|/* This file implements the The SPARC 32-bit ABI as defined by the    section "Low-Level System Information" of the SPARC Compliance    Definition (SCD) 2.4.1, which is the 32-bit System V psABI for    SPARC.  The SCD lists changes with respect to the origional 32-bit    psABI as defined in the "System V ABI, SPARC Processor    Supplement".     Note that if we talk about SunOS, we mean SunOS 4.x, which was    BSD-based, which is sometimes (retroactively?) referred to as    Solaris 1.x.  If we talk about Solaris we mean Solaris 2.x and    above (Solaris 7, 8 and 9 are nothing but Solaris 2.7, 2.8 and 2.9    suffering from severe version number inflation).  Solaris 2.x is    also known as SunOS 5.x, since that's what uname(1) says.  Solaris    2.x is SVR4-based.  */
end_comment

begin_comment
comment|/* Please use the sparc32_-prefix for 32-bit specific code, the    sparc64_-prefix for 64-bit specific code and the sparc_-prefix for    code that can handle both.  The 64-bit specific code lives in    sparc64-tdep.c; don't add any here.  */
end_comment

begin_comment
comment|/* The SPARC Floating-Point Quad-Precision format is similar to    big-endian IA-64 Quad-recision format.  */
end_comment

begin_define
define|#
directive|define
name|floatformat_sparc_quad
value|floatformat_ia64_quad_big
end_define

begin_comment
comment|/* The stack pointer is offset from the stack frame by a BIAS of 2047    (0x7ff) for 64-bit code.  BIAS is likely to be defined on SPARC    hosts, so undefine it first.  */
end_comment

begin_undef
undef|#
directive|undef
name|BIAS
end_undef

begin_define
define|#
directive|define
name|BIAS
value|2047
end_define

begin_comment
comment|/* Macros to extract fields from SPARC instructions.  */
end_comment

begin_define
define|#
directive|define
name|X_OP
parameter_list|(
name|i
parameter_list|)
value|(((i)>> 30)& 0x3)
end_define

begin_define
define|#
directive|define
name|X_RD
parameter_list|(
name|i
parameter_list|)
value|(((i)>> 25)& 0x1f)
end_define

begin_define
define|#
directive|define
name|X_A
parameter_list|(
name|i
parameter_list|)
value|(((i)>> 29)& 1)
end_define

begin_define
define|#
directive|define
name|X_COND
parameter_list|(
name|i
parameter_list|)
value|(((i)>> 25)& 0xf)
end_define

begin_define
define|#
directive|define
name|X_OP2
parameter_list|(
name|i
parameter_list|)
value|(((i)>> 22)& 0x7)
end_define

begin_define
define|#
directive|define
name|X_IMM22
parameter_list|(
name|i
parameter_list|)
value|((i)& 0x3fffff)
end_define

begin_define
define|#
directive|define
name|X_OP3
parameter_list|(
name|i
parameter_list|)
value|(((i)>> 19)& 0x3f)
end_define

begin_define
define|#
directive|define
name|X_I
parameter_list|(
name|i
parameter_list|)
value|(((i)>> 13)& 1)
end_define

begin_comment
comment|/* Sign extension macros.  */
end_comment

begin_define
define|#
directive|define
name|X_DISP22
parameter_list|(
name|i
parameter_list|)
value|((X_IMM22 (i) ^ 0x200000) - 0x200000)
end_define

begin_define
define|#
directive|define
name|X_DISP19
parameter_list|(
name|i
parameter_list|)
value|((((i)& 0x7ffff) ^ 0x40000) - 0x40000)
end_define

begin_comment
comment|/* Fetch the instruction at PC.  Instructions are always big-endian    even if the processor operates in little-endian mode.  */
end_comment

begin_function
name|unsigned
name|long
name|sparc_fetch_instruction
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
name|unsigned
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|unsigned
name|long
name|insn
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* If we can't read the instruction at PC, return zero.  */
if|if
condition|(
name|target_read_memory
argument_list|(
name|pc
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|insn
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
condition|;
name|i
operator|++
control|)
name|insn
operator|=
operator|(
name|insn
operator|<<
literal|8
operator|)
operator||
name|buf
index|[
name|i
index|]
expr_stmt|;
return|return
name|insn
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* OpenBSD/sparc includes StackGhost, which according to the author's    website http://stackghost.cerias.purdue.edu "... transparently and    automatically protects applications' stack frames; more    specifically, it guards the return pointers.  The protection    mechanisms require no application source or binary modification and    imposes only a negligible performance penalty."     The same website provides the following description of how    StackGhost works:     "StackGhost interfaces with the kernel trap handler that would    normally write out registers to the stack and the handler that    would read them back in.  By XORing a cookie into the    return-address saved in the user stack when it is actually written    to the stack, and then XOR it out when the return-address is pulled    from the stack, StackGhost can cause attacker corrupted return    pointers to behave in a manner the attacker cannot predict.    StackGhost can also use several unused bits in the return pointer    to detect a smashed return pointer and abort the process."     For GDB this means that whenever we're reading %i7 from a stack    frame's window save area, we'll have to XOR the cookie.     More information on StackGuard can be found on in:     Mike Frantzen and Mike Shuey. "StackGhost: Hardware Facilitated    Stack Protection."  2001.  Published in USENIX Security Symposium    '01.  */
end_comment

begin_comment
comment|/* Fetch StackGhost Per-Process XOR cookie.  */
end_comment

begin_function
name|ULONGEST
name|sparc_fetch_wcookie
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|target_ops
modifier|*
name|ops
init|=
operator|&
name|current_target
decl_stmt|;
name|char
name|buf
index|[
literal|8
index|]
decl_stmt|;
name|int
name|len
decl_stmt|;
name|len
operator|=
name|target_read_partial
argument_list|(
name|ops
argument_list|,
name|TARGET_OBJECT_WCOOKIE
argument_list|,
name|NULL
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
operator|-
literal|1
condition|)
return|return
literal|0
return|;
comment|/* We should have either an 32-bit or an 64-bit cookie.  */
name|gdb_assert
argument_list|(
name|len
operator|==
literal|4
operator|||
name|len
operator|==
literal|8
argument_list|)
expr_stmt|;
return|return
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the contents if register REGNUM as an address.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|sparc_address_from_register
parameter_list|(
name|int
name|regnum
parameter_list|)
block|{
name|ULONGEST
name|addr
decl_stmt|;
name|regcache_cooked_read_unsigned
argument_list|(
name|current_regcache
argument_list|,
name|regnum
argument_list|,
operator|&
name|addr
argument_list|)
expr_stmt|;
return|return
name|addr
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The functions on this page are intended to be used to classify    function arguments.  */
end_comment

begin_comment
comment|/* Check whether TYPE is "Integral or Pointer".  */
end_comment

begin_function
specifier|static
name|int
name|sparc_integral_or_pointer_p
parameter_list|(
specifier|const
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_INT
case|:
case|case
name|TYPE_CODE_BOOL
case|:
case|case
name|TYPE_CODE_CHAR
case|:
case|case
name|TYPE_CODE_ENUM
case|:
case|case
name|TYPE_CODE_RANGE
case|:
block|{
comment|/* We have byte, half-word, word and extended-word/doubleword            integral types.  The doubleword is an extension to the            origional 32-bit ABI by the SCD 2.4.x.  */
name|int
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
decl_stmt|;
return|return
operator|(
name|len
operator|==
literal|1
operator|||
name|len
operator|==
literal|2
operator|||
name|len
operator|==
literal|4
operator|||
name|len
operator|==
literal|8
operator|)
return|;
block|}
return|return
literal|1
return|;
case|case
name|TYPE_CODE_PTR
case|:
case|case
name|TYPE_CODE_REF
case|:
block|{
comment|/* Allow either 32-bit or 64-bit pointers.  */
name|int
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
decl_stmt|;
return|return
operator|(
name|len
operator|==
literal|4
operator|||
name|len
operator|==
literal|8
operator|)
return|;
block|}
return|return
literal|1
return|;
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Check whether TYPE is "Floating".  */
end_comment

begin_function
specifier|static
name|int
name|sparc_floating_p
parameter_list|(
specifier|const
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_FLT
case|:
block|{
name|int
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
decl_stmt|;
return|return
operator|(
name|len
operator|==
literal|4
operator|||
name|len
operator|==
literal|8
operator|||
name|len
operator|==
literal|16
operator|)
return|;
block|}
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Check whether TYPE is "Structure or Union".  */
end_comment

begin_function
specifier|static
name|int
name|sparc_structure_or_union_p
parameter_list|(
specifier|const
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_STRUCT
case|:
case|case
name|TYPE_CODE_UNION
case|:
return|return
literal|1
return|;
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Register information.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|sparc32_register_names
index|[]
init|=
block|{
literal|"g0"
block|,
literal|"g1"
block|,
literal|"g2"
block|,
literal|"g3"
block|,
literal|"g4"
block|,
literal|"g5"
block|,
literal|"g6"
block|,
literal|"g7"
block|,
literal|"o0"
block|,
literal|"o1"
block|,
literal|"o2"
block|,
literal|"o3"
block|,
literal|"o4"
block|,
literal|"o5"
block|,
literal|"sp"
block|,
literal|"o7"
block|,
literal|"l0"
block|,
literal|"l1"
block|,
literal|"l2"
block|,
literal|"l3"
block|,
literal|"l4"
block|,
literal|"l5"
block|,
literal|"l6"
block|,
literal|"l7"
block|,
literal|"i0"
block|,
literal|"i1"
block|,
literal|"i2"
block|,
literal|"i3"
block|,
literal|"i4"
block|,
literal|"i5"
block|,
literal|"fp"
block|,
literal|"i7"
block|,
literal|"f0"
block|,
literal|"f1"
block|,
literal|"f2"
block|,
literal|"f3"
block|,
literal|"f4"
block|,
literal|"f5"
block|,
literal|"f6"
block|,
literal|"f7"
block|,
literal|"f8"
block|,
literal|"f9"
block|,
literal|"f10"
block|,
literal|"f11"
block|,
literal|"f12"
block|,
literal|"f13"
block|,
literal|"f14"
block|,
literal|"f15"
block|,
literal|"f16"
block|,
literal|"f17"
block|,
literal|"f18"
block|,
literal|"f19"
block|,
literal|"f20"
block|,
literal|"f21"
block|,
literal|"f22"
block|,
literal|"f23"
block|,
literal|"f24"
block|,
literal|"f25"
block|,
literal|"f26"
block|,
literal|"f27"
block|,
literal|"f28"
block|,
literal|"f29"
block|,
literal|"f30"
block|,
literal|"f31"
block|,
literal|"y"
block|,
literal|"psr"
block|,
literal|"wim"
block|,
literal|"tbr"
block|,
literal|"pc"
block|,
literal|"npc"
block|,
literal|"fsr"
block|,
literal|"csr"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Total number of registers.  */
end_comment

begin_define
define|#
directive|define
name|SPARC32_NUM_REGS
value|ARRAY_SIZE (sparc32_register_names)
end_define

begin_comment
comment|/* We provide the aliases %d0..%d30 for the floating registers as    "psuedo" registers.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|sparc32_pseudo_register_names
index|[]
init|=
block|{
literal|"d0"
block|,
literal|"d2"
block|,
literal|"d4"
block|,
literal|"d6"
block|,
literal|"d8"
block|,
literal|"d10"
block|,
literal|"d12"
block|,
literal|"d14"
block|,
literal|"d16"
block|,
literal|"d18"
block|,
literal|"d20"
block|,
literal|"d22"
block|,
literal|"d24"
block|,
literal|"d26"
block|,
literal|"d28"
block|,
literal|"d30"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Total number of pseudo registers.  */
end_comment

begin_define
define|#
directive|define
name|SPARC32_NUM_PSEUDO_REGS
value|ARRAY_SIZE (sparc32_pseudo_register_names)
end_define

begin_comment
comment|/* Return the name of register REGNUM.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|sparc32_register_name
parameter_list|(
name|int
name|regnum
parameter_list|)
block|{
if|if
condition|(
name|regnum
operator|>=
literal|0
operator|&&
name|regnum
operator|<
name|SPARC32_NUM_REGS
condition|)
return|return
name|sparc32_register_names
index|[
name|regnum
index|]
return|;
if|if
condition|(
name|regnum
operator|<
name|SPARC32_NUM_REGS
operator|+
name|SPARC32_NUM_PSEUDO_REGS
condition|)
return|return
name|sparc32_pseudo_register_names
index|[
name|regnum
operator|-
name|SPARC32_NUM_REGS
index|]
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Return the GDB type object for the "standard" data type of data in    register REGNUM. */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|sparc32_register_type
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|int
name|regnum
parameter_list|)
block|{
if|if
condition|(
name|regnum
operator|>=
name|SPARC_F0_REGNUM
operator|&&
name|regnum
operator|<=
name|SPARC_F31_REGNUM
condition|)
return|return
name|builtin_type_float
return|;
if|if
condition|(
name|regnum
operator|>=
name|SPARC32_D0_REGNUM
operator|&&
name|regnum
operator|<=
name|SPARC32_D30_REGNUM
condition|)
return|return
name|builtin_type_double
return|;
if|if
condition|(
name|regnum
operator|==
name|SPARC_SP_REGNUM
operator|||
name|regnum
operator|==
name|SPARC_FP_REGNUM
condition|)
return|return
name|builtin_type_void_data_ptr
return|;
if|if
condition|(
name|regnum
operator|==
name|SPARC32_PC_REGNUM
operator|||
name|regnum
operator|==
name|SPARC32_NPC_REGNUM
condition|)
return|return
name|builtin_type_void_func_ptr
return|;
return|return
name|builtin_type_int32
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sparc32_pseudo_register_read
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|int
name|regnum
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|)
block|{
name|gdb_assert
argument_list|(
name|regnum
operator|>=
name|SPARC32_D0_REGNUM
operator|&&
name|regnum
operator|<=
name|SPARC32_D30_REGNUM
argument_list|)
expr_stmt|;
name|regnum
operator|=
name|SPARC_F0_REGNUM
operator|+
literal|2
operator|*
operator|(
name|regnum
operator|-
name|SPARC32_D0_REGNUM
operator|)
expr_stmt|;
name|regcache_raw_read
argument_list|(
name|regcache
argument_list|,
name|regnum
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|regcache_raw_read
argument_list|(
name|regcache
argument_list|,
name|regnum
operator|+
literal|1
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
name|buf
operator|)
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sparc32_pseudo_register_write
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|int
name|regnum
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|)
block|{
name|gdb_assert
argument_list|(
name|regnum
operator|>=
name|SPARC32_D0_REGNUM
operator|&&
name|regnum
operator|<=
name|SPARC32_D30_REGNUM
argument_list|)
expr_stmt|;
name|regnum
operator|=
name|SPARC_F0_REGNUM
operator|+
literal|2
operator|*
operator|(
name|regnum
operator|-
name|SPARC32_D0_REGNUM
operator|)
expr_stmt|;
name|regcache_raw_write
argument_list|(
name|regcache
argument_list|,
name|regnum
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|regcache_raw_write
argument_list|(
name|regcache
argument_list|,
name|regnum
operator|+
literal|1
argument_list|,
operator|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|buf
operator|)
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|CORE_ADDR
name|sparc32_push_dummy_code
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|CORE_ADDR
name|sp
parameter_list|,
name|CORE_ADDR
name|funcaddr
parameter_list|,
name|int
name|using_gcc
parameter_list|,
name|struct
name|value
modifier|*
modifier|*
name|args
parameter_list|,
name|int
name|nargs
parameter_list|,
name|struct
name|type
modifier|*
name|value_type
parameter_list|,
name|CORE_ADDR
modifier|*
name|real_pc
parameter_list|,
name|CORE_ADDR
modifier|*
name|bp_addr
parameter_list|)
block|{
operator|*
name|bp_addr
operator|=
name|sp
operator|-
literal|4
expr_stmt|;
operator|*
name|real_pc
operator|=
name|funcaddr
expr_stmt|;
if|if
condition|(
name|using_struct_return
argument_list|(
name|value_type
argument_list|,
name|using_gcc
argument_list|)
condition|)
block|{
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|;
comment|/* This is an UNIMP instruction.  */
name|store_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|value_type
argument_list|)
operator|&
literal|0x1fff
argument_list|)
expr_stmt|;
name|write_memory
argument_list|(
name|sp
operator|-
literal|8
argument_list|,
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
return|return
name|sp
operator|-
literal|8
return|;
block|}
return|return
name|sp
operator|-
literal|4
return|;
block|}
end_function

begin_function
specifier|static
name|CORE_ADDR
name|sparc32_store_arguments
parameter_list|(
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|int
name|nargs
parameter_list|,
name|struct
name|value
modifier|*
modifier|*
name|args
parameter_list|,
name|CORE_ADDR
name|sp
parameter_list|,
name|int
name|struct_return
parameter_list|,
name|CORE_ADDR
name|struct_addr
parameter_list|)
block|{
comment|/* Number of words in the "parameter array".  */
name|int
name|num_elements
init|=
literal|0
decl_stmt|;
name|int
name|element
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nargs
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|type
modifier|*
name|type
init|=
name|VALUE_TYPE
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|sparc_structure_or_union_p
argument_list|(
name|type
argument_list|)
operator|||
operator|(
name|sparc_floating_p
argument_list|(
name|type
argument_list|)
operator|&&
name|len
operator|==
literal|16
operator|)
condition|)
block|{
comment|/* Structure, Union and Quad-Precision Arguments.  */
name|sp
operator|-=
name|len
expr_stmt|;
comment|/* Use doubleword alignment for these values.  That's always              correct, and wasting a few bytes shouldn't be a problem.  */
name|sp
operator|&=
operator|~
literal|0x7
expr_stmt|;
name|write_memory
argument_list|(
name|sp
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|args
index|[
name|i
index|]
operator|=
name|value_from_pointer
argument_list|(
name|lookup_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|num_elements
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sparc_floating_p
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* Floating arguments.  */
name|gdb_assert
argument_list|(
name|len
operator|==
literal|4
operator|||
name|len
operator|==
literal|8
argument_list|)
expr_stmt|;
name|num_elements
operator|+=
operator|(
name|len
operator|/
literal|4
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Integral and pointer arguments.  */
name|gdb_assert
argument_list|(
name|sparc_integral_or_pointer_p
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|4
condition|)
name|args
index|[
name|i
index|]
operator|=
name|value_cast
argument_list|(
name|builtin_type_int32
argument_list|,
name|args
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|num_elements
operator|+=
operator|(
operator|(
name|len
operator|+
literal|3
operator|)
operator|/
literal|4
operator|)
expr_stmt|;
block|}
block|}
comment|/* Always allocate at least six words.  */
name|sp
operator|-=
name|max
argument_list|(
literal|6
argument_list|,
name|num_elements
argument_list|)
operator|*
literal|4
expr_stmt|;
comment|/* The psABI says that "Software convention requires space for the      struct/union return value pointer, even if the word is unused."  */
name|sp
operator|-=
literal|4
expr_stmt|;
comment|/* The psABI says that "Although software convention and the      operating system require every stack frame to be doubleword      aligned."  */
name|sp
operator|&=
operator|~
literal|0x7
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nargs
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|valbuf
init|=
name|VALUE_CONTENTS
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|struct
name|type
modifier|*
name|type
init|=
name|VALUE_TYPE
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|gdb_assert
argument_list|(
name|len
operator|==
literal|4
operator|||
name|len
operator|==
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|element
operator|<
literal|6
condition|)
block|{
name|int
name|regnum
init|=
name|SPARC_O0_REGNUM
operator|+
name|element
decl_stmt|;
name|regcache_cooked_write
argument_list|(
name|regcache
argument_list|,
name|regnum
argument_list|,
name|valbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|4
operator|&&
name|element
operator|<
literal|5
condition|)
name|regcache_cooked_write
argument_list|(
name|regcache
argument_list|,
name|regnum
operator|+
literal|1
argument_list|,
name|valbuf
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
comment|/* Always store the argument in memory.  */
name|write_memory
argument_list|(
name|sp
operator|+
literal|4
operator|+
name|element
operator|*
literal|4
argument_list|,
name|valbuf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|element
operator|+=
name|len
operator|/
literal|4
expr_stmt|;
block|}
name|gdb_assert
argument_list|(
name|element
operator|==
name|num_elements
argument_list|)
expr_stmt|;
if|if
condition|(
name|struct_return
condition|)
block|{
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|store_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|,
name|struct_addr
argument_list|)
expr_stmt|;
name|write_memory
argument_list|(
name|sp
argument_list|,
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
return|return
name|sp
return|;
block|}
end_function

begin_function
specifier|static
name|CORE_ADDR
name|sparc32_push_dummy_call
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|CORE_ADDR
name|func_addr
parameter_list|,
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|CORE_ADDR
name|bp_addr
parameter_list|,
name|int
name|nargs
parameter_list|,
name|struct
name|value
modifier|*
modifier|*
name|args
parameter_list|,
name|CORE_ADDR
name|sp
parameter_list|,
name|int
name|struct_return
parameter_list|,
name|CORE_ADDR
name|struct_addr
parameter_list|)
block|{
name|CORE_ADDR
name|call_pc
init|=
operator|(
name|struct_return
condition|?
operator|(
name|bp_addr
operator|-
literal|12
operator|)
else|:
operator|(
name|bp_addr
operator|-
literal|8
operator|)
operator|)
decl_stmt|;
comment|/* Set return address.  */
name|regcache_cooked_write_unsigned
argument_list|(
name|regcache
argument_list|,
name|SPARC_O7_REGNUM
argument_list|,
name|call_pc
argument_list|)
expr_stmt|;
comment|/* Set up function arguments.  */
name|sp
operator|=
name|sparc32_store_arguments
argument_list|(
name|regcache
argument_list|,
name|nargs
argument_list|,
name|args
argument_list|,
name|sp
argument_list|,
name|struct_return
argument_list|,
name|struct_addr
argument_list|)
expr_stmt|;
comment|/* Allocate the 16-word window save area.  */
name|sp
operator|-=
literal|16
operator|*
literal|4
expr_stmt|;
comment|/* Stack should be doubleword aligned at this point.  */
name|gdb_assert
argument_list|(
name|sp
operator|%
literal|8
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* Finally, update the stack pointer.  */
name|regcache_cooked_write_unsigned
argument_list|(
name|regcache
argument_list|,
name|SPARC_SP_REGNUM
argument_list|,
name|sp
argument_list|)
expr_stmt|;
return|return
name|sp
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Use the program counter to determine the contents and size of a    breakpoint instruction.  Return a pointer to a string of bytes that    encode a breakpoint instruction, store the length of the string in    *LEN and optionally adjust *PC to point to the correct memory    location for inserting the breakpoint.  */
end_comment

begin_function
specifier|static
specifier|const
name|unsigned
name|char
modifier|*
name|sparc_breakpoint_from_pc
parameter_list|(
name|CORE_ADDR
modifier|*
name|pc
parameter_list|,
name|int
modifier|*
name|len
parameter_list|)
block|{
specifier|static
name|unsigned
name|char
name|break_insn
index|[]
init|=
block|{
literal|0x91
block|,
literal|0xd0
block|,
literal|0x20
block|,
literal|0x01
block|}
decl_stmt|;
operator|*
name|len
operator|=
sizeof|sizeof
argument_list|(
name|break_insn
argument_list|)
expr_stmt|;
return|return
name|break_insn
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Allocate and initialize a frame cache.  */
end_comment

begin_function
specifier|static
name|struct
name|sparc_frame_cache
modifier|*
name|sparc_alloc_frame_cache
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|sparc_frame_cache
modifier|*
name|cache
decl_stmt|;
name|int
name|i
decl_stmt|;
name|cache
operator|=
name|FRAME_OBSTACK_ZALLOC
argument_list|(
expr|struct
name|sparc_frame_cache
argument_list|)
expr_stmt|;
comment|/* Base address.  */
name|cache
operator|->
name|base
operator|=
literal|0
expr_stmt|;
name|cache
operator|->
name|pc
operator|=
literal|0
expr_stmt|;
comment|/* Frameless until proven otherwise.  */
name|cache
operator|->
name|frameless_p
operator|=
literal|1
expr_stmt|;
name|cache
operator|->
name|struct_return_p
operator|=
literal|0
expr_stmt|;
return|return
name|cache
return|;
block|}
end_function

begin_function
name|CORE_ADDR
name|sparc_analyze_prologue
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|CORE_ADDR
name|current_pc
parameter_list|,
name|struct
name|sparc_frame_cache
modifier|*
name|cache
parameter_list|)
block|{
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
decl_stmt|;
name|unsigned
name|long
name|insn
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|int
name|dest
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|current_pc
operator|<=
name|pc
condition|)
return|return
name|current_pc
return|;
comment|/* We have to handle to "Procedure Linkage Table" (PLT) special.  On      SPARC the linker usually defines a symbol (typically      _PROCEDURE_LINKAGE_TABLE_) at the start of the .plt section.      This symbol makes us end up here with PC pointing at the start of      the PLT and CURRENT_PC probably pointing at a PLT entry.  If we      would do our normal prologue analysis, we would probably conclude      that we've got a frame when in reality we don't, since the      dynamic linker patches up the first PLT with some code that      starts with a SAVE instruction.  Patch up PC such that it points      at the start of our PLT entry.  */
if|if
condition|(
name|tdep
operator|->
name|plt_entry_size
operator|>
literal|0
operator|&&
name|in_plt_section
argument_list|(
name|current_pc
argument_list|,
name|NULL
argument_list|)
condition|)
name|pc
operator|=
name|current_pc
operator|-
operator|(
operator|(
name|current_pc
operator|-
name|pc
operator|)
operator|%
name|tdep
operator|->
name|plt_entry_size
operator|)
expr_stmt|;
name|insn
operator|=
name|sparc_fetch_instruction
argument_list|(
name|pc
argument_list|)
expr_stmt|;
comment|/* Recognize a SETHI insn and record its destination.  */
if|if
condition|(
name|X_OP
argument_list|(
name|insn
argument_list|)
operator|==
literal|0
operator|&&
name|X_OP2
argument_list|(
name|insn
argument_list|)
operator|==
literal|0x04
condition|)
block|{
name|dest
operator|=
name|X_RD
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|4
expr_stmt|;
name|insn
operator|=
name|sparc_fetch_instruction
argument_list|(
name|pc
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
comment|/* Allow for an arithmetic operation on DEST or %g1.  */
if|if
condition|(
name|X_OP
argument_list|(
name|insn
argument_list|)
operator|==
literal|2
operator|&&
name|X_I
argument_list|(
name|insn
argument_list|)
operator|&&
operator|(
name|X_RD
argument_list|(
name|insn
argument_list|)
operator|==
literal|1
operator|||
name|X_RD
argument_list|(
name|insn
argument_list|)
operator|==
name|dest
operator|)
condition|)
block|{
name|offset
operator|+=
literal|4
expr_stmt|;
name|insn
operator|=
name|sparc_fetch_instruction
argument_list|(
name|pc
operator|+
literal|8
argument_list|)
expr_stmt|;
block|}
comment|/* Check for the SAVE instruction that sets up the frame.  */
if|if
condition|(
name|X_OP
argument_list|(
name|insn
argument_list|)
operator|==
literal|2
operator|&&
name|X_OP3
argument_list|(
name|insn
argument_list|)
operator|==
literal|0x3c
condition|)
block|{
name|cache
operator|->
name|frameless_p
operator|=
literal|0
expr_stmt|;
return|return
name|pc
operator|+
name|offset
operator|+
literal|4
return|;
block|}
return|return
name|pc
return|;
block|}
end_function

begin_function
specifier|static
name|CORE_ADDR
name|sparc_unwind_pc
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|)
block|{
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|gdbarch
argument_list|)
decl_stmt|;
return|return
name|frame_unwind_register_unsigned
argument_list|(
name|next_frame
argument_list|,
name|tdep
operator|->
name|pc_regnum
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return PC of first real instruction of the function starting at    START_PC.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|sparc32_skip_prologue
parameter_list|(
name|CORE_ADDR
name|start_pc
parameter_list|)
block|{
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|CORE_ADDR
name|func_start
decl_stmt|,
name|func_end
decl_stmt|;
name|struct
name|sparc_frame_cache
name|cache
decl_stmt|;
comment|/* This is the preferred method, find the end of the prologue by      using the debugging information.  */
if|if
condition|(
name|find_pc_partial_function
argument_list|(
name|start_pc
argument_list|,
name|NULL
argument_list|,
operator|&
name|func_start
argument_list|,
operator|&
name|func_end
argument_list|)
condition|)
block|{
name|sal
operator|=
name|find_pc_line
argument_list|(
name|func_start
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sal
operator|.
name|end
operator|<
name|func_end
operator|&&
name|start_pc
operator|<=
name|sal
operator|.
name|end
condition|)
return|return
name|sal
operator|.
name|end
return|;
block|}
return|return
name|sparc_analyze_prologue
argument_list|(
name|start_pc
argument_list|,
literal|0xffffffffUL
argument_list|,
operator|&
name|cache
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Normal frames.  */
end_comment

begin_function
name|struct
name|sparc_frame_cache
modifier|*
name|sparc_frame_cache
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|void
modifier|*
modifier|*
name|this_cache
parameter_list|)
block|{
name|struct
name|sparc_frame_cache
modifier|*
name|cache
decl_stmt|;
if|if
condition|(
operator|*
name|this_cache
condition|)
return|return
operator|*
name|this_cache
return|;
name|cache
operator|=
name|sparc_alloc_frame_cache
argument_list|()
expr_stmt|;
operator|*
name|this_cache
operator|=
name|cache
expr_stmt|;
name|cache
operator|->
name|pc
operator|=
name|frame_func_unwind
argument_list|(
name|next_frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|cache
operator|->
name|pc
operator|!=
literal|0
condition|)
block|{
name|CORE_ADDR
name|addr_in_block
init|=
name|frame_unwind_address_in_block
argument_list|(
name|next_frame
argument_list|)
decl_stmt|;
name|sparc_analyze_prologue
argument_list|(
name|cache
operator|->
name|pc
argument_list|,
name|addr_in_block
argument_list|,
name|cache
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cache
operator|->
name|frameless_p
condition|)
block|{
comment|/* This function is frameless, so %fp (%i6) holds the frame          pointer for our calling frame.  Use %sp (%o6) as this frame's          base address.  */
name|cache
operator|->
name|base
operator|=
name|frame_unwind_register_unsigned
argument_list|(
name|next_frame
argument_list|,
name|SPARC_SP_REGNUM
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* For normal frames, %fp (%i6) holds the frame pointer, the          base address for the current stack frame.  */
name|cache
operator|->
name|base
operator|=
name|frame_unwind_register_unsigned
argument_list|(
name|next_frame
argument_list|,
name|SPARC_FP_REGNUM
argument_list|)
expr_stmt|;
block|}
return|return
name|cache
return|;
block|}
end_function

begin_function
name|struct
name|sparc_frame_cache
modifier|*
name|sparc32_frame_cache
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|void
modifier|*
modifier|*
name|this_cache
parameter_list|)
block|{
name|struct
name|sparc_frame_cache
modifier|*
name|cache
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
if|if
condition|(
operator|*
name|this_cache
condition|)
return|return
operator|*
name|this_cache
return|;
name|cache
operator|=
name|sparc_frame_cache
argument_list|(
name|next_frame
argument_list|,
name|this_cache
argument_list|)
expr_stmt|;
name|sym
operator|=
name|find_pc_function
argument_list|(
name|cache
operator|->
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
condition|)
block|{
name|struct
name|type
modifier|*
name|type
init|=
name|check_typedef
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
decl_stmt|;
name|enum
name|type_code
name|code
init|=
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|TYPE_CODE_FUNC
operator|||
name|code
operator|==
name|TYPE_CODE_METHOD
condition|)
block|{
name|type
operator|=
name|check_typedef
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sparc_structure_or_union_p
argument_list|(
name|type
argument_list|)
operator|||
operator|(
name|sparc_floating_p
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|==
literal|16
operator|)
condition|)
name|cache
operator|->
name|struct_return_p
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
name|cache
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sparc32_frame_this_id
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|void
modifier|*
modifier|*
name|this_cache
parameter_list|,
name|struct
name|frame_id
modifier|*
name|this_id
parameter_list|)
block|{
name|struct
name|sparc_frame_cache
modifier|*
name|cache
init|=
name|sparc32_frame_cache
argument_list|(
name|next_frame
argument_list|,
name|this_cache
argument_list|)
decl_stmt|;
comment|/* This marks the outermost frame.  */
if|if
condition|(
name|cache
operator|->
name|base
operator|==
literal|0
condition|)
return|return;
operator|(
operator|*
name|this_id
operator|)
operator|=
name|frame_id_build
argument_list|(
name|cache
operator|->
name|base
argument_list|,
name|cache
operator|->
name|pc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sparc32_frame_prev_register
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|void
modifier|*
modifier|*
name|this_cache
parameter_list|,
name|int
name|regnum
parameter_list|,
name|int
modifier|*
name|optimizedp
parameter_list|,
name|enum
name|lval_type
modifier|*
name|lvalp
parameter_list|,
name|CORE_ADDR
modifier|*
name|addrp
parameter_list|,
name|int
modifier|*
name|realnump
parameter_list|,
name|void
modifier|*
name|valuep
parameter_list|)
block|{
name|struct
name|sparc_frame_cache
modifier|*
name|cache
init|=
name|sparc32_frame_cache
argument_list|(
name|next_frame
argument_list|,
name|this_cache
argument_list|)
decl_stmt|;
if|if
condition|(
name|regnum
operator|==
name|SPARC32_PC_REGNUM
operator|||
name|regnum
operator|==
name|SPARC32_NPC_REGNUM
condition|)
block|{
operator|*
name|optimizedp
operator|=
literal|0
expr_stmt|;
operator|*
name|lvalp
operator|=
name|not_lval
expr_stmt|;
operator|*
name|addrp
operator|=
literal|0
expr_stmt|;
operator|*
name|realnump
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|valuep
condition|)
block|{
name|CORE_ADDR
name|pc
init|=
operator|(
name|regnum
operator|==
name|SPARC32_NPC_REGNUM
operator|)
condition|?
literal|4
else|:
literal|0
decl_stmt|;
comment|/* If this functions has a Structure, Union or              Quad-Precision return value, we have to skip the UNIMP              instruction that encodes the size of the structure.  */
if|if
condition|(
name|cache
operator|->
name|struct_return_p
condition|)
name|pc
operator|+=
literal|4
expr_stmt|;
name|regnum
operator|=
name|cache
operator|->
name|frameless_p
condition|?
name|SPARC_O7_REGNUM
else|:
name|SPARC_I7_REGNUM
expr_stmt|;
name|pc
operator|+=
name|frame_unwind_register_unsigned
argument_list|(
name|next_frame
argument_list|,
name|regnum
argument_list|)
operator|+
literal|8
expr_stmt|;
name|store_unsigned_integer
argument_list|(
name|valuep
argument_list|,
literal|4
argument_list|,
name|pc
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/* Handle StackGhost.  */
block|{
name|ULONGEST
name|wcookie
init|=
name|sparc_fetch_wcookie
argument_list|()
decl_stmt|;
if|if
condition|(
name|wcookie
operator|!=
literal|0
operator|&&
operator|!
name|cache
operator|->
name|frameless_p
operator|&&
name|regnum
operator|==
name|SPARC_I7_REGNUM
condition|)
block|{
operator|*
name|optimizedp
operator|=
literal|0
expr_stmt|;
operator|*
name|lvalp
operator|=
name|not_lval
expr_stmt|;
operator|*
name|addrp
operator|=
literal|0
expr_stmt|;
operator|*
name|realnump
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|valuep
condition|)
block|{
name|CORE_ADDR
name|addr
init|=
name|cache
operator|->
name|base
operator|+
operator|(
name|regnum
operator|-
name|SPARC_L0_REGNUM
operator|)
operator|*
literal|4
decl_stmt|;
name|ULONGEST
name|i7
decl_stmt|;
comment|/* Read the value in from memory.  */
name|i7
operator|=
name|get_frame_memory_unsigned
argument_list|(
name|next_frame
argument_list|,
name|addr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|store_unsigned_integer
argument_list|(
name|valuep
argument_list|,
literal|4
argument_list|,
name|i7
operator|^
name|wcookie
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
block|}
comment|/* The previous frame's `local' and `in' registers have been saved      in the register save area.  */
if|if
condition|(
operator|!
name|cache
operator|->
name|frameless_p
operator|&&
name|regnum
operator|>=
name|SPARC_L0_REGNUM
operator|&&
name|regnum
operator|<=
name|SPARC_I7_REGNUM
condition|)
block|{
operator|*
name|optimizedp
operator|=
literal|0
expr_stmt|;
operator|*
name|lvalp
operator|=
name|lval_memory
expr_stmt|;
operator|*
name|addrp
operator|=
name|cache
operator|->
name|base
operator|+
operator|(
name|regnum
operator|-
name|SPARC_L0_REGNUM
operator|)
operator|*
literal|4
expr_stmt|;
operator|*
name|realnump
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|valuep
condition|)
block|{
name|struct
name|gdbarch
modifier|*
name|gdbarch
init|=
name|get_frame_arch
argument_list|(
name|next_frame
argument_list|)
decl_stmt|;
comment|/* Read the value in from memory.  */
name|read_memory
argument_list|(
operator|*
name|addrp
argument_list|,
name|valuep
argument_list|,
name|register_size
argument_list|(
name|gdbarch
argument_list|,
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/* The previous frame's `out' registers are accessable as the      current frame's `in' registers.  */
if|if
condition|(
operator|!
name|cache
operator|->
name|frameless_p
operator|&&
name|regnum
operator|>=
name|SPARC_O0_REGNUM
operator|&&
name|regnum
operator|<=
name|SPARC_O7_REGNUM
condition|)
name|regnum
operator|+=
operator|(
name|SPARC_I0_REGNUM
operator|-
name|SPARC_O0_REGNUM
operator|)
expr_stmt|;
name|frame_register_unwind
argument_list|(
name|next_frame
argument_list|,
name|regnum
argument_list|,
name|optimizedp
argument_list|,
name|lvalp
argument_list|,
name|addrp
argument_list|,
name|realnump
argument_list|,
name|valuep
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|frame_unwind
name|sparc32_frame_unwind
init|=
block|{
name|NORMAL_FRAME
block|,
name|sparc32_frame_this_id
block|,
name|sparc32_frame_prev_register
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|const
name|struct
name|frame_unwind
modifier|*
name|sparc32_frame_sniffer
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|)
block|{
return|return
operator|&
name|sparc32_frame_unwind
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|CORE_ADDR
name|sparc32_frame_base_address
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|void
modifier|*
modifier|*
name|this_cache
parameter_list|)
block|{
name|struct
name|sparc_frame_cache
modifier|*
name|cache
init|=
name|sparc32_frame_cache
argument_list|(
name|next_frame
argument_list|,
name|this_cache
argument_list|)
decl_stmt|;
return|return
name|cache
operator|->
name|base
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|frame_base
name|sparc32_frame_base
init|=
block|{
operator|&
name|sparc32_frame_unwind
block|,
name|sparc32_frame_base_address
block|,
name|sparc32_frame_base_address
block|,
name|sparc32_frame_base_address
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|struct
name|frame_id
name|sparc_unwind_dummy_id
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|)
block|{
name|CORE_ADDR
name|sp
decl_stmt|;
name|sp
operator|=
name|frame_unwind_register_unsigned
argument_list|(
name|next_frame
argument_list|,
name|SPARC_SP_REGNUM
argument_list|)
expr_stmt|;
return|return
name|frame_id_build
argument_list|(
name|sp
argument_list|,
name|frame_pc_unwind
argument_list|(
name|next_frame
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Extract from an array REGBUF containing the (raw) register state, a    function return value of TYPE, and copy that into VALBUF.  */
end_comment

begin_function
specifier|static
name|void
name|sparc32_extract_return_value
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|void
modifier|*
name|valbuf
parameter_list|)
block|{
name|int
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|char
name|buf
index|[
literal|8
index|]
decl_stmt|;
name|gdb_assert
argument_list|(
operator|!
name|sparc_structure_or_union_p
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
operator|!
operator|(
name|sparc_floating_p
argument_list|(
name|type
argument_list|)
operator|&&
name|len
operator|==
literal|16
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sparc_floating_p
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* Floating return values.  */
name|regcache_cooked_read
argument_list|(
name|regcache
argument_list|,
name|SPARC_F0_REGNUM
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|4
condition|)
name|regcache_cooked_read
argument_list|(
name|regcache
argument_list|,
name|SPARC_F1_REGNUM
argument_list|,
name|buf
operator|+
literal|4
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|valbuf
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Integral and pointer return values.  */
name|gdb_assert
argument_list|(
name|sparc_integral_or_pointer_p
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|regcache_cooked_read
argument_list|(
name|regcache
argument_list|,
name|SPARC_O0_REGNUM
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|4
condition|)
block|{
name|regcache_cooked_read
argument_list|(
name|regcache
argument_list|,
name|SPARC_O1_REGNUM
argument_list|,
name|buf
operator|+
literal|4
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
name|len
operator|==
literal|8
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|valbuf
argument_list|,
name|buf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Just stripping off any unused bytes should preserve the 	     signed-ness just fine.  */
name|memcpy
argument_list|(
name|valbuf
argument_list|,
name|buf
operator|+
literal|4
operator|-
name|len
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Write into the appropriate registers a function return value stored    in VALBUF of type TYPE.  */
end_comment

begin_function
specifier|static
name|void
name|sparc32_store_return_value
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
specifier|const
name|void
modifier|*
name|valbuf
parameter_list|)
block|{
name|int
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|char
name|buf
index|[
literal|8
index|]
decl_stmt|;
name|gdb_assert
argument_list|(
operator|!
name|sparc_structure_or_union_p
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
operator|!
operator|(
name|sparc_floating_p
argument_list|(
name|type
argument_list|)
operator|&&
name|len
operator|==
literal|16
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sparc_floating_p
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* Floating return values.  */
name|memcpy
argument_list|(
name|buf
argument_list|,
name|valbuf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|regcache_cooked_write
argument_list|(
name|regcache
argument_list|,
name|SPARC_F0_REGNUM
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|4
condition|)
name|regcache_cooked_write
argument_list|(
name|regcache
argument_list|,
name|SPARC_F1_REGNUM
argument_list|,
name|buf
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Integral and pointer return values.  */
name|gdb_assert
argument_list|(
name|sparc_integral_or_pointer_p
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|4
condition|)
block|{
name|gdb_assert
argument_list|(
name|len
operator|==
literal|8
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
name|valbuf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|regcache_cooked_write
argument_list|(
name|regcache
argument_list|,
name|SPARC_O1_REGNUM
argument_list|,
name|buf
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* ??? Do we need to do any sign-extension here?  */
name|memcpy
argument_list|(
name|buf
operator|+
literal|4
operator|-
name|len
argument_list|,
name|valbuf
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
name|regcache_cooked_write
argument_list|(
name|regcache
argument_list|,
name|SPARC_O0_REGNUM
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|enum
name|return_value_convention
name|sparc32_return_value
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|void
modifier|*
name|readbuf
parameter_list|,
specifier|const
name|void
modifier|*
name|writebuf
parameter_list|)
block|{
if|if
condition|(
name|sparc_structure_or_union_p
argument_list|(
name|type
argument_list|)
operator|||
operator|(
name|sparc_floating_p
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|==
literal|16
operator|)
condition|)
return|return
name|RETURN_VALUE_STRUCT_CONVENTION
return|;
if|if
condition|(
name|readbuf
condition|)
name|sparc32_extract_return_value
argument_list|(
name|type
argument_list|,
name|regcache
argument_list|,
name|readbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|writebuf
condition|)
name|sparc32_store_return_value
argument_list|(
name|type
argument_list|,
name|regcache
argument_list|,
name|writebuf
argument_list|)
expr_stmt|;
return|return
name|RETURN_VALUE_REGISTER_CONVENTION
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* NOTE: cagney/2004-01-17: For the moment disable this method.  The    architecture and CORE-gdb will need new code (and a replacement for    DEPRECATED_EXTRACT_STRUCT_VALUE_ADDRESS) before this can be made to    work robustly.  Here is a possible function signature: */
end_comment

begin_comment
comment|/* NOTE: cagney/2004-01-17: So far only the 32-bit SPARC ABI has been    identifed as having a way to robustly recover the address of a    struct-convention return-value (after the function has returned).    For all other ABIs so far examined, the calling convention makes no    guarenteed that the register containing the return-value will be    preserved and hence that the return-value's address can be    recovered.  */
end_comment

begin_comment
comment|/* Extract from REGCACHE, which contains the (raw) register state, the    address in which a function should return its structure value, as a    CORE_ADDR.  */
end_comment

begin_endif
unit|static CORE_ADDR sparc32_extract_struct_value_address (struct regcache *regcache) {   ULONGEST sp;    regcache_cooked_read_unsigned (regcache, SPARC_SP_REGNUM,&sp);   return read_memory_unsigned_integer (sp + 64, 4); }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|sparc32_stabs_argument_has_addr
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
return|return
operator|(
name|sparc_structure_or_union_p
argument_list|(
name|type
argument_list|)
operator|||
operator|(
name|sparc_floating_p
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|==
literal|16
operator|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The SPARC Architecture doesn't have hardware single-step support,    and most operating systems don't implement it either, so we provide    software single-step mechanism.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|sparc_analyze_control_transfer
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|CORE_ADDR
modifier|*
name|npc
parameter_list|)
block|{
name|unsigned
name|long
name|insn
init|=
name|sparc_fetch_instruction
argument_list|(
name|pc
argument_list|)
decl_stmt|;
name|int
name|conditional_p
init|=
name|X_COND
argument_list|(
name|insn
argument_list|)
operator|&
literal|0x7
decl_stmt|;
name|int
name|branch_p
init|=
literal|0
decl_stmt|;
name|long
name|offset
init|=
literal|0
decl_stmt|;
comment|/* Must be signed for sign-extend.  */
if|if
condition|(
name|X_OP
argument_list|(
name|insn
argument_list|)
operator|==
literal|0
operator|&&
name|X_OP2
argument_list|(
name|insn
argument_list|)
operator|==
literal|3
operator|&&
operator|(
name|insn
operator|&
literal|0x1000000
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Branch on Integer Register with Prediction (BPr).  */
name|branch_p
operator|=
literal|1
expr_stmt|;
name|conditional_p
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|X_OP
argument_list|(
name|insn
argument_list|)
operator|==
literal|0
operator|&&
name|X_OP2
argument_list|(
name|insn
argument_list|)
operator|==
literal|6
condition|)
block|{
comment|/* Branch on Floating-Point Condition Codes (FBfcc).  */
name|branch_p
operator|=
literal|1
expr_stmt|;
name|offset
operator|=
literal|4
operator|*
name|X_DISP22
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|X_OP
argument_list|(
name|insn
argument_list|)
operator|==
literal|0
operator|&&
name|X_OP2
argument_list|(
name|insn
argument_list|)
operator|==
literal|5
condition|)
block|{
comment|/* Branch on Floating-Point Condition Codes with Prediction          (FBPfcc).  */
name|branch_p
operator|=
literal|1
expr_stmt|;
name|offset
operator|=
literal|4
operator|*
name|X_DISP19
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|X_OP
argument_list|(
name|insn
argument_list|)
operator|==
literal|0
operator|&&
name|X_OP2
argument_list|(
name|insn
argument_list|)
operator|==
literal|2
condition|)
block|{
comment|/* Branch on Integer Condition Codes (Bicc).  */
name|branch_p
operator|=
literal|1
expr_stmt|;
name|offset
operator|=
literal|4
operator|*
name|X_DISP22
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|X_OP
argument_list|(
name|insn
argument_list|)
operator|==
literal|0
operator|&&
name|X_OP2
argument_list|(
name|insn
argument_list|)
operator|==
literal|1
condition|)
block|{
comment|/* Branch on Integer Condition Codes with Prediction (BPcc).  */
name|branch_p
operator|=
literal|1
expr_stmt|;
name|offset
operator|=
literal|4
operator|*
name|X_DISP19
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* FIXME: Handle DONE and RETRY instructions.  */
comment|/* FIXME: Handle the Trap instruction.  */
if|if
condition|(
name|branch_p
condition|)
block|{
if|if
condition|(
name|conditional_p
condition|)
block|{
comment|/* For conditional branches, return nPC + 4 iff the annul 	     bit is 1.  */
return|return
operator|(
name|X_A
argument_list|(
name|insn
argument_list|)
condition|?
operator|*
name|npc
operator|+
literal|4
else|:
literal|0
operator|)
return|;
block|}
else|else
block|{
comment|/* For unconditional branches, return the target if its 	     specified condition is "always" and return nPC + 4 if the 	     condition is "never".  If the annul bit is 1, set *NPC to 	     zero.  */
if|if
condition|(
name|X_COND
argument_list|(
name|insn
argument_list|)
operator|==
literal|0x0
condition|)
name|pc
operator|=
operator|*
name|npc
operator|,
name|offset
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|X_A
argument_list|(
name|insn
argument_list|)
condition|)
operator|*
name|npc
operator|=
literal|0
expr_stmt|;
name|gdb_assert
argument_list|(
name|offset
operator|!=
literal|0
argument_list|)
expr_stmt|;
return|return
name|pc
operator|+
name|offset
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|sparc_software_single_step
parameter_list|(
name|enum
name|target_signal
name|sig
parameter_list|,
name|int
name|insert_breakpoints_p
parameter_list|)
block|{
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
decl_stmt|;
specifier|static
name|CORE_ADDR
name|npc
decl_stmt|,
name|nnpc
decl_stmt|;
specifier|static
name|char
name|npc_save
index|[
literal|4
index|]
decl_stmt|,
name|nnpc_save
index|[
literal|4
index|]
decl_stmt|;
if|if
condition|(
name|insert_breakpoints_p
condition|)
block|{
name|CORE_ADDR
name|pc
decl_stmt|;
name|pc
operator|=
name|sparc_address_from_register
argument_list|(
name|tdep
operator|->
name|pc_regnum
argument_list|)
expr_stmt|;
name|npc
operator|=
name|sparc_address_from_register
argument_list|(
name|tdep
operator|->
name|npc_regnum
argument_list|)
expr_stmt|;
comment|/* Analyze the instruction at PC.  */
name|nnpc
operator|=
name|sparc_analyze_control_transfer
argument_list|(
name|pc
argument_list|,
operator|&
name|npc
argument_list|)
expr_stmt|;
if|if
condition|(
name|npc
operator|!=
literal|0
condition|)
name|target_insert_breakpoint
argument_list|(
name|npc
argument_list|,
name|npc_save
argument_list|)
expr_stmt|;
if|if
condition|(
name|nnpc
operator|!=
literal|0
condition|)
name|target_insert_breakpoint
argument_list|(
name|nnpc
argument_list|,
name|nnpc_save
argument_list|)
expr_stmt|;
comment|/* Assert that we have set at least one breakpoint, and that          they're not set at the same spot.  */
name|gdb_assert
argument_list|(
name|npc
operator|!=
literal|0
operator|||
name|nnpc
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
name|nnpc
operator|!=
name|npc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|npc
operator|!=
literal|0
condition|)
name|target_remove_breakpoint
argument_list|(
name|npc
argument_list|,
name|npc_save
argument_list|)
expr_stmt|;
if|if
condition|(
name|nnpc
operator|!=
literal|0
condition|)
name|target_remove_breakpoint
argument_list|(
name|nnpc
argument_list|,
name|nnpc_save
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sparc_write_pc
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|ptid_t
name|ptid
parameter_list|)
block|{
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
decl_stmt|;
name|write_register_pid
argument_list|(
name|tdep
operator|->
name|pc_regnum
argument_list|,
name|pc
argument_list|,
name|ptid
argument_list|)
expr_stmt|;
name|write_register_pid
argument_list|(
name|tdep
operator|->
name|npc_regnum
argument_list|,
name|pc
operator|+
literal|4
argument_list|,
name|ptid
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Unglobalize NAME.  */
end_comment

begin_function
name|char
modifier|*
name|sparc_stabs_unglobalize_name
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
comment|/* The Sun compilers (Sun ONE Studio, Forte Developer, Sun WorkShop,      SunPRO) convert file static variables into global values, a      process known as globalization.  In order to do this, the      compiler will create a unique prefix and prepend it to each file      static variable.  For static variables within a function, this      globalization prefix is followed by the function name (nested      static variables within a function are supposed to generate a      warning message, and are left alone).  The procedure is      documented in the Stabs Interface Manual, which is distrubuted      with the compilers, although version 4.0 of the manual seems to      be incorrect in some places, at least for SPARC.  The      globalization prefix is encoded into an N_OPT stab, with the form      "G=<prefix>".  The globalization prefix always seems to start      with a dollar sign '$'; a dot '.' is used as a seperator.  So we      simply strip everything up until the last dot.  */
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'$'
condition|)
block|{
name|char
modifier|*
name|p
init|=
name|strrchr
argument_list|(
name|name
argument_list|,
literal|'.'
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
condition|)
return|return
name|p
operator|+
literal|1
return|;
block|}
return|return
name|name
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the appropriate register set for the core section identified    by SECT_NAME and SECT_SIZE.  */
end_comment

begin_function
specifier|const
name|struct
name|regset
modifier|*
name|sparc_regset_from_core_section
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
specifier|const
name|char
modifier|*
name|sect_name
parameter_list|,
name|size_t
name|sect_size
parameter_list|)
block|{
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|gdbarch
argument_list|)
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|sect_name
argument_list|,
literal|".reg"
argument_list|)
operator|==
literal|0
operator|&&
name|sect_size
operator|>=
name|tdep
operator|->
name|sizeof_gregset
condition|)
return|return
name|tdep
operator|->
name|gregset
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|sect_name
argument_list|,
literal|".reg2"
argument_list|)
operator|==
literal|0
operator|&&
name|sect_size
operator|>=
name|tdep
operator|->
name|sizeof_fpregset
condition|)
return|return
name|tdep
operator|->
name|fpregset
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|struct
name|gdbarch
modifier|*
name|sparc32_gdbarch_init
parameter_list|(
name|struct
name|gdbarch_info
name|info
parameter_list|,
name|struct
name|gdbarch_list
modifier|*
name|arches
parameter_list|)
block|{
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
decl_stmt|;
name|struct
name|gdbarch
modifier|*
name|gdbarch
decl_stmt|;
comment|/* If there is already a candidate, use it.  */
name|arches
operator|=
name|gdbarch_list_lookup_by_info
argument_list|(
name|arches
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|arches
operator|!=
name|NULL
condition|)
return|return
name|arches
operator|->
name|gdbarch
return|;
comment|/* Allocate space for the new architecture.  */
name|tdep
operator|=
name|XMALLOC
argument_list|(
expr|struct
name|gdbarch_tdep
argument_list|)
expr_stmt|;
name|gdbarch
operator|=
name|gdbarch_alloc
argument_list|(
operator|&
name|info
argument_list|,
name|tdep
argument_list|)
expr_stmt|;
name|tdep
operator|->
name|pc_regnum
operator|=
name|SPARC32_PC_REGNUM
expr_stmt|;
name|tdep
operator|->
name|npc_regnum
operator|=
name|SPARC32_NPC_REGNUM
expr_stmt|;
name|tdep
operator|->
name|gregset
operator|=
name|NULL
expr_stmt|;
name|tdep
operator|->
name|sizeof_gregset
operator|=
literal|0
expr_stmt|;
name|tdep
operator|->
name|fpregset
operator|=
name|NULL
expr_stmt|;
name|tdep
operator|->
name|sizeof_fpregset
operator|=
literal|0
expr_stmt|;
name|tdep
operator|->
name|plt_entry_size
operator|=
literal|0
expr_stmt|;
name|set_gdbarch_long_double_bit
argument_list|(
name|gdbarch
argument_list|,
literal|128
argument_list|)
expr_stmt|;
name|set_gdbarch_long_double_format
argument_list|(
name|gdbarch
argument_list|,
operator|&
name|floatformat_sparc_quad
argument_list|)
expr_stmt|;
name|set_gdbarch_num_regs
argument_list|(
name|gdbarch
argument_list|,
name|SPARC32_NUM_REGS
argument_list|)
expr_stmt|;
name|set_gdbarch_register_name
argument_list|(
name|gdbarch
argument_list|,
name|sparc32_register_name
argument_list|)
expr_stmt|;
name|set_gdbarch_register_type
argument_list|(
name|gdbarch
argument_list|,
name|sparc32_register_type
argument_list|)
expr_stmt|;
name|set_gdbarch_num_pseudo_regs
argument_list|(
name|gdbarch
argument_list|,
name|SPARC32_NUM_PSEUDO_REGS
argument_list|)
expr_stmt|;
name|set_gdbarch_pseudo_register_read
argument_list|(
name|gdbarch
argument_list|,
name|sparc32_pseudo_register_read
argument_list|)
expr_stmt|;
name|set_gdbarch_pseudo_register_write
argument_list|(
name|gdbarch
argument_list|,
name|sparc32_pseudo_register_write
argument_list|)
expr_stmt|;
comment|/* Register numbers of various important registers.  */
name|set_gdbarch_sp_regnum
argument_list|(
name|gdbarch
argument_list|,
name|SPARC_SP_REGNUM
argument_list|)
expr_stmt|;
comment|/* %sp */
name|set_gdbarch_pc_regnum
argument_list|(
name|gdbarch
argument_list|,
name|SPARC32_PC_REGNUM
argument_list|)
expr_stmt|;
comment|/* %pc */
name|set_gdbarch_fp0_regnum
argument_list|(
name|gdbarch
argument_list|,
name|SPARC_F0_REGNUM
argument_list|)
expr_stmt|;
comment|/* %f0 */
comment|/* Call dummy code.  */
name|set_gdbarch_call_dummy_location
argument_list|(
name|gdbarch
argument_list|,
name|ON_STACK
argument_list|)
expr_stmt|;
name|set_gdbarch_push_dummy_code
argument_list|(
name|gdbarch
argument_list|,
name|sparc32_push_dummy_code
argument_list|)
expr_stmt|;
name|set_gdbarch_push_dummy_call
argument_list|(
name|gdbarch
argument_list|,
name|sparc32_push_dummy_call
argument_list|)
expr_stmt|;
name|set_gdbarch_return_value
argument_list|(
name|gdbarch
argument_list|,
name|sparc32_return_value
argument_list|)
expr_stmt|;
name|set_gdbarch_stabs_argument_has_addr
argument_list|(
name|gdbarch
argument_list|,
name|sparc32_stabs_argument_has_addr
argument_list|)
expr_stmt|;
name|set_gdbarch_skip_prologue
argument_list|(
name|gdbarch
argument_list|,
name|sparc32_skip_prologue
argument_list|)
expr_stmt|;
comment|/* Stack grows downward.  */
name|set_gdbarch_inner_than
argument_list|(
name|gdbarch
argument_list|,
name|core_addr_lessthan
argument_list|)
expr_stmt|;
name|set_gdbarch_breakpoint_from_pc
argument_list|(
name|gdbarch
argument_list|,
name|sparc_breakpoint_from_pc
argument_list|)
expr_stmt|;
name|set_gdbarch_frame_args_skip
argument_list|(
name|gdbarch
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|set_gdbarch_print_insn
argument_list|(
name|gdbarch
argument_list|,
name|print_insn_sparc
argument_list|)
expr_stmt|;
name|set_gdbarch_software_single_step
argument_list|(
name|gdbarch
argument_list|,
name|sparc_software_single_step
argument_list|)
expr_stmt|;
name|set_gdbarch_write_pc
argument_list|(
name|gdbarch
argument_list|,
name|sparc_write_pc
argument_list|)
expr_stmt|;
name|set_gdbarch_unwind_dummy_id
argument_list|(
name|gdbarch
argument_list|,
name|sparc_unwind_dummy_id
argument_list|)
expr_stmt|;
name|set_gdbarch_unwind_pc
argument_list|(
name|gdbarch
argument_list|,
name|sparc_unwind_pc
argument_list|)
expr_stmt|;
name|frame_base_set_default
argument_list|(
name|gdbarch
argument_list|,
operator|&
name|sparc32_frame_base
argument_list|)
expr_stmt|;
comment|/* Hook in ABI-specific overrides, if they have been registered.  */
name|gdbarch_init_osabi
argument_list|(
name|info
argument_list|,
name|gdbarch
argument_list|)
expr_stmt|;
name|frame_unwind_append_sniffer
argument_list|(
name|gdbarch
argument_list|,
name|sparc32_frame_sniffer
argument_list|)
expr_stmt|;
comment|/* If we have register sets, enable the generic core file support.  */
if|if
condition|(
name|tdep
operator|->
name|gregset
condition|)
name|set_gdbarch_regset_from_core_section
argument_list|(
name|gdbarch
argument_list|,
name|sparc_regset_from_core_section
argument_list|)
expr_stmt|;
return|return
name|gdbarch
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Helper functions for dealing with register windows.  */
end_comment

begin_function
name|void
name|sparc_supply_rwindow
parameter_list|(
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|CORE_ADDR
name|sp
parameter_list|,
name|int
name|regnum
parameter_list|)
block|{
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|char
name|buf
index|[
literal|8
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|sp
operator|&
literal|1
condition|)
block|{
comment|/* Registers are 64-bit.  */
name|sp
operator|+=
name|BIAS
expr_stmt|;
for|for
control|(
name|i
operator|=
name|SPARC_L0_REGNUM
init|;
name|i
operator|<=
name|SPARC_I7_REGNUM
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|regnum
operator|==
name|i
operator|||
name|regnum
operator|==
operator|-
literal|1
condition|)
block|{
name|target_read_memory
argument_list|(
name|sp
operator|+
operator|(
operator|(
name|i
operator|-
name|SPARC_L0_REGNUM
operator|)
operator|*
literal|8
operator|)
argument_list|,
name|buf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|regcache_raw_supply
argument_list|(
name|regcache
argument_list|,
name|i
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* Registers are 32-bit.  Toss any sign-extension of the stack 	 pointer.  */
name|sp
operator|&=
literal|0xffffffffUL
expr_stmt|;
comment|/* Clear out the top half of the temporary buffer, and put the 	 register value in the bottom half if we're in 64-bit mode.  */
if|if
condition|(
name|gdbarch_ptr_bit
argument_list|(
name|current_gdbarch
argument_list|)
operator|==
literal|64
condition|)
block|{
name|memset
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|offset
operator|=
literal|4
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|SPARC_L0_REGNUM
init|;
name|i
operator|<=
name|SPARC_I7_REGNUM
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|regnum
operator|==
name|i
operator|||
name|regnum
operator|==
operator|-
literal|1
condition|)
block|{
name|target_read_memory
argument_list|(
name|sp
operator|+
operator|(
operator|(
name|i
operator|-
name|SPARC_L0_REGNUM
operator|)
operator|*
literal|4
operator|)
argument_list|,
name|buf
operator|+
name|offset
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Handle StackGhost.  */
if|if
condition|(
name|i
operator|==
name|SPARC_I7_REGNUM
condition|)
block|{
name|ULONGEST
name|wcookie
init|=
name|sparc_fetch_wcookie
argument_list|()
decl_stmt|;
name|ULONGEST
name|i7
init|=
name|extract_unsigned_integer
argument_list|(
name|buf
operator|+
name|offset
argument_list|,
literal|4
argument_list|)
decl_stmt|;
name|store_unsigned_integer
argument_list|(
name|buf
operator|+
name|offset
argument_list|,
literal|4
argument_list|,
name|i7
operator|^
name|wcookie
argument_list|)
expr_stmt|;
block|}
name|regcache_raw_supply
argument_list|(
name|regcache
argument_list|,
name|i
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
name|void
name|sparc_collect_rwindow
parameter_list|(
specifier|const
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|CORE_ADDR
name|sp
parameter_list|,
name|int
name|regnum
parameter_list|)
block|{
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|char
name|buf
index|[
literal|8
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|sp
operator|&
literal|1
condition|)
block|{
comment|/* Registers are 64-bit.  */
name|sp
operator|+=
name|BIAS
expr_stmt|;
for|for
control|(
name|i
operator|=
name|SPARC_L0_REGNUM
init|;
name|i
operator|<=
name|SPARC_I7_REGNUM
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|regnum
operator|==
operator|-
literal|1
operator|||
name|regnum
operator|==
name|SPARC_SP_REGNUM
operator|||
name|regnum
operator|==
name|i
condition|)
block|{
name|regcache_raw_collect
argument_list|(
name|regcache
argument_list|,
name|i
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|target_write_memory
argument_list|(
name|sp
operator|+
operator|(
operator|(
name|i
operator|-
name|SPARC_L0_REGNUM
operator|)
operator|*
literal|8
operator|)
argument_list|,
name|buf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* Registers are 32-bit.  Toss any sign-extension of the stack 	 pointer.  */
name|sp
operator|&=
literal|0xffffffffUL
expr_stmt|;
comment|/* Only use the bottom half if we're in 64-bit mode.  */
if|if
condition|(
name|gdbarch_ptr_bit
argument_list|(
name|current_gdbarch
argument_list|)
operator|==
literal|64
condition|)
name|offset
operator|=
literal|4
expr_stmt|;
for|for
control|(
name|i
operator|=
name|SPARC_L0_REGNUM
init|;
name|i
operator|<=
name|SPARC_I7_REGNUM
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|regnum
operator|==
operator|-
literal|1
operator|||
name|regnum
operator|==
name|SPARC_SP_REGNUM
operator|||
name|regnum
operator|==
name|i
condition|)
block|{
name|regcache_raw_collect
argument_list|(
name|regcache
argument_list|,
name|i
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* Handle StackGhost.  */
if|if
condition|(
name|i
operator|==
name|SPARC_I7_REGNUM
condition|)
block|{
name|ULONGEST
name|wcookie
init|=
name|sparc_fetch_wcookie
argument_list|()
decl_stmt|;
name|ULONGEST
name|i7
init|=
name|extract_unsigned_integer
argument_list|(
name|buf
operator|+
name|offset
argument_list|,
literal|4
argument_list|)
decl_stmt|;
name|store_unsigned_integer
argument_list|(
name|buf
operator|+
name|offset
argument_list|,
literal|4
argument_list|,
name|i7
operator|^
name|wcookie
argument_list|)
expr_stmt|;
block|}
name|target_write_memory
argument_list|(
name|sp
operator|+
operator|(
operator|(
name|i
operator|-
name|SPARC_L0_REGNUM
operator|)
operator|*
literal|4
operator|)
argument_list|,
name|buf
operator|+
name|offset
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Helper functions for dealing with register sets.  */
end_comment

begin_function
name|void
name|sparc32_supply_gregset
parameter_list|(
specifier|const
name|struct
name|sparc_gregset
modifier|*
name|gregset
parameter_list|,
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|int
name|regnum
parameter_list|,
specifier|const
name|void
modifier|*
name|gregs
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|regs
init|=
name|gregs
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|regnum
operator|==
name|SPARC32_PSR_REGNUM
operator|||
name|regnum
operator|==
operator|-
literal|1
condition|)
name|regcache_raw_supply
argument_list|(
name|regcache
argument_list|,
name|SPARC32_PSR_REGNUM
argument_list|,
name|regs
operator|+
name|gregset
operator|->
name|r_psr_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|regnum
operator|==
name|SPARC32_PC_REGNUM
operator|||
name|regnum
operator|==
operator|-
literal|1
condition|)
name|regcache_raw_supply
argument_list|(
name|regcache
argument_list|,
name|SPARC32_PC_REGNUM
argument_list|,
name|regs
operator|+
name|gregset
operator|->
name|r_pc_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|regnum
operator|==
name|SPARC32_NPC_REGNUM
operator|||
name|regnum
operator|==
operator|-
literal|1
condition|)
name|regcache_raw_supply
argument_list|(
name|regcache
argument_list|,
name|SPARC32_NPC_REGNUM
argument_list|,
name|regs
operator|+
name|gregset
operator|->
name|r_npc_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|regnum
operator|==
name|SPARC32_Y_REGNUM
operator|||
name|regnum
operator|==
operator|-
literal|1
condition|)
name|regcache_raw_supply
argument_list|(
name|regcache
argument_list|,
name|SPARC32_Y_REGNUM
argument_list|,
name|regs
operator|+
name|gregset
operator|->
name|r_y_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|regnum
operator|==
name|SPARC_G0_REGNUM
operator|||
name|regnum
operator|==
operator|-
literal|1
condition|)
name|regcache_raw_supply
argument_list|(
name|regcache
argument_list|,
name|SPARC_G0_REGNUM
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|regnum
operator|>=
name|SPARC_G1_REGNUM
operator|&&
name|regnum
operator|<=
name|SPARC_O7_REGNUM
operator|)
operator|||
name|regnum
operator|==
operator|-
literal|1
condition|)
block|{
name|int
name|offset
init|=
name|gregset
operator|->
name|r_g1_offset
decl_stmt|;
for|for
control|(
name|i
operator|=
name|SPARC_G1_REGNUM
init|;
name|i
operator|<=
name|SPARC_O7_REGNUM
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|regnum
operator|==
name|i
operator|||
name|regnum
operator|==
operator|-
literal|1
condition|)
name|regcache_raw_supply
argument_list|(
name|regcache
argument_list|,
name|i
argument_list|,
name|regs
operator|+
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|4
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|regnum
operator|>=
name|SPARC_L0_REGNUM
operator|&&
name|regnum
operator|<=
name|SPARC_I7_REGNUM
operator|)
operator|||
name|regnum
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* Not all of the register set variants include Locals and          Inputs.  For those that don't, we read them off the stack.  */
if|if
condition|(
name|gregset
operator|->
name|r_l0_offset
operator|==
operator|-
literal|1
condition|)
block|{
name|ULONGEST
name|sp
decl_stmt|;
name|regcache_cooked_read_unsigned
argument_list|(
name|regcache
argument_list|,
name|SPARC_SP_REGNUM
argument_list|,
operator|&
name|sp
argument_list|)
expr_stmt|;
name|sparc_supply_rwindow
argument_list|(
name|regcache
argument_list|,
name|sp
argument_list|,
name|regnum
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|offset
init|=
name|gregset
operator|->
name|r_l0_offset
decl_stmt|;
for|for
control|(
name|i
operator|=
name|SPARC_L0_REGNUM
init|;
name|i
operator|<=
name|SPARC_I7_REGNUM
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|regnum
operator|==
name|i
operator|||
name|regnum
operator|==
operator|-
literal|1
condition|)
name|regcache_raw_supply
argument_list|(
name|regcache
argument_list|,
name|i
argument_list|,
name|regs
operator|+
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|4
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
name|void
name|sparc32_collect_gregset
parameter_list|(
specifier|const
name|struct
name|sparc_gregset
modifier|*
name|gregset
parameter_list|,
specifier|const
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|int
name|regnum
parameter_list|,
name|void
modifier|*
name|gregs
parameter_list|)
block|{
name|char
modifier|*
name|regs
init|=
name|gregs
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|regnum
operator|==
name|SPARC32_PSR_REGNUM
operator|||
name|regnum
operator|==
operator|-
literal|1
condition|)
name|regcache_raw_collect
argument_list|(
name|regcache
argument_list|,
name|SPARC32_PSR_REGNUM
argument_list|,
name|regs
operator|+
name|gregset
operator|->
name|r_psr_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|regnum
operator|==
name|SPARC32_PC_REGNUM
operator|||
name|regnum
operator|==
operator|-
literal|1
condition|)
name|regcache_raw_collect
argument_list|(
name|regcache
argument_list|,
name|SPARC32_PC_REGNUM
argument_list|,
name|regs
operator|+
name|gregset
operator|->
name|r_pc_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|regnum
operator|==
name|SPARC32_NPC_REGNUM
operator|||
name|regnum
operator|==
operator|-
literal|1
condition|)
name|regcache_raw_collect
argument_list|(
name|regcache
argument_list|,
name|SPARC32_NPC_REGNUM
argument_list|,
name|regs
operator|+
name|gregset
operator|->
name|r_npc_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|regnum
operator|==
name|SPARC32_Y_REGNUM
operator|||
name|regnum
operator|==
operator|-
literal|1
condition|)
name|regcache_raw_collect
argument_list|(
name|regcache
argument_list|,
name|SPARC32_Y_REGNUM
argument_list|,
name|regs
operator|+
name|gregset
operator|->
name|r_y_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|regnum
operator|>=
name|SPARC_G1_REGNUM
operator|&&
name|regnum
operator|<=
name|SPARC_O7_REGNUM
operator|)
operator|||
name|regnum
operator|==
operator|-
literal|1
condition|)
block|{
name|int
name|offset
init|=
name|gregset
operator|->
name|r_g1_offset
decl_stmt|;
comment|/* %g0 is always zero.  */
for|for
control|(
name|i
operator|=
name|SPARC_G1_REGNUM
init|;
name|i
operator|<=
name|SPARC_O7_REGNUM
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|regnum
operator|==
name|i
operator|||
name|regnum
operator|==
operator|-
literal|1
condition|)
name|regcache_raw_collect
argument_list|(
name|regcache
argument_list|,
name|i
argument_list|,
name|regs
operator|+
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|4
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|regnum
operator|>=
name|SPARC_L0_REGNUM
operator|&&
name|regnum
operator|<=
name|SPARC_I7_REGNUM
operator|)
operator|||
name|regnum
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* Not all of the register set variants include Locals and          Inputs.  For those that don't, we read them off the stack.  */
if|if
condition|(
name|gregset
operator|->
name|r_l0_offset
operator|!=
operator|-
literal|1
condition|)
block|{
name|int
name|offset
init|=
name|gregset
operator|->
name|r_l0_offset
decl_stmt|;
for|for
control|(
name|i
operator|=
name|SPARC_L0_REGNUM
init|;
name|i
operator|<=
name|SPARC_I7_REGNUM
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|regnum
operator|==
name|i
operator|||
name|regnum
operator|==
operator|-
literal|1
condition|)
name|regcache_raw_collect
argument_list|(
name|regcache
argument_list|,
name|i
argument_list|,
name|regs
operator|+
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|4
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
name|void
name|sparc32_supply_fpregset
parameter_list|(
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|int
name|regnum
parameter_list|,
specifier|const
name|void
modifier|*
name|fpregs
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|regs
init|=
name|fpregs
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|regnum
operator|==
operator|(
name|SPARC_F0_REGNUM
operator|+
name|i
operator|)
operator|||
name|regnum
operator|==
operator|-
literal|1
condition|)
name|regcache_raw_supply
argument_list|(
name|regcache
argument_list|,
name|SPARC_F0_REGNUM
operator|+
name|i
argument_list|,
name|regs
operator|+
operator|(
name|i
operator|*
literal|4
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|regnum
operator|==
name|SPARC32_FSR_REGNUM
operator|||
name|regnum
operator|==
operator|-
literal|1
condition|)
name|regcache_raw_supply
argument_list|(
name|regcache
argument_list|,
name|SPARC32_FSR_REGNUM
argument_list|,
name|regs
operator|+
operator|(
literal|32
operator|*
literal|4
operator|)
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sparc32_collect_fpregset
parameter_list|(
specifier|const
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|int
name|regnum
parameter_list|,
name|void
modifier|*
name|fpregs
parameter_list|)
block|{
name|char
modifier|*
name|regs
init|=
name|fpregs
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|regnum
operator|==
operator|(
name|SPARC_F0_REGNUM
operator|+
name|i
operator|)
operator|||
name|regnum
operator|==
operator|-
literal|1
condition|)
name|regcache_raw_collect
argument_list|(
name|regcache
argument_list|,
name|SPARC_F0_REGNUM
operator|+
name|i
argument_list|,
name|regs
operator|+
operator|(
name|i
operator|*
literal|4
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|regnum
operator|==
name|SPARC32_FSR_REGNUM
operator|||
name|regnum
operator|==
operator|-
literal|1
condition|)
name|regcache_raw_collect
argument_list|(
name|regcache
argument_list|,
name|SPARC32_FSR_REGNUM
argument_list|,
name|regs
operator|+
operator|(
literal|32
operator|*
literal|4
operator|)
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* SunOS 4.  */
end_comment

begin_comment
comment|/* From<machine/reg.h>.  */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|sparc_gregset
name|sparc32_sunos4_gregset
init|=
block|{
literal|0
operator|*
literal|4
block|,
comment|/* %psr */
literal|1
operator|*
literal|4
block|,
comment|/* %pc */
literal|2
operator|*
literal|4
block|,
comment|/* %npc */
literal|3
operator|*
literal|4
block|,
comment|/* %y */
operator|-
literal|1
block|,
comment|/* %wim */
operator|-
literal|1
block|,
comment|/* %tbr */
literal|4
operator|*
literal|4
block|,
comment|/* %g1 */
operator|-
literal|1
comment|/* %l0 */
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Provide a prototype to silence -Wmissing-prototypes.  */
end_comment

begin_function_decl
name|void
name|_initialize_sparc_tdep
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|_initialize_sparc_tdep
parameter_list|(
name|void
parameter_list|)
block|{
name|register_gdbarch_init
argument_list|(
name|bfd_arch_sparc
argument_list|,
name|sparc32_gdbarch_init
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

