begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Target-dependent code for the SPARC for GDB, the GNU debugger.    Copyright 1986, 1987, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996,    1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* ??? Support for calling functions from gdb in sparc64 is unfinished.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"arch-utils.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USE_PROC_FS
end_ifdef

begin_include
include|#
directive|include
file|<sys/procfs.h>
end_include

begin_comment
comment|/* Prototypes for supply_gregset etc. */
end_comment

begin_include
include|#
directive|include
file|"gregset.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_comment
comment|/* for 'entry_point_address' */
end_comment

begin_comment
comment|/*  * Some local macros that have multi-arch and non-multi-arch versions:  */
end_comment

begin_if
if|#
directive|if
operator|(
name|GDB_MULTI_ARCH
operator|>
literal|0
operator|)
end_if

begin_comment
comment|/* Does the target have Floating Point registers?  */
end_comment

begin_define
define|#
directive|define
name|SPARC_HAS_FPU
value|(gdbarch_tdep (current_gdbarch)->has_fpu)
end_define

begin_comment
comment|/* Number of bytes devoted to Floating Point registers: */
end_comment

begin_define
define|#
directive|define
name|FP_REGISTER_BYTES
value|(gdbarch_tdep (current_gdbarch)->fp_register_bytes)
end_define

begin_comment
comment|/* Highest numbered Floating Point register.  */
end_comment

begin_define
define|#
directive|define
name|FP_MAX_REGNUM
value|(gdbarch_tdep (current_gdbarch)->fp_max_regnum)
end_define

begin_comment
comment|/* Size of a general (integer) register: */
end_comment

begin_define
define|#
directive|define
name|SPARC_INTREG_SIZE
value|(gdbarch_tdep (current_gdbarch)->intreg_size)
end_define

begin_comment
comment|/* Offset within the call dummy stack of the saved registers.  */
end_comment

begin_define
define|#
directive|define
name|DUMMY_REG_SAVE_OFFSET
value|(gdbarch_tdep (current_gdbarch)->reg_save_offset)
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* non-multi-arch */
end_comment

begin_comment
comment|/* Does the target have Floating Point registers?  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|TARGET_SPARCLET
argument_list|)
operator|||
name|defined
argument_list|(
name|TARGET_SPARCLITE
argument_list|)
end_if

begin_define
define|#
directive|define
name|SPARC_HAS_FPU
value|0
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SPARC_HAS_FPU
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Number of bytes devoted to Floating Point registers: */
end_comment

begin_if
if|#
directive|if
operator|(
name|GDB_TARGET_IS_SPARC64
operator|)
end_if

begin_define
define|#
directive|define
name|FP_REGISTER_BYTES
value|(64 * 4)
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
operator|(
name|SPARC_HAS_FPU
operator|)
end_if

begin_define
define|#
directive|define
name|FP_REGISTER_BYTES
value|(32 * 4)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|FP_REGISTER_BYTES
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Highest numbered Floating Point register.  */
end_comment

begin_if
if|#
directive|if
operator|(
name|GDB_TARGET_IS_SPARC64
operator|)
end_if

begin_define
define|#
directive|define
name|FP_MAX_REGNUM
value|(FP0_REGNUM + 48)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|FP_MAX_REGNUM
value|(FP0_REGNUM + 32)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Size of a general (integer) register: */
end_comment

begin_define
define|#
directive|define
name|SPARC_INTREG_SIZE
value|(REGISTER_RAW_SIZE (G0_REGNUM))
end_define

begin_comment
comment|/* Offset within the call dummy stack of the saved registers.  */
end_comment

begin_if
if|#
directive|if
operator|(
name|GDB_TARGET_IS_SPARC64
operator|)
end_if

begin_define
define|#
directive|define
name|DUMMY_REG_SAVE_OFFSET
value|(128 + 16)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DUMMY_REG_SAVE_OFFSET
value|0x60
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* GDB_MULTI_ARCH */
end_comment

begin_struct
struct|struct
name|gdbarch_tdep
block|{
name|int
name|has_fpu
decl_stmt|;
name|int
name|fp_register_bytes
decl_stmt|;
name|int
name|y_regnum
decl_stmt|;
name|int
name|fp_max_regnum
decl_stmt|;
name|int
name|intreg_size
decl_stmt|;
name|int
name|reg_save_offset
decl_stmt|;
name|int
name|call_dummy_call_offset
decl_stmt|;
name|int
name|print_insn_mach
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Now make GDB_TARGET_IS_SPARC64 a runtime test.  */
end_comment

begin_comment
comment|/* FIXME MVS: or try testing bfd_arch_info.arch and bfd_arch_info.mach ...   * define GDB_TARGET_IS_SPARC64 \  *      (TARGET_ARCHITECTURE->arch == bfd_arch_sparc&&    \  *      (TARGET_ARCHITECTURE->mach == bfd_mach_sparc_v9 || \  *       TARGET_ARCHITECTURE->mach == bfd_mach_sparc_v9a))  */
end_comment

begin_comment
comment|/* From infrun.c */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|stop_after_trap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We don't store all registers immediately when requested, since they    get sent over in large chunks anyway.  Instead, we accumulate most    of the changes and send them over once.  "deferred_stores" keeps    track of which sets of registers we have locally-changed copies of,    so we only need send the groups that have changed.  */
end_comment

begin_decl_stmt
name|int
name|deferred_stores
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Accumulated stores we want to do eventually. */
end_comment

begin_comment
comment|/* Some machines, such as Fujitsu SPARClite 86x, have a bi-endian mode    where instructions are big-endian and data are little-endian.    This flag is set when we detect that the target is of this type. */
end_comment

begin_decl_stmt
name|int
name|bi_endian
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Fetch a single instruction.  Even on bi-endian machines    such as sparc86x, instructions are always big-endian.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|fetch_instruction
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
name|unsigned
name|long
name|retval
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unsigned
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|read_memory
argument_list|(
name|pc
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Start at the most significant end of the integer, and work towards      the least significant.  */
name|retval
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
condition|;
operator|++
name|i
control|)
name|retval
operator|=
operator|(
name|retval
operator|<<
literal|8
operator|)
operator||
name|buf
index|[
name|i
index|]
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Branches with prediction are treated like their non-predicting cousins.  */
end_comment

begin_comment
comment|/* FIXME: What about floating point branches?  */
end_comment

begin_comment
comment|/* Macros to extract fields from sparc instructions.  */
end_comment

begin_define
define|#
directive|define
name|X_OP
parameter_list|(
name|i
parameter_list|)
value|(((i)>> 30)& 0x3)
end_define

begin_define
define|#
directive|define
name|X_RD
parameter_list|(
name|i
parameter_list|)
value|(((i)>> 25)& 0x1f)
end_define

begin_define
define|#
directive|define
name|X_A
parameter_list|(
name|i
parameter_list|)
value|(((i)>> 29)& 1)
end_define

begin_define
define|#
directive|define
name|X_COND
parameter_list|(
name|i
parameter_list|)
value|(((i)>> 25)& 0xf)
end_define

begin_define
define|#
directive|define
name|X_OP2
parameter_list|(
name|i
parameter_list|)
value|(((i)>> 22)& 0x7)
end_define

begin_define
define|#
directive|define
name|X_IMM22
parameter_list|(
name|i
parameter_list|)
value|((i)& 0x3fffff)
end_define

begin_define
define|#
directive|define
name|X_OP3
parameter_list|(
name|i
parameter_list|)
value|(((i)>> 19)& 0x3f)
end_define

begin_define
define|#
directive|define
name|X_RS1
parameter_list|(
name|i
parameter_list|)
value|(((i)>> 14)& 0x1f)
end_define

begin_define
define|#
directive|define
name|X_I
parameter_list|(
name|i
parameter_list|)
value|(((i)>> 13)& 1)
end_define

begin_define
define|#
directive|define
name|X_IMM13
parameter_list|(
name|i
parameter_list|)
value|((i)& 0x1fff)
end_define

begin_comment
comment|/* Sign extension macros.  */
end_comment

begin_define
define|#
directive|define
name|X_SIMM13
parameter_list|(
name|i
parameter_list|)
value|((X_IMM13 (i) ^ 0x1000) - 0x1000)
end_define

begin_define
define|#
directive|define
name|X_DISP22
parameter_list|(
name|i
parameter_list|)
value|((X_IMM22 (i) ^ 0x200000) - 0x200000)
end_define

begin_define
define|#
directive|define
name|X_CC
parameter_list|(
name|i
parameter_list|)
value|(((i)>> 20)& 3)
end_define

begin_define
define|#
directive|define
name|X_P
parameter_list|(
name|i
parameter_list|)
value|(((i)>> 19)& 1)
end_define

begin_define
define|#
directive|define
name|X_DISP19
parameter_list|(
name|i
parameter_list|)
value|((((i)& 0x7ffff) ^ 0x40000) - 0x40000)
end_define

begin_define
define|#
directive|define
name|X_RCOND
parameter_list|(
name|i
parameter_list|)
value|(((i)>> 25)& 7)
end_define

begin_define
define|#
directive|define
name|X_DISP16
parameter_list|(
name|i
parameter_list|)
value|((((((i)>> 6)&& 0xc000) | ((i)& 0x3fff)) ^ 0x8000) - 0x8000)
end_define

begin_define
define|#
directive|define
name|X_FCN
parameter_list|(
name|i
parameter_list|)
value|(((i)>> 25)& 31)
end_define

begin_typedef
typedef|typedef
enum|enum
block|{
name|Error
block|,
name|not_branch
block|,
name|bicc
block|,
name|bicca
block|,
name|ba
block|,
name|baa
block|,
name|ticc
block|,
name|ta
block|,
name|done_retry
block|}
name|branch_type
typedef|;
end_typedef

begin_comment
comment|/* Simulate single-step ptrace call for sun4.  Code written by Gary    Beihl (beihl@mcc.com).  */
end_comment

begin_comment
comment|/* npc4 and next_pc describe the situation at the time that the    step-breakpoint was set, not necessary the current value of NPC_REGNUM.  */
end_comment

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|next_pc
decl_stmt|,
name|npc4
decl_stmt|,
name|target
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|brknpc4
decl_stmt|,
name|brktrg
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
name|char
name|binsn_quantum
index|[
name|BREAKPOINT_MAX
index|]
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|binsn_quantum
name|break_mem
index|[
literal|3
index|]
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|branch_type
name|isbranch
parameter_list|(
name|long
parameter_list|,
name|CORE_ADDR
parameter_list|,
name|CORE_ADDR
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* single_step() is called just before we want to resume the inferior,    if we want to single-step it but there is no hardware or kernel single-step    support (as on all SPARCs).  We find all the possible targets of the    coming instruction and breakpoint them.     single_step is also called just after the inferior stops.  If we had    set up a simulated single-step, we undo our damage.  */
end_comment

begin_function
name|void
name|sparc_software_single_step
parameter_list|(
name|enum
name|target_signal
name|ignore
parameter_list|,
comment|/* pid, but we don't need it */
name|int
name|insert_breakpoints_p
parameter_list|)
block|{
name|branch_type
name|br
decl_stmt|;
name|CORE_ADDR
name|pc
decl_stmt|;
name|long
name|pc_instruction
decl_stmt|;
if|if
condition|(
name|insert_breakpoints_p
condition|)
block|{
comment|/* Always set breakpoint for NPC.  */
name|next_pc
operator|=
name|read_register
argument_list|(
name|NPC_REGNUM
argument_list|)
expr_stmt|;
name|npc4
operator|=
name|next_pc
operator|+
literal|4
expr_stmt|;
comment|/* branch not taken */
name|target_insert_breakpoint
argument_list|(
name|next_pc
argument_list|,
name|break_mem
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* printf_unfiltered ("set break at %x\n",next_pc); */
name|pc
operator|=
name|read_register
argument_list|(
name|PC_REGNUM
argument_list|)
expr_stmt|;
name|pc_instruction
operator|=
name|fetch_instruction
argument_list|(
name|pc
argument_list|)
expr_stmt|;
name|br
operator|=
name|isbranch
argument_list|(
name|pc_instruction
argument_list|,
name|pc
argument_list|,
operator|&
name|target
argument_list|)
expr_stmt|;
name|brknpc4
operator|=
name|brktrg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|br
operator|==
name|bicca
condition|)
block|{
comment|/* Conditional annulled branch will either end up at 	     npc (if taken) or at npc+4 (if not taken). 	     Trap npc+4.  */
name|brknpc4
operator|=
literal|1
expr_stmt|;
name|target_insert_breakpoint
argument_list|(
name|npc4
argument_list|,
name|break_mem
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|br
operator|==
name|baa
operator|&&
name|target
operator|!=
name|next_pc
condition|)
block|{
comment|/* Unconditional annulled branch will always end up at 	     the target.  */
name|brktrg
operator|=
literal|1
expr_stmt|;
name|target_insert_breakpoint
argument_list|(
name|target
argument_list|,
name|break_mem
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GDB_TARGET_IS_SPARC64
operator|&&
name|br
operator|==
name|done_retry
condition|)
block|{
name|brktrg
operator|=
literal|1
expr_stmt|;
name|target_insert_breakpoint
argument_list|(
name|target
argument_list|,
name|break_mem
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Remove breakpoints */
name|target_remove_breakpoint
argument_list|(
name|next_pc
argument_list|,
name|break_mem
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|brknpc4
condition|)
name|target_remove_breakpoint
argument_list|(
name|npc4
argument_list|,
name|break_mem
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|brktrg
condition|)
name|target_remove_breakpoint
argument_list|(
name|target
argument_list|,
name|break_mem
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_struct
struct|struct
name|frame_extra_info
block|{
name|CORE_ADDR
name|bottom
decl_stmt|;
name|int
name|in_prologue
decl_stmt|;
name|int
name|flat
decl_stmt|;
comment|/* Following fields only relevant for flat frames.  */
name|CORE_ADDR
name|pc_addr
decl_stmt|;
name|CORE_ADDR
name|fp_addr
decl_stmt|;
comment|/* Add this to ->frame to get the value of the stack pointer at the       time of the register saves.  */
name|int
name|sp_offset
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Call this for each newly created frame.  For SPARC, we need to    calculate the bottom of the frame, and do some extra work if the    prologue has been generated via the -mflat option to GCC.  In    particular, we need to know where the previous fp and the pc have    been stashed, since their exact position within the frame may vary.  */
end_comment

begin_function
name|void
name|sparc_init_extra_frame_info
parameter_list|(
name|int
name|fromleaf
parameter_list|,
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|CORE_ADDR
name|prologue_start
decl_stmt|,
name|prologue_end
decl_stmt|;
name|int
name|insn
decl_stmt|;
name|fi
operator|->
name|extra_info
operator|=
operator|(
expr|struct
name|frame_extra_info
operator|*
operator|)
name|frame_obstack_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|frame_extra_info
argument_list|)
argument_list|)
expr_stmt|;
name|frame_saved_regs_zalloc
argument_list|(
name|fi
argument_list|)
expr_stmt|;
name|fi
operator|->
name|extra_info
operator|->
name|bottom
operator|=
operator|(
name|fi
operator|->
name|next
condition|?
operator|(
name|fi
operator|->
name|frame
operator|==
name|fi
operator|->
name|next
operator|->
name|frame
condition|?
name|fi
operator|->
name|next
operator|->
name|extra_info
operator|->
name|bottom
else|:
name|fi
operator|->
name|next
operator|->
name|frame
operator|)
else|:
name|read_sp
argument_list|()
operator|)
expr_stmt|;
comment|/* If fi->next is NULL, then we already set ->frame by passing read_fp()      to create_new_frame.  */
if|if
condition|(
name|fi
operator|->
name|next
condition|)
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|buf
operator|=
name|alloca
argument_list|(
name|MAX_REGISTER_RAW_SIZE
argument_list|)
expr_stmt|;
comment|/* Compute ->frame as if not flat.  If it is flat, we'll change          it later.  */
if|if
condition|(
name|fi
operator|->
name|next
operator|->
name|next
operator|!=
name|NULL
operator|&&
operator|(
name|fi
operator|->
name|next
operator|->
name|next
operator|->
name|signal_handler_caller
operator|||
name|frame_in_dummy
argument_list|(
name|fi
operator|->
name|next
operator|->
name|next
argument_list|)
operator|)
operator|&&
name|frameless_look_for_prologue
argument_list|(
name|fi
operator|->
name|next
argument_list|)
condition|)
block|{
comment|/* A frameless function interrupted by a signal did not change 	     the frame pointer, fix up frame pointer accordingly.  */
name|fi
operator|->
name|frame
operator|=
name|FRAME_FP
argument_list|(
name|fi
operator|->
name|next
argument_list|)
expr_stmt|;
name|fi
operator|->
name|extra_info
operator|->
name|bottom
operator|=
name|fi
operator|->
name|next
operator|->
name|extra_info
operator|->
name|bottom
expr_stmt|;
block|}
else|else
block|{
comment|/* Should we adjust for stack bias here? */
name|get_saved_register
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|fi
argument_list|,
name|FP_REGNUM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fi
operator|->
name|frame
operator|=
name|extract_address
argument_list|(
name|buf
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|FP_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GDB_TARGET_IS_SPARC64
operator|&&
operator|(
name|fi
operator|->
name|frame
operator|&
literal|1
operator|)
condition|)
name|fi
operator|->
name|frame
operator|+=
literal|2047
expr_stmt|;
block|}
block|}
comment|/* Decide whether this is a function with a ``flat register window''      frame.  For such functions, the frame pointer is actually in %i7.  */
name|fi
operator|->
name|extra_info
operator|->
name|flat
operator|=
literal|0
expr_stmt|;
name|fi
operator|->
name|extra_info
operator|->
name|in_prologue
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|find_pc_partial_function
argument_list|(
name|fi
operator|->
name|pc
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|prologue_start
argument_list|,
operator|&
name|prologue_end
argument_list|)
condition|)
block|{
comment|/* See if the function starts with an add (which will be of a          negative number if a flat frame) to the sp.  FIXME: Does not          handle large frames which will need more than one instruction          to adjust the sp.  */
name|insn
operator|=
name|fetch_instruction
argument_list|(
name|prologue_start
argument_list|)
expr_stmt|;
if|if
condition|(
name|X_OP
argument_list|(
name|insn
argument_list|)
operator|==
literal|2
operator|&&
name|X_RD
argument_list|(
name|insn
argument_list|)
operator|==
literal|14
operator|&&
name|X_OP3
argument_list|(
name|insn
argument_list|)
operator|==
literal|0
operator|&&
name|X_I
argument_list|(
name|insn
argument_list|)
operator|&&
name|X_SIMM13
argument_list|(
name|insn
argument_list|)
operator|<
literal|0
condition|)
block|{
name|int
name|offset
init|=
name|X_SIMM13
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* Then look for a save of %i7 into the frame.  */
name|insn
operator|=
name|fetch_instruction
argument_list|(
name|prologue_start
operator|+
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|X_OP
argument_list|(
name|insn
argument_list|)
operator|==
literal|3
operator|&&
name|X_RD
argument_list|(
name|insn
argument_list|)
operator|==
literal|31
operator|&&
name|X_OP3
argument_list|(
name|insn
argument_list|)
operator|==
literal|4
operator|&&
name|X_RS1
argument_list|(
name|insn
argument_list|)
operator|==
literal|14
condition|)
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|buf
operator|=
name|alloca
argument_list|(
name|MAX_REGISTER_RAW_SIZE
argument_list|)
expr_stmt|;
comment|/* We definitely have a flat frame now.  */
name|fi
operator|->
name|extra_info
operator|->
name|flat
operator|=
literal|1
expr_stmt|;
name|fi
operator|->
name|extra_info
operator|->
name|sp_offset
operator|=
name|offset
expr_stmt|;
comment|/* Overwrite the frame's address with the value in %i7.  */
name|get_saved_register
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|fi
argument_list|,
name|I7_REGNUM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fi
operator|->
name|frame
operator|=
name|extract_address
argument_list|(
name|buf
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|I7_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GDB_TARGET_IS_SPARC64
operator|&&
operator|(
name|fi
operator|->
name|frame
operator|&
literal|1
operator|)
condition|)
name|fi
operator|->
name|frame
operator|+=
literal|2047
expr_stmt|;
comment|/* Record where the fp got saved.  */
name|fi
operator|->
name|extra_info
operator|->
name|fp_addr
operator|=
name|fi
operator|->
name|frame
operator|+
name|fi
operator|->
name|extra_info
operator|->
name|sp_offset
operator|+
name|X_SIMM13
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Also try to collect where the pc got saved to.  */
name|fi
operator|->
name|extra_info
operator|->
name|pc_addr
operator|=
literal|0
expr_stmt|;
name|insn
operator|=
name|fetch_instruction
argument_list|(
name|prologue_start
operator|+
literal|12
argument_list|)
expr_stmt|;
if|if
condition|(
name|X_OP
argument_list|(
name|insn
argument_list|)
operator|==
literal|3
operator|&&
name|X_RD
argument_list|(
name|insn
argument_list|)
operator|==
literal|15
operator|&&
name|X_OP3
argument_list|(
name|insn
argument_list|)
operator|==
literal|4
operator|&&
name|X_RS1
argument_list|(
name|insn
argument_list|)
operator|==
literal|14
condition|)
name|fi
operator|->
name|extra_info
operator|->
name|pc_addr
operator|=
name|fi
operator|->
name|frame
operator|+
name|fi
operator|->
name|extra_info
operator|->
name|sp_offset
operator|+
name|X_SIMM13
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Check if the PC is in the function prologue before a SAVE 	     instruction has been executed yet.  If so, set the frame 	     to the current value of the stack pointer and set 	     the in_prologue flag.  */
name|CORE_ADDR
name|addr
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|sal
operator|=
name|find_pc_line
argument_list|(
name|prologue_start
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sal
operator|.
name|line
operator|==
literal|0
condition|)
comment|/* no line info, use PC */
name|prologue_end
operator|=
name|fi
operator|->
name|pc
expr_stmt|;
elseif|else
if|if
condition|(
name|sal
operator|.
name|end
operator|<
name|prologue_end
condition|)
name|prologue_end
operator|=
name|sal
operator|.
name|end
expr_stmt|;
if|if
condition|(
name|fi
operator|->
name|pc
operator|<
name|prologue_end
condition|)
block|{
for|for
control|(
name|addr
operator|=
name|prologue_start
init|;
name|addr
operator|<
name|fi
operator|->
name|pc
condition|;
name|addr
operator|+=
literal|4
control|)
block|{
name|insn
operator|=
name|read_memory_integer
argument_list|(
name|addr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|X_OP
argument_list|(
name|insn
argument_list|)
operator|==
literal|2
operator|&&
name|X_OP3
argument_list|(
name|insn
argument_list|)
operator|==
literal|0x3c
condition|)
break|break;
comment|/* SAVE seen, stop searching */
block|}
if|if
condition|(
name|addr
operator|>=
name|fi
operator|->
name|pc
condition|)
block|{
name|fi
operator|->
name|extra_info
operator|->
name|in_prologue
operator|=
literal|1
expr_stmt|;
name|fi
operator|->
name|frame
operator|=
name|read_register
argument_list|(
name|SP_REGNUM
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|fi
operator|->
name|next
operator|&&
name|fi
operator|->
name|frame
operator|==
literal|0
condition|)
block|{
comment|/* Kludge to cause init_prev_frame_info to destroy the new frame.  */
name|fi
operator|->
name|frame
operator|=
name|fi
operator|->
name|next
operator|->
name|frame
expr_stmt|;
name|fi
operator|->
name|pc
operator|=
name|fi
operator|->
name|next
operator|->
name|pc
expr_stmt|;
block|}
block|}
end_function

begin_function
name|CORE_ADDR
name|sparc_frame_chain
parameter_list|(
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|)
block|{
comment|/* Value that will cause FRAME_CHAIN_VALID to not worry about the chain      value.  If it really is zero, we detect it later in      sparc_init_prev_frame.  */
return|return
operator|(
name|CORE_ADDR
operator|)
literal|1
return|;
block|}
end_function

begin_function
name|CORE_ADDR
name|sparc_extract_struct_value_address
parameter_list|(
name|char
modifier|*
name|regbuf
parameter_list|)
block|{
return|return
name|extract_address
argument_list|(
name|regbuf
operator|+
name|REGISTER_BYTE
argument_list|(
name|O0_REGNUM
argument_list|)
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|O0_REGNUM
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Find the pc saved in frame FRAME.  */
end_comment

begin_function
name|CORE_ADDR
name|sparc_frame_saved_pc
parameter_list|(
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|)
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|buf
operator|=
name|alloca
argument_list|(
name|MAX_REGISTER_RAW_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame
operator|->
name|signal_handler_caller
condition|)
block|{
comment|/* This is the signal trampoline frame.          Get the saved PC from the sigcontext structure.  */
ifndef|#
directive|ifndef
name|SIGCONTEXT_PC_OFFSET
define|#
directive|define
name|SIGCONTEXT_PC_OFFSET
value|12
endif|#
directive|endif
name|CORE_ADDR
name|sigcontext_addr
decl_stmt|;
name|char
modifier|*
name|scbuf
decl_stmt|;
name|int
name|saved_pc_offset
init|=
name|SIGCONTEXT_PC_OFFSET
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
name|scbuf
operator|=
name|alloca
argument_list|(
name|TARGET_PTR_BIT
operator|/
name|HOST_CHAR_BIT
argument_list|)
expr_stmt|;
comment|/* Solaris2 ucbsigvechandler passes a pointer to a sigcontext          as the third parameter.  The offset to the saved pc is 12.  */
name|find_pc_partial_function
argument_list|(
name|frame
operator|->
name|pc
argument_list|,
operator|&
name|name
argument_list|,
operator|(
name|CORE_ADDR
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|CORE_ADDR
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|&&
name|STREQ
argument_list|(
name|name
argument_list|,
literal|"ucbsigvechandler"
argument_list|)
condition|)
name|saved_pc_offset
operator|=
literal|12
expr_stmt|;
comment|/* The sigcontext address is contained in register O2.  */
name|get_saved_register
argument_list|(
name|buf
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|CORE_ADDR
operator|*
operator|)
name|NULL
argument_list|,
name|frame
argument_list|,
name|O0_REGNUM
operator|+
literal|2
argument_list|,
operator|(
expr|enum
name|lval_type
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|sigcontext_addr
operator|=
name|extract_address
argument_list|(
name|buf
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|O0_REGNUM
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Don't cause a memory_error when accessing sigcontext in case the          stack layout has changed or the stack is corrupt.  */
name|target_read_memory
argument_list|(
name|sigcontext_addr
operator|+
name|saved_pc_offset
argument_list|,
name|scbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|scbuf
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|extract_address
argument_list|(
name|scbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|scbuf
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|frame
operator|->
name|extra_info
operator|->
name|in_prologue
operator|||
operator|(
name|frame
operator|->
name|next
operator|!=
name|NULL
operator|&&
operator|(
name|frame
operator|->
name|next
operator|->
name|signal_handler_caller
operator|||
name|frame_in_dummy
argument_list|(
name|frame
operator|->
name|next
argument_list|)
operator|)
operator|&&
name|frameless_look_for_prologue
argument_list|(
name|frame
argument_list|)
operator|)
condition|)
block|{
comment|/* A frameless function interrupted by a signal did not save          the PC, it is still in %o7.  */
name|get_saved_register
argument_list|(
name|buf
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|CORE_ADDR
operator|*
operator|)
name|NULL
argument_list|,
name|frame
argument_list|,
name|O7_REGNUM
argument_list|,
operator|(
expr|enum
name|lval_type
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|PC_ADJUST
argument_list|(
name|extract_address
argument_list|(
name|buf
argument_list|,
name|SPARC_INTREG_SIZE
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|frame
operator|->
name|extra_info
operator|->
name|flat
condition|)
name|addr
operator|=
name|frame
operator|->
name|extra_info
operator|->
name|pc_addr
expr_stmt|;
else|else
name|addr
operator|=
name|frame
operator|->
name|extra_info
operator|->
name|bottom
operator|+
name|FRAME_SAVED_I0
operator|+
name|SPARC_INTREG_SIZE
operator|*
operator|(
name|I7_REGNUM
operator|-
name|I0_REGNUM
operator|)
expr_stmt|;
if|if
condition|(
name|addr
operator|==
literal|0
condition|)
comment|/* A flat frame leaf function might not save the PC anywhere,        just leave it in %o7.  */
return|return
name|PC_ADJUST
argument_list|(
name|read_register
argument_list|(
name|O7_REGNUM
argument_list|)
argument_list|)
return|;
name|read_memory
argument_list|(
name|addr
argument_list|,
name|buf
argument_list|,
name|SPARC_INTREG_SIZE
argument_list|)
expr_stmt|;
return|return
name|PC_ADJUST
argument_list|(
name|extract_address
argument_list|(
name|buf
argument_list|,
name|SPARC_INTREG_SIZE
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Since an individual frame in the frame cache is defined by two    arguments (a frame pointer and a stack pointer), we need two    arguments to get info for an arbitrary stack frame.  This routine    takes two arguments and makes the cached frames look as if these    two arguments defined a frame on the cache.  This allows the rest    of info frame to extract the important arguments without    difficulty.  */
end_comment

begin_function
name|struct
name|frame_info
modifier|*
name|setup_arbitrary_frame
parameter_list|(
name|int
name|argc
parameter_list|,
name|CORE_ADDR
modifier|*
name|argv
parameter_list|)
block|{
name|struct
name|frame_info
modifier|*
name|frame
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
name|error
argument_list|(
literal|"Sparc frame specifications require two arguments: fp and sp"
argument_list|)
expr_stmt|;
name|frame
operator|=
name|create_new_frame
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|frame
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"create_new_frame returned invalid frame"
argument_list|)
expr_stmt|;
name|frame
operator|->
name|extra_info
operator|->
name|bottom
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
name|frame
operator|->
name|pc
operator|=
name|FRAME_SAVED_PC
argument_list|(
name|frame
argument_list|)
expr_stmt|;
return|return
name|frame
return|;
block|}
end_function

begin_comment
comment|/* Given a pc value, skip it forward past the function prologue by    disassembling instructions that appear to be a prologue.     If FRAMELESS_P is set, we are only testing to see if the function    is frameless.  This allows a quicker answer.     This routine should be more specific in its actions; making sure    that it uses the same register in the initial prologue section.  */
end_comment

begin_function_decl
specifier|static
name|CORE_ADDR
name|examine_prologue
parameter_list|(
name|CORE_ADDR
parameter_list|,
name|int
parameter_list|,
name|struct
name|frame_info
modifier|*
parameter_list|,
name|CORE_ADDR
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|CORE_ADDR
name|examine_prologue
parameter_list|(
name|CORE_ADDR
name|start_pc
parameter_list|,
name|int
name|frameless_p
parameter_list|,
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|,
name|CORE_ADDR
modifier|*
name|saved_regs
parameter_list|)
block|{
name|int
name|insn
decl_stmt|;
name|int
name|dest
init|=
operator|-
literal|1
decl_stmt|;
name|CORE_ADDR
name|pc
init|=
name|start_pc
decl_stmt|;
name|int
name|is_flat
init|=
literal|0
decl_stmt|;
name|insn
operator|=
name|fetch_instruction
argument_list|(
name|pc
argument_list|)
expr_stmt|;
comment|/* Recognize the `sethi' insn and record its destination.  */
if|if
condition|(
name|X_OP
argument_list|(
name|insn
argument_list|)
operator|==
literal|0
operator|&&
name|X_OP2
argument_list|(
name|insn
argument_list|)
operator|==
literal|4
condition|)
block|{
name|dest
operator|=
name|X_RD
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|pc
operator|+=
literal|4
expr_stmt|;
name|insn
operator|=
name|fetch_instruction
argument_list|(
name|pc
argument_list|)
expr_stmt|;
block|}
comment|/* Recognize an add immediate value to register to either %g1 or      the destination register recorded above.  Actually, this might      well recognize several different arithmetic operations.      It doesn't check that rs1 == rd because in theory "sub %g0, 5, %g1"      followed by "save %sp, %g1, %sp" is a valid prologue (Not that      I imagine any compiler really does that, however).  */
if|if
condition|(
name|X_OP
argument_list|(
name|insn
argument_list|)
operator|==
literal|2
operator|&&
name|X_I
argument_list|(
name|insn
argument_list|)
operator|&&
operator|(
name|X_RD
argument_list|(
name|insn
argument_list|)
operator|==
literal|1
operator|||
name|X_RD
argument_list|(
name|insn
argument_list|)
operator|==
name|dest
operator|)
condition|)
block|{
name|pc
operator|+=
literal|4
expr_stmt|;
name|insn
operator|=
name|fetch_instruction
argument_list|(
name|pc
argument_list|)
expr_stmt|;
block|}
comment|/* Recognize any SAVE insn.  */
if|if
condition|(
name|X_OP
argument_list|(
name|insn
argument_list|)
operator|==
literal|2
operator|&&
name|X_OP3
argument_list|(
name|insn
argument_list|)
operator|==
literal|60
condition|)
block|{
name|pc
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|frameless_p
condition|)
comment|/* If the save is all we care about, */
return|return
name|pc
return|;
comment|/* return before doing more work */
name|insn
operator|=
name|fetch_instruction
argument_list|(
name|pc
argument_list|)
expr_stmt|;
block|}
comment|/* Recognize add to %sp.  */
elseif|else
if|if
condition|(
name|X_OP
argument_list|(
name|insn
argument_list|)
operator|==
literal|2
operator|&&
name|X_RD
argument_list|(
name|insn
argument_list|)
operator|==
literal|14
operator|&&
name|X_OP3
argument_list|(
name|insn
argument_list|)
operator|==
literal|0
condition|)
block|{
name|pc
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|frameless_p
condition|)
comment|/* If the add is all we care about, */
return|return
name|pc
return|;
comment|/* return before doing more work */
name|is_flat
operator|=
literal|1
expr_stmt|;
name|insn
operator|=
name|fetch_instruction
argument_list|(
name|pc
argument_list|)
expr_stmt|;
comment|/* Recognize store of frame pointer (i7).  */
if|if
condition|(
name|X_OP
argument_list|(
name|insn
argument_list|)
operator|==
literal|3
operator|&&
name|X_RD
argument_list|(
name|insn
argument_list|)
operator|==
literal|31
operator|&&
name|X_OP3
argument_list|(
name|insn
argument_list|)
operator|==
literal|4
operator|&&
name|X_RS1
argument_list|(
name|insn
argument_list|)
operator|==
literal|14
condition|)
block|{
name|pc
operator|+=
literal|4
expr_stmt|;
name|insn
operator|=
name|fetch_instruction
argument_list|(
name|pc
argument_list|)
expr_stmt|;
comment|/* Recognize sub %sp,<anything>, %i7.  */
if|if
condition|(
name|X_OP
argument_list|(
name|insn
argument_list|)
operator|==
literal|2
operator|&&
name|X_OP3
argument_list|(
name|insn
argument_list|)
operator|==
literal|4
operator|&&
name|X_RS1
argument_list|(
name|insn
argument_list|)
operator|==
literal|14
operator|&&
name|X_RD
argument_list|(
name|insn
argument_list|)
operator|==
literal|31
condition|)
block|{
name|pc
operator|+=
literal|4
expr_stmt|;
name|insn
operator|=
name|fetch_instruction
argument_list|(
name|pc
argument_list|)
expr_stmt|;
block|}
else|else
return|return
name|pc
return|;
block|}
else|else
return|return
name|pc
return|;
block|}
else|else
comment|/* Without a save or add instruction, it's not a prologue.  */
return|return
name|start_pc
return|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Recognize stores into the frame from the input registers.          This recognizes all non alternate stores of an input register,          into a location offset from the frame pointer between 	 +68 and +92.  */
comment|/* The above will fail for arguments that are promoted  	 (eg. shorts to ints or floats to doubles), because the compiler 	 will pass them in positive-offset frame space, but the prologue 	 will save them (after conversion) in negative frame space at an 	 unpredictable offset.  Therefore I am going to remove the  	 restriction on the target-address of the save, on the theory 	 that any unbroken sequence of saves from input registers must 	 be part of the prologue.  In un-optimized code (at least), I'm 	 fairly sure that the compiler would emit SOME other instruction 	 (eg. a move or add) before emitting another save that is actually 	 a part of the function body.  	 Besides, the reserved stack space is different for SPARC64 anyway.  	 MVS  4/23/2000  */
if|if
condition|(
name|X_OP
argument_list|(
name|insn
argument_list|)
operator|==
literal|3
operator|&&
operator|(
name|X_OP3
argument_list|(
name|insn
argument_list|)
operator|&
literal|0x3c
operator|)
operator|==
literal|4
comment|/* Store, non-alternate.  */
operator|&&
operator|(
name|X_RD
argument_list|(
name|insn
argument_list|)
operator|&
literal|0x18
operator|)
operator|==
literal|0x18
comment|/* Input register.  */
operator|&&
name|X_I
argument_list|(
name|insn
argument_list|)
comment|/* Immediate mode.  */
operator|&&
name|X_RS1
argument_list|(
name|insn
argument_list|)
operator|==
literal|30
condition|)
comment|/* Off of frame pointer.  */
empty_stmt|;
comment|/* empty statement -- fall thru to end of loop */
elseif|else
if|if
condition|(
name|GDB_TARGET_IS_SPARC64
operator|&&
name|X_OP
argument_list|(
name|insn
argument_list|)
operator|==
literal|3
operator|&&
operator|(
name|X_OP3
argument_list|(
name|insn
argument_list|)
operator|&
literal|0x3c
operator|)
operator|==
literal|12
comment|/* store, extended (64-bit) */
operator|&&
operator|(
name|X_RD
argument_list|(
name|insn
argument_list|)
operator|&
literal|0x18
operator|)
operator|==
literal|0x18
comment|/* input register */
operator|&&
name|X_I
argument_list|(
name|insn
argument_list|)
comment|/* immediate mode */
operator|&&
name|X_RS1
argument_list|(
name|insn
argument_list|)
operator|==
literal|30
condition|)
comment|/* off of frame pointer */
empty_stmt|;
comment|/* empty statement -- fall thru to end of loop */
elseif|else
if|if
condition|(
name|X_OP
argument_list|(
name|insn
argument_list|)
operator|==
literal|3
operator|&&
operator|(
name|X_OP3
argument_list|(
name|insn
argument_list|)
operator|&
literal|0x3c
operator|)
operator|==
literal|36
comment|/* store, floating-point */
operator|&&
name|X_I
argument_list|(
name|insn
argument_list|)
comment|/* immediate mode */
operator|&&
name|X_RS1
argument_list|(
name|insn
argument_list|)
operator|==
literal|30
condition|)
comment|/* off of frame pointer */
empty_stmt|;
comment|/* empty statement -- fall thru to end of loop */
elseif|else
if|if
condition|(
name|is_flat
operator|&&
name|X_OP
argument_list|(
name|insn
argument_list|)
operator|==
literal|3
operator|&&
name|X_OP3
argument_list|(
name|insn
argument_list|)
operator|==
literal|4
comment|/* store? */
operator|&&
name|X_RS1
argument_list|(
name|insn
argument_list|)
operator|==
literal|14
condition|)
comment|/* off of frame pointer */
block|{
if|if
condition|(
name|saved_regs
operator|&&
name|X_I
argument_list|(
name|insn
argument_list|)
condition|)
name|saved_regs
index|[
name|X_RD
argument_list|(
name|insn
argument_list|)
index|]
operator|=
name|fi
operator|->
name|frame
operator|+
name|fi
operator|->
name|extra_info
operator|->
name|sp_offset
operator|+
name|X_SIMM13
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
else|else
break|break;
name|pc
operator|+=
literal|4
expr_stmt|;
name|insn
operator|=
name|fetch_instruction
argument_list|(
name|pc
argument_list|)
expr_stmt|;
block|}
return|return
name|pc
return|;
block|}
end_function

begin_function
name|CORE_ADDR
name|sparc_skip_prologue
parameter_list|(
name|CORE_ADDR
name|start_pc
parameter_list|,
name|int
name|frameless_p
parameter_list|)
block|{
return|return
name|examine_prologue
argument_list|(
name|start_pc
argument_list|,
name|frameless_p
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Check instruction at ADDR to see if it is a branch.    All non-annulled instructions will go to NPC or will trap.    Set *TARGET if we find a candidate branch; set to zero if not.     This isn't static as it's used by remote-sa.sparc.c.  */
end_comment

begin_function
specifier|static
name|branch_type
name|isbranch
parameter_list|(
name|long
name|instruction
parameter_list|,
name|CORE_ADDR
name|addr
parameter_list|,
name|CORE_ADDR
modifier|*
name|target
parameter_list|)
block|{
name|branch_type
name|val
init|=
name|not_branch
decl_stmt|;
name|long
name|int
name|offset
init|=
literal|0
decl_stmt|;
comment|/* Must be signed for sign-extend.  */
operator|*
name|target
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|X_OP
argument_list|(
name|instruction
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|X_OP2
argument_list|(
name|instruction
argument_list|)
operator|==
literal|2
operator|||
name|X_OP2
argument_list|(
name|instruction
argument_list|)
operator|==
literal|6
operator|||
name|X_OP2
argument_list|(
name|instruction
argument_list|)
operator|==
literal|1
operator|||
name|X_OP2
argument_list|(
name|instruction
argument_list|)
operator|==
literal|3
operator|||
name|X_OP2
argument_list|(
name|instruction
argument_list|)
operator|==
literal|5
operator|||
operator|(
name|GDB_TARGET_IS_SPARC64
operator|&&
name|X_OP2
argument_list|(
name|instruction
argument_list|)
operator|==
literal|7
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|X_COND
argument_list|(
name|instruction
argument_list|)
operator|==
literal|8
condition|)
name|val
operator|=
name|X_A
argument_list|(
name|instruction
argument_list|)
condition|?
name|baa
else|:
name|ba
expr_stmt|;
else|else
name|val
operator|=
name|X_A
argument_list|(
name|instruction
argument_list|)
condition|?
name|bicca
else|:
name|bicc
expr_stmt|;
switch|switch
condition|(
name|X_OP2
argument_list|(
name|instruction
argument_list|)
condition|)
block|{
case|case
literal|7
case|:
if|if
condition|(
operator|!
name|GDB_TARGET_IS_SPARC64
condition|)
break|break;
comment|/* else fall thru */
case|case
literal|2
case|:
case|case
literal|6
case|:
name|offset
operator|=
literal|4
operator|*
name|X_DISP22
argument_list|(
name|instruction
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
case|case
literal|5
case|:
name|offset
operator|=
literal|4
operator|*
name|X_DISP19
argument_list|(
name|instruction
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|offset
operator|=
literal|4
operator|*
name|X_DISP16
argument_list|(
name|instruction
argument_list|)
expr_stmt|;
break|break;
block|}
operator|*
name|target
operator|=
name|addr
operator|+
name|offset
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GDB_TARGET_IS_SPARC64
operator|&&
name|X_OP
argument_list|(
name|instruction
argument_list|)
operator|==
literal|2
operator|&&
name|X_OP3
argument_list|(
name|instruction
argument_list|)
operator|==
literal|62
condition|)
block|{
if|if
condition|(
name|X_FCN
argument_list|(
name|instruction
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* done */
operator|*
name|target
operator|=
name|read_register
argument_list|(
name|TNPC_REGNUM
argument_list|)
expr_stmt|;
name|val
operator|=
name|done_retry
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|X_FCN
argument_list|(
name|instruction
argument_list|)
operator|==
literal|1
condition|)
block|{
comment|/* retry */
operator|*
name|target
operator|=
name|read_register
argument_list|(
name|TPC_REGNUM
argument_list|)
expr_stmt|;
name|val
operator|=
name|done_retry
expr_stmt|;
block|}
block|}
return|return
name|val
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find register number REGNUM relative to FRAME and put its    (raw) contents in *RAW_BUFFER.  Set *OPTIMIZED if the variable    was optimized out (and thus can't be fetched).  If the variable    was fetched from memory, set *ADDRP to where it was fetched from,    otherwise it was fetched from a register.     The argument RAW_BUFFER must point to aligned memory.  */
end_comment

begin_function
name|void
name|sparc_get_saved_register
parameter_list|(
name|char
modifier|*
name|raw_buffer
parameter_list|,
name|int
modifier|*
name|optimized
parameter_list|,
name|CORE_ADDR
modifier|*
name|addrp
parameter_list|,
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|,
name|int
name|regnum
parameter_list|,
name|enum
name|lval_type
modifier|*
name|lval
parameter_list|)
block|{
name|struct
name|frame_info
modifier|*
name|frame1
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
if|if
condition|(
operator|!
name|target_has_registers
condition|)
name|error
argument_list|(
literal|"No registers."
argument_list|)
expr_stmt|;
if|if
condition|(
name|optimized
condition|)
operator|*
name|optimized
operator|=
literal|0
expr_stmt|;
name|addr
operator|=
literal|0
expr_stmt|;
comment|/* FIXME This code extracted from infcmd.c; should put elsewhere! */
if|if
condition|(
name|frame
operator|==
name|NULL
condition|)
block|{
comment|/* error ("No selected frame."); */
if|if
condition|(
operator|!
name|target_has_registers
condition|)
name|error
argument_list|(
literal|"The program has no registers now."
argument_list|)
expr_stmt|;
if|if
condition|(
name|selected_frame
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"No selected frame."
argument_list|)
expr_stmt|;
comment|/* Try to use selected frame */
name|frame
operator|=
name|get_prev_frame
argument_list|(
name|selected_frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Cmd not meaningful in the outermost frame."
argument_list|)
expr_stmt|;
block|}
name|frame1
operator|=
name|frame
operator|->
name|next
expr_stmt|;
comment|/* Get saved PC from the frame info if not in innermost frame.  */
if|if
condition|(
name|regnum
operator|==
name|PC_REGNUM
operator|&&
name|frame1
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|lval
operator|!=
name|NULL
condition|)
operator|*
name|lval
operator|=
name|not_lval
expr_stmt|;
if|if
condition|(
name|raw_buffer
operator|!=
name|NULL
condition|)
block|{
comment|/* Put it back in target format.  */
name|store_address
argument_list|(
name|raw_buffer
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|,
name|frame
operator|->
name|pc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|addrp
operator|!=
name|NULL
condition|)
operator|*
name|addrp
operator|=
literal|0
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|frame1
operator|!=
name|NULL
condition|)
block|{
comment|/* FIXME MVS: wrong test for dummy frame at entry.  */
if|if
condition|(
name|frame1
operator|->
name|pc
operator|>=
operator|(
name|frame1
operator|->
name|extra_info
operator|->
name|bottom
condition|?
name|frame1
operator|->
name|extra_info
operator|->
name|bottom
else|:
name|read_sp
argument_list|()
operator|)
operator|&&
name|frame1
operator|->
name|pc
operator|<=
name|FRAME_FP
argument_list|(
name|frame1
argument_list|)
condition|)
block|{
comment|/* Dummy frame.  All but the window regs are in there somewhere. 	     The window registers are saved on the stack, just like in a 	     normal frame.  */
if|if
condition|(
name|regnum
operator|>=
name|G1_REGNUM
operator|&&
name|regnum
operator|<
name|G1_REGNUM
operator|+
literal|7
condition|)
name|addr
operator|=
name|frame1
operator|->
name|frame
operator|+
operator|(
name|regnum
operator|-
name|G0_REGNUM
operator|)
operator|*
name|SPARC_INTREG_SIZE
operator|-
operator|(
name|FP_REGISTER_BYTES
operator|+
literal|8
operator|*
name|SPARC_INTREG_SIZE
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|regnum
operator|>=
name|I0_REGNUM
operator|&&
name|regnum
operator|<
name|I0_REGNUM
operator|+
literal|8
condition|)
name|addr
operator|=
operator|(
name|frame1
operator|->
name|prev
operator|->
name|extra_info
operator|->
name|bottom
operator|+
operator|(
name|regnum
operator|-
name|I0_REGNUM
operator|)
operator|*
name|SPARC_INTREG_SIZE
operator|+
name|FRAME_SAVED_I0
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|regnum
operator|>=
name|L0_REGNUM
operator|&&
name|regnum
operator|<
name|L0_REGNUM
operator|+
literal|8
condition|)
name|addr
operator|=
operator|(
name|frame1
operator|->
name|prev
operator|->
name|extra_info
operator|->
name|bottom
operator|+
operator|(
name|regnum
operator|-
name|L0_REGNUM
operator|)
operator|*
name|SPARC_INTREG_SIZE
operator|+
name|FRAME_SAVED_L0
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|regnum
operator|>=
name|O0_REGNUM
operator|&&
name|regnum
operator|<
name|O0_REGNUM
operator|+
literal|8
condition|)
name|addr
operator|=
name|frame1
operator|->
name|frame
operator|+
operator|(
name|regnum
operator|-
name|O0_REGNUM
operator|)
operator|*
name|SPARC_INTREG_SIZE
operator|-
operator|(
name|FP_REGISTER_BYTES
operator|+
literal|16
operator|*
name|SPARC_INTREG_SIZE
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|SPARC_HAS_FPU
operator|&&
name|regnum
operator|>=
name|FP0_REGNUM
operator|&&
name|regnum
operator|<
name|FP0_REGNUM
operator|+
literal|32
condition|)
name|addr
operator|=
name|frame1
operator|->
name|frame
operator|+
operator|(
name|regnum
operator|-
name|FP0_REGNUM
operator|)
operator|*
literal|4
operator|-
operator|(
name|FP_REGISTER_BYTES
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GDB_TARGET_IS_SPARC64
operator|&&
name|SPARC_HAS_FPU
operator|&&
name|regnum
operator|>=
name|FP0_REGNUM
operator|+
literal|32
operator|&&
name|regnum
operator|<
name|FP_MAX_REGNUM
condition|)
name|addr
operator|=
name|frame1
operator|->
name|frame
operator|+
literal|32
operator|*
literal|4
operator|+
operator|(
name|regnum
operator|-
name|FP0_REGNUM
operator|-
literal|32
operator|)
operator|*
literal|8
operator|-
operator|(
name|FP_REGISTER_BYTES
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|regnum
operator|>=
name|Y_REGNUM
operator|&&
name|regnum
operator|<
name|NUM_REGS
condition|)
name|addr
operator|=
name|frame1
operator|->
name|frame
operator|+
operator|(
name|regnum
operator|-
name|Y_REGNUM
operator|)
operator|*
name|SPARC_INTREG_SIZE
operator|-
operator|(
name|FP_REGISTER_BYTES
operator|+
literal|24
operator|*
name|SPARC_INTREG_SIZE
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|frame1
operator|->
name|extra_info
operator|->
name|flat
condition|)
block|{
if|if
condition|(
name|regnum
operator|==
name|RP_REGNUM
condition|)
name|addr
operator|=
name|frame1
operator|->
name|extra_info
operator|->
name|pc_addr
expr_stmt|;
elseif|else
if|if
condition|(
name|regnum
operator|==
name|I7_REGNUM
condition|)
name|addr
operator|=
name|frame1
operator|->
name|extra_info
operator|->
name|fp_addr
expr_stmt|;
else|else
block|{
name|CORE_ADDR
name|func_start
decl_stmt|;
name|CORE_ADDR
modifier|*
name|regs
decl_stmt|;
name|regs
operator|=
name|alloca
argument_list|(
name|NUM_REGS
operator|*
sizeof|sizeof
argument_list|(
name|CORE_ADDR
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|regs
argument_list|,
literal|0
argument_list|,
name|NUM_REGS
operator|*
sizeof|sizeof
argument_list|(
name|CORE_ADDR
argument_list|)
argument_list|)
expr_stmt|;
name|find_pc_partial_function
argument_list|(
name|frame1
operator|->
name|pc
argument_list|,
name|NULL
argument_list|,
operator|&
name|func_start
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|examine_prologue
argument_list|(
name|func_start
argument_list|,
literal|0
argument_list|,
name|frame1
argument_list|,
name|regs
argument_list|)
expr_stmt|;
name|addr
operator|=
name|regs
index|[
name|regnum
index|]
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Normal frame.  Local and In registers are saved on stack.  */
if|if
condition|(
name|regnum
operator|>=
name|I0_REGNUM
operator|&&
name|regnum
operator|<
name|I0_REGNUM
operator|+
literal|8
condition|)
name|addr
operator|=
operator|(
name|frame1
operator|->
name|prev
operator|->
name|extra_info
operator|->
name|bottom
operator|+
operator|(
name|regnum
operator|-
name|I0_REGNUM
operator|)
operator|*
name|SPARC_INTREG_SIZE
operator|+
name|FRAME_SAVED_I0
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|regnum
operator|>=
name|L0_REGNUM
operator|&&
name|regnum
operator|<
name|L0_REGNUM
operator|+
literal|8
condition|)
name|addr
operator|=
operator|(
name|frame1
operator|->
name|prev
operator|->
name|extra_info
operator|->
name|bottom
operator|+
operator|(
name|regnum
operator|-
name|L0_REGNUM
operator|)
operator|*
name|SPARC_INTREG_SIZE
operator|+
name|FRAME_SAVED_L0
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|regnum
operator|>=
name|O0_REGNUM
operator|&&
name|regnum
operator|<
name|O0_REGNUM
operator|+
literal|8
condition|)
block|{
comment|/* Outs become ins.  */
name|get_saved_register
argument_list|(
name|raw_buffer
argument_list|,
name|optimized
argument_list|,
name|addrp
argument_list|,
name|frame1
argument_list|,
operator|(
name|regnum
operator|-
name|O0_REGNUM
operator|+
name|I0_REGNUM
operator|)
argument_list|,
name|lval
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|addr
operator|!=
literal|0
condition|)
break|break;
name|frame1
operator|=
name|frame1
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|addr
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|lval
operator|!=
name|NULL
condition|)
operator|*
name|lval
operator|=
name|lval_memory
expr_stmt|;
if|if
condition|(
name|regnum
operator|==
name|SP_REGNUM
condition|)
block|{
if|if
condition|(
name|raw_buffer
operator|!=
name|NULL
condition|)
block|{
comment|/* Put it back in target format.  */
name|store_address
argument_list|(
name|raw_buffer
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|addrp
operator|!=
name|NULL
condition|)
operator|*
name|addrp
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|raw_buffer
operator|!=
name|NULL
condition|)
name|read_memory
argument_list|(
name|addr
argument_list|,
name|raw_buffer
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|lval
operator|!=
name|NULL
condition|)
operator|*
name|lval
operator|=
name|lval_register
expr_stmt|;
name|addr
operator|=
name|REGISTER_BYTE
argument_list|(
name|regnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|raw_buffer
operator|!=
name|NULL
condition|)
name|read_register_gen
argument_list|(
name|regnum
argument_list|,
name|raw_buffer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|addrp
operator|!=
name|NULL
condition|)
operator|*
name|addrp
operator|=
name|addr
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Push an empty stack frame, and record in it the current PC, regs, etc.     We save the non-windowed registers and the ins.  The locals and outs    are new; they don't need to be saved. The i's and l's of    the last frame were already saved on the stack.  */
end_comment

begin_comment
comment|/* Definitely see tm-sparc.h for more doc of the frame format here.  */
end_comment

begin_comment
comment|/* See tm-sparc.h for how this is calculated.  */
end_comment

begin_define
define|#
directive|define
name|DUMMY_STACK_REG_BUF_SIZE
define|\
value|(((8+8+8) * SPARC_INTREG_SIZE) + FP_REGISTER_BYTES)
end_define

begin_define
define|#
directive|define
name|DUMMY_STACK_SIZE
define|\
value|(DUMMY_STACK_REG_BUF_SIZE + DUMMY_REG_SAVE_OFFSET)
end_define

begin_function
name|void
name|sparc_push_dummy_frame
parameter_list|(
name|void
parameter_list|)
block|{
name|CORE_ADDR
name|sp
decl_stmt|,
name|old_sp
decl_stmt|;
name|char
modifier|*
name|register_temp
decl_stmt|;
name|register_temp
operator|=
name|alloca
argument_list|(
name|DUMMY_STACK_SIZE
argument_list|)
expr_stmt|;
name|old_sp
operator|=
name|sp
operator|=
name|read_sp
argument_list|()
expr_stmt|;
if|if
condition|(
name|GDB_TARGET_IS_SPARC64
condition|)
block|{
comment|/* PC, NPC, CCR, FSR, FPRS, Y, ASI */
name|read_register_bytes
argument_list|(
name|REGISTER_BYTE
argument_list|(
name|PC_REGNUM
argument_list|)
argument_list|,
operator|&
name|register_temp
index|[
literal|0
index|]
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|PC_REGNUM
argument_list|)
operator|*
literal|7
argument_list|)
expr_stmt|;
name|read_register_bytes
argument_list|(
name|REGISTER_BYTE
argument_list|(
name|PSTATE_REGNUM
argument_list|)
argument_list|,
operator|&
name|register_temp
index|[
literal|7
operator|*
name|SPARC_INTREG_SIZE
index|]
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|PSTATE_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
comment|/* FIXME: not sure what needs to be saved here.  */
block|}
else|else
block|{
comment|/* Y, PS, WIM, TBR, PC, NPC, FPS, CPS regs */
name|read_register_bytes
argument_list|(
name|REGISTER_BYTE
argument_list|(
name|Y_REGNUM
argument_list|)
argument_list|,
operator|&
name|register_temp
index|[
literal|0
index|]
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|Y_REGNUM
argument_list|)
operator|*
literal|8
argument_list|)
expr_stmt|;
block|}
name|read_register_bytes
argument_list|(
name|REGISTER_BYTE
argument_list|(
name|O0_REGNUM
argument_list|)
argument_list|,
operator|&
name|register_temp
index|[
literal|8
operator|*
name|SPARC_INTREG_SIZE
index|]
argument_list|,
name|SPARC_INTREG_SIZE
operator|*
literal|8
argument_list|)
expr_stmt|;
name|read_register_bytes
argument_list|(
name|REGISTER_BYTE
argument_list|(
name|G0_REGNUM
argument_list|)
argument_list|,
operator|&
name|register_temp
index|[
literal|16
operator|*
name|SPARC_INTREG_SIZE
index|]
argument_list|,
name|SPARC_INTREG_SIZE
operator|*
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|SPARC_HAS_FPU
condition|)
name|read_register_bytes
argument_list|(
name|REGISTER_BYTE
argument_list|(
name|FP0_REGNUM
argument_list|)
argument_list|,
operator|&
name|register_temp
index|[
literal|24
operator|*
name|SPARC_INTREG_SIZE
index|]
argument_list|,
name|FP_REGISTER_BYTES
argument_list|)
expr_stmt|;
name|sp
operator|-=
name|DUMMY_STACK_SIZE
expr_stmt|;
name|write_sp
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|write_memory
argument_list|(
name|sp
operator|+
name|DUMMY_REG_SAVE_OFFSET
argument_list|,
operator|&
name|register_temp
index|[
literal|0
index|]
argument_list|,
name|DUMMY_STACK_REG_BUF_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|target_shortname
argument_list|,
literal|"sim"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|write_fp
argument_list|(
name|old_sp
argument_list|)
expr_stmt|;
comment|/* Set return address register for the call dummy to the current PC.  */
name|write_register
argument_list|(
name|I7_REGNUM
argument_list|,
name|read_pc
argument_list|()
operator|-
literal|8
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The call dummy will write this value to FP before executing          the 'save'.  This ensures that register window flushes work          correctly in the simulator.  */
name|write_register
argument_list|(
name|G0_REGNUM
operator|+
literal|1
argument_list|,
name|read_register
argument_list|(
name|FP_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The call dummy will write this value to FP after executing          the 'save'. */
name|write_register
argument_list|(
name|G0_REGNUM
operator|+
literal|2
argument_list|,
name|old_sp
argument_list|)
expr_stmt|;
comment|/* The call dummy will write this value to the return address (%i7) after          executing the 'save'. */
name|write_register
argument_list|(
name|G0_REGNUM
operator|+
literal|3
argument_list|,
name|read_pc
argument_list|()
operator|-
literal|8
argument_list|)
expr_stmt|;
comment|/* Set the FP that the call dummy will be using after the 'save'.          This makes backtraces from an inferior function call work properly.  */
name|write_register
argument_list|(
name|FP_REGNUM
argument_list|,
name|old_sp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* sparc_frame_find_saved_regs ().  This function is here only because    pop_frame uses it.  Note there is an interesting corner case which    I think few ports of GDB get right--if you are popping a frame    which does not save some register that *is* saved by a more inner    frame (such a frame will never be a dummy frame because dummy    frames save all registers).  Rewriting pop_frame to use    get_saved_register would solve this problem and also get rid of the    ugly duplication between sparc_frame_find_saved_regs and    get_saved_register.     Stores, into an array of CORE_ADDR,     the addresses of the saved registers of frame described by FRAME_INFO.    This includes special registers such as pc and fp saved in special    ways in the stack frame.  sp is even more special:    the address we return for it IS the sp for the next frame.     Note that on register window machines, we are currently making the    assumption that window registers are being saved somewhere in the    frame in which they are being used.  If they are stored in an    inferior frame, find_saved_register will break.     On the Sun 4, the only time all registers are saved is when    a dummy frame is involved.  Otherwise, the only saved registers    are the LOCAL and IN registers which are saved as a result    of the "save/restore" opcodes.  This condition is determined    by address rather than by value.     The "pc" is not stored in a frame on the SPARC.  (What is stored    is a return address minus 8.)  sparc_pop_frame knows how to    deal with that.  Other routines might or might not.     See tm-sparc.h (PUSH_DUMMY_FRAME and friends) for CRITICAL information    about how this works.  */
end_comment

begin_function_decl
specifier|static
name|void
name|sparc_frame_find_saved_regs
parameter_list|(
name|struct
name|frame_info
modifier|*
parameter_list|,
name|CORE_ADDR
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|sparc_frame_find_saved_regs
parameter_list|(
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|,
name|CORE_ADDR
modifier|*
name|saved_regs_addr
parameter_list|)
block|{
specifier|register
name|int
name|regnum
decl_stmt|;
name|CORE_ADDR
name|frame_addr
init|=
name|FRAME_FP
argument_list|(
name|fi
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|fi
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"Bad frame info struct in FRAME_FIND_SAVED_REGS"
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|saved_regs_addr
argument_list|,
literal|0
argument_list|,
name|NUM_REGS
operator|*
sizeof|sizeof
argument_list|(
name|CORE_ADDR
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fi
operator|->
name|pc
operator|>=
operator|(
name|fi
operator|->
name|extra_info
operator|->
name|bottom
condition|?
name|fi
operator|->
name|extra_info
operator|->
name|bottom
else|:
name|read_sp
argument_list|()
operator|)
operator|&&
name|fi
operator|->
name|pc
operator|<=
name|FRAME_FP
argument_list|(
name|fi
argument_list|)
condition|)
block|{
comment|/* Dummy frame.  All but the window regs are in there somewhere. */
for|for
control|(
name|regnum
operator|=
name|G1_REGNUM
init|;
name|regnum
operator|<
name|G1_REGNUM
operator|+
literal|7
condition|;
name|regnum
operator|++
control|)
name|saved_regs_addr
index|[
name|regnum
index|]
operator|=
name|frame_addr
operator|+
operator|(
name|regnum
operator|-
name|G0_REGNUM
operator|)
operator|*
name|SPARC_INTREG_SIZE
operator|-
name|DUMMY_STACK_REG_BUF_SIZE
operator|+
literal|16
operator|*
name|SPARC_INTREG_SIZE
expr_stmt|;
for|for
control|(
name|regnum
operator|=
name|I0_REGNUM
init|;
name|regnum
operator|<
name|I0_REGNUM
operator|+
literal|8
condition|;
name|regnum
operator|++
control|)
name|saved_regs_addr
index|[
name|regnum
index|]
operator|=
name|frame_addr
operator|+
operator|(
name|regnum
operator|-
name|I0_REGNUM
operator|)
operator|*
name|SPARC_INTREG_SIZE
operator|-
name|DUMMY_STACK_REG_BUF_SIZE
operator|+
literal|8
operator|*
name|SPARC_INTREG_SIZE
expr_stmt|;
if|if
condition|(
name|SPARC_HAS_FPU
condition|)
for|for
control|(
name|regnum
operator|=
name|FP0_REGNUM
init|;
name|regnum
operator|<
name|FP_MAX_REGNUM
condition|;
name|regnum
operator|++
control|)
name|saved_regs_addr
index|[
name|regnum
index|]
operator|=
name|frame_addr
operator|+
operator|(
name|regnum
operator|-
name|FP0_REGNUM
operator|)
operator|*
literal|4
operator|-
name|DUMMY_STACK_REG_BUF_SIZE
operator|+
literal|24
operator|*
name|SPARC_INTREG_SIZE
expr_stmt|;
if|if
condition|(
name|GDB_TARGET_IS_SPARC64
condition|)
block|{
for|for
control|(
name|regnum
operator|=
name|PC_REGNUM
init|;
name|regnum
operator|<
name|PC_REGNUM
operator|+
literal|7
condition|;
name|regnum
operator|++
control|)
block|{
name|saved_regs_addr
index|[
name|regnum
index|]
operator|=
name|frame_addr
operator|+
operator|(
name|regnum
operator|-
name|PC_REGNUM
operator|)
operator|*
name|SPARC_INTREG_SIZE
operator|-
name|DUMMY_STACK_REG_BUF_SIZE
expr_stmt|;
block|}
name|saved_regs_addr
index|[
name|PSTATE_REGNUM
index|]
operator|=
name|frame_addr
operator|+
literal|8
operator|*
name|SPARC_INTREG_SIZE
operator|-
name|DUMMY_STACK_REG_BUF_SIZE
expr_stmt|;
block|}
else|else
for|for
control|(
name|regnum
operator|=
name|Y_REGNUM
init|;
name|regnum
operator|<
name|NUM_REGS
condition|;
name|regnum
operator|++
control|)
name|saved_regs_addr
index|[
name|regnum
index|]
operator|=
name|frame_addr
operator|+
operator|(
name|regnum
operator|-
name|Y_REGNUM
operator|)
operator|*
name|SPARC_INTREG_SIZE
operator|-
name|DUMMY_STACK_REG_BUF_SIZE
expr_stmt|;
name|frame_addr
operator|=
name|fi
operator|->
name|extra_info
operator|->
name|bottom
condition|?
name|fi
operator|->
name|extra_info
operator|->
name|bottom
else|:
name|read_sp
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fi
operator|->
name|extra_info
operator|->
name|flat
condition|)
block|{
name|CORE_ADDR
name|func_start
decl_stmt|;
name|find_pc_partial_function
argument_list|(
name|fi
operator|->
name|pc
argument_list|,
name|NULL
argument_list|,
operator|&
name|func_start
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|examine_prologue
argument_list|(
name|func_start
argument_list|,
literal|0
argument_list|,
name|fi
argument_list|,
name|saved_regs_addr
argument_list|)
expr_stmt|;
comment|/* Flat register window frame.  */
name|saved_regs_addr
index|[
name|RP_REGNUM
index|]
operator|=
name|fi
operator|->
name|extra_info
operator|->
name|pc_addr
expr_stmt|;
name|saved_regs_addr
index|[
name|I7_REGNUM
index|]
operator|=
name|fi
operator|->
name|extra_info
operator|->
name|fp_addr
expr_stmt|;
block|}
else|else
block|{
comment|/* Normal frame.  Just Local and In registers */
name|frame_addr
operator|=
name|fi
operator|->
name|extra_info
operator|->
name|bottom
condition|?
name|fi
operator|->
name|extra_info
operator|->
name|bottom
else|:
name|read_sp
argument_list|()
expr_stmt|;
for|for
control|(
name|regnum
operator|=
name|L0_REGNUM
init|;
name|regnum
operator|<
name|L0_REGNUM
operator|+
literal|8
condition|;
name|regnum
operator|++
control|)
name|saved_regs_addr
index|[
name|regnum
index|]
operator|=
operator|(
name|frame_addr
operator|+
operator|(
name|regnum
operator|-
name|L0_REGNUM
operator|)
operator|*
name|SPARC_INTREG_SIZE
operator|+
name|FRAME_SAVED_L0
operator|)
expr_stmt|;
for|for
control|(
name|regnum
operator|=
name|I0_REGNUM
init|;
name|regnum
operator|<
name|I0_REGNUM
operator|+
literal|8
condition|;
name|regnum
operator|++
control|)
name|saved_regs_addr
index|[
name|regnum
index|]
operator|=
operator|(
name|frame_addr
operator|+
operator|(
name|regnum
operator|-
name|I0_REGNUM
operator|)
operator|*
name|SPARC_INTREG_SIZE
operator|+
name|FRAME_SAVED_I0
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|fi
operator|->
name|next
condition|)
block|{
if|if
condition|(
name|fi
operator|->
name|extra_info
operator|->
name|flat
condition|)
block|{
name|saved_regs_addr
index|[
name|O7_REGNUM
index|]
operator|=
name|fi
operator|->
name|extra_info
operator|->
name|pc_addr
expr_stmt|;
block|}
else|else
block|{
comment|/* Pull off either the next frame pointer or the stack pointer */
name|CORE_ADDR
name|next_next_frame_addr
init|=
operator|(
name|fi
operator|->
name|next
operator|->
name|extra_info
operator|->
name|bottom
condition|?
name|fi
operator|->
name|next
operator|->
name|extra_info
operator|->
name|bottom
else|:
name|read_sp
argument_list|()
operator|)
decl_stmt|;
for|for
control|(
name|regnum
operator|=
name|O0_REGNUM
init|;
name|regnum
operator|<
name|O0_REGNUM
operator|+
literal|8
condition|;
name|regnum
operator|++
control|)
name|saved_regs_addr
index|[
name|regnum
index|]
operator|=
operator|(
name|next_next_frame_addr
operator|+
operator|(
name|regnum
operator|-
name|O0_REGNUM
operator|)
operator|*
name|SPARC_INTREG_SIZE
operator|+
name|FRAME_SAVED_I0
operator|)
expr_stmt|;
block|}
block|}
comment|/* Otherwise, whatever we would get from ptrace(GETREGS) is accurate */
comment|/* FIXME -- should this adjust for the sparc64 offset? */
name|saved_regs_addr
index|[
name|SP_REGNUM
index|]
operator|=
name|FRAME_FP
argument_list|(
name|fi
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Discard from the stack the innermost frame, restoring all saved registers.     Note that the values stored in fsr by get_frame_saved_regs are *in    the context of the called frame*.  What this means is that the i    regs of fsr must be restored into the o regs of the (calling) frame that    we pop into.  We don't care about the output regs of the calling frame,    since unless it's a dummy frame, it won't have any output regs in it.     We never have to bother with %l (local) regs, since the called routine's    locals get tossed, and the calling routine's locals are already saved    on its stack.  */
end_comment

begin_comment
comment|/* Definitely see tm-sparc.h for more doc of the frame format here.  */
end_comment

begin_function
name|void
name|sparc_pop_frame
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|struct
name|frame_info
modifier|*
name|frame
init|=
name|get_current_frame
argument_list|()
decl_stmt|;
specifier|register
name|CORE_ADDR
name|pc
decl_stmt|;
name|CORE_ADDR
modifier|*
name|fsr
decl_stmt|;
name|char
modifier|*
name|raw_buffer
decl_stmt|;
name|int
name|regnum
decl_stmt|;
name|fsr
operator|=
name|alloca
argument_list|(
name|NUM_REGS
operator|*
sizeof|sizeof
argument_list|(
name|CORE_ADDR
argument_list|)
argument_list|)
expr_stmt|;
name|raw_buffer
operator|=
name|alloca
argument_list|(
name|REGISTER_BYTES
argument_list|)
expr_stmt|;
name|sparc_frame_find_saved_regs
argument_list|(
name|frame
argument_list|,
operator|&
name|fsr
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|SPARC_HAS_FPU
condition|)
block|{
if|if
condition|(
name|fsr
index|[
name|FP0_REGNUM
index|]
condition|)
block|{
name|read_memory
argument_list|(
name|fsr
index|[
name|FP0_REGNUM
index|]
argument_list|,
name|raw_buffer
argument_list|,
name|FP_REGISTER_BYTES
argument_list|)
expr_stmt|;
name|write_register_bytes
argument_list|(
name|REGISTER_BYTE
argument_list|(
name|FP0_REGNUM
argument_list|)
argument_list|,
name|raw_buffer
argument_list|,
name|FP_REGISTER_BYTES
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|GDB_TARGET_IS_SPARC64
operator|)
condition|)
block|{
if|if
condition|(
name|fsr
index|[
name|FPS_REGNUM
index|]
condition|)
block|{
name|read_memory
argument_list|(
name|fsr
index|[
name|FPS_REGNUM
index|]
argument_list|,
name|raw_buffer
argument_list|,
name|SPARC_INTREG_SIZE
argument_list|)
expr_stmt|;
name|write_register_gen
argument_list|(
name|FPS_REGNUM
argument_list|,
name|raw_buffer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fsr
index|[
name|CPS_REGNUM
index|]
condition|)
block|{
name|read_memory
argument_list|(
name|fsr
index|[
name|CPS_REGNUM
index|]
argument_list|,
name|raw_buffer
argument_list|,
name|SPARC_INTREG_SIZE
argument_list|)
expr_stmt|;
name|write_register_gen
argument_list|(
name|CPS_REGNUM
argument_list|,
name|raw_buffer
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|fsr
index|[
name|G1_REGNUM
index|]
condition|)
block|{
name|read_memory
argument_list|(
name|fsr
index|[
name|G1_REGNUM
index|]
argument_list|,
name|raw_buffer
argument_list|,
literal|7
operator|*
name|SPARC_INTREG_SIZE
argument_list|)
expr_stmt|;
name|write_register_bytes
argument_list|(
name|REGISTER_BYTE
argument_list|(
name|G1_REGNUM
argument_list|)
argument_list|,
name|raw_buffer
argument_list|,
literal|7
operator|*
name|SPARC_INTREG_SIZE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|frame
operator|->
name|extra_info
operator|->
name|flat
condition|)
block|{
comment|/* Each register might or might not have been saved, need to test          individually.  */
for|for
control|(
name|regnum
operator|=
name|L0_REGNUM
init|;
name|regnum
operator|<
name|L0_REGNUM
operator|+
literal|8
condition|;
operator|++
name|regnum
control|)
if|if
condition|(
name|fsr
index|[
name|regnum
index|]
condition|)
name|write_register
argument_list|(
name|regnum
argument_list|,
name|read_memory_integer
argument_list|(
name|fsr
index|[
name|regnum
index|]
argument_list|,
name|SPARC_INTREG_SIZE
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|regnum
operator|=
name|I0_REGNUM
init|;
name|regnum
operator|<
name|I0_REGNUM
operator|+
literal|8
condition|;
operator|++
name|regnum
control|)
if|if
condition|(
name|fsr
index|[
name|regnum
index|]
condition|)
name|write_register
argument_list|(
name|regnum
argument_list|,
name|read_memory_integer
argument_list|(
name|fsr
index|[
name|regnum
index|]
argument_list|,
name|SPARC_INTREG_SIZE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Handle all outs except stack pointer (o0-o5; o7).  */
for|for
control|(
name|regnum
operator|=
name|O0_REGNUM
init|;
name|regnum
operator|<
name|O0_REGNUM
operator|+
literal|6
condition|;
operator|++
name|regnum
control|)
if|if
condition|(
name|fsr
index|[
name|regnum
index|]
condition|)
name|write_register
argument_list|(
name|regnum
argument_list|,
name|read_memory_integer
argument_list|(
name|fsr
index|[
name|regnum
index|]
argument_list|,
name|SPARC_INTREG_SIZE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fsr
index|[
name|O0_REGNUM
operator|+
literal|7
index|]
condition|)
name|write_register
argument_list|(
name|O0_REGNUM
operator|+
literal|7
argument_list|,
name|read_memory_integer
argument_list|(
name|fsr
index|[
name|O0_REGNUM
operator|+
literal|7
index|]
argument_list|,
name|SPARC_INTREG_SIZE
argument_list|)
argument_list|)
expr_stmt|;
name|write_sp
argument_list|(
name|frame
operator|->
name|frame
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fsr
index|[
name|I0_REGNUM
index|]
condition|)
block|{
name|CORE_ADDR
name|sp
decl_stmt|;
name|char
modifier|*
name|reg_temp
decl_stmt|;
name|reg_temp
operator|=
name|alloca
argument_list|(
name|REGISTER_BYTES
argument_list|)
expr_stmt|;
name|read_memory
argument_list|(
name|fsr
index|[
name|I0_REGNUM
index|]
argument_list|,
name|raw_buffer
argument_list|,
literal|8
operator|*
name|SPARC_INTREG_SIZE
argument_list|)
expr_stmt|;
comment|/* Get the ins and locals which we are about to restore.  Just          moving the stack pointer is all that is really needed, except          store_inferior_registers is then going to write the ins and          locals from the registers array, so we need to muck with the          registers array.  */
name|sp
operator|=
name|fsr
index|[
name|SP_REGNUM
index|]
expr_stmt|;
if|if
condition|(
name|GDB_TARGET_IS_SPARC64
operator|&&
operator|(
name|sp
operator|&
literal|1
operator|)
condition|)
name|sp
operator|+=
literal|2047
expr_stmt|;
name|read_memory
argument_list|(
name|sp
argument_list|,
name|reg_temp
argument_list|,
name|SPARC_INTREG_SIZE
operator|*
literal|16
argument_list|)
expr_stmt|;
comment|/* Restore the out registers.          Among other things this writes the new stack pointer.  */
name|write_register_bytes
argument_list|(
name|REGISTER_BYTE
argument_list|(
name|O0_REGNUM
argument_list|)
argument_list|,
name|raw_buffer
argument_list|,
name|SPARC_INTREG_SIZE
operator|*
literal|8
argument_list|)
expr_stmt|;
name|write_register_bytes
argument_list|(
name|REGISTER_BYTE
argument_list|(
name|L0_REGNUM
argument_list|)
argument_list|,
name|reg_temp
argument_list|,
name|SPARC_INTREG_SIZE
operator|*
literal|16
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|GDB_TARGET_IS_SPARC64
operator|)
condition|)
if|if
condition|(
name|fsr
index|[
name|PS_REGNUM
index|]
condition|)
name|write_register
argument_list|(
name|PS_REGNUM
argument_list|,
name|read_memory_integer
argument_list|(
name|fsr
index|[
name|PS_REGNUM
index|]
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|PS_REGNUM
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fsr
index|[
name|Y_REGNUM
index|]
condition|)
name|write_register
argument_list|(
name|Y_REGNUM
argument_list|,
name|read_memory_integer
argument_list|(
name|fsr
index|[
name|Y_REGNUM
index|]
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|Y_REGNUM
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fsr
index|[
name|PC_REGNUM
index|]
condition|)
block|{
comment|/* Explicitly specified PC (and maybe NPC) -- just restore them. */
name|write_register
argument_list|(
name|PC_REGNUM
argument_list|,
name|read_memory_integer
argument_list|(
name|fsr
index|[
name|PC_REGNUM
index|]
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|PC_REGNUM
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fsr
index|[
name|NPC_REGNUM
index|]
condition|)
name|write_register
argument_list|(
name|NPC_REGNUM
argument_list|,
name|read_memory_integer
argument_list|(
name|fsr
index|[
name|NPC_REGNUM
index|]
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|NPC_REGNUM
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|frame
operator|->
name|extra_info
operator|->
name|flat
condition|)
block|{
if|if
condition|(
name|frame
operator|->
name|extra_info
operator|->
name|pc_addr
condition|)
name|pc
operator|=
name|PC_ADJUST
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|read_memory_integer
argument_list|(
name|frame
operator|->
name|extra_info
operator|->
name|pc_addr
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|PC_REGNUM
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* I think this happens only in the innermost frame, if so then 	     it is a complicated way of saying 	     "pc = read_register (O7_REGNUM);".  */
name|char
modifier|*
name|buf
decl_stmt|;
name|buf
operator|=
name|alloca
argument_list|(
name|MAX_REGISTER_RAW_SIZE
argument_list|)
expr_stmt|;
name|get_saved_register
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|frame
argument_list|,
name|O7_REGNUM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pc
operator|=
name|PC_ADJUST
argument_list|(
name|extract_address
argument_list|(
name|buf
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|O7_REGNUM
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|write_register
argument_list|(
name|PC_REGNUM
argument_list|,
name|pc
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|NPC_REGNUM
argument_list|,
name|pc
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fsr
index|[
name|I7_REGNUM
index|]
condition|)
block|{
comment|/* Return address in %i7 -- adjust it, then restore PC and NPC from it */
name|pc
operator|=
name|PC_ADJUST
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|read_memory_integer
argument_list|(
name|fsr
index|[
name|I7_REGNUM
index|]
argument_list|,
name|SPARC_INTREG_SIZE
argument_list|)
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|PC_REGNUM
argument_list|,
name|pc
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|NPC_REGNUM
argument_list|,
name|pc
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
name|flush_cached_frames
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* On the Sun 4 under SunOS, the compile will leave a fake insn which    encodes the structure size being returned.  If we detect such    a fake insn, step past it.  */
end_comment

begin_function
name|CORE_ADDR
name|sparc_pc_adjust
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
name|unsigned
name|long
name|insn
decl_stmt|;
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
name|target_read_memory
argument_list|(
name|pc
operator|+
literal|8
argument_list|,
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|insn
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|==
literal|0
operator|)
operator|&&
operator|(
name|insn
operator|&
literal|0xffc00000
operator|)
operator|==
literal|0
condition|)
return|return
name|pc
operator|+
literal|12
return|;
else|else
return|return
name|pc
operator|+
literal|8
return|;
block|}
end_function

begin_comment
comment|/* If pc is in a shared library trampoline, return its target.    The SunOs 4.x linker rewrites the jump table entries for PIC    compiled modules in the main executable to bypass the dynamic linker    with jumps of the form    sethi %hi(addr),%g1    jmp %g1+%lo(addr)    and removes the corresponding jump table relocation entry in the    dynamic relocations.    find_solib_trampoline_target relies on the presence of the jump    table relocation entry, so we have to detect these jump instructions    by hand.  */
end_comment

begin_function
name|CORE_ADDR
name|sunos4_skip_trampoline_code
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
name|unsigned
name|long
name|insn1
decl_stmt|;
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
name|target_read_memory
argument_list|(
name|pc
argument_list|,
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|insn1
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
operator|&&
operator|(
name|insn1
operator|&
literal|0xffc00000
operator|)
operator|==
literal|0x03000000
condition|)
block|{
name|unsigned
name|long
name|insn2
decl_stmt|;
name|err
operator|=
name|target_read_memory
argument_list|(
name|pc
operator|+
literal|4
argument_list|,
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|insn2
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
operator|&&
operator|(
name|insn2
operator|&
literal|0xffffe000
operator|)
operator|==
literal|0x81c06000
condition|)
block|{
name|CORE_ADDR
name|target_pc
init|=
operator|(
name|insn1
operator|&
literal|0x3fffff
operator|)
operator|<<
literal|10
decl_stmt|;
name|int
name|delta
init|=
name|insn2
operator|&
literal|0x1fff
decl_stmt|;
comment|/* Sign extend the displacement.  */
if|if
condition|(
name|delta
operator|&
literal|0x1000
condition|)
name|delta
operator||=
operator|~
literal|0x1fff
expr_stmt|;
return|return
name|target_pc
operator|+
name|delta
return|;
block|}
block|}
return|return
name|find_solib_trampoline_target
argument_list|(
name|pc
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|USE_PROC_FS
end_ifdef

begin_comment
comment|/* Target dependent support for /proc */
end_comment

begin_comment
comment|/* *INDENT-OFF* */
end_comment

begin_comment
comment|/*  The /proc interface divides the target machine's register set up into     two different sets, the general register set (gregset) and the floating     point register set (fpregset).  For each set, there is an ioctl to get     the current register set and another ioctl to set the current values.      The actual structure passed through the ioctl interface is, of course,     naturally machine dependent, and is different for each set of registers.     For the sparc for example, the general register set is typically defined     by:  	typedef int gregset_t[38];  	#define	R_G0	0 	... 	#define	R_TBR	37      and the floating point set by:  	typedef struct prfpregset { 		union {  			u_long  pr_regs[32];  			double  pr_dregs[16]; 		} pr_fr; 		void *  pr_filler; 		u_long  pr_fsr; 		u_char  pr_qcnt; 		u_char  pr_q_entrysize; 		u_char  pr_en; 		u_long  pr_q[64]; 	} prfpregset_t;      These routines provide the packing and unpacking of gregset_t and     fpregset_t formatted data.   */
end_comment

begin_comment
comment|/* *INDENT-ON* */
end_comment

begin_comment
comment|/* Given a pointer to a general register set in /proc format (gregset_t *),    unpack the register contents and supply them as gdb's idea of the current    register values. */
end_comment

begin_function
name|void
name|supply_gregset
parameter_list|(
name|gdb_gregset_t
modifier|*
name|gregsetp
parameter_list|)
block|{
name|prgreg_t
modifier|*
name|regp
init|=
operator|(
name|prgreg_t
operator|*
operator|)
name|gregsetp
decl_stmt|;
name|int
name|regi
decl_stmt|,
name|offset
init|=
literal|0
decl_stmt|;
comment|/* If the host is 64-bit sparc, but the target is 32-bit sparc,       then the gregset may contain 64-bit ints while supply_register      is expecting 32-bit ints.  Compensate.  */
if|if
condition|(
sizeof|sizeof
argument_list|(
name|regp
index|[
literal|0
index|]
argument_list|)
operator|==
literal|8
operator|&&
name|SPARC_INTREG_SIZE
operator|==
literal|4
condition|)
name|offset
operator|=
literal|4
expr_stmt|;
comment|/* GDB register numbers for Gn, On, Ln, In all match /proc reg numbers.  */
comment|/* FIXME MVS: assumes the order of the first 32 elements... */
for|for
control|(
name|regi
operator|=
name|G0_REGNUM
init|;
name|regi
operator|<=
name|I7_REGNUM
condition|;
name|regi
operator|++
control|)
block|{
name|supply_register
argument_list|(
name|regi
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
name|regi
operator|)
operator|)
operator|+
name|offset
argument_list|)
expr_stmt|;
block|}
comment|/* These require a bit more care.  */
name|supply_register
argument_list|(
name|PC_REGNUM
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
name|R_PC
operator|)
operator|)
operator|+
name|offset
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|NPC_REGNUM
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
name|R_nPC
operator|)
operator|)
operator|+
name|offset
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|Y_REGNUM
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
name|R_Y
operator|)
operator|)
operator|+
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|GDB_TARGET_IS_SPARC64
condition|)
block|{
ifdef|#
directive|ifdef
name|R_CCR
name|supply_register
argument_list|(
name|CCR_REGNUM
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
name|R_CCR
operator|)
operator|)
operator|+
name|offset
argument_list|)
expr_stmt|;
else|#
directive|else
name|supply_register
argument_list|(
name|CCR_REGNUM
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|R_FPRS
name|supply_register
argument_list|(
name|FPRS_REGNUM
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
name|R_FPRS
operator|)
operator|)
operator|+
name|offset
argument_list|)
expr_stmt|;
else|#
directive|else
name|supply_register
argument_list|(
name|FPRS_REGNUM
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|R_ASI
name|supply_register
argument_list|(
name|ASI_REGNUM
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
name|R_ASI
operator|)
operator|)
operator|+
name|offset
argument_list|)
expr_stmt|;
else|#
directive|else
name|supply_register
argument_list|(
name|ASI_REGNUM
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
comment|/* sparc32 */
block|{
ifdef|#
directive|ifdef
name|R_PS
name|supply_register
argument_list|(
name|PS_REGNUM
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
name|R_PS
operator|)
operator|)
operator|+
name|offset
argument_list|)
expr_stmt|;
else|#
directive|else
name|supply_register
argument_list|(
name|PS_REGNUM
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* For 64-bit hosts, R_WIM and R_TBR may not be defined. 	 Steal R_ASI and R_FPRS, and hope for the best!  */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|R_WIM
argument_list|)
operator|&&
name|defined
argument_list|(
name|R_ASI
argument_list|)
define|#
directive|define
name|R_WIM
value|R_ASI
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|R_TBR
argument_list|)
operator|&&
name|defined
argument_list|(
name|R_FPRS
argument_list|)
define|#
directive|define
name|R_TBR
value|R_FPRS
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|R_WIM
argument_list|)
name|supply_register
argument_list|(
name|WIM_REGNUM
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
name|R_WIM
operator|)
operator|)
operator|+
name|offset
argument_list|)
expr_stmt|;
else|#
directive|else
name|supply_register
argument_list|(
name|WIM_REGNUM
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|R_TBR
argument_list|)
name|supply_register
argument_list|(
name|TBR_REGNUM
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
name|R_TBR
operator|)
operator|)
operator|+
name|offset
argument_list|)
expr_stmt|;
else|#
directive|else
name|supply_register
argument_list|(
name|TBR_REGNUM
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Fill inaccessible registers with zero.  */
if|if
condition|(
name|GDB_TARGET_IS_SPARC64
condition|)
block|{
comment|/*        * don't know how to get value of any of the following:        */
name|supply_register
argument_list|(
name|VER_REGNUM
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|TICK_REGNUM
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|PIL_REGNUM
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|PSTATE_REGNUM
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|TSTATE_REGNUM
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|TBA_REGNUM
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|TL_REGNUM
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|TT_REGNUM
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|TPC_REGNUM
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|TNPC_REGNUM
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|WSTATE_REGNUM
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|CWP_REGNUM
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|CANSAVE_REGNUM
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|CANRESTORE_REGNUM
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|CLEANWIN_REGNUM
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|OTHERWIN_REGNUM
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|ASR16_REGNUM
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|ASR17_REGNUM
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|ASR18_REGNUM
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|ASR19_REGNUM
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|ASR20_REGNUM
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|ASR21_REGNUM
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|ASR22_REGNUM
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|ASR23_REGNUM
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|ASR24_REGNUM
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|ASR25_REGNUM
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|ASR26_REGNUM
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|ASR27_REGNUM
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|ASR28_REGNUM
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|ASR29_REGNUM
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|ASR30_REGNUM
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|ASR31_REGNUM
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|ICC_REGNUM
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|XCC_REGNUM
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|supply_register
argument_list|(
name|CPS_REGNUM
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|fill_gregset
parameter_list|(
name|gdb_gregset_t
modifier|*
name|gregsetp
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
name|prgreg_t
modifier|*
name|regp
init|=
operator|(
name|prgreg_t
operator|*
operator|)
name|gregsetp
decl_stmt|;
name|int
name|regi
decl_stmt|,
name|offset
init|=
literal|0
decl_stmt|;
comment|/* If the host is 64-bit sparc, but the target is 32-bit sparc,       then the gregset may contain 64-bit ints while supply_register      is expecting 32-bit ints.  Compensate.  */
if|if
condition|(
sizeof|sizeof
argument_list|(
name|regp
index|[
literal|0
index|]
argument_list|)
operator|==
literal|8
operator|&&
name|SPARC_INTREG_SIZE
operator|==
literal|4
condition|)
name|offset
operator|=
literal|4
expr_stmt|;
for|for
control|(
name|regi
operator|=
literal|0
init|;
name|regi
operator|<=
name|R_I7
condition|;
name|regi
operator|++
control|)
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|regno
operator|==
name|regi
operator|)
condition|)
name|read_register_gen
argument_list|(
name|regi
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
name|regi
operator|)
operator|+
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|regno
operator|==
name|PC_REGNUM
operator|)
condition|)
name|read_register_gen
argument_list|(
name|PC_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
name|R_PC
operator|)
operator|+
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|regno
operator|==
name|NPC_REGNUM
operator|)
condition|)
name|read_register_gen
argument_list|(
name|NPC_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
name|R_nPC
operator|)
operator|+
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|regno
operator|==
name|Y_REGNUM
operator|)
condition|)
name|read_register_gen
argument_list|(
name|Y_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
name|R_Y
operator|)
operator|+
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|GDB_TARGET_IS_SPARC64
condition|)
block|{
ifdef|#
directive|ifdef
name|R_CCR
if|if
condition|(
name|regno
operator|==
operator|-
literal|1
operator|||
name|regno
operator|==
name|CCR_REGNUM
condition|)
name|read_register_gen
argument_list|(
name|CCR_REGNUM
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
name|R_CCR
operator|)
operator|)
operator|+
name|offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|R_FPRS
if|if
condition|(
name|regno
operator|==
operator|-
literal|1
operator|||
name|regno
operator|==
name|FPRS_REGNUM
condition|)
name|read_register_gen
argument_list|(
name|FPRS_REGNUM
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
name|R_FPRS
operator|)
operator|)
operator|+
name|offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|R_ASI
if|if
condition|(
name|regno
operator|==
operator|-
literal|1
operator|||
name|regno
operator|==
name|ASI_REGNUM
condition|)
name|read_register_gen
argument_list|(
name|ASI_REGNUM
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
name|R_ASI
operator|)
operator|)
operator|+
name|offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
comment|/* sparc32 */
block|{
ifdef|#
directive|ifdef
name|R_PS
if|if
condition|(
name|regno
operator|==
operator|-
literal|1
operator|||
name|regno
operator|==
name|PS_REGNUM
condition|)
name|read_register_gen
argument_list|(
name|PS_REGNUM
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
name|R_PS
operator|)
operator|)
operator|+
name|offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* For 64-bit hosts, R_WIM and R_TBR may not be defined. 	 Steal R_ASI and R_FPRS, and hope for the best!  */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|R_WIM
argument_list|)
operator|&&
name|defined
argument_list|(
name|R_ASI
argument_list|)
define|#
directive|define
name|R_WIM
value|R_ASI
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|R_TBR
argument_list|)
operator|&&
name|defined
argument_list|(
name|R_FPRS
argument_list|)
define|#
directive|define
name|R_TBR
value|R_FPRS
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|R_WIM
argument_list|)
if|if
condition|(
name|regno
operator|==
operator|-
literal|1
operator|||
name|regno
operator|==
name|WIM_REGNUM
condition|)
name|read_register_gen
argument_list|(
name|WIM_REGNUM
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
name|R_WIM
operator|)
operator|)
operator|+
name|offset
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|regno
operator|==
operator|-
literal|1
operator|||
name|regno
operator|==
name|WIM_REGNUM
condition|)
name|read_register_gen
argument_list|(
name|WIM_REGNUM
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|R_TBR
argument_list|)
if|if
condition|(
name|regno
operator|==
operator|-
literal|1
operator|||
name|regno
operator|==
name|TBR_REGNUM
condition|)
name|read_register_gen
argument_list|(
name|TBR_REGNUM
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
name|R_TBR
operator|)
operator|)
operator|+
name|offset
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|regno
operator|==
operator|-
literal|1
operator|||
name|regno
operator|==
name|TBR_REGNUM
condition|)
name|read_register_gen
argument_list|(
name|TBR_REGNUM
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/*  Given a pointer to a floating point register set in /proc format    (fpregset_t *), unpack the register contents and supply them as gdb's    idea of the current floating point register values. */
end_comment

begin_function
name|void
name|supply_fpregset
parameter_list|(
name|gdb_fpregset_t
modifier|*
name|fpregsetp
parameter_list|)
block|{
specifier|register
name|int
name|regi
decl_stmt|;
name|char
modifier|*
name|from
decl_stmt|;
if|if
condition|(
operator|!
name|SPARC_HAS_FPU
condition|)
return|return;
for|for
control|(
name|regi
operator|=
name|FP0_REGNUM
init|;
name|regi
operator|<
name|FP_MAX_REGNUM
condition|;
name|regi
operator|++
control|)
block|{
name|from
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|fpregsetp
operator|->
name|pr_fr
operator|.
name|pr_regs
index|[
name|regi
operator|-
name|FP0_REGNUM
index|]
expr_stmt|;
name|supply_register
argument_list|(
name|regi
argument_list|,
name|from
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GDB_TARGET_IS_SPARC64
condition|)
block|{
comment|/*        * don't know how to get value of the following.          */
name|supply_register
argument_list|(
name|FSR_REGNUM
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* zero it out for now */
name|supply_register
argument_list|(
name|FCC0_REGNUM
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|FCC1_REGNUM
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* don't know how to get value */
name|supply_register
argument_list|(
name|FCC2_REGNUM
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* don't know how to get value */
name|supply_register
argument_list|(
name|FCC3_REGNUM
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* don't know how to get value */
block|}
else|else
block|{
name|supply_register
argument_list|(
name|FPS_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|fpregsetp
operator|->
name|pr_fsr
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  Given a pointer to a floating point register set in /proc format    (fpregset_t *), update the register specified by REGNO from gdb's idea    of the current floating point register set.  If REGNO is -1, update    them all. */
end_comment

begin_comment
comment|/* This will probably need some changes for sparc64.  */
end_comment

begin_function
name|void
name|fill_fpregset
parameter_list|(
name|gdb_fpregset_t
modifier|*
name|fpregsetp
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
name|int
name|regi
decl_stmt|;
name|char
modifier|*
name|to
decl_stmt|;
name|char
modifier|*
name|from
decl_stmt|;
if|if
condition|(
operator|!
name|SPARC_HAS_FPU
condition|)
return|return;
for|for
control|(
name|regi
operator|=
name|FP0_REGNUM
init|;
name|regi
operator|<
name|FP_MAX_REGNUM
condition|;
name|regi
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|regno
operator|==
name|regi
operator|)
condition|)
block|{
name|from
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|regi
argument_list|)
index|]
expr_stmt|;
name|to
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|fpregsetp
operator|->
name|pr_fr
operator|.
name|pr_regs
index|[
name|regi
operator|-
name|FP0_REGNUM
index|]
expr_stmt|;
name|memcpy
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regi
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|GDB_TARGET_IS_SPARC64
operator|)
condition|)
comment|/* FIXME: does Sparc64 have this register? */
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|regno
operator|==
name|FPS_REGNUM
operator|)
condition|)
block|{
name|from
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|FPS_REGNUM
argument_list|)
index|]
expr_stmt|;
name|to
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|fpregsetp
operator|->
name|pr_fsr
expr_stmt|;
name|memcpy
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|FPS_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_PROC_FS */
end_comment

begin_comment
comment|/* Because of Multi-arch, GET_LONGJMP_TARGET is always defined.  So test    for a definition of JB_PC.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|JB_PC
end_ifdef

begin_comment
comment|/* Figure out where the longjmp will land.  We expect that we have just entered    longjmp and haven't yet setup the stack frame, so the args are still in the    output regs.  %o0 (O0_REGNUM) points at the jmp_buf structure from which we    extract the pc (JB_PC) that we will land at.  The pc is copied into ADDR.    This routine returns true on success */
end_comment

begin_function
name|int
name|get_longjmp_target
parameter_list|(
name|CORE_ADDR
modifier|*
name|pc
parameter_list|)
block|{
name|CORE_ADDR
name|jb_addr
decl_stmt|;
define|#
directive|define
name|LONGJMP_TARGET_SIZE
value|4
name|char
name|buf
index|[
name|LONGJMP_TARGET_SIZE
index|]
decl_stmt|;
name|jb_addr
operator|=
name|read_register
argument_list|(
name|O0_REGNUM
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_read_memory
argument_list|(
name|jb_addr
operator|+
name|JB_PC
operator|*
name|JB_ELEMENT_SIZE
argument_list|,
name|buf
argument_list|,
name|LONGJMP_TARGET_SIZE
argument_list|)
condition|)
return|return
literal|0
return|;
operator|*
name|pc
operator|=
name|extract_address
argument_list|(
name|buf
argument_list|,
name|LONGJMP_TARGET_SIZE
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* GET_LONGJMP_TARGET */
end_comment

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|STATIC_TRANSFORM_NAME
end_ifdef

begin_comment
comment|/* SunPRO (3.0 at least), encodes the static variables.  This is not    related to C++ mangling, it is done for C too.  */
end_comment

begin_function
name|char
modifier|*
name|sunpro_static_transform_name
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'$'
condition|)
block|{
comment|/* For file-local statics there will be a dollar sign, a bunch          of junk (the contents of which match a string given in the          N_OPT), a period and the name.  For function-local statics          there will be a bunch of junk (which seems to change the          second character from 'A' to 'B'), a period, the name of the          function, and the name.  So just skip everything before the          last period.  */
name|p
operator|=
name|strrchr
argument_list|(
name|name
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
name|name
operator|=
name|p
operator|+
literal|1
expr_stmt|;
block|}
return|return
name|name
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* STATIC_TRANSFORM_NAME */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Utilities for printing registers.    Page numbers refer to the SPARC Architecture Manual.  */
end_comment

begin_function_decl
specifier|static
name|void
name|dump_ccreg
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|dump_ccreg
parameter_list|(
name|char
modifier|*
name|reg
parameter_list|,
name|int
name|val
parameter_list|)
block|{
comment|/* page 41 */
name|printf_unfiltered
argument_list|(
literal|"%s:%s,%s,%s,%s"
argument_list|,
name|reg
argument_list|,
name|val
operator|&
literal|8
condition|?
literal|"N"
else|:
literal|"NN"
argument_list|,
name|val
operator|&
literal|4
condition|?
literal|"Z"
else|:
literal|"NZ"
argument_list|,
name|val
operator|&
literal|2
condition|?
literal|"O"
else|:
literal|"NO"
argument_list|,
name|val
operator|&
literal|1
condition|?
literal|"C"
else|:
literal|"NC"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|decode_asi
parameter_list|(
name|int
name|val
parameter_list|)
block|{
comment|/* page 72 */
switch|switch
condition|(
name|val
condition|)
block|{
case|case
literal|4
case|:
return|return
literal|"ASI_NUCLEUS"
return|;
case|case
literal|0x0c
case|:
return|return
literal|"ASI_NUCLEUS_LITTLE"
return|;
case|case
literal|0x10
case|:
return|return
literal|"ASI_AS_IF_USER_PRIMARY"
return|;
case|case
literal|0x11
case|:
return|return
literal|"ASI_AS_IF_USER_SECONDARY"
return|;
case|case
literal|0x18
case|:
return|return
literal|"ASI_AS_IF_USER_PRIMARY_LITTLE"
return|;
case|case
literal|0x19
case|:
return|return
literal|"ASI_AS_IF_USER_SECONDARY_LITTLE"
return|;
case|case
literal|0x80
case|:
return|return
literal|"ASI_PRIMARY"
return|;
case|case
literal|0x81
case|:
return|return
literal|"ASI_SECONDARY"
return|;
case|case
literal|0x82
case|:
return|return
literal|"ASI_PRIMARY_NOFAULT"
return|;
case|case
literal|0x83
case|:
return|return
literal|"ASI_SECONDARY_NOFAULT"
return|;
case|case
literal|0x88
case|:
return|return
literal|"ASI_PRIMARY_LITTLE"
return|;
case|case
literal|0x89
case|:
return|return
literal|"ASI_SECONDARY_LITTLE"
return|;
case|case
literal|0x8a
case|:
return|return
literal|"ASI_PRIMARY_NOFAULT_LITTLE"
return|;
case|case
literal|0x8b
case|:
return|return
literal|"ASI_SECONDARY_NOFAULT_LITTLE"
return|;
default|default:
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_comment
comment|/* PRINT_REGISTER_HOOK routine.    Pretty print various registers.  */
end_comment

begin_comment
comment|/* FIXME: Would be nice if this did some fancy things for 32 bit sparc.  */
end_comment

begin_function
name|void
name|sparc_print_register_hook
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
name|ULONGEST
name|val
decl_stmt|;
comment|/* Handle double/quad versions of lower 32 fp regs.  */
if|if
condition|(
name|regno
operator|>=
name|FP0_REGNUM
operator|&&
name|regno
operator|<
name|FP0_REGNUM
operator|+
literal|32
operator|&&
operator|(
name|regno
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
name|char
name|value
index|[
literal|16
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|read_relative_register_raw_bytes
argument_list|(
name|regno
argument_list|,
name|value
argument_list|)
operator|&&
operator|!
name|read_relative_register_raw_bytes
argument_list|(
name|regno
operator|+
literal|1
argument_list|,
name|value
operator|+
literal|4
argument_list|)
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
name|print_floating
argument_list|(
name|value
argument_list|,
name|builtin_type_double
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* FIXME: gdb doesn't handle long doubles */
block|if ((regno& 3) == 0) 	{ 	  if (!read_relative_register_raw_bytes (regno + 2, value + 8)&& !read_relative_register_raw_bytes (regno + 3, value + 12)) 	    { 	      printf_unfiltered ("\t"); 	      print_floating (value, builtin_type_long_double, gdb_stdout); 	    } 	}
endif|#
directive|endif
return|return;
block|}
if|#
directive|if
literal|0
comment|/* FIXME: gdb doesn't handle long doubles */
comment|/* Print upper fp regs as long double if appropriate.  */
block|if (regno>= FP0_REGNUM + 32&& regno< FP_MAX_REGNUM
comment|/* We test for even numbered regs and not a multiple of 4 because      the upper fp regs are recorded as doubles.  */
block|&& (regno& 1) == 0)     {       char value[16];        if (!read_relative_register_raw_bytes (regno, value)&& !read_relative_register_raw_bytes (regno + 1, value + 8)) 	{ 	  printf_unfiltered ("\t"); 	  print_floating (value, builtin_type_long_double, gdb_stdout); 	}       return;     }
endif|#
directive|endif
comment|/* FIXME: Some of these are priviledged registers.      Not sure how they should be handled.  */
define|#
directive|define
name|BITS
parameter_list|(
name|n
parameter_list|,
name|mask
parameter_list|)
value|((int) (((val)>> (n))& (mask)))
name|val
operator|=
name|read_register
argument_list|(
name|regno
argument_list|)
expr_stmt|;
comment|/* pages 40 - 60 */
if|if
condition|(
name|GDB_TARGET_IS_SPARC64
condition|)
switch|switch
condition|(
name|regno
condition|)
block|{
case|case
name|CCR_REGNUM
case|:
name|printf_unfiltered
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
name|dump_ccreg
argument_list|(
literal|"xcc"
argument_list|,
name|val
operator|>>
literal|4
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|dump_ccreg
argument_list|(
literal|"icc"
argument_list|,
name|val
operator|&
literal|15
argument_list|)
expr_stmt|;
break|break;
case|case
name|FPRS_REGNUM
case|:
name|printf
argument_list|(
literal|"\tfef:%d, du:%d, dl:%d"
argument_list|,
name|BITS
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|)
argument_list|,
name|BITS
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
argument_list|,
name|BITS
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FSR_REGNUM
case|:
block|{
specifier|static
name|char
modifier|*
name|fcc
index|[
literal|4
index|]
init|=
block|{
literal|"="
block|,
literal|"<"
block|,
literal|">"
block|,
literal|"?"
block|}
decl_stmt|;
specifier|static
name|char
modifier|*
name|rd
index|[
literal|4
index|]
init|=
block|{
literal|"N"
block|,
literal|"0"
block|,
literal|"+"
block|,
literal|"-"
block|}
decl_stmt|;
comment|/* Long, but I'd rather leave it as is and use a wide screen.  */
name|printf_filtered
argument_list|(
literal|"\t0:%s, 1:%s, 2:%s, 3:%s, rd:%s, tem:%d, "
argument_list|,
name|fcc
index|[
name|BITS
argument_list|(
literal|10
argument_list|,
literal|3
argument_list|)
index|]
argument_list|,
name|fcc
index|[
name|BITS
argument_list|(
literal|32
argument_list|,
literal|3
argument_list|)
index|]
argument_list|,
name|fcc
index|[
name|BITS
argument_list|(
literal|34
argument_list|,
literal|3
argument_list|)
index|]
argument_list|,
name|fcc
index|[
name|BITS
argument_list|(
literal|36
argument_list|,
literal|3
argument_list|)
index|]
argument_list|,
name|rd
index|[
name|BITS
argument_list|(
literal|30
argument_list|,
literal|3
argument_list|)
index|]
argument_list|,
name|BITS
argument_list|(
literal|23
argument_list|,
literal|31
argument_list|)
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"ns:%d, ver:%d, ftt:%d, qne:%d, aexc:%d, cexc:%d"
argument_list|,
name|BITS
argument_list|(
literal|22
argument_list|,
literal|1
argument_list|)
argument_list|,
name|BITS
argument_list|(
literal|17
argument_list|,
literal|7
argument_list|)
argument_list|,
name|BITS
argument_list|(
literal|14
argument_list|,
literal|7
argument_list|)
argument_list|,
name|BITS
argument_list|(
literal|13
argument_list|,
literal|1
argument_list|)
argument_list|,
name|BITS
argument_list|(
literal|5
argument_list|,
literal|31
argument_list|)
argument_list|,
name|BITS
argument_list|(
literal|0
argument_list|,
literal|31
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|ASI_REGNUM
case|:
block|{
name|char
modifier|*
name|asi
init|=
name|decode_asi
argument_list|(
name|val
argument_list|)
decl_stmt|;
if|if
condition|(
name|asi
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"\t%s"
argument_list|,
name|asi
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|VER_REGNUM
case|:
name|printf
argument_list|(
literal|"\tmanuf:%d, impl:%d, mask:%d, maxtl:%d, maxwin:%d"
argument_list|,
name|BITS
argument_list|(
literal|48
argument_list|,
literal|0xffff
argument_list|)
argument_list|,
name|BITS
argument_list|(
literal|32
argument_list|,
literal|0xffff
argument_list|)
argument_list|,
name|BITS
argument_list|(
literal|24
argument_list|,
literal|0xff
argument_list|)
argument_list|,
name|BITS
argument_list|(
literal|8
argument_list|,
literal|0xff
argument_list|)
argument_list|,
name|BITS
argument_list|(
literal|0
argument_list|,
literal|31
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|PSTATE_REGNUM
case|:
block|{
specifier|static
name|char
modifier|*
name|mm
index|[
literal|4
index|]
init|=
block|{
literal|"tso"
block|,
literal|"pso"
block|,
literal|"rso"
block|,
literal|"?"
block|}
decl_stmt|;
name|printf_filtered
argument_list|(
literal|"\tcle:%d, tle:%d, mm:%s, red:%d, "
argument_list|,
name|BITS
argument_list|(
literal|9
argument_list|,
literal|1
argument_list|)
argument_list|,
name|BITS
argument_list|(
literal|8
argument_list|,
literal|1
argument_list|)
argument_list|,
name|mm
index|[
name|BITS
argument_list|(
literal|6
argument_list|,
literal|3
argument_list|)
index|]
argument_list|,
name|BITS
argument_list|(
literal|5
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"pef:%d, am:%d, priv:%d, ie:%d, ag:%d"
argument_list|,
name|BITS
argument_list|(
literal|4
argument_list|,
literal|1
argument_list|)
argument_list|,
name|BITS
argument_list|(
literal|3
argument_list|,
literal|1
argument_list|)
argument_list|,
name|BITS
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|)
argument_list|,
name|BITS
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
argument_list|,
name|BITS
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|TSTATE_REGNUM
case|:
comment|/* FIXME: print all 4? */
break|break;
case|case
name|TT_REGNUM
case|:
comment|/* FIXME: print all 4? */
break|break;
case|case
name|TPC_REGNUM
case|:
comment|/* FIXME: print all 4? */
break|break;
case|case
name|TNPC_REGNUM
case|:
comment|/* FIXME: print all 4? */
break|break;
case|case
name|WSTATE_REGNUM
case|:
name|printf
argument_list|(
literal|"\tother:%d, normal:%d"
argument_list|,
name|BITS
argument_list|(
literal|3
argument_list|,
literal|7
argument_list|)
argument_list|,
name|BITS
argument_list|(
literal|0
argument_list|,
literal|7
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CWP_REGNUM
case|:
name|printf
argument_list|(
literal|"\t%d"
argument_list|,
name|BITS
argument_list|(
literal|0
argument_list|,
literal|31
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CANSAVE_REGNUM
case|:
name|printf
argument_list|(
literal|"\t%-2d before spill"
argument_list|,
name|BITS
argument_list|(
literal|0
argument_list|,
literal|31
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CANRESTORE_REGNUM
case|:
name|printf
argument_list|(
literal|"\t%-2d before fill"
argument_list|,
name|BITS
argument_list|(
literal|0
argument_list|,
literal|31
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CLEANWIN_REGNUM
case|:
name|printf
argument_list|(
literal|"\t%-2d before clean"
argument_list|,
name|BITS
argument_list|(
literal|0
argument_list|,
literal|31
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|OTHERWIN_REGNUM
case|:
name|printf
argument_list|(
literal|"\t%d"
argument_list|,
name|BITS
argument_list|(
literal|0
argument_list|,
literal|31
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
comment|/* Sparc32 */
switch|switch
condition|(
name|regno
condition|)
block|{
case|case
name|PS_REGNUM
case|:
name|printf
argument_list|(
literal|"\ticc:%c%c%c%c, pil:%d, s:%d, ps:%d, et:%d, cwp:%d"
argument_list|,
name|BITS
argument_list|(
literal|23
argument_list|,
literal|1
argument_list|)
condition|?
literal|'N'
else|:
literal|'-'
argument_list|,
name|BITS
argument_list|(
literal|22
argument_list|,
literal|1
argument_list|)
condition|?
literal|'Z'
else|:
literal|'-'
argument_list|,
name|BITS
argument_list|(
literal|21
argument_list|,
literal|1
argument_list|)
condition|?
literal|'V'
else|:
literal|'-'
argument_list|,
name|BITS
argument_list|(
literal|20
argument_list|,
literal|1
argument_list|)
condition|?
literal|'C'
else|:
literal|'-'
argument_list|,
name|BITS
argument_list|(
literal|8
argument_list|,
literal|15
argument_list|)
argument_list|,
name|BITS
argument_list|(
literal|7
argument_list|,
literal|1
argument_list|)
argument_list|,
name|BITS
argument_list|(
literal|6
argument_list|,
literal|1
argument_list|)
argument_list|,
name|BITS
argument_list|(
literal|5
argument_list|,
literal|1
argument_list|)
argument_list|,
name|BITS
argument_list|(
literal|0
argument_list|,
literal|31
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FPS_REGNUM
case|:
block|{
specifier|static
name|char
modifier|*
name|fcc
index|[
literal|4
index|]
init|=
block|{
literal|"="
block|,
literal|"<"
block|,
literal|">"
block|,
literal|"?"
block|}
decl_stmt|;
specifier|static
name|char
modifier|*
name|rd
index|[
literal|4
index|]
init|=
block|{
literal|"N"
block|,
literal|"0"
block|,
literal|"+"
block|,
literal|"-"
block|}
decl_stmt|;
comment|/* Long, but I'd rather leave it as is and use a wide screen.  */
name|printf
argument_list|(
literal|"\trd:%s, tem:%d, ns:%d, ver:%d, ftt:%d, qne:%d, "
literal|"fcc:%s, aexc:%d, cexc:%d"
argument_list|,
name|rd
index|[
name|BITS
argument_list|(
literal|30
argument_list|,
literal|3
argument_list|)
index|]
argument_list|,
name|BITS
argument_list|(
literal|23
argument_list|,
literal|31
argument_list|)
argument_list|,
name|BITS
argument_list|(
literal|22
argument_list|,
literal|1
argument_list|)
argument_list|,
name|BITS
argument_list|(
literal|17
argument_list|,
literal|7
argument_list|)
argument_list|,
name|BITS
argument_list|(
literal|14
argument_list|,
literal|7
argument_list|)
argument_list|,
name|BITS
argument_list|(
literal|13
argument_list|,
literal|1
argument_list|)
argument_list|,
name|fcc
index|[
name|BITS
argument_list|(
literal|10
argument_list|,
literal|3
argument_list|)
index|]
argument_list|,
name|BITS
argument_list|(
literal|5
argument_list|,
literal|31
argument_list|)
argument_list|,
name|BITS
argument_list|(
literal|0
argument_list|,
literal|31
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
undef|#
directive|undef
name|BITS
block|}
end_function

begin_escape
end_escape

begin_function
name|int
name|gdb_print_insn_sparc
parameter_list|(
name|bfd_vma
name|memaddr
parameter_list|,
name|disassemble_info
modifier|*
name|info
parameter_list|)
block|{
comment|/* It's necessary to override mach again because print_insn messes it up. */
name|info
operator|->
name|mach
operator|=
name|TARGET_ARCHITECTURE
operator|->
name|mach
expr_stmt|;
return|return
name|print_insn_sparc
argument_list|(
name|memaddr
argument_list|,
name|info
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The SPARC passes the arguments on the stack; arguments smaller    than an int are promoted to an int.  The first 6 words worth of     args are also passed in registers o0 - o5.  */
end_comment

begin_function
name|CORE_ADDR
name|sparc32_push_arguments
parameter_list|(
name|int
name|nargs
parameter_list|,
name|struct
name|value
modifier|*
modifier|*
name|args
parameter_list|,
name|CORE_ADDR
name|sp
parameter_list|,
name|int
name|struct_return
parameter_list|,
name|CORE_ADDR
name|struct_addr
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|oregnum
decl_stmt|;
name|int
name|accumulate_size
init|=
literal|0
decl_stmt|;
struct|struct
name|sparc_arg
block|{
name|char
modifier|*
name|contents
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|offset
decl_stmt|;
block|}
struct|;
name|struct
name|sparc_arg
modifier|*
name|sparc_args
init|=
operator|(
expr|struct
name|sparc_arg
operator|*
operator|)
name|alloca
argument_list|(
name|nargs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sparc_arg
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|sparc_arg
modifier|*
name|m_arg
decl_stmt|;
comment|/* Promote arguments if necessary, and calculate their stack offsets      and sizes. */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|m_arg
operator|=
name|sparc_args
init|;
name|i
operator|<
name|nargs
condition|;
name|i
operator|++
operator|,
name|m_arg
operator|++
control|)
block|{
name|struct
name|value
modifier|*
name|arg
init|=
name|args
index|[
name|i
index|]
decl_stmt|;
name|struct
name|type
modifier|*
name|arg_type
init|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Cast argument to long if necessary as the compiler does it too.  */
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|arg_type
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_INT
case|:
case|case
name|TYPE_CODE_BOOL
case|:
case|case
name|TYPE_CODE_CHAR
case|:
case|case
name|TYPE_CODE_RANGE
case|:
case|case
name|TYPE_CODE_ENUM
case|:
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|arg_type
argument_list|)
operator|<
name|TYPE_LENGTH
argument_list|(
name|builtin_type_long
argument_list|)
condition|)
block|{
name|arg_type
operator|=
name|builtin_type_long
expr_stmt|;
name|arg
operator|=
name|value_cast
argument_list|(
name|arg_type
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
name|m_arg
operator|->
name|len
operator|=
name|TYPE_LENGTH
argument_list|(
name|arg_type
argument_list|)
expr_stmt|;
name|m_arg
operator|->
name|offset
operator|=
name|accumulate_size
expr_stmt|;
name|accumulate_size
operator|=
operator|(
name|accumulate_size
operator|+
name|m_arg
operator|->
name|len
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
expr_stmt|;
name|m_arg
operator|->
name|contents
operator|=
name|VALUE_CONTENTS
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
comment|/* Make room for the arguments on the stack.  */
name|accumulate_size
operator|+=
name|CALL_DUMMY_STACK_ADJUST
expr_stmt|;
name|sp
operator|=
operator|(
operator|(
name|sp
operator|-
name|accumulate_size
operator|)
operator|&
operator|~
literal|7
operator|)
operator|+
name|CALL_DUMMY_STACK_ADJUST
expr_stmt|;
comment|/* `Push' arguments on the stack.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|oregnum
operator|=
literal|0
operator|,
name|m_arg
operator|=
name|sparc_args
init|;
name|i
operator|<
name|nargs
condition|;
name|i
operator|++
operator|,
name|m_arg
operator|++
control|)
block|{
name|write_memory
argument_list|(
name|sp
operator|+
name|m_arg
operator|->
name|offset
argument_list|,
name|m_arg
operator|->
name|contents
argument_list|,
name|m_arg
operator|->
name|len
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|m_arg
operator|->
name|len
operator|&&
name|oregnum
operator|<
literal|6
condition|;
name|j
operator|+=
name|SPARC_INTREG_SIZE
operator|,
name|oregnum
operator|++
control|)
name|write_register_gen
argument_list|(
name|O0_REGNUM
operator|+
name|oregnum
argument_list|,
name|m_arg
operator|->
name|contents
operator|+
name|j
argument_list|)
expr_stmt|;
block|}
return|return
name|sp
return|;
block|}
end_function

begin_comment
comment|/* Extract from an array REGBUF containing the (raw) register state    a function return value of type TYPE, and copy that, in virtual format,    into VALBUF.  */
end_comment

begin_function
name|void
name|sparc32_extract_return_value
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|char
modifier|*
name|regbuf
parameter_list|,
name|char
modifier|*
name|valbuf
parameter_list|)
block|{
name|int
name|typelen
init|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|regsize
init|=
name|REGISTER_RAW_SIZE
argument_list|(
name|O0_REGNUM
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_FLT
operator|&&
name|SPARC_HAS_FPU
condition|)
name|memcpy
argument_list|(
name|valbuf
argument_list|,
operator|&
name|regbuf
index|[
name|REGISTER_BYTE
argument_list|(
name|FP0_REGNUM
argument_list|)
index|]
argument_list|,
name|typelen
argument_list|)
expr_stmt|;
else|else
name|memcpy
argument_list|(
name|valbuf
argument_list|,
operator|&
name|regbuf
index|[
name|O0_REGNUM
operator|*
name|regsize
operator|+
operator|(
name|typelen
operator|>=
name|regsize
operator|||
name|TARGET_BYTE_ORDER
operator|==
name|BFD_ENDIAN_LITTLE
condition|?
literal|0
else|:
name|regsize
operator|-
name|typelen
operator|)
index|]
argument_list|,
name|typelen
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write into appropriate registers a function return value    of type TYPE, given in virtual format.  On SPARCs with FPUs,    float values are returned in %f0 (and %f1).  In all other cases,    values are returned in register %o0.  */
end_comment

begin_function
name|void
name|sparc_store_return_value
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|char
modifier|*
name|valbuf
parameter_list|)
block|{
name|int
name|regno
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
name|buffer
operator|=
name|alloca
argument_list|(
name|MAX_REGISTER_RAW_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_FLT
operator|&&
name|SPARC_HAS_FPU
condition|)
comment|/* Floating-point values are returned in the register pair */
comment|/* formed by %f0 and %f1 (doubles are, anyway).  */
name|regno
operator|=
name|FP0_REGNUM
expr_stmt|;
else|else
comment|/* Other values are returned in register %o0.  */
name|regno
operator|=
name|O0_REGNUM
expr_stmt|;
comment|/* Add leading zeros to the value. */
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|<
name|REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
condition|)
block|{
name|memset
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buffer
operator|+
name|REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
operator|-
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|,
name|valbuf
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|write_register_gen
argument_list|(
name|regno
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
else|else
name|write_register_bytes
argument_list|(
name|REGISTER_BYTE
argument_list|(
name|regno
argument_list|)
argument_list|,
name|valbuf
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|extern
name|void
name|sparclet_store_return_value
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|char
modifier|*
name|valbuf
parameter_list|)
block|{
comment|/* Other values are returned in register %o0.  */
name|write_register_bytes
argument_list|(
name|REGISTER_BYTE
argument_list|(
name|O0_REGNUM
argument_list|)
argument_list|,
name|valbuf
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|CALL_DUMMY_CALL_OFFSET
end_ifndef

begin_define
define|#
directive|define
name|CALL_DUMMY_CALL_OFFSET
define|\
value|(gdbarch_tdep (current_gdbarch)->call_dummy_call_offset)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CALL_DUMMY_CALL_OFFSET */
end_comment

begin_comment
comment|/* Insert the function address into a call dummy instruction sequence    stored at DUMMY.     For structs and unions, if the function was compiled with Sun cc,    it expects 'unimp' after the call.  But gcc doesn't use that    (twisted) convention.  So leave a nop there for gcc (FIX_CALL_DUMMY    can assume it is operating on a pristine CALL_DUMMY, not one that    has already been customized for a different function).  */
end_comment

begin_function
name|void
name|sparc_fix_call_dummy
parameter_list|(
name|char
modifier|*
name|dummy
parameter_list|,
name|CORE_ADDR
name|pc
parameter_list|,
name|CORE_ADDR
name|fun
parameter_list|,
name|struct
name|type
modifier|*
name|value_type
parameter_list|,
name|int
name|using_gcc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Store the relative adddress of the target function into the      'call' instruction. */
name|store_unsigned_integer
argument_list|(
name|dummy
operator|+
name|CALL_DUMMY_CALL_OFFSET
argument_list|,
literal|4
argument_list|,
operator|(
literal|0x40000000
operator||
operator|(
operator|(
operator|(
name|fun
operator|-
operator|(
name|pc
operator|+
name|CALL_DUMMY_CALL_OFFSET
operator|)
operator|)
operator|>>
literal|2
operator|)
operator|&
literal|0x3fffffff
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* If the called function returns an aggregate value, fill in the UNIMP      instruction containing the size of the returned aggregate return value,      which follows the call instruction.      For details see the SPARC Architecture Manual Version 8, Appendix D.3.       Adjust the call_dummy_breakpoint_offset for the bp_call_dummy breakpoint      to the proper address in the call dummy, so that `finish' after a stop      in a call dummy works.      Tweeking current_gdbarch is not an optimal solution, but the call to      sparc_fix_call_dummy is immediately followed by a call to run_stack_dummy,      which is the only function where dummy_breakpoint_offset is actually      used, if it is non-zero.  */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|value_type
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
operator|||
name|TYPE_CODE
argument_list|(
name|value_type
argument_list|)
operator|==
name|TYPE_CODE_UNION
condition|)
block|{
name|store_unsigned_integer
argument_list|(
name|dummy
operator|+
name|CALL_DUMMY_CALL_OFFSET
operator|+
literal|8
argument_list|,
literal|4
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|value_type
argument_list|)
operator|&
literal|0x1fff
argument_list|)
expr_stmt|;
name|set_gdbarch_call_dummy_breakpoint_offset
argument_list|(
name|current_gdbarch
argument_list|,
literal|0x30
argument_list|)
expr_stmt|;
block|}
else|else
name|set_gdbarch_call_dummy_breakpoint_offset
argument_list|(
name|current_gdbarch
argument_list|,
literal|0x2c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|GDB_TARGET_IS_SPARC64
operator|)
condition|)
block|{
comment|/* If this is not a simulator target, change the first four 	 instructions of the call dummy to NOPs.  Those instructions 	 include a 'save' instruction and are designed to work around 	 problems with register window flushing in the simulator. */
if|if
condition|(
name|strcmp
argument_list|(
name|target_shortname
argument_list|,
literal|"sim"
argument_list|)
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|store_unsigned_integer
argument_list|(
name|dummy
operator|+
operator|(
name|i
operator|*
literal|4
operator|)
argument_list|,
literal|4
argument_list|,
literal|0x01000000
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If this is a bi-endian target, GDB has written the call dummy      in little-endian order.  We must byte-swap it back to big-endian. */
if|if
condition|(
name|bi_endian
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CALL_DUMMY_LENGTH
condition|;
name|i
operator|+=
literal|4
control|)
block|{
name|char
name|tmp
init|=
name|dummy
index|[
name|i
index|]
decl_stmt|;
name|dummy
index|[
name|i
index|]
operator|=
name|dummy
index|[
name|i
operator|+
literal|3
index|]
expr_stmt|;
name|dummy
index|[
name|i
operator|+
literal|3
index|]
operator|=
name|tmp
expr_stmt|;
name|tmp
operator|=
name|dummy
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|dummy
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|dummy
index|[
name|i
operator|+
literal|2
index|]
expr_stmt|;
name|dummy
index|[
name|i
operator|+
literal|2
index|]
operator|=
name|tmp
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Set target byte order based on machine type. */
end_comment

begin_function
specifier|static
name|int
name|sparc_target_architecture_hook
parameter_list|(
specifier|const
name|bfd_arch_info_type
modifier|*
name|ap
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|ap
operator|->
name|mach
operator|==
name|bfd_mach_sparc_sparclite_le
condition|)
block|{
name|target_byte_order
operator|=
name|BFD_ENDIAN_LITTLE
expr_stmt|;
name|bi_endian
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|bi_endian
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Module "constructor" function.   */
end_comment

begin_function_decl
specifier|static
name|struct
name|gdbarch
modifier|*
name|sparc_gdbarch_init
parameter_list|(
name|struct
name|gdbarch_info
name|info
parameter_list|,
name|struct
name|gdbarch_list
modifier|*
name|arches
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|_initialize_sparc_tdep
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Hook us into the gdbarch mechanism.  */
name|register_gdbarch_init
argument_list|(
name|bfd_arch_sparc
argument_list|,
name|sparc_gdbarch_init
argument_list|)
expr_stmt|;
name|tm_print_insn
operator|=
name|gdb_print_insn_sparc
expr_stmt|;
name|tm_print_insn_info
operator|.
name|mach
operator|=
name|TM_PRINT_INSN_MACH
expr_stmt|;
comment|/* Selects sparc/sparclite */
name|target_architecture_hook
operator|=
name|sparc_target_architecture_hook
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compensate for stack bias. Note that we currently don't handle    mixed 32/64 bit code. */
end_comment

begin_function
name|CORE_ADDR
name|sparc64_read_sp
parameter_list|(
name|void
parameter_list|)
block|{
name|CORE_ADDR
name|sp
init|=
name|read_register
argument_list|(
name|SP_REGNUM
argument_list|)
decl_stmt|;
if|if
condition|(
name|sp
operator|&
literal|1
condition|)
name|sp
operator|+=
literal|2047
expr_stmt|;
return|return
name|sp
return|;
block|}
end_function

begin_function
name|CORE_ADDR
name|sparc64_read_fp
parameter_list|(
name|void
parameter_list|)
block|{
name|CORE_ADDR
name|fp
init|=
name|read_register
argument_list|(
name|FP_REGNUM
argument_list|)
decl_stmt|;
if|if
condition|(
name|fp
operator|&
literal|1
condition|)
name|fp
operator|+=
literal|2047
expr_stmt|;
return|return
name|fp
return|;
block|}
end_function

begin_function
name|void
name|sparc64_write_sp
parameter_list|(
name|CORE_ADDR
name|val
parameter_list|)
block|{
name|CORE_ADDR
name|oldsp
init|=
name|read_register
argument_list|(
name|SP_REGNUM
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldsp
operator|&
literal|1
condition|)
name|write_register
argument_list|(
name|SP_REGNUM
argument_list|,
name|val
operator|-
literal|2047
argument_list|)
expr_stmt|;
else|else
name|write_register
argument_list|(
name|SP_REGNUM
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sparc64_write_fp
parameter_list|(
name|CORE_ADDR
name|val
parameter_list|)
block|{
name|CORE_ADDR
name|oldfp
init|=
name|read_register
argument_list|(
name|FP_REGNUM
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldfp
operator|&
literal|1
condition|)
name|write_register
argument_list|(
name|FP_REGNUM
argument_list|,
name|val
operator|-
literal|2047
argument_list|)
expr_stmt|;
else|else
name|write_register
argument_list|(
name|FP_REGNUM
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The SPARC 64 ABI passes floating-point arguments in FP0 to FP31,    and all other arguments in O0 to O5.  They are also copied onto    the stack in the correct places.  Apparently (empirically),     structs of less than 16 bytes are passed member-by-member in    separate registers, but I am unable to figure out the algorithm.    Some members go in floating point regs, but I don't know which.     FIXME: Handle small structs (less than 16 bytes containing floats).     The counting regimen for using both integer and FP registers    for argument passing is rather odd -- a single counter is used    for both; this means that if the arguments alternate between    int and float, we will waste every other register of both types.  */
end_comment

begin_function
name|CORE_ADDR
name|sparc64_push_arguments
parameter_list|(
name|int
name|nargs
parameter_list|,
name|struct
name|value
modifier|*
modifier|*
name|args
parameter_list|,
name|CORE_ADDR
name|sp
parameter_list|,
name|int
name|struct_return
parameter_list|,
name|CORE_ADDR
name|struct_retaddr
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|register_counter
init|=
literal|0
decl_stmt|;
name|CORE_ADDR
name|tempsp
decl_stmt|;
name|struct
name|type
modifier|*
name|sparc_intreg_type
init|=
name|TYPE_LENGTH
argument_list|(
name|builtin_type_long
argument_list|)
operator|==
name|SPARC_INTREG_SIZE
condition|?
name|builtin_type_long
else|:
name|builtin_type_long_long
decl_stmt|;
name|sp
operator|=
operator|(
name|sp
operator|&
operator|~
operator|(
operator|(
operator|(
name|unsigned
name|long
operator|)
name|SPARC_INTREG_SIZE
operator|)
operator|-
literal|1UL
operator|)
operator|)
expr_stmt|;
comment|/* Figure out how much space we'll need. */
for|for
control|(
name|i
operator|=
name|nargs
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|int
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|value
modifier|*
name|copyarg
init|=
name|args
index|[
name|i
index|]
decl_stmt|;
name|int
name|copylen
init|=
name|len
decl_stmt|;
if|if
condition|(
name|copylen
operator|<
name|SPARC_INTREG_SIZE
condition|)
block|{
name|copyarg
operator|=
name|value_cast
argument_list|(
name|sparc_intreg_type
argument_list|,
name|copyarg
argument_list|)
expr_stmt|;
name|copylen
operator|=
name|SPARC_INTREG_SIZE
expr_stmt|;
block|}
name|sp
operator|-=
name|copylen
expr_stmt|;
block|}
comment|/* Round down. */
name|sp
operator|=
name|sp
operator|&
operator|~
literal|7
expr_stmt|;
name|tempsp
operator|=
name|sp
expr_stmt|;
comment|/* if STRUCT_RETURN, then first argument is the struct return location. */
if|if
condition|(
name|struct_return
condition|)
name|write_register
argument_list|(
name|O0_REGNUM
operator|+
name|register_counter
operator|++
argument_list|,
name|struct_retaddr
argument_list|)
expr_stmt|;
comment|/* Now write the arguments onto the stack, while writing FP      arguments into the FP registers, and other arguments into the      first six 'O' registers.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nargs
condition|;
name|i
operator|++
control|)
block|{
name|int
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|value
modifier|*
name|copyarg
init|=
name|args
index|[
name|i
index|]
decl_stmt|;
name|enum
name|type_code
name|typecode
init|=
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|copylen
init|=
name|len
decl_stmt|;
if|if
condition|(
name|typecode
operator|==
name|TYPE_CODE_INT
operator|||
name|typecode
operator|==
name|TYPE_CODE_BOOL
operator|||
name|typecode
operator|==
name|TYPE_CODE_CHAR
operator|||
name|typecode
operator|==
name|TYPE_CODE_RANGE
operator|||
name|typecode
operator|==
name|TYPE_CODE_ENUM
condition|)
if|if
condition|(
name|len
operator|<
name|SPARC_INTREG_SIZE
condition|)
block|{
comment|/* Small ints will all take up the size of one intreg on 	       the stack.  */
name|copyarg
operator|=
name|value_cast
argument_list|(
name|sparc_intreg_type
argument_list|,
name|copyarg
argument_list|)
expr_stmt|;
name|copylen
operator|=
name|SPARC_INTREG_SIZE
expr_stmt|;
block|}
name|write_memory
argument_list|(
name|tempsp
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|copyarg
argument_list|)
argument_list|,
name|copylen
argument_list|)
expr_stmt|;
name|tempsp
operator|+=
name|copylen
expr_stmt|;
comment|/* Corner case: Structs consisting of a single float member are floats.        * FIXME!  I don't know about structs containing multiple floats!        * Structs containing mixed floats and ints are even more weird.        */
comment|/* Separate float args from all other args.  */
if|if
condition|(
name|typecode
operator|==
name|TYPE_CODE_FLT
operator|&&
name|SPARC_HAS_FPU
condition|)
block|{
if|if
condition|(
name|register_counter
operator|<
literal|16
condition|)
block|{
comment|/* This arg gets copied into a FP register. */
name|int
name|fpreg
decl_stmt|;
switch|switch
condition|(
name|len
condition|)
block|{
case|case
literal|4
case|:
comment|/* Single-precision (float) */
name|fpreg
operator|=
name|FP0_REGNUM
operator|+
literal|2
operator|*
name|register_counter
operator|+
literal|1
expr_stmt|;
name|register_counter
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
literal|8
case|:
comment|/* Double-precision (double) */
name|fpreg
operator|=
name|FP0_REGNUM
operator|+
literal|2
operator|*
name|register_counter
expr_stmt|;
name|register_counter
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
literal|16
case|:
comment|/* Quad-precision (long double) */
name|fpreg
operator|=
name|FP0_REGNUM
operator|+
literal|2
operator|*
name|register_counter
expr_stmt|;
name|register_counter
operator|+=
literal|2
expr_stmt|;
break|break;
default|default:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"bad switch"
argument_list|)
expr_stmt|;
block|}
name|write_register_bytes
argument_list|(
name|REGISTER_BYTE
argument_list|(
name|fpreg
argument_list|)
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
else|else
comment|/* all other args go into the first six 'o' registers */
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|len
operator|&&
name|register_counter
operator|<
literal|6
condition|;
name|j
operator|+=
name|SPARC_INTREG_SIZE
control|)
block|{
name|int
name|oreg
init|=
name|O0_REGNUM
operator|+
name|register_counter
decl_stmt|;
name|write_register_gen
argument_list|(
name|oreg
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|copyarg
argument_list|)
operator|+
name|j
argument_list|)
expr_stmt|;
name|register_counter
operator|+=
literal|1
expr_stmt|;
block|}
block|}
block|}
return|return
name|sp
return|;
block|}
end_function

begin_comment
comment|/* Values<= 32 bytes are returned in o0-o3 (floating-point values are    returned in f0-f3). */
end_comment

begin_function
name|void
name|sp64_extract_return_value
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|char
modifier|*
name|regbuf
parameter_list|,
name|char
modifier|*
name|valbuf
parameter_list|,
name|int
name|bitoffset
parameter_list|)
block|{
name|int
name|typelen
init|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|regsize
init|=
name|REGISTER_RAW_SIZE
argument_list|(
name|O0_REGNUM
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_FLT
operator|&&
name|SPARC_HAS_FPU
condition|)
block|{
name|memcpy
argument_list|(
name|valbuf
argument_list|,
operator|&
name|regbuf
index|[
name|REGISTER_BYTE
argument_list|(
name|FP0_REGNUM
argument_list|)
index|]
argument_list|,
name|typelen
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_CODE_STRUCT
operator|||
operator|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|>
literal|32
operator|)
condition|)
block|{
name|memcpy
argument_list|(
name|valbuf
argument_list|,
operator|&
name|regbuf
index|[
name|O0_REGNUM
operator|*
name|regsize
operator|+
operator|(
name|typelen
operator|>=
name|regsize
condition|?
literal|0
else|:
name|regsize
operator|-
name|typelen
operator|)
index|]
argument_list|,
name|typelen
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|char
modifier|*
name|o0
init|=
operator|&
name|regbuf
index|[
name|O0_REGNUM
operator|*
name|regsize
index|]
decl_stmt|;
name|char
modifier|*
name|f0
init|=
operator|&
name|regbuf
index|[
name|FP0_REGNUM
operator|*
name|regsize
index|]
decl_stmt|;
name|int
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
condition|;
name|x
operator|++
control|)
block|{
name|struct
name|field
modifier|*
name|f
init|=
operator|&
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
index|[
name|x
index|]
decl_stmt|;
comment|/* FIXME: We may need to handle static fields here. */
name|int
name|whichreg
init|=
operator|(
name|f
operator|->
name|loc
operator|.
name|bitpos
operator|+
name|bitoffset
operator|)
operator|/
literal|32
decl_stmt|;
name|int
name|remainder
init|=
operator|(
operator|(
name|f
operator|->
name|loc
operator|.
name|bitpos
operator|+
name|bitoffset
operator|)
operator|%
literal|32
operator|)
operator|/
literal|8
decl_stmt|;
name|int
name|where
init|=
operator|(
name|f
operator|->
name|loc
operator|.
name|bitpos
operator|+
name|bitoffset
operator|)
operator|/
literal|8
decl_stmt|;
name|int
name|size
init|=
name|TYPE_LENGTH
argument_list|(
name|f
operator|->
name|type
argument_list|)
decl_stmt|;
name|int
name|typecode
init|=
name|TYPE_CODE
argument_list|(
name|f
operator|->
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|typecode
operator|==
name|TYPE_CODE_STRUCT
condition|)
block|{
name|sp64_extract_return_value
argument_list|(
name|f
operator|->
name|type
argument_list|,
name|regbuf
argument_list|,
name|valbuf
argument_list|,
name|bitoffset
operator|+
name|f
operator|->
name|loc
operator|.
name|bitpos
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|typecode
operator|==
name|TYPE_CODE_FLT
operator|&&
name|SPARC_HAS_FPU
condition|)
block|{
name|memcpy
argument_list|(
name|valbuf
operator|+
name|where
argument_list|,
operator|&
name|f0
index|[
name|whichreg
operator|*
literal|4
index|]
operator|+
name|remainder
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|valbuf
operator|+
name|where
argument_list|,
operator|&
name|o0
index|[
name|whichreg
operator|*
literal|4
index|]
operator|+
name|remainder
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|extern
name|void
name|sparc64_extract_return_value
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|char
modifier|*
name|regbuf
parameter_list|,
name|char
modifier|*
name|valbuf
parameter_list|)
block|{
name|sp64_extract_return_value
argument_list|(
name|type
argument_list|,
name|regbuf
argument_list|,
name|valbuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|extern
name|void
name|sparclet_extract_return_value
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|char
modifier|*
name|regbuf
parameter_list|,
name|char
modifier|*
name|valbuf
parameter_list|)
block|{
name|regbuf
operator|+=
name|REGISTER_RAW_SIZE
argument_list|(
name|O0_REGNUM
argument_list|)
operator|*
literal|8
expr_stmt|;
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|<
name|REGISTER_RAW_SIZE
argument_list|(
name|O0_REGNUM
argument_list|)
condition|)
name|regbuf
operator|+=
name|REGISTER_RAW_SIZE
argument_list|(
name|O0_REGNUM
argument_list|)
operator|-
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|void
operator|*
operator|)
name|valbuf
argument_list|,
name|regbuf
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|extern
name|CORE_ADDR
name|sparc32_stack_align
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|)
block|{
return|return
operator|(
operator|(
name|addr
operator|+
literal|7
operator|)
operator|&
operator|-
literal|8
operator|)
return|;
block|}
end_function

begin_function
specifier|extern
name|CORE_ADDR
name|sparc64_stack_align
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|)
block|{
return|return
operator|(
operator|(
name|addr
operator|+
literal|15
operator|)
operator|&
operator|-
literal|16
operator|)
return|;
block|}
end_function

begin_function
specifier|extern
name|void
name|sparc_print_extra_frame_info
parameter_list|(
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|)
block|{
if|if
condition|(
name|fi
operator|&&
name|fi
operator|->
name|extra_info
operator|&&
name|fi
operator|->
name|extra_info
operator|->
name|flat
condition|)
name|printf_filtered
argument_list|(
literal|" flat, pc saved at 0x%s, fp saved at 0x%s\n"
argument_list|,
name|paddr_nz
argument_list|(
name|fi
operator|->
name|extra_info
operator|->
name|pc_addr
argument_list|)
argument_list|,
name|paddr_nz
argument_list|(
name|fi
operator|->
name|extra_info
operator|->
name|fp_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* MULTI_ARCH support */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|sparc32_register_name
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|register_names
index|[]
init|=
block|{
literal|"g0"
block|,
literal|"g1"
block|,
literal|"g2"
block|,
literal|"g3"
block|,
literal|"g4"
block|,
literal|"g5"
block|,
literal|"g6"
block|,
literal|"g7"
block|,
literal|"o0"
block|,
literal|"o1"
block|,
literal|"o2"
block|,
literal|"o3"
block|,
literal|"o4"
block|,
literal|"o5"
block|,
literal|"sp"
block|,
literal|"o7"
block|,
literal|"l0"
block|,
literal|"l1"
block|,
literal|"l2"
block|,
literal|"l3"
block|,
literal|"l4"
block|,
literal|"l5"
block|,
literal|"l6"
block|,
literal|"l7"
block|,
literal|"i0"
block|,
literal|"i1"
block|,
literal|"i2"
block|,
literal|"i3"
block|,
literal|"i4"
block|,
literal|"i5"
block|,
literal|"fp"
block|,
literal|"i7"
block|,
literal|"f0"
block|,
literal|"f1"
block|,
literal|"f2"
block|,
literal|"f3"
block|,
literal|"f4"
block|,
literal|"f5"
block|,
literal|"f6"
block|,
literal|"f7"
block|,
literal|"f8"
block|,
literal|"f9"
block|,
literal|"f10"
block|,
literal|"f11"
block|,
literal|"f12"
block|,
literal|"f13"
block|,
literal|"f14"
block|,
literal|"f15"
block|,
literal|"f16"
block|,
literal|"f17"
block|,
literal|"f18"
block|,
literal|"f19"
block|,
literal|"f20"
block|,
literal|"f21"
block|,
literal|"f22"
block|,
literal|"f23"
block|,
literal|"f24"
block|,
literal|"f25"
block|,
literal|"f26"
block|,
literal|"f27"
block|,
literal|"f28"
block|,
literal|"f29"
block|,
literal|"f30"
block|,
literal|"f31"
block|,
literal|"y"
block|,
literal|"psr"
block|,
literal|"wim"
block|,
literal|"tbr"
block|,
literal|"pc"
block|,
literal|"npc"
block|,
literal|"fpsr"
block|,
literal|"cpsr"
block|}
decl_stmt|;
if|if
condition|(
name|regno
operator|<
literal|0
operator|||
name|regno
operator|>=
operator|(
sizeof|sizeof
argument_list|(
name|register_names
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|register_names
index|[
literal|0
index|]
argument_list|)
operator|)
condition|)
return|return
name|NULL
return|;
else|else
return|return
name|register_names
index|[
name|regno
index|]
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|sparc64_register_name
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|register_names
index|[]
init|=
block|{
literal|"g0"
block|,
literal|"g1"
block|,
literal|"g2"
block|,
literal|"g3"
block|,
literal|"g4"
block|,
literal|"g5"
block|,
literal|"g6"
block|,
literal|"g7"
block|,
literal|"o0"
block|,
literal|"o1"
block|,
literal|"o2"
block|,
literal|"o3"
block|,
literal|"o4"
block|,
literal|"o5"
block|,
literal|"sp"
block|,
literal|"o7"
block|,
literal|"l0"
block|,
literal|"l1"
block|,
literal|"l2"
block|,
literal|"l3"
block|,
literal|"l4"
block|,
literal|"l5"
block|,
literal|"l6"
block|,
literal|"l7"
block|,
literal|"i0"
block|,
literal|"i1"
block|,
literal|"i2"
block|,
literal|"i3"
block|,
literal|"i4"
block|,
literal|"i5"
block|,
literal|"fp"
block|,
literal|"i7"
block|,
literal|"f0"
block|,
literal|"f1"
block|,
literal|"f2"
block|,
literal|"f3"
block|,
literal|"f4"
block|,
literal|"f5"
block|,
literal|"f6"
block|,
literal|"f7"
block|,
literal|"f8"
block|,
literal|"f9"
block|,
literal|"f10"
block|,
literal|"f11"
block|,
literal|"f12"
block|,
literal|"f13"
block|,
literal|"f14"
block|,
literal|"f15"
block|,
literal|"f16"
block|,
literal|"f17"
block|,
literal|"f18"
block|,
literal|"f19"
block|,
literal|"f20"
block|,
literal|"f21"
block|,
literal|"f22"
block|,
literal|"f23"
block|,
literal|"f24"
block|,
literal|"f25"
block|,
literal|"f26"
block|,
literal|"f27"
block|,
literal|"f28"
block|,
literal|"f29"
block|,
literal|"f30"
block|,
literal|"f31"
block|,
literal|"f32"
block|,
literal|"f34"
block|,
literal|"f36"
block|,
literal|"f38"
block|,
literal|"f40"
block|,
literal|"f42"
block|,
literal|"f44"
block|,
literal|"f46"
block|,
literal|"f48"
block|,
literal|"f50"
block|,
literal|"f52"
block|,
literal|"f54"
block|,
literal|"f56"
block|,
literal|"f58"
block|,
literal|"f60"
block|,
literal|"f62"
block|,
literal|"pc"
block|,
literal|"npc"
block|,
literal|"ccr"
block|,
literal|"fsr"
block|,
literal|"fprs"
block|,
literal|"y"
block|,
literal|"asi"
block|,
literal|"ver"
block|,
literal|"tick"
block|,
literal|"pil"
block|,
literal|"pstate"
block|,
literal|"tstate"
block|,
literal|"tba"
block|,
literal|"tl"
block|,
literal|"tt"
block|,
literal|"tpc"
block|,
literal|"tnpc"
block|,
literal|"wstate"
block|,
literal|"cwp"
block|,
literal|"cansave"
block|,
literal|"canrestore"
block|,
literal|"cleanwin"
block|,
literal|"otherwin"
block|,
literal|"asr16"
block|,
literal|"asr17"
block|,
literal|"asr18"
block|,
literal|"asr19"
block|,
literal|"asr20"
block|,
literal|"asr21"
block|,
literal|"asr22"
block|,
literal|"asr23"
block|,
literal|"asr24"
block|,
literal|"asr25"
block|,
literal|"asr26"
block|,
literal|"asr27"
block|,
literal|"asr28"
block|,
literal|"asr29"
block|,
literal|"asr30"
block|,
literal|"asr31"
block|,
comment|/* These are here at the end to simplify removing them if we have to.  */
literal|"icc"
block|,
literal|"xcc"
block|,
literal|"fcc0"
block|,
literal|"fcc1"
block|,
literal|"fcc2"
block|,
literal|"fcc3"
block|}
decl_stmt|;
if|if
condition|(
name|regno
operator|<
literal|0
operator|||
name|regno
operator|>=
operator|(
sizeof|sizeof
argument_list|(
name|register_names
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|register_names
index|[
literal|0
index|]
argument_list|)
operator|)
condition|)
return|return
name|NULL
return|;
else|else
return|return
name|register_names
index|[
name|regno
index|]
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|sparclite_register_name
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|register_names
index|[]
init|=
block|{
literal|"g0"
block|,
literal|"g1"
block|,
literal|"g2"
block|,
literal|"g3"
block|,
literal|"g4"
block|,
literal|"g5"
block|,
literal|"g6"
block|,
literal|"g7"
block|,
literal|"o0"
block|,
literal|"o1"
block|,
literal|"o2"
block|,
literal|"o3"
block|,
literal|"o4"
block|,
literal|"o5"
block|,
literal|"sp"
block|,
literal|"o7"
block|,
literal|"l0"
block|,
literal|"l1"
block|,
literal|"l2"
block|,
literal|"l3"
block|,
literal|"l4"
block|,
literal|"l5"
block|,
literal|"l6"
block|,
literal|"l7"
block|,
literal|"i0"
block|,
literal|"i1"
block|,
literal|"i2"
block|,
literal|"i3"
block|,
literal|"i4"
block|,
literal|"i5"
block|,
literal|"fp"
block|,
literal|"i7"
block|,
literal|"f0"
block|,
literal|"f1"
block|,
literal|"f2"
block|,
literal|"f3"
block|,
literal|"f4"
block|,
literal|"f5"
block|,
literal|"f6"
block|,
literal|"f7"
block|,
literal|"f8"
block|,
literal|"f9"
block|,
literal|"f10"
block|,
literal|"f11"
block|,
literal|"f12"
block|,
literal|"f13"
block|,
literal|"f14"
block|,
literal|"f15"
block|,
literal|"f16"
block|,
literal|"f17"
block|,
literal|"f18"
block|,
literal|"f19"
block|,
literal|"f20"
block|,
literal|"f21"
block|,
literal|"f22"
block|,
literal|"f23"
block|,
literal|"f24"
block|,
literal|"f25"
block|,
literal|"f26"
block|,
literal|"f27"
block|,
literal|"f28"
block|,
literal|"f29"
block|,
literal|"f30"
block|,
literal|"f31"
block|,
literal|"y"
block|,
literal|"psr"
block|,
literal|"wim"
block|,
literal|"tbr"
block|,
literal|"pc"
block|,
literal|"npc"
block|,
literal|"fpsr"
block|,
literal|"cpsr"
block|,
literal|"dia1"
block|,
literal|"dia2"
block|,
literal|"dda1"
block|,
literal|"dda2"
block|,
literal|"ddv1"
block|,
literal|"ddv2"
block|,
literal|"dcr"
block|,
literal|"dsr"
block|}
decl_stmt|;
if|if
condition|(
name|regno
operator|<
literal|0
operator|||
name|regno
operator|>=
operator|(
sizeof|sizeof
argument_list|(
name|register_names
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|register_names
index|[
literal|0
index|]
argument_list|)
operator|)
condition|)
return|return
name|NULL
return|;
else|else
return|return
name|register_names
index|[
name|regno
index|]
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|sparclet_register_name
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|register_names
index|[]
init|=
block|{
literal|"g0"
block|,
literal|"g1"
block|,
literal|"g2"
block|,
literal|"g3"
block|,
literal|"g4"
block|,
literal|"g5"
block|,
literal|"g6"
block|,
literal|"g7"
block|,
literal|"o0"
block|,
literal|"o1"
block|,
literal|"o2"
block|,
literal|"o3"
block|,
literal|"o4"
block|,
literal|"o5"
block|,
literal|"sp"
block|,
literal|"o7"
block|,
literal|"l0"
block|,
literal|"l1"
block|,
literal|"l2"
block|,
literal|"l3"
block|,
literal|"l4"
block|,
literal|"l5"
block|,
literal|"l6"
block|,
literal|"l7"
block|,
literal|"i0"
block|,
literal|"i1"
block|,
literal|"i2"
block|,
literal|"i3"
block|,
literal|"i4"
block|,
literal|"i5"
block|,
literal|"fp"
block|,
literal|"i7"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
comment|/* no floating point registers */
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|"y"
block|,
literal|"psr"
block|,
literal|"wim"
block|,
literal|"tbr"
block|,
literal|"pc"
block|,
literal|"npc"
block|,
literal|""
block|,
literal|""
block|,
comment|/* no FPSR or CPSR */
literal|"ccsr"
block|,
literal|"ccpr"
block|,
literal|"cccrcr"
block|,
literal|"ccor"
block|,
literal|"ccobr"
block|,
literal|"ccibr"
block|,
literal|"ccir"
block|,
literal|""
block|,
comment|/*       ASR15                 ASR19 (don't display them) */
literal|"asr1"
block|,
literal|""
block|,
literal|"asr17"
block|,
literal|"asr18"
block|,
literal|""
block|,
literal|"asr20"
block|,
literal|"asr21"
block|,
literal|"asr22"
comment|/* None of the rest get displayed */
if|#
directive|if
literal|0
block|"awr0",  "awr1",  "awr2",  "awr3",  "awr4",  "awr5",  "awr6",  "awr7",       "awr8",  "awr9",  "awr10", "awr11", "awr12", "awr13", "awr14", "awr15",      "awr16", "awr17", "awr18", "awr19", "awr20", "awr21", "awr22", "awr23",      "awr24", "awr25", "awr26", "awr27", "awr28", "awr29", "awr30", "awr31",      "apsr"
endif|#
directive|endif
comment|/* 0 */
block|}
decl_stmt|;
if|if
condition|(
name|regno
operator|<
literal|0
operator|||
name|regno
operator|>=
operator|(
sizeof|sizeof
argument_list|(
name|register_names
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|register_names
index|[
literal|0
index|]
argument_list|)
operator|)
condition|)
return|return
name|NULL
return|;
else|else
return|return
name|register_names
index|[
name|regno
index|]
return|;
block|}
end_function

begin_function
name|CORE_ADDR
name|sparc_push_return_address
parameter_list|(
name|CORE_ADDR
name|pc_unused
parameter_list|,
name|CORE_ADDR
name|sp
parameter_list|)
block|{
if|if
condition|(
name|CALL_DUMMY_LOCATION
operator|==
name|AT_ENTRY_POINT
condition|)
block|{
comment|/* The return PC of the dummy_frame is the former 'current' PC 	 (where we were before we made the target function call). 	 This is saved in %i7 by push_dummy_frame.  	 We will save the 'call dummy location' (ie. the address 	 to which the target function will return) in %o7.   	 This address will actually be the program's entry point.   	 There will be a special call_dummy breakpoint there.  */
name|write_register
argument_list|(
name|O7_REGNUM
argument_list|,
name|CALL_DUMMY_ADDRESS
argument_list|()
operator|-
literal|8
argument_list|)
expr_stmt|;
block|}
return|return
name|sp
return|;
block|}
end_function

begin_comment
comment|/* Should call_function allocate stack space for a struct return?  */
end_comment

begin_function
specifier|static
name|int
name|sparc64_use_struct_convention
parameter_list|(
name|int
name|gcc_p
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
return|return
operator|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|>
literal|32
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Store the address of the place in which to copy the structure the    subroutine will return.  This is called from call_function_by_hand.    The ultimate mystery is, tho, what is the value "16"?     MVS: That's the offset from where the sp is now, to where the    subroutine is gonna expect to find the struct return address.  */
end_comment

begin_function
specifier|static
name|void
name|sparc32_store_struct_return
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|CORE_ADDR
name|sp
parameter_list|)
block|{
name|char
modifier|*
name|val
decl_stmt|;
name|CORE_ADDR
name|o7
decl_stmt|;
name|val
operator|=
name|alloca
argument_list|(
name|SPARC_INTREG_SIZE
argument_list|)
expr_stmt|;
name|store_unsigned_integer
argument_list|(
name|val
argument_list|,
name|SPARC_INTREG_SIZE
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|write_memory
argument_list|(
name|sp
operator|+
operator|(
literal|16
operator|*
name|SPARC_INTREG_SIZE
operator|)
argument_list|,
name|val
argument_list|,
name|SPARC_INTREG_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|CALL_DUMMY_LOCATION
operator|==
name|AT_ENTRY_POINT
condition|)
block|{
comment|/* Now adjust the value of the link register, which was previously 	 stored by push_return_address.  Functions that return structs are 	 peculiar in that they return to link register + 12, rather than 	 link register + 8.  */
name|o7
operator|=
name|read_register
argument_list|(
name|O7_REGNUM
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|O7_REGNUM
argument_list|,
name|o7
operator|-
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sparc64_store_struct_return
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|CORE_ADDR
name|sp
parameter_list|)
block|{
comment|/* FIXME: V9 uses %o0 for this.  */
comment|/* FIXME MVS: Only for small enough structs!!! */
name|target_write_memory
argument_list|(
name|sp
operator|+
operator|(
literal|16
operator|*
name|SPARC_INTREG_SIZE
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|addr
argument_list|,
name|SPARC_INTREG_SIZE
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (CALL_DUMMY_LOCATION == AT_ENTRY_POINT)     {
comment|/* Now adjust the value of the link register, which was previously 	 stored by push_return_address.  Functions that return structs are 	 peculiar in that they return to link register + 12, rather than 	 link register + 8.  */
block|write_register (O7_REGNUM, read_register (O7_REGNUM) - 4);     }
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Default target data type for register REGNO.  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|sparc32_register_virtual_type
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
if|if
condition|(
name|regno
operator|==
name|PC_REGNUM
operator|||
name|regno
operator|==
name|FP_REGNUM
operator|||
name|regno
operator|==
name|SP_REGNUM
condition|)
return|return
name|builtin_type_unsigned_int
return|;
if|if
condition|(
name|regno
operator|<
literal|32
condition|)
return|return
name|builtin_type_int
return|;
if|if
condition|(
name|regno
operator|<
literal|64
condition|)
return|return
name|builtin_type_float
return|;
return|return
name|builtin_type_int
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|type
modifier|*
name|sparc64_register_virtual_type
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
if|if
condition|(
name|regno
operator|==
name|PC_REGNUM
operator|||
name|regno
operator|==
name|FP_REGNUM
operator|||
name|regno
operator|==
name|SP_REGNUM
condition|)
return|return
name|builtin_type_unsigned_long_long
return|;
if|if
condition|(
name|regno
operator|<
literal|32
condition|)
return|return
name|builtin_type_long_long
return|;
if|if
condition|(
name|regno
operator|<
literal|64
condition|)
return|return
name|builtin_type_float
return|;
if|if
condition|(
name|regno
operator|<
literal|80
condition|)
return|return
name|builtin_type_double
return|;
return|return
name|builtin_type_long_long
return|;
block|}
end_function

begin_comment
comment|/* Number of bytes of storage in the actual machine representation for    register REGNO.  */
end_comment

begin_function
specifier|static
name|int
name|sparc32_register_size
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
return|return
literal|4
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sparc64_register_size
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
return|return
operator|(
name|regno
operator|<
literal|32
condition|?
literal|8
else|:
name|regno
operator|<
literal|64
condition|?
literal|4
else|:
literal|8
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Index within the `registers' buffer of the first byte of the space    for register REGNO.  */
end_comment

begin_function
specifier|static
name|int
name|sparc32_register_byte
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
return|return
operator|(
name|regno
operator|*
literal|4
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sparc64_register_byte
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
if|if
condition|(
name|regno
operator|<
literal|32
condition|)
return|return
name|regno
operator|*
literal|8
return|;
elseif|else
if|if
condition|(
name|regno
operator|<
literal|64
condition|)
return|return
literal|32
operator|*
literal|8
operator|+
operator|(
name|regno
operator|-
literal|32
operator|)
operator|*
literal|4
return|;
elseif|else
if|if
condition|(
name|regno
operator|<
literal|80
condition|)
return|return
literal|32
operator|*
literal|8
operator|+
literal|32
operator|*
literal|4
operator|+
operator|(
name|regno
operator|-
literal|64
operator|)
operator|*
literal|8
return|;
else|else
return|return
literal|64
operator|*
literal|8
operator|+
operator|(
name|regno
operator|-
literal|80
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_comment
comment|/* Advance PC across any function entry prologue instructions to reach    some "real" code.  SKIP_PROLOGUE_FRAMELESS_P advances the PC past    some of the prologue, but stops as soon as it knows that the    function has a frame.  Its result is equal to its input PC if the    function is frameless, unequal otherwise.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|sparc_gdbarch_skip_prologue
parameter_list|(
name|CORE_ADDR
name|ip
parameter_list|)
block|{
return|return
name|examine_prologue
argument_list|(
name|ip
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Immediately after a function call, return the saved pc.    Can't go through the frames for this because on some machines    the new frame is not set up until the new function executes    some instructions.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|sparc_saved_pc_after_call
parameter_list|(
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|)
block|{
return|return
name|sparc_pc_adjust
argument_list|(
name|read_register
argument_list|(
name|RP_REGNUM
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Convert registers between 'raw' and 'virtual' formats.    They are the same on sparc, so there's nothing to do.  */
end_comment

begin_function
specifier|static
name|void
name|sparc_convert_to_virtual
parameter_list|(
name|int
name|regnum
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|char
modifier|*
name|from
parameter_list|,
name|char
modifier|*
name|to
parameter_list|)
block|{
comment|/* do nothing (should never be called) */
block|}
end_function

begin_function
specifier|static
name|void
name|sparc_convert_to_raw
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|int
name|regnum
parameter_list|,
name|char
modifier|*
name|from
parameter_list|,
name|char
modifier|*
name|to
parameter_list|)
block|{
comment|/* do nothing (should never be called) */
block|}
end_function

begin_comment
comment|/* Init saved regs: nothing to do, just a place-holder function.  */
end_comment

begin_function
specifier|static
name|void
name|sparc_frame_init_saved_regs
parameter_list|(
name|struct
name|frame_info
modifier|*
name|fi_ignored
parameter_list|)
block|{
comment|/* no-op */
block|}
end_function

begin_comment
comment|/* gdbarch fix call dummy:    All this function does is rearrange the arguments before calling    sparc_fix_call_dummy (which does the real work).  */
end_comment

begin_function
specifier|static
name|void
name|sparc_gdbarch_fix_call_dummy
parameter_list|(
name|char
modifier|*
name|dummy
parameter_list|,
name|CORE_ADDR
name|pc
parameter_list|,
name|CORE_ADDR
name|fun
parameter_list|,
name|int
name|nargs
parameter_list|,
name|struct
name|value
modifier|*
modifier|*
name|args
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|int
name|gcc_p
parameter_list|)
block|{
if|if
condition|(
name|CALL_DUMMY_LOCATION
operator|==
name|ON_STACK
condition|)
name|sparc_fix_call_dummy
argument_list|(
name|dummy
argument_list|,
name|pc
argument_list|,
name|fun
argument_list|,
name|type
argument_list|,
name|gcc_p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Coerce float to double: a no-op.  */
end_comment

begin_function
specifier|static
name|int
name|sparc_coerce_float_to_double
parameter_list|(
name|struct
name|type
modifier|*
name|formal
parameter_list|,
name|struct
name|type
modifier|*
name|actual
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* CALL_DUMMY_ADDRESS: fetch the breakpoint address for a call dummy.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|sparc_call_dummy_address
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|CALL_DUMMY_START_OFFSET
operator|)
operator|+
name|CALL_DUMMY_BREAKPOINT_OFFSET
return|;
block|}
end_function

begin_comment
comment|/* Supply the Y register number to those that need it.  */
end_comment

begin_function
name|int
name|sparc_y_regnum
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|y_regnum
return|;
block|}
end_function

begin_function
name|int
name|sparc_reg_struct_has_addr
parameter_list|(
name|int
name|gcc_p
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
if|if
condition|(
name|GDB_TARGET_IS_SPARC64
condition|)
return|return
operator|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|>
literal|32
operator|)
return|;
else|else
return|return
operator|(
name|gcc_p
operator|!=
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sparc_intreg_size
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|SPARC_INTREG_SIZE
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sparc_return_value_on_stack
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_FLT
operator|&&
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|>
literal|8
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Gdbarch "constructor" function.  */
end_comment

begin_define
define|#
directive|define
name|SPARC32_CALL_DUMMY_ON_STACK
end_define

begin_define
define|#
directive|define
name|SPARC_SP_REGNUM
value|14
end_define

begin_define
define|#
directive|define
name|SPARC_FP_REGNUM
value|30
end_define

begin_define
define|#
directive|define
name|SPARC_FP0_REGNUM
value|32
end_define

begin_define
define|#
directive|define
name|SPARC32_NPC_REGNUM
value|69
end_define

begin_define
define|#
directive|define
name|SPARC32_PC_REGNUM
value|68
end_define

begin_define
define|#
directive|define
name|SPARC32_Y_REGNUM
value|64
end_define

begin_define
define|#
directive|define
name|SPARC64_PC_REGNUM
value|80
end_define

begin_define
define|#
directive|define
name|SPARC64_NPC_REGNUM
value|81
end_define

begin_define
define|#
directive|define
name|SPARC64_Y_REGNUM
value|85
end_define

begin_function
specifier|static
name|struct
name|gdbarch
modifier|*
name|sparc_gdbarch_init
parameter_list|(
name|struct
name|gdbarch_info
name|info
parameter_list|,
name|struct
name|gdbarch_list
modifier|*
name|arches
parameter_list|)
block|{
name|struct
name|gdbarch
modifier|*
name|gdbarch
decl_stmt|;
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
decl_stmt|;
specifier|static
name|LONGEST
name|call_dummy_32
index|[]
init|=
block|{
literal|0xbc100001
block|,
literal|0x9de38000
block|,
literal|0xbc100002
block|,
literal|0xbe100003
block|,
literal|0xda03a058
block|,
literal|0xd803a054
block|,
literal|0xd603a050
block|,
literal|0xd403a04c
block|,
literal|0xd203a048
block|,
literal|0x40000000
block|,
literal|0xd003a044
block|,
literal|0x01000000
block|,
literal|0x91d02001
block|,
literal|0x01000000
block|}
decl_stmt|;
specifier|static
name|LONGEST
name|call_dummy_64
index|[]
init|=
block|{
literal|0x9de3bec0fd3fa7f7LL
block|,
literal|0xf93fa7eff53fa7e7LL
block|,
literal|0xf13fa7dfed3fa7d7LL
block|,
literal|0xe93fa7cfe53fa7c7LL
block|,
literal|0xe13fa7bfdd3fa7b7LL
block|,
literal|0xd93fa7afd53fa7a7LL
block|,
literal|0xd13fa79fcd3fa797LL
block|,
literal|0xc93fa78fc53fa787LL
block|,
literal|0xc13fa77fcc3fa777LL
block|,
literal|0xc83fa76fc43fa767LL
block|,
literal|0xc03fa75ffc3fa757LL
block|,
literal|0xf83fa74ff43fa747LL
block|,
literal|0xf03fa73f01000000LL
block|,
literal|0x0100000001000000LL
block|,
literal|0x0100000091580000LL
block|,
literal|0xd027a72b93500000LL
block|,
literal|0xd027a72791480000LL
block|,
literal|0xd027a72391400000LL
block|,
literal|0xd027a71fda5ba8a7LL
block|,
literal|0xd85ba89fd65ba897LL
block|,
literal|0xd45ba88fd25ba887LL
block|,
literal|0x9fc02000d05ba87fLL
block|,
literal|0x0100000091d02001LL
block|,
literal|0x0100000001000000LL
block|}
decl_stmt|;
specifier|static
name|LONGEST
name|call_dummy_nil
index|[]
init|=
block|{
literal|0
block|}
decl_stmt|;
comment|/* First see if there is already a gdbarch that can satisfy the request.  */
name|arches
operator|=
name|gdbarch_list_lookup_by_info
argument_list|(
name|arches
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|arches
operator|!=
name|NULL
condition|)
return|return
name|arches
operator|->
name|gdbarch
return|;
comment|/* None found: is the request for a sparc architecture? */
if|if
condition|(
name|info
operator|.
name|bfd_arch_info
operator|->
name|arch
operator|!=
name|bfd_arch_sparc
condition|)
return|return
name|NULL
return|;
comment|/* No; then it's not for us.  */
comment|/* Yes: create a new gdbarch for the specified machine type.  */
name|tdep
operator|=
operator|(
expr|struct
name|gdbarch_tdep
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|gdbarch_tdep
argument_list|)
argument_list|)
expr_stmt|;
name|gdbarch
operator|=
name|gdbarch_alloc
argument_list|(
operator|&
name|info
argument_list|,
name|tdep
argument_list|)
expr_stmt|;
comment|/* First set settings that are common for all sparc architectures.  */
name|set_gdbarch_believe_pcc_promotion
argument_list|(
name|gdbarch
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|set_gdbarch_breakpoint_from_pc
argument_list|(
name|gdbarch
argument_list|,
name|memory_breakpoint_from_pc
argument_list|)
expr_stmt|;
name|set_gdbarch_coerce_float_to_double
argument_list|(
name|gdbarch
argument_list|,
name|sparc_coerce_float_to_double
argument_list|)
expr_stmt|;
name|set_gdbarch_call_dummy_breakpoint_offset_p
argument_list|(
name|gdbarch
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|set_gdbarch_call_dummy_p
argument_list|(
name|gdbarch
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|set_gdbarch_call_dummy_stack_adjust_p
argument_list|(
name|gdbarch
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|set_gdbarch_decr_pc_after_break
argument_list|(
name|gdbarch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_gdbarch_double_bit
argument_list|(
name|gdbarch
argument_list|,
literal|8
operator|*
name|TARGET_CHAR_BIT
argument_list|)
expr_stmt|;
name|set_gdbarch_extract_struct_value_address
argument_list|(
name|gdbarch
argument_list|,
name|sparc_extract_struct_value_address
argument_list|)
expr_stmt|;
name|set_gdbarch_fix_call_dummy
argument_list|(
name|gdbarch
argument_list|,
name|sparc_gdbarch_fix_call_dummy
argument_list|)
expr_stmt|;
name|set_gdbarch_float_bit
argument_list|(
name|gdbarch
argument_list|,
literal|4
operator|*
name|TARGET_CHAR_BIT
argument_list|)
expr_stmt|;
name|set_gdbarch_fp_regnum
argument_list|(
name|gdbarch
argument_list|,
name|SPARC_FP_REGNUM
argument_list|)
expr_stmt|;
name|set_gdbarch_fp0_regnum
argument_list|(
name|gdbarch
argument_list|,
name|SPARC_FP0_REGNUM
argument_list|)
expr_stmt|;
name|set_gdbarch_frame_args_address
argument_list|(
name|gdbarch
argument_list|,
name|default_frame_address
argument_list|)
expr_stmt|;
name|set_gdbarch_frame_chain
argument_list|(
name|gdbarch
argument_list|,
name|sparc_frame_chain
argument_list|)
expr_stmt|;
name|set_gdbarch_frame_init_saved_regs
argument_list|(
name|gdbarch
argument_list|,
name|sparc_frame_init_saved_regs
argument_list|)
expr_stmt|;
name|set_gdbarch_frame_locals_address
argument_list|(
name|gdbarch
argument_list|,
name|default_frame_address
argument_list|)
expr_stmt|;
name|set_gdbarch_frame_num_args
argument_list|(
name|gdbarch
argument_list|,
name|frame_num_args_unknown
argument_list|)
expr_stmt|;
name|set_gdbarch_frame_saved_pc
argument_list|(
name|gdbarch
argument_list|,
name|sparc_frame_saved_pc
argument_list|)
expr_stmt|;
name|set_gdbarch_frameless_function_invocation
argument_list|(
name|gdbarch
argument_list|,
name|frameless_look_for_prologue
argument_list|)
expr_stmt|;
name|set_gdbarch_get_saved_register
argument_list|(
name|gdbarch
argument_list|,
name|sparc_get_saved_register
argument_list|)
expr_stmt|;
name|set_gdbarch_init_extra_frame_info
argument_list|(
name|gdbarch
argument_list|,
name|sparc_init_extra_frame_info
argument_list|)
expr_stmt|;
name|set_gdbarch_inner_than
argument_list|(
name|gdbarch
argument_list|,
name|core_addr_lessthan
argument_list|)
expr_stmt|;
name|set_gdbarch_int_bit
argument_list|(
name|gdbarch
argument_list|,
literal|4
operator|*
name|TARGET_CHAR_BIT
argument_list|)
expr_stmt|;
name|set_gdbarch_long_double_bit
argument_list|(
name|gdbarch
argument_list|,
literal|16
operator|*
name|TARGET_CHAR_BIT
argument_list|)
expr_stmt|;
name|set_gdbarch_long_long_bit
argument_list|(
name|gdbarch
argument_list|,
literal|8
operator|*
name|TARGET_CHAR_BIT
argument_list|)
expr_stmt|;
name|set_gdbarch_max_register_raw_size
argument_list|(
name|gdbarch
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|set_gdbarch_max_register_virtual_size
argument_list|(
name|gdbarch
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|set_gdbarch_pop_frame
argument_list|(
name|gdbarch
argument_list|,
name|sparc_pop_frame
argument_list|)
expr_stmt|;
name|set_gdbarch_push_return_address
argument_list|(
name|gdbarch
argument_list|,
name|sparc_push_return_address
argument_list|)
expr_stmt|;
name|set_gdbarch_push_dummy_frame
argument_list|(
name|gdbarch
argument_list|,
name|sparc_push_dummy_frame
argument_list|)
expr_stmt|;
name|set_gdbarch_read_pc
argument_list|(
name|gdbarch
argument_list|,
name|generic_target_read_pc
argument_list|)
expr_stmt|;
name|set_gdbarch_register_convert_to_raw
argument_list|(
name|gdbarch
argument_list|,
name|sparc_convert_to_raw
argument_list|)
expr_stmt|;
name|set_gdbarch_register_convert_to_virtual
argument_list|(
name|gdbarch
argument_list|,
name|sparc_convert_to_virtual
argument_list|)
expr_stmt|;
name|set_gdbarch_register_convertible
argument_list|(
name|gdbarch
argument_list|,
name|generic_register_convertible_not
argument_list|)
expr_stmt|;
name|set_gdbarch_reg_struct_has_addr
argument_list|(
name|gdbarch
argument_list|,
name|sparc_reg_struct_has_addr
argument_list|)
expr_stmt|;
name|set_gdbarch_return_value_on_stack
argument_list|(
name|gdbarch
argument_list|,
name|sparc_return_value_on_stack
argument_list|)
expr_stmt|;
name|set_gdbarch_saved_pc_after_call
argument_list|(
name|gdbarch
argument_list|,
name|sparc_saved_pc_after_call
argument_list|)
expr_stmt|;
name|set_gdbarch_short_bit
argument_list|(
name|gdbarch
argument_list|,
literal|2
operator|*
name|TARGET_CHAR_BIT
argument_list|)
expr_stmt|;
name|set_gdbarch_skip_prologue
argument_list|(
name|gdbarch
argument_list|,
name|sparc_gdbarch_skip_prologue
argument_list|)
expr_stmt|;
name|set_gdbarch_sp_regnum
argument_list|(
name|gdbarch
argument_list|,
name|SPARC_SP_REGNUM
argument_list|)
expr_stmt|;
name|set_gdbarch_use_generic_dummy_frames
argument_list|(
name|gdbarch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_gdbarch_write_pc
argument_list|(
name|gdbarch
argument_list|,
name|generic_target_write_pc
argument_list|)
expr_stmt|;
comment|/*    * Settings that depend only on 32/64 bit word size     */
switch|switch
condition|(
name|info
operator|.
name|bfd_arch_info
operator|->
name|mach
condition|)
block|{
case|case
name|bfd_mach_sparc
case|:
case|case
name|bfd_mach_sparc_sparclet
case|:
case|case
name|bfd_mach_sparc_sparclite
case|:
case|case
name|bfd_mach_sparc_v8plus
case|:
case|case
name|bfd_mach_sparc_v8plusa
case|:
case|case
name|bfd_mach_sparc_sparclite_le
case|:
comment|/* 32-bit machine types: */
ifdef|#
directive|ifdef
name|SPARC32_CALL_DUMMY_ON_STACK
name|set_gdbarch_pc_in_call_dummy
argument_list|(
name|gdbarch
argument_list|,
name|pc_in_call_dummy_on_stack
argument_list|)
expr_stmt|;
name|set_gdbarch_call_dummy_address
argument_list|(
name|gdbarch
argument_list|,
name|sparc_call_dummy_address
argument_list|)
expr_stmt|;
name|set_gdbarch_call_dummy_breakpoint_offset
argument_list|(
name|gdbarch
argument_list|,
literal|0x30
argument_list|)
expr_stmt|;
name|set_gdbarch_call_dummy_length
argument_list|(
name|gdbarch
argument_list|,
literal|0x38
argument_list|)
expr_stmt|;
name|set_gdbarch_call_dummy_location
argument_list|(
name|gdbarch
argument_list|,
name|ON_STACK
argument_list|)
expr_stmt|;
name|set_gdbarch_call_dummy_words
argument_list|(
name|gdbarch
argument_list|,
name|call_dummy_32
argument_list|)
expr_stmt|;
else|#
directive|else
name|set_gdbarch_pc_in_call_dummy
argument_list|(
name|gdbarch
argument_list|,
name|pc_in_call_dummy_at_entry_point
argument_list|)
expr_stmt|;
name|set_gdbarch_call_dummy_address
argument_list|(
name|gdbarch
argument_list|,
name|entry_point_address
argument_list|)
expr_stmt|;
name|set_gdbarch_call_dummy_breakpoint_offset
argument_list|(
name|gdbarch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_gdbarch_call_dummy_length
argument_list|(
name|gdbarch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_gdbarch_call_dummy_location
argument_list|(
name|gdbarch
argument_list|,
name|AT_ENTRY_POINT
argument_list|)
expr_stmt|;
name|set_gdbarch_call_dummy_words
argument_list|(
name|gdbarch
argument_list|,
name|call_dummy_nil
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|set_gdbarch_call_dummy_stack_adjust
argument_list|(
name|gdbarch
argument_list|,
literal|68
argument_list|)
expr_stmt|;
name|set_gdbarch_call_dummy_start_offset
argument_list|(
name|gdbarch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_gdbarch_frame_args_skip
argument_list|(
name|gdbarch
argument_list|,
literal|68
argument_list|)
expr_stmt|;
name|set_gdbarch_function_start_offset
argument_list|(
name|gdbarch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_gdbarch_long_bit
argument_list|(
name|gdbarch
argument_list|,
literal|4
operator|*
name|TARGET_CHAR_BIT
argument_list|)
expr_stmt|;
name|set_gdbarch_npc_regnum
argument_list|(
name|gdbarch
argument_list|,
name|SPARC32_NPC_REGNUM
argument_list|)
expr_stmt|;
name|set_gdbarch_pc_regnum
argument_list|(
name|gdbarch
argument_list|,
name|SPARC32_PC_REGNUM
argument_list|)
expr_stmt|;
name|set_gdbarch_ptr_bit
argument_list|(
name|gdbarch
argument_list|,
literal|4
operator|*
name|TARGET_CHAR_BIT
argument_list|)
expr_stmt|;
name|set_gdbarch_push_arguments
argument_list|(
name|gdbarch
argument_list|,
name|sparc32_push_arguments
argument_list|)
expr_stmt|;
name|set_gdbarch_read_fp
argument_list|(
name|gdbarch
argument_list|,
name|generic_target_read_fp
argument_list|)
expr_stmt|;
name|set_gdbarch_read_sp
argument_list|(
name|gdbarch
argument_list|,
name|generic_target_read_sp
argument_list|)
expr_stmt|;
name|set_gdbarch_register_byte
argument_list|(
name|gdbarch
argument_list|,
name|sparc32_register_byte
argument_list|)
expr_stmt|;
name|set_gdbarch_register_raw_size
argument_list|(
name|gdbarch
argument_list|,
name|sparc32_register_size
argument_list|)
expr_stmt|;
name|set_gdbarch_register_size
argument_list|(
name|gdbarch
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|set_gdbarch_register_virtual_size
argument_list|(
name|gdbarch
argument_list|,
name|sparc32_register_size
argument_list|)
expr_stmt|;
name|set_gdbarch_register_virtual_type
argument_list|(
name|gdbarch
argument_list|,
name|sparc32_register_virtual_type
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SPARC32_CALL_DUMMY_ON_STACK
name|set_gdbarch_sizeof_call_dummy_words
argument_list|(
name|gdbarch
argument_list|,
sizeof|sizeof
argument_list|(
name|call_dummy_32
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|set_gdbarch_sizeof_call_dummy_words
argument_list|(
name|gdbarch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|set_gdbarch_stack_align
argument_list|(
name|gdbarch
argument_list|,
name|sparc32_stack_align
argument_list|)
expr_stmt|;
name|set_gdbarch_store_struct_return
argument_list|(
name|gdbarch
argument_list|,
name|sparc32_store_struct_return
argument_list|)
expr_stmt|;
name|set_gdbarch_use_struct_convention
argument_list|(
name|gdbarch
argument_list|,
name|generic_use_struct_convention
argument_list|)
expr_stmt|;
name|set_gdbarch_write_fp
argument_list|(
name|gdbarch
argument_list|,
name|generic_target_write_fp
argument_list|)
expr_stmt|;
name|set_gdbarch_write_sp
argument_list|(
name|gdbarch
argument_list|,
name|generic_target_write_sp
argument_list|)
expr_stmt|;
name|tdep
operator|->
name|y_regnum
operator|=
name|SPARC32_Y_REGNUM
expr_stmt|;
name|tdep
operator|->
name|fp_max_regnum
operator|=
name|SPARC_FP0_REGNUM
operator|+
literal|32
expr_stmt|;
name|tdep
operator|->
name|intreg_size
operator|=
literal|4
expr_stmt|;
name|tdep
operator|->
name|reg_save_offset
operator|=
literal|0x60
expr_stmt|;
name|tdep
operator|->
name|call_dummy_call_offset
operator|=
literal|0x24
expr_stmt|;
break|break;
case|case
name|bfd_mach_sparc_v9
case|:
case|case
name|bfd_mach_sparc_v9a
case|:
comment|/* 64-bit machine types: */
default|default:
comment|/* Any new machine type is likely to be 64-bit.  */
ifdef|#
directive|ifdef
name|SPARC64_CALL_DUMMY_ON_STACK
name|set_gdbarch_pc_in_call_dummy
argument_list|(
name|gdbarch
argument_list|,
name|pc_in_call_dummy_on_stack
argument_list|)
expr_stmt|;
name|set_gdbarch_call_dummy_address
argument_list|(
name|gdbarch
argument_list|,
name|sparc_call_dummy_address
argument_list|)
expr_stmt|;
name|set_gdbarch_call_dummy_breakpoint_offset
argument_list|(
name|gdbarch
argument_list|,
literal|8
operator|*
literal|4
argument_list|)
expr_stmt|;
name|set_gdbarch_call_dummy_length
argument_list|(
name|gdbarch
argument_list|,
literal|192
argument_list|)
expr_stmt|;
name|set_gdbarch_call_dummy_location
argument_list|(
name|gdbarch
argument_list|,
name|ON_STACK
argument_list|)
expr_stmt|;
name|set_gdbarch_call_dummy_start_offset
argument_list|(
name|gdbarch
argument_list|,
literal|148
argument_list|)
expr_stmt|;
name|set_gdbarch_call_dummy_words
argument_list|(
name|gdbarch
argument_list|,
name|call_dummy_64
argument_list|)
expr_stmt|;
else|#
directive|else
name|set_gdbarch_pc_in_call_dummy
argument_list|(
name|gdbarch
argument_list|,
name|pc_in_call_dummy_at_entry_point
argument_list|)
expr_stmt|;
name|set_gdbarch_call_dummy_address
argument_list|(
name|gdbarch
argument_list|,
name|entry_point_address
argument_list|)
expr_stmt|;
name|set_gdbarch_call_dummy_breakpoint_offset
argument_list|(
name|gdbarch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_gdbarch_call_dummy_length
argument_list|(
name|gdbarch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_gdbarch_call_dummy_location
argument_list|(
name|gdbarch
argument_list|,
name|AT_ENTRY_POINT
argument_list|)
expr_stmt|;
name|set_gdbarch_call_dummy_start_offset
argument_list|(
name|gdbarch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_gdbarch_call_dummy_words
argument_list|(
name|gdbarch
argument_list|,
name|call_dummy_nil
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|set_gdbarch_call_dummy_stack_adjust
argument_list|(
name|gdbarch
argument_list|,
literal|128
argument_list|)
expr_stmt|;
name|set_gdbarch_frame_args_skip
argument_list|(
name|gdbarch
argument_list|,
literal|136
argument_list|)
expr_stmt|;
name|set_gdbarch_function_start_offset
argument_list|(
name|gdbarch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_gdbarch_long_bit
argument_list|(
name|gdbarch
argument_list|,
literal|8
operator|*
name|TARGET_CHAR_BIT
argument_list|)
expr_stmt|;
name|set_gdbarch_npc_regnum
argument_list|(
name|gdbarch
argument_list|,
name|SPARC64_NPC_REGNUM
argument_list|)
expr_stmt|;
name|set_gdbarch_pc_regnum
argument_list|(
name|gdbarch
argument_list|,
name|SPARC64_PC_REGNUM
argument_list|)
expr_stmt|;
name|set_gdbarch_ptr_bit
argument_list|(
name|gdbarch
argument_list|,
literal|8
operator|*
name|TARGET_CHAR_BIT
argument_list|)
expr_stmt|;
name|set_gdbarch_push_arguments
argument_list|(
name|gdbarch
argument_list|,
name|sparc64_push_arguments
argument_list|)
expr_stmt|;
comment|/* NOTE different for at_entry */
name|set_gdbarch_read_fp
argument_list|(
name|gdbarch
argument_list|,
name|sparc64_read_fp
argument_list|)
expr_stmt|;
name|set_gdbarch_read_sp
argument_list|(
name|gdbarch
argument_list|,
name|sparc64_read_sp
argument_list|)
expr_stmt|;
comment|/* Some of the registers aren't 64 bits, but it's a lot simpler just 	 to assume they all are (since most of them are).  */
name|set_gdbarch_register_byte
argument_list|(
name|gdbarch
argument_list|,
name|sparc64_register_byte
argument_list|)
expr_stmt|;
name|set_gdbarch_register_raw_size
argument_list|(
name|gdbarch
argument_list|,
name|sparc64_register_size
argument_list|)
expr_stmt|;
name|set_gdbarch_register_size
argument_list|(
name|gdbarch
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|set_gdbarch_register_virtual_size
argument_list|(
name|gdbarch
argument_list|,
name|sparc64_register_size
argument_list|)
expr_stmt|;
name|set_gdbarch_register_virtual_type
argument_list|(
name|gdbarch
argument_list|,
name|sparc64_register_virtual_type
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SPARC64_CALL_DUMMY_ON_STACK
name|set_gdbarch_sizeof_call_dummy_words
argument_list|(
name|gdbarch
argument_list|,
sizeof|sizeof
argument_list|(
name|call_dummy_64
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|set_gdbarch_sizeof_call_dummy_words
argument_list|(
name|gdbarch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|set_gdbarch_stack_align
argument_list|(
name|gdbarch
argument_list|,
name|sparc64_stack_align
argument_list|)
expr_stmt|;
name|set_gdbarch_store_struct_return
argument_list|(
name|gdbarch
argument_list|,
name|sparc64_store_struct_return
argument_list|)
expr_stmt|;
name|set_gdbarch_use_struct_convention
argument_list|(
name|gdbarch
argument_list|,
name|sparc64_use_struct_convention
argument_list|)
expr_stmt|;
name|set_gdbarch_write_fp
argument_list|(
name|gdbarch
argument_list|,
name|sparc64_write_fp
argument_list|)
expr_stmt|;
name|set_gdbarch_write_sp
argument_list|(
name|gdbarch
argument_list|,
name|sparc64_write_sp
argument_list|)
expr_stmt|;
name|tdep
operator|->
name|y_regnum
operator|=
name|SPARC64_Y_REGNUM
expr_stmt|;
name|tdep
operator|->
name|fp_max_regnum
operator|=
name|SPARC_FP0_REGNUM
operator|+
literal|48
expr_stmt|;
name|tdep
operator|->
name|intreg_size
operator|=
literal|8
expr_stmt|;
name|tdep
operator|->
name|reg_save_offset
operator|=
literal|0x90
expr_stmt|;
name|tdep
operator|->
name|call_dummy_call_offset
operator|=
literal|148
operator|+
literal|4
operator|*
literal|5
expr_stmt|;
break|break;
block|}
comment|/*     * Settings that vary per-architecture:    */
switch|switch
condition|(
name|info
operator|.
name|bfd_arch_info
operator|->
name|mach
condition|)
block|{
case|case
name|bfd_mach_sparc
case|:
name|set_gdbarch_extract_return_value
argument_list|(
name|gdbarch
argument_list|,
name|sparc32_extract_return_value
argument_list|)
expr_stmt|;
name|set_gdbarch_frame_chain_valid
argument_list|(
name|gdbarch
argument_list|,
name|file_frame_chain_valid
argument_list|)
expr_stmt|;
name|set_gdbarch_num_regs
argument_list|(
name|gdbarch
argument_list|,
literal|72
argument_list|)
expr_stmt|;
name|set_gdbarch_register_bytes
argument_list|(
name|gdbarch
argument_list|,
literal|32
operator|*
literal|4
operator|+
literal|32
operator|*
literal|4
operator|+
literal|8
operator|*
literal|4
argument_list|)
expr_stmt|;
name|set_gdbarch_register_name
argument_list|(
name|gdbarch
argument_list|,
name|sparc32_register_name
argument_list|)
expr_stmt|;
name|set_gdbarch_store_return_value
argument_list|(
name|gdbarch
argument_list|,
name|sparc_store_return_value
argument_list|)
expr_stmt|;
name|tdep
operator|->
name|has_fpu
operator|=
literal|1
expr_stmt|;
comment|/* (all but sparclet and sparclite) */
name|tdep
operator|->
name|fp_register_bytes
operator|=
literal|32
operator|*
literal|4
expr_stmt|;
name|tdep
operator|->
name|print_insn_mach
operator|=
name|bfd_mach_sparc
expr_stmt|;
break|break;
case|case
name|bfd_mach_sparc_sparclet
case|:
name|set_gdbarch_extract_return_value
argument_list|(
name|gdbarch
argument_list|,
name|sparclet_extract_return_value
argument_list|)
expr_stmt|;
name|set_gdbarch_frame_chain_valid
argument_list|(
name|gdbarch
argument_list|,
name|file_frame_chain_valid
argument_list|)
expr_stmt|;
name|set_gdbarch_num_regs
argument_list|(
name|gdbarch
argument_list|,
literal|32
operator|+
literal|32
operator|+
literal|8
operator|+
literal|8
operator|+
literal|8
argument_list|)
expr_stmt|;
name|set_gdbarch_register_bytes
argument_list|(
name|gdbarch
argument_list|,
literal|32
operator|*
literal|4
operator|+
literal|32
operator|*
literal|4
operator|+
literal|8
operator|*
literal|4
operator|+
literal|8
operator|*
literal|4
operator|+
literal|8
operator|*
literal|4
argument_list|)
expr_stmt|;
name|set_gdbarch_register_name
argument_list|(
name|gdbarch
argument_list|,
name|sparclet_register_name
argument_list|)
expr_stmt|;
name|set_gdbarch_store_return_value
argument_list|(
name|gdbarch
argument_list|,
name|sparclet_store_return_value
argument_list|)
expr_stmt|;
name|tdep
operator|->
name|has_fpu
operator|=
literal|0
expr_stmt|;
comment|/* (all but sparclet and sparclite) */
name|tdep
operator|->
name|fp_register_bytes
operator|=
literal|0
expr_stmt|;
name|tdep
operator|->
name|print_insn_mach
operator|=
name|bfd_mach_sparc_sparclet
expr_stmt|;
break|break;
case|case
name|bfd_mach_sparc_sparclite
case|:
name|set_gdbarch_extract_return_value
argument_list|(
name|gdbarch
argument_list|,
name|sparc32_extract_return_value
argument_list|)
expr_stmt|;
name|set_gdbarch_frame_chain_valid
argument_list|(
name|gdbarch
argument_list|,
name|func_frame_chain_valid
argument_list|)
expr_stmt|;
name|set_gdbarch_num_regs
argument_list|(
name|gdbarch
argument_list|,
literal|80
argument_list|)
expr_stmt|;
name|set_gdbarch_register_bytes
argument_list|(
name|gdbarch
argument_list|,
literal|32
operator|*
literal|4
operator|+
literal|32
operator|*
literal|4
operator|+
literal|8
operator|*
literal|4
operator|+
literal|8
operator|*
literal|4
argument_list|)
expr_stmt|;
name|set_gdbarch_register_name
argument_list|(
name|gdbarch
argument_list|,
name|sparclite_register_name
argument_list|)
expr_stmt|;
name|set_gdbarch_store_return_value
argument_list|(
name|gdbarch
argument_list|,
name|sparc_store_return_value
argument_list|)
expr_stmt|;
name|tdep
operator|->
name|has_fpu
operator|=
literal|0
expr_stmt|;
comment|/* (all but sparclet and sparclite) */
name|tdep
operator|->
name|fp_register_bytes
operator|=
literal|0
expr_stmt|;
name|tdep
operator|->
name|print_insn_mach
operator|=
name|bfd_mach_sparc_sparclite
expr_stmt|;
break|break;
case|case
name|bfd_mach_sparc_v8plus
case|:
name|set_gdbarch_extract_return_value
argument_list|(
name|gdbarch
argument_list|,
name|sparc32_extract_return_value
argument_list|)
expr_stmt|;
name|set_gdbarch_frame_chain_valid
argument_list|(
name|gdbarch
argument_list|,
name|file_frame_chain_valid
argument_list|)
expr_stmt|;
name|set_gdbarch_num_regs
argument_list|(
name|gdbarch
argument_list|,
literal|72
argument_list|)
expr_stmt|;
name|set_gdbarch_register_bytes
argument_list|(
name|gdbarch
argument_list|,
literal|32
operator|*
literal|4
operator|+
literal|32
operator|*
literal|4
operator|+
literal|8
operator|*
literal|4
argument_list|)
expr_stmt|;
name|set_gdbarch_register_name
argument_list|(
name|gdbarch
argument_list|,
name|sparc32_register_name
argument_list|)
expr_stmt|;
name|set_gdbarch_store_return_value
argument_list|(
name|gdbarch
argument_list|,
name|sparc_store_return_value
argument_list|)
expr_stmt|;
name|tdep
operator|->
name|print_insn_mach
operator|=
name|bfd_mach_sparc
expr_stmt|;
name|tdep
operator|->
name|fp_register_bytes
operator|=
literal|32
operator|*
literal|4
expr_stmt|;
name|tdep
operator|->
name|has_fpu
operator|=
literal|1
expr_stmt|;
comment|/* (all but sparclet and sparclite) */
break|break;
case|case
name|bfd_mach_sparc_v8plusa
case|:
name|set_gdbarch_extract_return_value
argument_list|(
name|gdbarch
argument_list|,
name|sparc32_extract_return_value
argument_list|)
expr_stmt|;
name|set_gdbarch_frame_chain_valid
argument_list|(
name|gdbarch
argument_list|,
name|file_frame_chain_valid
argument_list|)
expr_stmt|;
name|set_gdbarch_num_regs
argument_list|(
name|gdbarch
argument_list|,
literal|72
argument_list|)
expr_stmt|;
name|set_gdbarch_register_bytes
argument_list|(
name|gdbarch
argument_list|,
literal|32
operator|*
literal|4
operator|+
literal|32
operator|*
literal|4
operator|+
literal|8
operator|*
literal|4
argument_list|)
expr_stmt|;
name|set_gdbarch_register_name
argument_list|(
name|gdbarch
argument_list|,
name|sparc32_register_name
argument_list|)
expr_stmt|;
name|set_gdbarch_store_return_value
argument_list|(
name|gdbarch
argument_list|,
name|sparc_store_return_value
argument_list|)
expr_stmt|;
name|tdep
operator|->
name|has_fpu
operator|=
literal|1
expr_stmt|;
comment|/* (all but sparclet and sparclite) */
name|tdep
operator|->
name|fp_register_bytes
operator|=
literal|32
operator|*
literal|4
expr_stmt|;
name|tdep
operator|->
name|print_insn_mach
operator|=
name|bfd_mach_sparc
expr_stmt|;
break|break;
case|case
name|bfd_mach_sparc_sparclite_le
case|:
name|set_gdbarch_extract_return_value
argument_list|(
name|gdbarch
argument_list|,
name|sparc32_extract_return_value
argument_list|)
expr_stmt|;
name|set_gdbarch_frame_chain_valid
argument_list|(
name|gdbarch
argument_list|,
name|func_frame_chain_valid
argument_list|)
expr_stmt|;
name|set_gdbarch_num_regs
argument_list|(
name|gdbarch
argument_list|,
literal|80
argument_list|)
expr_stmt|;
name|set_gdbarch_register_bytes
argument_list|(
name|gdbarch
argument_list|,
literal|32
operator|*
literal|4
operator|+
literal|32
operator|*
literal|4
operator|+
literal|8
operator|*
literal|4
operator|+
literal|8
operator|*
literal|4
argument_list|)
expr_stmt|;
name|set_gdbarch_register_name
argument_list|(
name|gdbarch
argument_list|,
name|sparclite_register_name
argument_list|)
expr_stmt|;
name|set_gdbarch_store_return_value
argument_list|(
name|gdbarch
argument_list|,
name|sparc_store_return_value
argument_list|)
expr_stmt|;
name|tdep
operator|->
name|has_fpu
operator|=
literal|0
expr_stmt|;
comment|/* (all but sparclet and sparclite) */
name|tdep
operator|->
name|fp_register_bytes
operator|=
literal|0
expr_stmt|;
name|tdep
operator|->
name|print_insn_mach
operator|=
name|bfd_mach_sparc_sparclite
expr_stmt|;
break|break;
case|case
name|bfd_mach_sparc_v9
case|:
name|set_gdbarch_extract_return_value
argument_list|(
name|gdbarch
argument_list|,
name|sparc64_extract_return_value
argument_list|)
expr_stmt|;
name|set_gdbarch_frame_chain_valid
argument_list|(
name|gdbarch
argument_list|,
name|file_frame_chain_valid
argument_list|)
expr_stmt|;
name|set_gdbarch_num_regs
argument_list|(
name|gdbarch
argument_list|,
literal|125
argument_list|)
expr_stmt|;
name|set_gdbarch_register_bytes
argument_list|(
name|gdbarch
argument_list|,
literal|32
operator|*
literal|8
operator|+
literal|32
operator|*
literal|8
operator|+
literal|45
operator|*
literal|8
argument_list|)
expr_stmt|;
name|set_gdbarch_register_name
argument_list|(
name|gdbarch
argument_list|,
name|sparc64_register_name
argument_list|)
expr_stmt|;
name|set_gdbarch_store_return_value
argument_list|(
name|gdbarch
argument_list|,
name|sparc_store_return_value
argument_list|)
expr_stmt|;
name|tdep
operator|->
name|has_fpu
operator|=
literal|1
expr_stmt|;
comment|/* (all but sparclet and sparclite) */
name|tdep
operator|->
name|fp_register_bytes
operator|=
literal|64
operator|*
literal|4
expr_stmt|;
name|tdep
operator|->
name|print_insn_mach
operator|=
name|bfd_mach_sparc_v9a
expr_stmt|;
break|break;
case|case
name|bfd_mach_sparc_v9a
case|:
name|set_gdbarch_extract_return_value
argument_list|(
name|gdbarch
argument_list|,
name|sparc64_extract_return_value
argument_list|)
expr_stmt|;
name|set_gdbarch_frame_chain_valid
argument_list|(
name|gdbarch
argument_list|,
name|file_frame_chain_valid
argument_list|)
expr_stmt|;
name|set_gdbarch_num_regs
argument_list|(
name|gdbarch
argument_list|,
literal|125
argument_list|)
expr_stmt|;
name|set_gdbarch_register_bytes
argument_list|(
name|gdbarch
argument_list|,
literal|32
operator|*
literal|8
operator|+
literal|32
operator|*
literal|8
operator|+
literal|45
operator|*
literal|8
argument_list|)
expr_stmt|;
name|set_gdbarch_register_name
argument_list|(
name|gdbarch
argument_list|,
name|sparc64_register_name
argument_list|)
expr_stmt|;
name|set_gdbarch_store_return_value
argument_list|(
name|gdbarch
argument_list|,
name|sparc_store_return_value
argument_list|)
expr_stmt|;
name|tdep
operator|->
name|has_fpu
operator|=
literal|1
expr_stmt|;
comment|/* (all but sparclet and sparclite) */
name|tdep
operator|->
name|fp_register_bytes
operator|=
literal|64
operator|*
literal|4
expr_stmt|;
name|tdep
operator|->
name|print_insn_mach
operator|=
name|bfd_mach_sparc_v9a
expr_stmt|;
break|break;
block|}
return|return
name|gdbarch
return|;
block|}
end_function

end_unit

