begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Abstraction of GNU v2 abi.    Contributed by Daniel Berlin<dberlin@redhat.com>    Copyright 2001 Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or    modify    it under the terms of the GNU General Public License as published    by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_include
include|#
directive|include
file|"cp-abi.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_decl_stmt
name|struct
name|cp_abi_ops
name|gnu_v2_abi_ops
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|vb_match
parameter_list|(
name|struct
name|type
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|type
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|gnuv2_baseclass_offset
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|int
name|index
parameter_list|,
name|char
modifier|*
name|valaddr
parameter_list|,
name|CORE_ADDR
name|address
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|enum
name|dtor_kinds
name|gnuv2_is_destructor_name
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
operator|(
name|name
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|is_cplus_marker
argument_list|(
name|name
index|[
literal|1
index|]
argument_list|)
operator|&&
name|name
index|[
literal|2
index|]
operator|==
literal|'_'
operator|)
operator|||
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"__dt__"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
return|return
name|complete_object_dtor
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|ctor_kinds
name|gnuv2_is_constructor_name
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
operator|(
name|name
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|'_'
operator|&&
operator|(
name|isdigit
argument_list|(
name|name
index|[
literal|2
index|]
argument_list|)
operator|||
name|strchr
argument_list|(
literal|"Qt"
argument_list|,
name|name
index|[
literal|2
index|]
argument_list|)
operator|)
operator|)
operator|||
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"__ct__"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
return|return
name|complete_object_ctor
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|gnuv2_is_vtable_name
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
operator|(
operator|(
operator|(
name|name
operator|)
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
operator|(
operator|(
operator|(
name|name
operator|)
index|[
literal|1
index|]
operator|==
literal|'V'
operator|&&
operator|(
name|name
operator|)
index|[
literal|2
index|]
operator|==
literal|'T'
operator|)
operator|||
operator|(
operator|(
name|name
operator|)
index|[
literal|1
index|]
operator|==
literal|'v'
operator|&&
operator|(
name|name
operator|)
index|[
literal|2
index|]
operator|==
literal|'t'
operator|)
operator|)
operator|&&
name|is_cplus_marker
argument_list|(
operator|(
name|name
operator|)
index|[
literal|3
index|]
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|name
operator|)
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
operator|(
name|name
operator|)
index|[
literal|1
index|]
operator|==
literal|'_'
operator|&&
operator|(
name|name
operator|)
index|[
literal|2
index|]
operator|==
literal|'v'
operator|&&
operator|(
name|name
operator|)
index|[
literal|3
index|]
operator|==
literal|'t'
operator|&&
operator|(
name|name
operator|)
index|[
literal|4
index|]
operator|==
literal|'_'
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|gnuv2_is_operator_name
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"operator"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a virtual function as a value.    ARG1 is the object which provides the virtual function    table pointer.  *ARG1P is side-effected in calling this function.    F is the list of member functions which contains the desired virtual    function.    J is an index into F which provides the desired virtual function.     TYPE is the type in which F is located.  */
end_comment

begin_function
specifier|static
name|struct
name|value
modifier|*
name|gnuv2_virtual_fn_field
parameter_list|(
name|struct
name|value
modifier|*
modifier|*
name|arg1p
parameter_list|,
name|struct
name|fn_field
modifier|*
name|f
parameter_list|,
name|int
name|j
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
name|struct
name|value
modifier|*
name|arg1
init|=
operator|*
name|arg1p
decl_stmt|;
name|struct
name|type
modifier|*
name|type1
init|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|type
modifier|*
name|entry_type
decl_stmt|;
comment|/* First, get the virtual function table pointer.  That comes      with a strange type, so cast it to type `pointer to long' (which      should serve just fine as a function type).  Then, index into      the table, and convert final value to appropriate function type.  */
name|struct
name|value
modifier|*
name|entry
decl_stmt|;
name|struct
name|value
modifier|*
name|vfn
decl_stmt|;
name|struct
name|value
modifier|*
name|vtbl
decl_stmt|;
name|struct
name|value
modifier|*
name|vi
init|=
name|value_from_longest
argument_list|(
name|builtin_type_int
argument_list|,
operator|(
name|LONGEST
operator|)
name|TYPE_FN_FIELD_VOFFSET
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|type
modifier|*
name|fcontext
init|=
name|TYPE_FN_FIELD_FCONTEXT
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
decl_stmt|;
name|struct
name|type
modifier|*
name|context
decl_stmt|;
if|if
condition|(
name|fcontext
operator|==
name|NULL
condition|)
comment|/* We don't have an fcontext (e.g. the program was compiled with        g++ version 1).  Try to get the vtbl from the TYPE_VPTR_BASETYPE.        This won't work right for multiple inheritance, but at least we        should do as well as GDB 3.x did.  */
name|fcontext
operator|=
name|TYPE_VPTR_BASETYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|context
operator|=
name|lookup_pointer_type
argument_list|(
name|fcontext
argument_list|)
expr_stmt|;
comment|/* Now context is a pointer to the basetype containing the vtbl.  */
if|if
condition|(
name|TYPE_TARGET_TYPE
argument_list|(
name|context
argument_list|)
operator|!=
name|type1
condition|)
block|{
name|struct
name|value
modifier|*
name|tmp
init|=
name|value_cast
argument_list|(
name|context
argument_list|,
name|value_addr
argument_list|(
name|arg1
argument_list|)
argument_list|)
decl_stmt|;
name|arg1
operator|=
name|value_ind
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|type1
operator|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|context
operator|=
name|type1
expr_stmt|;
comment|/* Now context is the basetype containing the vtbl.  */
comment|/* This type may have been defined before its virtual function table      was.  If so, fill in the virtual function table entry for the      type now.  */
if|if
condition|(
name|TYPE_VPTR_FIELDNO
argument_list|(
name|context
argument_list|)
operator|<
literal|0
condition|)
name|fill_in_vptr_fieldno
argument_list|(
name|context
argument_list|)
expr_stmt|;
comment|/* The virtual function table is now an array of structures      which have the form { int16 offset, delta; void *pfn; }.  */
name|vtbl
operator|=
name|value_primitive_field
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|,
name|TYPE_VPTR_FIELDNO
argument_list|(
name|context
argument_list|)
argument_list|,
name|TYPE_VPTR_BASETYPE
argument_list|(
name|context
argument_list|)
argument_list|)
expr_stmt|;
comment|/* With older versions of g++, the vtbl field pointed to an array      of structures.  Nowadays it points directly to the structure. */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|vtbl
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_PTR
operator|&&
name|TYPE_CODE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|vtbl
argument_list|)
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_ARRAY
condition|)
block|{
comment|/* Handle the case where the vtbl field points to an          array of structures. */
name|vtbl
operator|=
name|value_ind
argument_list|(
name|vtbl
argument_list|)
expr_stmt|;
comment|/* Index into the virtual function table.  This is hard-coded because          looking up a field is not cheap, and it may be important to save          time, e.g. if the user has set a conditional breakpoint calling          a virtual function.  */
name|entry
operator|=
name|value_subscript
argument_list|(
name|vtbl
argument_list|,
name|vi
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Handle the case where the vtbl field points directly to a structure. */
name|vtbl
operator|=
name|value_add
argument_list|(
name|vtbl
argument_list|,
name|vi
argument_list|)
expr_stmt|;
name|entry
operator|=
name|value_ind
argument_list|(
name|vtbl
argument_list|)
expr_stmt|;
block|}
name|entry_type
operator|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|entry_type
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
condition|)
block|{
comment|/* Move the `this' pointer according to the virtual function table. */
name|VALUE_OFFSET
argument_list|(
name|arg1
argument_list|)
operator|+=
name|value_as_long
argument_list|(
name|value_field
argument_list|(
name|entry
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|VALUE_LAZY
argument_list|(
name|arg1
argument_list|)
condition|)
block|{
name|VALUE_LAZY
argument_list|(
name|arg1
argument_list|)
operator|=
literal|1
expr_stmt|;
name|value_fetch_lazy
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
block|}
name|vfn
operator|=
name|value_field
argument_list|(
name|entry
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|entry_type
argument_list|)
operator|==
name|TYPE_CODE_PTR
condition|)
name|vfn
operator|=
name|entry
expr_stmt|;
else|else
name|error
argument_list|(
literal|"I'm confused:  virtual function table has bad type"
argument_list|)
expr_stmt|;
comment|/* Reinstantiate the function pointer with the correct type.  */
name|VALUE_TYPE
argument_list|(
name|vfn
argument_list|)
operator|=
name|lookup_pointer_type
argument_list|(
name|TYPE_FN_FIELD_TYPE
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|arg1p
operator|=
name|arg1
expr_stmt|;
return|return
name|vfn
return|;
block|}
end_function

begin_function
name|struct
name|type
modifier|*
name|gnuv2_value_rtti_type
parameter_list|(
name|struct
name|value
modifier|*
name|v
parameter_list|,
name|int
modifier|*
name|full
parameter_list|,
name|int
modifier|*
name|top
parameter_list|,
name|int
modifier|*
name|using_enc
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|known_type
decl_stmt|;
name|struct
name|type
modifier|*
name|rtti_type
decl_stmt|;
name|CORE_ADDR
name|coreptr
decl_stmt|;
name|struct
name|value
modifier|*
name|vp
decl_stmt|;
name|int
name|using_enclosing
init|=
literal|0
decl_stmt|;
name|long
name|top_offset
init|=
literal|0
decl_stmt|;
name|char
name|rtti_type_name
index|[
literal|256
index|]
decl_stmt|;
name|CORE_ADDR
name|vtbl
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|minsym
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|char
modifier|*
name|demangled_name
decl_stmt|;
name|struct
name|type
modifier|*
name|btype
decl_stmt|;
if|if
condition|(
name|full
condition|)
operator|*
name|full
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|top
condition|)
operator|*
name|top
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|using_enc
condition|)
operator|*
name|using_enc
operator|=
literal|0
expr_stmt|;
comment|/* Get declared type */
name|known_type
operator|=
name|VALUE_TYPE
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|CHECK_TYPEDEF
argument_list|(
name|known_type
argument_list|)
expr_stmt|;
comment|/* RTTI works only or class objects */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|known_type
argument_list|)
operator|!=
name|TYPE_CODE_CLASS
condition|)
return|return
name|NULL
return|;
comment|/* Plan on this changing in the future as i get around to setting      the vtables properly for G++ compiled stuff.  Also, I'll be using      the type info functions, which are always right.  Deal with it      until then.  */
comment|/* If the type has no vptr fieldno, try to get it filled in */
if|if
condition|(
name|TYPE_VPTR_FIELDNO
argument_list|(
name|known_type
argument_list|)
operator|<
literal|0
condition|)
name|fill_in_vptr_fieldno
argument_list|(
name|known_type
argument_list|)
expr_stmt|;
comment|/* If we still can't find one, give up */
if|if
condition|(
name|TYPE_VPTR_FIELDNO
argument_list|(
name|known_type
argument_list|)
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
comment|/* Make sure our basetype and known type match, otherwise, cast      so we can get at the vtable properly.   */
name|btype
operator|=
name|TYPE_VPTR_BASETYPE
argument_list|(
name|known_type
argument_list|)
expr_stmt|;
name|CHECK_TYPEDEF
argument_list|(
name|btype
argument_list|)
expr_stmt|;
if|if
condition|(
name|btype
operator|!=
name|known_type
condition|)
block|{
name|v
operator|=
name|value_cast
argument_list|(
name|btype
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|using_enc
condition|)
operator|*
name|using_enc
operator|=
literal|1
expr_stmt|;
block|}
comment|/*     We can't use value_ind here, because it would want to use RTTI, and     we'd waste a bunch of time figuring out we already know the type.     Besides, we don't care about the type, just the actual pointer   */
if|if
condition|(
name|VALUE_ADDRESS
argument_list|(
name|value_field
argument_list|(
name|v
argument_list|,
name|TYPE_VPTR_FIELDNO
argument_list|(
name|known_type
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
comment|/*     If we are enclosed by something that isn't us, adjust the     address properly and set using_enclosing.   */
if|if
condition|(
name|VALUE_ENCLOSING_TYPE
argument_list|(
name|v
argument_list|)
operator|!=
name|VALUE_TYPE
argument_list|(
name|v
argument_list|)
condition|)
block|{
name|struct
name|value
modifier|*
name|tempval
decl_stmt|;
name|int
name|bitpos
init|=
name|TYPE_BASECLASS_BITPOS
argument_list|(
name|known_type
argument_list|,
name|TYPE_VPTR_FIELDNO
argument_list|(
name|known_type
argument_list|)
argument_list|)
decl_stmt|;
name|tempval
operator|=
name|value_field
argument_list|(
name|v
argument_list|,
name|TYPE_VPTR_FIELDNO
argument_list|(
name|known_type
argument_list|)
argument_list|)
expr_stmt|;
name|VALUE_ADDRESS
argument_list|(
name|tempval
argument_list|)
operator|+=
name|bitpos
operator|/
literal|8
expr_stmt|;
name|vtbl
operator|=
name|value_as_address
argument_list|(
name|tempval
argument_list|)
expr_stmt|;
name|using_enclosing
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|vtbl
operator|=
name|value_as_address
argument_list|(
name|value_field
argument_list|(
name|v
argument_list|,
name|TYPE_VPTR_FIELDNO
argument_list|(
name|known_type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|using_enclosing
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Try to find a symbol that is the vtable */
name|minsym
operator|=
name|lookup_minimal_symbol_by_pc
argument_list|(
name|vtbl
argument_list|)
expr_stmt|;
if|if
condition|(
name|minsym
operator|==
name|NULL
operator|||
operator|(
name|demangled_name
operator|=
name|SYMBOL_NAME
argument_list|(
name|minsym
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|!
name|is_vtable_name
argument_list|(
name|demangled_name
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* If we just skip the prefix, we get screwed by namespaces */
name|demangled_name
operator|=
name|cplus_demangle
argument_list|(
name|demangled_name
argument_list|,
name|DMGL_PARAMS
operator||
name|DMGL_ANSI
argument_list|)
expr_stmt|;
operator|*
operator|(
name|strchr
argument_list|(
name|demangled_name
argument_list|,
literal|' '
argument_list|)
operator|)
operator|=
literal|0
expr_stmt|;
comment|/* Lookup the type for the name */
name|rtti_type
operator|=
name|lookup_typename
argument_list|(
name|demangled_name
argument_list|,
operator|(
expr|struct
name|block
operator|*
operator|)
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtti_type
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|TYPE_N_BASECLASSES
argument_list|(
name|rtti_type
argument_list|)
operator|>
literal|1
operator|&&
name|full
operator|&&
operator|(
operator|*
name|full
operator|)
operator|!=
literal|1
condition|)
block|{
if|if
condition|(
name|top
condition|)
operator|*
name|top
operator|=
name|TYPE_BASECLASS_BITPOS
argument_list|(
name|rtti_type
argument_list|,
name|TYPE_VPTR_FIELDNO
argument_list|(
name|rtti_type
argument_list|)
argument_list|)
operator|/
literal|8
expr_stmt|;
if|if
condition|(
name|top
operator|&&
operator|(
operator|(
operator|*
name|top
operator|)
operator|>
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|rtti_type
argument_list|)
operator|>
name|TYPE_LENGTH
argument_list|(
name|known_type
argument_list|)
condition|)
block|{
if|if
condition|(
name|full
condition|)
operator|*
name|full
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|full
condition|)
operator|*
name|full
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|full
condition|)
operator|*
name|full
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|using_enc
condition|)
operator|*
name|using_enc
operator|=
name|using_enclosing
expr_stmt|;
return|return
name|rtti_type
return|;
block|}
end_function

begin_comment
comment|/* Return true if the INDEXth field of TYPE is a virtual baseclass    pointer which is for the base class whose type is BASECLASS.  */
end_comment

begin_function
specifier|static
name|int
name|vb_match
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|int
name|index
parameter_list|,
name|struct
name|type
modifier|*
name|basetype
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|fieldtype
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|index
argument_list|)
decl_stmt|;
name|char
modifier|*
name|field_class_name
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|*
name|name
operator|!=
literal|'_'
condition|)
return|return
literal|0
return|;
comment|/* gcc 2.4 uses _vb$.  */
if|if
condition|(
name|name
index|[
literal|1
index|]
operator|==
literal|'v'
operator|&&
name|name
index|[
literal|2
index|]
operator|==
literal|'b'
operator|&&
name|is_cplus_marker
argument_list|(
name|name
index|[
literal|3
index|]
argument_list|)
condition|)
name|field_class_name
operator|=
name|name
operator|+
literal|4
expr_stmt|;
comment|/* gcc 2.5 will use __vb_.  */
if|if
condition|(
name|name
index|[
literal|1
index|]
operator|==
literal|'_'
operator|&&
name|name
index|[
literal|2
index|]
operator|==
literal|'v'
operator|&&
name|name
index|[
literal|3
index|]
operator|==
literal|'b'
operator|&&
name|name
index|[
literal|4
index|]
operator|==
literal|'_'
condition|)
name|field_class_name
operator|=
name|name
operator|+
literal|5
expr_stmt|;
if|if
condition|(
name|field_class_name
operator|==
name|NULL
condition|)
comment|/* This field is not a virtual base class pointer.  */
return|return
literal|0
return|;
comment|/* It's a virtual baseclass pointer, now we just need to find out whether      it is for this baseclass.  */
name|fieldtype
operator|=
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|fieldtype
operator|==
name|NULL
operator|||
name|TYPE_CODE
argument_list|(
name|fieldtype
argument_list|)
operator|!=
name|TYPE_CODE_PTR
condition|)
comment|/* "Can't happen".  */
return|return
literal|0
return|;
comment|/* What we check for is that either the types are equal (needed for      nameless types) or have the same name.  This is ugly, and a more      elegant solution should be devised (which would probably just push      the ugliness into symbol reading unless we change the stabs format).  */
if|if
condition|(
name|TYPE_TARGET_TYPE
argument_list|(
name|fieldtype
argument_list|)
operator|==
name|basetype
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|basetype
argument_list|)
operator|!=
name|NULL
operator|&&
name|TYPE_NAME
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|fieldtype
argument_list|)
argument_list|)
operator|!=
name|NULL
operator|&&
name|STREQ
argument_list|(
name|TYPE_NAME
argument_list|(
name|basetype
argument_list|)
argument_list|,
name|TYPE_NAME
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|fieldtype
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Compute the offset of the baseclass which is    the INDEXth baseclass of class TYPE,    for value at VALADDR (in host) at ADDRESS (in target).    The result is the offset of the baseclass value relative    to (the address of)(ARG) + OFFSET.     -1 is returned on error. */
end_comment

begin_function
name|int
name|gnuv2_baseclass_offset
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|int
name|index
parameter_list|,
name|char
modifier|*
name|valaddr
parameter_list|,
name|CORE_ADDR
name|address
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|basetype
init|=
name|TYPE_BASECLASS
argument_list|(
name|type
argument_list|,
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
name|BASETYPE_VIA_VIRTUAL
argument_list|(
name|type
argument_list|,
name|index
argument_list|)
condition|)
block|{
comment|/* Must hunt for the pointer to this virtual baseclass.  */
specifier|register
name|int
name|i
decl_stmt|,
name|len
init|=
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|register
name|int
name|n_baseclasses
init|=
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
decl_stmt|;
comment|/* First look for the virtual baseclass pointer          in the fields.  */
for|for
control|(
name|i
operator|=
name|n_baseclasses
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|vb_match
argument_list|(
name|type
argument_list|,
name|i
argument_list|,
name|basetype
argument_list|)
condition|)
block|{
name|CORE_ADDR
name|addr
init|=
name|unpack_pointer
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|valaddr
operator|+
operator|(
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
operator|/
literal|8
operator|)
argument_list|)
decl_stmt|;
return|return
name|addr
operator|-
operator|(
name|LONGEST
operator|)
name|address
return|;
block|}
block|}
comment|/* Not in the fields, so try looking through the baseclasses.  */
for|for
control|(
name|i
operator|=
name|index
operator|+
literal|1
init|;
name|i
operator|<
name|n_baseclasses
condition|;
name|i
operator|++
control|)
block|{
name|int
name|boffset
init|=
name|baseclass_offset
argument_list|(
name|type
argument_list|,
name|i
argument_list|,
name|valaddr
argument_list|,
name|address
argument_list|)
decl_stmt|;
if|if
condition|(
name|boffset
condition|)
return|return
name|boffset
return|;
block|}
comment|/* Not found.  */
return|return
operator|-
literal|1
return|;
block|}
comment|/* Baseclass is easily computed.  */
return|return
name|TYPE_BASECLASS_BITPOS
argument_list|(
name|type
argument_list|,
name|index
argument_list|)
operator|/
literal|8
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|init_gnuv2_ops
parameter_list|(
name|void
parameter_list|)
block|{
name|gnu_v2_abi_ops
operator|.
name|shortname
operator|=
literal|"gnu-v2"
expr_stmt|;
name|gnu_v2_abi_ops
operator|.
name|longname
operator|=
literal|"GNU G++ Version 2 ABI"
expr_stmt|;
name|gnu_v2_abi_ops
operator|.
name|doc
operator|=
literal|"G++ Version 2 ABI"
expr_stmt|;
name|gnu_v2_abi_ops
operator|.
name|is_destructor_name
operator|=
name|gnuv2_is_destructor_name
expr_stmt|;
name|gnu_v2_abi_ops
operator|.
name|is_constructor_name
operator|=
name|gnuv2_is_constructor_name
expr_stmt|;
name|gnu_v2_abi_ops
operator|.
name|is_vtable_name
operator|=
name|gnuv2_is_vtable_name
expr_stmt|;
name|gnu_v2_abi_ops
operator|.
name|is_operator_name
operator|=
name|gnuv2_is_operator_name
expr_stmt|;
name|gnu_v2_abi_ops
operator|.
name|virtual_fn_field
operator|=
name|gnuv2_virtual_fn_field
expr_stmt|;
name|gnu_v2_abi_ops
operator|.
name|rtti_type
operator|=
name|gnuv2_value_rtti_type
expr_stmt|;
name|gnu_v2_abi_ops
operator|.
name|baseclass_offset
operator|=
name|gnuv2_baseclass_offset
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_initialize_gnu_v2_abi
parameter_list|(
name|void
parameter_list|)
block|{
name|init_gnuv2_ops
argument_list|()
expr_stmt|;
name|register_cp_abi
argument_list|(
name|gnu_v2_abi_ops
argument_list|)
expr_stmt|;
name|switch_to_cp_abi
argument_list|(
literal|"gnu-v2"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

