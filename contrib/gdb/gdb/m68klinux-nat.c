begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Motorola m68k native support for GNU/Linux.     Copyright 1996, 1998, 2000, 2001, 2002 Free Software Foundation,    Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/ptrace.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/procfs.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_REG_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/reg.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|"gdb_stat.h"
end_include

begin_include
include|#
directive|include
file|"floatformat.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* This table must line up with REGISTER_NAMES in tm-m68k.h */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|int
name|regmap
index|[]
init|=
block|{
name|PT_D0
block|,
name|PT_D1
block|,
name|PT_D2
block|,
name|PT_D3
block|,
name|PT_D4
block|,
name|PT_D5
block|,
name|PT_D6
block|,
name|PT_D7
block|,
name|PT_A0
block|,
name|PT_A1
block|,
name|PT_A2
block|,
name|PT_A3
block|,
name|PT_A4
block|,
name|PT_A5
block|,
name|PT_A6
block|,
name|PT_USP
block|,
name|PT_SR
block|,
name|PT_PC
block|,
comment|/* PT_FP0, ..., PT_FP7 */
literal|21
block|,
literal|24
block|,
literal|27
block|,
literal|30
block|,
literal|33
block|,
literal|36
block|,
literal|39
block|,
literal|42
block|,
comment|/* PT_FPCR, PT_FPSR, PT_FPIAR */
literal|45
block|,
literal|46
block|,
literal|47
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Which ptrace request retrieves which registers?    These apply to the corresponding SET requests as well.  */
end_comment

begin_define
define|#
directive|define
name|NUM_GREGS
value|(18)
end_define

begin_define
define|#
directive|define
name|MAX_NUM_REGS
value|(NUM_GREGS + 11)
end_define

begin_function
name|int
name|getregs_supplies
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
return|return
literal|0
operator|<=
name|regno
operator|&&
name|regno
operator|<
name|NUM_GREGS
return|;
block|}
end_function

begin_function
name|int
name|getfpregs_supplies
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
return|return
name|FP0_REGNUM
operator|<=
name|regno
operator|&&
name|regno
operator|<=
name|FPI_REGNUM
return|;
block|}
end_function

begin_comment
comment|/* Does the current host support the GETREGS request?  */
end_comment

begin_decl_stmt
name|int
name|have_ptrace_getregs
init|=
ifdef|#
directive|ifdef
name|HAVE_PTRACE_GETREGS
literal|1
else|#
directive|else
literal|0
endif|#
directive|endif
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* BLOCKEND is the value of u.u_ar0, and points to the place where GS    is stored.  */
end_comment

begin_function
name|int
name|m68k_linux_register_u_addr
parameter_list|(
name|int
name|blockend
parameter_list|,
name|int
name|regnum
parameter_list|)
block|{
return|return
operator|(
name|blockend
operator|+
literal|4
operator|*
name|regmap
index|[
name|regnum
index|]
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Fetching registers directly from the U area, one at a time.  */
end_comment

begin_comment
comment|/* FIXME: This duplicates code from `inptrace.c'.  The problem is that we    define FETCH_INFERIOR_REGISTERS since we want to use our own versions    of {fetch,store}_inferior_registers that use the GETREGS request.  This    means that the code in `infptrace.c' is #ifdef'd out.  But we need to    fall back on that code when GDB is running on top of a kernel that    doesn't support the GETREGS request.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PT_READ_U
end_ifndef

begin_define
define|#
directive|define
name|PT_READ_U
value|PTRACE_PEEKUSR
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PT_WRITE_U
end_ifndef

begin_define
define|#
directive|define
name|PT_WRITE_U
value|PTRACE_POKEUSR
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Default the type of the ptrace transfer to int.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PTRACE_XFER_TYPE
end_ifndef

begin_define
define|#
directive|define
name|PTRACE_XFER_TYPE
value|int
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Fetch one register.  */
end_comment

begin_function
specifier|static
name|void
name|fetch_register
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
comment|/* This isn't really an address.  But ptrace thinks of it as one.  */
name|CORE_ADDR
name|regaddr
decl_stmt|;
name|char
name|mess
index|[
literal|128
index|]
decl_stmt|;
comment|/* For messages */
specifier|register
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|offset
decl_stmt|;
comment|/* Offset of registers within the u area.  */
name|char
name|buf
index|[
name|MAX_REGISTER_RAW_SIZE
index|]
decl_stmt|;
name|int
name|tid
decl_stmt|;
if|if
condition|(
name|CANNOT_FETCH_REGISTER
argument_list|(
name|regno
argument_list|)
condition|)
block|{
name|memset
argument_list|(
name|buf
argument_list|,
literal|'\0'
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Supply zeroes */
name|supply_register
argument_list|(
name|regno
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Overload thread id onto process id */
if|if
condition|(
operator|(
name|tid
operator|=
name|TIDGET
argument_list|(
name|inferior_ptid
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|tid
operator|=
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
expr_stmt|;
comment|/* no thread id, just use process id */
name|offset
operator|=
name|U_REGS_OFFSET
expr_stmt|;
name|regaddr
operator|=
name|register_addr
argument_list|(
name|regno
argument_list|,
name|offset
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
condition|;
name|i
operator|+=
sizeof|sizeof
argument_list|(
name|PTRACE_XFER_TYPE
argument_list|)
control|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
operator|*
operator|(
name|PTRACE_XFER_TYPE
operator|*
operator|)
operator|&
name|buf
index|[
name|i
index|]
operator|=
name|ptrace
argument_list|(
name|PT_READ_U
argument_list|,
name|tid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|regaddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|regaddr
operator|+=
sizeof|sizeof
argument_list|(
name|PTRACE_XFER_TYPE
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|mess
argument_list|,
literal|"reading register %s (#%d)"
argument_list|,
name|REGISTER_NAME
argument_list|(
name|regno
argument_list|)
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|perror_with_name
argument_list|(
name|mess
argument_list|)
expr_stmt|;
block|}
block|}
name|supply_register
argument_list|(
name|regno
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fetch register values from the inferior.    If REGNO is negative, do this for all registers.    Otherwise, REGNO specifies which register (so we can save time). */
end_comment

begin_function
name|void
name|old_fetch_inferior_registers
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
if|if
condition|(
name|regno
operator|>=
literal|0
condition|)
block|{
name|fetch_register
argument_list|(
name|regno
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|NUM_REGS
condition|;
name|regno
operator|++
control|)
block|{
name|fetch_register
argument_list|(
name|regno
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Store one register. */
end_comment

begin_function
specifier|static
name|void
name|store_register
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
comment|/* This isn't really an address.  But ptrace thinks of it as one.  */
name|CORE_ADDR
name|regaddr
decl_stmt|;
name|char
name|mess
index|[
literal|128
index|]
decl_stmt|;
comment|/* For messages */
specifier|register
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|offset
decl_stmt|;
comment|/* Offset of registers within the u area.  */
name|int
name|tid
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|alloca
argument_list|(
name|MAX_REGISTER_RAW_SIZE
argument_list|)
decl_stmt|;
if|if
condition|(
name|CANNOT_STORE_REGISTER
argument_list|(
name|regno
argument_list|)
condition|)
block|{
return|return;
block|}
comment|/* Overload thread id onto process id */
if|if
condition|(
operator|(
name|tid
operator|=
name|TIDGET
argument_list|(
name|inferior_ptid
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|tid
operator|=
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
expr_stmt|;
comment|/* no thread id, just use process id */
name|offset
operator|=
name|U_REGS_OFFSET
expr_stmt|;
name|regaddr
operator|=
name|register_addr
argument_list|(
name|regno
argument_list|,
name|offset
argument_list|)
expr_stmt|;
comment|/* Put the contents of regno into a local buffer */
name|regcache_collect
argument_list|(
name|regno
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* Store the local buffer into the inferior a chunk at the time. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
condition|;
name|i
operator|+=
sizeof|sizeof
argument_list|(
name|PTRACE_XFER_TYPE
argument_list|)
control|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|ptrace
argument_list|(
name|PT_WRITE_U
argument_list|,
name|tid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|regaddr
argument_list|,
operator|*
operator|(
name|PTRACE_XFER_TYPE
operator|*
operator|)
operator|(
name|buf
operator|+
name|i
operator|)
argument_list|)
expr_stmt|;
name|regaddr
operator|+=
sizeof|sizeof
argument_list|(
name|PTRACE_XFER_TYPE
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|mess
argument_list|,
literal|"writing register %s (#%d)"
argument_list|,
name|REGISTER_NAME
argument_list|(
name|regno
argument_list|)
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|perror_with_name
argument_list|(
name|mess
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Store our register values back into the inferior.    If REGNO is negative, do this for all registers.    Otherwise, REGNO specifies which register (so we can save time).  */
end_comment

begin_function
name|void
name|old_store_inferior_registers
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
if|if
condition|(
name|regno
operator|>=
literal|0
condition|)
block|{
name|store_register
argument_list|(
name|regno
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|NUM_REGS
condition|;
name|regno
operator|++
control|)
block|{
name|store_register
argument_list|(
name|regno
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  Given a pointer to a general register set in /proc format    (elf_gregset_t *), unpack the register contents and supply    them as gdb's idea of the current register values. */
end_comment

begin_comment
comment|/* Note both m68k-tdep.c and m68klinux-nat.c contain definitions    for supply_gregset and supply_fpregset. The definitions    in m68k-tdep.c are valid if USE_PROC_FS is defined. Otherwise,    the definitions in m68klinux-nat.c will be used. This is a     bit of a hack. The supply_* routines do not belong in     *_tdep.c files. But, there are several lynx ports that currently     depend on these definitions. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|USE_PROC_FS
end_ifndef

begin_comment
comment|/* Prototypes for supply_gregset etc. */
end_comment

begin_include
include|#
directive|include
file|"gregset.h"
end_include

begin_function
name|void
name|supply_gregset
parameter_list|(
name|elf_gregset_t
modifier|*
name|gregsetp
parameter_list|)
block|{
name|elf_greg_t
modifier|*
name|regp
init|=
operator|(
name|elf_greg_t
operator|*
operator|)
name|gregsetp
decl_stmt|;
name|int
name|regi
decl_stmt|;
for|for
control|(
name|regi
operator|=
name|D0_REGNUM
init|;
name|regi
operator|<=
name|SP_REGNUM
condition|;
name|regi
operator|++
control|)
name|supply_register
argument_list|(
name|regi
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|regp
index|[
name|regmap
index|[
name|regi
index|]
index|]
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|PS_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|regp
index|[
name|PT_SR
index|]
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|PC_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|regp
index|[
name|PT_PC
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fill register REGNO (if it is a general-purpose register) in    *GREGSETPS with the value in GDB's register array.  If REGNO is -1,    do this for all registers.  */
end_comment

begin_function
name|void
name|fill_gregset
parameter_list|(
name|elf_gregset_t
modifier|*
name|gregsetp
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
name|elf_greg_t
modifier|*
name|regp
init|=
operator|(
name|elf_greg_t
operator|*
operator|)
name|gregsetp
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_GREGS
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|||
name|regno
operator|==
name|i
operator|)
condition|)
name|regcache_collect
argument_list|(
name|i
argument_list|,
name|regp
operator|+
name|regmap
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PTRACE_GETREGS
end_ifdef

begin_comment
comment|/* Fetch all general-purpose registers from process/thread TID and    store their values in GDB's register array.  */
end_comment

begin_function
specifier|static
name|void
name|fetch_regs
parameter_list|(
name|int
name|tid
parameter_list|)
block|{
name|elf_gregset_t
name|regs
decl_stmt|;
if|if
condition|(
name|ptrace
argument_list|(
name|PTRACE_GETREGS
argument_list|,
name|tid
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|)
operator|&
name|regs
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EIO
condition|)
block|{
comment|/* The kernel we're running on doesn't support the GETREGS              request.  Reset `have_ptrace_getregs'.  */
name|have_ptrace_getregs
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|perror_with_name
argument_list|(
literal|"Couldn't get registers"
argument_list|)
expr_stmt|;
block|}
name|supply_gregset
argument_list|(
operator|&
name|regs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Store all valid general-purpose registers in GDB's register array    into the process/thread specified by TID.  */
end_comment

begin_function
specifier|static
name|void
name|store_regs
parameter_list|(
name|int
name|tid
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
name|elf_gregset_t
name|regs
decl_stmt|;
if|if
condition|(
name|ptrace
argument_list|(
name|PTRACE_GETREGS
argument_list|,
name|tid
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|)
operator|&
name|regs
argument_list|)
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
literal|"Couldn't get registers"
argument_list|)
expr_stmt|;
name|fill_gregset
argument_list|(
operator|&
name|regs
argument_list|,
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptrace
argument_list|(
name|PTRACE_SETREGS
argument_list|,
name|tid
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|)
operator|&
name|regs
argument_list|)
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
literal|"Couldn't write registers"
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|void
name|fetch_regs
parameter_list|(
name|int
name|tid
parameter_list|)
block|{}
end_function

begin_function
specifier|static
name|void
name|store_regs
parameter_list|(
name|int
name|tid
parameter_list|,
name|int
name|regno
parameter_list|)
block|{}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Transfering floating-point registers between GDB, inferiors and cores.  */
end_comment

begin_comment
comment|/* What is the address of fpN within the floating-point register set F?  */
end_comment

begin_define
define|#
directive|define
name|FPREG_ADDR
parameter_list|(
name|f
parameter_list|,
name|n
parameter_list|)
value|((char *)&(f)->fpregs[(n) * 3])
end_define

begin_comment
comment|/* Fill GDB's register array with the floating-point register values in    *FPREGSETP.  */
end_comment

begin_function
name|void
name|supply_fpregset
parameter_list|(
name|elf_fpregset_t
modifier|*
name|fpregsetp
parameter_list|)
block|{
name|int
name|regi
decl_stmt|;
for|for
control|(
name|regi
operator|=
name|FP0_REGNUM
init|;
name|regi
operator|<
name|FPC_REGNUM
condition|;
name|regi
operator|++
control|)
name|supply_register
argument_list|(
name|regi
argument_list|,
name|FPREG_ADDR
argument_list|(
name|fpregsetp
argument_list|,
name|regi
operator|-
name|FP0_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|FPC_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|fpregsetp
operator|->
name|fpcntl
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|FPS_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|fpregsetp
operator|->
name|fpcntl
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|FPI_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|fpregsetp
operator|->
name|fpcntl
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fill register REGNO (if it is a floating-point register) in    *FPREGSETP with the value in GDB's register array.  If REGNO is -1,    do this for all registers.  */
end_comment

begin_function
name|void
name|fill_fpregset
parameter_list|(
name|elf_fpregset_t
modifier|*
name|fpregsetp
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Fill in the floating-point registers.  */
for|for
control|(
name|i
operator|=
name|FP0_REGNUM
init|;
name|i
operator|<
name|FP0_REGNUM
operator|+
literal|8
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regno
operator|==
operator|-
literal|1
operator|||
name|regno
operator|==
name|i
condition|)
name|regcache_collect
argument_list|(
name|regno
argument_list|,
name|FPREG_ADDR
argument_list|(
name|fpregsetp
argument_list|,
name|regno
operator|-
name|FP0_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fill in the floating-point control registers.  */
for|for
control|(
name|i
operator|=
name|FPC_REGNUM
init|;
name|i
operator|<=
name|FPI_REGNUM
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regno
operator|==
operator|-
literal|1
operator|||
name|regno
operator|==
name|i
condition|)
name|regcache_collect
argument_list|(
name|regno
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|fpregsetp
operator|->
name|fpcntl
index|[
name|regno
operator|-
name|FPC_REGNUM
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PTRACE_GETREGS
end_ifdef

begin_comment
comment|/* Fetch all floating-point registers from process/thread TID and store    thier values in GDB's register array.  */
end_comment

begin_function
specifier|static
name|void
name|fetch_fpregs
parameter_list|(
name|int
name|tid
parameter_list|)
block|{
name|elf_fpregset_t
name|fpregs
decl_stmt|;
if|if
condition|(
name|ptrace
argument_list|(
name|PTRACE_GETFPREGS
argument_list|,
name|tid
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|)
operator|&
name|fpregs
argument_list|)
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
literal|"Couldn't get floating point status"
argument_list|)
expr_stmt|;
name|supply_fpregset
argument_list|(
operator|&
name|fpregs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Store all valid floating-point registers in GDB's register array    into the process/thread specified by TID.  */
end_comment

begin_function
specifier|static
name|void
name|store_fpregs
parameter_list|(
name|int
name|tid
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
name|elf_fpregset_t
name|fpregs
decl_stmt|;
if|if
condition|(
name|ptrace
argument_list|(
name|PTRACE_GETFPREGS
argument_list|,
name|tid
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|)
operator|&
name|fpregs
argument_list|)
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
literal|"Couldn't get floating point status"
argument_list|)
expr_stmt|;
name|fill_fpregset
argument_list|(
operator|&
name|fpregs
argument_list|,
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptrace
argument_list|(
name|PTRACE_SETFPREGS
argument_list|,
name|tid
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|)
operator|&
name|fpregs
argument_list|)
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
literal|"Couldn't write floating point status"
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|void
name|fetch_fpregs
parameter_list|(
name|int
name|tid
parameter_list|)
block|{}
end_function

begin_function
specifier|static
name|void
name|store_fpregs
parameter_list|(
name|int
name|tid
parameter_list|,
name|int
name|regno
parameter_list|)
block|{}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Transferring arbitrary registers between GDB and inferior.  */
end_comment

begin_comment
comment|/* Fetch register REGNO from the child process.  If REGNO is -1, do    this for all registers (including the floating point and SSE    registers).  */
end_comment

begin_function
name|void
name|fetch_inferior_registers
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
name|int
name|tid
decl_stmt|;
comment|/* Use the old method of peeking around in `struct user' if the      GETREGS request isn't available.  */
if|if
condition|(
operator|!
name|have_ptrace_getregs
condition|)
block|{
name|old_fetch_inferior_registers
argument_list|(
name|regno
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* GNU/Linux LWP ID's are process ID's.  */
if|if
condition|(
operator|(
name|tid
operator|=
name|TIDGET
argument_list|(
name|inferior_ptid
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|tid
operator|=
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
expr_stmt|;
comment|/* Not a threaded program.  */
comment|/* Use the PTRACE_GETFPXREGS request whenever possible, since it      transfers more registers in one system call, and we'll cache the      results.  But remember that fetch_fpxregs can fail, and return      zero.  */
if|if
condition|(
name|regno
operator|==
operator|-
literal|1
condition|)
block|{
name|fetch_regs
argument_list|(
name|tid
argument_list|)
expr_stmt|;
comment|/* The call above might reset `have_ptrace_getregs'.  */
if|if
condition|(
operator|!
name|have_ptrace_getregs
condition|)
block|{
name|old_fetch_inferior_registers
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|fetch_fpregs
argument_list|(
name|tid
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|getregs_supplies
argument_list|(
name|regno
argument_list|)
condition|)
block|{
name|fetch_regs
argument_list|(
name|tid
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|getfpregs_supplies
argument_list|(
name|regno
argument_list|)
condition|)
block|{
name|fetch_fpregs
argument_list|(
name|tid
argument_list|)
expr_stmt|;
return|return;
block|}
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"Got request for bad register number %d."
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Store register REGNO back into the child process.  If REGNO is -1,    do this for all registers (including the floating point and SSE    registers).  */
end_comment

begin_function
name|void
name|store_inferior_registers
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
name|int
name|tid
decl_stmt|;
comment|/* Use the old method of poking around in `struct user' if the      SETREGS request isn't available.  */
if|if
condition|(
operator|!
name|have_ptrace_getregs
condition|)
block|{
name|old_store_inferior_registers
argument_list|(
name|regno
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* GNU/Linux LWP ID's are process ID's.  */
if|if
condition|(
operator|(
name|tid
operator|=
name|TIDGET
argument_list|(
name|inferior_ptid
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|tid
operator|=
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
expr_stmt|;
comment|/* Not a threaded program.  */
comment|/* Use the PTRACE_SETFPREGS requests whenever possible, since it      transfers more registers in one system call.  But remember that      store_fpregs can fail, and return zero.  */
if|if
condition|(
name|regno
operator|==
operator|-
literal|1
condition|)
block|{
name|store_regs
argument_list|(
name|tid
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|store_fpregs
argument_list|(
name|tid
argument_list|,
name|regno
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|getregs_supplies
argument_list|(
name|regno
argument_list|)
condition|)
block|{
name|store_regs
argument_list|(
name|tid
argument_list|,
name|regno
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|getfpregs_supplies
argument_list|(
name|regno
argument_list|)
condition|)
block|{
name|store_fpregs
argument_list|(
name|tid
argument_list|,
name|regno
argument_list|)
expr_stmt|;
return|return;
block|}
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"Got request to store bad register number %d."
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Interpreting register set info found in core files.  */
end_comment

begin_comment
comment|/* Provide registers to GDB from a core file.     (We can't use the generic version of this function in    core-regset.c, because we need to use elf_gregset_t instead of    gregset_t.)     CORE_REG_SECT points to an array of bytes, which are the contents    of a `note' from a core file which BFD thinks might contain    register contents.  CORE_REG_SIZE is its size.     WHICH says which register set corelow suspects this is:      0 --- the general-purpose register set, in elf_gregset_t format      2 --- the floating-point register set, in elf_fpregset_t format     REG_ADDR isn't used on GNU/Linux.  */
end_comment

begin_function
specifier|static
name|void
name|fetch_core_registers
parameter_list|(
name|char
modifier|*
name|core_reg_sect
parameter_list|,
name|unsigned
name|core_reg_size
parameter_list|,
name|int
name|which
parameter_list|,
name|CORE_ADDR
name|reg_addr
parameter_list|)
block|{
name|elf_gregset_t
name|gregset
decl_stmt|;
name|elf_fpregset_t
name|fpregset
decl_stmt|;
switch|switch
condition|(
name|which
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
name|core_reg_size
operator|!=
sizeof|sizeof
argument_list|(
name|gregset
argument_list|)
condition|)
name|warning
argument_list|(
literal|"Wrong size gregset in core file."
argument_list|)
expr_stmt|;
else|else
block|{
name|memcpy
argument_list|(
operator|&
name|gregset
argument_list|,
name|core_reg_sect
argument_list|,
sizeof|sizeof
argument_list|(
name|gregset
argument_list|)
argument_list|)
expr_stmt|;
name|supply_gregset
argument_list|(
operator|&
name|gregset
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
if|if
condition|(
name|core_reg_size
operator|!=
sizeof|sizeof
argument_list|(
name|fpregset
argument_list|)
condition|)
name|warning
argument_list|(
literal|"Wrong size fpregset in core file."
argument_list|)
expr_stmt|;
else|else
block|{
name|memcpy
argument_list|(
operator|&
name|fpregset
argument_list|,
name|core_reg_sect
argument_list|,
sizeof|sizeof
argument_list|(
name|fpregset
argument_list|)
argument_list|)
expr_stmt|;
name|supply_fpregset
argument_list|(
operator|&
name|fpregset
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
comment|/* We've covered all the kinds of registers we know about here,          so this must be something we wouldn't know what to do with          anyway.  Just ignore it.  */
break|break;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
name|int
name|kernel_u_size
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|user
argument_list|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Check whether insn1 and insn2 are parts of a signal trampoline.  */
end_comment

begin_define
define|#
directive|define
name|IS_SIGTRAMP
parameter_list|(
name|insn1
parameter_list|,
name|insn2
parameter_list|)
define|\
value|(
comment|/* addaw #20,sp; moveq #119,d0; trap #0 */
value|\    (insn1 == 0xdefc0014&& insn2 == 0x70774e40)				\
comment|/* moveq #119,d0; trap #0 */
value|\    || insn1 == 0x70774e40)
end_define

begin_define
define|#
directive|define
name|IS_RT_SIGTRAMP
parameter_list|(
name|insn1
parameter_list|,
name|insn2
parameter_list|)
define|\
value|(
comment|/* movel #173,d0; trap #0 */
value|\    (insn1 == 0x203c0000&& insn2 == 0x00ad4e40)				\
comment|/* moveq #82,d0; notb d0; trap #0 */
value|\    || (insn1 == 0x70524600&& (insn2>> 16) == 0x4e40))
end_define

begin_comment
comment|/* Return non-zero if PC points into the signal trampoline.  For the sake    of m68k_linux_frame_saved_pc we also distinguish between non-RT and RT    signal trampolines.  */
end_comment

begin_function
name|int
name|m68k_linux_in_sigtramp
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
name|CORE_ADDR
name|sp
decl_stmt|;
name|char
name|buf
index|[
literal|12
index|]
decl_stmt|;
name|unsigned
name|long
name|insn0
decl_stmt|,
name|insn1
decl_stmt|,
name|insn2
decl_stmt|;
if|if
condition|(
name|read_memory_nobpt
argument_list|(
name|pc
operator|-
literal|4
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|insn1
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
operator|+
literal|4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|insn2
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
operator|+
literal|8
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_SIGTRAMP
argument_list|(
name|insn1
argument_list|,
name|insn2
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|IS_RT_SIGTRAMP
argument_list|(
name|insn1
argument_list|,
name|insn2
argument_list|)
condition|)
return|return
literal|2
return|;
name|insn0
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_SIGTRAMP
argument_list|(
name|insn0
argument_list|,
name|insn1
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|IS_RT_SIGTRAMP
argument_list|(
name|insn0
argument_list|,
name|insn1
argument_list|)
condition|)
return|return
literal|2
return|;
name|insn0
operator|=
operator|(
name|insn0
operator|<<
literal|16
operator|)
operator||
operator|(
name|insn1
operator|>>
literal|16
operator|)
expr_stmt|;
name|insn1
operator|=
operator|(
name|insn1
operator|<<
literal|16
operator|)
operator||
operator|(
name|insn2
operator|>>
literal|16
operator|)
expr_stmt|;
if|if
condition|(
name|IS_SIGTRAMP
argument_list|(
name|insn0
argument_list|,
name|insn1
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|IS_RT_SIGTRAMP
argument_list|(
name|insn0
argument_list|,
name|insn1
argument_list|)
condition|)
return|return
literal|2
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Offset to saved PC in sigcontext, from<asm/sigcontext.h>.  */
end_comment

begin_define
define|#
directive|define
name|SIGCONTEXT_PC_OFFSET
value|26
end_define

begin_comment
comment|/* Offset to saved PC in ucontext, from<asm/ucontext.h>.  */
end_comment

begin_define
define|#
directive|define
name|UCONTEXT_PC_OFFSET
value|88
end_define

begin_comment
comment|/* Get saved user PC for sigtramp from sigcontext or ucontext.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|m68k_linux_sigtramp_saved_pc
parameter_list|(
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|)
block|{
name|CORE_ADDR
name|sigcontext_addr
decl_stmt|;
name|char
name|buf
index|[
name|TARGET_PTR_BIT
operator|/
name|TARGET_CHAR_BIT
index|]
decl_stmt|;
name|int
name|ptrbytes
init|=
name|TARGET_PTR_BIT
operator|/
name|TARGET_CHAR_BIT
decl_stmt|;
name|int
name|sigcontext_offs
init|=
operator|(
literal|2
operator|*
name|TARGET_INT_BIT
operator|)
operator|/
name|TARGET_CHAR_BIT
decl_stmt|;
comment|/* Get sigcontext address, it is the third parameter on the stack.  */
if|if
condition|(
name|frame
operator|->
name|next
condition|)
name|sigcontext_addr
operator|=
name|read_memory_integer
argument_list|(
name|FRAME_ARGS_ADDRESS
argument_list|(
name|frame
operator|->
name|next
argument_list|)
operator|+
name|FRAME_ARGS_SKIP
operator|+
name|sigcontext_offs
argument_list|,
name|ptrbytes
argument_list|)
expr_stmt|;
else|else
name|sigcontext_addr
operator|=
name|read_memory_integer
argument_list|(
name|read_register
argument_list|(
name|SP_REGNUM
argument_list|)
operator|+
name|sigcontext_offs
argument_list|,
name|ptrbytes
argument_list|)
expr_stmt|;
comment|/* Don't cause a memory_error when accessing sigcontext in case the      stack layout has changed or the stack is corrupt.  */
if|if
condition|(
name|m68k_linux_in_sigtramp
argument_list|(
name|frame
operator|->
name|pc
argument_list|)
operator|==
literal|2
condition|)
name|target_read_memory
argument_list|(
name|sigcontext_addr
operator|+
name|UCONTEXT_PC_OFFSET
argument_list|,
name|buf
argument_list|,
name|ptrbytes
argument_list|)
expr_stmt|;
else|else
name|target_read_memory
argument_list|(
name|sigcontext_addr
operator|+
name|SIGCONTEXT_PC_OFFSET
argument_list|,
name|buf
argument_list|,
name|ptrbytes
argument_list|)
expr_stmt|;
return|return
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
name|ptrbytes
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the saved program counter for FRAME.  */
end_comment

begin_function
name|CORE_ADDR
name|m68k_linux_frame_saved_pc
parameter_list|(
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|)
block|{
if|if
condition|(
name|frame
operator|->
name|signal_handler_caller
condition|)
return|return
name|m68k_linux_sigtramp_saved_pc
argument_list|(
name|frame
argument_list|)
return|;
return|return
name|read_memory_integer
argument_list|(
name|frame
operator|->
name|frame
operator|+
literal|4
argument_list|,
literal|4
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Register that we are able to handle GNU/Linux ELF core file    formats.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|core_fns
name|linux_elf_core_fns
init|=
block|{
name|bfd_target_elf_flavour
block|,
comment|/* core_flavour */
name|default_check_format
block|,
comment|/* check_format */
name|default_core_sniffer
block|,
comment|/* core_sniffer */
name|fetch_core_registers
block|,
comment|/* core_read_registers */
name|NULL
comment|/* next */
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|_initialize_m68k_linux_nat
parameter_list|()
block|{
name|add_core_fns
argument_list|(
operator|&
name|linux_elf_core_fns
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

