begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Language independent support for printing types for GDB, the GNU debugger.    Copyright 1986, 88, 89, 91, 92, 93, 1998 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_comment
comment|/* Binary File Description */
end_comment

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_comment
comment|/* For real-type printing in whatis_exp() */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|objectprint
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Controls looking up an object's derived type 				   using what we find in its vtables.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|ptype_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|ptype_eval
name|PARAMS
argument_list|(
operator|(
expr|struct
name|expression
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|whatis_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|whatis_exp
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print a description of a type TYPE in the form of a declaration of a    variable named VARSTRING.  (VARSTRING is demangled if necessary.)    Output goes to STREAM (via stdio).    If SHOW is positive, we show the contents of the outermost level    of structure even if there is a type name that could be used instead.    If SHOW is negative, we never show the details of elements' types.  */
end_comment

begin_function
name|void
name|type_print
parameter_list|(
name|type
parameter_list|,
name|varstring
parameter_list|,
name|stream
parameter_list|,
name|show
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|char
modifier|*
name|varstring
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|show
decl_stmt|;
block|{
name|LA_PRINT_TYPE
argument_list|(
name|type
argument_list|,
name|varstring
argument_list|,
name|stream
argument_list|,
name|show
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print type of EXP, or last thing in value history if EXP == NULL.    show is passed to type_print.  */
end_comment

begin_function
specifier|static
name|void
name|whatis_exp
parameter_list|(
name|exp
parameter_list|,
name|show
parameter_list|)
name|char
modifier|*
name|exp
decl_stmt|;
name|int
name|show
decl_stmt|;
block|{
name|struct
name|expression
modifier|*
name|expr
decl_stmt|;
specifier|register
name|value_ptr
name|val
decl_stmt|;
specifier|register
name|struct
name|cleanup
modifier|*
name|old_chain
init|=
name|NULL
decl_stmt|;
name|struct
name|type
modifier|*
name|real_type
init|=
name|NULL
decl_stmt|;
name|int
name|full
init|=
literal|0
decl_stmt|;
name|int
name|top
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|using_enc
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|exp
condition|)
block|{
name|expr
operator|=
name|parse_expression
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
operator|(
name|make_cleanup_func
operator|)
name|free_current_contents
argument_list|,
operator|&
name|expr
argument_list|)
expr_stmt|;
name|val
operator|=
name|evaluate_type
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
else|else
name|val
operator|=
name|access_value_history
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|real_type
operator|=
name|value_rtti_type
argument_list|(
name|val
argument_list|,
operator|&
name|full
argument_list|,
operator|&
name|top
argument_list|,
operator|&
name|using_enc
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"type = "
argument_list|)
expr_stmt|;
if|if
condition|(
name|real_type
operator|&&
name|objectprint
condition|)
name|printf_filtered
argument_list|(
literal|"/* real type = %s%s */\n"
argument_list|,
name|TYPE_NAME
argument_list|(
name|real_type
argument_list|)
argument_list|,
name|full
condition|?
literal|""
else|:
literal|" (incomplete object)"
argument_list|)
expr_stmt|;
comment|/* FIXME: maybe better to use type_print (real_type, "", gdb_stdout, -1); */
name|type_print
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|,
literal|""
argument_list|,
name|gdb_stdout
argument_list|,
name|show
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
condition|)
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|whatis_command
parameter_list|(
name|exp
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|exp
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
comment|/* Most of the time users do not want to see all the fields      in a structure.  If they do they can use the "ptype" command.      Hence the "-1" below.  */
name|whatis_exp
argument_list|(
name|exp
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Simple subroutine for ptype_command.  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|ptype_eval
parameter_list|(
name|exp
parameter_list|)
name|struct
name|expression
modifier|*
name|exp
decl_stmt|;
block|{
if|if
condition|(
name|exp
operator|->
name|elts
index|[
literal|0
index|]
operator|.
name|opcode
operator|==
name|OP_TYPE
condition|)
block|{
return|return
operator|(
name|exp
operator|->
name|elts
index|[
literal|1
index|]
operator|.
name|type
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* TYPENAME is either the name of a type, or an expression.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|ptype_command
parameter_list|(
name|typename
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|typename
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
specifier|register
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|struct
name|expression
modifier|*
name|expr
decl_stmt|;
specifier|register
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
if|if
condition|(
name|typename
operator|==
name|NULL
condition|)
block|{
comment|/* Print type of last thing in value history. */
name|whatis_exp
argument_list|(
name|typename
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|expr
operator|=
name|parse_expression
argument_list|(
name|typename
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
operator|(
name|make_cleanup_func
operator|)
name|free_current_contents
argument_list|,
operator|&
name|expr
argument_list|)
expr_stmt|;
name|type
operator|=
name|ptype_eval
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|NULL
condition|)
block|{
comment|/* User did "ptype<typename>" */
name|printf_filtered
argument_list|(
literal|"type = "
argument_list|)
expr_stmt|;
name|type_print
argument_list|(
name|type
argument_list|,
literal|""
argument_list|,
name|gdb_stdout
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* User did "ptype<symbolname>" */
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
name|whatis_exp
argument_list|(
name|typename
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Print integral scalar data VAL, of type TYPE, onto stdio stream STREAM.    Used to print data from type structures in a specified type.  For example,    array bounds may be characters or booleans in some languages, and this    allows the ranges to be printed in their "natural" form rather than as    decimal integer values.     FIXME:  This is here simply because only the type printing routines    currently use it, and it wasn't clear if it really belonged somewhere    else (like printcmd.c).  There are a lot of other gdb routines that do    something similar, but they are generally concerned with printing values    that come from the inferior in target byte order and target size. */
end_comment

begin_function
name|void
name|print_type_scalar
parameter_list|(
name|type
parameter_list|,
name|val
parameter_list|,
name|stream
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|LONGEST
name|val
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|len
decl_stmt|;
name|CHECK_TYPEDEF
argument_list|(
name|type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_ENUM
case|:
name|len
operator|=
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
operator|==
name|val
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|<
name|len
condition|)
block|{
name|fputs_filtered
argument_list|(
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|print_longest
argument_list|(
name|stream
argument_list|,
literal|'d'
argument_list|,
literal|0
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_CODE_INT
case|:
name|print_longest
argument_list|(
name|stream
argument_list|,
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|?
literal|'u'
else|:
literal|'d'
argument_list|,
literal|0
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_CHAR
case|:
name|LA_PRINT_CHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|val
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_BOOL
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|val
condition|?
literal|"TRUE"
else|:
literal|"FALSE"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_RANGE
case|:
name|print_type_scalar
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|val
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
case|case
name|TYPE_CODE_UNDEF
case|:
case|case
name|TYPE_CODE_PTR
case|:
case|case
name|TYPE_CODE_ARRAY
case|:
case|case
name|TYPE_CODE_STRUCT
case|:
case|case
name|TYPE_CODE_UNION
case|:
case|case
name|TYPE_CODE_FUNC
case|:
case|case
name|TYPE_CODE_FLT
case|:
case|case
name|TYPE_CODE_VOID
case|:
case|case
name|TYPE_CODE_SET
case|:
case|case
name|TYPE_CODE_STRING
case|:
case|case
name|TYPE_CODE_ERROR
case|:
case|case
name|TYPE_CODE_MEMBER
case|:
case|case
name|TYPE_CODE_METHOD
case|:
case|case
name|TYPE_CODE_REF
case|:
name|error
argument_list|(
literal|"internal error: unhandled type in print_type_scalar"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Invalid type code in symbol table."
argument_list|)
expr_stmt|;
block|}
name|gdb_flush
argument_list|(
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|MAINTENANCE_CMDS
end_if

begin_comment
comment|/* Dump details of a type specified either directly or indirectly.    Uses the same sort of type lookup mechanism as ptype_command()    and whatis_command(). */
end_comment

begin_function
name|void
name|maintenance_print_type
parameter_list|(
name|typename
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|typename
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
specifier|register
name|value_ptr
name|val
decl_stmt|;
specifier|register
name|struct
name|type
modifier|*
name|type
decl_stmt|;
specifier|register
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|struct
name|expression
modifier|*
name|expr
decl_stmt|;
if|if
condition|(
name|typename
operator|!=
name|NULL
condition|)
block|{
name|expr
operator|=
name|parse_expression
argument_list|(
name|typename
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
operator|(
name|make_cleanup_func
operator|)
name|free_current_contents
argument_list|,
operator|&
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
operator|->
name|elts
index|[
literal|0
index|]
operator|.
name|opcode
operator|==
name|OP_TYPE
condition|)
block|{
comment|/* The user expression names a type directly, just use that type. */
name|type
operator|=
name|expr
operator|->
name|elts
index|[
literal|1
index|]
operator|.
name|type
expr_stmt|;
block|}
else|else
block|{
comment|/* The user expression may name a type indirectly by naming an 	   object of that type.  Find that indirectly named type. */
name|val
operator|=
name|evaluate_type
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|type
operator|=
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|!=
name|NULL
condition|)
block|{
name|recursive_dump_type
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MAINTENANCE_CMDS */
end_comment

begin_escape
end_escape

begin_function
name|void
name|_initialize_typeprint
parameter_list|()
block|{
name|add_com
argument_list|(
literal|"ptype"
argument_list|,
name|class_vars
argument_list|,
name|ptype_command
argument_list|,
literal|"Print definition of type TYPE.\n\ Argument may be a type name defined by typedef, or \"struct STRUCT-TAG\"\n\ or \"class CLASS-NAME\" or \"union UNION-TAG\" or \"enum ENUM-TAG\".\n\ The selected stack frame's lexical context is used to look up the name."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"whatis"
argument_list|,
name|class_vars
argument_list|,
name|whatis_command
argument_list|,
literal|"Print data type of expression EXP."
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

