begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Perform arithmetic and other operations on values, for GDB.    Copyright 1986, 89, 91, 92, 93, 94, 95, 96, 97, 1998    Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_comment
comment|/* Define whether or not the C operator '/' truncates towards zero for    differently signed operands (truncation direction is undefined in C). */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|TRUNCATION_TOWARDS_ZERO
end_ifndef

begin_define
define|#
directive|define
name|TRUNCATION_TOWARDS_ZERO
value|((-5 / 2) == -2)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|value_ptr
name|value_subscripted_rvalue
name|PARAMS
argument_list|(
operator|(
name|value_ptr
operator|,
name|value_ptr
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|_initialize_valarith
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
name|value_ptr
name|value_add
parameter_list|(
name|arg1
parameter_list|,
name|arg2
parameter_list|)
name|value_ptr
name|arg1
decl_stmt|,
name|arg2
decl_stmt|;
block|{
specifier|register
name|value_ptr
name|valint
decl_stmt|,
name|valptr
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
name|struct
name|type
modifier|*
name|type1
decl_stmt|,
modifier|*
name|type2
decl_stmt|,
modifier|*
name|valptrtype
decl_stmt|;
name|COERCE_NUMBER
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|COERCE_NUMBER
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
name|type1
operator|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
name|type2
operator|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TYPE_CODE
argument_list|(
name|type1
argument_list|)
operator|==
name|TYPE_CODE_PTR
operator|||
name|TYPE_CODE
argument_list|(
name|type2
argument_list|)
operator|==
name|TYPE_CODE_PTR
operator|)
operator|&&
operator|(
name|TYPE_CODE
argument_list|(
name|type1
argument_list|)
operator|==
name|TYPE_CODE_INT
operator|||
name|TYPE_CODE
argument_list|(
name|type2
argument_list|)
operator|==
name|TYPE_CODE_INT
operator|)
condition|)
comment|/* Exactly one argument is a pointer, and one is an integer.  */
block|{
name|value_ptr
name|retval
decl_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type1
argument_list|)
operator|==
name|TYPE_CODE_PTR
condition|)
block|{
name|valptr
operator|=
name|arg1
expr_stmt|;
name|valint
operator|=
name|arg2
expr_stmt|;
name|valptrtype
operator|=
name|type1
expr_stmt|;
block|}
else|else
block|{
name|valptr
operator|=
name|arg2
expr_stmt|;
name|valint
operator|=
name|arg1
expr_stmt|;
name|valptrtype
operator|=
name|type2
expr_stmt|;
block|}
name|len
operator|=
name|TYPE_LENGTH
argument_list|(
name|check_typedef
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|valptrtype
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
name|len
operator|=
literal|1
expr_stmt|;
comment|/* For (void *) */
name|retval
operator|=
name|value_from_longest
argument_list|(
name|valptrtype
argument_list|,
name|value_as_long
argument_list|(
name|valptr
argument_list|)
operator|+
operator|(
name|len
operator|*
name|value_as_long
argument_list|(
name|valint
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|VALUE_BFD_SECTION
argument_list|(
name|retval
argument_list|)
operator|=
name|VALUE_BFD_SECTION
argument_list|(
name|valptr
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
return|return
name|value_binop
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
name|BINOP_ADD
argument_list|)
return|;
block|}
end_function

begin_function
name|value_ptr
name|value_sub
parameter_list|(
name|arg1
parameter_list|,
name|arg2
parameter_list|)
name|value_ptr
name|arg1
decl_stmt|,
name|arg2
decl_stmt|;
block|{
name|struct
name|type
modifier|*
name|type1
decl_stmt|,
modifier|*
name|type2
decl_stmt|;
name|COERCE_NUMBER
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|COERCE_NUMBER
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
name|type1
operator|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
name|type2
operator|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type1
argument_list|)
operator|==
name|TYPE_CODE_PTR
condition|)
block|{
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type2
argument_list|)
operator|==
name|TYPE_CODE_INT
condition|)
block|{
comment|/* pointer - integer.  */
name|LONGEST
name|sz
init|=
name|TYPE_LENGTH
argument_list|(
name|check_typedef
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type1
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|value_from_longest
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|value_as_long
argument_list|(
name|arg1
argument_list|)
operator|-
operator|(
name|sz
operator|*
name|value_as_long
argument_list|(
name|arg2
argument_list|)
operator|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type2
argument_list|)
operator|==
name|TYPE_CODE_PTR
operator|&&
name|TYPE_LENGTH
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type1
argument_list|)
argument_list|)
operator|==
name|TYPE_LENGTH
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type2
argument_list|)
argument_list|)
condition|)
block|{
comment|/* pointer to<type x> - pointer to<type x>.  */
name|LONGEST
name|sz
init|=
name|TYPE_LENGTH
argument_list|(
name|check_typedef
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type1
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|value_from_longest
argument_list|(
name|builtin_type_long
argument_list|,
comment|/* FIXME -- should be ptrdiff_t */
operator|(
name|value_as_long
argument_list|(
name|arg1
argument_list|)
operator|-
name|value_as_long
argument_list|(
name|arg2
argument_list|)
operator|)
operator|/
name|sz
argument_list|)
return|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"\ First argument of `-' is a pointer and second argument is neither\n\ an integer nor a pointer of the same type."
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|value_binop
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
name|BINOP_SUB
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the value of ARRAY[IDX].    See comments in value_coerce_array() for rationale for reason for    doing lower bounds adjustment here rather than there.    FIXME:  Perhaps we should validate that the index is valid and if    verbosity is set, warn about invalid indices (but still use them). */
end_comment

begin_function
name|value_ptr
name|value_subscript
parameter_list|(
name|array
parameter_list|,
name|idx
parameter_list|)
name|value_ptr
name|array
decl_stmt|,
name|idx
decl_stmt|;
block|{
name|value_ptr
name|bound
decl_stmt|;
name|int
name|c_style
init|=
name|current_language
operator|->
name|c_style_arrays
decl_stmt|;
name|struct
name|type
modifier|*
name|tarray
decl_stmt|;
name|COERCE_REF
argument_list|(
name|array
argument_list|)
expr_stmt|;
name|tarray
operator|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
expr_stmt|;
name|COERCE_VARYING_ARRAY
argument_list|(
name|array
argument_list|,
name|tarray
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|tarray
argument_list|)
operator|==
name|TYPE_CODE_ARRAY
operator|||
name|TYPE_CODE
argument_list|(
name|tarray
argument_list|)
operator|==
name|TYPE_CODE_STRING
condition|)
block|{
name|struct
name|type
modifier|*
name|range_type
init|=
name|TYPE_INDEX_TYPE
argument_list|(
name|tarray
argument_list|)
decl_stmt|;
name|LONGEST
name|lowerbound
decl_stmt|,
name|upperbound
decl_stmt|;
name|get_discrete_bounds
argument_list|(
name|range_type
argument_list|,
operator|&
name|lowerbound
argument_list|,
operator|&
name|upperbound
argument_list|)
expr_stmt|;
if|if
condition|(
name|VALUE_LVAL
argument_list|(
name|array
argument_list|)
operator|!=
name|lval_memory
condition|)
return|return
name|value_subscripted_rvalue
argument_list|(
name|array
argument_list|,
name|idx
argument_list|,
name|lowerbound
argument_list|)
return|;
if|if
condition|(
name|c_style
operator|==
literal|0
condition|)
block|{
name|LONGEST
name|index
init|=
name|value_as_long
argument_list|(
name|idx
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|>=
name|lowerbound
operator|&&
name|index
operator|<=
name|upperbound
condition|)
return|return
name|value_subscripted_rvalue
argument_list|(
name|array
argument_list|,
name|idx
argument_list|,
name|lowerbound
argument_list|)
return|;
name|warning
argument_list|(
literal|"array or string index out of range"
argument_list|)
expr_stmt|;
comment|/* fall doing C stuff */
name|c_style
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|lowerbound
operator|!=
literal|0
condition|)
block|{
name|bound
operator|=
name|value_from_longest
argument_list|(
name|builtin_type_int
argument_list|,
operator|(
name|LONGEST
operator|)
name|lowerbound
argument_list|)
expr_stmt|;
name|idx
operator|=
name|value_sub
argument_list|(
name|idx
argument_list|,
name|bound
argument_list|)
expr_stmt|;
block|}
name|array
operator|=
name|value_coerce_array
argument_list|(
name|array
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|tarray
argument_list|)
operator|==
name|TYPE_CODE_BITSTRING
condition|)
block|{
name|struct
name|type
modifier|*
name|range_type
init|=
name|TYPE_INDEX_TYPE
argument_list|(
name|tarray
argument_list|)
decl_stmt|;
name|LONGEST
name|index
init|=
name|value_as_long
argument_list|(
name|idx
argument_list|)
decl_stmt|;
name|value_ptr
name|v
decl_stmt|;
name|int
name|offset
decl_stmt|,
name|byte
decl_stmt|,
name|bit_index
decl_stmt|;
name|LONGEST
name|lowerbound
decl_stmt|,
name|upperbound
decl_stmt|;
name|get_discrete_bounds
argument_list|(
name|range_type
argument_list|,
operator|&
name|lowerbound
argument_list|,
operator|&
name|upperbound
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|<
name|lowerbound
operator|||
name|index
operator|>
name|upperbound
condition|)
name|error
argument_list|(
literal|"bitstring index out of range"
argument_list|)
expr_stmt|;
name|index
operator|-=
name|lowerbound
expr_stmt|;
name|offset
operator|=
name|index
operator|/
name|TARGET_CHAR_BIT
expr_stmt|;
name|byte
operator|=
operator|*
operator|(
operator|(
name|char
operator|*
operator|)
name|VALUE_CONTENTS
argument_list|(
name|array
argument_list|)
operator|+
name|offset
operator|)
expr_stmt|;
name|bit_index
operator|=
name|index
operator|%
name|TARGET_CHAR_BIT
expr_stmt|;
name|byte
operator|>>=
operator|(
name|BITS_BIG_ENDIAN
condition|?
name|TARGET_CHAR_BIT
operator|-
literal|1
operator|-
name|bit_index
else|:
name|bit_index
operator|)
expr_stmt|;
name|v
operator|=
name|value_from_longest
argument_list|(
name|LA_BOOL_TYPE
argument_list|,
name|byte
operator|&
literal|1
argument_list|)
expr_stmt|;
name|VALUE_BITPOS
argument_list|(
name|v
argument_list|)
operator|=
name|bit_index
expr_stmt|;
name|VALUE_BITSIZE
argument_list|(
name|v
argument_list|)
operator|=
literal|1
expr_stmt|;
name|VALUE_LVAL
argument_list|(
name|v
argument_list|)
operator|=
name|VALUE_LVAL
argument_list|(
name|array
argument_list|)
expr_stmt|;
if|if
condition|(
name|VALUE_LVAL
argument_list|(
name|array
argument_list|)
operator|==
name|lval_internalvar
condition|)
name|VALUE_LVAL
argument_list|(
name|v
argument_list|)
operator|=
name|lval_internalvar_component
expr_stmt|;
name|VALUE_ADDRESS
argument_list|(
name|v
argument_list|)
operator|=
name|VALUE_ADDRESS
argument_list|(
name|array
argument_list|)
expr_stmt|;
name|VALUE_OFFSET
argument_list|(
name|v
argument_list|)
operator|=
name|offset
operator|+
name|VALUE_OFFSET
argument_list|(
name|array
argument_list|)
expr_stmt|;
return|return
name|v
return|;
block|}
if|if
condition|(
name|c_style
condition|)
return|return
name|value_ind
argument_list|(
name|value_add
argument_list|(
name|array
argument_list|,
name|idx
argument_list|)
argument_list|)
return|;
else|else
name|error
argument_list|(
literal|"not an array or string"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the value of EXPR[IDX], expr an aggregate rvalue    (eg, a vector register).  This routine used to promote floats    to doubles, but no longer does.  */
end_comment

begin_function
specifier|static
name|value_ptr
name|value_subscripted_rvalue
parameter_list|(
name|array
parameter_list|,
name|idx
parameter_list|,
name|lowerbound
parameter_list|)
name|value_ptr
name|array
decl_stmt|,
name|idx
decl_stmt|;
name|int
name|lowerbound
decl_stmt|;
block|{
name|struct
name|type
modifier|*
name|array_type
init|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|type
modifier|*
name|elt_type
init|=
name|check_typedef
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|array_type
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|elt_size
init|=
name|TYPE_LENGTH
argument_list|(
name|elt_type
argument_list|)
decl_stmt|;
name|LONGEST
name|index
init|=
name|value_as_long
argument_list|(
name|idx
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|elt_offs
init|=
name|elt_size
operator|*
name|longest_to_int
argument_list|(
name|index
operator|-
name|lowerbound
argument_list|)
decl_stmt|;
name|value_ptr
name|v
decl_stmt|;
if|if
condition|(
name|index
operator|<
name|lowerbound
operator|||
name|elt_offs
operator|>=
name|TYPE_LENGTH
argument_list|(
name|array_type
argument_list|)
condition|)
name|error
argument_list|(
literal|"no such vector element"
argument_list|)
expr_stmt|;
name|v
operator|=
name|allocate_value
argument_list|(
name|elt_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|VALUE_LAZY
argument_list|(
name|array
argument_list|)
condition|)
name|VALUE_LAZY
argument_list|(
name|v
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
name|memcpy
argument_list|(
name|VALUE_CONTENTS
argument_list|(
name|v
argument_list|)
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|array
argument_list|)
operator|+
name|elt_offs
argument_list|,
name|elt_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|VALUE_LVAL
argument_list|(
name|array
argument_list|)
operator|==
name|lval_internalvar
condition|)
name|VALUE_LVAL
argument_list|(
name|v
argument_list|)
operator|=
name|lval_internalvar_component
expr_stmt|;
else|else
name|VALUE_LVAL
argument_list|(
name|v
argument_list|)
operator|=
name|VALUE_LVAL
argument_list|(
name|array
argument_list|)
expr_stmt|;
name|VALUE_ADDRESS
argument_list|(
name|v
argument_list|)
operator|=
name|VALUE_ADDRESS
argument_list|(
name|array
argument_list|)
expr_stmt|;
name|VALUE_OFFSET
argument_list|(
name|v
argument_list|)
operator|=
name|VALUE_OFFSET
argument_list|(
name|array
argument_list|)
operator|+
name|elt_offs
expr_stmt|;
return|return
name|v
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Check to see if either argument is a structure.  This is called so    we know whether to go ahead with the normal binop or look for a     user defined function instead.     For now, we do not overload the `=' operator.  */
end_comment

begin_function
name|int
name|binop_user_defined_p
parameter_list|(
name|op
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|)
name|enum
name|exp_opcode
name|op
decl_stmt|;
name|value_ptr
name|arg1
decl_stmt|,
name|arg2
decl_stmt|;
block|{
name|struct
name|type
modifier|*
name|type1
decl_stmt|,
modifier|*
name|type2
decl_stmt|;
if|if
condition|(
name|op
operator|==
name|BINOP_ASSIGN
operator|||
name|op
operator|==
name|BINOP_CONCAT
condition|)
return|return
literal|0
return|;
name|type1
operator|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
name|type2
operator|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|TYPE_CODE
argument_list|(
name|type1
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
operator|||
name|TYPE_CODE
argument_list|(
name|type2
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
operator|||
operator|(
name|TYPE_CODE
argument_list|(
name|type1
argument_list|)
operator|==
name|TYPE_CODE_REF
operator|&&
name|TYPE_CODE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type1
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
operator|)
operator|||
operator|(
name|TYPE_CODE
argument_list|(
name|type2
argument_list|)
operator|==
name|TYPE_CODE_REF
operator|&&
name|TYPE_CODE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type2
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Check to see if argument is a structure.  This is called so    we know whether to go ahead with the normal unop or look for a     user defined function instead.     For now, we do not overload the `&' operator.  */
end_comment

begin_function
name|int
name|unop_user_defined_p
parameter_list|(
name|op
parameter_list|,
name|arg1
parameter_list|)
name|enum
name|exp_opcode
name|op
decl_stmt|;
name|value_ptr
name|arg1
decl_stmt|;
block|{
name|struct
name|type
modifier|*
name|type1
decl_stmt|;
if|if
condition|(
name|op
operator|==
name|UNOP_ADDR
condition|)
return|return
literal|0
return|;
name|type1
operator|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type1
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type1
argument_list|)
operator|==
name|TYPE_CODE_REF
condition|)
name|type1
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|type1
argument_list|)
expr_stmt|;
else|else
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* We know either arg1 or arg2 is a structure, so try to find the right    user defined function.  Create an argument vector that calls     arg1.operator @ (arg1,arg2) and return that value (where '@' is any    binary operator which is legal for GNU C++).     OP is the operatore, and if it is BINOP_ASSIGN_MODIFY, then OTHEROP    is the opcode saying how to modify it.  Otherwise, OTHEROP is    unused.  */
end_comment

begin_function
name|value_ptr
name|value_x_binop
parameter_list|(
name|arg1
parameter_list|,
name|arg2
parameter_list|,
name|op
parameter_list|,
name|otherop
parameter_list|,
name|noside
parameter_list|)
name|value_ptr
name|arg1
decl_stmt|,
name|arg2
decl_stmt|;
name|enum
name|exp_opcode
name|op
decl_stmt|,
name|otherop
decl_stmt|;
name|enum
name|noside
name|noside
decl_stmt|;
block|{
name|value_ptr
modifier|*
name|argvec
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|char
name|tstr
index|[
literal|13
index|]
decl_stmt|;
name|int
name|static_memfuncp
decl_stmt|;
name|COERCE_REF
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|COERCE_REF
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
name|COERCE_ENUM
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|COERCE_ENUM
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
comment|/* now we know that what we have to do is construct our      arg vector and find the right function to call it with.  */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|TYPE_CODE_STRUCT
condition|)
name|error
argument_list|(
literal|"Can't do that binary op on that type"
argument_list|)
expr_stmt|;
comment|/* FIXME be explicit */
name|argvec
operator|=
operator|(
name|value_ptr
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|value_ptr
argument_list|)
operator|*
literal|4
argument_list|)
expr_stmt|;
name|argvec
index|[
literal|1
index|]
operator|=
name|value_addr
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|argvec
index|[
literal|2
index|]
operator|=
name|arg2
expr_stmt|;
name|argvec
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
comment|/* make the right function name up */
name|strcpy
argument_list|(
name|tstr
argument_list|,
literal|"operator__"
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|tstr
operator|+
literal|8
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|BINOP_ADD
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"+"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_SUB
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_MUL
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_DIV
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_REM
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"%"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_LSH
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"<<"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_RSH
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|">>"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_BITWISE_AND
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"&"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_BITWISE_IOR
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"|"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_BITWISE_XOR
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"^"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_LOGICAL_AND
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"&&"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_LOGICAL_OR
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"||"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_MIN
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"<?"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_MAX
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|">?"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_ASSIGN
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"="
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_ASSIGN_MODIFY
case|:
switch|switch
condition|(
name|otherop
condition|)
block|{
case|case
name|BINOP_ADD
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"+="
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_SUB
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"-="
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_MUL
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"*="
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_DIV
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"/="
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_REM
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"%="
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_BITWISE_AND
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"&="
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_BITWISE_IOR
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"|="
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_BITWISE_XOR
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"^="
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_MOD
case|:
comment|/* invalid */
default|default:
name|error
argument_list|(
literal|"Invalid binary operation specified."
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|BINOP_SUBSCRIPT
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"[]"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_EQUAL
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"=="
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_NOTEQUAL
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"!="
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_LESS
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"<"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_GTR
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|">"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_GEQ
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|">="
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_LEQ
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"<="
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_MOD
case|:
comment|/* invalid */
default|default:
name|error
argument_list|(
literal|"Invalid binary operation specified."
argument_list|)
expr_stmt|;
block|}
name|argvec
index|[
literal|0
index|]
operator|=
name|value_struct_elt
argument_list|(
operator|&
name|arg1
argument_list|,
name|argvec
operator|+
literal|1
argument_list|,
name|tstr
argument_list|,
operator|&
name|static_memfuncp
argument_list|,
literal|"structure"
argument_list|)
expr_stmt|;
if|if
condition|(
name|argvec
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
name|static_memfuncp
condition|)
block|{
name|argvec
index|[
literal|1
index|]
operator|=
name|argvec
index|[
literal|0
index|]
expr_stmt|;
name|argvec
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|noside
operator|==
name|EVAL_AVOID_SIDE_EFFECTS
condition|)
block|{
name|struct
name|type
modifier|*
name|return_type
decl_stmt|;
name|return_type
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|argvec
index|[
literal|0
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|value_zero
argument_list|(
name|return_type
argument_list|,
name|VALUE_LVAL
argument_list|(
name|arg1
argument_list|)
argument_list|)
return|;
block|}
return|return
name|call_function_by_hand
argument_list|(
name|argvec
index|[
literal|0
index|]
argument_list|,
literal|2
operator|-
name|static_memfuncp
argument_list|,
name|argvec
operator|+
literal|1
argument_list|)
return|;
block|}
name|error
argument_list|(
literal|"member function %s not found"
argument_list|,
name|tstr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|lint
return|return
name|call_function_by_hand
argument_list|(
name|argvec
index|[
literal|0
index|]
argument_list|,
literal|2
operator|-
name|static_memfuncp
argument_list|,
name|argvec
operator|+
literal|1
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* We know that arg1 is a structure, so try to find a unary user    defined operator that matches the operator in question.      Create an argument vector that calls arg1.operator @ (arg1)    and return that value (where '@' is (almost) any unary operator which    is legal for GNU C++).  */
end_comment

begin_function
name|value_ptr
name|value_x_unop
parameter_list|(
name|arg1
parameter_list|,
name|op
parameter_list|,
name|noside
parameter_list|)
name|value_ptr
name|arg1
decl_stmt|;
name|enum
name|exp_opcode
name|op
decl_stmt|;
name|enum
name|noside
name|noside
decl_stmt|;
block|{
name|value_ptr
modifier|*
name|argvec
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|,
modifier|*
name|mangle_ptr
decl_stmt|;
name|char
name|tstr
index|[
literal|13
index|]
decl_stmt|,
name|mangle_tstr
index|[
literal|13
index|]
decl_stmt|;
name|int
name|static_memfuncp
decl_stmt|;
name|COERCE_REF
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|COERCE_ENUM
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
comment|/* now we know that what we have to do is construct our      arg vector and find the right function to call it with.  */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|TYPE_CODE_STRUCT
condition|)
name|error
argument_list|(
literal|"Can't do that unary op on that type"
argument_list|)
expr_stmt|;
comment|/* FIXME be explicit */
name|argvec
operator|=
operator|(
name|value_ptr
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|value_ptr
argument_list|)
operator|*
literal|3
argument_list|)
expr_stmt|;
name|argvec
index|[
literal|1
index|]
operator|=
name|value_addr
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|argvec
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
comment|/* make the right function name up */
name|strcpy
argument_list|(
name|tstr
argument_list|,
literal|"operator__"
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|tstr
operator|+
literal|8
expr_stmt|;
name|strcpy
argument_list|(
name|mangle_tstr
argument_list|,
literal|"__"
argument_list|)
expr_stmt|;
name|mangle_ptr
operator|=
name|mangle_tstr
operator|+
literal|2
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|UNOP_PREINCREMENT
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"++"
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNOP_PREDECREMENT
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"++"
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNOP_POSTINCREMENT
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"++"
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNOP_POSTDECREMENT
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"++"
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNOP_LOGICAL_NOT
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"!"
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNOP_COMPLEMENT
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"~"
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNOP_NEG
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNOP_IND
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Invalid unary operation specified."
argument_list|)
expr_stmt|;
block|}
name|argvec
index|[
literal|0
index|]
operator|=
name|value_struct_elt
argument_list|(
operator|&
name|arg1
argument_list|,
name|argvec
operator|+
literal|1
argument_list|,
name|tstr
argument_list|,
operator|&
name|static_memfuncp
argument_list|,
literal|"structure"
argument_list|)
expr_stmt|;
if|if
condition|(
name|argvec
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
name|static_memfuncp
condition|)
block|{
name|argvec
index|[
literal|1
index|]
operator|=
name|argvec
index|[
literal|0
index|]
expr_stmt|;
name|argvec
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|noside
operator|==
name|EVAL_AVOID_SIDE_EFFECTS
condition|)
block|{
name|struct
name|type
modifier|*
name|return_type
decl_stmt|;
name|return_type
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|argvec
index|[
literal|0
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|value_zero
argument_list|(
name|return_type
argument_list|,
name|VALUE_LVAL
argument_list|(
name|arg1
argument_list|)
argument_list|)
return|;
block|}
return|return
name|call_function_by_hand
argument_list|(
name|argvec
index|[
literal|0
index|]
argument_list|,
literal|1
operator|-
name|static_memfuncp
argument_list|,
name|argvec
operator|+
literal|1
argument_list|)
return|;
block|}
name|error
argument_list|(
literal|"member function %s not found"
argument_list|,
name|tstr
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* For lint -- never reached */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Concatenate two values with the following conditions:     (1)	Both values must be either bitstring values or character string 	values and the resulting value consists of the concatenation of 	ARG1 followed by ARG2.  	or  	One value must be an integer value and the other value must be 	either a bitstring value or character string value, which is 	to be repeated by the number of times specified by the integer 	value.       (2)	Boolean values are also allowed and are treated as bit string     	values of length 1.      (3)	Character values are also allowed and are treated as character     	string values of length 1. */
end_comment

begin_function
name|value_ptr
name|value_concat
parameter_list|(
name|arg1
parameter_list|,
name|arg2
parameter_list|)
name|value_ptr
name|arg1
decl_stmt|,
name|arg2
decl_stmt|;
block|{
specifier|register
name|value_ptr
name|inval1
decl_stmt|,
name|inval2
decl_stmt|,
name|outval
decl_stmt|;
name|int
name|inval1len
decl_stmt|,
name|inval2len
decl_stmt|;
name|int
name|count
decl_stmt|,
name|idx
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|char
name|inchar
decl_stmt|;
name|struct
name|type
modifier|*
name|type1
init|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|type
modifier|*
name|type2
init|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
decl_stmt|;
name|COERCE_VARYING_ARRAY
argument_list|(
name|arg1
argument_list|,
name|type1
argument_list|)
expr_stmt|;
name|COERCE_VARYING_ARRAY
argument_list|(
name|arg2
argument_list|,
name|type2
argument_list|)
expr_stmt|;
comment|/* First figure out if we are dealing with two values to be concatenated      or a repeat count and a value to be repeated.  INVAL1 is set to the      first of two concatenated values, or the repeat count.  INVAL2 is set      to the second of the two concatenated values or the value to be       repeated. */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type2
argument_list|)
operator|==
name|TYPE_CODE_INT
condition|)
block|{
name|struct
name|type
modifier|*
name|tmp
init|=
name|type1
decl_stmt|;
name|type1
operator|=
name|tmp
expr_stmt|;
name|tmp
operator|=
name|type2
expr_stmt|;
name|inval1
operator|=
name|arg2
expr_stmt|;
name|inval2
operator|=
name|arg1
expr_stmt|;
block|}
else|else
block|{
name|inval1
operator|=
name|arg1
expr_stmt|;
name|inval2
operator|=
name|arg2
expr_stmt|;
block|}
comment|/* Now process the input values. */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type1
argument_list|)
operator|==
name|TYPE_CODE_INT
condition|)
block|{
comment|/* We have a repeat count.  Validate the second value and then 	 construct a value repeated that many times. */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type2
argument_list|)
operator|==
name|TYPE_CODE_STRING
operator|||
name|TYPE_CODE
argument_list|(
name|type2
argument_list|)
operator|==
name|TYPE_CODE_CHAR
condition|)
block|{
name|count
operator|=
name|longest_to_int
argument_list|(
name|value_as_long
argument_list|(
name|inval1
argument_list|)
argument_list|)
expr_stmt|;
name|inval2len
operator|=
name|TYPE_LENGTH
argument_list|(
name|type2
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|count
operator|*
name|inval2len
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type2
argument_list|)
operator|==
name|TYPE_CODE_CHAR
condition|)
block|{
name|inchar
operator|=
operator|(
name|char
operator|)
name|unpack_long
argument_list|(
name|type2
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|inval2
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|count
condition|;
name|idx
operator|++
control|)
block|{
operator|*
operator|(
name|ptr
operator|+
name|idx
operator|)
operator|=
name|inchar
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|count
condition|;
name|idx
operator|++
control|)
block|{
name|memcpy
argument_list|(
name|ptr
operator|+
operator|(
name|idx
operator|*
name|inval2len
operator|)
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|inval2
argument_list|)
argument_list|,
name|inval2len
argument_list|)
expr_stmt|;
block|}
block|}
name|outval
operator|=
name|value_string
argument_list|(
name|ptr
argument_list|,
name|count
operator|*
name|inval2len
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type2
argument_list|)
operator|==
name|TYPE_CODE_BITSTRING
operator|||
name|TYPE_CODE
argument_list|(
name|type2
argument_list|)
operator|==
name|TYPE_CODE_BOOL
condition|)
block|{
name|error
argument_list|(
literal|"unimplemented support for bitstring/boolean repeats"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"can't repeat values of that type"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type1
argument_list|)
operator|==
name|TYPE_CODE_STRING
operator|||
name|TYPE_CODE
argument_list|(
name|type1
argument_list|)
operator|==
name|TYPE_CODE_CHAR
condition|)
block|{
comment|/* We have two character strings to concatenate. */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type2
argument_list|)
operator|!=
name|TYPE_CODE_STRING
operator|&&
name|TYPE_CODE
argument_list|(
name|type2
argument_list|)
operator|!=
name|TYPE_CODE_CHAR
condition|)
block|{
name|error
argument_list|(
literal|"Strings can only be concatenated with other strings."
argument_list|)
expr_stmt|;
block|}
name|inval1len
operator|=
name|TYPE_LENGTH
argument_list|(
name|type1
argument_list|)
expr_stmt|;
name|inval2len
operator|=
name|TYPE_LENGTH
argument_list|(
name|type2
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|inval1len
operator|+
name|inval2len
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type1
argument_list|)
operator|==
name|TYPE_CODE_CHAR
condition|)
block|{
operator|*
name|ptr
operator|=
operator|(
name|char
operator|)
name|unpack_long
argument_list|(
name|type1
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|inval1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|ptr
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|inval1
argument_list|)
argument_list|,
name|inval1len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type2
argument_list|)
operator|==
name|TYPE_CODE_CHAR
condition|)
block|{
operator|*
operator|(
name|ptr
operator|+
name|inval1len
operator|)
operator|=
operator|(
name|char
operator|)
name|unpack_long
argument_list|(
name|type2
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|inval2
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|ptr
operator|+
name|inval1len
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|inval2
argument_list|)
argument_list|,
name|inval2len
argument_list|)
expr_stmt|;
block|}
name|outval
operator|=
name|value_string
argument_list|(
name|ptr
argument_list|,
name|inval1len
operator|+
name|inval2len
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type1
argument_list|)
operator|==
name|TYPE_CODE_BITSTRING
operator|||
name|TYPE_CODE
argument_list|(
name|type1
argument_list|)
operator|==
name|TYPE_CODE_BOOL
condition|)
block|{
comment|/* We have two bitstrings to concatenate. */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type2
argument_list|)
operator|!=
name|TYPE_CODE_BITSTRING
operator|&&
name|TYPE_CODE
argument_list|(
name|type2
argument_list|)
operator|!=
name|TYPE_CODE_BOOL
condition|)
block|{
name|error
argument_list|(
literal|"Bitstrings or booleans can only be concatenated with other bitstrings or booleans."
argument_list|)
expr_stmt|;
block|}
name|error
argument_list|(
literal|"unimplemented support for bitstring/boolean concatenation."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We don't know how to concatenate these operands. */
name|error
argument_list|(
literal|"illegal operands for concatenation."
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|outval
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Perform a binary operation on two operands which have reasonable    representations as integers or floats.  This includes booleans,    characters, integers, or floats.    Does not support addition and subtraction on pointers;    use value_add or value_sub if you want to handle those possibilities.  */
end_comment

begin_function
name|value_ptr
name|value_binop
parameter_list|(
name|arg1
parameter_list|,
name|arg2
parameter_list|,
name|op
parameter_list|)
name|value_ptr
name|arg1
decl_stmt|,
name|arg2
decl_stmt|;
name|enum
name|exp_opcode
name|op
decl_stmt|;
block|{
specifier|register
name|value_ptr
name|val
decl_stmt|;
name|struct
name|type
modifier|*
name|type1
decl_stmt|,
modifier|*
name|type2
decl_stmt|;
name|COERCE_REF
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|COERCE_REF
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
name|COERCE_ENUM
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|COERCE_ENUM
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
name|type1
operator|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
name|type2
operator|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TYPE_CODE
argument_list|(
name|type1
argument_list|)
operator|!=
name|TYPE_CODE_FLT
operator|&&
name|TYPE_CODE
argument_list|(
name|type1
argument_list|)
operator|!=
name|TYPE_CODE_CHAR
operator|&&
name|TYPE_CODE
argument_list|(
name|type1
argument_list|)
operator|!=
name|TYPE_CODE_INT
operator|&&
name|TYPE_CODE
argument_list|(
name|type1
argument_list|)
operator|!=
name|TYPE_CODE_BOOL
operator|&&
name|TYPE_CODE
argument_list|(
name|type1
argument_list|)
operator|!=
name|TYPE_CODE_RANGE
operator|)
operator|||
operator|(
name|TYPE_CODE
argument_list|(
name|type2
argument_list|)
operator|!=
name|TYPE_CODE_FLT
operator|&&
name|TYPE_CODE
argument_list|(
name|type2
argument_list|)
operator|!=
name|TYPE_CODE_CHAR
operator|&&
name|TYPE_CODE
argument_list|(
name|type2
argument_list|)
operator|!=
name|TYPE_CODE_INT
operator|&&
name|TYPE_CODE
argument_list|(
name|type2
argument_list|)
operator|!=
name|TYPE_CODE_BOOL
operator|&&
name|TYPE_CODE
argument_list|(
name|type2
argument_list|)
operator|!=
name|TYPE_CODE_RANGE
operator|)
condition|)
name|error
argument_list|(
literal|"Argument to arithmetic operation not a number or boolean."
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type1
argument_list|)
operator|==
name|TYPE_CODE_FLT
operator|||
name|TYPE_CODE
argument_list|(
name|type2
argument_list|)
operator|==
name|TYPE_CODE_FLT
condition|)
block|{
comment|/* FIXME-if-picky-about-floating-accuracy: Should be doing this 	 in target format.  real.c in GCC probably has the necessary 	 code.  */
name|DOUBLEST
name|v1
decl_stmt|,
name|v2
decl_stmt|,
name|v
decl_stmt|;
name|v1
operator|=
name|value_as_double
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|v2
operator|=
name|value_as_double
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|BINOP_ADD
case|:
name|v
operator|=
name|v1
operator|+
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_SUB
case|:
name|v
operator|=
name|v1
operator|-
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_MUL
case|:
name|v
operator|=
name|v1
operator|*
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_DIV
case|:
name|v
operator|=
name|v1
operator|/
name|v2
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Integer-only operation on floating point number."
argument_list|)
expr_stmt|;
block|}
comment|/* If either arg was long double, make sure that value is also long 	 double.  */
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|type1
argument_list|)
operator|*
literal|8
operator|>
name|TARGET_DOUBLE_BIT
operator|||
name|TYPE_LENGTH
argument_list|(
name|type2
argument_list|)
operator|*
literal|8
operator|>
name|TARGET_DOUBLE_BIT
condition|)
name|val
operator|=
name|allocate_value
argument_list|(
name|builtin_type_long_double
argument_list|)
expr_stmt|;
else|else
name|val
operator|=
name|allocate_value
argument_list|(
name|builtin_type_double
argument_list|)
expr_stmt|;
name|store_floating
argument_list|(
name|VALUE_CONTENTS_RAW
argument_list|(
name|val
argument_list|)
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type1
argument_list|)
operator|==
name|TYPE_CODE_BOOL
operator|&&
name|TYPE_CODE
argument_list|(
name|type2
argument_list|)
operator|==
name|TYPE_CODE_BOOL
condition|)
block|{
name|LONGEST
name|v1
decl_stmt|,
name|v2
decl_stmt|,
name|v
decl_stmt|;
name|v1
operator|=
name|value_as_long
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|v2
operator|=
name|value_as_long
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|BINOP_BITWISE_AND
case|:
name|v
operator|=
name|v1
operator|&
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_BITWISE_IOR
case|:
name|v
operator|=
name|v1
operator||
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_BITWISE_XOR
case|:
name|v
operator|=
name|v1
operator|^
name|v2
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Invalid operation on booleans."
argument_list|)
expr_stmt|;
block|}
name|val
operator|=
name|allocate_value
argument_list|(
name|type1
argument_list|)
expr_stmt|;
name|store_signed_integer
argument_list|(
name|VALUE_CONTENTS_RAW
argument_list|(
name|val
argument_list|)
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type1
argument_list|)
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Integral operations here.  */
comment|/* FIXME:  Also mixed integral/booleans, with result an integer. */
comment|/* FIXME: This implements ANSI C rules (also correct for C++).        What about FORTRAN and chill?  */
block|{
name|unsigned
name|int
name|promoted_len1
init|=
name|TYPE_LENGTH
argument_list|(
name|type1
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|promoted_len2
init|=
name|TYPE_LENGTH
argument_list|(
name|type2
argument_list|)
decl_stmt|;
name|int
name|is_unsigned1
init|=
name|TYPE_UNSIGNED
argument_list|(
name|type1
argument_list|)
decl_stmt|;
name|int
name|is_unsigned2
init|=
name|TYPE_UNSIGNED
argument_list|(
name|type2
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|result_len
decl_stmt|;
name|int
name|unsigned_operation
decl_stmt|;
comment|/* Determine type length and signedness after promotion for 	 both operands.  */
if|if
condition|(
name|promoted_len1
operator|<
name|TYPE_LENGTH
argument_list|(
name|builtin_type_int
argument_list|)
condition|)
block|{
name|is_unsigned1
operator|=
literal|0
expr_stmt|;
name|promoted_len1
operator|=
name|TYPE_LENGTH
argument_list|(
name|builtin_type_int
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|promoted_len2
operator|<
name|TYPE_LENGTH
argument_list|(
name|builtin_type_int
argument_list|)
condition|)
block|{
name|is_unsigned2
operator|=
literal|0
expr_stmt|;
name|promoted_len2
operator|=
name|TYPE_LENGTH
argument_list|(
name|builtin_type_int
argument_list|)
expr_stmt|;
block|}
comment|/* Determine type length of the result, and if the operation should 	 be done unsigned. 	 Use the signedness of the operand with the greater length. 	 If both operands are of equal length, use unsigned operation 	 if one of the operands is unsigned.  */
if|if
condition|(
name|promoted_len1
operator|>
name|promoted_len2
condition|)
block|{
name|unsigned_operation
operator|=
name|is_unsigned1
expr_stmt|;
name|result_len
operator|=
name|promoted_len1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|promoted_len2
operator|>
name|promoted_len1
condition|)
block|{
name|unsigned_operation
operator|=
name|is_unsigned2
expr_stmt|;
name|result_len
operator|=
name|promoted_len2
expr_stmt|;
block|}
else|else
block|{
name|unsigned_operation
operator|=
name|is_unsigned1
operator|||
name|is_unsigned2
expr_stmt|;
name|result_len
operator|=
name|promoted_len1
expr_stmt|;
block|}
if|if
condition|(
name|unsigned_operation
condition|)
block|{
name|ULONGEST
name|v1
decl_stmt|,
name|v2
decl_stmt|,
name|v
decl_stmt|;
name|v1
operator|=
operator|(
name|ULONGEST
operator|)
name|value_as_long
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|v2
operator|=
operator|(
name|ULONGEST
operator|)
name|value_as_long
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
comment|/* Truncate values to the type length of the result.  */
if|if
condition|(
name|result_len
operator|<
sizeof|sizeof
argument_list|(
name|ULONGEST
argument_list|)
condition|)
block|{
name|v1
operator|&=
operator|(
operator|(
name|LONGEST
operator|)
literal|1
operator|<<
name|HOST_CHAR_BIT
operator|*
name|result_len
operator|)
operator|-
literal|1
expr_stmt|;
name|v2
operator|&=
operator|(
operator|(
name|LONGEST
operator|)
literal|1
operator|<<
name|HOST_CHAR_BIT
operator|*
name|result_len
operator|)
operator|-
literal|1
expr_stmt|;
block|}
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|BINOP_ADD
case|:
name|v
operator|=
name|v1
operator|+
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_SUB
case|:
name|v
operator|=
name|v1
operator|-
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_MUL
case|:
name|v
operator|=
name|v1
operator|*
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_DIV
case|:
name|v
operator|=
name|v1
operator|/
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_REM
case|:
name|v
operator|=
name|v1
operator|%
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_MOD
case|:
comment|/* Knuth 1.2.4, integer only.  Note that unlike the C '%' op, 	         v1 mod 0 has a defined value, v1. */
comment|/* Chill specifies that v2 must be> 0, so check for that. */
if|if
condition|(
name|current_language
operator|->
name|la_language
operator|==
name|language_chill
operator|&&
name|value_as_long
argument_list|(
name|arg2
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Second operand of MOD must be greater than zero."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|v2
operator|==
literal|0
condition|)
block|{
name|v
operator|=
name|v1
expr_stmt|;
block|}
else|else
block|{
name|v
operator|=
name|v1
operator|/
name|v2
expr_stmt|;
comment|/* Note floor(v1/v2) == v1/v2 for unsigned. */
name|v
operator|=
name|v1
operator|-
operator|(
name|v2
operator|*
name|v
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|BINOP_LSH
case|:
name|v
operator|=
name|v1
operator|<<
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_RSH
case|:
name|v
operator|=
name|v1
operator|>>
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_BITWISE_AND
case|:
name|v
operator|=
name|v1
operator|&
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_BITWISE_IOR
case|:
name|v
operator|=
name|v1
operator||
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_BITWISE_XOR
case|:
name|v
operator|=
name|v1
operator|^
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_LOGICAL_AND
case|:
name|v
operator|=
name|v1
operator|&&
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_LOGICAL_OR
case|:
name|v
operator|=
name|v1
operator|||
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_MIN
case|:
name|v
operator|=
name|v1
operator|<
name|v2
condition|?
name|v1
else|:
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_MAX
case|:
name|v
operator|=
name|v1
operator|>
name|v2
condition|?
name|v1
else|:
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_EQUAL
case|:
name|v
operator|=
name|v1
operator|==
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_LESS
case|:
name|v
operator|=
name|v1
operator|<
name|v2
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Invalid binary operation on numbers."
argument_list|)
expr_stmt|;
block|}
comment|/* This is a kludge to get around the fact that we don't 	     know how to determine the result type from the types of 	     the operands.  (I'm not really sure how much we feel the 	     need to duplicate the exact rules of the current 	     language.  They can get really hairy.  But not to do so 	     makes it hard to document just what we *do* do).  */
comment|/* Can't just call init_type because we wouldn't know what 	     name to give the type.  */
name|val
operator|=
name|allocate_value
argument_list|(
name|result_len
operator|>
name|TARGET_LONG_BIT
operator|/
name|HOST_CHAR_BIT
condition|?
name|builtin_type_unsigned_long_long
else|:
name|builtin_type_unsigned_long
argument_list|)
expr_stmt|;
name|store_unsigned_integer
argument_list|(
name|VALUE_CONTENTS_RAW
argument_list|(
name|val
argument_list|)
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LONGEST
name|v1
decl_stmt|,
name|v2
decl_stmt|,
name|v
decl_stmt|;
name|v1
operator|=
name|value_as_long
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|v2
operator|=
name|value_as_long
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|BINOP_ADD
case|:
name|v
operator|=
name|v1
operator|+
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_SUB
case|:
name|v
operator|=
name|v1
operator|-
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_MUL
case|:
name|v
operator|=
name|v1
operator|*
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_DIV
case|:
name|v
operator|=
name|v1
operator|/
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_REM
case|:
name|v
operator|=
name|v1
operator|%
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_MOD
case|:
comment|/* Knuth 1.2.4, integer only.  Note that unlike the C '%' op, 	         X mod 0 has a defined value, X. */
comment|/* Chill specifies that v2 must be> 0, so check for that. */
if|if
condition|(
name|current_language
operator|->
name|la_language
operator|==
name|language_chill
operator|&&
name|v2
operator|<=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Second operand of MOD must be greater than zero."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|v2
operator|==
literal|0
condition|)
block|{
name|v
operator|=
name|v1
expr_stmt|;
block|}
else|else
block|{
name|v
operator|=
name|v1
operator|/
name|v2
expr_stmt|;
comment|/* Compute floor. */
if|if
condition|(
name|TRUNCATION_TOWARDS_ZERO
operator|&&
operator|(
name|v
operator|<
literal|0
operator|)
operator|&&
operator|(
operator|(
name|v1
operator|%
name|v2
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|v
operator|--
expr_stmt|;
block|}
name|v
operator|=
name|v1
operator|-
operator|(
name|v2
operator|*
name|v
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|BINOP_LSH
case|:
name|v
operator|=
name|v1
operator|<<
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_RSH
case|:
name|v
operator|=
name|v1
operator|>>
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_BITWISE_AND
case|:
name|v
operator|=
name|v1
operator|&
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_BITWISE_IOR
case|:
name|v
operator|=
name|v1
operator||
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_BITWISE_XOR
case|:
name|v
operator|=
name|v1
operator|^
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_LOGICAL_AND
case|:
name|v
operator|=
name|v1
operator|&&
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_LOGICAL_OR
case|:
name|v
operator|=
name|v1
operator|||
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_MIN
case|:
name|v
operator|=
name|v1
operator|<
name|v2
condition|?
name|v1
else|:
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_MAX
case|:
name|v
operator|=
name|v1
operator|>
name|v2
condition|?
name|v1
else|:
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_EQUAL
case|:
name|v
operator|=
name|v1
operator|==
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_LESS
case|:
name|v
operator|=
name|v1
operator|<
name|v2
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Invalid binary operation on numbers."
argument_list|)
expr_stmt|;
block|}
comment|/* This is a kludge to get around the fact that we don't 	     know how to determine the result type from the types of 	     the operands.  (I'm not really sure how much we feel the 	     need to duplicate the exact rules of the current 	     language.  They can get really hairy.  But not to do so 	     makes it hard to document just what we *do* do).  */
comment|/* Can't just call init_type because we wouldn't know what 	     name to give the type.  */
name|val
operator|=
name|allocate_value
argument_list|(
name|result_len
operator|>
name|TARGET_LONG_BIT
operator|/
name|HOST_CHAR_BIT
condition|?
name|builtin_type_long_long
else|:
name|builtin_type_long
argument_list|)
expr_stmt|;
name|store_signed_integer
argument_list|(
name|VALUE_CONTENTS_RAW
argument_list|(
name|val
argument_list|)
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|val
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Simulate the C operator ! -- return 1 if ARG1 contains zero.  */
end_comment

begin_function
name|int
name|value_logical_not
parameter_list|(
name|arg1
parameter_list|)
name|value_ptr
name|arg1
decl_stmt|;
block|{
specifier|register
name|int
name|len
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|struct
name|type
modifier|*
name|type1
decl_stmt|;
name|COERCE_NUMBER
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|type1
operator|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type1
argument_list|)
operator|==
name|TYPE_CODE_FLT
condition|)
return|return
literal|0
operator|==
name|value_as_double
argument_list|(
name|arg1
argument_list|)
return|;
name|len
operator|=
name|TYPE_LENGTH
argument_list|(
name|type1
argument_list|)
expr_stmt|;
name|p
operator|=
name|VALUE_CONTENTS
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|len
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|++
condition|)
break|break;
block|}
return|return
name|len
operator|<
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Simulate the C operator == by returning a 1    iff ARG1 and ARG2 have equal contents.  */
end_comment

begin_function
name|int
name|value_equal
parameter_list|(
name|arg1
parameter_list|,
name|arg2
parameter_list|)
specifier|register
name|value_ptr
name|arg1
decl_stmt|,
name|arg2
decl_stmt|;
block|{
specifier|register
name|int
name|len
decl_stmt|;
specifier|register
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
name|struct
name|type
modifier|*
name|type1
decl_stmt|,
modifier|*
name|type2
decl_stmt|;
name|enum
name|type_code
name|code1
decl_stmt|;
name|enum
name|type_code
name|code2
decl_stmt|;
name|COERCE_NUMBER
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|COERCE_NUMBER
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
name|type1
operator|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
name|type2
operator|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
expr_stmt|;
name|code1
operator|=
name|TYPE_CODE
argument_list|(
name|type1
argument_list|)
expr_stmt|;
name|code2
operator|=
name|TYPE_CODE
argument_list|(
name|type2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|code1
operator|==
name|TYPE_CODE_INT
operator|||
name|code1
operator|==
name|TYPE_CODE_BOOL
operator|)
operator|&&
operator|(
name|code2
operator|==
name|TYPE_CODE_INT
operator|||
name|code2
operator|==
name|TYPE_CODE_BOOL
operator|)
condition|)
return|return
name|longest_to_int
argument_list|(
name|value_as_long
argument_list|(
name|value_binop
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
name|BINOP_EQUAL
argument_list|)
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
operator|(
name|code1
operator|==
name|TYPE_CODE_FLT
operator|||
name|code1
operator|==
name|TYPE_CODE_INT
operator|||
name|code1
operator|==
name|TYPE_CODE_BOOL
operator|)
operator|&&
operator|(
name|code2
operator|==
name|TYPE_CODE_FLT
operator|||
name|code2
operator|==
name|TYPE_CODE_INT
operator|||
name|code2
operator|==
name|TYPE_CODE_BOOL
operator|)
condition|)
return|return
name|value_as_double
argument_list|(
name|arg1
argument_list|)
operator|==
name|value_as_double
argument_list|(
name|arg2
argument_list|)
return|;
comment|/* FIXME: Need to promote to either CORE_ADDR or LONGEST, whichever      is bigger.  */
elseif|else
if|if
condition|(
name|code1
operator|==
name|TYPE_CODE_PTR
operator|&&
operator|(
name|code2
operator|==
name|TYPE_CODE_INT
operator|||
name|code2
operator|==
name|TYPE_CODE_BOOL
operator|)
condition|)
return|return
name|value_as_pointer
argument_list|(
name|arg1
argument_list|)
operator|==
operator|(
name|CORE_ADDR
operator|)
name|value_as_long
argument_list|(
name|arg2
argument_list|)
return|;
elseif|else
if|if
condition|(
name|code2
operator|==
name|TYPE_CODE_PTR
operator|&&
operator|(
name|code1
operator|==
name|TYPE_CODE_INT
operator|||
name|code1
operator|==
name|TYPE_CODE_BOOL
operator|)
condition|)
return|return
operator|(
name|CORE_ADDR
operator|)
name|value_as_long
argument_list|(
name|arg1
argument_list|)
operator|==
name|value_as_pointer
argument_list|(
name|arg2
argument_list|)
return|;
elseif|else
if|if
condition|(
name|code1
operator|==
name|code2
operator|&&
operator|(
operator|(
name|len
operator|=
operator|(
name|int
operator|)
name|TYPE_LENGTH
argument_list|(
name|type1
argument_list|)
operator|)
operator|==
operator|(
name|int
operator|)
name|TYPE_LENGTH
argument_list|(
name|type2
argument_list|)
operator|)
condition|)
block|{
name|p1
operator|=
name|VALUE_CONTENTS
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|p2
operator|=
name|VALUE_CONTENTS
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|len
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|p1
operator|++
operator|!=
operator|*
name|p2
operator|++
condition|)
break|break;
block|}
return|return
name|len
operator|<
literal|0
return|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"Invalid type combination in equality test."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* For lint -- never reached */
block|}
block|}
end_function

begin_comment
comment|/* Simulate the C operator< by returning 1    iff ARG1's contents are less than ARG2's.  */
end_comment

begin_function
name|int
name|value_less
parameter_list|(
name|arg1
parameter_list|,
name|arg2
parameter_list|)
specifier|register
name|value_ptr
name|arg1
decl_stmt|,
name|arg2
decl_stmt|;
block|{
specifier|register
name|enum
name|type_code
name|code1
decl_stmt|;
specifier|register
name|enum
name|type_code
name|code2
decl_stmt|;
name|struct
name|type
modifier|*
name|type1
decl_stmt|,
modifier|*
name|type2
decl_stmt|;
name|COERCE_NUMBER
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|COERCE_NUMBER
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
name|type1
operator|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
name|type2
operator|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
expr_stmt|;
name|code1
operator|=
name|TYPE_CODE
argument_list|(
name|type1
argument_list|)
expr_stmt|;
name|code2
operator|=
name|TYPE_CODE
argument_list|(
name|type2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|code1
operator|==
name|TYPE_CODE_INT
operator|||
name|code1
operator|==
name|TYPE_CODE_BOOL
operator|)
operator|&&
operator|(
name|code2
operator|==
name|TYPE_CODE_INT
operator|||
name|code2
operator|==
name|TYPE_CODE_BOOL
operator|)
condition|)
return|return
name|longest_to_int
argument_list|(
name|value_as_long
argument_list|(
name|value_binop
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
name|BINOP_LESS
argument_list|)
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
operator|(
name|code1
operator|==
name|TYPE_CODE_FLT
operator|||
name|code1
operator|==
name|TYPE_CODE_INT
operator|||
name|code1
operator|==
name|TYPE_CODE_BOOL
operator|)
operator|&&
operator|(
name|code2
operator|==
name|TYPE_CODE_FLT
operator|||
name|code2
operator|==
name|TYPE_CODE_INT
operator|||
name|code2
operator|==
name|TYPE_CODE_BOOL
operator|)
condition|)
return|return
name|value_as_double
argument_list|(
name|arg1
argument_list|)
operator|<
name|value_as_double
argument_list|(
name|arg2
argument_list|)
return|;
elseif|else
if|if
condition|(
name|code1
operator|==
name|TYPE_CODE_PTR
operator|&&
name|code2
operator|==
name|TYPE_CODE_PTR
condition|)
return|return
name|value_as_pointer
argument_list|(
name|arg1
argument_list|)
operator|<
name|value_as_pointer
argument_list|(
name|arg2
argument_list|)
return|;
comment|/* FIXME: Need to promote to either CORE_ADDR or LONGEST, whichever      is bigger.  */
elseif|else
if|if
condition|(
name|code1
operator|==
name|TYPE_CODE_PTR
operator|&&
operator|(
name|code2
operator|==
name|TYPE_CODE_INT
operator|||
name|code2
operator|==
name|TYPE_CODE_BOOL
operator|)
condition|)
return|return
name|value_as_pointer
argument_list|(
name|arg1
argument_list|)
operator|<
operator|(
name|CORE_ADDR
operator|)
name|value_as_long
argument_list|(
name|arg2
argument_list|)
return|;
elseif|else
if|if
condition|(
name|code2
operator|==
name|TYPE_CODE_PTR
operator|&&
operator|(
name|code1
operator|==
name|TYPE_CODE_INT
operator|||
name|code1
operator|==
name|TYPE_CODE_BOOL
operator|)
condition|)
return|return
operator|(
name|CORE_ADDR
operator|)
name|value_as_long
argument_list|(
name|arg1
argument_list|)
operator|<
name|value_as_pointer
argument_list|(
name|arg2
argument_list|)
return|;
else|else
block|{
name|error
argument_list|(
literal|"Invalid type combination in ordering comparison."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The unary operators - and ~.  Both free the argument ARG1.  */
end_comment

begin_function
name|value_ptr
name|value_neg
parameter_list|(
name|arg1
parameter_list|)
specifier|register
name|value_ptr
name|arg1
decl_stmt|;
block|{
specifier|register
name|struct
name|type
modifier|*
name|type
decl_stmt|;
specifier|register
name|struct
name|type
modifier|*
name|result_type
init|=
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
decl_stmt|;
name|COERCE_REF
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|COERCE_ENUM
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|type
operator|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_FLT
condition|)
return|return
name|value_from_double
argument_list|(
name|result_type
argument_list|,
operator|-
name|value_as_double
argument_list|(
name|arg1
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_INT
operator|||
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_BOOL
condition|)
block|{
comment|/* Perform integral promotion for ANSI C/C++. 	 FIXME: What about FORTRAN and chill ?  */
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|<
name|TYPE_LENGTH
argument_list|(
name|builtin_type_int
argument_list|)
condition|)
name|result_type
operator|=
name|builtin_type_int
expr_stmt|;
return|return
name|value_from_longest
argument_list|(
name|result_type
argument_list|,
operator|-
name|value_as_long
argument_list|(
name|arg1
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"Argument to negate operation not a number."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* For lint -- never reached */
block|}
block|}
end_function

begin_function
name|value_ptr
name|value_complement
parameter_list|(
name|arg1
parameter_list|)
specifier|register
name|value_ptr
name|arg1
decl_stmt|;
block|{
specifier|register
name|struct
name|type
modifier|*
name|type
decl_stmt|;
specifier|register
name|struct
name|type
modifier|*
name|result_type
init|=
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
decl_stmt|;
name|int
name|typecode
decl_stmt|;
name|COERCE_REF
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|COERCE_ENUM
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|type
operator|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
name|typecode
operator|=
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|typecode
operator|!=
name|TYPE_CODE_INT
operator|)
operator|&&
operator|(
name|typecode
operator|!=
name|TYPE_CODE_BOOL
operator|)
condition|)
name|error
argument_list|(
literal|"Argument to complement operation not an integer or boolean."
argument_list|)
expr_stmt|;
comment|/* Perform integral promotion for ANSI C/C++.      FIXME: What about FORTRAN ?  */
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|<
name|TYPE_LENGTH
argument_list|(
name|builtin_type_int
argument_list|)
condition|)
name|result_type
operator|=
name|builtin_type_int
expr_stmt|;
return|return
name|value_from_longest
argument_list|(
name|result_type
argument_list|,
operator|~
name|value_as_long
argument_list|(
name|arg1
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The INDEX'th bit of SET value whose VALUE_TYPE is TYPE,    and whose VALUE_CONTENTS is valaddr.    Return -1 if out of range, -2 other error. */
end_comment

begin_function
name|int
name|value_bit_index
parameter_list|(
name|type
parameter_list|,
name|valaddr
parameter_list|,
name|index
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|char
modifier|*
name|valaddr
decl_stmt|;
name|int
name|index
decl_stmt|;
block|{
name|LONGEST
name|low_bound
decl_stmt|,
name|high_bound
decl_stmt|;
name|LONGEST
name|word
decl_stmt|;
name|unsigned
name|rel_index
decl_stmt|;
name|struct
name|type
modifier|*
name|range
init|=
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|get_discrete_bounds
argument_list|(
name|range
argument_list|,
operator|&
name|low_bound
argument_list|,
operator|&
name|high_bound
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|2
return|;
if|if
condition|(
name|index
operator|<
name|low_bound
operator|||
name|index
operator|>
name|high_bound
condition|)
return|return
operator|-
literal|1
return|;
name|rel_index
operator|=
name|index
operator|-
name|low_bound
expr_stmt|;
name|word
operator|=
name|unpack_long
argument_list|(
name|builtin_type_unsigned_char
argument_list|,
name|valaddr
operator|+
operator|(
name|rel_index
operator|/
name|TARGET_CHAR_BIT
operator|)
argument_list|)
expr_stmt|;
name|rel_index
operator|%=
name|TARGET_CHAR_BIT
expr_stmt|;
if|if
condition|(
name|BITS_BIG_ENDIAN
condition|)
name|rel_index
operator|=
name|TARGET_CHAR_BIT
operator|-
literal|1
operator|-
name|rel_index
expr_stmt|;
return|return
operator|(
name|word
operator|>>
name|rel_index
operator|)
operator|&
literal|1
return|;
block|}
end_function

begin_function
name|value_ptr
name|value_in
parameter_list|(
name|element
parameter_list|,
name|set
parameter_list|)
name|value_ptr
name|element
decl_stmt|,
name|set
decl_stmt|;
block|{
name|int
name|member
decl_stmt|;
name|struct
name|type
modifier|*
name|settype
init|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|set
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|type
modifier|*
name|eltype
init|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|element
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|eltype
argument_list|)
operator|==
name|TYPE_CODE_RANGE
condition|)
name|eltype
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|eltype
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|settype
argument_list|)
operator|!=
name|TYPE_CODE_SET
condition|)
name|error
argument_list|(
literal|"Second argument of 'IN' has wrong type"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|eltype
argument_list|)
operator|!=
name|TYPE_CODE_INT
operator|&&
name|TYPE_CODE
argument_list|(
name|eltype
argument_list|)
operator|!=
name|TYPE_CODE_CHAR
operator|&&
name|TYPE_CODE
argument_list|(
name|eltype
argument_list|)
operator|!=
name|TYPE_CODE_ENUM
operator|&&
name|TYPE_CODE
argument_list|(
name|eltype
argument_list|)
operator|!=
name|TYPE_CODE_BOOL
condition|)
name|error
argument_list|(
literal|"First argument of 'IN' has wrong type"
argument_list|)
expr_stmt|;
name|member
operator|=
name|value_bit_index
argument_list|(
name|settype
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|set
argument_list|)
argument_list|,
name|value_as_long
argument_list|(
name|element
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|member
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"First argument of 'IN' not in range"
argument_list|)
expr_stmt|;
return|return
name|value_from_longest
argument_list|(
name|LA_BOOL_TYPE
argument_list|,
name|member
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|_initialize_valarith
parameter_list|()
block|{ }
end_function

end_unit

