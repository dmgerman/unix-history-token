begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Remote debugging interface for boot monitors, for GDB.     Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999,    2000, 2001, 2002 Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This file was derived from remote-eb.c, which did a similar job, but for    an AMD-29K running EBMON.  That file was in turn derived from remote.c    as mentioned in the following comment (left in for comic relief):     "This is like remote.c but is for a different situation--    having a PC running os9000 hook up with a unix machine with    a serial line, and running ctty com2 on the PC. os9000 has a debug    monitor called ROMBUG running.  Not to mention that the PC    has PC/NFS, so it can access the same executables that gdb can,    over the net in real time."     In reality, this module talks to a debug monitor called 'ROMBUG', which    We communicate with ROMBUG via a direct serial line, the network version    of ROMBUG is not available yet.  */
end_comment

begin_comment
comment|/* FIXME This file needs to be rewritten if it's to work again, either    to self-contained or to use the new monitor interface.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"serial.h"
end_include

begin_include
include|#
directive|include
file|"monitor.h"
end_include

begin_include
include|#
directive|include
file|"remote-utils.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"gdb-stabs.h"
end_include

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|showlist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|target_ops
name|rombug_ops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward declaration */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|monitor_ops
name|rombug_cmds
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward declaration */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|cmd_list_element
modifier|*
name|setlist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|cmd_list_element
modifier|*
name|unsetlist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|attach_flag
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|rombug_close
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rombug_fetch_register
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rombug_fetch_registers
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rombug_store_register
parameter_list|()
function_decl|;
end_function_decl

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|static int sr_get_debug ();
comment|/* flag set by "set remotedebug" */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|hashmark
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* flag set by "set hash" */
end_comment

begin_decl_stmt
specifier|static
name|int
name|rombug_is_open
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* FIXME: Replace with sr_get_debug ().  */
end_comment

begin_define
define|#
directive|define
name|LOG_FILE
value|"monitor.log"
end_define

begin_decl_stmt
name|FILE
modifier|*
name|log_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|monitor_log
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tty_xon
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tty_xoff
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|timeout
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_trace_mode
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Descriptor for I/O to remote machine.  Initialize it to NULL */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|serial
modifier|*
name|monitor_desc
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|bufaddr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|buflen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|readbuf
index|[
literal|16
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Send data to monitor.  Works just like printf. */
end_comment

begin_function
specifier|static
name|void
name|printf_monitor
parameter_list|(
name|char
modifier|*
name|pattern
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|char
name|buf
index|[
literal|200
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|pattern
argument_list|)
expr_stmt|;
name|vsprintf
argument_list|(
name|buf
argument_list|,
name|pattern
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|serial_write
argument_list|(
name|monitor_desc
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"serial_write failed: %s\n"
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read a character from the remote system, doing all the fancy timeout stuff */
end_comment

begin_function
specifier|static
name|int
name|readchar
parameter_list|(
name|int
name|timeout
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|c
operator|=
name|serial_readchar
argument_list|(
name|monitor_desc
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|sr_get_debug
argument_list|()
condition|)
name|putchar
argument_list|(
name|c
operator|&
literal|0x7f
argument_list|)
expr_stmt|;
if|if
condition|(
name|monitor_log
operator|&&
name|isascii
argument_list|(
name|c
argument_list|)
condition|)
name|putc
argument_list|(
name|c
operator|&
literal|0x7f
argument_list|,
name|log_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|0
condition|)
return|return
name|c
operator|&
literal|0x7f
return|;
if|if
condition|(
name|c
operator|==
name|SERIAL_TIMEOUT
condition|)
block|{
if|if
condition|(
name|timeout
operator|==
literal|0
condition|)
return|return
name|c
return|;
comment|/* Polls shouldn't generate timeout errors */
name|error
argument_list|(
literal|"Timeout reading from remote system."
argument_list|)
expr_stmt|;
block|}
name|perror_with_name
argument_list|(
literal|"remote-monitor"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Scan input from the remote system, until STRING is found.  If DISCARD is    non-zero, then discard non-matching input, else print it out.    Let the user break out immediately.  */
end_comment

begin_function
specifier|static
name|void
name|expect
parameter_list|(
name|char
modifier|*
name|string
parameter_list|,
name|int
name|discard
parameter_list|)
block|{
name|char
modifier|*
name|p
init|=
name|string
decl_stmt|;
name|int
name|c
decl_stmt|;
if|if
condition|(
name|sr_get_debug
argument_list|()
condition|)
name|printf
argument_list|(
literal|"Expecting \"%s\"\n"
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|immediate_quit
operator|++
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|c
operator|=
name|readchar
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isascii
argument_list|(
name|c
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|c
operator|==
operator|*
name|p
operator|++
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
name|immediate_quit
operator|--
expr_stmt|;
if|if
condition|(
name|sr_get_debug
argument_list|()
condition|)
name|printf
argument_list|(
literal|"\nMatched\n"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|discard
condition|)
block|{
name|fwrite
argument_list|(
name|string
argument_list|,
literal|1
argument_list|,
operator|(
name|p
operator|-
literal|1
operator|)
operator|-
name|string
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|string
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Keep discarding input until we see the ROMBUG prompt.     The convention for dealing with the prompt is that you    o give your command    o *then* wait for the prompt.     Thus the last thing that a procedure does with the serial line    will be an expect_prompt().  Exception:  rombug_resume does not    wait for the prompt, because the terminal is being handed over    to the inferior.  However, the next thing which happens after that    is a rombug_wait which does wait for the prompt.    Note that this includes abnormal exit, e.g. error().  This is    necessary to prevent getting into states from which we can't    recover.  */
end_comment

begin_function
specifier|static
name|void
name|expect_prompt
parameter_list|(
name|int
name|discard
parameter_list|)
block|{
if|if
condition|(
name|monitor_log
condition|)
comment|/* This is a convenient place to do this.  The idea is to do it often        enough that we never lose much data if we terminate abnormally.  */
name|fflush
argument_list|(
name|log_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_trace_mode
condition|)
block|{
name|expect
argument_list|(
literal|"trace"
argument_list|,
name|discard
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|expect
argument_list|(
name|PROMPT
argument_list|,
name|discard
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Get a hex digit from the remote system& return its value.    If ignore_space is nonzero, ignore spaces (not newline, tab, etc).  */
end_comment

begin_function
specifier|static
name|int
name|get_hex_digit
parameter_list|(
name|int
name|ignore_space
parameter_list|)
block|{
name|int
name|ch
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|ch
operator|=
name|readchar
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|>=
literal|'0'
operator|&&
name|ch
operator|<=
literal|'9'
condition|)
return|return
name|ch
operator|-
literal|'0'
return|;
elseif|else
if|if
condition|(
name|ch
operator|>=
literal|'A'
operator|&&
name|ch
operator|<=
literal|'F'
condition|)
return|return
name|ch
operator|-
literal|'A'
operator|+
literal|10
return|;
elseif|else
if|if
condition|(
name|ch
operator|>=
literal|'a'
operator|&&
name|ch
operator|<=
literal|'f'
condition|)
return|return
name|ch
operator|-
literal|'a'
operator|+
literal|10
return|;
elseif|else
if|if
condition|(
name|ch
operator|==
literal|' '
operator|&&
name|ignore_space
condition|)
empty_stmt|;
else|else
block|{
name|expect_prompt
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Invalid hex digit from remote system."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Get a byte from monitor and put it in *BYT.  Accept any number    leading spaces.  */
end_comment

begin_function
specifier|static
name|void
name|get_hex_byte
parameter_list|(
name|char
modifier|*
name|byt
parameter_list|)
block|{
name|int
name|val
decl_stmt|;
name|val
operator|=
name|get_hex_digit
argument_list|(
literal|1
argument_list|)
operator|<<
literal|4
expr_stmt|;
name|val
operator||=
name|get_hex_digit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|*
name|byt
operator|=
name|val
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get N 32-bit words from remote, each preceded by a space,    and put them in registers starting at REGNO.  */
end_comment

begin_function
specifier|static
name|void
name|get_hex_regs
parameter_list|(
name|int
name|n
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
name|long
name|val
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unsigned
name|char
name|b
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
decl_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|4
condition|;
name|j
operator|++
control|)
block|{
name|get_hex_byte
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_BYTE_ORDER
operator|==
name|BFD_ENDIAN_BIG
condition|)
name|val
operator|=
operator|(
name|val
operator|<<
literal|8
operator|)
operator|+
name|b
expr_stmt|;
else|else
name|val
operator|=
name|val
operator|+
operator|(
name|b
operator|<<
operator|(
name|j
operator|*
literal|8
operator|)
operator|)
expr_stmt|;
block|}
name|supply_register
argument_list|(
name|regno
operator|++
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|val
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This is called not only when we first attach, but also when the    user types "run" after having attached.  */
end_comment

begin_function
specifier|static
name|void
name|rombug_create_inferior
parameter_list|(
name|char
modifier|*
name|execfile
parameter_list|,
name|char
modifier|*
name|args
parameter_list|,
name|char
modifier|*
modifier|*
name|env
parameter_list|)
block|{
name|int
name|entry_pt
decl_stmt|;
if|if
condition|(
name|args
operator|&&
operator|*
name|args
condition|)
name|error
argument_list|(
literal|"Can't pass arguments to remote ROMBUG process"
argument_list|)
expr_stmt|;
if|if
condition|(
name|execfile
operator|==
literal|0
operator|||
name|exec_bfd
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No executable file specified"
argument_list|)
expr_stmt|;
name|entry_pt
operator|=
operator|(
name|int
operator|)
name|bfd_get_start_address
argument_list|(
name|exec_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|monitor_log
condition|)
name|fputs
argument_list|(
literal|"\nIn Create_inferior()"
argument_list|,
name|log_file
argument_list|)
expr_stmt|;
comment|/* The "process" (board) is already stopped awaiting our commands, and    the program is already downloaded.  We just set its PC and go.  */
name|init_wait_for_inferior
argument_list|()
expr_stmt|;
name|proceed
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|entry_pt
argument_list|,
name|TARGET_SIGNAL_DEFAULT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Open a connection to a remote debugger.    NAME is the filename used for communication.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|dev_name
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|rombug_open
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
if|if
condition|(
name|args
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Use `target RomBug DEVICE-NAME' to use a serial port, or \n\ `target RomBug HOST-NAME:PORT-NUMBER' to use a network connection."
argument_list|)
expr_stmt|;
name|target_preopen
argument_list|(
name|from_tty
argument_list|)
expr_stmt|;
if|if
condition|(
name|rombug_is_open
condition|)
name|unpush_target
argument_list|(
operator|&
name|rombug_ops
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|dev_name
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|monitor_desc
operator|=
name|serial_open
argument_list|(
name|dev_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|monitor_desc
operator|==
name|NULL
condition|)
name|perror_with_name
argument_list|(
name|dev_name
argument_list|)
expr_stmt|;
comment|/* if baud rate is set by 'set remotebaud' */
if|if
condition|(
name|serial_setbaudrate
argument_list|(
name|monitor_desc
argument_list|,
name|sr_get_baud_rate
argument_list|()
argument_list|)
condition|)
block|{
name|serial_close
argument_list|(
name|monitor_desc
argument_list|)
expr_stmt|;
name|perror_with_name
argument_list|(
literal|"RomBug"
argument_list|)
expr_stmt|;
block|}
name|serial_raw
argument_list|(
name|monitor_desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|tty_xon
operator|||
name|tty_xoff
condition|)
block|{
struct|struct
name|hardware_ttystate
block|{
name|struct
name|termios
name|t
decl_stmt|;
block|}
modifier|*
name|tty_s
struct|;
name|tty_s
operator|=
operator|(
expr|struct
name|hardware_ttystate
operator|*
operator|)
name|serial_get_tty_state
argument_list|(
name|monitor_desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|tty_xon
condition|)
name|tty_s
operator|->
name|t
operator|.
name|c_iflag
operator||=
name|IXON
expr_stmt|;
if|if
condition|(
name|tty_xoff
condition|)
name|tty_s
operator|->
name|t
operator|.
name|c_iflag
operator||=
name|IXOFF
expr_stmt|;
name|serial_set_tty_state
argument_list|(
name|monitor_desc
argument_list|,
operator|(
name|serial_ttystate
operator|)
name|tty_s
argument_list|)
expr_stmt|;
block|}
name|rombug_is_open
operator|=
literal|1
expr_stmt|;
name|log_file
operator|=
name|fopen
argument_list|(
name|LOG_FILE
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|log_file
operator|==
name|NULL
condition|)
name|perror_with_name
argument_list|(
name|LOG_FILE
argument_list|)
expr_stmt|;
name|push_monitor
argument_list|(
operator|&
name|rombug_cmds
argument_list|)
expr_stmt|;
name|printf_monitor
argument_list|(
literal|"\r"
argument_list|)
expr_stmt|;
comment|/* CR wakes up monitor */
name|expect_prompt
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|push_target
argument_list|(
operator|&
name|rombug_ops
argument_list|)
expr_stmt|;
name|attach_flag
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
name|printf
argument_list|(
literal|"Remote %s connected to %s\n"
argument_list|,
name|target_shortname
argument_list|,
name|dev_name
argument_list|)
expr_stmt|;
name|rombug_fetch_registers
argument_list|()
expr_stmt|;
name|printf_monitor
argument_list|(
literal|"ov e \r"
argument_list|)
expr_stmt|;
name|expect_prompt
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|bufaddr
operator|=
literal|0
expr_stmt|;
name|buflen
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Close out all files and local state before this target loses control.  */
end_comment

begin_function
specifier|static
name|void
name|rombug_close
parameter_list|(
name|int
name|quitting
parameter_list|)
block|{
if|if
condition|(
name|rombug_is_open
condition|)
block|{
name|serial_close
argument_list|(
name|monitor_desc
argument_list|)
expr_stmt|;
name|monitor_desc
operator|=
name|NULL
expr_stmt|;
name|rombug_is_open
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|log_file
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|log_file
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error writing log file.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|log_file
argument_list|)
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error closing log file.\n"
argument_list|)
expr_stmt|;
name|log_file
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|rombug_link
parameter_list|(
name|char
modifier|*
name|mod_name
parameter_list|,
name|CORE_ADDR
modifier|*
name|text_reloc
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|unsigned
name|long
name|val
decl_stmt|;
name|unsigned
name|char
name|b
decl_stmt|;
name|printf_monitor
argument_list|(
literal|"l %s \r"
argument_list|,
name|mod_name
argument_list|)
expr_stmt|;
name|expect_prompt
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|printf_monitor
argument_list|(
literal|".r \r"
argument_list|)
expr_stmt|;
name|expect
argument_list|(
name|REG_DELIM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
literal|7
condition|;
name|i
operator|++
control|)
block|{
name|val
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|4
condition|;
name|j
operator|++
control|)
block|{
name|get_hex_byte
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
name|val
operator|<<
literal|8
operator|)
operator|+
name|b
expr_stmt|;
block|}
block|}
name|expect_prompt
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|*
name|text_reloc
operator|=
name|val
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Terminate the open connection to the remote debugger.    Use this when you want to detach and do something else    with your gdb.  */
end_comment

begin_function
specifier|static
name|void
name|rombug_detach
parameter_list|(
name|int
name|from_tty
parameter_list|)
block|{
if|if
condition|(
name|attach_flag
condition|)
block|{
name|printf_monitor
argument_list|(
name|GO_CMD
argument_list|)
expr_stmt|;
name|attach_flag
operator|=
literal|0
expr_stmt|;
block|}
name|pop_target
argument_list|()
expr_stmt|;
comment|/* calls rombug_close to do the real work */
if|if
condition|(
name|from_tty
condition|)
name|printf
argument_list|(
literal|"Ending remote %s debugging\n"
argument_list|,
name|target_shortname
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Tell the remote machine to resume.  */
end_comment

begin_function
specifier|static
name|void
name|rombug_resume
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
name|int
name|step
parameter_list|,
name|enum
name|target_signal
name|sig
parameter_list|)
block|{
if|if
condition|(
name|monitor_log
condition|)
name|fprintf
argument_list|(
name|log_file
argument_list|,
literal|"\nIn Resume (step=%d, sig=%d)\n"
argument_list|,
name|step
argument_list|,
name|sig
argument_list|)
expr_stmt|;
if|if
condition|(
name|step
condition|)
block|{
name|is_trace_mode
operator|=
literal|1
expr_stmt|;
name|printf_monitor
argument_list|(
name|STEP_CMD
argument_list|)
expr_stmt|;
comment|/* wait for the echo.  **          expect (STEP_CMD, 1);        */
block|}
else|else
block|{
name|printf_monitor
argument_list|(
name|GO_CMD
argument_list|)
expr_stmt|;
comment|/* swallow the echo.  **          expect (GO_CMD, 1);        */
block|}
name|bufaddr
operator|=
literal|0
expr_stmt|;
name|buflen
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Wait until the remote machine stops, then return,  * storing status in status just as `wait' would.  */
end_comment

begin_function
specifier|static
name|ptid
modifier|*
name|rombug_wait
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
name|struct
name|target_waitstatus
modifier|*
name|status
parameter_list|)
block|{
name|int
name|old_timeout
init|=
name|timeout
decl_stmt|;
name|struct
name|section_offsets
modifier|*
name|offs
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|,
name|pc
decl_stmt|;
name|struct
name|obj_section
modifier|*
name|obj_sec
decl_stmt|;
if|if
condition|(
name|monitor_log
condition|)
name|fputs
argument_list|(
literal|"\nIn wait ()"
argument_list|,
name|log_file
argument_list|)
expr_stmt|;
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_EXITED
expr_stmt|;
name|status
operator|->
name|value
operator|.
name|integer
operator|=
literal|0
expr_stmt|;
name|timeout
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Don't time out -- user program is running. */
name|expect
argument_list|(
literal|"eax:"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* output any message before register display */
name|expect_prompt
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Wait for prompt, outputting extraneous text */
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_STOPPED
expr_stmt|;
name|status
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_TRAP
expr_stmt|;
name|timeout
operator|=
name|old_timeout
expr_stmt|;
name|rombug_fetch_registers
argument_list|()
expr_stmt|;
name|bufaddr
operator|=
literal|0
expr_stmt|;
name|buflen
operator|=
literal|0
expr_stmt|;
name|pc
operator|=
name|read_register
argument_list|(
name|PC_REGNUM
argument_list|)
expr_stmt|;
name|addr
operator|=
name|read_register
argument_list|(
name|DATABASE_REG
argument_list|)
expr_stmt|;
name|obj_sec
operator|=
name|find_pc_section
argument_list|(
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj_sec
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|obj_sec
operator|->
name|objfile
operator|!=
name|symfile_objfile
condition|)
name|new_symfile_objfile
argument_list|(
name|obj_sec
operator|->
name|objfile
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|offs
operator|=
operator|(
expr|struct
name|section_offsets
operator|*
operator|)
name|alloca
argument_list|(
name|SIZEOF_SECTION_OFFSETS
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|offs
argument_list|,
name|symfile_objfile
operator|->
name|section_offsets
argument_list|,
name|SIZEOF_SECTION_OFFSETS
argument_list|)
expr_stmt|;
name|offs
operator|->
name|offsets
index|[
name|SECT_OFF_DATA
argument_list|(
name|symfile_objfile
argument_list|)
index|]
operator|=
name|addr
expr_stmt|;
name|offs
operator|->
name|offsets
index|[
name|SECT_OFF_BSS
argument_list|(
name|symfile_objfile
argument_list|)
index|]
operator|=
name|addr
expr_stmt|;
name|objfile_relocate
argument_list|(
name|symfile_objfile
argument_list|,
name|offs
argument_list|)
expr_stmt|;
block|}
return|return
name|inferior_ptid
return|;
block|}
end_function

begin_comment
comment|/* Return the name of register number regno in the form input and output by    monitor.  Currently, register_names just happens to contain exactly what    monitor wants.  Lets take advantage of that just as long as possible! */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|get_reg_name
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
specifier|static
name|char
name|buf
index|[
literal|50
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|b
decl_stmt|;
name|b
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|regno
operator|<
literal|0
condition|)
return|return
operator|(
literal|""
operator|)
return|;
comment|/*    for (p = REGISTER_NAME (regno); *p; p++)    *b++ = toupper(*p);    *b = '\000';  */
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|REGISTER_NAME
argument_list|(
name|regno
argument_list|)
expr_stmt|;
return|return
name|p
return|;
comment|/*    return buf;  */
block|}
end_function

begin_comment
comment|/* read the remote registers into the block regs.  */
end_comment

begin_function
specifier|static
name|void
name|rombug_fetch_registers
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|regno
decl_stmt|,
name|j
decl_stmt|,
name|i
decl_stmt|;
name|long
name|val
decl_stmt|;
name|unsigned
name|char
name|b
decl_stmt|;
name|printf_monitor
argument_list|(
name|GET_REG
argument_list|)
expr_stmt|;
name|expect
argument_list|(
literal|"eax:"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|expect
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|get_hex_regs
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|get_hex_regs
argument_list|(
literal|1
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|get_hex_regs
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|get_hex_regs
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|get_hex_regs
argument_list|(
literal|1
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|get_hex_regs
argument_list|(
literal|1
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|get_hex_regs
argument_list|(
literal|1
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|get_hex_regs
argument_list|(
literal|1
argument_list|,
literal|4
argument_list|)
expr_stmt|;
for|for
control|(
name|regno
operator|=
literal|8
init|;
name|regno
operator|<=
literal|15
condition|;
name|regno
operator|++
control|)
block|{
name|expect
argument_list|(
name|REG_DELIM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|>=
literal|8
operator|&&
name|regno
operator|<=
literal|13
condition|)
block|{
name|val
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|2
condition|;
name|j
operator|++
control|)
block|{
name|get_hex_byte
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_BYTE_ORDER
operator|==
name|BFD_ENDIAN_BIG
condition|)
name|val
operator|=
operator|(
name|val
operator|<<
literal|8
operator|)
operator|+
name|b
expr_stmt|;
else|else
name|val
operator|=
name|val
operator|+
operator|(
name|b
operator|<<
operator|(
name|j
operator|*
literal|8
operator|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|regno
operator|==
literal|8
condition|)
name|i
operator|=
literal|10
expr_stmt|;
if|if
condition|(
name|regno
operator|>=
literal|9
operator|&&
name|regno
operator|<=
literal|12
condition|)
name|i
operator|=
name|regno
operator|+
literal|3
expr_stmt|;
if|if
condition|(
name|regno
operator|==
literal|13
condition|)
name|i
operator|=
literal|11
expr_stmt|;
name|supply_register
argument_list|(
name|i
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|val
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|regno
operator|==
literal|14
condition|)
block|{
name|get_hex_regs
argument_list|(
literal|1
argument_list|,
name|PC_REGNUM
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|regno
operator|==
literal|15
condition|)
block|{
name|get_hex_regs
argument_list|(
literal|1
argument_list|,
literal|9
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|val
operator|=
literal|0
expr_stmt|;
name|supply_register
argument_list|(
name|regno
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|val
argument_list|)
expr_stmt|;
block|}
block|}
name|is_trace_mode
operator|=
literal|0
expr_stmt|;
name|expect_prompt
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fetch register REGNO, or all registers if REGNO is -1.    Returns errno value.  */
end_comment

begin_function
specifier|static
name|void
name|rombug_fetch_register
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
name|int
name|val
decl_stmt|,
name|j
decl_stmt|;
name|unsigned
name|char
name|b
decl_stmt|;
if|if
condition|(
name|monitor_log
condition|)
block|{
name|fprintf
argument_list|(
name|log_file
argument_list|,
literal|"\nIn Fetch Register (reg=%s)\n"
argument_list|,
name|get_reg_name
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|log_file
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|regno
operator|<
literal|0
condition|)
block|{
name|rombug_fetch_registers
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|name
init|=
name|get_reg_name
argument_list|(
name|regno
argument_list|)
decl_stmt|;
name|printf_monitor
argument_list|(
name|GET_REG
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|>=
literal|10
operator|&&
name|regno
operator|<=
literal|15
condition|)
block|{
name|expect
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|expect
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|expect
argument_list|(
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|expect
argument_list|(
name|REG_DELIM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|2
condition|;
name|j
operator|++
control|)
block|{
name|get_hex_byte
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_BYTE_ORDER
operator|==
name|BFD_ENDIAN_BIG
condition|)
name|val
operator|=
operator|(
name|val
operator|<<
literal|8
operator|)
operator|+
name|b
expr_stmt|;
else|else
name|val
operator|=
name|val
operator|+
operator|(
name|b
operator|<<
operator|(
name|j
operator|*
literal|8
operator|)
operator|)
expr_stmt|;
block|}
name|supply_register
argument_list|(
name|regno
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|val
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|regno
operator|==
literal|8
operator|||
name|regno
operator|==
literal|9
condition|)
block|{
name|expect
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|expect
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|expect
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|expect
argument_list|(
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|expect
argument_list|(
name|REG_DELIM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|get_hex_regs
argument_list|(
literal|1
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|expect
argument_list|(
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|expect
argument_list|(
name|REG_DELIM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|expect
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|get_hex_regs
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|get_hex_regs
argument_list|(
literal|1
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|get_hex_regs
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|get_hex_regs
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|get_hex_regs
argument_list|(
literal|1
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|get_hex_regs
argument_list|(
literal|1
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|get_hex_regs
argument_list|(
literal|1
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|get_hex_regs
argument_list|(
literal|1
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
name|expect_prompt
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* Store the remote registers from the contents of the block REGS.  */
end_comment

begin_function
specifier|static
name|void
name|rombug_store_registers
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|regno
decl_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<=
name|PC_REGNUM
condition|;
name|regno
operator|++
control|)
name|rombug_store_register
argument_list|(
name|regno
argument_list|)
expr_stmt|;
name|registers_changed
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Store register REGNO, or all if REGNO == 0.    return errno value.  */
end_comment

begin_function
specifier|static
name|void
name|rombug_store_register
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|monitor_log
condition|)
name|fprintf
argument_list|(
name|log_file
argument_list|,
literal|"\nIn Store_register (regno=%d)\n"
argument_list|,
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|==
operator|-
literal|1
condition|)
name|rombug_store_registers
argument_list|()
expr_stmt|;
else|else
block|{
if|if
condition|(
name|sr_get_debug
argument_list|()
condition|)
name|printf
argument_list|(
literal|"Setting register %s to 0x%x\n"
argument_list|,
name|get_reg_name
argument_list|(
name|regno
argument_list|)
argument_list|,
name|read_register
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
name|name
operator|=
name|get_reg_name
argument_list|(
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
literal|0
condition|)
return|return;
name|printf_monitor
argument_list|(
name|SET_REG
argument_list|,
name|name
argument_list|,
name|read_register
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
name|is_trace_mode
operator|=
literal|0
expr_stmt|;
name|expect_prompt
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Get ready to modify the registers array.  On machines which store    individual registers, this doesn't need to do anything.  On machines    which store all the registers in one fell swoop, this makes sure    that registers contains all the registers from the program being    debugged.  */
end_comment

begin_function
specifier|static
name|void
name|rombug_prepare_to_store
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Do nothing, since we can store individual regs */
block|}
end_function

begin_function
specifier|static
name|void
name|rombug_files_info
parameter_list|(
name|void
parameter_list|)
block|{
name|printf
argument_list|(
literal|"\tAttached to %s at %d baud.\n"
argument_list|,
name|dev_name
argument_list|,
name|sr_get_baud_rate
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy LEN bytes of data from debugger memory at MYADDR    to inferior's memory at MEMADDR.  Returns length moved.  */
end_comment

begin_function
specifier|static
name|int
name|rombug_write_inferior_memory
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|unsigned
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
name|buf
index|[
literal|10
index|]
decl_stmt|;
if|if
condition|(
name|monitor_log
condition|)
name|fprintf
argument_list|(
name|log_file
argument_list|,
literal|"\nIn Write_inferior_memory (memaddr=%x, len=%d)\n"
argument_list|,
name|memaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|printf_monitor
argument_list|(
name|MEM_SET_CMD
argument_list|,
name|memaddr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|expect
argument_list|(
name|CMD_DELIM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|printf_monitor
argument_list|(
literal|"%x \r"
argument_list|,
name|myaddr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sr_get_debug
argument_list|()
condition|)
name|printf
argument_list|(
literal|"\nSet 0x%x to 0x%x\n"
argument_list|,
name|memaddr
operator|+
name|i
argument_list|,
name|myaddr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|expect
argument_list|(
name|CMD_DELIM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|CMD_END
condition|)
name|printf_monitor
argument_list|(
name|CMD_END
argument_list|)
expr_stmt|;
name|is_trace_mode
operator|=
literal|0
expr_stmt|;
name|expect_prompt
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|bufaddr
operator|=
literal|0
expr_stmt|;
name|buflen
operator|=
literal|0
expr_stmt|;
return|return
name|len
return|;
block|}
end_function

begin_comment
comment|/* Read LEN bytes from inferior memory at MEMADDR.  Put the result    at debugger address MYADDR.  Returns length moved.  */
end_comment

begin_function
specifier|static
name|int
name|rombug_read_inferior_memory
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* Number of bytes read so far.  */
name|int
name|count
decl_stmt|;
comment|/* Starting address of this pass.  */
name|unsigned
name|long
name|startaddr
decl_stmt|;
comment|/* Number of bytes to read in this pass.  */
name|int
name|len_this_pass
decl_stmt|;
if|if
condition|(
name|monitor_log
condition|)
name|fprintf
argument_list|(
name|log_file
argument_list|,
literal|"\nIn Read_inferior_memory (memaddr=%x, len=%d)\n"
argument_list|,
name|memaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Note that this code works correctly if startaddr is just less      than UINT_MAX (well, really CORE_ADDR_MAX if there was such a      thing).  That is, something like      rombug_read_bytes (CORE_ADDR_MAX - 4, foo, 4)      works--it never adds len To memaddr and gets 0.  */
comment|/* However, something like      rombug_read_bytes (CORE_ADDR_MAX - 3, foo, 4)      doesn't need to work.  Detect it and give up if there's an attempt      to do that.  */
if|if
condition|(
operator|(
operator|(
name|memaddr
operator|-
literal|1
operator|)
operator|+
name|len
operator|)
operator|<
name|memaddr
condition|)
block|{
name|errno
operator|=
name|EIO
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|bufaddr
operator|<=
name|memaddr
operator|&&
operator|(
name|memaddr
operator|+
name|len
operator|)
operator|<=
operator|(
name|bufaddr
operator|+
name|buflen
operator|)
condition|)
block|{
name|memcpy
argument_list|(
name|myaddr
argument_list|,
operator|&
name|readbuf
index|[
name|memaddr
operator|-
name|bufaddr
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|len
return|;
block|}
name|startaddr
operator|=
name|memaddr
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|count
operator|<
name|len
condition|)
block|{
name|len_this_pass
operator|=
literal|16
expr_stmt|;
if|if
condition|(
operator|(
name|startaddr
operator|%
literal|16
operator|)
operator|!=
literal|0
condition|)
name|len_this_pass
operator|-=
name|startaddr
operator|%
literal|16
expr_stmt|;
if|if
condition|(
name|len_this_pass
operator|>
operator|(
name|len
operator|-
name|count
operator|)
condition|)
name|len_this_pass
operator|=
operator|(
name|len
operator|-
name|count
operator|)
expr_stmt|;
if|if
condition|(
name|sr_get_debug
argument_list|()
condition|)
name|printf
argument_list|(
literal|"\nDisplay %d bytes at %x\n"
argument_list|,
name|len_this_pass
argument_list|,
name|startaddr
argument_list|)
expr_stmt|;
name|printf_monitor
argument_list|(
name|MEM_DIS_CMD
argument_list|,
name|startaddr
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|expect
argument_list|(
literal|"- "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|get_hex_byte
argument_list|(
operator|&
name|readbuf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|bufaddr
operator|=
name|startaddr
expr_stmt|;
name|buflen
operator|=
literal|16
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|myaddr
index|[
name|count
index|]
argument_list|,
name|readbuf
argument_list|,
name|len_this_pass
argument_list|)
expr_stmt|;
name|count
operator|+=
name|len_this_pass
expr_stmt|;
name|startaddr
operator|+=
name|len_this_pass
expr_stmt|;
name|expect
argument_list|(
name|CMD_DELIM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|CMD_END
condition|)
name|printf_monitor
argument_list|(
name|CMD_END
argument_list|)
expr_stmt|;
name|is_trace_mode
operator|=
literal|0
expr_stmt|;
name|expect_prompt
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|len
return|;
block|}
end_function

begin_comment
comment|/* Transfer LEN bytes between GDB address MYADDR and target address    MEMADDR.  If WRITE is non-zero, transfer them to the target,    otherwise transfer them from the target.  TARGET is unused.     Returns the number of bytes transferred. */
end_comment

begin_function
specifier|static
name|int
name|rombug_xfer_inferior_memory
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|write
parameter_list|,
name|struct
name|mem_attrib
modifier|*
name|attrib
parameter_list|,
name|struct
name|target_ops
modifier|*
name|target
parameter_list|)
block|{
if|if
condition|(
name|write
condition|)
return|return
name|rombug_write_inferior_memory
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
return|;
else|else
return|return
name|rombug_read_inferior_memory
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|rombug_kill
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
return|return;
comment|/* ignore attempts to kill target system */
block|}
end_function

begin_comment
comment|/* Clean up when a program exits.    The program actually lives on in the remote processor's RAM, and may be    run again without a download.  Don't leave it full of breakpoint    instructions.  */
end_comment

begin_function
specifier|static
name|void
name|rombug_mourn_inferior
parameter_list|(
name|void
parameter_list|)
block|{
name|remove_breakpoints
argument_list|()
expr_stmt|;
name|generic_mourn_inferior
argument_list|()
expr_stmt|;
comment|/* Do all the proper things now */
block|}
end_function

begin_define
define|#
directive|define
name|MAX_MONITOR_BREAKPOINTS
value|16
end_define

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|breakaddr
index|[
name|MAX_MONITOR_BREAKPOINTS
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|rombug_insert_breakpoint
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|char
modifier|*
name|shadow
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|CORE_ADDR
name|bp_addr
init|=
name|addr
decl_stmt|;
name|int
name|bp_size
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|monitor_log
condition|)
name|fprintf
argument_list|(
name|log_file
argument_list|,
literal|"\nIn Insert_breakpoint (addr=%x)\n"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|BREAKPOINT_FROM_PC
argument_list|(
operator|&
name|bp_addr
argument_list|,
operator|&
name|bp_size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|MAX_MONITOR_BREAKPOINTS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|breakaddr
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|breakaddr
index|[
name|i
index|]
operator|=
name|addr
expr_stmt|;
if|if
condition|(
name|sr_get_debug
argument_list|()
condition|)
name|printf
argument_list|(
literal|"Breakpoint at %x\n"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|rombug_read_inferior_memory
argument_list|(
name|bp_addr
argument_list|,
name|shadow
argument_list|,
name|bp_size
argument_list|)
expr_stmt|;
name|printf_monitor
argument_list|(
name|SET_BREAK_CMD
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|is_trace_mode
operator|=
literal|0
expr_stmt|;
name|expect_prompt
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Too many breakpoints (> 16) for monitor\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * _remove_breakpoint -- Tell the monitor to remove a breakpoint  */
end_comment

begin_function
specifier|static
name|int
name|rombug_remove_breakpoint
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|char
modifier|*
name|shadow
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|monitor_log
condition|)
name|fprintf
argument_list|(
name|log_file
argument_list|,
literal|"\nIn Remove_breakpoint (addr=%x)\n"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_MONITOR_BREAKPOINTS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|breakaddr
index|[
name|i
index|]
operator|==
name|addr
condition|)
block|{
name|breakaddr
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|printf_monitor
argument_list|(
name|CLR_BREAK_CMD
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|is_trace_mode
operator|=
literal|0
expr_stmt|;
name|expect_prompt
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't find breakpoint associated with 0x%x\n"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Load a file. This is usually an srecord, which is ascii. No     protocol, just sent line by line. */
end_comment

begin_define
define|#
directive|define
name|DOWNLOAD_LINE_SIZE
value|100
end_define

begin_function
specifier|static
name|void
name|rombug_load
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|)
block|{
comment|/* this part comment out for os9* */
if|#
directive|if
literal|0
block|FILE *download;   char buf[DOWNLOAD_LINE_SIZE];   int i, bytes_read;    if (sr_get_debug ())     printf ("Loading %s to monitor\n", arg);    download = fopen (arg, "r");   if (download == NULL)     {       error (sprintf (buf, "%s Does not exist", arg));       return;     }    printf_monitor (LOAD_CMD);
comment|/*  expect ("Waiting for S-records from host... ", 1); */
block|while (!feof (download))     {       bytes_read = fread (buf, sizeof (char), DOWNLOAD_LINE_SIZE, download);       if (hashmark) 	{ 	  putchar ('.'); 	  fflush (stdout); 	}        if (serial_write (monitor_desc, buf, bytes_read)) 	{ 	  fprintf (stderr, "serial_write failed: (while downloading) %s\n", safe_strerror (errno)); 	  break; 	}       i = 0;       while (i++<= 200000) 	{ 	};
comment|/* Ugly HACK, probably needs flow control */
block|if (bytes_read< DOWNLOAD_LINE_SIZE) 	{ 	  if (!feof (download)) 	    error ("Only read %d bytes\n", bytes_read); 	  break; 	}     }    if (hashmark)     {       putchar ('\n');     }   if (!feof (download))     error ("Never got EOF while downloading");   fclose (download);
endif|#
directive|endif
comment|/* 0 */
block|}
end_function

begin_comment
comment|/* Put a command string, in args, out to MONITOR.      Output from MONITOR is placed on the users terminal until the prompt     is seen. */
end_comment

begin_function
specifier|static
name|void
name|rombug_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|fromtty
parameter_list|)
block|{
if|if
condition|(
name|monitor_desc
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"monitor target not open."
argument_list|)
expr_stmt|;
if|if
condition|(
name|monitor_log
condition|)
name|fprintf
argument_list|(
name|log_file
argument_list|,
literal|"\nIn command (args=%s)\n"
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|args
condition|)
name|error
argument_list|(
literal|"Missing command."
argument_list|)
expr_stmt|;
name|printf_monitor
argument_list|(
literal|"%s\r"
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|expect_prompt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Connect the user directly to MONITOR.  This command acts just like the    'cu' or 'tip' command.  Use<CR>~. or<CR>~^D to break out.  */
end_comment

begin_comment
unit|static struct ttystate ttystate;  static void cleanup_tty (void) {   printf ("\r\n[Exiting connect mode]\r\n");
comment|/*serial_restore(0,&ttystate); */
end_comment

begin_comment
unit|}  static void connect_command (char *args, int fromtty) {   fd_set readfds;   int numfds;   int c;   char cur_esc = 0;    dont_repeat ();    if (monitor_desc == NULL)     error ("monitor target not open.");    if (args)     fprintf ("This command takes no args.  They have been ignored.\n");    printf ("[Entering connect mode.  Use ~. or ~^D to escape]\n");    serial_raw (0,&ttystate);    make_cleanup (cleanup_tty, 0);    FD_ZERO (&readfds);    while (1)     {       do 	{ 	  FD_SET (0,&readfds); 	  FD_SET (deprecated_serial_fd (monitor_desc),&readfds); 	  numfds = select (sizeof (readfds) * 8,&readfds, 0, 0, 0); 	}       while (numfds == 0);        if (numfds< 0) 	perror_with_name ("select");        if (FD_ISSET (0,&readfds)) 	{
comment|/* tty input, send to monitor */
end_comment

begin_endif
unit|c = getchar (); 	  if (c< 0) 	    perror_with_name ("connect");  	  printf_monitor ("%c", c); 	  switch (cur_esc) 	    { 	    case 0: 	      if (c == '\r') 		cur_esc = c; 	      break; 	    case '\r': 	      if (c == '~') 		cur_esc = c; 	      else 		cur_esc = 0; 	      break; 	    case '~': 	      if (c == '.' || c == '\004') 		return; 	      else 		cur_esc = 0; 	    } 	}        if (FD_ISSET (deprecated_serial_fd (monitor_desc),&readfds)) 	{ 	  while (1) 	    { 	      c = readchar (0); 	      if (c< 0) 		break; 	      putchar (c); 	    } 	  fflush (stdout); 	}     } }
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Define the monitor command strings. Since these are passed directly  * through to a printf style function, we need can include formatting  * strings. We also need a CR or LF on the end.  */
end_comment

begin_warning
warning|#
directive|warning
warning|FIXME: monitor interface pattern strings, stale struct decl
end_warning

begin_decl_stmt
name|struct
name|monitor_ops
name|rombug_cmds
init|=
block|{
literal|"g \r"
block|,
comment|/* execute or usually GO command */
literal|"g \r"
block|,
comment|/* continue command */
literal|"t \r"
block|,
comment|/* single step */
literal|"b %x\r"
block|,
comment|/* set a breakpoint */
literal|"k %x\r"
block|,
comment|/* clear a breakpoint */
literal|"c %x\r"
block|,
comment|/* set memory to a value */
literal|"d %x %d\r"
block|,
comment|/* display memory */
literal|"$%08X"
block|,
comment|/* prompt memory commands use */
literal|".%s %x\r"
block|,
comment|/* set a register */
literal|":"
block|,
comment|/* delimiter between registers */
literal|". \r"
block|,
comment|/* read a register */
literal|"mf \r"
block|,
comment|/* download command */
literal|"RomBug: "
block|,
comment|/* monitor command prompt */
literal|": "
block|,
comment|/* end-of-command delimitor */
literal|".\r"
comment|/* optional command terminator */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|target_ops
name|rombug_ops
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|init_rombug_ops
parameter_list|(
name|void
parameter_list|)
block|{
name|rombug_ops
operator|.
name|to_shortname
operator|=
literal|"rombug"
expr_stmt|;
name|rombug_ops
operator|.
name|to_longname
operator|=
literal|"Microware's ROMBUG debug monitor"
expr_stmt|;
name|rombug_ops
operator|.
name|to_doc
operator|=
literal|"Use a remote computer running the ROMBUG debug monitor.\n\ Specify the serial device it is connected to (e.g. /dev/ttya)."
operator|,
name|rombug_ops
operator|.
name|to_open
operator|=
name|rombug_open
expr_stmt|;
name|rombug_ops
operator|.
name|to_close
operator|=
name|rombug_close
expr_stmt|;
name|rombug_ops
operator|.
name|to_attach
operator|=
literal|0
expr_stmt|;
name|rombug_ops
operator|.
name|to_post_attach
operator|=
name|NULL
expr_stmt|;
name|rombug_ops
operator|.
name|to_require_attach
operator|=
name|NULL
expr_stmt|;
name|rombug_ops
operator|.
name|to_detach
operator|=
name|rombug_detach
expr_stmt|;
name|rombug_ops
operator|.
name|to_require_detach
operator|=
name|NULL
expr_stmt|;
name|rombug_ops
operator|.
name|to_resume
operator|=
name|rombug_resume
expr_stmt|;
name|rombug_ops
operator|.
name|to_wait
operator|=
name|rombug_wait
expr_stmt|;
name|rombug_ops
operator|.
name|to_post_wait
operator|=
name|NULL
expr_stmt|;
name|rombug_ops
operator|.
name|to_fetch_registers
operator|=
name|rombug_fetch_register
expr_stmt|;
name|rombug_ops
operator|.
name|to_store_registers
operator|=
name|rombug_store_register
expr_stmt|;
name|rombug_ops
operator|.
name|to_prepare_to_store
operator|=
name|rombug_prepare_to_store
expr_stmt|;
name|rombug_ops
operator|.
name|to_xfer_memory
operator|=
name|rombug_xfer_inferior_memory
expr_stmt|;
name|rombug_ops
operator|.
name|to_files_info
operator|=
name|rombug_files_info
expr_stmt|;
name|rombug_ops
operator|.
name|to_insert_breakpoint
operator|=
name|rombug_insert_breakpoint
expr_stmt|;
name|rombug_ops
operator|.
name|to_remove_breakpoint
operator|=
name|rombug_remove_breakpoint
expr_stmt|;
comment|/* Breakpoints */
name|rombug_ops
operator|.
name|to_terminal_init
operator|=
literal|0
expr_stmt|;
name|rombug_ops
operator|.
name|to_terminal_inferior
operator|=
literal|0
expr_stmt|;
name|rombug_ops
operator|.
name|to_terminal_ours_for_output
operator|=
literal|0
expr_stmt|;
name|rombug_ops
operator|.
name|to_terminal_ours
operator|=
literal|0
expr_stmt|;
name|rombug_ops
operator|.
name|to_terminal_info
operator|=
literal|0
expr_stmt|;
comment|/* Terminal handling */
name|rombug_ops
operator|.
name|to_kill
operator|=
name|rombug_kill
expr_stmt|;
name|rombug_ops
operator|.
name|to_load
operator|=
name|rombug_load
expr_stmt|;
comment|/* load */
name|rombug_ops
operator|.
name|to_lookup_symbol
operator|=
name|rombug_link
expr_stmt|;
comment|/* lookup_symbol */
name|rombug_ops
operator|.
name|to_create_inferior
operator|=
name|rombug_create_inferior
expr_stmt|;
name|rombug_ops
operator|.
name|to_post_startup_inferior
operator|=
name|NULL
expr_stmt|;
name|rombug_ops
operator|.
name|to_acknowledge_created_inferior
operator|=
name|NULL
expr_stmt|;
name|rombug_ops
operator|.
name|to_clone_and_follow_inferior
operator|=
name|NULL
expr_stmt|;
name|rombug_ops
operator|.
name|to_post_follow_inferior_by_clone
operator|=
name|NULL
expr_stmt|;
name|rombug_ops
operator|.
name|to_insert_fork_catchpoint
operator|=
name|NULL
expr_stmt|;
name|rombug_ops
operator|.
name|to_remove_fork_catchpoint
operator|=
name|NULL
expr_stmt|;
name|rombug_ops
operator|.
name|to_insert_vfork_catchpoint
operator|=
name|NULL
expr_stmt|;
name|rombug_ops
operator|.
name|to_remove_vfork_catchpoint
operator|=
name|NULL
expr_stmt|;
name|rombug_ops
operator|.
name|to_has_forked
operator|=
name|NULL
expr_stmt|;
name|rombug_ops
operator|.
name|to_has_vforked
operator|=
name|NULL
expr_stmt|;
name|rombug_ops
operator|.
name|to_can_follow_vfork_prior_to_exec
operator|=
name|NULL
expr_stmt|;
name|rombug_ops
operator|.
name|to_post_follow_vfork
operator|=
name|NULL
expr_stmt|;
name|rombug_ops
operator|.
name|to_insert_exec_catchpoint
operator|=
name|NULL
expr_stmt|;
name|rombug_ops
operator|.
name|to_remove_exec_catchpoint
operator|=
name|NULL
expr_stmt|;
name|rombug_ops
operator|.
name|to_has_execd
operator|=
name|NULL
expr_stmt|;
name|rombug_ops
operator|.
name|to_reported_exec_events_per_exec_call
operator|=
name|NULL
expr_stmt|;
name|rombug_ops
operator|.
name|to_has_exited
operator|=
name|NULL
expr_stmt|;
name|rombug_ops
operator|.
name|to_mourn_inferior
operator|=
name|rombug_mourn_inferior
expr_stmt|;
name|rombug_ops
operator|.
name|to_can_run
operator|=
literal|0
expr_stmt|;
comment|/* can_run */
name|rombug_ops
operator|.
name|to_notice_signals
operator|=
literal|0
expr_stmt|;
comment|/* notice_signals */
name|rombug_ops
operator|.
name|to_thread_alive
operator|=
literal|0
expr_stmt|;
name|rombug_ops
operator|.
name|to_stop
operator|=
literal|0
expr_stmt|;
comment|/* to_stop */
name|rombug_ops
operator|.
name|to_pid_to_exec_file
operator|=
name|NULL
expr_stmt|;
name|rombug_ops
operator|.
name|to_stratum
operator|=
name|process_stratum
expr_stmt|;
name|rombug_ops
operator|.
name|DONT_USE
operator|=
literal|0
expr_stmt|;
comment|/* next */
name|rombug_ops
operator|.
name|to_has_all_memory
operator|=
literal|1
expr_stmt|;
name|rombug_ops
operator|.
name|to_has_memory
operator|=
literal|1
expr_stmt|;
name|rombug_ops
operator|.
name|to_has_stack
operator|=
literal|1
expr_stmt|;
name|rombug_ops
operator|.
name|to_has_registers
operator|=
literal|1
expr_stmt|;
name|rombug_ops
operator|.
name|to_has_execution
operator|=
literal|1
expr_stmt|;
comment|/* has execution */
name|rombug_ops
operator|.
name|to_sections
operator|=
literal|0
expr_stmt|;
name|rombug_ops
operator|.
name|to_sections_end
operator|=
literal|0
expr_stmt|;
comment|/* Section pointers */
name|rombug_ops
operator|.
name|to_magic
operator|=
name|OPS_MAGIC
expr_stmt|;
comment|/* Always the last thing */
block|}
end_function

begin_function
name|void
name|_initialize_remote_os9k
parameter_list|(
name|void
parameter_list|)
block|{
name|init_rombug_ops
argument_list|()
expr_stmt|;
name|add_target
argument_list|(
operator|&
name|rombug_ops
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"hash"
argument_list|,
name|no_class
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|hashmark
argument_list|,
literal|"Set display of activity while downloading a file.\nWhen enabled, a period \'.\' is displayed."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"timeout"
argument_list|,
name|no_class
argument_list|,
name|var_zinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|timeout
argument_list|,
literal|"Set timeout in seconds for remote MIPS serial I/O."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"remotelog"
argument_list|,
name|no_class
argument_list|,
name|var_zinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|monitor_log
argument_list|,
literal|"Set monitor activity log on(=1) or off(=0)."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"remotexon"
argument_list|,
name|no_class
argument_list|,
name|var_zinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|tty_xon
argument_list|,
literal|"Set remote tty line XON control"
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"remotexoff"
argument_list|,
name|no_class
argument_list|,
name|var_zinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|tty_xoff
argument_list|,
literal|"Set remote tty line XOFF control"
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"rombug<command>"
argument_list|,
name|class_obscure
argument_list|,
name|rombug_command
argument_list|,
literal|"Send a command to the debug monitor."
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|add_com ("connect", class_obscure, connect_command, 	   "Connect the terminal directly up to a serial based command monitor.\nUse<CR>~. or<CR>~^D to break out.");
endif|#
directive|endif
block|}
end_function

end_unit

