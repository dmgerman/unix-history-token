begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Remote debugging interface for boot monitors, for GDB.    Copyright 1990, 1991, 1992, 1993 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This file was derived from remote-eb.c, which did a similar job, but for    an AMD-29K running EBMON.  That file was in turn derived from remote.c    as mentioned in the following comment (left in for comic relief):    "This is like remote.c but is for a different situation--    having a PC running os9000 hook up with a unix machine with    a serial line, and running ctty com2 on the PC. os9000 has a debug    monitor called ROMBUG running.  Not to mention that the PC    has PC/NFS, so it can access the same executables that gdb can,    over the net in real time."     In reality, this module talks to a debug monitor called 'ROMBUG', which    We communicate with ROMBUG via a direct serial line, the network version    of ROMBUG is not available yet. */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"wait.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|ANSI_PROTOTYPES
end_ifdef

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"serial.h"
end_include

begin_include
include|#
directive|include
file|"monitor.h"
end_include

begin_include
include|#
directive|include
file|"remote-utils.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"gdb-stabs.h"
end_include

begin_decl_stmt
name|struct
name|monitor_ops
modifier|*
name|current_monitor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|showlist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|target_ops
name|rombug_ops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward declaration */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|monitor_ops
name|rombug_cmds
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward declaration */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|cmd_list_element
modifier|*
name|setlist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|cmd_list_element
modifier|*
name|unsetlist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|attach_flag
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|rombug_close
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rombug_fetch_register
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rombug_fetch_registers
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rombug_store_register
parameter_list|()
function_decl|;
end_function_decl

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|static int sr_get_debug();
comment|/* flag set by "set remotedebug" */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|hashmark
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* flag set by "set hash" */
end_comment

begin_decl_stmt
specifier|static
name|int
name|rombug_is_open
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* FIXME: Replace with sr_get_debug ().  */
end_comment

begin_define
define|#
directive|define
name|LOG_FILE
value|"monitor.log"
end_define

begin_decl_stmt
name|FILE
modifier|*
name|log_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|monitor_log
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tty_xon
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tty_xoff
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|timeout
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_trace_mode
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Descriptor for I/O to remote machine.  Initialize it to NULL*/
end_comment

begin_decl_stmt
specifier|static
name|serial_t
name|monitor_desc
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|bufaddr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|buflen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|readbuf
index|[
literal|16
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Send data to monitor.  Works just like printf. */
end_comment

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|ANSI_PROTOTYPES
name|printf_monitor
parameter_list|(
name|char
modifier|*
name|pattern
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
function|printf_monitor
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
endif|#
directive|endif
block|{
name|va_list
name|args
decl_stmt|;
name|char
name|buf
index|[
literal|200
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|ANSI_PROTOTYPES
name|va_start
argument_list|(
name|args
argument_list|,
name|pattern
argument_list|)
expr_stmt|;
else|#
directive|else
name|char
modifier|*
name|pattern
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|pattern
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vsprintf
argument_list|(
name|buf
argument_list|,
name|pattern
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|SERIAL_WRITE
argument_list|(
name|monitor_desc
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"SERIAL_WRITE failed: %s\n"
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read a character from the remote system, doing all the fancy timeout stuff*/
end_comment

begin_function
specifier|static
name|int
name|readchar
parameter_list|(
name|timeout
parameter_list|)
name|int
name|timeout
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
name|c
operator|=
name|SERIAL_READCHAR
argument_list|(
name|monitor_desc
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|sr_get_debug
argument_list|()
condition|)
name|putchar
argument_list|(
name|c
operator|&
literal|0x7f
argument_list|)
expr_stmt|;
if|if
condition|(
name|monitor_log
operator|&&
name|isascii
argument_list|(
name|c
argument_list|)
condition|)
name|putc
argument_list|(
name|c
operator|&
literal|0x7f
argument_list|,
name|log_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|0
condition|)
return|return
name|c
operator|&
literal|0x7f
return|;
if|if
condition|(
name|c
operator|==
name|SERIAL_TIMEOUT
condition|)
block|{
if|if
condition|(
name|timeout
operator|==
literal|0
condition|)
return|return
name|c
return|;
comment|/* Polls shouldn't generate timeout errors */
name|error
argument_list|(
literal|"Timeout reading from remote system."
argument_list|)
expr_stmt|;
block|}
name|perror_with_name
argument_list|(
literal|"remote-monitor"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Scan input from the remote system, until STRING is found.  If DISCARD is    non-zero, then discard non-matching input, else print it out.    Let the user break out immediately.  */
end_comment

begin_function
specifier|static
name|void
name|expect
parameter_list|(
name|string
parameter_list|,
name|discard
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|discard
decl_stmt|;
block|{
name|char
modifier|*
name|p
init|=
name|string
decl_stmt|;
name|int
name|c
decl_stmt|;
if|if
condition|(
name|sr_get_debug
argument_list|()
condition|)
name|printf
argument_list|(
literal|"Expecting \"%s\"\n"
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|immediate_quit
operator|=
literal|1
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|c
operator|=
name|readchar
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isascii
argument_list|(
name|c
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|c
operator|==
operator|*
name|p
operator|++
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
name|immediate_quit
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sr_get_debug
argument_list|()
condition|)
name|printf
argument_list|(
literal|"\nMatched\n"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|discard
condition|)
block|{
name|fwrite
argument_list|(
name|string
argument_list|,
literal|1
argument_list|,
operator|(
name|p
operator|-
literal|1
operator|)
operator|-
name|string
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|string
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Keep discarding input until we see the ROMBUG prompt.     The convention for dealing with the prompt is that you    o give your command    o *then* wait for the prompt.     Thus the last thing that a procedure does with the serial line    will be an expect_prompt().  Exception:  rombug_resume does not    wait for the prompt, because the terminal is being handed over    to the inferior.  However, the next thing which happens after that    is a rombug_wait which does wait for the prompt.    Note that this includes abnormal exit, e.g. error().  This is    necessary to prevent getting into states from which we can't    recover.  */
end_comment

begin_function
specifier|static
name|void
name|expect_prompt
parameter_list|(
name|discard
parameter_list|)
name|int
name|discard
decl_stmt|;
block|{
if|if
condition|(
name|monitor_log
condition|)
comment|/* This is a convenient place to do this.  The idea is to do it often      enough that we never lose much data if we terminate abnormally.  */
name|fflush
argument_list|(
name|log_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_trace_mode
condition|)
block|{
name|expect
argument_list|(
literal|"trace"
argument_list|,
name|discard
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|expect
argument_list|(
name|PROMPT
argument_list|,
name|discard
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Get a hex digit from the remote system& return its value.    If ignore_space is nonzero, ignore spaces (not newline, tab, etc).  */
end_comment

begin_function
specifier|static
name|int
name|get_hex_digit
parameter_list|(
name|ignore_space
parameter_list|)
name|int
name|ignore_space
decl_stmt|;
block|{
name|int
name|ch
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|ch
operator|=
name|readchar
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|>=
literal|'0'
operator|&&
name|ch
operator|<=
literal|'9'
condition|)
return|return
name|ch
operator|-
literal|'0'
return|;
elseif|else
if|if
condition|(
name|ch
operator|>=
literal|'A'
operator|&&
name|ch
operator|<=
literal|'F'
condition|)
return|return
name|ch
operator|-
literal|'A'
operator|+
literal|10
return|;
elseif|else
if|if
condition|(
name|ch
operator|>=
literal|'a'
operator|&&
name|ch
operator|<=
literal|'f'
condition|)
return|return
name|ch
operator|-
literal|'a'
operator|+
literal|10
return|;
elseif|else
if|if
condition|(
name|ch
operator|==
literal|' '
operator|&&
name|ignore_space
condition|)
empty_stmt|;
else|else
block|{
name|expect_prompt
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Invalid hex digit from remote system."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Get a byte from monitor and put it in *BYT.  Accept any number    leading spaces.  */
end_comment

begin_function
specifier|static
name|void
name|get_hex_byte
parameter_list|(
name|byt
parameter_list|)
name|char
modifier|*
name|byt
decl_stmt|;
block|{
name|int
name|val
decl_stmt|;
name|val
operator|=
name|get_hex_digit
argument_list|(
literal|1
argument_list|)
operator|<<
literal|4
expr_stmt|;
name|val
operator||=
name|get_hex_digit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|*
name|byt
operator|=
name|val
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get N 32-bit words from remote, each preceded by a space,    and put them in registers starting at REGNO.  */
end_comment

begin_function
specifier|static
name|void
name|get_hex_regs
parameter_list|(
name|n
parameter_list|,
name|regno
parameter_list|)
name|int
name|n
decl_stmt|;
name|int
name|regno
decl_stmt|;
block|{
name|long
name|val
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unsigned
name|char
name|b
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
decl_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|4
condition|;
name|j
operator|++
control|)
block|{
name|get_hex_byte
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_BYTE_ORDER
operator|==
name|BIG_ENDIAN
condition|)
name|val
operator|=
operator|(
name|val
operator|<<
literal|8
operator|)
operator|+
name|b
expr_stmt|;
else|else
name|val
operator|=
name|val
operator|+
operator|(
name|b
operator|<<
operator|(
name|j
operator|*
literal|8
operator|)
operator|)
expr_stmt|;
block|}
name|supply_register
argument_list|(
name|regno
operator|++
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|val
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This is called not only when we first attach, but also when the    user types "run" after having attached.  */
end_comment

begin_function
specifier|static
name|void
name|rombug_create_inferior
parameter_list|(
name|execfile
parameter_list|,
name|args
parameter_list|,
name|env
parameter_list|)
name|char
modifier|*
name|execfile
decl_stmt|;
name|char
modifier|*
name|args
decl_stmt|;
name|char
modifier|*
modifier|*
name|env
decl_stmt|;
block|{
name|int
name|entry_pt
decl_stmt|;
if|if
condition|(
name|args
operator|&&
operator|*
name|args
condition|)
name|error
argument_list|(
literal|"Can't pass arguments to remote ROMBUG process"
argument_list|)
expr_stmt|;
if|if
condition|(
name|execfile
operator|==
literal|0
operator|||
name|exec_bfd
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No exec file specified"
argument_list|)
expr_stmt|;
name|entry_pt
operator|=
operator|(
name|int
operator|)
name|bfd_get_start_address
argument_list|(
name|exec_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|monitor_log
condition|)
name|fputs
argument_list|(
literal|"\nIn Create_inferior()"
argument_list|,
name|log_file
argument_list|)
expr_stmt|;
comment|/* The "process" (board) is already stopped awaiting our commands, and    the program is already downloaded.  We just set its PC and go.  */
name|init_wait_for_inferior
argument_list|()
expr_stmt|;
name|proceed
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|entry_pt
argument_list|,
name|TARGET_SIGNAL_DEFAULT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Open a connection to a remote debugger.    NAME is the filename used for communication.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|dev_name
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|rombug_open
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
if|if
condition|(
name|args
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Use `target RomBug DEVICE-NAME' to use a serial port, or \n\ `target RomBug HOST-NAME:PORT-NUMBER' to use a network connection."
argument_list|)
expr_stmt|;
name|target_preopen
argument_list|(
name|from_tty
argument_list|)
expr_stmt|;
if|if
condition|(
name|rombug_is_open
condition|)
name|unpush_target
argument_list|(
operator|&
name|rombug_ops
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|dev_name
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|monitor_desc
operator|=
name|SERIAL_OPEN
argument_list|(
name|dev_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|monitor_desc
operator|==
name|NULL
condition|)
name|perror_with_name
argument_list|(
name|dev_name
argument_list|)
expr_stmt|;
comment|/* if baud rate is set by 'set remotebaud' */
if|if
condition|(
name|SERIAL_SETBAUDRATE
argument_list|(
name|monitor_desc
argument_list|,
name|sr_get_baud_rate
argument_list|()
argument_list|)
condition|)
block|{
name|SERIAL_CLOSE
argument_list|(
name|monitor_desc
argument_list|)
expr_stmt|;
name|perror_with_name
argument_list|(
literal|"RomBug"
argument_list|)
expr_stmt|;
block|}
name|SERIAL_RAW
argument_list|(
name|monitor_desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|tty_xon
operator|||
name|tty_xoff
condition|)
block|{
struct|struct
name|hardware_ttystate
block|{
name|struct
name|termios
name|t
decl_stmt|;
block|}
modifier|*
name|tty_s
struct|;
name|tty_s
operator|=
operator|(
expr|struct
name|hardware_ttystate
operator|*
operator|)
name|SERIAL_GET_TTY_STATE
argument_list|(
name|monitor_desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|tty_xon
condition|)
name|tty_s
operator|->
name|t
operator|.
name|c_iflag
operator||=
name|IXON
expr_stmt|;
if|if
condition|(
name|tty_xoff
condition|)
name|tty_s
operator|->
name|t
operator|.
name|c_iflag
operator||=
name|IXOFF
expr_stmt|;
name|SERIAL_SET_TTY_STATE
argument_list|(
name|monitor_desc
argument_list|,
operator|(
name|serial_ttystate
operator|)
name|tty_s
argument_list|)
expr_stmt|;
block|}
name|rombug_is_open
operator|=
literal|1
expr_stmt|;
name|log_file
operator|=
name|fopen
argument_list|(
name|LOG_FILE
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|log_file
operator|==
name|NULL
condition|)
name|perror_with_name
argument_list|(
name|LOG_FILE
argument_list|)
expr_stmt|;
name|push_monitor
argument_list|(
operator|&
name|rombug_cmds
argument_list|)
expr_stmt|;
name|printf_monitor
argument_list|(
literal|"\r"
argument_list|)
expr_stmt|;
comment|/* CR wakes up monitor */
name|expect_prompt
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|push_target
argument_list|(
operator|&
name|rombug_ops
argument_list|)
expr_stmt|;
name|attach_flag
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
name|printf
argument_list|(
literal|"Remote %s connected to %s\n"
argument_list|,
name|target_shortname
argument_list|,
name|dev_name
argument_list|)
expr_stmt|;
name|rombug_fetch_registers
argument_list|()
expr_stmt|;
name|printf_monitor
argument_list|(
literal|"ov e \r"
argument_list|)
expr_stmt|;
name|expect_prompt
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|bufaddr
operator|=
literal|0
expr_stmt|;
name|buflen
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Close out all files and local state before this target loses control.  */
end_comment

begin_function
specifier|static
name|void
name|rombug_close
parameter_list|(
name|quitting
parameter_list|)
name|int
name|quitting
decl_stmt|;
block|{
if|if
condition|(
name|rombug_is_open
condition|)
block|{
name|SERIAL_CLOSE
argument_list|(
name|monitor_desc
argument_list|)
expr_stmt|;
name|monitor_desc
operator|=
name|NULL
expr_stmt|;
name|rombug_is_open
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|log_file
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|log_file
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error writing log file.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|log_file
argument_list|)
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error closing log file.\n"
argument_list|)
expr_stmt|;
name|log_file
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|rombug_link
parameter_list|(
name|mod_name
parameter_list|,
name|text_reloc
parameter_list|)
name|char
modifier|*
name|mod_name
decl_stmt|;
name|CORE_ADDR
modifier|*
name|text_reloc
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|unsigned
name|long
name|val
decl_stmt|;
name|unsigned
name|char
name|b
decl_stmt|;
name|printf_monitor
argument_list|(
literal|"l %s \r"
argument_list|,
name|mod_name
argument_list|)
expr_stmt|;
name|expect_prompt
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|printf_monitor
argument_list|(
literal|".r \r"
argument_list|)
expr_stmt|;
name|expect
argument_list|(
name|REG_DELIM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
literal|7
condition|;
name|i
operator|++
control|)
block|{
name|val
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|4
condition|;
name|j
operator|++
control|)
block|{
name|get_hex_byte
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
name|val
operator|<<
literal|8
operator|)
operator|+
name|b
expr_stmt|;
block|}
block|}
name|expect_prompt
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|*
name|text_reloc
operator|=
name|val
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Terminate the open connection to the remote debugger.    Use this when you want to detach and do something else    with your gdb.  */
end_comment

begin_function
specifier|static
name|void
name|rombug_detach
parameter_list|(
name|from_tty
parameter_list|)
name|int
name|from_tty
decl_stmt|;
block|{
if|if
condition|(
name|attach_flag
condition|)
block|{
name|printf_monitor
argument_list|(
name|GO_CMD
argument_list|)
expr_stmt|;
name|attach_flag
operator|=
literal|0
expr_stmt|;
block|}
name|pop_target
argument_list|()
expr_stmt|;
comment|/* calls rombug_close to do the real work */
if|if
condition|(
name|from_tty
condition|)
name|printf
argument_list|(
literal|"Ending remote %s debugging\n"
argument_list|,
name|target_shortname
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Tell the remote machine to resume.  */
end_comment

begin_function
specifier|static
name|void
name|rombug_resume
parameter_list|(
name|pid
parameter_list|,
name|step
parameter_list|,
name|sig
parameter_list|)
name|int
name|pid
decl_stmt|,
name|step
decl_stmt|;
name|enum
name|target_signal
name|sig
decl_stmt|;
block|{
if|if
condition|(
name|monitor_log
condition|)
name|fprintf
argument_list|(
name|log_file
argument_list|,
literal|"\nIn Resume (step=%d, sig=%d)\n"
argument_list|,
name|step
argument_list|,
name|sig
argument_list|)
expr_stmt|;
if|if
condition|(
name|step
condition|)
block|{
name|is_trace_mode
operator|=
literal|1
expr_stmt|;
name|printf_monitor
argument_list|(
name|STEP_CMD
argument_list|)
expr_stmt|;
comment|/* wait for the echo.  **       expect (STEP_CMD, 1);       */
block|}
else|else
block|{
name|printf_monitor
argument_list|(
name|GO_CMD
argument_list|)
expr_stmt|;
comment|/* swallow the echo.  **       expect (GO_CMD, 1);       */
block|}
name|bufaddr
operator|=
literal|0
expr_stmt|;
name|buflen
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Wait until the remote machine stops, then return,  * storing status in status just as `wait' would.  */
end_comment

begin_function
specifier|static
name|int
name|rombug_wait
parameter_list|(
name|pid
parameter_list|,
name|status
parameter_list|)
name|int
name|pid
decl_stmt|;
name|struct
name|target_waitstatus
modifier|*
name|status
decl_stmt|;
block|{
name|int
name|old_timeout
init|=
name|timeout
decl_stmt|;
name|struct
name|section_offsets
modifier|*
name|offs
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|,
name|pc
decl_stmt|;
name|struct
name|obj_section
modifier|*
name|obj_sec
decl_stmt|;
if|if
condition|(
name|monitor_log
condition|)
name|fputs
argument_list|(
literal|"\nIn wait ()"
argument_list|,
name|log_file
argument_list|)
expr_stmt|;
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_EXITED
expr_stmt|;
name|status
operator|->
name|value
operator|.
name|integer
operator|=
literal|0
expr_stmt|;
name|timeout
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Don't time out -- user program is running. */
name|expect
argument_list|(
literal|"eax:"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* output any message before register display */
name|expect_prompt
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Wait for prompt, outputting extraneous text */
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_STOPPED
expr_stmt|;
name|status
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_TRAP
expr_stmt|;
name|timeout
operator|=
name|old_timeout
expr_stmt|;
name|rombug_fetch_registers
argument_list|()
expr_stmt|;
name|bufaddr
operator|=
literal|0
expr_stmt|;
name|buflen
operator|=
literal|0
expr_stmt|;
name|pc
operator|=
name|read_register
argument_list|(
name|PC_REGNUM
argument_list|)
expr_stmt|;
name|addr
operator|=
name|read_register
argument_list|(
name|DATABASE_REG
argument_list|)
expr_stmt|;
name|obj_sec
operator|=
name|find_pc_section
argument_list|(
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj_sec
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|obj_sec
operator|->
name|objfile
operator|!=
name|symfile_objfile
condition|)
name|new_symfile_objfile
argument_list|(
name|obj_sec
operator|->
name|objfile
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|offs
operator|=
operator|(
operator|(
expr|struct
name|section_offsets
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|section_offsets
argument_list|)
operator|+
operator|(
name|symfile_objfile
operator|->
name|num_sections
operator|*
sizeof|sizeof
argument_list|(
name|offs
operator|->
name|offsets
argument_list|)
operator|)
argument_list|)
operator|)
expr_stmt|;
name|memcpy
argument_list|(
name|offs
argument_list|,
name|symfile_objfile
operator|->
name|section_offsets
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|section_offsets
argument_list|)
operator|+
operator|(
name|symfile_objfile
operator|->
name|num_sections
operator|*
sizeof|sizeof
argument_list|(
name|offs
operator|->
name|offsets
argument_list|)
operator|)
operator|)
argument_list|)
expr_stmt|;
name|ANOFFSET
argument_list|(
name|offs
argument_list|,
name|SECT_OFF_DATA
argument_list|)
operator|=
name|addr
expr_stmt|;
name|ANOFFSET
argument_list|(
name|offs
argument_list|,
name|SECT_OFF_BSS
argument_list|)
operator|=
name|addr
expr_stmt|;
name|objfile_relocate
argument_list|(
name|symfile_objfile
argument_list|,
name|offs
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return the name of register number regno in the form input and output by    monitor.  Currently, register_names just happens to contain exactly what    monitor wants.  Lets take advantage of that just as long as possible! */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|get_reg_name
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
specifier|static
name|char
name|buf
index|[
literal|50
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|b
decl_stmt|;
name|b
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|regno
operator|<
literal|0
condition|)
return|return
operator|(
literal|""
operator|)
return|;
comment|/*   for (p = reg_names[regno]; *p; p++)     *b++ = toupper(*p);   *b = '\000'; */
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|reg_names
index|[
name|regno
index|]
expr_stmt|;
return|return
name|p
return|;
comment|/*   return buf; */
block|}
end_function

begin_comment
comment|/* read the remote registers into the block regs.  */
end_comment

begin_function
specifier|static
name|void
name|rombug_fetch_registers
parameter_list|()
block|{
name|int
name|regno
decl_stmt|,
name|j
decl_stmt|,
name|i
decl_stmt|;
name|long
name|val
decl_stmt|;
name|unsigned
name|char
name|b
decl_stmt|;
name|printf_monitor
argument_list|(
name|GET_REG
argument_list|)
expr_stmt|;
name|expect
argument_list|(
literal|"eax:"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|expect
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|get_hex_regs
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|get_hex_regs
argument_list|(
literal|1
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|get_hex_regs
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|get_hex_regs
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|get_hex_regs
argument_list|(
literal|1
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|get_hex_regs
argument_list|(
literal|1
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|get_hex_regs
argument_list|(
literal|1
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|get_hex_regs
argument_list|(
literal|1
argument_list|,
literal|4
argument_list|)
expr_stmt|;
for|for
control|(
name|regno
operator|=
literal|8
init|;
name|regno
operator|<=
literal|15
condition|;
name|regno
operator|++
control|)
block|{
name|expect
argument_list|(
name|REG_DELIM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|>=
literal|8
operator|&&
name|regno
operator|<=
literal|13
condition|)
block|{
name|val
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|2
condition|;
name|j
operator|++
control|)
block|{
name|get_hex_byte
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_BYTE_ORDER
operator|==
name|BIG_ENDIAN
condition|)
name|val
operator|=
operator|(
name|val
operator|<<
literal|8
operator|)
operator|+
name|b
expr_stmt|;
else|else
name|val
operator|=
name|val
operator|+
operator|(
name|b
operator|<<
operator|(
name|j
operator|*
literal|8
operator|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|regno
operator|==
literal|8
condition|)
name|i
operator|=
literal|10
expr_stmt|;
if|if
condition|(
name|regno
operator|>=
literal|9
operator|&&
name|regno
operator|<=
literal|12
condition|)
name|i
operator|=
name|regno
operator|+
literal|3
expr_stmt|;
if|if
condition|(
name|regno
operator|==
literal|13
condition|)
name|i
operator|=
literal|11
expr_stmt|;
name|supply_register
argument_list|(
name|i
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|val
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|regno
operator|==
literal|14
condition|)
block|{
name|get_hex_regs
argument_list|(
literal|1
argument_list|,
name|PC_REGNUM
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|regno
operator|==
literal|15
condition|)
block|{
name|get_hex_regs
argument_list|(
literal|1
argument_list|,
literal|9
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|val
operator|=
literal|0
expr_stmt|;
name|supply_register
argument_list|(
name|regno
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|val
argument_list|)
expr_stmt|;
block|}
block|}
name|is_trace_mode
operator|=
literal|0
expr_stmt|;
name|expect_prompt
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fetch register REGNO, or all registers if REGNO is -1.    Returns errno value.  */
end_comment

begin_function
specifier|static
name|void
name|rombug_fetch_register
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
name|int
name|val
decl_stmt|,
name|j
decl_stmt|;
name|unsigned
name|char
name|b
decl_stmt|;
if|if
condition|(
name|monitor_log
condition|)
block|{
name|fprintf
argument_list|(
name|log_file
argument_list|,
literal|"\nIn Fetch Register (reg=%s)\n"
argument_list|,
name|get_reg_name
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|log_file
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|regno
operator|<
literal|0
condition|)
block|{
name|rombug_fetch_registers
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|name
init|=
name|get_reg_name
argument_list|(
name|regno
argument_list|)
decl_stmt|;
name|printf_monitor
argument_list|(
name|GET_REG
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|>=
literal|10
operator|&&
name|regno
operator|<=
literal|15
condition|)
block|{
name|expect
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|expect
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|expect
argument_list|(
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|expect
argument_list|(
name|REG_DELIM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|2
condition|;
name|j
operator|++
control|)
block|{
name|get_hex_byte
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_BYTE_ORDER
operator|==
name|BIG_ENDIAN
condition|)
name|val
operator|=
operator|(
name|val
operator|<<
literal|8
operator|)
operator|+
name|b
expr_stmt|;
else|else
name|val
operator|=
name|val
operator|+
operator|(
name|b
operator|<<
operator|(
name|j
operator|*
literal|8
operator|)
operator|)
expr_stmt|;
block|}
name|supply_register
argument_list|(
name|regno
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|val
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|regno
operator|==
literal|8
operator|||
name|regno
operator|==
literal|9
condition|)
block|{
name|expect
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|expect
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|expect
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|expect
argument_list|(
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|expect
argument_list|(
name|REG_DELIM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|get_hex_regs
argument_list|(
literal|1
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|expect
argument_list|(
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|expect
argument_list|(
name|REG_DELIM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|expect
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|get_hex_regs
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|get_hex_regs
argument_list|(
literal|1
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|get_hex_regs
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|get_hex_regs
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|get_hex_regs
argument_list|(
literal|1
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|get_hex_regs
argument_list|(
literal|1
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|get_hex_regs
argument_list|(
literal|1
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|get_hex_regs
argument_list|(
literal|1
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
name|expect_prompt
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* Store the remote registers from the contents of the block REGS.  */
end_comment

begin_function
specifier|static
name|void
name|rombug_store_registers
parameter_list|()
block|{
name|int
name|regno
decl_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<=
name|PC_REGNUM
condition|;
name|regno
operator|++
control|)
name|rombug_store_register
argument_list|(
name|regno
argument_list|)
expr_stmt|;
name|registers_changed
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Store register REGNO, or all if REGNO == 0.    return errno value.  */
end_comment

begin_function
specifier|static
name|void
name|rombug_store_register
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|monitor_log
condition|)
name|fprintf
argument_list|(
name|log_file
argument_list|,
literal|"\nIn Store_register (regno=%d)\n"
argument_list|,
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|==
operator|-
literal|1
condition|)
name|rombug_store_registers
argument_list|()
expr_stmt|;
else|else
block|{
if|if
condition|(
name|sr_get_debug
argument_list|()
condition|)
name|printf
argument_list|(
literal|"Setting register %s to 0x%x\n"
argument_list|,
name|get_reg_name
argument_list|(
name|regno
argument_list|)
argument_list|,
name|read_register
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
name|name
operator|=
name|get_reg_name
argument_list|(
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
literal|0
condition|)
return|return;
name|printf_monitor
argument_list|(
name|SET_REG
argument_list|,
name|name
argument_list|,
name|read_register
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
name|is_trace_mode
operator|=
literal|0
expr_stmt|;
name|expect_prompt
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Get ready to modify the registers array.  On machines which store    individual registers, this doesn't need to do anything.  On machines    which store all the registers in one fell swoop, this makes sure    that registers contains all the registers from the program being    debugged.  */
end_comment

begin_function
specifier|static
name|void
name|rombug_prepare_to_store
parameter_list|()
block|{
comment|/* Do nothing, since we can store individual regs */
block|}
end_function

begin_function
specifier|static
name|void
name|rombug_files_info
parameter_list|()
block|{
name|printf
argument_list|(
literal|"\tAttached to %s at %d baud.\n"
argument_list|,
name|dev_name
argument_list|,
name|sr_get_baud_rate
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy LEN bytes of data from debugger memory at MYADDR    to inferior's memory at MEMADDR.  Returns length moved.  */
end_comment

begin_function
specifier|static
name|int
name|rombug_write_inferior_memory
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|unsigned
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|char
name|buf
index|[
literal|10
index|]
decl_stmt|;
if|if
condition|(
name|monitor_log
condition|)
name|fprintf
argument_list|(
name|log_file
argument_list|,
literal|"\nIn Write_inferior_memory (memaddr=%x, len=%d)\n"
argument_list|,
name|memaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|printf_monitor
argument_list|(
name|MEM_SET_CMD
argument_list|,
name|memaddr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|expect
argument_list|(
name|CMD_DELIM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|printf_monitor
argument_list|(
literal|"%x \r"
argument_list|,
name|myaddr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sr_get_debug
argument_list|()
condition|)
name|printf
argument_list|(
literal|"\nSet 0x%x to 0x%x\n"
argument_list|,
name|memaddr
operator|+
name|i
argument_list|,
name|myaddr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|expect
argument_list|(
name|CMD_DELIM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|CMD_END
condition|)
name|printf_monitor
argument_list|(
name|CMD_END
argument_list|)
expr_stmt|;
name|is_trace_mode
operator|=
literal|0
expr_stmt|;
name|expect_prompt
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|bufaddr
operator|=
literal|0
expr_stmt|;
name|buflen
operator|=
literal|0
expr_stmt|;
return|return
name|len
return|;
block|}
end_function

begin_comment
comment|/* Read LEN bytes from inferior memory at MEMADDR.  Put the result    at debugger address MYADDR.  Returns length moved.  */
end_comment

begin_function
specifier|static
name|int
name|rombug_read_inferior_memory
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* Number of bytes read so far.  */
name|int
name|count
decl_stmt|;
comment|/* Starting address of this pass.  */
name|unsigned
name|long
name|startaddr
decl_stmt|;
comment|/* Number of bytes to read in this pass.  */
name|int
name|len_this_pass
decl_stmt|;
if|if
condition|(
name|monitor_log
condition|)
name|fprintf
argument_list|(
name|log_file
argument_list|,
literal|"\nIn Read_inferior_memory (memaddr=%x, len=%d)\n"
argument_list|,
name|memaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Note that this code works correctly if startaddr is just less      than UINT_MAX (well, really CORE_ADDR_MAX if there was such a      thing).  That is, something like      rombug_read_bytes (CORE_ADDR_MAX - 4, foo, 4)      works--it never adds len To memaddr and gets 0.  */
comment|/* However, something like      rombug_read_bytes (CORE_ADDR_MAX - 3, foo, 4)      doesn't need to work.  Detect it and give up if there's an attempt      to do that.  */
if|if
condition|(
operator|(
operator|(
name|memaddr
operator|-
literal|1
operator|)
operator|+
name|len
operator|)
operator|<
name|memaddr
condition|)
block|{
name|errno
operator|=
name|EIO
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|bufaddr
operator|<=
name|memaddr
operator|&&
operator|(
name|memaddr
operator|+
name|len
operator|)
operator|<=
operator|(
name|bufaddr
operator|+
name|buflen
operator|)
condition|)
block|{
name|memcpy
argument_list|(
name|myaddr
argument_list|,
operator|&
name|readbuf
index|[
name|memaddr
operator|-
name|bufaddr
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|len
return|;
block|}
name|startaddr
operator|=
name|memaddr
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|count
operator|<
name|len
condition|)
block|{
name|len_this_pass
operator|=
literal|16
expr_stmt|;
if|if
condition|(
operator|(
name|startaddr
operator|%
literal|16
operator|)
operator|!=
literal|0
condition|)
name|len_this_pass
operator|-=
name|startaddr
operator|%
literal|16
expr_stmt|;
if|if
condition|(
name|len_this_pass
operator|>
operator|(
name|len
operator|-
name|count
operator|)
condition|)
name|len_this_pass
operator|=
operator|(
name|len
operator|-
name|count
operator|)
expr_stmt|;
if|if
condition|(
name|sr_get_debug
argument_list|()
condition|)
name|printf
argument_list|(
literal|"\nDisplay %d bytes at %x\n"
argument_list|,
name|len_this_pass
argument_list|,
name|startaddr
argument_list|)
expr_stmt|;
name|printf_monitor
argument_list|(
name|MEM_DIS_CMD
argument_list|,
name|startaddr
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|expect
argument_list|(
literal|"- "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|get_hex_byte
argument_list|(
operator|&
name|readbuf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|bufaddr
operator|=
name|startaddr
expr_stmt|;
name|buflen
operator|=
literal|16
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|myaddr
index|[
name|count
index|]
argument_list|,
name|readbuf
argument_list|,
name|len_this_pass
argument_list|)
expr_stmt|;
name|count
operator|+=
name|len_this_pass
expr_stmt|;
name|startaddr
operator|+=
name|len_this_pass
expr_stmt|;
name|expect
argument_list|(
name|CMD_DELIM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|CMD_END
condition|)
name|printf_monitor
argument_list|(
name|CMD_END
argument_list|)
expr_stmt|;
name|is_trace_mode
operator|=
literal|0
expr_stmt|;
name|expect_prompt
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|len
return|;
block|}
end_function

begin_comment
comment|/* FIXME-someday!  merge these two.  */
end_comment

begin_function
specifier|static
name|int
name|rombug_xfer_inferior_memory
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|,
name|write
parameter_list|,
name|target
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|write
decl_stmt|;
name|struct
name|target_ops
modifier|*
name|target
decl_stmt|;
comment|/* ignored */
block|{
if|if
condition|(
name|write
condition|)
return|return
name|rombug_write_inferior_memory
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
return|;
else|else
return|return
name|rombug_read_inferior_memory
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|rombug_kill
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
return|return;
comment|/* ignore attempts to kill target system */
block|}
end_function

begin_comment
comment|/* Clean up when a program exits.    The program actually lives on in the remote processor's RAM, and may be    run again without a download.  Don't leave it full of breakpoint    instructions.  */
end_comment

begin_function
specifier|static
name|void
name|rombug_mourn_inferior
parameter_list|()
block|{
name|remove_breakpoints
argument_list|()
expr_stmt|;
name|generic_mourn_inferior
argument_list|()
expr_stmt|;
comment|/* Do all the proper things now */
block|}
end_function

begin_define
define|#
directive|define
name|MAX_MONITOR_BREAKPOINTS
value|16
end_define

begin_decl_stmt
specifier|extern
name|int
name|memory_breakpoint_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|breakaddr
index|[
name|MAX_MONITOR_BREAKPOINTS
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|rombug_insert_breakpoint
parameter_list|(
name|addr
parameter_list|,
name|shadow
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
name|char
modifier|*
name|shadow
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|monitor_log
condition|)
name|fprintf
argument_list|(
name|log_file
argument_list|,
literal|"\nIn Insert_breakpoint (addr=%x)\n"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|MAX_MONITOR_BREAKPOINTS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|breakaddr
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|breakaddr
index|[
name|i
index|]
operator|=
name|addr
expr_stmt|;
if|if
condition|(
name|sr_get_debug
argument_list|()
condition|)
name|printf
argument_list|(
literal|"Breakpoint at %x\n"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|rombug_read_inferior_memory
argument_list|(
name|addr
argument_list|,
name|shadow
argument_list|,
name|memory_breakpoint_size
argument_list|)
expr_stmt|;
name|printf_monitor
argument_list|(
name|SET_BREAK_CMD
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|is_trace_mode
operator|=
literal|0
expr_stmt|;
name|expect_prompt
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Too many breakpoints (> 16) for monitor\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * _remove_breakpoint -- Tell the monitor to remove a breakpoint  */
end_comment

begin_function
specifier|static
name|int
name|rombug_remove_breakpoint
parameter_list|(
name|addr
parameter_list|,
name|shadow
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
name|char
modifier|*
name|shadow
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|monitor_log
condition|)
name|fprintf
argument_list|(
name|log_file
argument_list|,
literal|"\nIn Remove_breakpoint (addr=%x)\n"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_MONITOR_BREAKPOINTS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|breakaddr
index|[
name|i
index|]
operator|==
name|addr
condition|)
block|{
name|breakaddr
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|printf_monitor
argument_list|(
name|CLR_BREAK_CMD
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|is_trace_mode
operator|=
literal|0
expr_stmt|;
name|expect_prompt
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't find breakpoint associated with 0x%x\n"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Load a file. This is usually an srecord, which is ascii. No     protocol, just sent line by line. */
end_comment

begin_define
define|#
directive|define
name|DOWNLOAD_LINE_SIZE
value|100
end_define

begin_function
specifier|static
name|void
name|rombug_load
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
comment|/* this part comment out for os9* */
if|#
directive|if
literal|0
block|FILE *download;   char buf[DOWNLOAD_LINE_SIZE];   int i, bytes_read;    if (sr_get_debug())     printf ("Loading %s to monitor\n", arg);    download = fopen (arg, "r");   if (download == NULL)     {     error (sprintf (buf, "%s Does not exist", arg));     return;   }    printf_monitor (LOAD_CMD);
comment|/*  expect ("Waiting for S-records from host... ", 1); */
block|while (!feof (download))     {       bytes_read = fread (buf, sizeof (char), DOWNLOAD_LINE_SIZE, download);       if (hashmark) 	{ 	  putchar ('.'); 	  fflush (stdout); 	}        if (SERIAL_WRITE(monitor_desc, buf, bytes_read)) { 	fprintf(stderr, "SERIAL_WRITE failed: (while downloading) %s\n", safe_strerror(errno)); 	break;       }       i = 0;       while (i++<=200000) {} ;
comment|/* Ugly HACK, probably needs flow control */
block|if (bytes_read< DOWNLOAD_LINE_SIZE) 	{ 	  if (!feof (download)) 	    error ("Only read %d bytes\n", bytes_read); 	  break; 	}     }    if (hashmark)     {       putchar ('\n');     }   if (!feof (download))     error ("Never got EOF while downloading");   fclose (download);
endif|#
directive|endif
endif|0
block|}
end_function

begin_comment
comment|/* Put a command string, in args, out to MONITOR.      Output from MONITOR is placed on the users terminal until the prompt     is seen. */
end_comment

begin_function
specifier|static
name|void
name|rombug_command
parameter_list|(
name|args
parameter_list|,
name|fromtty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|fromtty
decl_stmt|;
block|{
if|if
condition|(
name|monitor_desc
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"monitor target not open."
argument_list|)
expr_stmt|;
if|if
condition|(
name|monitor_log
condition|)
name|fprintf
argument_list|(
name|log_file
argument_list|,
literal|"\nIn command (args=%s)\n"
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|args
condition|)
name|error
argument_list|(
literal|"Missing command."
argument_list|)
expr_stmt|;
name|printf_monitor
argument_list|(
literal|"%s\r"
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|expect_prompt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Connect the user directly to MONITOR.  This command acts just like the    'cu' or 'tip' command.  Use<CR>~. or<CR>~^D to break out.  */
end_comment

begin_comment
unit|static struct ttystate ttystate;  static void cleanup_tty() {  printf("\r\n[Exiting connect mode]\r\n");
comment|/*SERIAL_RESTORE(0,&ttystate);*/
end_comment

begin_comment
unit|}  static void connect_command (args, fromtty)      char	*args;      int	fromtty; {   fd_set readfds;   int numfds;   int c;   char cur_esc = 0;    dont_repeat();    if (monitor_desc == NULL)     error("monitor target not open.");      if (args)     fprintf("This command takes no args.  They have been ignored.\n"); 	   printf("[Entering connect mode.  Use ~. or ~^D to escape]\n");    serial_raw(0,&ttystate);    make_cleanup(cleanup_tty, 0);    FD_ZERO(&readfds);    while (1)     {       do 	{ 	  FD_SET(0,&readfds); 	  FD_SET(monitor_desc,&readfds); 	  numfds = select(sizeof(readfds)*8,&readfds, 0, 0, 0); 	}       while (numfds == 0);        if (numfds< 0) 	perror_with_name("select");        if (FD_ISSET(0,&readfds)) 	{
comment|/* tty input, send to monitor */
end_comment

begin_endif
unit|c = getchar(); 	  if (c< 0) 	    perror_with_name("connect");  	  printf_monitor("%c", c); 	  switch (cur_esc) 	    { 	    case 0: 	      if (c == '\r') 		cur_esc = c; 	      break; 	    case '\r': 	      if (c == '~') 		cur_esc = c; 	      else 		cur_esc = 0; 	      break; 	    case '~': 	      if (c == '.' || c == '\004') 		return; 	      else 		cur_esc = 0; 	    } 	}        if (FD_ISSET(monitor_desc,&readfds)) 	{ 	  while (1) 	    { 	      c = readchar(0); 	      if (c< 0) 		break; 	      putchar(c); 	    } 	  fflush(stdout); 	}     } }
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Define the monitor command strings. Since these are passed directly  * through to a printf style function, we need can include formatting  * strings. We also need a CR or LF on the end.  */
end_comment

begin_decl_stmt
name|struct
name|monitor_ops
name|rombug_cmds
init|=
block|{
literal|"g \r"
block|,
comment|/* execute or usually GO command */
literal|"g \r"
block|,
comment|/* continue command */
literal|"t \r"
block|,
comment|/* single step */
literal|"b %x\r"
block|,
comment|/* set a breakpoint */
literal|"k %x\r"
block|,
comment|/* clear a breakpoint */
literal|"c %x\r"
block|,
comment|/* set memory to a value */
literal|"d %x %d\r"
block|,
comment|/* display memory */
literal|"$%08X"
block|,
comment|/* prompt memory commands use */
literal|".%s %x\r"
block|,
comment|/* set a register */
literal|":"
block|,
comment|/* delimiter between registers */
literal|". \r"
block|,
comment|/* read a register */
literal|"mf \r"
block|,
comment|/* download command */
literal|"RomBug: "
block|,
comment|/* monitor command prompt */
literal|": "
block|,
comment|/* end-of-command delimitor */
literal|".\r"
comment|/* optional command terminator */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|target_ops
name|rombug_ops
init|=
block|{
literal|"rombug"
block|,
literal|"Microware's ROMBUG debug monitor"
block|,
literal|"Use a remote computer running the ROMBUG debug monitor.\n\ Specify the serial device it is connected to (e.g. /dev/ttya)."
block|,
name|rombug_open
block|,
name|rombug_close
block|,
literal|0
block|,
name|rombug_detach
block|,
name|rombug_resume
block|,
name|rombug_wait
block|,
name|rombug_fetch_register
block|,
name|rombug_store_register
block|,
name|rombug_prepare_to_store
block|,
name|rombug_xfer_inferior_memory
block|,
name|rombug_files_info
block|,
name|rombug_insert_breakpoint
block|,
name|rombug_remove_breakpoint
block|,
comment|/* Breakpoints */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* Terminal handling */
name|rombug_kill
block|,
name|rombug_load
block|,
comment|/* load */
name|rombug_link
block|,
comment|/* lookup_symbol */
name|rombug_create_inferior
block|,
name|rombug_mourn_inferior
block|,
literal|0
block|,
comment|/* can_run */
literal|0
block|,
comment|/* notice_signals */
literal|0
block|,
comment|/* to_stop */
name|process_stratum
block|,
literal|0
block|,
comment|/* next */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* has execution */
literal|0
block|,
literal|0
block|,
comment|/* Section pointers */
name|OPS_MAGIC
block|,
comment|/* Always the last thing */
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|_initialize_remote_os9k
parameter_list|()
block|{
name|add_target
argument_list|(
operator|&
name|rombug_ops
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"hash"
argument_list|,
name|no_class
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|hashmark
argument_list|,
literal|"Set display of activity while downloading a file.\nWhen enabled, a period \'.\' is displayed."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"timeout"
argument_list|,
name|no_class
argument_list|,
name|var_zinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|timeout
argument_list|,
literal|"Set timeout in seconds for remote MIPS serial I/O."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"remotelog"
argument_list|,
name|no_class
argument_list|,
name|var_zinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|monitor_log
argument_list|,
literal|"Set monitor activity log on(=1) or off(=0)."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"remotexon"
argument_list|,
name|no_class
argument_list|,
name|var_zinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|tty_xon
argument_list|,
literal|"Set remote tty line XON control"
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"remotexoff"
argument_list|,
name|no_class
argument_list|,
name|var_zinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|tty_xoff
argument_list|,
literal|"Set remote tty line XOFF control"
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"rombug<command>"
argument_list|,
name|class_obscure
argument_list|,
name|rombug_command
argument_list|,
literal|"Send a command to the debug monitor."
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|add_com ("connect", class_obscure, connect_command,    	   "Connect the terminal directly up to a serial based command monitor.\nUse<CR>~. or<CR>~^D to break out.");
endif|#
directive|endif
block|}
end_function

end_unit

