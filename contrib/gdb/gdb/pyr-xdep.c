begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Low level Pyramid interface to ptrace, for GDB when running under Unix.    Copyright (C) 1988, 1989, 1991 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_comment
comment|/* #include<fcntl.h>  Can we live without this?  */
end_comment

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_comment
comment|/* After a.out.h  */
end_comment

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|"gdb_stat.h"
end_include

begin_escape
end_escape

begin_function
name|void
name|fetch_inferior_registers
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
specifier|register
name|int
name|datum
decl_stmt|;
specifier|register
name|unsigned
name|int
name|regaddr
decl_stmt|;
name|int
name|reg_buf
index|[
name|NUM_REGS
operator|+
literal|1
index|]
decl_stmt|;
name|struct
name|user
name|u
decl_stmt|;
specifier|register
name|int
name|skipped_frames
init|=
literal|0
decl_stmt|;
name|registers_fetched
argument_list|()
expr_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
literal|64
condition|;
name|regno
operator|++
control|)
block|{
name|reg_buf
index|[
name|regno
index|]
operator|=
name|ptrace
argument_list|(
literal|3
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|regno
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|PYRAMID_CONTROL_FRAME_DEBUGGING
argument_list|)
name|printf_unfiltered
argument_list|(
literal|"Fetching register %s, got %0x\n"
argument_list|,
name|reg_names
index|[
name|regno
index|]
argument_list|,
name|reg_buf
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PYRAMID_CONTROL_FRAME_DEBUGGING */
if|if
condition|(
name|reg_buf
index|[
name|regno
index|]
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EIO
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"fetch_interior_registers: fetching register %s\n"
argument_list|,
name|reg_names
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
block|}
name|supply_register
argument_list|(
name|regno
argument_list|,
name|reg_buf
operator|+
name|regno
argument_list|)
expr_stmt|;
block|}
comment|/* that leaves regs 64, 65, and 66 */
name|datum
operator|=
name|ptrace
argument_list|(
literal|3
argument_list|,
name|inferior_pid
argument_list|,
call|(
name|PTRACE_ARG3_TYPE
call|)
argument_list|(
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|u
operator|.
name|u_pcb
operator|.
name|pcb_csp
operator|)
operator|-
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|u
operator|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* FIXME: Find the Current Frame Pointer (CFP). CFP is a global      register (ie, NOT windowed), that gets saved in a frame iff      the code for that frame has a prologue (ie, "adsf N").  If      there is a prologue, the adsf insn saves the old cfp in      pr13, cfp is set to sp, and N bytes of locals are allocated      (sp is decremented by n).      This makes finding CFP hard. I guess the right way to do it      is:       - If this is the innermost frame, believe ptrace() or      the core area.      - Otherwise:      Find the first insn of the current frame.      - find the saved pc;      - find the call insn that saved it;      - figure out where the call is to;      - if the first insn is an adsf, we got a frame      pointer. */
comment|/* Normal processors have separate stack pointers for user and      kernel mode. Getting the last user mode frame on such      machines is easy: the kernel context of the ptrace()'d      process is on the kernel stack, and the USP points to what      we want. But Pyramids only have a single cfp for both user and      kernel mode.  And processes being ptrace()'d have some      kernel-context control frames on their stack.      To avoid tracing back into the kernel context of an inferior,      we skip 0 or more contiguous control frames where the pc is      in the kernel. */
while|while
condition|(
literal|1
condition|)
block|{
specifier|register
name|int
name|inferior_saved_pc
decl_stmt|;
name|inferior_saved_pc
operator|=
name|ptrace
argument_list|(
literal|1
argument_list|,
name|inferior_pid
argument_list|,
call|(
name|PTRACE_ARG3_TYPE
call|)
argument_list|(
name|datum
operator|+
operator|(
operator|(
literal|32
operator|+
literal|15
operator|)
operator|*
literal|4
operator|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|inferior_saved_pc
operator|>
literal|0
condition|)
break|break;
if|#
directive|if
name|defined
argument_list|(
name|PYRAMID_CONTROL_FRAME_DEBUGGING
argument_list|)
name|printf_unfiltered
argument_list|(
literal|"skipping kernel frame %08x, pc=%08x\n"
argument_list|,
name|datum
argument_list|,
name|inferior_saved_pc
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PYRAMID_CONTROL_FRAME_DEBUGGING */
name|skipped_frames
operator|++
expr_stmt|;
name|datum
operator|-=
name|CONTROL_STACK_FRAME_SIZE
expr_stmt|;
block|}
name|reg_buf
index|[
name|CSP_REGNUM
index|]
operator|=
name|datum
expr_stmt|;
name|supply_register
argument_list|(
name|CSP_REGNUM
argument_list|,
name|reg_buf
operator|+
name|CSP_REGNUM
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PYRAMID_CONTROL_FRAME_DEBUGGING
if|if
condition|(
name|skipped_frames
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|stderr
argument_list|,
literal|"skipped %d frames from %x to %x; cfp was %x, now %x\n"
argument_list|,
name|skipped_frames
argument_list|,
name|reg_buf
index|[
name|CSP_REGNUM
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* PYRAMID_CONTROL_FRAME_DEBUGGING */
block|}
end_function

begin_comment
comment|/* Store our register values back into the inferior.    If REGNO is -1, do this for all registers.    Otherwise, REGNO specifies which register (so we can save time).  */
end_comment

begin_function
name|void
name|store_inferior_registers
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
specifier|register
name|unsigned
name|int
name|regaddr
decl_stmt|;
name|char
name|buf
index|[
literal|80
index|]
decl_stmt|;
if|if
condition|(
name|regno
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
literal|0
operator|<=
name|regno
operator|)
operator|&&
operator|(
name|regno
operator|<
literal|64
operator|)
condition|)
block|{
comment|/*regaddr = register_addr (regno, offset);*/
name|regaddr
operator|=
name|regno
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|ptrace
argument_list|(
literal|6
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|regaddr
argument_list|,
name|read_register
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"writing register number %d"
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|perror_with_name
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|NUM_REGS
condition|;
name|regno
operator|++
control|)
block|{
comment|/*regaddr = register_addr (regno, offset);*/
name|regaddr
operator|=
name|regno
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|ptrace
argument_list|(
literal|6
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|regaddr
argument_list|,
name|read_register
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"writing all regs, number %d"
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|perror_with_name
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/*** Extensions to  core and dump files, for GDB. */
specifier|extern
name|unsigned
name|int
name|last_frame_offset
decl_stmt|;
ifdef|#
directive|ifdef
name|PYRAMID_CORE
comment|/* Can't make definitions here static, since corefile.c needs them    to do bounds checking on the core-file areas. O well. */
comment|/* have two stacks: one for data, one for register windows. */
specifier|extern
name|CORE_ADDR
name|reg_stack_start
decl_stmt|;
specifier|extern
name|CORE_ADDR
name|reg_stack_end
decl_stmt|;
comment|/* need this so we can find the global registers: they never get saved. */
name|CORE_ADDR
name|global_reg_offset
decl_stmt|;
specifier|static
name|CORE_ADDR
name|last_frame_address
decl_stmt|;
name|CORE_ADDR
name|last_frame_offset
decl_stmt|;
comment|/* Address in core file of start of register window stack area.    Don't know if is this any of meaningful, useful or necessary.   */
specifier|extern
name|int
name|reg_stack_offset
decl_stmt|;
endif|#
directive|endif
comment|/* PYRAMID_CORE */
comment|/* Work with core dump and executable files, for GDB.     This code would be in corefile.c if it weren't machine-dependent. */
name|void
name|core_file_command
parameter_list|(
name|filename
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|int
name|val
decl_stmt|;
specifier|extern
name|char
name|registers
index|[]
decl_stmt|;
comment|/* Discard all vestiges of any previous core file      and mark data and stack spaces as empty.  */
if|if
condition|(
name|corefile
condition|)
name|free
argument_list|(
name|corefile
argument_list|)
expr_stmt|;
name|corefile
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|corechan
operator|>=
literal|0
condition|)
name|close
argument_list|(
name|corechan
argument_list|)
expr_stmt|;
name|corechan
operator|=
operator|-
literal|1
expr_stmt|;
name|data_start
operator|=
literal|0
expr_stmt|;
name|data_end
operator|=
literal|0
expr_stmt|;
name|stack_start
operator|=
name|STACK_END_ADDR
expr_stmt|;
name|stack_end
operator|=
name|STACK_END_ADDR
expr_stmt|;
ifdef|#
directive|ifdef
name|PYRAMID_CORE
name|reg_stack_start
operator|=
name|CONTROL_STACK_ADDR
expr_stmt|;
name|reg_stack_end
operator|=
name|CONTROL_STACK_ADDR
expr_stmt|;
comment|/* this isn't strictly true...*/
endif|#
directive|endif
comment|/* PYRAMID_CORE */
comment|/* Now, if a new core file was specified, open it and digest it.  */
if|if
condition|(
name|filename
condition|)
block|{
name|filename
operator|=
name|tilde_expand
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_inferior_p
argument_list|()
condition|)
name|error
argument_list|(
literal|"To look at a core file, you must kill the program with \"kill\"."
argument_list|)
expr_stmt|;
name|corechan
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|corechan
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
comment|/* 4.2-style (and perhaps also sysV-style) core dump file.  */
block|{
name|struct
name|user
name|u
decl_stmt|;
name|unsigned
name|int
name|reg_offset
decl_stmt|;
name|val
operator|=
name|myread
argument_list|(
name|corechan
argument_list|,
operator|&
name|u
argument_list|,
sizeof|sizeof
name|u
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
literal|"Not a core file: reading upage"
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
sizeof|sizeof
name|u
condition|)
name|error
argument_list|(
literal|"Not a core file: could only read %d bytes"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|data_start
operator|=
name|exec_data_start
expr_stmt|;
name|data_end
operator|=
name|data_start
operator|+
name|NBPG
operator|*
name|u
operator|.
name|u_dsize
expr_stmt|;
name|data_offset
operator|=
name|NBPG
operator|*
name|UPAGES
expr_stmt|;
name|stack_offset
operator|=
name|NBPG
operator|*
operator|(
name|UPAGES
operator|+
name|u
operator|.
name|u_dsize
operator|)
expr_stmt|;
comment|/* find registers in core file */
ifdef|#
directive|ifdef
name|PYRAMID_PTRACE
name|stack_start
operator|=
name|stack_end
operator|-
name|NBPG
operator|*
name|u
operator|.
name|u_ussize
expr_stmt|;
name|reg_stack_offset
operator|=
name|stack_offset
operator|+
operator|(
name|NBPG
operator|*
name|u
operator|.
name|u_ussize
operator|)
expr_stmt|;
name|reg_stack_end
operator|=
name|reg_stack_start
operator|+
name|NBPG
operator|*
name|u
operator|.
name|u_cssize
expr_stmt|;
name|last_frame_address
operator|=
operator|(
operator|(
name|int
operator|)
name|u
operator|.
name|u_pcb
operator|.
name|pcb_csp
operator|)
expr_stmt|;
name|last_frame_offset
operator|=
name|reg_stack_offset
operator|+
name|last_frame_address
operator|-
name|CONTROL_STACK_ADDR
expr_stmt|;
name|global_reg_offset
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|u
operator|-
operator|(
name|char
operator|*
operator|)
operator|&
name|u
operator|.
name|u_pcb
operator|.
name|pcb_gr0
expr_stmt|;
comment|/* skip any control-stack frames that were executed in the 	   kernel. */
while|while
condition|(
literal|1
condition|)
block|{
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|val
operator|=
name|lseek
argument_list|(
name|corechan
argument_list|,
name|last_frame_offset
operator|+
operator|(
literal|47
operator|*
literal|4
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|val
operator|=
name|myread
argument_list|(
name|corechan
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|buf
operator|>=
literal|0
condition|)
break|break;
name|printf_unfiltered
argument_list|(
literal|"skipping frame %s\n"
argument_list|,
name|local_hex_string
argument_list|(
name|last_frame_address
argument_list|)
argument_list|)
expr_stmt|;
name|last_frame_offset
operator|-=
name|CONTROL_STACK_FRAME_SIZE
expr_stmt|;
name|last_frame_address
operator|-=
name|CONTROL_STACK_FRAME_SIZE
expr_stmt|;
block|}
name|reg_offset
operator|=
name|last_frame_offset
expr_stmt|;
if|#
directive|if
literal|1
operator|||
name|defined
argument_list|(
name|PYRAMID_CONTROL_FRAME_DEBUGGING
argument_list|)
name|printf_unfiltered
argument_list|(
literal|"Control stack pointer = %s\n"
argument_list|,
name|local_hex_string
argument_list|(
name|u
operator|.
name|u_pcb
operator|.
name|pcb_csp
argument_list|)
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"offset to control stack %d outermost frame %d (%s)\n"
argument_list|,
name|reg_stack_offset
argument_list|,
name|reg_offset
argument_list|,
name|local_hex_string
argument_list|(
name|last_frame_address
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PYRAMID_CONTROL_FRAME_DEBUGGING */
else|#
directive|else
comment|/* not PYRAMID_CORE */
name|stack_start
operator|=
name|stack_end
operator|-
name|NBPG
operator|*
name|u
operator|.
name|u_ssize
expr_stmt|;
name|reg_offset
operator|=
operator|(
name|int
operator|)
name|u
operator|.
name|u_ar0
operator|-
name|KERNEL_U_ADDR
expr_stmt|;
endif|#
directive|endif
comment|/* not PYRAMID_CORE */
ifdef|#
directive|ifdef
name|__not_on_pyr_yet
comment|/* Some machines put an absolute address in here and some put 	   the offset in the upage of the regs.  */
name|reg_offset
operator|=
operator|(
name|int
operator|)
name|u
operator|.
name|u_ar0
expr_stmt|;
if|if
condition|(
name|reg_offset
operator|>
name|NBPG
operator|*
name|UPAGES
condition|)
name|reg_offset
operator|-=
name|KERNEL_U_ADDR
expr_stmt|;
endif|#
directive|endif
comment|/* I don't know where to find this info. 	   So, for now, mark it as not available.  */
name|N_SET_MAGIC
argument_list|(
name|core_aouthdr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Read the register values out of the core file and store 	   them where `read_register' will find them.  */
block|{
specifier|register
name|int
name|regno
decl_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
literal|64
condition|;
name|regno
operator|++
control|)
block|{
name|char
name|buf
index|[
name|MAX_REGISTER_RAW_SIZE
index|]
decl_stmt|;
name|val
operator|=
name|lseek
argument_list|(
name|corechan
argument_list|,
name|register_addr
argument_list|(
name|regno
argument_list|,
name|reg_offset
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
operator|||
operator|(
name|val
operator|=
name|myread
argument_list|(
name|corechan
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|char
modifier|*
name|buffer
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|reg_names
index|[
name|regno
index|]
argument_list|)
operator|+
literal|30
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|buffer
argument_list|,
literal|"Reading register "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buffer
argument_list|,
name|reg_names
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
name|perror_with_name
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PYRAMID_CONTROL_FRAME_DEBUGGING
name|printf_unfiltered
argument_list|(
literal|"[reg %s(%d), offset in file %s=0x%0x, addr =0x%0x, =%0x]\n"
argument_list|,
name|reg_names
index|[
name|regno
index|]
argument_list|,
name|regno
argument_list|,
name|filename
argument_list|,
name|register_addr
argument_list|(
name|regno
argument_list|,
name|reg_offset
argument_list|)
argument_list|,
name|regno
operator|*
literal|4
operator|+
name|last_frame_address
argument_list|,
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|buf
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PYRAMID_CONTROL_FRAME_DEBUGGING */
name|supply_register
argument_list|(
name|regno
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|filename
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
name|corefile
operator|=
name|savestring
argument_list|(
name|filename
argument_list|,
name|strlen
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|corefile
operator|=
name|concat
argument_list|(
name|current_directory
argument_list|,
literal|"/"
argument_list|,
name|filename
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|1
operator|||
name|defined
argument_list|(
name|PYRAMID_CONTROL_FRAME_DEBUGGING
argument_list|)
name|printf_unfiltered
argument_list|(
literal|"Providing CSP (%s) as nominal address of current frame.\n"
argument_list|,
name|local_hex_string
argument_list|(
name|last_frame_address
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|PYRAMID_CONTROL_FRAME_DEBUGGING
comment|/* FIXME: Which of the following is correct? */
if|#
directive|if
literal|0
block|set_current_frame ( create_new_frame (read_register (FP_REGNUM), 					    read_pc ()));
else|#
directive|else
name|set_current_frame
argument_list|(
name|create_new_frame
argument_list|(
name|last_frame_address
argument_list|,
name|read_pc
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|select_frame
argument_list|(
name|get_current_frame
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|validate_files
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|from_tty
condition|)
name|printf_unfiltered
argument_list|(
literal|"No core file now.\n"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

