begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Target-dependent code for the IA-64 for GDB, the GNU debugger.     Copyright 1999, 2000, 2001, 2002, 2003, 2004 Free Software    Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"arch-utils.h"
end_include

begin_include
include|#
directive|include
file|"floatformat.h"
end_include

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_include
include|#
directive|include
file|"reggroups.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"frame-base.h"
end_include

begin_include
include|#
directive|include
file|"frame-unwind.h"
end_include

begin_include
include|#
directive|include
file|"doublest.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"gdb_assert.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"elf/common.h"
end_include

begin_comment
comment|/* for DT_PLTGOT value */
end_comment

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_include
include|#
directive|include
file|"elf.h"
end_include

begin_comment
comment|/* for PT_IA64_UNWIND value */
end_comment

begin_include
include|#
directive|include
file|"dis-asm.h"
end_include

begin_include
include|#
directive|include
file|"ia64-tdep.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LIBUNWIND_IA64_H
end_ifdef

begin_include
include|#
directive|include
file|"libunwind-frame.h"
end_include

begin_include
include|#
directive|include
file|"libunwind-ia64.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Hook for determining the global pointer when calling functions in    the inferior under AIX.  The initialization code in ia64-aix-nat.c    sets this hook to the address of a function which will find the    global pointer for a given address.          The generic code which uses the dynamic section in the inferior for    finding the global pointer is not of much use on AIX since the    values obtained from the inferior have not been relocated.  */
end_comment

begin_function_decl
name|CORE_ADDR
function_decl|(
modifier|*
name|native_find_global_pointer
function_decl|)
parameter_list|(
name|CORE_ADDR
parameter_list|)
init|=
literal|0
function_decl|;
end_function_decl

begin_comment
comment|/* An enumeration of the different IA-64 instruction types.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
name|instruction_type
block|{
name|A
block|,
comment|/* Integer ALU ;    I-unit or M-unit */
name|I
block|,
comment|/* Non-ALU integer; I-unit */
name|M
block|,
comment|/* Memory ;         M-unit */
name|F
block|,
comment|/* Floating-point ; F-unit */
name|B
block|,
comment|/* Branch ;         B-unit */
name|L
block|,
comment|/* Extended (L+X) ; I-unit */
name|X
block|,
comment|/* Extended (L+X) ; I-unit */
name|undefined
comment|/* undefined or reserved */
block|}
name|instruction_type
typedef|;
end_typedef

begin_comment
comment|/* We represent IA-64 PC addresses as the value of the instruction    pointer or'd with some bit combination in the low nibble which    represents the slot number in the bundle addressed by the    instruction pointer.  The problem is that the Linux kernel    multiplies its slot numbers (for exceptions) by one while the    disassembler multiplies its slot numbers by 6.  In addition, I've    heard it said that the simulator uses 1 as the multiplier.        I've fixed the disassembler so that the bytes_per_line field will    be the slot multiplier.  If bytes_per_line comes in as zero, it    is set to six (which is how it was set up initially). -- objdump    displays pretty disassembly dumps with this value.  For our purposes,    we'll set bytes_per_line to SLOT_MULTIPLIER. This is okay since we    never want to also display the raw bytes the way objdump does. */
end_comment

begin_define
define|#
directive|define
name|SLOT_MULTIPLIER
value|1
end_define

begin_comment
comment|/* Length in bytes of an instruction bundle */
end_comment

begin_define
define|#
directive|define
name|BUNDLE_LEN
value|16
end_define

begin_decl_stmt
specifier|static
name|gdbarch_init_ftype
name|ia64_gdbarch_init
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|gdbarch_register_name_ftype
name|ia64_register_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|gdbarch_register_type_ftype
name|ia64_register_type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|gdbarch_breakpoint_from_pc_ftype
name|ia64_breakpoint_from_pc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|gdbarch_skip_prologue_ftype
name|ia64_skip_prologue
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|gdbarch_extract_return_value_ftype
name|ia64_extract_return_value
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|gdbarch_use_struct_convention_ftype
name|ia64_use_struct_convention
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|struct
name|type
modifier|*
name|is_float_or_hfa_type
parameter_list|(
name|struct
name|type
modifier|*
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|builtin_type_ia64_ext
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NUM_IA64_RAW_REGS
value|462
end_define

begin_decl_stmt
specifier|static
name|int
name|sp_regnum
init|=
name|IA64_GR12_REGNUM
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fp_regnum
init|=
name|IA64_VFP_REGNUM
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|lr_regnum
init|=
name|IA64_VRAP_REGNUM
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* NOTE: we treat the register stack registers r32-r127 as pseudo-registers because    they may not be accessible via the ptrace register get/set interfaces.  */
end_comment

begin_enum
enum|enum
name|pseudo_regs
block|{
name|FIRST_PSEUDO_REGNUM
init|=
name|NUM_IA64_RAW_REGS
block|,
name|VBOF_REGNUM
init|=
name|IA64_NAT127_REGNUM
operator|+
literal|1
block|,
name|V32_REGNUM
block|,
name|V127_REGNUM
init|=
name|V32_REGNUM
operator|+
literal|95
block|,
name|VP0_REGNUM
block|,
name|VP16_REGNUM
init|=
name|VP0_REGNUM
operator|+
literal|16
block|,
name|VP63_REGNUM
init|=
name|VP0_REGNUM
operator|+
literal|63
block|,
name|LAST_PSEUDO_REGNUM
block|}
enum|;
end_enum

begin_comment
comment|/* Array of register names; There should be ia64_num_regs strings in    the initializer.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ia64_register_names
index|[]
init|=
block|{
literal|"r0"
block|,
literal|"r1"
block|,
literal|"r2"
block|,
literal|"r3"
block|,
literal|"r4"
block|,
literal|"r5"
block|,
literal|"r6"
block|,
literal|"r7"
block|,
literal|"r8"
block|,
literal|"r9"
block|,
literal|"r10"
block|,
literal|"r11"
block|,
literal|"r12"
block|,
literal|"r13"
block|,
literal|"r14"
block|,
literal|"r15"
block|,
literal|"r16"
block|,
literal|"r17"
block|,
literal|"r18"
block|,
literal|"r19"
block|,
literal|"r20"
block|,
literal|"r21"
block|,
literal|"r22"
block|,
literal|"r23"
block|,
literal|"r24"
block|,
literal|"r25"
block|,
literal|"r26"
block|,
literal|"r27"
block|,
literal|"r28"
block|,
literal|"r29"
block|,
literal|"r30"
block|,
literal|"r31"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|"f0"
block|,
literal|"f1"
block|,
literal|"f2"
block|,
literal|"f3"
block|,
literal|"f4"
block|,
literal|"f5"
block|,
literal|"f6"
block|,
literal|"f7"
block|,
literal|"f8"
block|,
literal|"f9"
block|,
literal|"f10"
block|,
literal|"f11"
block|,
literal|"f12"
block|,
literal|"f13"
block|,
literal|"f14"
block|,
literal|"f15"
block|,
literal|"f16"
block|,
literal|"f17"
block|,
literal|"f18"
block|,
literal|"f19"
block|,
literal|"f20"
block|,
literal|"f21"
block|,
literal|"f22"
block|,
literal|"f23"
block|,
literal|"f24"
block|,
literal|"f25"
block|,
literal|"f26"
block|,
literal|"f27"
block|,
literal|"f28"
block|,
literal|"f29"
block|,
literal|"f30"
block|,
literal|"f31"
block|,
literal|"f32"
block|,
literal|"f33"
block|,
literal|"f34"
block|,
literal|"f35"
block|,
literal|"f36"
block|,
literal|"f37"
block|,
literal|"f38"
block|,
literal|"f39"
block|,
literal|"f40"
block|,
literal|"f41"
block|,
literal|"f42"
block|,
literal|"f43"
block|,
literal|"f44"
block|,
literal|"f45"
block|,
literal|"f46"
block|,
literal|"f47"
block|,
literal|"f48"
block|,
literal|"f49"
block|,
literal|"f50"
block|,
literal|"f51"
block|,
literal|"f52"
block|,
literal|"f53"
block|,
literal|"f54"
block|,
literal|"f55"
block|,
literal|"f56"
block|,
literal|"f57"
block|,
literal|"f58"
block|,
literal|"f59"
block|,
literal|"f60"
block|,
literal|"f61"
block|,
literal|"f62"
block|,
literal|"f63"
block|,
literal|"f64"
block|,
literal|"f65"
block|,
literal|"f66"
block|,
literal|"f67"
block|,
literal|"f68"
block|,
literal|"f69"
block|,
literal|"f70"
block|,
literal|"f71"
block|,
literal|"f72"
block|,
literal|"f73"
block|,
literal|"f74"
block|,
literal|"f75"
block|,
literal|"f76"
block|,
literal|"f77"
block|,
literal|"f78"
block|,
literal|"f79"
block|,
literal|"f80"
block|,
literal|"f81"
block|,
literal|"f82"
block|,
literal|"f83"
block|,
literal|"f84"
block|,
literal|"f85"
block|,
literal|"f86"
block|,
literal|"f87"
block|,
literal|"f88"
block|,
literal|"f89"
block|,
literal|"f90"
block|,
literal|"f91"
block|,
literal|"f92"
block|,
literal|"f93"
block|,
literal|"f94"
block|,
literal|"f95"
block|,
literal|"f96"
block|,
literal|"f97"
block|,
literal|"f98"
block|,
literal|"f99"
block|,
literal|"f100"
block|,
literal|"f101"
block|,
literal|"f102"
block|,
literal|"f103"
block|,
literal|"f104"
block|,
literal|"f105"
block|,
literal|"f106"
block|,
literal|"f107"
block|,
literal|"f108"
block|,
literal|"f109"
block|,
literal|"f110"
block|,
literal|"f111"
block|,
literal|"f112"
block|,
literal|"f113"
block|,
literal|"f114"
block|,
literal|"f115"
block|,
literal|"f116"
block|,
literal|"f117"
block|,
literal|"f118"
block|,
literal|"f119"
block|,
literal|"f120"
block|,
literal|"f121"
block|,
literal|"f122"
block|,
literal|"f123"
block|,
literal|"f124"
block|,
literal|"f125"
block|,
literal|"f126"
block|,
literal|"f127"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|"b0"
block|,
literal|"b1"
block|,
literal|"b2"
block|,
literal|"b3"
block|,
literal|"b4"
block|,
literal|"b5"
block|,
literal|"b6"
block|,
literal|"b7"
block|,
literal|"vfp"
block|,
literal|"vrap"
block|,
literal|"pr"
block|,
literal|"ip"
block|,
literal|"psr"
block|,
literal|"cfm"
block|,
literal|"kr0"
block|,
literal|"kr1"
block|,
literal|"kr2"
block|,
literal|"kr3"
block|,
literal|"kr4"
block|,
literal|"kr5"
block|,
literal|"kr6"
block|,
literal|"kr7"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|"rsc"
block|,
literal|"bsp"
block|,
literal|"bspstore"
block|,
literal|"rnat"
block|,
literal|""
block|,
literal|"fcr"
block|,
literal|""
block|,
literal|""
block|,
literal|"eflag"
block|,
literal|"csd"
block|,
literal|"ssd"
block|,
literal|"cflg"
block|,
literal|"fsr"
block|,
literal|"fir"
block|,
literal|"fdr"
block|,
literal|""
block|,
literal|"ccv"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|"unat"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|"fpsr"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|"itc"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|"pfs"
block|,
literal|"lc"
block|,
literal|"ec"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|"nat0"
block|,
literal|"nat1"
block|,
literal|"nat2"
block|,
literal|"nat3"
block|,
literal|"nat4"
block|,
literal|"nat5"
block|,
literal|"nat6"
block|,
literal|"nat7"
block|,
literal|"nat8"
block|,
literal|"nat9"
block|,
literal|"nat10"
block|,
literal|"nat11"
block|,
literal|"nat12"
block|,
literal|"nat13"
block|,
literal|"nat14"
block|,
literal|"nat15"
block|,
literal|"nat16"
block|,
literal|"nat17"
block|,
literal|"nat18"
block|,
literal|"nat19"
block|,
literal|"nat20"
block|,
literal|"nat21"
block|,
literal|"nat22"
block|,
literal|"nat23"
block|,
literal|"nat24"
block|,
literal|"nat25"
block|,
literal|"nat26"
block|,
literal|"nat27"
block|,
literal|"nat28"
block|,
literal|"nat29"
block|,
literal|"nat30"
block|,
literal|"nat31"
block|,
literal|"nat32"
block|,
literal|"nat33"
block|,
literal|"nat34"
block|,
literal|"nat35"
block|,
literal|"nat36"
block|,
literal|"nat37"
block|,
literal|"nat38"
block|,
literal|"nat39"
block|,
literal|"nat40"
block|,
literal|"nat41"
block|,
literal|"nat42"
block|,
literal|"nat43"
block|,
literal|"nat44"
block|,
literal|"nat45"
block|,
literal|"nat46"
block|,
literal|"nat47"
block|,
literal|"nat48"
block|,
literal|"nat49"
block|,
literal|"nat50"
block|,
literal|"nat51"
block|,
literal|"nat52"
block|,
literal|"nat53"
block|,
literal|"nat54"
block|,
literal|"nat55"
block|,
literal|"nat56"
block|,
literal|"nat57"
block|,
literal|"nat58"
block|,
literal|"nat59"
block|,
literal|"nat60"
block|,
literal|"nat61"
block|,
literal|"nat62"
block|,
literal|"nat63"
block|,
literal|"nat64"
block|,
literal|"nat65"
block|,
literal|"nat66"
block|,
literal|"nat67"
block|,
literal|"nat68"
block|,
literal|"nat69"
block|,
literal|"nat70"
block|,
literal|"nat71"
block|,
literal|"nat72"
block|,
literal|"nat73"
block|,
literal|"nat74"
block|,
literal|"nat75"
block|,
literal|"nat76"
block|,
literal|"nat77"
block|,
literal|"nat78"
block|,
literal|"nat79"
block|,
literal|"nat80"
block|,
literal|"nat81"
block|,
literal|"nat82"
block|,
literal|"nat83"
block|,
literal|"nat84"
block|,
literal|"nat85"
block|,
literal|"nat86"
block|,
literal|"nat87"
block|,
literal|"nat88"
block|,
literal|"nat89"
block|,
literal|"nat90"
block|,
literal|"nat91"
block|,
literal|"nat92"
block|,
literal|"nat93"
block|,
literal|"nat94"
block|,
literal|"nat95"
block|,
literal|"nat96"
block|,
literal|"nat97"
block|,
literal|"nat98"
block|,
literal|"nat99"
block|,
literal|"nat100"
block|,
literal|"nat101"
block|,
literal|"nat102"
block|,
literal|"nat103"
block|,
literal|"nat104"
block|,
literal|"nat105"
block|,
literal|"nat106"
block|,
literal|"nat107"
block|,
literal|"nat108"
block|,
literal|"nat109"
block|,
literal|"nat110"
block|,
literal|"nat111"
block|,
literal|"nat112"
block|,
literal|"nat113"
block|,
literal|"nat114"
block|,
literal|"nat115"
block|,
literal|"nat116"
block|,
literal|"nat117"
block|,
literal|"nat118"
block|,
literal|"nat119"
block|,
literal|"nat120"
block|,
literal|"nat121"
block|,
literal|"nat122"
block|,
literal|"nat123"
block|,
literal|"nat124"
block|,
literal|"nat125"
block|,
literal|"nat126"
block|,
literal|"nat127"
block|,
literal|"bof"
block|,
literal|"r32"
block|,
literal|"r33"
block|,
literal|"r34"
block|,
literal|"r35"
block|,
literal|"r36"
block|,
literal|"r37"
block|,
literal|"r38"
block|,
literal|"r39"
block|,
literal|"r40"
block|,
literal|"r41"
block|,
literal|"r42"
block|,
literal|"r43"
block|,
literal|"r44"
block|,
literal|"r45"
block|,
literal|"r46"
block|,
literal|"r47"
block|,
literal|"r48"
block|,
literal|"r49"
block|,
literal|"r50"
block|,
literal|"r51"
block|,
literal|"r52"
block|,
literal|"r53"
block|,
literal|"r54"
block|,
literal|"r55"
block|,
literal|"r56"
block|,
literal|"r57"
block|,
literal|"r58"
block|,
literal|"r59"
block|,
literal|"r60"
block|,
literal|"r61"
block|,
literal|"r62"
block|,
literal|"r63"
block|,
literal|"r64"
block|,
literal|"r65"
block|,
literal|"r66"
block|,
literal|"r67"
block|,
literal|"r68"
block|,
literal|"r69"
block|,
literal|"r70"
block|,
literal|"r71"
block|,
literal|"r72"
block|,
literal|"r73"
block|,
literal|"r74"
block|,
literal|"r75"
block|,
literal|"r76"
block|,
literal|"r77"
block|,
literal|"r78"
block|,
literal|"r79"
block|,
literal|"r80"
block|,
literal|"r81"
block|,
literal|"r82"
block|,
literal|"r83"
block|,
literal|"r84"
block|,
literal|"r85"
block|,
literal|"r86"
block|,
literal|"r87"
block|,
literal|"r88"
block|,
literal|"r89"
block|,
literal|"r90"
block|,
literal|"r91"
block|,
literal|"r92"
block|,
literal|"r93"
block|,
literal|"r94"
block|,
literal|"r95"
block|,
literal|"r96"
block|,
literal|"r97"
block|,
literal|"r98"
block|,
literal|"r99"
block|,
literal|"r100"
block|,
literal|"r101"
block|,
literal|"r102"
block|,
literal|"r103"
block|,
literal|"r104"
block|,
literal|"r105"
block|,
literal|"r106"
block|,
literal|"r107"
block|,
literal|"r108"
block|,
literal|"r109"
block|,
literal|"r110"
block|,
literal|"r111"
block|,
literal|"r112"
block|,
literal|"r113"
block|,
literal|"r114"
block|,
literal|"r115"
block|,
literal|"r116"
block|,
literal|"r117"
block|,
literal|"r118"
block|,
literal|"r119"
block|,
literal|"r120"
block|,
literal|"r121"
block|,
literal|"r122"
block|,
literal|"r123"
block|,
literal|"r124"
block|,
literal|"r125"
block|,
literal|"r126"
block|,
literal|"r127"
block|,
literal|"p0"
block|,
literal|"p1"
block|,
literal|"p2"
block|,
literal|"p3"
block|,
literal|"p4"
block|,
literal|"p5"
block|,
literal|"p6"
block|,
literal|"p7"
block|,
literal|"p8"
block|,
literal|"p9"
block|,
literal|"p10"
block|,
literal|"p11"
block|,
literal|"p12"
block|,
literal|"p13"
block|,
literal|"p14"
block|,
literal|"p15"
block|,
literal|"p16"
block|,
literal|"p17"
block|,
literal|"p18"
block|,
literal|"p19"
block|,
literal|"p20"
block|,
literal|"p21"
block|,
literal|"p22"
block|,
literal|"p23"
block|,
literal|"p24"
block|,
literal|"p25"
block|,
literal|"p26"
block|,
literal|"p27"
block|,
literal|"p28"
block|,
literal|"p29"
block|,
literal|"p30"
block|,
literal|"p31"
block|,
literal|"p32"
block|,
literal|"p33"
block|,
literal|"p34"
block|,
literal|"p35"
block|,
literal|"p36"
block|,
literal|"p37"
block|,
literal|"p38"
block|,
literal|"p39"
block|,
literal|"p40"
block|,
literal|"p41"
block|,
literal|"p42"
block|,
literal|"p43"
block|,
literal|"p44"
block|,
literal|"p45"
block|,
literal|"p46"
block|,
literal|"p47"
block|,
literal|"p48"
block|,
literal|"p49"
block|,
literal|"p50"
block|,
literal|"p51"
block|,
literal|"p52"
block|,
literal|"p53"
block|,
literal|"p54"
block|,
literal|"p55"
block|,
literal|"p56"
block|,
literal|"p57"
block|,
literal|"p58"
block|,
literal|"p59"
block|,
literal|"p60"
block|,
literal|"p61"
block|,
literal|"p62"
block|,
literal|"p63"
block|, }
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|ia64_frame_cache
block|{
name|CORE_ADDR
name|base
decl_stmt|;
comment|/* frame pointer base for frame */
name|CORE_ADDR
name|pc
decl_stmt|;
comment|/* function start pc for frame */
name|CORE_ADDR
name|saved_sp
decl_stmt|;
comment|/* stack pointer for frame */
name|CORE_ADDR
name|bsp
decl_stmt|;
comment|/* points at r32 for the current frame */
name|CORE_ADDR
name|cfm
decl_stmt|;
comment|/* cfm value for current frame */
name|CORE_ADDR
name|prev_cfm
decl_stmt|;
comment|/* cfm value for previous frame */
name|int
name|frameless
decl_stmt|;
name|int
name|sof
decl_stmt|;
comment|/* Size of frame  (decoded from cfm value) */
name|int
name|sol
decl_stmt|;
comment|/* Size of locals (decoded from cfm value) */
name|int
name|sor
decl_stmt|;
comment|/* Number of rotating registers. (decoded from cfm value) */
name|CORE_ADDR
name|after_prologue
decl_stmt|;
comment|/* Address of first instruction after the last      prologue instruction;  Note that there may      be instructions from the function's body      intermingled with the prologue. */
name|int
name|mem_stack_frame_size
decl_stmt|;
comment|/* Size of the memory stack frame (may be zero),      or -1 if it has not been determined yet. */
name|int
name|fp_reg
decl_stmt|;
comment|/* Register number (if any) used a frame pointer 			   for this frame.  0 if no register is being used 			   as the frame pointer. */
comment|/* Saved registers.  */
name|CORE_ADDR
name|saved_regs
index|[
name|NUM_IA64_RAW_REGS
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|gdbarch_tdep
block|{
name|CORE_ADDR
function_decl|(
modifier|*
name|sigcontext_register_address
function_decl|)
parameter_list|(
name|CORE_ADDR
parameter_list|,
name|int
parameter_list|)
function_decl|;
comment|/* OS specific function which, given a frame address 			   and register number, returns the offset to the 			   given register from the start of the frame. */
name|CORE_ADDR
function_decl|(
modifier|*
name|find_global_pointer
function_decl|)
parameter_list|(
name|CORE_ADDR
parameter_list|)
function_decl|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|SIGCONTEXT_REGISTER_ADDRESS
define|\
value|(gdbarch_tdep (current_gdbarch)->sigcontext_register_address)
end_define

begin_define
define|#
directive|define
name|FIND_GLOBAL_POINTER
define|\
value|(gdbarch_tdep (current_gdbarch)->find_global_pointer)
end_define

begin_function
name|int
name|ia64_register_reggroup_p
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|int
name|regnum
parameter_list|,
name|struct
name|reggroup
modifier|*
name|group
parameter_list|)
block|{
name|int
name|vector_p
decl_stmt|;
name|int
name|float_p
decl_stmt|;
name|int
name|raw_p
decl_stmt|;
if|if
condition|(
name|group
operator|==
name|all_reggroup
condition|)
return|return
literal|1
return|;
name|vector_p
operator|=
name|TYPE_VECTOR
argument_list|(
name|register_type
argument_list|(
name|gdbarch
argument_list|,
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
name|float_p
operator|=
name|TYPE_CODE
argument_list|(
name|register_type
argument_list|(
name|gdbarch
argument_list|,
name|regnum
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_FLT
expr_stmt|;
name|raw_p
operator|=
name|regnum
operator|<
name|NUM_IA64_RAW_REGS
expr_stmt|;
if|if
condition|(
name|group
operator|==
name|float_reggroup
condition|)
return|return
name|float_p
return|;
if|if
condition|(
name|group
operator|==
name|vector_reggroup
condition|)
return|return
name|vector_p
return|;
if|if
condition|(
name|group
operator|==
name|general_reggroup
condition|)
return|return
operator|(
operator|!
name|vector_p
operator|&&
operator|!
name|float_p
operator|)
return|;
if|if
condition|(
name|group
operator|==
name|save_reggroup
operator|||
name|group
operator|==
name|restore_reggroup
condition|)
return|return
name|raw_p
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|ia64_register_name
parameter_list|(
name|int
name|reg
parameter_list|)
block|{
return|return
name|ia64_register_names
index|[
name|reg
index|]
return|;
block|}
end_function

begin_function
name|struct
name|type
modifier|*
name|ia64_register_type
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|arch
parameter_list|,
name|int
name|reg
parameter_list|)
block|{
if|if
condition|(
name|reg
operator|>=
name|IA64_FR0_REGNUM
operator|&&
name|reg
operator|<=
name|IA64_FR127_REGNUM
condition|)
return|return
name|builtin_type_ia64_ext
return|;
else|else
return|return
name|builtin_type_long
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ia64_dwarf_reg_to_regnum
parameter_list|(
name|int
name|reg
parameter_list|)
block|{
if|if
condition|(
name|reg
operator|>=
name|IA64_GR32_REGNUM
operator|&&
name|reg
operator|<=
name|IA64_GR127_REGNUM
condition|)
return|return
name|V32_REGNUM
operator|+
operator|(
name|reg
operator|-
name|IA64_GR32_REGNUM
operator|)
return|;
return|return
name|reg
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|floatformat_valid
parameter_list|(
specifier|const
name|struct
name|floatformat
modifier|*
name|fmt
parameter_list|,
specifier|const
name|char
modifier|*
name|from
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
end_function

begin_decl_stmt
specifier|const
name|struct
name|floatformat
name|floatformat_ia64_ext
init|=
block|{
name|floatformat_little
block|,
literal|82
block|,
literal|0
block|,
literal|1
block|,
literal|17
block|,
literal|65535
block|,
literal|0x1ffff
block|,
literal|18
block|,
literal|64
block|,
name|floatformat_intbit_yes
block|,
literal|"floatformat_ia64_ext"
block|,
name|floatformat_valid
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Extract ``len'' bits from an instruction bundle starting at    bit ``from''.  */
end_comment

begin_function
specifier|static
name|long
name|long
name|extract_bit_field
parameter_list|(
name|char
modifier|*
name|bundle
parameter_list|,
name|int
name|from
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|long
name|long
name|result
init|=
literal|0LL
decl_stmt|;
name|int
name|to
init|=
name|from
operator|+
name|len
decl_stmt|;
name|int
name|from_byte
init|=
name|from
operator|/
literal|8
decl_stmt|;
name|int
name|to_byte
init|=
name|to
operator|/
literal|8
decl_stmt|;
name|unsigned
name|char
modifier|*
name|b
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|bundle
decl_stmt|;
name|unsigned
name|char
name|c
decl_stmt|;
name|int
name|lshift
decl_stmt|;
name|int
name|i
decl_stmt|;
name|c
operator|=
name|b
index|[
name|from_byte
index|]
expr_stmt|;
if|if
condition|(
name|from_byte
operator|==
name|to_byte
condition|)
name|c
operator|=
operator|(
call|(
name|unsigned
name|char
call|)
argument_list|(
name|c
operator|<<
operator|(
literal|8
operator|-
name|to
operator|%
literal|8
operator|)
argument_list|)
operator|)
operator|>>
operator|(
literal|8
operator|-
name|to
operator|%
literal|8
operator|)
expr_stmt|;
name|result
operator|=
name|c
operator|>>
operator|(
name|from
operator|%
literal|8
operator|)
expr_stmt|;
name|lshift
operator|=
literal|8
operator|-
operator|(
name|from
operator|%
literal|8
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|from_byte
operator|+
literal|1
init|;
name|i
operator|<
name|to_byte
condition|;
name|i
operator|++
control|)
block|{
name|result
operator||=
operator|(
operator|(
name|long
name|long
operator|)
name|b
index|[
name|i
index|]
operator|)
operator|<<
name|lshift
expr_stmt|;
name|lshift
operator|+=
literal|8
expr_stmt|;
block|}
if|if
condition|(
name|from_byte
operator|<
name|to_byte
operator|&&
operator|(
name|to
operator|%
literal|8
operator|!=
literal|0
operator|)
condition|)
block|{
name|c
operator|=
name|b
index|[
name|to_byte
index|]
expr_stmt|;
name|c
operator|=
operator|(
call|(
name|unsigned
name|char
call|)
argument_list|(
name|c
operator|<<
operator|(
literal|8
operator|-
name|to
operator|%
literal|8
operator|)
argument_list|)
operator|)
operator|>>
operator|(
literal|8
operator|-
name|to
operator|%
literal|8
operator|)
expr_stmt|;
name|result
operator||=
operator|(
operator|(
name|long
name|long
operator|)
name|c
operator|)
operator|<<
name|lshift
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Replace the specified bits in an instruction bundle */
end_comment

begin_function
specifier|static
name|void
name|replace_bit_field
parameter_list|(
name|char
modifier|*
name|bundle
parameter_list|,
name|long
name|long
name|val
parameter_list|,
name|int
name|from
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|to
init|=
name|from
operator|+
name|len
decl_stmt|;
name|int
name|from_byte
init|=
name|from
operator|/
literal|8
decl_stmt|;
name|int
name|to_byte
init|=
name|to
operator|/
literal|8
decl_stmt|;
name|unsigned
name|char
modifier|*
name|b
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|bundle
decl_stmt|;
name|unsigned
name|char
name|c
decl_stmt|;
if|if
condition|(
name|from_byte
operator|==
name|to_byte
condition|)
block|{
name|unsigned
name|char
name|left
decl_stmt|,
name|right
decl_stmt|;
name|c
operator|=
name|b
index|[
name|from_byte
index|]
expr_stmt|;
name|left
operator|=
operator|(
name|c
operator|>>
operator|(
name|to
operator|%
literal|8
operator|)
operator|)
operator|<<
operator|(
name|to
operator|%
literal|8
operator|)
expr_stmt|;
name|right
operator|=
operator|(
call|(
name|unsigned
name|char
call|)
argument_list|(
name|c
operator|<<
operator|(
literal|8
operator|-
name|from
operator|%
literal|8
operator|)
argument_list|)
operator|)
operator|>>
operator|(
literal|8
operator|-
name|from
operator|%
literal|8
operator|)
expr_stmt|;
name|c
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|val
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|c
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|c
operator|<<
operator|(
name|from
operator|%
literal|8
operator|+
literal|8
operator|-
name|to
operator|%
literal|8
operator|)
argument_list|)
operator|>>
operator|(
literal|8
operator|-
name|to
operator|%
literal|8
operator|)
expr_stmt|;
name|c
operator||=
name|right
operator||
name|left
expr_stmt|;
name|b
index|[
name|from_byte
index|]
operator|=
name|c
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
name|c
operator|=
name|b
index|[
name|from_byte
index|]
expr_stmt|;
name|c
operator|=
operator|(
call|(
name|unsigned
name|char
call|)
argument_list|(
name|c
operator|<<
operator|(
literal|8
operator|-
name|from
operator|%
literal|8
operator|)
argument_list|)
operator|)
operator|>>
operator|(
literal|8
operator|-
name|from
operator|%
literal|8
operator|)
expr_stmt|;
name|c
operator|=
name|c
operator||
operator|(
name|val
operator|<<
operator|(
name|from
operator|%
literal|8
operator|)
operator|)
expr_stmt|;
name|b
index|[
name|from_byte
index|]
operator|=
name|c
expr_stmt|;
name|val
operator|>>=
literal|8
operator|-
name|from
operator|%
literal|8
expr_stmt|;
for|for
control|(
name|i
operator|=
name|from_byte
operator|+
literal|1
init|;
name|i
operator|<
name|to_byte
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
name|val
operator|&
literal|0xff
expr_stmt|;
name|val
operator|>>=
literal|8
expr_stmt|;
name|b
index|[
name|i
index|]
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
name|to
operator|%
literal|8
operator|!=
literal|0
condition|)
block|{
name|unsigned
name|char
name|cv
init|=
operator|(
name|unsigned
name|char
operator|)
name|val
decl_stmt|;
name|c
operator|=
name|b
index|[
name|to_byte
index|]
expr_stmt|;
name|c
operator|=
name|c
operator|>>
operator|(
name|to
operator|%
literal|8
operator|)
operator|<<
operator|(
name|to
operator|%
literal|8
operator|)
expr_stmt|;
name|c
operator||=
operator|(
call|(
name|unsigned
name|char
call|)
argument_list|(
name|cv
operator|<<
operator|(
literal|8
operator|-
name|to
operator|%
literal|8
operator|)
argument_list|)
operator|)
operator|>>
operator|(
literal|8
operator|-
name|to
operator|%
literal|8
operator|)
expr_stmt|;
name|b
index|[
name|to_byte
index|]
operator|=
name|c
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Return the contents of slot N (for N = 0, 1, or 2) in    and instruction bundle */
end_comment

begin_function
specifier|static
name|long
name|long
name|slotN_contents
parameter_list|(
name|char
modifier|*
name|bundle
parameter_list|,
name|int
name|slotnum
parameter_list|)
block|{
return|return
name|extract_bit_field
argument_list|(
name|bundle
argument_list|,
literal|5
operator|+
literal|41
operator|*
name|slotnum
argument_list|,
literal|41
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Store an instruction in an instruction bundle */
end_comment

begin_function
specifier|static
name|void
name|replace_slotN_contents
parameter_list|(
name|char
modifier|*
name|bundle
parameter_list|,
name|long
name|long
name|instr
parameter_list|,
name|int
name|slotnum
parameter_list|)
block|{
name|replace_bit_field
argument_list|(
name|bundle
argument_list|,
name|instr
argument_list|,
literal|5
operator|+
literal|41
operator|*
name|slotnum
argument_list|,
literal|41
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|enum
name|instruction_type
name|template_encoding_table
index|[
literal|32
index|]
index|[
literal|3
index|]
init|=
block|{
block|{
name|M
block|,
name|I
block|,
name|I
block|}
block|,
comment|/* 00 */
block|{
name|M
block|,
name|I
block|,
name|I
block|}
block|,
comment|/* 01 */
block|{
name|M
block|,
name|I
block|,
name|I
block|}
block|,
comment|/* 02 */
block|{
name|M
block|,
name|I
block|,
name|I
block|}
block|,
comment|/* 03 */
block|{
name|M
block|,
name|L
block|,
name|X
block|}
block|,
comment|/* 04 */
block|{
name|M
block|,
name|L
block|,
name|X
block|}
block|,
comment|/* 05 */
block|{
name|undefined
block|,
name|undefined
block|,
name|undefined
block|}
block|,
comment|/* 06 */
block|{
name|undefined
block|,
name|undefined
block|,
name|undefined
block|}
block|,
comment|/* 07 */
block|{
name|M
block|,
name|M
block|,
name|I
block|}
block|,
comment|/* 08 */
block|{
name|M
block|,
name|M
block|,
name|I
block|}
block|,
comment|/* 09 */
block|{
name|M
block|,
name|M
block|,
name|I
block|}
block|,
comment|/* 0A */
block|{
name|M
block|,
name|M
block|,
name|I
block|}
block|,
comment|/* 0B */
block|{
name|M
block|,
name|F
block|,
name|I
block|}
block|,
comment|/* 0C */
block|{
name|M
block|,
name|F
block|,
name|I
block|}
block|,
comment|/* 0D */
block|{
name|M
block|,
name|M
block|,
name|F
block|}
block|,
comment|/* 0E */
block|{
name|M
block|,
name|M
block|,
name|F
block|}
block|,
comment|/* 0F */
block|{
name|M
block|,
name|I
block|,
name|B
block|}
block|,
comment|/* 10 */
block|{
name|M
block|,
name|I
block|,
name|B
block|}
block|,
comment|/* 11 */
block|{
name|M
block|,
name|B
block|,
name|B
block|}
block|,
comment|/* 12 */
block|{
name|M
block|,
name|B
block|,
name|B
block|}
block|,
comment|/* 13 */
block|{
name|undefined
block|,
name|undefined
block|,
name|undefined
block|}
block|,
comment|/* 14 */
block|{
name|undefined
block|,
name|undefined
block|,
name|undefined
block|}
block|,
comment|/* 15 */
block|{
name|B
block|,
name|B
block|,
name|B
block|}
block|,
comment|/* 16 */
block|{
name|B
block|,
name|B
block|,
name|B
block|}
block|,
comment|/* 17 */
block|{
name|M
block|,
name|M
block|,
name|B
block|}
block|,
comment|/* 18 */
block|{
name|M
block|,
name|M
block|,
name|B
block|}
block|,
comment|/* 19 */
block|{
name|undefined
block|,
name|undefined
block|,
name|undefined
block|}
block|,
comment|/* 1A */
block|{
name|undefined
block|,
name|undefined
block|,
name|undefined
block|}
block|,
comment|/* 1B */
block|{
name|M
block|,
name|F
block|,
name|B
block|}
block|,
comment|/* 1C */
block|{
name|M
block|,
name|F
block|,
name|B
block|}
block|,
comment|/* 1D */
block|{
name|undefined
block|,
name|undefined
block|,
name|undefined
block|}
block|,
comment|/* 1E */
block|{
name|undefined
block|,
name|undefined
block|,
name|undefined
block|}
block|,
comment|/* 1F */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Fetch and (partially) decode an instruction at ADDR and return the    address of the next instruction to fetch.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|fetch_instruction
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|instruction_type
modifier|*
name|it
parameter_list|,
name|long
name|long
modifier|*
name|instr
parameter_list|)
block|{
name|char
name|bundle
index|[
name|BUNDLE_LEN
index|]
decl_stmt|;
name|int
name|slotnum
init|=
call|(
name|int
call|)
argument_list|(
name|addr
operator|&
literal|0x0f
argument_list|)
operator|/
name|SLOT_MULTIPLIER
decl_stmt|;
name|long
name|long
name|template
decl_stmt|;
name|int
name|val
decl_stmt|;
comment|/* Warn about slot numbers greater than 2.  We used to generate      an error here on the assumption that the user entered an invalid      address.  But, sometimes GDB itself requests an invalid address.      This can (easily) happen when execution stops in a function for      which there are no symbols.  The prologue scanner will attempt to      find the beginning of the function - if the nearest symbol      happens to not be aligned on a bundle boundary (16 bytes), the      resulting starting address will cause GDB to think that the slot      number is too large.       So we warn about it and set the slot number to zero.  It is      not necessarily a fatal condition, particularly if debugging      at the assembly language level.  */
if|if
condition|(
name|slotnum
operator|>
literal|2
condition|)
block|{
name|warning
argument_list|(
literal|"Can't fetch instructions for slot numbers greater than 2.\n"
literal|"Using slot 0 instead"
argument_list|)
expr_stmt|;
name|slotnum
operator|=
literal|0
expr_stmt|;
block|}
name|addr
operator|&=
operator|~
literal|0x0f
expr_stmt|;
name|val
operator|=
name|target_read_memory
argument_list|(
name|addr
argument_list|,
name|bundle
argument_list|,
name|BUNDLE_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
operator|*
name|instr
operator|=
name|slotN_contents
argument_list|(
name|bundle
argument_list|,
name|slotnum
argument_list|)
expr_stmt|;
name|template
operator|=
name|extract_bit_field
argument_list|(
name|bundle
argument_list|,
literal|0
argument_list|,
literal|5
argument_list|)
expr_stmt|;
operator|*
name|it
operator|=
name|template_encoding_table
index|[
operator|(
name|int
operator|)
name|template
index|]
index|[
name|slotnum
index|]
expr_stmt|;
if|if
condition|(
name|slotnum
operator|==
literal|2
operator|||
operator|(
name|slotnum
operator|==
literal|1
operator|&&
operator|*
name|it
operator|==
name|L
operator|)
condition|)
name|addr
operator|+=
literal|16
expr_stmt|;
else|else
name|addr
operator|+=
operator|(
name|slotnum
operator|+
literal|1
operator|)
operator|*
name|SLOT_MULTIPLIER
expr_stmt|;
return|return
name|addr
return|;
block|}
end_function

begin_comment
comment|/* There are 5 different break instructions (break.i, break.b,    break.m, break.f, and break.x), but they all have the same    encoding.  (The five bit template in the low five bits of the    instruction bundle distinguishes one from another.)        The runtime architecture manual specifies that break instructions    used for debugging purposes must have the upper two bits of the 21    bit immediate set to a 0 and a 1 respectively.  A breakpoint    instruction encodes the most significant bit of its 21 bit    immediate at bit 36 of the 41 bit instruction.  The penultimate msb    is at bit 25 which leads to the pattern below.          Originally, I had this set up to do, e.g, a "break.i 0x80000"  But    it turns out that 0x80000 was used as the syscall break in the early    simulators.  So I changed the pattern slightly to do "break.i 0x080001"    instead.  But that didn't work either (I later found out that this    pattern was used by the simulator that I was using.)  So I ended up    using the pattern seen below. */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_define
define|#
directive|define
name|IA64_BREAKPOINT
value|0x00002000040LL
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|IA64_BREAKPOINT
value|0x00003333300LL
end_define

begin_function
specifier|static
name|int
name|ia64_memory_insert_breakpoint
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|char
modifier|*
name|contents_cache
parameter_list|)
block|{
name|char
name|bundle
index|[
name|BUNDLE_LEN
index|]
decl_stmt|;
name|int
name|slotnum
init|=
call|(
name|int
call|)
argument_list|(
name|addr
operator|&
literal|0x0f
argument_list|)
operator|/
name|SLOT_MULTIPLIER
decl_stmt|;
name|long
name|long
name|instr
decl_stmt|;
name|int
name|val
decl_stmt|;
name|int
name|template
decl_stmt|;
if|if
condition|(
name|slotnum
operator|>
literal|2
condition|)
name|error
argument_list|(
literal|"Can't insert breakpoint for slot numbers greater than 2."
argument_list|)
expr_stmt|;
name|addr
operator|&=
operator|~
literal|0x0f
expr_stmt|;
name|val
operator|=
name|target_read_memory
argument_list|(
name|addr
argument_list|,
name|bundle
argument_list|,
name|BUNDLE_LEN
argument_list|)
expr_stmt|;
comment|/* Check for L type instruction in 2nd slot, if present then      bump up the slot number to the 3rd slot */
name|template
operator|=
name|extract_bit_field
argument_list|(
name|bundle
argument_list|,
literal|0
argument_list|,
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|slotnum
operator|==
literal|1
operator|&&
name|template_encoding_table
index|[
name|template
index|]
index|[
literal|1
index|]
operator|==
name|L
condition|)
block|{
name|slotnum
operator|=
literal|2
expr_stmt|;
block|}
name|instr
operator|=
name|slotN_contents
argument_list|(
name|bundle
argument_list|,
name|slotnum
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|contents_cache
argument_list|,
operator|&
name|instr
argument_list|,
sizeof|sizeof
argument_list|(
name|instr
argument_list|)
argument_list|)
expr_stmt|;
name|replace_slotN_contents
argument_list|(
name|bundle
argument_list|,
name|IA64_BREAKPOINT
argument_list|,
name|slotnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
name|target_write_memory
argument_list|(
name|addr
argument_list|,
name|bundle
argument_list|,
name|BUNDLE_LEN
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ia64_memory_remove_breakpoint
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|char
modifier|*
name|contents_cache
parameter_list|)
block|{
name|char
name|bundle
index|[
name|BUNDLE_LEN
index|]
decl_stmt|;
name|int
name|slotnum
init|=
operator|(
name|addr
operator|&
literal|0x0f
operator|)
operator|/
name|SLOT_MULTIPLIER
decl_stmt|;
name|long
name|long
name|instr
decl_stmt|;
name|int
name|val
decl_stmt|;
name|int
name|template
decl_stmt|;
name|addr
operator|&=
operator|~
literal|0x0f
expr_stmt|;
name|val
operator|=
name|target_read_memory
argument_list|(
name|addr
argument_list|,
name|bundle
argument_list|,
name|BUNDLE_LEN
argument_list|)
expr_stmt|;
comment|/* Check for L type instruction in 2nd slot, if present then      bump up the slot number to the 3rd slot */
name|template
operator|=
name|extract_bit_field
argument_list|(
name|bundle
argument_list|,
literal|0
argument_list|,
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|slotnum
operator|==
literal|1
operator|&&
name|template_encoding_table
index|[
name|template
index|]
index|[
literal|1
index|]
operator|==
name|L
condition|)
block|{
name|slotnum
operator|=
literal|2
expr_stmt|;
block|}
name|memcpy
argument_list|(
operator|&
name|instr
argument_list|,
name|contents_cache
argument_list|,
sizeof|sizeof
name|instr
argument_list|)
expr_stmt|;
name|replace_slotN_contents
argument_list|(
name|bundle
argument_list|,
name|instr
argument_list|,
name|slotnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
name|target_write_memory
argument_list|(
name|addr
argument_list|,
name|bundle
argument_list|,
name|BUNDLE_LEN
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* We don't really want to use this, but remote.c needs to call it in order    to figure out if Z-packets are supported or not.  Oh, well. */
end_comment

begin_function
specifier|const
name|unsigned
name|char
modifier|*
name|ia64_breakpoint_from_pc
parameter_list|(
name|CORE_ADDR
modifier|*
name|pcptr
parameter_list|,
name|int
modifier|*
name|lenptr
parameter_list|)
block|{
specifier|static
name|unsigned
name|char
name|breakpoint
index|[]
init|=
block|{
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
operator|*
name|lenptr
operator|=
sizeof|sizeof
argument_list|(
name|breakpoint
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|*pcptr&= ~0x0f;
endif|#
directive|endif
return|return
name|breakpoint
return|;
block|}
end_function

begin_function
specifier|static
name|CORE_ADDR
name|ia64_read_pc
parameter_list|(
name|ptid_t
name|ptid
parameter_list|)
block|{
name|CORE_ADDR
name|psr_value
init|=
name|read_register_pid
argument_list|(
name|IA64_PSR_REGNUM
argument_list|,
name|ptid
argument_list|)
decl_stmt|;
name|CORE_ADDR
name|pc_value
init|=
name|read_register_pid
argument_list|(
name|IA64_IP_REGNUM
argument_list|,
name|ptid
argument_list|)
decl_stmt|;
name|int
name|slot_num
init|=
operator|(
name|psr_value
operator|>>
literal|41
operator|)
operator|&
literal|3
decl_stmt|;
return|return
name|pc_value
operator||
operator|(
name|slot_num
operator|*
name|SLOT_MULTIPLIER
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ia64_write_pc
parameter_list|(
name|CORE_ADDR
name|new_pc
parameter_list|,
name|ptid_t
name|ptid
parameter_list|)
block|{
name|int
name|slot_num
init|=
call|(
name|int
call|)
argument_list|(
name|new_pc
operator|&
literal|0xf
argument_list|)
operator|/
name|SLOT_MULTIPLIER
decl_stmt|;
name|CORE_ADDR
name|psr_value
init|=
name|read_register_pid
argument_list|(
name|IA64_PSR_REGNUM
argument_list|,
name|ptid
argument_list|)
decl_stmt|;
name|psr_value
operator|&=
operator|~
operator|(
literal|3LL
operator|<<
literal|41
operator|)
expr_stmt|;
name|psr_value
operator||=
call|(
name|CORE_ADDR
call|)
argument_list|(
name|slot_num
operator|&
literal|0x3
argument_list|)
operator|<<
literal|41
expr_stmt|;
name|new_pc
operator|&=
operator|~
literal|0xfLL
expr_stmt|;
name|write_register_pid
argument_list|(
name|IA64_PSR_REGNUM
argument_list|,
name|psr_value
argument_list|,
name|ptid
argument_list|)
expr_stmt|;
name|write_register_pid
argument_list|(
name|IA64_IP_REGNUM
argument_list|,
name|new_pc
argument_list|,
name|ptid
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|IS_NaT_COLLECTION_ADDR
parameter_list|(
name|addr
parameter_list|)
value|((((addr)>> 3)& 0x3f) == 0x3f)
end_define

begin_comment
comment|/* Returns the address of the slot that's NSLOTS slots away from    the address ADDR. NSLOTS may be positive or negative. */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|rse_address_add
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|int
name|nslots
parameter_list|)
block|{
name|CORE_ADDR
name|new_addr
decl_stmt|;
name|int
name|mandatory_nat_slots
init|=
name|nslots
operator|/
literal|63
decl_stmt|;
name|int
name|direction
init|=
name|nslots
operator|<
literal|0
condition|?
operator|-
literal|1
else|:
literal|1
decl_stmt|;
name|new_addr
operator|=
name|addr
operator|+
literal|8
operator|*
operator|(
name|nslots
operator|+
name|mandatory_nat_slots
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|new_addr
operator|>>
literal|9
operator|)
operator|!=
operator|(
operator|(
name|addr
operator|+
literal|8
operator|*
literal|64
operator|*
name|mandatory_nat_slots
operator|)
operator|>>
literal|9
operator|)
condition|)
name|new_addr
operator|+=
literal|8
operator|*
name|direction
expr_stmt|;
if|if
condition|(
name|IS_NaT_COLLECTION_ADDR
argument_list|(
name|new_addr
argument_list|)
condition|)
name|new_addr
operator|+=
literal|8
operator|*
name|direction
expr_stmt|;
return|return
name|new_addr
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ia64_pseudo_register_read
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|int
name|regnum
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|)
block|{
if|if
condition|(
name|regnum
operator|>=
name|V32_REGNUM
operator|&&
name|regnum
operator|<=
name|V127_REGNUM
condition|)
block|{
name|ULONGEST
name|bsp
decl_stmt|;
name|ULONGEST
name|cfm
decl_stmt|;
name|CORE_ADDR
name|reg
decl_stmt|;
name|regcache_cooked_read_unsigned
argument_list|(
name|regcache
argument_list|,
name|IA64_BSP_REGNUM
argument_list|,
operator|&
name|bsp
argument_list|)
expr_stmt|;
name|regcache_cooked_read_unsigned
argument_list|(
name|regcache
argument_list|,
name|IA64_CFM_REGNUM
argument_list|,
operator|&
name|cfm
argument_list|)
expr_stmt|;
comment|/* The bsp points at the end of the register frame so we 	 subtract the size of frame from it to get start of register frame.  */
name|bsp
operator|=
name|rse_address_add
argument_list|(
name|bsp
argument_list|,
operator|-
operator|(
name|cfm
operator|&
literal|0x7f
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cfm
operator|&
literal|0x7f
operator|)
operator|>
name|regnum
operator|-
name|V32_REGNUM
condition|)
block|{
name|ULONGEST
name|reg_addr
init|=
name|rse_address_add
argument_list|(
name|bsp
argument_list|,
operator|(
name|regnum
operator|-
name|V32_REGNUM
operator|)
argument_list|)
decl_stmt|;
name|reg
operator|=
name|read_memory_integer
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|reg_addr
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|store_unsigned_integer
argument_list|(
name|buf
argument_list|,
name|register_size
argument_list|(
name|current_gdbarch
argument_list|,
name|regnum
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
else|else
name|store_unsigned_integer
argument_list|(
name|buf
argument_list|,
name|register_size
argument_list|(
name|current_gdbarch
argument_list|,
name|regnum
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IA64_NAT0_REGNUM
operator|<=
name|regnum
operator|&&
name|regnum
operator|<=
name|IA64_NAT31_REGNUM
condition|)
block|{
name|ULONGEST
name|unatN_val
decl_stmt|;
name|ULONGEST
name|unat
decl_stmt|;
name|regcache_cooked_read_unsigned
argument_list|(
name|regcache
argument_list|,
name|IA64_UNAT_REGNUM
argument_list|,
operator|&
name|unat
argument_list|)
expr_stmt|;
name|unatN_val
operator|=
operator|(
name|unat
operator|&
operator|(
literal|1LL
operator|<<
operator|(
name|regnum
operator|-
name|IA64_NAT0_REGNUM
operator|)
operator|)
operator|)
operator|!=
literal|0
expr_stmt|;
name|store_unsigned_integer
argument_list|(
name|buf
argument_list|,
name|register_size
argument_list|(
name|current_gdbarch
argument_list|,
name|regnum
argument_list|)
argument_list|,
name|unatN_val
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IA64_NAT32_REGNUM
operator|<=
name|regnum
operator|&&
name|regnum
operator|<=
name|IA64_NAT127_REGNUM
condition|)
block|{
name|ULONGEST
name|natN_val
init|=
literal|0
decl_stmt|;
name|ULONGEST
name|bsp
decl_stmt|;
name|ULONGEST
name|cfm
decl_stmt|;
name|CORE_ADDR
name|gr_addr
init|=
literal|0
decl_stmt|;
name|regcache_cooked_read_unsigned
argument_list|(
name|regcache
argument_list|,
name|IA64_BSP_REGNUM
argument_list|,
operator|&
name|bsp
argument_list|)
expr_stmt|;
name|regcache_cooked_read_unsigned
argument_list|(
name|regcache
argument_list|,
name|IA64_CFM_REGNUM
argument_list|,
operator|&
name|cfm
argument_list|)
expr_stmt|;
comment|/* The bsp points at the end of the register frame so we 	 subtract the size of frame from it to get start of register frame.  */
name|bsp
operator|=
name|rse_address_add
argument_list|(
name|bsp
argument_list|,
operator|-
operator|(
name|cfm
operator|&
literal|0x7f
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cfm
operator|&
literal|0x7f
operator|)
operator|>
name|regnum
operator|-
name|V32_REGNUM
condition|)
name|gr_addr
operator|=
name|rse_address_add
argument_list|(
name|bsp
argument_list|,
operator|(
name|regnum
operator|-
name|V32_REGNUM
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|gr_addr
operator|!=
literal|0
condition|)
block|{
comment|/* Compute address of nat collection bits.  */
name|CORE_ADDR
name|nat_addr
init|=
name|gr_addr
operator||
literal|0x1f8
decl_stmt|;
name|CORE_ADDR
name|nat_collection
decl_stmt|;
name|int
name|nat_bit
decl_stmt|;
comment|/* If our nat collection address is bigger than bsp, we have to get 	     the nat collection from rnat.  Otherwise, we fetch the nat 	     collection from the computed address.  */
if|if
condition|(
name|nat_addr
operator|>=
name|bsp
condition|)
name|regcache_cooked_read_unsigned
argument_list|(
name|regcache
argument_list|,
name|IA64_RNAT_REGNUM
argument_list|,
operator|&
name|nat_collection
argument_list|)
expr_stmt|;
else|else
name|nat_collection
operator|=
name|read_memory_integer
argument_list|(
name|nat_addr
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|nat_bit
operator|=
operator|(
name|gr_addr
operator|>>
literal|3
operator|)
operator|&
literal|0x3f
expr_stmt|;
name|natN_val
operator|=
operator|(
name|nat_collection
operator|>>
name|nat_bit
operator|)
operator|&
literal|1
expr_stmt|;
block|}
name|store_unsigned_integer
argument_list|(
name|buf
argument_list|,
name|register_size
argument_list|(
name|current_gdbarch
argument_list|,
name|regnum
argument_list|)
argument_list|,
name|natN_val
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|regnum
operator|==
name|VBOF_REGNUM
condition|)
block|{
comment|/* A virtual register frame start is provided for user convenience.          It can be calculated as the bsp - sof (sizeof frame). */
name|ULONGEST
name|bsp
decl_stmt|,
name|vbsp
decl_stmt|;
name|ULONGEST
name|cfm
decl_stmt|;
name|CORE_ADDR
name|reg
decl_stmt|;
name|regcache_cooked_read_unsigned
argument_list|(
name|regcache
argument_list|,
name|IA64_BSP_REGNUM
argument_list|,
operator|&
name|bsp
argument_list|)
expr_stmt|;
name|regcache_cooked_read_unsigned
argument_list|(
name|regcache
argument_list|,
name|IA64_CFM_REGNUM
argument_list|,
operator|&
name|cfm
argument_list|)
expr_stmt|;
comment|/* The bsp points at the end of the register frame so we 	 subtract the size of frame from it to get beginning of frame.  */
name|vbsp
operator|=
name|rse_address_add
argument_list|(
name|bsp
argument_list|,
operator|-
operator|(
name|cfm
operator|&
literal|0x7f
operator|)
argument_list|)
expr_stmt|;
name|store_unsigned_integer
argument_list|(
name|buf
argument_list|,
name|register_size
argument_list|(
name|current_gdbarch
argument_list|,
name|regnum
argument_list|)
argument_list|,
name|vbsp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|VP0_REGNUM
operator|<=
name|regnum
operator|&&
name|regnum
operator|<=
name|VP63_REGNUM
condition|)
block|{
name|ULONGEST
name|pr
decl_stmt|;
name|ULONGEST
name|cfm
decl_stmt|;
name|ULONGEST
name|prN_val
decl_stmt|;
name|CORE_ADDR
name|reg
decl_stmt|;
name|regcache_cooked_read_unsigned
argument_list|(
name|regcache
argument_list|,
name|IA64_PR_REGNUM
argument_list|,
operator|&
name|pr
argument_list|)
expr_stmt|;
name|regcache_cooked_read_unsigned
argument_list|(
name|regcache
argument_list|,
name|IA64_CFM_REGNUM
argument_list|,
operator|&
name|cfm
argument_list|)
expr_stmt|;
if|if
condition|(
name|VP16_REGNUM
operator|<=
name|regnum
operator|&&
name|regnum
operator|<=
name|VP63_REGNUM
condition|)
block|{
comment|/* Fetch predicate register rename base from current frame 	     marker for this frame. */
name|int
name|rrb_pr
init|=
operator|(
name|cfm
operator|>>
literal|32
operator|)
operator|&
literal|0x3f
decl_stmt|;
comment|/* Adjust the register number to account for register rotation. */
name|regnum
operator|=
name|VP16_REGNUM
operator|+
operator|(
operator|(
name|regnum
operator|-
name|VP16_REGNUM
operator|)
operator|+
name|rrb_pr
operator|)
operator|%
literal|48
expr_stmt|;
block|}
name|prN_val
operator|=
operator|(
name|pr
operator|&
operator|(
literal|1LL
operator|<<
operator|(
name|regnum
operator|-
name|VP0_REGNUM
operator|)
operator|)
operator|)
operator|!=
literal|0
expr_stmt|;
name|store_unsigned_integer
argument_list|(
name|buf
argument_list|,
name|register_size
argument_list|(
name|current_gdbarch
argument_list|,
name|regnum
argument_list|)
argument_list|,
name|prN_val
argument_list|)
expr_stmt|;
block|}
else|else
name|memset
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|register_size
argument_list|(
name|current_gdbarch
argument_list|,
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ia64_pseudo_register_write
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|int
name|regnum
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|)
block|{
if|if
condition|(
name|regnum
operator|>=
name|V32_REGNUM
operator|&&
name|regnum
operator|<=
name|V127_REGNUM
condition|)
block|{
name|ULONGEST
name|bsp
decl_stmt|;
name|ULONGEST
name|cfm
decl_stmt|;
name|CORE_ADDR
name|reg
decl_stmt|;
name|regcache_cooked_read_unsigned
argument_list|(
name|regcache
argument_list|,
name|IA64_BSP_REGNUM
argument_list|,
operator|&
name|bsp
argument_list|)
expr_stmt|;
name|regcache_cooked_read_unsigned
argument_list|(
name|regcache
argument_list|,
name|IA64_CFM_REGNUM
argument_list|,
operator|&
name|cfm
argument_list|)
expr_stmt|;
name|bsp
operator|=
name|rse_address_add
argument_list|(
name|bsp
argument_list|,
operator|-
operator|(
name|cfm
operator|&
literal|0x7f
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cfm
operator|&
literal|0x7f
operator|)
operator|>
name|regnum
operator|-
name|V32_REGNUM
condition|)
block|{
name|ULONGEST
name|reg_addr
init|=
name|rse_address_add
argument_list|(
name|bsp
argument_list|,
operator|(
name|regnum
operator|-
name|V32_REGNUM
operator|)
argument_list|)
decl_stmt|;
name|write_memory
argument_list|(
name|reg_addr
argument_list|,
operator|(
name|void
operator|*
operator|)
name|buf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|IA64_NAT0_REGNUM
operator|<=
name|regnum
operator|&&
name|regnum
operator|<=
name|IA64_NAT31_REGNUM
condition|)
block|{
name|ULONGEST
name|unatN_val
decl_stmt|,
name|unat
decl_stmt|,
name|unatN_mask
decl_stmt|;
name|regcache_cooked_read_unsigned
argument_list|(
name|regcache
argument_list|,
name|IA64_UNAT_REGNUM
argument_list|,
operator|&
name|unat
argument_list|)
expr_stmt|;
name|unatN_val
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
name|register_size
argument_list|(
name|current_gdbarch
argument_list|,
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
name|unatN_mask
operator|=
operator|(
literal|1LL
operator|<<
operator|(
name|regnum
operator|-
name|IA64_NAT0_REGNUM
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|unatN_val
operator|==
literal|0
condition|)
name|unat
operator|&=
operator|~
name|unatN_mask
expr_stmt|;
elseif|else
if|if
condition|(
name|unatN_val
operator|==
literal|1
condition|)
name|unat
operator||=
name|unatN_mask
expr_stmt|;
name|regcache_cooked_write_unsigned
argument_list|(
name|regcache
argument_list|,
name|IA64_UNAT_REGNUM
argument_list|,
name|unat
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IA64_NAT32_REGNUM
operator|<=
name|regnum
operator|&&
name|regnum
operator|<=
name|IA64_NAT127_REGNUM
condition|)
block|{
name|ULONGEST
name|natN_val
decl_stmt|;
name|ULONGEST
name|bsp
decl_stmt|;
name|ULONGEST
name|cfm
decl_stmt|;
name|CORE_ADDR
name|gr_addr
init|=
literal|0
decl_stmt|;
name|regcache_cooked_read_unsigned
argument_list|(
name|regcache
argument_list|,
name|IA64_BSP_REGNUM
argument_list|,
operator|&
name|bsp
argument_list|)
expr_stmt|;
name|regcache_cooked_read_unsigned
argument_list|(
name|regcache
argument_list|,
name|IA64_CFM_REGNUM
argument_list|,
operator|&
name|cfm
argument_list|)
expr_stmt|;
comment|/* The bsp points at the end of the register frame so we 	 subtract the size of frame from it to get start of register frame.  */
name|bsp
operator|=
name|rse_address_add
argument_list|(
name|bsp
argument_list|,
operator|-
operator|(
name|cfm
operator|&
literal|0x7f
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cfm
operator|&
literal|0x7f
operator|)
operator|>
name|regnum
operator|-
name|V32_REGNUM
condition|)
name|gr_addr
operator|=
name|rse_address_add
argument_list|(
name|bsp
argument_list|,
operator|(
name|regnum
operator|-
name|V32_REGNUM
operator|)
argument_list|)
expr_stmt|;
name|natN_val
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
name|register_size
argument_list|(
name|current_gdbarch
argument_list|,
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|gr_addr
operator|!=
literal|0
operator|&&
operator|(
name|natN_val
operator|==
literal|0
operator|||
name|natN_val
operator|==
literal|1
operator|)
condition|)
block|{
comment|/* Compute address of nat collection bits.  */
name|CORE_ADDR
name|nat_addr
init|=
name|gr_addr
operator||
literal|0x1f8
decl_stmt|;
name|CORE_ADDR
name|nat_collection
decl_stmt|;
name|int
name|natN_bit
init|=
operator|(
name|gr_addr
operator|>>
literal|3
operator|)
operator|&
literal|0x3f
decl_stmt|;
name|ULONGEST
name|natN_mask
init|=
operator|(
literal|1LL
operator|<<
name|natN_bit
operator|)
decl_stmt|;
comment|/* If our nat collection address is bigger than bsp, we have to get 	     the nat collection from rnat.  Otherwise, we fetch the nat 	     collection from the computed address.  */
if|if
condition|(
name|nat_addr
operator|>=
name|bsp
condition|)
block|{
name|regcache_cooked_read_unsigned
argument_list|(
name|regcache
argument_list|,
name|IA64_RNAT_REGNUM
argument_list|,
operator|&
name|nat_collection
argument_list|)
expr_stmt|;
if|if
condition|(
name|natN_val
condition|)
name|nat_collection
operator||=
name|natN_mask
expr_stmt|;
else|else
name|nat_collection
operator|&=
operator|~
name|natN_mask
expr_stmt|;
name|regcache_cooked_write_unsigned
argument_list|(
name|regcache
argument_list|,
name|IA64_RNAT_REGNUM
argument_list|,
name|nat_collection
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
name|nat_buf
index|[
literal|8
index|]
decl_stmt|;
name|nat_collection
operator|=
name|read_memory_integer
argument_list|(
name|nat_addr
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|natN_val
condition|)
name|nat_collection
operator||=
name|natN_mask
expr_stmt|;
else|else
name|nat_collection
operator|&=
operator|~
name|natN_mask
expr_stmt|;
name|store_unsigned_integer
argument_list|(
name|nat_buf
argument_list|,
name|register_size
argument_list|(
name|current_gdbarch
argument_list|,
name|regnum
argument_list|)
argument_list|,
name|nat_collection
argument_list|)
expr_stmt|;
name|write_memory
argument_list|(
name|nat_addr
argument_list|,
name|nat_buf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|VP0_REGNUM
operator|<=
name|regnum
operator|&&
name|regnum
operator|<=
name|VP63_REGNUM
condition|)
block|{
name|ULONGEST
name|pr
decl_stmt|;
name|ULONGEST
name|cfm
decl_stmt|;
name|ULONGEST
name|prN_val
decl_stmt|;
name|ULONGEST
name|prN_mask
decl_stmt|;
name|regcache_cooked_read_unsigned
argument_list|(
name|regcache
argument_list|,
name|IA64_PR_REGNUM
argument_list|,
operator|&
name|pr
argument_list|)
expr_stmt|;
name|regcache_cooked_read_unsigned
argument_list|(
name|regcache
argument_list|,
name|IA64_CFM_REGNUM
argument_list|,
operator|&
name|cfm
argument_list|)
expr_stmt|;
if|if
condition|(
name|VP16_REGNUM
operator|<=
name|regnum
operator|&&
name|regnum
operator|<=
name|VP63_REGNUM
condition|)
block|{
comment|/* Fetch predicate register rename base from current frame 	     marker for this frame. */
name|int
name|rrb_pr
init|=
operator|(
name|cfm
operator|>>
literal|32
operator|)
operator|&
literal|0x3f
decl_stmt|;
comment|/* Adjust the register number to account for register rotation. */
name|regnum
operator|=
name|VP16_REGNUM
operator|+
operator|(
operator|(
name|regnum
operator|-
name|VP16_REGNUM
operator|)
operator|+
name|rrb_pr
operator|)
operator|%
literal|48
expr_stmt|;
block|}
name|prN_val
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
name|register_size
argument_list|(
name|current_gdbarch
argument_list|,
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
name|prN_mask
operator|=
operator|(
literal|1LL
operator|<<
operator|(
name|regnum
operator|-
name|VP0_REGNUM
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|prN_val
operator|==
literal|0
condition|)
name|pr
operator|&=
operator|~
name|prN_mask
expr_stmt|;
elseif|else
if|if
condition|(
name|prN_val
operator|==
literal|1
condition|)
name|pr
operator||=
name|prN_mask
expr_stmt|;
name|regcache_cooked_write_unsigned
argument_list|(
name|regcache
argument_list|,
name|IA64_PR_REGNUM
argument_list|,
name|pr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The ia64 needs to convert between various ieee floating-point formats    and the special ia64 floating point register format.  */
end_comment

begin_function
specifier|static
name|int
name|ia64_convert_register_p
parameter_list|(
name|int
name|regno
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
return|return
operator|(
name|regno
operator|>=
name|IA64_FR0_REGNUM
operator|&&
name|regno
operator|<=
name|IA64_FR127_REGNUM
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ia64_register_to_value
parameter_list|(
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|,
name|int
name|regnum
parameter_list|,
name|struct
name|type
modifier|*
name|valtype
parameter_list|,
name|void
modifier|*
name|out
parameter_list|)
block|{
name|char
name|in
index|[
name|MAX_REGISTER_SIZE
index|]
decl_stmt|;
name|frame_register_read
argument_list|(
name|frame
argument_list|,
name|regnum
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|convert_typed_floating
argument_list|(
name|in
argument_list|,
name|builtin_type_ia64_ext
argument_list|,
name|out
argument_list|,
name|valtype
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ia64_value_to_register
parameter_list|(
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|,
name|int
name|regnum
parameter_list|,
name|struct
name|type
modifier|*
name|valtype
parameter_list|,
specifier|const
name|void
modifier|*
name|in
parameter_list|)
block|{
name|char
name|out
index|[
name|MAX_REGISTER_SIZE
index|]
decl_stmt|;
name|convert_typed_floating
argument_list|(
name|in
argument_list|,
name|valtype
argument_list|,
name|out
argument_list|,
name|builtin_type_ia64_ext
argument_list|)
expr_stmt|;
name|put_frame_register
argument_list|(
name|frame
argument_list|,
name|regnum
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Limit the number of skipped non-prologue instructions since examining    of the prologue is expensive.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_skip_non_prologue_insns
init|=
literal|40
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Given PC representing the starting address of a function, and    LIM_PC which is the (sloppy) limit to which to scan when looking    for a prologue, attempt to further refine this limit by using    the line data in the symbol table.  If successful, a better guess    on where the prologue ends is returned, otherwise the previous    value of lim_pc is returned.  TRUST_LIMIT is a pointer to a flag    which will be set to indicate whether the returned limit may be    used with no further scanning in the event that the function is    frameless.  */
end_comment

begin_comment
comment|/* FIXME: cagney/2004-02-14: This function and logic have largely been    superseded by skip_prologue_using_sal.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|refine_prologue_limit
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|CORE_ADDR
name|lim_pc
parameter_list|,
name|int
modifier|*
name|trust_limit
parameter_list|)
block|{
name|struct
name|symtab_and_line
name|prologue_sal
decl_stmt|;
name|CORE_ADDR
name|start_pc
init|=
name|pc
decl_stmt|;
comment|/* Start off not trusting the limit.  */
operator|*
name|trust_limit
operator|=
literal|0
expr_stmt|;
name|prologue_sal
operator|=
name|find_pc_line
argument_list|(
name|pc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|prologue_sal
operator|.
name|line
operator|!=
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
name|CORE_ADDR
name|addr
init|=
name|prologue_sal
operator|.
name|end
decl_stmt|;
comment|/* Handle the case in which compiler's optimizer/scheduler          has moved instructions into the prologue.  We scan ahead 	 in the function looking for address ranges whose corresponding 	 line number is less than or equal to the first one that we 	 found for the function.  (It can be less than when the 	 scheduler puts a body instruction before the first prologue 	 instruction.)  */
for|for
control|(
name|i
operator|=
literal|2
operator|*
name|max_skip_non_prologue_insns
init|;
name|i
operator|>
literal|0
operator|&&
operator|(
name|lim_pc
operator|==
literal|0
operator|||
name|addr
operator|<
name|lim_pc
operator|)
condition|;
name|i
operator|--
control|)
block|{
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|sal
operator|=
name|find_pc_line
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sal
operator|.
name|line
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|sal
operator|.
name|line
operator|<=
name|prologue_sal
operator|.
name|line
operator|&&
name|sal
operator|.
name|symtab
operator|==
name|prologue_sal
operator|.
name|symtab
condition|)
block|{
name|prologue_sal
operator|=
name|sal
expr_stmt|;
block|}
name|addr
operator|=
name|sal
operator|.
name|end
expr_stmt|;
block|}
if|if
condition|(
name|lim_pc
operator|==
literal|0
operator|||
name|prologue_sal
operator|.
name|end
operator|<
name|lim_pc
condition|)
block|{
name|lim_pc
operator|=
name|prologue_sal
operator|.
name|end
expr_stmt|;
if|if
condition|(
name|start_pc
operator|==
name|get_pc_function_start
argument_list|(
name|lim_pc
argument_list|)
condition|)
operator|*
name|trust_limit
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
name|lim_pc
return|;
block|}
end_function

begin_define
define|#
directive|define
name|isScratch
parameter_list|(
name|_regnum_
parameter_list|)
value|((_regnum_) == 2 || (_regnum_) == 3 \   || (8<= (_regnum_)&& (_regnum_)<= 11) \   || (14<= (_regnum_)&& (_regnum_)<= 31))
end_define

begin_define
define|#
directive|define
name|imm9
parameter_list|(
name|_instr_
parameter_list|)
define|\
value|( ((((_instr_)& 0x01000000000LL) ? -1 : 0)<< 8) \    | (((_instr_)& 0x00008000000LL)>> 20) \    | (((_instr_)& 0x00000001fc0LL)>> 6))
end_define

begin_comment
comment|/* Allocate and initialize a frame cache.  */
end_comment

begin_function
specifier|static
name|struct
name|ia64_frame_cache
modifier|*
name|ia64_alloc_frame_cache
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|ia64_frame_cache
modifier|*
name|cache
decl_stmt|;
name|int
name|i
decl_stmt|;
name|cache
operator|=
name|FRAME_OBSTACK_ZALLOC
argument_list|(
expr|struct
name|ia64_frame_cache
argument_list|)
expr_stmt|;
comment|/* Base address.  */
name|cache
operator|->
name|base
operator|=
literal|0
expr_stmt|;
name|cache
operator|->
name|pc
operator|=
literal|0
expr_stmt|;
name|cache
operator|->
name|cfm
operator|=
literal|0
expr_stmt|;
name|cache
operator|->
name|prev_cfm
operator|=
literal|0
expr_stmt|;
name|cache
operator|->
name|sof
operator|=
literal|0
expr_stmt|;
name|cache
operator|->
name|sol
operator|=
literal|0
expr_stmt|;
name|cache
operator|->
name|sor
operator|=
literal|0
expr_stmt|;
name|cache
operator|->
name|bsp
operator|=
literal|0
expr_stmt|;
name|cache
operator|->
name|fp_reg
operator|=
literal|0
expr_stmt|;
name|cache
operator|->
name|frameless
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_IA64_RAW_REGS
condition|;
name|i
operator|++
control|)
name|cache
operator|->
name|saved_regs
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|cache
return|;
block|}
end_function

begin_function
specifier|static
name|CORE_ADDR
name|examine_prologue
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|CORE_ADDR
name|lim_pc
parameter_list|,
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|struct
name|ia64_frame_cache
modifier|*
name|cache
parameter_list|)
block|{
name|CORE_ADDR
name|next_pc
decl_stmt|;
name|CORE_ADDR
name|last_prologue_pc
init|=
name|pc
decl_stmt|;
name|instruction_type
name|it
decl_stmt|;
name|long
name|long
name|instr
decl_stmt|;
name|int
name|cfm_reg
init|=
literal|0
decl_stmt|;
name|int
name|ret_reg
init|=
literal|0
decl_stmt|;
name|int
name|fp_reg
init|=
literal|0
decl_stmt|;
name|int
name|unat_save_reg
init|=
literal|0
decl_stmt|;
name|int
name|pr_save_reg
init|=
literal|0
decl_stmt|;
name|int
name|mem_stack_frame_size
init|=
literal|0
decl_stmt|;
name|int
name|spill_reg
init|=
literal|0
decl_stmt|;
name|CORE_ADDR
name|spill_addr
init|=
literal|0
decl_stmt|;
name|char
name|instores
index|[
literal|8
index|]
decl_stmt|;
name|char
name|infpstores
index|[
literal|8
index|]
decl_stmt|;
name|char
name|reg_contents
index|[
literal|256
index|]
decl_stmt|;
name|int
name|trust_limit
decl_stmt|;
name|int
name|frameless
init|=
literal|1
decl_stmt|;
name|int
name|i
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|char
name|buf
index|[
literal|8
index|]
decl_stmt|;
name|CORE_ADDR
name|bof
decl_stmt|,
name|sor
decl_stmt|,
name|sol
decl_stmt|,
name|sof
decl_stmt|,
name|cfm
decl_stmt|,
name|rrb_gr
decl_stmt|;
name|memset
argument_list|(
name|instores
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|instores
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|infpstores
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|infpstores
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|reg_contents
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|reg_contents
argument_list|)
expr_stmt|;
if|if
condition|(
name|cache
operator|->
name|after_prologue
operator|!=
literal|0
operator|&&
name|cache
operator|->
name|after_prologue
operator|<=
name|lim_pc
condition|)
return|return
name|cache
operator|->
name|after_prologue
return|;
name|lim_pc
operator|=
name|refine_prologue_limit
argument_list|(
name|pc
argument_list|,
name|lim_pc
argument_list|,
operator|&
name|trust_limit
argument_list|)
expr_stmt|;
name|next_pc
operator|=
name|fetch_instruction
argument_list|(
name|pc
argument_list|,
operator|&
name|it
argument_list|,
operator|&
name|instr
argument_list|)
expr_stmt|;
comment|/* We want to check if we have a recognizable function start before we      look ahead for a prologue.  */
if|if
condition|(
name|pc
operator|<
name|lim_pc
operator|&&
name|next_pc
operator|&&
name|it
operator|==
name|M
operator|&&
operator|(
operator|(
name|instr
operator|&
literal|0x1ee0000003fLL
operator|)
operator|==
literal|0x02c00000000LL
operator|)
condition|)
block|{
comment|/* alloc - start of a regular function.  */
name|int
name|sor
init|=
call|(
name|int
call|)
argument_list|(
operator|(
name|instr
operator|&
literal|0x00078000000LL
operator|)
operator|>>
literal|27
argument_list|)
decl_stmt|;
name|int
name|sol
init|=
call|(
name|int
call|)
argument_list|(
operator|(
name|instr
operator|&
literal|0x00007f00000LL
operator|)
operator|>>
literal|20
argument_list|)
decl_stmt|;
name|int
name|sof
init|=
call|(
name|int
call|)
argument_list|(
operator|(
name|instr
operator|&
literal|0x000000fe000LL
operator|)
operator|>>
literal|13
argument_list|)
decl_stmt|;
name|int
name|rN
init|=
call|(
name|int
call|)
argument_list|(
operator|(
name|instr
operator|&
literal|0x00000001fc0LL
operator|)
operator|>>
literal|6
argument_list|)
decl_stmt|;
comment|/* Verify that the current cfm matches what we think is the 	 function start.  If we have somehow jumped within a function, 	 we do not want to interpret the prologue and calculate the 	 addresses of various registers such as the return address.   	 We will instead treat the frame as frameless. */
if|if
condition|(
operator|!
name|next_frame
operator|||
operator|(
name|sof
operator|==
operator|(
name|cache
operator|->
name|cfm
operator|&
literal|0x7f
operator|)
operator|&&
name|sol
operator|==
operator|(
operator|(
name|cache
operator|->
name|cfm
operator|>>
literal|7
operator|)
operator|&
literal|0x7f
operator|)
operator|)
condition|)
name|frameless
operator|=
literal|0
expr_stmt|;
name|cfm_reg
operator|=
name|rN
expr_stmt|;
name|last_prologue_pc
operator|=
name|next_pc
expr_stmt|;
name|pc
operator|=
name|next_pc
expr_stmt|;
block|}
else|else
block|{
comment|/* Look for a leaf routine.  */
if|if
condition|(
name|pc
operator|<
name|lim_pc
operator|&&
name|next_pc
operator|&&
operator|(
name|it
operator|==
name|I
operator|||
name|it
operator|==
name|M
operator|)
operator|&&
operator|(
operator|(
name|instr
operator|&
literal|0x1ee00000000LL
operator|)
operator|==
literal|0x10800000000LL
operator|)
condition|)
block|{
comment|/* adds rN = imm14, rM   (or mov rN, rM  when imm14 is 0) */
name|int
name|imm
init|=
call|(
name|int
call|)
argument_list|(
operator|(
operator|(
operator|(
name|instr
operator|&
literal|0x01000000000LL
operator|)
condition|?
operator|-
literal|1
else|:
literal|0
operator|)
operator|<<
literal|13
operator|)
operator||
operator|(
operator|(
name|instr
operator|&
literal|0x001f8000000LL
operator|)
operator|>>
literal|20
operator|)
operator||
operator|(
operator|(
name|instr
operator|&
literal|0x000000fe000LL
operator|)
operator|>>
literal|13
operator|)
argument_list|)
decl_stmt|;
name|int
name|rM
init|=
call|(
name|int
call|)
argument_list|(
operator|(
name|instr
operator|&
literal|0x00007f00000LL
operator|)
operator|>>
literal|20
argument_list|)
decl_stmt|;
name|int
name|rN
init|=
call|(
name|int
call|)
argument_list|(
operator|(
name|instr
operator|&
literal|0x00000001fc0LL
operator|)
operator|>>
literal|6
argument_list|)
decl_stmt|;
name|int
name|qp
init|=
call|(
name|int
call|)
argument_list|(
name|instr
operator|&
literal|0x0000000003fLL
argument_list|)
decl_stmt|;
if|if
condition|(
name|qp
operator|==
literal|0
operator|&&
name|rN
operator|==
literal|2
operator|&&
name|imm
operator|==
literal|0
operator|&&
name|rM
operator|==
literal|12
operator|&&
name|fp_reg
operator|==
literal|0
condition|)
block|{
comment|/* mov r2, r12 - beginning of leaf routine */
name|fp_reg
operator|=
name|rN
expr_stmt|;
name|last_prologue_pc
operator|=
name|next_pc
expr_stmt|;
block|}
block|}
comment|/* If we don't recognize a regular function or leaf routine, we are 	 done.  */
if|if
condition|(
operator|!
name|fp_reg
condition|)
block|{
name|pc
operator|=
name|lim_pc
expr_stmt|;
if|if
condition|(
name|trust_limit
condition|)
name|last_prologue_pc
operator|=
name|lim_pc
expr_stmt|;
block|}
block|}
comment|/* Loop, looking for prologue instructions, keeping track of      where preserved registers were spilled. */
while|while
condition|(
name|pc
operator|<
name|lim_pc
condition|)
block|{
name|next_pc
operator|=
name|fetch_instruction
argument_list|(
name|pc
argument_list|,
operator|&
name|it
argument_list|,
operator|&
name|instr
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_pc
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|it
operator|==
name|B
operator|&&
operator|(
operator|(
name|instr
operator|&
literal|0x1e1f800003f
operator|)
operator|!=
literal|0x04000000000
operator|)
condition|)
block|{
comment|/* Exit loop upon hitting a non-nop branch instruction. */
if|if
condition|(
name|trust_limit
condition|)
name|lim_pc
operator|=
name|pc
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|instr
operator|&
literal|0x3fLL
operator|)
operator|!=
literal|0LL
operator|)
operator|&&
operator|(
name|frameless
operator|||
name|ret_reg
operator|!=
literal|0
operator|)
condition|)
block|{
comment|/* Exit loop upon hitting a predicated instruction if 	     we already have the return register or if we are frameless.  */
if|if
condition|(
name|trust_limit
condition|)
name|lim_pc
operator|=
name|pc
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|it
operator|==
name|I
operator|&&
operator|(
operator|(
name|instr
operator|&
literal|0x1eff8000000LL
operator|)
operator|==
literal|0x00188000000LL
operator|)
condition|)
block|{
comment|/* Move from BR */
name|int
name|b2
init|=
call|(
name|int
call|)
argument_list|(
operator|(
name|instr
operator|&
literal|0x0000000e000LL
operator|)
operator|>>
literal|13
argument_list|)
decl_stmt|;
name|int
name|rN
init|=
call|(
name|int
call|)
argument_list|(
operator|(
name|instr
operator|&
literal|0x00000001fc0LL
operator|)
operator|>>
literal|6
argument_list|)
decl_stmt|;
name|int
name|qp
init|=
call|(
name|int
call|)
argument_list|(
name|instr
operator|&
literal|0x0000000003f
argument_list|)
decl_stmt|;
if|if
condition|(
name|qp
operator|==
literal|0
operator|&&
name|b2
operator|==
literal|0
operator|&&
name|rN
operator|>=
literal|32
operator|&&
name|ret_reg
operator|==
literal|0
condition|)
block|{
name|ret_reg
operator|=
name|rN
expr_stmt|;
name|last_prologue_pc
operator|=
name|next_pc
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|it
operator|==
name|I
operator|||
name|it
operator|==
name|M
operator|)
operator|&&
operator|(
operator|(
name|instr
operator|&
literal|0x1ee00000000LL
operator|)
operator|==
literal|0x10800000000LL
operator|)
condition|)
block|{
comment|/* adds rN = imm14, rM   (or mov rN, rM  when imm14 is 0) */
name|int
name|imm
init|=
call|(
name|int
call|)
argument_list|(
operator|(
operator|(
operator|(
name|instr
operator|&
literal|0x01000000000LL
operator|)
condition|?
operator|-
literal|1
else|:
literal|0
operator|)
operator|<<
literal|13
operator|)
operator||
operator|(
operator|(
name|instr
operator|&
literal|0x001f8000000LL
operator|)
operator|>>
literal|20
operator|)
operator||
operator|(
operator|(
name|instr
operator|&
literal|0x000000fe000LL
operator|)
operator|>>
literal|13
operator|)
argument_list|)
decl_stmt|;
name|int
name|rM
init|=
call|(
name|int
call|)
argument_list|(
operator|(
name|instr
operator|&
literal|0x00007f00000LL
operator|)
operator|>>
literal|20
argument_list|)
decl_stmt|;
name|int
name|rN
init|=
call|(
name|int
call|)
argument_list|(
operator|(
name|instr
operator|&
literal|0x00000001fc0LL
operator|)
operator|>>
literal|6
argument_list|)
decl_stmt|;
name|int
name|qp
init|=
call|(
name|int
call|)
argument_list|(
name|instr
operator|&
literal|0x0000000003fLL
argument_list|)
decl_stmt|;
if|if
condition|(
name|qp
operator|==
literal|0
operator|&&
name|rN
operator|>=
literal|32
operator|&&
name|imm
operator|==
literal|0
operator|&&
name|rM
operator|==
literal|12
operator|&&
name|fp_reg
operator|==
literal|0
condition|)
block|{
comment|/* mov rN, r12 */
name|fp_reg
operator|=
name|rN
expr_stmt|;
name|last_prologue_pc
operator|=
name|next_pc
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|qp
operator|==
literal|0
operator|&&
name|rN
operator|==
literal|12
operator|&&
name|rM
operator|==
literal|12
condition|)
block|{
comment|/* adds r12, -mem_stack_frame_size, r12 */
name|mem_stack_frame_size
operator|-=
name|imm
expr_stmt|;
name|last_prologue_pc
operator|=
name|next_pc
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|qp
operator|==
literal|0
operator|&&
name|rN
operator|==
literal|2
operator|&&
operator|(
operator|(
name|rM
operator|==
name|fp_reg
operator|&&
name|fp_reg
operator|!=
literal|0
operator|)
operator|||
name|rM
operator|==
literal|12
operator|)
condition|)
block|{
name|char
name|buf
index|[
name|MAX_REGISTER_SIZE
index|]
decl_stmt|;
name|CORE_ADDR
name|saved_sp
init|=
literal|0
decl_stmt|;
comment|/* adds r2, spilloffset, rFramePointer  	           or 		 adds r2, spilloffset, r12  	         Get ready for stf.spill or st8.spill instructions. 		 The address to start spilling at is loaded into r2.  		 FIXME:  Why r2?  That's what gcc currently uses; it 		 could well be different for other compilers.  */
comment|/* Hmm... whether or not this will work will depend on 	         where the pc is.  If it's still early in the prologue 		 this'll be wrong.  FIXME */
if|if
condition|(
name|next_frame
condition|)
block|{
name|frame_unwind_register
argument_list|(
name|next_frame
argument_list|,
name|sp_regnum
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|saved_sp
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
name|spill_addr
operator|=
name|saved_sp
operator|+
operator|(
name|rM
operator|==
literal|12
condition|?
literal|0
else|:
name|mem_stack_frame_size
operator|)
operator|+
name|imm
expr_stmt|;
name|spill_reg
operator|=
name|rN
expr_stmt|;
name|last_prologue_pc
operator|=
name|next_pc
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|qp
operator|==
literal|0
operator|&&
name|rM
operator|>=
literal|32
operator|&&
name|rM
operator|<
literal|40
operator|&&
operator|!
name|instores
index|[
name|rM
index|]
operator|&&
name|rN
operator|<
literal|256
operator|&&
name|imm
operator|==
literal|0
condition|)
block|{
comment|/* mov rN, rM where rM is an input register */
name|reg_contents
index|[
name|rN
index|]
operator|=
name|rM
expr_stmt|;
name|last_prologue_pc
operator|=
name|next_pc
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|frameless
operator|&&
name|qp
operator|==
literal|0
operator|&&
name|rN
operator|==
name|fp_reg
operator|&&
name|imm
operator|==
literal|0
operator|&&
name|rM
operator|==
literal|2
condition|)
block|{
comment|/* mov r12, r2 */
name|last_prologue_pc
operator|=
name|next_pc
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|it
operator|==
name|M
operator|&&
operator|(
operator|(
operator|(
name|instr
operator|&
literal|0x1efc0000000LL
operator|)
operator|==
literal|0x0eec0000000LL
operator|)
operator|||
operator|(
operator|(
name|instr
operator|&
literal|0x1ffc8000000LL
operator|)
operator|==
literal|0x0cec0000000LL
operator|)
operator|)
condition|)
block|{
comment|/* stf.spill [rN] = fM, imm9 	     or 	     stf.spill [rN] = fM  */
name|int
name|imm
init|=
name|imm9
argument_list|(
name|instr
argument_list|)
decl_stmt|;
name|int
name|rN
init|=
call|(
name|int
call|)
argument_list|(
operator|(
name|instr
operator|&
literal|0x00007f00000LL
operator|)
operator|>>
literal|20
argument_list|)
decl_stmt|;
name|int
name|fM
init|=
call|(
name|int
call|)
argument_list|(
operator|(
name|instr
operator|&
literal|0x000000fe000LL
operator|)
operator|>>
literal|13
argument_list|)
decl_stmt|;
name|int
name|qp
init|=
call|(
name|int
call|)
argument_list|(
name|instr
operator|&
literal|0x0000000003fLL
argument_list|)
decl_stmt|;
if|if
condition|(
name|qp
operator|==
literal|0
operator|&&
name|rN
operator|==
name|spill_reg
operator|&&
name|spill_addr
operator|!=
literal|0
operator|&&
operator|(
operator|(
literal|2
operator|<=
name|fM
operator|&&
name|fM
operator|<=
literal|5
operator|)
operator|||
operator|(
literal|16
operator|<=
name|fM
operator|&&
name|fM
operator|<=
literal|31
operator|)
operator|)
condition|)
block|{
name|cache
operator|->
name|saved_regs
index|[
name|IA64_FR0_REGNUM
operator|+
name|fM
index|]
operator|=
name|spill_addr
expr_stmt|;
if|if
condition|(
operator|(
name|instr
operator|&
literal|0x1efc0000000
operator|)
operator|==
literal|0x0eec0000000
condition|)
name|spill_addr
operator|+=
name|imm
expr_stmt|;
else|else
name|spill_addr
operator|=
literal|0
expr_stmt|;
comment|/* last one; must be done */
name|last_prologue_pc
operator|=
name|next_pc
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|it
operator|==
name|M
operator|&&
operator|(
operator|(
name|instr
operator|&
literal|0x1eff8000000LL
operator|)
operator|==
literal|0x02110000000LL
operator|)
operator|)
operator|||
operator|(
name|it
operator|==
name|I
operator|&&
operator|(
operator|(
name|instr
operator|&
literal|0x1eff8000000LL
operator|)
operator|==
literal|0x00050000000LL
operator|)
operator|)
condition|)
block|{
comment|/* mov.m rN = arM    	       or  	     mov.i rN = arM */
name|int
name|arM
init|=
call|(
name|int
call|)
argument_list|(
operator|(
name|instr
operator|&
literal|0x00007f00000LL
operator|)
operator|>>
literal|20
argument_list|)
decl_stmt|;
name|int
name|rN
init|=
call|(
name|int
call|)
argument_list|(
operator|(
name|instr
operator|&
literal|0x00000001fc0LL
operator|)
operator|>>
literal|6
argument_list|)
decl_stmt|;
name|int
name|qp
init|=
call|(
name|int
call|)
argument_list|(
name|instr
operator|&
literal|0x0000000003fLL
argument_list|)
decl_stmt|;
if|if
condition|(
name|qp
operator|==
literal|0
operator|&&
name|isScratch
argument_list|(
name|rN
argument_list|)
operator|&&
name|arM
operator|==
literal|36
comment|/* ar.unat */
condition|)
block|{
comment|/* We have something like "mov.m r3 = ar.unat".  Remember the 		 r3 (or whatever) and watch for a store of this register... */
name|unat_save_reg
operator|=
name|rN
expr_stmt|;
name|last_prologue_pc
operator|=
name|next_pc
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|it
operator|==
name|I
operator|&&
operator|(
operator|(
name|instr
operator|&
literal|0x1eff8000000LL
operator|)
operator|==
literal|0x00198000000LL
operator|)
condition|)
block|{
comment|/* mov rN = pr */
name|int
name|rN
init|=
call|(
name|int
call|)
argument_list|(
operator|(
name|instr
operator|&
literal|0x00000001fc0LL
operator|)
operator|>>
literal|6
argument_list|)
decl_stmt|;
name|int
name|qp
init|=
call|(
name|int
call|)
argument_list|(
name|instr
operator|&
literal|0x0000000003fLL
argument_list|)
decl_stmt|;
if|if
condition|(
name|qp
operator|==
literal|0
operator|&&
name|isScratch
argument_list|(
name|rN
argument_list|)
condition|)
block|{
name|pr_save_reg
operator|=
name|rN
expr_stmt|;
name|last_prologue_pc
operator|=
name|next_pc
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|it
operator|==
name|M
operator|&&
operator|(
operator|(
operator|(
name|instr
operator|&
literal|0x1ffc8000000LL
operator|)
operator|==
literal|0x08cc0000000LL
operator|)
operator|||
operator|(
operator|(
name|instr
operator|&
literal|0x1efc0000000LL
operator|)
operator|==
literal|0x0acc0000000LL
operator|)
operator|)
condition|)
block|{
comment|/* st8 [rN] = rM  	      or 	     st8 [rN] = rM, imm9 */
name|int
name|rN
init|=
call|(
name|int
call|)
argument_list|(
operator|(
name|instr
operator|&
literal|0x00007f00000LL
operator|)
operator|>>
literal|20
argument_list|)
decl_stmt|;
name|int
name|rM
init|=
call|(
name|int
call|)
argument_list|(
operator|(
name|instr
operator|&
literal|0x000000fe000LL
operator|)
operator|>>
literal|13
argument_list|)
decl_stmt|;
name|int
name|qp
init|=
call|(
name|int
call|)
argument_list|(
name|instr
operator|&
literal|0x0000000003fLL
argument_list|)
decl_stmt|;
name|int
name|indirect
init|=
name|rM
operator|<
literal|256
condition|?
name|reg_contents
index|[
name|rM
index|]
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|qp
operator|==
literal|0
operator|&&
name|rN
operator|==
name|spill_reg
operator|&&
name|spill_addr
operator|!=
literal|0
operator|&&
operator|(
name|rM
operator|==
name|unat_save_reg
operator|||
name|rM
operator|==
name|pr_save_reg
operator|)
condition|)
block|{
comment|/* We've found a spill of either the UNAT register or the PR 	         register.  (Well, not exactly; what we've actually found is 		 a spill of the register that UNAT or PR was moved to). 		 Record that fact and move on... */
if|if
condition|(
name|rM
operator|==
name|unat_save_reg
condition|)
block|{
comment|/* Track UNAT register */
name|cache
operator|->
name|saved_regs
index|[
name|IA64_UNAT_REGNUM
index|]
operator|=
name|spill_addr
expr_stmt|;
name|unat_save_reg
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Track PR register */
name|cache
operator|->
name|saved_regs
index|[
name|IA64_PR_REGNUM
index|]
operator|=
name|spill_addr
expr_stmt|;
name|pr_save_reg
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|instr
operator|&
literal|0x1efc0000000LL
operator|)
operator|==
literal|0x0acc0000000LL
condition|)
comment|/* st8 [rN] = rM, imm9 */
name|spill_addr
operator|+=
name|imm9
argument_list|(
name|instr
argument_list|)
expr_stmt|;
else|else
name|spill_addr
operator|=
literal|0
expr_stmt|;
comment|/* must be done spilling */
name|last_prologue_pc
operator|=
name|next_pc
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|qp
operator|==
literal|0
operator|&&
literal|32
operator|<=
name|rM
operator|&&
name|rM
operator|<
literal|40
operator|&&
operator|!
name|instores
index|[
name|rM
operator|-
literal|32
index|]
condition|)
block|{
comment|/* Allow up to one store of each input register. */
name|instores
index|[
name|rM
operator|-
literal|32
index|]
operator|=
literal|1
expr_stmt|;
name|last_prologue_pc
operator|=
name|next_pc
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|qp
operator|==
literal|0
operator|&&
literal|32
operator|<=
name|indirect
operator|&&
name|indirect
operator|<
literal|40
operator|&&
operator|!
name|instores
index|[
name|indirect
operator|-
literal|32
index|]
condition|)
block|{
comment|/* Allow an indirect store of an input register.  */
name|instores
index|[
name|indirect
operator|-
literal|32
index|]
operator|=
literal|1
expr_stmt|;
name|last_prologue_pc
operator|=
name|next_pc
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|it
operator|==
name|M
operator|&&
operator|(
operator|(
name|instr
operator|&
literal|0x1ff08000000LL
operator|)
operator|==
literal|0x08c00000000LL
operator|)
condition|)
block|{
comment|/* One of 	       st1 [rN] = rM 	       st2 [rN] = rM 	       st4 [rN] = rM 	       st8 [rN] = rM 	     Note that the st8 case is handled in the clause above. 	      	     Advance over stores of input registers. One store per input 	     register is permitted. */
name|int
name|rM
init|=
call|(
name|int
call|)
argument_list|(
operator|(
name|instr
operator|&
literal|0x000000fe000LL
operator|)
operator|>>
literal|13
argument_list|)
decl_stmt|;
name|int
name|qp
init|=
call|(
name|int
call|)
argument_list|(
name|instr
operator|&
literal|0x0000000003fLL
argument_list|)
decl_stmt|;
name|int
name|indirect
init|=
name|rM
operator|<
literal|256
condition|?
name|reg_contents
index|[
name|rM
index|]
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|qp
operator|==
literal|0
operator|&&
literal|32
operator|<=
name|rM
operator|&&
name|rM
operator|<
literal|40
operator|&&
operator|!
name|instores
index|[
name|rM
operator|-
literal|32
index|]
condition|)
block|{
name|instores
index|[
name|rM
operator|-
literal|32
index|]
operator|=
literal|1
expr_stmt|;
name|last_prologue_pc
operator|=
name|next_pc
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|qp
operator|==
literal|0
operator|&&
literal|32
operator|<=
name|indirect
operator|&&
name|indirect
operator|<
literal|40
operator|&&
operator|!
name|instores
index|[
name|indirect
operator|-
literal|32
index|]
condition|)
block|{
comment|/* Allow an indirect store of an input register.  */
name|instores
index|[
name|indirect
operator|-
literal|32
index|]
operator|=
literal|1
expr_stmt|;
name|last_prologue_pc
operator|=
name|next_pc
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|it
operator|==
name|M
operator|&&
operator|(
operator|(
name|instr
operator|&
literal|0x1ff88000000LL
operator|)
operator|==
literal|0x0cc80000000LL
operator|)
condition|)
block|{
comment|/* Either 	       stfs [rN] = fM 	     or 	       stfd [rN] = fM  	     Advance over stores of floating point input registers.  Again 	     one store per register is permitted */
name|int
name|fM
init|=
call|(
name|int
call|)
argument_list|(
operator|(
name|instr
operator|&
literal|0x000000fe000LL
operator|)
operator|>>
literal|13
argument_list|)
decl_stmt|;
name|int
name|qp
init|=
call|(
name|int
call|)
argument_list|(
name|instr
operator|&
literal|0x0000000003fLL
argument_list|)
decl_stmt|;
if|if
condition|(
name|qp
operator|==
literal|0
operator|&&
literal|8
operator|<=
name|fM
operator|&&
name|fM
operator|<
literal|16
operator|&&
operator|!
name|infpstores
index|[
name|fM
operator|-
literal|8
index|]
condition|)
block|{
name|infpstores
index|[
name|fM
operator|-
literal|8
index|]
operator|=
literal|1
expr_stmt|;
name|last_prologue_pc
operator|=
name|next_pc
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|it
operator|==
name|M
operator|&&
operator|(
operator|(
operator|(
name|instr
operator|&
literal|0x1ffc8000000LL
operator|)
operator|==
literal|0x08ec0000000LL
operator|)
operator|||
operator|(
operator|(
name|instr
operator|&
literal|0x1efc0000000LL
operator|)
operator|==
literal|0x0aec0000000LL
operator|)
operator|)
condition|)
block|{
comment|/* st8.spill [rN] = rM 	       or 	     st8.spill [rN] = rM, imm9 */
name|int
name|rN
init|=
call|(
name|int
call|)
argument_list|(
operator|(
name|instr
operator|&
literal|0x00007f00000LL
operator|)
operator|>>
literal|20
argument_list|)
decl_stmt|;
name|int
name|rM
init|=
call|(
name|int
call|)
argument_list|(
operator|(
name|instr
operator|&
literal|0x000000fe000LL
operator|)
operator|>>
literal|13
argument_list|)
decl_stmt|;
name|int
name|qp
init|=
call|(
name|int
call|)
argument_list|(
name|instr
operator|&
literal|0x0000000003fLL
argument_list|)
decl_stmt|;
if|if
condition|(
name|qp
operator|==
literal|0
operator|&&
name|rN
operator|==
name|spill_reg
operator|&&
literal|4
operator|<=
name|rM
operator|&&
name|rM
operator|<=
literal|7
condition|)
block|{
comment|/* We've found a spill of one of the preserved general purpose 	         regs.  Record the spill address and advance the spill 		 register if appropriate. */
name|cache
operator|->
name|saved_regs
index|[
name|IA64_GR0_REGNUM
operator|+
name|rM
index|]
operator|=
name|spill_addr
expr_stmt|;
if|if
condition|(
operator|(
name|instr
operator|&
literal|0x1efc0000000LL
operator|)
operator|==
literal|0x0aec0000000LL
condition|)
comment|/* st8.spill [rN] = rM, imm9 */
name|spill_addr
operator|+=
name|imm9
argument_list|(
name|instr
argument_list|)
expr_stmt|;
else|else
name|spill_addr
operator|=
literal|0
expr_stmt|;
comment|/* Done spilling */
name|last_prologue_pc
operator|=
name|next_pc
expr_stmt|;
block|}
block|}
name|pc
operator|=
name|next_pc
expr_stmt|;
block|}
comment|/* If not frameless and we aren't called by skip_prologue, then we need to calculate      registers for the previous frame which will be needed later.  */
if|if
condition|(
operator|!
name|frameless
operator|&&
name|next_frame
condition|)
block|{
comment|/* Extract the size of the rotating portion of the stack 	 frame and the register rename base from the current 	 frame marker. */
name|cfm
operator|=
name|cache
operator|->
name|cfm
expr_stmt|;
name|sor
operator|=
name|cache
operator|->
name|sor
expr_stmt|;
name|sof
operator|=
name|cache
operator|->
name|sof
expr_stmt|;
name|sol
operator|=
name|cache
operator|->
name|sol
expr_stmt|;
name|rrb_gr
operator|=
operator|(
name|cfm
operator|>>
literal|18
operator|)
operator|&
literal|0x7f
expr_stmt|;
comment|/* Find the bof (beginning of frame).  */
name|bof
operator|=
name|rse_address_add
argument_list|(
name|cache
operator|->
name|bsp
argument_list|,
operator|-
name|sof
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|addr
operator|=
name|bof
init|;
name|i
operator|<
name|sof
condition|;
name|i
operator|++
operator|,
name|addr
operator|+=
literal|8
control|)
block|{
if|if
condition|(
name|IS_NaT_COLLECTION_ADDR
argument_list|(
name|addr
argument_list|)
condition|)
block|{
name|addr
operator|+=
literal|8
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|+
literal|32
operator|==
name|cfm_reg
condition|)
name|cache
operator|->
name|saved_regs
index|[
name|IA64_CFM_REGNUM
index|]
operator|=
name|addr
expr_stmt|;
if|if
condition|(
name|i
operator|+
literal|32
operator|==
name|ret_reg
condition|)
name|cache
operator|->
name|saved_regs
index|[
name|IA64_VRAP_REGNUM
index|]
operator|=
name|addr
expr_stmt|;
if|if
condition|(
name|i
operator|+
literal|32
operator|==
name|fp_reg
condition|)
name|cache
operator|->
name|saved_regs
index|[
name|IA64_VFP_REGNUM
index|]
operator|=
name|addr
expr_stmt|;
block|}
comment|/* For the previous argument registers we require the previous bof.   	 If we can't find the previous cfm, then we can do nothing.  */
name|cfm
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cache
operator|->
name|saved_regs
index|[
name|IA64_CFM_REGNUM
index|]
operator|!=
literal|0
condition|)
block|{
name|cfm
operator|=
name|read_memory_integer
argument_list|(
name|cache
operator|->
name|saved_regs
index|[
name|IA64_CFM_REGNUM
index|]
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cfm_reg
operator|!=
literal|0
condition|)
block|{
name|frame_unwind_register
argument_list|(
name|next_frame
argument_list|,
name|cfm_reg
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|cfm
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
name|cache
operator|->
name|prev_cfm
operator|=
name|cfm
expr_stmt|;
if|if
condition|(
name|cfm
operator|!=
literal|0
condition|)
block|{
name|sor
operator|=
operator|(
operator|(
name|cfm
operator|>>
literal|14
operator|)
operator|&
literal|0xf
operator|)
operator|*
literal|8
expr_stmt|;
name|sof
operator|=
operator|(
name|cfm
operator|&
literal|0x7f
operator|)
expr_stmt|;
name|sol
operator|=
operator|(
name|cfm
operator|>>
literal|7
operator|)
operator|&
literal|0x7f
expr_stmt|;
name|rrb_gr
operator|=
operator|(
name|cfm
operator|>>
literal|18
operator|)
operator|&
literal|0x7f
expr_stmt|;
comment|/* The previous bof only requires subtraction of the sol (size of locals) 	     due to the overlap between output and input of subsequent frames.  */
name|bof
operator|=
name|rse_address_add
argument_list|(
name|bof
argument_list|,
operator|-
name|sol
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|addr
operator|=
name|bof
init|;
name|i
operator|<
name|sof
condition|;
name|i
operator|++
operator|,
name|addr
operator|+=
literal|8
control|)
block|{
if|if
condition|(
name|IS_NaT_COLLECTION_ADDR
argument_list|(
name|addr
argument_list|)
condition|)
block|{
name|addr
operator|+=
literal|8
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
name|sor
condition|)
name|cache
operator|->
name|saved_regs
index|[
name|IA64_GR32_REGNUM
operator|+
operator|(
operator|(
name|i
operator|+
operator|(
name|sor
operator|-
name|rrb_gr
operator|)
operator|)
operator|%
name|sor
operator|)
index|]
operator|=
name|addr
expr_stmt|;
else|else
name|cache
operator|->
name|saved_regs
index|[
name|IA64_GR32_REGNUM
operator|+
name|i
index|]
operator|=
name|addr
expr_stmt|;
block|}
block|}
block|}
comment|/* Try and trust the lim_pc value whenever possible.  */
if|if
condition|(
name|trust_limit
operator|&&
name|lim_pc
operator|>=
name|last_prologue_pc
condition|)
name|last_prologue_pc
operator|=
name|lim_pc
expr_stmt|;
name|cache
operator|->
name|frameless
operator|=
name|frameless
expr_stmt|;
name|cache
operator|->
name|after_prologue
operator|=
name|last_prologue_pc
expr_stmt|;
name|cache
operator|->
name|mem_stack_frame_size
operator|=
name|mem_stack_frame_size
expr_stmt|;
name|cache
operator|->
name|fp_reg
operator|=
name|fp_reg
expr_stmt|;
return|return
name|last_prologue_pc
return|;
block|}
end_function

begin_function
name|CORE_ADDR
name|ia64_skip_prologue
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
name|struct
name|ia64_frame_cache
name|cache
decl_stmt|;
name|cache
operator|.
name|base
operator|=
literal|0
expr_stmt|;
name|cache
operator|.
name|after_prologue
operator|=
literal|0
expr_stmt|;
name|cache
operator|.
name|cfm
operator|=
literal|0
expr_stmt|;
name|cache
operator|.
name|bsp
operator|=
literal|0
expr_stmt|;
comment|/* Call examine_prologue with - as third argument since we don't have a next frame pointer to send.  */
return|return
name|examine_prologue
argument_list|(
name|pc
argument_list|,
name|pc
operator|+
literal|1024
argument_list|,
literal|0
argument_list|,
operator|&
name|cache
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Normal frames.  */
end_comment

begin_function
specifier|static
name|struct
name|ia64_frame_cache
modifier|*
name|ia64_frame_cache
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|void
modifier|*
modifier|*
name|this_cache
parameter_list|)
block|{
name|struct
name|ia64_frame_cache
modifier|*
name|cache
decl_stmt|;
name|char
name|buf
index|[
literal|8
index|]
decl_stmt|;
name|CORE_ADDR
name|cfm
decl_stmt|,
name|sof
decl_stmt|,
name|sol
decl_stmt|,
name|bsp
decl_stmt|,
name|psr
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|*
name|this_cache
condition|)
return|return
operator|*
name|this_cache
return|;
name|cache
operator|=
name|ia64_alloc_frame_cache
argument_list|()
expr_stmt|;
operator|*
name|this_cache
operator|=
name|cache
expr_stmt|;
name|frame_unwind_register
argument_list|(
name|next_frame
argument_list|,
name|sp_regnum
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|cache
operator|->
name|saved_sp
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
comment|/* We always want the bsp to point to the end of frame.      This way, we can always get the beginning of frame (bof)      by subtracting frame size.  */
name|frame_unwind_register
argument_list|(
name|next_frame
argument_list|,
name|IA64_BSP_REGNUM
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|cache
operator|->
name|bsp
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|frame_unwind_register
argument_list|(
name|next_frame
argument_list|,
name|IA64_PSR_REGNUM
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|psr
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|frame_unwind_register
argument_list|(
name|next_frame
argument_list|,
name|IA64_CFM_REGNUM
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|cfm
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|cache
operator|->
name|sof
operator|=
operator|(
name|cfm
operator|&
literal|0x7f
operator|)
expr_stmt|;
name|cache
operator|->
name|sol
operator|=
operator|(
name|cfm
operator|>>
literal|7
operator|)
operator|&
literal|0x7f
expr_stmt|;
name|cache
operator|->
name|sor
operator|=
operator|(
operator|(
name|cfm
operator|>>
literal|14
operator|)
operator|&
literal|0xf
operator|)
operator|*
literal|8
expr_stmt|;
name|cache
operator|->
name|cfm
operator|=
name|cfm
expr_stmt|;
name|cache
operator|->
name|pc
operator|=
name|frame_func_unwind
argument_list|(
name|next_frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|cache
operator|->
name|pc
operator|!=
literal|0
condition|)
name|examine_prologue
argument_list|(
name|cache
operator|->
name|pc
argument_list|,
name|frame_pc_unwind
argument_list|(
name|next_frame
argument_list|)
argument_list|,
name|next_frame
argument_list|,
name|cache
argument_list|)
expr_stmt|;
name|cache
operator|->
name|base
operator|=
name|cache
operator|->
name|saved_sp
operator|+
name|cache
operator|->
name|mem_stack_frame_size
expr_stmt|;
return|return
name|cache
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ia64_frame_this_id
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|void
modifier|*
modifier|*
name|this_cache
parameter_list|,
name|struct
name|frame_id
modifier|*
name|this_id
parameter_list|)
block|{
name|struct
name|ia64_frame_cache
modifier|*
name|cache
init|=
name|ia64_frame_cache
argument_list|(
name|next_frame
argument_list|,
name|this_cache
argument_list|)
decl_stmt|;
comment|/* This marks the outermost frame.  */
if|if
condition|(
name|cache
operator|->
name|base
operator|==
literal|0
condition|)
return|return;
operator|(
operator|*
name|this_id
operator|)
operator|=
name|frame_id_build_special
argument_list|(
name|cache
operator|->
name|base
argument_list|,
name|cache
operator|->
name|pc
argument_list|,
name|cache
operator|->
name|bsp
argument_list|)
expr_stmt|;
if|if
condition|(
name|gdbarch_debug
operator|>=
literal|1
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"regular frame id: code 0x%s, stack 0x%s, special 0x%s, next_frame %p\n"
argument_list|,
name|paddr_nz
argument_list|(
name|this_id
operator|->
name|code_addr
argument_list|)
argument_list|,
name|paddr_nz
argument_list|(
name|this_id
operator|->
name|stack_addr
argument_list|)
argument_list|,
name|paddr_nz
argument_list|(
name|cache
operator|->
name|bsp
argument_list|)
argument_list|,
name|next_frame
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ia64_frame_prev_register
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|void
modifier|*
modifier|*
name|this_cache
parameter_list|,
name|int
name|regnum
parameter_list|,
name|int
modifier|*
name|optimizedp
parameter_list|,
name|enum
name|lval_type
modifier|*
name|lvalp
parameter_list|,
name|CORE_ADDR
modifier|*
name|addrp
parameter_list|,
name|int
modifier|*
name|realnump
parameter_list|,
name|void
modifier|*
name|valuep
parameter_list|)
block|{
name|struct
name|ia64_frame_cache
modifier|*
name|cache
init|=
name|ia64_frame_cache
argument_list|(
name|next_frame
argument_list|,
name|this_cache
argument_list|)
decl_stmt|;
name|char
name|dummy_valp
index|[
name|MAX_REGISTER_SIZE
index|]
decl_stmt|;
name|char
name|buf
index|[
literal|8
index|]
decl_stmt|;
name|gdb_assert
argument_list|(
name|regnum
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target_has_registers
condition|)
name|error
argument_list|(
literal|"No registers."
argument_list|)
expr_stmt|;
operator|*
name|optimizedp
operator|=
literal|0
expr_stmt|;
operator|*
name|addrp
operator|=
literal|0
expr_stmt|;
operator|*
name|lvalp
operator|=
name|not_lval
expr_stmt|;
operator|*
name|realnump
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Rather than check each time if valuep is non-null, supply a dummy buffer      when valuep is not supplied.  */
if|if
condition|(
operator|!
name|valuep
condition|)
name|valuep
operator|=
name|dummy_valp
expr_stmt|;
name|memset
argument_list|(
name|valuep
argument_list|,
literal|0
argument_list|,
name|register_size
argument_list|(
name|current_gdbarch
argument_list|,
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|regnum
operator|==
name|SP_REGNUM
condition|)
block|{
comment|/* Handle SP values for all frames but the topmost. */
name|store_unsigned_integer
argument_list|(
name|valuep
argument_list|,
name|register_size
argument_list|(
name|current_gdbarch
argument_list|,
name|regnum
argument_list|)
argument_list|,
name|cache
operator|->
name|base
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|regnum
operator|==
name|IA64_BSP_REGNUM
condition|)
block|{
name|char
name|cfm_valuep
index|[
name|MAX_REGISTER_SIZE
index|]
decl_stmt|;
name|int
name|cfm_optim
decl_stmt|;
name|int
name|cfm_realnum
decl_stmt|;
name|enum
name|lval_type
name|cfm_lval
decl_stmt|;
name|CORE_ADDR
name|cfm_addr
decl_stmt|;
name|CORE_ADDR
name|bsp
decl_stmt|,
name|prev_cfm
decl_stmt|,
name|prev_bsp
decl_stmt|;
comment|/* We want to calculate the previous bsp as the end of the previous register stack frame. 	 This corresponds to what the hardware bsp register will be if we pop the frame 	 back which is why we might have been called.  We know the beginning of the current 	 frame is cache->bsp - cache->sof.  This value in the previous frame points to 	 the start of the output registers.  We can calculate the end of that frame by adding 	 the size of output (sof (size of frame) - sol (size of locals)).  */
name|ia64_frame_prev_register
argument_list|(
name|next_frame
argument_list|,
name|this_cache
argument_list|,
name|IA64_CFM_REGNUM
argument_list|,
operator|&
name|cfm_optim
argument_list|,
operator|&
name|cfm_lval
argument_list|,
operator|&
name|cfm_addr
argument_list|,
operator|&
name|cfm_realnum
argument_list|,
name|cfm_valuep
argument_list|)
expr_stmt|;
name|prev_cfm
operator|=
name|extract_unsigned_integer
argument_list|(
name|cfm_valuep
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|bsp
operator|=
name|rse_address_add
argument_list|(
name|cache
operator|->
name|bsp
argument_list|,
operator|-
operator|(
name|cache
operator|->
name|sof
operator|)
argument_list|)
expr_stmt|;
name|prev_bsp
operator|=
name|rse_address_add
argument_list|(
name|bsp
argument_list|,
operator|(
name|prev_cfm
operator|&
literal|0x7f
operator|)
operator|-
operator|(
operator|(
name|prev_cfm
operator|>>
literal|7
operator|)
operator|&
literal|0x7f
operator|)
argument_list|)
expr_stmt|;
name|store_unsigned_integer
argument_list|(
name|valuep
argument_list|,
name|register_size
argument_list|(
name|current_gdbarch
argument_list|,
name|regnum
argument_list|)
argument_list|,
name|prev_bsp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|regnum
operator|==
name|IA64_CFM_REGNUM
condition|)
block|{
name|CORE_ADDR
name|addr
init|=
name|cache
operator|->
name|saved_regs
index|[
name|IA64_CFM_REGNUM
index|]
decl_stmt|;
if|if
condition|(
name|addr
operator|!=
literal|0
condition|)
block|{
operator|*
name|lvalp
operator|=
name|lval_memory
expr_stmt|;
operator|*
name|addrp
operator|=
name|addr
expr_stmt|;
name|read_memory
argument_list|(
name|addr
argument_list|,
name|valuep
argument_list|,
name|register_size
argument_list|(
name|current_gdbarch
argument_list|,
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cache
operator|->
name|prev_cfm
condition|)
name|store_unsigned_integer
argument_list|(
name|valuep
argument_list|,
name|register_size
argument_list|(
name|current_gdbarch
argument_list|,
name|regnum
argument_list|)
argument_list|,
name|cache
operator|->
name|prev_cfm
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cache
operator|->
name|frameless
condition|)
block|{
name|CORE_ADDR
name|cfm
init|=
literal|0
decl_stmt|;
name|frame_unwind_register
argument_list|(
name|next_frame
argument_list|,
name|IA64_PFS_REGNUM
argument_list|,
name|valuep
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|regnum
operator|==
name|IA64_VFP_REGNUM
condition|)
block|{
comment|/* If the function in question uses an automatic register (r32-r127)          for the frame pointer, it'll be found by ia64_find_saved_register() 	 above.  If the function lacks one of these frame pointers, we can 	 still provide a value since we know the size of the frame.  */
name|CORE_ADDR
name|vfp
init|=
name|cache
operator|->
name|base
decl_stmt|;
name|store_unsigned_integer
argument_list|(
name|valuep
argument_list|,
name|register_size
argument_list|(
name|current_gdbarch
argument_list|,
name|IA64_VFP_REGNUM
argument_list|)
argument_list|,
name|vfp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|VP0_REGNUM
operator|<=
name|regnum
operator|&&
name|regnum
operator|<=
name|VP63_REGNUM
condition|)
block|{
name|char
name|pr_valuep
index|[
name|MAX_REGISTER_SIZE
index|]
decl_stmt|;
name|int
name|pr_optim
decl_stmt|;
name|int
name|pr_realnum
decl_stmt|;
name|enum
name|lval_type
name|pr_lval
decl_stmt|;
name|CORE_ADDR
name|pr_addr
decl_stmt|;
name|ULONGEST
name|prN_val
decl_stmt|;
name|ia64_frame_prev_register
argument_list|(
name|next_frame
argument_list|,
name|this_cache
argument_list|,
name|IA64_PR_REGNUM
argument_list|,
operator|&
name|pr_optim
argument_list|,
operator|&
name|pr_lval
argument_list|,
operator|&
name|pr_addr
argument_list|,
operator|&
name|pr_realnum
argument_list|,
name|pr_valuep
argument_list|)
expr_stmt|;
if|if
condition|(
name|VP16_REGNUM
operator|<=
name|regnum
operator|&&
name|regnum
operator|<=
name|VP63_REGNUM
condition|)
block|{
comment|/* Fetch predicate register rename base from current frame 	     marker for this frame.  */
name|int
name|rrb_pr
init|=
operator|(
name|cache
operator|->
name|cfm
operator|>>
literal|32
operator|)
operator|&
literal|0x3f
decl_stmt|;
comment|/* Adjust the register number to account for register rotation.  */
name|regnum
operator|=
name|VP16_REGNUM
operator|+
operator|(
operator|(
name|regnum
operator|-
name|VP16_REGNUM
operator|)
operator|+
name|rrb_pr
operator|)
operator|%
literal|48
expr_stmt|;
block|}
name|prN_val
operator|=
name|extract_bit_field
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|pr_valuep
argument_list|,
name|regnum
operator|-
name|VP0_REGNUM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|store_unsigned_integer
argument_list|(
name|valuep
argument_list|,
name|register_size
argument_list|(
name|current_gdbarch
argument_list|,
name|regnum
argument_list|)
argument_list|,
name|prN_val
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IA64_NAT0_REGNUM
operator|<=
name|regnum
operator|&&
name|regnum
operator|<=
name|IA64_NAT31_REGNUM
condition|)
block|{
name|char
name|unat_valuep
index|[
name|MAX_REGISTER_SIZE
index|]
decl_stmt|;
name|int
name|unat_optim
decl_stmt|;
name|int
name|unat_realnum
decl_stmt|;
name|enum
name|lval_type
name|unat_lval
decl_stmt|;
name|CORE_ADDR
name|unat_addr
decl_stmt|;
name|ULONGEST
name|unatN_val
decl_stmt|;
name|ia64_frame_prev_register
argument_list|(
name|next_frame
argument_list|,
name|this_cache
argument_list|,
name|IA64_UNAT_REGNUM
argument_list|,
operator|&
name|unat_optim
argument_list|,
operator|&
name|unat_lval
argument_list|,
operator|&
name|unat_addr
argument_list|,
operator|&
name|unat_realnum
argument_list|,
name|unat_valuep
argument_list|)
expr_stmt|;
name|unatN_val
operator|=
name|extract_bit_field
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|unat_valuep
argument_list|,
name|regnum
operator|-
name|IA64_NAT0_REGNUM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|store_unsigned_integer
argument_list|(
name|valuep
argument_list|,
name|register_size
argument_list|(
name|current_gdbarch
argument_list|,
name|regnum
argument_list|)
argument_list|,
name|unatN_val
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IA64_NAT32_REGNUM
operator|<=
name|regnum
operator|&&
name|regnum
operator|<=
name|IA64_NAT127_REGNUM
condition|)
block|{
name|int
name|natval
init|=
literal|0
decl_stmt|;
comment|/* Find address of general register corresponding to nat bit we're          interested in.  */
name|CORE_ADDR
name|gr_addr
decl_stmt|;
name|gr_addr
operator|=
name|cache
operator|->
name|saved_regs
index|[
name|regnum
operator|-
name|IA64_NAT0_REGNUM
operator|+
name|IA64_GR0_REGNUM
index|]
expr_stmt|;
if|if
condition|(
name|gr_addr
operator|!=
literal|0
condition|)
block|{
comment|/* Compute address of nat collection bits.  */
name|CORE_ADDR
name|nat_addr
init|=
name|gr_addr
operator||
literal|0x1f8
decl_stmt|;
name|CORE_ADDR
name|bsp
decl_stmt|;
name|CORE_ADDR
name|nat_collection
decl_stmt|;
name|int
name|nat_bit
decl_stmt|;
comment|/* If our nat collection address is bigger than bsp, we have to get 	     the nat collection from rnat.  Otherwise, we fetch the nat 	     collection from the computed address.  */
name|frame_unwind_register
argument_list|(
name|next_frame
argument_list|,
name|IA64_BSP_REGNUM
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|bsp
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|nat_addr
operator|>=
name|bsp
condition|)
block|{
name|frame_unwind_register
argument_list|(
name|next_frame
argument_list|,
name|IA64_RNAT_REGNUM
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|nat_collection
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
else|else
name|nat_collection
operator|=
name|read_memory_integer
argument_list|(
name|nat_addr
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|nat_bit
operator|=
operator|(
name|gr_addr
operator|>>
literal|3
operator|)
operator|&
literal|0x3f
expr_stmt|;
name|natval
operator|=
operator|(
name|nat_collection
operator|>>
name|nat_bit
operator|)
operator|&
literal|1
expr_stmt|;
block|}
name|store_unsigned_integer
argument_list|(
name|valuep
argument_list|,
name|register_size
argument_list|(
name|current_gdbarch
argument_list|,
name|regnum
argument_list|)
argument_list|,
name|natval
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|regnum
operator|==
name|IA64_IP_REGNUM
condition|)
block|{
name|CORE_ADDR
name|pc
init|=
literal|0
decl_stmt|;
name|CORE_ADDR
name|addr
init|=
name|cache
operator|->
name|saved_regs
index|[
name|IA64_VRAP_REGNUM
index|]
decl_stmt|;
if|if
condition|(
name|addr
operator|!=
literal|0
condition|)
block|{
operator|*
name|lvalp
operator|=
name|lval_memory
expr_stmt|;
operator|*
name|addrp
operator|=
name|addr
expr_stmt|;
name|read_memory
argument_list|(
name|addr
argument_list|,
name|buf
argument_list|,
name|register_size
argument_list|(
name|current_gdbarch
argument_list|,
name|IA64_IP_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
name|pc
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cache
operator|->
name|frameless
condition|)
block|{
name|frame_unwind_register
argument_list|(
name|next_frame
argument_list|,
name|IA64_BR0_REGNUM
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|pc
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
name|pc
operator|&=
operator|~
literal|0xf
expr_stmt|;
name|store_unsigned_integer
argument_list|(
name|valuep
argument_list|,
literal|8
argument_list|,
name|pc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|regnum
operator|==
name|IA64_PSR_REGNUM
condition|)
block|{
comment|/* We don't know how to get the complete previous PSR, but we need it for 	 the slot information when we unwind the pc (pc is formed of IP register 	 plus slot information from PSR).  To get the previous slot information,  	 we mask it off the return address.  */
name|ULONGEST
name|slot_num
init|=
literal|0
decl_stmt|;
name|CORE_ADDR
name|pc
init|=
literal|0
decl_stmt|;
name|CORE_ADDR
name|psr
init|=
literal|0
decl_stmt|;
name|CORE_ADDR
name|addr
init|=
name|cache
operator|->
name|saved_regs
index|[
name|IA64_VRAP_REGNUM
index|]
decl_stmt|;
name|frame_unwind_register
argument_list|(
name|next_frame
argument_list|,
name|IA64_PSR_REGNUM
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|psr
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|!=
literal|0
condition|)
block|{
operator|*
name|lvalp
operator|=
name|lval_memory
expr_stmt|;
operator|*
name|addrp
operator|=
name|addr
expr_stmt|;
name|read_memory
argument_list|(
name|addr
argument_list|,
name|buf
argument_list|,
name|register_size
argument_list|(
name|current_gdbarch
argument_list|,
name|IA64_IP_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
name|pc
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cache
operator|->
name|frameless
condition|)
block|{
name|CORE_ADDR
name|pc
decl_stmt|;
name|frame_unwind_register
argument_list|(
name|next_frame
argument_list|,
name|IA64_BR0_REGNUM
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|pc
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
name|psr
operator|&=
operator|~
operator|(
literal|3LL
operator|<<
literal|41
operator|)
expr_stmt|;
name|slot_num
operator|=
name|pc
operator|&
literal|0x3LL
expr_stmt|;
name|psr
operator||=
operator|(
name|CORE_ADDR
operator|)
name|slot_num
operator|<<
literal|41
expr_stmt|;
name|store_unsigned_integer
argument_list|(
name|valuep
argument_list|,
literal|8
argument_list|,
name|psr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|regnum
operator|==
name|IA64_BR0_REGNUM
condition|)
block|{
name|CORE_ADDR
name|br0
init|=
literal|0
decl_stmt|;
name|CORE_ADDR
name|addr
init|=
name|cache
operator|->
name|saved_regs
index|[
name|IA64_BR0_REGNUM
index|]
decl_stmt|;
if|if
condition|(
name|addr
operator|!=
literal|0
condition|)
block|{
operator|*
name|lvalp
operator|=
name|lval_memory
expr_stmt|;
operator|*
name|addrp
operator|=
name|addr
expr_stmt|;
name|read_memory
argument_list|(
name|addr
argument_list|,
name|buf
argument_list|,
name|register_size
argument_list|(
name|current_gdbarch
argument_list|,
name|IA64_BR0_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
name|br0
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
name|store_unsigned_integer
argument_list|(
name|valuep
argument_list|,
literal|8
argument_list|,
name|br0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|regnum
operator|>=
name|IA64_GR32_REGNUM
operator|&&
name|regnum
operator|<=
name|IA64_GR127_REGNUM
operator|)
operator|||
operator|(
name|regnum
operator|>=
name|V32_REGNUM
operator|&&
name|regnum
operator|<=
name|V127_REGNUM
operator|)
condition|)
block|{
name|CORE_ADDR
name|addr
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|regnum
operator|>=
name|V32_REGNUM
condition|)
name|regnum
operator|=
name|IA64_GR32_REGNUM
operator|+
operator|(
name|regnum
operator|-
name|V32_REGNUM
operator|)
expr_stmt|;
name|addr
operator|=
name|cache
operator|->
name|saved_regs
index|[
name|regnum
index|]
expr_stmt|;
if|if
condition|(
name|addr
operator|!=
literal|0
condition|)
block|{
operator|*
name|lvalp
operator|=
name|lval_memory
expr_stmt|;
operator|*
name|addrp
operator|=
name|addr
expr_stmt|;
name|read_memory
argument_list|(
name|addr
argument_list|,
name|valuep
argument_list|,
name|register_size
argument_list|(
name|current_gdbarch
argument_list|,
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cache
operator|->
name|frameless
condition|)
block|{
name|char
name|r_valuep
index|[
name|MAX_REGISTER_SIZE
index|]
decl_stmt|;
name|int
name|r_optim
decl_stmt|;
name|int
name|r_realnum
decl_stmt|;
name|enum
name|lval_type
name|r_lval
decl_stmt|;
name|CORE_ADDR
name|r_addr
decl_stmt|;
name|CORE_ADDR
name|prev_cfm
decl_stmt|,
name|prev_bsp
decl_stmt|,
name|prev_bof
decl_stmt|;
name|CORE_ADDR
name|addr
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|regnum
operator|>=
name|V32_REGNUM
condition|)
name|regnum
operator|=
name|IA64_GR32_REGNUM
operator|+
operator|(
name|regnum
operator|-
name|V32_REGNUM
operator|)
expr_stmt|;
name|ia64_frame_prev_register
argument_list|(
name|next_frame
argument_list|,
name|this_cache
argument_list|,
name|IA64_CFM_REGNUM
argument_list|,
operator|&
name|r_optim
argument_list|,
operator|&
name|r_lval
argument_list|,
operator|&
name|r_addr
argument_list|,
operator|&
name|r_realnum
argument_list|,
name|r_valuep
argument_list|)
expr_stmt|;
name|prev_cfm
operator|=
name|extract_unsigned_integer
argument_list|(
name|r_valuep
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|ia64_frame_prev_register
argument_list|(
name|next_frame
argument_list|,
name|this_cache
argument_list|,
name|IA64_BSP_REGNUM
argument_list|,
operator|&
name|r_optim
argument_list|,
operator|&
name|r_lval
argument_list|,
operator|&
name|r_addr
argument_list|,
operator|&
name|r_realnum
argument_list|,
name|r_valuep
argument_list|)
expr_stmt|;
name|prev_bsp
operator|=
name|extract_unsigned_integer
argument_list|(
name|r_valuep
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|prev_bof
operator|=
name|rse_address_add
argument_list|(
name|prev_bsp
argument_list|,
operator|-
operator|(
name|prev_cfm
operator|&
literal|0x7f
operator|)
argument_list|)
expr_stmt|;
name|addr
operator|=
name|rse_address_add
argument_list|(
name|prev_bof
argument_list|,
operator|(
name|regnum
operator|-
name|IA64_GR32_REGNUM
operator|)
argument_list|)
expr_stmt|;
operator|*
name|lvalp
operator|=
name|lval_memory
expr_stmt|;
operator|*
name|addrp
operator|=
name|addr
expr_stmt|;
name|read_memory
argument_list|(
name|addr
argument_list|,
name|valuep
argument_list|,
name|register_size
argument_list|(
name|current_gdbarch
argument_list|,
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|CORE_ADDR
name|addr
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|IA64_FR32_REGNUM
operator|<=
name|regnum
operator|&&
name|regnum
operator|<=
name|IA64_FR127_REGNUM
condition|)
block|{
comment|/* Fetch floating point register rename base from current 	     frame marker for this frame.  */
name|int
name|rrb_fr
init|=
operator|(
name|cache
operator|->
name|cfm
operator|>>
literal|25
operator|)
operator|&
literal|0x7f
decl_stmt|;
comment|/* Adjust the floating point register number to account for 	     register rotation.  */
name|regnum
operator|=
name|IA64_FR32_REGNUM
operator|+
operator|(
operator|(
name|regnum
operator|-
name|IA64_FR32_REGNUM
operator|)
operator|+
name|rrb_fr
operator|)
operator|%
literal|96
expr_stmt|;
block|}
comment|/* If we have stored a memory address, access the register.  */
name|addr
operator|=
name|cache
operator|->
name|saved_regs
index|[
name|regnum
index|]
expr_stmt|;
if|if
condition|(
name|addr
operator|!=
literal|0
condition|)
block|{
operator|*
name|lvalp
operator|=
name|lval_memory
expr_stmt|;
operator|*
name|addrp
operator|=
name|addr
expr_stmt|;
name|read_memory
argument_list|(
name|addr
argument_list|,
name|valuep
argument_list|,
name|register_size
argument_list|(
name|current_gdbarch
argument_list|,
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Otherwise, punt and get the current value of the register.  */
else|else
name|frame_unwind_register
argument_list|(
name|next_frame
argument_list|,
name|regnum
argument_list|,
name|valuep
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gdbarch_debug
operator|>=
literal|1
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"regular prev register<%d><%s> is 0x%s\n"
argument_list|,
name|regnum
argument_list|,
operator|(
operator|(
operator|(
name|unsigned
operator|)
name|regnum
operator|<=
name|IA64_NAT127_REGNUM
operator|)
condition|?
name|ia64_register_names
index|[
name|regnum
index|]
else|:
literal|"r??"
operator|)
argument_list|,
name|paddr_nz
argument_list|(
name|extract_unsigned_integer
argument_list|(
name|valuep
argument_list|,
literal|8
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|frame_unwind
name|ia64_frame_unwind
init|=
block|{
name|NORMAL_FRAME
block|,
operator|&
name|ia64_frame_this_id
block|,
operator|&
name|ia64_frame_prev_register
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|const
name|struct
name|frame_unwind
modifier|*
name|ia64_frame_sniffer
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|)
block|{
return|return
operator|&
name|ia64_frame_unwind
return|;
block|}
end_function

begin_comment
comment|/* Signal trampolines.  */
end_comment

begin_function
specifier|static
name|void
name|ia64_sigtramp_frame_init_saved_regs
parameter_list|(
name|struct
name|ia64_frame_cache
modifier|*
name|cache
parameter_list|)
block|{
if|if
condition|(
name|SIGCONTEXT_REGISTER_ADDRESS
condition|)
block|{
name|int
name|regno
decl_stmt|;
name|cache
operator|->
name|saved_regs
index|[
name|IA64_VRAP_REGNUM
index|]
operator|=
name|SIGCONTEXT_REGISTER_ADDRESS
argument_list|(
name|cache
operator|->
name|base
argument_list|,
name|IA64_IP_REGNUM
argument_list|)
expr_stmt|;
name|cache
operator|->
name|saved_regs
index|[
name|IA64_CFM_REGNUM
index|]
operator|=
name|SIGCONTEXT_REGISTER_ADDRESS
argument_list|(
name|cache
operator|->
name|base
argument_list|,
name|IA64_CFM_REGNUM
argument_list|)
expr_stmt|;
name|cache
operator|->
name|saved_regs
index|[
name|IA64_PSR_REGNUM
index|]
operator|=
name|SIGCONTEXT_REGISTER_ADDRESS
argument_list|(
name|cache
operator|->
name|base
argument_list|,
name|IA64_PSR_REGNUM
argument_list|)
expr_stmt|;
name|cache
operator|->
name|saved_regs
index|[
name|IA64_BSP_REGNUM
index|]
operator|=
name|SIGCONTEXT_REGISTER_ADDRESS
argument_list|(
name|cache
operator|->
name|base
argument_list|,
name|IA64_BSP_REGNUM
argument_list|)
expr_stmt|;
name|cache
operator|->
name|saved_regs
index|[
name|IA64_RNAT_REGNUM
index|]
operator|=
name|SIGCONTEXT_REGISTER_ADDRESS
argument_list|(
name|cache
operator|->
name|base
argument_list|,
name|IA64_RNAT_REGNUM
argument_list|)
expr_stmt|;
name|cache
operator|->
name|saved_regs
index|[
name|IA64_CCV_REGNUM
index|]
operator|=
name|SIGCONTEXT_REGISTER_ADDRESS
argument_list|(
name|cache
operator|->
name|base
argument_list|,
name|IA64_CCV_REGNUM
argument_list|)
expr_stmt|;
name|cache
operator|->
name|saved_regs
index|[
name|IA64_UNAT_REGNUM
index|]
operator|=
name|SIGCONTEXT_REGISTER_ADDRESS
argument_list|(
name|cache
operator|->
name|base
argument_list|,
name|IA64_UNAT_REGNUM
argument_list|)
expr_stmt|;
name|cache
operator|->
name|saved_regs
index|[
name|IA64_FPSR_REGNUM
index|]
operator|=
name|SIGCONTEXT_REGISTER_ADDRESS
argument_list|(
name|cache
operator|->
name|base
argument_list|,
name|IA64_FPSR_REGNUM
argument_list|)
expr_stmt|;
name|cache
operator|->
name|saved_regs
index|[
name|IA64_PFS_REGNUM
index|]
operator|=
name|SIGCONTEXT_REGISTER_ADDRESS
argument_list|(
name|cache
operator|->
name|base
argument_list|,
name|IA64_PFS_REGNUM
argument_list|)
expr_stmt|;
name|cache
operator|->
name|saved_regs
index|[
name|IA64_LC_REGNUM
index|]
operator|=
name|SIGCONTEXT_REGISTER_ADDRESS
argument_list|(
name|cache
operator|->
name|base
argument_list|,
name|IA64_LC_REGNUM
argument_list|)
expr_stmt|;
for|for
control|(
name|regno
operator|=
name|IA64_GR1_REGNUM
init|;
name|regno
operator|<=
name|IA64_GR31_REGNUM
condition|;
name|regno
operator|++
control|)
name|cache
operator|->
name|saved_regs
index|[
name|regno
index|]
operator|=
name|SIGCONTEXT_REGISTER_ADDRESS
argument_list|(
name|cache
operator|->
name|base
argument_list|,
name|regno
argument_list|)
expr_stmt|;
for|for
control|(
name|regno
operator|=
name|IA64_BR0_REGNUM
init|;
name|regno
operator|<=
name|IA64_BR7_REGNUM
condition|;
name|regno
operator|++
control|)
name|cache
operator|->
name|saved_regs
index|[
name|regno
index|]
operator|=
name|SIGCONTEXT_REGISTER_ADDRESS
argument_list|(
name|cache
operator|->
name|base
argument_list|,
name|regno
argument_list|)
expr_stmt|;
for|for
control|(
name|regno
operator|=
name|IA64_FR2_REGNUM
init|;
name|regno
operator|<=
name|IA64_FR31_REGNUM
condition|;
name|regno
operator|++
control|)
name|cache
operator|->
name|saved_regs
index|[
name|regno
index|]
operator|=
name|SIGCONTEXT_REGISTER_ADDRESS
argument_list|(
name|cache
operator|->
name|base
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|ia64_frame_cache
modifier|*
name|ia64_sigtramp_frame_cache
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|void
modifier|*
modifier|*
name|this_cache
parameter_list|)
block|{
name|struct
name|ia64_frame_cache
modifier|*
name|cache
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|char
name|buf
index|[
literal|8
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|*
name|this_cache
condition|)
return|return
operator|*
name|this_cache
return|;
name|cache
operator|=
name|ia64_alloc_frame_cache
argument_list|()
expr_stmt|;
name|frame_unwind_register
argument_list|(
name|next_frame
argument_list|,
name|sp_regnum
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* Note that frame size is hard-coded below.  We cannot calculate it      via prologue examination.  */
name|cache
operator|->
name|base
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|8
argument_list|)
operator|+
literal|16
expr_stmt|;
name|frame_unwind_register
argument_list|(
name|next_frame
argument_list|,
name|IA64_BSP_REGNUM
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|cache
operator|->
name|bsp
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|frame_unwind_register
argument_list|(
name|next_frame
argument_list|,
name|IA64_CFM_REGNUM
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|cache
operator|->
name|cfm
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|cache
operator|->
name|sof
operator|=
name|cache
operator|->
name|cfm
operator|&
literal|0x7f
expr_stmt|;
name|ia64_sigtramp_frame_init_saved_regs
argument_list|(
name|cache
argument_list|)
expr_stmt|;
operator|*
name|this_cache
operator|=
name|cache
expr_stmt|;
return|return
name|cache
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ia64_sigtramp_frame_this_id
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|void
modifier|*
modifier|*
name|this_cache
parameter_list|,
name|struct
name|frame_id
modifier|*
name|this_id
parameter_list|)
block|{
name|struct
name|ia64_frame_cache
modifier|*
name|cache
init|=
name|ia64_sigtramp_frame_cache
argument_list|(
name|next_frame
argument_list|,
name|this_cache
argument_list|)
decl_stmt|;
operator|(
operator|*
name|this_id
operator|)
operator|=
name|frame_id_build_special
argument_list|(
name|cache
operator|->
name|base
argument_list|,
name|frame_pc_unwind
argument_list|(
name|next_frame
argument_list|)
argument_list|,
name|cache
operator|->
name|bsp
argument_list|)
expr_stmt|;
if|if
condition|(
name|gdbarch_debug
operator|>=
literal|1
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"sigtramp frame id: code 0x%s, stack 0x%s, special 0x%s, next_frame %p\n"
argument_list|,
name|paddr_nz
argument_list|(
name|this_id
operator|->
name|code_addr
argument_list|)
argument_list|,
name|paddr_nz
argument_list|(
name|this_id
operator|->
name|stack_addr
argument_list|)
argument_list|,
name|paddr_nz
argument_list|(
name|cache
operator|->
name|bsp
argument_list|)
argument_list|,
name|next_frame
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ia64_sigtramp_frame_prev_register
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|void
modifier|*
modifier|*
name|this_cache
parameter_list|,
name|int
name|regnum
parameter_list|,
name|int
modifier|*
name|optimizedp
parameter_list|,
name|enum
name|lval_type
modifier|*
name|lvalp
parameter_list|,
name|CORE_ADDR
modifier|*
name|addrp
parameter_list|,
name|int
modifier|*
name|realnump
parameter_list|,
name|void
modifier|*
name|valuep
parameter_list|)
block|{
name|char
name|dummy_valp
index|[
name|MAX_REGISTER_SIZE
index|]
decl_stmt|;
name|char
name|buf
index|[
name|MAX_REGISTER_SIZE
index|]
decl_stmt|;
name|struct
name|ia64_frame_cache
modifier|*
name|cache
init|=
name|ia64_sigtramp_frame_cache
argument_list|(
name|next_frame
argument_list|,
name|this_cache
argument_list|)
decl_stmt|;
name|gdb_assert
argument_list|(
name|regnum
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target_has_registers
condition|)
name|error
argument_list|(
literal|"No registers."
argument_list|)
expr_stmt|;
operator|*
name|optimizedp
operator|=
literal|0
expr_stmt|;
operator|*
name|addrp
operator|=
literal|0
expr_stmt|;
operator|*
name|lvalp
operator|=
name|not_lval
expr_stmt|;
operator|*
name|realnump
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Rather than check each time if valuep is non-null, supply a dummy buffer      when valuep is not supplied.  */
if|if
condition|(
operator|!
name|valuep
condition|)
name|valuep
operator|=
name|dummy_valp
expr_stmt|;
name|memset
argument_list|(
name|valuep
argument_list|,
literal|0
argument_list|,
name|register_size
argument_list|(
name|current_gdbarch
argument_list|,
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|regnum
operator|==
name|IA64_IP_REGNUM
condition|)
block|{
name|CORE_ADDR
name|pc
init|=
literal|0
decl_stmt|;
name|CORE_ADDR
name|addr
init|=
name|cache
operator|->
name|saved_regs
index|[
name|IA64_VRAP_REGNUM
index|]
decl_stmt|;
if|if
condition|(
name|addr
operator|!=
literal|0
condition|)
block|{
operator|*
name|lvalp
operator|=
name|lval_memory
expr_stmt|;
operator|*
name|addrp
operator|=
name|addr
expr_stmt|;
name|read_memory
argument_list|(
name|addr
argument_list|,
name|buf
argument_list|,
name|register_size
argument_list|(
name|current_gdbarch
argument_list|,
name|IA64_IP_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
name|pc
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
name|pc
operator|&=
operator|~
literal|0xf
expr_stmt|;
name|store_unsigned_integer
argument_list|(
name|valuep
argument_list|,
literal|8
argument_list|,
name|pc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|regnum
operator|>=
name|IA64_GR32_REGNUM
operator|&&
name|regnum
operator|<=
name|IA64_GR127_REGNUM
operator|)
operator|||
operator|(
name|regnum
operator|>=
name|V32_REGNUM
operator|&&
name|regnum
operator|<=
name|V127_REGNUM
operator|)
condition|)
block|{
name|CORE_ADDR
name|addr
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|regnum
operator|>=
name|V32_REGNUM
condition|)
name|regnum
operator|=
name|IA64_GR32_REGNUM
operator|+
operator|(
name|regnum
operator|-
name|V32_REGNUM
operator|)
expr_stmt|;
name|addr
operator|=
name|cache
operator|->
name|saved_regs
index|[
name|regnum
index|]
expr_stmt|;
if|if
condition|(
name|addr
operator|!=
literal|0
condition|)
block|{
operator|*
name|lvalp
operator|=
name|lval_memory
expr_stmt|;
operator|*
name|addrp
operator|=
name|addr
expr_stmt|;
name|read_memory
argument_list|(
name|addr
argument_list|,
name|valuep
argument_list|,
name|register_size
argument_list|(
name|current_gdbarch
argument_list|,
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* All other registers not listed above.  */
name|CORE_ADDR
name|addr
init|=
name|cache
operator|->
name|saved_regs
index|[
name|regnum
index|]
decl_stmt|;
if|if
condition|(
name|addr
operator|!=
literal|0
condition|)
block|{
operator|*
name|lvalp
operator|=
name|lval_memory
expr_stmt|;
operator|*
name|addrp
operator|=
name|addr
expr_stmt|;
name|read_memory
argument_list|(
name|addr
argument_list|,
name|valuep
argument_list|,
name|register_size
argument_list|(
name|current_gdbarch
argument_list|,
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|gdbarch_debug
operator|>=
literal|1
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"sigtramp prev register<%s> is 0x%s\n"
argument_list|,
operator|(
operator|(
operator|(
name|unsigned
operator|)
name|regnum
operator|<=
name|IA64_NAT127_REGNUM
operator|)
condition|?
name|ia64_register_names
index|[
name|regnum
index|]
else|:
literal|"r??"
operator|)
argument_list|,
name|paddr_nz
argument_list|(
name|extract_unsigned_integer
argument_list|(
name|valuep
argument_list|,
literal|8
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|frame_unwind
name|ia64_sigtramp_frame_unwind
init|=
block|{
name|SIGTRAMP_FRAME
block|,
name|ia64_sigtramp_frame_this_id
block|,
name|ia64_sigtramp_frame_prev_register
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|const
name|struct
name|frame_unwind
modifier|*
name|ia64_sigtramp_frame_sniffer
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|CORE_ADDR
name|pc
init|=
name|frame_pc_unwind
argument_list|(
name|next_frame
argument_list|)
decl_stmt|;
name|find_pc_partial_function
argument_list|(
name|pc
argument_list|,
operator|&
name|name
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|PC_IN_SIGTRAMP
argument_list|(
name|pc
argument_list|,
name|name
argument_list|)
condition|)
return|return
operator|&
name|ia64_sigtramp_frame_unwind
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|CORE_ADDR
name|ia64_frame_base_address
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|void
modifier|*
modifier|*
name|this_cache
parameter_list|)
block|{
name|struct
name|ia64_frame_cache
modifier|*
name|cache
init|=
name|ia64_frame_cache
argument_list|(
name|next_frame
argument_list|,
name|this_cache
argument_list|)
decl_stmt|;
return|return
name|cache
operator|->
name|base
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|frame_base
name|ia64_frame_base
init|=
block|{
operator|&
name|ia64_frame_unwind
block|,
name|ia64_frame_base_address
block|,
name|ia64_frame_base_address
block|,
name|ia64_frame_base_address
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LIBUNWIND_IA64_H
end_ifdef

begin_struct
struct|struct
name|ia64_unwind_table_entry
block|{
name|unw_word_t
name|start_offset
decl_stmt|;
name|unw_word_t
name|end_offset
decl_stmt|;
name|unw_word_t
name|info_offset
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|__inline__
name|uint64_t
name|ia64_rse_slot_num
parameter_list|(
name|uint64_t
name|addr
parameter_list|)
block|{
return|return
operator|(
name|addr
operator|>>
literal|3
operator|)
operator|&
literal|0x3f
return|;
block|}
end_function

begin_comment
comment|/* Skip over a designated number of registers in the backing    store, remembering every 64th position is for NAT.  */
end_comment

begin_function
specifier|static
name|__inline__
name|uint64_t
name|ia64_rse_skip_regs
parameter_list|(
name|uint64_t
name|addr
parameter_list|,
name|long
name|num_regs
parameter_list|)
block|{
name|long
name|delta
init|=
name|ia64_rse_slot_num
argument_list|(
name|addr
argument_list|)
operator|+
name|num_regs
decl_stmt|;
if|if
condition|(
name|num_regs
operator|<
literal|0
condition|)
name|delta
operator|-=
literal|0x3e
expr_stmt|;
return|return
name|addr
operator|+
operator|(
operator|(
name|num_regs
operator|+
name|delta
operator|/
literal|0x3f
operator|)
operator|<<
literal|3
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Gdb libunwind-frame callback function to convert from an ia64 gdb register     number to a libunwind register number.  */
end_comment

begin_function
specifier|static
name|int
name|ia64_gdb2uw_regnum
parameter_list|(
name|int
name|regnum
parameter_list|)
block|{
if|if
condition|(
name|regnum
operator|==
name|sp_regnum
condition|)
return|return
name|UNW_IA64_SP
return|;
elseif|else
if|if
condition|(
name|regnum
operator|==
name|IA64_BSP_REGNUM
condition|)
return|return
name|UNW_IA64_BSP
return|;
elseif|else
if|if
condition|(
call|(
name|unsigned
call|)
argument_list|(
name|regnum
operator|-
name|IA64_GR0_REGNUM
argument_list|)
operator|<
literal|128
condition|)
return|return
name|UNW_IA64_GR
operator|+
operator|(
name|regnum
operator|-
name|IA64_GR0_REGNUM
operator|)
return|;
elseif|else
if|if
condition|(
call|(
name|unsigned
call|)
argument_list|(
name|regnum
operator|-
name|V32_REGNUM
argument_list|)
operator|<
literal|95
condition|)
return|return
name|UNW_IA64_GR
operator|+
literal|32
operator|+
operator|(
name|regnum
operator|-
name|V32_REGNUM
operator|)
return|;
elseif|else
if|if
condition|(
call|(
name|unsigned
call|)
argument_list|(
name|regnum
operator|-
name|IA64_FR0_REGNUM
argument_list|)
operator|<
literal|128
condition|)
return|return
name|UNW_IA64_FR
operator|+
operator|(
name|regnum
operator|-
name|IA64_FR0_REGNUM
operator|)
return|;
elseif|else
if|if
condition|(
call|(
name|unsigned
call|)
argument_list|(
name|regnum
operator|-
name|IA64_PR0_REGNUM
argument_list|)
operator|<
literal|64
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
call|(
name|unsigned
call|)
argument_list|(
name|regnum
operator|-
name|IA64_BR0_REGNUM
argument_list|)
operator|<
literal|8
condition|)
return|return
name|UNW_IA64_BR
operator|+
operator|(
name|regnum
operator|-
name|IA64_BR0_REGNUM
operator|)
return|;
elseif|else
if|if
condition|(
name|regnum
operator|==
name|IA64_PR_REGNUM
condition|)
return|return
name|UNW_IA64_PR
return|;
elseif|else
if|if
condition|(
name|regnum
operator|==
name|IA64_IP_REGNUM
condition|)
return|return
name|UNW_REG_IP
return|;
elseif|else
if|if
condition|(
name|regnum
operator|==
name|IA64_CFM_REGNUM
condition|)
return|return
name|UNW_IA64_CFM
return|;
elseif|else
if|if
condition|(
call|(
name|unsigned
call|)
argument_list|(
name|regnum
operator|-
name|IA64_AR0_REGNUM
argument_list|)
operator|<
literal|128
condition|)
return|return
name|UNW_IA64_AR
operator|+
operator|(
name|regnum
operator|-
name|IA64_AR0_REGNUM
operator|)
return|;
elseif|else
if|if
condition|(
call|(
name|unsigned
call|)
argument_list|(
name|regnum
operator|-
name|IA64_NAT0_REGNUM
argument_list|)
operator|<
literal|128
condition|)
return|return
name|UNW_IA64_NAT
operator|+
operator|(
name|regnum
operator|-
name|IA64_NAT0_REGNUM
operator|)
return|;
else|else
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Gdb libunwind-frame callback function to convert from a libunwind register     number to a ia64 gdb register number.  */
end_comment

begin_function
specifier|static
name|int
name|ia64_uw2gdb_regnum
parameter_list|(
name|int
name|uw_regnum
parameter_list|)
block|{
if|if
condition|(
name|uw_regnum
operator|==
name|UNW_IA64_SP
condition|)
return|return
name|sp_regnum
return|;
elseif|else
if|if
condition|(
name|uw_regnum
operator|==
name|UNW_IA64_BSP
condition|)
return|return
name|IA64_BSP_REGNUM
return|;
elseif|else
if|if
condition|(
call|(
name|unsigned
call|)
argument_list|(
name|uw_regnum
operator|-
name|UNW_IA64_GR
argument_list|)
operator|<
literal|32
condition|)
return|return
name|IA64_GR0_REGNUM
operator|+
operator|(
name|uw_regnum
operator|-
name|UNW_IA64_GR
operator|)
return|;
elseif|else
if|if
condition|(
call|(
name|unsigned
call|)
argument_list|(
name|uw_regnum
operator|-
name|UNW_IA64_GR
argument_list|)
operator|<
literal|128
condition|)
return|return
name|V32_REGNUM
operator|+
operator|(
name|uw_regnum
operator|-
operator|(
name|IA64_GR0_REGNUM
operator|+
literal|32
operator|)
operator|)
return|;
elseif|else
if|if
condition|(
call|(
name|unsigned
call|)
argument_list|(
name|uw_regnum
operator|-
name|UNW_IA64_FR
argument_list|)
operator|<
literal|128
condition|)
return|return
name|IA64_FR0_REGNUM
operator|+
operator|(
name|uw_regnum
operator|-
name|UNW_IA64_FR
operator|)
return|;
elseif|else
if|if
condition|(
call|(
name|unsigned
call|)
argument_list|(
name|uw_regnum
operator|-
name|UNW_IA64_BR
argument_list|)
operator|<
literal|8
condition|)
return|return
name|IA64_BR0_REGNUM
operator|+
operator|(
name|uw_regnum
operator|-
name|UNW_IA64_BR
operator|)
return|;
elseif|else
if|if
condition|(
name|uw_regnum
operator|==
name|UNW_IA64_PR
condition|)
return|return
name|IA64_PR_REGNUM
return|;
elseif|else
if|if
condition|(
name|uw_regnum
operator|==
name|UNW_REG_IP
condition|)
return|return
name|IA64_IP_REGNUM
return|;
elseif|else
if|if
condition|(
name|uw_regnum
operator|==
name|UNW_IA64_CFM
condition|)
return|return
name|IA64_CFM_REGNUM
return|;
elseif|else
if|if
condition|(
call|(
name|unsigned
call|)
argument_list|(
name|uw_regnum
operator|-
name|UNW_IA64_AR
argument_list|)
operator|<
literal|128
condition|)
return|return
name|IA64_AR0_REGNUM
operator|+
operator|(
name|uw_regnum
operator|-
name|UNW_IA64_AR
operator|)
return|;
elseif|else
if|if
condition|(
call|(
name|unsigned
call|)
argument_list|(
name|uw_regnum
operator|-
name|UNW_IA64_NAT
argument_list|)
operator|<
literal|128
condition|)
return|return
name|IA64_NAT0_REGNUM
operator|+
operator|(
name|uw_regnum
operator|-
name|UNW_IA64_NAT
operator|)
return|;
else|else
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Gdb libunwind-frame callback function to reveal if register is a float     register or not.  */
end_comment

begin_function
specifier|static
name|int
name|ia64_is_fpreg
parameter_list|(
name|int
name|uw_regnum
parameter_list|)
block|{
return|return
name|unw_is_fpreg
argument_list|(
name|uw_regnum
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Libunwind callback accessor function for general registers.  */
end_comment

begin_function
specifier|static
name|int
name|ia64_access_reg
parameter_list|(
name|unw_addr_space_t
name|as
parameter_list|,
name|unw_regnum_t
name|uw_regnum
parameter_list|,
name|unw_word_t
modifier|*
name|val
parameter_list|,
name|int
name|write
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|regnum
init|=
name|ia64_uw2gdb_regnum
argument_list|(
name|uw_regnum
argument_list|)
decl_stmt|;
name|unw_word_t
name|bsp
decl_stmt|,
name|sof
decl_stmt|,
name|sol
decl_stmt|,
name|cfm
decl_stmt|,
name|psr
decl_stmt|,
name|ip
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|next_frame
init|=
name|arg
decl_stmt|;
name|long
name|new_sof
decl_stmt|,
name|old_sof
decl_stmt|;
name|char
name|buf
index|[
name|MAX_REGISTER_SIZE
index|]
decl_stmt|;
if|if
condition|(
name|write
condition|)
block|{
if|if
condition|(
name|regnum
operator|<
literal|0
condition|)
comment|/* ignore writes to pseudo-registers such as UNW_IA64_PROC_STARTI.  */
return|return
literal|0
return|;
switch|switch
condition|(
name|uw_regnum
condition|)
block|{
case|case
name|UNW_REG_IP
case|:
name|ia64_write_pc
argument_list|(
operator|*
name|val
argument_list|,
name|inferior_ptid
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNW_IA64_AR_BSPSTORE
case|:
name|write_register
argument_list|(
name|IA64_BSP_REGNUM
argument_list|,
operator|*
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNW_IA64_AR_BSP
case|:
case|case
name|UNW_IA64_BSP
case|:
comment|/* Account for the fact that ptrace() expects bsp to point 	     after the current register frame.  */
name|cfm
operator|=
name|read_register
argument_list|(
name|IA64_CFM_REGNUM
argument_list|)
expr_stmt|;
name|sof
operator|=
operator|(
name|cfm
operator|&
literal|0x7f
operator|)
expr_stmt|;
name|bsp
operator|=
name|ia64_rse_skip_regs
argument_list|(
operator|*
name|val
argument_list|,
name|sof
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|IA64_BSP_REGNUM
argument_list|,
name|bsp
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNW_IA64_CFM
case|:
comment|/* If we change CFM, we need to adjust ptrace's notion of 	     bsp accordingly, so that the real bsp remains 	     unchanged.  */
name|bsp
operator|=
name|read_register
argument_list|(
name|IA64_BSP_REGNUM
argument_list|)
expr_stmt|;
name|cfm
operator|=
name|read_register
argument_list|(
name|IA64_CFM_REGNUM
argument_list|)
expr_stmt|;
name|old_sof
operator|=
operator|(
name|cfm
operator|&
literal|0x7f
operator|)
expr_stmt|;
name|new_sof
operator|=
operator|(
operator|*
name|val
operator|&
literal|0x7f
operator|)
expr_stmt|;
if|if
condition|(
name|old_sof
operator|!=
name|new_sof
condition|)
block|{
name|bsp
operator|=
name|ia64_rse_skip_regs
argument_list|(
name|bsp
argument_list|,
operator|-
name|old_sof
operator|+
name|new_sof
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|IA64_BSP_REGNUM
argument_list|,
name|bsp
argument_list|)
expr_stmt|;
block|}
name|write_register
argument_list|(
name|IA64_CFM_REGNUM
argument_list|,
operator|*
name|val
argument_list|)
expr_stmt|;
break|break;
default|default:
name|write_register
argument_list|(
name|regnum
argument_list|,
operator|*
name|val
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|gdbarch_debug
operator|>=
literal|1
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"  access_reg: to cache: %4s=0x%s\n"
argument_list|,
operator|(
operator|(
operator|(
name|unsigned
operator|)
name|regnum
operator|<=
name|IA64_NAT127_REGNUM
operator|)
condition|?
name|ia64_register_names
index|[
name|regnum
index|]
else|:
literal|"r??"
operator|)
argument_list|,
name|paddr_nz
argument_list|(
operator|*
name|val
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|uw_regnum
condition|)
block|{
case|case
name|UNW_REG_IP
case|:
comment|/* Libunwind expects to see the pc value which means the slot number 	     from the psr must be merged with the ip word address.  */
name|frame_unwind_register
argument_list|(
name|next_frame
argument_list|,
name|IA64_IP_REGNUM
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|ip
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|frame_unwind_register
argument_list|(
name|next_frame
argument_list|,
name|IA64_PSR_REGNUM
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|psr
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
operator|*
name|val
operator|=
name|ip
operator||
operator|(
operator|(
name|psr
operator|>>
literal|41
operator|)
operator|&
literal|0x3
operator|)
expr_stmt|;
break|break;
case|case
name|UNW_IA64_AR_BSP
case|:
comment|/* Libunwind expects to see the beginning of the current register 	     frame so we must account for the fact that ptrace() will return a value 	     for bsp that points *after* the current register frame.  */
name|frame_unwind_register
argument_list|(
name|next_frame
argument_list|,
name|IA64_BSP_REGNUM
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|bsp
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|frame_unwind_register
argument_list|(
name|next_frame
argument_list|,
name|IA64_CFM_REGNUM
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|cfm
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|sof
operator|=
operator|(
name|cfm
operator|&
literal|0x7f
operator|)
expr_stmt|;
operator|*
name|val
operator|=
name|ia64_rse_skip_regs
argument_list|(
name|bsp
argument_list|,
operator|-
name|sof
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNW_IA64_AR_BSPSTORE
case|:
comment|/* Libunwind wants bspstore to be after the current register frame. 	     This is what ptrace() and gdb treats as the regular bsp value.  */
name|frame_unwind_register
argument_list|(
name|next_frame
argument_list|,
name|IA64_BSP_REGNUM
argument_list|,
name|buf
argument_list|)
expr_stmt|;
operator|*
name|val
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* For all other registers, just unwind the value directly.  */
name|frame_unwind_register
argument_list|(
name|next_frame
argument_list|,
name|regnum
argument_list|,
name|buf
argument_list|)
expr_stmt|;
operator|*
name|val
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|gdbarch_debug
operator|>=
literal|1
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"  access_reg: from cache: %4s=0x%s\n"
argument_list|,
operator|(
operator|(
operator|(
name|unsigned
operator|)
name|regnum
operator|<=
name|IA64_NAT127_REGNUM
operator|)
condition|?
name|ia64_register_names
index|[
name|regnum
index|]
else|:
literal|"r??"
operator|)
argument_list|,
name|paddr_nz
argument_list|(
operator|*
name|val
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Libunwind callback accessor function for floating-point registers.  */
end_comment

begin_function
specifier|static
name|int
name|ia64_access_fpreg
parameter_list|(
name|unw_addr_space_t
name|as
parameter_list|,
name|unw_regnum_t
name|uw_regnum
parameter_list|,
name|unw_fpreg_t
modifier|*
name|val
parameter_list|,
name|int
name|write
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|regnum
init|=
name|ia64_uw2gdb_regnum
argument_list|(
name|uw_regnum
argument_list|)
decl_stmt|;
if|if
condition|(
name|write
condition|)
name|regcache_cooked_write
argument_list|(
name|current_regcache
argument_list|,
name|regnum
argument_list|,
operator|(
name|char
operator|*
operator|)
name|val
argument_list|)
expr_stmt|;
else|else
name|regcache_cooked_read
argument_list|(
name|current_regcache
argument_list|,
name|regnum
argument_list|,
operator|(
name|char
operator|*
operator|)
name|val
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Libunwind callback accessor function for accessing memory.  */
end_comment

begin_function
specifier|static
name|int
name|ia64_access_mem
parameter_list|(
name|unw_addr_space_t
name|as
parameter_list|,
name|unw_word_t
name|addr
parameter_list|,
name|unw_word_t
modifier|*
name|val
parameter_list|,
name|int
name|write
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
comment|/* XXX do we need to normalize byte-order here?  */
if|if
condition|(
name|write
condition|)
return|return
name|target_write_memory
argument_list|(
name|addr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|val
argument_list|,
sizeof|sizeof
argument_list|(
name|unw_word_t
argument_list|)
argument_list|)
return|;
else|else
return|return
name|target_read_memory
argument_list|(
name|addr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|val
argument_list|,
sizeof|sizeof
argument_list|(
name|unw_word_t
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Call low-level function to access the kernel unwind table.  */
end_comment

begin_function
specifier|static
name|int
name|getunwind_table
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|LONGEST
name|x
decl_stmt|;
name|x
operator|=
name|target_read_partial
argument_list|(
operator|&
name|current_target
argument_list|,
name|TARGET_OBJECT_UNWIND_TABLE
argument_list|,
name|NULL
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
name|int
operator|)
name|x
return|;
block|}
end_function

begin_comment
comment|/* Get the kernel unwind table.  */
end_comment

begin_function
specifier|static
name|int
name|get_kernel_table
parameter_list|(
name|unw_word_t
name|ip
parameter_list|,
name|unw_dyn_info_t
modifier|*
name|di
parameter_list|)
block|{
name|size_t
name|size
decl_stmt|;
struct|struct
name|ia64_table_entry
block|{
name|uint64_t
name|start_offset
decl_stmt|;
name|uint64_t
name|end_offset
decl_stmt|;
name|uint64_t
name|info_offset
decl_stmt|;
block|}
struct|;
specifier|static
name|struct
name|ia64_table_entry
modifier|*
name|ktab
init|=
name|NULL
decl_stmt|,
modifier|*
name|etab
decl_stmt|;
if|if
condition|(
operator|!
name|ktab
condition|)
block|{
name|size
operator|=
name|getunwind_table
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|size
operator|<
literal|0
condition|)
return|return
operator|-
name|UNW_ENOINFO
return|;
name|ktab
operator|=
name|xmalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|getunwind_table
argument_list|(
name|ktab
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* Determine length of kernel's unwind table and relocate 	 it's entries.  */
for|for
control|(
name|etab
operator|=
name|ktab
init|;
name|etab
operator|->
name|start_offset
condition|;
operator|++
name|etab
control|)
name|etab
operator|->
name|info_offset
operator|+=
operator|(
name|uint64_t
operator|)
name|ktab
expr_stmt|;
block|}
if|if
condition|(
name|ip
operator|<
name|ktab
index|[
literal|0
index|]
operator|.
name|start_offset
operator|||
name|ip
operator|>=
name|etab
index|[
operator|-
literal|1
index|]
operator|.
name|end_offset
condition|)
return|return
operator|-
name|UNW_ENOINFO
return|;
name|di
operator|->
name|format
operator|=
name|UNW_INFO_FORMAT_TABLE
expr_stmt|;
name|di
operator|->
name|gp
operator|=
literal|0
expr_stmt|;
name|di
operator|->
name|start_ip
operator|=
name|ktab
index|[
literal|0
index|]
operator|.
name|start_offset
expr_stmt|;
name|di
operator|->
name|end_ip
operator|=
name|etab
index|[
operator|-
literal|1
index|]
operator|.
name|end_offset
expr_stmt|;
name|di
operator|->
name|u
operator|.
name|ti
operator|.
name|name_ptr
operator|=
operator|(
name|unw_word_t
operator|)
literal|"<kernel>"
expr_stmt|;
name|di
operator|->
name|u
operator|.
name|ti
operator|.
name|segbase
operator|=
literal|0
expr_stmt|;
name|di
operator|->
name|u
operator|.
name|ti
operator|.
name|table_len
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|etab
operator|-
operator|(
name|char
operator|*
operator|)
name|ktab
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|unw_word_t
argument_list|)
expr_stmt|;
name|di
operator|->
name|u
operator|.
name|ti
operator|.
name|table_data
operator|=
operator|(
name|unw_word_t
operator|*
operator|)
name|ktab
expr_stmt|;
if|if
condition|(
name|gdbarch_debug
operator|>=
literal|1
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"get_kernel_table: found table `%s': "
literal|"segbase=0x%s, length=%s, gp=0x%s\n"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|di
operator|->
name|u
operator|.
name|ti
operator|.
name|name_ptr
argument_list|,
name|paddr_nz
argument_list|(
name|di
operator|->
name|u
operator|.
name|ti
operator|.
name|segbase
argument_list|)
argument_list|,
name|paddr_u
argument_list|(
name|di
operator|->
name|u
operator|.
name|ti
operator|.
name|table_len
argument_list|)
argument_list|,
name|paddr_nz
argument_list|(
name|di
operator|->
name|gp
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Find the unwind table entry for a specified address.  */
end_comment

begin_function
specifier|static
name|int
name|ia64_find_unwind_table
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|,
name|unw_word_t
name|ip
parameter_list|,
name|unw_dyn_info_t
modifier|*
name|dip
parameter_list|,
name|void
modifier|*
modifier|*
name|buf
parameter_list|)
block|{
name|Elf_Internal_Phdr
modifier|*
name|phdr
decl_stmt|,
modifier|*
name|p_text
init|=
name|NULL
decl_stmt|,
modifier|*
name|p_unwind
init|=
name|NULL
decl_stmt|;
name|Elf_Internal_Ehdr
modifier|*
name|ehdr
decl_stmt|;
name|unw_word_t
name|segbase
init|=
literal|0
decl_stmt|;
name|CORE_ADDR
name|load_base
decl_stmt|;
name|bfd
modifier|*
name|bfd
decl_stmt|;
name|int
name|i
decl_stmt|;
name|bfd
operator|=
name|objfile
operator|->
name|obfd
expr_stmt|;
name|ehdr
operator|=
name|elf_tdata
argument_list|(
name|bfd
argument_list|)
operator|->
name|elf_header
expr_stmt|;
name|phdr
operator|=
name|elf_tdata
argument_list|(
name|bfd
argument_list|)
operator|->
name|phdr
expr_stmt|;
name|load_base
operator|=
name|ANOFFSET
argument_list|(
name|objfile
operator|->
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|(
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ehdr
operator|->
name|e_phnum
condition|;
operator|++
name|i
control|)
block|{
switch|switch
condition|(
name|phdr
index|[
name|i
index|]
operator|.
name|p_type
condition|)
block|{
case|case
name|PT_LOAD
case|:
if|if
condition|(
call|(
name|unw_word_t
call|)
argument_list|(
name|ip
operator|-
name|load_base
operator|-
name|phdr
index|[
name|i
index|]
operator|.
name|p_vaddr
argument_list|)
operator|<
name|phdr
index|[
name|i
index|]
operator|.
name|p_memsz
condition|)
name|p_text
operator|=
name|phdr
operator|+
name|i
expr_stmt|;
break|break;
case|case
name|PT_IA_64_UNWIND
case|:
name|p_unwind
operator|=
name|phdr
operator|+
name|i
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|p_text
operator|||
operator|!
name|p_unwind
comment|/* Verify that the segment that contains the IP also contains 	 the static unwind table.  If not, we are dealing with 	 runtime-generated code, for which we have no info here.  */
operator|||
operator|(
name|p_unwind
operator|->
name|p_vaddr
operator|-
name|p_text
operator|->
name|p_vaddr
operator|)
operator|>=
name|p_text
operator|->
name|p_memsz
condition|)
return|return
operator|-
name|UNW_ENOINFO
return|;
name|segbase
operator|=
name|p_text
operator|->
name|p_vaddr
operator|+
name|load_base
expr_stmt|;
name|dip
operator|->
name|start_ip
operator|=
name|segbase
expr_stmt|;
name|dip
operator|->
name|end_ip
operator|=
name|dip
operator|->
name|start_ip
operator|+
name|p_text
operator|->
name|p_memsz
expr_stmt|;
name|dip
operator|->
name|gp
operator|=
name|FIND_GLOBAL_POINTER
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|dip
operator|->
name|format
operator|=
name|UNW_INFO_FORMAT_REMOTE_TABLE
expr_stmt|;
name|dip
operator|->
name|u
operator|.
name|rti
operator|.
name|name_ptr
operator|=
operator|(
name|unw_word_t
operator|)
name|bfd_get_filename
argument_list|(
name|bfd
argument_list|)
expr_stmt|;
name|dip
operator|->
name|u
operator|.
name|rti
operator|.
name|segbase
operator|=
name|segbase
expr_stmt|;
name|dip
operator|->
name|u
operator|.
name|rti
operator|.
name|table_len
operator|=
name|p_unwind
operator|->
name|p_memsz
operator|/
sizeof|sizeof
argument_list|(
name|unw_word_t
argument_list|)
expr_stmt|;
name|dip
operator|->
name|u
operator|.
name|rti
operator|.
name|table_data
operator|=
name|p_unwind
operator|->
name|p_vaddr
operator|+
name|load_base
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Libunwind callback accessor function to acquire procedure unwind-info.  */
end_comment

begin_function
specifier|static
name|int
name|ia64_find_proc_info_x
parameter_list|(
name|unw_addr_space_t
name|as
parameter_list|,
name|unw_word_t
name|ip
parameter_list|,
name|unw_proc_info_t
modifier|*
name|pi
parameter_list|,
name|int
name|need_unwind_info
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|obj_section
modifier|*
name|sec
init|=
name|find_pc_section
argument_list|(
name|ip
argument_list|)
decl_stmt|;
name|unw_dyn_info_t
name|di
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|void
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|sec
condition|)
block|{
comment|/* XXX This only works if the host and the target architecture are 	 both ia64 and if the have (more or less) the same kernel 	 version.  */
if|if
condition|(
name|get_kernel_table
argument_list|(
name|ip
argument_list|,
operator|&
name|di
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
name|UNW_ENOINFO
return|;
if|if
condition|(
name|gdbarch_debug
operator|>=
literal|1
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"ia64_find_proc_info_x: 0x%s -> "
literal|"(name=`%s',segbase=0x%s,start=0x%s,end=0x%s,gp=0x%s,"
literal|"length=%s,data=0x%s)\n"
argument_list|,
name|paddr_nz
argument_list|(
name|ip
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|di
operator|.
name|u
operator|.
name|ti
operator|.
name|name_ptr
argument_list|,
name|paddr_nz
argument_list|(
name|di
operator|.
name|u
operator|.
name|ti
operator|.
name|segbase
argument_list|)
argument_list|,
name|paddr_nz
argument_list|(
name|di
operator|.
name|start_ip
argument_list|)
argument_list|,
name|paddr_nz
argument_list|(
name|di
operator|.
name|end_ip
argument_list|)
argument_list|,
name|paddr_nz
argument_list|(
name|di
operator|.
name|gp
argument_list|)
argument_list|,
name|paddr_u
argument_list|(
name|di
operator|.
name|u
operator|.
name|ti
operator|.
name|table_len
argument_list|)
argument_list|,
name|paddr_nz
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|di
operator|.
name|u
operator|.
name|ti
operator|.
name|table_data
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|ia64_find_unwind_table
argument_list|(
name|sec
operator|->
name|objfile
argument_list|,
name|ip
argument_list|,
operator|&
name|di
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
return|return
name|ret
return|;
if|if
condition|(
name|gdbarch_debug
operator|>=
literal|1
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"ia64_find_proc_info_x: 0x%s -> "
literal|"(name=`%s',segbase=0x%s,start=0x%s,end=0x%s,gp=0x%s,"
literal|"length=%s,data=0x%s)\n"
argument_list|,
name|paddr_nz
argument_list|(
name|ip
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|di
operator|.
name|u
operator|.
name|rti
operator|.
name|name_ptr
argument_list|,
name|paddr_nz
argument_list|(
name|di
operator|.
name|u
operator|.
name|rti
operator|.
name|segbase
argument_list|)
argument_list|,
name|paddr_nz
argument_list|(
name|di
operator|.
name|start_ip
argument_list|)
argument_list|,
name|paddr_nz
argument_list|(
name|di
operator|.
name|end_ip
argument_list|)
argument_list|,
name|paddr_nz
argument_list|(
name|di
operator|.
name|gp
argument_list|)
argument_list|,
name|paddr_u
argument_list|(
name|di
operator|.
name|u
operator|.
name|rti
operator|.
name|table_len
argument_list|)
argument_list|,
name|paddr_nz
argument_list|(
name|di
operator|.
name|u
operator|.
name|rti
operator|.
name|table_data
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|libunwind_search_unwind_table
argument_list|(
operator|&
name|as
argument_list|,
name|ip
argument_list|,
operator|&
name|di
argument_list|,
name|pi
argument_list|,
name|need_unwind_info
argument_list|,
name|arg
argument_list|)
expr_stmt|;
comment|/* We no longer need the dyn info storage so free it.  */
name|xfree
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Libunwind callback accessor function for cleanup.  */
end_comment

begin_function
specifier|static
name|void
name|ia64_put_unwind_info
parameter_list|(
name|unw_addr_space_t
name|as
parameter_list|,
name|unw_proc_info_t
modifier|*
name|pip
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
comment|/* Nothing required for now.  */
block|}
end_function

begin_comment
comment|/* Libunwind callback accessor function to get head of the dynamic     unwind-info registration list.  */
end_comment

begin_function
specifier|static
name|int
name|ia64_get_dyn_info_list
parameter_list|(
name|unw_addr_space_t
name|as
parameter_list|,
name|unw_word_t
modifier|*
name|dilap
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|obj_section
modifier|*
name|text_sec
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|unw_word_t
name|ip
decl_stmt|,
name|addr
decl_stmt|;
name|unw_dyn_info_t
name|di
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|libunwind_is_initialized
argument_list|()
condition|)
return|return
operator|-
name|UNW_ENOINFO
return|;
for|for
control|(
name|objfile
operator|=
name|object_files
init|;
name|objfile
condition|;
name|objfile
operator|=
name|objfile
operator|->
name|next
control|)
block|{
name|void
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
name|text_sec
operator|=
name|objfile
operator|->
name|sections
operator|+
name|SECT_OFF_TEXT
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
name|ip
operator|=
name|text_sec
operator|->
name|addr
expr_stmt|;
name|ret
operator|=
name|ia64_find_unwind_table
argument_list|(
name|objfile
argument_list|,
name|ip
argument_list|,
operator|&
name|di
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|>=
literal|0
condition|)
block|{
name|addr
operator|=
name|libunwind_find_dyn_list
argument_list|(
name|as
argument_list|,
operator|&
name|di
argument_list|,
name|arg
argument_list|)
expr_stmt|;
comment|/* We no longer need the dyn info storage so free it.  */
name|xfree
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
condition|)
block|{
if|if
condition|(
name|gdbarch_debug
operator|>=
literal|1
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"dynamic unwind table in objfile %s "
literal|"at 0x%s (gp=0x%s)\n"
argument_list|,
name|bfd_get_filename
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|)
argument_list|,
name|paddr_nz
argument_list|(
name|addr
argument_list|)
argument_list|,
name|paddr_nz
argument_list|(
name|di
operator|.
name|gp
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|dilap
operator|=
name|addr
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
block|}
return|return
operator|-
name|UNW_ENOINFO
return|;
block|}
end_function

begin_comment
comment|/* Frame interface functions for libunwind.  */
end_comment

begin_function
specifier|static
name|void
name|ia64_libunwind_frame_this_id
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|void
modifier|*
modifier|*
name|this_cache
parameter_list|,
name|struct
name|frame_id
modifier|*
name|this_id
parameter_list|)
block|{
name|char
name|buf
index|[
literal|8
index|]
decl_stmt|;
name|CORE_ADDR
name|bsp
decl_stmt|;
name|struct
name|frame_id
name|id
decl_stmt|;
name|libunwind_frame_this_id
argument_list|(
name|next_frame
argument_list|,
name|this_cache
argument_list|,
operator|&
name|id
argument_list|)
expr_stmt|;
comment|/* We must add the bsp as the special address for frame comparison purposes.  */
name|frame_unwind_register
argument_list|(
name|next_frame
argument_list|,
name|IA64_BSP_REGNUM
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|bsp
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
operator|(
operator|*
name|this_id
operator|)
operator|=
name|frame_id_build_special
argument_list|(
name|id
operator|.
name|stack_addr
argument_list|,
name|id
operator|.
name|code_addr
argument_list|,
name|bsp
argument_list|)
expr_stmt|;
if|if
condition|(
name|gdbarch_debug
operator|>=
literal|1
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"libunwind frame id: code 0x%s, stack 0x%s, special 0x%s, next_frame %p\n"
argument_list|,
name|paddr_nz
argument_list|(
name|id
operator|.
name|code_addr
argument_list|)
argument_list|,
name|paddr_nz
argument_list|(
name|id
operator|.
name|stack_addr
argument_list|)
argument_list|,
name|paddr_nz
argument_list|(
name|bsp
argument_list|)
argument_list|,
name|next_frame
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ia64_libunwind_frame_prev_register
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|void
modifier|*
modifier|*
name|this_cache
parameter_list|,
name|int
name|regnum
parameter_list|,
name|int
modifier|*
name|optimizedp
parameter_list|,
name|enum
name|lval_type
modifier|*
name|lvalp
parameter_list|,
name|CORE_ADDR
modifier|*
name|addrp
parameter_list|,
name|int
modifier|*
name|realnump
parameter_list|,
name|void
modifier|*
name|valuep
parameter_list|)
block|{
name|int
name|reg
init|=
name|regnum
decl_stmt|;
if|if
condition|(
name|VP0_REGNUM
operator|<=
name|regnum
operator|&&
name|regnum
operator|<=
name|VP63_REGNUM
condition|)
name|reg
operator|=
name|IA64_PR_REGNUM
expr_stmt|;
elseif|else
if|if
condition|(
name|IA64_NAT0_REGNUM
operator|<=
name|regnum
operator|&&
name|regnum
operator|<=
name|IA64_NAT127_REGNUM
condition|)
name|reg
operator|=
name|IA64_UNAT_REGNUM
expr_stmt|;
comment|/* Let libunwind do most of the work.  */
name|libunwind_frame_prev_register
argument_list|(
name|next_frame
argument_list|,
name|this_cache
argument_list|,
name|reg
argument_list|,
name|optimizedp
argument_list|,
name|lvalp
argument_list|,
name|addrp
argument_list|,
name|realnump
argument_list|,
name|valuep
argument_list|)
expr_stmt|;
if|if
condition|(
name|VP0_REGNUM
operator|<=
name|regnum
operator|&&
name|regnum
operator|<=
name|VP63_REGNUM
condition|)
block|{
name|ULONGEST
name|prN_val
decl_stmt|;
if|if
condition|(
name|VP16_REGNUM
operator|<=
name|regnum
operator|&&
name|regnum
operator|<=
name|VP63_REGNUM
condition|)
block|{
name|int
name|rrb_pr
init|=
literal|0
decl_stmt|;
name|ULONGEST
name|cfm
decl_stmt|;
name|unsigned
name|char
name|buf
index|[
name|MAX_REGISTER_SIZE
index|]
decl_stmt|;
comment|/* Fetch predicate register rename base from current frame 	     marker for this frame.  */
name|frame_unwind_register
argument_list|(
name|next_frame
argument_list|,
name|IA64_CFM_REGNUM
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|cfm
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|rrb_pr
operator|=
operator|(
name|cfm
operator|>>
literal|32
operator|)
operator|&
literal|0x3f
expr_stmt|;
comment|/* Adjust the register number to account for register rotation.  */
name|regnum
operator|=
name|VP16_REGNUM
operator|+
operator|(
operator|(
name|regnum
operator|-
name|VP16_REGNUM
operator|)
operator|+
name|rrb_pr
operator|)
operator|%
literal|48
expr_stmt|;
block|}
name|prN_val
operator|=
name|extract_bit_field
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|valuep
argument_list|,
name|regnum
operator|-
name|VP0_REGNUM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|store_unsigned_integer
argument_list|(
name|valuep
argument_list|,
name|register_size
argument_list|(
name|current_gdbarch
argument_list|,
name|regnum
argument_list|)
argument_list|,
name|prN_val
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IA64_NAT0_REGNUM
operator|<=
name|regnum
operator|&&
name|regnum
operator|<=
name|IA64_NAT127_REGNUM
condition|)
block|{
name|ULONGEST
name|unatN_val
decl_stmt|;
name|unatN_val
operator|=
name|extract_bit_field
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|valuep
argument_list|,
name|regnum
operator|-
name|IA64_NAT0_REGNUM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|store_unsigned_integer
argument_list|(
name|valuep
argument_list|,
name|register_size
argument_list|(
name|current_gdbarch
argument_list|,
name|regnum
argument_list|)
argument_list|,
name|unatN_val
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|regnum
operator|==
name|IA64_BSP_REGNUM
condition|)
block|{
name|char
name|cfm_valuep
index|[
name|MAX_REGISTER_SIZE
index|]
decl_stmt|;
name|int
name|cfm_optim
decl_stmt|;
name|int
name|cfm_realnum
decl_stmt|;
name|enum
name|lval_type
name|cfm_lval
decl_stmt|;
name|CORE_ADDR
name|cfm_addr
decl_stmt|;
name|CORE_ADDR
name|bsp
decl_stmt|,
name|prev_cfm
decl_stmt|,
name|prev_bsp
decl_stmt|;
comment|/* We want to calculate the previous bsp as the end of the previous register stack frame. 	 This corresponds to what the hardware bsp register will be if we pop the frame 	 back which is why we might have been called.  We know that libunwind will pass us back 	 the beginning of the current frame so we should just add sof to it. */
name|prev_bsp
operator|=
name|extract_unsigned_integer
argument_list|(
name|valuep
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|libunwind_frame_prev_register
argument_list|(
name|next_frame
argument_list|,
name|this_cache
argument_list|,
name|IA64_CFM_REGNUM
argument_list|,
operator|&
name|cfm_optim
argument_list|,
operator|&
name|cfm_lval
argument_list|,
operator|&
name|cfm_addr
argument_list|,
operator|&
name|cfm_realnum
argument_list|,
name|cfm_valuep
argument_list|)
expr_stmt|;
name|prev_cfm
operator|=
name|extract_unsigned_integer
argument_list|(
name|cfm_valuep
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|prev_bsp
operator|=
name|rse_address_add
argument_list|(
name|prev_bsp
argument_list|,
operator|(
name|prev_cfm
operator|&
literal|0x7f
operator|)
argument_list|)
expr_stmt|;
name|store_unsigned_integer
argument_list|(
name|valuep
argument_list|,
name|register_size
argument_list|(
name|current_gdbarch
argument_list|,
name|regnum
argument_list|)
argument_list|,
name|prev_bsp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gdbarch_debug
operator|>=
literal|1
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"libunwind prev register<%s> is 0x%s\n"
argument_list|,
operator|(
operator|(
operator|(
name|unsigned
operator|)
name|regnum
operator|<=
name|IA64_NAT127_REGNUM
operator|)
condition|?
name|ia64_register_names
index|[
name|regnum
index|]
else|:
literal|"r??"
operator|)
argument_list|,
name|paddr_nz
argument_list|(
name|extract_unsigned_integer
argument_list|(
name|valuep
argument_list|,
literal|8
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|frame_unwind
name|ia64_libunwind_frame_unwind
init|=
block|{
name|NORMAL_FRAME
block|,
name|ia64_libunwind_frame_this_id
block|,
name|ia64_libunwind_frame_prev_register
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|const
name|struct
name|frame_unwind
modifier|*
name|ia64_libunwind_frame_sniffer
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|)
block|{
if|if
condition|(
name|libunwind_is_initialized
argument_list|()
operator|&&
name|libunwind_frame_sniffer
argument_list|(
name|next_frame
argument_list|)
condition|)
return|return
operator|&
name|ia64_libunwind_frame_unwind
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Set of libunwind callback acccessor functions.  */
end_comment

begin_decl_stmt
specifier|static
name|unw_accessors_t
name|ia64_unw_accessors
init|=
block|{
name|ia64_find_proc_info_x
block|,
name|ia64_put_unwind_info
block|,
name|ia64_get_dyn_info_list
block|,
name|ia64_access_mem
block|,
name|ia64_access_reg
block|,
name|ia64_access_fpreg
block|,
comment|/* resume */
comment|/* get_proc_name */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set of ia64 gdb libunwind-frame callbacks and data for generic libunwind-frame code to use.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|libunwind_descr
name|ia64_libunwind_descr
init|=
block|{
name|ia64_gdb2uw_regnum
block|,
name|ia64_uw2gdb_regnum
block|,
name|ia64_is_fpreg
block|,
operator|&
name|ia64_unw_accessors
block|, }
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_LIBUNWIND_IA64_H  */
end_comment

begin_comment
comment|/* Should we use DEPRECATED_EXTRACT_STRUCT_VALUE_ADDRESS instead of    EXTRACT_RETURN_VALUE?  GCC_P is true if compiled with gcc and TYPE    is the type (which is known to be struct, union or array).  */
end_comment

begin_function
name|int
name|ia64_use_struct_convention
parameter_list|(
name|int
name|gcc_p
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|float_elt_type
decl_stmt|;
comment|/* HFAs are structures (or arrays) consisting entirely of floating      point values of the same length.  Up to 8 of these are returned      in registers.  Don't use the struct convention when this is the      case.  */
name|float_elt_type
operator|=
name|is_float_or_hfa_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|float_elt_type
operator|!=
name|NULL
operator|&&
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|/
name|TYPE_LENGTH
argument_list|(
name|float_elt_type
argument_list|)
operator|<=
literal|8
condition|)
return|return
literal|0
return|;
comment|/* Other structs of length 32 or less are returned in r8-r11.      Don't use the struct convention for those either.  */
return|return
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|>
literal|32
return|;
block|}
end_function

begin_function
name|void
name|ia64_extract_return_value
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|void
modifier|*
name|valbuf
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|float_elt_type
decl_stmt|;
name|float_elt_type
operator|=
name|is_float_or_hfa_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|float_elt_type
operator|!=
name|NULL
condition|)
block|{
name|char
name|from
index|[
name|MAX_REGISTER_SIZE
index|]
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|int
name|regnum
init|=
name|IA64_FR8_REGNUM
decl_stmt|;
name|int
name|n
init|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|/
name|TYPE_LENGTH
argument_list|(
name|float_elt_type
argument_list|)
decl_stmt|;
while|while
condition|(
name|n
operator|--
operator|>
literal|0
condition|)
block|{
name|regcache_cooked_read
argument_list|(
name|regcache
argument_list|,
name|regnum
argument_list|,
name|from
argument_list|)
expr_stmt|;
name|convert_typed_floating
argument_list|(
name|from
argument_list|,
name|builtin_type_ia64_ext
argument_list|,
operator|(
name|char
operator|*
operator|)
name|valbuf
operator|+
name|offset
argument_list|,
name|float_elt_type
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|TYPE_LENGTH
argument_list|(
name|float_elt_type
argument_list|)
expr_stmt|;
name|regnum
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|ULONGEST
name|val
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|int
name|regnum
init|=
name|IA64_GR8_REGNUM
decl_stmt|;
name|int
name|reglen
init|=
name|TYPE_LENGTH
argument_list|(
name|ia64_register_type
argument_list|(
name|NULL
argument_list|,
name|IA64_GR8_REGNUM
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|n
init|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|/
name|reglen
decl_stmt|;
name|int
name|m
init|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|%
name|reglen
decl_stmt|;
while|while
condition|(
name|n
operator|--
operator|>
literal|0
condition|)
block|{
name|ULONGEST
name|val
decl_stmt|;
name|regcache_cooked_read_unsigned
argument_list|(
name|regcache
argument_list|,
name|regnum
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|valbuf
operator|+
name|offset
argument_list|,
operator|&
name|val
argument_list|,
name|reglen
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|reglen
expr_stmt|;
name|regnum
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|m
condition|)
block|{
name|regcache_cooked_read_unsigned
argument_list|(
name|regcache
argument_list|,
name|regnum
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|valbuf
operator|+
name|offset
argument_list|,
operator|&
name|val
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|CORE_ADDR
name|ia64_extract_struct_value_address
parameter_list|(
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|)
block|{
name|error
argument_list|(
literal|"ia64_extract_struct_value_address called and cannot get struct value address"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|is_float_or_hfa_type_recurse
parameter_list|(
name|struct
name|type
modifier|*
name|t
parameter_list|,
name|struct
name|type
modifier|*
modifier|*
name|etp
parameter_list|)
block|{
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_FLT
case|:
if|if
condition|(
operator|*
name|etp
condition|)
return|return
name|TYPE_LENGTH
argument_list|(
operator|*
name|etp
argument_list|)
operator|==
name|TYPE_LENGTH
argument_list|(
name|t
argument_list|)
return|;
else|else
block|{
operator|*
name|etp
operator|=
name|t
expr_stmt|;
return|return
literal|1
return|;
block|}
break|break;
case|case
name|TYPE_CODE_ARRAY
case|:
return|return
name|is_float_or_hfa_type_recurse
argument_list|(
name|check_typedef
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|,
name|etp
argument_list|)
return|;
break|break;
case|case
name|TYPE_CODE_STRUCT
case|:
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TYPE_NFIELDS
argument_list|(
name|t
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|is_float_or_hfa_type_recurse
argument_list|(
name|check_typedef
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|,
name|etp
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
break|break;
default|default:
return|return
literal|0
return|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Determine if the given type is one of the floating point types or    and HFA (which is a struct, array, or combination thereof whose    bottom-most elements are all of the same floating point type).  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|is_float_or_hfa_type
parameter_list|(
name|struct
name|type
modifier|*
name|t
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|et
init|=
literal|0
decl_stmt|;
return|return
name|is_float_or_hfa_type_recurse
argument_list|(
name|t
argument_list|,
operator|&
name|et
argument_list|)
condition|?
name|et
else|:
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the alignment of T is such that the next even slot    should be used.  Return 0, if the next available slot should    be used.  (See section 8.5.1 of the IA-64 Software Conventions    and Runtime manual).  */
end_comment

begin_function
specifier|static
name|int
name|slot_alignment_is_next_even
parameter_list|(
name|struct
name|type
modifier|*
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_INT
case|:
case|case
name|TYPE_CODE_FLT
case|:
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|t
argument_list|)
operator|>
literal|8
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
case|case
name|TYPE_CODE_ARRAY
case|:
return|return
name|slot_alignment_is_next_even
argument_list|(
name|check_typedef
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|TYPE_CODE_STRUCT
case|:
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TYPE_NFIELDS
argument_list|(
name|t
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|slot_alignment_is_next_even
argument_list|(
name|check_typedef
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Attempt to find (and return) the global pointer for the given    function.     This is a rather nasty bit of code searchs for the .dynamic section    in the objfile corresponding to the pc of the function we're trying    to call.  Once it finds the addresses at which the .dynamic section    lives in the child process, it scans the Elf64_Dyn entries for a    DT_PLTGOT tag.  If it finds one of these, the corresponding    d_un.d_ptr value is the global pointer.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|generic_elf_find_global_pointer
parameter_list|(
name|CORE_ADDR
name|faddr
parameter_list|)
block|{
name|struct
name|obj_section
modifier|*
name|faddr_sect
decl_stmt|;
name|faddr_sect
operator|=
name|find_pc_section
argument_list|(
name|faddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|faddr_sect
operator|!=
name|NULL
condition|)
block|{
name|struct
name|obj_section
modifier|*
name|osect
decl_stmt|;
name|ALL_OBJFILE_OSECTIONS
argument_list|(
argument|faddr_sect->objfile
argument_list|,
argument|osect
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|osect
operator|->
name|the_bfd_section
operator|->
name|name
argument_list|,
literal|".dynamic"
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|osect
operator|<
name|faddr_sect
operator|->
name|objfile
operator|->
name|sections_end
condition|)
block|{
name|CORE_ADDR
name|addr
decl_stmt|;
name|addr
operator|=
name|osect
operator|->
name|addr
expr_stmt|;
while|while
condition|(
name|addr
operator|<
name|osect
operator|->
name|endaddr
condition|)
block|{
name|int
name|status
decl_stmt|;
name|LONGEST
name|tag
decl_stmt|;
name|char
name|buf
index|[
literal|8
index|]
decl_stmt|;
name|status
operator|=
name|target_read_memory
argument_list|(
name|addr
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
break|break;
name|tag
operator|=
name|extract_signed_integer
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag
operator|==
name|DT_PLTGOT
condition|)
block|{
name|CORE_ADDR
name|global_pointer
decl_stmt|;
name|status
operator|=
name|target_read_memory
argument_list|(
name|addr
operator|+
literal|8
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
break|break;
name|global_pointer
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The payoff... */
return|return
name|global_pointer
return|;
block|}
if|if
condition|(
name|tag
operator|==
name|DT_NULL
condition|)
break|break;
name|addr
operator|+=
literal|16
expr_stmt|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Given a function's address, attempt to find (and return) the    corresponding (canonical) function descriptor.  Return 0 if    not found.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|find_extant_func_descr
parameter_list|(
name|CORE_ADDR
name|faddr
parameter_list|)
block|{
name|struct
name|obj_section
modifier|*
name|faddr_sect
decl_stmt|;
comment|/* Return early if faddr is already a function descriptor.  */
name|faddr_sect
operator|=
name|find_pc_section
argument_list|(
name|faddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|faddr_sect
operator|&&
name|strcmp
argument_list|(
name|faddr_sect
operator|->
name|the_bfd_section
operator|->
name|name
argument_list|,
literal|".opd"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|faddr
return|;
if|if
condition|(
name|faddr_sect
operator|!=
name|NULL
condition|)
block|{
name|struct
name|obj_section
modifier|*
name|osect
decl_stmt|;
name|ALL_OBJFILE_OSECTIONS
argument_list|(
argument|faddr_sect->objfile
argument_list|,
argument|osect
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|osect
operator|->
name|the_bfd_section
operator|->
name|name
argument_list|,
literal|".opd"
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|osect
operator|<
name|faddr_sect
operator|->
name|objfile
operator|->
name|sections_end
condition|)
block|{
name|CORE_ADDR
name|addr
decl_stmt|;
name|addr
operator|=
name|osect
operator|->
name|addr
expr_stmt|;
while|while
condition|(
name|addr
operator|<
name|osect
operator|->
name|endaddr
condition|)
block|{
name|int
name|status
decl_stmt|;
name|LONGEST
name|faddr2
decl_stmt|;
name|char
name|buf
index|[
literal|8
index|]
decl_stmt|;
name|status
operator|=
name|target_read_memory
argument_list|(
name|addr
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
break|break;
name|faddr2
operator|=
name|extract_signed_integer
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|faddr
operator|==
name|faddr2
condition|)
return|return
name|addr
return|;
name|addr
operator|+=
literal|16
expr_stmt|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Attempt to find a function descriptor corresponding to the    given address.  If none is found, construct one on the    stack using the address at fdaptr.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|find_func_descr
parameter_list|(
name|CORE_ADDR
name|faddr
parameter_list|,
name|CORE_ADDR
modifier|*
name|fdaptr
parameter_list|)
block|{
name|CORE_ADDR
name|fdesc
decl_stmt|;
name|fdesc
operator|=
name|find_extant_func_descr
argument_list|(
name|faddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdesc
operator|==
literal|0
condition|)
block|{
name|CORE_ADDR
name|global_pointer
decl_stmt|;
name|char
name|buf
index|[
literal|16
index|]
decl_stmt|;
name|fdesc
operator|=
operator|*
name|fdaptr
expr_stmt|;
operator|*
name|fdaptr
operator|+=
literal|16
expr_stmt|;
name|global_pointer
operator|=
name|FIND_GLOBAL_POINTER
argument_list|(
name|faddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|global_pointer
operator|==
literal|0
condition|)
name|global_pointer
operator|=
name|read_register
argument_list|(
name|IA64_GR1_REGNUM
argument_list|)
expr_stmt|;
name|store_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|8
argument_list|,
name|faddr
argument_list|)
expr_stmt|;
name|store_unsigned_integer
argument_list|(
name|buf
operator|+
literal|8
argument_list|,
literal|8
argument_list|,
name|global_pointer
argument_list|)
expr_stmt|;
name|write_memory
argument_list|(
name|fdesc
argument_list|,
name|buf
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
return|return
name|fdesc
return|;
block|}
end_function

begin_comment
comment|/* Use the following routine when printing out function pointers    so the user can see the function address rather than just the    function descriptor.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|ia64_convert_from_func_ptr_addr
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|CORE_ADDR
name|addr
parameter_list|,
name|struct
name|target_ops
modifier|*
name|targ
parameter_list|)
block|{
name|struct
name|obj_section
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|find_pc_section
argument_list|(
name|addr
argument_list|)
expr_stmt|;
comment|/* check if ADDR points to a function descriptor.  */
if|if
condition|(
name|s
operator|&&
name|strcmp
argument_list|(
name|s
operator|->
name|the_bfd_section
operator|->
name|name
argument_list|,
literal|".opd"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|read_memory_unsigned_integer
argument_list|(
name|addr
argument_list|,
literal|8
argument_list|)
return|;
return|return
name|addr
return|;
block|}
end_function

begin_function
specifier|static
name|CORE_ADDR
name|ia64_frame_align
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|CORE_ADDR
name|sp
parameter_list|)
block|{
return|return
name|sp
operator|&
operator|~
literal|0xfLL
return|;
block|}
end_function

begin_function
specifier|static
name|CORE_ADDR
name|ia64_push_dummy_call
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|CORE_ADDR
name|func_addr
parameter_list|,
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|CORE_ADDR
name|bp_addr
parameter_list|,
name|int
name|nargs
parameter_list|,
name|struct
name|value
modifier|*
modifier|*
name|args
parameter_list|,
name|CORE_ADDR
name|sp
parameter_list|,
name|int
name|struct_return
parameter_list|,
name|CORE_ADDR
name|struct_addr
parameter_list|)
block|{
name|int
name|argno
decl_stmt|;
name|struct
name|value
modifier|*
name|arg
decl_stmt|;
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|int
name|len
decl_stmt|,
name|argoffset
decl_stmt|;
name|int
name|nslots
decl_stmt|,
name|rseslots
decl_stmt|,
name|memslots
decl_stmt|,
name|slotnum
decl_stmt|,
name|nfuncargs
decl_stmt|;
name|int
name|floatreg
decl_stmt|;
name|CORE_ADDR
name|bsp
decl_stmt|,
name|cfm
decl_stmt|,
name|pfs
decl_stmt|,
name|new_bsp
decl_stmt|,
name|funcdescaddr
decl_stmt|,
name|pc
decl_stmt|,
name|global_pointer
decl_stmt|;
name|nslots
operator|=
literal|0
expr_stmt|;
name|nfuncargs
operator|=
literal|0
expr_stmt|;
comment|/* Count the number of slots needed for the arguments.  */
for|for
control|(
name|argno
operator|=
literal|0
init|;
name|argno
operator|<
name|nargs
condition|;
name|argno
operator|++
control|)
block|{
name|arg
operator|=
name|args
index|[
name|argno
index|]
expr_stmt|;
name|type
operator|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nslots
operator|&
literal|1
operator|)
operator|&&
name|slot_alignment_is_next_even
argument_list|(
name|type
argument_list|)
condition|)
name|nslots
operator|++
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_FUNC
condition|)
name|nfuncargs
operator|++
expr_stmt|;
name|nslots
operator|+=
operator|(
name|len
operator|+
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
block|}
comment|/* Divvy up the slots between the RSE and the memory stack.  */
name|rseslots
operator|=
operator|(
name|nslots
operator|>
literal|8
operator|)
condition|?
literal|8
else|:
name|nslots
expr_stmt|;
name|memslots
operator|=
name|nslots
operator|-
name|rseslots
expr_stmt|;
comment|/* Allocate a new RSE frame.  */
name|cfm
operator|=
name|read_register
argument_list|(
name|IA64_CFM_REGNUM
argument_list|)
expr_stmt|;
name|bsp
operator|=
name|read_register
argument_list|(
name|IA64_BSP_REGNUM
argument_list|)
expr_stmt|;
name|new_bsp
operator|=
name|rse_address_add
argument_list|(
name|bsp
argument_list|,
name|rseslots
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|IA64_BSP_REGNUM
argument_list|,
name|new_bsp
argument_list|)
expr_stmt|;
name|pfs
operator|=
name|read_register
argument_list|(
name|IA64_PFS_REGNUM
argument_list|)
expr_stmt|;
name|pfs
operator|&=
literal|0xc000000000000000LL
expr_stmt|;
name|pfs
operator||=
operator|(
name|cfm
operator|&
literal|0xffffffffffffLL
operator|)
expr_stmt|;
name|write_register
argument_list|(
name|IA64_PFS_REGNUM
argument_list|,
name|pfs
argument_list|)
expr_stmt|;
name|cfm
operator|&=
literal|0xc000000000000000LL
expr_stmt|;
name|cfm
operator||=
name|rseslots
expr_stmt|;
name|write_register
argument_list|(
name|IA64_CFM_REGNUM
argument_list|,
name|cfm
argument_list|)
expr_stmt|;
comment|/* We will attempt to find function descriptors in the .opd segment,      but if we can't we'll construct them ourselves.  That being the      case, we'll need to reserve space on the stack for them.  */
name|funcdescaddr
operator|=
name|sp
operator|-
name|nfuncargs
operator|*
literal|16
expr_stmt|;
name|funcdescaddr
operator|&=
operator|~
literal|0xfLL
expr_stmt|;
comment|/* Adjust the stack pointer to it's new value.  The calling conventions      require us to have 16 bytes of scratch, plus whatever space is      necessary for the memory slots and our function descriptors.  */
name|sp
operator|=
name|sp
operator|-
literal|16
operator|-
operator|(
name|memslots
operator|+
name|nfuncargs
operator|)
operator|*
literal|8
expr_stmt|;
name|sp
operator|&=
operator|~
literal|0xfLL
expr_stmt|;
comment|/* Maintain 16 byte alignment.  */
comment|/* Place the arguments where they belong.  The arguments will be      either placed in the RSE backing store or on the memory stack.      In addition, floating point arguments or HFAs are placed in      floating point registers.  */
name|slotnum
operator|=
literal|0
expr_stmt|;
name|floatreg
operator|=
name|IA64_FR8_REGNUM
expr_stmt|;
for|for
control|(
name|argno
operator|=
literal|0
init|;
name|argno
operator|<
name|nargs
condition|;
name|argno
operator|++
control|)
block|{
name|struct
name|type
modifier|*
name|float_elt_type
decl_stmt|;
name|arg
operator|=
name|args
index|[
name|argno
index|]
expr_stmt|;
name|type
operator|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Special handling for function parameters.  */
if|if
condition|(
name|len
operator|==
literal|8
operator|&&
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_PTR
operator|&&
name|TYPE_CODE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_FUNC
condition|)
block|{
name|char
name|val_buf
index|[
literal|8
index|]
decl_stmt|;
name|store_unsigned_integer
argument_list|(
name|val_buf
argument_list|,
literal|8
argument_list|,
name|find_func_descr
argument_list|(
name|extract_unsigned_integer
argument_list|(
name|VALUE_CONTENTS
argument_list|(
name|arg
argument_list|)
argument_list|,
literal|8
argument_list|)
argument_list|,
operator|&
name|funcdescaddr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|slotnum
operator|<
name|rseslots
condition|)
name|write_memory
argument_list|(
name|rse_address_add
argument_list|(
name|bsp
argument_list|,
name|slotnum
argument_list|)
argument_list|,
name|val_buf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
else|else
name|write_memory
argument_list|(
name|sp
operator|+
literal|16
operator|+
literal|8
operator|*
operator|(
name|slotnum
operator|-
name|rseslots
operator|)
argument_list|,
name|val_buf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|slotnum
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* Normal slots.  */
comment|/* Skip odd slot if necessary...  */
if|if
condition|(
operator|(
name|slotnum
operator|&
literal|1
operator|)
operator|&&
name|slot_alignment_is_next_even
argument_list|(
name|type
argument_list|)
condition|)
name|slotnum
operator|++
expr_stmt|;
name|argoffset
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|char
name|val_buf
index|[
literal|8
index|]
decl_stmt|;
name|memset
argument_list|(
name|val_buf
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|val_buf
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|arg
argument_list|)
operator|+
name|argoffset
argument_list|,
operator|(
name|len
operator|>
literal|8
operator|)
condition|?
literal|8
else|:
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|slotnum
operator|<
name|rseslots
condition|)
name|write_memory
argument_list|(
name|rse_address_add
argument_list|(
name|bsp
argument_list|,
name|slotnum
argument_list|)
argument_list|,
name|val_buf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
else|else
name|write_memory
argument_list|(
name|sp
operator|+
literal|16
operator|+
literal|8
operator|*
operator|(
name|slotnum
operator|-
name|rseslots
operator|)
argument_list|,
name|val_buf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|argoffset
operator|+=
literal|8
expr_stmt|;
name|len
operator|-=
literal|8
expr_stmt|;
name|slotnum
operator|++
expr_stmt|;
block|}
comment|/* Handle floating point types (including HFAs).  */
name|float_elt_type
operator|=
name|is_float_or_hfa_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|float_elt_type
operator|!=
name|NULL
condition|)
block|{
name|argoffset
operator|=
literal|0
expr_stmt|;
name|len
operator|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
operator|&&
name|floatreg
operator|<
name|IA64_FR16_REGNUM
condition|)
block|{
name|char
name|to
index|[
name|MAX_REGISTER_SIZE
index|]
decl_stmt|;
name|convert_typed_floating
argument_list|(
name|VALUE_CONTENTS
argument_list|(
name|arg
argument_list|)
operator|+
name|argoffset
argument_list|,
name|float_elt_type
argument_list|,
name|to
argument_list|,
name|builtin_type_ia64_ext
argument_list|)
expr_stmt|;
name|regcache_cooked_write
argument_list|(
name|regcache
argument_list|,
name|floatreg
argument_list|,
operator|(
name|void
operator|*
operator|)
name|to
argument_list|)
expr_stmt|;
name|floatreg
operator|++
expr_stmt|;
name|argoffset
operator|+=
name|TYPE_LENGTH
argument_list|(
name|float_elt_type
argument_list|)
expr_stmt|;
name|len
operator|-=
name|TYPE_LENGTH
argument_list|(
name|float_elt_type
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Store the struct return value in r8 if necessary.  */
if|if
condition|(
name|struct_return
condition|)
block|{
name|regcache_cooked_write_unsigned
argument_list|(
name|regcache
argument_list|,
name|IA64_GR8_REGNUM
argument_list|,
operator|(
name|ULONGEST
operator|)
name|struct_addr
argument_list|)
expr_stmt|;
block|}
name|global_pointer
operator|=
name|FIND_GLOBAL_POINTER
argument_list|(
name|func_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|global_pointer
operator|!=
literal|0
condition|)
name|write_register
argument_list|(
name|IA64_GR1_REGNUM
argument_list|,
name|global_pointer
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|IA64_BR0_REGNUM
argument_list|,
name|bp_addr
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|sp_regnum
argument_list|,
name|sp
argument_list|)
expr_stmt|;
return|return
name|sp
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|frame_id
name|ia64_unwind_dummy_id
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|)
block|{
name|char
name|buf
index|[
literal|8
index|]
decl_stmt|;
name|CORE_ADDR
name|sp
decl_stmt|,
name|bsp
decl_stmt|;
name|frame_unwind_register
argument_list|(
name|next_frame
argument_list|,
name|sp_regnum
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|sp
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|frame_unwind_register
argument_list|(
name|next_frame
argument_list|,
name|IA64_BSP_REGNUM
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|bsp
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|gdbarch_debug
operator|>=
literal|1
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"dummy frame id: code 0x%s, stack 0x%s, special 0x%s\n"
argument_list|,
name|paddr_nz
argument_list|(
name|frame_pc_unwind
argument_list|(
name|next_frame
argument_list|)
argument_list|)
argument_list|,
name|paddr_nz
argument_list|(
name|sp
argument_list|)
argument_list|,
name|paddr_nz
argument_list|(
name|bsp
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|frame_id_build_special
argument_list|(
name|sp
argument_list|,
name|frame_pc_unwind
argument_list|(
name|next_frame
argument_list|)
argument_list|,
name|bsp
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|CORE_ADDR
name|ia64_unwind_pc
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|)
block|{
name|char
name|buf
index|[
literal|8
index|]
decl_stmt|;
name|CORE_ADDR
name|ip
decl_stmt|,
name|psr
decl_stmt|,
name|pc
decl_stmt|;
name|frame_unwind_register
argument_list|(
name|next_frame
argument_list|,
name|IA64_IP_REGNUM
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|ip
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|frame_unwind_register
argument_list|(
name|next_frame
argument_list|,
name|IA64_PSR_REGNUM
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|psr
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|pc
operator|=
operator|(
name|ip
operator|&
operator|~
literal|0xf
operator|)
operator||
operator|(
operator|(
name|psr
operator|>>
literal|41
operator|)
operator|&
literal|3
operator|)
expr_stmt|;
return|return
name|pc
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ia64_store_return_value
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
specifier|const
name|void
modifier|*
name|valbuf
parameter_list|)
block|{
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_FLT
condition|)
block|{
name|char
name|to
index|[
name|MAX_REGISTER_SIZE
index|]
decl_stmt|;
name|convert_typed_floating
argument_list|(
name|valbuf
argument_list|,
name|type
argument_list|,
name|to
argument_list|,
name|builtin_type_ia64_ext
argument_list|)
expr_stmt|;
name|regcache_cooked_write
argument_list|(
name|regcache
argument_list|,
name|IA64_FR8_REGNUM
argument_list|,
operator|(
name|void
operator|*
operator|)
name|to
argument_list|)
expr_stmt|;
name|target_store_registers
argument_list|(
name|IA64_FR8_REGNUM
argument_list|)
expr_stmt|;
block|}
else|else
name|regcache_cooked_write
argument_list|(
name|regcache
argument_list|,
name|IA64_GR8_REGNUM
argument_list|,
name|valbuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ia64_remote_translate_xfer_address
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|CORE_ADDR
name|memaddr
parameter_list|,
name|int
name|nr_bytes
parameter_list|,
name|CORE_ADDR
modifier|*
name|targ_addr
parameter_list|,
name|int
modifier|*
name|targ_len
parameter_list|)
block|{
operator|*
name|targ_addr
operator|=
name|memaddr
expr_stmt|;
operator|*
name|targ_len
operator|=
name|nr_bytes
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ia64_print_insn
parameter_list|(
name|bfd_vma
name|memaddr
parameter_list|,
name|struct
name|disassemble_info
modifier|*
name|info
parameter_list|)
block|{
name|info
operator|->
name|bytes_per_line
operator|=
name|SLOT_MULTIPLIER
expr_stmt|;
return|return
name|print_insn_ia64
argument_list|(
name|memaddr
argument_list|,
name|info
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|gdbarch
modifier|*
name|ia64_gdbarch_init
parameter_list|(
name|struct
name|gdbarch_info
name|info
parameter_list|,
name|struct
name|gdbarch_list
modifier|*
name|arches
parameter_list|)
block|{
name|struct
name|gdbarch
modifier|*
name|gdbarch
decl_stmt|;
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
decl_stmt|;
comment|/* If there is already a candidate, use it.  */
name|arches
operator|=
name|gdbarch_list_lookup_by_info
argument_list|(
name|arches
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|arches
operator|!=
name|NULL
condition|)
return|return
name|arches
operator|->
name|gdbarch
return|;
name|tdep
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|gdbarch_tdep
argument_list|)
argument_list|)
expr_stmt|;
name|gdbarch
operator|=
name|gdbarch_alloc
argument_list|(
operator|&
name|info
argument_list|,
name|tdep
argument_list|)
expr_stmt|;
comment|/* Set the method of obtaining the sigcontext addresses at which      registers are saved.  The method of checking to see if      native_find_global_pointer is nonzero to indicate that we're      on AIX is kind of hokey, but I can't think of a better way      to do it.  */
if|if
condition|(
name|info
operator|.
name|osabi
operator|==
name|GDB_OSABI_LINUX
condition|)
name|tdep
operator|->
name|sigcontext_register_address
operator|=
name|ia64_linux_sigcontext_register_address
expr_stmt|;
elseif|else
if|if
condition|(
name|native_find_global_pointer
operator|!=
literal|0
condition|)
name|tdep
operator|->
name|sigcontext_register_address
operator|=
name|ia64_aix_sigcontext_register_address
expr_stmt|;
else|else
name|tdep
operator|->
name|sigcontext_register_address
operator|=
literal|0
expr_stmt|;
comment|/* We know that GNU/Linux won't have to resort to the      native_find_global_pointer hackery.  But that's the only one we      know about so far, so if native_find_global_pointer is set to      something non-zero, then use it.  Otherwise fall back to using      generic_elf_find_global_pointer.  This arrangement should (in      theory) allow us to cross debug GNU/Linux binaries from an AIX      machine.  */
if|if
condition|(
name|info
operator|.
name|osabi
operator|==
name|GDB_OSABI_LINUX
condition|)
name|tdep
operator|->
name|find_global_pointer
operator|=
name|generic_elf_find_global_pointer
expr_stmt|;
elseif|else
if|if
condition|(
name|native_find_global_pointer
operator|!=
literal|0
condition|)
name|tdep
operator|->
name|find_global_pointer
operator|=
name|native_find_global_pointer
expr_stmt|;
else|else
name|tdep
operator|->
name|find_global_pointer
operator|=
name|generic_elf_find_global_pointer
expr_stmt|;
comment|/* Define the ia64 floating-point format to gdb.  */
name|builtin_type_ia64_ext
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
literal|128
operator|/
literal|8
argument_list|,
literal|0
argument_list|,
literal|"builtin_type_ia64_ext"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|TYPE_FLOATFORMAT
argument_list|(
name|builtin_type_ia64_ext
argument_list|)
operator|=
operator|&
name|floatformat_ia64_ext
expr_stmt|;
comment|/* According to the ia64 specs, instructions that store long double      floats in memory use a long-double format different than that      used in the floating registers.  The memory format matches the      x86 extended float format which is 80 bits.  An OS may choose to      use this format (e.g. GNU/Linux) or choose to use a different      format for storing long doubles (e.g. HPUX).  In the latter case,      the setting of the format may be moved/overridden in an      OS-specific tdep file.  */
name|set_gdbarch_long_double_format
argument_list|(
name|gdbarch
argument_list|,
operator|&
name|floatformat_i387_ext
argument_list|)
expr_stmt|;
name|set_gdbarch_short_bit
argument_list|(
name|gdbarch
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|set_gdbarch_int_bit
argument_list|(
name|gdbarch
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|set_gdbarch_long_bit
argument_list|(
name|gdbarch
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|set_gdbarch_long_long_bit
argument_list|(
name|gdbarch
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|set_gdbarch_float_bit
argument_list|(
name|gdbarch
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|set_gdbarch_double_bit
argument_list|(
name|gdbarch
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|set_gdbarch_long_double_bit
argument_list|(
name|gdbarch
argument_list|,
literal|128
argument_list|)
expr_stmt|;
name|set_gdbarch_ptr_bit
argument_list|(
name|gdbarch
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|set_gdbarch_num_regs
argument_list|(
name|gdbarch
argument_list|,
name|NUM_IA64_RAW_REGS
argument_list|)
expr_stmt|;
name|set_gdbarch_num_pseudo_regs
argument_list|(
name|gdbarch
argument_list|,
name|LAST_PSEUDO_REGNUM
operator|-
name|FIRST_PSEUDO_REGNUM
argument_list|)
expr_stmt|;
name|set_gdbarch_sp_regnum
argument_list|(
name|gdbarch
argument_list|,
name|sp_regnum
argument_list|)
expr_stmt|;
name|set_gdbarch_fp0_regnum
argument_list|(
name|gdbarch
argument_list|,
name|IA64_FR0_REGNUM
argument_list|)
expr_stmt|;
name|set_gdbarch_register_name
argument_list|(
name|gdbarch
argument_list|,
name|ia64_register_name
argument_list|)
expr_stmt|;
comment|/* FIXME:  Following interface should not be needed, however, without it recurse.exp      gets a number of extra failures.  */
name|set_gdbarch_deprecated_register_size
argument_list|(
name|gdbarch
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|set_gdbarch_register_type
argument_list|(
name|gdbarch
argument_list|,
name|ia64_register_type
argument_list|)
expr_stmt|;
name|set_gdbarch_pseudo_register_read
argument_list|(
name|gdbarch
argument_list|,
name|ia64_pseudo_register_read
argument_list|)
expr_stmt|;
name|set_gdbarch_pseudo_register_write
argument_list|(
name|gdbarch
argument_list|,
name|ia64_pseudo_register_write
argument_list|)
expr_stmt|;
name|set_gdbarch_dwarf2_reg_to_regnum
argument_list|(
name|gdbarch
argument_list|,
name|ia64_dwarf_reg_to_regnum
argument_list|)
expr_stmt|;
name|set_gdbarch_register_reggroup_p
argument_list|(
name|gdbarch
argument_list|,
name|ia64_register_reggroup_p
argument_list|)
expr_stmt|;
name|set_gdbarch_convert_register_p
argument_list|(
name|gdbarch
argument_list|,
name|ia64_convert_register_p
argument_list|)
expr_stmt|;
name|set_gdbarch_register_to_value
argument_list|(
name|gdbarch
argument_list|,
name|ia64_register_to_value
argument_list|)
expr_stmt|;
name|set_gdbarch_value_to_register
argument_list|(
name|gdbarch
argument_list|,
name|ia64_value_to_register
argument_list|)
expr_stmt|;
name|set_gdbarch_skip_prologue
argument_list|(
name|gdbarch
argument_list|,
name|ia64_skip_prologue
argument_list|)
expr_stmt|;
name|set_gdbarch_use_struct_convention
argument_list|(
name|gdbarch
argument_list|,
name|ia64_use_struct_convention
argument_list|)
expr_stmt|;
name|set_gdbarch_extract_return_value
argument_list|(
name|gdbarch
argument_list|,
name|ia64_extract_return_value
argument_list|)
expr_stmt|;
name|set_gdbarch_store_return_value
argument_list|(
name|gdbarch
argument_list|,
name|ia64_store_return_value
argument_list|)
expr_stmt|;
name|set_gdbarch_deprecated_extract_struct_value_address
argument_list|(
name|gdbarch
argument_list|,
name|ia64_extract_struct_value_address
argument_list|)
expr_stmt|;
name|set_gdbarch_memory_insert_breakpoint
argument_list|(
name|gdbarch
argument_list|,
name|ia64_memory_insert_breakpoint
argument_list|)
expr_stmt|;
name|set_gdbarch_memory_remove_breakpoint
argument_list|(
name|gdbarch
argument_list|,
name|ia64_memory_remove_breakpoint
argument_list|)
expr_stmt|;
name|set_gdbarch_breakpoint_from_pc
argument_list|(
name|gdbarch
argument_list|,
name|ia64_breakpoint_from_pc
argument_list|)
expr_stmt|;
name|set_gdbarch_read_pc
argument_list|(
name|gdbarch
argument_list|,
name|ia64_read_pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|osabi
operator|==
name|GDB_OSABI_LINUX
condition|)
name|set_gdbarch_write_pc
argument_list|(
name|gdbarch
argument_list|,
name|ia64_linux_write_pc
argument_list|)
expr_stmt|;
else|else
name|set_gdbarch_write_pc
argument_list|(
name|gdbarch
argument_list|,
name|ia64_write_pc
argument_list|)
expr_stmt|;
comment|/* Settings for calling functions in the inferior.  */
name|set_gdbarch_push_dummy_call
argument_list|(
name|gdbarch
argument_list|,
name|ia64_push_dummy_call
argument_list|)
expr_stmt|;
name|set_gdbarch_frame_align
argument_list|(
name|gdbarch
argument_list|,
name|ia64_frame_align
argument_list|)
expr_stmt|;
name|set_gdbarch_unwind_dummy_id
argument_list|(
name|gdbarch
argument_list|,
name|ia64_unwind_dummy_id
argument_list|)
expr_stmt|;
name|set_gdbarch_unwind_pc
argument_list|(
name|gdbarch
argument_list|,
name|ia64_unwind_pc
argument_list|)
expr_stmt|;
name|frame_unwind_append_sniffer
argument_list|(
name|gdbarch
argument_list|,
name|ia64_sigtramp_frame_sniffer
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_LIBUNWIND_IA64_H
name|frame_unwind_append_sniffer
argument_list|(
name|gdbarch
argument_list|,
name|ia64_libunwind_frame_sniffer
argument_list|)
expr_stmt|;
name|libunwind_frame_set_descr
argument_list|(
name|gdbarch
argument_list|,
operator|&
name|ia64_libunwind_descr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|frame_unwind_append_sniffer
argument_list|(
name|gdbarch
argument_list|,
name|ia64_frame_sniffer
argument_list|)
expr_stmt|;
name|frame_base_set_default
argument_list|(
name|gdbarch
argument_list|,
operator|&
name|ia64_frame_base
argument_list|)
expr_stmt|;
comment|/* Settings that should be unnecessary.  */
name|set_gdbarch_inner_than
argument_list|(
name|gdbarch
argument_list|,
name|core_addr_lessthan
argument_list|)
expr_stmt|;
name|set_gdbarch_remote_translate_xfer_address
argument_list|(
name|gdbarch
argument_list|,
name|ia64_remote_translate_xfer_address
argument_list|)
expr_stmt|;
name|set_gdbarch_print_insn
argument_list|(
name|gdbarch
argument_list|,
name|ia64_print_insn
argument_list|)
expr_stmt|;
name|set_gdbarch_convert_from_func_ptr_addr
argument_list|(
name|gdbarch
argument_list|,
name|ia64_convert_from_func_ptr_addr
argument_list|)
expr_stmt|;
return|return
name|gdbarch
return|;
block|}
end_function

begin_decl_stmt
specifier|extern
name|initialize_file_ftype
name|_initialize_ia64_tdep
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -Wmissing-prototypes */
end_comment

begin_function
name|void
name|_initialize_ia64_tdep
parameter_list|(
name|void
parameter_list|)
block|{
name|register_gdbarch_init
argument_list|(
name|bfd_arch_ia64
argument_list|,
name|ia64_gdbarch_init
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

