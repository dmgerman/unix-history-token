begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Target-dependent code for the IA-64 for GDB, the GNU debugger.     Copyright 1999, 2000, 2001, 2002 Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_comment
comment|/* for entry_point_address */
end_comment

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"arch-utils.h"
end_include

begin_include
include|#
directive|include
file|"floatformat.h"
end_include

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_include
include|#
directive|include
file|"doublest.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"elf/common.h"
end_include

begin_comment
comment|/* for DT_PLTGOT value */
end_comment

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_comment
comment|/* Hook for determining the global pointer when calling functions in    the inferior under AIX.  The initialization code in ia64-aix-nat.c    sets this hook to the address of a function which will find the    global pointer for a given address.          The generic code which uses the dynamic section in the inferior for    finding the global pointer is not of much use on AIX since the    values obtained from the inferior have not been relocated.  */
end_comment

begin_function_decl
name|CORE_ADDR
function_decl|(
modifier|*
name|native_find_global_pointer
function_decl|)
parameter_list|(
name|CORE_ADDR
parameter_list|)
init|=
literal|0
function_decl|;
end_function_decl

begin_comment
comment|/* An enumeration of the different IA-64 instruction types.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
name|instruction_type
block|{
name|A
block|,
comment|/* Integer ALU ;    I-unit or M-unit */
name|I
block|,
comment|/* Non-ALU integer; I-unit */
name|M
block|,
comment|/* Memory ;         M-unit */
name|F
block|,
comment|/* Floating-point ; F-unit */
name|B
block|,
comment|/* Branch ;         B-unit */
name|L
block|,
comment|/* Extended (L+X) ; I-unit */
name|X
block|,
comment|/* Extended (L+X) ; I-unit */
name|undefined
comment|/* undefined or reserved */
block|}
name|instruction_type
typedef|;
end_typedef

begin_comment
comment|/* We represent IA-64 PC addresses as the value of the instruction    pointer or'd with some bit combination in the low nibble which    represents the slot number in the bundle addressed by the    instruction pointer.  The problem is that the Linux kernel    multiplies its slot numbers (for exceptions) by one while the    disassembler multiplies its slot numbers by 6.  In addition, I've    heard it said that the simulator uses 1 as the multiplier.        I've fixed the disassembler so that the bytes_per_line field will    be the slot multiplier.  If bytes_per_line comes in as zero, it    is set to six (which is how it was set up initially). -- objdump    displays pretty disassembly dumps with this value.  For our purposes,    we'll set bytes_per_line to SLOT_MULTIPLIER. This is okay since we    never want to also display the raw bytes the way objdump does. */
end_comment

begin_define
define|#
directive|define
name|SLOT_MULTIPLIER
value|1
end_define

begin_comment
comment|/* Length in bytes of an instruction bundle */
end_comment

begin_define
define|#
directive|define
name|BUNDLE_LEN
value|16
end_define

begin_comment
comment|/* FIXME: These extern declarations should go in ia64-tdep.h.  */
end_comment

begin_function_decl
specifier|extern
name|CORE_ADDR
name|ia64_linux_sigcontext_register_address
parameter_list|(
name|CORE_ADDR
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|CORE_ADDR
name|ia64_aix_sigcontext_register_address
parameter_list|(
name|CORE_ADDR
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|gdbarch_init_ftype
name|ia64_gdbarch_init
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|gdbarch_register_name_ftype
name|ia64_register_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|gdbarch_register_raw_size_ftype
name|ia64_register_raw_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|gdbarch_register_virtual_size_ftype
name|ia64_register_virtual_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|gdbarch_register_virtual_type_ftype
name|ia64_register_virtual_type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|gdbarch_register_byte_ftype
name|ia64_register_byte
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|gdbarch_breakpoint_from_pc_ftype
name|ia64_breakpoint_from_pc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|gdbarch_frame_chain_ftype
name|ia64_frame_chain
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|gdbarch_frame_saved_pc_ftype
name|ia64_frame_saved_pc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|gdbarch_skip_prologue_ftype
name|ia64_skip_prologue
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|gdbarch_frame_init_saved_regs_ftype
name|ia64_frame_init_saved_regs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|gdbarch_get_saved_register_ftype
name|ia64_get_saved_register
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|gdbarch_extract_return_value_ftype
name|ia64_extract_return_value
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|gdbarch_extract_struct_value_address_ftype
name|ia64_extract_struct_value_address
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|gdbarch_use_struct_convention_ftype
name|ia64_use_struct_convention
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|gdbarch_frameless_function_invocation_ftype
name|ia64_frameless_function_invocation
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|gdbarch_init_extra_frame_info_ftype
name|ia64_init_extra_frame_info
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|gdbarch_store_return_value_ftype
name|ia64_store_return_value
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|gdbarch_store_struct_return_ftype
name|ia64_store_struct_return
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|gdbarch_push_arguments_ftype
name|ia64_push_arguments
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|gdbarch_push_return_address_ftype
name|ia64_push_return_address
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|gdbarch_pop_frame_ftype
name|ia64_pop_frame
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|gdbarch_saved_pc_after_call_ftype
name|ia64_saved_pc_after_call
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|ia64_pop_frame_regular
parameter_list|(
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|type
modifier|*
name|is_float_or_hfa_type
parameter_list|(
name|struct
name|type
modifier|*
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|ia64_num_regs
init|=
literal|590
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pc_regnum
init|=
name|IA64_IP_REGNUM
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sp_regnum
init|=
name|IA64_GR12_REGNUM
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fp_regnum
init|=
name|IA64_VFP_REGNUM
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|lr_regnum
init|=
name|IA64_VRAP_REGNUM
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|LONGEST
name|ia64_call_dummy_words
index|[]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Array of register names; There should be ia64_num_regs strings in    the initializer.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ia64_register_names
index|[]
init|=
block|{
literal|"r0"
block|,
literal|"r1"
block|,
literal|"r2"
block|,
literal|"r3"
block|,
literal|"r4"
block|,
literal|"r5"
block|,
literal|"r6"
block|,
literal|"r7"
block|,
literal|"r8"
block|,
literal|"r9"
block|,
literal|"r10"
block|,
literal|"r11"
block|,
literal|"r12"
block|,
literal|"r13"
block|,
literal|"r14"
block|,
literal|"r15"
block|,
literal|"r16"
block|,
literal|"r17"
block|,
literal|"r18"
block|,
literal|"r19"
block|,
literal|"r20"
block|,
literal|"r21"
block|,
literal|"r22"
block|,
literal|"r23"
block|,
literal|"r24"
block|,
literal|"r25"
block|,
literal|"r26"
block|,
literal|"r27"
block|,
literal|"r28"
block|,
literal|"r29"
block|,
literal|"r30"
block|,
literal|"r31"
block|,
literal|"r32"
block|,
literal|"r33"
block|,
literal|"r34"
block|,
literal|"r35"
block|,
literal|"r36"
block|,
literal|"r37"
block|,
literal|"r38"
block|,
literal|"r39"
block|,
literal|"r40"
block|,
literal|"r41"
block|,
literal|"r42"
block|,
literal|"r43"
block|,
literal|"r44"
block|,
literal|"r45"
block|,
literal|"r46"
block|,
literal|"r47"
block|,
literal|"r48"
block|,
literal|"r49"
block|,
literal|"r50"
block|,
literal|"r51"
block|,
literal|"r52"
block|,
literal|"r53"
block|,
literal|"r54"
block|,
literal|"r55"
block|,
literal|"r56"
block|,
literal|"r57"
block|,
literal|"r58"
block|,
literal|"r59"
block|,
literal|"r60"
block|,
literal|"r61"
block|,
literal|"r62"
block|,
literal|"r63"
block|,
literal|"r64"
block|,
literal|"r65"
block|,
literal|"r66"
block|,
literal|"r67"
block|,
literal|"r68"
block|,
literal|"r69"
block|,
literal|"r70"
block|,
literal|"r71"
block|,
literal|"r72"
block|,
literal|"r73"
block|,
literal|"r74"
block|,
literal|"r75"
block|,
literal|"r76"
block|,
literal|"r77"
block|,
literal|"r78"
block|,
literal|"r79"
block|,
literal|"r80"
block|,
literal|"r81"
block|,
literal|"r82"
block|,
literal|"r83"
block|,
literal|"r84"
block|,
literal|"r85"
block|,
literal|"r86"
block|,
literal|"r87"
block|,
literal|"r88"
block|,
literal|"r89"
block|,
literal|"r90"
block|,
literal|"r91"
block|,
literal|"r92"
block|,
literal|"r93"
block|,
literal|"r94"
block|,
literal|"r95"
block|,
literal|"r96"
block|,
literal|"r97"
block|,
literal|"r98"
block|,
literal|"r99"
block|,
literal|"r100"
block|,
literal|"r101"
block|,
literal|"r102"
block|,
literal|"r103"
block|,
literal|"r104"
block|,
literal|"r105"
block|,
literal|"r106"
block|,
literal|"r107"
block|,
literal|"r108"
block|,
literal|"r109"
block|,
literal|"r110"
block|,
literal|"r111"
block|,
literal|"r112"
block|,
literal|"r113"
block|,
literal|"r114"
block|,
literal|"r115"
block|,
literal|"r116"
block|,
literal|"r117"
block|,
literal|"r118"
block|,
literal|"r119"
block|,
literal|"r120"
block|,
literal|"r121"
block|,
literal|"r122"
block|,
literal|"r123"
block|,
literal|"r124"
block|,
literal|"r125"
block|,
literal|"r126"
block|,
literal|"r127"
block|,
literal|"f0"
block|,
literal|"f1"
block|,
literal|"f2"
block|,
literal|"f3"
block|,
literal|"f4"
block|,
literal|"f5"
block|,
literal|"f6"
block|,
literal|"f7"
block|,
literal|"f8"
block|,
literal|"f9"
block|,
literal|"f10"
block|,
literal|"f11"
block|,
literal|"f12"
block|,
literal|"f13"
block|,
literal|"f14"
block|,
literal|"f15"
block|,
literal|"f16"
block|,
literal|"f17"
block|,
literal|"f18"
block|,
literal|"f19"
block|,
literal|"f20"
block|,
literal|"f21"
block|,
literal|"f22"
block|,
literal|"f23"
block|,
literal|"f24"
block|,
literal|"f25"
block|,
literal|"f26"
block|,
literal|"f27"
block|,
literal|"f28"
block|,
literal|"f29"
block|,
literal|"f30"
block|,
literal|"f31"
block|,
literal|"f32"
block|,
literal|"f33"
block|,
literal|"f34"
block|,
literal|"f35"
block|,
literal|"f36"
block|,
literal|"f37"
block|,
literal|"f38"
block|,
literal|"f39"
block|,
literal|"f40"
block|,
literal|"f41"
block|,
literal|"f42"
block|,
literal|"f43"
block|,
literal|"f44"
block|,
literal|"f45"
block|,
literal|"f46"
block|,
literal|"f47"
block|,
literal|"f48"
block|,
literal|"f49"
block|,
literal|"f50"
block|,
literal|"f51"
block|,
literal|"f52"
block|,
literal|"f53"
block|,
literal|"f54"
block|,
literal|"f55"
block|,
literal|"f56"
block|,
literal|"f57"
block|,
literal|"f58"
block|,
literal|"f59"
block|,
literal|"f60"
block|,
literal|"f61"
block|,
literal|"f62"
block|,
literal|"f63"
block|,
literal|"f64"
block|,
literal|"f65"
block|,
literal|"f66"
block|,
literal|"f67"
block|,
literal|"f68"
block|,
literal|"f69"
block|,
literal|"f70"
block|,
literal|"f71"
block|,
literal|"f72"
block|,
literal|"f73"
block|,
literal|"f74"
block|,
literal|"f75"
block|,
literal|"f76"
block|,
literal|"f77"
block|,
literal|"f78"
block|,
literal|"f79"
block|,
literal|"f80"
block|,
literal|"f81"
block|,
literal|"f82"
block|,
literal|"f83"
block|,
literal|"f84"
block|,
literal|"f85"
block|,
literal|"f86"
block|,
literal|"f87"
block|,
literal|"f88"
block|,
literal|"f89"
block|,
literal|"f90"
block|,
literal|"f91"
block|,
literal|"f92"
block|,
literal|"f93"
block|,
literal|"f94"
block|,
literal|"f95"
block|,
literal|"f96"
block|,
literal|"f97"
block|,
literal|"f98"
block|,
literal|"f99"
block|,
literal|"f100"
block|,
literal|"f101"
block|,
literal|"f102"
block|,
literal|"f103"
block|,
literal|"f104"
block|,
literal|"f105"
block|,
literal|"f106"
block|,
literal|"f107"
block|,
literal|"f108"
block|,
literal|"f109"
block|,
literal|"f110"
block|,
literal|"f111"
block|,
literal|"f112"
block|,
literal|"f113"
block|,
literal|"f114"
block|,
literal|"f115"
block|,
literal|"f116"
block|,
literal|"f117"
block|,
literal|"f118"
block|,
literal|"f119"
block|,
literal|"f120"
block|,
literal|"f121"
block|,
literal|"f122"
block|,
literal|"f123"
block|,
literal|"f124"
block|,
literal|"f125"
block|,
literal|"f126"
block|,
literal|"f127"
block|,
literal|"p0"
block|,
literal|"p1"
block|,
literal|"p2"
block|,
literal|"p3"
block|,
literal|"p4"
block|,
literal|"p5"
block|,
literal|"p6"
block|,
literal|"p7"
block|,
literal|"p8"
block|,
literal|"p9"
block|,
literal|"p10"
block|,
literal|"p11"
block|,
literal|"p12"
block|,
literal|"p13"
block|,
literal|"p14"
block|,
literal|"p15"
block|,
literal|"p16"
block|,
literal|"p17"
block|,
literal|"p18"
block|,
literal|"p19"
block|,
literal|"p20"
block|,
literal|"p21"
block|,
literal|"p22"
block|,
literal|"p23"
block|,
literal|"p24"
block|,
literal|"p25"
block|,
literal|"p26"
block|,
literal|"p27"
block|,
literal|"p28"
block|,
literal|"p29"
block|,
literal|"p30"
block|,
literal|"p31"
block|,
literal|"p32"
block|,
literal|"p33"
block|,
literal|"p34"
block|,
literal|"p35"
block|,
literal|"p36"
block|,
literal|"p37"
block|,
literal|"p38"
block|,
literal|"p39"
block|,
literal|"p40"
block|,
literal|"p41"
block|,
literal|"p42"
block|,
literal|"p43"
block|,
literal|"p44"
block|,
literal|"p45"
block|,
literal|"p46"
block|,
literal|"p47"
block|,
literal|"p48"
block|,
literal|"p49"
block|,
literal|"p50"
block|,
literal|"p51"
block|,
literal|"p52"
block|,
literal|"p53"
block|,
literal|"p54"
block|,
literal|"p55"
block|,
literal|"p56"
block|,
literal|"p57"
block|,
literal|"p58"
block|,
literal|"p59"
block|,
literal|"p60"
block|,
literal|"p61"
block|,
literal|"p62"
block|,
literal|"p63"
block|,
literal|"b0"
block|,
literal|"b1"
block|,
literal|"b2"
block|,
literal|"b3"
block|,
literal|"b4"
block|,
literal|"b5"
block|,
literal|"b6"
block|,
literal|"b7"
block|,
literal|"vfp"
block|,
literal|"vrap"
block|,
literal|"pr"
block|,
literal|"ip"
block|,
literal|"psr"
block|,
literal|"cfm"
block|,
literal|"kr0"
block|,
literal|"kr1"
block|,
literal|"kr2"
block|,
literal|"kr3"
block|,
literal|"kr4"
block|,
literal|"kr5"
block|,
literal|"kr6"
block|,
literal|"kr7"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|"rsc"
block|,
literal|"bsp"
block|,
literal|"bspstore"
block|,
literal|"rnat"
block|,
literal|""
block|,
literal|"fcr"
block|,
literal|""
block|,
literal|""
block|,
literal|"eflag"
block|,
literal|"csd"
block|,
literal|"ssd"
block|,
literal|"cflg"
block|,
literal|"fsr"
block|,
literal|"fir"
block|,
literal|"fdr"
block|,
literal|""
block|,
literal|"ccv"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|"unat"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|"fpsr"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|"itc"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|"pfs"
block|,
literal|"lc"
block|,
literal|"ec"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|"nat0"
block|,
literal|"nat1"
block|,
literal|"nat2"
block|,
literal|"nat3"
block|,
literal|"nat4"
block|,
literal|"nat5"
block|,
literal|"nat6"
block|,
literal|"nat7"
block|,
literal|"nat8"
block|,
literal|"nat9"
block|,
literal|"nat10"
block|,
literal|"nat11"
block|,
literal|"nat12"
block|,
literal|"nat13"
block|,
literal|"nat14"
block|,
literal|"nat15"
block|,
literal|"nat16"
block|,
literal|"nat17"
block|,
literal|"nat18"
block|,
literal|"nat19"
block|,
literal|"nat20"
block|,
literal|"nat21"
block|,
literal|"nat22"
block|,
literal|"nat23"
block|,
literal|"nat24"
block|,
literal|"nat25"
block|,
literal|"nat26"
block|,
literal|"nat27"
block|,
literal|"nat28"
block|,
literal|"nat29"
block|,
literal|"nat30"
block|,
literal|"nat31"
block|,
literal|"nat32"
block|,
literal|"nat33"
block|,
literal|"nat34"
block|,
literal|"nat35"
block|,
literal|"nat36"
block|,
literal|"nat37"
block|,
literal|"nat38"
block|,
literal|"nat39"
block|,
literal|"nat40"
block|,
literal|"nat41"
block|,
literal|"nat42"
block|,
literal|"nat43"
block|,
literal|"nat44"
block|,
literal|"nat45"
block|,
literal|"nat46"
block|,
literal|"nat47"
block|,
literal|"nat48"
block|,
literal|"nat49"
block|,
literal|"nat50"
block|,
literal|"nat51"
block|,
literal|"nat52"
block|,
literal|"nat53"
block|,
literal|"nat54"
block|,
literal|"nat55"
block|,
literal|"nat56"
block|,
literal|"nat57"
block|,
literal|"nat58"
block|,
literal|"nat59"
block|,
literal|"nat60"
block|,
literal|"nat61"
block|,
literal|"nat62"
block|,
literal|"nat63"
block|,
literal|"nat64"
block|,
literal|"nat65"
block|,
literal|"nat66"
block|,
literal|"nat67"
block|,
literal|"nat68"
block|,
literal|"nat69"
block|,
literal|"nat70"
block|,
literal|"nat71"
block|,
literal|"nat72"
block|,
literal|"nat73"
block|,
literal|"nat74"
block|,
literal|"nat75"
block|,
literal|"nat76"
block|,
literal|"nat77"
block|,
literal|"nat78"
block|,
literal|"nat79"
block|,
literal|"nat80"
block|,
literal|"nat81"
block|,
literal|"nat82"
block|,
literal|"nat83"
block|,
literal|"nat84"
block|,
literal|"nat85"
block|,
literal|"nat86"
block|,
literal|"nat87"
block|,
literal|"nat88"
block|,
literal|"nat89"
block|,
literal|"nat90"
block|,
literal|"nat91"
block|,
literal|"nat92"
block|,
literal|"nat93"
block|,
literal|"nat94"
block|,
literal|"nat95"
block|,
literal|"nat96"
block|,
literal|"nat97"
block|,
literal|"nat98"
block|,
literal|"nat99"
block|,
literal|"nat100"
block|,
literal|"nat101"
block|,
literal|"nat102"
block|,
literal|"nat103"
block|,
literal|"nat104"
block|,
literal|"nat105"
block|,
literal|"nat106"
block|,
literal|"nat107"
block|,
literal|"nat108"
block|,
literal|"nat109"
block|,
literal|"nat110"
block|,
literal|"nat111"
block|,
literal|"nat112"
block|,
literal|"nat113"
block|,
literal|"nat114"
block|,
literal|"nat115"
block|,
literal|"nat116"
block|,
literal|"nat117"
block|,
literal|"nat118"
block|,
literal|"nat119"
block|,
literal|"nat120"
block|,
literal|"nat121"
block|,
literal|"nat122"
block|,
literal|"nat123"
block|,
literal|"nat124"
block|,
literal|"nat125"
block|,
literal|"nat126"
block|,
literal|"nat127"
block|, }
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|frame_extra_info
block|{
name|CORE_ADDR
name|bsp
decl_stmt|;
comment|/* points at r32 for the current frame */
name|CORE_ADDR
name|cfm
decl_stmt|;
comment|/* cfm value for current frame */
name|int
name|sof
decl_stmt|;
comment|/* Size of frame  (decoded from cfm value) */
name|int
name|sol
decl_stmt|;
comment|/* Size of locals (decoded from cfm value) */
name|CORE_ADDR
name|after_prologue
decl_stmt|;
comment|/* Address of first instruction after the last 			   prologue instruction;  Note that there may 			   be instructions from the function's body 			   intermingled with the prologue. */
name|int
name|mem_stack_frame_size
decl_stmt|;
comment|/* Size of the memory stack frame (may be zero), 			   or -1 if it has not been determined yet. */
name|int
name|fp_reg
decl_stmt|;
comment|/* Register number (if any) used a frame pointer 			   for this frame.  0 if no register is being used 			   as the frame pointer. */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|gdbarch_tdep
block|{
name|int
name|os_ident
decl_stmt|;
comment|/* From the ELF header, one of the ELFOSABI_                            constants: ELFOSABI_LINUX, ELFOSABI_AIX, 			   etc. */
name|CORE_ADDR
function_decl|(
modifier|*
name|sigcontext_register_address
function_decl|)
parameter_list|(
name|CORE_ADDR
parameter_list|,
name|int
parameter_list|)
function_decl|;
comment|/* OS specific function which, given a frame address 			   and register number, returns the offset to the 			   given register from the start of the frame. */
name|CORE_ADDR
function_decl|(
modifier|*
name|find_global_pointer
function_decl|)
parameter_list|(
name|CORE_ADDR
parameter_list|)
function_decl|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|SIGCONTEXT_REGISTER_ADDRESS
define|\
value|(gdbarch_tdep (current_gdbarch)->sigcontext_register_address)
end_define

begin_define
define|#
directive|define
name|FIND_GLOBAL_POINTER
define|\
value|(gdbarch_tdep (current_gdbarch)->find_global_pointer)
end_define

begin_function
specifier|static
name|char
modifier|*
name|ia64_register_name
parameter_list|(
name|int
name|reg
parameter_list|)
block|{
return|return
name|ia64_register_names
index|[
name|reg
index|]
return|;
block|}
end_function

begin_function
name|int
name|ia64_register_raw_size
parameter_list|(
name|int
name|reg
parameter_list|)
block|{
return|return
operator|(
name|IA64_FR0_REGNUM
operator|<=
name|reg
operator|&&
name|reg
operator|<=
name|IA64_FR127_REGNUM
operator|)
condition|?
literal|16
else|:
literal|8
return|;
block|}
end_function

begin_function
name|int
name|ia64_register_virtual_size
parameter_list|(
name|int
name|reg
parameter_list|)
block|{
return|return
operator|(
name|IA64_FR0_REGNUM
operator|<=
name|reg
operator|&&
name|reg
operator|<=
name|IA64_FR127_REGNUM
operator|)
condition|?
literal|16
else|:
literal|8
return|;
block|}
end_function

begin_comment
comment|/* Return true iff register N's virtual format is different from    its raw format. */
end_comment

begin_function
name|int
name|ia64_register_convertible
parameter_list|(
name|int
name|nr
parameter_list|)
block|{
return|return
operator|(
name|IA64_FR0_REGNUM
operator|<=
name|nr
operator|&&
name|nr
operator|<=
name|IA64_FR127_REGNUM
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|const
name|struct
name|floatformat
name|floatformat_ia64_ext
init|=
block|{
name|floatformat_little
block|,
literal|82
block|,
literal|0
block|,
literal|1
block|,
literal|17
block|,
literal|65535
block|,
literal|0x1ffff
block|,
literal|18
block|,
literal|64
block|,
name|floatformat_intbit_yes
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|ia64_register_convert_to_virtual
parameter_list|(
name|int
name|regnum
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|char
modifier|*
name|from
parameter_list|,
name|char
modifier|*
name|to
parameter_list|)
block|{
if|if
condition|(
name|regnum
operator|>=
name|IA64_FR0_REGNUM
operator|&&
name|regnum
operator|<=
name|IA64_FR127_REGNUM
condition|)
block|{
name|DOUBLEST
name|val
decl_stmt|;
name|floatformat_to_doublest
argument_list|(
operator|&
name|floatformat_ia64_ext
argument_list|,
name|from
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|store_floating
argument_list|(
name|to
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"ia64_register_convert_to_virtual called with non floating point register number"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ia64_register_convert_to_raw
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|int
name|regnum
parameter_list|,
name|char
modifier|*
name|from
parameter_list|,
name|char
modifier|*
name|to
parameter_list|)
block|{
if|if
condition|(
name|regnum
operator|>=
name|IA64_FR0_REGNUM
operator|&&
name|regnum
operator|<=
name|IA64_FR127_REGNUM
condition|)
block|{
name|DOUBLEST
name|val
init|=
name|extract_floating
argument_list|(
name|from
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
name|floatformat_from_doublest
argument_list|(
operator|&
name|floatformat_ia64_ext
argument_list|,
operator|&
name|val
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"ia64_register_convert_to_raw called with non floating point register number"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|type
modifier|*
name|ia64_register_virtual_type
parameter_list|(
name|int
name|reg
parameter_list|)
block|{
if|if
condition|(
name|reg
operator|>=
name|IA64_FR0_REGNUM
operator|&&
name|reg
operator|<=
name|IA64_FR127_REGNUM
condition|)
return|return
name|builtin_type_long_double
return|;
else|else
return|return
name|builtin_type_long
return|;
block|}
end_function

begin_function
name|int
name|ia64_register_byte
parameter_list|(
name|int
name|reg
parameter_list|)
block|{
return|return
operator|(
literal|8
operator|*
name|reg
operator|)
operator|+
operator|(
name|reg
operator|<=
name|IA64_FR0_REGNUM
condition|?
literal|0
else|:
literal|8
operator|*
operator|(
operator|(
name|reg
operator|>
name|IA64_FR127_REGNUM
operator|)
condition|?
literal|128
else|:
name|reg
operator|-
name|IA64_FR0_REGNUM
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Read the given register from a sigcontext structure in the    specified frame.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|read_sigcontext_register
parameter_list|(
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|,
name|int
name|regnum
parameter_list|)
block|{
name|CORE_ADDR
name|regaddr
decl_stmt|;
if|if
condition|(
name|frame
operator|==
name|NULL
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"read_sigcontext_register: NULL frame"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|frame
operator|->
name|signal_handler_caller
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"read_sigcontext_register: frame not a signal_handler_caller"
argument_list|)
expr_stmt|;
if|if
condition|(
name|SIGCONTEXT_REGISTER_ADDRESS
operator|==
literal|0
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"read_sigcontext_register: SIGCONTEXT_REGISTER_ADDRESS is 0"
argument_list|)
expr_stmt|;
name|regaddr
operator|=
name|SIGCONTEXT_REGISTER_ADDRESS
argument_list|(
name|frame
operator|->
name|frame
argument_list|,
name|regnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|regaddr
condition|)
return|return
name|read_memory_integer
argument_list|(
name|regaddr
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|)
return|;
else|else
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"read_sigcontext_register: Register %d not in struct sigcontext"
argument_list|,
name|regnum
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Extract ``len'' bits from an instruction bundle starting at    bit ``from''.  */
end_comment

begin_function
specifier|static
name|long
name|long
name|extract_bit_field
parameter_list|(
name|char
modifier|*
name|bundle
parameter_list|,
name|int
name|from
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|long
name|long
name|result
init|=
literal|0LL
decl_stmt|;
name|int
name|to
init|=
name|from
operator|+
name|len
decl_stmt|;
name|int
name|from_byte
init|=
name|from
operator|/
literal|8
decl_stmt|;
name|int
name|to_byte
init|=
name|to
operator|/
literal|8
decl_stmt|;
name|unsigned
name|char
modifier|*
name|b
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|bundle
decl_stmt|;
name|unsigned
name|char
name|c
decl_stmt|;
name|int
name|lshift
decl_stmt|;
name|int
name|i
decl_stmt|;
name|c
operator|=
name|b
index|[
name|from_byte
index|]
expr_stmt|;
if|if
condition|(
name|from_byte
operator|==
name|to_byte
condition|)
name|c
operator|=
operator|(
call|(
name|unsigned
name|char
call|)
argument_list|(
name|c
operator|<<
operator|(
literal|8
operator|-
name|to
operator|%
literal|8
operator|)
argument_list|)
operator|)
operator|>>
operator|(
literal|8
operator|-
name|to
operator|%
literal|8
operator|)
expr_stmt|;
name|result
operator|=
name|c
operator|>>
operator|(
name|from
operator|%
literal|8
operator|)
expr_stmt|;
name|lshift
operator|=
literal|8
operator|-
operator|(
name|from
operator|%
literal|8
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|from_byte
operator|+
literal|1
init|;
name|i
operator|<
name|to_byte
condition|;
name|i
operator|++
control|)
block|{
name|result
operator||=
operator|(
operator|(
name|long
name|long
operator|)
name|b
index|[
name|i
index|]
operator|)
operator|<<
name|lshift
expr_stmt|;
name|lshift
operator|+=
literal|8
expr_stmt|;
block|}
if|if
condition|(
name|from_byte
operator|<
name|to_byte
operator|&&
operator|(
name|to
operator|%
literal|8
operator|!=
literal|0
operator|)
condition|)
block|{
name|c
operator|=
name|b
index|[
name|to_byte
index|]
expr_stmt|;
name|c
operator|=
operator|(
call|(
name|unsigned
name|char
call|)
argument_list|(
name|c
operator|<<
operator|(
literal|8
operator|-
name|to
operator|%
literal|8
operator|)
argument_list|)
operator|)
operator|>>
operator|(
literal|8
operator|-
name|to
operator|%
literal|8
operator|)
expr_stmt|;
name|result
operator||=
operator|(
operator|(
name|long
name|long
operator|)
name|c
operator|)
operator|<<
name|lshift
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Replace the specified bits in an instruction bundle */
end_comment

begin_function
specifier|static
name|void
name|replace_bit_field
parameter_list|(
name|char
modifier|*
name|bundle
parameter_list|,
name|long
name|long
name|val
parameter_list|,
name|int
name|from
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|to
init|=
name|from
operator|+
name|len
decl_stmt|;
name|int
name|from_byte
init|=
name|from
operator|/
literal|8
decl_stmt|;
name|int
name|to_byte
init|=
name|to
operator|/
literal|8
decl_stmt|;
name|unsigned
name|char
modifier|*
name|b
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|bundle
decl_stmt|;
name|unsigned
name|char
name|c
decl_stmt|;
if|if
condition|(
name|from_byte
operator|==
name|to_byte
condition|)
block|{
name|unsigned
name|char
name|left
decl_stmt|,
name|right
decl_stmt|;
name|c
operator|=
name|b
index|[
name|from_byte
index|]
expr_stmt|;
name|left
operator|=
operator|(
name|c
operator|>>
operator|(
name|to
operator|%
literal|8
operator|)
operator|)
operator|<<
operator|(
name|to
operator|%
literal|8
operator|)
expr_stmt|;
name|right
operator|=
operator|(
call|(
name|unsigned
name|char
call|)
argument_list|(
name|c
operator|<<
operator|(
literal|8
operator|-
name|from
operator|%
literal|8
operator|)
argument_list|)
operator|)
operator|>>
operator|(
literal|8
operator|-
name|from
operator|%
literal|8
operator|)
expr_stmt|;
name|c
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|val
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|c
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|c
operator|<<
operator|(
name|from
operator|%
literal|8
operator|+
literal|8
operator|-
name|to
operator|%
literal|8
operator|)
argument_list|)
operator|>>
operator|(
literal|8
operator|-
name|to
operator|%
literal|8
operator|)
expr_stmt|;
name|c
operator||=
name|right
operator||
name|left
expr_stmt|;
name|b
index|[
name|from_byte
index|]
operator|=
name|c
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
name|c
operator|=
name|b
index|[
name|from_byte
index|]
expr_stmt|;
name|c
operator|=
operator|(
call|(
name|unsigned
name|char
call|)
argument_list|(
name|c
operator|<<
operator|(
literal|8
operator|-
name|from
operator|%
literal|8
operator|)
argument_list|)
operator|)
operator|>>
operator|(
literal|8
operator|-
name|from
operator|%
literal|8
operator|)
expr_stmt|;
name|c
operator|=
name|c
operator||
operator|(
name|val
operator|<<
operator|(
name|from
operator|%
literal|8
operator|)
operator|)
expr_stmt|;
name|b
index|[
name|from_byte
index|]
operator|=
name|c
expr_stmt|;
name|val
operator|>>=
literal|8
operator|-
name|from
operator|%
literal|8
expr_stmt|;
for|for
control|(
name|i
operator|=
name|from_byte
operator|+
literal|1
init|;
name|i
operator|<
name|to_byte
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
name|val
operator|&
literal|0xff
expr_stmt|;
name|val
operator|>>=
literal|8
expr_stmt|;
name|b
index|[
name|i
index|]
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
name|to
operator|%
literal|8
operator|!=
literal|0
condition|)
block|{
name|unsigned
name|char
name|cv
init|=
operator|(
name|unsigned
name|char
operator|)
name|val
decl_stmt|;
name|c
operator|=
name|b
index|[
name|to_byte
index|]
expr_stmt|;
name|c
operator|=
name|c
operator|>>
operator|(
name|to
operator|%
literal|8
operator|)
operator|<<
operator|(
name|to
operator|%
literal|8
operator|)
expr_stmt|;
name|c
operator||=
operator|(
call|(
name|unsigned
name|char
call|)
argument_list|(
name|cv
operator|<<
operator|(
literal|8
operator|-
name|to
operator|%
literal|8
operator|)
argument_list|)
operator|)
operator|>>
operator|(
literal|8
operator|-
name|to
operator|%
literal|8
operator|)
expr_stmt|;
name|b
index|[
name|to_byte
index|]
operator|=
name|c
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Return the contents of slot N (for N = 0, 1, or 2) in    and instruction bundle */
end_comment

begin_function
specifier|static
name|long
name|long
name|slotN_contents
parameter_list|(
name|char
modifier|*
name|bundle
parameter_list|,
name|int
name|slotnum
parameter_list|)
block|{
return|return
name|extract_bit_field
argument_list|(
name|bundle
argument_list|,
literal|5
operator|+
literal|41
operator|*
name|slotnum
argument_list|,
literal|41
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Store an instruction in an instruction bundle */
end_comment

begin_function
specifier|static
name|void
name|replace_slotN_contents
parameter_list|(
name|char
modifier|*
name|bundle
parameter_list|,
name|long
name|long
name|instr
parameter_list|,
name|int
name|slotnum
parameter_list|)
block|{
name|replace_bit_field
argument_list|(
name|bundle
argument_list|,
name|instr
argument_list|,
literal|5
operator|+
literal|41
operator|*
name|slotnum
argument_list|,
literal|41
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|enum
name|instruction_type
name|template_encoding_table
index|[
literal|32
index|]
index|[
literal|3
index|]
init|=
block|{
block|{
name|M
block|,
name|I
block|,
name|I
block|}
block|,
comment|/* 00 */
block|{
name|M
block|,
name|I
block|,
name|I
block|}
block|,
comment|/* 01 */
block|{
name|M
block|,
name|I
block|,
name|I
block|}
block|,
comment|/* 02 */
block|{
name|M
block|,
name|I
block|,
name|I
block|}
block|,
comment|/* 03 */
block|{
name|M
block|,
name|L
block|,
name|X
block|}
block|,
comment|/* 04 */
block|{
name|M
block|,
name|L
block|,
name|X
block|}
block|,
comment|/* 05 */
block|{
name|undefined
block|,
name|undefined
block|,
name|undefined
block|}
block|,
comment|/* 06 */
block|{
name|undefined
block|,
name|undefined
block|,
name|undefined
block|}
block|,
comment|/* 07 */
block|{
name|M
block|,
name|M
block|,
name|I
block|}
block|,
comment|/* 08 */
block|{
name|M
block|,
name|M
block|,
name|I
block|}
block|,
comment|/* 09 */
block|{
name|M
block|,
name|M
block|,
name|I
block|}
block|,
comment|/* 0A */
block|{
name|M
block|,
name|M
block|,
name|I
block|}
block|,
comment|/* 0B */
block|{
name|M
block|,
name|F
block|,
name|I
block|}
block|,
comment|/* 0C */
block|{
name|M
block|,
name|F
block|,
name|I
block|}
block|,
comment|/* 0D */
block|{
name|M
block|,
name|M
block|,
name|F
block|}
block|,
comment|/* 0E */
block|{
name|M
block|,
name|M
block|,
name|F
block|}
block|,
comment|/* 0F */
block|{
name|M
block|,
name|I
block|,
name|B
block|}
block|,
comment|/* 10 */
block|{
name|M
block|,
name|I
block|,
name|B
block|}
block|,
comment|/* 11 */
block|{
name|M
block|,
name|B
block|,
name|B
block|}
block|,
comment|/* 12 */
block|{
name|M
block|,
name|B
block|,
name|B
block|}
block|,
comment|/* 13 */
block|{
name|undefined
block|,
name|undefined
block|,
name|undefined
block|}
block|,
comment|/* 14 */
block|{
name|undefined
block|,
name|undefined
block|,
name|undefined
block|}
block|,
comment|/* 15 */
block|{
name|B
block|,
name|B
block|,
name|B
block|}
block|,
comment|/* 16 */
block|{
name|B
block|,
name|B
block|,
name|B
block|}
block|,
comment|/* 17 */
block|{
name|M
block|,
name|M
block|,
name|B
block|}
block|,
comment|/* 18 */
block|{
name|M
block|,
name|M
block|,
name|B
block|}
block|,
comment|/* 19 */
block|{
name|undefined
block|,
name|undefined
block|,
name|undefined
block|}
block|,
comment|/* 1A */
block|{
name|undefined
block|,
name|undefined
block|,
name|undefined
block|}
block|,
comment|/* 1B */
block|{
name|M
block|,
name|F
block|,
name|B
block|}
block|,
comment|/* 1C */
block|{
name|M
block|,
name|F
block|,
name|B
block|}
block|,
comment|/* 1D */
block|{
name|undefined
block|,
name|undefined
block|,
name|undefined
block|}
block|,
comment|/* 1E */
block|{
name|undefined
block|,
name|undefined
block|,
name|undefined
block|}
block|,
comment|/* 1F */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Fetch and (partially) decode an instruction at ADDR and return the    address of the next instruction to fetch.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|fetch_instruction
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|instruction_type
modifier|*
name|it
parameter_list|,
name|long
name|long
modifier|*
name|instr
parameter_list|)
block|{
name|char
name|bundle
index|[
name|BUNDLE_LEN
index|]
decl_stmt|;
name|int
name|slotnum
init|=
call|(
name|int
call|)
argument_list|(
name|addr
operator|&
literal|0x0f
argument_list|)
operator|/
name|SLOT_MULTIPLIER
decl_stmt|;
name|long
name|long
name|template
decl_stmt|;
name|int
name|val
decl_stmt|;
comment|/* Warn about slot numbers greater than 2.  We used to generate      an error here on the assumption that the user entered an invalid      address.  But, sometimes GDB itself requests an invalid address.      This can (easily) happen when execution stops in a function for      which there are no symbols.  The prologue scanner will attempt to      find the beginning of the function - if the nearest symbol      happens to not be aligned on a bundle boundary (16 bytes), the      resulting starting address will cause GDB to think that the slot      number is too large.       So we warn about it and set the slot number to zero.  It is      not necessarily a fatal condition, particularly if debugging      at the assembly language level.  */
if|if
condition|(
name|slotnum
operator|>
literal|2
condition|)
block|{
name|warning
argument_list|(
literal|"Can't fetch instructions for slot numbers greater than 2.\n"
literal|"Using slot 0 instead"
argument_list|)
expr_stmt|;
name|slotnum
operator|=
literal|0
expr_stmt|;
block|}
name|addr
operator|&=
operator|~
literal|0x0f
expr_stmt|;
name|val
operator|=
name|target_read_memory
argument_list|(
name|addr
argument_list|,
name|bundle
argument_list|,
name|BUNDLE_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
operator|*
name|instr
operator|=
name|slotN_contents
argument_list|(
name|bundle
argument_list|,
name|slotnum
argument_list|)
expr_stmt|;
name|template
operator|=
name|extract_bit_field
argument_list|(
name|bundle
argument_list|,
literal|0
argument_list|,
literal|5
argument_list|)
expr_stmt|;
operator|*
name|it
operator|=
name|template_encoding_table
index|[
operator|(
name|int
operator|)
name|template
index|]
index|[
name|slotnum
index|]
expr_stmt|;
if|if
condition|(
name|slotnum
operator|==
literal|2
operator|||
operator|(
name|slotnum
operator|==
literal|1
operator|&&
operator|*
name|it
operator|==
name|L
operator|)
condition|)
name|addr
operator|+=
literal|16
expr_stmt|;
else|else
name|addr
operator|+=
operator|(
name|slotnum
operator|+
literal|1
operator|)
operator|*
name|SLOT_MULTIPLIER
expr_stmt|;
return|return
name|addr
return|;
block|}
end_function

begin_comment
comment|/* There are 5 different break instructions (break.i, break.b,    break.m, break.f, and break.x), but they all have the same    encoding.  (The five bit template in the low five bits of the    instruction bundle distinguishes one from another.)        The runtime architecture manual specifies that break instructions    used for debugging purposes must have the upper two bits of the 21    bit immediate set to a 0 and a 1 respectively.  A breakpoint    instruction encodes the most significant bit of its 21 bit    immediate at bit 36 of the 41 bit instruction.  The penultimate msb    is at bit 25 which leads to the pattern below.          Originally, I had this set up to do, e.g, a "break.i 0x80000"  But    it turns out that 0x80000 was used as the syscall break in the early    simulators.  So I changed the pattern slightly to do "break.i 0x080001"    instead.  But that didn't work either (I later found out that this    pattern was used by the simulator that I was using.)  So I ended up    using the pattern seen below. */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_define
define|#
directive|define
name|BREAKPOINT
value|0x00002000040LL
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|BREAKPOINT
value|0x00003333300LL
end_define

begin_function
specifier|static
name|int
name|ia64_memory_insert_breakpoint
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|char
modifier|*
name|contents_cache
parameter_list|)
block|{
name|char
name|bundle
index|[
name|BUNDLE_LEN
index|]
decl_stmt|;
name|int
name|slotnum
init|=
call|(
name|int
call|)
argument_list|(
name|addr
operator|&
literal|0x0f
argument_list|)
operator|/
name|SLOT_MULTIPLIER
decl_stmt|;
name|long
name|long
name|instr
decl_stmt|;
name|int
name|val
decl_stmt|;
if|if
condition|(
name|slotnum
operator|>
literal|2
condition|)
name|error
argument_list|(
literal|"Can't insert breakpoint for slot numbers greater than 2."
argument_list|)
expr_stmt|;
name|addr
operator|&=
operator|~
literal|0x0f
expr_stmt|;
name|val
operator|=
name|target_read_memory
argument_list|(
name|addr
argument_list|,
name|bundle
argument_list|,
name|BUNDLE_LEN
argument_list|)
expr_stmt|;
name|instr
operator|=
name|slotN_contents
argument_list|(
name|bundle
argument_list|,
name|slotnum
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|contents_cache
argument_list|,
operator|&
name|instr
argument_list|,
sizeof|sizeof
argument_list|(
name|instr
argument_list|)
argument_list|)
expr_stmt|;
name|replace_slotN_contents
argument_list|(
name|bundle
argument_list|,
name|BREAKPOINT
argument_list|,
name|slotnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
name|target_write_memory
argument_list|(
name|addr
argument_list|,
name|bundle
argument_list|,
name|BUNDLE_LEN
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ia64_memory_remove_breakpoint
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|char
modifier|*
name|contents_cache
parameter_list|)
block|{
name|char
name|bundle
index|[
name|BUNDLE_LEN
index|]
decl_stmt|;
name|int
name|slotnum
init|=
operator|(
name|addr
operator|&
literal|0x0f
operator|)
operator|/
name|SLOT_MULTIPLIER
decl_stmt|;
name|long
name|long
name|instr
decl_stmt|;
name|int
name|val
decl_stmt|;
name|addr
operator|&=
operator|~
literal|0x0f
expr_stmt|;
name|val
operator|=
name|target_read_memory
argument_list|(
name|addr
argument_list|,
name|bundle
argument_list|,
name|BUNDLE_LEN
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|instr
argument_list|,
name|contents_cache
argument_list|,
sizeof|sizeof
name|instr
argument_list|)
expr_stmt|;
name|replace_slotN_contents
argument_list|(
name|bundle
argument_list|,
name|instr
argument_list|,
name|slotnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
name|target_write_memory
argument_list|(
name|addr
argument_list|,
name|bundle
argument_list|,
name|BUNDLE_LEN
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* We don't really want to use this, but remote.c needs to call it in order    to figure out if Z-packets are supported or not.  Oh, well. */
end_comment

begin_function
name|unsigned
name|char
modifier|*
name|ia64_breakpoint_from_pc
parameter_list|(
name|CORE_ADDR
modifier|*
name|pcptr
parameter_list|,
name|int
modifier|*
name|lenptr
parameter_list|)
block|{
specifier|static
name|unsigned
name|char
name|breakpoint
index|[]
init|=
block|{
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
operator|*
name|lenptr
operator|=
sizeof|sizeof
argument_list|(
name|breakpoint
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|*pcptr&= ~0x0f;
endif|#
directive|endif
return|return
name|breakpoint
return|;
block|}
end_function

begin_function
name|CORE_ADDR
name|ia64_read_pc
parameter_list|(
name|ptid_t
name|ptid
parameter_list|)
block|{
name|CORE_ADDR
name|psr_value
init|=
name|read_register_pid
argument_list|(
name|IA64_PSR_REGNUM
argument_list|,
name|ptid
argument_list|)
decl_stmt|;
name|CORE_ADDR
name|pc_value
init|=
name|read_register_pid
argument_list|(
name|IA64_IP_REGNUM
argument_list|,
name|ptid
argument_list|)
decl_stmt|;
name|int
name|slot_num
init|=
operator|(
name|psr_value
operator|>>
literal|41
operator|)
operator|&
literal|3
decl_stmt|;
return|return
name|pc_value
operator||
operator|(
name|slot_num
operator|*
name|SLOT_MULTIPLIER
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ia64_write_pc
parameter_list|(
name|CORE_ADDR
name|new_pc
parameter_list|,
name|ptid_t
name|ptid
parameter_list|)
block|{
name|int
name|slot_num
init|=
call|(
name|int
call|)
argument_list|(
name|new_pc
operator|&
literal|0xf
argument_list|)
operator|/
name|SLOT_MULTIPLIER
decl_stmt|;
name|CORE_ADDR
name|psr_value
init|=
name|read_register_pid
argument_list|(
name|IA64_PSR_REGNUM
argument_list|,
name|ptid
argument_list|)
decl_stmt|;
name|psr_value
operator|&=
operator|~
operator|(
literal|3LL
operator|<<
literal|41
operator|)
expr_stmt|;
name|psr_value
operator||=
call|(
name|CORE_ADDR
call|)
argument_list|(
name|slot_num
operator|&
literal|0x3
argument_list|)
operator|<<
literal|41
expr_stmt|;
name|new_pc
operator|&=
operator|~
literal|0xfLL
expr_stmt|;
name|write_register_pid
argument_list|(
name|IA64_PSR_REGNUM
argument_list|,
name|psr_value
argument_list|,
name|ptid
argument_list|)
expr_stmt|;
name|write_register_pid
argument_list|(
name|IA64_IP_REGNUM
argument_list|,
name|new_pc
argument_list|,
name|ptid
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|IS_NaT_COLLECTION_ADDR
parameter_list|(
name|addr
parameter_list|)
value|((((addr)>> 3)& 0x3f) == 0x3f)
end_define

begin_comment
comment|/* Returns the address of the slot that's NSLOTS slots away from    the address ADDR. NSLOTS may be positive or negative. */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|rse_address_add
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|int
name|nslots
parameter_list|)
block|{
name|CORE_ADDR
name|new_addr
decl_stmt|;
name|int
name|mandatory_nat_slots
init|=
name|nslots
operator|/
literal|63
decl_stmt|;
name|int
name|direction
init|=
name|nslots
operator|<
literal|0
condition|?
operator|-
literal|1
else|:
literal|1
decl_stmt|;
name|new_addr
operator|=
name|addr
operator|+
literal|8
operator|*
operator|(
name|nslots
operator|+
name|mandatory_nat_slots
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|new_addr
operator|>>
literal|9
operator|)
operator|!=
operator|(
operator|(
name|addr
operator|+
literal|8
operator|*
literal|64
operator|*
name|mandatory_nat_slots
operator|)
operator|>>
literal|9
operator|)
condition|)
name|new_addr
operator|+=
literal|8
operator|*
name|direction
expr_stmt|;
if|if
condition|(
name|IS_NaT_COLLECTION_ADDR
argument_list|(
name|new_addr
argument_list|)
condition|)
name|new_addr
operator|+=
literal|8
operator|*
name|direction
expr_stmt|;
return|return
name|new_addr
return|;
block|}
end_function

begin_comment
comment|/* The IA-64 frame chain is a bit odd.  We won't always have a frame    pointer, so we use the SP value as the FP for the purpose of    creating a frame.  There is sometimes a register (not fixed) which    is used as a frame pointer.  When this register exists, it is not    especially hard to determine which one is being used.  It isn't    even really hard to compute the frame chain, but it can be    computationally expensive.  So, instead of making life difficult    (and slow), we pick a more convenient representation of the frame    chain, knowing that we'll have to make some small adjustments    in other places.  (E.g, note that read_fp() and write_fp() are    actually read_sp() and write_sp() below in ia64_gdbarch_init()    below.)      Okay, so what is the frame chain exactly?  It'll be the SP value    at the time that the function in question was entered.     Note that this *should* actually the frame pointer for the current    function!  But as I note above, if we were to attempt to find the    address of the beginning of the previous frame, we'd waste a lot    of cycles for no good reason.  So instead, we simply choose to    represent the frame chain as the end of the previous frame instead    of the beginning.  */
end_comment

begin_function
name|CORE_ADDR
name|ia64_frame_chain
parameter_list|(
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|)
block|{
if|if
condition|(
name|frame
operator|->
name|signal_handler_caller
condition|)
return|return
name|read_sigcontext_register
argument_list|(
name|frame
argument_list|,
name|sp_regnum
argument_list|)
return|;
elseif|else
if|if
condition|(
name|PC_IN_CALL_DUMMY
argument_list|(
name|frame
operator|->
name|pc
argument_list|,
name|frame
operator|->
name|frame
argument_list|,
name|frame
operator|->
name|frame
argument_list|)
condition|)
return|return
name|frame
operator|->
name|frame
return|;
else|else
block|{
name|FRAME_INIT_SAVED_REGS
argument_list|(
name|frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame
operator|->
name|saved_regs
index|[
name|IA64_VFP_REGNUM
index|]
condition|)
return|return
name|read_memory_integer
argument_list|(
name|frame
operator|->
name|saved_regs
index|[
name|IA64_VFP_REGNUM
index|]
argument_list|,
literal|8
argument_list|)
return|;
else|else
return|return
name|frame
operator|->
name|frame
operator|+
name|frame
operator|->
name|extra_info
operator|->
name|mem_stack_frame_size
return|;
block|}
block|}
end_function

begin_function
name|CORE_ADDR
name|ia64_frame_saved_pc
parameter_list|(
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|)
block|{
if|if
condition|(
name|frame
operator|->
name|signal_handler_caller
condition|)
return|return
name|read_sigcontext_register
argument_list|(
name|frame
argument_list|,
name|pc_regnum
argument_list|)
return|;
elseif|else
if|if
condition|(
name|PC_IN_CALL_DUMMY
argument_list|(
name|frame
operator|->
name|pc
argument_list|,
name|frame
operator|->
name|frame
argument_list|,
name|frame
operator|->
name|frame
argument_list|)
condition|)
return|return
name|generic_read_register_dummy
argument_list|(
name|frame
operator|->
name|pc
argument_list|,
name|frame
operator|->
name|frame
argument_list|,
name|pc_regnum
argument_list|)
return|;
else|else
block|{
name|FRAME_INIT_SAVED_REGS
argument_list|(
name|frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame
operator|->
name|saved_regs
index|[
name|IA64_VRAP_REGNUM
index|]
condition|)
return|return
name|read_memory_integer
argument_list|(
name|frame
operator|->
name|saved_regs
index|[
name|IA64_VRAP_REGNUM
index|]
argument_list|,
literal|8
argument_list|)
return|;
elseif|else
if|if
condition|(
name|frame
operator|->
name|next
operator|&&
name|frame
operator|->
name|next
operator|->
name|signal_handler_caller
condition|)
return|return
name|read_sigcontext_register
argument_list|(
name|frame
operator|->
name|next
argument_list|,
name|IA64_BR0_REGNUM
argument_list|)
return|;
else|else
comment|/* either frameless, or not far enough along in the prologue... */
return|return
name|ia64_saved_pc_after_call
argument_list|(
name|frame
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Limit the number of skipped non-prologue instructions since examining    of the prologue is expensive.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_skip_non_prologue_insns
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Given PC representing the starting address of a function, and    LIM_PC which is the (sloppy) limit to which to scan when looking    for a prologue, attempt to further refine this limit by using    the line data in the symbol table.  If successful, a better guess    on where the prologue ends is returned, otherwise the previous    value of lim_pc is returned.  TRUST_LIMIT is a pointer to a flag    which will be set to indicate whether the returned limit may be    used with no further scanning in the event that the function is    frameless.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|refine_prologue_limit
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|CORE_ADDR
name|lim_pc
parameter_list|,
name|int
modifier|*
name|trust_limit
parameter_list|)
block|{
name|struct
name|symtab_and_line
name|prologue_sal
decl_stmt|;
name|CORE_ADDR
name|start_pc
init|=
name|pc
decl_stmt|;
comment|/* Start off not trusting the limit.  */
operator|*
name|trust_limit
operator|=
literal|0
expr_stmt|;
name|prologue_sal
operator|=
name|find_pc_line
argument_list|(
name|pc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|prologue_sal
operator|.
name|line
operator|!=
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
name|CORE_ADDR
name|addr
init|=
name|prologue_sal
operator|.
name|end
decl_stmt|;
comment|/* Handle the case in which compiler's optimizer/scheduler          has moved instructions into the prologue.  We scan ahead 	 in the function looking for address ranges whose corresponding 	 line number is less than or equal to the first one that we 	 found for the function.  (It can be less than when the 	 scheduler puts a body instruction before the first prologue 	 instruction.)  */
for|for
control|(
name|i
operator|=
literal|2
operator|*
name|max_skip_non_prologue_insns
init|;
name|i
operator|>
literal|0
operator|&&
operator|(
name|lim_pc
operator|==
literal|0
operator|||
name|addr
operator|<
name|lim_pc
operator|)
condition|;
name|i
operator|--
control|)
block|{
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|sal
operator|=
name|find_pc_line
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sal
operator|.
name|line
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|sal
operator|.
name|line
operator|<=
name|prologue_sal
operator|.
name|line
operator|&&
name|sal
operator|.
name|symtab
operator|==
name|prologue_sal
operator|.
name|symtab
condition|)
block|{
name|prologue_sal
operator|=
name|sal
expr_stmt|;
block|}
name|addr
operator|=
name|sal
operator|.
name|end
expr_stmt|;
block|}
if|if
condition|(
name|lim_pc
operator|==
literal|0
operator|||
name|prologue_sal
operator|.
name|end
operator|<
name|lim_pc
condition|)
block|{
name|lim_pc
operator|=
name|prologue_sal
operator|.
name|end
expr_stmt|;
if|if
condition|(
name|start_pc
operator|==
name|get_pc_function_start
argument_list|(
name|lim_pc
argument_list|)
condition|)
operator|*
name|trust_limit
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
name|lim_pc
return|;
block|}
end_function

begin_define
define|#
directive|define
name|isScratch
parameter_list|(
name|_regnum_
parameter_list|)
value|((_regnum_) == 2 || (_regnum_) == 3 \   || (8<= (_regnum_)&& (_regnum_)<= 11) \   || (14<= (_regnum_)&& (_regnum_)<= 31))
end_define

begin_define
define|#
directive|define
name|imm9
parameter_list|(
name|_instr_
parameter_list|)
define|\
value|( ((((_instr_)& 0x01000000000LL) ? -1 : 0)<< 8) \    | (((_instr_)& 0x00008000000LL)>> 20) \    | (((_instr_)& 0x00000001fc0LL)>> 6))
end_define

begin_function
specifier|static
name|CORE_ADDR
name|examine_prologue
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|CORE_ADDR
name|lim_pc
parameter_list|,
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|)
block|{
name|CORE_ADDR
name|next_pc
decl_stmt|;
name|CORE_ADDR
name|last_prologue_pc
init|=
name|pc
decl_stmt|;
name|instruction_type
name|it
decl_stmt|;
name|long
name|long
name|instr
decl_stmt|;
name|int
name|do_fsr_stuff
init|=
literal|0
decl_stmt|;
name|int
name|cfm_reg
init|=
literal|0
decl_stmt|;
name|int
name|ret_reg
init|=
literal|0
decl_stmt|;
name|int
name|fp_reg
init|=
literal|0
decl_stmt|;
name|int
name|unat_save_reg
init|=
literal|0
decl_stmt|;
name|int
name|pr_save_reg
init|=
literal|0
decl_stmt|;
name|int
name|mem_stack_frame_size
init|=
literal|0
decl_stmt|;
name|int
name|spill_reg
init|=
literal|0
decl_stmt|;
name|CORE_ADDR
name|spill_addr
init|=
literal|0
decl_stmt|;
name|char
name|instores
index|[
literal|8
index|]
decl_stmt|;
name|char
name|infpstores
index|[
literal|8
index|]
decl_stmt|;
name|int
name|trust_limit
decl_stmt|;
name|memset
argument_list|(
name|instores
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|instores
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|infpstores
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|infpstores
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame
operator|&&
operator|!
name|frame
operator|->
name|saved_regs
condition|)
block|{
name|frame_saved_regs_zalloc
argument_list|(
name|frame
argument_list|)
expr_stmt|;
name|do_fsr_stuff
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|frame
operator|&&
operator|!
name|do_fsr_stuff
operator|&&
name|frame
operator|->
name|extra_info
operator|->
name|after_prologue
operator|!=
literal|0
operator|&&
name|frame
operator|->
name|extra_info
operator|->
name|after_prologue
operator|<=
name|lim_pc
condition|)
return|return
name|frame
operator|->
name|extra_info
operator|->
name|after_prologue
return|;
name|lim_pc
operator|=
name|refine_prologue_limit
argument_list|(
name|pc
argument_list|,
name|lim_pc
argument_list|,
operator|&
name|trust_limit
argument_list|)
expr_stmt|;
comment|/* Must start with an alloc instruction */
name|next_pc
operator|=
name|fetch_instruction
argument_list|(
name|pc
argument_list|,
operator|&
name|it
argument_list|,
operator|&
name|instr
argument_list|)
expr_stmt|;
if|if
condition|(
name|pc
operator|<
name|lim_pc
operator|&&
name|next_pc
operator|&&
name|it
operator|==
name|M
operator|&&
operator|(
operator|(
name|instr
operator|&
literal|0x1ee0000003fLL
operator|)
operator|==
literal|0x02c00000000LL
operator|)
condition|)
block|{
comment|/* alloc */
name|int
name|sor
init|=
call|(
name|int
call|)
argument_list|(
operator|(
name|instr
operator|&
literal|0x00078000000LL
operator|)
operator|>>
literal|27
argument_list|)
decl_stmt|;
name|int
name|sol
init|=
call|(
name|int
call|)
argument_list|(
operator|(
name|instr
operator|&
literal|0x00007f00000LL
operator|)
operator|>>
literal|20
argument_list|)
decl_stmt|;
name|int
name|sof
init|=
call|(
name|int
call|)
argument_list|(
operator|(
name|instr
operator|&
literal|0x000000fe000LL
operator|)
operator|>>
literal|13
argument_list|)
decl_stmt|;
comment|/* Okay, so sor, sol, and sof aren't used right now; but perhaps          we could compare against the size given to us via the cfm as 	 either a sanity check or possibly to see if the frame has been 	 changed by a later alloc instruction... */
name|int
name|rN
init|=
call|(
name|int
call|)
argument_list|(
operator|(
name|instr
operator|&
literal|0x00000001fc0LL
operator|)
operator|>>
literal|6
argument_list|)
decl_stmt|;
name|cfm_reg
operator|=
name|rN
expr_stmt|;
name|last_prologue_pc
operator|=
name|next_pc
expr_stmt|;
name|pc
operator|=
name|next_pc
expr_stmt|;
block|}
else|else
block|{
name|pc
operator|=
name|lim_pc
expr_stmt|;
comment|/* Frameless: We're done early.  */
if|if
condition|(
name|trust_limit
condition|)
name|last_prologue_pc
operator|=
name|lim_pc
expr_stmt|;
block|}
comment|/* Loop, looking for prologue instructions, keeping track of      where preserved registers were spilled. */
while|while
condition|(
name|pc
operator|<
name|lim_pc
condition|)
block|{
name|next_pc
operator|=
name|fetch_instruction
argument_list|(
name|pc
argument_list|,
operator|&
name|it
argument_list|,
operator|&
name|instr
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_pc
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
operator|(
name|it
operator|==
name|B
operator|&&
operator|(
operator|(
name|instr
operator|&
literal|0x1e1f800003f
operator|)
operator|!=
literal|0x04000000000
operator|)
operator|)
operator|||
operator|(
operator|(
name|instr
operator|&
literal|0x3fLL
operator|)
operator|!=
literal|0LL
operator|)
condition|)
block|{
comment|/* Exit loop upon hitting a non-nop branch instruction  	     or a predicated instruction. */
break|break;
block|}
elseif|else
if|if
condition|(
name|it
operator|==
name|I
operator|&&
operator|(
operator|(
name|instr
operator|&
literal|0x1eff8000000LL
operator|)
operator|==
literal|0x00188000000LL
operator|)
condition|)
block|{
comment|/* Move from BR */
name|int
name|b2
init|=
call|(
name|int
call|)
argument_list|(
operator|(
name|instr
operator|&
literal|0x0000000e000LL
operator|)
operator|>>
literal|13
argument_list|)
decl_stmt|;
name|int
name|rN
init|=
call|(
name|int
call|)
argument_list|(
operator|(
name|instr
operator|&
literal|0x00000001fc0LL
operator|)
operator|>>
literal|6
argument_list|)
decl_stmt|;
name|int
name|qp
init|=
call|(
name|int
call|)
argument_list|(
name|instr
operator|&
literal|0x0000000003f
argument_list|)
decl_stmt|;
if|if
condition|(
name|qp
operator|==
literal|0
operator|&&
name|b2
operator|==
literal|0
operator|&&
name|rN
operator|>=
literal|32
operator|&&
name|ret_reg
operator|==
literal|0
condition|)
block|{
name|ret_reg
operator|=
name|rN
expr_stmt|;
name|last_prologue_pc
operator|=
name|next_pc
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|it
operator|==
name|I
operator|||
name|it
operator|==
name|M
operator|)
operator|&&
operator|(
operator|(
name|instr
operator|&
literal|0x1ee00000000LL
operator|)
operator|==
literal|0x10800000000LL
operator|)
condition|)
block|{
comment|/* adds rN = imm14, rM   (or mov rN, rM  when imm14 is 0) */
name|int
name|imm
init|=
call|(
name|int
call|)
argument_list|(
operator|(
operator|(
operator|(
name|instr
operator|&
literal|0x01000000000LL
operator|)
condition|?
operator|-
literal|1
else|:
literal|0
operator|)
operator|<<
literal|13
operator|)
operator||
operator|(
operator|(
name|instr
operator|&
literal|0x001f8000000LL
operator|)
operator|>>
literal|20
operator|)
operator||
operator|(
operator|(
name|instr
operator|&
literal|0x000000fe000LL
operator|)
operator|>>
literal|13
operator|)
argument_list|)
decl_stmt|;
name|int
name|rM
init|=
call|(
name|int
call|)
argument_list|(
operator|(
name|instr
operator|&
literal|0x00007f00000LL
operator|)
operator|>>
literal|20
argument_list|)
decl_stmt|;
name|int
name|rN
init|=
call|(
name|int
call|)
argument_list|(
operator|(
name|instr
operator|&
literal|0x00000001fc0LL
operator|)
operator|>>
literal|6
argument_list|)
decl_stmt|;
name|int
name|qp
init|=
call|(
name|int
call|)
argument_list|(
name|instr
operator|&
literal|0x0000000003fLL
argument_list|)
decl_stmt|;
if|if
condition|(
name|qp
operator|==
literal|0
operator|&&
name|rN
operator|>=
literal|32
operator|&&
name|imm
operator|==
literal|0
operator|&&
name|rM
operator|==
literal|12
operator|&&
name|fp_reg
operator|==
literal|0
condition|)
block|{
comment|/* mov rN, r12 */
name|fp_reg
operator|=
name|rN
expr_stmt|;
name|last_prologue_pc
operator|=
name|next_pc
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|qp
operator|==
literal|0
operator|&&
name|rN
operator|==
literal|12
operator|&&
name|rM
operator|==
literal|12
condition|)
block|{
comment|/* adds r12, -mem_stack_frame_size, r12 */
name|mem_stack_frame_size
operator|-=
name|imm
expr_stmt|;
name|last_prologue_pc
operator|=
name|next_pc
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|qp
operator|==
literal|0
operator|&&
name|rN
operator|==
literal|2
operator|&&
operator|(
operator|(
name|rM
operator|==
name|fp_reg
operator|&&
name|fp_reg
operator|!=
literal|0
operator|)
operator|||
name|rM
operator|==
literal|12
operator|)
condition|)
block|{
comment|/* adds r2, spilloffset, rFramePointer  	           or 		 adds r2, spilloffset, r12  	         Get ready for stf.spill or st8.spill instructions. 		 The address to start spilling at is loaded into r2.  		 FIXME:  Why r2?  That's what gcc currently uses; it 		 could well be different for other compilers.  */
comment|/* Hmm... whether or not this will work will depend on 	         where the pc is.  If it's still early in the prologue 		 this'll be wrong.  FIXME */
name|spill_addr
operator|=
operator|(
name|frame
condition|?
name|frame
operator|->
name|frame
else|:
literal|0
operator|)
operator|+
operator|(
name|rM
operator|==
literal|12
condition|?
literal|0
else|:
name|mem_stack_frame_size
operator|)
operator|+
name|imm
expr_stmt|;
name|spill_reg
operator|=
name|rN
expr_stmt|;
name|last_prologue_pc
operator|=
name|next_pc
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|it
operator|==
name|M
operator|&&
operator|(
operator|(
operator|(
name|instr
operator|&
literal|0x1efc0000000LL
operator|)
operator|==
literal|0x0eec0000000LL
operator|)
operator|||
operator|(
operator|(
name|instr
operator|&
literal|0x1ffc8000000LL
operator|)
operator|==
literal|0x0cec0000000LL
operator|)
operator|)
condition|)
block|{
comment|/* stf.spill [rN] = fM, imm9 	     or 	     stf.spill [rN] = fM  */
name|int
name|imm
init|=
name|imm9
argument_list|(
name|instr
argument_list|)
decl_stmt|;
name|int
name|rN
init|=
call|(
name|int
call|)
argument_list|(
operator|(
name|instr
operator|&
literal|0x00007f00000LL
operator|)
operator|>>
literal|20
argument_list|)
decl_stmt|;
name|int
name|fM
init|=
call|(
name|int
call|)
argument_list|(
operator|(
name|instr
operator|&
literal|0x000000fe000LL
operator|)
operator|>>
literal|13
argument_list|)
decl_stmt|;
name|int
name|qp
init|=
call|(
name|int
call|)
argument_list|(
name|instr
operator|&
literal|0x0000000003fLL
argument_list|)
decl_stmt|;
if|if
condition|(
name|qp
operator|==
literal|0
operator|&&
name|rN
operator|==
name|spill_reg
operator|&&
name|spill_addr
operator|!=
literal|0
operator|&&
operator|(
operator|(
literal|2
operator|<=
name|fM
operator|&&
name|fM
operator|<=
literal|5
operator|)
operator|||
operator|(
literal|16
operator|<=
name|fM
operator|&&
name|fM
operator|<=
literal|31
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|do_fsr_stuff
condition|)
name|frame
operator|->
name|saved_regs
index|[
name|IA64_FR0_REGNUM
operator|+
name|fM
index|]
operator|=
name|spill_addr
expr_stmt|;
if|if
condition|(
operator|(
name|instr
operator|&
literal|0x1efc0000000
operator|)
operator|==
literal|0x0eec0000000
condition|)
name|spill_addr
operator|+=
name|imm
expr_stmt|;
else|else
name|spill_addr
operator|=
literal|0
expr_stmt|;
comment|/* last one; must be done */
name|last_prologue_pc
operator|=
name|next_pc
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|it
operator|==
name|M
operator|&&
operator|(
operator|(
name|instr
operator|&
literal|0x1eff8000000LL
operator|)
operator|==
literal|0x02110000000LL
operator|)
operator|)
operator|||
operator|(
name|it
operator|==
name|I
operator|&&
operator|(
operator|(
name|instr
operator|&
literal|0x1eff8000000LL
operator|)
operator|==
literal|0x00050000000LL
operator|)
operator|)
condition|)
block|{
comment|/* mov.m rN = arM    	       or  	     mov.i rN = arM */
name|int
name|arM
init|=
call|(
name|int
call|)
argument_list|(
operator|(
name|instr
operator|&
literal|0x00007f00000LL
operator|)
operator|>>
literal|20
argument_list|)
decl_stmt|;
name|int
name|rN
init|=
call|(
name|int
call|)
argument_list|(
operator|(
name|instr
operator|&
literal|0x00000001fc0LL
operator|)
operator|>>
literal|6
argument_list|)
decl_stmt|;
name|int
name|qp
init|=
call|(
name|int
call|)
argument_list|(
name|instr
operator|&
literal|0x0000000003fLL
argument_list|)
decl_stmt|;
if|if
condition|(
name|qp
operator|==
literal|0
operator|&&
name|isScratch
argument_list|(
name|rN
argument_list|)
operator|&&
name|arM
operator|==
literal|36
comment|/* ar.unat */
condition|)
block|{
comment|/* We have something like "mov.m r3 = ar.unat".  Remember the 		 r3 (or whatever) and watch for a store of this register... */
name|unat_save_reg
operator|=
name|rN
expr_stmt|;
name|last_prologue_pc
operator|=
name|next_pc
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|it
operator|==
name|I
operator|&&
operator|(
operator|(
name|instr
operator|&
literal|0x1eff8000000LL
operator|)
operator|==
literal|0x00198000000LL
operator|)
condition|)
block|{
comment|/* mov rN = pr */
name|int
name|rN
init|=
call|(
name|int
call|)
argument_list|(
operator|(
name|instr
operator|&
literal|0x00000001fc0LL
operator|)
operator|>>
literal|6
argument_list|)
decl_stmt|;
name|int
name|qp
init|=
call|(
name|int
call|)
argument_list|(
name|instr
operator|&
literal|0x0000000003fLL
argument_list|)
decl_stmt|;
if|if
condition|(
name|qp
operator|==
literal|0
operator|&&
name|isScratch
argument_list|(
name|rN
argument_list|)
condition|)
block|{
name|pr_save_reg
operator|=
name|rN
expr_stmt|;
name|last_prologue_pc
operator|=
name|next_pc
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|it
operator|==
name|M
operator|&&
operator|(
operator|(
operator|(
name|instr
operator|&
literal|0x1ffc8000000LL
operator|)
operator|==
literal|0x08cc0000000LL
operator|)
operator|||
operator|(
operator|(
name|instr
operator|&
literal|0x1efc0000000LL
operator|)
operator|==
literal|0x0acc0000000LL
operator|)
operator|)
condition|)
block|{
comment|/* st8 [rN] = rM  	      or 	     st8 [rN] = rM, imm9 */
name|int
name|rN
init|=
call|(
name|int
call|)
argument_list|(
operator|(
name|instr
operator|&
literal|0x00007f00000LL
operator|)
operator|>>
literal|20
argument_list|)
decl_stmt|;
name|int
name|rM
init|=
call|(
name|int
call|)
argument_list|(
operator|(
name|instr
operator|&
literal|0x000000fe000LL
operator|)
operator|>>
literal|13
argument_list|)
decl_stmt|;
name|int
name|qp
init|=
call|(
name|int
call|)
argument_list|(
name|instr
operator|&
literal|0x0000000003fLL
argument_list|)
decl_stmt|;
if|if
condition|(
name|qp
operator|==
literal|0
operator|&&
name|rN
operator|==
name|spill_reg
operator|&&
name|spill_addr
operator|!=
literal|0
operator|&&
operator|(
name|rM
operator|==
name|unat_save_reg
operator|||
name|rM
operator|==
name|pr_save_reg
operator|)
condition|)
block|{
comment|/* We've found a spill of either the UNAT register or the PR 	         register.  (Well, not exactly; what we've actually found is 		 a spill of the register that UNAT or PR was moved to). 		 Record that fact and move on... */
if|if
condition|(
name|rM
operator|==
name|unat_save_reg
condition|)
block|{
comment|/* Track UNAT register */
if|if
condition|(
name|do_fsr_stuff
condition|)
name|frame
operator|->
name|saved_regs
index|[
name|IA64_UNAT_REGNUM
index|]
operator|=
name|spill_addr
expr_stmt|;
name|unat_save_reg
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Track PR register */
if|if
condition|(
name|do_fsr_stuff
condition|)
name|frame
operator|->
name|saved_regs
index|[
name|IA64_PR_REGNUM
index|]
operator|=
name|spill_addr
expr_stmt|;
name|pr_save_reg
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|instr
operator|&
literal|0x1efc0000000LL
operator|)
operator|==
literal|0x0acc0000000LL
condition|)
comment|/* st8 [rN] = rM, imm9 */
name|spill_addr
operator|+=
name|imm9
argument_list|(
name|instr
argument_list|)
expr_stmt|;
else|else
name|spill_addr
operator|=
literal|0
expr_stmt|;
comment|/* must be done spilling */
name|last_prologue_pc
operator|=
name|next_pc
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|qp
operator|==
literal|0
operator|&&
literal|32
operator|<=
name|rM
operator|&&
name|rM
operator|<
literal|40
operator|&&
operator|!
name|instores
index|[
name|rM
operator|-
literal|32
index|]
condition|)
block|{
comment|/* Allow up to one store of each input register. */
name|instores
index|[
name|rM
operator|-
literal|32
index|]
operator|=
literal|1
expr_stmt|;
name|last_prologue_pc
operator|=
name|next_pc
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|it
operator|==
name|M
operator|&&
operator|(
operator|(
name|instr
operator|&
literal|0x1ff08000000LL
operator|)
operator|==
literal|0x08c00000000LL
operator|)
condition|)
block|{
comment|/* One of 	       st1 [rN] = rM 	       st2 [rN] = rM 	       st4 [rN] = rM 	       st8 [rN] = rM 	     Note that the st8 case is handled in the clause above. 	      	     Advance over stores of input registers. One store per input 	     register is permitted. */
name|int
name|rM
init|=
call|(
name|int
call|)
argument_list|(
operator|(
name|instr
operator|&
literal|0x000000fe000LL
operator|)
operator|>>
literal|13
argument_list|)
decl_stmt|;
name|int
name|qp
init|=
call|(
name|int
call|)
argument_list|(
name|instr
operator|&
literal|0x0000000003fLL
argument_list|)
decl_stmt|;
if|if
condition|(
name|qp
operator|==
literal|0
operator|&&
literal|32
operator|<=
name|rM
operator|&&
name|rM
operator|<
literal|40
operator|&&
operator|!
name|instores
index|[
name|rM
operator|-
literal|32
index|]
condition|)
block|{
name|instores
index|[
name|rM
operator|-
literal|32
index|]
operator|=
literal|1
expr_stmt|;
name|last_prologue_pc
operator|=
name|next_pc
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|it
operator|==
name|M
operator|&&
operator|(
operator|(
name|instr
operator|&
literal|0x1ff88000000LL
operator|)
operator|==
literal|0x0cc80000000LL
operator|)
condition|)
block|{
comment|/* Either 	       stfs [rN] = fM 	     or 	       stfd [rN] = fM  	     Advance over stores of floating point input registers.  Again 	     one store per register is permitted */
name|int
name|fM
init|=
call|(
name|int
call|)
argument_list|(
operator|(
name|instr
operator|&
literal|0x000000fe000LL
operator|)
operator|>>
literal|13
argument_list|)
decl_stmt|;
name|int
name|qp
init|=
call|(
name|int
call|)
argument_list|(
name|instr
operator|&
literal|0x0000000003fLL
argument_list|)
decl_stmt|;
if|if
condition|(
name|qp
operator|==
literal|0
operator|&&
literal|8
operator|<=
name|fM
operator|&&
name|fM
operator|<
literal|16
operator|&&
operator|!
name|infpstores
index|[
name|fM
operator|-
literal|8
index|]
condition|)
block|{
name|infpstores
index|[
name|fM
operator|-
literal|8
index|]
operator|=
literal|1
expr_stmt|;
name|last_prologue_pc
operator|=
name|next_pc
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|it
operator|==
name|M
operator|&&
operator|(
operator|(
operator|(
name|instr
operator|&
literal|0x1ffc8000000LL
operator|)
operator|==
literal|0x08ec0000000LL
operator|)
operator|||
operator|(
operator|(
name|instr
operator|&
literal|0x1efc0000000LL
operator|)
operator|==
literal|0x0aec0000000LL
operator|)
operator|)
condition|)
block|{
comment|/* st8.spill [rN] = rM 	       or 	     st8.spill [rN] = rM, imm9 */
name|int
name|rN
init|=
call|(
name|int
call|)
argument_list|(
operator|(
name|instr
operator|&
literal|0x00007f00000LL
operator|)
operator|>>
literal|20
argument_list|)
decl_stmt|;
name|int
name|rM
init|=
call|(
name|int
call|)
argument_list|(
operator|(
name|instr
operator|&
literal|0x000000fe000LL
operator|)
operator|>>
literal|13
argument_list|)
decl_stmt|;
name|int
name|qp
init|=
call|(
name|int
call|)
argument_list|(
name|instr
operator|&
literal|0x0000000003fLL
argument_list|)
decl_stmt|;
if|if
condition|(
name|qp
operator|==
literal|0
operator|&&
name|rN
operator|==
name|spill_reg
operator|&&
literal|4
operator|<=
name|rM
operator|&&
name|rM
operator|<=
literal|7
condition|)
block|{
comment|/* We've found a spill of one of the preserved general purpose 	         regs.  Record the spill address and advance the spill 		 register if appropriate. */
if|if
condition|(
name|do_fsr_stuff
condition|)
name|frame
operator|->
name|saved_regs
index|[
name|IA64_GR0_REGNUM
operator|+
name|rM
index|]
operator|=
name|spill_addr
expr_stmt|;
if|if
condition|(
operator|(
name|instr
operator|&
literal|0x1efc0000000LL
operator|)
operator|==
literal|0x0aec0000000LL
condition|)
comment|/* st8.spill [rN] = rM, imm9 */
name|spill_addr
operator|+=
name|imm9
argument_list|(
name|instr
argument_list|)
expr_stmt|;
else|else
name|spill_addr
operator|=
literal|0
expr_stmt|;
comment|/* Done spilling */
name|last_prologue_pc
operator|=
name|next_pc
expr_stmt|;
block|}
block|}
name|pc
operator|=
name|next_pc
expr_stmt|;
block|}
if|if
condition|(
name|do_fsr_stuff
condition|)
block|{
name|int
name|i
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|int
name|sor
decl_stmt|,
name|rrb_gr
decl_stmt|;
comment|/* Extract the size of the rotating portion of the stack        frame and the register rename base from the current        frame marker. */
name|sor
operator|=
operator|(
operator|(
name|frame
operator|->
name|extra_info
operator|->
name|cfm
operator|>>
literal|14
operator|)
operator|&
literal|0xf
operator|)
operator|*
literal|8
expr_stmt|;
name|rrb_gr
operator|=
operator|(
name|frame
operator|->
name|extra_info
operator|->
name|cfm
operator|>>
literal|18
operator|)
operator|&
literal|0x7f
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|addr
operator|=
name|frame
operator|->
name|extra_info
operator|->
name|bsp
init|;
name|i
operator|<
name|frame
operator|->
name|extra_info
operator|->
name|sof
condition|;
name|i
operator|++
operator|,
name|addr
operator|+=
literal|8
control|)
block|{
if|if
condition|(
name|IS_NaT_COLLECTION_ADDR
argument_list|(
name|addr
argument_list|)
condition|)
block|{
name|addr
operator|+=
literal|8
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
name|sor
condition|)
name|frame
operator|->
name|saved_regs
index|[
name|IA64_GR32_REGNUM
operator|+
operator|(
operator|(
name|i
operator|+
operator|(
name|sor
operator|-
name|rrb_gr
operator|)
operator|)
operator|%
name|sor
operator|)
index|]
operator|=
name|addr
expr_stmt|;
else|else
name|frame
operator|->
name|saved_regs
index|[
name|IA64_GR32_REGNUM
operator|+
name|i
index|]
operator|=
name|addr
expr_stmt|;
if|if
condition|(
name|i
operator|+
literal|32
operator|==
name|cfm_reg
condition|)
name|frame
operator|->
name|saved_regs
index|[
name|IA64_CFM_REGNUM
index|]
operator|=
name|addr
expr_stmt|;
if|if
condition|(
name|i
operator|+
literal|32
operator|==
name|ret_reg
condition|)
name|frame
operator|->
name|saved_regs
index|[
name|IA64_VRAP_REGNUM
index|]
operator|=
name|addr
expr_stmt|;
if|if
condition|(
name|i
operator|+
literal|32
operator|==
name|fp_reg
condition|)
name|frame
operator|->
name|saved_regs
index|[
name|IA64_VFP_REGNUM
index|]
operator|=
name|addr
expr_stmt|;
block|}
block|}
if|if
condition|(
name|frame
operator|&&
name|frame
operator|->
name|extra_info
condition|)
block|{
name|frame
operator|->
name|extra_info
operator|->
name|after_prologue
operator|=
name|last_prologue_pc
expr_stmt|;
name|frame
operator|->
name|extra_info
operator|->
name|mem_stack_frame_size
operator|=
name|mem_stack_frame_size
expr_stmt|;
name|frame
operator|->
name|extra_info
operator|->
name|fp_reg
operator|=
name|fp_reg
expr_stmt|;
block|}
return|return
name|last_prologue_pc
return|;
block|}
end_function

begin_function
name|CORE_ADDR
name|ia64_skip_prologue
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
return|return
name|examine_prologue
argument_list|(
name|pc
argument_list|,
name|pc
operator|+
literal|1024
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|ia64_frame_init_saved_regs
parameter_list|(
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|)
block|{
if|if
condition|(
name|frame
operator|->
name|saved_regs
condition|)
return|return;
if|if
condition|(
name|frame
operator|->
name|signal_handler_caller
operator|&&
name|SIGCONTEXT_REGISTER_ADDRESS
condition|)
block|{
name|int
name|regno
decl_stmt|;
name|frame_saved_regs_zalloc
argument_list|(
name|frame
argument_list|)
expr_stmt|;
name|frame
operator|->
name|saved_regs
index|[
name|IA64_VRAP_REGNUM
index|]
operator|=
name|SIGCONTEXT_REGISTER_ADDRESS
argument_list|(
name|frame
operator|->
name|frame
argument_list|,
name|IA64_IP_REGNUM
argument_list|)
expr_stmt|;
name|frame
operator|->
name|saved_regs
index|[
name|IA64_CFM_REGNUM
index|]
operator|=
name|SIGCONTEXT_REGISTER_ADDRESS
argument_list|(
name|frame
operator|->
name|frame
argument_list|,
name|IA64_CFM_REGNUM
argument_list|)
expr_stmt|;
name|frame
operator|->
name|saved_regs
index|[
name|IA64_PSR_REGNUM
index|]
operator|=
name|SIGCONTEXT_REGISTER_ADDRESS
argument_list|(
name|frame
operator|->
name|frame
argument_list|,
name|IA64_PSR_REGNUM
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|frame->saved_regs[IA64_BSP_REGNUM] =  	SIGCONTEXT_REGISTER_ADDRESS (frame->frame, IA64_BSP_REGNUM);
endif|#
directive|endif
name|frame
operator|->
name|saved_regs
index|[
name|IA64_RNAT_REGNUM
index|]
operator|=
name|SIGCONTEXT_REGISTER_ADDRESS
argument_list|(
name|frame
operator|->
name|frame
argument_list|,
name|IA64_RNAT_REGNUM
argument_list|)
expr_stmt|;
name|frame
operator|->
name|saved_regs
index|[
name|IA64_CCV_REGNUM
index|]
operator|=
name|SIGCONTEXT_REGISTER_ADDRESS
argument_list|(
name|frame
operator|->
name|frame
argument_list|,
name|IA64_CCV_REGNUM
argument_list|)
expr_stmt|;
name|frame
operator|->
name|saved_regs
index|[
name|IA64_UNAT_REGNUM
index|]
operator|=
name|SIGCONTEXT_REGISTER_ADDRESS
argument_list|(
name|frame
operator|->
name|frame
argument_list|,
name|IA64_UNAT_REGNUM
argument_list|)
expr_stmt|;
name|frame
operator|->
name|saved_regs
index|[
name|IA64_FPSR_REGNUM
index|]
operator|=
name|SIGCONTEXT_REGISTER_ADDRESS
argument_list|(
name|frame
operator|->
name|frame
argument_list|,
name|IA64_FPSR_REGNUM
argument_list|)
expr_stmt|;
name|frame
operator|->
name|saved_regs
index|[
name|IA64_PFS_REGNUM
index|]
operator|=
name|SIGCONTEXT_REGISTER_ADDRESS
argument_list|(
name|frame
operator|->
name|frame
argument_list|,
name|IA64_PFS_REGNUM
argument_list|)
expr_stmt|;
name|frame
operator|->
name|saved_regs
index|[
name|IA64_LC_REGNUM
index|]
operator|=
name|SIGCONTEXT_REGISTER_ADDRESS
argument_list|(
name|frame
operator|->
name|frame
argument_list|,
name|IA64_LC_REGNUM
argument_list|)
expr_stmt|;
for|for
control|(
name|regno
operator|=
name|IA64_GR1_REGNUM
init|;
name|regno
operator|<=
name|IA64_GR31_REGNUM
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|regno
operator|!=
name|sp_regnum
condition|)
name|frame
operator|->
name|saved_regs
index|[
name|regno
index|]
operator|=
name|SIGCONTEXT_REGISTER_ADDRESS
argument_list|(
name|frame
operator|->
name|frame
argument_list|,
name|regno
argument_list|)
expr_stmt|;
for|for
control|(
name|regno
operator|=
name|IA64_BR0_REGNUM
init|;
name|regno
operator|<=
name|IA64_BR7_REGNUM
condition|;
name|regno
operator|++
control|)
name|frame
operator|->
name|saved_regs
index|[
name|regno
index|]
operator|=
name|SIGCONTEXT_REGISTER_ADDRESS
argument_list|(
name|frame
operator|->
name|frame
argument_list|,
name|regno
argument_list|)
expr_stmt|;
for|for
control|(
name|regno
operator|=
name|IA64_FR2_REGNUM
init|;
name|regno
operator|<=
name|IA64_BR7_REGNUM
condition|;
name|regno
operator|++
control|)
name|frame
operator|->
name|saved_regs
index|[
name|regno
index|]
operator|=
name|SIGCONTEXT_REGISTER_ADDRESS
argument_list|(
name|frame
operator|->
name|frame
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CORE_ADDR
name|func_start
decl_stmt|;
name|func_start
operator|=
name|get_pc_function_start
argument_list|(
name|frame
operator|->
name|pc
argument_list|)
expr_stmt|;
name|examine_prologue
argument_list|(
name|func_start
argument_list|,
name|frame
operator|->
name|pc
argument_list|,
name|frame
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ia64_get_saved_register
parameter_list|(
name|char
modifier|*
name|raw_buffer
parameter_list|,
name|int
modifier|*
name|optimized
parameter_list|,
name|CORE_ADDR
modifier|*
name|addrp
parameter_list|,
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|,
name|int
name|regnum
parameter_list|,
name|enum
name|lval_type
modifier|*
name|lval
parameter_list|)
block|{
name|int
name|is_dummy_frame
decl_stmt|;
if|if
condition|(
operator|!
name|target_has_registers
condition|)
name|error
argument_list|(
literal|"No registers."
argument_list|)
expr_stmt|;
if|if
condition|(
name|optimized
operator|!=
name|NULL
condition|)
operator|*
name|optimized
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|addrp
operator|!=
name|NULL
condition|)
operator|*
name|addrp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|lval
operator|!=
name|NULL
condition|)
operator|*
name|lval
operator|=
name|not_lval
expr_stmt|;
name|is_dummy_frame
operator|=
name|PC_IN_CALL_DUMMY
argument_list|(
name|frame
operator|->
name|pc
argument_list|,
name|frame
operator|->
name|frame
argument_list|,
name|frame
operator|->
name|frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|regnum
operator|==
name|SP_REGNUM
operator|&&
name|frame
operator|->
name|next
condition|)
block|{
comment|/* Handle SP values for all frames but the topmost. */
name|store_address
argument_list|(
name|raw_buffer
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|,
name|frame
operator|->
name|frame
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|regnum
operator|==
name|IA64_BSP_REGNUM
condition|)
block|{
name|store_address
argument_list|(
name|raw_buffer
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|,
name|frame
operator|->
name|extra_info
operator|->
name|bsp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|regnum
operator|==
name|IA64_VFP_REGNUM
condition|)
block|{
comment|/* If the function in question uses an automatic register (r32-r127)          for the frame pointer, it'll be found by ia64_find_saved_register() 	 above.  If the function lacks one of these frame pointers, we can 	 still provide a value since we know the size of the frame */
name|CORE_ADDR
name|vfp
init|=
name|frame
operator|->
name|frame
operator|+
name|frame
operator|->
name|extra_info
operator|->
name|mem_stack_frame_size
decl_stmt|;
name|store_address
argument_list|(
name|raw_buffer
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|IA64_VFP_REGNUM
argument_list|)
argument_list|,
name|vfp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IA64_PR0_REGNUM
operator|<=
name|regnum
operator|&&
name|regnum
operator|<=
name|IA64_PR63_REGNUM
condition|)
block|{
name|char
modifier|*
name|pr_raw_buffer
init|=
name|alloca
argument_list|(
name|MAX_REGISTER_RAW_SIZE
argument_list|)
decl_stmt|;
name|int
name|pr_optim
decl_stmt|;
name|enum
name|lval_type
name|pr_lval
decl_stmt|;
name|CORE_ADDR
name|pr_addr
decl_stmt|;
name|int
name|prN_val
decl_stmt|;
name|ia64_get_saved_register
argument_list|(
name|pr_raw_buffer
argument_list|,
operator|&
name|pr_optim
argument_list|,
operator|&
name|pr_addr
argument_list|,
name|frame
argument_list|,
name|IA64_PR_REGNUM
argument_list|,
operator|&
name|pr_lval
argument_list|)
expr_stmt|;
if|if
condition|(
name|IA64_PR16_REGNUM
operator|<=
name|regnum
operator|&&
name|regnum
operator|<=
name|IA64_PR63_REGNUM
condition|)
block|{
comment|/* Fetch predicate register rename base from current frame 	     marker for this frame. */
name|int
name|rrb_pr
init|=
operator|(
name|frame
operator|->
name|extra_info
operator|->
name|cfm
operator|>>
literal|32
operator|)
operator|&
literal|0x3f
decl_stmt|;
comment|/* Adjust the register number to account for register rotation. */
name|regnum
operator|=
name|IA64_PR16_REGNUM
operator|+
operator|(
operator|(
name|regnum
operator|-
name|IA64_PR16_REGNUM
operator|)
operator|+
name|rrb_pr
operator|)
operator|%
literal|48
expr_stmt|;
block|}
name|prN_val
operator|=
name|extract_bit_field
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|pr_raw_buffer
argument_list|,
name|regnum
operator|-
name|IA64_PR0_REGNUM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|store_unsigned_integer
argument_list|(
name|raw_buffer
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|,
name|prN_val
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IA64_NAT0_REGNUM
operator|<=
name|regnum
operator|&&
name|regnum
operator|<=
name|IA64_NAT31_REGNUM
condition|)
block|{
name|char
modifier|*
name|unat_raw_buffer
init|=
name|alloca
argument_list|(
name|MAX_REGISTER_RAW_SIZE
argument_list|)
decl_stmt|;
name|int
name|unat_optim
decl_stmt|;
name|enum
name|lval_type
name|unat_lval
decl_stmt|;
name|CORE_ADDR
name|unat_addr
decl_stmt|;
name|int
name|unatN_val
decl_stmt|;
name|ia64_get_saved_register
argument_list|(
name|unat_raw_buffer
argument_list|,
operator|&
name|unat_optim
argument_list|,
operator|&
name|unat_addr
argument_list|,
name|frame
argument_list|,
name|IA64_UNAT_REGNUM
argument_list|,
operator|&
name|unat_lval
argument_list|)
expr_stmt|;
name|unatN_val
operator|=
name|extract_bit_field
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|unat_raw_buffer
argument_list|,
name|regnum
operator|-
name|IA64_NAT0_REGNUM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|store_unsigned_integer
argument_list|(
name|raw_buffer
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|,
name|unatN_val
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IA64_NAT32_REGNUM
operator|<=
name|regnum
operator|&&
name|regnum
operator|<=
name|IA64_NAT127_REGNUM
condition|)
block|{
name|int
name|natval
init|=
literal|0
decl_stmt|;
comment|/* Find address of general register corresponding to nat bit we're          interested in. */
name|CORE_ADDR
name|gr_addr
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|is_dummy_frame
condition|)
block|{
name|FRAME_INIT_SAVED_REGS
argument_list|(
name|frame
argument_list|)
expr_stmt|;
name|gr_addr
operator|=
name|frame
operator|->
name|saved_regs
index|[
name|regnum
operator|-
name|IA64_NAT0_REGNUM
operator|+
name|IA64_GR0_REGNUM
index|]
expr_stmt|;
block|}
if|if
condition|(
name|gr_addr
condition|)
block|{
comment|/* Compute address of nat collection bits */
name|CORE_ADDR
name|nat_addr
init|=
name|gr_addr
operator||
literal|0x1f8
decl_stmt|;
name|CORE_ADDR
name|bsp
init|=
name|read_register
argument_list|(
name|IA64_BSP_REGNUM
argument_list|)
decl_stmt|;
name|CORE_ADDR
name|nat_collection
decl_stmt|;
name|int
name|nat_bit
decl_stmt|;
comment|/* If our nat collection address is bigger than bsp, we have to get 	     the nat collection from rnat.  Otherwise, we fetch the nat 	     collection from the computed address. */
if|if
condition|(
name|nat_addr
operator|>=
name|bsp
condition|)
name|nat_collection
operator|=
name|read_register
argument_list|(
name|IA64_RNAT_REGNUM
argument_list|)
expr_stmt|;
else|else
name|nat_collection
operator|=
name|read_memory_integer
argument_list|(
name|nat_addr
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|nat_bit
operator|=
operator|(
name|gr_addr
operator|>>
literal|3
operator|)
operator|&
literal|0x3f
expr_stmt|;
name|natval
operator|=
operator|(
name|nat_collection
operator|>>
name|nat_bit
operator|)
operator|&
literal|1
expr_stmt|;
block|}
name|store_unsigned_integer
argument_list|(
name|raw_buffer
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|,
name|natval
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|regnum
operator|==
name|IA64_IP_REGNUM
condition|)
block|{
name|CORE_ADDR
name|pc
decl_stmt|;
if|if
condition|(
name|frame
operator|->
name|next
condition|)
block|{
comment|/* FIXME: Set *addrp, *lval when possible. */
name|pc
operator|=
name|ia64_frame_saved_pc
argument_list|(
name|frame
operator|->
name|next
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pc
operator|=
name|read_pc
argument_list|()
expr_stmt|;
block|}
name|store_address
argument_list|(
name|raw_buffer
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|IA64_IP_REGNUM
argument_list|)
argument_list|,
name|pc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IA64_GR32_REGNUM
operator|<=
name|regnum
operator|&&
name|regnum
operator|<=
name|IA64_GR127_REGNUM
condition|)
block|{
name|CORE_ADDR
name|addr
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|is_dummy_frame
condition|)
block|{
name|FRAME_INIT_SAVED_REGS
argument_list|(
name|frame
argument_list|)
expr_stmt|;
name|addr
operator|=
name|frame
operator|->
name|saved_regs
index|[
name|regnum
index|]
expr_stmt|;
block|}
if|if
condition|(
name|addr
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|lval
operator|!=
name|NULL
condition|)
operator|*
name|lval
operator|=
name|lval_memory
expr_stmt|;
if|if
condition|(
name|addrp
operator|!=
name|NULL
condition|)
operator|*
name|addrp
operator|=
name|addr
expr_stmt|;
name|read_memory
argument_list|(
name|addr
argument_list|,
name|raw_buffer
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* r32 - r127 must be fetchable via memory.  If they aren't, 	     then the register is unavailable */
name|memset
argument_list|(
name|raw_buffer
argument_list|,
literal|0
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|IA64_FR32_REGNUM
operator|<=
name|regnum
operator|&&
name|regnum
operator|<=
name|IA64_FR127_REGNUM
condition|)
block|{
comment|/* Fetch floating point register rename base from current 	     frame marker for this frame. */
name|int
name|rrb_fr
init|=
operator|(
name|frame
operator|->
name|extra_info
operator|->
name|cfm
operator|>>
literal|25
operator|)
operator|&
literal|0x7f
decl_stmt|;
comment|/* Adjust the floating point register number to account for 	     register rotation. */
name|regnum
operator|=
name|IA64_FR32_REGNUM
operator|+
operator|(
operator|(
name|regnum
operator|-
name|IA64_FR32_REGNUM
operator|)
operator|+
name|rrb_fr
operator|)
operator|%
literal|96
expr_stmt|;
block|}
name|generic_get_saved_register
argument_list|(
name|raw_buffer
argument_list|,
name|optimized
argument_list|,
name|addrp
argument_list|,
name|frame
argument_list|,
name|regnum
argument_list|,
name|lval
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Should we use EXTRACT_STRUCT_VALUE_ADDRESS instead of    EXTRACT_RETURN_VALUE?  GCC_P is true if compiled with gcc    and TYPE is the type (which is known to be struct, union or array).  */
end_comment

begin_function
name|int
name|ia64_use_struct_convention
parameter_list|(
name|int
name|gcc_p
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|float_elt_type
decl_stmt|;
comment|/* HFAs are structures (or arrays) consisting entirely of floating      point values of the same length.  Up to 8 of these are returned      in registers.  Don't use the struct convention when this is the      case. */
name|float_elt_type
operator|=
name|is_float_or_hfa_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|float_elt_type
operator|!=
name|NULL
operator|&&
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|/
name|TYPE_LENGTH
argument_list|(
name|float_elt_type
argument_list|)
operator|<=
literal|8
condition|)
return|return
literal|0
return|;
comment|/* Other structs of length 32 or less are returned in r8-r11.      Don't use the struct convention for those either. */
return|return
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|>
literal|32
return|;
block|}
end_function

begin_function
name|void
name|ia64_extract_return_value
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|char
modifier|*
name|regbuf
parameter_list|,
name|char
modifier|*
name|valbuf
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|float_elt_type
decl_stmt|;
name|float_elt_type
operator|=
name|is_float_or_hfa_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|float_elt_type
operator|!=
name|NULL
condition|)
block|{
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|int
name|regnum
init|=
name|IA64_FR8_REGNUM
decl_stmt|;
name|int
name|n
init|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|/
name|TYPE_LENGTH
argument_list|(
name|float_elt_type
argument_list|)
decl_stmt|;
while|while
condition|(
name|n
operator|--
operator|>
literal|0
condition|)
block|{
name|ia64_register_convert_to_virtual
argument_list|(
name|regnum
argument_list|,
name|float_elt_type
argument_list|,
operator|&
name|regbuf
index|[
name|REGISTER_BYTE
argument_list|(
name|regnum
argument_list|)
index|]
argument_list|,
name|valbuf
operator|+
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|TYPE_LENGTH
argument_list|(
name|float_elt_type
argument_list|)
expr_stmt|;
name|regnum
operator|++
expr_stmt|;
block|}
block|}
else|else
name|memcpy
argument_list|(
name|valbuf
argument_list|,
operator|&
name|regbuf
index|[
name|REGISTER_BYTE
argument_list|(
name|IA64_GR8_REGNUM
argument_list|)
index|]
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* FIXME: Turn this into a stack of some sort.  Unfortunately, something    like this is necessary though since the IA-64 calling conventions specify    that r8 is not preserved. */
end_comment

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|struct_return_address
decl_stmt|;
end_decl_stmt

begin_function
name|CORE_ADDR
name|ia64_extract_struct_value_address
parameter_list|(
name|char
modifier|*
name|regbuf
parameter_list|)
block|{
comment|/* FIXME: See above. */
return|return
name|struct_return_address
return|;
block|}
end_function

begin_function
name|void
name|ia64_store_struct_return
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|CORE_ADDR
name|sp
parameter_list|)
block|{
comment|/* FIXME: See above. */
comment|/* Note that most of the work was done in ia64_push_arguments() */
name|struct_return_address
operator|=
name|addr
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ia64_frameless_function_invocation
parameter_list|(
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|)
block|{
name|FRAME_INIT_SAVED_REGS
argument_list|(
name|frame
argument_list|)
expr_stmt|;
return|return
operator|(
name|frame
operator|->
name|extra_info
operator|->
name|mem_stack_frame_size
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|CORE_ADDR
name|ia64_saved_pc_after_call
parameter_list|(
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|)
block|{
return|return
name|read_register
argument_list|(
name|IA64_BR0_REGNUM
argument_list|)
return|;
block|}
end_function

begin_function
name|CORE_ADDR
name|ia64_frame_args_address
parameter_list|(
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|)
block|{
comment|/* frame->frame points at the SP for this frame; But we want the start      of the frame, not the end.  Calling frame chain will get his for us. */
return|return
name|ia64_frame_chain
argument_list|(
name|frame
argument_list|)
return|;
block|}
end_function

begin_function
name|CORE_ADDR
name|ia64_frame_locals_address
parameter_list|(
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|)
block|{
comment|/* frame->frame points at the SP for this frame; But we want the start      of the frame, not the end.  Calling frame chain will get his for us. */
return|return
name|ia64_frame_chain
argument_list|(
name|frame
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|ia64_init_extra_frame_info
parameter_list|(
name|int
name|fromleaf
parameter_list|,
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|)
block|{
name|CORE_ADDR
name|bsp
decl_stmt|,
name|cfm
decl_stmt|;
name|int
name|next_frame_is_call_dummy
init|=
operator|(
operator|(
name|frame
operator|->
name|next
operator|!=
name|NULL
operator|)
operator|&&
name|PC_IN_CALL_DUMMY
argument_list|(
name|frame
operator|->
name|next
operator|->
name|pc
argument_list|,
name|frame
operator|->
name|next
operator|->
name|frame
argument_list|,
name|frame
operator|->
name|next
operator|->
name|frame
argument_list|)
operator|)
decl_stmt|;
name|frame
operator|->
name|extra_info
operator|=
operator|(
expr|struct
name|frame_extra_info
operator|*
operator|)
name|frame_obstack_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|frame_extra_info
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame
operator|->
name|next
operator|==
literal|0
condition|)
block|{
name|bsp
operator|=
name|read_register
argument_list|(
name|IA64_BSP_REGNUM
argument_list|)
expr_stmt|;
name|cfm
operator|=
name|read_register
argument_list|(
name|IA64_CFM_REGNUM
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|frame
operator|->
name|next
operator|->
name|signal_handler_caller
condition|)
block|{
name|bsp
operator|=
name|read_sigcontext_register
argument_list|(
name|frame
operator|->
name|next
argument_list|,
name|IA64_BSP_REGNUM
argument_list|)
expr_stmt|;
name|cfm
operator|=
name|read_sigcontext_register
argument_list|(
name|frame
operator|->
name|next
argument_list|,
name|IA64_CFM_REGNUM
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|next_frame_is_call_dummy
condition|)
block|{
name|bsp
operator|=
name|generic_read_register_dummy
argument_list|(
name|frame
operator|->
name|next
operator|->
name|pc
argument_list|,
name|frame
operator|->
name|next
operator|->
name|frame
argument_list|,
name|IA64_BSP_REGNUM
argument_list|)
expr_stmt|;
name|cfm
operator|=
name|generic_read_register_dummy
argument_list|(
name|frame
operator|->
name|next
operator|->
name|pc
argument_list|,
name|frame
operator|->
name|next
operator|->
name|frame
argument_list|,
name|IA64_CFM_REGNUM
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|frame_info
modifier|*
name|frn
init|=
name|frame
operator|->
name|next
decl_stmt|;
name|FRAME_INIT_SAVED_REGS
argument_list|(
name|frn
argument_list|)
expr_stmt|;
if|if
condition|(
name|frn
operator|->
name|saved_regs
index|[
name|IA64_CFM_REGNUM
index|]
operator|!=
literal|0
condition|)
name|cfm
operator|=
name|read_memory_integer
argument_list|(
name|frn
operator|->
name|saved_regs
index|[
name|IA64_CFM_REGNUM
index|]
argument_list|,
literal|8
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|frn
operator|->
name|next
operator|&&
name|frn
operator|->
name|next
operator|->
name|signal_handler_caller
condition|)
name|cfm
operator|=
name|read_sigcontext_register
argument_list|(
name|frn
operator|->
name|next
argument_list|,
name|IA64_PFS_REGNUM
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|frn
operator|->
name|next
operator|&&
name|PC_IN_CALL_DUMMY
argument_list|(
name|frn
operator|->
name|next
operator|->
name|pc
argument_list|,
name|frn
operator|->
name|next
operator|->
name|frame
argument_list|,
name|frn
operator|->
name|next
operator|->
name|frame
argument_list|)
condition|)
name|cfm
operator|=
name|generic_read_register_dummy
argument_list|(
name|frn
operator|->
name|next
operator|->
name|pc
argument_list|,
name|frn
operator|->
name|next
operator|->
name|frame
argument_list|,
name|IA64_PFS_REGNUM
argument_list|)
expr_stmt|;
else|else
name|cfm
operator|=
name|read_register
argument_list|(
name|IA64_PFS_REGNUM
argument_list|)
expr_stmt|;
name|bsp
operator|=
name|frn
operator|->
name|extra_info
operator|->
name|bsp
expr_stmt|;
block|}
name|frame
operator|->
name|extra_info
operator|->
name|cfm
operator|=
name|cfm
expr_stmt|;
name|frame
operator|->
name|extra_info
operator|->
name|sof
operator|=
name|cfm
operator|&
literal|0x7f
expr_stmt|;
name|frame
operator|->
name|extra_info
operator|->
name|sol
operator|=
operator|(
name|cfm
operator|>>
literal|7
operator|)
operator|&
literal|0x7f
expr_stmt|;
if|if
condition|(
name|frame
operator|->
name|next
operator|==
literal|0
operator|||
name|frame
operator|->
name|next
operator|->
name|signal_handler_caller
operator|||
name|next_frame_is_call_dummy
condition|)
name|frame
operator|->
name|extra_info
operator|->
name|bsp
operator|=
name|rse_address_add
argument_list|(
name|bsp
argument_list|,
operator|-
name|frame
operator|->
name|extra_info
operator|->
name|sof
argument_list|)
expr_stmt|;
else|else
name|frame
operator|->
name|extra_info
operator|->
name|bsp
operator|=
name|rse_address_add
argument_list|(
name|bsp
argument_list|,
operator|-
name|frame
operator|->
name|extra_info
operator|->
name|sol
argument_list|)
expr_stmt|;
name|frame
operator|->
name|extra_info
operator|->
name|after_prologue
operator|=
literal|0
expr_stmt|;
name|frame
operator|->
name|extra_info
operator|->
name|mem_stack_frame_size
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Not yet determined */
name|frame
operator|->
name|extra_info
operator|->
name|fp_reg
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|is_float_or_hfa_type_recurse
parameter_list|(
name|struct
name|type
modifier|*
name|t
parameter_list|,
name|struct
name|type
modifier|*
modifier|*
name|etp
parameter_list|)
block|{
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_FLT
case|:
if|if
condition|(
operator|*
name|etp
condition|)
return|return
name|TYPE_LENGTH
argument_list|(
operator|*
name|etp
argument_list|)
operator|==
name|TYPE_LENGTH
argument_list|(
name|t
argument_list|)
return|;
else|else
block|{
operator|*
name|etp
operator|=
name|t
expr_stmt|;
return|return
literal|1
return|;
block|}
break|break;
case|case
name|TYPE_CODE_ARRAY
case|:
return|return
name|is_float_or_hfa_type_recurse
argument_list|(
name|check_typedef
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|,
name|etp
argument_list|)
return|;
break|break;
case|case
name|TYPE_CODE_STRUCT
case|:
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TYPE_NFIELDS
argument_list|(
name|t
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|is_float_or_hfa_type_recurse
argument_list|(
name|check_typedef
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|,
name|etp
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
break|break;
default|default:
return|return
literal|0
return|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Determine if the given type is one of the floating point types or    and HFA (which is a struct, array, or combination thereof whose    bottom-most elements are all of the same floating point type.) */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|is_float_or_hfa_type
parameter_list|(
name|struct
name|type
modifier|*
name|t
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|et
init|=
literal|0
decl_stmt|;
return|return
name|is_float_or_hfa_type_recurse
argument_list|(
name|t
argument_list|,
operator|&
name|et
argument_list|)
condition|?
name|et
else|:
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the alignment of T is such that the next even slot    should be used.  Return 0, if the next available slot should    be used.  (See section 8.5.1 of the IA-64 Software Conventions    and Runtime manual.)  */
end_comment

begin_function
specifier|static
name|int
name|slot_alignment_is_next_even
parameter_list|(
name|struct
name|type
modifier|*
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_INT
case|:
case|case
name|TYPE_CODE_FLT
case|:
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|t
argument_list|)
operator|>
literal|8
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
case|case
name|TYPE_CODE_ARRAY
case|:
return|return
name|slot_alignment_is_next_even
argument_list|(
name|check_typedef
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|TYPE_CODE_STRUCT
case|:
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TYPE_NFIELDS
argument_list|(
name|t
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|slot_alignment_is_next_even
argument_list|(
name|check_typedef
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Attempt to find (and return) the global pointer for the given    function.     This is a rather nasty bit of code searchs for the .dynamic section    in the objfile corresponding to the pc of the function we're trying    to call.  Once it finds the addresses at which the .dynamic section    lives in the child process, it scans the Elf64_Dyn entries for a    DT_PLTGOT tag.  If it finds one of these, the corresponding    d_un.d_ptr value is the global pointer.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|generic_elf_find_global_pointer
parameter_list|(
name|CORE_ADDR
name|faddr
parameter_list|)
block|{
name|struct
name|obj_section
modifier|*
name|faddr_sect
decl_stmt|;
name|faddr_sect
operator|=
name|find_pc_section
argument_list|(
name|faddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|faddr_sect
operator|!=
name|NULL
condition|)
block|{
name|struct
name|obj_section
modifier|*
name|osect
decl_stmt|;
name|ALL_OBJFILE_OSECTIONS
argument_list|(
argument|faddr_sect->objfile
argument_list|,
argument|osect
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|osect
operator|->
name|the_bfd_section
operator|->
name|name
argument_list|,
literal|".dynamic"
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|osect
operator|<
name|faddr_sect
operator|->
name|objfile
operator|->
name|sections_end
condition|)
block|{
name|CORE_ADDR
name|addr
decl_stmt|;
name|addr
operator|=
name|osect
operator|->
name|addr
expr_stmt|;
while|while
condition|(
name|addr
operator|<
name|osect
operator|->
name|endaddr
condition|)
block|{
name|int
name|status
decl_stmt|;
name|LONGEST
name|tag
decl_stmt|;
name|char
name|buf
index|[
literal|8
index|]
decl_stmt|;
name|status
operator|=
name|target_read_memory
argument_list|(
name|addr
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
break|break;
name|tag
operator|=
name|extract_signed_integer
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag
operator|==
name|DT_PLTGOT
condition|)
block|{
name|CORE_ADDR
name|global_pointer
decl_stmt|;
name|status
operator|=
name|target_read_memory
argument_list|(
name|addr
operator|+
literal|8
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
break|break;
name|global_pointer
operator|=
name|extract_address
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The payoff... */
return|return
name|global_pointer
return|;
block|}
if|if
condition|(
name|tag
operator|==
name|DT_NULL
condition|)
break|break;
name|addr
operator|+=
literal|16
expr_stmt|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Given a function's address, attempt to find (and return) the    corresponding (canonical) function descriptor.  Return 0 if    not found. */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|find_extant_func_descr
parameter_list|(
name|CORE_ADDR
name|faddr
parameter_list|)
block|{
name|struct
name|obj_section
modifier|*
name|faddr_sect
decl_stmt|;
comment|/* Return early if faddr is already a function descriptor */
name|faddr_sect
operator|=
name|find_pc_section
argument_list|(
name|faddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|faddr_sect
operator|&&
name|strcmp
argument_list|(
name|faddr_sect
operator|->
name|the_bfd_section
operator|->
name|name
argument_list|,
literal|".opd"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|faddr
return|;
if|if
condition|(
name|faddr_sect
operator|!=
name|NULL
condition|)
block|{
name|struct
name|obj_section
modifier|*
name|osect
decl_stmt|;
name|ALL_OBJFILE_OSECTIONS
argument_list|(
argument|faddr_sect->objfile
argument_list|,
argument|osect
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|osect
operator|->
name|the_bfd_section
operator|->
name|name
argument_list|,
literal|".opd"
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|osect
operator|<
name|faddr_sect
operator|->
name|objfile
operator|->
name|sections_end
condition|)
block|{
name|CORE_ADDR
name|addr
decl_stmt|;
name|addr
operator|=
name|osect
operator|->
name|addr
expr_stmt|;
while|while
condition|(
name|addr
operator|<
name|osect
operator|->
name|endaddr
condition|)
block|{
name|int
name|status
decl_stmt|;
name|LONGEST
name|faddr2
decl_stmt|;
name|char
name|buf
index|[
literal|8
index|]
decl_stmt|;
name|status
operator|=
name|target_read_memory
argument_list|(
name|addr
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
break|break;
name|faddr2
operator|=
name|extract_signed_integer
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|faddr
operator|==
name|faddr2
condition|)
return|return
name|addr
return|;
name|addr
operator|+=
literal|16
expr_stmt|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Attempt to find a function descriptor corresponding to the    given address.  If none is found, construct one on the    stack using the address at fdaptr */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|find_func_descr
parameter_list|(
name|CORE_ADDR
name|faddr
parameter_list|,
name|CORE_ADDR
modifier|*
name|fdaptr
parameter_list|)
block|{
name|CORE_ADDR
name|fdesc
decl_stmt|;
name|fdesc
operator|=
name|find_extant_func_descr
argument_list|(
name|faddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdesc
operator|==
literal|0
condition|)
block|{
name|CORE_ADDR
name|global_pointer
decl_stmt|;
name|char
name|buf
index|[
literal|16
index|]
decl_stmt|;
name|fdesc
operator|=
operator|*
name|fdaptr
expr_stmt|;
operator|*
name|fdaptr
operator|+=
literal|16
expr_stmt|;
name|global_pointer
operator|=
name|FIND_GLOBAL_POINTER
argument_list|(
name|faddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|global_pointer
operator|==
literal|0
condition|)
name|global_pointer
operator|=
name|read_register
argument_list|(
name|IA64_GR1_REGNUM
argument_list|)
expr_stmt|;
name|store_address
argument_list|(
name|buf
argument_list|,
literal|8
argument_list|,
name|faddr
argument_list|)
expr_stmt|;
name|store_address
argument_list|(
name|buf
operator|+
literal|8
argument_list|,
literal|8
argument_list|,
name|global_pointer
argument_list|)
expr_stmt|;
name|write_memory
argument_list|(
name|fdesc
argument_list|,
name|buf
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
return|return
name|fdesc
return|;
block|}
end_function

begin_function
name|CORE_ADDR
name|ia64_push_arguments
parameter_list|(
name|int
name|nargs
parameter_list|,
name|struct
name|value
modifier|*
modifier|*
name|args
parameter_list|,
name|CORE_ADDR
name|sp
parameter_list|,
name|int
name|struct_return
parameter_list|,
name|CORE_ADDR
name|struct_addr
parameter_list|)
block|{
name|int
name|argno
decl_stmt|;
name|struct
name|value
modifier|*
name|arg
decl_stmt|;
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|int
name|len
decl_stmt|,
name|argoffset
decl_stmt|;
name|int
name|nslots
decl_stmt|,
name|rseslots
decl_stmt|,
name|memslots
decl_stmt|,
name|slotnum
decl_stmt|,
name|nfuncargs
decl_stmt|;
name|int
name|floatreg
decl_stmt|;
name|CORE_ADDR
name|bsp
decl_stmt|,
name|cfm
decl_stmt|,
name|pfs
decl_stmt|,
name|new_bsp
decl_stmt|,
name|funcdescaddr
decl_stmt|;
name|nslots
operator|=
literal|0
expr_stmt|;
name|nfuncargs
operator|=
literal|0
expr_stmt|;
comment|/* Count the number of slots needed for the arguments */
for|for
control|(
name|argno
operator|=
literal|0
init|;
name|argno
operator|<
name|nargs
condition|;
name|argno
operator|++
control|)
block|{
name|arg
operator|=
name|args
index|[
name|argno
index|]
expr_stmt|;
name|type
operator|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nslots
operator|&
literal|1
operator|)
operator|&&
name|slot_alignment_is_next_even
argument_list|(
name|type
argument_list|)
condition|)
name|nslots
operator|++
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_FUNC
condition|)
name|nfuncargs
operator|++
expr_stmt|;
name|nslots
operator|+=
operator|(
name|len
operator|+
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
block|}
comment|/* Divvy up the slots between the RSE and the memory stack */
name|rseslots
operator|=
operator|(
name|nslots
operator|>
literal|8
operator|)
condition|?
literal|8
else|:
name|nslots
expr_stmt|;
name|memslots
operator|=
name|nslots
operator|-
name|rseslots
expr_stmt|;
comment|/* Allocate a new RSE frame */
name|cfm
operator|=
name|read_register
argument_list|(
name|IA64_CFM_REGNUM
argument_list|)
expr_stmt|;
name|bsp
operator|=
name|read_register
argument_list|(
name|IA64_BSP_REGNUM
argument_list|)
expr_stmt|;
name|bsp
operator|=
name|rse_address_add
argument_list|(
name|bsp
argument_list|,
name|cfm
operator|&
literal|0x7f
argument_list|)
expr_stmt|;
name|new_bsp
operator|=
name|rse_address_add
argument_list|(
name|bsp
argument_list|,
name|rseslots
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|IA64_BSP_REGNUM
argument_list|,
name|new_bsp
argument_list|)
expr_stmt|;
name|pfs
operator|=
name|read_register
argument_list|(
name|IA64_PFS_REGNUM
argument_list|)
expr_stmt|;
name|pfs
operator|&=
literal|0xc000000000000000LL
expr_stmt|;
name|pfs
operator||=
operator|(
name|cfm
operator|&
literal|0xffffffffffffLL
operator|)
expr_stmt|;
name|write_register
argument_list|(
name|IA64_PFS_REGNUM
argument_list|,
name|pfs
argument_list|)
expr_stmt|;
name|cfm
operator|&=
literal|0xc000000000000000LL
expr_stmt|;
name|cfm
operator||=
name|rseslots
expr_stmt|;
name|write_register
argument_list|(
name|IA64_CFM_REGNUM
argument_list|,
name|cfm
argument_list|)
expr_stmt|;
comment|/* We will attempt to find function descriptors in the .opd segment,      but if we can't we'll construct them ourselves.  That being the      case, we'll need to reserve space on the stack for them. */
name|funcdescaddr
operator|=
name|sp
operator|-
name|nfuncargs
operator|*
literal|16
expr_stmt|;
name|funcdescaddr
operator|&=
operator|~
literal|0xfLL
expr_stmt|;
comment|/* Adjust the stack pointer to it's new value.  The calling conventions      require us to have 16 bytes of scratch, plus whatever space is      necessary for the memory slots and our function descriptors */
name|sp
operator|=
name|sp
operator|-
literal|16
operator|-
operator|(
name|memslots
operator|+
name|nfuncargs
operator|)
operator|*
literal|8
expr_stmt|;
name|sp
operator|&=
operator|~
literal|0xfLL
expr_stmt|;
comment|/* Maintain 16 byte alignment */
comment|/* Place the arguments where they belong.  The arguments will be      either placed in the RSE backing store or on the memory stack.      In addition, floating point arguments or HFAs are placed in      floating point registers. */
name|slotnum
operator|=
literal|0
expr_stmt|;
name|floatreg
operator|=
name|IA64_FR8_REGNUM
expr_stmt|;
for|for
control|(
name|argno
operator|=
literal|0
init|;
name|argno
operator|<
name|nargs
condition|;
name|argno
operator|++
control|)
block|{
name|struct
name|type
modifier|*
name|float_elt_type
decl_stmt|;
name|arg
operator|=
name|args
index|[
name|argno
index|]
expr_stmt|;
name|type
operator|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Special handling for function parameters */
if|if
condition|(
name|len
operator|==
literal|8
operator|&&
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_PTR
operator|&&
name|TYPE_CODE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_FUNC
condition|)
block|{
name|char
name|val_buf
index|[
literal|8
index|]
decl_stmt|;
name|store_address
argument_list|(
name|val_buf
argument_list|,
literal|8
argument_list|,
name|find_func_descr
argument_list|(
name|extract_address
argument_list|(
name|VALUE_CONTENTS
argument_list|(
name|arg
argument_list|)
argument_list|,
literal|8
argument_list|)
argument_list|,
operator|&
name|funcdescaddr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|slotnum
operator|<
name|rseslots
condition|)
name|write_memory
argument_list|(
name|rse_address_add
argument_list|(
name|bsp
argument_list|,
name|slotnum
argument_list|)
argument_list|,
name|val_buf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
else|else
name|write_memory
argument_list|(
name|sp
operator|+
literal|16
operator|+
literal|8
operator|*
operator|(
name|slotnum
operator|-
name|rseslots
operator|)
argument_list|,
name|val_buf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|slotnum
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* Normal slots */
comment|/* Skip odd slot if necessary...  */
if|if
condition|(
operator|(
name|slotnum
operator|&
literal|1
operator|)
operator|&&
name|slot_alignment_is_next_even
argument_list|(
name|type
argument_list|)
condition|)
name|slotnum
operator|++
expr_stmt|;
name|argoffset
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|char
name|val_buf
index|[
literal|8
index|]
decl_stmt|;
name|memset
argument_list|(
name|val_buf
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|val_buf
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|arg
argument_list|)
operator|+
name|argoffset
argument_list|,
operator|(
name|len
operator|>
literal|8
operator|)
condition|?
literal|8
else|:
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|slotnum
operator|<
name|rseslots
condition|)
name|write_memory
argument_list|(
name|rse_address_add
argument_list|(
name|bsp
argument_list|,
name|slotnum
argument_list|)
argument_list|,
name|val_buf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
else|else
name|write_memory
argument_list|(
name|sp
operator|+
literal|16
operator|+
literal|8
operator|*
operator|(
name|slotnum
operator|-
name|rseslots
operator|)
argument_list|,
name|val_buf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|argoffset
operator|+=
literal|8
expr_stmt|;
name|len
operator|-=
literal|8
expr_stmt|;
name|slotnum
operator|++
expr_stmt|;
block|}
comment|/* Handle floating point types (including HFAs) */
name|float_elt_type
operator|=
name|is_float_or_hfa_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|float_elt_type
operator|!=
name|NULL
condition|)
block|{
name|argoffset
operator|=
literal|0
expr_stmt|;
name|len
operator|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
operator|&&
name|floatreg
operator|<
name|IA64_FR16_REGNUM
condition|)
block|{
name|ia64_register_convert_to_raw
argument_list|(
name|float_elt_type
argument_list|,
name|floatreg
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|arg
argument_list|)
operator|+
name|argoffset
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|floatreg
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|floatreg
operator|++
expr_stmt|;
name|argoffset
operator|+=
name|TYPE_LENGTH
argument_list|(
name|float_elt_type
argument_list|)
expr_stmt|;
name|len
operator|-=
name|TYPE_LENGTH
argument_list|(
name|float_elt_type
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Store the struct return value in r8 if necessary. */
if|if
condition|(
name|struct_return
condition|)
block|{
name|store_address
argument_list|(
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|IA64_GR8_REGNUM
argument_list|)
index|]
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|IA64_GR8_REGNUM
argument_list|)
argument_list|,
name|struct_addr
argument_list|)
expr_stmt|;
block|}
comment|/* Sync gdb's idea of what the registers are with the target. */
name|target_store_registers
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* FIXME: This doesn't belong here!  Instead, SAVE_DUMMY_FRAME_TOS needs      to be defined to call generic_save_dummy_frame_tos().  But at the      time of this writing, SAVE_DUMMY_FRAME_TOS wasn't gdbarch'd, so      I chose to put this call here instead of using the old mechanisms.       Once SAVE_DUMMY_FRAME_TOS is gdbarch'd, all we need to do is add the      line  	set_gdbarch_save_dummy_frame_tos (gdbarch, generic_save_dummy_frame_tos);       to ia64_gdbarch_init() and remove the line below. */
name|generic_save_dummy_frame_tos
argument_list|(
name|sp
argument_list|)
expr_stmt|;
return|return
name|sp
return|;
block|}
end_function

begin_function
name|CORE_ADDR
name|ia64_push_return_address
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|CORE_ADDR
name|sp
parameter_list|)
block|{
name|CORE_ADDR
name|global_pointer
init|=
name|FIND_GLOBAL_POINTER
argument_list|(
name|pc
argument_list|)
decl_stmt|;
if|if
condition|(
name|global_pointer
operator|!=
literal|0
condition|)
name|write_register
argument_list|(
name|IA64_GR1_REGNUM
argument_list|,
name|global_pointer
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|IA64_BR0_REGNUM
argument_list|,
name|CALL_DUMMY_ADDRESS
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|sp
return|;
block|}
end_function

begin_function
name|void
name|ia64_store_return_value
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|char
modifier|*
name|valbuf
parameter_list|)
block|{
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_FLT
condition|)
block|{
name|ia64_register_convert_to_raw
argument_list|(
name|type
argument_list|,
name|IA64_FR8_REGNUM
argument_list|,
name|valbuf
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|IA64_FR8_REGNUM
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|target_store_registers
argument_list|(
name|IA64_FR8_REGNUM
argument_list|)
expr_stmt|;
block|}
else|else
name|write_register_bytes
argument_list|(
name|REGISTER_BYTE
argument_list|(
name|IA64_GR8_REGNUM
argument_list|)
argument_list|,
name|valbuf
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ia64_pop_frame
parameter_list|(
name|void
parameter_list|)
block|{
name|generic_pop_current_frame
argument_list|(
name|ia64_pop_frame_regular
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ia64_pop_frame_regular
parameter_list|(
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|)
block|{
name|int
name|regno
decl_stmt|;
name|CORE_ADDR
name|bsp
decl_stmt|,
name|cfm
decl_stmt|,
name|pfs
decl_stmt|;
name|FRAME_INIT_SAVED_REGS
argument_list|(
name|frame
argument_list|)
expr_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|ia64_num_regs
condition|;
name|regno
operator|++
control|)
block|{
if|if
condition|(
name|frame
operator|->
name|saved_regs
index|[
name|regno
index|]
operator|&&
operator|(
operator|!
operator|(
name|IA64_GR32_REGNUM
operator|<=
name|regno
operator|&&
name|regno
operator|<=
name|IA64_GR127_REGNUM
operator|)
operator|)
operator|&&
name|regno
operator|!=
name|pc_regnum
operator|&&
name|regno
operator|!=
name|sp_regnum
operator|&&
name|regno
operator|!=
name|IA64_PFS_REGNUM
operator|&&
name|regno
operator|!=
name|IA64_CFM_REGNUM
operator|&&
name|regno
operator|!=
name|IA64_BSP_REGNUM
operator|&&
name|regno
operator|!=
name|IA64_BSPSTORE_REGNUM
condition|)
block|{
name|write_register
argument_list|(
name|regno
argument_list|,
name|read_memory_integer
argument_list|(
name|frame
operator|->
name|saved_regs
index|[
name|regno
index|]
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|write_register
argument_list|(
name|sp_regnum
argument_list|,
name|FRAME_CHAIN
argument_list|(
name|frame
argument_list|)
argument_list|)
expr_stmt|;
name|write_pc
argument_list|(
name|FRAME_SAVED_PC
argument_list|(
name|frame
argument_list|)
argument_list|)
expr_stmt|;
name|cfm
operator|=
name|read_register
argument_list|(
name|IA64_CFM_REGNUM
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame
operator|->
name|saved_regs
index|[
name|IA64_PFS_REGNUM
index|]
condition|)
block|{
name|pfs
operator|=
name|read_memory_integer
argument_list|(
name|frame
operator|->
name|saved_regs
index|[
name|IA64_PFS_REGNUM
index|]
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|IA64_PFS_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|pfs
operator|=
name|read_register
argument_list|(
name|IA64_PFS_REGNUM
argument_list|)
expr_stmt|;
comment|/* Compute the new bsp by *adding* the difference between the      size of the frame and the size of the locals (both wrt the      frame that we're going back to).  This seems kind of strange,      especially since it seems like we ought to be subtracting the      size of the locals... and we should; but the Linux kernel      wants bsp to be set at the end of all used registers.  It's      likely that this code will need to be revised to accomodate      other operating systems. */
name|bsp
operator|=
name|rse_address_add
argument_list|(
name|frame
operator|->
name|extra_info
operator|->
name|bsp
argument_list|,
operator|(
name|pfs
operator|&
literal|0x7f
operator|)
operator|-
operator|(
operator|(
name|pfs
operator|>>
literal|7
operator|)
operator|&
literal|0x7f
operator|)
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|IA64_BSP_REGNUM
argument_list|,
name|bsp
argument_list|)
expr_stmt|;
comment|/* FIXME: What becomes of the epilog count in the PFS? */
name|cfm
operator|=
operator|(
name|cfm
operator|&
operator|~
literal|0xffffffffffffLL
operator|)
operator||
operator|(
name|pfs
operator|&
literal|0xffffffffffffLL
operator|)
expr_stmt|;
name|write_register
argument_list|(
name|IA64_CFM_REGNUM
argument_list|,
name|cfm
argument_list|)
expr_stmt|;
name|flush_cached_frames
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ia64_remote_translate_xfer_address
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|int
name|nr_bytes
parameter_list|,
name|CORE_ADDR
modifier|*
name|targ_addr
parameter_list|,
name|int
modifier|*
name|targ_len
parameter_list|)
block|{
operator|*
name|targ_addr
operator|=
name|memaddr
expr_stmt|;
operator|*
name|targ_len
operator|=
name|nr_bytes
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|process_note_abi_tag_sections
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sect
parameter_list|,
name|void
modifier|*
name|obj
parameter_list|)
block|{
name|int
modifier|*
name|os_ident_ptr
init|=
name|obj
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|int
name|sectsize
decl_stmt|;
name|name
operator|=
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sect
argument_list|)
expr_stmt|;
name|sectsize
operator|=
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|sect
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".note.ABI-tag"
argument_list|)
operator|==
literal|0
operator|&&
name|sectsize
operator|>
literal|0
condition|)
block|{
name|unsigned
name|int
name|name_length
decl_stmt|,
name|data_length
decl_stmt|,
name|note_type
decl_stmt|;
name|char
modifier|*
name|note
init|=
name|alloca
argument_list|(
name|sectsize
argument_list|)
decl_stmt|;
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|sect
argument_list|,
name|note
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|sectsize
argument_list|)
expr_stmt|;
name|name_length
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|note
argument_list|)
expr_stmt|;
name|data_length
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|note
operator|+
literal|4
argument_list|)
expr_stmt|;
name|note_type
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|note
operator|+
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|name_length
operator|==
literal|4
operator|&&
name|data_length
operator|==
literal|16
operator|&&
name|note_type
operator|==
literal|1
operator|&&
name|strcmp
argument_list|(
name|note
operator|+
literal|12
argument_list|,
literal|"GNU"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|os_number
init|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|note
operator|+
literal|16
argument_list|)
decl_stmt|;
comment|/* The case numbers are from abi-tags in glibc */
switch|switch
condition|(
name|os_number
condition|)
block|{
case|case
literal|0
case|:
operator|*
name|os_ident_ptr
operator|=
name|ELFOSABI_LINUX
expr_stmt|;
break|break;
case|case
literal|1
case|:
operator|*
name|os_ident_ptr
operator|=
name|ELFOSABI_HURD
expr_stmt|;
break|break;
case|case
literal|2
case|:
operator|*
name|os_ident_ptr
operator|=
name|ELFOSABI_SOLARIS
expr_stmt|;
break|break;
default|default :
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"process_note_abi_sections: unknown OS number %d"
argument_list|,
name|os_number
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|gdbarch
modifier|*
name|ia64_gdbarch_init
parameter_list|(
name|struct
name|gdbarch_info
name|info
parameter_list|,
name|struct
name|gdbarch_list
modifier|*
name|arches
parameter_list|)
block|{
name|struct
name|gdbarch
modifier|*
name|gdbarch
decl_stmt|;
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
decl_stmt|;
name|int
name|os_ident
decl_stmt|;
if|if
condition|(
name|info
operator|.
name|abfd
operator|!=
name|NULL
operator|&&
name|bfd_get_flavour
argument_list|(
name|info
operator|.
name|abfd
argument_list|)
operator|==
name|bfd_target_elf_flavour
condition|)
block|{
name|os_ident
operator|=
name|elf_elfheader
argument_list|(
name|info
operator|.
name|abfd
argument_list|)
operator|->
name|e_ident
index|[
name|EI_OSABI
index|]
expr_stmt|;
comment|/* If os_ident is 0, it is not necessarily the case that we're          on a SYSV system.  (ELFOSABI_NONE is defined to be 0.)          GNU/Linux uses a note section to record OS/ABI info, but          leaves e_ident[EI_OSABI] zero.  So we have to check for note          sections too. */
if|if
condition|(
name|os_ident
operator|==
literal|0
condition|)
block|{
name|bfd_map_over_sections
argument_list|(
name|info
operator|.
name|abfd
argument_list|,
name|process_note_abi_tag_sections
argument_list|,
operator|&
name|os_ident
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|os_ident
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|arches
operator|=
name|gdbarch_list_lookup_by_info
argument_list|(
name|arches
argument_list|,
operator|&
name|info
argument_list|)
init|;
name|arches
operator|!=
name|NULL
condition|;
name|arches
operator|=
name|gdbarch_list_lookup_by_info
argument_list|(
name|arches
operator|->
name|next
argument_list|,
operator|&
name|info
argument_list|)
control|)
block|{
name|tdep
operator|=
name|gdbarch_tdep
argument_list|(
name|arches
operator|->
name|gdbarch
argument_list|)
expr_stmt|;
if|if
condition|(
name|tdep
operator|&&
name|tdep
operator|->
name|os_ident
operator|==
name|os_ident
condition|)
return|return
name|arches
operator|->
name|gdbarch
return|;
block|}
name|tdep
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|gdbarch_tdep
argument_list|)
argument_list|)
expr_stmt|;
name|gdbarch
operator|=
name|gdbarch_alloc
argument_list|(
operator|&
name|info
argument_list|,
name|tdep
argument_list|)
expr_stmt|;
name|tdep
operator|->
name|os_ident
operator|=
name|os_ident
expr_stmt|;
comment|/* Set the method of obtaining the sigcontext addresses at which      registers are saved.  The method of checking to see if      native_find_global_pointer is nonzero to indicate that we're      on AIX is kind of hokey, but I can't think of a better way      to do it.  */
if|if
condition|(
name|os_ident
operator|==
name|ELFOSABI_LINUX
condition|)
name|tdep
operator|->
name|sigcontext_register_address
operator|=
name|ia64_linux_sigcontext_register_address
expr_stmt|;
elseif|else
if|if
condition|(
name|native_find_global_pointer
operator|!=
literal|0
condition|)
name|tdep
operator|->
name|sigcontext_register_address
operator|=
name|ia64_aix_sigcontext_register_address
expr_stmt|;
else|else
name|tdep
operator|->
name|sigcontext_register_address
operator|=
literal|0
expr_stmt|;
comment|/* We know that GNU/Linux won't have to resort to the      native_find_global_pointer hackery.  But that's the only one we      know about so far, so if native_find_global_pointer is set to      something non-zero, then use it.  Otherwise fall back to using      generic_elf_find_global_pointer.  This arrangement should (in      theory) allow us to cross debug GNU/Linux binaries from an AIX      machine.  */
if|if
condition|(
name|os_ident
operator|==
name|ELFOSABI_LINUX
condition|)
name|tdep
operator|->
name|find_global_pointer
operator|=
name|generic_elf_find_global_pointer
expr_stmt|;
elseif|else
if|if
condition|(
name|native_find_global_pointer
operator|!=
literal|0
condition|)
name|tdep
operator|->
name|find_global_pointer
operator|=
name|native_find_global_pointer
expr_stmt|;
else|else
name|tdep
operator|->
name|find_global_pointer
operator|=
name|generic_elf_find_global_pointer
expr_stmt|;
name|set_gdbarch_short_bit
argument_list|(
name|gdbarch
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|set_gdbarch_int_bit
argument_list|(
name|gdbarch
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|set_gdbarch_long_bit
argument_list|(
name|gdbarch
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|set_gdbarch_long_long_bit
argument_list|(
name|gdbarch
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|set_gdbarch_float_bit
argument_list|(
name|gdbarch
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|set_gdbarch_double_bit
argument_list|(
name|gdbarch
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|set_gdbarch_long_double_bit
argument_list|(
name|gdbarch
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|set_gdbarch_ptr_bit
argument_list|(
name|gdbarch
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|set_gdbarch_num_regs
argument_list|(
name|gdbarch
argument_list|,
name|ia64_num_regs
argument_list|)
expr_stmt|;
name|set_gdbarch_sp_regnum
argument_list|(
name|gdbarch
argument_list|,
name|sp_regnum
argument_list|)
expr_stmt|;
name|set_gdbarch_fp_regnum
argument_list|(
name|gdbarch
argument_list|,
name|fp_regnum
argument_list|)
expr_stmt|;
name|set_gdbarch_pc_regnum
argument_list|(
name|gdbarch
argument_list|,
name|pc_regnum
argument_list|)
expr_stmt|;
name|set_gdbarch_fp0_regnum
argument_list|(
name|gdbarch
argument_list|,
name|IA64_FR0_REGNUM
argument_list|)
expr_stmt|;
name|set_gdbarch_register_name
argument_list|(
name|gdbarch
argument_list|,
name|ia64_register_name
argument_list|)
expr_stmt|;
name|set_gdbarch_register_size
argument_list|(
name|gdbarch
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|set_gdbarch_register_bytes
argument_list|(
name|gdbarch
argument_list|,
name|ia64_num_regs
operator|*
literal|8
operator|+
literal|128
operator|*
literal|8
argument_list|)
expr_stmt|;
name|set_gdbarch_register_byte
argument_list|(
name|gdbarch
argument_list|,
name|ia64_register_byte
argument_list|)
expr_stmt|;
name|set_gdbarch_register_raw_size
argument_list|(
name|gdbarch
argument_list|,
name|ia64_register_raw_size
argument_list|)
expr_stmt|;
name|set_gdbarch_max_register_raw_size
argument_list|(
name|gdbarch
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|set_gdbarch_register_virtual_size
argument_list|(
name|gdbarch
argument_list|,
name|ia64_register_virtual_size
argument_list|)
expr_stmt|;
name|set_gdbarch_max_register_virtual_size
argument_list|(
name|gdbarch
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|set_gdbarch_register_virtual_type
argument_list|(
name|gdbarch
argument_list|,
name|ia64_register_virtual_type
argument_list|)
expr_stmt|;
name|set_gdbarch_skip_prologue
argument_list|(
name|gdbarch
argument_list|,
name|ia64_skip_prologue
argument_list|)
expr_stmt|;
name|set_gdbarch_frame_num_args
argument_list|(
name|gdbarch
argument_list|,
name|frame_num_args_unknown
argument_list|)
expr_stmt|;
name|set_gdbarch_frameless_function_invocation
argument_list|(
name|gdbarch
argument_list|,
name|ia64_frameless_function_invocation
argument_list|)
expr_stmt|;
name|set_gdbarch_saved_pc_after_call
argument_list|(
name|gdbarch
argument_list|,
name|ia64_saved_pc_after_call
argument_list|)
expr_stmt|;
name|set_gdbarch_frame_chain
argument_list|(
name|gdbarch
argument_list|,
name|ia64_frame_chain
argument_list|)
expr_stmt|;
name|set_gdbarch_frame_chain_valid
argument_list|(
name|gdbarch
argument_list|,
name|generic_func_frame_chain_valid
argument_list|)
expr_stmt|;
name|set_gdbarch_frame_saved_pc
argument_list|(
name|gdbarch
argument_list|,
name|ia64_frame_saved_pc
argument_list|)
expr_stmt|;
name|set_gdbarch_frame_init_saved_regs
argument_list|(
name|gdbarch
argument_list|,
name|ia64_frame_init_saved_regs
argument_list|)
expr_stmt|;
name|set_gdbarch_get_saved_register
argument_list|(
name|gdbarch
argument_list|,
name|ia64_get_saved_register
argument_list|)
expr_stmt|;
name|set_gdbarch_register_convertible
argument_list|(
name|gdbarch
argument_list|,
name|ia64_register_convertible
argument_list|)
expr_stmt|;
name|set_gdbarch_register_convert_to_virtual
argument_list|(
name|gdbarch
argument_list|,
name|ia64_register_convert_to_virtual
argument_list|)
expr_stmt|;
name|set_gdbarch_register_convert_to_raw
argument_list|(
name|gdbarch
argument_list|,
name|ia64_register_convert_to_raw
argument_list|)
expr_stmt|;
name|set_gdbarch_use_struct_convention
argument_list|(
name|gdbarch
argument_list|,
name|ia64_use_struct_convention
argument_list|)
expr_stmt|;
name|set_gdbarch_extract_return_value
argument_list|(
name|gdbarch
argument_list|,
name|ia64_extract_return_value
argument_list|)
expr_stmt|;
name|set_gdbarch_store_struct_return
argument_list|(
name|gdbarch
argument_list|,
name|ia64_store_struct_return
argument_list|)
expr_stmt|;
name|set_gdbarch_store_return_value
argument_list|(
name|gdbarch
argument_list|,
name|ia64_store_return_value
argument_list|)
expr_stmt|;
name|set_gdbarch_extract_struct_value_address
argument_list|(
name|gdbarch
argument_list|,
name|ia64_extract_struct_value_address
argument_list|)
expr_stmt|;
name|set_gdbarch_memory_insert_breakpoint
argument_list|(
name|gdbarch
argument_list|,
name|ia64_memory_insert_breakpoint
argument_list|)
expr_stmt|;
name|set_gdbarch_memory_remove_breakpoint
argument_list|(
name|gdbarch
argument_list|,
name|ia64_memory_remove_breakpoint
argument_list|)
expr_stmt|;
name|set_gdbarch_breakpoint_from_pc
argument_list|(
name|gdbarch
argument_list|,
name|ia64_breakpoint_from_pc
argument_list|)
expr_stmt|;
name|set_gdbarch_read_pc
argument_list|(
name|gdbarch
argument_list|,
name|ia64_read_pc
argument_list|)
expr_stmt|;
name|set_gdbarch_write_pc
argument_list|(
name|gdbarch
argument_list|,
name|ia64_write_pc
argument_list|)
expr_stmt|;
comment|/* Settings for calling functions in the inferior.  */
name|set_gdbarch_use_generic_dummy_frames
argument_list|(
name|gdbarch
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|set_gdbarch_call_dummy_length
argument_list|(
name|gdbarch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_gdbarch_push_arguments
argument_list|(
name|gdbarch
argument_list|,
name|ia64_push_arguments
argument_list|)
expr_stmt|;
name|set_gdbarch_push_return_address
argument_list|(
name|gdbarch
argument_list|,
name|ia64_push_return_address
argument_list|)
expr_stmt|;
name|set_gdbarch_pop_frame
argument_list|(
name|gdbarch
argument_list|,
name|ia64_pop_frame
argument_list|)
expr_stmt|;
name|set_gdbarch_call_dummy_p
argument_list|(
name|gdbarch
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|set_gdbarch_call_dummy_words
argument_list|(
name|gdbarch
argument_list|,
name|ia64_call_dummy_words
argument_list|)
expr_stmt|;
name|set_gdbarch_sizeof_call_dummy_words
argument_list|(
name|gdbarch
argument_list|,
sizeof|sizeof
argument_list|(
name|ia64_call_dummy_words
argument_list|)
argument_list|)
expr_stmt|;
name|set_gdbarch_call_dummy_breakpoint_offset_p
argument_list|(
name|gdbarch
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|set_gdbarch_init_extra_frame_info
argument_list|(
name|gdbarch
argument_list|,
name|ia64_init_extra_frame_info
argument_list|)
expr_stmt|;
name|set_gdbarch_frame_args_address
argument_list|(
name|gdbarch
argument_list|,
name|ia64_frame_args_address
argument_list|)
expr_stmt|;
name|set_gdbarch_frame_locals_address
argument_list|(
name|gdbarch
argument_list|,
name|ia64_frame_locals_address
argument_list|)
expr_stmt|;
comment|/* We won't necessarily have a frame pointer and even if we do,      it winds up being extraordinarly messy when attempting to find      the frame chain.  So for the purposes of creating frames (which      is all read_fp() is used for), simply use the stack pointer value      instead.  */
name|set_gdbarch_read_fp
argument_list|(
name|gdbarch
argument_list|,
name|generic_target_read_sp
argument_list|)
expr_stmt|;
name|set_gdbarch_write_fp
argument_list|(
name|gdbarch
argument_list|,
name|generic_target_write_sp
argument_list|)
expr_stmt|;
comment|/* Settings that should be unnecessary.  */
name|set_gdbarch_inner_than
argument_list|(
name|gdbarch
argument_list|,
name|core_addr_lessthan
argument_list|)
expr_stmt|;
name|set_gdbarch_read_sp
argument_list|(
name|gdbarch
argument_list|,
name|generic_target_read_sp
argument_list|)
expr_stmt|;
name|set_gdbarch_write_sp
argument_list|(
name|gdbarch
argument_list|,
name|generic_target_write_sp
argument_list|)
expr_stmt|;
name|set_gdbarch_call_dummy_location
argument_list|(
name|gdbarch
argument_list|,
name|AT_ENTRY_POINT
argument_list|)
expr_stmt|;
name|set_gdbarch_call_dummy_address
argument_list|(
name|gdbarch
argument_list|,
name|entry_point_address
argument_list|)
expr_stmt|;
name|set_gdbarch_call_dummy_breakpoint_offset
argument_list|(
name|gdbarch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_gdbarch_call_dummy_start_offset
argument_list|(
name|gdbarch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_gdbarch_pc_in_call_dummy
argument_list|(
name|gdbarch
argument_list|,
name|generic_pc_in_call_dummy
argument_list|)
expr_stmt|;
name|set_gdbarch_call_dummy_stack_adjust_p
argument_list|(
name|gdbarch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_gdbarch_push_dummy_frame
argument_list|(
name|gdbarch
argument_list|,
name|generic_push_dummy_frame
argument_list|)
expr_stmt|;
name|set_gdbarch_fix_call_dummy
argument_list|(
name|gdbarch
argument_list|,
name|generic_fix_call_dummy
argument_list|)
expr_stmt|;
name|set_gdbarch_decr_pc_after_break
argument_list|(
name|gdbarch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_gdbarch_function_start_offset
argument_list|(
name|gdbarch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_gdbarch_remote_translate_xfer_address
argument_list|(
name|gdbarch
argument_list|,
name|ia64_remote_translate_xfer_address
argument_list|)
expr_stmt|;
return|return
name|gdbarch
return|;
block|}
end_function

begin_function
name|void
name|_initialize_ia64_tdep
parameter_list|(
name|void
parameter_list|)
block|{
name|register_gdbarch_init
argument_list|(
name|bfd_arch_ia64
argument_list|,
name|ia64_gdbarch_init
argument_list|)
expr_stmt|;
name|tm_print_insn
operator|=
name|print_insn_ia64
expr_stmt|;
name|tm_print_insn_info
operator|.
name|bytes_per_line
operator|=
name|SLOT_MULTIPLIER
expr_stmt|;
block|}
end_function

end_unit

