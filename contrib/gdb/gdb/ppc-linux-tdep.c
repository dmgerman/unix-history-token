begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Target-dependent code for GDB, the GNU debugger.     Copyright 1986, 1987, 1989, 1991, 1992, 1993, 1994, 1995, 1996,    1997, 2000, 2001, 2002 Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"solib-svr4.h"
end_include

begin_include
include|#
directive|include
file|"ppc-tdep.h"
end_include

begin_comment
comment|/* The following two instructions are used in the signal trampoline    code on GNU/Linux PPC.  */
end_comment

begin_define
define|#
directive|define
name|INSTR_LI_R0_0x7777
value|0x38007777
end_define

begin_define
define|#
directive|define
name|INSTR_SC
value|0x44000002
end_define

begin_comment
comment|/* Since the *-tdep.c files are platform independent (i.e, they may be    used to build cross platform debuggers), we can't include system    headers.  Therefore, details concerning the sigcontext structure    must be painstakingly rerecorded.  What's worse, if these details    ever change in the header files, they'll have to be changed here    as well. */
end_comment

begin_comment
comment|/* __SIGNAL_FRAMESIZE from<asm/ptrace.h> */
end_comment

begin_define
define|#
directive|define
name|PPC_LINUX_SIGNAL_FRAMESIZE
value|64
end_define

begin_comment
comment|/* From<asm/sigcontext.h>, offsetof(struct sigcontext_struct, regs) == 0x1c */
end_comment

begin_define
define|#
directive|define
name|PPC_LINUX_REGS_PTR_OFFSET
value|(PPC_LINUX_SIGNAL_FRAMESIZE + 0x1c)
end_define

begin_comment
comment|/* From<asm/sigcontext.h>,     offsetof(struct sigcontext_struct, handler) == 0x14 */
end_comment

begin_define
define|#
directive|define
name|PPC_LINUX_HANDLER_PTR_OFFSET
value|(PPC_LINUX_SIGNAL_FRAMESIZE + 0x14)
end_define

begin_comment
comment|/* From<asm/ptrace.h>, values for PT_NIP, PT_R1, and PT_LNK */
end_comment

begin_define
define|#
directive|define
name|PPC_LINUX_PT_R0
value|0
end_define

begin_define
define|#
directive|define
name|PPC_LINUX_PT_R1
value|1
end_define

begin_define
define|#
directive|define
name|PPC_LINUX_PT_R2
value|2
end_define

begin_define
define|#
directive|define
name|PPC_LINUX_PT_R3
value|3
end_define

begin_define
define|#
directive|define
name|PPC_LINUX_PT_R4
value|4
end_define

begin_define
define|#
directive|define
name|PPC_LINUX_PT_R5
value|5
end_define

begin_define
define|#
directive|define
name|PPC_LINUX_PT_R6
value|6
end_define

begin_define
define|#
directive|define
name|PPC_LINUX_PT_R7
value|7
end_define

begin_define
define|#
directive|define
name|PPC_LINUX_PT_R8
value|8
end_define

begin_define
define|#
directive|define
name|PPC_LINUX_PT_R9
value|9
end_define

begin_define
define|#
directive|define
name|PPC_LINUX_PT_R10
value|10
end_define

begin_define
define|#
directive|define
name|PPC_LINUX_PT_R11
value|11
end_define

begin_define
define|#
directive|define
name|PPC_LINUX_PT_R12
value|12
end_define

begin_define
define|#
directive|define
name|PPC_LINUX_PT_R13
value|13
end_define

begin_define
define|#
directive|define
name|PPC_LINUX_PT_R14
value|14
end_define

begin_define
define|#
directive|define
name|PPC_LINUX_PT_R15
value|15
end_define

begin_define
define|#
directive|define
name|PPC_LINUX_PT_R16
value|16
end_define

begin_define
define|#
directive|define
name|PPC_LINUX_PT_R17
value|17
end_define

begin_define
define|#
directive|define
name|PPC_LINUX_PT_R18
value|18
end_define

begin_define
define|#
directive|define
name|PPC_LINUX_PT_R19
value|19
end_define

begin_define
define|#
directive|define
name|PPC_LINUX_PT_R20
value|20
end_define

begin_define
define|#
directive|define
name|PPC_LINUX_PT_R21
value|21
end_define

begin_define
define|#
directive|define
name|PPC_LINUX_PT_R22
value|22
end_define

begin_define
define|#
directive|define
name|PPC_LINUX_PT_R23
value|23
end_define

begin_define
define|#
directive|define
name|PPC_LINUX_PT_R24
value|24
end_define

begin_define
define|#
directive|define
name|PPC_LINUX_PT_R25
value|25
end_define

begin_define
define|#
directive|define
name|PPC_LINUX_PT_R26
value|26
end_define

begin_define
define|#
directive|define
name|PPC_LINUX_PT_R27
value|27
end_define

begin_define
define|#
directive|define
name|PPC_LINUX_PT_R28
value|28
end_define

begin_define
define|#
directive|define
name|PPC_LINUX_PT_R29
value|29
end_define

begin_define
define|#
directive|define
name|PPC_LINUX_PT_R30
value|30
end_define

begin_define
define|#
directive|define
name|PPC_LINUX_PT_R31
value|31
end_define

begin_define
define|#
directive|define
name|PPC_LINUX_PT_NIP
value|32
end_define

begin_define
define|#
directive|define
name|PPC_LINUX_PT_MSR
value|33
end_define

begin_define
define|#
directive|define
name|PPC_LINUX_PT_CTR
value|35
end_define

begin_define
define|#
directive|define
name|PPC_LINUX_PT_LNK
value|36
end_define

begin_define
define|#
directive|define
name|PPC_LINUX_PT_XER
value|37
end_define

begin_define
define|#
directive|define
name|PPC_LINUX_PT_CCR
value|38
end_define

begin_define
define|#
directive|define
name|PPC_LINUX_PT_MQ
value|39
end_define

begin_define
define|#
directive|define
name|PPC_LINUX_PT_FPR0
value|48
end_define

begin_comment
comment|/* each FP reg occupies 2 slots in this space */
end_comment

begin_define
define|#
directive|define
name|PPC_LINUX_PT_FPR31
value|(PPC_LINUX_PT_FPR0 + 2*31)
end_define

begin_define
define|#
directive|define
name|PPC_LINUX_PT_FPSCR
value|(PPC_LINUX_PT_FPR0 + 2*32 + 1)
end_define

begin_function_decl
specifier|static
name|int
name|ppc_linux_at_sigtramp_return_path
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Determine if pc is in a signal trampoline...     Ha!  That's not what this does at all.  wait_for_inferior in    infrun.c calls IN_SIGTRAMP in order to detect entry into a signal    trampoline just after delivery of a signal.  But on GNU/Linux,    signal trampolines are used for the return path only.  The kernel    sets things up so that the signal handler is called directly.     If we use in_sigtramp2() in place of in_sigtramp() (see below)    we'll (often) end up with stop_pc in the trampoline and prev_pc in    the (now exited) handler.  The code there will cause a temporary    breakpoint to be set on prev_pc which is not very likely to get hit    again.     If this is confusing, think of it this way...  the code in    wait_for_inferior() needs to be able to detect entry into a signal    trampoline just after a signal is delivered, not after the handler    has been run.     So, we define in_sigtramp() below to return 1 if the following is    true:     1) The previous frame is a real signal trampoline.     - and -     2) pc is at the first or second instruction of the corresponding    handler.     Why the second instruction?  It seems that wait_for_inferior()    never sees the first instruction when single stepping.  When a    signal is delivered while stepping, the next instruction that    would've been stepped over isn't, instead a signal is delivered and    the first instruction of the handler is stepped over instead.  That    puts us on the second instruction.  (I added the test for the    first instruction long after the fact, just in case the observed    behavior is ever fixed.)     IN_SIGTRAMP is called from blockframe.c as well in order to set    the signal_handler_caller flag.  Because of our strange definition    of in_sigtramp below, we can't rely on signal_handler_caller getting    set correctly from within blockframe.c.  This is why we take pains    to set it in init_extra_frame_info().  */
end_comment

begin_function
name|int
name|ppc_linux_in_sigtramp
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|char
modifier|*
name|func_name
parameter_list|)
block|{
name|CORE_ADDR
name|lr
decl_stmt|;
name|CORE_ADDR
name|sp
decl_stmt|;
name|CORE_ADDR
name|tramp_sp
decl_stmt|;
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|CORE_ADDR
name|handler
decl_stmt|;
name|lr
operator|=
name|read_register
argument_list|(
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|ppc_lr_regnum
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ppc_linux_at_sigtramp_return_path
argument_list|(
name|lr
argument_list|)
condition|)
return|return
literal|0
return|;
name|sp
operator|=
name|read_register
argument_list|(
name|SP_REGNUM
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_read_memory
argument_list|(
name|sp
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
name|tramp_sp
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_read_memory
argument_list|(
name|tramp_sp
operator|+
name|PPC_LINUX_HANDLER_PTR_OFFSET
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
name|handler
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
return|return
operator|(
name|pc
operator|==
name|handler
operator|||
name|pc
operator|==
name|handler
operator|+
literal|4
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The signal handler trampoline is on the stack and consists of exactly  * two instructions.  The easiest and most accurate way of determining  * whether the pc is in one of these trampolines is by inspecting the  * instructions.  It'd be faster though if we could find a way to do this  * via some simple address comparisons.  */
end_comment

begin_function
specifier|static
name|int
name|ppc_linux_at_sigtramp_return_path
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
name|char
name|buf
index|[
literal|12
index|]
decl_stmt|;
name|unsigned
name|long
name|pcinsn
decl_stmt|;
if|if
condition|(
name|target_read_memory
argument_list|(
name|pc
operator|-
literal|4
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* extract the instruction at the pc */
name|pcinsn
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
operator|+
literal|4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|pcinsn
operator|==
name|INSTR_LI_R0_0x7777
operator|&&
name|extract_unsigned_integer
argument_list|(
name|buf
operator|+
literal|8
argument_list|,
literal|4
argument_list|)
operator|==
name|INSTR_SC
operator|)
operator|||
operator|(
name|pcinsn
operator|==
name|INSTR_SC
operator|&&
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|)
operator|==
name|INSTR_LI_R0_0x7777
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|CORE_ADDR
name|ppc_linux_skip_trampoline_code
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|struct
name|obj_section
modifier|*
name|sect
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|unsigned
name|long
name|insn
decl_stmt|;
name|CORE_ADDR
name|plt_start
init|=
literal|0
decl_stmt|;
name|CORE_ADDR
name|symtab
init|=
literal|0
decl_stmt|;
name|CORE_ADDR
name|strtab
init|=
literal|0
decl_stmt|;
name|int
name|num_slots
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|reloc_index
init|=
operator|-
literal|1
decl_stmt|;
name|CORE_ADDR
name|plt_table
decl_stmt|;
name|CORE_ADDR
name|reloc
decl_stmt|;
name|CORE_ADDR
name|sym
decl_stmt|;
name|long
name|symidx
decl_stmt|;
name|char
name|symname
index|[
literal|1024
index|]
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
comment|/* Find the section pc is in; return if not in .plt */
name|sect
operator|=
name|find_pc_section
argument_list|(
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sect
operator|||
name|strcmp
argument_list|(
name|sect
operator|->
name|the_bfd_section
operator|->
name|name
argument_list|,
literal|".plt"
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
name|objfile
operator|=
name|sect
operator|->
name|objfile
expr_stmt|;
comment|/* Pick up the instruction at pc.  It had better be of the      form      li r11, IDX       where IDX is an index into the plt_table.  */
if|if
condition|(
name|target_read_memory
argument_list|(
name|pc
argument_list|,
name|buf
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
name|insn
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xffff0000
operator|)
operator|!=
literal|0x39600000
comment|/* li r11, VAL */
condition|)
return|return
literal|0
return|;
name|reloc_index
operator|=
operator|(
name|insn
operator|<<
literal|16
operator|)
operator|>>
literal|16
expr_stmt|;
comment|/* Find the objfile that pc is in and obtain the information      necessary for finding the symbol name. */
for|for
control|(
name|sect
operator|=
name|objfile
operator|->
name|sections
init|;
name|sect
operator|<
name|objfile
operator|->
name|sections_end
condition|;
operator|++
name|sect
control|)
block|{
specifier|const
name|char
modifier|*
name|secname
init|=
name|sect
operator|->
name|the_bfd_section
operator|->
name|name
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|secname
argument_list|,
literal|".plt"
argument_list|)
operator|==
literal|0
condition|)
name|plt_start
operator|=
name|sect
operator|->
name|addr
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|secname
argument_list|,
literal|".rela.plt"
argument_list|)
operator|==
literal|0
condition|)
name|num_slots
operator|=
operator|(
operator|(
name|int
operator|)
name|sect
operator|->
name|endaddr
operator|-
operator|(
name|int
operator|)
name|sect
operator|->
name|addr
operator|)
operator|/
literal|12
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|secname
argument_list|,
literal|".dynsym"
argument_list|)
operator|==
literal|0
condition|)
name|symtab
operator|=
name|sect
operator|->
name|addr
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|secname
argument_list|,
literal|".dynstr"
argument_list|)
operator|==
literal|0
condition|)
name|strtab
operator|=
name|sect
operator|->
name|addr
expr_stmt|;
block|}
comment|/* Make sure we have all the information we need. */
if|if
condition|(
name|plt_start
operator|==
literal|0
operator|||
name|num_slots
operator|==
operator|-
literal|1
operator|||
name|symtab
operator|==
literal|0
operator|||
name|strtab
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Compute the value of the plt table */
name|plt_table
operator|=
name|plt_start
operator|+
literal|72
operator|+
literal|8
operator|*
name|num_slots
expr_stmt|;
comment|/* Get address of the relocation entry (Elf32_Rela) */
if|if
condition|(
name|target_read_memory
argument_list|(
name|plt_table
operator|+
name|reloc_index
argument_list|,
name|buf
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
name|reloc
operator|=
name|extract_address
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|sect
operator|=
name|find_pc_section
argument_list|(
name|reloc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sect
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|sect
operator|->
name|the_bfd_section
operator|->
name|name
argument_list|,
literal|".text"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|reloc
return|;
comment|/* Now get the r_info field which is the relocation type and symbol      index. */
if|if
condition|(
name|target_read_memory
argument_list|(
name|reloc
operator|+
literal|4
argument_list|,
name|buf
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
name|symidx
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Shift out the relocation type leaving just the symbol index */
comment|/* symidx = ELF32_R_SYM(symidx); */
name|symidx
operator|=
name|symidx
operator|>>
literal|8
expr_stmt|;
comment|/* compute the address of the symbol */
name|sym
operator|=
name|symtab
operator|+
name|symidx
operator|*
literal|4
expr_stmt|;
comment|/* Fetch the string table index */
if|if
condition|(
name|target_read_memory
argument_list|(
name|sym
argument_list|,
name|buf
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
name|symidx
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Fetch the string; we don't know how long it is.  Is it possible      that the following will fail because we're trying to fetch too      much? */
if|if
condition|(
name|target_read_memory
argument_list|(
name|strtab
operator|+
name|symidx
argument_list|,
name|symname
argument_list|,
sizeof|sizeof
argument_list|(
name|symname
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* This might not work right if we have multiple symbols with the      same name; the only way to really get it right is to perform      the same sort of lookup as the dynamic linker. */
name|msymbol
operator|=
name|lookup_minimal_symbol_text
argument_list|(
name|symname
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|msymbol
condition|)
return|return
literal|0
return|;
return|return
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The rs6000 version of FRAME_SAVED_PC will almost work for us.  The    signal handler details are different, so we'll handle those here    and call the rs6000 version to do the rest. */
end_comment

begin_function
name|CORE_ADDR
name|ppc_linux_frame_saved_pc
parameter_list|(
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|)
block|{
if|if
condition|(
name|fi
operator|->
name|signal_handler_caller
condition|)
block|{
name|CORE_ADDR
name|regs_addr
init|=
name|read_memory_integer
argument_list|(
name|fi
operator|->
name|frame
operator|+
name|PPC_LINUX_REGS_PTR_OFFSET
argument_list|,
literal|4
argument_list|)
decl_stmt|;
comment|/* return the NIP in the regs array */
return|return
name|read_memory_integer
argument_list|(
name|regs_addr
operator|+
literal|4
operator|*
name|PPC_LINUX_PT_NIP
argument_list|,
literal|4
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|fi
operator|->
name|next
operator|&&
name|fi
operator|->
name|next
operator|->
name|signal_handler_caller
condition|)
block|{
name|CORE_ADDR
name|regs_addr
init|=
name|read_memory_integer
argument_list|(
name|fi
operator|->
name|next
operator|->
name|frame
operator|+
name|PPC_LINUX_REGS_PTR_OFFSET
argument_list|,
literal|4
argument_list|)
decl_stmt|;
comment|/* return LNK in the regs array */
return|return
name|read_memory_integer
argument_list|(
name|regs_addr
operator|+
literal|4
operator|*
name|PPC_LINUX_PT_LNK
argument_list|,
literal|4
argument_list|)
return|;
block|}
else|else
return|return
name|rs6000_frame_saved_pc
argument_list|(
name|fi
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|ppc_linux_init_extra_frame_info
parameter_list|(
name|int
name|fromleaf
parameter_list|,
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|)
block|{
name|rs6000_init_extra_frame_info
argument_list|(
name|fromleaf
argument_list|,
name|fi
argument_list|)
expr_stmt|;
if|if
condition|(
name|fi
operator|->
name|next
operator|!=
literal|0
condition|)
block|{
comment|/* We're called from get_prev_frame_info; check to see if          this is a signal frame by looking to see if the pc points          at trampoline code */
if|if
condition|(
name|ppc_linux_at_sigtramp_return_path
argument_list|(
name|fi
operator|->
name|pc
argument_list|)
condition|)
name|fi
operator|->
name|signal_handler_caller
operator|=
literal|1
expr_stmt|;
else|else
name|fi
operator|->
name|signal_handler_caller
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|ppc_linux_frameless_function_invocation
parameter_list|(
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|)
block|{
comment|/* We'll find the wrong thing if we let       rs6000_frameless_function_invocation () search for a signal trampoline */
if|if
condition|(
name|ppc_linux_at_sigtramp_return_path
argument_list|(
name|fi
operator|->
name|pc
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
return|return
name|rs6000_frameless_function_invocation
argument_list|(
name|fi
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|ppc_linux_frame_init_saved_regs
parameter_list|(
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|)
block|{
if|if
condition|(
name|fi
operator|->
name|signal_handler_caller
condition|)
block|{
name|CORE_ADDR
name|regs_addr
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|fi
operator|->
name|saved_regs
condition|)
return|return;
name|frame_saved_regs_zalloc
argument_list|(
name|fi
argument_list|)
expr_stmt|;
name|regs_addr
operator|=
name|read_memory_integer
argument_list|(
name|fi
operator|->
name|frame
operator|+
name|PPC_LINUX_REGS_PTR_OFFSET
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|fi
operator|->
name|saved_regs
index|[
name|PC_REGNUM
index|]
operator|=
name|regs_addr
operator|+
literal|4
operator|*
name|PPC_LINUX_PT_NIP
expr_stmt|;
name|fi
operator|->
name|saved_regs
index|[
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|ppc_ps_regnum
index|]
operator|=
name|regs_addr
operator|+
literal|4
operator|*
name|PPC_LINUX_PT_MSR
expr_stmt|;
name|fi
operator|->
name|saved_regs
index|[
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|ppc_cr_regnum
index|]
operator|=
name|regs_addr
operator|+
literal|4
operator|*
name|PPC_LINUX_PT_CCR
expr_stmt|;
name|fi
operator|->
name|saved_regs
index|[
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|ppc_lr_regnum
index|]
operator|=
name|regs_addr
operator|+
literal|4
operator|*
name|PPC_LINUX_PT_LNK
expr_stmt|;
name|fi
operator|->
name|saved_regs
index|[
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|ppc_ctr_regnum
index|]
operator|=
name|regs_addr
operator|+
literal|4
operator|*
name|PPC_LINUX_PT_CTR
expr_stmt|;
name|fi
operator|->
name|saved_regs
index|[
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|ppc_xer_regnum
index|]
operator|=
name|regs_addr
operator|+
literal|4
operator|*
name|PPC_LINUX_PT_XER
expr_stmt|;
name|fi
operator|->
name|saved_regs
index|[
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|ppc_mq_regnum
index|]
operator|=
name|regs_addr
operator|+
literal|4
operator|*
name|PPC_LINUX_PT_MQ
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
name|fi
operator|->
name|saved_regs
index|[
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|ppc_gp0_regnum
operator|+
name|i
index|]
operator|=
name|regs_addr
operator|+
literal|4
operator|*
name|PPC_LINUX_PT_R0
operator|+
literal|4
operator|*
name|i
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
name|fi
operator|->
name|saved_regs
index|[
name|FP0_REGNUM
operator|+
name|i
index|]
operator|=
name|regs_addr
operator|+
literal|4
operator|*
name|PPC_LINUX_PT_FPR0
operator|+
literal|8
operator|*
name|i
expr_stmt|;
block|}
else|else
name|rs6000_frame_init_saved_regs
argument_list|(
name|fi
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|CORE_ADDR
name|ppc_linux_frame_chain
parameter_list|(
name|struct
name|frame_info
modifier|*
name|thisframe
parameter_list|)
block|{
comment|/* Kernel properly constructs the frame chain for the handler */
if|if
condition|(
name|thisframe
operator|->
name|signal_handler_caller
condition|)
return|return
name|read_memory_integer
argument_list|(
operator|(
name|thisframe
operator|)
operator|->
name|frame
argument_list|,
literal|4
argument_list|)
return|;
else|else
return|return
name|rs6000_frame_chain
argument_list|(
name|thisframe
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* FIXME: Move the following to rs6000-tdep.c (or some other file where    it may be used generically by ports which use either the SysV ABI or    the EABI */
end_comment

begin_comment
comment|/* round2 rounds x up to the nearest multiple of s assuming that s is a    power of 2 */
end_comment

begin_undef
undef|#
directive|undef
name|round2
end_undef

begin_define
define|#
directive|define
name|round2
parameter_list|(
name|x
parameter_list|,
name|s
parameter_list|)
value|((((long) (x) - 1)& ~(long)((s)-1)) + (s))
end_define

begin_comment
comment|/* Pass the arguments in either registers, or in the stack. Using the    ppc sysv ABI, the first eight words of the argument list (that might    be less than eight parameters if some parameters occupy more than one    word) are passed in r3..r10 registers.  float and double parameters are    passed in fpr's, in addition to that. Rest of the parameters if any    are passed in user stack.      If the function is returning a structure, then the return address is passed    in r3, then the first 7 words of the parametes can be passed in registers,    starting from r4. */
end_comment

begin_function
name|CORE_ADDR
name|ppc_sysv_abi_push_arguments
parameter_list|(
name|int
name|nargs
parameter_list|,
name|struct
name|value
modifier|*
modifier|*
name|args
parameter_list|,
name|CORE_ADDR
name|sp
parameter_list|,
name|int
name|struct_return
parameter_list|,
name|CORE_ADDR
name|struct_addr
parameter_list|)
block|{
name|int
name|argno
decl_stmt|;
name|int
name|greg
decl_stmt|,
name|freg
decl_stmt|;
name|int
name|argstkspace
decl_stmt|;
name|int
name|structstkspace
decl_stmt|;
name|int
name|argoffset
decl_stmt|;
name|int
name|structoffset
decl_stmt|;
name|struct
name|value
modifier|*
name|arg
decl_stmt|;
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|int
name|len
decl_stmt|;
name|char
name|old_sp_buf
index|[
literal|4
index|]
decl_stmt|;
name|CORE_ADDR
name|saved_sp
decl_stmt|;
name|greg
operator|=
name|struct_return
condition|?
literal|4
else|:
literal|3
expr_stmt|;
name|freg
operator|=
literal|1
expr_stmt|;
name|argstkspace
operator|=
literal|0
expr_stmt|;
name|structstkspace
operator|=
literal|0
expr_stmt|;
comment|/* Figure out how much new stack space is required for arguments      which don't fit in registers.  Unlike the PowerOpen ABI, the      SysV ABI doesn't reserve any extra space for parameters which      are put in registers. */
for|for
control|(
name|argno
operator|=
literal|0
init|;
name|argno
operator|<
name|nargs
condition|;
name|argno
operator|++
control|)
block|{
name|arg
operator|=
name|args
index|[
name|argno
index|]
expr_stmt|;
name|type
operator|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_FLT
condition|)
block|{
if|if
condition|(
name|freg
operator|<=
literal|8
condition|)
name|freg
operator|++
expr_stmt|;
else|else
block|{
comment|/* SysV ABI converts floats to doubles when placed in 	         memory and requires 8 byte alignment */
if|if
condition|(
name|argstkspace
operator|&
literal|0x4
condition|)
name|argstkspace
operator|+=
literal|4
expr_stmt|;
name|argstkspace
operator|+=
literal|8
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_INT
operator|&&
name|len
operator|==
literal|8
condition|)
comment|/* long long */
block|{
if|if
condition|(
name|greg
operator|>
literal|9
condition|)
block|{
name|greg
operator|=
literal|11
expr_stmt|;
if|if
condition|(
name|argstkspace
operator|&
literal|0x4
condition|)
name|argstkspace
operator|+=
literal|4
expr_stmt|;
name|argstkspace
operator|+=
literal|8
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|greg
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
name|greg
operator|++
expr_stmt|;
name|greg
operator|+=
literal|2
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|len
operator|>
literal|4
operator|||
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
operator|||
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_UNION
condition|)
block|{
comment|/* Rounding to the nearest multiple of 8 may not be necessary, 	         but it is safe.  Particularly since we don't know the 	         field types of the structure */
name|structstkspace
operator|+=
name|round2
argument_list|(
name|len
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|greg
operator|<=
literal|10
condition|)
name|greg
operator|++
expr_stmt|;
else|else
name|argstkspace
operator|+=
literal|4
expr_stmt|;
block|}
block|}
comment|/* Get current SP location */
name|saved_sp
operator|=
name|read_sp
argument_list|()
expr_stmt|;
name|sp
operator|-=
name|argstkspace
operator|+
name|structstkspace
expr_stmt|;
comment|/* Allocate space for backchain and callee's saved lr */
name|sp
operator|-=
literal|8
expr_stmt|;
comment|/* Make sure that we maintain 16 byte alignment */
name|sp
operator|&=
operator|~
literal|0x0f
expr_stmt|;
comment|/* Update %sp before proceeding any further */
name|write_register
argument_list|(
name|SP_REGNUM
argument_list|,
name|sp
argument_list|)
expr_stmt|;
comment|/* write the backchain */
name|store_address
argument_list|(
name|old_sp_buf
argument_list|,
literal|4
argument_list|,
name|saved_sp
argument_list|)
expr_stmt|;
name|write_memory
argument_list|(
name|sp
argument_list|,
name|old_sp_buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|argoffset
operator|=
literal|8
expr_stmt|;
name|structoffset
operator|=
name|argoffset
operator|+
name|argstkspace
expr_stmt|;
name|freg
operator|=
literal|1
expr_stmt|;
name|greg
operator|=
literal|3
expr_stmt|;
comment|/* Fill in r3 with the return structure, if any */
if|if
condition|(
name|struct_return
condition|)
block|{
name|char
name|val_buf
index|[
literal|4
index|]
decl_stmt|;
name|store_address
argument_list|(
name|val_buf
argument_list|,
literal|4
argument_list|,
name|struct_addr
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|greg
argument_list|)
index|]
argument_list|,
name|val_buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|greg
operator|++
expr_stmt|;
block|}
comment|/* Now fill in the registers and stack... */
for|for
control|(
name|argno
operator|=
literal|0
init|;
name|argno
operator|<
name|nargs
condition|;
name|argno
operator|++
control|)
block|{
name|arg
operator|=
name|args
index|[
name|argno
index|]
expr_stmt|;
name|type
operator|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_FLT
condition|)
block|{
if|if
condition|(
name|freg
operator|<=
literal|8
condition|)
block|{
if|if
condition|(
name|len
operator|>
literal|8
condition|)
name|printf_unfiltered
argument_list|(
literal|"Fatal Error: a floating point parameter #%d with a size> 8 is found!\n"
argument_list|,
name|argno
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|FP0_REGNUM
operator|+
name|freg
argument_list|)
index|]
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|arg
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|freg
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* SysV ABI converts floats to doubles when placed in 	         memory and requires 8 byte alignment */
comment|/* FIXME: Convert floats to doubles */
if|if
condition|(
name|argoffset
operator|&
literal|0x4
condition|)
name|argoffset
operator|+=
literal|4
expr_stmt|;
name|write_memory
argument_list|(
name|sp
operator|+
name|argoffset
argument_list|,
operator|(
name|char
operator|*
operator|)
name|VALUE_CONTENTS
argument_list|(
name|arg
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|argoffset
operator|+=
literal|8
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_INT
operator|&&
name|len
operator|==
literal|8
condition|)
comment|/* long long */
block|{
if|if
condition|(
name|greg
operator|>
literal|9
condition|)
block|{
name|greg
operator|=
literal|11
expr_stmt|;
if|if
condition|(
name|argoffset
operator|&
literal|0x4
condition|)
name|argoffset
operator|+=
literal|4
expr_stmt|;
name|write_memory
argument_list|(
name|sp
operator|+
name|argoffset
argument_list|,
operator|(
name|char
operator|*
operator|)
name|VALUE_CONTENTS
argument_list|(
name|arg
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|argoffset
operator|+=
literal|8
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|greg
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
name|greg
operator|++
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|greg
argument_list|)
index|]
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|arg
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|greg
operator|+
literal|1
argument_list|)
index|]
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|arg
argument_list|)
operator|+
literal|4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|greg
operator|+=
literal|2
expr_stmt|;
block|}
block|}
else|else
block|{
name|char
name|val_buf
index|[
literal|4
index|]
decl_stmt|;
if|if
condition|(
name|len
operator|>
literal|4
operator|||
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
operator|||
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_UNION
condition|)
block|{
name|write_memory
argument_list|(
name|sp
operator|+
name|structoffset
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|arg
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|store_address
argument_list|(
name|val_buf
argument_list|,
literal|4
argument_list|,
name|sp
operator|+
name|structoffset
argument_list|)
expr_stmt|;
name|structoffset
operator|+=
name|round2
argument_list|(
name|len
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memset
argument_list|(
name|val_buf
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|val_buf
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|arg
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|greg
operator|<=
literal|10
condition|)
block|{
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|greg
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|greg
argument_list|)
index|]
argument_list|,
name|val_buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|greg
operator|++
expr_stmt|;
block|}
else|else
block|{
name|write_memory
argument_list|(
name|sp
operator|+
name|argoffset
argument_list|,
name|val_buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|argoffset
operator|+=
literal|4
expr_stmt|;
block|}
block|}
block|}
name|target_store_registers
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|sp
return|;
block|}
end_function

begin_comment
comment|/* ppc_linux_memory_remove_breakpoints attempts to remove a breakpoint    in much the same fashion as memory_remove_breakpoint in mem-break.c,    but is careful not to write back the previous contents if the code    in question has changed in between inserting the breakpoint and    removing it.     Here is the problem that we're trying to solve...     Once upon a time, before introducing this function to remove    breakpoints from the inferior, setting a breakpoint on a shared    library function prior to running the program would not work    properly.  In order to understand the problem, it is first    necessary to understand a little bit about dynamic linking on    this platform.     A call to a shared library function is accomplished via a bl    (branch-and-link) instruction whose branch target is an entry    in the procedure linkage table (PLT).  The PLT in the object    file is uninitialized.  To gdb, prior to running the program, the    entries in the PLT are all zeros.     Once the program starts running, the shared libraries are loaded    and the procedure linkage table is initialized, but the entries in    the table are not (necessarily) resolved.  Once a function is    actually called, the code in the PLT is hit and the function is    resolved.  In order to better illustrate this, an example is in    order; the following example is from the gdb testsuite. 	     	We start the program shmain.  	    [kev@arroyo testsuite]$ ../gdb gdb.base/shmain 	    [...]  	We place two breakpoints, one on shr1 and the other on main.  	    (gdb) b shr1 	    Breakpoint 1 at 0x100409d4 	    (gdb) b main 	    Breakpoint 2 at 0x100006a0: file gdb.base/shmain.c, line 44.  	Examine the instruction (and the immediatly following instruction) 	upon which the breakpoint was placed.  Note that the PLT entry 	for shr1 contains zeros.  	    (gdb) x/2i 0x100409d4 	    0x100409d4<shr1>:      .long 0x0 	    0x100409d8<shr1+4>:    .long 0x0  	Now run 'til main.  	    (gdb) r 	    Starting program: gdb.base/shmain  	    Breakpoint 1 at 0xffaf790: file gdb.base/shr1.c, line 19.  	    Breakpoint 2, main () 		at gdb.base/shmain.c:44 	    44        g = 1;  	Examine the PLT again.  Note that the loading of the shared 	library has initialized the PLT to code which loads a constant 	(which I think is an index into the GOT) into r11 and then 	branchs a short distance to the code which actually does the 	resolving.  	    (gdb) x/2i 0x100409d4 	    0x100409d4<shr1>:      li      r11,4 	    0x100409d8<shr1+4>:    b       0x10040984<sg+4> 	    (gdb) c 	    Continuing.  	    Breakpoint 1, shr1 (x=1) 		at gdb.base/shr1.c:19 	    19        l = 1;  	Now we've hit the breakpoint at shr1.  (The breakpoint was 	reset from the PLT entry to the actual shr1 function after the 	shared library was loaded.) Note that the PLT entry has been 	resolved to contain a branch that takes us directly to shr1.  	(The real one, not the PLT entry.)  	    (gdb) x/2i 0x100409d4 	    0x100409d4<shr1>:      b       0xffaf76c<shr1> 	    0x100409d8<shr1+4>:    b       0x10040984<sg+4>     The thing to note here is that the PLT entry for shr1 has been    changed twice.     Now the problem should be obvious.  GDB places a breakpoint (a    trap instruction) on the zero value of the PLT entry for shr1.     Later on, after the shared library had been loaded and the PLT    initialized, GDB gets a signal indicating this fact and attempts    (as it always does when it stops) to remove all the breakpoints.     The breakpoint removal was causing the former contents (a zero    word) to be written back to the now initialized PLT entry thus    destroying a portion of the initialization that had occurred only a    short time ago.  When execution continued, the zero word would be    executed as an instruction an an illegal instruction trap was    generated instead.  (0 is not a legal instruction.)     The fix for this problem was fairly straightforward.  The function    memory_remove_breakpoint from mem-break.c was copied to this file,    modified slightly, and renamed to ppc_linux_memory_remove_breakpoint.    In tm-linux.h, MEMORY_REMOVE_BREAKPOINT is defined to call this new    function.     The differences between ppc_linux_memory_remove_breakpoint () and    memory_remove_breakpoint () are minor.  All that the former does    that the latter does not is check to make sure that the breakpoint    location actually contains a breakpoint (trap instruction) prior    to attempting to write back the old contents.  If it does contain    a trap instruction, we allow the old contents to be written back.     Otherwise, we silently do nothing.     The big question is whether memory_remove_breakpoint () should be    changed to have the same functionality.  The downside is that more    traffic is generated for remote targets since we'll have an extra    fetch of a memory word each time a breakpoint is removed.     For the time being, we'll leave this self-modifying-code-friendly    version in ppc-linux-tdep.c, but it ought to be migrated somewhere    else in the event that some other platform has similar needs with    regard to removing breakpoints in some potentially self modifying    code.  */
end_comment

begin_function
name|int
name|ppc_linux_memory_remove_breakpoint
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|char
modifier|*
name|contents_cache
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|bp
decl_stmt|;
name|int
name|val
decl_stmt|;
name|int
name|bplen
decl_stmt|;
name|char
name|old_contents
index|[
name|BREAKPOINT_MAX
index|]
decl_stmt|;
comment|/* Determine appropriate breakpoint contents and size for this address.  */
name|bp
operator|=
name|BREAKPOINT_FROM_PC
argument_list|(
operator|&
name|addr
argument_list|,
operator|&
name|bplen
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Software breakpoints not implemented for this target."
argument_list|)
expr_stmt|;
name|val
operator|=
name|target_read_memory
argument_list|(
name|addr
argument_list|,
name|old_contents
argument_list|,
name|bplen
argument_list|)
expr_stmt|;
comment|/* If our breakpoint is no longer at the address, this means that the      program modified the code on us, so it is wrong to put back the      old value */
if|if
condition|(
name|val
operator|==
literal|0
operator|&&
name|memcmp
argument_list|(
name|bp
argument_list|,
name|old_contents
argument_list|,
name|bplen
argument_list|)
operator|==
literal|0
condition|)
name|val
operator|=
name|target_write_memory
argument_list|(
name|addr
argument_list|,
name|contents_cache
argument_list|,
name|bplen
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Fetch (and possibly build) an appropriate link_map_offsets    structure for GNU/Linux PPC targets using the struct offsets    defined in link.h (but without actual reference to that file).     This makes it possible to access GNU/Linux PPC shared libraries    from a GDB that was not built on an GNU/Linux PPC host (for cross    debugging).  */
end_comment

begin_function
name|struct
name|link_map_offsets
modifier|*
name|ppc_linux_svr4_fetch_link_map_offsets
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|struct
name|link_map_offsets
name|lmo
decl_stmt|;
specifier|static
name|struct
name|link_map_offsets
modifier|*
name|lmp
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|lmp
operator|==
name|NULL
condition|)
block|{
name|lmp
operator|=
operator|&
name|lmo
expr_stmt|;
name|lmo
operator|.
name|r_debug_size
operator|=
literal|8
expr_stmt|;
comment|/* The actual size is 20 bytes, but 				   this is all we need.  */
name|lmo
operator|.
name|r_map_offset
operator|=
literal|4
expr_stmt|;
name|lmo
operator|.
name|r_map_size
operator|=
literal|4
expr_stmt|;
name|lmo
operator|.
name|link_map_size
operator|=
literal|20
expr_stmt|;
comment|/* The actual size is 560 bytes, but 				   this is all we need.  */
name|lmo
operator|.
name|l_addr_offset
operator|=
literal|0
expr_stmt|;
name|lmo
operator|.
name|l_addr_size
operator|=
literal|4
expr_stmt|;
name|lmo
operator|.
name|l_name_offset
operator|=
literal|4
expr_stmt|;
name|lmo
operator|.
name|l_name_size
operator|=
literal|4
expr_stmt|;
name|lmo
operator|.
name|l_next_offset
operator|=
literal|12
expr_stmt|;
name|lmo
operator|.
name|l_next_size
operator|=
literal|4
expr_stmt|;
name|lmo
operator|.
name|l_prev_offset
operator|=
literal|16
expr_stmt|;
name|lmo
operator|.
name|l_prev_size
operator|=
literal|4
expr_stmt|;
block|}
return|return
name|lmp
return|;
block|}
end_function

end_unit

