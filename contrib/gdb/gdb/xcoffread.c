begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Read AIX xcoff symbol tables and convert to internal format, for GDB.    Copyright 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996    	     Free Software Foundation, Inc.    Derived from coffread.c, dbxread.c, and a lot of hacking.    Contributed by IBM Corporation.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* RS/6000 and PowerPC only:    Needs xcoff_add_toc_to_loadinfo and xcoff_init_loadinfo in    rs6000-tdep.c from target.    However, if you define FAKING_RS6000, then this code will link with    any target.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|NO_SYS_FILE
end_ifndef

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"gdb_stat.h"
end_include

begin_include
include|#
directive|include
file|"coff/internal.h"
end_include

begin_include
include|#
directive|include
file|"libcoff.h"
end_include

begin_comment
comment|/* FIXME, internal data from BFD */
end_comment

begin_include
include|#
directive|include
file|"coff/rs6000.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"buildsym.h"
end_include

begin_include
include|#
directive|include
file|"stabsread.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_comment
comment|/* Needed inside partial-stab.h */
end_comment

begin_include
include|#
directive|include
file|"complaints.h"
end_include

begin_include
include|#
directive|include
file|"gdb-stabs.h"
end_include

begin_comment
comment|/* For interface with stabsread.c.  */
end_comment

begin_include
include|#
directive|include
file|"aout/stab_gnu.h"
end_include

begin_comment
comment|/* For interface with partial-stab.h.  */
end_comment

begin_define
define|#
directive|define
name|N_UNDF
value|0
end_define

begin_comment
comment|/* Undefined symbol */
end_comment

begin_undef
undef|#
directive|undef
name|N_ABS
end_undef

begin_define
define|#
directive|define
name|N_ABS
value|2
end_define

begin_define
define|#
directive|define
name|N_TEXT
value|4
end_define

begin_comment
comment|/* Text sym -- defined at offset in text seg */
end_comment

begin_define
define|#
directive|define
name|N_DATA
value|6
end_define

begin_comment
comment|/* Data sym -- defined at offset in data seg */
end_comment

begin_define
define|#
directive|define
name|N_BSS
value|8
end_define

begin_comment
comment|/* BSS  sym -- defined at offset in zero'd seg */
end_comment

begin_define
define|#
directive|define
name|N_COMM
value|0x12
end_define

begin_comment
comment|/* Common symbol (visible after shared lib dynlink) */
end_comment

begin_define
define|#
directive|define
name|N_FN
value|0x1f
end_define

begin_comment
comment|/* File name of .o file */
end_comment

begin_define
define|#
directive|define
name|N_FN_SEQ
value|0x0C
end_define

begin_comment
comment|/* N_FN from Sequent compilers (sigh) */
end_comment

begin_comment
comment|/* Note: N_EXT can only be usefully OR-ed with N_UNDF, N_ABS, N_TEXT,    N_DATA, or N_BSS.  When the low-order bit of other types is set,    (e.g. N_WARNING versus N_FN), they are two different types.  */
end_comment

begin_define
define|#
directive|define
name|N_EXT
value|1
end_define

begin_comment
comment|/* External symbol (as opposed to local-to-this-file) */
end_comment

begin_define
define|#
directive|define
name|N_INDR
value|0x0a
end_define

begin_comment
comment|/* The following symbols refer to set elements.    All the N_SET[ATDB] symbols with the same name form one set.    Space is allocated for the set in the text section, and each set    elements value is stored into one word of the space.    The first word of the space is the length of the set (number of elements).     The address of the set is made into an N_SETV symbol    whose name is the same as the name of the set.    This symbol acts like a N_DATA global symbol    in that it can satisfy undefined external references.  */
end_comment

begin_comment
comment|/* These appear as input to LD, in a .o file.  */
end_comment

begin_define
define|#
directive|define
name|N_SETA
value|0x14
end_define

begin_comment
comment|/* Absolute set element symbol */
end_comment

begin_define
define|#
directive|define
name|N_SETT
value|0x16
end_define

begin_comment
comment|/* Text set element symbol */
end_comment

begin_define
define|#
directive|define
name|N_SETD
value|0x18
end_define

begin_comment
comment|/* Data set element symbol */
end_comment

begin_define
define|#
directive|define
name|N_SETB
value|0x1A
end_define

begin_comment
comment|/* Bss set element symbol */
end_comment

begin_comment
comment|/* This is output from LD.  */
end_comment

begin_define
define|#
directive|define
name|N_SETV
value|0x1C
end_define

begin_comment
comment|/* Pointer to set vector in data area.  */
end_comment

begin_escape
end_escape

begin_comment
comment|/* We put a pointer to this structure in the read_symtab_private field    of the psymtab.  */
end_comment

begin_struct
struct|struct
name|symloc
block|{
comment|/* First symbol number for this file.  */
name|int
name|first_symnum
decl_stmt|;
comment|/* Number of symbols in the section of the symbol table devoted to      this file's symbols (actually, the section bracketed may contain      more than just this file's symbols).  If numsyms is 0, the only      reason for this thing's existence is the dependency list.  Nothing      else will happen when it is read in.  */
name|int
name|numsyms
decl_stmt|;
comment|/* Position of the start of the line number information for this psymtab.  */
name|unsigned
name|int
name|lineno_off
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Remember what we deduced to be the source language of this psymtab. */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|language
name|psymtab_language
init|=
name|language_unknown
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Simplified internal version of coff symbol table information */
end_comment

begin_struct
struct|struct
name|coff_symbol
block|{
name|char
modifier|*
name|c_name
decl_stmt|;
name|int
name|c_symnum
decl_stmt|;
comment|/* symbol number of this entry */
name|int
name|c_naux
decl_stmt|;
comment|/* 0 if syment only, 1 if syment + auxent */
name|long
name|c_value
decl_stmt|;
name|unsigned
name|char
name|c_sclass
decl_stmt|;
name|int
name|c_secnum
decl_stmt|;
name|unsigned
name|int
name|c_type
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* last function's saved coff symbol `cs' */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|coff_symbol
name|fcn_cs_saved
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd
modifier|*
name|symfile_bfd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Core address of start and end of text of current source file.    This is calculated from the first function seen after a C_FILE    symbol. */
end_comment

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|cur_src_end_addr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Core address of the end of the first object file.  */
end_comment

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|first_object_file_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* initial symbol-table-debug-string vector length */
end_comment

begin_define
define|#
directive|define
name|INITIAL_STABVECTOR_LENGTH
value|40
end_define

begin_comment
comment|/* Nonzero if within a function (so symbols should be local,    if nothing says specifically).  */
end_comment

begin_decl_stmt
name|int
name|within_function
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size of a COFF symbol.  I think it is always 18, so I'm not sure    there is any reason not to just use a #define, but might as well    ask BFD for the size and store it here, I guess.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|local_symesz
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|coff_symfile_info
block|{
name|file_ptr
name|min_lineno_offset
decl_stmt|;
comment|/* Where in file lowest line#s are */
name|file_ptr
name|max_lineno_offset
decl_stmt|;
comment|/* 1+last byte of line#s in file */
comment|/* Pointer to the string table.  */
name|char
modifier|*
name|strtbl
decl_stmt|;
comment|/* Pointer to debug section.  */
name|char
modifier|*
name|debugsec
decl_stmt|;
comment|/* Pointer to the a.out symbol table.  */
name|char
modifier|*
name|symtbl
decl_stmt|;
comment|/* Number of symbols in symtbl.  */
name|int
name|symtbl_num_syms
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|complaint
name|storclass_complaint
init|=
block|{
literal|"Unexpected storage class: %d"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|complaint
name|bf_notfound_complaint
init|=
block|{
literal|"line numbers off, `.bf' symbol not found"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|complaint
name|ef_complaint
init|=
block|{
literal|"Mismatched .ef symbol ignored starting at symnum %d"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|complaint
name|eb_complaint
init|=
block|{
literal|"Mismatched .eb symbol ignored starting at symnum %d"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|enter_line_range
name|PARAMS
argument_list|(
operator|(
expr|struct
name|subfile
operator|*
operator|,
name|unsigned
operator|,
name|unsigned
operator|,
name|CORE_ADDR
operator|,
name|CORE_ADDR
operator|,
name|unsigned
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_stringtab
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|file_ptr
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|xcoff_symfile_init
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|xcoff_new_init
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|xcoff_symfile_finish
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|section_offsets
modifier|*
name|xcoff_symfile_offsets
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|,
name|CORE_ADDR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|find_linenos
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|sec_ptr
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|coff_getfilename
name|PARAMS
argument_list|(
operator|(
expr|union
name|internal_auxent
operator|*
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|read_symbol
name|PARAMS
argument_list|(
operator|(
expr|struct
name|internal_syment
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|read_symbol_lineno
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|read_symbol_nvalue
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|symbol
modifier|*
name|process_xcoff_symbol
name|PARAMS
argument_list|(
operator|(
expr|struct
name|coff_symbol
operator|*
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|read_xcoff_symtab
name|PARAMS
argument_list|(
operator|(
expr|struct
name|partial_symtab
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_stab_to_list
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
expr|struct
name|pending_stabs
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Translate from a COFF section number (target_index) to a SECT_OFF_*    code.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|secnum_to_section
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|find_targ_sec_arg
block|{
name|int
name|targ_index
decl_stmt|;
name|int
modifier|*
name|resultp
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|void
name|find_targ_sec
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|find_targ_sec
parameter_list|(
name|abfd
parameter_list|,
name|sect
parameter_list|,
name|obj
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sect
decl_stmt|;
name|PTR
name|obj
decl_stmt|;
block|{
name|struct
name|find_targ_sec_arg
modifier|*
name|args
init|=
operator|(
expr|struct
name|find_targ_sec_arg
operator|*
operator|)
name|obj
decl_stmt|;
if|if
condition|(
name|sect
operator|->
name|target_index
operator|==
name|args
operator|->
name|targ_index
condition|)
block|{
comment|/* This is the section.  Figure out what SECT_OFF_* code it is.  */
if|if
condition|(
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|sect
argument_list|)
operator|&
name|SEC_CODE
condition|)
operator|*
name|args
operator|->
name|resultp
operator|=
name|SECT_OFF_TEXT
expr_stmt|;
elseif|else
if|if
condition|(
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|sect
argument_list|)
operator|&
name|SEC_LOAD
condition|)
operator|*
name|args
operator|->
name|resultp
operator|=
name|SECT_OFF_DATA
expr_stmt|;
else|else
operator|*
name|args
operator|->
name|resultp
operator|=
name|SECT_OFF_BSS
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return the section number (SECT_OFF_*) that CS points to.  */
end_comment

begin_function
specifier|static
name|int
name|secnum_to_section
parameter_list|(
name|secnum
parameter_list|,
name|objfile
parameter_list|)
name|int
name|secnum
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|int
name|off
init|=
name|SECT_OFF_TEXT
decl_stmt|;
name|struct
name|find_targ_sec_arg
name|args
decl_stmt|;
name|args
operator|.
name|targ_index
operator|=
name|secnum
expr_stmt|;
name|args
operator|.
name|resultp
operator|=
operator|&
name|off
expr_stmt|;
name|bfd_map_over_sections
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|find_targ_sec
argument_list|,
operator|&
name|args
argument_list|)
expr_stmt|;
return|return
name|off
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* add a given stab string into given stab vector. */
end_comment

begin_function
specifier|static
name|void
name|add_stab_to_list
parameter_list|(
name|stabname
parameter_list|,
name|stabvector
parameter_list|)
name|char
modifier|*
name|stabname
decl_stmt|;
name|struct
name|pending_stabs
modifier|*
modifier|*
name|stabvector
decl_stmt|;
block|{
if|if
condition|(
operator|*
name|stabvector
operator|==
name|NULL
condition|)
block|{
operator|*
name|stabvector
operator|=
operator|(
expr|struct
name|pending_stabs
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pending_stabs
argument_list|)
operator|+
name|INITIAL_STABVECTOR_LENGTH
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|stabvector
operator|)
operator|->
name|count
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|stabvector
operator|)
operator|->
name|length
operator|=
name|INITIAL_STABVECTOR_LENGTH
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|stabvector
operator|)
operator|->
name|count
operator|>=
operator|(
operator|*
name|stabvector
operator|)
operator|->
name|length
condition|)
block|{
operator|(
operator|*
name|stabvector
operator|)
operator|->
name|length
operator|+=
name|INITIAL_STABVECTOR_LENGTH
expr_stmt|;
operator|*
name|stabvector
operator|=
operator|(
expr|struct
name|pending_stabs
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|*
name|stabvector
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pending_stabs
argument_list|)
operator|+
operator|(
operator|*
name|stabvector
operator|)
operator|->
name|length
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|(
operator|*
name|stabvector
operator|)
operator|->
name|stab
index|[
operator|(
operator|*
name|stabvector
operator|)
operator|->
name|count
operator|++
index|]
operator|=
name|stabname
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Linenos are processed on a file-by-file basis.     Two reasons:      1) xlc (IBM's native c compiler) postpones static function code        emission to the end of a compilation unit. This way it can        determine if those functions (statics) are needed or not, and        can do some garbage collection (I think). This makes line        numbers and corresponding addresses unordered, and we end up        with a line table like:          		lineno	addr         foo()	  10	0x100 		  20	0x200 		  30	0x300  	foo3()	  70	0x400 		  80	0x500 		  90	0x600  	static foo2() 		  40	0x700 		  50	0x800 		  60	0x900		  	and that breaks gdb's binary search on line numbers, if the 	above table is not sorted on line numbers. And that sort 	should be on function based, since gcc can emit line numbers 	like: 	 		10	0x100	- for the init/test part of a for stmt. 		20	0x200 		30	0x300 		10	0x400	- for the increment part of a for stmt.  	arrange_linetable() will do this sorting.		       2)	aix symbol table might look like:  		c_file		// beginning of a new file 		.bi		// beginning of include file 		.ei		// end of include file 		.bi 		.ei  	basically, .bi/.ei pairs do not necessarily encapsulate 	their scope. They need to be recorded, and processed later 	on when we come the end of the compilation unit. 	Include table (inclTable) and process_linenos() handle 	that.  */
end_comment

begin_comment
comment|/* compare line table entry addresses. */
end_comment

begin_function
specifier|static
name|int
name|compare_lte
parameter_list|(
name|lte1
parameter_list|,
name|lte2
parameter_list|)
name|struct
name|linetable_entry
modifier|*
name|lte1
decl_stmt|,
decl|*
name|lte2
decl_stmt|;
end_function

begin_block
block|{
return|return
name|lte1
operator|->
name|pc
operator|-
name|lte2
operator|->
name|pc
return|;
block|}
end_block

begin_comment
comment|/* Give a line table with function entries are marked, arrange its functions    in assending order and strip off function entry markers and return it in    a newly created table. If the old one is good enough, return the old one. */
end_comment

begin_comment
comment|/* FIXME: I think all this stuff can be replaced by just passing    sort_linevec = 1 to end_symtab.  */
end_comment

begin_function
specifier|static
name|struct
name|linetable
modifier|*
name|arrange_linetable
parameter_list|(
name|oldLineTb
parameter_list|)
name|struct
name|linetable
modifier|*
name|oldLineTb
decl_stmt|;
comment|/* old linetable */
block|{
name|int
name|ii
decl_stmt|,
name|jj
decl_stmt|,
name|newline
decl_stmt|,
comment|/* new line count */
name|function_count
decl_stmt|;
comment|/* # of functions */
name|struct
name|linetable_entry
modifier|*
name|fentry
decl_stmt|;
comment|/* function entry vector */
name|int
name|fentry_size
decl_stmt|;
comment|/* # of function entries */
name|struct
name|linetable
modifier|*
name|newLineTb
decl_stmt|;
comment|/* new line table */
define|#
directive|define
name|NUM_OF_FUNCTIONS
value|20
name|fentry_size
operator|=
name|NUM_OF_FUNCTIONS
expr_stmt|;
name|fentry
operator|=
operator|(
expr|struct
name|linetable_entry
operator|*
operator|)
name|xmalloc
argument_list|(
name|fentry_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|linetable_entry
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|function_count
operator|=
literal|0
operator|,
name|ii
operator|=
literal|0
init|;
name|ii
operator|<
name|oldLineTb
operator|->
name|nitems
condition|;
operator|++
name|ii
control|)
block|{
if|if
condition|(
name|oldLineTb
operator|->
name|item
index|[
name|ii
index|]
operator|.
name|line
operator|==
literal|0
condition|)
block|{
comment|/* function entry found. */
if|if
condition|(
name|function_count
operator|>=
name|fentry_size
condition|)
block|{
comment|/* make sure you have room. */
name|fentry_size
operator|*=
literal|2
expr_stmt|;
name|fentry
operator|=
operator|(
expr|struct
name|linetable_entry
operator|*
operator|)
name|xrealloc
argument_list|(
name|fentry
argument_list|,
name|fentry_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|linetable_entry
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fentry
index|[
name|function_count
index|]
operator|.
name|line
operator|=
name|ii
expr_stmt|;
name|fentry
index|[
name|function_count
index|]
operator|.
name|pc
operator|=
name|oldLineTb
operator|->
name|item
index|[
name|ii
index|]
operator|.
name|pc
expr_stmt|;
operator|++
name|function_count
expr_stmt|;
block|}
block|}
if|if
condition|(
name|function_count
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|fentry
argument_list|)
expr_stmt|;
return|return
name|oldLineTb
return|;
block|}
elseif|else
if|if
condition|(
name|function_count
operator|>
literal|1
condition|)
name|qsort
argument_list|(
name|fentry
argument_list|,
name|function_count
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|linetable_entry
argument_list|)
argument_list|,
name|compare_lte
argument_list|)
expr_stmt|;
comment|/* allocate a new line table. */
name|newLineTb
operator|=
operator|(
expr|struct
name|linetable
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|linetable
argument_list|)
operator|+
operator|(
name|oldLineTb
operator|->
name|nitems
operator|-
name|function_count
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|linetable_entry
argument_list|)
argument_list|)
expr_stmt|;
comment|/* if line table does not start with a function beginning, copy up until      a function begin. */
name|newline
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|oldLineTb
operator|->
name|item
index|[
literal|0
index|]
operator|.
name|line
operator|!=
literal|0
condition|)
for|for
control|(
name|newline
operator|=
literal|0
init|;
name|newline
operator|<
name|oldLineTb
operator|->
name|nitems
operator|&&
name|oldLineTb
operator|->
name|item
index|[
name|newline
index|]
operator|.
name|line
condition|;
operator|++
name|newline
control|)
name|newLineTb
operator|->
name|item
index|[
name|newline
index|]
operator|=
name|oldLineTb
operator|->
name|item
index|[
name|newline
index|]
expr_stmt|;
comment|/* Now copy function lines one by one. */
for|for
control|(
name|ii
operator|=
literal|0
init|;
name|ii
operator|<
name|function_count
condition|;
operator|++
name|ii
control|)
block|{
for|for
control|(
name|jj
operator|=
name|fentry
index|[
name|ii
index|]
operator|.
name|line
operator|+
literal|1
init|;
name|jj
operator|<
name|oldLineTb
operator|->
name|nitems
operator|&&
name|oldLineTb
operator|->
name|item
index|[
name|jj
index|]
operator|.
name|line
operator|!=
literal|0
condition|;
operator|++
name|jj
operator|,
operator|++
name|newline
control|)
name|newLineTb
operator|->
name|item
index|[
name|newline
index|]
operator|=
name|oldLineTb
operator|->
name|item
index|[
name|jj
index|]
expr_stmt|;
block|}
name|free
argument_list|(
name|fentry
argument_list|)
expr_stmt|;
name|newLineTb
operator|->
name|nitems
operator|=
name|oldLineTb
operator|->
name|nitems
operator|-
name|function_count
expr_stmt|;
return|return
name|newLineTb
return|;
block|}
end_function

begin_comment
comment|/* include file support: C_BINCL/C_EINCL pairs will be kept in the     following `IncludeChain'. At the end of each symtab (end_symtab),    we will determine if we should create additional symtab's to    represent if (the include files. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|_inclTable
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* include filename */
comment|/* Offsets to the line table.  end points to the last entry which is      part of this include file.  */
name|int
name|begin
decl_stmt|,
name|end
decl_stmt|;
name|struct
name|subfile
modifier|*
name|subfile
decl_stmt|;
name|unsigned
name|funStartLine
decl_stmt|;
comment|/* start line # of its function */
block|}
name|InclTable
typedef|;
end_typedef

begin_define
define|#
directive|define
name|INITIAL_INCLUDE_TABLE_LENGTH
value|20
end_define

begin_decl_stmt
specifier|static
name|InclTable
modifier|*
name|inclTable
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* global include table */
end_comment

begin_decl_stmt
specifier|static
name|int
name|inclIndx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last entry to table */
end_comment

begin_decl_stmt
specifier|static
name|int
name|inclLength
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* table length */
end_comment

begin_decl_stmt
specifier|static
name|int
name|inclDepth
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* nested include depth */
end_comment

begin_decl_stmt
specifier|static
name|void
name|allocate_include_entry
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|record_include_begin
parameter_list|(
name|cs
parameter_list|)
name|struct
name|coff_symbol
modifier|*
name|cs
decl_stmt|;
block|{
if|if
condition|(
name|inclDepth
condition|)
block|{
comment|/* In xcoff, we assume include files cannot be nested (not in .c files 	 of course, but in corresponding .s files.).  */
comment|/* This can happen with old versions of GCC. 	 GCC 2.3.3-930426 does not exhibit this on a test case which 	 a user said produced the message for him.  */
specifier|static
name|struct
name|complaint
name|msg
init|=
block|{
literal|"Nested C_BINCL symbols"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|complain
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
block|}
operator|++
name|inclDepth
expr_stmt|;
name|allocate_include_entry
argument_list|()
expr_stmt|;
name|inclTable
index|[
name|inclIndx
index|]
operator|.
name|name
operator|=
name|cs
operator|->
name|c_name
expr_stmt|;
name|inclTable
index|[
name|inclIndx
index|]
operator|.
name|begin
operator|=
name|cs
operator|->
name|c_value
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|record_include_end
parameter_list|(
name|cs
parameter_list|)
name|struct
name|coff_symbol
modifier|*
name|cs
decl_stmt|;
block|{
name|InclTable
modifier|*
name|pTbl
decl_stmt|;
if|if
condition|(
name|inclDepth
operator|==
literal|0
condition|)
block|{
specifier|static
name|struct
name|complaint
name|msg
init|=
block|{
literal|"Mismatched C_BINCL/C_EINCL pair"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|complain
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
block|}
name|allocate_include_entry
argument_list|()
expr_stmt|;
name|pTbl
operator|=
operator|&
name|inclTable
index|[
name|inclIndx
index|]
expr_stmt|;
name|pTbl
operator|->
name|end
operator|=
name|cs
operator|->
name|c_value
expr_stmt|;
operator|--
name|inclDepth
expr_stmt|;
operator|++
name|inclIndx
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|allocate_include_entry
parameter_list|()
block|{
if|if
condition|(
name|inclTable
operator|==
name|NULL
condition|)
block|{
name|inclTable
operator|=
operator|(
name|InclTable
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|InclTable
argument_list|)
operator|*
name|INITIAL_INCLUDE_TABLE_LENGTH
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|inclTable
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|InclTable
argument_list|)
operator|*
name|INITIAL_INCLUDE_TABLE_LENGTH
argument_list|)
expr_stmt|;
name|inclLength
operator|=
name|INITIAL_INCLUDE_TABLE_LENGTH
expr_stmt|;
name|inclIndx
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|inclIndx
operator|>=
name|inclLength
condition|)
block|{
name|inclLength
operator|+=
name|INITIAL_INCLUDE_TABLE_LENGTH
expr_stmt|;
name|inclTable
operator|=
operator|(
name|InclTable
operator|*
operator|)
name|xrealloc
argument_list|(
name|inclTable
argument_list|,
sizeof|sizeof
argument_list|(
name|InclTable
argument_list|)
operator|*
name|inclLength
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|inclTable
operator|+
name|inclLength
operator|-
name|INITIAL_INCLUDE_TABLE_LENGTH
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|InclTable
argument_list|)
operator|*
name|INITIAL_INCLUDE_TABLE_LENGTH
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Global variable to pass the psymtab down to all the routines involved    in psymtab to symtab processing.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|partial_symtab
modifier|*
name|this_symtab_psymtab
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* given the start and end addresses of a compilation unit (or a csect,    at times) process its lines and create appropriate line vectors. */
end_comment

begin_function
specifier|static
name|void
name|process_linenos
parameter_list|(
name|start
parameter_list|,
name|end
parameter_list|)
name|CORE_ADDR
name|start
decl_stmt|,
name|end
decl_stmt|;
block|{
name|int
name|offset
decl_stmt|,
name|ii
decl_stmt|;
name|file_ptr
name|max_offset
init|=
operator|(
operator|(
expr|struct
name|coff_symfile_info
operator|*
operator|)
name|this_symtab_psymtab
operator|->
name|objfile
operator|->
name|sym_private
operator|)
operator|->
name|max_lineno_offset
decl_stmt|;
comment|/* subfile structure for the main compilation unit.  */
name|struct
name|subfile
name|main_subfile
decl_stmt|;
comment|/* In the main source file, any time we see a function entry, we      reset this variable to function's absolute starting line number.      All the following line numbers in the function are relative to      this, and we record absolute line numbers in record_line().  */
name|unsigned
name|int
name|main_source_baseline
init|=
literal|0
decl_stmt|;
name|unsigned
modifier|*
name|firstLine
decl_stmt|;
name|offset
operator|=
operator|(
operator|(
expr|struct
name|symloc
operator|*
operator|)
name|this_symtab_psymtab
operator|->
name|read_symtab_private
operator|)
operator|->
name|lineno_off
expr_stmt|;
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
goto|goto
name|return_after_cleanup
goto|;
name|memset
argument_list|(
operator|&
name|main_subfile
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|main_subfile
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|inclIndx
operator|==
literal|0
condition|)
comment|/* All source lines were in the main source file. None in include files. */
name|enter_line_range
argument_list|(
operator|&
name|main_subfile
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
operator|&
name|main_source_baseline
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* There was source with line numbers in include files.  */
name|main_source_baseline
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ii
operator|=
literal|0
init|;
name|ii
operator|<
name|inclIndx
condition|;
operator|++
name|ii
control|)
block|{
name|struct
name|subfile
modifier|*
name|tmpSubfile
decl_stmt|;
comment|/* If there is main file source before include file, enter it.  */
if|if
condition|(
name|offset
operator|<
name|inclTable
index|[
name|ii
index|]
operator|.
name|begin
condition|)
block|{
name|enter_line_range
argument_list|(
operator|&
name|main_subfile
argument_list|,
name|offset
argument_list|,
name|inclTable
index|[
name|ii
index|]
operator|.
name|begin
operator|-
name|LINESZ
argument_list|,
name|start
argument_list|,
literal|0
argument_list|,
operator|&
name|main_source_baseline
argument_list|)
expr_stmt|;
block|}
comment|/* Have a new subfile for the include file.  */
name|tmpSubfile
operator|=
name|inclTable
index|[
name|ii
index|]
operator|.
name|subfile
operator|=
operator|(
expr|struct
name|subfile
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|subfile
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|tmpSubfile
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|subfile
argument_list|)
argument_list|)
expr_stmt|;
name|firstLine
operator|=
operator|&
operator|(
name|inclTable
index|[
name|ii
index|]
operator|.
name|funStartLine
operator|)
expr_stmt|;
comment|/* Enter include file's lines now.  */
name|enter_line_range
argument_list|(
name|tmpSubfile
argument_list|,
name|inclTable
index|[
name|ii
index|]
operator|.
name|begin
argument_list|,
name|inclTable
index|[
name|ii
index|]
operator|.
name|end
argument_list|,
name|start
argument_list|,
literal|0
argument_list|,
name|firstLine
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|<=
name|inclTable
index|[
name|ii
index|]
operator|.
name|end
condition|)
name|offset
operator|=
name|inclTable
index|[
name|ii
index|]
operator|.
name|end
operator|+
name|LINESZ
expr_stmt|;
block|}
comment|/* All the include files' line have been processed at this point.  Now, 	 enter remaining lines of the main file, if any left.  */
if|if
condition|(
name|offset
operator|<
name|max_offset
operator|+
literal|1
operator|-
name|LINESZ
condition|)
block|{
name|enter_line_range
argument_list|(
operator|&
name|main_subfile
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
operator|&
name|main_source_baseline
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Process main file's line numbers.  */
if|if
condition|(
name|main_subfile
operator|.
name|line_vector
condition|)
block|{
name|struct
name|linetable
modifier|*
name|lineTb
decl_stmt|,
modifier|*
name|lv
decl_stmt|;
name|lv
operator|=
name|main_subfile
operator|.
name|line_vector
expr_stmt|;
comment|/* Line numbers are not necessarily ordered. xlc compilation will 	 put static function to the end. */
name|lineTb
operator|=
name|arrange_linetable
argument_list|(
name|lv
argument_list|)
expr_stmt|;
if|if
condition|(
name|lv
operator|==
name|lineTb
condition|)
block|{
name|current_subfile
operator|->
name|line_vector
operator|=
operator|(
expr|struct
name|linetable
operator|*
operator|)
name|xrealloc
argument_list|(
name|lv
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|linetable
argument_list|)
operator|+
name|lv
operator|->
name|nitems
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|linetable_entry
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|free
argument_list|(
name|lv
argument_list|)
expr_stmt|;
name|current_subfile
operator|->
name|line_vector
operator|=
name|lineTb
expr_stmt|;
block|}
name|current_subfile
operator|->
name|line_vector_length
operator|=
name|current_subfile
operator|->
name|line_vector
operator|->
name|nitems
expr_stmt|;
block|}
comment|/* Now, process included files' line numbers.  */
for|for
control|(
name|ii
operator|=
literal|0
init|;
name|ii
operator|<
name|inclIndx
condition|;
operator|++
name|ii
control|)
block|{
if|if
condition|(
operator|(
name|inclTable
index|[
name|ii
index|]
operator|.
name|subfile
operator|)
operator|->
name|line_vector
condition|)
comment|/* Useless if!!! FIXMEmgo */
block|{
name|struct
name|linetable
modifier|*
name|lineTb
decl_stmt|,
modifier|*
name|lv
decl_stmt|;
name|lv
operator|=
operator|(
name|inclTable
index|[
name|ii
index|]
operator|.
name|subfile
operator|)
operator|->
name|line_vector
expr_stmt|;
comment|/* Line numbers are not necessarily ordered. xlc compilation will 	     put static function to the end. */
name|lineTb
operator|=
name|arrange_linetable
argument_list|(
name|lv
argument_list|)
expr_stmt|;
name|push_subfile
argument_list|()
expr_stmt|;
comment|/* For the same include file, we might want to have more than one 	     subfile.  This happens if we have something like:    		...... 	        #include "foo.h" 		...... 	 	#include "foo.h" 		......  	     while foo.h including code in it. (stupid but possible) 	     Since start_subfile() looks at the name and uses an 	     existing one if finds, we need to provide a fake name and 	     fool it.  */
if|#
directive|if
literal|0
block|start_subfile (inclTable[ii].name, (char*)0);
else|#
directive|else
block|{
comment|/* Pick a fake name that will produce the same results as this 	       one when passed to deduce_language_from_filename.  Kludge on 	       top of kludge.  */
name|char
modifier|*
name|fakename
init|=
name|strrchr
argument_list|(
name|inclTable
index|[
name|ii
index|]
operator|.
name|name
argument_list|,
literal|'.'
argument_list|)
decl_stmt|;
if|if
condition|(
name|fakename
operator|==
name|NULL
condition|)
name|fakename
operator|=
literal|" ?"
expr_stmt|;
name|start_subfile
argument_list|(
name|fakename
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|current_subfile
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|current_subfile
operator|->
name|name
operator|=
name|strdup
argument_list|(
name|inclTable
index|[
name|ii
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|lv
operator|==
name|lineTb
condition|)
block|{
name|current_subfile
operator|->
name|line_vector
operator|=
operator|(
expr|struct
name|linetable
operator|*
operator|)
name|xrealloc
argument_list|(
name|lv
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|linetable
argument_list|)
operator|+
name|lv
operator|->
name|nitems
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|linetable_entry
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|free
argument_list|(
name|lv
argument_list|)
expr_stmt|;
name|current_subfile
operator|->
name|line_vector
operator|=
name|lineTb
expr_stmt|;
block|}
name|current_subfile
operator|->
name|line_vector_length
operator|=
name|current_subfile
operator|->
name|line_vector
operator|->
name|nitems
expr_stmt|;
name|start_subfile
argument_list|(
name|pop_subfile
argument_list|()
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|return_after_cleanup
label|:
comment|/* We don't want to keep alloc/free'ing the global include file table.  */
name|inclIndx
operator|=
literal|0
expr_stmt|;
comment|/* Start with a fresh subfile structure for the next file.  */
name|memset
argument_list|(
operator|&
name|main_subfile
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|subfile
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|aix_process_linenos
parameter_list|()
block|{
comment|/* process line numbers and enter them into line vector */
name|process_linenos
argument_list|(
name|last_source_start_addr
argument_list|,
name|cur_src_end_addr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Enter a given range of lines into the line vector.    can be called in the following two ways:      enter_line_range (subfile, beginoffset, endoffset, startaddr, 0, firstLine)  or      enter_line_range (subfile, beginoffset, 0, startaddr, endaddr, firstLine)     endoffset points to the last line table entry that we should pay    attention to.  */
end_comment

begin_function
specifier|static
name|void
name|enter_line_range
parameter_list|(
name|subfile
parameter_list|,
name|beginoffset
parameter_list|,
name|endoffset
parameter_list|,
name|startaddr
parameter_list|,
name|endaddr
parameter_list|,
name|firstLine
parameter_list|)
name|struct
name|subfile
modifier|*
name|subfile
decl_stmt|;
name|unsigned
name|beginoffset
decl_stmt|,
name|endoffset
decl_stmt|;
comment|/* offsets to line table */
name|CORE_ADDR
name|startaddr
decl_stmt|,
name|endaddr
decl_stmt|;
name|unsigned
modifier|*
name|firstLine
decl_stmt|;
block|{
name|unsigned
name|int
name|curoffset
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|struct
name|external_lineno
name|ext_lnno
decl_stmt|;
name|struct
name|internal_lineno
name|int_lnno
decl_stmt|;
name|unsigned
name|int
name|limit_offset
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
if|if
condition|(
name|endoffset
operator|==
literal|0
operator|&&
name|startaddr
operator|==
literal|0
operator|&&
name|endaddr
operator|==
literal|0
condition|)
return|return;
name|curoffset
operator|=
name|beginoffset
expr_stmt|;
name|limit_offset
operator|=
operator|(
operator|(
expr|struct
name|coff_symfile_info
operator|*
operator|)
name|this_symtab_psymtab
operator|->
name|objfile
operator|->
name|sym_private
operator|)
operator|->
name|max_lineno_offset
expr_stmt|;
if|if
condition|(
name|endoffset
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|endoffset
operator|>=
name|limit_offset
condition|)
block|{
specifier|static
name|struct
name|complaint
name|msg
init|=
block|{
literal|"Bad line table offset in C_EINCL directive"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|complain
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
return|return;
block|}
name|limit_offset
operator|=
name|endoffset
expr_stmt|;
block|}
else|else
name|limit_offset
operator|-=
literal|1
expr_stmt|;
name|abfd
operator|=
name|this_symtab_psymtab
operator|->
name|objfile
operator|->
name|obfd
expr_stmt|;
while|while
condition|(
name|curoffset
operator|<=
name|limit_offset
condition|)
block|{
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|curoffset
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|bfd_read
argument_list|(
operator|&
name|ext_lnno
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|external_lineno
argument_list|)
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|bfd_coff_swap_lineno_in
argument_list|(
name|abfd
argument_list|,
operator|&
name|ext_lnno
argument_list|,
operator|&
name|int_lnno
argument_list|)
expr_stmt|;
comment|/* Find the address this line represents.  */
name|addr
operator|=
operator|(
name|int_lnno
operator|.
name|l_lnno
condition|?
name|int_lnno
operator|.
name|l_addr
operator|.
name|l_paddr
else|:
name|read_symbol_nvalue
argument_list|(
name|int_lnno
operator|.
name|l_addr
operator|.
name|l_symndx
argument_list|)
operator|)
expr_stmt|;
name|addr
operator|+=
name|ANOFFSET
argument_list|(
name|this_symtab_psymtab
operator|->
name|objfile
operator|->
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|<
name|startaddr
operator|||
operator|(
name|endaddr
operator|&&
name|addr
operator|>=
name|endaddr
operator|)
condition|)
return|return;
if|if
condition|(
name|int_lnno
operator|.
name|l_lnno
operator|==
literal|0
condition|)
block|{
operator|*
name|firstLine
operator|=
name|read_symbol_lineno
argument_list|(
name|int_lnno
operator|.
name|l_addr
operator|.
name|l_symndx
argument_list|)
expr_stmt|;
name|record_line
argument_list|(
name|subfile
argument_list|,
literal|0
argument_list|,
name|addr
argument_list|)
expr_stmt|;
operator|--
operator|(
operator|*
name|firstLine
operator|)
expr_stmt|;
block|}
else|else
name|record_line
argument_list|(
name|subfile
argument_list|,
operator|*
name|firstLine
operator|+
name|int_lnno
operator|.
name|l_lnno
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|curoffset
operator|+=
name|LINESZ
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Save the vital information for use when closing off the current file.    NAME is the file name the symbols came from, START_ADDR is the first    text address for the file, and SIZE is the number of bytes of text.  */
end_comment

begin_define
define|#
directive|define
name|complete_symtab
parameter_list|(
name|name
parameter_list|,
name|start_addr
parameter_list|)
value|{	\   last_source_file = savestring (name, strlen (name));	\   last_source_start_addr = start_addr;			\ }
end_define

begin_comment
comment|/* Refill the symbol table input buffer    and set the variables that control fetching entries from it.    Reports an error if no data available.    This function can read past the end of the symbol table    (into the string table) but this does no harm.  */
end_comment

begin_comment
comment|/* Reading symbol table has to be fast! Keep the followings as macros, rather    than functions. */
end_comment

begin_define
define|#
directive|define
name|RECORD_MINIMAL_SYMBOL
parameter_list|(
name|NAME
parameter_list|,
name|ADDR
parameter_list|,
name|TYPE
parameter_list|,
name|SECTION
parameter_list|,
name|OBJFILE
parameter_list|)
define|\
value|{						\   char *namestr;				\   namestr = (NAME); \   if (namestr[0] == '.') ++namestr; \   prim_record_minimal_symbol_and_info (namestr, (ADDR), (TYPE), \ 				       (char *)NULL, (SECTION), (OBJFILE)); \   misc_func_recorded = 1;					\ }
end_define

begin_comment
comment|/* xcoff has static blocks marked in `.bs', `.es' pairs. They cannot be    nested. At any given time, a symbol can only be in one static block.    This is the base address of current static block, zero if non exists. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|static_block_base
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Section number for the current static block.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|static_block_section
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true if space for symbol name has been allocated. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|symname_alloced
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Next symbol to read.  Pointer into raw seething symbol table.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|raw_symbol
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is the function which stabsread.c calls to get symbol    continuations.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|xcoff_next_symbol_text
parameter_list|(
name|objfile
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|struct
name|internal_syment
name|symbol
decl_stmt|;
specifier|static
name|struct
name|complaint
name|msg
init|=
block|{
literal|"Unexpected symbol continuation"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|char
modifier|*
name|retval
decl_stmt|;
comment|/* FIXME: is this the same as the passed arg? */
name|objfile
operator|=
name|this_symtab_psymtab
operator|->
name|objfile
expr_stmt|;
name|bfd_coff_swap_sym_in
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|raw_symbol
argument_list|,
operator|&
name|symbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbol
operator|.
name|n_zeroes
condition|)
block|{
name|complain
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
comment|/* Return something which points to '\0' and hope the symbol reading 	 code does something reasonable.  */
name|retval
operator|=
literal|""
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|symbol
operator|.
name|n_sclass
operator|&
literal|0x80
condition|)
block|{
name|retval
operator|=
operator|(
operator|(
expr|struct
name|coff_symfile_info
operator|*
operator|)
name|objfile
operator|->
name|sym_private
operator|)
operator|->
name|debugsec
operator|+
name|symbol
operator|.
name|n_offset
expr_stmt|;
name|raw_symbol
operator|+=
name|coff_data
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|)
operator|->
name|local_symesz
expr_stmt|;
operator|++
name|symnum
expr_stmt|;
block|}
else|else
block|{
name|complain
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
comment|/* Return something which points to '\0' and hope the symbol reading 	 code does something reasonable.  */
name|retval
operator|=
literal|""
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Read symbols for a given partial symbol table.  */
end_comment

begin_function
specifier|static
name|void
name|read_xcoff_symtab
parameter_list|(
name|pst
parameter_list|)
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
block|{
name|struct
name|objfile
modifier|*
name|objfile
init|=
name|pst
operator|->
name|objfile
decl_stmt|;
name|bfd
modifier|*
name|abfd
init|=
name|objfile
operator|->
name|obfd
decl_stmt|;
name|char
modifier|*
name|raw_auxptr
decl_stmt|;
comment|/* Pointer to first raw aux entry for sym */
name|char
modifier|*
name|strtbl
init|=
operator|(
operator|(
expr|struct
name|coff_symfile_info
operator|*
operator|)
name|objfile
operator|->
name|sym_private
operator|)
operator|->
name|strtbl
decl_stmt|;
name|char
modifier|*
name|debugsec
init|=
operator|(
operator|(
expr|struct
name|coff_symfile_info
operator|*
operator|)
name|objfile
operator|->
name|sym_private
operator|)
operator|->
name|debugsec
decl_stmt|;
name|struct
name|internal_syment
name|symbol
index|[
literal|1
index|]
decl_stmt|;
name|union
name|internal_auxent
name|main_aux
decl_stmt|;
name|struct
name|coff_symbol
name|cs
index|[
literal|1
index|]
decl_stmt|;
name|CORE_ADDR
name|file_start_addr
init|=
literal|0
decl_stmt|;
name|CORE_ADDR
name|file_end_addr
init|=
literal|0
decl_stmt|;
name|int
name|next_file_symnum
init|=
operator|-
literal|1
decl_stmt|;
name|unsigned
name|int
name|max_symnum
decl_stmt|;
name|int
name|just_started
init|=
literal|1
decl_stmt|;
name|int
name|depth
init|=
literal|0
decl_stmt|;
name|int
name|fcn_start_addr
init|=
literal|0
decl_stmt|;
name|struct
name|coff_symbol
name|fcn_stab_saved
decl_stmt|;
comment|/* fcn_cs_saved is global because process_xcoff_symbol needs it. */
name|union
name|internal_auxent
name|fcn_aux_saved
decl_stmt|;
name|struct
name|context_stack
modifier|*
name|new
decl_stmt|;
name|char
modifier|*
name|filestring
init|=
literal|" _start_ "
decl_stmt|;
comment|/* Name of the current file. */
name|char
modifier|*
name|last_csect_name
decl_stmt|;
comment|/* last seen csect's name and value */
name|CORE_ADDR
name|last_csect_val
decl_stmt|;
name|int
name|last_csect_sec
decl_stmt|;
name|this_symtab_psymtab
operator|=
name|pst
expr_stmt|;
comment|/* Get the appropriate COFF "constants" related to the file we're      handling. */
name|local_symesz
operator|=
name|coff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|local_symesz
expr_stmt|;
name|last_source_file
operator|=
name|NULL
expr_stmt|;
name|last_csect_name
operator|=
literal|0
expr_stmt|;
name|last_csect_val
operator|=
literal|0
expr_stmt|;
name|start_stabs
argument_list|()
expr_stmt|;
name|start_symtab
argument_list|(
name|filestring
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|file_start_addr
argument_list|)
expr_stmt|;
name|symnum
operator|=
operator|(
operator|(
expr|struct
name|symloc
operator|*
operator|)
name|pst
operator|->
name|read_symtab_private
operator|)
operator|->
name|first_symnum
expr_stmt|;
name|max_symnum
operator|=
name|symnum
operator|+
operator|(
operator|(
expr|struct
name|symloc
operator|*
operator|)
name|pst
operator|->
name|read_symtab_private
operator|)
operator|->
name|numsyms
expr_stmt|;
name|first_object_file_end
operator|=
literal|0
expr_stmt|;
name|raw_symbol
operator|=
operator|(
operator|(
expr|struct
name|coff_symfile_info
operator|*
operator|)
name|objfile
operator|->
name|sym_private
operator|)
operator|->
name|symtbl
operator|+
name|symnum
operator|*
name|local_symesz
expr_stmt|;
while|while
condition|(
name|symnum
operator|<
name|max_symnum
condition|)
block|{
name|QUIT
expr_stmt|;
comment|/* make this command interruptable.  */
comment|/* READ_ONE_SYMBOL (symbol, cs, symname_alloced); */
comment|/* read one symbol into `cs' structure. After processing the 	 whole symbol table, only string table will be kept in memory, 	 symbol table and debug section of xcoff will be freed. Thus 	 we can mark symbols with names in string table as 	 `alloced'. */
block|{
name|int
name|ii
decl_stmt|;
comment|/* Swap and align the symbol into a reasonable C structure.  */
name|bfd_coff_swap_sym_in
argument_list|(
name|abfd
argument_list|,
name|raw_symbol
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
name|cs
operator|->
name|c_symnum
operator|=
name|symnum
expr_stmt|;
name|cs
operator|->
name|c_naux
operator|=
name|symbol
operator|->
name|n_numaux
expr_stmt|;
if|if
condition|(
name|symbol
operator|->
name|n_zeroes
condition|)
block|{
name|symname_alloced
operator|=
literal|0
expr_stmt|;
comment|/* We must use the original, unswapped, name here so the name field 	       pointed to by cs->c_name will persist throughout xcoffread.  If 	       we use the new field, it gets overwritten for each symbol.  */
name|cs
operator|->
name|c_name
operator|=
operator|(
operator|(
expr|struct
name|external_syment
operator|*
operator|)
name|raw_symbol
operator|)
operator|->
name|e
operator|.
name|e_name
expr_stmt|;
comment|/* If it's exactly E_SYMNMLEN characters long it isn't 	       '\0'-terminated.  */
if|if
condition|(
name|cs
operator|->
name|c_name
index|[
name|E_SYMNMLEN
operator|-
literal|1
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|,
name|E_SYMNMLEN
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|p
argument_list|,
name|cs
operator|->
name|c_name
argument_list|,
name|E_SYMNMLEN
argument_list|)
expr_stmt|;
name|p
index|[
name|E_SYMNMLEN
index|]
operator|=
literal|'\0'
expr_stmt|;
name|cs
operator|->
name|c_name
operator|=
name|p
expr_stmt|;
name|symname_alloced
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|symbol
operator|->
name|n_sclass
operator|&
literal|0x80
condition|)
block|{
name|cs
operator|->
name|c_name
operator|=
name|debugsec
operator|+
name|symbol
operator|->
name|n_offset
expr_stmt|;
name|symname_alloced
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* in string table */
name|cs
operator|->
name|c_name
operator|=
name|strtbl
operator|+
operator|(
name|int
operator|)
name|symbol
operator|->
name|n_offset
expr_stmt|;
name|symname_alloced
operator|=
literal|1
expr_stmt|;
block|}
name|cs
operator|->
name|c_value
operator|=
name|symbol
operator|->
name|n_value
expr_stmt|;
name|cs
operator|->
name|c_sclass
operator|=
name|symbol
operator|->
name|n_sclass
expr_stmt|;
name|cs
operator|->
name|c_secnum
operator|=
name|symbol
operator|->
name|n_scnum
expr_stmt|;
name|cs
operator|->
name|c_type
operator|=
operator|(
name|unsigned
operator|)
name|symbol
operator|->
name|n_type
expr_stmt|;
name|raw_symbol
operator|+=
name|coff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|local_symesz
expr_stmt|;
operator|++
name|symnum
expr_stmt|;
comment|/* Save addr of first aux entry.  */
name|raw_auxptr
operator|=
name|raw_symbol
expr_stmt|;
comment|/* Skip all the auxents associated with this symbol.  */
for|for
control|(
name|ii
operator|=
name|symbol
operator|->
name|n_numaux
init|;
name|ii
condition|;
operator|--
name|ii
control|)
block|{
name|raw_symbol
operator|+=
name|coff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|local_auxesz
expr_stmt|;
operator|++
name|symnum
expr_stmt|;
block|}
block|}
comment|/* if symbol name starts with ".$" or "$", ignore it. */
if|if
condition|(
name|cs
operator|->
name|c_name
index|[
literal|0
index|]
operator|==
literal|'$'
operator|||
operator|(
name|cs
operator|->
name|c_name
index|[
literal|1
index|]
operator|==
literal|'$'
operator|&&
name|cs
operator|->
name|c_name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|)
condition|)
continue|continue;
if|if
condition|(
name|cs
operator|->
name|c_symnum
operator|==
name|next_file_symnum
operator|&&
name|cs
operator|->
name|c_sclass
operator|!=
name|C_FILE
condition|)
block|{
if|if
condition|(
name|last_source_file
condition|)
block|{
name|pst
operator|->
name|symtab
operator|=
name|end_symtab
argument_list|(
name|cur_src_end_addr
argument_list|,
name|objfile
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
expr_stmt|;
name|end_stabs
argument_list|()
expr_stmt|;
block|}
name|start_stabs
argument_list|()
expr_stmt|;
name|start_symtab
argument_list|(
literal|"_globals_"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|CORE_ADDR
operator|)
literal|0
argument_list|)
expr_stmt|;
name|cur_src_end_addr
operator|=
name|first_object_file_end
expr_stmt|;
comment|/* done with all files, everything from here on is globals */
block|}
comment|/* if explicitly specified as a function, treat is as one. */
if|if
condition|(
name|ISFCN
argument_list|(
name|cs
operator|->
name|c_type
argument_list|)
operator|&&
name|cs
operator|->
name|c_sclass
operator|!=
name|C_TPDEF
condition|)
block|{
name|bfd_coff_swap_aux_in
argument_list|(
name|abfd
argument_list|,
name|raw_auxptr
argument_list|,
name|cs
operator|->
name|c_type
argument_list|,
name|cs
operator|->
name|c_sclass
argument_list|,
literal|0
argument_list|,
name|cs
operator|->
name|c_naux
argument_list|,
operator|&
name|main_aux
argument_list|)
expr_stmt|;
goto|goto
name|function_entry_point
goto|;
block|}
if|if
condition|(
operator|(
name|cs
operator|->
name|c_sclass
operator|==
name|C_EXT
operator|||
name|cs
operator|->
name|c_sclass
operator|==
name|C_HIDEXT
operator|)
operator|&&
name|cs
operator|->
name|c_naux
operator|==
literal|1
condition|)
block|{
comment|/* Dealing with a symbol with a csect entry.  */
define|#
directive|define
name|CSECT
parameter_list|(
name|PP
parameter_list|)
value|((PP)->x_csect)
define|#
directive|define
name|CSECT_LEN
parameter_list|(
name|PP
parameter_list|)
value|(CSECT(PP).x_scnlen.l)
define|#
directive|define
name|CSECT_ALIGN
parameter_list|(
name|PP
parameter_list|)
value|(SMTYP_ALIGN(CSECT(PP).x_smtyp))
define|#
directive|define
name|CSECT_SMTYP
parameter_list|(
name|PP
parameter_list|)
value|(SMTYP_SMTYP(CSECT(PP).x_smtyp))
define|#
directive|define
name|CSECT_SCLAS
parameter_list|(
name|PP
parameter_list|)
value|(CSECT(PP).x_smclas)
comment|/* Convert the auxent to something we can access.  */
name|bfd_coff_swap_aux_in
argument_list|(
name|abfd
argument_list|,
name|raw_auxptr
argument_list|,
name|cs
operator|->
name|c_type
argument_list|,
name|cs
operator|->
name|c_sclass
argument_list|,
literal|0
argument_list|,
name|cs
operator|->
name|c_naux
argument_list|,
operator|&
name|main_aux
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|CSECT_SMTYP
argument_list|(
operator|&
name|main_aux
argument_list|)
condition|)
block|{
case|case
name|XTY_ER
case|:
comment|/* Ignore all external references.  */
continue|continue;
case|case
name|XTY_SD
case|:
comment|/* A section description.  */
block|{
switch|switch
condition|(
name|CSECT_SCLAS
argument_list|(
operator|&
name|main_aux
argument_list|)
condition|)
block|{
case|case
name|XMC_PR
case|:
block|{
comment|/* A program csect is seen.  We have to allocate one 			 symbol table for each program csect.  Normally gdb 			 prefers one symtab for each source file.  In case 			 of AIX, one source file might include more than one 			 [PR] csect, and they don't have to be adjacent in 			 terms of the space they occupy in memory. Thus, one 			 single source file might get fragmented in the 			 memory and gdb's file start and end address 			 approach does not work!  GCC (and I think xlc) seem 			 to put all the code in the unnamed program csect.  */
if|if
condition|(
name|last_csect_name
condition|)
block|{
name|complete_symtab
argument_list|(
name|filestring
argument_list|,
name|file_start_addr
argument_list|)
expr_stmt|;
name|cur_src_end_addr
operator|=
name|file_end_addr
expr_stmt|;
name|end_symtab
argument_list|(
name|file_end_addr
argument_list|,
name|objfile
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
expr_stmt|;
name|end_stabs
argument_list|()
expr_stmt|;
name|start_stabs
argument_list|()
expr_stmt|;
comment|/* Give all csects for this source file the same 			     name.  */
name|start_symtab
argument_list|(
name|filestring
argument_list|,
name|NULL
argument_list|,
operator|(
name|CORE_ADDR
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* If this is the very first csect seen, 			 basically `__start'. */
if|if
condition|(
name|just_started
condition|)
block|{
name|first_object_file_end
operator|=
name|cs
operator|->
name|c_value
operator|+
name|CSECT_LEN
argument_list|(
operator|&
name|main_aux
argument_list|)
expr_stmt|;
name|just_started
operator|=
literal|0
expr_stmt|;
block|}
name|file_start_addr
operator|=
name|cs
operator|->
name|c_value
operator|+
name|ANOFFSET
argument_list|(
name|objfile
operator|->
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
expr_stmt|;
name|file_end_addr
operator|=
name|file_start_addr
operator|+
name|CSECT_LEN
argument_list|(
operator|&
name|main_aux
argument_list|)
expr_stmt|;
if|if
condition|(
name|cs
operator|->
name|c_name
operator|&&
name|cs
operator|->
name|c_name
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
block|{
name|last_csect_name
operator|=
name|cs
operator|->
name|c_name
expr_stmt|;
name|last_csect_val
operator|=
name|cs
operator|->
name|c_value
expr_stmt|;
name|last_csect_sec
operator|=
name|secnum_to_section
argument_list|(
name|cs
operator|->
name|c_secnum
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
block|}
continue|continue;
comment|/* All other symbols are put into the minimal symbol 		       table only.  */
case|case
name|XMC_RW
case|:
continue|continue;
case|case
name|XMC_TC0
case|:
continue|continue;
case|case
name|XMC_TC
case|:
continue|continue;
default|default:
comment|/* Ignore the symbol.  */
continue|continue;
block|}
block|}
break|break;
case|case
name|XTY_LD
case|:
switch|switch
condition|(
name|CSECT_SCLAS
argument_list|(
operator|&
name|main_aux
argument_list|)
condition|)
block|{
case|case
name|XMC_PR
case|:
comment|/* a function entry point. */
name|function_entry_point
label|:
name|fcn_start_addr
operator|=
name|cs
operator|->
name|c_value
expr_stmt|;
comment|/* save the function header info, which will be used 		     when `.bf' is seen. */
name|fcn_cs_saved
operator|=
operator|*
name|cs
expr_stmt|;
name|fcn_aux_saved
operator|=
name|main_aux
expr_stmt|;
continue|continue;
case|case
name|XMC_GL
case|:
comment|/* shared library function trampoline code entry point. */
continue|continue;
case|case
name|XMC_DS
case|:
comment|/* The symbols often have the same names as debug symbols for 		     functions, and confuse lookup_symbol.  */
continue|continue;
default|default:
comment|/* xlc puts each variable in a separate csect, so we get 		     an XTY_SD for each variable.  But gcc puts several 		     variables in a csect, so that each variable only gets 		     an XTY_LD. This will typically be XMC_RW; I suspect 		     XMC_RO and XMC_BS might be possible too. 		     These variables are put in the minimal symbol table 		     only.  */
continue|continue;
block|}
break|break;
case|case
name|XTY_CM
case|:
comment|/* Common symbols are put into the minimal symbol table only.  */
continue|continue;
default|default:
break|break;
block|}
block|}
switch|switch
condition|(
name|cs
operator|->
name|c_sclass
condition|)
block|{
case|case
name|C_FILE
case|:
comment|/* c_value field contains symnum of next .file entry in table 	     or symnum of first global after last .file. */
name|next_file_symnum
operator|=
name|cs
operator|->
name|c_value
expr_stmt|;
comment|/* Complete symbol table for last object file containing 	     debugging information. */
comment|/* Whether or not there was a csect in the previous file, we 	     have to call `end_stabs' and `start_stabs' to reset 	     type_vector, line_vector, etc. structures.  */
name|complete_symtab
argument_list|(
name|filestring
argument_list|,
name|file_start_addr
argument_list|)
expr_stmt|;
name|cur_src_end_addr
operator|=
name|file_end_addr
expr_stmt|;
name|end_symtab
argument_list|(
name|file_end_addr
argument_list|,
name|objfile
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
expr_stmt|;
name|end_stabs
argument_list|()
expr_stmt|;
comment|/* XCOFF, according to the AIX 3.2 documentation, puts the filename 	     in cs->c_name.  But xlc 1.3.0.2 has decided to do things the 	     standard COFF way and put it in the auxent.  We use the auxent if 	     the symbol is ".file" and an auxent exists, otherwise use the symbol 	     itself.  Simple enough.  */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|cs
operator|->
name|c_name
argument_list|,
literal|".file"
argument_list|)
operator|&&
name|cs
operator|->
name|c_naux
operator|>
literal|0
condition|)
block|{
name|bfd_coff_swap_aux_in
argument_list|(
name|abfd
argument_list|,
name|raw_auxptr
argument_list|,
name|cs
operator|->
name|c_type
argument_list|,
name|cs
operator|->
name|c_sclass
argument_list|,
literal|0
argument_list|,
name|cs
operator|->
name|c_naux
argument_list|,
operator|&
name|main_aux
argument_list|)
expr_stmt|;
name|filestring
operator|=
name|coff_getfilename
argument_list|(
operator|&
name|main_aux
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
else|else
name|filestring
operator|=
name|cs
operator|->
name|c_name
expr_stmt|;
name|start_stabs
argument_list|()
expr_stmt|;
name|start_symtab
argument_list|(
name|filestring
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|CORE_ADDR
operator|)
literal|0
argument_list|)
expr_stmt|;
name|last_csect_name
operator|=
literal|0
expr_stmt|;
comment|/* reset file start and end addresses. A compilation unit with no text 	     (only data) should have zero file boundaries. */
name|file_start_addr
operator|=
name|file_end_addr
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|C_FUN
case|:
name|fcn_stab_saved
operator|=
operator|*
name|cs
expr_stmt|;
break|break;
case|case
name|C_FCN
case|:
if|if
condition|(
name|STREQ
argument_list|(
name|cs
operator|->
name|c_name
argument_list|,
literal|".bf"
argument_list|)
condition|)
block|{
name|CORE_ADDR
name|off
init|=
name|ANOFFSET
argument_list|(
name|objfile
operator|->
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
decl_stmt|;
name|bfd_coff_swap_aux_in
argument_list|(
name|abfd
argument_list|,
name|raw_auxptr
argument_list|,
name|cs
operator|->
name|c_type
argument_list|,
name|cs
operator|->
name|c_sclass
argument_list|,
literal|0
argument_list|,
name|cs
operator|->
name|c_naux
argument_list|,
operator|&
name|main_aux
argument_list|)
expr_stmt|;
name|within_function
operator|=
literal|1
expr_stmt|;
name|new
operator|=
name|push_context
argument_list|(
literal|0
argument_list|,
name|fcn_start_addr
operator|+
name|off
argument_list|)
expr_stmt|;
name|new
operator|->
name|name
operator|=
name|define_symbol
argument_list|(
name|fcn_cs_saved
operator|.
name|c_value
operator|+
name|off
argument_list|,
name|fcn_stab_saved
operator|.
name|c_name
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|->
name|name
operator|!=
name|NULL
condition|)
name|SYMBOL_SECTION
argument_list|(
name|new
operator|->
name|name
argument_list|)
operator|=
name|SECT_OFF_TEXT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|cs
operator|->
name|c_name
argument_list|,
literal|".ef"
argument_list|)
condition|)
block|{
name|bfd_coff_swap_aux_in
argument_list|(
name|abfd
argument_list|,
name|raw_auxptr
argument_list|,
name|cs
operator|->
name|c_type
argument_list|,
name|cs
operator|->
name|c_sclass
argument_list|,
literal|0
argument_list|,
name|cs
operator|->
name|c_naux
argument_list|,
operator|&
name|main_aux
argument_list|)
expr_stmt|;
comment|/* The value of .ef is the address of epilogue code; 		 not useful for gdb.  */
comment|/* { main_aux.x_sym.x_misc.x_lnsz.x_lnno 		 contains number of lines to '}' */
if|if
condition|(
name|context_stack_depth
operator|<=
literal|0
condition|)
block|{
comment|/* We attempted to pop an empty context stack */
name|complain
argument_list|(
operator|&
name|ef_complaint
argument_list|,
name|cs
operator|->
name|c_symnum
argument_list|)
expr_stmt|;
name|within_function
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|new
operator|=
name|pop_context
argument_list|()
expr_stmt|;
comment|/* Stack must be empty now.  */
if|if
condition|(
name|context_stack_depth
operator|>
literal|0
operator|||
name|new
operator|==
name|NULL
condition|)
block|{
name|complain
argument_list|(
operator|&
name|ef_complaint
argument_list|,
name|cs
operator|->
name|c_symnum
argument_list|)
expr_stmt|;
name|within_function
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|finish_block
argument_list|(
name|new
operator|->
name|name
argument_list|,
operator|&
name|local_symbols
argument_list|,
name|new
operator|->
name|old_blocks
argument_list|,
name|new
operator|->
name|start_addr
argument_list|,
operator|(
name|fcn_cs_saved
operator|.
name|c_value
operator|+
name|fcn_aux_saved
operator|.
name|x_sym
operator|.
name|x_misc
operator|.
name|x_fsize
operator|+
name|ANOFFSET
argument_list|(
name|objfile
operator|->
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
operator|)
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|within_function
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|C_BSTAT
case|:
comment|/* Begin static block.  */
block|{
name|struct
name|internal_syment
name|symbol
decl_stmt|;
name|read_symbol
argument_list|(
operator|&
name|symbol
argument_list|,
name|cs
operator|->
name|c_value
argument_list|)
expr_stmt|;
name|static_block_base
operator|=
name|symbol
operator|.
name|n_value
expr_stmt|;
name|static_block_section
operator|=
name|secnum_to_section
argument_list|(
name|symbol
operator|.
name|n_scnum
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|C_ESTAT
case|:
comment|/* End of static block.  */
name|static_block_base
operator|=
literal|0
expr_stmt|;
name|static_block_section
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|C_ARG
case|:
case|case
name|C_REGPARM
case|:
case|case
name|C_REG
case|:
case|case
name|C_TPDEF
case|:
case|case
name|C_STRTAG
case|:
case|case
name|C_UNTAG
case|:
case|case
name|C_ENTAG
case|:
block|{
specifier|static
name|struct
name|complaint
name|msg
init|=
block|{
literal|"Unrecognized storage class %d."
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|complain
argument_list|(
operator|&
name|msg
argument_list|,
name|cs
operator|->
name|c_sclass
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|C_LABEL
case|:
case|case
name|C_NULL
case|:
comment|/* Ignore these.  */
break|break;
case|case
name|C_HIDEXT
case|:
case|case
name|C_STAT
case|:
break|break;
case|case
name|C_BINCL
case|:
comment|/* beginning of include file */
comment|/* In xlc output, C_BINCL/C_EINCL pair doesn't show up in sorted 	     order. Thus, when wee see them, we might not know enough info 	     to process them. Thus, we'll be saving them into a table  	     (inclTable) and postpone their processing. */
name|record_include_begin
argument_list|(
name|cs
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_EINCL
case|:
comment|/* End of include file.  */
comment|/* See the comment after case C_BINCL.  */
name|record_include_end
argument_list|(
name|cs
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_BLOCK
case|:
if|if
condition|(
name|STREQ
argument_list|(
name|cs
operator|->
name|c_name
argument_list|,
literal|".bb"
argument_list|)
condition|)
block|{
name|depth
operator|++
expr_stmt|;
name|new
operator|=
name|push_context
argument_list|(
name|depth
argument_list|,
operator|(
name|cs
operator|->
name|c_value
operator|+
name|ANOFFSET
argument_list|(
name|objfile
operator|->
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|cs
operator|->
name|c_name
argument_list|,
literal|".eb"
argument_list|)
condition|)
block|{
if|if
condition|(
name|context_stack_depth
operator|<=
literal|0
condition|)
block|{
comment|/* We attempted to pop an empty context stack */
name|complain
argument_list|(
operator|&
name|eb_complaint
argument_list|,
name|cs
operator|->
name|c_symnum
argument_list|)
expr_stmt|;
break|break;
block|}
name|new
operator|=
name|pop_context
argument_list|()
expr_stmt|;
if|if
condition|(
name|depth
operator|--
operator|!=
name|new
operator|->
name|depth
condition|)
block|{
name|complain
argument_list|(
operator|&
name|eb_complaint
argument_list|,
name|cs
operator|->
name|c_symnum
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|local_symbols
operator|&&
name|context_stack_depth
operator|>
literal|0
condition|)
block|{
comment|/* Make a block for the local symbols within.  */
name|finish_block
argument_list|(
name|new
operator|->
name|name
argument_list|,
operator|&
name|local_symbols
argument_list|,
name|new
operator|->
name|old_blocks
argument_list|,
name|new
operator|->
name|start_addr
argument_list|,
operator|(
name|cs
operator|->
name|c_value
operator|+
name|ANOFFSET
argument_list|(
name|objfile
operator|->
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
operator|)
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
name|local_symbols
operator|=
name|new
operator|->
name|locals
expr_stmt|;
block|}
break|break;
default|default:
name|process_xcoff_symbol
argument_list|(
name|cs
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|last_source_file
condition|)
block|{
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
name|complete_symtab
argument_list|(
name|filestring
argument_list|,
name|file_start_addr
argument_list|)
expr_stmt|;
name|cur_src_end_addr
operator|=
name|file_end_addr
expr_stmt|;
name|s
operator|=
name|end_symtab
argument_list|(
name|file_end_addr
argument_list|,
name|objfile
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
expr_stmt|;
comment|/* When reading symbols for the last C_FILE of the objfile, try          to make sure that we set pst->symtab to the symtab for the          file, not to the _globals_ symtab.  I'm not sure whether this          actually works right or when/if it comes up.  */
if|if
condition|(
name|pst
operator|->
name|symtab
operator|==
name|NULL
condition|)
name|pst
operator|->
name|symtab
operator|=
name|s
expr_stmt|;
name|end_stabs
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|SYMBOL_DUP
parameter_list|(
name|SYMBOL1
parameter_list|,
name|SYMBOL2
parameter_list|)
define|\
value|(SYMBOL2) = (struct symbol *)		\   	obstack_alloc (&objfile->symbol_obstack, sizeof (struct symbol)); \   *(SYMBOL2) = *(SYMBOL1);
end_define

begin_define
define|#
directive|define
name|SYMNAME_ALLOC
parameter_list|(
name|NAME
parameter_list|,
name|ALLOCED
parameter_list|)
define|\
value|(ALLOCED) ? (NAME) : obstack_copy0 (&objfile->symbol_obstack, (NAME), strlen (NAME));
end_define

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|func_symbol_type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|var_symbol_type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* process one xcoff symbol. */
end_comment

begin_function
specifier|static
name|struct
name|symbol
modifier|*
name|process_xcoff_symbol
parameter_list|(
name|cs
parameter_list|,
name|objfile
parameter_list|)
specifier|register
name|struct
name|coff_symbol
modifier|*
name|cs
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|struct
name|symbol
name|onesymbol
decl_stmt|;
specifier|register
name|struct
name|symbol
modifier|*
name|sym
init|=
operator|&
name|onesymbol
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym2
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|pp
decl_stmt|;
name|int
name|sec
decl_stmt|;
name|CORE_ADDR
name|off
decl_stmt|;
if|if
condition|(
name|cs
operator|->
name|c_secnum
operator|<
literal|0
condition|)
block|{
comment|/* The value is a register number, offset within a frame, etc., 	 and does not get relocated.  */
name|off
operator|=
literal|0
expr_stmt|;
name|sec
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|sec
operator|=
name|secnum_to_section
argument_list|(
name|cs
operator|->
name|c_secnum
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|off
operator|=
name|ANOFFSET
argument_list|(
name|objfile
operator|->
name|section_offsets
argument_list|,
name|sec
argument_list|)
expr_stmt|;
block|}
name|name
operator|=
name|cs
operator|->
name|c_name
expr_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
operator|++
name|name
expr_stmt|;
name|memset
argument_list|(
name|sym
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
comment|/* default assumptions */
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|cs
operator|->
name|c_value
operator|+
name|off
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
name|SYMBOL_SECTION
argument_list|(
name|sym
argument_list|)
operator|=
name|secnum_to_section
argument_list|(
name|cs
operator|->
name|c_secnum
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISFCN
argument_list|(
name|cs
operator|->
name|c_type
argument_list|)
condition|)
block|{
comment|/* At this point, we don't know the type of the function.  This 	 will be patched with the type from its stab entry later on in 	 patch_block_stabs (), unless the file was compiled without -g.  */
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|=
name|SYMNAME_ALLOC
argument_list|(
name|name
argument_list|,
name|symname_alloced
argument_list|)
expr_stmt|;
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|func_symbol_type
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_BLOCK
expr_stmt|;
name|SYMBOL_DUP
argument_list|(
name|sym
argument_list|,
name|sym2
argument_list|)
expr_stmt|;
if|if
condition|(
name|cs
operator|->
name|c_sclass
operator|==
name|C_EXT
condition|)
name|add_symbol_to_list
argument_list|(
name|sym2
argument_list|,
operator|&
name|global_symbols
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cs
operator|->
name|c_sclass
operator|==
name|C_HIDEXT
operator|||
name|cs
operator|->
name|c_sclass
operator|==
name|C_STAT
condition|)
name|add_symbol_to_list
argument_list|(
name|sym2
argument_list|,
operator|&
name|file_symbols
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* In case we can't figure out the type, provide default. */
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|var_symbol_type
expr_stmt|;
switch|switch
condition|(
name|cs
operator|->
name|c_sclass
condition|)
block|{
if|#
directive|if
literal|0
comment|/* The values of functions and global symbols are now resolved 	   via the global_sym_chain in stabsread.c.  */
block|case C_FUN: 	  if (fcn_cs_saved.c_sclass == C_EXT) 	    add_stab_to_list (name,&global_stabs); 	  else 	    add_stab_to_list (name,&file_stabs); 	  break;  	case C_GSYM: 	  add_stab_to_list (name,&global_stabs); 	  break;
endif|#
directive|endif
case|case
name|C_BCOMM
case|:
name|common_block_start
argument_list|(
name|cs
operator|->
name|c_name
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_ECOMM
case|:
name|common_block_end
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
break|break;
default|default:
name|complain
argument_list|(
operator|&
name|storclass_complaint
argument_list|,
name|cs
operator|->
name|c_sclass
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|C_DECL
case|:
case|case
name|C_PSYM
case|:
case|case
name|C_RPSYM
case|:
case|case
name|C_ECOML
case|:
case|case
name|C_LSYM
case|:
case|case
name|C_RSYM
case|:
case|case
name|C_GSYM
case|:
block|{
name|sym
operator|=
name|define_symbol
argument_list|(
name|cs
operator|->
name|c_value
operator|+
name|off
argument_list|,
name|cs
operator|->
name|c_name
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|!=
name|NULL
condition|)
block|{
name|SYMBOL_SECTION
argument_list|(
name|sym
argument_list|)
operator|=
name|sec
expr_stmt|;
block|}
return|return
name|sym
return|;
block|}
case|case
name|C_STSYM
case|:
comment|/* For xlc (not GCC), the 'V' symbol descriptor is used for 	     all statics and we need to distinguish file-scope versus 	     function-scope using within_function.  We do this by 	     changing the string we pass to define_symbol to use 'S' 	     where we need to, which is not necessarily super-clean, 	     but seems workable enough.  */
if|if
condition|(
operator|*
name|name
operator|==
literal|':'
operator|||
operator|(
name|pp
operator|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|name
argument_list|,
literal|':'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
operator|++
name|pp
expr_stmt|;
if|if
condition|(
operator|*
name|pp
operator|==
literal|'V'
operator|&&
operator|!
name|within_function
condition|)
operator|*
name|pp
operator|=
literal|'S'
expr_stmt|;
name|sym
operator|=
name|define_symbol
argument_list|(
operator|(
name|cs
operator|->
name|c_value
operator|+
name|ANOFFSET
argument_list|(
name|objfile
operator|->
name|section_offsets
argument_list|,
name|static_block_section
argument_list|)
operator|)
argument_list|,
name|cs
operator|->
name|c_name
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|!=
name|NULL
condition|)
block|{
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|+=
name|static_block_base
expr_stmt|;
name|SYMBOL_SECTION
argument_list|(
name|sym
argument_list|)
operator|=
name|static_block_section
expr_stmt|;
block|}
return|return
name|sym
return|;
block|}
block|}
return|return
name|sym2
return|;
block|}
end_function

begin_comment
comment|/* Extract the file name from the aux entry of a C_FILE symbol.  Return    only the last component of the name.  Result is in static storage and    is only good for temporary use.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|coff_getfilename
parameter_list|(
name|aux_entry
parameter_list|,
name|objfile
parameter_list|)
name|union
name|internal_auxent
modifier|*
name|aux_entry
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
specifier|static
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|temp
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
if|if
condition|(
name|aux_entry
operator|->
name|x_file
operator|.
name|x_n
operator|.
name|x_zeroes
operator|==
literal|0
condition|)
name|strcpy
argument_list|(
name|buffer
argument_list|,
operator|(
operator|(
expr|struct
name|coff_symfile_info
operator|*
operator|)
name|objfile
operator|->
name|sym_private
operator|)
operator|->
name|strtbl
operator|+
name|aux_entry
operator|->
name|x_file
operator|.
name|x_n
operator|.
name|x_offset
argument_list|)
expr_stmt|;
else|else
block|{
name|strncpy
argument_list|(
name|buffer
argument_list|,
name|aux_entry
operator|->
name|x_file
operator|.
name|x_fname
argument_list|,
name|FILNMLEN
argument_list|)
expr_stmt|;
name|buffer
index|[
name|FILNMLEN
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|result
operator|=
name|buffer
expr_stmt|;
comment|/* FIXME: We should not be throwing away the information about what      directory.  It should go into dirname of the symtab, or some such      place.  */
if|if
condition|(
operator|(
name|temp
operator|=
name|strrchr
argument_list|(
name|result
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|result
operator|=
name|temp
operator|+
literal|1
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Set *SYMBOL to symbol number symno in symtbl.  */
end_comment

begin_function
specifier|static
name|void
name|read_symbol
parameter_list|(
name|symbol
parameter_list|,
name|symno
parameter_list|)
name|struct
name|internal_syment
modifier|*
name|symbol
decl_stmt|;
name|int
name|symno
decl_stmt|;
block|{
name|int
name|nsyms
init|=
operator|(
operator|(
expr|struct
name|coff_symfile_info
operator|*
operator|)
name|this_symtab_psymtab
operator|->
name|objfile
operator|->
name|sym_private
operator|)
operator|->
name|symtbl_num_syms
decl_stmt|;
name|char
modifier|*
name|stbl
init|=
operator|(
operator|(
expr|struct
name|coff_symfile_info
operator|*
operator|)
name|this_symtab_psymtab
operator|->
name|objfile
operator|->
name|sym_private
operator|)
operator|->
name|symtbl
decl_stmt|;
if|if
condition|(
name|symno
operator|<
literal|0
operator|||
name|symno
operator|>=
name|nsyms
condition|)
block|{
specifier|static
name|struct
name|complaint
name|msg
init|=
block|{
literal|"Invalid symbol offset"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|complain
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
name|symbol
operator|->
name|n_value
operator|=
literal|0
expr_stmt|;
name|symbol
operator|->
name|n_scnum
operator|=
operator|-
literal|1
expr_stmt|;
return|return;
block|}
name|bfd_coff_swap_sym_in
argument_list|(
name|this_symtab_psymtab
operator|->
name|objfile
operator|->
name|obfd
argument_list|,
name|stbl
operator|+
operator|(
name|symno
operator|*
name|local_symesz
operator|)
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get value corresponding to symbol number symno in symtbl.  */
end_comment

begin_function
specifier|static
name|int
name|read_symbol_nvalue
parameter_list|(
name|symno
parameter_list|)
name|int
name|symno
decl_stmt|;
block|{
name|struct
name|internal_syment
name|symbol
index|[
literal|1
index|]
decl_stmt|;
name|read_symbol
argument_list|(
name|symbol
argument_list|,
name|symno
argument_list|)
expr_stmt|;
return|return
name|symbol
operator|->
name|n_value
return|;
block|}
end_function

begin_comment
comment|/* Find the address of the function corresponding to symno, where    symno is the symbol pointed to by the linetable.  */
end_comment

begin_function
specifier|static
name|int
name|read_symbol_lineno
parameter_list|(
name|symno
parameter_list|)
name|int
name|symno
decl_stmt|;
block|{
name|int
name|nsyms
init|=
operator|(
operator|(
expr|struct
name|coff_symfile_info
operator|*
operator|)
name|this_symtab_psymtab
operator|->
name|objfile
operator|->
name|sym_private
operator|)
operator|->
name|symtbl_num_syms
decl_stmt|;
name|char
modifier|*
name|stbl
init|=
operator|(
operator|(
expr|struct
name|coff_symfile_info
operator|*
operator|)
name|this_symtab_psymtab
operator|->
name|objfile
operator|->
name|sym_private
operator|)
operator|->
name|symtbl
decl_stmt|;
name|struct
name|internal_syment
name|symbol
index|[
literal|1
index|]
decl_stmt|;
name|union
name|internal_auxent
name|main_aux
index|[
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|symno
operator|<
literal|0
condition|)
block|{
name|complain
argument_list|(
operator|&
name|bf_notfound_complaint
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Note that just searching for a short distance (e.g. 50 symbols)      is not enough, at least in the following case.       .extern foo      [many .stabx entries]      [a few functions, referring to foo]      .globl foo      .bf       What happens here is that the assembler moves the .stabx entries      to right before the ".bf" for foo, but the symbol for "foo" is before      all the stabx entries.  See PR gdb/2222.  */
comment|/* Maintaining a table of .bf entries might be preferable to this search.      If I understand things correctly it would need to be done only for      the duration of a single psymtab to symtab conversion.  */
while|while
condition|(
name|symno
operator|<
name|nsyms
condition|)
block|{
name|bfd_coff_swap_sym_in
argument_list|(
name|symfile_bfd
argument_list|,
name|stbl
operator|+
operator|(
name|symno
operator|*
name|local_symesz
operator|)
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbol
operator|->
name|n_sclass
operator|==
name|C_FCN
operator|&&
name|STREQ
argument_list|(
name|symbol
operator|->
name|n_name
argument_list|,
literal|".bf"
argument_list|)
condition|)
goto|goto
name|gotit
goto|;
name|symno
operator|+=
name|symbol
operator|->
name|n_numaux
operator|+
literal|1
expr_stmt|;
block|}
name|complain
argument_list|(
operator|&
name|bf_notfound_complaint
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|gotit
label|:
comment|/* take aux entry and return its lineno */
name|symno
operator|++
expr_stmt|;
name|bfd_coff_swap_aux_in
argument_list|(
name|this_symtab_psymtab
operator|->
name|objfile
operator|->
name|obfd
argument_list|,
name|stbl
operator|+
name|symno
operator|*
name|local_symesz
argument_list|,
name|symbol
operator|->
name|n_type
argument_list|,
name|symbol
operator|->
name|n_sclass
argument_list|,
literal|0
argument_list|,
name|symbol
operator|->
name|n_numaux
argument_list|,
name|main_aux
argument_list|)
expr_stmt|;
return|return
name|main_aux
operator|->
name|x_sym
operator|.
name|x_misc
operator|.
name|x_lnsz
operator|.
name|x_lnno
return|;
block|}
end_function

begin_comment
comment|/* Support for line number handling */
end_comment

begin_comment
comment|/* This function is called for every section; it finds the outer limits  * of the line table (minimum and maximum file offset) so that the  * mainline code can read the whole thing for efficiency.  */
end_comment

begin_function
specifier|static
name|void
name|find_linenos
parameter_list|(
name|abfd
parameter_list|,
name|asect
parameter_list|,
name|vpinfo
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|sec_ptr
name|asect
decl_stmt|;
name|PTR
name|vpinfo
decl_stmt|;
block|{
name|struct
name|coff_symfile_info
modifier|*
name|info
decl_stmt|;
name|int
name|size
decl_stmt|,
name|count
decl_stmt|;
name|file_ptr
name|offset
decl_stmt|,
name|maxoff
decl_stmt|;
name|count
operator|=
name|asect
operator|->
name|lineno_count
expr_stmt|;
if|if
condition|(
operator|!
name|STREQ
argument_list|(
name|asect
operator|->
name|name
argument_list|,
literal|".text"
argument_list|)
operator|||
name|count
operator|==
literal|0
condition|)
return|return;
name|size
operator|=
name|count
operator|*
name|coff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|local_linesz
expr_stmt|;
name|info
operator|=
operator|(
expr|struct
name|coff_symfile_info
operator|*
operator|)
name|vpinfo
expr_stmt|;
name|offset
operator|=
name|asect
operator|->
name|line_filepos
expr_stmt|;
name|maxoff
operator|=
name|offset
operator|+
name|size
expr_stmt|;
if|if
condition|(
name|offset
operator|<
name|info
operator|->
name|min_lineno_offset
operator|||
name|info
operator|->
name|min_lineno_offset
operator|==
literal|0
condition|)
name|info
operator|->
name|min_lineno_offset
operator|=
name|offset
expr_stmt|;
if|if
condition|(
name|maxoff
operator|>
name|info
operator|->
name|max_lineno_offset
condition|)
name|info
operator|->
name|max_lineno_offset
operator|=
name|maxoff
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|void
name|xcoff_psymtab_to_symtab_1
name|PARAMS
argument_list|(
operator|(
expr|struct
name|partial_symtab
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|xcoff_psymtab_to_symtab_1
parameter_list|(
name|pst
parameter_list|)
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
block|{
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|pst
condition|)
return|return;
if|if
condition|(
name|pst
operator|->
name|readin
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Psymtab for %s already read in.  Shouldn't happen.\n"
argument_list|,
name|pst
operator|->
name|filename
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Read in all partial symtabs on which this one is dependent */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pst
operator|->
name|number_of_dependencies
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|pst
operator|->
name|dependencies
index|[
name|i
index|]
operator|->
name|readin
condition|)
block|{
comment|/* Inform about additional files that need to be read in.  */
if|if
condition|(
name|info_verbose
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|" "
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"and "
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%s..."
argument_list|,
name|pst
operator|->
name|dependencies
index|[
name|i
index|]
operator|->
name|filename
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
comment|/* Flush output */
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
name|xcoff_psymtab_to_symtab_1
argument_list|(
name|pst
operator|->
name|dependencies
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
expr|struct
name|symloc
operator|*
operator|)
name|pst
operator|->
name|read_symtab_private
operator|)
operator|->
name|numsyms
operator|!=
literal|0
condition|)
block|{
comment|/* Init stuff necessary for reading in symbols.  */
name|stabsread_init
argument_list|()
expr_stmt|;
name|buildsym_init
argument_list|()
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|really_free_pendings
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|read_xcoff_symtab
argument_list|(
name|pst
argument_list|)
expr_stmt|;
name|sort_symtab_syms
argument_list|(
name|pst
operator|->
name|symtab
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
name|pst
operator|->
name|readin
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|xcoff_psymtab_to_symtab
name|PARAMS
argument_list|(
operator|(
expr|struct
name|partial_symtab
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Read in all of the symbols for a given psymtab for real.    Be verbose about it if the user wants that.  */
end_comment

begin_function
specifier|static
name|void
name|xcoff_psymtab_to_symtab
parameter_list|(
name|pst
parameter_list|)
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
block|{
name|bfd
modifier|*
name|sym_bfd
decl_stmt|;
if|if
condition|(
operator|!
name|pst
condition|)
return|return;
if|if
condition|(
name|pst
operator|->
name|readin
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Psymtab for %s already read in.  Shouldn't happen.\n"
argument_list|,
name|pst
operator|->
name|filename
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
operator|(
expr|struct
name|symloc
operator|*
operator|)
name|pst
operator|->
name|read_symtab_private
operator|)
operator|->
name|numsyms
operator|!=
literal|0
operator|||
name|pst
operator|->
name|number_of_dependencies
condition|)
block|{
comment|/* Print the message now, before reading the string table, 	 to avoid disconcerting pauses.  */
if|if
condition|(
name|info_verbose
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Reading in symbols for %s..."
argument_list|,
name|pst
operator|->
name|filename
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
name|sym_bfd
operator|=
name|pst
operator|->
name|objfile
operator|->
name|obfd
expr_stmt|;
name|next_symbol_text_func
operator|=
name|xcoff_next_symbol_text
expr_stmt|;
name|xcoff_psymtab_to_symtab_1
argument_list|(
name|pst
argument_list|)
expr_stmt|;
comment|/* Match with global symbols.  This only needs to be done once,          after all of the symtabs and dependencies have been read in.   */
name|scan_file_globals
argument_list|(
name|pst
operator|->
name|objfile
argument_list|)
expr_stmt|;
comment|/* Finish up the debug error message.  */
if|if
condition|(
name|info_verbose
condition|)
name|printf_filtered
argument_list|(
literal|"done.\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|xcoff_new_init
parameter_list|(
name|objfile
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|stabsread_new_init
argument_list|()
expr_stmt|;
name|buildsym_new_init
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Do initialization in preparation for reading symbols from OBJFILE.      We will only be called if this is an XCOFF or XCOFF-like file.    BFD handles figuring out the format of the file, and code in symfile.c    uses BFD's determination to vector to us.  */
end_comment

begin_function
specifier|static
name|void
name|xcoff_symfile_init
parameter_list|(
name|objfile
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
comment|/* Allocate struct to keep track of the symfile */
name|objfile
operator|->
name|sym_private
operator|=
name|xmmalloc
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|coff_symfile_info
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XCOFF objects may be reordered, so set OBJF_REORDERED.  If we      find this causes a significant slowdown in gdb then we could      set it in the debug symbol readers only when necessary.  */
name|objfile
operator|->
name|flags
operator||=
name|OBJF_REORDERED
expr_stmt|;
name|init_entry_point_info
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Perform any local cleanups required when we are done with a particular    objfile.  I.E, we are in the process of discarding all symbol information    for an objfile, freeing up all memory held for it, and unlinking the    objfile struct from the global list of known objfiles. */
end_comment

begin_function
specifier|static
name|void
name|xcoff_symfile_finish
parameter_list|(
name|objfile
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
if|if
condition|(
name|objfile
operator|->
name|sym_private
operator|!=
name|NULL
condition|)
block|{
name|mfree
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
name|objfile
operator|->
name|sym_private
argument_list|)
expr_stmt|;
block|}
comment|/* Start with a fresh include table for the next objfile.  */
if|if
condition|(
name|inclTable
condition|)
block|{
name|free
argument_list|(
name|inclTable
argument_list|)
expr_stmt|;
name|inclTable
operator|=
name|NULL
expr_stmt|;
block|}
name|inclIndx
operator|=
name|inclLength
operator|=
name|inclDepth
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|init_stringtab
parameter_list|(
name|abfd
parameter_list|,
name|offset
parameter_list|,
name|objfile
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|file_ptr
name|offset
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|long
name|length
decl_stmt|;
name|int
name|val
decl_stmt|;
name|unsigned
name|char
name|lengthbuf
index|[
literal|4
index|]
decl_stmt|;
name|char
modifier|*
name|strtbl
decl_stmt|;
operator|(
operator|(
expr|struct
name|coff_symfile_info
operator|*
operator|)
name|objfile
operator|->
name|sym_private
operator|)
operator|->
name|strtbl
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"cannot seek to string table in %s: %s"
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|val
operator|=
name|bfd_read
argument_list|(
operator|(
name|char
operator|*
operator|)
name|lengthbuf
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
name|lengthbuf
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|length
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|lengthbuf
argument_list|)
expr_stmt|;
comment|/* If no string table is needed, then the file may end immediately      after the symbols.  Just return with `strtbl' set to NULL.  */
if|if
condition|(
name|val
operator|!=
sizeof|sizeof
name|lengthbuf
operator|||
name|length
operator|<
sizeof|sizeof
name|lengthbuf
condition|)
return|return;
comment|/* Allocate string table from symbol_obstack. We will need this table      as long as we have its symbol table around. */
name|strtbl
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|,
name|length
argument_list|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|coff_symfile_info
operator|*
operator|)
name|objfile
operator|->
name|sym_private
operator|)
operator|->
name|strtbl
operator|=
name|strtbl
expr_stmt|;
comment|/* Copy length buffer, the first byte is usually zero and is      used for stabs with a name length of zero.  */
name|memcpy
argument_list|(
name|strtbl
argument_list|,
name|lengthbuf
argument_list|,
sizeof|sizeof
name|lengthbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|==
sizeof|sizeof
name|lengthbuf
condition|)
return|return;
name|val
operator|=
name|bfd_read
argument_list|(
name|strtbl
operator|+
sizeof|sizeof
name|lengthbuf
argument_list|,
literal|1
argument_list|,
name|length
operator|-
sizeof|sizeof
name|lengthbuf
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|length
operator|-
sizeof|sizeof
name|lengthbuf
condition|)
name|error
argument_list|(
literal|"cannot read string table from %s: %s"
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strtbl
index|[
name|length
operator|-
literal|1
index|]
operator|!=
literal|'\0'
condition|)
name|error
argument_list|(
literal|"bad symbol file: string table does not end with null character"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If we have not yet seen a function for this psymtab, this is 0.  If we    have seen one, it is the offset in the line numbers of the line numbers    for the psymtab.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|first_fun_line_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|partial_symtab
modifier|*
name|xcoff_start_psymtab
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|,
expr|struct
name|section_offsets
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|,
expr|struct
name|partial_symbol
operator|*
operator|*
operator|,
expr|struct
name|partial_symbol
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Allocate and partially fill a partial symtab.  It will be    completely filled at the end of the symbol list.     SYMFILE_NAME is the name of the symbol-file we are reading from, and ADDR    is the address relative to which its symbols are (incremental) or 0    (normal). */
end_comment

begin_function
specifier|static
name|struct
name|partial_symtab
modifier|*
name|xcoff_start_psymtab
parameter_list|(
name|objfile
parameter_list|,
name|section_offsets
parameter_list|,
name|filename
parameter_list|,
name|first_symnum
parameter_list|,
name|global_syms
parameter_list|,
name|static_syms
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|section_offsets
modifier|*
name|section_offsets
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|first_symnum
decl_stmt|;
name|struct
name|partial_symbol
modifier|*
modifier|*
name|global_syms
decl_stmt|;
name|struct
name|partial_symbol
modifier|*
modifier|*
name|static_syms
decl_stmt|;
block|{
name|struct
name|partial_symtab
modifier|*
name|result
init|=
name|start_psymtab_common
argument_list|(
name|objfile
argument_list|,
name|section_offsets
argument_list|,
name|filename
argument_list|,
comment|/* We fill in textlow later.  */
literal|0
argument_list|,
name|global_syms
argument_list|,
name|static_syms
argument_list|)
decl_stmt|;
name|result
operator|->
name|read_symtab_private
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|psymbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symloc
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|symloc
operator|*
operator|)
name|result
operator|->
name|read_symtab_private
operator|)
operator|->
name|first_symnum
operator|=
name|first_symnum
expr_stmt|;
name|result
operator|->
name|read_symtab
operator|=
name|xcoff_psymtab_to_symtab
expr_stmt|;
comment|/* Deduce the source language from the filename for this psymtab. */
name|psymtab_language
operator|=
name|deduce_language_from_filename
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|partial_symtab
modifier|*
name|xcoff_end_psymtab
name|PARAMS
argument_list|(
operator|(
expr|struct
name|partial_symtab
operator|*
operator|,
name|char
operator|*
operator|*
operator|,
name|int
operator|,
name|int
operator|,
expr|struct
name|partial_symtab
operator|*
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Close off the current usage of PST.      Returns PST, or NULL if the partial symtab was empty and thrown away.     CAPPING_SYMBOL_NUMBER is the end of pst (exclusive).     INCLUDE_LIST, NUM_INCLUDES, DEPENDENCY_LIST, and NUMBER_DEPENDENCIES    are the information for includes and dependencies.  */
end_comment

begin_function
specifier|static
name|struct
name|partial_symtab
modifier|*
name|xcoff_end_psymtab
parameter_list|(
name|pst
parameter_list|,
name|include_list
parameter_list|,
name|num_includes
parameter_list|,
name|capping_symbol_number
parameter_list|,
name|dependency_list
parameter_list|,
name|number_dependencies
parameter_list|)
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
name|char
modifier|*
modifier|*
name|include_list
decl_stmt|;
name|int
name|num_includes
decl_stmt|;
name|int
name|capping_symbol_number
decl_stmt|;
name|struct
name|partial_symtab
modifier|*
modifier|*
name|dependency_list
decl_stmt|;
name|int
name|number_dependencies
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
init|=
name|pst
operator|->
name|objfile
decl_stmt|;
if|if
condition|(
name|capping_symbol_number
operator|!=
operator|-
literal|1
condition|)
operator|(
operator|(
expr|struct
name|symloc
operator|*
operator|)
name|pst
operator|->
name|read_symtab_private
operator|)
operator|->
name|numsyms
operator|=
name|capping_symbol_number
operator|-
operator|(
operator|(
expr|struct
name|symloc
operator|*
operator|)
name|pst
operator|->
name|read_symtab_private
operator|)
operator|->
name|first_symnum
expr_stmt|;
operator|(
operator|(
expr|struct
name|symloc
operator|*
operator|)
name|pst
operator|->
name|read_symtab_private
operator|)
operator|->
name|lineno_off
operator|=
name|first_fun_line_offset
expr_stmt|;
name|first_fun_line_offset
operator|=
literal|0
expr_stmt|;
name|pst
operator|->
name|n_global_syms
operator|=
name|objfile
operator|->
name|global_psymbols
operator|.
name|next
operator|-
operator|(
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
operator|+
name|pst
operator|->
name|globals_offset
operator|)
expr_stmt|;
name|pst
operator|->
name|n_static_syms
operator|=
name|objfile
operator|->
name|static_psymbols
operator|.
name|next
operator|-
operator|(
name|objfile
operator|->
name|static_psymbols
operator|.
name|list
operator|+
name|pst
operator|->
name|statics_offset
operator|)
expr_stmt|;
name|pst
operator|->
name|number_of_dependencies
operator|=
name|number_dependencies
expr_stmt|;
if|if
condition|(
name|number_dependencies
condition|)
block|{
name|pst
operator|->
name|dependencies
operator|=
operator|(
expr|struct
name|partial_symtab
operator|*
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|psymbol_obstack
argument_list|,
name|number_dependencies
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|partial_symtab
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|pst
operator|->
name|dependencies
argument_list|,
name|dependency_list
argument_list|,
name|number_dependencies
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|partial_symtab
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|pst
operator|->
name|dependencies
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_includes
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|partial_symtab
modifier|*
name|subpst
init|=
name|allocate_psymtab
argument_list|(
name|include_list
index|[
name|i
index|]
argument_list|,
name|objfile
argument_list|)
decl_stmt|;
name|subpst
operator|->
name|section_offsets
operator|=
name|pst
operator|->
name|section_offsets
expr_stmt|;
name|subpst
operator|->
name|read_symtab_private
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|psymbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symloc
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|symloc
operator|*
operator|)
name|subpst
operator|->
name|read_symtab_private
operator|)
operator|->
name|first_symnum
operator|=
literal|0
expr_stmt|;
operator|(
operator|(
expr|struct
name|symloc
operator|*
operator|)
name|subpst
operator|->
name|read_symtab_private
operator|)
operator|->
name|numsyms
operator|=
literal|0
expr_stmt|;
name|subpst
operator|->
name|textlow
operator|=
literal|0
expr_stmt|;
name|subpst
operator|->
name|texthigh
operator|=
literal|0
expr_stmt|;
comment|/* We could save slight bits of space by only making one of these, 	 shared by the entire set of include files.  FIXME-someday.  */
name|subpst
operator|->
name|dependencies
operator|=
operator|(
expr|struct
name|partial_symtab
operator|*
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|psymbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|partial_symtab
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|subpst
operator|->
name|dependencies
index|[
literal|0
index|]
operator|=
name|pst
expr_stmt|;
name|subpst
operator|->
name|number_of_dependencies
operator|=
literal|1
expr_stmt|;
name|subpst
operator|->
name|globals_offset
operator|=
name|subpst
operator|->
name|n_global_syms
operator|=
name|subpst
operator|->
name|statics_offset
operator|=
name|subpst
operator|->
name|n_static_syms
operator|=
literal|0
expr_stmt|;
name|subpst
operator|->
name|readin
operator|=
literal|0
expr_stmt|;
name|subpst
operator|->
name|symtab
operator|=
literal|0
expr_stmt|;
name|subpst
operator|->
name|read_symtab
operator|=
name|pst
operator|->
name|read_symtab
expr_stmt|;
block|}
name|sort_pst_symbols
argument_list|(
name|pst
argument_list|)
expr_stmt|;
comment|/* If there is already a psymtab or symtab for a file of this name,      remove it.  (If there is a symtab, more drastic things also      happen.)  This happens in VxWorks.  */
name|free_named_symtabs
argument_list|(
name|pst
operator|->
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_includes
operator|==
literal|0
operator|&&
name|number_dependencies
operator|==
literal|0
operator|&&
name|pst
operator|->
name|n_global_syms
operator|==
literal|0
operator|&&
name|pst
operator|->
name|n_static_syms
operator|==
literal|0
condition|)
block|{
comment|/* Throw away this psymtab, it's empty.  We can't deallocate it, since 	 it is on the obstack, but we can forget to chain it on the list.  */
comment|/* Empty psymtabs happen as a result of header files which don't have 	 any symbols in them.  There can be a lot of them.  */
name|struct
name|partial_symtab
modifier|*
name|prev_pst
decl_stmt|;
comment|/* First, snip it out of the psymtab chain */
if|if
condition|(
name|pst
operator|->
name|objfile
operator|->
name|psymtabs
operator|==
name|pst
condition|)
name|pst
operator|->
name|objfile
operator|->
name|psymtabs
operator|=
name|pst
operator|->
name|next
expr_stmt|;
else|else
for|for
control|(
name|prev_pst
operator|=
name|pst
operator|->
name|objfile
operator|->
name|psymtabs
init|;
name|prev_pst
condition|;
name|prev_pst
operator|=
name|pst
operator|->
name|next
control|)
if|if
condition|(
name|prev_pst
operator|->
name|next
operator|==
name|pst
condition|)
name|prev_pst
operator|->
name|next
operator|=
name|pst
operator|->
name|next
expr_stmt|;
comment|/* Next, put it on a free list for recycling */
name|pst
operator|->
name|next
operator|=
name|pst
operator|->
name|objfile
operator|->
name|free_psymtabs
expr_stmt|;
name|pst
operator|->
name|objfile
operator|->
name|free_psymtabs
operator|=
name|pst
expr_stmt|;
comment|/* Indicate that psymtab was thrown away.  */
name|pst
operator|=
operator|(
expr|struct
name|partial_symtab
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
return|return
name|pst
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|swap_sym
name|PARAMS
argument_list|(
operator|(
expr|struct
name|internal_syment
operator|*
operator|,
expr|union
name|internal_auxent
operator|*
operator|,
name|char
operator|*
operator|*
operator|,
name|char
operator|*
operator|*
operator|,
name|unsigned
name|int
operator|*
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Swap raw symbol at *RAW and put the name in *NAME, the symbol in    *SYMBOL, the first auxent in *AUX.  Advance *RAW and *SYMNUMP over    the symbol and its auxents.  */
end_comment

begin_function
specifier|static
name|void
name|swap_sym
parameter_list|(
name|symbol
parameter_list|,
name|aux
parameter_list|,
name|name
parameter_list|,
name|raw
parameter_list|,
name|symnump
parameter_list|,
name|objfile
parameter_list|)
name|struct
name|internal_syment
modifier|*
name|symbol
decl_stmt|;
name|union
name|internal_auxent
modifier|*
name|aux
decl_stmt|;
name|char
modifier|*
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
modifier|*
name|raw
decl_stmt|;
name|unsigned
name|int
modifier|*
name|symnump
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|bfd_coff_swap_sym_in
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
operator|*
name|raw
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbol
operator|->
name|n_zeroes
condition|)
block|{
comment|/* If it's exactly E_SYMNMLEN characters long it isn't 	 '\0'-terminated.  */
if|if
condition|(
name|symbol
operator|->
name|n_name
index|[
name|E_SYMNMLEN
operator|-
literal|1
index|]
operator|!=
literal|'\0'
condition|)
block|{
comment|/* FIXME: wastes memory for symbols which we don't end up putting 	     into the minimal symbols.  */
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|psymbol_obstack
argument_list|,
name|E_SYMNMLEN
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|p
argument_list|,
name|symbol
operator|->
name|n_name
argument_list|,
name|E_SYMNMLEN
argument_list|)
expr_stmt|;
name|p
index|[
name|E_SYMNMLEN
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|name
operator|=
name|p
expr_stmt|;
block|}
else|else
comment|/* Point to the unswapped name as that persists as long as the 	   objfile does.  */
operator|*
name|name
operator|=
operator|(
operator|(
expr|struct
name|external_syment
operator|*
operator|)
operator|*
name|raw
operator|)
operator|->
name|e
operator|.
name|e_name
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|symbol
operator|->
name|n_sclass
operator|&
literal|0x80
condition|)
block|{
operator|*
name|name
operator|=
operator|(
operator|(
expr|struct
name|coff_symfile_info
operator|*
operator|)
name|objfile
operator|->
name|sym_private
operator|)
operator|->
name|debugsec
operator|+
name|symbol
operator|->
name|n_offset
expr_stmt|;
block|}
else|else
block|{
operator|*
name|name
operator|=
operator|(
operator|(
expr|struct
name|coff_symfile_info
operator|*
operator|)
name|objfile
operator|->
name|sym_private
operator|)
operator|->
name|strtbl
operator|+
name|symbol
operator|->
name|n_offset
expr_stmt|;
block|}
operator|++
operator|*
name|symnump
expr_stmt|;
operator|*
name|raw
operator|+=
name|coff_data
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|)
operator|->
name|local_symesz
expr_stmt|;
if|if
condition|(
name|symbol
operator|->
name|n_numaux
operator|>
literal|0
condition|)
block|{
name|bfd_coff_swap_aux_in
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
operator|*
name|raw
argument_list|,
name|symbol
operator|->
name|n_type
argument_list|,
name|symbol
operator|->
name|n_sclass
argument_list|,
literal|0
argument_list|,
name|symbol
operator|->
name|n_numaux
argument_list|,
name|aux
argument_list|)
expr_stmt|;
operator|*
name|symnump
operator|+=
name|symbol
operator|->
name|n_numaux
expr_stmt|;
operator|*
name|raw
operator|+=
name|coff_data
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|)
operator|->
name|local_symesz
operator|*
name|symbol
operator|->
name|n_numaux
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|scan_xcoff_symtab
parameter_list|(
name|section_offsets
parameter_list|,
name|objfile
parameter_list|)
name|struct
name|section_offsets
modifier|*
name|section_offsets
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|int
name|toc_offset
init|=
literal|0
decl_stmt|;
comment|/* toc offset value in data section. */
name|char
modifier|*
name|filestring
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|namestring
decl_stmt|;
name|int
name|past_first_source_file
init|=
literal|0
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|unsigned
name|int
name|nsyms
decl_stmt|;
comment|/* Current partial symtab */
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
comment|/* List of current psymtab's include files */
name|char
modifier|*
modifier|*
name|psymtab_include_list
decl_stmt|;
name|int
name|includes_allocated
decl_stmt|;
name|int
name|includes_used
decl_stmt|;
comment|/* Index within current psymtab dependency list */
name|struct
name|partial_symtab
modifier|*
modifier|*
name|dependency_list
decl_stmt|;
name|int
name|dependencies_used
decl_stmt|,
name|dependencies_allocated
decl_stmt|;
name|char
modifier|*
name|sraw_symbol
decl_stmt|;
name|struct
name|internal_syment
name|symbol
decl_stmt|;
name|union
name|internal_auxent
name|main_aux
decl_stmt|;
name|unsigned
name|int
name|ssymnum
decl_stmt|;
name|char
modifier|*
name|last_csect_name
init|=
name|NULL
decl_stmt|;
comment|/* last seen csect's name and value */
name|CORE_ADDR
name|last_csect_val
init|=
literal|0
decl_stmt|;
name|int
name|last_csect_sec
init|=
literal|0
decl_stmt|;
name|int
name|misc_func_recorded
init|=
literal|0
decl_stmt|;
comment|/* true if any misc. function */
name|pst
operator|=
operator|(
expr|struct
name|partial_symtab
operator|*
operator|)
literal|0
expr_stmt|;
name|includes_allocated
operator|=
literal|30
expr_stmt|;
name|includes_used
operator|=
literal|0
expr_stmt|;
name|psymtab_include_list
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|alloca
argument_list|(
name|includes_allocated
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|dependencies_allocated
operator|=
literal|30
expr_stmt|;
name|dependencies_used
operator|=
literal|0
expr_stmt|;
name|dependency_list
operator|=
operator|(
expr|struct
name|partial_symtab
operator|*
operator|*
operator|)
name|alloca
argument_list|(
name|dependencies_allocated
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|partial_symtab
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|last_source_file
operator|=
name|NULL
expr_stmt|;
name|abfd
operator|=
name|objfile
operator|->
name|obfd
expr_stmt|;
name|sraw_symbol
operator|=
operator|(
operator|(
expr|struct
name|coff_symfile_info
operator|*
operator|)
name|objfile
operator|->
name|sym_private
operator|)
operator|->
name|symtbl
expr_stmt|;
name|nsyms
operator|=
operator|(
operator|(
expr|struct
name|coff_symfile_info
operator|*
operator|)
name|objfile
operator|->
name|sym_private
operator|)
operator|->
name|symtbl_num_syms
expr_stmt|;
name|ssymnum
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|ssymnum
operator|<
name|nsyms
condition|)
block|{
name|int
name|sclass
init|=
operator|(
operator|(
expr|struct
name|external_syment
operator|*
operator|)
name|sraw_symbol
operator|)
operator|->
name|e_sclass
index|[
literal|0
index|]
operator|&
literal|0xff
decl_stmt|;
comment|/* This is the type we pass to partial-stab.h.  A less kludgy solution 	 would be to break out partial-stab.h into its various parts--shuffle 	 off the DBXREAD_ONLY stuff to dbxread.c, and make separate 	 pstab-norm.h (for most types), pstab-sol.h (for N_SOL), etc.  */
name|int
name|stype
decl_stmt|;
name|QUIT
expr_stmt|;
switch|switch
condition|(
name|sclass
condition|)
block|{
case|case
name|C_EXT
case|:
case|case
name|C_HIDEXT
case|:
block|{
comment|/* The CSECT auxent--always the last auxent.  */
name|union
name|internal_auxent
name|csect_aux
decl_stmt|;
name|unsigned
name|int
name|symnum_before
init|=
name|ssymnum
decl_stmt|;
name|swap_sym
argument_list|(
operator|&
name|symbol
argument_list|,
operator|&
name|main_aux
argument_list|,
operator|&
name|namestring
argument_list|,
operator|&
name|sraw_symbol
argument_list|,
operator|&
name|ssymnum
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbol
operator|.
name|n_numaux
operator|>
literal|1
condition|)
block|{
name|bfd_coff_swap_aux_in
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|sraw_symbol
operator|-
name|coff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|local_symesz
argument_list|,
name|symbol
operator|.
name|n_type
argument_list|,
name|symbol
operator|.
name|n_sclass
argument_list|,
name|symbol
operator|.
name|n_numaux
operator|-
literal|1
argument_list|,
name|symbol
operator|.
name|n_numaux
argument_list|,
operator|&
name|csect_aux
argument_list|)
expr_stmt|;
block|}
else|else
name|csect_aux
operator|=
name|main_aux
expr_stmt|;
comment|/* If symbol name starts with ".$" or "$", ignore it.  */
if|if
condition|(
name|namestring
index|[
literal|0
index|]
operator|==
literal|'$'
operator|||
operator|(
name|namestring
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|namestring
index|[
literal|1
index|]
operator|==
literal|'$'
operator|)
condition|)
break|break;
switch|switch
condition|(
name|csect_aux
operator|.
name|x_csect
operator|.
name|x_smtyp
operator|&
literal|0x7
condition|)
block|{
case|case
name|XTY_SD
case|:
switch|switch
condition|(
name|csect_aux
operator|.
name|x_csect
operator|.
name|x_smclas
condition|)
block|{
case|case
name|XMC_PR
case|:
if|if
condition|(
name|last_csect_name
condition|)
block|{
comment|/* If no misc. function recorded in the last 			   seen csect, enter it as a function. This 			   will take care of functions like strcmp() 			   compiled by xlc.  */
if|if
condition|(
operator|!
name|misc_func_recorded
condition|)
block|{
name|RECORD_MINIMAL_SYMBOL
argument_list|(
name|last_csect_name
argument_list|,
name|last_csect_val
argument_list|,
name|mst_text
argument_list|,
name|last_csect_sec
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pst
operator|!=
name|NULL
condition|)
block|{
comment|/* We have to allocate one psymtab for 			       each program csect, because their text 			       sections need not be adjacent.  */
name|xcoff_end_psymtab
argument_list|(
name|pst
argument_list|,
name|psymtab_include_list
argument_list|,
name|includes_used
argument_list|,
name|symnum_before
argument_list|,
name|dependency_list
argument_list|,
name|dependencies_used
argument_list|)
expr_stmt|;
name|includes_used
operator|=
literal|0
expr_stmt|;
name|dependencies_used
operator|=
literal|0
expr_stmt|;
comment|/* Give all psymtabs for this source file the same 			       name.  */
name|pst
operator|=
name|xcoff_start_psymtab
argument_list|(
name|objfile
argument_list|,
name|section_offsets
argument_list|,
name|filestring
argument_list|,
name|symnum_before
argument_list|,
name|objfile
operator|->
name|global_psymbols
operator|.
name|next
argument_list|,
name|objfile
operator|->
name|static_psymbols
operator|.
name|next
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|namestring
operator|&&
name|namestring
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
block|{
name|last_csect_name
operator|=
name|namestring
expr_stmt|;
name|last_csect_val
operator|=
name|symbol
operator|.
name|n_value
expr_stmt|;
name|last_csect_sec
operator|=
name|secnum_to_section
argument_list|(
name|symbol
operator|.
name|n_scnum
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pst
operator|!=
name|NULL
condition|)
block|{
name|CORE_ADDR
name|highval
init|=
name|symbol
operator|.
name|n_value
operator|+
name|csect_aux
operator|.
name|x_csect
operator|.
name|x_scnlen
operator|.
name|l
decl_stmt|;
if|if
condition|(
name|highval
operator|>
name|pst
operator|->
name|texthigh
condition|)
name|pst
operator|->
name|texthigh
operator|=
name|highval
expr_stmt|;
if|if
condition|(
name|pst
operator|->
name|textlow
operator|==
literal|0
operator|||
name|symbol
operator|.
name|n_value
operator|<
name|pst
operator|->
name|textlow
condition|)
name|pst
operator|->
name|textlow
operator|=
name|symbol
operator|.
name|n_value
expr_stmt|;
block|}
name|misc_func_recorded
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|XMC_RW
case|:
comment|/* Data variables are recorded in the minimal symbol 		       table, except for section symbols.  */
if|if
condition|(
operator|*
name|namestring
operator|!=
literal|'.'
condition|)
name|prim_record_minimal_symbol_and_info
argument_list|(
name|namestring
argument_list|,
name|symbol
operator|.
name|n_value
argument_list|,
name|sclass
operator|==
name|C_HIDEXT
condition|?
name|mst_file_data
else|:
name|mst_data
argument_list|,
name|NULL
argument_list|,
name|secnum_to_section
argument_list|(
name|symbol
operator|.
name|n_scnum
argument_list|,
name|objfile
argument_list|)
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|XMC_TC0
case|:
if|if
condition|(
name|toc_offset
condition|)
name|warning
argument_list|(
literal|"More than one XMC_TC0 symbol found."
argument_list|)
expr_stmt|;
name|toc_offset
operator|=
name|symbol
operator|.
name|n_value
expr_stmt|;
break|break;
case|case
name|XMC_TC
case|:
comment|/* These symbols tell us where the TOC entry for a 		       variable is, not the variable itself.  */
break|break;
default|default:
break|break;
block|}
break|break;
case|case
name|XTY_LD
case|:
switch|switch
condition|(
name|csect_aux
operator|.
name|x_csect
operator|.
name|x_smclas
condition|)
block|{
case|case
name|XMC_PR
case|:
comment|/* A function entry point.  */
if|if
condition|(
name|first_fun_line_offset
operator|==
literal|0
operator|&&
name|symbol
operator|.
name|n_numaux
operator|>
literal|1
condition|)
name|first_fun_line_offset
operator|=
name|main_aux
operator|.
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_lnnoptr
expr_stmt|;
name|RECORD_MINIMAL_SYMBOL
argument_list|(
name|namestring
argument_list|,
name|symbol
operator|.
name|n_value
argument_list|,
name|sclass
operator|==
name|C_HIDEXT
condition|?
name|mst_file_text
else|:
name|mst_text
argument_list|,
name|secnum_to_section
argument_list|(
name|symbol
operator|.
name|n_scnum
argument_list|,
name|objfile
argument_list|)
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|XMC_GL
case|:
comment|/* shared library function trampoline code entry 		       point. */
comment|/* record trampoline code entries as 		       mst_solib_trampoline symbol.  When we lookup mst 		       symbols, we will choose mst_text over 		       mst_solib_trampoline. */
name|RECORD_MINIMAL_SYMBOL
argument_list|(
name|namestring
argument_list|,
name|symbol
operator|.
name|n_value
argument_list|,
name|mst_solib_trampoline
argument_list|,
name|secnum_to_section
argument_list|(
name|symbol
operator|.
name|n_scnum
argument_list|,
name|objfile
argument_list|)
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|XMC_DS
case|:
comment|/* The symbols often have the same names as 		       debug symbols for functions, and confuse 		       lookup_symbol.  */
break|break;
default|default:
comment|/* xlc puts each variable in a separate csect, 		       so we get an XTY_SD for each variable.  But 		       gcc puts several variables in a csect, so 		       that each variable only gets an XTY_LD.  We 		       still need to record them.  This will 		       typically be XMC_RW; I suspect XMC_RO and 		       XMC_BS might be possible too.  */
if|if
condition|(
operator|*
name|namestring
operator|!=
literal|'.'
condition|)
name|prim_record_minimal_symbol_and_info
argument_list|(
name|namestring
argument_list|,
name|symbol
operator|.
name|n_value
argument_list|,
name|sclass
operator|==
name|C_HIDEXT
condition|?
name|mst_file_data
else|:
name|mst_data
argument_list|,
name|NULL
argument_list|,
name|secnum_to_section
argument_list|(
name|symbol
operator|.
name|n_scnum
argument_list|,
name|objfile
argument_list|)
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|XTY_CM
case|:
switch|switch
condition|(
name|csect_aux
operator|.
name|x_csect
operator|.
name|x_smclas
condition|)
block|{
case|case
name|XMC_RW
case|:
case|case
name|XMC_BS
case|:
comment|/* Common variables are recorded in the minimal symbol 		       table, except for section symbols.  */
if|if
condition|(
operator|*
name|namestring
operator|!=
literal|'.'
condition|)
name|prim_record_minimal_symbol_and_info
argument_list|(
name|namestring
argument_list|,
name|symbol
operator|.
name|n_value
argument_list|,
name|sclass
operator|==
name|C_HIDEXT
condition|?
name|mst_file_bss
else|:
name|mst_bss
argument_list|,
name|NULL
argument_list|,
name|secnum_to_section
argument_list|(
name|symbol
operator|.
name|n_scnum
argument_list|,
name|objfile
argument_list|)
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
break|break;
block|}
block|}
break|break;
case|case
name|C_FILE
case|:
block|{
name|unsigned
name|int
name|symnum_before
decl_stmt|;
name|symnum_before
operator|=
name|ssymnum
expr_stmt|;
name|swap_sym
argument_list|(
operator|&
name|symbol
argument_list|,
operator|&
name|main_aux
argument_list|,
operator|&
name|namestring
argument_list|,
operator|&
name|sraw_symbol
argument_list|,
operator|&
name|ssymnum
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* See if the last csect needs to be recorded.  */
if|if
condition|(
name|last_csect_name
operator|&&
operator|!
name|misc_func_recorded
condition|)
block|{
comment|/* If no misc. function recorded in the last seen csect, enter 		   it as a function.  This will take care of functions like 		   strcmp() compiled by xlc.  */
name|RECORD_MINIMAL_SYMBOL
argument_list|(
name|last_csect_name
argument_list|,
name|last_csect_val
argument_list|,
name|mst_text
argument_list|,
name|last_csect_sec
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pst
condition|)
block|{
name|xcoff_end_psymtab
argument_list|(
name|pst
argument_list|,
name|psymtab_include_list
argument_list|,
name|includes_used
argument_list|,
name|symnum_before
argument_list|,
name|dependency_list
argument_list|,
name|dependencies_used
argument_list|)
expr_stmt|;
name|includes_used
operator|=
literal|0
expr_stmt|;
name|dependencies_used
operator|=
literal|0
expr_stmt|;
block|}
name|first_fun_line_offset
operator|=
literal|0
expr_stmt|;
comment|/* XCOFF, according to the AIX 3.2 documentation, puts the 	       filename in cs->c_name.  But xlc 1.3.0.2 has decided to 	       do things the standard COFF way and put it in the auxent. 	       We use the auxent if the symbol is ".file" and an auxent 	       exists, otherwise use the symbol itself.  */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|namestring
argument_list|,
literal|".file"
argument_list|)
operator|&&
name|symbol
operator|.
name|n_numaux
operator|>
literal|0
condition|)
block|{
name|filestring
operator|=
name|coff_getfilename
argument_list|(
operator|&
name|main_aux
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
else|else
name|filestring
operator|=
name|namestring
expr_stmt|;
name|pst
operator|=
name|xcoff_start_psymtab
argument_list|(
name|objfile
argument_list|,
name|section_offsets
argument_list|,
name|filestring
argument_list|,
name|symnum_before
argument_list|,
name|objfile
operator|->
name|global_psymbols
operator|.
name|next
argument_list|,
name|objfile
operator|->
name|static_psymbols
operator|.
name|next
argument_list|)
expr_stmt|;
name|last_csect_name
operator|=
name|NULL
expr_stmt|;
block|}
break|break;
default|default:
block|{
specifier|static
name|struct
name|complaint
name|msg
init|=
block|{
literal|"Storage class %d not recognized during scan"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|complain
argument_list|(
operator|&
name|msg
argument_list|,
name|sclass
argument_list|)
expr_stmt|;
block|}
comment|/* FALLTHROUGH */
comment|/* C_FCN is .bf and .ef symbols.  I think it is sufficient 	     to handle only the C_FUN and C_EXT.  */
case|case
name|C_FCN
case|:
case|case
name|C_BSTAT
case|:
case|case
name|C_ESTAT
case|:
case|case
name|C_ARG
case|:
case|case
name|C_REGPARM
case|:
case|case
name|C_REG
case|:
case|case
name|C_TPDEF
case|:
case|case
name|C_STRTAG
case|:
case|case
name|C_UNTAG
case|:
case|case
name|C_ENTAG
case|:
case|case
name|C_LABEL
case|:
case|case
name|C_NULL
case|:
comment|/* C_EINCL means we are switching back to the main file.  But there 	     is no reason to care; the only thing we want to know about 	     includes is the names of all the included (.h) files.  */
case|case
name|C_EINCL
case|:
case|case
name|C_BLOCK
case|:
comment|/* I don't think C_STAT is used in xcoff; C_HIDEXT appears to be 	     used instead.  */
case|case
name|C_STAT
case|:
comment|/* I don't think the name of the common block (as opposed to the 	     variables within it) is something which is user visible 	     currently.  */
case|case
name|C_BCOMM
case|:
case|case
name|C_ECOMM
case|:
case|case
name|C_PSYM
case|:
case|case
name|C_RPSYM
case|:
comment|/* I think we can ignore C_LSYM; types on xcoff seem to use C_DECL 	     so C_LSYM would appear to be only for locals.  */
case|case
name|C_LSYM
case|:
case|case
name|C_AUTO
case|:
case|case
name|C_RSYM
case|:
block|{
comment|/* We probably could save a few instructions by assuming that 	       C_LSYM, C_PSYM, etc., never have auxents.  */
name|int
name|naux1
init|=
operator|(
operator|(
expr|struct
name|external_syment
operator|*
operator|)
name|sraw_symbol
operator|)
operator|->
name|e_numaux
index|[
literal|0
index|]
operator|+
literal|1
decl_stmt|;
name|ssymnum
operator|+=
name|naux1
expr_stmt|;
name|sraw_symbol
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|external_syment
argument_list|)
operator|*
name|naux1
expr_stmt|;
block|}
break|break;
case|case
name|C_BINCL
case|:
name|stype
operator|=
name|N_SOL
expr_stmt|;
goto|goto
name|pstab
goto|;
case|case
name|C_FUN
case|:
comment|/* The value of the C_FUN is not the address of the function (it 	     appears to be the address before linking), but as long as it 	     is smaller than the actual address, then find_pc_partial_function 	     will use the minimal symbols instead.  I hope.  */
case|case
name|C_GSYM
case|:
case|case
name|C_ECOML
case|:
case|case
name|C_DECL
case|:
case|case
name|C_STSYM
case|:
name|stype
operator|=
name|N_LSYM
expr_stmt|;
name|pstab
label|:
empty_stmt|;
name|swap_sym
argument_list|(
operator|&
name|symbol
argument_list|,
operator|&
name|main_aux
argument_list|,
operator|&
name|namestring
argument_list|,
operator|&
name|sraw_symbol
argument_list|,
operator|&
name|ssymnum
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
define|#
directive|define
name|CUR_SYMBOL_TYPE
value|stype
define|#
directive|define
name|CUR_SYMBOL_VALUE
value|symbol.n_value
comment|/* START_PSYMTAB and END_PSYMTAB are never used, because they are only    called from DBXREAD_ONLY or N_SO code.  Likewise for the symnum    variable.  */
define|#
directive|define
name|START_PSYMTAB
parameter_list|(
name|ofile
parameter_list|,
name|secoff
parameter_list|,
name|fname
parameter_list|,
name|low
parameter_list|,
name|symoff
parameter_list|,
name|global_syms
parameter_list|,
name|static_syms
parameter_list|)
value|0
define|#
directive|define
name|END_PSYMTAB
parameter_list|(
name|pst
parameter_list|,
name|ilist
parameter_list|,
name|ninc
parameter_list|,
name|c_off
parameter_list|,
name|c_text
parameter_list|,
name|dep_list
parameter_list|,
name|n_deps
parameter_list|)
define|\
value|do {} while (0)
comment|/* We have already set the namestring.  */
define|#
directive|define
name|SET_NAMESTRING
parameter_list|()
comment|/* */
include|#
directive|include
file|"partial-stab.h"
block|}
block|}
if|if
condition|(
name|pst
condition|)
block|{
name|xcoff_end_psymtab
argument_list|(
name|pst
argument_list|,
name|psymtab_include_list
argument_list|,
name|includes_used
argument_list|,
name|ssymnum
argument_list|,
name|dependency_list
argument_list|,
name|dependencies_used
argument_list|)
expr_stmt|;
block|}
comment|/* Record the toc offset value of this symbol table into ldinfo structure.      If no XMC_TC0 is found, toc_offset should be zero. Another place to obtain      this information would be file auxiliary header. */
ifndef|#
directive|ifndef
name|FAKING_RS6000
name|xcoff_add_toc_to_loadinfo
argument_list|(
name|toc_offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Scan and build partial symbols for a symbol file.    We have been initialized by a call to dbx_symfile_init, which     put all the relevant info into a "struct dbx_symfile_info",    hung off the objfile structure.     SECTION_OFFSETS contains offsets relative to which the symbols in the    various sections are (depending where the sections were actually loaded).    MAINLINE is true if we are reading the main symbol    table (as opposed to a shared lib or dynamically loaded file).  */
end_comment

begin_function
specifier|static
name|void
name|xcoff_initial_scan
parameter_list|(
name|objfile
parameter_list|,
name|section_offsets
parameter_list|,
name|mainline
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|section_offsets
modifier|*
name|section_offsets
decl_stmt|;
name|int
name|mainline
decl_stmt|;
comment|/* FIXME comments above */
block|{
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|int
name|val
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|back_to
decl_stmt|;
name|int
name|num_symbols
decl_stmt|;
comment|/* # of symbols */
name|file_ptr
name|symtab_offset
decl_stmt|;
comment|/* symbol table and */
name|file_ptr
name|stringtab_offset
decl_stmt|;
comment|/* string table file offsets */
name|struct
name|coff_symfile_info
modifier|*
name|info
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
ifndef|#
directive|ifndef
name|FAKING_RS6000
comment|/* Initialize load info structure. */
if|if
condition|(
name|mainline
condition|)
name|xcoff_init_loadinfo
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|info
operator|=
operator|(
expr|struct
name|coff_symfile_info
operator|*
operator|)
name|objfile
operator|->
name|sym_private
expr_stmt|;
name|symfile_bfd
operator|=
name|abfd
operator|=
name|objfile
operator|->
name|obfd
expr_stmt|;
name|name
operator|=
name|objfile
operator|->
name|name
expr_stmt|;
name|num_symbols
operator|=
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* # of symbols */
name|symtab_offset
operator|=
name|obj_sym_filepos
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* symbol table file offset */
name|stringtab_offset
operator|=
name|symtab_offset
operator|+
name|num_symbols
operator|*
name|coff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|local_symesz
expr_stmt|;
name|info
operator|->
name|min_lineno_offset
operator|=
literal|0
expr_stmt|;
name|info
operator|->
name|max_lineno_offset
operator|=
literal|0
expr_stmt|;
name|bfd_map_over_sections
argument_list|(
name|abfd
argument_list|,
name|find_linenos
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_symbols
operator|>
literal|0
condition|)
block|{
comment|/* Read the string table.  */
name|init_stringtab
argument_list|(
name|abfd
argument_list|,
name|stringtab_offset
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* Read the .debug section, if present.  */
block|{
name|sec_ptr
name|secp
decl_stmt|;
name|bfd_size_type
name|length
decl_stmt|;
name|char
modifier|*
name|debugsec
init|=
name|NULL
decl_stmt|;
name|secp
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".debug"
argument_list|)
expr_stmt|;
if|if
condition|(
name|secp
condition|)
block|{
name|length
operator|=
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|secp
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
condition|)
block|{
name|debugsec
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|secp
argument_list|,
name|debugsec
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|length
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"Error reading .debug section of `%s': %s"
argument_list|,
name|name
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
operator|(
operator|(
expr|struct
name|coff_symfile_info
operator|*
operator|)
name|objfile
operator|->
name|sym_private
operator|)
operator|->
name|debugsec
operator|=
name|debugsec
expr_stmt|;
block|}
block|}
comment|/* Read the symbols.  We keep them in core because we will want to      access them randomly in read_symbol*.  */
name|val
operator|=
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|symtab_offset
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"Error reading symbols from %s: %s"
argument_list|,
name|name
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|=
name|coff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|local_symesz
operator|*
name|num_symbols
expr_stmt|;
operator|(
operator|(
expr|struct
name|coff_symfile_info
operator|*
operator|)
name|objfile
operator|->
name|sym_private
operator|)
operator|->
name|symtbl
operator|=
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|,
name|size
argument_list|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|coff_symfile_info
operator|*
operator|)
name|objfile
operator|->
name|sym_private
operator|)
operator|->
name|symtbl_num_syms
operator|=
name|num_symbols
expr_stmt|;
name|val
operator|=
name|bfd_read
argument_list|(
operator|(
operator|(
expr|struct
name|coff_symfile_info
operator|*
operator|)
name|objfile
operator|->
name|sym_private
operator|)
operator|->
name|symtbl
argument_list|,
name|size
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|size
condition|)
name|perror_with_name
argument_list|(
literal|"reading symbol table"
argument_list|)
expr_stmt|;
comment|/* If we are reinitializing, or if we have never loaded syms yet, init */
if|if
condition|(
name|mainline
operator|||
name|objfile
operator|->
name|global_psymbols
operator|.
name|size
operator|==
literal|0
operator|||
name|objfile
operator|->
name|static_psymbols
operator|.
name|size
operator|==
literal|0
condition|)
comment|/* I'm not sure how how good num_symbols is; the rule of thumb in        init_psymbol_list was developed for a.out.  On the one hand,        num_symbols includes auxents.  On the other hand, it doesn't        include N_SLINE.  */
name|init_psymbol_list
argument_list|(
name|objfile
argument_list|,
name|num_symbols
argument_list|)
expr_stmt|;
name|pending_blocks
operator|=
literal|0
expr_stmt|;
name|back_to
operator|=
name|make_cleanup
argument_list|(
name|really_free_pendings
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|init_minimal_symbol_collection
argument_list|()
expr_stmt|;
name|make_cleanup
argument_list|(
name|discard_minimal_symbols
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Now that the symbol table data of the executable file are all in core,      process them and define symbols accordingly.  */
name|scan_xcoff_symtab
argument_list|(
name|section_offsets
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* Install any minimal symbols that have been collected as the current      minimal symbols for this objfile. */
name|install_minimal_symbols
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|back_to
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|struct
name|section_offsets
modifier|*
name|xcoff_symfile_offsets
parameter_list|(
name|objfile
parameter_list|,
name|addr
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
block|{
name|struct
name|section_offsets
modifier|*
name|section_offsets
decl_stmt|;
name|int
name|i
decl_stmt|;
name|objfile
operator|->
name|num_sections
operator|=
name|SECT_OFF_MAX
expr_stmt|;
name|section_offsets
operator|=
operator|(
expr|struct
name|section_offsets
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|psymbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|section_offsets
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|section_offsets
operator|->
name|offsets
argument_list|)
operator|*
name|objfile
operator|->
name|num_sections
argument_list|)
expr_stmt|;
comment|/* syms_from_objfile kindly subtracts from addr the bfd_section_vma      of the .text section.  This strikes me as wrong--whether the      offset to be applied to symbol reading is relative to the start      address of the section depends on the symbol format.  In any      event, this whole "addr" concept is pretty broken (it doesn't      handle any section but .text sensibly), so just ignore the addr      parameter and use 0.  rs6000-nat.c will set the correct section      offsets via objfile_relocate.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|objfile
operator|->
name|num_sections
condition|;
operator|++
name|i
control|)
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|i
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|section_offsets
return|;
block|}
end_function

begin_comment
comment|/* Register our ability to parse symbols for xcoff BFD files.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sym_fns
name|xcoff_sym_fns
init|=
block|{
comment|/* Because the bfd uses coff_flavour, we need to specially kludge      the flavour.  It is possible that coff and xcoff should be merged as      they do have fundamental similarities (for example, the extra storage      classes used for stabs could presumably be recognized in any COFF file).      However, in addition to obvious things like all the csect hair, there are      some subtler differences between xcoffread.c and coffread.c, notably      the fact that coffread.c has no need to read in all the symbols, but      xcoffread.c reads all the symbols and does in fact randomly access them      (in C_BSTAT and line number processing).  */
operator|(
expr|enum
name|bfd_flavour
operator|)
operator|-
literal|1
block|,
name|xcoff_new_init
block|,
comment|/* sym_new_init: init anything gbl to entire symtab */
name|xcoff_symfile_init
block|,
comment|/* sym_init: read initial info, setup for sym_read() */
name|xcoff_initial_scan
block|,
comment|/* sym_read: read a symbol file into symtab */
name|xcoff_symfile_finish
block|,
comment|/* sym_finish: finished with file, cleanup */
name|xcoff_symfile_offsets
block|,
comment|/* sym_offsets: xlate offsets ext->int form */
name|NULL
comment|/* next: pointer to next struct sym_fns */
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|_initialize_xcoffread
parameter_list|()
block|{
name|add_symtab_fns
argument_list|(
operator|&
name|xcoff_sym_fns
argument_list|)
expr_stmt|;
name|func_symbol_type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FUNC
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"<function, no debug info>"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|TYPE_TARGET_TYPE
argument_list|(
name|func_symbol_type
argument_list|)
operator|=
name|builtin_type_int
expr_stmt|;
name|var_symbol_type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_INT_BIT
operator|/
name|HOST_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"<variable, no debug info>"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

