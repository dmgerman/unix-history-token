begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Frame unwinder for frames with DWARF Call Frame Information.     Copyright 2003, 2004 Free Software Foundation, Inc.     Contributed by Mark Kettenis.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"dwarf2expr.h"
end_include

begin_include
include|#
directive|include
file|"elf/dwarf2.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"frame-base.h"
end_include

begin_include
include|#
directive|include
file|"frame-unwind.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_include
include|#
directive|include
file|"gdb_assert.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"complaints.h"
end_include

begin_include
include|#
directive|include
file|"dwarf2-frame.h"
end_include

begin_comment
comment|/* Call Frame Information (CFI).  */
end_comment

begin_comment
comment|/* Common Information Entry (CIE).  */
end_comment

begin_struct
struct|struct
name|dwarf2_cie
block|{
comment|/* Offset into the .debug_frame section where this CIE was found.      Used to identify this CIE.  */
name|ULONGEST
name|cie_pointer
decl_stmt|;
comment|/* Constant that is factored out of all advance location      instructions.  */
name|ULONGEST
name|code_alignment_factor
decl_stmt|;
comment|/* Constants that is factored out of all offset instructions.  */
name|LONGEST
name|data_alignment_factor
decl_stmt|;
comment|/* Return address column.  */
name|ULONGEST
name|return_address_register
decl_stmt|;
comment|/* Instruction sequence to initialize a register set.  */
name|unsigned
name|char
modifier|*
name|initial_instructions
decl_stmt|;
name|unsigned
name|char
modifier|*
name|end
decl_stmt|;
comment|/* Encoding of addresses.  */
name|unsigned
name|char
name|encoding
decl_stmt|;
comment|/* True if a 'z' augmentation existed.  */
name|unsigned
name|char
name|saw_z_augmentation
decl_stmt|;
name|struct
name|dwarf2_cie
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Frame Description Entry (FDE).  */
end_comment

begin_struct
struct|struct
name|dwarf2_fde
block|{
comment|/* CIE for this FDE.  */
name|struct
name|dwarf2_cie
modifier|*
name|cie
decl_stmt|;
comment|/* First location associated with this FDE.  */
name|CORE_ADDR
name|initial_location
decl_stmt|;
comment|/* Number of bytes of program instructions described by this FDE.  */
name|CORE_ADDR
name|address_range
decl_stmt|;
comment|/* Instruction sequence.  */
name|unsigned
name|char
modifier|*
name|instructions
decl_stmt|;
name|unsigned
name|char
modifier|*
name|end
decl_stmt|;
name|struct
name|dwarf2_fde
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|struct
name|dwarf2_fde
modifier|*
name|dwarf2_frame_find_fde
parameter_list|(
name|CORE_ADDR
modifier|*
name|pc
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Structure describing a frame state.  */
end_comment

begin_struct
struct|struct
name|dwarf2_frame_state
block|{
comment|/* Each register save state can be described in terms of a CFA slot,      another register, or a location expression.  */
struct|struct
name|dwarf2_frame_state_reg_info
block|{
name|struct
name|dwarf2_frame_state_reg
modifier|*
name|reg
decl_stmt|;
name|int
name|num_regs
decl_stmt|;
comment|/* Used to implement DW_CFA_remember_state.  */
name|struct
name|dwarf2_frame_state_reg_info
modifier|*
name|prev
decl_stmt|;
block|}
name|regs
struct|;
name|LONGEST
name|cfa_offset
decl_stmt|;
name|ULONGEST
name|cfa_reg
decl_stmt|;
name|unsigned
name|char
modifier|*
name|cfa_exp
decl_stmt|;
enum|enum
block|{
name|CFA_UNSET
block|,
name|CFA_REG_OFFSET
block|,
name|CFA_EXP
block|}
name|cfa_how
enum|;
comment|/* The PC described by the current frame state.  */
name|CORE_ADDR
name|pc
decl_stmt|;
comment|/* Initial register set from the CIE.      Used to implement DW_CFA_restore.  */
name|struct
name|dwarf2_frame_state_reg_info
name|initial
decl_stmt|;
comment|/* The information we care about from the CIE.  */
name|LONGEST
name|data_align
decl_stmt|;
name|ULONGEST
name|code_align
decl_stmt|;
name|ULONGEST
name|retaddr_column
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Store the length the expression for the CFA in the `cfa_reg' field,    which is unused in that case.  */
end_comment

begin_define
define|#
directive|define
name|cfa_exp_len
value|cfa_reg
end_define

begin_comment
comment|/* Assert that the register set RS is large enough to store NUM_REGS    columns.  If necessary, enlarge the register set.  */
end_comment

begin_function
specifier|static
name|void
name|dwarf2_frame_state_alloc_regs
parameter_list|(
name|struct
name|dwarf2_frame_state_reg_info
modifier|*
name|rs
parameter_list|,
name|int
name|num_regs
parameter_list|)
block|{
name|size_t
name|size
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|dwarf2_frame_state_reg
argument_list|)
decl_stmt|;
if|if
condition|(
name|num_regs
operator|<=
name|rs
operator|->
name|num_regs
condition|)
return|return;
name|rs
operator|->
name|reg
operator|=
operator|(
expr|struct
name|dwarf2_frame_state_reg
operator|*
operator|)
name|xrealloc
argument_list|(
name|rs
operator|->
name|reg
argument_list|,
name|num_regs
operator|*
name|size
argument_list|)
expr_stmt|;
comment|/* Initialize newly allocated registers.  */
name|memset
argument_list|(
name|rs
operator|->
name|reg
operator|+
name|rs
operator|->
name|num_regs
argument_list|,
literal|0
argument_list|,
operator|(
name|num_regs
operator|-
name|rs
operator|->
name|num_regs
operator|)
operator|*
name|size
argument_list|)
expr_stmt|;
name|rs
operator|->
name|num_regs
operator|=
name|num_regs
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy the register columns in register set RS into newly allocated    memory and return a pointer to this newly created copy.  */
end_comment

begin_function
specifier|static
name|struct
name|dwarf2_frame_state_reg
modifier|*
name|dwarf2_frame_state_copy_regs
parameter_list|(
name|struct
name|dwarf2_frame_state_reg_info
modifier|*
name|rs
parameter_list|)
block|{
name|size_t
name|size
init|=
name|rs
operator|->
name|num_regs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|dwarf2_frame_state_reg_info
argument_list|)
decl_stmt|;
name|struct
name|dwarf2_frame_state_reg
modifier|*
name|reg
decl_stmt|;
name|reg
operator|=
operator|(
expr|struct
name|dwarf2_frame_state_reg
operator|*
operator|)
name|xmalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|reg
argument_list|,
name|rs
operator|->
name|reg
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|reg
return|;
block|}
end_function

begin_comment
comment|/* Release the memory allocated to register set RS.  */
end_comment

begin_function
specifier|static
name|void
name|dwarf2_frame_state_free_regs
parameter_list|(
name|struct
name|dwarf2_frame_state_reg_info
modifier|*
name|rs
parameter_list|)
block|{
if|if
condition|(
name|rs
condition|)
block|{
name|dwarf2_frame_state_free_regs
argument_list|(
name|rs
operator|->
name|prev
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|rs
operator|->
name|reg
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|rs
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Release the memory allocated to the frame state FS.  */
end_comment

begin_function
specifier|static
name|void
name|dwarf2_frame_state_free
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|dwarf2_frame_state
modifier|*
name|fs
init|=
name|p
decl_stmt|;
name|dwarf2_frame_state_free_regs
argument_list|(
name|fs
operator|->
name|initial
operator|.
name|prev
argument_list|)
expr_stmt|;
name|dwarf2_frame_state_free_regs
argument_list|(
name|fs
operator|->
name|regs
operator|.
name|prev
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|fs
operator|->
name|initial
operator|.
name|reg
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|fs
operator|->
name|regs
operator|.
name|reg
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|fs
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Helper functions for execute_stack_op.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|read_reg
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|int
name|reg
parameter_list|)
block|{
name|struct
name|frame_info
modifier|*
name|next_frame
init|=
operator|(
expr|struct
name|frame_info
operator|*
operator|)
name|baton
decl_stmt|;
name|struct
name|gdbarch
modifier|*
name|gdbarch
init|=
name|get_frame_arch
argument_list|(
name|next_frame
argument_list|)
decl_stmt|;
name|int
name|regnum
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|regnum
operator|=
name|DWARF2_REG_TO_REGNUM
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|register_size
argument_list|(
name|gdbarch
argument_list|,
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
name|frame_unwind_register
argument_list|(
name|next_frame
argument_list|,
name|regnum
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
name|extract_typed_address
argument_list|(
name|buf
argument_list|,
name|builtin_type_void_data_ptr
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|read_mem
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|CORE_ADDR
name|addr
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|read_memory
argument_list|(
name|addr
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|no_get_frame_base
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|unsigned
name|char
modifier|*
modifier|*
name|start
parameter_list|,
name|size_t
modifier|*
name|length
parameter_list|)
block|{
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"Support for DW_OP_fbreg is unimplemented"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|CORE_ADDR
name|no_get_tls_address
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|CORE_ADDR
name|offset
parameter_list|)
block|{
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"Support for DW_OP_GNU_push_tls_address is unimplemented"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|CORE_ADDR
name|execute_stack_op
parameter_list|(
name|unsigned
name|char
modifier|*
name|exp
parameter_list|,
name|ULONGEST
name|len
parameter_list|,
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|CORE_ADDR
name|initial
parameter_list|)
block|{
name|struct
name|dwarf_expr_context
modifier|*
name|ctx
decl_stmt|;
name|CORE_ADDR
name|result
decl_stmt|;
name|ctx
operator|=
name|new_dwarf_expr_context
argument_list|()
expr_stmt|;
name|ctx
operator|->
name|baton
operator|=
name|next_frame
expr_stmt|;
name|ctx
operator|->
name|read_reg
operator|=
name|read_reg
expr_stmt|;
name|ctx
operator|->
name|read_mem
operator|=
name|read_mem
expr_stmt|;
name|ctx
operator|->
name|get_frame_base
operator|=
name|no_get_frame_base
expr_stmt|;
name|ctx
operator|->
name|get_tls_address
operator|=
name|no_get_tls_address
expr_stmt|;
name|dwarf_expr_push
argument_list|(
name|ctx
argument_list|,
name|initial
argument_list|)
expr_stmt|;
name|dwarf_expr_eval
argument_list|(
name|ctx
argument_list|,
name|exp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|result
operator|=
name|dwarf_expr_fetch
argument_list|(
name|ctx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|in_reg
condition|)
name|result
operator|=
name|read_reg
argument_list|(
name|next_frame
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|free_dwarf_expr_context
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|execute_cfa_program
parameter_list|(
name|unsigned
name|char
modifier|*
name|insn_ptr
parameter_list|,
name|unsigned
name|char
modifier|*
name|insn_end
parameter_list|,
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|struct
name|dwarf2_frame_state
modifier|*
name|fs
parameter_list|)
block|{
name|CORE_ADDR
name|pc
init|=
name|frame_pc_unwind
argument_list|(
name|next_frame
argument_list|)
decl_stmt|;
name|int
name|bytes_read
decl_stmt|;
while|while
condition|(
name|insn_ptr
operator|<
name|insn_end
operator|&&
name|fs
operator|->
name|pc
operator|<=
name|pc
condition|)
block|{
name|unsigned
name|char
name|insn
init|=
operator|*
name|insn_ptr
operator|++
decl_stmt|;
name|ULONGEST
name|utmp
decl_stmt|,
name|reg
decl_stmt|;
name|LONGEST
name|offset
decl_stmt|;
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xc0
operator|)
operator|==
name|DW_CFA_advance_loc
condition|)
name|fs
operator|->
name|pc
operator|+=
operator|(
name|insn
operator|&
literal|0x3f
operator|)
operator|*
name|fs
operator|->
name|code_align
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xc0
operator|)
operator|==
name|DW_CFA_offset
condition|)
block|{
name|reg
operator|=
name|insn
operator|&
literal|0x3f
expr_stmt|;
name|insn_ptr
operator|=
name|read_uleb128
argument_list|(
name|insn_ptr
argument_list|,
name|insn_end
argument_list|,
operator|&
name|utmp
argument_list|)
expr_stmt|;
name|offset
operator|=
name|utmp
operator|*
name|fs
operator|->
name|data_align
expr_stmt|;
name|dwarf2_frame_state_alloc_regs
argument_list|(
operator|&
name|fs
operator|->
name|regs
argument_list|,
name|reg
operator|+
literal|1
argument_list|)
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|reg
index|]
operator|.
name|how
operator|=
name|DWARF2_FRAME_REG_SAVED_OFFSET
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|reg
index|]
operator|.
name|loc
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xc0
operator|)
operator|==
name|DW_CFA_restore
condition|)
block|{
name|gdb_assert
argument_list|(
name|fs
operator|->
name|initial
operator|.
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|insn
operator|&
literal|0x3f
expr_stmt|;
name|dwarf2_frame_state_alloc_regs
argument_list|(
operator|&
name|fs
operator|->
name|regs
argument_list|,
name|reg
operator|+
literal|1
argument_list|)
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|reg
index|]
operator|=
name|fs
operator|->
name|initial
operator|.
name|reg
index|[
name|reg
index|]
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|insn
condition|)
block|{
case|case
name|DW_CFA_set_loc
case|:
name|fs
operator|->
name|pc
operator|=
name|dwarf2_read_address
argument_list|(
name|insn_ptr
argument_list|,
name|insn_end
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|insn_ptr
operator|+=
name|bytes_read
expr_stmt|;
break|break;
case|case
name|DW_CFA_advance_loc1
case|:
name|utmp
operator|=
name|extract_unsigned_integer
argument_list|(
name|insn_ptr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fs
operator|->
name|pc
operator|+=
name|utmp
operator|*
name|fs
operator|->
name|code_align
expr_stmt|;
name|insn_ptr
operator|++
expr_stmt|;
break|break;
case|case
name|DW_CFA_advance_loc2
case|:
name|utmp
operator|=
name|extract_unsigned_integer
argument_list|(
name|insn_ptr
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|fs
operator|->
name|pc
operator|+=
name|utmp
operator|*
name|fs
operator|->
name|code_align
expr_stmt|;
name|insn_ptr
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|DW_CFA_advance_loc4
case|:
name|utmp
operator|=
name|extract_unsigned_integer
argument_list|(
name|insn_ptr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|fs
operator|->
name|pc
operator|+=
name|utmp
operator|*
name|fs
operator|->
name|code_align
expr_stmt|;
name|insn_ptr
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|DW_CFA_offset_extended
case|:
name|insn_ptr
operator|=
name|read_uleb128
argument_list|(
name|insn_ptr
argument_list|,
name|insn_end
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|insn_ptr
operator|=
name|read_uleb128
argument_list|(
name|insn_ptr
argument_list|,
name|insn_end
argument_list|,
operator|&
name|utmp
argument_list|)
expr_stmt|;
name|offset
operator|=
name|utmp
operator|*
name|fs
operator|->
name|data_align
expr_stmt|;
name|dwarf2_frame_state_alloc_regs
argument_list|(
operator|&
name|fs
operator|->
name|regs
argument_list|,
name|reg
operator|+
literal|1
argument_list|)
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|reg
index|]
operator|.
name|how
operator|=
name|DWARF2_FRAME_REG_SAVED_OFFSET
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|reg
index|]
operator|.
name|loc
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
break|break;
case|case
name|DW_CFA_restore_extended
case|:
name|gdb_assert
argument_list|(
name|fs
operator|->
name|initial
operator|.
name|reg
argument_list|)
expr_stmt|;
name|insn_ptr
operator|=
name|read_uleb128
argument_list|(
name|insn_ptr
argument_list|,
name|insn_end
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|dwarf2_frame_state_alloc_regs
argument_list|(
operator|&
name|fs
operator|->
name|regs
argument_list|,
name|reg
operator|+
literal|1
argument_list|)
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|reg
index|]
operator|=
name|fs
operator|->
name|initial
operator|.
name|reg
index|[
name|reg
index|]
expr_stmt|;
break|break;
case|case
name|DW_CFA_undefined
case|:
name|insn_ptr
operator|=
name|read_uleb128
argument_list|(
name|insn_ptr
argument_list|,
name|insn_end
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|dwarf2_frame_state_alloc_regs
argument_list|(
operator|&
name|fs
operator|->
name|regs
argument_list|,
name|reg
operator|+
literal|1
argument_list|)
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|reg
index|]
operator|.
name|how
operator|=
name|DWARF2_FRAME_REG_UNDEFINED
expr_stmt|;
break|break;
case|case
name|DW_CFA_same_value
case|:
name|insn_ptr
operator|=
name|read_uleb128
argument_list|(
name|insn_ptr
argument_list|,
name|insn_end
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|dwarf2_frame_state_alloc_regs
argument_list|(
operator|&
name|fs
operator|->
name|regs
argument_list|,
name|reg
operator|+
literal|1
argument_list|)
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|reg
index|]
operator|.
name|how
operator|=
name|DWARF2_FRAME_REG_SAME_VALUE
expr_stmt|;
break|break;
case|case
name|DW_CFA_register
case|:
name|insn_ptr
operator|=
name|read_uleb128
argument_list|(
name|insn_ptr
argument_list|,
name|insn_end
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|insn_ptr
operator|=
name|read_uleb128
argument_list|(
name|insn_ptr
argument_list|,
name|insn_end
argument_list|,
operator|&
name|utmp
argument_list|)
expr_stmt|;
name|dwarf2_frame_state_alloc_regs
argument_list|(
operator|&
name|fs
operator|->
name|regs
argument_list|,
name|reg
operator|+
literal|1
argument_list|)
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|reg
index|]
operator|.
name|how
operator|=
name|DWARF2_FRAME_REG_SAVED_REG
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|reg
index|]
operator|.
name|loc
operator|.
name|reg
operator|=
name|utmp
expr_stmt|;
break|break;
case|case
name|DW_CFA_remember_state
case|:
block|{
name|struct
name|dwarf2_frame_state_reg_info
modifier|*
name|new_rs
decl_stmt|;
name|new_rs
operator|=
name|XMALLOC
argument_list|(
expr|struct
name|dwarf2_frame_state_reg_info
argument_list|)
expr_stmt|;
operator|*
name|new_rs
operator|=
name|fs
operator|->
name|regs
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
operator|=
name|dwarf2_frame_state_copy_regs
argument_list|(
operator|&
name|fs
operator|->
name|regs
argument_list|)
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|prev
operator|=
name|new_rs
expr_stmt|;
block|}
break|break;
case|case
name|DW_CFA_restore_state
case|:
block|{
name|struct
name|dwarf2_frame_state_reg_info
modifier|*
name|old_rs
init|=
name|fs
operator|->
name|regs
operator|.
name|prev
decl_stmt|;
name|gdb_assert
argument_list|(
name|old_rs
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|fs
operator|->
name|regs
operator|.
name|reg
argument_list|)
expr_stmt|;
name|fs
operator|->
name|regs
operator|=
operator|*
name|old_rs
expr_stmt|;
name|xfree
argument_list|(
name|old_rs
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DW_CFA_def_cfa
case|:
name|insn_ptr
operator|=
name|read_uleb128
argument_list|(
name|insn_ptr
argument_list|,
name|insn_end
argument_list|,
operator|&
name|fs
operator|->
name|cfa_reg
argument_list|)
expr_stmt|;
name|insn_ptr
operator|=
name|read_uleb128
argument_list|(
name|insn_ptr
argument_list|,
name|insn_end
argument_list|,
operator|&
name|utmp
argument_list|)
expr_stmt|;
name|fs
operator|->
name|cfa_offset
operator|=
name|utmp
expr_stmt|;
name|fs
operator|->
name|cfa_how
operator|=
name|CFA_REG_OFFSET
expr_stmt|;
break|break;
case|case
name|DW_CFA_def_cfa_register
case|:
name|insn_ptr
operator|=
name|read_uleb128
argument_list|(
name|insn_ptr
argument_list|,
name|insn_end
argument_list|,
operator|&
name|fs
operator|->
name|cfa_reg
argument_list|)
expr_stmt|;
name|fs
operator|->
name|cfa_how
operator|=
name|CFA_REG_OFFSET
expr_stmt|;
break|break;
case|case
name|DW_CFA_def_cfa_offset
case|:
name|insn_ptr
operator|=
name|read_uleb128
argument_list|(
name|insn_ptr
argument_list|,
name|insn_end
argument_list|,
operator|&
name|fs
operator|->
name|cfa_offset
argument_list|)
expr_stmt|;
comment|/* cfa_how deliberately not set.  */
break|break;
case|case
name|DW_CFA_nop
case|:
break|break;
case|case
name|DW_CFA_def_cfa_expression
case|:
name|insn_ptr
operator|=
name|read_uleb128
argument_list|(
name|insn_ptr
argument_list|,
name|insn_end
argument_list|,
operator|&
name|fs
operator|->
name|cfa_exp_len
argument_list|)
expr_stmt|;
name|fs
operator|->
name|cfa_exp
operator|=
name|insn_ptr
expr_stmt|;
name|fs
operator|->
name|cfa_how
operator|=
name|CFA_EXP
expr_stmt|;
name|insn_ptr
operator|+=
name|fs
operator|->
name|cfa_exp_len
expr_stmt|;
break|break;
case|case
name|DW_CFA_expression
case|:
name|insn_ptr
operator|=
name|read_uleb128
argument_list|(
name|insn_ptr
argument_list|,
name|insn_end
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|dwarf2_frame_state_alloc_regs
argument_list|(
operator|&
name|fs
operator|->
name|regs
argument_list|,
name|reg
operator|+
literal|1
argument_list|)
expr_stmt|;
name|insn_ptr
operator|=
name|read_uleb128
argument_list|(
name|insn_ptr
argument_list|,
name|insn_end
argument_list|,
operator|&
name|utmp
argument_list|)
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|reg
index|]
operator|.
name|loc
operator|.
name|exp
operator|=
name|insn_ptr
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|reg
index|]
operator|.
name|exp_len
operator|=
name|utmp
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|reg
index|]
operator|.
name|how
operator|=
name|DWARF2_FRAME_REG_SAVED_EXP
expr_stmt|;
name|insn_ptr
operator|+=
name|utmp
expr_stmt|;
break|break;
case|case
name|DW_CFA_offset_extended_sf
case|:
name|insn_ptr
operator|=
name|read_uleb128
argument_list|(
name|insn_ptr
argument_list|,
name|insn_end
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|insn_ptr
operator|=
name|read_sleb128
argument_list|(
name|insn_ptr
argument_list|,
name|insn_end
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|fs
operator|->
name|data_align
expr_stmt|;
name|dwarf2_frame_state_alloc_regs
argument_list|(
operator|&
name|fs
operator|->
name|regs
argument_list|,
name|reg
operator|+
literal|1
argument_list|)
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|reg
index|]
operator|.
name|how
operator|=
name|DWARF2_FRAME_REG_SAVED_OFFSET
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|reg
index|]
operator|.
name|loc
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
break|break;
case|case
name|DW_CFA_def_cfa_sf
case|:
name|insn_ptr
operator|=
name|read_uleb128
argument_list|(
name|insn_ptr
argument_list|,
name|insn_end
argument_list|,
operator|&
name|fs
operator|->
name|cfa_reg
argument_list|)
expr_stmt|;
name|insn_ptr
operator|=
name|read_sleb128
argument_list|(
name|insn_ptr
argument_list|,
name|insn_end
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
name|fs
operator|->
name|cfa_offset
operator|=
name|offset
operator|*
name|fs
operator|->
name|data_align
expr_stmt|;
name|fs
operator|->
name|cfa_how
operator|=
name|CFA_REG_OFFSET
expr_stmt|;
break|break;
case|case
name|DW_CFA_def_cfa_offset_sf
case|:
name|insn_ptr
operator|=
name|read_sleb128
argument_list|(
name|insn_ptr
argument_list|,
name|insn_end
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
name|fs
operator|->
name|cfa_offset
operator|=
name|offset
operator|*
name|fs
operator|->
name|data_align
expr_stmt|;
comment|/* cfa_how deliberately not set.  */
break|break;
case|case
name|DW_CFA_GNU_args_size
case|:
comment|/* Ignored.  */
name|insn_ptr
operator|=
name|read_uleb128
argument_list|(
name|insn_ptr
argument_list|,
name|insn_end
argument_list|,
operator|&
name|utmp
argument_list|)
expr_stmt|;
break|break;
default|default:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"Unknown CFI encountered."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Don't allow remember/restore between CIE and FDE programs.  */
name|dwarf2_frame_state_free_regs
argument_list|(
name|fs
operator|->
name|regs
operator|.
name|prev
argument_list|)
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|prev
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Architecture-specific operations.  */
end_comment

begin_comment
comment|/* Per-architecture data key.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|gdbarch_data
modifier|*
name|dwarf2_frame_data
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|dwarf2_frame_ops
block|{
comment|/* Pre-initialize the register state REG for register REGNUM.  */
name|void
function_decl|(
modifier|*
name|init_reg
function_decl|)
parameter_list|(
name|struct
name|gdbarch
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|dwarf2_frame_state_reg
modifier|*
parameter_list|)
function_decl|;
block|}
struct|;
end_struct

begin_comment
comment|/* Default architecture-specific register state initialization    function.  */
end_comment

begin_function
specifier|static
name|void
name|dwarf2_frame_default_init_reg
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|int
name|regnum
parameter_list|,
name|struct
name|dwarf2_frame_state_reg
modifier|*
name|reg
parameter_list|)
block|{
comment|/* If we have a register that acts as a program counter, mark it as      a destination for the return address.  If we have a register that      serves as the stack pointer, arrange for it to be filled with the      call frame address (CFA).  The other registers are marked as      unspecified.       We copy the return address to the program counter, since many      parts in GDB assume that it is possible to get the return address      by unwinding the program counter register.  However, on ISA's      with a dedicated return address register, the CFI usually only      contains information to unwind that return address register.       The reason we're treating the stack pointer special here is      because in many cases GCC doesn't emit CFI for the stack pointer      and implicitly assumes that it is equal to the CFA.  This makes      some sense since the DWARF specification (version 3, draft 8,      p. 102) says that:       "Typically, the CFA is defined to be the value of the stack      pointer at the call site in the previous frame (which may be      different from its value on entry to the current frame)."       However, this isn't true for all platforms supported by GCC      (e.g. IBM S/390 and zSeries).  Those architectures should provide      their own architecture-specific initialization function.  */
if|if
condition|(
name|regnum
operator|==
name|PC_REGNUM
condition|)
name|reg
operator|->
name|how
operator|=
name|DWARF2_FRAME_REG_RA
expr_stmt|;
elseif|else
if|if
condition|(
name|regnum
operator|==
name|SP_REGNUM
condition|)
name|reg
operator|->
name|how
operator|=
name|DWARF2_FRAME_REG_CFA
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a default for the architecture-specific operations.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|dwarf2_frame_init
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|)
block|{
name|struct
name|dwarf2_frame_ops
modifier|*
name|ops
decl_stmt|;
name|ops
operator|=
name|GDBARCH_OBSTACK_ZALLOC
argument_list|(
name|gdbarch
argument_list|,
expr|struct
name|dwarf2_frame_ops
argument_list|)
expr_stmt|;
name|ops
operator|->
name|init_reg
operator|=
name|dwarf2_frame_default_init_reg
expr_stmt|;
return|return
name|ops
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|dwarf2_frame_ops
modifier|*
name|dwarf2_frame_ops
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|)
block|{
name|struct
name|dwarf2_frame_ops
modifier|*
name|ops
init|=
name|gdbarch_data
argument_list|(
name|gdbarch
argument_list|,
name|dwarf2_frame_data
argument_list|)
decl_stmt|;
if|if
condition|(
name|ops
operator|==
name|NULL
condition|)
block|{
comment|/* ULGH, called during architecture initialization.  Patch          things up.  */
name|ops
operator|=
name|dwarf2_frame_init
argument_list|(
name|gdbarch
argument_list|)
expr_stmt|;
name|set_gdbarch_data
argument_list|(
name|gdbarch
argument_list|,
name|dwarf2_frame_data
argument_list|,
name|ops
argument_list|)
expr_stmt|;
block|}
return|return
name|ops
return|;
block|}
end_function

begin_comment
comment|/* Set the architecture-specific register state initialization    function for GDBARCH to INIT_REG.  */
end_comment

begin_function
name|void
name|dwarf2_frame_set_init_reg
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|void
function_decl|(
modifier|*
name|init_reg
function_decl|)
parameter_list|(
name|struct
name|gdbarch
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|dwarf2_frame_state_reg
modifier|*
parameter_list|)
parameter_list|)
block|{
name|struct
name|dwarf2_frame_ops
modifier|*
name|ops
decl_stmt|;
name|ops
operator|=
name|dwarf2_frame_ops
argument_list|(
name|gdbarch
argument_list|)
expr_stmt|;
name|ops
operator|->
name|init_reg
operator|=
name|init_reg
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pre-initialize the register state REG for register REGNUM.  */
end_comment

begin_function
specifier|static
name|void
name|dwarf2_frame_init_reg
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|int
name|regnum
parameter_list|,
name|struct
name|dwarf2_frame_state_reg
modifier|*
name|reg
parameter_list|)
block|{
name|struct
name|dwarf2_frame_ops
modifier|*
name|ops
decl_stmt|;
name|ops
operator|=
name|dwarf2_frame_ops
argument_list|(
name|gdbarch
argument_list|)
expr_stmt|;
name|ops
operator|->
name|init_reg
argument_list|(
name|gdbarch
argument_list|,
name|regnum
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_struct
struct|struct
name|dwarf2_frame_cache
block|{
comment|/* DWARF Call Frame Address.  */
name|CORE_ADDR
name|cfa
decl_stmt|;
comment|/* Saved registers, indexed by GDB register number, not by DWARF      register number.  */
name|struct
name|dwarf2_frame_state_reg
modifier|*
name|reg
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|struct
name|dwarf2_frame_cache
modifier|*
name|dwarf2_frame_cache
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|void
modifier|*
modifier|*
name|this_cache
parameter_list|)
block|{
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|struct
name|gdbarch
modifier|*
name|gdbarch
init|=
name|get_frame_arch
argument_list|(
name|next_frame
argument_list|)
decl_stmt|;
specifier|const
name|int
name|num_regs
init|=
name|NUM_REGS
operator|+
name|NUM_PSEUDO_REGS
decl_stmt|;
name|struct
name|dwarf2_frame_cache
modifier|*
name|cache
decl_stmt|;
name|struct
name|dwarf2_frame_state
modifier|*
name|fs
decl_stmt|;
name|struct
name|dwarf2_fde
modifier|*
name|fde
decl_stmt|;
if|if
condition|(
operator|*
name|this_cache
condition|)
return|return
operator|*
name|this_cache
return|;
comment|/* Allocate a new cache.  */
name|cache
operator|=
name|FRAME_OBSTACK_ZALLOC
argument_list|(
expr|struct
name|dwarf2_frame_cache
argument_list|)
expr_stmt|;
name|cache
operator|->
name|reg
operator|=
name|FRAME_OBSTACK_CALLOC
argument_list|(
name|num_regs
argument_list|,
expr|struct
name|dwarf2_frame_state_reg
argument_list|)
expr_stmt|;
comment|/* Allocate and initialize the frame state.  */
name|fs
operator|=
name|XMALLOC
argument_list|(
expr|struct
name|dwarf2_frame_state
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|fs
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dwarf2_frame_state
argument_list|)
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|dwarf2_frame_state_free
argument_list|,
name|fs
argument_list|)
expr_stmt|;
comment|/* Unwind the PC.       Note that if NEXT_FRAME is never supposed to return (i.e. a call      to abort), the compiler might optimize away the instruction at      NEXT_FRAME's return address.  As a result the return address will      point at some random instruction, and the CFI for that      instruction is probably worthless to us.  GCC's unwinder solves      this problem by substracting 1 from the return address to get an      address in the middle of a presumed call instruction (or the      instruction in the associated delay slot).  This should only be      done for "normal" frames and not for resume-type frames (signal      handlers, sentinel frames, dummy frames).  The function      frame_unwind_address_in_block does just this.  It's not clear how      reliable the method is though; there is the potential for the      register state pre-call being different to that on return.  */
name|fs
operator|->
name|pc
operator|=
name|frame_unwind_address_in_block
argument_list|(
name|next_frame
argument_list|)
expr_stmt|;
comment|/* Find the correct FDE.  */
name|fde
operator|=
name|dwarf2_frame_find_fde
argument_list|(
operator|&
name|fs
operator|->
name|pc
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
name|fde
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Extract any interesting information from the CIE.  */
name|fs
operator|->
name|data_align
operator|=
name|fde
operator|->
name|cie
operator|->
name|data_alignment_factor
expr_stmt|;
name|fs
operator|->
name|code_align
operator|=
name|fde
operator|->
name|cie
operator|->
name|code_alignment_factor
expr_stmt|;
name|fs
operator|->
name|retaddr_column
operator|=
name|fde
operator|->
name|cie
operator|->
name|return_address_register
expr_stmt|;
comment|/* First decode all the insns in the CIE.  */
name|execute_cfa_program
argument_list|(
name|fde
operator|->
name|cie
operator|->
name|initial_instructions
argument_list|,
name|fde
operator|->
name|cie
operator|->
name|end
argument_list|,
name|next_frame
argument_list|,
name|fs
argument_list|)
expr_stmt|;
comment|/* Save the initialized register set.  */
name|fs
operator|->
name|initial
operator|=
name|fs
operator|->
name|regs
expr_stmt|;
name|fs
operator|->
name|initial
operator|.
name|reg
operator|=
name|dwarf2_frame_state_copy_regs
argument_list|(
operator|&
name|fs
operator|->
name|regs
argument_list|)
expr_stmt|;
comment|/* Then decode the insns in the FDE up to our target PC.  */
name|execute_cfa_program
argument_list|(
name|fde
operator|->
name|instructions
argument_list|,
name|fde
operator|->
name|end
argument_list|,
name|next_frame
argument_list|,
name|fs
argument_list|)
expr_stmt|;
comment|/* Caclulate the CFA.  */
switch|switch
condition|(
name|fs
operator|->
name|cfa_how
condition|)
block|{
case|case
name|CFA_REG_OFFSET
case|:
name|cache
operator|->
name|cfa
operator|=
name|read_reg
argument_list|(
name|next_frame
argument_list|,
name|fs
operator|->
name|cfa_reg
argument_list|)
expr_stmt|;
name|cache
operator|->
name|cfa
operator|+=
name|fs
operator|->
name|cfa_offset
expr_stmt|;
break|break;
case|case
name|CFA_EXP
case|:
name|cache
operator|->
name|cfa
operator|=
name|execute_stack_op
argument_list|(
name|fs
operator|->
name|cfa_exp
argument_list|,
name|fs
operator|->
name|cfa_exp_len
argument_list|,
name|next_frame
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"Unknown CFA rule."
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize the register state.  */
block|{
name|int
name|regnum
decl_stmt|;
for|for
control|(
name|regnum
operator|=
literal|0
init|;
name|regnum
operator|<
name|num_regs
condition|;
name|regnum
operator|++
control|)
name|dwarf2_frame_init_reg
argument_list|(
name|gdbarch
argument_list|,
name|regnum
argument_list|,
operator|&
name|cache
operator|->
name|reg
index|[
name|regnum
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Go through the DWARF2 CFI generated table and save its register      location information in the cache.  Note that we don't skip the      return address column; it's perfectly all right for it to      correspond to a real register.  If it doesn't correspond to a      real register, or if we shouldn't treat it as such,      DWARF2_REG_TO_REGNUM should be defined to return a number outside      the range [0, NUM_REGS).  */
block|{
name|int
name|column
decl_stmt|;
comment|/* CFI speak for "register number".  */
for|for
control|(
name|column
operator|=
literal|0
init|;
name|column
operator|<
name|fs
operator|->
name|regs
operator|.
name|num_regs
condition|;
name|column
operator|++
control|)
block|{
comment|/* Use the GDB register number as the destination index.  */
name|int
name|regnum
init|=
name|DWARF2_REG_TO_REGNUM
argument_list|(
name|column
argument_list|)
decl_stmt|;
comment|/* If there's no corresponding GDB register, ignore it.  */
if|if
condition|(
name|regnum
operator|<
literal|0
operator|||
name|regnum
operator|>=
name|num_regs
condition|)
continue|continue;
comment|/* NOTE: cagney/2003-09-05: CFI should specify the disposition 	   of all debug info registers.  If it doesn't, complain (but 	   not too loudly).  It turns out that GCC assumes that an 	   unspecified register implies "same value" when CFI (draft 	   7) specifies nothing at all.  Such a register could equally 	   be interpreted as "undefined".  Also note that this check 	   isn't sufficient; it only checks that all registers in the 	   range [0 .. max column] are specified, and won't detect 	   problems when a debug info register falls outside of the 	   table.  We need a way of iterating through all the valid 	   DWARF2 register numbers.  */
if|if
condition|(
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|column
index|]
operator|.
name|how
operator|==
name|DWARF2_FRAME_REG_UNSPECIFIED
condition|)
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"Incomplete CFI data; unspecified registers at 0x%s"
argument_list|,
name|paddr
argument_list|(
name|fs
operator|->
name|pc
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|cache
operator|->
name|reg
index|[
name|regnum
index|]
operator|=
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|column
index|]
expr_stmt|;
block|}
block|}
comment|/* Eliminate any DWARF2_FRAME_REG_RA rules.  */
block|{
name|int
name|regnum
decl_stmt|;
for|for
control|(
name|regnum
operator|=
literal|0
init|;
name|regnum
operator|<
name|num_regs
condition|;
name|regnum
operator|++
control|)
block|{
if|if
condition|(
name|cache
operator|->
name|reg
index|[
name|regnum
index|]
operator|.
name|how
operator|==
name|DWARF2_FRAME_REG_RA
condition|)
block|{
name|struct
name|dwarf2_frame_state_reg
modifier|*
name|retaddr_reg
init|=
operator|&
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|fs
operator|->
name|retaddr_column
index|]
decl_stmt|;
comment|/* It seems rather bizarre to specify an "empty" column as                the return adress column.  However, this is exactly                what GCC does on some targets.  It turns out that GCC                assumes that the return address can be found in the                register corresponding to the return address column.                Incidentally, that's how should treat a return address                column specifying "same value" too.  */
if|if
condition|(
name|fs
operator|->
name|retaddr_column
operator|<
name|fs
operator|->
name|regs
operator|.
name|num_regs
operator|&&
name|retaddr_reg
operator|->
name|how
operator|!=
name|DWARF2_FRAME_REG_UNSPECIFIED
operator|&&
name|retaddr_reg
operator|->
name|how
operator|!=
name|DWARF2_FRAME_REG_SAME_VALUE
condition|)
name|cache
operator|->
name|reg
index|[
name|regnum
index|]
operator|=
operator|*
name|retaddr_reg
expr_stmt|;
else|else
block|{
name|cache
operator|->
name|reg
index|[
name|regnum
index|]
operator|.
name|loc
operator|.
name|reg
operator|=
name|fs
operator|->
name|retaddr_column
expr_stmt|;
name|cache
operator|->
name|reg
index|[
name|regnum
index|]
operator|.
name|how
operator|=
name|DWARF2_FRAME_REG_SAVED_REG
expr_stmt|;
block|}
block|}
block|}
block|}
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
operator|*
name|this_cache
operator|=
name|cache
expr_stmt|;
return|return
name|cache
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dwarf2_frame_this_id
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|void
modifier|*
modifier|*
name|this_cache
parameter_list|,
name|struct
name|frame_id
modifier|*
name|this_id
parameter_list|)
block|{
name|struct
name|dwarf2_frame_cache
modifier|*
name|cache
init|=
name|dwarf2_frame_cache
argument_list|(
name|next_frame
argument_list|,
name|this_cache
argument_list|)
decl_stmt|;
operator|(
operator|*
name|this_id
operator|)
operator|=
name|frame_id_build
argument_list|(
name|cache
operator|->
name|cfa
argument_list|,
name|frame_func_unwind
argument_list|(
name|next_frame
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dwarf2_frame_prev_register
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|void
modifier|*
modifier|*
name|this_cache
parameter_list|,
name|int
name|regnum
parameter_list|,
name|int
modifier|*
name|optimizedp
parameter_list|,
name|enum
name|lval_type
modifier|*
name|lvalp
parameter_list|,
name|CORE_ADDR
modifier|*
name|addrp
parameter_list|,
name|int
modifier|*
name|realnump
parameter_list|,
name|void
modifier|*
name|valuep
parameter_list|)
block|{
name|struct
name|gdbarch
modifier|*
name|gdbarch
init|=
name|get_frame_arch
argument_list|(
name|next_frame
argument_list|)
decl_stmt|;
name|struct
name|dwarf2_frame_cache
modifier|*
name|cache
init|=
name|dwarf2_frame_cache
argument_list|(
name|next_frame
argument_list|,
name|this_cache
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|cache
operator|->
name|reg
index|[
name|regnum
index|]
operator|.
name|how
condition|)
block|{
case|case
name|DWARF2_FRAME_REG_UNDEFINED
case|:
comment|/* If CFI explicitly specified that the value isn't defined, 	 mark it as optimized away; the value isn't available.  */
operator|*
name|optimizedp
operator|=
literal|1
expr_stmt|;
operator|*
name|lvalp
operator|=
name|not_lval
expr_stmt|;
operator|*
name|addrp
operator|=
literal|0
expr_stmt|;
operator|*
name|realnump
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|valuep
condition|)
block|{
comment|/* In some cases, for example %eflags on the i386, we have 	     to provide a sane value, even though this register wasn't 	     saved.  Assume we can get it from NEXT_FRAME.  */
name|frame_unwind_register
argument_list|(
name|next_frame
argument_list|,
name|regnum
argument_list|,
name|valuep
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DWARF2_FRAME_REG_SAVED_OFFSET
case|:
operator|*
name|optimizedp
operator|=
literal|0
expr_stmt|;
operator|*
name|lvalp
operator|=
name|lval_memory
expr_stmt|;
operator|*
name|addrp
operator|=
name|cache
operator|->
name|cfa
operator|+
name|cache
operator|->
name|reg
index|[
name|regnum
index|]
operator|.
name|loc
operator|.
name|offset
expr_stmt|;
operator|*
name|realnump
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|valuep
condition|)
block|{
comment|/* Read the value in from memory.  */
name|read_memory
argument_list|(
operator|*
name|addrp
argument_list|,
name|valuep
argument_list|,
name|register_size
argument_list|(
name|gdbarch
argument_list|,
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DWARF2_FRAME_REG_SAVED_REG
case|:
name|regnum
operator|=
name|DWARF2_REG_TO_REGNUM
argument_list|(
name|cache
operator|->
name|reg
index|[
name|regnum
index|]
operator|.
name|loc
operator|.
name|reg
argument_list|)
expr_stmt|;
name|frame_register_unwind
argument_list|(
name|next_frame
argument_list|,
name|regnum
argument_list|,
name|optimizedp
argument_list|,
name|lvalp
argument_list|,
name|addrp
argument_list|,
name|realnump
argument_list|,
name|valuep
argument_list|)
expr_stmt|;
break|break;
case|case
name|DWARF2_FRAME_REG_SAVED_EXP
case|:
operator|*
name|optimizedp
operator|=
literal|0
expr_stmt|;
operator|*
name|lvalp
operator|=
name|lval_memory
expr_stmt|;
operator|*
name|addrp
operator|=
name|execute_stack_op
argument_list|(
name|cache
operator|->
name|reg
index|[
name|regnum
index|]
operator|.
name|loc
operator|.
name|exp
argument_list|,
name|cache
operator|->
name|reg
index|[
name|regnum
index|]
operator|.
name|exp_len
argument_list|,
name|next_frame
argument_list|,
name|cache
operator|->
name|cfa
argument_list|)
expr_stmt|;
operator|*
name|realnump
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|valuep
condition|)
block|{
comment|/* Read the value in from memory.  */
name|read_memory
argument_list|(
operator|*
name|addrp
argument_list|,
name|valuep
argument_list|,
name|register_size
argument_list|(
name|gdbarch
argument_list|,
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DWARF2_FRAME_REG_UNSPECIFIED
case|:
comment|/* GCC, in its infinite wisdom decided to not provide unwind 	 information for registers that are "same value".  Since 	 DWARF2 (3 draft 7) doesn't define such behavior, said 	 registers are actually undefined (which is different to CFI 	 "undefined").  Code above issues a complaint about this. 	 Here just fudge the books, assume GCC, and that the value is 	 more inner on the stack.  */
name|frame_register_unwind
argument_list|(
name|next_frame
argument_list|,
name|regnum
argument_list|,
name|optimizedp
argument_list|,
name|lvalp
argument_list|,
name|addrp
argument_list|,
name|realnump
argument_list|,
name|valuep
argument_list|)
expr_stmt|;
break|break;
case|case
name|DWARF2_FRAME_REG_SAME_VALUE
case|:
name|frame_register_unwind
argument_list|(
name|next_frame
argument_list|,
name|regnum
argument_list|,
name|optimizedp
argument_list|,
name|lvalp
argument_list|,
name|addrp
argument_list|,
name|realnump
argument_list|,
name|valuep
argument_list|)
expr_stmt|;
break|break;
case|case
name|DWARF2_FRAME_REG_CFA
case|:
operator|*
name|optimizedp
operator|=
literal|0
expr_stmt|;
operator|*
name|lvalp
operator|=
name|not_lval
expr_stmt|;
operator|*
name|addrp
operator|=
literal|0
expr_stmt|;
operator|*
name|realnump
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|valuep
condition|)
block|{
comment|/* Store the value.  */
name|store_typed_address
argument_list|(
name|valuep
argument_list|,
name|builtin_type_void_data_ptr
argument_list|,
name|cache
operator|->
name|cfa
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"Unknown register rule."
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|frame_unwind
name|dwarf2_frame_unwind
init|=
block|{
name|NORMAL_FRAME
block|,
name|dwarf2_frame_this_id
block|,
name|dwarf2_frame_prev_register
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|const
name|struct
name|frame_unwind
modifier|*
name|dwarf2_frame_sniffer
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|)
block|{
comment|/* Grab an address that is guarenteed to reside somewhere within the      function.  frame_pc_unwind(), for a no-return next function, can      end up returning something past the end of this function's body.  */
name|CORE_ADDR
name|block_addr
init|=
name|frame_unwind_address_in_block
argument_list|(
name|next_frame
argument_list|)
decl_stmt|;
if|if
condition|(
name|dwarf2_frame_find_fde
argument_list|(
operator|&
name|block_addr
argument_list|)
condition|)
return|return
operator|&
name|dwarf2_frame_unwind
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* There is no explicitly defined relationship between the CFA and the    location of frame's local variables and arguments/parameters.    Therefore, frame base methods on this page should probably only be    used as a last resort, just to avoid printing total garbage as a    response to the "info frame" command.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|dwarf2_frame_base_address
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|void
modifier|*
modifier|*
name|this_cache
parameter_list|)
block|{
name|struct
name|dwarf2_frame_cache
modifier|*
name|cache
init|=
name|dwarf2_frame_cache
argument_list|(
name|next_frame
argument_list|,
name|this_cache
argument_list|)
decl_stmt|;
return|return
name|cache
operator|->
name|cfa
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|frame_base
name|dwarf2_frame_base
init|=
block|{
operator|&
name|dwarf2_frame_unwind
block|,
name|dwarf2_frame_base_address
block|,
name|dwarf2_frame_base_address
block|,
name|dwarf2_frame_base_address
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|const
name|struct
name|frame_base
modifier|*
name|dwarf2_frame_base_sniffer
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|)
block|{
name|CORE_ADDR
name|pc
init|=
name|frame_pc_unwind
argument_list|(
name|next_frame
argument_list|)
decl_stmt|;
if|if
condition|(
name|dwarf2_frame_find_fde
argument_list|(
operator|&
name|pc
argument_list|)
condition|)
return|return
operator|&
name|dwarf2_frame_base
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A minimal decoding of DWARF2 compilation units.  We only decode    what's needed to get to the call frame information.  */
end_comment

begin_struct
struct|struct
name|comp_unit
block|{
comment|/* Keep the bfd convenient.  */
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
comment|/* Linked list of CIEs for this object.  */
name|struct
name|dwarf2_cie
modifier|*
name|cie
decl_stmt|;
comment|/* Address size for this unit - from unit header.  */
name|unsigned
name|char
name|addr_size
decl_stmt|;
comment|/* Pointer to the .debug_frame section loaded into memory.  */
name|char
modifier|*
name|dwarf_frame_buffer
decl_stmt|;
comment|/* Length of the loaded .debug_frame section.  */
name|unsigned
name|long
name|dwarf_frame_size
decl_stmt|;
comment|/* Pointer to the .debug_frame section.  */
name|asection
modifier|*
name|dwarf_frame_section
decl_stmt|;
comment|/* Base for DW_EH_PE_datarel encodings.  */
name|bfd_vma
name|dbase
decl_stmt|;
comment|/* Base for DW_EH_PE_textrel encodings.  */
name|bfd_vma
name|tbase
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|const
name|struct
name|objfile_data
modifier|*
name|dwarf2_frame_objfile_data
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|unsigned
name|int
name|read_1_byte
parameter_list|(
name|bfd
modifier|*
name|bfd
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
return|return
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|buf
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|read_4_bytes
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
return|return
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|buf
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|ULONGEST
name|read_8_bytes
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
return|return
name|bfd_get_64
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|buf
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|ULONGEST
name|read_unsigned_leb128
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|unsigned
name|int
modifier|*
name|bytes_read_ptr
parameter_list|)
block|{
name|ULONGEST
name|result
decl_stmt|;
name|unsigned
name|int
name|num_read
decl_stmt|;
name|int
name|shift
decl_stmt|;
name|unsigned
name|char
name|byte
decl_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
name|shift
operator|=
literal|0
expr_stmt|;
name|num_read
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|byte
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|++
expr_stmt|;
name|num_read
operator|++
expr_stmt|;
name|result
operator||=
operator|(
operator|(
name|byte
operator|&
literal|0x7f
operator|)
operator|<<
name|shift
operator|)
expr_stmt|;
name|shift
operator|+=
literal|7
expr_stmt|;
block|}
do|while
condition|(
name|byte
operator|&
literal|0x80
condition|)
do|;
operator|*
name|bytes_read_ptr
operator|=
name|num_read
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|LONGEST
name|read_signed_leb128
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|unsigned
name|int
modifier|*
name|bytes_read_ptr
parameter_list|)
block|{
name|LONGEST
name|result
decl_stmt|;
name|int
name|shift
decl_stmt|;
name|unsigned
name|int
name|num_read
decl_stmt|;
name|unsigned
name|char
name|byte
decl_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
name|shift
operator|=
literal|0
expr_stmt|;
name|num_read
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|byte
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|++
expr_stmt|;
name|num_read
operator|++
expr_stmt|;
name|result
operator||=
operator|(
operator|(
name|byte
operator|&
literal|0x7f
operator|)
operator|<<
name|shift
operator|)
expr_stmt|;
name|shift
operator|+=
literal|7
expr_stmt|;
block|}
do|while
condition|(
name|byte
operator|&
literal|0x80
condition|)
do|;
if|if
condition|(
operator|(
name|shift
operator|<
literal|32
operator|)
operator|&&
operator|(
name|byte
operator|&
literal|0x40
operator|)
condition|)
name|result
operator||=
operator|-
operator|(
literal|1
operator|<<
name|shift
operator|)
expr_stmt|;
operator|*
name|bytes_read_ptr
operator|=
name|num_read
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|ULONGEST
name|read_initial_length
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|unsigned
name|int
modifier|*
name|bytes_read_ptr
parameter_list|)
block|{
name|LONGEST
name|result
decl_stmt|;
name|result
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
literal|0xffffffff
condition|)
block|{
name|result
operator|=
name|bfd_get_64
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|buf
operator|+
literal|4
argument_list|)
expr_stmt|;
operator|*
name|bytes_read_ptr
operator|=
literal|12
expr_stmt|;
block|}
else|else
operator|*
name|bytes_read_ptr
operator|=
literal|4
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Pointer encoding helper functions.  */
end_comment

begin_comment
comment|/* GCC supports exception handling based on DWARF2 CFI.  However, for    technical reasons, it encodes addresses in its FDE's in a different    way.  Several "pointer encodings" are supported.  The encoding    that's used for a particular FDE is determined by the 'R'    augmentation in the associated CIE.  The argument of this    augmentation is a single byte.       The address can be encoded as 2 bytes, 4 bytes, 8 bytes, or as a    LEB128.  This is encoded in bits 0, 1 and 2.  Bit 3 encodes whether    the address is signed or unsigned.  Bits 4, 5 and 6 encode how the    address should be interpreted (absolute, relative to the current    position in the FDE, ...).  Bit 7, indicates that the address    should be dereferenced.  */
end_comment

begin_function
specifier|static
name|unsigned
name|char
name|encoding_for_size
parameter_list|(
name|unsigned
name|int
name|size
parameter_list|)
block|{
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|2
case|:
return|return
name|DW_EH_PE_udata2
return|;
case|case
literal|4
case|:
return|return
name|DW_EH_PE_udata4
return|;
case|case
literal|8
case|:
return|return
name|DW_EH_PE_udata8
return|;
default|default:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"Unsupported address size"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|size_of_encoded_value
parameter_list|(
name|unsigned
name|char
name|encoding
parameter_list|)
block|{
if|if
condition|(
name|encoding
operator|==
name|DW_EH_PE_omit
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|encoding
operator|&
literal|0x07
condition|)
block|{
case|case
name|DW_EH_PE_absptr
case|:
return|return
name|TYPE_LENGTH
argument_list|(
name|builtin_type_void_data_ptr
argument_list|)
return|;
case|case
name|DW_EH_PE_udata2
case|:
return|return
literal|2
return|;
case|case
name|DW_EH_PE_udata4
case|:
return|return
literal|4
return|;
case|case
name|DW_EH_PE_udata8
case|:
return|return
literal|8
return|;
default|default:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"Invalid or unsupported encoding"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|CORE_ADDR
name|read_encoded_value
parameter_list|(
name|struct
name|comp_unit
modifier|*
name|unit
parameter_list|,
name|unsigned
name|char
name|encoding
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|unsigned
name|int
modifier|*
name|bytes_read_ptr
parameter_list|)
block|{
name|int
name|ptr_len
init|=
name|size_of_encoded_value
argument_list|(
name|DW_EH_PE_absptr
argument_list|)
decl_stmt|;
name|ptrdiff_t
name|offset
decl_stmt|;
name|CORE_ADDR
name|base
decl_stmt|;
comment|/* GCC currently doesn't generate DW_EH_PE_indirect encodings for      FDE's.  */
if|if
condition|(
name|encoding
operator|&
name|DW_EH_PE_indirect
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"Unsupported encoding: DW_EH_PE_indirect"
argument_list|)
expr_stmt|;
operator|*
name|bytes_read_ptr
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|encoding
operator|&
literal|0x70
condition|)
block|{
case|case
name|DW_EH_PE_absptr
case|:
name|base
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|DW_EH_PE_pcrel
case|:
name|base
operator|=
name|bfd_get_section_vma
argument_list|(
name|unit
operator|->
name|bfd
argument_list|,
name|unit
operator|->
name|dwarf_frame_section
argument_list|)
expr_stmt|;
name|base
operator|+=
operator|(
name|buf
operator|-
name|unit
operator|->
name|dwarf_frame_buffer
operator|)
expr_stmt|;
break|break;
case|case
name|DW_EH_PE_datarel
case|:
name|base
operator|=
name|unit
operator|->
name|dbase
expr_stmt|;
break|break;
case|case
name|DW_EH_PE_textrel
case|:
name|base
operator|=
name|unit
operator|->
name|tbase
expr_stmt|;
break|break;
case|case
name|DW_EH_PE_funcrel
case|:
comment|/* FIXME: kettenis/20040501: For now just pretend          DW_EH_PE_funcrel is equivalent to DW_EH_PE_absptr.  For          reading the initial location of an FDE it should be treated          as such, and currently that's the only place where this code          is used.  */
name|base
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|DW_EH_PE_aligned
case|:
name|base
operator|=
literal|0
expr_stmt|;
name|offset
operator|=
name|buf
operator|-
name|unit
operator|->
name|dwarf_frame_buffer
expr_stmt|;
if|if
condition|(
operator|(
name|offset
operator|%
name|ptr_len
operator|)
operator|!=
literal|0
condition|)
block|{
operator|*
name|bytes_read_ptr
operator|=
name|ptr_len
operator|-
operator|(
name|offset
operator|%
name|ptr_len
operator|)
expr_stmt|;
name|buf
operator|+=
operator|*
name|bytes_read_ptr
expr_stmt|;
block|}
break|break;
default|default:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"Invalid or unsupported encoding"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|encoding
operator|&
literal|0x0f
operator|)
operator|==
literal|0x00
condition|)
name|encoding
operator||=
name|encoding_for_size
argument_list|(
name|ptr_len
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|encoding
operator|&
literal|0x0f
condition|)
block|{
case|case
name|DW_EH_PE_udata2
case|:
operator|*
name|bytes_read_ptr
operator|+=
literal|2
expr_stmt|;
return|return
operator|(
name|base
operator|+
name|bfd_get_16
argument_list|(
name|unit
operator|->
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|buf
argument_list|)
operator|)
return|;
case|case
name|DW_EH_PE_udata4
case|:
operator|*
name|bytes_read_ptr
operator|+=
literal|4
expr_stmt|;
return|return
operator|(
name|base
operator|+
name|bfd_get_32
argument_list|(
name|unit
operator|->
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|buf
argument_list|)
operator|)
return|;
case|case
name|DW_EH_PE_udata8
case|:
operator|*
name|bytes_read_ptr
operator|+=
literal|8
expr_stmt|;
return|return
operator|(
name|base
operator|+
name|bfd_get_64
argument_list|(
name|unit
operator|->
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|buf
argument_list|)
operator|)
return|;
case|case
name|DW_EH_PE_sdata2
case|:
operator|*
name|bytes_read_ptr
operator|+=
literal|2
expr_stmt|;
return|return
operator|(
name|base
operator|+
name|bfd_get_signed_16
argument_list|(
name|unit
operator|->
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|buf
argument_list|)
operator|)
return|;
case|case
name|DW_EH_PE_sdata4
case|:
operator|*
name|bytes_read_ptr
operator|+=
literal|4
expr_stmt|;
return|return
operator|(
name|base
operator|+
name|bfd_get_signed_32
argument_list|(
name|unit
operator|->
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|buf
argument_list|)
operator|)
return|;
case|case
name|DW_EH_PE_sdata8
case|:
operator|*
name|bytes_read_ptr
operator|+=
literal|8
expr_stmt|;
return|return
operator|(
name|base
operator|+
name|bfd_get_signed_64
argument_list|(
name|unit
operator|->
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|buf
argument_list|)
operator|)
return|;
default|default:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"Invalid or unsupported encoding"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* GCC uses a single CIE for all FDEs in a .debug_frame section.    That's why we use a simple linked list here.  */
end_comment

begin_function
specifier|static
name|struct
name|dwarf2_cie
modifier|*
name|find_cie
parameter_list|(
name|struct
name|comp_unit
modifier|*
name|unit
parameter_list|,
name|ULONGEST
name|cie_pointer
parameter_list|)
block|{
name|struct
name|dwarf2_cie
modifier|*
name|cie
init|=
name|unit
operator|->
name|cie
decl_stmt|;
while|while
condition|(
name|cie
condition|)
block|{
if|if
condition|(
name|cie
operator|->
name|cie_pointer
operator|==
name|cie_pointer
condition|)
return|return
name|cie
return|;
name|cie
operator|=
name|cie
operator|->
name|next
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_cie
parameter_list|(
name|struct
name|comp_unit
modifier|*
name|unit
parameter_list|,
name|struct
name|dwarf2_cie
modifier|*
name|cie
parameter_list|)
block|{
name|cie
operator|->
name|next
operator|=
name|unit
operator|->
name|cie
expr_stmt|;
name|unit
operator|->
name|cie
operator|=
name|cie
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find the FDE for *PC.  Return a pointer to the FDE, and store the    inital location associated with it into *PC.  */
end_comment

begin_function
specifier|static
name|struct
name|dwarf2_fde
modifier|*
name|dwarf2_frame_find_fde
parameter_list|(
name|CORE_ADDR
modifier|*
name|pc
parameter_list|)
block|{
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|ALL_OBJFILES
argument_list|(
argument|objfile
argument_list|)
block|{
name|struct
name|dwarf2_fde
modifier|*
name|fde
decl_stmt|;
name|CORE_ADDR
name|offset
decl_stmt|;
name|fde
operator|=
name|objfile_data
argument_list|(
name|objfile
argument_list|,
name|dwarf2_frame_objfile_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|fde
operator|==
name|NULL
condition|)
continue|continue;
name|gdb_assert
argument_list|(
name|objfile
operator|->
name|section_offsets
argument_list|)
expr_stmt|;
name|offset
operator|=
name|ANOFFSET
argument_list|(
name|objfile
operator|->
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|(
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|fde
condition|)
block|{
if|if
condition|(
operator|*
name|pc
operator|>=
name|fde
operator|->
name|initial_location
operator|+
name|offset
operator|&&
operator|*
name|pc
operator|<
name|fde
operator|->
name|initial_location
operator|+
name|offset
operator|+
name|fde
operator|->
name|address_range
condition|)
block|{
operator|*
name|pc
operator|=
name|fde
operator|->
name|initial_location
operator|+
name|offset
expr_stmt|;
return|return
name|fde
return|;
block|}
name|fde
operator|=
name|fde
operator|->
name|next
expr_stmt|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_fde
parameter_list|(
name|struct
name|comp_unit
modifier|*
name|unit
parameter_list|,
name|struct
name|dwarf2_fde
modifier|*
name|fde
parameter_list|)
block|{
name|fde
operator|->
name|next
operator|=
name|objfile_data
argument_list|(
name|unit
operator|->
name|objfile
argument_list|,
name|dwarf2_frame_objfile_data
argument_list|)
expr_stmt|;
name|set_objfile_data
argument_list|(
name|unit
operator|->
name|objfile
argument_list|,
name|dwarf2_frame_objfile_data
argument_list|,
name|fde
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CC_HAS_LONG_LONG
end_ifdef

begin_define
define|#
directive|define
name|DW64_CIE_ID
value|0xffffffffffffffffULL
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DW64_CIE_ID
value|~0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|char
modifier|*
name|decode_frame_entry
parameter_list|(
name|struct
name|comp_unit
modifier|*
name|unit
parameter_list|,
name|char
modifier|*
name|start
parameter_list|,
name|int
name|eh_frame_p
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Decode the next CIE or FDE.  Return NULL if invalid input, otherwise    the next byte to be processed.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|decode_frame_entry_1
parameter_list|(
name|struct
name|comp_unit
modifier|*
name|unit
parameter_list|,
name|char
modifier|*
name|start
parameter_list|,
name|int
name|eh_frame_p
parameter_list|)
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|LONGEST
name|length
decl_stmt|;
name|unsigned
name|int
name|bytes_read
decl_stmt|;
name|int
name|dwarf64_p
decl_stmt|;
name|ULONGEST
name|cie_id
decl_stmt|;
name|ULONGEST
name|cie_pointer
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
name|buf
operator|=
name|start
expr_stmt|;
name|length
operator|=
name|read_initial_length
argument_list|(
name|unit
operator|->
name|abfd
argument_list|,
name|buf
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|bytes_read
expr_stmt|;
name|end
operator|=
name|buf
operator|+
name|length
expr_stmt|;
comment|/* Are we still within the section? */
if|if
condition|(
name|end
operator|>
name|unit
operator|->
name|dwarf_frame_buffer
operator|+
name|unit
operator|->
name|dwarf_frame_size
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|length
operator|==
literal|0
condition|)
return|return
name|end
return|;
comment|/* Distinguish between 32 and 64-bit encoded frame info.  */
name|dwarf64_p
operator|=
operator|(
name|bytes_read
operator|==
literal|12
operator|)
expr_stmt|;
comment|/* In a .eh_frame section, zero is used to distinguish CIEs from FDEs.  */
if|if
condition|(
name|eh_frame_p
condition|)
name|cie_id
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|dwarf64_p
condition|)
name|cie_id
operator|=
name|DW64_CIE_ID
expr_stmt|;
else|else
name|cie_id
operator|=
name|DW_CIE_ID
expr_stmt|;
if|if
condition|(
name|dwarf64_p
condition|)
block|{
name|cie_pointer
operator|=
name|read_8_bytes
argument_list|(
name|unit
operator|->
name|abfd
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|+=
literal|8
expr_stmt|;
block|}
else|else
block|{
name|cie_pointer
operator|=
name|read_4_bytes
argument_list|(
name|unit
operator|->
name|abfd
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|+=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|cie_pointer
operator|==
name|cie_id
condition|)
block|{
comment|/* This is a CIE.  */
name|struct
name|dwarf2_cie
modifier|*
name|cie
decl_stmt|;
name|char
modifier|*
name|augmentation
decl_stmt|;
comment|/* Record the offset into the .debug_frame section of this CIE.  */
name|cie_pointer
operator|=
name|start
operator|-
name|unit
operator|->
name|dwarf_frame_buffer
expr_stmt|;
comment|/* Check whether we've already read it.  */
if|if
condition|(
name|find_cie
argument_list|(
name|unit
argument_list|,
name|cie_pointer
argument_list|)
condition|)
return|return
name|end
return|;
name|cie
operator|=
operator|(
expr|struct
name|dwarf2_cie
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|unit
operator|->
name|objfile
operator|->
name|objfile_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dwarf2_cie
argument_list|)
argument_list|)
expr_stmt|;
name|cie
operator|->
name|initial_instructions
operator|=
name|NULL
expr_stmt|;
name|cie
operator|->
name|cie_pointer
operator|=
name|cie_pointer
expr_stmt|;
comment|/* The encoding for FDE's in a normal .debug_frame section          depends on the target address size as specified in the          Compilation Unit Header.  */
name|cie
operator|->
name|encoding
operator|=
name|encoding_for_size
argument_list|(
name|unit
operator|->
name|addr_size
argument_list|)
expr_stmt|;
comment|/* Check version number.  */
if|if
condition|(
name|read_1_byte
argument_list|(
name|unit
operator|->
name|abfd
argument_list|,
name|buf
argument_list|)
operator|!=
name|DW_CIE_VERSION
condition|)
return|return
name|NULL
return|;
name|buf
operator|+=
literal|1
expr_stmt|;
comment|/* Interpret the interesting bits of the augmentation.  */
name|augmentation
operator|=
name|buf
expr_stmt|;
name|buf
operator|=
name|augmentation
operator|+
name|strlen
argument_list|(
name|augmentation
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* The GCC 2.x "eh" augmentation has a pointer immediately          following the augmentation string, so it must be handled          first.  */
if|if
condition|(
name|augmentation
index|[
literal|0
index|]
operator|==
literal|'e'
operator|&&
name|augmentation
index|[
literal|1
index|]
operator|==
literal|'h'
condition|)
block|{
comment|/* Skip.  */
name|buf
operator|+=
name|TYPE_LENGTH
argument_list|(
name|builtin_type_void_data_ptr
argument_list|)
expr_stmt|;
name|augmentation
operator|+=
literal|2
expr_stmt|;
block|}
name|cie
operator|->
name|code_alignment_factor
operator|=
name|read_unsigned_leb128
argument_list|(
name|unit
operator|->
name|abfd
argument_list|,
name|buf
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|bytes_read
expr_stmt|;
name|cie
operator|->
name|data_alignment_factor
operator|=
name|read_signed_leb128
argument_list|(
name|unit
operator|->
name|abfd
argument_list|,
name|buf
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|bytes_read
expr_stmt|;
name|cie
operator|->
name|return_address_register
operator|=
name|read_1_byte
argument_list|(
name|unit
operator|->
name|abfd
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|+=
literal|1
expr_stmt|;
name|cie
operator|->
name|saw_z_augmentation
operator|=
operator|(
operator|*
name|augmentation
operator|==
literal|'z'
operator|)
expr_stmt|;
if|if
condition|(
name|cie
operator|->
name|saw_z_augmentation
condition|)
block|{
name|ULONGEST
name|length
decl_stmt|;
name|length
operator|=
name|read_unsigned_leb128
argument_list|(
name|unit
operator|->
name|abfd
argument_list|,
name|buf
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|bytes_read
expr_stmt|;
if|if
condition|(
name|buf
operator|>
name|end
condition|)
return|return
name|NULL
return|;
name|cie
operator|->
name|initial_instructions
operator|=
name|buf
operator|+
name|length
expr_stmt|;
name|augmentation
operator|++
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|augmentation
condition|)
block|{
comment|/* "L" indicates a byte showing how the LSDA pointer is encoded.  */
if|if
condition|(
operator|*
name|augmentation
operator|==
literal|'L'
condition|)
block|{
comment|/* Skip.  */
name|buf
operator|++
expr_stmt|;
name|augmentation
operator|++
expr_stmt|;
block|}
comment|/* "R" indicates a byte indicating how FDE addresses are encoded.  */
elseif|else
if|if
condition|(
operator|*
name|augmentation
operator|==
literal|'R'
condition|)
block|{
name|cie
operator|->
name|encoding
operator|=
operator|*
name|buf
operator|++
expr_stmt|;
name|augmentation
operator|++
expr_stmt|;
block|}
comment|/* "P" indicates a personality routine in the CIE augmentation.  */
elseif|else
if|if
condition|(
operator|*
name|augmentation
operator|==
literal|'P'
condition|)
block|{
comment|/* Skip.  */
name|buf
operator|+=
name|size_of_encoded_value
argument_list|(
operator|*
name|buf
operator|++
argument_list|)
expr_stmt|;
name|augmentation
operator|++
expr_stmt|;
block|}
comment|/* Otherwise we have an unknown augmentation. 	     Bail out unless we saw a 'z' prefix.  */
else|else
block|{
if|if
condition|(
name|cie
operator|->
name|initial_instructions
operator|==
name|NULL
condition|)
return|return
name|end
return|;
comment|/* Skip unknown augmentations.  */
name|buf
operator|=
name|cie
operator|->
name|initial_instructions
expr_stmt|;
break|break;
block|}
block|}
name|cie
operator|->
name|initial_instructions
operator|=
name|buf
expr_stmt|;
name|cie
operator|->
name|end
operator|=
name|end
expr_stmt|;
name|add_cie
argument_list|(
name|unit
argument_list|,
name|cie
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This is a FDE.  */
name|struct
name|dwarf2_fde
modifier|*
name|fde
decl_stmt|;
comment|/* In an .eh_frame section, the CIE pointer is the delta between the 	 address within the FDE where the CIE pointer is stored and the 	 address of the CIE.  Convert it to an offset into the .eh_frame 	 section.  */
if|if
condition|(
name|eh_frame_p
condition|)
block|{
name|cie_pointer
operator|=
name|buf
operator|-
name|unit
operator|->
name|dwarf_frame_buffer
operator|-
name|cie_pointer
expr_stmt|;
name|cie_pointer
operator|-=
operator|(
name|dwarf64_p
condition|?
literal|8
else|:
literal|4
operator|)
expr_stmt|;
block|}
comment|/* In either case, validate the result is still within the section.  */
if|if
condition|(
name|cie_pointer
operator|>=
name|unit
operator|->
name|dwarf_frame_size
condition|)
return|return
name|NULL
return|;
name|fde
operator|=
operator|(
expr|struct
name|dwarf2_fde
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|unit
operator|->
name|objfile
operator|->
name|objfile_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dwarf2_fde
argument_list|)
argument_list|)
expr_stmt|;
name|fde
operator|->
name|cie
operator|=
name|find_cie
argument_list|(
name|unit
argument_list|,
name|cie_pointer
argument_list|)
expr_stmt|;
if|if
condition|(
name|fde
operator|->
name|cie
operator|==
name|NULL
condition|)
block|{
name|decode_frame_entry
argument_list|(
name|unit
argument_list|,
name|unit
operator|->
name|dwarf_frame_buffer
operator|+
name|cie_pointer
argument_list|,
name|eh_frame_p
argument_list|)
expr_stmt|;
name|fde
operator|->
name|cie
operator|=
name|find_cie
argument_list|(
name|unit
argument_list|,
name|cie_pointer
argument_list|)
expr_stmt|;
block|}
name|gdb_assert
argument_list|(
name|fde
operator|->
name|cie
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|fde
operator|->
name|initial_location
operator|=
name|read_encoded_value
argument_list|(
name|unit
argument_list|,
name|fde
operator|->
name|cie
operator|->
name|encoding
argument_list|,
name|buf
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|bytes_read
expr_stmt|;
name|fde
operator|->
name|address_range
operator|=
name|read_encoded_value
argument_list|(
name|unit
argument_list|,
name|fde
operator|->
name|cie
operator|->
name|encoding
operator|&
literal|0x0f
argument_list|,
name|buf
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|bytes_read
expr_stmt|;
comment|/* A 'z' augmentation in the CIE implies the presence of an 	 augmentation field in the FDE as well.  The only thing known 	 to be in here at present is the LSDA entry for EH.  So we 	 can skip the whole thing.  */
if|if
condition|(
name|fde
operator|->
name|cie
operator|->
name|saw_z_augmentation
condition|)
block|{
name|ULONGEST
name|length
decl_stmt|;
name|length
operator|=
name|read_unsigned_leb128
argument_list|(
name|unit
operator|->
name|abfd
argument_list|,
name|buf
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|bytes_read
operator|+
name|length
expr_stmt|;
if|if
condition|(
name|buf
operator|>
name|end
condition|)
return|return
name|NULL
return|;
block|}
name|fde
operator|->
name|instructions
operator|=
name|buf
expr_stmt|;
name|fde
operator|->
name|end
operator|=
name|end
expr_stmt|;
name|add_fde
argument_list|(
name|unit
argument_list|,
name|fde
argument_list|)
expr_stmt|;
block|}
return|return
name|end
return|;
block|}
end_function

begin_comment
comment|/* Read a CIE or FDE in BUF and decode it.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|decode_frame_entry
parameter_list|(
name|struct
name|comp_unit
modifier|*
name|unit
parameter_list|,
name|char
modifier|*
name|start
parameter_list|,
name|int
name|eh_frame_p
parameter_list|)
block|{
enum|enum
block|{
name|NONE
block|,
name|ALIGN4
block|,
name|ALIGN8
block|,
name|FAIL
block|}
name|workaround
init|=
name|NONE
enum|;
name|char
modifier|*
name|ret
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
name|ptrdiff_t
name|start_offset
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|ret
operator|=
name|decode_frame_entry_1
argument_list|(
name|unit
argument_list|,
name|start
argument_list|,
name|eh_frame_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|NULL
condition|)
break|break;
comment|/* We have corrupt input data of some form.  */
comment|/* ??? Try, weakly, to work around compiler/assembler/linker bugs 	 and mismatches wrt padding and alignment of debug sections.  */
comment|/* Note that there is no requirement in the standard for any 	 alignment at all in the frame unwind sections.  Testing for 	 alignment before trying to interpret data would be incorrect.  	 However, GCC traditionally arranged for frame sections to be 	 sized such that the FDE length and CIE fields happen to be 	 aligned (in theory, for performance).  This, unfortunately, 	 was done with .align directives, which had the side effect of 	 forcing the section to be aligned by the linker.  	 This becomes a problem when you have some other producer that 	 creates frame sections that are not as strictly aligned.  That 	 produces a hole in the frame info that gets filled by the  	 linker with zeros.  	 The GCC behaviour is arguably a bug, but it's effectively now 	 part of the ABI, so we're now stuck with it, at least at the 	 object file level.  A smart linker may decide, in the process 	 of compressing duplicate CIE information, that it can rewrite 	 the entire output section without this extra padding.  */
name|start_offset
operator|=
name|start
operator|-
name|unit
operator|->
name|dwarf_frame_buffer
expr_stmt|;
if|if
condition|(
name|workaround
operator|<
name|ALIGN4
operator|&&
operator|(
name|start_offset
operator|&
literal|3
operator|)
operator|!=
literal|0
condition|)
block|{
name|start
operator|+=
literal|4
operator|-
operator|(
name|start_offset
operator|&
literal|3
operator|)
expr_stmt|;
name|workaround
operator|=
name|ALIGN4
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|workaround
operator|<
name|ALIGN8
operator|&&
operator|(
name|start_offset
operator|&
literal|7
operator|)
operator|!=
literal|0
condition|)
block|{
name|start
operator|+=
literal|8
operator|-
operator|(
name|start_offset
operator|&
literal|7
operator|)
expr_stmt|;
name|workaround
operator|=
name|ALIGN8
expr_stmt|;
continue|continue;
block|}
comment|/* Nothing left to try.  Arrange to return as if we've consumed 	 the entire input section.  Hopefully we'll get valid info from 	 the other of .debug_frame/.eh_frame.  */
name|workaround
operator|=
name|FAIL
expr_stmt|;
name|ret
operator|=
name|unit
operator|->
name|dwarf_frame_buffer
operator|+
name|unit
operator|->
name|dwarf_frame_size
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|workaround
condition|)
block|{
case|case
name|NONE
case|:
break|break;
case|case
name|ALIGN4
case|:
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"Corrupt data in %s:%s; align 4 workaround apparently succeeded"
argument_list|,
name|unit
operator|->
name|dwarf_frame_section
operator|->
name|owner
operator|->
name|filename
argument_list|,
name|unit
operator|->
name|dwarf_frame_section
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|ALIGN8
case|:
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"Corrupt data in %s:%s; align 8 workaround apparently succeeded"
argument_list|,
name|unit
operator|->
name|dwarf_frame_section
operator|->
name|owner
operator|->
name|filename
argument_list|,
name|unit
operator|->
name|dwarf_frame_section
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
default|default:
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"Corrupt data in %s:%s"
argument_list|,
name|unit
operator|->
name|dwarf_frame_section
operator|->
name|owner
operator|->
name|filename
argument_list|,
name|unit
operator|->
name|dwarf_frame_section
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* FIXME: kettenis/20030504: This still needs to be integrated with    dwarf2read.c in a better way.  */
end_comment

begin_comment
comment|/* Imported from dwarf2read.c.  */
end_comment

begin_decl_stmt
specifier|extern
name|asection
modifier|*
name|dwarf_frame_section
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|asection
modifier|*
name|dwarf_eh_frame_section
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Imported from dwarf2read.c.  */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|dwarf2_read_section
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|,
name|asection
modifier|*
name|sectp
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|dwarf2_build_frame_info
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|struct
name|comp_unit
name|unit
decl_stmt|;
name|char
modifier|*
name|frame_ptr
decl_stmt|;
comment|/* Build a minimal decoding of the DWARF2 compilation unit.  */
name|unit
operator|.
name|abfd
operator|=
name|objfile
operator|->
name|obfd
expr_stmt|;
name|unit
operator|.
name|objfile
operator|=
name|objfile
expr_stmt|;
name|unit
operator|.
name|addr_size
operator|=
name|objfile
operator|->
name|obfd
operator|->
name|arch_info
operator|->
name|bits_per_address
operator|/
literal|8
expr_stmt|;
name|unit
operator|.
name|dbase
operator|=
literal|0
expr_stmt|;
name|unit
operator|.
name|tbase
operator|=
literal|0
expr_stmt|;
comment|/* First add the information from the .eh_frame section.  That way,      the FDEs from that section are searched last.  */
if|if
condition|(
name|dwarf_eh_frame_section
condition|)
block|{
name|asection
modifier|*
name|got
decl_stmt|,
modifier|*
name|txt
decl_stmt|;
name|unit
operator|.
name|cie
operator|=
name|NULL
expr_stmt|;
name|unit
operator|.
name|dwarf_frame_buffer
operator|=
name|dwarf2_read_section
argument_list|(
name|objfile
argument_list|,
name|dwarf_eh_frame_section
argument_list|)
expr_stmt|;
name|unit
operator|.
name|dwarf_frame_size
operator|=
name|bfd_get_section_size_before_reloc
argument_list|(
name|dwarf_eh_frame_section
argument_list|)
expr_stmt|;
name|unit
operator|.
name|dwarf_frame_section
operator|=
name|dwarf_eh_frame_section
expr_stmt|;
comment|/* FIXME: kettenis/20030602: This is the DW_EH_PE_datarel base 	 that is used for the i386/amd64 target, which currently is 	 the only target in GCC that supports/uses the 	 DW_EH_PE_datarel encoding.  */
name|got
operator|=
name|bfd_get_section_by_name
argument_list|(
name|unit
operator|.
name|abfd
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
if|if
condition|(
name|got
condition|)
name|unit
operator|.
name|dbase
operator|=
name|got
operator|->
name|vma
expr_stmt|;
comment|/* GCC emits the DW_EH_PE_textrel encoding type on sh and ia64          so far.  */
name|txt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|unit
operator|.
name|abfd
argument_list|,
literal|".text"
argument_list|)
expr_stmt|;
if|if
condition|(
name|txt
condition|)
name|unit
operator|.
name|tbase
operator|=
name|txt
operator|->
name|vma
expr_stmt|;
name|frame_ptr
operator|=
name|unit
operator|.
name|dwarf_frame_buffer
expr_stmt|;
while|while
condition|(
name|frame_ptr
operator|<
name|unit
operator|.
name|dwarf_frame_buffer
operator|+
name|unit
operator|.
name|dwarf_frame_size
condition|)
name|frame_ptr
operator|=
name|decode_frame_entry
argument_list|(
operator|&
name|unit
argument_list|,
name|frame_ptr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dwarf_frame_section
condition|)
block|{
name|unit
operator|.
name|cie
operator|=
name|NULL
expr_stmt|;
name|unit
operator|.
name|dwarf_frame_buffer
operator|=
name|dwarf2_read_section
argument_list|(
name|objfile
argument_list|,
name|dwarf_frame_section
argument_list|)
expr_stmt|;
name|unit
operator|.
name|dwarf_frame_size
operator|=
name|bfd_get_section_size_before_reloc
argument_list|(
name|dwarf_frame_section
argument_list|)
expr_stmt|;
name|unit
operator|.
name|dwarf_frame_section
operator|=
name|dwarf_frame_section
expr_stmt|;
name|frame_ptr
operator|=
name|unit
operator|.
name|dwarf_frame_buffer
expr_stmt|;
while|while
condition|(
name|frame_ptr
operator|<
name|unit
operator|.
name|dwarf_frame_buffer
operator|+
name|unit
operator|.
name|dwarf_frame_size
condition|)
name|frame_ptr
operator|=
name|decode_frame_entry
argument_list|(
operator|&
name|unit
argument_list|,
name|frame_ptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Provide a prototype to silence -Wmissing-prototypes.  */
end_comment

begin_function_decl
name|void
name|_initialize_dwarf2_frame
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|_initialize_dwarf2_frame
parameter_list|(
name|void
parameter_list|)
block|{
name|dwarf2_frame_data
operator|=
name|register_gdbarch_data
argument_list|(
name|dwarf2_frame_init
argument_list|)
expr_stmt|;
name|dwarf2_frame_objfile_data
operator|=
name|register_objfile_data
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

