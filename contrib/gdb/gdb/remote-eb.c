begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Remote debugging interface for AMD 29000 EBMON on IBM PC, for GDB.    Copyright 1990, 1991, 1992 Free Software Foundation, Inc.    Contributed by Cygnus Support.  Written by Jim Kingdon for Cygnus.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This is like remote.c but is for an esoteric situation--    having a a29k board in a PC hooked up to a unix machine with    a serial line, and running ctty com1 on the PC, through which    the unix machine can run ebmon.  Not to mention that the PC    has PC/NFS, so it can access the same executables that gdb can,    over the net in real time.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"wait.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"terminal.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_decl_stmt
specifier|extern
name|struct
name|target_ops
name|eb_ops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward declaration */
end_comment

begin_function_decl
specifier|static
name|void
name|eb_close
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|LOG_FILE
value|"eb.log"
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|LOG_FILE
argument_list|)
end_if

begin_decl_stmt
name|FILE
modifier|*
name|log_file
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|timeout
init|=
literal|24
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Descriptor for I/O to remote machine.  Initialize it to -1 so that    eb_open knows that we don't have a file open when the program    starts.  */
end_comment

begin_decl_stmt
name|int
name|eb_desc
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* stream which is fdopen'd from eb_desc.  Only valid when    eb_desc != -1.  */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|eb_stream
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Read a character from the remote system, doing all the fancy    timeout stuff.  */
end_comment

begin_function
specifier|static
name|int
name|readchar
parameter_list|()
block|{
name|char
name|buf
decl_stmt|;
name|buf
operator|=
literal|'\0'
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_TERMIO
comment|/* termio does the timeout for us.  */
name|read
argument_list|(
name|eb_desc
argument_list|,
operator|&
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
name|alarm
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|eb_desc
argument_list|,
operator|&
name|buf
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
name|error
argument_list|(
literal|"Timeout reading from remote system."
argument_list|)
expr_stmt|;
else|else
name|perror_with_name
argument_list|(
literal|"remote"
argument_list|)
expr_stmt|;
block|}
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|buf
operator|==
literal|'\0'
condition|)
name|error
argument_list|(
literal|"Timeout reading from remote system."
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|LOG_FILE
argument_list|)
name|putc
argument_list|(
name|buf
operator|&
literal|0x7f
argument_list|,
name|log_file
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|buf
operator|&
literal|0x7f
return|;
block|}
end_function

begin_comment
comment|/* Keep discarding input from the remote system, until STRING is found.     Let the user break out immediately.  */
end_comment

begin_function
specifier|static
name|void
name|expect
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|char
modifier|*
name|p
init|=
name|string
decl_stmt|;
name|immediate_quit
operator|=
literal|1
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|readchar
argument_list|()
operator|==
operator|*
name|p
condition|)
block|{
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
name|immediate_quit
operator|=
literal|0
expr_stmt|;
return|return;
block|}
block|}
else|else
name|p
operator|=
name|string
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Keep discarding input until we see the ebmon prompt.     The convention for dealing with the prompt is that you    o give your command    o *then* wait for the prompt.     Thus the last thing that a procedure does with the serial line    will be an expect_prompt().  Exception:  eb_resume does not    wait for the prompt, because the terminal is being handed over    to the inferior.  However, the next thing which happens after that    is a eb_wait which does wait for the prompt.    Note that this includes abnormal exit, e.g. error().  This is    necessary to prevent getting into states from which we can't    recover.  */
end_comment

begin_function
specifier|static
name|void
name|expect_prompt
parameter_list|()
block|{
if|#
directive|if
name|defined
argument_list|(
name|LOG_FILE
argument_list|)
comment|/* This is a convenient place to do this.  The idea is to do it often      enough that we never lose much data if we terminate abnormally.  */
name|fflush
argument_list|(
name|log_file
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|expect
argument_list|(
literal|"\n# "
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get a hex digit from the remote system& return its value.    If ignore_space is nonzero, ignore spaces (not newline, tab, etc).  */
end_comment

begin_function
specifier|static
name|int
name|get_hex_digit
parameter_list|(
name|ignore_space
parameter_list|)
name|int
name|ignore_space
decl_stmt|;
block|{
name|int
name|ch
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|ch
operator|=
name|readchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|ch
operator|>=
literal|'0'
operator|&&
name|ch
operator|<=
literal|'9'
condition|)
return|return
name|ch
operator|-
literal|'0'
return|;
elseif|else
if|if
condition|(
name|ch
operator|>=
literal|'A'
operator|&&
name|ch
operator|<=
literal|'F'
condition|)
return|return
name|ch
operator|-
literal|'A'
operator|+
literal|10
return|;
elseif|else
if|if
condition|(
name|ch
operator|>=
literal|'a'
operator|&&
name|ch
operator|<=
literal|'f'
condition|)
return|return
name|ch
operator|-
literal|'a'
operator|+
literal|10
return|;
elseif|else
if|if
condition|(
name|ch
operator|==
literal|' '
operator|&&
name|ignore_space
condition|)
empty_stmt|;
else|else
block|{
name|expect_prompt
argument_list|()
expr_stmt|;
name|error
argument_list|(
literal|"Invalid hex digit from remote system."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Get a byte from eb_desc and put it in *BYT.  Accept any number    leading spaces.  */
end_comment

begin_function
specifier|static
name|void
name|get_hex_byte
parameter_list|(
name|byt
parameter_list|)
name|char
modifier|*
name|byt
decl_stmt|;
block|{
name|int
name|val
decl_stmt|;
name|val
operator|=
name|get_hex_digit
argument_list|(
literal|1
argument_list|)
operator|<<
literal|4
expr_stmt|;
name|val
operator||=
name|get_hex_digit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|*
name|byt
operator|=
name|val
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get N 32-bit words from remote, each preceded by a space,    and put them in registers starting at REGNO.  */
end_comment

begin_function
specifier|static
name|void
name|get_hex_regs
parameter_list|(
name|n
parameter_list|,
name|regno
parameter_list|)
name|int
name|n
decl_stmt|;
name|int
name|regno
decl_stmt|;
block|{
name|long
name|val
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
decl_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|8
condition|;
name|j
operator|++
control|)
name|val
operator|=
operator|(
name|val
operator|<<
literal|4
operator|)
operator|+
name|get_hex_digit
argument_list|(
name|j
operator|==
literal|0
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|regno
operator|++
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|val
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Called when SIGALRM signal sent due to alarm() timeout.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_TERMIO
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|__STDC__
end_ifndef

begin_define
define|#
directive|define
name|volatile
end_define

begin_comment
comment|/**/
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|volatile
name|int
name|n_alarms
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|eb_timer
parameter_list|()
block|{
if|#
directive|if
literal|0
block|if (kiodebug)     printf ("eb_timer called\n");
endif|#
directive|endif
name|n_alarms
operator|++
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* malloc'd name of the program on the remote system.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|prog_name
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we have loaded the file ("yc") and not yet issued a "gi"    command.  "gi" is supposed to happen exactly once for each "yc".  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|need_gi
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of SIGTRAPs we need to simulate.  That is, the next    NEED_ARTIFICIAL_TRAP calls to eb_wait should just return    SIGTRAP without actually waiting for anything.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|need_artificial_trap
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is called not only when we first attach, but also when the    user types "run" after having attached.  */
end_comment

begin_function
specifier|static
name|void
name|eb_create_inferior
parameter_list|(
name|execfile
parameter_list|,
name|args
parameter_list|,
name|env
parameter_list|)
name|char
modifier|*
name|execfile
decl_stmt|;
name|char
modifier|*
name|args
decl_stmt|;
name|char
modifier|*
modifier|*
name|env
decl_stmt|;
block|{
name|int
name|entry_pt
decl_stmt|;
if|if
condition|(
name|args
operator|&&
operator|*
name|args
condition|)
name|error
argument_list|(
literal|"Can't pass arguments to remote EBMON process"
argument_list|)
expr_stmt|;
if|if
condition|(
name|execfile
operator|==
literal|0
operator|||
name|exec_bfd
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No exec file specified"
argument_list|)
expr_stmt|;
name|entry_pt
operator|=
operator|(
name|int
operator|)
name|bfd_get_start_address
argument_list|(
name|exec_bfd
argument_list|)
expr_stmt|;
block|{
comment|/* OK, now read in the file.  Y=read, C=COFF, D=no symbols        0=start address, %s=filename.  */
name|fprintf
argument_list|(
name|eb_stream
argument_list|,
literal|"YC D,0:%s"
argument_list|,
name|prog_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|eb_stream
argument_list|,
literal|" %s"
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|eb_stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|eb_stream
argument_list|)
expr_stmt|;
name|expect_prompt
argument_list|()
expr_stmt|;
name|need_gi
operator|=
literal|1
expr_stmt|;
block|}
comment|/* The "process" (board) is already stopped awaiting our commands, and    the program is already downloaded.  We just set its PC and go.  */
name|clear_proceed_status
argument_list|()
expr_stmt|;
comment|/* Tell wait_for_inferior that we've started a new process.  */
name|init_wait_for_inferior
argument_list|()
expr_stmt|;
comment|/* Set up the "saved terminal modes" of the inferior      based on what modes we are starting it with.  */
name|target_terminal_init
argument_list|()
expr_stmt|;
comment|/* Install inferior's terminal modes.  */
name|target_terminal_inferior
argument_list|()
expr_stmt|;
comment|/* insert_step_breakpoint ();  FIXME, do we need this?  */
name|proceed
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|entry_pt
argument_list|,
name|TARGET_SIGNAL_DEFAULT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Let 'er rip... */
block|}
end_function

begin_comment
comment|/* Translate baud rates from integers to damn B_codes.  Unix should    have outgrown this crap years ago, but even POSIX wouldn't buck it.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|B19200
end_ifndef

begin_define
define|#
directive|define
name|B19200
value|EXTA
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|B38400
end_ifndef

begin_define
define|#
directive|define
name|B38400
value|EXTB
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
block|{
name|int
name|rate
decl_stmt|,
name|damn_b
decl_stmt|;
block|}
name|baudtab
index|[]
init|=
block|{
block|{
literal|0
block|,
name|B0
block|}
block|,
block|{
literal|50
block|,
name|B50
block|}
block|,
block|{
literal|75
block|,
name|B75
block|}
block|,
block|{
literal|110
block|,
name|B110
block|}
block|,
block|{
literal|134
block|,
name|B134
block|}
block|,
block|{
literal|150
block|,
name|B150
block|}
block|,
block|{
literal|200
block|,
name|B200
block|}
block|,
block|{
literal|300
block|,
name|B300
block|}
block|,
block|{
literal|600
block|,
name|B600
block|}
block|,
block|{
literal|1200
block|,
name|B1200
block|}
block|,
block|{
literal|1800
block|,
name|B1800
block|}
block|,
block|{
literal|2400
block|,
name|B2400
block|}
block|,
block|{
literal|4800
block|,
name|B4800
block|}
block|,
block|{
literal|9600
block|,
name|B9600
block|}
block|,
block|{
literal|19200
block|,
name|B19200
block|}
block|,
block|{
literal|38400
block|,
name|B38400
block|}
block|,
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|, }
struct|;
end_struct

begin_function
name|int
name|damn_b
parameter_list|(
name|rate
parameter_list|)
name|int
name|rate
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|baudtab
index|[
name|i
index|]
operator|.
name|rate
operator|!=
operator|-
literal|1
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|rate
operator|==
name|baudtab
index|[
name|i
index|]
operator|.
name|rate
condition|)
return|return
name|baudtab
index|[
name|i
index|]
operator|.
name|damn_b
return|;
return|return
name|B38400
return|;
comment|/* Random */
block|}
end_function

begin_comment
comment|/* Open a connection to a remote debugger.    NAME is the filename used for communication, then a space,    then the name of the program as we should name it to EBMON.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|baudrate
init|=
literal|9600
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|dev_name
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|eb_open
parameter_list|(
name|name
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|TERMINAL
name|sg
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|target_preopen
argument_list|(
name|from_tty
argument_list|)
expr_stmt|;
comment|/* Find the first whitespace character, it separates dev_name from      prog_name.  */
if|if
condition|(
name|name
operator|==
literal|0
condition|)
goto|goto
name|erroid
goto|;
for|for
control|(
name|p
operator|=
name|name
init|;
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
name|erroid
label|:
name|error
argument_list|(
literal|"\ Please include the name of the device for the serial port,\n\ the baud rate, and the name of the program to run on the remote system."
argument_list|)
expr_stmt|;
name|dev_name
operator|=
name|alloca
argument_list|(
name|p
operator|-
name|name
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|dev_name
argument_list|,
name|name
argument_list|,
name|p
operator|-
name|name
argument_list|)
expr_stmt|;
name|dev_name
index|[
name|p
operator|-
name|name
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Skip over the whitespace after dev_name */
for|for
control|(
init|;
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
comment|/*EMPTY*/
empty_stmt|;
if|if
condition|(
literal|1
operator|!=
name|sscanf
argument_list|(
name|p
argument_list|,
literal|"%d "
argument_list|,
operator|&
name|baudrate
argument_list|)
condition|)
goto|goto
name|erroid
goto|;
comment|/* Skip the number and then the spaces */
for|for
control|(
init|;
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
comment|/*EMPTY*/
empty_stmt|;
for|for
control|(
init|;
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
comment|/*EMPTY*/
empty_stmt|;
if|if
condition|(
name|prog_name
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|prog_name
argument_list|)
expr_stmt|;
name|prog_name
operator|=
name|savestring
argument_list|(
name|p
argument_list|,
name|strlen
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|eb_close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|eb_desc
operator|=
name|open
argument_list|(
name|dev_name
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|eb_desc
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|dev_name
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|eb_desc
argument_list|,
name|TIOCGETP
argument_list|,
operator|&
name|sg
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_TERMIO
name|sg
operator|.
name|c_cc
index|[
name|VMIN
index|]
operator|=
literal|0
expr_stmt|;
comment|/* read with timeout.  */
name|sg
operator|.
name|c_cc
index|[
name|VTIME
index|]
operator|=
name|timeout
operator|*
literal|10
expr_stmt|;
name|sg
operator|.
name|c_lflag
operator|&=
operator|~
operator|(
name|ICANON
operator||
name|ECHO
operator|)
expr_stmt|;
name|sg
operator|.
name|c_cflag
operator|=
operator|(
name|sg
operator|.
name|c_cflag
operator|&
operator|~
name|CBAUD
operator|)
operator||
name|damn_b
argument_list|(
name|baudrate
argument_list|)
expr_stmt|;
else|#
directive|else
name|sg
operator|.
name|sg_ispeed
operator|=
name|damn_b
argument_list|(
name|baudrate
argument_list|)
expr_stmt|;
name|sg
operator|.
name|sg_ospeed
operator|=
name|damn_b
argument_list|(
name|baudrate
argument_list|)
expr_stmt|;
name|sg
operator|.
name|sg_flags
operator||=
name|RAW
operator||
name|ANYP
expr_stmt|;
name|sg
operator|.
name|sg_flags
operator|&=
operator|~
name|ECHO
expr_stmt|;
endif|#
directive|endif
name|ioctl
argument_list|(
name|eb_desc
argument_list|,
name|TIOCSETP
argument_list|,
operator|&
name|sg
argument_list|)
expr_stmt|;
name|eb_stream
operator|=
name|fdopen
argument_list|(
name|eb_desc
argument_list|,
literal|"r+"
argument_list|)
expr_stmt|;
name|push_target
argument_list|(
operator|&
name|eb_ops
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
name|printf
argument_list|(
literal|"Remote %s debugging %s using %s\n"
argument_list|,
name|target_shortname
argument_list|,
name|prog_name
argument_list|,
name|dev_name
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|HAVE_TERMIO
ifndef|#
directive|ifndef
name|NO_SIGINTERRUPT
comment|/* Cause SIGALRM's to make reads fail with EINTR instead of resuming      the read.  */
if|if
condition|(
name|siginterrupt
argument_list|(
name|SIGALRM
argument_list|,
literal|1
argument_list|)
operator|!=
literal|0
condition|)
name|perror
argument_list|(
literal|"eb_open: error in siginterrupt"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Set up read timeout timer.  */
if|if
condition|(
operator|(
name|void
argument_list|(
operator|*
argument_list|)
operator|)
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|eb_timer
argument_list|)
operator|==
operator|(
name|void
argument_list|(
operator|*
argument_list|)
operator|)
operator|-
literal|1
condition|)
name|perror
argument_list|(
literal|"eb_open: error in signal"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|LOG_FILE
argument_list|)
name|log_file
operator|=
name|fopen
argument_list|(
name|LOG_FILE
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|log_file
operator|==
name|NULL
condition|)
name|perror_with_name
argument_list|(
name|LOG_FILE
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Hello?  Are you there?  */
name|write
argument_list|(
name|eb_desc
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|expect_prompt
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Close out all files and local state before this target loses control. */
end_comment

begin_function
specifier|static
name|void
name|eb_close
parameter_list|(
name|quitting
parameter_list|)
name|int
name|quitting
decl_stmt|;
block|{
comment|/* Due to a bug in Unix, fclose closes not only the stdio stream,      but also the file descriptor.  So we don't actually close      eb_desc.  */
if|if
condition|(
name|eb_stream
condition|)
name|fclose
argument_list|(
name|eb_stream
argument_list|)
expr_stmt|;
comment|/* This also closes eb_desc */
if|if
condition|(
name|eb_desc
operator|>=
literal|0
condition|)
comment|/* close (eb_desc); */
comment|/* Do not try to close eb_desc again, later in the program.  */
name|eb_stream
operator|=
name|NULL
expr_stmt|;
name|eb_desc
operator|=
operator|-
literal|1
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|LOG_FILE
argument_list|)
if|if
condition|(
name|log_file
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|log_file
argument_list|)
condition|)
name|printf
argument_list|(
literal|"Error writing log file.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|log_file
argument_list|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"Error closing log file.\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Terminate the open connection to the remote debugger.    Use this when you want to detach and do something else    with your gdb.  */
end_comment

begin_function
name|void
name|eb_detach
parameter_list|(
name|from_tty
parameter_list|)
name|int
name|from_tty
decl_stmt|;
block|{
name|pop_target
argument_list|()
expr_stmt|;
comment|/* calls eb_close to do the real work */
if|if
condition|(
name|from_tty
condition|)
name|printf
argument_list|(
literal|"Ending remote %s debugging\n"
argument_list|,
name|target_shortname
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Tell the remote machine to resume.  */
end_comment

begin_function
name|void
name|eb_resume
parameter_list|(
name|pid
parameter_list|,
name|step
parameter_list|,
name|sig
parameter_list|)
name|int
name|pid
decl_stmt|,
name|step
decl_stmt|;
name|enum
name|target_signal
name|sig
decl_stmt|;
block|{
if|if
condition|(
name|step
condition|)
block|{
name|write
argument_list|(
name|eb_desc
argument_list|,
literal|"t 1,s\n"
argument_list|,
literal|6
argument_list|)
expr_stmt|;
comment|/* Wait for the echo.  */
name|expect
argument_list|(
literal|"t 1,s\r"
argument_list|)
expr_stmt|;
comment|/* Then comes a line containing the instruction we stepped to.  */
name|expect
argument_list|(
literal|"\n@"
argument_list|)
expr_stmt|;
comment|/* Then we get the prompt.  */
name|expect_prompt
argument_list|()
expr_stmt|;
comment|/* Force the next eb_wait to return a trap.  Not doing anything          about I/O from the target means that the user has to type          "continue" to see any.  This should be fixed.  */
name|need_artificial_trap
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|need_gi
condition|)
block|{
name|need_gi
operator|=
literal|0
expr_stmt|;
name|write
argument_list|(
name|eb_desc
argument_list|,
literal|"gi\n"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
comment|/* Swallow the echo of "gi".  */
name|expect
argument_list|(
literal|"gi\r"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|write
argument_list|(
name|eb_desc
argument_list|,
literal|"GR\n"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
comment|/* Swallow the echo.  */
name|expect
argument_list|(
literal|"GR\r"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Wait until the remote machine stops, then return,    storing status in STATUS just as `wait' would.  */
end_comment

begin_function
name|int
name|eb_wait
parameter_list|(
name|status
parameter_list|)
name|struct
name|target_waitstatus
modifier|*
name|status
decl_stmt|;
block|{
comment|/* Strings to look for.  '?' means match any single character.        Note that with the algorithm we use, the initial character      of the string cannot recur in the string, or we will not      find some cases of the string in the input.  */
specifier|static
name|char
name|bpt
index|[]
init|=
literal|"Invalid interrupt taken - #0x50 - "
decl_stmt|;
comment|/* It would be tempting to look for "\n[__exit + 0x8]\n"      but that requires loading symbols with "yc i" and even if      we did do that we don't know that the file has symbols.  */
specifier|static
name|char
name|exitmsg
index|[]
init|=
literal|"\n@????????I    JMPTI     GR121,LR0"
decl_stmt|;
name|char
modifier|*
name|bp
init|=
name|bpt
decl_stmt|;
name|char
modifier|*
name|ep
init|=
name|exitmsg
decl_stmt|;
comment|/* Large enough for either sizeof (bpt) or sizeof (exitmsg) chars.  */
name|char
name|swallowed
index|[
literal|50
index|]
decl_stmt|;
comment|/* Current position in swallowed.  */
name|char
modifier|*
name|swallowed_p
init|=
name|swallowed
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|int
name|ch_handled
decl_stmt|;
name|int
name|old_timeout
init|=
name|timeout
decl_stmt|;
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_EXITED
expr_stmt|;
name|status
operator|->
name|value
operator|.
name|integer
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|need_artificial_trap
operator|!=
literal|0
condition|)
block|{
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_STOPPED
expr_stmt|;
name|status
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_TRAP
expr_stmt|;
name|need_artificial_trap
operator|--
expr_stmt|;
return|return
literal|0
return|;
block|}
name|timeout
operator|=
literal|0
expr_stmt|;
comment|/* Don't time out -- user program is running. */
while|while
condition|(
literal|1
condition|)
block|{
name|ch_handled
operator|=
literal|0
expr_stmt|;
name|ch
operator|=
name|readchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|ch
operator|==
operator|*
name|bp
condition|)
block|{
name|bp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\0'
condition|)
break|break;
name|ch_handled
operator|=
literal|1
expr_stmt|;
operator|*
name|swallowed_p
operator|++
operator|=
name|ch
expr_stmt|;
block|}
else|else
name|bp
operator|=
name|bpt
expr_stmt|;
if|if
condition|(
name|ch
operator|==
operator|*
name|ep
operator|||
operator|*
name|ep
operator|==
literal|'?'
condition|)
block|{
name|ep
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|ep
operator|==
literal|'\0'
condition|)
break|break;
if|if
condition|(
operator|!
name|ch_handled
condition|)
operator|*
name|swallowed_p
operator|++
operator|=
name|ch
expr_stmt|;
name|ch_handled
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|ep
operator|=
name|exitmsg
expr_stmt|;
if|if
condition|(
operator|!
name|ch_handled
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Print out any characters which have been swallowed.  */
for|for
control|(
name|p
operator|=
name|swallowed
init|;
name|p
operator|<
name|swallowed_p
condition|;
operator|++
name|p
control|)
name|putc
argument_list|(
operator|*
name|p
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|swallowed_p
operator|=
name|swallowed
expr_stmt|;
name|putc
argument_list|(
name|ch
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
name|expect_prompt
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\0'
condition|)
block|{
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_STOPPED
expr_stmt|;
name|status
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_TRAP
expr_stmt|;
block|}
else|else
block|{
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_EXITED
expr_stmt|;
name|status
operator|->
name|value
operator|.
name|integer
operator|=
literal|0
expr_stmt|;
block|}
name|timeout
operator|=
name|old_timeout
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return the name of register number REGNO    in the form input and output by EBMON.     Returns a pointer to a static buffer containing the answer.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|get_reg_name
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
specifier|static
name|char
name|buf
index|[
literal|80
index|]
decl_stmt|;
if|if
condition|(
name|regno
operator|>=
name|GR96_REGNUM
operator|&&
name|regno
operator|<
name|GR96_REGNUM
operator|+
literal|32
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"GR%03d"
argument_list|,
name|regno
operator|-
name|GR96_REGNUM
operator|+
literal|96
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|regno
operator|>=
name|LR0_REGNUM
operator|&&
name|regno
operator|<
name|LR0_REGNUM
operator|+
literal|128
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"LR%03d"
argument_list|,
name|regno
operator|-
name|LR0_REGNUM
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|regno
operator|==
name|Q_REGNUM
condition|)
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"SR131"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|regno
operator|>=
name|BP_REGNUM
operator|&&
name|regno
operator|<=
name|CR_REGNUM
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"SR%03d"
argument_list|,
name|regno
operator|-
name|BP_REGNUM
operator|+
literal|133
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|regno
operator|==
name|ALU_REGNUM
condition|)
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"SR132"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|regno
operator|>=
name|IPC_REGNUM
operator|&&
name|regno
operator|<=
name|IPB_REGNUM
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"SR%03d"
argument_list|,
name|regno
operator|-
name|IPC_REGNUM
operator|+
literal|128
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|regno
operator|>=
name|VAB_REGNUM
operator|&&
name|regno
operator|<=
name|LRU_REGNUM
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"SR%03d"
argument_list|,
name|regno
operator|-
name|VAB_REGNUM
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|regno
operator|==
name|GR1_REGNUM
condition|)
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"GR001"
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/* Read the remote registers into the block REGS.  */
end_comment

begin_function
specifier|static
name|void
name|eb_fetch_registers
parameter_list|()
block|{
name|int
name|reg_index
decl_stmt|;
name|int
name|regnum_index
decl_stmt|;
name|char
name|tempbuf
index|[
literal|10
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
if|#
directive|if
literal|0
comment|/* This should not be necessary, because one is supposed to read the      registers only when the inferior is stopped (at least with      ptrace() and why not make it the same for remote?).  */
comment|/* ^A is the "normal character" used to make sure we are talking to EBMON      and not to the program being debugged.  */
block|write (eb_desc, "\001\n");   expect_prompt ();
endif|#
directive|endif
name|write
argument_list|(
name|eb_desc
argument_list|,
literal|"dw gr96,gr127\n"
argument_list|,
literal|14
argument_list|)
expr_stmt|;
for|for
control|(
name|reg_index
operator|=
literal|96
operator|,
name|regnum_index
operator|=
name|GR96_REGNUM
init|;
name|reg_index
operator|<
literal|128
condition|;
name|reg_index
operator|+=
literal|4
operator|,
name|regnum_index
operator|+=
literal|4
control|)
block|{
name|sprintf
argument_list|(
name|tempbuf
argument_list|,
literal|"GR%03d "
argument_list|,
name|reg_index
argument_list|)
expr_stmt|;
name|expect
argument_list|(
name|tempbuf
argument_list|)
expr_stmt|;
name|get_hex_regs
argument_list|(
literal|4
argument_list|,
name|regnum_index
argument_list|)
expr_stmt|;
name|expect
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|128
condition|;
name|i
operator|+=
literal|32
control|)
block|{
comment|/* The PC has a tendency to hang if we get these 	 all in one fell swoop ("dw lr0,lr127").  */
name|sprintf
argument_list|(
name|tempbuf
argument_list|,
literal|"dw lr%d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|eb_desc
argument_list|,
name|tempbuf
argument_list|,
name|strlen
argument_list|(
name|tempbuf
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|reg_index
operator|=
name|i
operator|,
name|regnum_index
operator|=
name|LR0_REGNUM
operator|+
name|i
init|;
name|reg_index
operator|<
name|i
operator|+
literal|32
condition|;
name|reg_index
operator|+=
literal|4
operator|,
name|regnum_index
operator|+=
literal|4
control|)
block|{
name|sprintf
argument_list|(
name|tempbuf
argument_list|,
literal|"LR%03d "
argument_list|,
name|reg_index
argument_list|)
expr_stmt|;
name|expect
argument_list|(
name|tempbuf
argument_list|)
expr_stmt|;
name|get_hex_regs
argument_list|(
literal|4
argument_list|,
name|regnum_index
argument_list|)
expr_stmt|;
name|expect
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|write
argument_list|(
name|eb_desc
argument_list|,
literal|"dw sr133,sr133\n"
argument_list|,
literal|15
argument_list|)
expr_stmt|;
name|expect
argument_list|(
literal|"SR133          "
argument_list|)
expr_stmt|;
name|get_hex_regs
argument_list|(
literal|1
argument_list|,
name|BP_REGNUM
argument_list|)
expr_stmt|;
name|expect
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|eb_desc
argument_list|,
literal|"dw sr134,sr134\n"
argument_list|,
literal|15
argument_list|)
expr_stmt|;
name|expect
argument_list|(
literal|"SR134                   "
argument_list|)
expr_stmt|;
name|get_hex_regs
argument_list|(
literal|1
argument_list|,
name|FC_REGNUM
argument_list|)
expr_stmt|;
name|expect
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|eb_desc
argument_list|,
literal|"dw sr135,sr135\n"
argument_list|,
literal|15
argument_list|)
expr_stmt|;
name|expect
argument_list|(
literal|"SR135                            "
argument_list|)
expr_stmt|;
name|get_hex_regs
argument_list|(
literal|1
argument_list|,
name|CR_REGNUM
argument_list|)
expr_stmt|;
name|expect
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|eb_desc
argument_list|,
literal|"dw sr131,sr131\n"
argument_list|,
literal|15
argument_list|)
expr_stmt|;
name|expect
argument_list|(
literal|"SR131                            "
argument_list|)
expr_stmt|;
name|get_hex_regs
argument_list|(
literal|1
argument_list|,
name|Q_REGNUM
argument_list|)
expr_stmt|;
name|expect
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|eb_desc
argument_list|,
literal|"dw sr0,sr14\n"
argument_list|,
literal|12
argument_list|)
expr_stmt|;
for|for
control|(
name|reg_index
operator|=
literal|0
operator|,
name|regnum_index
operator|=
name|VAB_REGNUM
init|;
name|regnum_index
operator|<=
name|LRU_REGNUM
condition|;
name|regnum_index
operator|+=
literal|4
operator|,
name|reg_index
operator|+=
literal|4
control|)
block|{
name|sprintf
argument_list|(
name|tempbuf
argument_list|,
literal|"SR%03d "
argument_list|,
name|reg_index
argument_list|)
expr_stmt|;
name|expect
argument_list|(
name|tempbuf
argument_list|)
expr_stmt|;
name|get_hex_regs
argument_list|(
name|reg_index
operator|==
literal|12
condition|?
literal|3
else|:
literal|4
argument_list|,
name|regnum_index
argument_list|)
expr_stmt|;
name|expect
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* There doesn't seem to be any way to get these.  */
block|{
name|int
name|val
init|=
operator|-
literal|1
decl_stmt|;
name|supply_register
argument_list|(
name|FPE_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|val
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|INTE_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|val
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|FPS_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|val
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|EXO_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|val
argument_list|)
expr_stmt|;
block|}
name|write
argument_list|(
name|eb_desc
argument_list|,
literal|"dw gr1,gr1\n"
argument_list|,
literal|11
argument_list|)
expr_stmt|;
name|expect
argument_list|(
literal|"GR001 "
argument_list|)
expr_stmt|;
name|get_hex_regs
argument_list|(
literal|1
argument_list|,
name|GR1_REGNUM
argument_list|)
expr_stmt|;
name|expect_prompt
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fetch register REGNO, or all registers if REGNO is -1.    Returns errno value.  */
end_comment

begin_function
name|void
name|eb_fetch_register
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
if|if
condition|(
name|regno
operator|==
operator|-
literal|1
condition|)
name|eb_fetch_registers
argument_list|()
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|name
init|=
name|get_reg_name
argument_list|(
name|regno
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|eb_stream
argument_list|,
literal|"dw %s,%s\n"
argument_list|,
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|expect
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|expect
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|get_hex_regs
argument_list|(
literal|1
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|expect_prompt
argument_list|()
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* Store the remote registers from the contents of the block REGS.  */
end_comment

begin_function
specifier|static
name|void
name|eb_store_registers
parameter_list|()
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|fprintf
argument_list|(
name|eb_stream
argument_list|,
literal|"s gr1,%x\n"
argument_list|,
name|read_register
argument_list|(
name|GR1_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
name|expect_prompt
argument_list|()
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|32
condition|;
name|j
operator|+=
literal|16
control|)
block|{
name|fprintf
argument_list|(
name|eb_stream
argument_list|,
literal|"s gr%d,"
argument_list|,
name|j
operator|+
literal|96
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|15
condition|;
operator|++
name|i
control|)
name|fprintf
argument_list|(
name|eb_stream
argument_list|,
literal|"%x,"
argument_list|,
name|read_register
argument_list|(
name|GR96_REGNUM
operator|+
name|j
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|eb_stream
argument_list|,
literal|"%x\n"
argument_list|,
name|read_register
argument_list|(
name|GR96_REGNUM
operator|+
name|j
operator|+
literal|15
argument_list|)
argument_list|)
expr_stmt|;
name|expect_prompt
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|128
condition|;
name|j
operator|+=
literal|16
control|)
block|{
name|fprintf
argument_list|(
name|eb_stream
argument_list|,
literal|"s lr%d,"
argument_list|,
name|j
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|15
condition|;
operator|++
name|i
control|)
name|fprintf
argument_list|(
name|eb_stream
argument_list|,
literal|"%x,"
argument_list|,
name|read_register
argument_list|(
name|LR0_REGNUM
operator|+
name|j
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|eb_stream
argument_list|,
literal|"%x\n"
argument_list|,
name|read_register
argument_list|(
name|LR0_REGNUM
operator|+
name|j
operator|+
literal|15
argument_list|)
argument_list|)
expr_stmt|;
name|expect_prompt
argument_list|()
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|eb_stream
argument_list|,
literal|"s sr133,%x,%x,%x\n"
argument_list|,
name|read_register
argument_list|(
name|BP_REGNUM
argument_list|)
argument_list|,
name|read_register
argument_list|(
name|FC_REGNUM
argument_list|)
argument_list|,
name|read_register
argument_list|(
name|CR_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
name|expect_prompt
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|eb_stream
argument_list|,
literal|"s sr131,%x\n"
argument_list|,
name|read_register
argument_list|(
name|Q_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
name|expect_prompt
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|eb_stream
argument_list|,
literal|"s sr0,"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|11
condition|;
operator|++
name|i
control|)
name|fprintf
argument_list|(
name|eb_stream
argument_list|,
literal|"%x,"
argument_list|,
name|read_register
argument_list|(
name|VAB_REGNUM
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|eb_stream
argument_list|,
literal|"%x\n"
argument_list|,
name|read_register
argument_list|(
name|VAB_REGNUM
operator|+
literal|11
argument_list|)
argument_list|)
expr_stmt|;
name|expect_prompt
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Store register REGNO, or all if REGNO == 0.    Return errno value.  */
end_comment

begin_function
name|void
name|eb_store_register
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
if|if
condition|(
name|regno
operator|==
operator|-
literal|1
condition|)
name|eb_store_registers
argument_list|()
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|name
init|=
name|get_reg_name
argument_list|(
name|regno
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|eb_stream
argument_list|,
literal|"s %s,%x\n"
argument_list|,
name|name
argument_list|,
name|read_register
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Setting GR1 changes the numbers of all the locals, so 	 invalidate the register cache.  Do this *after* calling 	 read_register, because we want read_register to return the 	 value that write_register has just stuffed into the registers 	 array, not the value of the register fetched from the 	 inferior.  */
if|if
condition|(
name|regno
operator|==
name|GR1_REGNUM
condition|)
name|registers_changed
argument_list|()
expr_stmt|;
name|expect_prompt
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Get ready to modify the registers array.  On machines which store    individual registers, this doesn't need to do anything.  On machines    which store all the registers in one fell swoop, this makes sure    that registers contains all the registers from the program being    debugged.  */
end_comment

begin_function
name|void
name|eb_prepare_to_store
parameter_list|()
block|{
comment|/* Do nothing, since we can store individual regs */
block|}
end_function

begin_comment
comment|/* FIXME-someday!  Merge these two.  */
end_comment

begin_function
name|int
name|eb_xfer_inferior_memory
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|,
name|write
parameter_list|,
name|target
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|write
decl_stmt|;
name|struct
name|target_ops
modifier|*
name|target
decl_stmt|;
comment|/* ignored */
block|{
if|if
condition|(
name|write
condition|)
return|return
name|eb_write_inferior_memory
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
return|;
else|else
return|return
name|eb_read_inferior_memory
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|eb_files_info
parameter_list|()
block|{
name|printf
argument_list|(
literal|"\tAttached to %s at %d baud and running program %s.\n"
argument_list|,
name|dev_name
argument_list|,
name|baudrate
argument_list|,
name|prog_name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy LEN bytes of data from debugger memory at MYADDR    to inferior's memory at MEMADDR.  Returns length moved.  */
end_comment

begin_function
name|int
name|eb_write_inferior_memory
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|i
operator|%
literal|16
operator|)
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|eb_stream
argument_list|,
literal|"sb %x,"
argument_list|,
name|memaddr
operator|+
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|%
literal|16
operator|)
operator|==
literal|15
operator|||
name|i
operator|==
name|len
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|eb_stream
argument_list|,
literal|"%x\n"
argument_list|,
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|myaddr
operator|)
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|expect_prompt
argument_list|()
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|eb_stream
argument_list|,
literal|"%x,"
argument_list|,
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|myaddr
operator|)
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|len
return|;
block|}
end_function

begin_comment
comment|/* Read LEN bytes from inferior memory at MEMADDR.  Put the result    at debugger address MYADDR.  Returns length moved.  */
end_comment

begin_function
name|int
name|eb_read_inferior_memory
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
comment|/* Number of bytes read so far.  */
name|int
name|count
decl_stmt|;
comment|/* Starting address of this pass.  */
name|unsigned
name|long
name|startaddr
decl_stmt|;
comment|/* Number of bytes to read in this pass.  */
name|int
name|len_this_pass
decl_stmt|;
comment|/* Note that this code works correctly if startaddr is just less      than UINT_MAX (well, really CORE_ADDR_MAX if there was such a      thing).  That is, something like      eb_read_bytes (CORE_ADDR_MAX - 4, foo, 4)      works--it never adds len to memaddr and gets 0.  */
comment|/* However, something like      eb_read_bytes (CORE_ADDR_MAX - 3, foo, 4)      doesn't need to work.  Detect it and give up if there's an attempt      to do that.  */
if|if
condition|(
operator|(
operator|(
name|memaddr
operator|-
literal|1
operator|)
operator|+
name|len
operator|)
operator|<
name|memaddr
condition|)
block|{
name|errno
operator|=
name|EIO
expr_stmt|;
return|return
literal|0
return|;
block|}
name|startaddr
operator|=
name|memaddr
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|count
operator|<
name|len
condition|)
block|{
name|len_this_pass
operator|=
literal|16
expr_stmt|;
if|if
condition|(
operator|(
name|startaddr
operator|%
literal|16
operator|)
operator|!=
literal|0
condition|)
name|len_this_pass
operator|-=
name|startaddr
operator|%
literal|16
expr_stmt|;
if|if
condition|(
name|len_this_pass
operator|>
operator|(
name|len
operator|-
name|count
operator|)
condition|)
name|len_this_pass
operator|=
operator|(
name|len
operator|-
name|count
operator|)
expr_stmt|;
name|fprintf
argument_list|(
name|eb_stream
argument_list|,
literal|"db %x,%x\n"
argument_list|,
name|startaddr
argument_list|,
operator|(
name|startaddr
operator|-
literal|1
operator|)
operator|+
name|len_this_pass
argument_list|)
expr_stmt|;
name|expect
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* Look for 8 hex digits.  */
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|isxdigit
argument_list|(
name|readchar
argument_list|()
argument_list|)
condition|)
operator|++
name|i
expr_stmt|;
else|else
block|{
name|expect_prompt
argument_list|()
expr_stmt|;
name|error
argument_list|(
literal|"Hex digit expected from remote system."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>=
literal|8
condition|)
break|break;
block|}
name|expect
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len_this_pass
condition|;
name|i
operator|++
control|)
name|get_hex_byte
argument_list|(
operator|&
name|myaddr
index|[
name|count
operator|++
index|]
argument_list|)
expr_stmt|;
name|expect_prompt
argument_list|()
expr_stmt|;
name|startaddr
operator|+=
name|len_this_pass
expr_stmt|;
block|}
return|return
name|len
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|eb_kill
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
return|return;
comment|/* Ignore attempts to kill target system */
block|}
end_function

begin_comment
comment|/* Clean up when a program exits.     The program actually lives on in the remote processor's RAM, and may be    run again without a download.  Don't leave it full of breakpoint    instructions.  */
end_comment

begin_function
name|void
name|eb_mourn_inferior
parameter_list|()
block|{
name|remove_breakpoints
argument_list|()
expr_stmt|;
name|unpush_target
argument_list|(
operator|&
name|eb_ops
argument_list|)
expr_stmt|;
name|generic_mourn_inferior
argument_list|()
expr_stmt|;
comment|/* Do all the proper things now */
block|}
end_function

begin_comment
comment|/* Define the target subroutine names */
end_comment

begin_decl_stmt
name|struct
name|target_ops
name|eb_ops
init|=
block|{
literal|"amd-eb"
block|,
literal|"Remote serial AMD EBMON target"
block|,
literal|"Use a remote computer running EBMON connected by a serial line.\n\ Arguments are the name of the device for the serial line,\n\ the speed to connect at in bits per second, and the filename of the\n\ executable as it exists on the remote computer.  For example,\n\         target amd-eb /dev/ttya 9600 demo"
block|,
name|eb_open
block|,
name|eb_close
block|,
literal|0
block|,
name|eb_detach
block|,
name|eb_resume
block|,
name|eb_wait
block|,
name|eb_fetch_register
block|,
name|eb_store_register
block|,
name|eb_prepare_to_store
block|,
name|eb_xfer_inferior_memory
block|,
name|eb_files_info
block|,
literal|0
block|,
literal|0
block|,
comment|/* Breakpoints */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* Terminal handling */
name|eb_kill
block|,
name|generic_load
block|,
comment|/* load */
literal|0
block|,
comment|/* lookup_symbol */
name|eb_create_inferior
block|,
name|eb_mourn_inferior
block|,
literal|0
block|,
comment|/* can_run */
literal|0
block|,
comment|/* notice_signals */
literal|0
block|,
comment|/* to_stop */
name|process_stratum
block|,
literal|0
block|,
comment|/* next */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* all mem, mem, stack, regs, exec */
literal|0
block|,
literal|0
block|,
comment|/* Section pointers */
name|OPS_MAGIC
block|,
comment|/* Always the last thing */
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|_initialize_remote_eb
parameter_list|()
block|{
name|add_target
argument_list|(
operator|&
name|eb_ops
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

