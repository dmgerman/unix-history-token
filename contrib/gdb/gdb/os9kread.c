begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Read os9/os9k symbol tables and convert to internal format, for GDB.    Copyright 1986, 87, 88, 89, 90, 91, 92, 93, 94, 96, 1998    Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This module provides three functions: os9k_symfile_init,    which initializes to read a symbol file; os9k_new_init, which     discards existing cached information when all symbols are being    discarded; and os9k_symfile_read, which reads a symbol table    from a file.     os9k_symfile_read only does the minimum work necessary for letting the    user "name" things symbolically; it does not read the entire symtab.    Instead, it reads the external and static symbols and puts them in partial    symbol tables.  When more extensive information is requested of a    file, the corresponding partial symbol table is mutated into a full    fledged symbol table by going back and reading the symbols    for real.  os9k_psymtab_to_symtab() is the function that does this */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USG
argument_list|)
operator|||
name|defined
argument_list|(
name|__CYGNUSCLIB__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"gdb_stat.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"breakpoint.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_comment
comment|/* for bfd stuff */
end_comment

begin_include
include|#
directive|include
file|"libaout.h"
end_include

begin_comment
comment|/* FIXME Secret internal BFD stuff for a.out */
end_comment

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"buildsym.h"
end_include

begin_include
include|#
directive|include
file|"gdb-stabs.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_comment
comment|/* Needed inside partial-stab.h */
end_comment

begin_include
include|#
directive|include
file|"complaints.h"
end_include

begin_include
include|#
directive|include
file|"os9k.h"
end_include

begin_include
include|#
directive|include
file|"stabsread.h"
end_include

begin_comment
comment|/* Each partial symbol table entry contains a pointer to private data for the    read_symtab() function to use when expanding a partial symbol table entry    to a full symbol table entry.     For dbxread this structure contains the offset within the file symbol table    of first local symbol for this file, and count of the section    of the symbol table devoted to this file's symbols (actually, the section    bracketed may contain more than just this file's symbols).  It also contains    further information needed to locate the symbols if they are in an ELF file.     If ldsymcnt is 0, the only reason for this thing's existence is the    dependency list.  Nothing else will happen when it is read in.  */
end_comment

begin_define
define|#
directive|define
name|LDSYMOFF
parameter_list|(
name|p
parameter_list|)
value|(((struct symloc *)((p)->read_symtab_private))->ldsymoff)
end_define

begin_define
define|#
directive|define
name|LDSYMCNT
parameter_list|(
name|p
parameter_list|)
value|(((struct symloc *)((p)->read_symtab_private))->ldsymnum)
end_define

begin_struct
struct|struct
name|symloc
block|{
name|int
name|ldsymoff
decl_stmt|;
name|int
name|ldsymnum
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Remember what we deduced to be the source language of this psymtab. */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|language
name|psymtab_language
init|=
name|language_unknown
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* keep partial symbol table file nested depth */
end_comment

begin_decl_stmt
specifier|static
name|int
name|psymfile_depth
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* keep symbol table file nested depth */
end_comment

begin_decl_stmt
specifier|static
name|int
name|symfile_depth
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means give verbose info on gdb action.  From main.c.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|info_verbose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|previous_stab_code
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name of last function encountered.  Used in Solaris to approximate    object file boundaries.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|last_function_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Complaints about the symbols we have encountered.  */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|complaint
name|lbrac_complaint
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|complaint
name|unknown_symtype_complaint
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|complaint
name|unknown_symchar_complaint
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|complaint
name|lbrac_rbrac_complaint
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|complaint
name|repeated_header_complaint
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|complaint
name|repeated_header_name_complaint
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static struct complaint lbrac_unmatched_complaint =   {"unmatched Increment Block Entry before symtab pos %d", 0, 0};  static struct complaint lbrac_mismatch_complaint =   {"IBE/IDE symbol mismatch at symtab pos %d", 0, 0};
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Local function prototypes */
end_comment

begin_decl_stmt
specifier|static
name|void
name|read_minimal_symbols
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|,
expr|struct
name|section_offsets
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|os9k_read_ofile_symtab
name|PARAMS
argument_list|(
operator|(
expr|struct
name|partial_symtab
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|os9k_psymtab_to_symtab
name|PARAMS
argument_list|(
operator|(
expr|struct
name|partial_symtab
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|os9k_psymtab_to_symtab_1
name|PARAMS
argument_list|(
operator|(
expr|struct
name|partial_symtab
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|read_os9k_psymtab
name|PARAMS
argument_list|(
operator|(
expr|struct
name|section_offsets
operator|*
operator|,
expr|struct
name|objfile
operator|*
operator|,
name|CORE_ADDR
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fill_sym
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|os9k_symfile_init
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|os9k_new_init
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|os9k_symfile_read
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|,
expr|struct
name|section_offsets
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|os9k_symfile_finish
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|os9k_process_one_symbol
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|CORE_ADDR
operator|,
name|char
operator|*
operator|,
expr|struct
name|section_offsets
operator|*
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|partial_symtab
modifier|*
name|os9k_start_psymtab
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|,
expr|struct
name|section_offsets
operator|*
operator|,
name|char
operator|*
operator|,
name|CORE_ADDR
operator|,
name|int
operator|,
name|int
operator|,
expr|struct
name|partial_symbol
operator|*
operator|*
operator|,
expr|struct
name|partial_symbol
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|partial_symtab
modifier|*
name|os9k_end_psymtab
name|PARAMS
argument_list|(
operator|(
expr|struct
name|partial_symtab
operator|*
operator|,
name|char
operator|*
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|CORE_ADDR
operator|,
expr|struct
name|partial_symtab
operator|*
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|record_minimal_symbol
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|CORE_ADDR
operator|,
name|int
operator|,
expr|struct
name|objfile
operator|*
operator|,
expr|struct
name|section_offsets
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_define
define|#
directive|define
name|HANDLE_RBRAC
parameter_list|(
name|val
parameter_list|)
define|\
value|if ((val)> pst->texthigh) pst->texthigh = (val);
end_define

begin_define
define|#
directive|define
name|SWAP_STBHDR
parameter_list|(
name|hdrp
parameter_list|,
name|abfd
parameter_list|)
define|\
value|{ \     (hdrp)->fmtno = bfd_get_16(abfd, (unsigned char *)&(hdrp)->fmtno); \     (hdrp)->crc = bfd_get_32(abfd, (unsigned char *)&(hdrp)->crc); \     (hdrp)->offset = bfd_get_32(abfd, (unsigned char *)&(hdrp)->offset); \     (hdrp)->nsym = bfd_get_32(abfd, (unsigned char *)&(hdrp)->nsym); \   }
end_define

begin_define
define|#
directive|define
name|SWAP_STBSYM
parameter_list|(
name|symp
parameter_list|,
name|abfd
parameter_list|)
define|\
value|{ \     (symp)->value = bfd_get_32(abfd, (unsigned char *)&(symp)->value); \     (symp)->type = bfd_get_16(abfd, (unsigned char *)&(symp)->type); \     (symp)->stroff = bfd_get_32(abfd, (unsigned char *)&(symp)->stroff); \   }
end_define

begin_define
define|#
directive|define
name|N_DATA
value|0
end_define

begin_define
define|#
directive|define
name|N_BSS
value|1
end_define

begin_define
define|#
directive|define
name|N_RDATA
value|2
end_define

begin_define
define|#
directive|define
name|N_IDATA
value|3
end_define

begin_define
define|#
directive|define
name|N_TEXT
value|4
end_define

begin_define
define|#
directive|define
name|N_ABS
value|6
end_define

begin_function
specifier|static
name|void
name|record_minimal_symbol
parameter_list|(
name|name
parameter_list|,
name|address
parameter_list|,
name|type
parameter_list|,
name|objfile
parameter_list|,
name|section_offsets
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|CORE_ADDR
name|address
decl_stmt|;
name|int
name|type
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|section_offsets
modifier|*
name|section_offsets
decl_stmt|;
block|{
name|enum
name|minimal_symbol_type
name|ms_type
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|N_TEXT
case|:
name|ms_type
operator|=
name|mst_text
expr_stmt|;
name|address
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_DATA
case|:
name|ms_type
operator|=
name|mst_data
expr_stmt|;
break|break;
case|case
name|N_BSS
case|:
name|ms_type
operator|=
name|mst_bss
expr_stmt|;
break|break;
case|case
name|N_RDATA
case|:
name|ms_type
operator|=
name|mst_bss
expr_stmt|;
break|break;
case|case
name|N_IDATA
case|:
name|ms_type
operator|=
name|mst_data
expr_stmt|;
break|break;
case|case
name|N_ABS
case|:
name|ms_type
operator|=
name|mst_abs
expr_stmt|;
break|break;
default|default:
name|ms_type
operator|=
name|mst_unknown
expr_stmt|;
break|break;
block|}
name|prim_record_minimal_symbol
argument_list|(
name|name
argument_list|,
name|address
argument_list|,
name|ms_type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* read and process .stb file and store in minimal symbol table */
end_comment

begin_typedef
typedef|typedef
name|char
name|mhhdr
index|[
literal|80
index|]
typedef|;
end_typedef

begin_struct
struct|struct
name|stbhdr
block|{
name|mhhdr
name|comhdr
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|short
name|fmtno
decl_stmt|;
name|int
name|crc
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|int
name|nsym
decl_stmt|;
name|char
modifier|*
name|pad
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|stbsymbol
block|{
name|int
name|value
decl_stmt|;
name|short
name|type
decl_stmt|;
name|int
name|stroff
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|STBSYMSIZE
value|10
end_define

begin_function
specifier|static
name|void
name|read_minimal_symbols
parameter_list|(
name|objfile
parameter_list|,
name|section_offsets
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|section_offsets
modifier|*
name|section_offsets
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|stbhdr
name|hdr
decl_stmt|;
name|struct
name|stbsymbol
name|sym
decl_stmt|;
name|int
name|ch
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|off
decl_stmt|;
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|,
name|buf1
index|[
literal|128
index|]
decl_stmt|;
name|fp
operator|=
name|objfile
operator|->
name|auxf1
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
return|return;
name|abfd
operator|=
name|objfile
operator|->
name|obfd
expr_stmt|;
name|fread
argument_list|(
operator|&
name|hdr
operator|.
name|comhdr
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|mhhdr
argument_list|)
argument_list|,
literal|1
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|ch
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
while|while
condition|(
name|ch
operator|!=
operator|-
literal|1
condition|)
block|{
name|buf
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|)
name|ch
expr_stmt|;
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|0
condition|)
break|break;
name|ch
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|i
operator|%
literal|2
condition|)
name|ch
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|hdr
operator|.
name|name
operator|=
operator|&
name|buf
index|[
literal|0
index|]
expr_stmt|;
name|fread
argument_list|(
operator|&
name|hdr
operator|.
name|fmtno
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
operator|.
name|fmtno
argument_list|)
argument_list|,
literal|1
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fread
argument_list|(
operator|&
name|hdr
operator|.
name|crc
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
operator|.
name|crc
argument_list|)
argument_list|,
literal|1
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fread
argument_list|(
operator|&
name|hdr
operator|.
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
operator|.
name|offset
argument_list|)
argument_list|,
literal|1
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fread
argument_list|(
operator|&
name|hdr
operator|.
name|nsym
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
operator|.
name|nsym
argument_list|)
argument_list|,
literal|1
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|SWAP_STBHDR
argument_list|(
operator|&
name|hdr
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
comment|/* read symbols */
name|init_minimal_symbol_collection
argument_list|()
expr_stmt|;
name|off
operator|=
name|hdr
operator|.
name|offset
expr_stmt|;
for|for
control|(
name|i
operator|=
name|hdr
operator|.
name|nsym
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|fseek
argument_list|(
name|fp
argument_list|,
operator|(
name|long
operator|)
name|off
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fread
argument_list|(
operator|&
name|sym
operator|.
name|value
argument_list|,
sizeof|sizeof
argument_list|(
name|sym
operator|.
name|value
argument_list|)
argument_list|,
literal|1
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fread
argument_list|(
operator|&
name|sym
operator|.
name|type
argument_list|,
sizeof|sizeof
argument_list|(
name|sym
operator|.
name|type
argument_list|)
argument_list|,
literal|1
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fread
argument_list|(
operator|&
name|sym
operator|.
name|stroff
argument_list|,
sizeof|sizeof
argument_list|(
name|sym
operator|.
name|stroff
argument_list|)
argument_list|,
literal|1
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|SWAP_STBSYM
argument_list|(
operator|&
name|sym
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|fseek
argument_list|(
name|fp
argument_list|,
operator|(
name|long
operator|)
name|sym
operator|.
name|stroff
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
name|ch
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
while|while
condition|(
name|ch
operator|!=
operator|-
literal|1
condition|)
block|{
name|buf1
index|[
name|j
index|]
operator|=
operator|(
name|char
operator|)
name|ch
expr_stmt|;
name|j
operator|++
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|0
condition|)
break|break;
name|ch
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|record_minimal_symbol
argument_list|(
name|buf1
argument_list|,
name|sym
operator|.
name|value
argument_list|,
name|sym
operator|.
name|type
operator|&
literal|7
argument_list|,
name|objfile
argument_list|,
name|section_offsets
argument_list|)
expr_stmt|;
name|off
operator|+=
name|STBSYMSIZE
expr_stmt|;
block|}
empty_stmt|;
name|install_minimal_symbols
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Scan and build partial symbols for a symbol file.    We have been initialized by a call to os9k_symfile_init, which     put all the relevant info into a "struct os9k_symfile_info",    hung off the objfile structure.     SECTION_OFFSETS contains offsets relative to which the symbols in the    various sections are (depending where the sections were actually loaded).    MAINLINE is true if we are reading the main symbol    table (as opposed to a shared lib or dynamically loaded file).  */
end_comment

begin_function
specifier|static
name|void
name|os9k_symfile_read
parameter_list|(
name|objfile
parameter_list|,
name|section_offsets
parameter_list|,
name|mainline
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|section_offsets
modifier|*
name|section_offsets
decl_stmt|;
name|int
name|mainline
decl_stmt|;
comment|/* FIXME comments above */
block|{
name|bfd
modifier|*
name|sym_bfd
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|back_to
decl_stmt|;
name|sym_bfd
operator|=
name|objfile
operator|->
name|obfd
expr_stmt|;
comment|/* If we are reinitializing, or if we have never loaded syms yet, init */
if|if
condition|(
name|mainline
operator|||
name|objfile
operator|->
name|global_psymbols
operator|.
name|size
operator|==
literal|0
operator|||
name|objfile
operator|->
name|static_psymbols
operator|.
name|size
operator|==
literal|0
condition|)
name|init_psymbol_list
argument_list|(
name|objfile
argument_list|,
name|DBX_SYMCOUNT
argument_list|(
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
name|free_pending_blocks
argument_list|()
expr_stmt|;
name|back_to
operator|=
name|make_cleanup
argument_list|(
operator|(
name|make_cleanup_func
operator|)
name|really_free_pendings
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
operator|(
name|make_cleanup_func
operator|)
name|discard_minimal_symbols
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|read_minimal_symbols
argument_list|(
name|objfile
argument_list|,
name|section_offsets
argument_list|)
expr_stmt|;
comment|/* Now that the symbol table data of the executable file are all in core,      process them and define symbols accordingly.  */
name|read_os9k_psymtab
argument_list|(
name|section_offsets
argument_list|,
name|objfile
argument_list|,
name|DBX_TEXT_ADDR
argument_list|(
name|objfile
argument_list|)
argument_list|,
name|DBX_TEXT_SIZE
argument_list|(
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|back_to
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize anything that needs initializing when a completely new    symbol file is specified (not just adding some symbols from another    file, e.g. a shared library).  */
end_comment

begin_function
specifier|static
name|void
name|os9k_new_init
parameter_list|(
name|ignore
parameter_list|)
name|struct
name|objfile
modifier|*
name|ignore
decl_stmt|;
block|{
name|stabsread_new_init
argument_list|()
expr_stmt|;
name|buildsym_new_init
argument_list|()
expr_stmt|;
name|psymfile_depth
operator|=
literal|0
expr_stmt|;
comment|/*   init_header_files (); */
block|}
end_function

begin_comment
comment|/* os9k_symfile_init ()    It is passed a struct objfile which contains, among other things,    the BFD for the file whose symbols are being read, and a slot for a pointer    to "private data" which we fill with goodies.     Since BFD doesn't know how to read debug symbols in a format-independent    way (and may never do so...), we have to do it ourselves.  We will never    be called unless this is an a.out (or very similar) file.     FIXME, there should be a cleaner peephole into the BFD environment here.  */
end_comment

begin_function
specifier|static
name|void
name|os9k_symfile_init
parameter_list|(
name|objfile
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|bfd
modifier|*
name|sym_bfd
init|=
name|objfile
operator|->
name|obfd
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|bfd_get_filename
argument_list|(
name|sym_bfd
argument_list|)
decl_stmt|;
name|char
name|dbgname
index|[
literal|512
index|]
decl_stmt|,
name|stbname
index|[
literal|512
index|]
decl_stmt|;
name|FILE
modifier|*
name|symfile
init|=
literal|0
decl_stmt|;
name|FILE
modifier|*
name|minfile
init|=
literal|0
decl_stmt|;
name|asection
modifier|*
name|text_sect
decl_stmt|;
name|strcpy
argument_list|(
name|dbgname
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|dbgname
argument_list|,
literal|".dbg"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|stbname
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|stbname
argument_list|,
literal|".stb"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|symfile
operator|=
name|fopen
argument_list|(
name|dbgname
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warning
argument_list|(
literal|"Symbol file %s not found"
argument_list|,
name|dbgname
argument_list|)
expr_stmt|;
block|}
name|objfile
operator|->
name|auxf2
operator|=
name|symfile
expr_stmt|;
if|if
condition|(
operator|(
name|minfile
operator|=
name|fopen
argument_list|(
name|stbname
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warning
argument_list|(
literal|"Symbol file %s not found"
argument_list|,
name|stbname
argument_list|)
expr_stmt|;
block|}
name|objfile
operator|->
name|auxf1
operator|=
name|minfile
expr_stmt|;
comment|/* Allocate struct to keep track of the symfile */
name|objfile
operator|->
name|sym_stab_info
operator|=
operator|(
expr|struct
name|dbx_symfile_info
operator|*
operator|)
name|xmmalloc
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dbx_symfile_info
argument_list|)
argument_list|)
expr_stmt|;
name|DBX_SYMFILE_INFO
argument_list|(
name|objfile
argument_list|)
operator|->
name|stab_section_info
operator|=
name|NULL
expr_stmt|;
name|text_sect
operator|=
name|bfd_get_section_by_name
argument_list|(
name|sym_bfd
argument_list|,
literal|".text"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|text_sect
condition|)
name|error
argument_list|(
literal|"Can't find .text section in file"
argument_list|)
expr_stmt|;
name|DBX_TEXT_ADDR
argument_list|(
name|objfile
argument_list|)
operator|=
name|bfd_section_vma
argument_list|(
name|sym_bfd
argument_list|,
name|text_sect
argument_list|)
expr_stmt|;
name|DBX_TEXT_SIZE
argument_list|(
name|objfile
argument_list|)
operator|=
name|bfd_section_size
argument_list|(
name|sym_bfd
argument_list|,
name|text_sect
argument_list|)
expr_stmt|;
name|DBX_SYMBOL_SIZE
argument_list|(
name|objfile
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* variable size symbol */
name|DBX_SYMCOUNT
argument_list|(
name|objfile
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* used to be bfd_get_symcount(sym_bfd) */
name|DBX_SYMTAB_OFFSET
argument_list|(
name|objfile
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* used to be SYMBOL_TABLE_OFFSET */
block|}
end_function

begin_comment
comment|/* Perform any local cleanups required when we are done with a particular    objfile.  I.E, we are in the process of discarding all symbol information    for an objfile, freeing up all memory held for it, and unlinking the    objfile struct from the global list of known objfiles. */
end_comment

begin_function
specifier|static
name|void
name|os9k_symfile_finish
parameter_list|(
name|objfile
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
if|if
condition|(
name|objfile
operator|->
name|sym_stab_info
operator|!=
name|NULL
condition|)
block|{
name|mfree
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
name|objfile
operator|->
name|sym_stab_info
argument_list|)
expr_stmt|;
block|}
comment|/*   free_header_files (); */
block|}
end_function

begin_escape
end_escape

begin_struct
struct|struct
name|st_dbghdr
block|{
name|int
name|sync
decl_stmt|;
name|short
name|rev
decl_stmt|;
name|int
name|crc
decl_stmt|;
name|short
name|os
decl_stmt|;
name|short
name|cpu
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|SYNC
value|(int)0xefbefeca
end_define

begin_define
define|#
directive|define
name|SWAP_DBGHDR
parameter_list|(
name|hdrp
parameter_list|,
name|abfd
parameter_list|)
define|\
value|{ \     (hdrp)->sync = bfd_get_32(abfd, (unsigned char *)&(hdrp)->sync); \     (hdrp)->rev = bfd_get_16(abfd, (unsigned char *)&(hdrp)->rev); \     (hdrp)->crc = bfd_get_32(abfd, (unsigned char *)&(hdrp)->crc); \     (hdrp)->os = bfd_get_16(abfd, (unsigned char *)&(hdrp)->os); \     (hdrp)->cpu = bfd_get_16(abfd, (unsigned char *)&(hdrp)->cpu); \   }
end_define

begin_define
define|#
directive|define
name|N_SYM_CMPLR
value|0
end_define

begin_define
define|#
directive|define
name|N_SYM_SLINE
value|1
end_define

begin_define
define|#
directive|define
name|N_SYM_SYM
value|2
end_define

begin_define
define|#
directive|define
name|N_SYM_LBRAC
value|3
end_define

begin_define
define|#
directive|define
name|N_SYM_RBRAC
value|4
end_define

begin_define
define|#
directive|define
name|N_SYM_SE
value|5
end_define

begin_struct
struct|struct
name|internal_symstruct
block|{
name|short
name|n_type
decl_stmt|;
name|short
name|n_desc
decl_stmt|;
name|long
name|n_value
decl_stmt|;
name|char
modifier|*
name|n_strx
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|internal_symstruct
name|symbol
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|internal_symstruct
modifier|*
name|symbuf
init|=
operator|&
name|symbol
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|strbuf
index|[
literal|4096
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|st_dbghdr
name|dbghdr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|cmplrid
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|VER_PRE_ULTRAC
value|((short)4)
end_define

begin_define
define|#
directive|define
name|VER_ULTRAC
value|((short)5)
end_define

begin_function
specifier|static
name|int
name|fill_sym
parameter_list|(
name|dbg_file
parameter_list|,
name|abfd
parameter_list|)
name|FILE
modifier|*
name|dbg_file
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|short
name|si
decl_stmt|,
name|nmask
decl_stmt|;
name|long
name|li
decl_stmt|;
name|int
name|ii
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|nbytes
init|=
name|fread
argument_list|(
operator|&
name|si
argument_list|,
sizeof|sizeof
argument_list|(
name|si
argument_list|)
argument_list|,
literal|1
argument_list|,
name|dbg_file
argument_list|)
decl_stmt|;
if|if
condition|(
name|nbytes
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|nbytes
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
literal|"reading .dbg file."
argument_list|)
expr_stmt|;
name|symbuf
operator|->
name|n_desc
operator|=
literal|0
expr_stmt|;
name|symbuf
operator|->
name|n_value
operator|=
literal|0
expr_stmt|;
name|symbuf
operator|->
name|n_strx
operator|=
name|NULL
expr_stmt|;
name|symbuf
operator|->
name|n_type
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|si
argument_list|)
expr_stmt|;
name|symbuf
operator|->
name|n_type
operator|=
literal|0xf
operator|&
name|symbuf
operator|->
name|n_type
expr_stmt|;
switch|switch
condition|(
name|symbuf
operator|->
name|n_type
condition|)
block|{
case|case
name|N_SYM_CMPLR
case|:
name|fread
argument_list|(
operator|&
name|si
argument_list|,
sizeof|sizeof
argument_list|(
name|si
argument_list|)
argument_list|,
literal|1
argument_list|,
name|dbg_file
argument_list|)
expr_stmt|;
name|symbuf
operator|->
name|n_desc
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|si
argument_list|)
expr_stmt|;
name|cmplrid
operator|=
name|symbuf
operator|->
name|n_desc
operator|&
literal|0xff
expr_stmt|;
break|break;
case|case
name|N_SYM_SLINE
case|:
name|fread
argument_list|(
operator|&
name|li
argument_list|,
sizeof|sizeof
argument_list|(
name|li
argument_list|)
argument_list|,
literal|1
argument_list|,
name|dbg_file
argument_list|)
expr_stmt|;
name|symbuf
operator|->
name|n_value
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|li
argument_list|)
expr_stmt|;
name|fread
argument_list|(
operator|&
name|li
argument_list|,
sizeof|sizeof
argument_list|(
name|li
argument_list|)
argument_list|,
literal|1
argument_list|,
name|dbg_file
argument_list|)
expr_stmt|;
name|li
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|li
argument_list|)
expr_stmt|;
name|symbuf
operator|->
name|n_strx
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|li
operator|>>
literal|12
operator|)
expr_stmt|;
name|symbuf
operator|->
name|n_desc
operator|=
name|li
operator|&
literal|0xfff
expr_stmt|;
break|break;
case|case
name|N_SYM_SYM
case|:
name|fread
argument_list|(
operator|&
name|li
argument_list|,
sizeof|sizeof
argument_list|(
name|li
argument_list|)
argument_list|,
literal|1
argument_list|,
name|dbg_file
argument_list|)
expr_stmt|;
name|symbuf
operator|->
name|n_value
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|li
argument_list|)
expr_stmt|;
name|si
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|ii
operator|=
name|getc
argument_list|(
name|dbg_file
argument_list|)
expr_stmt|;
name|strbuf
index|[
name|si
operator|++
index|]
operator|=
operator|(
name|char
operator|)
name|ii
expr_stmt|;
block|}
do|while
condition|(
name|ii
operator|!=
literal|0
operator|||
name|si
operator|%
literal|2
operator|!=
literal|0
condition|)
do|;
name|symbuf
operator|->
name|n_strx
operator|=
name|strbuf
expr_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|strbuf
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
break|break;
if|if
condition|(
operator|(
name|p
index|[
literal|1
index|]
operator|==
literal|'F'
operator|||
name|p
index|[
literal|1
index|]
operator|==
literal|'f'
operator|)
operator|&&
name|cmplrid
operator|==
name|VER_PRE_ULTRAC
condition|)
block|{
name|fread
argument_list|(
operator|&
name|si
argument_list|,
sizeof|sizeof
argument_list|(
name|si
argument_list|)
argument_list|,
literal|1
argument_list|,
name|dbg_file
argument_list|)
expr_stmt|;
name|nmask
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|si
argument_list|)
expr_stmt|;
for|for
control|(
name|ii
operator|=
literal|0
init|;
name|ii
operator|<
name|nmask
condition|;
name|ii
operator|++
control|)
name|fread
argument_list|(
operator|&
name|si
argument_list|,
sizeof|sizeof
argument_list|(
name|si
argument_list|)
argument_list|,
literal|1
argument_list|,
name|dbg_file
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|N_SYM_LBRAC
case|:
name|fread
argument_list|(
operator|&
name|li
argument_list|,
sizeof|sizeof
argument_list|(
name|li
argument_list|)
argument_list|,
literal|1
argument_list|,
name|dbg_file
argument_list|)
expr_stmt|;
name|symbuf
operator|->
name|n_value
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|li
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_SYM_RBRAC
case|:
name|fread
argument_list|(
operator|&
name|li
argument_list|,
sizeof|sizeof
argument_list|(
name|li
argument_list|)
argument_list|,
literal|1
argument_list|,
name|dbg_file
argument_list|)
expr_stmt|;
name|symbuf
operator|->
name|n_value
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|li
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_SYM_SE
case|:
break|break;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given pointers to an a.out symbol table in core containing dbx    style data, setup partial_symtab's describing each source file for    which debugging information is available.    SYMFILE_NAME is the name of the file we are reading from    and SECTION_OFFSETS is the set of offsets for the various sections    of the file (a set of zeros if the mainline program).  */
end_comment

begin_function
specifier|static
name|void
name|read_os9k_psymtab
parameter_list|(
name|section_offsets
parameter_list|,
name|objfile
parameter_list|,
name|text_addr
parameter_list|,
name|text_size
parameter_list|)
name|struct
name|section_offsets
modifier|*
name|section_offsets
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|CORE_ADDR
name|text_addr
decl_stmt|;
name|int
name|text_size
decl_stmt|;
block|{
specifier|register
name|struct
name|internal_symstruct
modifier|*
name|bufp
init|=
literal|0
decl_stmt|;
comment|/* =0 avoids gcc -Wall glitch*/
specifier|register
name|char
modifier|*
name|namestring
decl_stmt|;
name|int
name|past_first_source_file
init|=
literal|0
decl_stmt|;
name|CORE_ADDR
name|last_o_file_start
init|=
literal|0
decl_stmt|;
if|#
directive|if
literal|0
block|struct cleanup *back_to;
endif|#
directive|endif
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
comment|/* End of the text segment of the executable file.  */
specifier|static
name|CORE_ADDR
name|end_of_text_addr
decl_stmt|;
comment|/* Current partial symtab */
specifier|static
name|struct
name|partial_symtab
modifier|*
name|pst
init|=
literal|0
decl_stmt|;
comment|/* List of current psymtab's include files */
name|char
modifier|*
modifier|*
name|psymtab_include_list
decl_stmt|;
name|int
name|includes_allocated
decl_stmt|;
name|int
name|includes_used
decl_stmt|;
comment|/* Index within current psymtab dependency list */
name|struct
name|partial_symtab
modifier|*
modifier|*
name|dependency_list
decl_stmt|;
name|int
name|dependencies_used
decl_stmt|,
name|dependencies_allocated
decl_stmt|;
name|includes_allocated
operator|=
literal|30
expr_stmt|;
name|includes_used
operator|=
literal|0
expr_stmt|;
name|psymtab_include_list
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|alloca
argument_list|(
name|includes_allocated
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|dependencies_allocated
operator|=
literal|30
expr_stmt|;
name|dependencies_used
operator|=
literal|0
expr_stmt|;
name|dependency_list
operator|=
operator|(
expr|struct
name|partial_symtab
operator|*
operator|*
operator|)
name|alloca
argument_list|(
name|dependencies_allocated
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|partial_symtab
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|last_source_file
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|END_OF_TEXT_DEFAULT
name|end_of_text_addr
operator|=
name|END_OF_TEXT_DEFAULT
expr_stmt|;
else|#
directive|else
name|end_of_text_addr
operator|=
name|text_addr
operator|+
name|section_offsets
operator|->
name|offsets
index|[
name|SECT_OFF_TEXT
index|]
operator|+
name|text_size
expr_stmt|;
comment|/* Relocate */
endif|#
directive|endif
name|abfd
operator|=
name|objfile
operator|->
name|obfd
expr_stmt|;
name|fp
operator|=
name|objfile
operator|->
name|auxf2
expr_stmt|;
if|if
condition|(
operator|!
name|fp
condition|)
return|return;
name|fread
argument_list|(
operator|&
name|dbghdr
operator|.
name|sync
argument_list|,
sizeof|sizeof
argument_list|(
name|dbghdr
operator|.
name|sync
argument_list|)
argument_list|,
literal|1
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fread
argument_list|(
operator|&
name|dbghdr
operator|.
name|rev
argument_list|,
sizeof|sizeof
argument_list|(
name|dbghdr
operator|.
name|rev
argument_list|)
argument_list|,
literal|1
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fread
argument_list|(
operator|&
name|dbghdr
operator|.
name|crc
argument_list|,
sizeof|sizeof
argument_list|(
name|dbghdr
operator|.
name|crc
argument_list|)
argument_list|,
literal|1
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fread
argument_list|(
operator|&
name|dbghdr
operator|.
name|os
argument_list|,
sizeof|sizeof
argument_list|(
name|dbghdr
operator|.
name|os
argument_list|)
argument_list|,
literal|1
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fread
argument_list|(
operator|&
name|dbghdr
operator|.
name|cpu
argument_list|,
sizeof|sizeof
argument_list|(
name|dbghdr
operator|.
name|cpu
argument_list|)
argument_list|,
literal|1
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|SWAP_DBGHDR
argument_list|(
operator|&
name|dbghdr
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|symnum
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|ret
decl_stmt|;
name|long
name|cursymoffset
decl_stmt|;
comment|/* Get the symbol for this run and pull out some info */
name|QUIT
expr_stmt|;
comment|/* allow this to be interruptable */
name|cursymoffset
operator|=
name|ftell
argument_list|(
name|objfile
operator|->
name|auxf2
argument_list|)
expr_stmt|;
name|ret
operator|=
name|fill_sym
argument_list|(
name|objfile
operator|->
name|auxf2
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<=
literal|0
condition|)
break|break;
else|else
name|symnum
operator|++
expr_stmt|;
name|bufp
operator|=
name|symbuf
expr_stmt|;
comment|/* Special case to speed up readin. */
if|if
condition|(
name|bufp
operator|->
name|n_type
operator|==
operator|(
name|short
operator|)
name|N_SYM_SLINE
condition|)
continue|continue;
define|#
directive|define
name|CUR_SYMBOL_VALUE
value|bufp->n_value
comment|/* partial-stab.h */
switch|switch
condition|(
name|bufp
operator|->
name|n_type
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
case|case
name|N_SYM_CMPLR
case|:
continue|continue;
case|case
name|N_SYM_SE
case|:
name|CUR_SYMBOL_VALUE
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
expr_stmt|;
if|if
condition|(
name|psymfile_depth
operator|==
literal|1
operator|&&
name|pst
condition|)
block|{
name|os9k_end_psymtab
argument_list|(
name|pst
argument_list|,
name|psymtab_include_list
argument_list|,
name|includes_used
argument_list|,
name|symnum
argument_list|,
name|CUR_SYMBOL_VALUE
argument_list|,
name|dependency_list
argument_list|,
name|dependencies_used
argument_list|)
expr_stmt|;
name|pst
operator|=
operator|(
expr|struct
name|partial_symtab
operator|*
operator|)
literal|0
expr_stmt|;
name|includes_used
operator|=
literal|0
expr_stmt|;
name|dependencies_used
operator|=
literal|0
expr_stmt|;
block|}
name|psymfile_depth
operator|--
expr_stmt|;
continue|continue;
case|case
name|N_SYM_SYM
case|:
comment|/* Typedef or automatic variable. */
name|namestring
operator|=
name|bufp
operator|->
name|n_strx
expr_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|namestring
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
continue|continue;
comment|/* Not a debugging symbol.   */
comment|/* Main processing section for debugging symbols which 	     the initial read through the symbol tables needs to worry 	     about.  If we reach this point, the symbol which we are 	     considering is definitely one we are interested in. 	     p must also contain the (valid) index into the namestring 	     which indicates the debugging type symbol.  */
switch|switch
condition|(
name|p
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'S'
case|:
block|{
name|unsigned
name|long
name|valu
decl_stmt|;
name|enum
name|language
name|tmp_language
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|n
decl_stmt|;
name|valu
operator|=
name|CUR_SYMBOL_VALUE
expr_stmt|;
if|if
condition|(
name|valu
condition|)
name|valu
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
expr_stmt|;
name|past_first_source_file
operator|=
literal|1
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|namestring
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
name|n
operator|=
name|p
operator|-
name|namestring
expr_stmt|;
else|else
name|n
operator|=
name|strlen
argument_list|(
name|namestring
argument_list|)
expr_stmt|;
name|str
operator|=
name|alloca
argument_list|(
name|n
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|str
argument_list|,
name|namestring
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|str
index|[
name|n
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|psymfile_depth
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|pst
condition|)
name|pst
operator|=
name|os9k_start_psymtab
argument_list|(
name|objfile
argument_list|,
name|section_offsets
argument_list|,
name|str
argument_list|,
name|valu
argument_list|,
name|cursymoffset
argument_list|,
name|symnum
operator|-
literal|1
argument_list|,
name|objfile
operator|->
name|global_psymbols
operator|.
name|next
argument_list|,
name|objfile
operator|->
name|static_psymbols
operator|.
name|next
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* this is a include file */
name|tmp_language
operator|=
name|deduce_language_from_filename
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp_language
operator|!=
name|language_unknown
operator|&&
operator|(
name|tmp_language
operator|!=
name|language_c
operator|||
name|psymtab_language
operator|!=
name|language_cplus
operator|)
condition|)
name|psymtab_language
operator|=
name|tmp_language
expr_stmt|;
comment|/* 		  if (pst&& STREQ (str, pst->filename)) 		    continue; 		  { 		    register int i; 		    for (i = 0; i< includes_used; i++) 		      if (STREQ (str, psymtab_include_list[i])) 			{ 			  i = -1;  			  break; 			} 		    if (i == -1) 		      continue; 		  } */
name|psymtab_include_list
index|[
name|includes_used
operator|++
index|]
operator|=
name|str
expr_stmt|;
if|if
condition|(
name|includes_used
operator|>=
name|includes_allocated
condition|)
block|{
name|char
modifier|*
modifier|*
name|orig
init|=
name|psymtab_include_list
decl_stmt|;
name|psymtab_include_list
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|includes_allocated
operator|*=
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|PTR
operator|)
name|psymtab_include_list
argument_list|,
operator|(
name|PTR
operator|)
name|orig
argument_list|,
name|includes_used
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|psymfile_depth
operator|++
expr_stmt|;
continue|continue;
block|}
case|case
literal|'v'
case|:
name|add_psymbol_to_list
argument_list|(
name|namestring
argument_list|,
name|p
operator|-
name|namestring
argument_list|,
name|VAR_NAMESPACE
argument_list|,
name|LOC_STATIC
argument_list|,
operator|&
name|objfile
operator|->
name|static_psymbols
argument_list|,
literal|0
argument_list|,
name|CUR_SYMBOL_VALUE
argument_list|,
name|psymtab_language
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'V'
case|:
name|add_psymbol_to_list
argument_list|(
name|namestring
argument_list|,
name|p
operator|-
name|namestring
argument_list|,
name|VAR_NAMESPACE
argument_list|,
name|LOC_STATIC
argument_list|,
operator|&
name|objfile
operator|->
name|global_psymbols
argument_list|,
literal|0
argument_list|,
name|CUR_SYMBOL_VALUE
argument_list|,
name|psymtab_language
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'T'
case|:
if|if
condition|(
name|p
operator|!=
name|namestring
condition|)
comment|/* a name is there, not just :T... */
block|{
name|add_psymbol_to_list
argument_list|(
name|namestring
argument_list|,
name|p
operator|-
name|namestring
argument_list|,
name|STRUCT_NAMESPACE
argument_list|,
name|LOC_TYPEDEF
argument_list|,
operator|&
name|objfile
operator|->
name|static_psymbols
argument_list|,
name|CUR_SYMBOL_VALUE
argument_list|,
literal|0
argument_list|,
name|psymtab_language
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|2
index|]
operator|==
literal|'t'
condition|)
block|{
comment|/* Also a typedef with the same name.  */
name|add_psymbol_to_list
argument_list|(
name|namestring
argument_list|,
name|p
operator|-
name|namestring
argument_list|,
name|VAR_NAMESPACE
argument_list|,
name|LOC_TYPEDEF
argument_list|,
operator|&
name|objfile
operator|->
name|static_psymbols
argument_list|,
name|CUR_SYMBOL_VALUE
argument_list|,
literal|0
argument_list|,
name|psymtab_language
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|1
expr_stmt|;
block|}
comment|/* The semantics of C++ state that "struct foo { ... }" 		     also defines a typedef for "foo".  Unfortuantely, cfront 		     never makes the typedef when translating from C++ to C. 		     We make the typedef here so that "ptype foo" works as 		     expected for cfront translated code.  */
elseif|else
if|if
condition|(
name|psymtab_language
operator|==
name|language_cplus
condition|)
block|{
comment|/* Also a typedef with the same name.  */
name|add_psymbol_to_list
argument_list|(
name|namestring
argument_list|,
name|p
operator|-
name|namestring
argument_list|,
name|VAR_NAMESPACE
argument_list|,
name|LOC_TYPEDEF
argument_list|,
operator|&
name|objfile
operator|->
name|static_psymbols
argument_list|,
name|CUR_SYMBOL_VALUE
argument_list|,
literal|0
argument_list|,
name|psymtab_language
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
block|}
goto|goto
name|check_enum
goto|;
case|case
literal|'t'
case|:
if|if
condition|(
name|p
operator|!=
name|namestring
condition|)
comment|/* a name is there, not just :T... */
block|{
name|add_psymbol_to_list
argument_list|(
name|namestring
argument_list|,
name|p
operator|-
name|namestring
argument_list|,
name|VAR_NAMESPACE
argument_list|,
name|LOC_TYPEDEF
argument_list|,
operator|&
name|objfile
operator|->
name|static_psymbols
argument_list|,
name|CUR_SYMBOL_VALUE
argument_list|,
literal|0
argument_list|,
name|psymtab_language
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
name|check_enum
label|:
comment|/* If this is an enumerated type, we need to 		 add all the enum constants to the partial symbol 		 table.  This does not cover enums without names, e.g. 		 "enum {a, b} c;" in C, but fortunately those are 		 rare.  There is no way for GDB to find those from the 		 enum type without spending too much time on it.  Thus 		 to solve this problem, the compiler needs to put out the 		 enum in a nameless type.  GCC2 does this.  */
comment|/* We are looking for something of the form<name> ":" ("t" | "T") [<number> "="] "e"<size> 		 {<constant> ":"<value> ","} ";".  */
comment|/* Skip over the colon and the 't' or 'T'.  */
name|p
operator|+=
literal|2
expr_stmt|;
comment|/* This type may be given a number.  Also, numbers can come 		 in pairs like (0,26).  Skip over it.  */
while|while
condition|(
operator|(
operator|*
name|p
operator|>=
literal|'0'
operator|&&
operator|*
name|p
operator|<=
literal|'9'
operator|)
operator|||
operator|*
name|p
operator|==
literal|'('
operator|||
operator|*
name|p
operator|==
literal|','
operator|||
operator|*
name|p
operator|==
literal|')'
operator|||
operator|*
name|p
operator|==
literal|'='
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
operator|==
literal|'e'
condition|)
block|{
comment|/* We have found an enumerated type. skip size */
while|while
condition|(
operator|*
name|p
operator|>=
literal|'0'
operator|&&
operator|*
name|p
operator|<=
literal|'9'
condition|)
name|p
operator|++
expr_stmt|;
comment|/* According to comments in read_enum_type 		     a comma could end it instead of a semicolon. 		     I don't know where that happens. 		     Accept either.  */
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|';'
operator|&&
operator|*
name|p
operator|!=
literal|','
condition|)
block|{
name|char
modifier|*
name|q
decl_stmt|;
comment|/* Check for and handle cretinous dbx symbol name 			 continuation!  		      if (*p == '\\') 			p = next_symbol_text (objfile); 		      */
comment|/* Point to the character after the name 			 of the enum constant.  */
for|for
control|(
name|q
operator|=
name|p
init|;
operator|*
name|q
operator|&&
operator|*
name|q
operator|!=
literal|':'
condition|;
name|q
operator|++
control|)
empty_stmt|;
comment|/* Note that the value doesn't matter for 			 enum constants in psymtabs, just in symtabs.  */
name|add_psymbol_to_list
argument_list|(
name|p
argument_list|,
name|q
operator|-
name|p
argument_list|,
name|VAR_NAMESPACE
argument_list|,
name|LOC_CONST
argument_list|,
operator|&
name|objfile
operator|->
name|static_psymbols
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|psymtab_language
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* Point past the name.  */
name|p
operator|=
name|q
expr_stmt|;
comment|/* Skip over the value.  */
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|','
condition|)
name|p
operator|++
expr_stmt|;
comment|/* Advance past the comma.  */
if|if
condition|(
operator|*
name|p
condition|)
name|p
operator|++
expr_stmt|;
block|}
block|}
continue|continue;
case|case
literal|'c'
case|:
comment|/* Constant, e.g. from "const" in Pascal.  */
name|add_psymbol_to_list
argument_list|(
name|namestring
argument_list|,
name|p
operator|-
name|namestring
argument_list|,
name|VAR_NAMESPACE
argument_list|,
name|LOC_CONST
argument_list|,
operator|&
name|objfile
operator|->
name|static_psymbols
argument_list|,
name|CUR_SYMBOL_VALUE
argument_list|,
literal|0
argument_list|,
name|psymtab_language
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'f'
case|:
name|CUR_SYMBOL_VALUE
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
expr_stmt|;
if|if
condition|(
name|pst
operator|&&
name|pst
operator|->
name|textlow
operator|==
literal|0
condition|)
name|pst
operator|->
name|textlow
operator|=
name|CUR_SYMBOL_VALUE
expr_stmt|;
name|add_psymbol_to_list
argument_list|(
name|namestring
argument_list|,
name|p
operator|-
name|namestring
argument_list|,
name|VAR_NAMESPACE
argument_list|,
name|LOC_BLOCK
argument_list|,
operator|&
name|objfile
operator|->
name|static_psymbols
argument_list|,
name|CUR_SYMBOL_VALUE
argument_list|,
literal|0
argument_list|,
name|psymtab_language
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'F'
case|:
name|CUR_SYMBOL_VALUE
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
expr_stmt|;
if|if
condition|(
name|pst
operator|&&
name|pst
operator|->
name|textlow
operator|==
literal|0
condition|)
name|pst
operator|->
name|textlow
operator|=
name|CUR_SYMBOL_VALUE
expr_stmt|;
name|add_psymbol_to_list
argument_list|(
name|namestring
argument_list|,
name|p
operator|-
name|namestring
argument_list|,
name|VAR_NAMESPACE
argument_list|,
name|LOC_BLOCK
argument_list|,
operator|&
name|objfile
operator|->
name|global_psymbols
argument_list|,
name|CUR_SYMBOL_VALUE
argument_list|,
literal|0
argument_list|,
name|psymtab_language
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'p'
case|:
case|case
literal|'l'
case|:
case|case
literal|'s'
case|:
continue|continue;
case|case
literal|':'
case|:
comment|/* It is a C++ nested symbol.  We don't need to record it 		 (I don't think); if we try to look up foo::bar::baz, 		 then symbols for the symtab containing foo should get 		 read in, I think.  */
comment|/* Someone says sun cc puts out symbols like 		 /foo/baz/maclib::/usr/local/bin/maclib, 		 which would get here with a symbol type of ':'.  */
continue|continue;
default|default:
comment|/* Unexpected symbol descriptor.  The second and subsequent stabs 		 of a continued stab can show up here.  The question is 		 whether they ever can mimic a normal stab--it would be 		 nice if not, since we certainly don't want to spend the 		 time searching to the end of every string looking for 		 a backslash.  */
name|complain
argument_list|(
operator|&
name|unknown_symchar_complaint
argument_list|,
name|p
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
continue|continue;
block|}
case|case
name|N_SYM_RBRAC
case|:
name|CUR_SYMBOL_VALUE
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HANDLE_RBRAC
name|HANDLE_RBRAC
argument_list|(
name|CUR_SYMBOL_VALUE
argument_list|)
expr_stmt|;
continue|continue;
endif|#
directive|endif
case|case
name|N_SYM_LBRAC
case|:
continue|continue;
default|default:
comment|/* If we haven't found it yet, ignore it.  It's probably some 	     new type we don't know about yet.  */
name|complain
argument_list|(
operator|&
name|unknown_symtype_complaint
argument_list|,
name|local_hex_string
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|bufp
operator|->
name|n_type
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
name|DBX_SYMCOUNT
argument_list|(
name|objfile
argument_list|)
operator|=
name|symnum
expr_stmt|;
comment|/* If there's stuff to be cleaned up, clean it up.  */
if|if
condition|(
name|DBX_SYMCOUNT
argument_list|(
name|objfile
argument_list|)
operator|>
literal|0
comment|/*FIXME, does this have a bug at start address 0? */
operator|&&
name|last_o_file_start
operator|&&
name|objfile
operator|->
name|ei
operator|.
name|entry_point
operator|<
name|bufp
operator|->
name|n_value
operator|&&
name|objfile
operator|->
name|ei
operator|.
name|entry_point
operator|>=
name|last_o_file_start
condition|)
block|{
name|objfile
operator|->
name|ei
operator|.
name|entry_file_lowpc
operator|=
name|last_o_file_start
expr_stmt|;
name|objfile
operator|->
name|ei
operator|.
name|entry_file_highpc
operator|=
name|bufp
operator|->
name|n_value
expr_stmt|;
block|}
if|if
condition|(
name|pst
condition|)
block|{
name|os9k_end_psymtab
argument_list|(
name|pst
argument_list|,
name|psymtab_include_list
argument_list|,
name|includes_used
argument_list|,
name|symnum
argument_list|,
name|end_of_text_addr
argument_list|,
name|dependency_list
argument_list|,
name|dependencies_used
argument_list|)
expr_stmt|;
block|}
comment|/*   do_cleanups (back_to); */
block|}
end_function

begin_comment
comment|/* Allocate and partially fill a partial symtab.  It will be    completely filled at the end of the symbol list.     SYMFILE_NAME is the name of the symbol-file we are reading from, and ADDR    is the address relative to which its symbols are (incremental) or 0    (normal). */
end_comment

begin_function
specifier|static
name|struct
name|partial_symtab
modifier|*
name|os9k_start_psymtab
parameter_list|(
name|objfile
parameter_list|,
name|section_offsets
parameter_list|,
name|filename
parameter_list|,
name|textlow
parameter_list|,
name|ldsymoff
parameter_list|,
name|ldsymcnt
parameter_list|,
name|global_syms
parameter_list|,
name|static_syms
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|section_offsets
modifier|*
name|section_offsets
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|CORE_ADDR
name|textlow
decl_stmt|;
name|int
name|ldsymoff
decl_stmt|;
name|int
name|ldsymcnt
decl_stmt|;
name|struct
name|partial_symbol
modifier|*
modifier|*
name|global_syms
decl_stmt|;
name|struct
name|partial_symbol
modifier|*
modifier|*
name|static_syms
decl_stmt|;
block|{
name|struct
name|partial_symtab
modifier|*
name|result
init|=
name|start_psymtab_common
argument_list|(
name|objfile
argument_list|,
name|section_offsets
argument_list|,
name|filename
argument_list|,
name|textlow
argument_list|,
name|global_syms
argument_list|,
name|static_syms
argument_list|)
decl_stmt|;
name|result
operator|->
name|read_symtab_private
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|psymbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symloc
argument_list|)
argument_list|)
expr_stmt|;
name|LDSYMOFF
argument_list|(
name|result
argument_list|)
operator|=
name|ldsymoff
expr_stmt|;
name|LDSYMCNT
argument_list|(
name|result
argument_list|)
operator|=
name|ldsymcnt
expr_stmt|;
name|result
operator|->
name|read_symtab
operator|=
name|os9k_psymtab_to_symtab
expr_stmt|;
comment|/* Deduce the source language from the filename for this psymtab. */
name|psymtab_language
operator|=
name|deduce_language_from_filename
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Close off the current usage of PST.      Returns PST or NULL if the partial symtab was empty and thrown away.    FIXME:  List variables and peculiarities of same.  */
end_comment

begin_function
specifier|static
name|struct
name|partial_symtab
modifier|*
name|os9k_end_psymtab
parameter_list|(
name|pst
parameter_list|,
name|include_list
parameter_list|,
name|num_includes
parameter_list|,
name|capping_symbol_cnt
parameter_list|,
name|capping_text
parameter_list|,
name|dependency_list
parameter_list|,
name|number_dependencies
parameter_list|)
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
name|char
modifier|*
modifier|*
name|include_list
decl_stmt|;
name|int
name|num_includes
decl_stmt|;
name|int
name|capping_symbol_cnt
decl_stmt|;
name|CORE_ADDR
name|capping_text
decl_stmt|;
name|struct
name|partial_symtab
modifier|*
modifier|*
name|dependency_list
decl_stmt|;
name|int
name|number_dependencies
decl_stmt|;
comment|/* struct partial_symbol *capping_global, *capping_static; */
block|{
name|int
name|i
decl_stmt|;
name|struct
name|partial_symtab
modifier|*
name|p1
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
init|=
name|pst
operator|->
name|objfile
decl_stmt|;
if|if
condition|(
name|capping_symbol_cnt
operator|!=
operator|-
literal|1
condition|)
name|LDSYMCNT
argument_list|(
name|pst
argument_list|)
operator|=
name|capping_symbol_cnt
operator|-
name|LDSYMCNT
argument_list|(
name|pst
argument_list|)
expr_stmt|;
comment|/* Under Solaris, the N_SO symbols always have a value of 0,      instead of the usual address of the .o file.  Therefore,      we have to do some tricks to fill in texthigh and textlow.      The first trick is in partial-stab.h: if we see a static      or global function, and the textlow for the current pst      is still 0, then we use that function's address for       the textlow of the pst.       Now, to fill in texthigh, we remember the last function seen      in the .o file (also in partial-stab.h).  Also, there's a hack in      bfd/elf.c and gdb/elfread.c to pass the ELF st_size field      to here via the misc_info field.  Therefore, we can fill in      a reliable texthigh by taking the address plus size of the      last function in the file.       Unfortunately, that does not cover the case where the last function      in the file is static.  See the paragraph below for more comments      on this situation.       Finally, if we have a valid textlow for the current file, we run      down the partial_symtab_list filling in previous texthighs that      are still unknown.  */
if|if
condition|(
name|pst
operator|->
name|texthigh
operator|==
literal|0
operator|&&
name|last_function_name
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|n
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|minsym
decl_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|last_function_name
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|p
operator|=
name|last_function_name
expr_stmt|;
name|n
operator|=
name|p
operator|-
name|last_function_name
expr_stmt|;
name|p
operator|=
name|alloca
argument_list|(
name|n
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|p
argument_list|,
name|last_function_name
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|p
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
name|minsym
operator|=
name|lookup_minimal_symbol
argument_list|(
name|p
argument_list|,
name|NULL
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|minsym
condition|)
block|{
name|pst
operator|->
name|texthigh
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|minsym
argument_list|)
operator|+
operator|(
name|long
operator|)
name|MSYMBOL_INFO
argument_list|(
name|minsym
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This file ends with a static function, and it's 	 difficult to imagine how hard it would be to track down 	 the elf symbol.  Luckily, most of the time no one will notice, 	 since the next file will likely be compiled with -g, so 	 the code below will copy the first fuction's start address  	 back to our texthigh variable.  (Also, if this file is the 	 last one in a dynamically linked program, texthigh already 	 has the right value.)  If the next file isn't compiled 	 with -g, then the last function in this file winds up owning 	 all of the text space up to the next -g file, or the end (minus 	 shared libraries).  This only matters for single stepping, 	 and even then it will still work, except that it will single 	 step through all of the covered functions, instead of setting 	 breakpoints around them as it usualy does.  This makes it 	 pretty slow, but at least it doesn't fail.  	 We can fix this with a fairly big change to bfd, but we need 	 to coordinate better with Cygnus if we want to do that.  FIXME.  */
block|}
name|last_function_name
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* this test will be true if the last .o file is only data */
if|if
condition|(
name|pst
operator|->
name|textlow
operator|==
literal|0
condition|)
name|pst
operator|->
name|textlow
operator|=
name|pst
operator|->
name|texthigh
expr_stmt|;
comment|/* If we know our own starting text address, then walk through all other      psymtabs for this objfile, and if any didn't know their ending text      address, set it to our starting address.  Take care to not set our      own ending address to our starting address, nor to set addresses on      `dependency' files that have both textlow and texthigh zero.  */
if|if
condition|(
name|pst
operator|->
name|textlow
condition|)
block|{
name|ALL_OBJFILE_PSYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|p1
argument_list|)
block|{
if|if
condition|(
name|p1
operator|->
name|texthigh
operator|==
literal|0
operator|&&
name|p1
operator|->
name|textlow
operator|!=
literal|0
operator|&&
name|p1
operator|!=
name|pst
condition|)
block|{
name|p1
operator|->
name|texthigh
operator|=
name|pst
operator|->
name|textlow
expr_stmt|;
comment|/* if this file has only data, then make textlow match texthigh */
if|if
condition|(
name|p1
operator|->
name|textlow
operator|==
literal|0
condition|)
name|p1
operator|->
name|textlow
operator|=
name|p1
operator|->
name|texthigh
expr_stmt|;
block|}
block|}
block|}
comment|/* End of kludge for patching Solaris textlow and texthigh.  */
name|pst
operator|->
name|n_global_syms
operator|=
name|objfile
operator|->
name|global_psymbols
operator|.
name|next
operator|-
operator|(
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
operator|+
name|pst
operator|->
name|globals_offset
operator|)
expr_stmt|;
name|pst
operator|->
name|n_static_syms
operator|=
name|objfile
operator|->
name|static_psymbols
operator|.
name|next
operator|-
operator|(
name|objfile
operator|->
name|static_psymbols
operator|.
name|list
operator|+
name|pst
operator|->
name|statics_offset
operator|)
expr_stmt|;
name|pst
operator|->
name|number_of_dependencies
operator|=
name|number_dependencies
expr_stmt|;
if|if
condition|(
name|number_dependencies
condition|)
block|{
name|pst
operator|->
name|dependencies
operator|=
operator|(
expr|struct
name|partial_symtab
operator|*
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|psymbol_obstack
argument_list|,
name|number_dependencies
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|partial_symtab
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|pst
operator|->
name|dependencies
argument_list|,
name|dependency_list
argument_list|,
name|number_dependencies
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|partial_symtab
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|pst
operator|->
name|dependencies
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_includes
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|partial_symtab
modifier|*
name|subpst
init|=
name|allocate_psymtab
argument_list|(
name|include_list
index|[
name|i
index|]
argument_list|,
name|objfile
argument_list|)
decl_stmt|;
name|subpst
operator|->
name|section_offsets
operator|=
name|pst
operator|->
name|section_offsets
expr_stmt|;
name|subpst
operator|->
name|read_symtab_private
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|psymbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symloc
argument_list|)
argument_list|)
expr_stmt|;
name|LDSYMOFF
argument_list|(
name|subpst
argument_list|)
operator|=
name|LDSYMCNT
argument_list|(
name|subpst
argument_list|)
operator|=
name|subpst
operator|->
name|textlow
operator|=
name|subpst
operator|->
name|texthigh
operator|=
literal|0
expr_stmt|;
comment|/* We could save slight bits of space by only making one of these, 	 shared by the entire set of include files.  FIXME-someday.  */
name|subpst
operator|->
name|dependencies
operator|=
operator|(
expr|struct
name|partial_symtab
operator|*
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|psymbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|partial_symtab
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|subpst
operator|->
name|dependencies
index|[
literal|0
index|]
operator|=
name|pst
expr_stmt|;
name|subpst
operator|->
name|number_of_dependencies
operator|=
literal|1
expr_stmt|;
name|subpst
operator|->
name|globals_offset
operator|=
name|subpst
operator|->
name|n_global_syms
operator|=
name|subpst
operator|->
name|statics_offset
operator|=
name|subpst
operator|->
name|n_static_syms
operator|=
literal|0
expr_stmt|;
name|subpst
operator|->
name|readin
operator|=
literal|0
expr_stmt|;
name|subpst
operator|->
name|symtab
operator|=
literal|0
expr_stmt|;
name|subpst
operator|->
name|read_symtab
operator|=
name|pst
operator|->
name|read_symtab
expr_stmt|;
block|}
name|sort_pst_symbols
argument_list|(
name|pst
argument_list|)
expr_stmt|;
comment|/* If there is already a psymtab or symtab for a file of this name,       remove it.      (If there is a symtab, more drastic things also happen.)      This happens in VxWorks.  */
name|free_named_symtabs
argument_list|(
name|pst
operator|->
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_includes
operator|==
literal|0
operator|&&
name|number_dependencies
operator|==
literal|0
operator|&&
name|pst
operator|->
name|n_global_syms
operator|==
literal|0
operator|&&
name|pst
operator|->
name|n_static_syms
operator|==
literal|0
condition|)
block|{
comment|/* Throw away this psymtab, it's empty.  We can't deallocate it, since        it is on the obstack, but we can forget to chain it on the list.  */
comment|/* Indicate that psymtab was thrown away.  */
name|discard_psymtab
argument_list|(
name|pst
argument_list|)
expr_stmt|;
name|pst
operator|=
operator|(
expr|struct
name|partial_symtab
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
return|return
name|pst
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|os9k_psymtab_to_symtab_1
parameter_list|(
name|pst
parameter_list|)
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
block|{
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|pst
condition|)
return|return;
if|if
condition|(
name|pst
operator|->
name|readin
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Psymtab for %s already read in.  Shouldn't happen.\n"
argument_list|,
name|pst
operator|->
name|filename
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Read in all partial symtabs on which this one is dependent */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pst
operator|->
name|number_of_dependencies
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|pst
operator|->
name|dependencies
index|[
name|i
index|]
operator|->
name|readin
condition|)
block|{
comment|/* Inform about additional files that need to be read in.  */
if|if
condition|(
name|info_verbose
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|" "
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"and "
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%s..."
argument_list|,
name|pst
operator|->
name|dependencies
index|[
name|i
index|]
operator|->
name|filename
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
comment|/* Flush output */
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
name|os9k_psymtab_to_symtab_1
argument_list|(
name|pst
operator|->
name|dependencies
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LDSYMCNT
argument_list|(
name|pst
argument_list|)
condition|)
comment|/* Otherwise it's a dummy */
block|{
comment|/* Init stuff necessary for reading in symbols */
name|stabsread_init
argument_list|()
expr_stmt|;
name|buildsym_init
argument_list|()
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
operator|(
name|make_cleanup_func
operator|)
name|really_free_pendings
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Read in this file's symbols */
name|os9k_read_ofile_symtab
argument_list|(
name|pst
argument_list|)
expr_stmt|;
name|sort_symtab_syms
argument_list|(
name|pst
operator|->
name|symtab
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
name|pst
operator|->
name|readin
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read in all of the symbols for a given psymtab for real.    Be verbose about it if the user wants that.  */
end_comment

begin_function
specifier|static
name|void
name|os9k_psymtab_to_symtab
parameter_list|(
name|pst
parameter_list|)
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
block|{
name|bfd
modifier|*
name|sym_bfd
decl_stmt|;
if|if
condition|(
operator|!
name|pst
condition|)
return|return;
if|if
condition|(
name|pst
operator|->
name|readin
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Psymtab for %s already read in.  Shouldn't happen.\n"
argument_list|,
name|pst
operator|->
name|filename
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|LDSYMCNT
argument_list|(
name|pst
argument_list|)
operator|||
name|pst
operator|->
name|number_of_dependencies
condition|)
block|{
comment|/* Print the message now, before reading the string table, 	 to avoid disconcerting pauses.  */
if|if
condition|(
name|info_verbose
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Reading in symbols for %s..."
argument_list|,
name|pst
operator|->
name|filename
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
name|sym_bfd
operator|=
name|pst
operator|->
name|objfile
operator|->
name|obfd
expr_stmt|;
name|os9k_psymtab_to_symtab_1
argument_list|(
name|pst
argument_list|)
expr_stmt|;
comment|/* Match with global symbols.  This only needs to be done once,          after all of the symtabs and dependencies have been read in.   */
name|scan_file_globals
argument_list|(
name|pst
operator|->
name|objfile
argument_list|)
expr_stmt|;
comment|/* Finish up the debug error message.  */
if|if
condition|(
name|info_verbose
condition|)
name|printf_filtered
argument_list|(
literal|"done.\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Read in a defined section of a specific object file's symbols. */
end_comment

begin_function
specifier|static
name|void
name|os9k_read_ofile_symtab
parameter_list|(
name|pst
parameter_list|)
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
block|{
specifier|register
name|struct
name|internal_symstruct
modifier|*
name|bufp
decl_stmt|;
name|unsigned
name|char
name|type
decl_stmt|;
name|unsigned
name|max_symnum
decl_stmt|;
specifier|register
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|int
name|sym_offset
decl_stmt|;
comment|/* Offset to start of symbols to read */
name|CORE_ADDR
name|text_offset
decl_stmt|;
comment|/* Start of text segment for symbols */
name|int
name|text_size
decl_stmt|;
comment|/* Size of text segment for symbols */
name|struct
name|section_offsets
modifier|*
name|section_offsets
decl_stmt|;
name|FILE
modifier|*
name|dbg_file
decl_stmt|;
name|objfile
operator|=
name|pst
operator|->
name|objfile
expr_stmt|;
name|sym_offset
operator|=
name|LDSYMOFF
argument_list|(
name|pst
argument_list|)
expr_stmt|;
name|max_symnum
operator|=
name|LDSYMCNT
argument_list|(
name|pst
argument_list|)
expr_stmt|;
name|text_offset
operator|=
name|pst
operator|->
name|textlow
expr_stmt|;
name|text_size
operator|=
name|pst
operator|->
name|texthigh
operator|-
name|pst
operator|->
name|textlow
expr_stmt|;
name|section_offsets
operator|=
name|pst
operator|->
name|section_offsets
expr_stmt|;
name|current_objfile
operator|=
name|objfile
expr_stmt|;
name|subfile_stack
operator|=
name|NULL
expr_stmt|;
name|last_source_file
operator|=
name|NULL
expr_stmt|;
name|abfd
operator|=
name|objfile
operator|->
name|obfd
expr_stmt|;
name|dbg_file
operator|=
name|objfile
operator|->
name|auxf2
expr_stmt|;
if|#
directive|if
literal|0
comment|/* It is necessary to actually read one symbol *before* the start      of this symtab's symbols, because the GCC_COMPILED_FLAG_SYMBOL      occurs before the N_SO symbol.      Detecting this in read_dbx_symtab      would slow down initial readin, so we look for it here instead. */
block|if (!processing_acc_compilation&& sym_offset>= (int)symbol_size)     {       fseek (objefile->auxf2, sym_offset, SEEK_CUR);       fill_sym(objfile->auxf2, abfd);       bufp = symbuf;        processing_gcc_compilation = 0;       if (bufp->n_type == N_TEXT) 	{ 	  if (STREQ (namestring, GCC_COMPILED_FLAG_SYMBOL)) 	    processing_gcc_compilation = 1; 	  else if (STREQ (namestring, GCC2_COMPILED_FLAG_SYMBOL)) 	    processing_gcc_compilation = 2; 	}
comment|/* Try to select a C++ demangling based on the compilation unit 	 producer. */
block|if (processing_gcc_compilation) 	{ 	  if (AUTO_DEMANGLING) 	    { 	      set_demangling_style (GNU_DEMANGLING_STYLE_STRING); 	    } 	}     }   else     {
comment|/* The N_SO starting this symtab is the first symbol, so we 	 better not check the symbol before it.  I'm not this can 	 happen, but it doesn't hurt to check for it.  */
block|bfd_seek (symfile_bfd, sym_offset, SEEK_CUR);       processing_gcc_compilation = 0;     }
endif|#
directive|endif
comment|/* 0 */
name|fseek
argument_list|(
name|dbg_file
argument_list|,
operator|(
name|long
operator|)
name|sym_offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*   if (bufp->n_type != (unsigned char)N_SYM_SYM)     error("First symbol in segment of executable not a source symbol"); */
for|for
control|(
name|symnum
operator|=
literal|0
init|;
name|symnum
operator|<
name|max_symnum
condition|;
name|symnum
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
comment|/* Allow this to be interruptable */
name|fill_sym
argument_list|(
name|dbg_file
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|bufp
operator|=
name|symbuf
expr_stmt|;
name|type
operator|=
name|bufp
operator|->
name|n_type
expr_stmt|;
name|os9k_process_one_symbol
argument_list|(
operator|(
name|int
operator|)
name|type
argument_list|,
operator|(
name|int
operator|)
name|bufp
operator|->
name|n_desc
argument_list|,
operator|(
name|CORE_ADDR
operator|)
name|bufp
operator|->
name|n_value
argument_list|,
name|bufp
operator|->
name|n_strx
argument_list|,
name|section_offsets
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* We skip checking for a new .o or -l file; that should never          happen in this routine. */
if|#
directive|if
literal|0
block|else if (type == N_TEXT) 	{
comment|/* I don't think this code will ever be executed, because 	     the GCC_COMPILED_FLAG_SYMBOL usually is right before 	     the N_SO symbol which starts this source file. 	     However, there is no reason not to accept 	     the GCC_COMPILED_FLAG_SYMBOL anywhere.  */
block|if (STREQ (namestring, GCC_COMPILED_FLAG_SYMBOL)) 	    processing_gcc_compilation = 1; 	  else if (STREQ (namestring, GCC2_COMPILED_FLAG_SYMBOL)) 	    processing_gcc_compilation = 2;  	  if (AUTO_DEMANGLING) 	    { 	      set_demangling_style (GNU_DEMANGLING_STYLE_STRING); 	    } 	}       else if (type& N_EXT || type == (unsigned char)N_TEXT 	       || type == (unsigned char)N_NBTEXT 	       ) {
comment|/* Global symbol: see if we came across a dbx defintion for 	     a corresponding symbol.  If so, store the value.  Remove 	     syms from the chain when their values are stored, but 	     search the whole chain, as there may be several syms from 	     different files with the same name. */
comment|/* This is probably not true.  Since the files will be read 	     in one at a time, each reference to a global symbol will 	     be satisfied in each file as it appears. So we skip this 	     section. */
block|;         }
endif|#
directive|endif
comment|/* 0 */
block|}
name|current_objfile
operator|=
name|NULL
expr_stmt|;
comment|/* In a Solaris elf file, this variable, which comes from the      value of the N_SO symbol, will still be 0.  Luckily, text_offset,      which comes from pst->textlow is correct. */
if|if
condition|(
name|last_source_start_addr
operator|==
literal|0
condition|)
name|last_source_start_addr
operator|=
name|text_offset
expr_stmt|;
name|pst
operator|->
name|symtab
operator|=
name|end_symtab
argument_list|(
name|text_offset
operator|+
name|text_size
argument_list|,
name|objfile
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
expr_stmt|;
name|end_stabs
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This handles a single symbol from the symbol-file, building symbols    into a GDB symtab.  It takes these arguments and an implicit argument.     TYPE is the type field of the ".stab" symbol entry.    DESC is the desc field of the ".stab" entry.    VALU is the value field of the ".stab" entry.    NAME is the symbol name, in our address space.    SECTION_OFFSETS is a set of amounts by which the sections of this object           file were relocated when it was loaded into memory.           All symbols that refer 	  to memory locations need to be offset by these amounts.    OBJFILE is the object file from which we are reading symbols.  	       It is used in end_symtab.  */
end_comment

begin_function
specifier|static
name|void
name|os9k_process_one_symbol
parameter_list|(
name|type
parameter_list|,
name|desc
parameter_list|,
name|valu
parameter_list|,
name|name
parameter_list|,
name|section_offsets
parameter_list|,
name|objfile
parameter_list|)
name|int
name|type
decl_stmt|,
name|desc
decl_stmt|;
name|CORE_ADDR
name|valu
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|section_offsets
modifier|*
name|section_offsets
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
specifier|register
name|struct
name|context_stack
modifier|*
name|new
decl_stmt|;
comment|/* The stab type used for the definition of the last function.      N_STSYM or N_GSYM for SunOS4 acc; N_FUN for other compilers.  */
specifier|static
name|int
name|function_stab_type
init|=
literal|0
decl_stmt|;
if|#
directive|if
literal|0
comment|/* Something is wrong if we see real data before      seeing a source file name.  */
block|if (last_source_file == NULL&& type != (unsigned char)N_SO)     {
comment|/* Ignore any symbols which appear before an N_SO symbol. 	 Currently no one puts symbols there, but we should deal 	 gracefully with the case.  A complain()t might be in order, 	 but this should not be an error ().  */
block|return;     }
endif|#
directive|endif
comment|/* 0 */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|N_SYM_LBRAC
case|:
comment|/* On most machines, the block addresses are relative to the 	 N_SO, the linker did not relocate them (sigh).  */
name|valu
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
expr_stmt|;
name|new
operator|=
name|push_context
argument_list|(
name|desc
argument_list|,
name|valu
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_SYM_RBRAC
case|:
name|valu
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
expr_stmt|;
name|new
operator|=
name|pop_context
argument_list|()
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|OS9K_VARIABLES_INSIDE_BLOCK
argument_list|)
define|#
directive|define
name|OS9K_VARIABLES_INSIDE_BLOCK
parameter_list|(
name|desc
parameter_list|,
name|gcc_p
parameter_list|)
value|1
endif|#
directive|endif
if|if
condition|(
operator|!
name|OS9K_VARIABLES_INSIDE_BLOCK
argument_list|(
name|desc
argument_list|,
name|processing_gcc_compilation
argument_list|)
condition|)
name|local_symbols
operator|=
name|new
operator|->
name|locals
expr_stmt|;
if|if
condition|(
name|context_stack_depth
operator|>
literal|1
condition|)
block|{
comment|/* This is not the outermost LBRAC...RBRAC pair in the function, 	     its local symbols preceded it, and are the ones just recovered 	     from the context stack.  Define the block for them (but don't 	     bother if the block contains no symbols.  Should we complain 	     on blocks without symbols?  I can't think of any useful purpose 	     for them).  */
if|if
condition|(
name|local_symbols
operator|!=
name|NULL
condition|)
block|{
comment|/* Muzzle a compiler bug that makes end< start.  (which 		 compilers?  Is this ever harmful?).  */
if|if
condition|(
name|new
operator|->
name|start_addr
operator|>
name|valu
condition|)
block|{
name|complain
argument_list|(
operator|&
name|lbrac_rbrac_complaint
argument_list|)
expr_stmt|;
name|new
operator|->
name|start_addr
operator|=
name|valu
expr_stmt|;
block|}
comment|/* Make a block for the local symbols within.  */
name|finish_block
argument_list|(
literal|0
argument_list|,
operator|&
name|local_symbols
argument_list|,
name|new
operator|->
name|old_blocks
argument_list|,
name|new
operator|->
name|start_addr
argument_list|,
name|valu
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|context_stack_depth
operator|==
literal|0
condition|)
block|{
name|within_function
operator|=
literal|0
expr_stmt|;
comment|/* Make a block for the local symbols within.  */
name|finish_block
argument_list|(
name|new
operator|->
name|name
argument_list|,
operator|&
name|local_symbols
argument_list|,
name|new
operator|->
name|old_blocks
argument_list|,
name|new
operator|->
name|start_addr
argument_list|,
name|valu
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* attach local_symbols to the end of new->locals */
if|if
condition|(
operator|!
name|new
operator|->
name|locals
condition|)
name|new
operator|->
name|locals
operator|=
name|local_symbols
expr_stmt|;
else|else
block|{
name|struct
name|pending
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|new
operator|->
name|locals
expr_stmt|;
while|while
condition|(
name|p
operator|->
name|next
condition|)
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|local_symbols
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|OS9K_VARIABLES_INSIDE_BLOCK
argument_list|(
name|desc
argument_list|,
name|processing_gcc_compilation
argument_list|)
condition|)
comment|/* Now pop locals of block just finished.  */
name|local_symbols
operator|=
name|new
operator|->
name|locals
expr_stmt|;
break|break;
case|case
name|N_SYM_SLINE
case|:
comment|/* This type of "symbol" really just records 	 one line-number -- core-address correspondence. 	 Enter it in the line list for this symbol table. */
comment|/* Relocate for dynamic loading and for ELF acc fn-relative syms.  */
name|valu
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
expr_stmt|;
comment|/* FIXME: loses if sizeof (char *)> sizeof (int) */
name|record_line
argument_list|(
name|current_subfile
argument_list|,
operator|(
name|int
operator|)
name|name
argument_list|,
name|valu
argument_list|)
expr_stmt|;
break|break;
comment|/* The following symbol types need to have the appropriate offset added        to their value; then we process symbol definitions in the name.  */
case|case
name|N_SYM_SYM
case|:
if|if
condition|(
name|name
condition|)
block|{
name|char
name|deftype
decl_stmt|;
name|char
modifier|*
name|dirn
decl_stmt|,
modifier|*
name|n
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|':'
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|deftype
operator|=
literal|'\0'
expr_stmt|;
else|else
name|deftype
operator|=
name|p
index|[
literal|1
index|]
expr_stmt|;
switch|switch
condition|(
name|deftype
condition|)
block|{
case|case
literal|'S'
case|:
name|valu
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
expr_stmt|;
name|n
operator|=
name|strrchr
argument_list|(
name|name
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|NULL
condition|)
block|{
operator|*
name|n
operator|=
literal|'\0'
expr_stmt|;
name|n
operator|++
expr_stmt|;
name|dirn
operator|=
name|name
expr_stmt|;
block|}
else|else
block|{
name|n
operator|=
name|name
expr_stmt|;
name|dirn
operator|=
name|NULL
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|symfile_depth
operator|++
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|last_source_file
condition|)
block|{
name|end_symtab
argument_list|(
name|valu
argument_list|,
name|objfile
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
expr_stmt|;
name|end_stabs
argument_list|()
expr_stmt|;
block|}
name|start_stabs
argument_list|()
expr_stmt|;
name|os9k_stabs
operator|=
literal|1
expr_stmt|;
name|start_symtab
argument_list|(
name|n
argument_list|,
name|dirn
argument_list|,
name|valu
argument_list|)
expr_stmt|;
name|record_debugformat
argument_list|(
literal|"OS9"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|push_subfile
argument_list|()
expr_stmt|;
name|start_subfile
argument_list|(
name|n
argument_list|,
name|dirn
operator|!=
name|NULL
condition|?
name|dirn
else|:
name|current_subfile
operator|->
name|dirname
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
name|valu
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
expr_stmt|;
name|function_stab_type
operator|=
name|type
expr_stmt|;
name|within_function
operator|=
literal|1
expr_stmt|;
name|new
operator|=
name|push_context
argument_list|(
literal|0
argument_list|,
name|valu
argument_list|)
expr_stmt|;
name|new
operator|->
name|name
operator|=
name|define_symbol
argument_list|(
name|valu
argument_list|,
name|name
argument_list|,
name|desc
argument_list|,
name|type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
case|case
literal|'v'
case|:
name|valu
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_DATA
argument_list|)
expr_stmt|;
name|define_symbol
argument_list|(
name|valu
argument_list|,
name|name
argument_list|,
name|desc
argument_list|,
name|type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
default|default:
name|define_symbol
argument_list|(
name|valu
argument_list|,
name|name
argument_list|,
name|desc
argument_list|,
name|type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
name|N_SYM_SE
case|:
if|if
condition|(
operator|--
name|symfile_depth
operator|!=
literal|0
condition|)
name|start_subfile
argument_list|(
name|pop_subfile
argument_list|()
argument_list|,
name|current_subfile
operator|->
name|dirname
argument_list|)
expr_stmt|;
break|break;
default|default:
name|complain
argument_list|(
operator|&
name|unknown_symtype_complaint
argument_list|,
name|local_hex_string
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
break|break;
case|case
name|N_SYM_CMPLR
case|:
break|break;
block|}
name|previous_stab_code
operator|=
name|type
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|sym_fns
name|os9k_sym_fns
init|=
block|{
name|bfd_target_os9k_flavour
block|,
name|os9k_new_init
block|,
comment|/* sym_new_init: init anything gbl to entire symtab */
name|os9k_symfile_init
block|,
comment|/* sym_init: read initial info, setup for sym_read() */
name|os9k_symfile_read
block|,
comment|/* sym_read: read a symbol file into symtab */
name|os9k_symfile_finish
block|,
comment|/* sym_finish: finished with file, cleanup */
name|default_symfile_offsets
block|,
comment|/* sym_offsets: parse user's offsets to internal form*/
name|NULL
comment|/* next: pointer to next struct sym_fns */
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|_initialize_os9kread
parameter_list|()
block|{
name|add_symtab_fns
argument_list|(
operator|&
name|os9k_sym_fns
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

