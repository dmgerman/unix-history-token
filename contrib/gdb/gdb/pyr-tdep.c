begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Pyramid target-dependent code for GDB.    Copyright (C) 1988, 1989, 1991 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_comment
comment|/*** Prettier register printing. ***/
end_comment

begin_comment
comment|/* Print registers in the same format as pyramid's dbx, adb, sdb.  */
end_comment

begin_macro
name|pyr_print_registers
argument_list|(
argument|reg_buf
argument_list|,
argument|regnum
argument_list|)
end_macro

begin_decl_stmt
name|long
modifier|*
name|reg_buf
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|regno
decl_stmt|;
name|int
name|usp
decl_stmt|,
name|ksp
decl_stmt|;
name|struct
name|user
name|u
decl_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
literal|16
condition|;
name|regno
operator|++
control|)
block|{
name|printf_unfiltered
comment|/*_filtered*/
argument_list|(
literal|"%6.6s: %8x  %6.6s: %8x  %6s: %8x  %6s: %8x\n"
argument_list|,
name|reg_names
index|[
name|regno
index|]
argument_list|,
name|reg_buf
index|[
name|regno
index|]
argument_list|,
name|reg_names
index|[
name|regno
operator|+
literal|16
index|]
argument_list|,
name|reg_buf
index|[
name|regno
operator|+
literal|16
index|]
argument_list|,
name|reg_names
index|[
name|regno
operator|+
literal|32
index|]
argument_list|,
name|reg_buf
index|[
name|regno
operator|+
literal|32
index|]
argument_list|,
name|reg_names
index|[
name|regno
operator|+
literal|48
index|]
argument_list|,
name|reg_buf
index|[
name|regno
operator|+
literal|48
index|]
argument_list|)
expr_stmt|;
block|}
name|usp
operator|=
name|ptrace
argument_list|(
literal|3
argument_list|,
name|inferior_pid
argument_list|,
call|(
name|PTRACE_ARG3_TYPE
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|u
operator|.
name|u_pcb
operator|.
name|pcb_usp
argument_list|)
operator|-
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|u
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ksp
operator|=
name|ptrace
argument_list|(
literal|3
argument_list|,
name|inferior_pid
argument_list|,
call|(
name|PTRACE_ARG3_TYPE
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|u
operator|.
name|u_pcb
operator|.
name|pcb_ksp
argument_list|)
operator|-
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|u
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf_unfiltered
comment|/*_filtered*/
argument_list|(
literal|"\n%6.6s: %8x  %6.6s: %8x (%08x) %6.6s %8x\n"
argument_list|,
name|reg_names
index|[
name|CSP_REGNUM
index|]
argument_list|,
name|reg_buf
index|[
name|CSP_REGNUM
index|]
argument_list|,
name|reg_names
index|[
name|KSP_REGNUM
index|]
argument_list|,
name|reg_buf
index|[
name|KSP_REGNUM
index|]
argument_list|,
name|ksp
argument_list|,
literal|"usp"
argument_list|,
name|usp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Print the register regnum, or all registers if regnum is -1.    fpregs is currently ignored.  */
end_comment

begin_macro
name|pyr_do_registers_info
argument_list|(
argument|regnum
argument_list|,
argument|fpregs
argument_list|)
end_macro

begin_decl_stmt
name|int
name|regnum
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|fpregs
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* On a pyr, we know a virtual register can always fit in an long.      Here (and elsewhere) we take advantage of that.  Yuk.  */
name|long
name|raw_regs
index|[
name|MAX_REGISTER_RAW_SIZE
operator|*
name|NUM_REGS
index|]
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
block|{
name|read_relative_register_raw_bytes
argument_list|(
name|i
argument_list|,
name|raw_regs
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|regnum
operator|==
operator|-
literal|1
condition|)
name|pyr_print_registers
argument_list|(
name|raw_regs
argument_list|,
name|regnum
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_REGS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|i
operator|==
name|regnum
condition|)
block|{
name|long
name|val
init|=
name|raw_regs
index|[
name|i
index|]
decl_stmt|;
name|fputs_filtered
argument_list|(
name|reg_names
index|[
name|i
index|]
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|":"
argument_list|)
expr_stmt|;
name|print_spaces_filtered
argument_list|(
literal|6
operator|-
name|strlen
argument_list|(
name|reg_names
index|[
name|i
index|]
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
name|printf_filtered
argument_list|(
literal|"0"
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|"%s  %d"
argument_list|,
name|local_hex_string_custom
argument_list|(
name|val
argument_list|,
literal|"08"
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*** Debugging editions of various macros from m-pyr.h ****/
end_comment

begin_function
name|CORE_ADDR
name|frame_locals_address
parameter_list|(
name|frame
parameter_list|)
name|struct
name|frame_info
modifier|*
name|frame
decl_stmt|;
block|{
specifier|register
name|int
name|addr
init|=
name|find_saved_register
argument_list|(
name|frame
argument_list|,
name|CFP_REGNUM
argument_list|)
decl_stmt|;
specifier|register
name|int
name|result
init|=
name|read_memory_integer
argument_list|(
name|addr
argument_list|,
literal|4
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|PYRAMID_CONTROL_FRAME_DEBUGGING
name|fprintf_unfiltered
argument_list|(
name|stderr
argument_list|,
literal|"\t[[..frame_locals:%8x, %s= %x @%x fcfp= %x foo= %x\n\t gr13=%x pr13=%x tr13=%x @%x]]\n"
argument_list|,
name|frame
operator|->
name|frame
argument_list|,
name|reg_names
index|[
name|CFP_REGNUM
index|]
argument_list|,
name|result
argument_list|,
name|addr
argument_list|,
name|frame
operator|->
name|frame_cfp
argument_list|,
operator|(
name|CFP_REGNUM
operator|)
argument_list|,
name|read_register
argument_list|(
literal|13
argument_list|)
argument_list|,
name|read_register
argument_list|(
literal|29
argument_list|)
argument_list|,
name|read_register
argument_list|(
literal|61
argument_list|)
argument_list|,
name|find_saved_register
argument_list|(
name|frame
argument_list|,
literal|61
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PYRAMID_CONTROL_FRAME_DEBUGGING */
comment|/* FIXME: I thought read_register (CFP_REGNUM) should be the right answer;      or at least CFP_REGNUM relative to FRAME (ie, result).      There seems to be a bug in the way the innermost frame is set up.  */
return|return
operator|(
operator|(
name|frame
operator|->
name|next
operator|)
condition|?
name|result
else|:
name|frame
operator|->
name|frame_cfp
operator|)
return|;
block|}
end_function

begin_function
name|CORE_ADDR
name|frame_args_addr
parameter_list|(
name|frame
parameter_list|)
name|struct
name|frame_info
modifier|*
name|frame
decl_stmt|;
block|{
specifier|register
name|int
name|addr
init|=
name|find_saved_register
argument_list|(
name|frame
argument_list|,
name|CFP_REGNUM
argument_list|)
decl_stmt|;
specifier|register
name|int
name|result
init|=
name|read_memory_integer
argument_list|(
name|addr
argument_list|,
literal|4
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|PYRAMID_CONTROL_FRAME_DEBUGGING
name|fprintf_unfiltered
argument_list|(
name|stderr
argument_list|,
literal|"\t[[..frame_args:%8x, %s= %x @%x fcfp= %x r_r= %x\n\t gr13=%x pr13=%x tr13=%x @%x]]\n"
argument_list|,
name|frame
operator|->
name|frame
argument_list|,
name|reg_names
index|[
name|CFP_REGNUM
index|]
argument_list|,
name|result
argument_list|,
name|addr
argument_list|,
name|frame
operator|->
name|frame_cfp
argument_list|,
name|read_register
argument_list|(
name|CFP_REGNUM
argument_list|)
argument_list|,
name|read_register
argument_list|(
literal|13
argument_list|)
argument_list|,
name|read_register
argument_list|(
literal|29
argument_list|)
argument_list|,
name|read_register
argument_list|(
literal|61
argument_list|)
argument_list|,
name|find_saved_register
argument_list|(
name|frame
argument_list|,
literal|61
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*  PYRAMID_CONTROL_FRAME_DEBUGGING */
comment|/* FIXME: I thought read_register (CFP_REGNUM) should be the right answer;      or at least CFP_REGNUM relative to FRAME (ie, result).      There seems to be a bug in the way the innermost frame is set up.  */
return|return
operator|(
operator|(
name|frame
operator|->
name|next
operator|)
condition|?
name|result
else|:
name|frame
operator|->
name|frame_cfp
operator|)
return|;
block|}
end_function

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"opcode/pyr.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_escape
end_escape

begin_comment
comment|/*  A couple of functions used for debugging frame-handling on     Pyramids. (The Pyramid-dependent handling of register values for     windowed registers is known to be buggy.)      When debugging, these functions can supplant the normal definitions of some     of the macros in tm-pyramid.h  The quantity of information produced     when these functions are used makes the gdb  unusable as a     debugger for user programs.  */
end_comment

begin_decl_stmt
specifier|extern
name|unsigned
name|pyr_saved_pc
argument_list|()
decl_stmt|,
name|pyr_frame_chain
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function
name|CORE_ADDR
name|pyr_frame_chain
parameter_list|(
name|frame
parameter_list|)
name|CORE_ADDR
name|frame
decl_stmt|;
block|{
name|int
name|foo
init|=
name|frame
operator|-
name|CONTROL_STACK_FRAME_SIZE
decl_stmt|;
comment|/* printf_unfiltered ("...following chain from %x: got %x\n", frame, foo);*/
return|return
name|foo
return|;
block|}
end_function

begin_function
name|CORE_ADDR
name|pyr_saved_pc
parameter_list|(
name|frame
parameter_list|)
name|CORE_ADDR
name|frame
decl_stmt|;
block|{
name|int
name|foo
init|=
literal|0
decl_stmt|;
name|foo
operator|=
name|read_memory_integer
argument_list|(
operator|(
call|(
name|CORE_ADDR
call|)
argument_list|(
name|frame
argument_list|)
operator|)
operator|+
literal|60
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"..reading pc from frame 0x%0x+%d regs: got %0x\n"
argument_list|,
name|frame
argument_list|,
literal|60
operator|/
literal|4
argument_list|,
name|foo
argument_list|)
expr_stmt|;
return|return
name|foo
return|;
block|}
end_function

begin_comment
comment|/* Pyramid instructions are never longer than this many bytes.  */
end_comment

begin_define
define|#
directive|define
name|MAXLEN
value|24
end_define

begin_comment
comment|/* Number of elements in the opcode table.  */
end_comment

begin_comment
comment|/*const*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|nopcodes
init|=
operator|(
sizeof|sizeof
argument_list|(
name|pyr_opcodes
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|pyr_opcodes
index|[
literal|0
index|]
argument_list|)
operator|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NOPCODES
value|(nopcodes)
end_define

begin_comment
comment|/* Let's be byte-independent so we can use this as a cross-assembler.  */
end_comment

begin_define
define|#
directive|define
name|NEXTLONG
parameter_list|(
name|p
parameter_list|)
define|\
value|(p += 4, (((((p[-4]<< 8) + p[-3])<< 8) + p[-2])<< 8) + p[-1])
end_define

begin_escape
end_escape

begin_comment
comment|/* Print one instruction at address MEMADDR in debugged memory,    on STREAM.  Returns length of the instruction, in bytes.  */
end_comment

begin_function
name|int
name|pyr_print_insn
parameter_list|(
name|memaddr
parameter_list|,
name|stream
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|unsigned
name|char
name|buffer
index|[
name|MAXLEN
index|]
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|nargs
decl_stmt|,
name|insn_size
init|=
literal|4
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|d
decl_stmt|;
specifier|register
name|int
name|insn_opcode
decl_stmt|,
name|operand_mode
decl_stmt|;
specifier|register
name|int
name|index_multiplier
decl_stmt|,
name|index_reg_regno
decl_stmt|,
name|op_1_regno
decl_stmt|,
name|op_2_regno
decl_stmt|;
name|long
name|insn
decl_stmt|;
comment|/* first word of the insn, not broken down. */
name|pyr_insn_format
name|insn_decode
decl_stmt|;
comment|/* the same, broken out into op{code,erands} */
name|long
name|extra_1
decl_stmt|,
name|extra_2
decl_stmt|;
name|read_memory
argument_list|(
name|memaddr
argument_list|,
name|buffer
argument_list|,
name|MAXLEN
argument_list|)
expr_stmt|;
name|insn_decode
operator|=
operator|*
operator|(
operator|(
name|pyr_insn_format
operator|*
operator|)
name|buffer
operator|)
expr_stmt|;
name|insn
operator|=
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|buffer
operator|)
expr_stmt|;
name|insn_opcode
operator|=
name|insn_decode
operator|.
name|operator
expr_stmt|;
name|operand_mode
operator|=
name|insn_decode
operator|.
name|mode
expr_stmt|;
name|index_multiplier
operator|=
name|insn_decode
operator|.
name|index_scale
expr_stmt|;
name|index_reg_regno
operator|=
name|insn_decode
operator|.
name|index_reg
expr_stmt|;
name|op_1_regno
operator|=
name|insn_decode
operator|.
name|operand_1
expr_stmt|;
name|op_2_regno
operator|=
name|insn_decode
operator|.
name|operand_2
expr_stmt|;
if|if
condition|(
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|buffer
operator|)
operator|==
literal|0x0
condition|)
block|{
comment|/* "halt" looks just like an invalid "jump" to the insn decoder,        so is dealt with as a special case */
name|fprintf_unfiltered
argument_list|(
name|stream
argument_list|,
literal|"halt"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|4
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NOPCODES
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|pyr_opcodes
index|[
name|i
index|]
operator|.
name|datum
operator|.
name|code
operator|==
name|insn_opcode
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|NOPCODES
condition|)
comment|/* FIXME: Handle unrecognised instructions better.  */
name|fprintf_unfiltered
argument_list|(
name|stream
argument_list|,
literal|"???\t#%08x\t(op=%x mode =%x)"
argument_list|,
name|insn
argument_list|,
name|insn_decode
operator|.
name|operator
argument_list|,
name|insn_decode
operator|.
name|mode
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Print the mnemonic for the instruction.  Pyramid insn operands          are so regular that we can deal with almost all of them          separately. 	 Unconditional branches are an exception: they are encoded as 	 conditional branches (branch if false condition, I think) 	 with no condition specified. The average user will not be 	 aware of this. To maintain their illusion that an 	 unconditional branch insn exists, we will have to FIXME to 	 treat the insn mnemnonic of all branch instructions here as a 	 special case: check the operands of branch insn and print an 	 appropriate mnemonic. */
name|fprintf_unfiltered
argument_list|(
name|stream
argument_list|,
literal|"%s\t"
argument_list|,
name|pyr_opcodes
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
comment|/* Print the operands of the insn (as specified in        insn.operand_mode).         Branch operands of branches are a special case: they are a word        offset, not a byte offset. */
if|if
condition|(
name|insn_decode
operator|.
name|operator
operator|==
literal|0x01
operator|||
name|insn_decode
operator|.
name|operator
operator|==
literal|0x02
condition|)
block|{
specifier|register
name|int
name|bit_codes
init|=
operator|(
name|insn
operator|>>
literal|16
operator|)
operator|&
literal|0xf
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|displacement
init|=
operator|(
name|insn
operator|&
literal|0x0000ffff
operator|)
operator|<<
literal|2
decl_stmt|;
specifier|static
name|char
name|cc_bit_names
index|[]
init|=
literal|"cvzn"
decl_stmt|;
comment|/* z,n,c,v: strange order? */
comment|/* Is bfc and no bits specified an unconditional branch?*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|bit_codes
operator|)
operator|&
literal|0x1
condition|)
name|fputc_unfiltered
argument_list|(
name|cc_bit_names
index|[
name|i
index|]
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|bit_codes
operator|>>=
literal|1
expr_stmt|;
block|}
name|fprintf_unfiltered
argument_list|(
name|stream
argument_list|,
literal|",%0x"
argument_list|,
name|displacement
operator|+
name|memaddr
argument_list|)
expr_stmt|;
return|return
operator|(
name|insn_size
operator|)
return|;
block|}
switch|switch
condition|(
name|operand_mode
condition|)
block|{
case|case
literal|0
case|:
name|fprintf_unfiltered
argument_list|(
name|stream
argument_list|,
literal|"%s,%s"
argument_list|,
name|reg_names
index|[
name|op_1_regno
index|]
argument_list|,
name|reg_names
index|[
name|op_2_regno
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|fprintf_unfiltered
argument_list|(
name|stream
argument_list|,
literal|" 0x%0x,%s"
argument_list|,
name|op_1_regno
argument_list|,
name|reg_names
index|[
name|op_2_regno
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|read_memory
argument_list|(
name|memaddr
operator|+
literal|4
argument_list|,
name|buffer
argument_list|,
name|MAXLEN
argument_list|)
expr_stmt|;
name|insn_size
operator|+=
literal|4
expr_stmt|;
name|extra_1
operator|=
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|buffer
operator|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|stream
argument_list|,
literal|" $0x%0x,%s"
argument_list|,
name|extra_1
argument_list|,
name|reg_names
index|[
name|op_2_regno
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|fprintf_unfiltered
argument_list|(
name|stream
argument_list|,
literal|" (%s),%s"
argument_list|,
name|reg_names
index|[
name|op_1_regno
index|]
argument_list|,
name|reg_names
index|[
name|op_2_regno
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|read_memory
argument_list|(
name|memaddr
operator|+
literal|4
argument_list|,
name|buffer
argument_list|,
name|MAXLEN
argument_list|)
expr_stmt|;
name|insn_size
operator|+=
literal|4
expr_stmt|;
name|extra_1
operator|=
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|buffer
operator|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|stream
argument_list|,
literal|" 0x%0x(%s),%s"
argument_list|,
name|extra_1
argument_list|,
name|reg_names
index|[
name|op_1_regno
index|]
argument_list|,
name|reg_names
index|[
name|op_2_regno
index|]
argument_list|)
expr_stmt|;
break|break;
comment|/* S1 destination mode */
case|case
literal|5
case|:
name|fprintf_unfiltered
argument_list|(
name|stream
argument_list|,
operator|(
operator|(
name|index_reg_regno
operator|)
condition|?
literal|"%s,(%s)[%s*%1d]"
else|:
literal|"%s,(%s)"
operator|)
argument_list|,
name|reg_names
index|[
name|op_1_regno
index|]
argument_list|,
name|reg_names
index|[
name|op_2_regno
index|]
argument_list|,
name|reg_names
index|[
name|index_reg_regno
index|]
argument_list|,
name|index_multiplier
argument_list|)
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|fprintf_unfiltered
argument_list|(
name|stream
argument_list|,
operator|(
operator|(
name|index_reg_regno
operator|)
condition|?
literal|" $%#0x,(%s)[%s*%1d]"
else|:
literal|" $%#0x,(%s)"
operator|)
argument_list|,
name|op_1_regno
argument_list|,
name|reg_names
index|[
name|op_2_regno
index|]
argument_list|,
name|reg_names
index|[
name|index_reg_regno
index|]
argument_list|,
name|index_multiplier
argument_list|)
expr_stmt|;
break|break;
case|case
literal|7
case|:
name|read_memory
argument_list|(
name|memaddr
operator|+
literal|4
argument_list|,
name|buffer
argument_list|,
name|MAXLEN
argument_list|)
expr_stmt|;
name|insn_size
operator|+=
literal|4
expr_stmt|;
name|extra_1
operator|=
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|buffer
operator|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|stream
argument_list|,
operator|(
operator|(
name|index_reg_regno
operator|)
condition|?
literal|" $%#0x,(%s)[%s*%1d]"
else|:
literal|" $%#0x,(%s)"
operator|)
argument_list|,
name|extra_1
argument_list|,
name|reg_names
index|[
name|op_2_regno
index|]
argument_list|,
name|reg_names
index|[
name|index_reg_regno
index|]
argument_list|,
name|index_multiplier
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|fprintf_unfiltered
argument_list|(
name|stream
argument_list|,
operator|(
operator|(
name|index_reg_regno
operator|)
condition|?
literal|" (%s),(%s)[%s*%1d]"
else|:
literal|" (%s),(%s)"
operator|)
argument_list|,
name|reg_names
index|[
name|op_1_regno
index|]
argument_list|,
name|reg_names
index|[
name|op_2_regno
index|]
argument_list|,
name|reg_names
index|[
name|index_reg_regno
index|]
argument_list|,
name|index_multiplier
argument_list|)
expr_stmt|;
break|break;
case|case
literal|9
case|:
name|read_memory
argument_list|(
name|memaddr
operator|+
literal|4
argument_list|,
name|buffer
argument_list|,
name|MAXLEN
argument_list|)
expr_stmt|;
name|insn_size
operator|+=
literal|4
expr_stmt|;
name|extra_1
operator|=
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|buffer
operator|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|stream
argument_list|,
operator|(
operator|(
name|index_reg_regno
operator|)
condition|?
literal|"%#0x(%s),(%s)[%s*%1d]"
else|:
literal|"%#0x(%s),(%s)"
operator|)
argument_list|,
name|extra_1
argument_list|,
name|reg_names
index|[
name|op_1_regno
index|]
argument_list|,
name|reg_names
index|[
name|op_2_regno
index|]
argument_list|,
name|reg_names
index|[
name|index_reg_regno
index|]
argument_list|,
name|index_multiplier
argument_list|)
expr_stmt|;
break|break;
comment|/* S2 destination mode */
case|case
literal|10
case|:
name|read_memory
argument_list|(
name|memaddr
operator|+
literal|4
argument_list|,
name|buffer
argument_list|,
name|MAXLEN
argument_list|)
expr_stmt|;
name|insn_size
operator|+=
literal|4
expr_stmt|;
name|extra_1
operator|=
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|buffer
operator|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|stream
argument_list|,
operator|(
operator|(
name|index_reg_regno
operator|)
condition|?
literal|"%s,%#0x(%s)[%s*%1d]"
else|:
literal|"%s,%#0x(%s)"
operator|)
argument_list|,
name|reg_names
index|[
name|op_1_regno
index|]
argument_list|,
name|extra_1
argument_list|,
name|reg_names
index|[
name|op_2_regno
index|]
argument_list|,
name|reg_names
index|[
name|index_reg_regno
index|]
argument_list|,
name|index_multiplier
argument_list|)
expr_stmt|;
break|break;
case|case
literal|11
case|:
name|read_memory
argument_list|(
name|memaddr
operator|+
literal|4
argument_list|,
name|buffer
argument_list|,
name|MAXLEN
argument_list|)
expr_stmt|;
name|insn_size
operator|+=
literal|4
expr_stmt|;
name|extra_1
operator|=
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|buffer
operator|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|stream
argument_list|,
operator|(
operator|(
name|index_reg_regno
operator|)
condition|?
literal|" $%#0x,%#0x(%s)[%s*%1d]"
else|:
literal|" $%#0x,%#0x(%s)"
operator|)
argument_list|,
name|op_1_regno
argument_list|,
name|extra_1
argument_list|,
name|reg_names
index|[
name|op_2_regno
index|]
argument_list|,
name|reg_names
index|[
name|index_reg_regno
index|]
argument_list|,
name|index_multiplier
argument_list|)
expr_stmt|;
break|break;
case|case
literal|12
case|:
name|read_memory
argument_list|(
name|memaddr
operator|+
literal|4
argument_list|,
name|buffer
argument_list|,
name|MAXLEN
argument_list|)
expr_stmt|;
name|insn_size
operator|+=
literal|4
expr_stmt|;
name|extra_1
operator|=
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|buffer
operator|)
expr_stmt|;
name|read_memory
argument_list|(
name|memaddr
operator|+
literal|8
argument_list|,
name|buffer
argument_list|,
name|MAXLEN
argument_list|)
expr_stmt|;
name|insn_size
operator|+=
literal|4
expr_stmt|;
name|extra_2
operator|=
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|buffer
operator|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|stream
argument_list|,
operator|(
operator|(
name|index_reg_regno
operator|)
condition|?
literal|" $%#0x,%#0x(%s)[%s*%1d]"
else|:
literal|" $%#0x,%#0x(%s)"
operator|)
argument_list|,
name|extra_1
argument_list|,
name|extra_2
argument_list|,
name|reg_names
index|[
name|op_2_regno
index|]
argument_list|,
name|reg_names
index|[
name|index_reg_regno
index|]
argument_list|,
name|index_multiplier
argument_list|)
expr_stmt|;
break|break;
case|case
literal|13
case|:
name|read_memory
argument_list|(
name|memaddr
operator|+
literal|4
argument_list|,
name|buffer
argument_list|,
name|MAXLEN
argument_list|)
expr_stmt|;
name|insn_size
operator|+=
literal|4
expr_stmt|;
name|extra_1
operator|=
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|buffer
operator|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|stream
argument_list|,
operator|(
operator|(
name|index_reg_regno
operator|)
condition|?
literal|" (%s),%#0x(%s)[%s*%1d]"
else|:
literal|" (%s),%#0x(%s)"
operator|)
argument_list|,
name|reg_names
index|[
name|op_1_regno
index|]
argument_list|,
name|extra_1
argument_list|,
name|reg_names
index|[
name|op_2_regno
index|]
argument_list|,
name|reg_names
index|[
name|index_reg_regno
index|]
argument_list|,
name|index_multiplier
argument_list|)
expr_stmt|;
break|break;
case|case
literal|14
case|:
name|read_memory
argument_list|(
name|memaddr
operator|+
literal|4
argument_list|,
name|buffer
argument_list|,
name|MAXLEN
argument_list|)
expr_stmt|;
name|insn_size
operator|+=
literal|4
expr_stmt|;
name|extra_1
operator|=
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|buffer
operator|)
expr_stmt|;
name|read_memory
argument_list|(
name|memaddr
operator|+
literal|8
argument_list|,
name|buffer
argument_list|,
name|MAXLEN
argument_list|)
expr_stmt|;
name|insn_size
operator|+=
literal|4
expr_stmt|;
name|extra_2
operator|=
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|buffer
operator|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|stream
argument_list|,
operator|(
operator|(
name|index_reg_regno
operator|)
condition|?
literal|"%#0x(%s),%#0x(%s)[%s*%1d]"
else|:
literal|"%#0x(%s),%#0x(%s) "
operator|)
argument_list|,
name|extra_1
argument_list|,
name|reg_names
index|[
name|op_1_regno
index|]
argument_list|,
name|extra_2
argument_list|,
name|reg_names
index|[
name|op_2_regno
index|]
argument_list|,
name|reg_names
index|[
name|index_reg_regno
index|]
argument_list|,
name|index_multiplier
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf_unfiltered
argument_list|(
name|stream
argument_list|,
operator|(
operator|(
name|index_reg_regno
operator|)
condition|?
literal|"%s,%s [%s*%1d]"
else|:
literal|"%s,%s"
operator|)
argument_list|,
name|reg_names
index|[
name|op_1_regno
index|]
argument_list|,
name|reg_names
index|[
name|op_2_regno
index|]
argument_list|,
name|reg_names
index|[
name|index_reg_regno
index|]
argument_list|,
name|index_multiplier
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|stream
argument_list|,
literal|"\t\t# unknown mode in %08x"
argument_list|,
name|insn
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* switch */
block|}
block|{
return|return
name|insn_size
return|;
block|}
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

