begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Target-dependent code for the MIPS architecture, for GDB, the GNU Debugger.     Copyright 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996,    1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004 Free Software    Foundation, Inc.     Contributed by Alessandro Forin(af@cs.cmu.edu) at CMU    and by Per Bothner(bothner@cs.wisc.edu) at U.Wisconsin.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"gdb_assert.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"arch-utils.h"
end_include

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_include
include|#
directive|include
file|"osabi.h"
end_include

begin_include
include|#
directive|include
file|"mips-tdep.h"
end_include

begin_include
include|#
directive|include
file|"block.h"
end_include

begin_include
include|#
directive|include
file|"reggroups.h"
end_include

begin_include
include|#
directive|include
file|"opcode/mips.h"
end_include

begin_include
include|#
directive|include
file|"elf/mips.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_include
include|#
directive|include
file|"symcat.h"
end_include

begin_include
include|#
directive|include
file|"sim-regno.h"
end_include

begin_include
include|#
directive|include
file|"dis-asm.h"
end_include

begin_include
include|#
directive|include
file|"frame-unwind.h"
end_include

begin_include
include|#
directive|include
file|"frame-base.h"
end_include

begin_include
include|#
directive|include
file|"trad-frame.h"
end_include

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|objfile_data
modifier|*
name|mips_pdr_data
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|set_reg_offset
parameter_list|(
name|CORE_ADDR
modifier|*
name|saved_regs
parameter_list|,
name|int
name|regnum
parameter_list|,
name|CORE_ADDR
name|off
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|type
modifier|*
name|mips_register_type
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|int
name|regnum
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* A useful bit in the CP0 status register (PS_REGNUM).  */
end_comment

begin_comment
comment|/* This bit is set if we are emulating 32-bit FPRs on a 64-bit chip.  */
end_comment

begin_define
define|#
directive|define
name|ST0_FR
value|(1<< 26)
end_define

begin_comment
comment|/* The sizes of floating point registers.  */
end_comment

begin_enum
enum|enum
block|{
name|MIPS_FPU_SINGLE_REGSIZE
init|=
literal|4
block|,
name|MIPS_FPU_DOUBLE_REGSIZE
init|=
literal|8
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|mips_abi_string
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|mips_abi_strings
index|[]
init|=
block|{
literal|"auto"
block|,
literal|"n32"
block|,
literal|"o32"
block|,
literal|"n64"
block|,
literal|"o64"
block|,
literal|"eabi32"
block|,
literal|"eabi64"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|frame_extra_info
block|{
name|mips_extra_func_info_t
name|proc_desc
decl_stmt|;
name|int
name|num_args
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Various MIPS ISA options (related to stack analysis) can be    overridden dynamically.  Establish an enum/array for managing    them. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|size_auto
index|[]
init|=
literal|"auto"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|size_32
index|[]
init|=
literal|"32"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|size_64
index|[]
init|=
literal|"64"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|size_enums
index|[]
init|=
block|{
name|size_auto
block|,
name|size_32
block|,
name|size_64
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Some MIPS boards don't support floating point while others only    support single-precision floating-point operations.  See also    FP_REGISTER_DOUBLE. */
end_comment

begin_enum
enum|enum
name|mips_fpu_type
block|{
name|MIPS_FPU_DOUBLE
block|,
comment|/* Full double precision floating point.  */
name|MIPS_FPU_SINGLE
block|,
comment|/* Single precision floating point (R4650).  */
name|MIPS_FPU_NONE
comment|/* No floating point.  */
block|}
enum|;
end_enum

begin_ifndef
ifndef|#
directive|ifndef
name|MIPS_DEFAULT_FPU_TYPE
end_ifndef

begin_define
define|#
directive|define
name|MIPS_DEFAULT_FPU_TYPE
value|MIPS_FPU_DOUBLE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|mips_fpu_type_auto
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|enum
name|mips_fpu_type
name|mips_fpu_type
init|=
name|MIPS_DEFAULT_FPU_TYPE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mips_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* MIPS specific per-architecture information */
end_comment

begin_struct
struct|struct
name|gdbarch_tdep
block|{
comment|/* from the elf header */
name|int
name|elf_flags
decl_stmt|;
comment|/* mips options */
name|enum
name|mips_abi
name|mips_abi
decl_stmt|;
name|enum
name|mips_abi
name|found_abi
decl_stmt|;
name|enum
name|mips_fpu_type
name|mips_fpu_type
decl_stmt|;
name|int
name|mips_last_arg_regnum
decl_stmt|;
name|int
name|mips_last_fp_arg_regnum
decl_stmt|;
name|int
name|mips_default_saved_regsize
decl_stmt|;
name|int
name|mips_fp_register_double
decl_stmt|;
name|int
name|mips_default_stack_argsize
decl_stmt|;
name|int
name|default_mask_address_p
decl_stmt|;
comment|/* Is the target using 64-bit raw integer registers but only      storing a left-aligned 32-bit value in each?  */
name|int
name|mips64_transfers_32bit_regs_p
decl_stmt|;
comment|/* Indexes for various registers.  IRIX and embedded have      different values.  This contains the "public" fields.  Don't      add any that do not need to be public.  */
specifier|const
name|struct
name|mips_regnum
modifier|*
name|regnum
decl_stmt|;
comment|/* Register names table for the current register set.  */
specifier|const
name|char
modifier|*
modifier|*
name|mips_processor_reg_names
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|const
name|struct
name|mips_regnum
modifier|*
name|mips_regnum
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|)
block|{
return|return
name|gdbarch_tdep
argument_list|(
name|gdbarch
argument_list|)
operator|->
name|regnum
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mips_fpa0_regnum
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|)
block|{
return|return
name|mips_regnum
argument_list|(
name|gdbarch
argument_list|)
operator|->
name|fp0
operator|+
literal|12
return|;
block|}
end_function

begin_define
define|#
directive|define
name|MIPS_EABI
value|(gdbarch_tdep (current_gdbarch)->mips_abi == MIPS_ABI_EABI32 \ 		   || gdbarch_tdep (current_gdbarch)->mips_abi == MIPS_ABI_EABI64)
end_define

begin_define
define|#
directive|define
name|MIPS_LAST_FP_ARG_REGNUM
value|(gdbarch_tdep (current_gdbarch)->mips_last_fp_arg_regnum)
end_define

begin_define
define|#
directive|define
name|MIPS_LAST_ARG_REGNUM
value|(gdbarch_tdep (current_gdbarch)->mips_last_arg_regnum)
end_define

begin_define
define|#
directive|define
name|MIPS_FPU_TYPE
value|(gdbarch_tdep (current_gdbarch)->mips_fpu_type)
end_define

begin_comment
comment|/* MIPS16 function addresses are odd (bit 0 is set).  Here are some    functions to test, set, or clear bit 0 of addresses.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|is_mips16_addr
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|)
block|{
return|return
operator|(
operator|(
name|addr
operator|)
operator|&
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|CORE_ADDR
name|make_mips16_addr
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|)
block|{
return|return
operator|(
operator|(
name|addr
operator|)
operator||
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|CORE_ADDR
name|unmake_mips16_addr
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|)
block|{
return|return
operator|(
operator|(
name|addr
operator|)
operator|&
operator|~
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the contents of register REGNUM as a signed integer.  */
end_comment

begin_function
specifier|static
name|LONGEST
name|read_signed_register
parameter_list|(
name|int
name|regnum
parameter_list|)
block|{
name|void
modifier|*
name|buf
init|=
name|alloca
argument_list|(
name|register_size
argument_list|(
name|current_gdbarch
argument_list|,
name|regnum
argument_list|)
argument_list|)
decl_stmt|;
name|deprecated_read_register_gen
argument_list|(
name|regnum
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|extract_signed_integer
argument_list|(
name|buf
argument_list|,
name|register_size
argument_list|(
name|current_gdbarch
argument_list|,
name|regnum
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|LONGEST
name|read_signed_register_pid
parameter_list|(
name|int
name|regnum
parameter_list|,
name|ptid_t
name|ptid
parameter_list|)
block|{
name|ptid_t
name|save_ptid
decl_stmt|;
name|LONGEST
name|retval
decl_stmt|;
if|if
condition|(
name|ptid_equal
argument_list|(
name|ptid
argument_list|,
name|inferior_ptid
argument_list|)
condition|)
return|return
name|read_signed_register
argument_list|(
name|regnum
argument_list|)
return|;
name|save_ptid
operator|=
name|inferior_ptid
expr_stmt|;
name|inferior_ptid
operator|=
name|ptid
expr_stmt|;
name|retval
operator|=
name|read_signed_register
argument_list|(
name|regnum
argument_list|)
expr_stmt|;
name|inferior_ptid
operator|=
name|save_ptid
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Return the MIPS ABI associated with GDBARCH.  */
end_comment

begin_function
name|enum
name|mips_abi
name|mips_abi
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|)
block|{
return|return
name|gdbarch_tdep
argument_list|(
name|gdbarch
argument_list|)
operator|->
name|mips_abi
return|;
block|}
end_function

begin_function
name|int
name|mips_regsize
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|)
block|{
return|return
operator|(
name|gdbarch_bfd_arch_info
argument_list|(
name|gdbarch
argument_list|)
operator|->
name|bits_per_word
operator|/
name|gdbarch_bfd_arch_info
argument_list|(
name|gdbarch
argument_list|)
operator|->
name|bits_per_byte
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the currently configured (or set) saved register size. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|mips_saved_regsize_string
init|=
name|size_auto
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|unsigned
name|int
name|mips_saved_regsize
parameter_list|(
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
parameter_list|)
block|{
if|if
condition|(
name|mips_saved_regsize_string
operator|==
name|size_auto
condition|)
return|return
name|tdep
operator|->
name|mips_default_saved_regsize
return|;
elseif|else
if|if
condition|(
name|mips_saved_regsize_string
operator|==
name|size_64
condition|)
return|return
literal|8
return|;
else|else
comment|/* if (mips_saved_regsize_string == size_32) */
return|return
literal|4
return|;
block|}
end_function

begin_comment
comment|/* Functions for setting and testing a bit in a minimal symbol that    marks it as 16-bit function.  The MSB of the minimal symbol's    "info" field is used for this purpose.     ELF_MAKE_MSYMBOL_SPECIAL tests whether an ELF symbol is "special",    i.e. refers to a 16-bit function, and sets a "special" bit in a    minimal symbol to mark it as a 16-bit function     MSYMBOL_IS_SPECIAL   tests the "special" bit in a minimal symbol  */
end_comment

begin_function
specifier|static
name|void
name|mips_elf_make_msymbol_special
parameter_list|(
name|asymbol
modifier|*
name|sym
parameter_list|,
name|struct
name|minimal_symbol
modifier|*
name|msym
parameter_list|)
block|{
if|if
condition|(
operator|(
operator|(
name|elf_symbol_type
operator|*
operator|)
operator|(
name|sym
operator|)
operator|)
operator|->
name|internal_elf_sym
operator|.
name|st_other
operator|==
name|STO_MIPS16
condition|)
block|{
name|MSYMBOL_INFO
argument_list|(
name|msym
argument_list|)
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
operator|(
operator|(
name|long
operator|)
name|MSYMBOL_INFO
argument_list|(
name|msym
argument_list|)
operator|)
operator||
literal|0x80000000
operator|)
expr_stmt|;
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msym
argument_list|)
operator||=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|msymbol_is_special
parameter_list|(
name|struct
name|minimal_symbol
modifier|*
name|msym
parameter_list|)
block|{
return|return
operator|(
operator|(
operator|(
name|long
operator|)
name|MSYMBOL_INFO
argument_list|(
name|msym
argument_list|)
operator|&
literal|0x80000000
operator|)
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* XFER a value from the big/little/left end of the register.    Depending on the size of the value it might occupy the entire    register or just part of it.  Make an allowance for this, aligning    things accordingly.  */
end_comment

begin_function
specifier|static
name|void
name|mips_xfer_register
parameter_list|(
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|int
name|reg_num
parameter_list|,
name|int
name|length
parameter_list|,
name|enum
name|bfd_endian
name|endian
parameter_list|,
name|bfd_byte
modifier|*
name|in
parameter_list|,
specifier|const
name|bfd_byte
modifier|*
name|out
parameter_list|,
name|int
name|buf_offset
parameter_list|)
block|{
name|int
name|reg_offset
init|=
literal|0
decl_stmt|;
name|gdb_assert
argument_list|(
name|reg_num
operator|>=
name|NUM_REGS
argument_list|)
expr_stmt|;
comment|/* Need to transfer the left or right part of the register, based on      the targets byte order.  */
switch|switch
condition|(
name|endian
condition|)
block|{
case|case
name|BFD_ENDIAN_BIG
case|:
name|reg_offset
operator|=
name|register_size
argument_list|(
name|current_gdbarch
argument_list|,
name|reg_num
argument_list|)
operator|-
name|length
expr_stmt|;
break|break;
case|case
name|BFD_ENDIAN_LITTLE
case|:
name|reg_offset
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|BFD_ENDIAN_UNKNOWN
case|:
comment|/* Indicates no alignment.  */
name|reg_offset
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"bad switch"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mips_debug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"xfer $%d, reg offset %d, buf offset %d, length %d, "
argument_list|,
name|reg_num
argument_list|,
name|reg_offset
argument_list|,
name|buf_offset
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|mips_debug
operator|&&
name|out
operator|!=
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"out "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"%02x"
argument_list|,
name|out
index|[
name|buf_offset
operator|+
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|in
operator|!=
name|NULL
condition|)
name|regcache_cooked_read_part
argument_list|(
name|regcache
argument_list|,
name|reg_num
argument_list|,
name|reg_offset
argument_list|,
name|length
argument_list|,
name|in
operator|+
name|buf_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|out
operator|!=
name|NULL
condition|)
name|regcache_cooked_write_part
argument_list|(
name|regcache
argument_list|,
name|reg_num
argument_list|,
name|reg_offset
argument_list|,
name|length
argument_list|,
name|out
operator|+
name|buf_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|mips_debug
operator|&&
name|in
operator|!=
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"in "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"%02x"
argument_list|,
name|in
index|[
name|buf_offset
operator|+
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mips_debug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Determine if a MIPS3 or later cpu is operating in MIPS{1,2} FPU    compatiblity mode.  A return value of 1 means that we have    physical 64-bit registers, but should treat them as 32-bit registers.  */
end_comment

begin_function
specifier|static
name|int
name|mips2_fp_compat
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* MIPS1 and MIPS2 have only 32 bit FPRs, and the FR bit is not      meaningful.  */
if|if
condition|(
name|register_size
argument_list|(
name|current_gdbarch
argument_list|,
name|mips_regnum
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|fp0
argument_list|)
operator|==
literal|4
condition|)
return|return
literal|0
return|;
if|#
directive|if
literal|0
comment|/* FIXME drow 2002-03-10: This is disabled until we can do it consistently,      in all the places we deal with FP registers.  PR gdb/413.  */
comment|/* Otherwise check the FR bit in the status register - it controls      the FP compatiblity mode.  If it is clear we are in compatibility      mode.  */
block|if ((read_register (PS_REGNUM)& ST0_FR) == 0)     return 1;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Indicate that the ABI makes use of double-precision registers    provided by the FPU (rather than combining pairs of registers to    form double-precision values).  See also MIPS_FPU_TYPE.  */
end_comment

begin_define
define|#
directive|define
name|FP_REGISTER_DOUBLE
value|(gdbarch_tdep (current_gdbarch)->mips_fp_register_double)
end_define

begin_comment
comment|/* The amount of space reserved on the stack for registers. This is    different to MIPS_SAVED_REGSIZE as it determines the alignment of    data allocated after the registers have run out. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|mips_stack_argsize_string
init|=
name|size_auto
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|unsigned
name|int
name|mips_stack_argsize
parameter_list|(
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
parameter_list|)
block|{
if|if
condition|(
name|mips_stack_argsize_string
operator|==
name|size_auto
condition|)
return|return
name|tdep
operator|->
name|mips_default_stack_argsize
return|;
elseif|else
if|if
condition|(
name|mips_stack_argsize_string
operator|==
name|size_64
condition|)
return|return
literal|8
return|;
else|else
comment|/* if (mips_stack_argsize_string == size_32) */
return|return
literal|4
return|;
block|}
end_function

begin_define
define|#
directive|define
name|VM_MIN_ADDRESS
value|(CORE_ADDR)0x400000
end_define

begin_function_decl
specifier|static
name|mips_extra_func_info_t
name|heuristic_proc_desc
parameter_list|(
name|CORE_ADDR
parameter_list|,
name|CORE_ADDR
parameter_list|,
name|struct
name|frame_info
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|CORE_ADDR
name|heuristic_proc_start
parameter_list|(
name|CORE_ADDR
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|CORE_ADDR
name|read_next_frame_reg
parameter_list|(
name|struct
name|frame_info
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|reinit_frame_cache_sfunc
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|mips_extra_func_info_t
name|find_proc_desc
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|int
name|cur_frame
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|CORE_ADDR
name|after_prologue
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|mips_extra_func_info_t
name|proc_desc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|type
modifier|*
name|mips_float_register_type
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|type
modifier|*
name|mips_double_register_type
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* The list of available "set mips " and "show mips " commands */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|cmd_list_element
modifier|*
name|setmipscmdlist
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cmd_list_element
modifier|*
name|showmipscmdlist
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Integer registers 0 thru 31 are handled explicitly by    mips_register_name().  Processor specific registers 32 and above    are listed in the followign tables.  */
end_comment

begin_enum
enum|enum
block|{
name|NUM_MIPS_PROCESSOR_REGS
init|=
operator|(
literal|90
operator|-
literal|32
operator|)
block|}
enum|;
end_enum

begin_comment
comment|/* Generic MIPS.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|mips_generic_reg_names
index|[
name|NUM_MIPS_PROCESSOR_REGS
index|]
init|=
block|{
literal|"sr"
block|,
literal|"lo"
block|,
literal|"hi"
block|,
literal|"bad"
block|,
literal|"cause"
block|,
literal|"pc"
block|,
literal|"f0"
block|,
literal|"f1"
block|,
literal|"f2"
block|,
literal|"f3"
block|,
literal|"f4"
block|,
literal|"f5"
block|,
literal|"f6"
block|,
literal|"f7"
block|,
literal|"f8"
block|,
literal|"f9"
block|,
literal|"f10"
block|,
literal|"f11"
block|,
literal|"f12"
block|,
literal|"f13"
block|,
literal|"f14"
block|,
literal|"f15"
block|,
literal|"f16"
block|,
literal|"f17"
block|,
literal|"f18"
block|,
literal|"f19"
block|,
literal|"f20"
block|,
literal|"f21"
block|,
literal|"f22"
block|,
literal|"f23"
block|,
literal|"f24"
block|,
literal|"f25"
block|,
literal|"f26"
block|,
literal|"f27"
block|,
literal|"f28"
block|,
literal|"f29"
block|,
literal|"f30"
block|,
literal|"f31"
block|,
literal|"fsr"
block|,
literal|"fir"
block|,
literal|""
comment|/*"fp" */
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Names of IDT R3041 registers.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|mips_r3041_reg_names
index|[]
init|=
block|{
literal|"sr"
block|,
literal|"lo"
block|,
literal|"hi"
block|,
literal|"bad"
block|,
literal|"cause"
block|,
literal|"pc"
block|,
literal|"f0"
block|,
literal|"f1"
block|,
literal|"f2"
block|,
literal|"f3"
block|,
literal|"f4"
block|,
literal|"f5"
block|,
literal|"f6"
block|,
literal|"f7"
block|,
literal|"f8"
block|,
literal|"f9"
block|,
literal|"f10"
block|,
literal|"f11"
block|,
literal|"f12"
block|,
literal|"f13"
block|,
literal|"f14"
block|,
literal|"f15"
block|,
literal|"f16"
block|,
literal|"f17"
block|,
literal|"f18"
block|,
literal|"f19"
block|,
literal|"f20"
block|,
literal|"f21"
block|,
literal|"f22"
block|,
literal|"f23"
block|,
literal|"f24"
block|,
literal|"f25"
block|,
literal|"f26"
block|,
literal|"f27"
block|,
literal|"f28"
block|,
literal|"f29"
block|,
literal|"f30"
block|,
literal|"f31"
block|,
literal|"fsr"
block|,
literal|"fir"
block|,
literal|""
block|,
comment|/*"fp" */
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|"bus"
block|,
literal|"ccfg"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|"port"
block|,
literal|"cmp"
block|,
literal|""
block|,
literal|""
block|,
literal|"epc"
block|,
literal|"prid"
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Names of tx39 registers.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|mips_tx39_reg_names
index|[
name|NUM_MIPS_PROCESSOR_REGS
index|]
init|=
block|{
literal|"sr"
block|,
literal|"lo"
block|,
literal|"hi"
block|,
literal|"bad"
block|,
literal|"cause"
block|,
literal|"pc"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|"config"
block|,
literal|"cache"
block|,
literal|"debug"
block|,
literal|"depc"
block|,
literal|"epc"
block|,
literal|""
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Names of IRIX registers.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|mips_irix_reg_names
index|[
name|NUM_MIPS_PROCESSOR_REGS
index|]
init|=
block|{
literal|"f0"
block|,
literal|"f1"
block|,
literal|"f2"
block|,
literal|"f3"
block|,
literal|"f4"
block|,
literal|"f5"
block|,
literal|"f6"
block|,
literal|"f7"
block|,
literal|"f8"
block|,
literal|"f9"
block|,
literal|"f10"
block|,
literal|"f11"
block|,
literal|"f12"
block|,
literal|"f13"
block|,
literal|"f14"
block|,
literal|"f15"
block|,
literal|"f16"
block|,
literal|"f17"
block|,
literal|"f18"
block|,
literal|"f19"
block|,
literal|"f20"
block|,
literal|"f21"
block|,
literal|"f22"
block|,
literal|"f23"
block|,
literal|"f24"
block|,
literal|"f25"
block|,
literal|"f26"
block|,
literal|"f27"
block|,
literal|"f28"
block|,
literal|"f29"
block|,
literal|"f30"
block|,
literal|"f31"
block|,
literal|"pc"
block|,
literal|"cause"
block|,
literal|"bad"
block|,
literal|"hi"
block|,
literal|"lo"
block|,
literal|"fsr"
block|,
literal|"fir"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return the name of the register corresponding to REGNO.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|mips_register_name
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
decl_stmt|;
comment|/* GPR names for all ABIs other than n32/n64.  */
specifier|static
name|char
modifier|*
name|mips_gpr_names
index|[]
init|=
block|{
literal|"zero"
block|,
literal|"at"
block|,
literal|"v0"
block|,
literal|"v1"
block|,
literal|"a0"
block|,
literal|"a1"
block|,
literal|"a2"
block|,
literal|"a3"
block|,
literal|"t0"
block|,
literal|"t1"
block|,
literal|"t2"
block|,
literal|"t3"
block|,
literal|"t4"
block|,
literal|"t5"
block|,
literal|"t6"
block|,
literal|"t7"
block|,
literal|"s0"
block|,
literal|"s1"
block|,
literal|"s2"
block|,
literal|"s3"
block|,
literal|"s4"
block|,
literal|"s5"
block|,
literal|"s6"
block|,
literal|"s7"
block|,
literal|"t8"
block|,
literal|"t9"
block|,
literal|"k0"
block|,
literal|"k1"
block|,
literal|"gp"
block|,
literal|"sp"
block|,
literal|"s8"
block|,
literal|"ra"
block|,   }
decl_stmt|;
comment|/* GPR names for n32 and n64 ABIs.  */
specifier|static
name|char
modifier|*
name|mips_n32_n64_gpr_names
index|[]
init|=
block|{
literal|"zero"
block|,
literal|"at"
block|,
literal|"v0"
block|,
literal|"v1"
block|,
literal|"a0"
block|,
literal|"a1"
block|,
literal|"a2"
block|,
literal|"a3"
block|,
literal|"a4"
block|,
literal|"a5"
block|,
literal|"a6"
block|,
literal|"a7"
block|,
literal|"t0"
block|,
literal|"t1"
block|,
literal|"t2"
block|,
literal|"t3"
block|,
literal|"s0"
block|,
literal|"s1"
block|,
literal|"s2"
block|,
literal|"s3"
block|,
literal|"s4"
block|,
literal|"s5"
block|,
literal|"s6"
block|,
literal|"s7"
block|,
literal|"t8"
block|,
literal|"t9"
block|,
literal|"k0"
block|,
literal|"k1"
block|,
literal|"gp"
block|,
literal|"sp"
block|,
literal|"s8"
block|,
literal|"ra"
block|}
decl_stmt|;
name|enum
name|mips_abi
name|abi
init|=
name|mips_abi
argument_list|(
name|current_gdbarch
argument_list|)
decl_stmt|;
comment|/* Map [NUM_REGS .. 2*NUM_REGS) onto the raw registers, but then      don't make the raw register names visible.  */
name|int
name|rawnum
init|=
name|regno
operator|%
name|NUM_REGS
decl_stmt|;
if|if
condition|(
name|regno
operator|<
name|NUM_REGS
condition|)
return|return
literal|""
return|;
comment|/* The MIPS integer registers are always mapped from 0 to 31.  The      names of the registers (which reflects the conventions regarding      register use) vary depending on the ABI.  */
if|if
condition|(
literal|0
operator|<=
name|rawnum
operator|&&
name|rawnum
operator|<
literal|32
condition|)
block|{
if|if
condition|(
name|abi
operator|==
name|MIPS_ABI_N32
operator|||
name|abi
operator|==
name|MIPS_ABI_N64
condition|)
return|return
name|mips_n32_n64_gpr_names
index|[
name|rawnum
index|]
return|;
else|else
return|return
name|mips_gpr_names
index|[
name|rawnum
index|]
return|;
block|}
elseif|else
if|if
condition|(
literal|32
operator|<=
name|rawnum
operator|&&
name|rawnum
operator|<
name|NUM_REGS
condition|)
block|{
name|gdb_assert
argument_list|(
name|rawnum
operator|-
literal|32
operator|<
name|NUM_MIPS_PROCESSOR_REGS
argument_list|)
expr_stmt|;
return|return
name|tdep
operator|->
name|mips_processor_reg_names
index|[
name|rawnum
operator|-
literal|32
index|]
return|;
block|}
else|else
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"mips_register_name: bad register number %d"
argument_list|,
name|rawnum
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the groups that a MIPS register can be categorised into.  */
end_comment

begin_function
specifier|static
name|int
name|mips_register_reggroup_p
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|int
name|regnum
parameter_list|,
name|struct
name|reggroup
modifier|*
name|reggroup
parameter_list|)
block|{
name|int
name|vector_p
decl_stmt|;
name|int
name|float_p
decl_stmt|;
name|int
name|raw_p
decl_stmt|;
name|int
name|rawnum
init|=
name|regnum
operator|%
name|NUM_REGS
decl_stmt|;
name|int
name|pseudo
init|=
name|regnum
operator|/
name|NUM_REGS
decl_stmt|;
if|if
condition|(
name|reggroup
operator|==
name|all_reggroup
condition|)
return|return
name|pseudo
return|;
name|vector_p
operator|=
name|TYPE_VECTOR
argument_list|(
name|register_type
argument_list|(
name|gdbarch
argument_list|,
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
name|float_p
operator|=
name|TYPE_CODE
argument_list|(
name|register_type
argument_list|(
name|gdbarch
argument_list|,
name|regnum
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_FLT
expr_stmt|;
comment|/* FIXME: cagney/2003-04-13: Can't yet use gdbarch_num_regs      (gdbarch), as not all architectures are multi-arch.  */
name|raw_p
operator|=
name|rawnum
operator|<
name|NUM_REGS
expr_stmt|;
if|if
condition|(
name|REGISTER_NAME
argument_list|(
name|regnum
argument_list|)
operator|==
name|NULL
operator|||
name|REGISTER_NAME
argument_list|(
name|regnum
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|reggroup
operator|==
name|float_reggroup
condition|)
return|return
name|float_p
operator|&&
name|pseudo
return|;
if|if
condition|(
name|reggroup
operator|==
name|vector_reggroup
condition|)
return|return
name|vector_p
operator|&&
name|pseudo
return|;
if|if
condition|(
name|reggroup
operator|==
name|general_reggroup
condition|)
return|return
operator|(
operator|!
name|vector_p
operator|&&
operator|!
name|float_p
operator|)
operator|&&
name|pseudo
return|;
comment|/* Save the pseudo registers.  Need to make certain that any code      extracting register values from a saved register cache also uses      pseudo registers.  */
if|if
condition|(
name|reggroup
operator|==
name|save_reggroup
condition|)
return|return
name|raw_p
operator|&&
name|pseudo
return|;
comment|/* Restore the same pseudo register.  */
if|if
condition|(
name|reggroup
operator|==
name|restore_reggroup
condition|)
return|return
name|raw_p
operator|&&
name|pseudo
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Map the symbol table registers which live in the range [1 *    NUM_REGS .. 2 * NUM_REGS) back onto the corresponding raw    registers.  Take care of alignment and size problems.  */
end_comment

begin_function
specifier|static
name|void
name|mips_pseudo_register_read
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|int
name|cookednum
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|)
block|{
name|int
name|rawnum
init|=
name|cookednum
operator|%
name|NUM_REGS
decl_stmt|;
name|gdb_assert
argument_list|(
name|cookednum
operator|>=
name|NUM_REGS
operator|&&
name|cookednum
operator|<
literal|2
operator|*
name|NUM_REGS
argument_list|)
expr_stmt|;
if|if
condition|(
name|register_size
argument_list|(
name|gdbarch
argument_list|,
name|rawnum
argument_list|)
operator|==
name|register_size
argument_list|(
name|gdbarch
argument_list|,
name|cookednum
argument_list|)
condition|)
name|regcache_raw_read
argument_list|(
name|regcache
argument_list|,
name|rawnum
argument_list|,
name|buf
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|register_size
argument_list|(
name|gdbarch
argument_list|,
name|rawnum
argument_list|)
operator|>
name|register_size
argument_list|(
name|gdbarch
argument_list|,
name|cookednum
argument_list|)
condition|)
block|{
if|if
condition|(
name|gdbarch_tdep
argument_list|(
name|gdbarch
argument_list|)
operator|->
name|mips64_transfers_32bit_regs_p
operator|||
name|TARGET_BYTE_ORDER
operator|==
name|BFD_ENDIAN_LITTLE
condition|)
name|regcache_raw_read_part
argument_list|(
name|regcache
argument_list|,
name|rawnum
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|,
name|buf
argument_list|)
expr_stmt|;
else|else
name|regcache_raw_read_part
argument_list|(
name|regcache
argument_list|,
name|rawnum
argument_list|,
literal|4
argument_list|,
literal|4
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"bad register size"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mips_pseudo_register_write
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|int
name|cookednum
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|)
block|{
name|int
name|rawnum
init|=
name|cookednum
operator|%
name|NUM_REGS
decl_stmt|;
name|gdb_assert
argument_list|(
name|cookednum
operator|>=
name|NUM_REGS
operator|&&
name|cookednum
operator|<
literal|2
operator|*
name|NUM_REGS
argument_list|)
expr_stmt|;
if|if
condition|(
name|register_size
argument_list|(
name|gdbarch
argument_list|,
name|rawnum
argument_list|)
operator|==
name|register_size
argument_list|(
name|gdbarch
argument_list|,
name|cookednum
argument_list|)
condition|)
name|regcache_raw_write
argument_list|(
name|regcache
argument_list|,
name|rawnum
argument_list|,
name|buf
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|register_size
argument_list|(
name|gdbarch
argument_list|,
name|rawnum
argument_list|)
operator|>
name|register_size
argument_list|(
name|gdbarch
argument_list|,
name|cookednum
argument_list|)
condition|)
block|{
if|if
condition|(
name|gdbarch_tdep
argument_list|(
name|gdbarch
argument_list|)
operator|->
name|mips64_transfers_32bit_regs_p
operator|||
name|TARGET_BYTE_ORDER
operator|==
name|BFD_ENDIAN_LITTLE
condition|)
name|regcache_raw_write_part
argument_list|(
name|regcache
argument_list|,
name|rawnum
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|,
name|buf
argument_list|)
expr_stmt|;
else|else
name|regcache_raw_write_part
argument_list|(
name|regcache
argument_list|,
name|rawnum
argument_list|,
literal|4
argument_list|,
literal|4
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"bad register size"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Table to translate MIPS16 register field to actual register number.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mips16_to_32_reg
index|[
literal|8
index|]
init|=
block|{
literal|16
block|,
literal|17
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Heuristic_proc_start may hunt through the text section for a long    time across a 2400 baud serial line.  Allows the user to limit this    search.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|heuristic_fence_post
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|PROC_LOW_ADDR
parameter_list|(
name|proc
parameter_list|)
value|((proc)->pdr.adr)
end_define

begin_comment
comment|/* least address */
end_comment

begin_define
define|#
directive|define
name|PROC_HIGH_ADDR
parameter_list|(
name|proc
parameter_list|)
value|((proc)->high_addr)
end_define

begin_comment
comment|/* upper address bound */
end_comment

begin_define
define|#
directive|define
name|PROC_FRAME_OFFSET
parameter_list|(
name|proc
parameter_list|)
value|((proc)->pdr.frameoffset)
end_define

begin_define
define|#
directive|define
name|PROC_FRAME_REG
parameter_list|(
name|proc
parameter_list|)
value|((proc)->pdr.framereg)
end_define

begin_define
define|#
directive|define
name|PROC_FRAME_ADJUST
parameter_list|(
name|proc
parameter_list|)
value|((proc)->frame_adjust)
end_define

begin_define
define|#
directive|define
name|PROC_REG_MASK
parameter_list|(
name|proc
parameter_list|)
value|((proc)->pdr.regmask)
end_define

begin_define
define|#
directive|define
name|PROC_FREG_MASK
parameter_list|(
name|proc
parameter_list|)
value|((proc)->pdr.fregmask)
end_define

begin_define
define|#
directive|define
name|PROC_REG_OFFSET
parameter_list|(
name|proc
parameter_list|)
value|((proc)->pdr.regoffset)
end_define

begin_define
define|#
directive|define
name|PROC_FREG_OFFSET
parameter_list|(
name|proc
parameter_list|)
value|((proc)->pdr.fregoffset)
end_define

begin_define
define|#
directive|define
name|PROC_PC_REG
parameter_list|(
name|proc
parameter_list|)
value|((proc)->pdr.pcreg)
end_define

begin_comment
comment|/* FIXME drow/2002-06-10: If a pointer on the host is bigger than a long,    this will corrupt pdr.iline.  Fortunately we don't use it.  */
end_comment

begin_define
define|#
directive|define
name|PROC_SYMBOL
parameter_list|(
name|proc
parameter_list|)
value|(*(struct symbol**)&(proc)->pdr.isym)
end_define

begin_define
define|#
directive|define
name|_PROC_MAGIC_
value|0x0F0F0F0F
end_define

begin_define
define|#
directive|define
name|PROC_DESC_IS_DUMMY
parameter_list|(
name|proc
parameter_list|)
value|((proc)->pdr.isym == _PROC_MAGIC_)
end_define

begin_define
define|#
directive|define
name|SET_PROC_DESC_IS_DUMMY
parameter_list|(
name|proc
parameter_list|)
value|((proc)->pdr.isym = _PROC_MAGIC_)
end_define

begin_struct
struct|struct
name|linked_proc_info
block|{
name|struct
name|mips_extra_func_info
name|info
decl_stmt|;
name|struct
name|linked_proc_info
modifier|*
name|next
decl_stmt|;
block|}
modifier|*
name|linked_proc_desc_table
init|=
name|NULL
struct|;
end_struct

begin_comment
comment|/* Number of bytes of storage in the actual machine representation for    register N.  NOTE: This defines the pseudo register type so need to    rebuild the architecture vector.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mips64_transfers_32bit_regs_p
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|set_mips64_transfers_32bit_regs
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
name|c
parameter_list|)
block|{
name|struct
name|gdbarch_info
name|info
decl_stmt|;
name|gdbarch_info_init
argument_list|(
operator|&
name|info
argument_list|)
expr_stmt|;
comment|/* FIXME: cagney/2003-11-15: Should be setting a field in "info"      instead of relying on globals.  Doing that would let generic code      handle the search for this specific architecture.  */
if|if
condition|(
operator|!
name|gdbarch_update_p
argument_list|(
name|info
argument_list|)
condition|)
block|{
name|mips64_transfers_32bit_regs_p
operator|=
literal|0
expr_stmt|;
name|error
argument_list|(
literal|"32-bit compatibility mode not supported"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Convert to/from a register and the corresponding memory value.  */
end_comment

begin_function
specifier|static
name|int
name|mips_convert_register_p
parameter_list|(
name|int
name|regnum
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
return|return
operator|(
name|TARGET_BYTE_ORDER
operator|==
name|BFD_ENDIAN_BIG
operator|&&
name|register_size
argument_list|(
name|current_gdbarch
argument_list|,
name|regnum
argument_list|)
operator|==
literal|4
operator|&&
operator|(
name|regnum
operator|%
name|NUM_REGS
operator|)
operator|>=
name|mips_regnum
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|fp0
operator|&&
operator|(
name|regnum
operator|%
name|NUM_REGS
operator|)
operator|<
name|mips_regnum
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|fp0
operator|+
literal|32
operator|&&
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_FLT
operator|&&
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|==
literal|8
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mips_register_to_value
parameter_list|(
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|,
name|int
name|regnum
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|void
modifier|*
name|to
parameter_list|)
block|{
name|get_frame_register
argument_list|(
name|frame
argument_list|,
name|regnum
operator|+
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|to
operator|+
literal|4
argument_list|)
expr_stmt|;
name|get_frame_register
argument_list|(
name|frame
argument_list|,
name|regnum
operator|+
literal|1
argument_list|,
operator|(
name|char
operator|*
operator|)
name|to
operator|+
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mips_value_to_register
parameter_list|(
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|,
name|int
name|regnum
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|,
specifier|const
name|void
modifier|*
name|from
parameter_list|)
block|{
name|put_frame_register
argument_list|(
name|frame
argument_list|,
name|regnum
operator|+
literal|0
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|from
operator|+
literal|4
argument_list|)
expr_stmt|;
name|put_frame_register
argument_list|(
name|frame
argument_list|,
name|regnum
operator|+
literal|1
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|from
operator|+
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the GDB type object for the "standard" data type of data in    register REG.  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|mips_register_type
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|int
name|regnum
parameter_list|)
block|{
name|gdb_assert
argument_list|(
name|regnum
operator|>=
literal|0
operator|&&
name|regnum
operator|<
literal|2
operator|*
name|NUM_REGS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|regnum
operator|%
name|NUM_REGS
operator|)
operator|>=
name|mips_regnum
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|fp0
operator|&&
operator|(
name|regnum
operator|%
name|NUM_REGS
operator|)
operator|<
name|mips_regnum
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|fp0
operator|+
literal|32
condition|)
block|{
comment|/* The floating-point registers raw, or cooked, always match          mips_regsize(), and also map 1:1, byte for byte.  */
switch|switch
condition|(
name|gdbarch_byte_order
argument_list|(
name|gdbarch
argument_list|)
condition|)
block|{
case|case
name|BFD_ENDIAN_BIG
case|:
if|if
condition|(
name|mips_regsize
argument_list|(
name|gdbarch
argument_list|)
operator|==
literal|4
condition|)
return|return
name|builtin_type_ieee_single_big
return|;
else|else
return|return
name|builtin_type_ieee_double_big
return|;
case|case
name|BFD_ENDIAN_LITTLE
case|:
if|if
condition|(
name|mips_regsize
argument_list|(
name|gdbarch
argument_list|)
operator|==
literal|4
condition|)
return|return
name|builtin_type_ieee_single_little
return|;
else|else
return|return
name|builtin_type_ieee_double_little
return|;
case|case
name|BFD_ENDIAN_UNKNOWN
case|:
default|default:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"bad switch"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|regnum
operator|>=
operator|(
name|NUM_REGS
operator|+
name|mips_regnum
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|fp_control_status
operator|)
operator|&&
name|regnum
operator|<=
name|NUM_REGS
operator|+
name|LAST_EMBED_REGNUM
condition|)
comment|/* The pseudo/cooked view of the embedded registers is always        32-bit.  The raw view is handled below.  */
return|return
name|builtin_type_int32
return|;
elseif|else
if|if
condition|(
name|regnum
operator|>=
name|NUM_REGS
operator|&&
name|mips_regsize
argument_list|(
name|gdbarch
argument_list|)
operator|&&
name|gdbarch_tdep
argument_list|(
name|gdbarch
argument_list|)
operator|->
name|mips64_transfers_32bit_regs_p
condition|)
comment|/* The target, while using a 64-bit register buffer, is only        transfering 32-bits of each integer register.  Reflect this in        the cooked/pseudo register value.  */
return|return
name|builtin_type_int32
return|;
elseif|else
if|if
condition|(
name|mips_regsize
argument_list|(
name|gdbarch
argument_list|)
operator|==
literal|8
condition|)
comment|/* 64-bit ISA.  */
return|return
name|builtin_type_int64
return|;
else|else
comment|/* 32-bit ISA.  */
return|return
name|builtin_type_int32
return|;
block|}
end_function

begin_comment
comment|/* TARGET_READ_SP -- Remove useless bits from the stack pointer.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|mips_read_sp
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|read_signed_register
argument_list|(
name|SP_REGNUM
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Should the upper word of 64-bit addresses be zeroed? */
end_comment

begin_decl_stmt
name|enum
name|auto_boolean
name|mask_address_var
init|=
name|AUTO_BOOLEAN_AUTO
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|mips_mask_address_p
parameter_list|(
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
parameter_list|)
block|{
switch|switch
condition|(
name|mask_address_var
condition|)
block|{
case|case
name|AUTO_BOOLEAN_TRUE
case|:
return|return
literal|1
return|;
case|case
name|AUTO_BOOLEAN_FALSE
case|:
return|return
literal|0
return|;
break|break;
case|case
name|AUTO_BOOLEAN_AUTO
case|:
return|return
name|tdep
operator|->
name|default_mask_address_p
return|;
default|default:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"mips_mask_address_p: bad switch"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|show_mask_address
parameter_list|(
name|char
modifier|*
name|cmd
parameter_list|,
name|int
name|from_tty
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
name|c
parameter_list|)
block|{
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|mask_address_var
condition|)
block|{
case|case
name|AUTO_BOOLEAN_TRUE
case|:
name|printf_filtered
argument_list|(
literal|"The 32 bit mips address mask is enabled\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|AUTO_BOOLEAN_FALSE
case|:
name|printf_filtered
argument_list|(
literal|"The 32 bit mips address mask is disabled\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|AUTO_BOOLEAN_AUTO
case|:
name|printf_filtered
argument_list|(
literal|"The 32 bit address mask is set automatically.  Currently %s\n"
argument_list|,
name|mips_mask_address_p
argument_list|(
name|tdep
argument_list|)
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"show_mask_address: bad switch"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Tell if the program counter value in MEMADDR is in a MIPS16 function.  */
end_comment

begin_function
specifier|static
name|int
name|pc_is_mips16
parameter_list|(
name|bfd_vma
name|memaddr
parameter_list|)
block|{
name|struct
name|minimal_symbol
modifier|*
name|sym
decl_stmt|;
comment|/* If bit 0 of the address is set, assume this is a MIPS16 address. */
if|if
condition|(
name|is_mips16_addr
argument_list|(
name|memaddr
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* A flag indicating that this is a MIPS16 function is stored by elfread.c in      the high bit of the info field.  Use this to decide if the function is      MIPS16 or normal MIPS.  */
name|sym
operator|=
name|lookup_minimal_symbol_by_pc
argument_list|(
name|memaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
condition|)
return|return
name|msymbol_is_special
argument_list|(
name|sym
argument_list|)
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* MIPS believes that the PC has a sign extended value.  Perhaphs the    all registers should be sign extended for simplicity? */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|mips_read_pc
parameter_list|(
name|ptid_t
name|ptid
parameter_list|)
block|{
return|return
name|read_signed_register_pid
argument_list|(
name|mips_regnum
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|pc
argument_list|,
name|ptid
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|CORE_ADDR
name|mips_unwind_pc
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|)
block|{
return|return
name|frame_unwind_register_signed
argument_list|(
name|next_frame
argument_list|,
name|NUM_REGS
operator|+
name|mips_regnum
argument_list|(
name|gdbarch
argument_list|)
operator|->
name|pc
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Assuming NEXT_FRAME->prev is a dummy, return the frame ID of that    dummy frame.  The frame ID's base needs to match the TOS value    saved by save_dummy_frame_tos(), and the PC match the dummy frame's    breakpoint.  */
end_comment

begin_function
specifier|static
name|struct
name|frame_id
name|mips_unwind_dummy_id
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|)
block|{
return|return
name|frame_id_build
argument_list|(
name|frame_unwind_register_signed
argument_list|(
name|next_frame
argument_list|,
name|NUM_REGS
operator|+
name|SP_REGNUM
argument_list|)
argument_list|,
name|frame_pc_unwind
argument_list|(
name|next_frame
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mips_write_pc
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|ptid_t
name|ptid
parameter_list|)
block|{
name|write_register_pid
argument_list|(
name|mips_regnum
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|pc
argument_list|,
name|pc
argument_list|,
name|ptid
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This returns the PC of the first inst after the prologue.  If we can't    find the prologue, then return 0.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|after_prologue
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|mips_extra_func_info_t
name|proc_desc
parameter_list|)
block|{
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|CORE_ADDR
name|func_addr
decl_stmt|,
name|func_end
decl_stmt|;
comment|/* Pass cur_frame == 0 to find_proc_desc.  We should not attempt      to read the stack pointer from the current machine state, because      the current machine state has nothing to do with the information      we need from the proc_desc; and the process may or may not exist      right now.  */
if|if
condition|(
operator|!
name|proc_desc
condition|)
name|proc_desc
operator|=
name|find_proc_desc
argument_list|(
name|pc
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|proc_desc
condition|)
block|{
comment|/* If function is frameless, then we need to do it the hard way.  I          strongly suspect that frameless always means prologueless... */
if|if
condition|(
name|PROC_FRAME_REG
argument_list|(
name|proc_desc
argument_list|)
operator|==
name|SP_REGNUM
operator|&&
name|PROC_FRAME_OFFSET
argument_list|(
name|proc_desc
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|find_pc_partial_function
argument_list|(
name|pc
argument_list|,
name|NULL
argument_list|,
operator|&
name|func_addr
argument_list|,
operator|&
name|func_end
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Unknown */
name|sal
operator|=
name|find_pc_line
argument_list|(
name|func_addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sal
operator|.
name|end
operator|<
name|func_end
condition|)
return|return
name|sal
operator|.
name|end
return|;
comment|/* The line after the prologue is after the end of the function.  In this      case, tell the caller to find the prologue the hard way.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Decode a MIPS32 instruction that saves a register in the stack, and    set the appropriate bit in the general register mask or float register mask    to indicate which register is saved.  This is a helper function    for mips_find_saved_regs.  */
end_comment

begin_function
specifier|static
name|void
name|mips32_decode_reg_save
parameter_list|(
name|t_inst
name|inst
parameter_list|,
name|unsigned
name|long
modifier|*
name|gen_mask
parameter_list|,
name|unsigned
name|long
modifier|*
name|float_mask
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
if|if
condition|(
operator|(
name|inst
operator|&
literal|0xffe00000
operator|)
operator|==
literal|0xafa00000
comment|/* sw reg,n($sp) */
operator|||
operator|(
name|inst
operator|&
literal|0xffe00000
operator|)
operator|==
literal|0xafc00000
comment|/* sw reg,n($r30) */
operator|||
operator|(
name|inst
operator|&
literal|0xffe00000
operator|)
operator|==
literal|0xffa00000
condition|)
comment|/* sd reg,n($sp) */
block|{
comment|/* It might be possible to use the instruction to          find the offset, rather than the code below which          is based on things being in a certain order in the          frame, but figuring out what the instruction's offset          is relative to might be a little tricky.  */
name|reg
operator|=
operator|(
name|inst
operator|&
literal|0x001f0000
operator|)
operator|>>
literal|16
expr_stmt|;
operator|*
name|gen_mask
operator||=
operator|(
literal|1
operator|<<
name|reg
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|inst
operator|&
literal|0xffe00000
operator|)
operator|==
literal|0xe7a00000
comment|/* swc1 freg,n($sp) */
operator|||
operator|(
name|inst
operator|&
literal|0xffe00000
operator|)
operator|==
literal|0xe7c00000
comment|/* swc1 freg,n($r30) */
operator|||
operator|(
name|inst
operator|&
literal|0xffe00000
operator|)
operator|==
literal|0xf7a00000
condition|)
comment|/* sdc1 freg,n($sp) */
block|{
name|reg
operator|=
operator|(
operator|(
name|inst
operator|&
literal|0x001f0000
operator|)
operator|>>
literal|16
operator|)
expr_stmt|;
operator|*
name|float_mask
operator||=
operator|(
literal|1
operator|<<
name|reg
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Decode a MIPS16 instruction that saves a register in the stack, and    set the appropriate bit in the general register or float register mask    to indicate which register is saved.  This is a helper function    for mips_find_saved_regs.  */
end_comment

begin_function
specifier|static
name|void
name|mips16_decode_reg_save
parameter_list|(
name|t_inst
name|inst
parameter_list|,
name|unsigned
name|long
modifier|*
name|gen_mask
parameter_list|)
block|{
if|if
condition|(
operator|(
name|inst
operator|&
literal|0xf800
operator|)
operator|==
literal|0xd000
condition|)
comment|/* sw reg,n($sp) */
block|{
name|int
name|reg
init|=
name|mips16_to_32_reg
index|[
operator|(
name|inst
operator|&
literal|0x700
operator|)
operator|>>
literal|8
index|]
decl_stmt|;
operator|*
name|gen_mask
operator||=
operator|(
literal|1
operator|<<
name|reg
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|inst
operator|&
literal|0xff00
operator|)
operator|==
literal|0xf900
condition|)
comment|/* sd reg,n($sp) */
block|{
name|int
name|reg
init|=
name|mips16_to_32_reg
index|[
operator|(
name|inst
operator|&
literal|0xe0
operator|)
operator|>>
literal|5
index|]
decl_stmt|;
operator|*
name|gen_mask
operator||=
operator|(
literal|1
operator|<<
name|reg
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|inst
operator|&
literal|0xff00
operator|)
operator|==
literal|0x6200
comment|/* sw $ra,n($sp) */
operator|||
operator|(
name|inst
operator|&
literal|0xff00
operator|)
operator|==
literal|0xfa00
condition|)
comment|/* sd $ra,n($sp) */
operator|*
name|gen_mask
operator||=
operator|(
literal|1
operator|<<
name|RA_REGNUM
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fetch and return instruction from the specified location.  If the PC    is odd, assume it's a MIPS16 instruction; otherwise MIPS32.  */
end_comment

begin_function
specifier|static
name|t_inst
name|mips_fetch_instruction
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|)
block|{
name|char
name|buf
index|[
name|MIPS_INSTLEN
index|]
decl_stmt|;
name|int
name|instlen
decl_stmt|;
name|int
name|status
decl_stmt|;
if|if
condition|(
name|pc_is_mips16
argument_list|(
name|addr
argument_list|)
condition|)
block|{
name|instlen
operator|=
name|MIPS16_INSTLEN
expr_stmt|;
name|addr
operator|=
name|unmake_mips16_addr
argument_list|(
name|addr
argument_list|)
expr_stmt|;
block|}
else|else
name|instlen
operator|=
name|MIPS_INSTLEN
expr_stmt|;
name|status
operator|=
name|read_memory_nobpt
argument_list|(
name|addr
argument_list|,
name|buf
argument_list|,
name|instlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
name|memory_error
argument_list|(
name|status
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
name|instlen
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|ULONGEST
name|mips16_fetch_instruction
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|)
block|{
name|char
name|buf
index|[
name|MIPS_INSTLEN
index|]
decl_stmt|;
name|int
name|instlen
decl_stmt|;
name|int
name|status
decl_stmt|;
name|instlen
operator|=
name|MIPS16_INSTLEN
expr_stmt|;
name|addr
operator|=
name|unmake_mips16_addr
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|status
operator|=
name|read_memory_nobpt
argument_list|(
name|addr
argument_list|,
name|buf
argument_list|,
name|instlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
name|memory_error
argument_list|(
name|status
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
name|instlen
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|ULONGEST
name|mips32_fetch_instruction
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|)
block|{
name|char
name|buf
index|[
name|MIPS_INSTLEN
index|]
decl_stmt|;
name|int
name|instlen
decl_stmt|;
name|int
name|status
decl_stmt|;
name|instlen
operator|=
name|MIPS_INSTLEN
expr_stmt|;
name|status
operator|=
name|read_memory_nobpt
argument_list|(
name|addr
argument_list|,
name|buf
argument_list|,
name|instlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
name|memory_error
argument_list|(
name|status
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
name|instlen
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* These the fields of 32 bit mips instructions */
end_comment

begin_define
define|#
directive|define
name|mips32_op
parameter_list|(
name|x
parameter_list|)
value|(x>> 26)
end_define

begin_define
define|#
directive|define
name|itype_op
parameter_list|(
name|x
parameter_list|)
value|(x>> 26)
end_define

begin_define
define|#
directive|define
name|itype_rs
parameter_list|(
name|x
parameter_list|)
value|((x>> 21)& 0x1f)
end_define

begin_define
define|#
directive|define
name|itype_rt
parameter_list|(
name|x
parameter_list|)
value|((x>> 16)& 0x1f)
end_define

begin_define
define|#
directive|define
name|itype_immediate
parameter_list|(
name|x
parameter_list|)
value|(x& 0xffff)
end_define

begin_define
define|#
directive|define
name|jtype_op
parameter_list|(
name|x
parameter_list|)
value|(x>> 26)
end_define

begin_define
define|#
directive|define
name|jtype_target
parameter_list|(
name|x
parameter_list|)
value|(x& 0x03ffffff)
end_define

begin_define
define|#
directive|define
name|rtype_op
parameter_list|(
name|x
parameter_list|)
value|(x>> 26)
end_define

begin_define
define|#
directive|define
name|rtype_rs
parameter_list|(
name|x
parameter_list|)
value|((x>> 21)& 0x1f)
end_define

begin_define
define|#
directive|define
name|rtype_rt
parameter_list|(
name|x
parameter_list|)
value|((x>> 16)& 0x1f)
end_define

begin_define
define|#
directive|define
name|rtype_rd
parameter_list|(
name|x
parameter_list|)
value|((x>> 11)& 0x1f)
end_define

begin_define
define|#
directive|define
name|rtype_shamt
parameter_list|(
name|x
parameter_list|)
value|((x>> 6)& 0x1f)
end_define

begin_define
define|#
directive|define
name|rtype_funct
parameter_list|(
name|x
parameter_list|)
value|(x& 0x3f)
end_define

begin_function
specifier|static
name|CORE_ADDR
name|mips32_relative_offset
parameter_list|(
name|unsigned
name|long
name|inst
parameter_list|)
block|{
name|long
name|x
decl_stmt|;
name|x
operator|=
name|itype_immediate
argument_list|(
name|inst
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|&
literal|0x8000
condition|)
comment|/* sign bit set */
block|{
name|x
operator||=
literal|0xffff0000
expr_stmt|;
comment|/* sign extension */
block|}
name|x
operator|=
name|x
operator|<<
literal|2
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* Determine whate to set a single step breakpoint while considering    branch prediction */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|mips32_next_pc
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
name|unsigned
name|long
name|inst
decl_stmt|;
name|int
name|op
decl_stmt|;
name|inst
operator|=
name|mips_fetch_instruction
argument_list|(
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|inst
operator|&
literal|0xe0000000
operator|)
operator|!=
literal|0
condition|)
comment|/* Not a special, jump or branch instruction */
block|{
if|if
condition|(
name|itype_op
argument_list|(
name|inst
argument_list|)
operator|>>
literal|2
operator|==
literal|5
condition|)
comment|/* BEQL, BNEL, BLEZL, BGTZL: bits 0101xx */
block|{
name|op
operator|=
operator|(
name|itype_op
argument_list|(
name|inst
argument_list|)
operator|&
literal|0x03
operator|)
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
literal|0
case|:
comment|/* BEQL */
goto|goto
name|equal_branch
goto|;
case|case
literal|1
case|:
comment|/* BNEL */
goto|goto
name|neq_branch
goto|;
case|case
literal|2
case|:
comment|/* BLEZL */
goto|goto
name|less_branch
goto|;
case|case
literal|3
case|:
comment|/* BGTZ */
goto|goto
name|greater_branch
goto|;
default|default:
name|pc
operator|+=
literal|4
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|itype_op
argument_list|(
name|inst
argument_list|)
operator|==
literal|17
operator|&&
name|itype_rs
argument_list|(
name|inst
argument_list|)
operator|==
literal|8
condition|)
comment|/* BC1F, BC1FL, BC1T, BC1TL: 010001 01000 */
block|{
name|int
name|tf
init|=
name|itype_rt
argument_list|(
name|inst
argument_list|)
operator|&
literal|0x01
decl_stmt|;
name|int
name|cnum
init|=
name|itype_rt
argument_list|(
name|inst
argument_list|)
operator|>>
literal|2
decl_stmt|;
name|int
name|fcrcs
init|=
name|read_signed_register
argument_list|(
name|mips_regnum
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|fp_control_status
argument_list|)
decl_stmt|;
name|int
name|cond
init|=
operator|(
operator|(
name|fcrcs
operator|>>
literal|24
operator|)
operator|&
literal|0x0e
operator|)
operator||
operator|(
operator|(
name|fcrcs
operator|>>
literal|23
operator|)
operator|&
literal|0x01
operator|)
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|cond
operator|>>
name|cnum
operator|)
operator|&
literal|0x01
operator|)
operator|==
name|tf
condition|)
name|pc
operator|+=
name|mips32_relative_offset
argument_list|(
name|inst
argument_list|)
operator|+
literal|4
expr_stmt|;
else|else
name|pc
operator|+=
literal|8
expr_stmt|;
block|}
else|else
name|pc
operator|+=
literal|4
expr_stmt|;
comment|/* Not a branch, next instruction is easy */
block|}
else|else
block|{
comment|/* This gets way messy */
comment|/* Further subdivide into SPECIAL, REGIMM and other */
switch|switch
condition|(
name|op
operator|=
name|itype_op
argument_list|(
name|inst
argument_list|)
operator|&
literal|0x07
condition|)
comment|/* extract bits 28,27,26 */
block|{
case|case
literal|0
case|:
comment|/* SPECIAL */
name|op
operator|=
name|rtype_funct
argument_list|(
name|inst
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
literal|8
case|:
comment|/* JR */
case|case
literal|9
case|:
comment|/* JALR */
comment|/* Set PC to that address */
name|pc
operator|=
name|read_signed_register
argument_list|(
name|rtype_rs
argument_list|(
name|inst
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|pc
operator|+=
literal|4
expr_stmt|;
block|}
break|break;
comment|/* end SPECIAL */
case|case
literal|1
case|:
comment|/* REGIMM */
block|{
name|op
operator|=
name|itype_rt
argument_list|(
name|inst
argument_list|)
expr_stmt|;
comment|/* branch condition */
switch|switch
condition|(
name|op
condition|)
block|{
case|case
literal|0
case|:
comment|/* BLTZ */
case|case
literal|2
case|:
comment|/* BLTZL */
case|case
literal|16
case|:
comment|/* BLTZAL */
case|case
literal|18
case|:
comment|/* BLTZALL */
name|less_branch
label|:
if|if
condition|(
name|read_signed_register
argument_list|(
name|itype_rs
argument_list|(
name|inst
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|pc
operator|+=
name|mips32_relative_offset
argument_list|(
name|inst
argument_list|)
operator|+
literal|4
expr_stmt|;
else|else
name|pc
operator|+=
literal|8
expr_stmt|;
comment|/* after the delay slot */
break|break;
case|case
literal|1
case|:
comment|/* BGEZ */
case|case
literal|3
case|:
comment|/* BGEZL */
case|case
literal|17
case|:
comment|/* BGEZAL */
case|case
literal|19
case|:
comment|/* BGEZALL */
if|if
condition|(
name|read_signed_register
argument_list|(
name|itype_rs
argument_list|(
name|inst
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
name|pc
operator|+=
name|mips32_relative_offset
argument_list|(
name|inst
argument_list|)
operator|+
literal|4
expr_stmt|;
else|else
name|pc
operator|+=
literal|8
expr_stmt|;
comment|/* after the delay slot */
break|break;
comment|/* All of the other instructions in the REGIMM category */
default|default:
name|pc
operator|+=
literal|4
expr_stmt|;
block|}
block|}
break|break;
comment|/* end REGIMM */
case|case
literal|2
case|:
comment|/* J */
case|case
literal|3
case|:
comment|/* JAL */
block|{
name|unsigned
name|long
name|reg
decl_stmt|;
name|reg
operator|=
name|jtype_target
argument_list|(
name|inst
argument_list|)
operator|<<
literal|2
expr_stmt|;
comment|/* Upper four bits get never changed... */
name|pc
operator|=
name|reg
operator|+
operator|(
operator|(
name|pc
operator|+
literal|4
operator|)
operator|&
literal|0xf0000000
operator|)
expr_stmt|;
block|}
break|break;
comment|/* FIXME case JALX : */
block|{
name|unsigned
name|long
name|reg
decl_stmt|;
name|reg
operator|=
name|jtype_target
argument_list|(
name|inst
argument_list|)
operator|<<
literal|2
expr_stmt|;
name|pc
operator|=
name|reg
operator|+
operator|(
operator|(
name|pc
operator|+
literal|4
operator|)
operator|&
literal|0xf0000000
operator|)
operator|+
literal|1
expr_stmt|;
comment|/* yes, +1 */
comment|/* Add 1 to indicate 16 bit mode - Invert ISA mode */
block|}
break|break;
comment|/* The new PC will be alternate mode */
case|case
literal|4
case|:
comment|/* BEQ, BEQL */
name|equal_branch
label|:
if|if
condition|(
name|read_signed_register
argument_list|(
name|itype_rs
argument_list|(
name|inst
argument_list|)
argument_list|)
operator|==
name|read_signed_register
argument_list|(
name|itype_rt
argument_list|(
name|inst
argument_list|)
argument_list|)
condition|)
name|pc
operator|+=
name|mips32_relative_offset
argument_list|(
name|inst
argument_list|)
operator|+
literal|4
expr_stmt|;
else|else
name|pc
operator|+=
literal|8
expr_stmt|;
break|break;
case|case
literal|5
case|:
comment|/* BNE, BNEL */
name|neq_branch
label|:
if|if
condition|(
name|read_signed_register
argument_list|(
name|itype_rs
argument_list|(
name|inst
argument_list|)
argument_list|)
operator|!=
name|read_signed_register
argument_list|(
name|itype_rt
argument_list|(
name|inst
argument_list|)
argument_list|)
condition|)
name|pc
operator|+=
name|mips32_relative_offset
argument_list|(
name|inst
argument_list|)
operator|+
literal|4
expr_stmt|;
else|else
name|pc
operator|+=
literal|8
expr_stmt|;
break|break;
case|case
literal|6
case|:
comment|/* BLEZ, BLEZL */
if|if
condition|(
name|read_signed_register
argument_list|(
name|itype_rs
argument_list|(
name|inst
argument_list|)
operator|<=
literal|0
argument_list|)
condition|)
name|pc
operator|+=
name|mips32_relative_offset
argument_list|(
name|inst
argument_list|)
operator|+
literal|4
expr_stmt|;
else|else
name|pc
operator|+=
literal|8
expr_stmt|;
break|break;
case|case
literal|7
case|:
default|default:
name|greater_branch
label|:
comment|/* BGTZ, BGTZL */
if|if
condition|(
name|read_signed_register
argument_list|(
name|itype_rs
argument_list|(
name|inst
argument_list|)
operator|>
literal|0
argument_list|)
condition|)
name|pc
operator|+=
name|mips32_relative_offset
argument_list|(
name|inst
argument_list|)
operator|+
literal|4
expr_stmt|;
else|else
name|pc
operator|+=
literal|8
expr_stmt|;
break|break;
block|}
comment|/* switch */
block|}
comment|/* else */
return|return
name|pc
return|;
block|}
end_function

begin_comment
comment|/* mips32_next_pc */
end_comment

begin_comment
comment|/* Decoding the next place to set a breakpoint is irregular for the    mips 16 variant, but fortunately, there fewer instructions. We have to cope    ith extensions for 16 bit instructions and a pair of actual 32 bit instructions.    We dont want to set a single step instruction on the extend instruction    either.  */
end_comment

begin_comment
comment|/* Lots of mips16 instruction formats */
end_comment

begin_comment
comment|/* Predicting jumps requires itype,ritype,i8type    and their extensions      extItype,extritype,extI8type  */
end_comment

begin_enum
enum|enum
name|mips16_inst_fmts
block|{
name|itype
block|,
comment|/* 0  immediate 5,10 */
name|ritype
block|,
comment|/* 1   5,3,8 */
name|rrtype
block|,
comment|/* 2   5,3,3,5 */
name|rritype
block|,
comment|/* 3   5,3,3,5 */
name|rrrtype
block|,
comment|/* 4   5,3,3,3,2 */
name|rriatype
block|,
comment|/* 5   5,3,3,1,4 */
name|shifttype
block|,
comment|/* 6   5,3,3,3,2 */
name|i8type
block|,
comment|/* 7   5,3,8 */
name|i8movtype
block|,
comment|/* 8   5,3,3,5 */
name|i8mov32rtype
block|,
comment|/* 9   5,3,5,3 */
name|i64type
block|,
comment|/* 10  5,3,8 */
name|ri64type
block|,
comment|/* 11  5,3,3,5 */
name|jalxtype
block|,
comment|/* 12  5,1,5,5,16 - a 32 bit instruction */
name|exiItype
block|,
comment|/* 13  5,6,5,5,1,1,1,1,1,1,5 */
name|extRitype
block|,
comment|/* 14  5,6,5,5,3,1,1,1,5 */
name|extRRItype
block|,
comment|/* 15  5,5,5,5,3,3,5 */
name|extRRIAtype
block|,
comment|/* 16  5,7,4,5,3,3,1,4 */
name|EXTshifttype
block|,
comment|/* 17  5,5,1,1,1,1,1,1,5,3,3,1,1,1,2 */
name|extI8type
block|,
comment|/* 18  5,6,5,5,3,1,1,1,5 */
name|extI64type
block|,
comment|/* 19  5,6,5,5,3,1,1,1,5 */
name|extRi64type
block|,
comment|/* 20  5,6,5,5,3,3,5 */
name|extshift64type
comment|/* 21  5,5,1,1,1,1,1,1,5,1,1,1,3,5 */
block|}
enum|;
end_enum

begin_comment
comment|/* I am heaping all the fields of the formats into one structure and    then, only the fields which are involved in instruction extension */
end_comment

begin_struct
struct|struct
name|upk_mips16
block|{
name|CORE_ADDR
name|offset
decl_stmt|;
name|unsigned
name|int
name|regx
decl_stmt|;
comment|/* Function in i8 type */
name|unsigned
name|int
name|regy
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The EXT-I, EXT-ri nad EXT-I8 instructions all have the same format    for the bits which make up the immediatate extension.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|extended_offset
parameter_list|(
name|unsigned
name|int
name|extension
parameter_list|)
block|{
name|CORE_ADDR
name|value
decl_stmt|;
name|value
operator|=
operator|(
name|extension
operator|>>
literal|21
operator|)
operator|&
literal|0x3f
expr_stmt|;
comment|/* * extract 15:11 */
name|value
operator|=
name|value
operator|<<
literal|6
expr_stmt|;
name|value
operator||=
operator|(
name|extension
operator|>>
literal|16
operator|)
operator|&
literal|0x1f
expr_stmt|;
comment|/* extrace 10:5 */
name|value
operator|=
name|value
operator|<<
literal|5
expr_stmt|;
name|value
operator||=
name|extension
operator|&
literal|0x01f
expr_stmt|;
comment|/* extract 4:0 */
return|return
name|value
return|;
block|}
end_function

begin_comment
comment|/* Only call this function if you know that this is an extendable    instruction, It wont malfunction, but why make excess remote memory references?    If the immediate operands get sign extended or somthing, do it after    the extension is performed.  */
end_comment

begin_comment
comment|/* FIXME: Every one of these cases needs to worry about sign extension    when the offset is to be used in relative addressing */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|fetch_mips_16
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
name|char
name|buf
index|[
literal|8
index|]
decl_stmt|;
name|pc
operator|&=
literal|0xfffffffe
expr_stmt|;
comment|/* clear the low order bit */
name|target_read_memory
argument_list|(
name|pc
argument_list|,
name|buf
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|2
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|unpack_mips16
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|unsigned
name|int
name|extension
parameter_list|,
name|unsigned
name|int
name|inst
parameter_list|,
name|enum
name|mips16_inst_fmts
name|insn_format
parameter_list|,
name|struct
name|upk_mips16
modifier|*
name|upk
parameter_list|)
block|{
name|CORE_ADDR
name|offset
decl_stmt|;
name|int
name|regx
decl_stmt|;
name|int
name|regy
decl_stmt|;
switch|switch
condition|(
name|insn_format
condition|)
block|{
case|case
name|itype
case|:
block|{
name|CORE_ADDR
name|value
decl_stmt|;
if|if
condition|(
name|extension
condition|)
block|{
name|value
operator|=
name|extended_offset
argument_list|(
name|extension
argument_list|)
expr_stmt|;
name|value
operator|=
name|value
operator|<<
literal|11
expr_stmt|;
comment|/* rom for the original value */
name|value
operator||=
name|inst
operator|&
literal|0x7ff
expr_stmt|;
comment|/* eleven bits from instruction */
block|}
else|else
block|{
name|value
operator|=
name|inst
operator|&
literal|0x7ff
expr_stmt|;
comment|/* FIXME : Consider sign extension */
block|}
name|offset
operator|=
name|value
expr_stmt|;
name|regx
operator|=
operator|-
literal|1
expr_stmt|;
name|regy
operator|=
operator|-
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|ritype
case|:
case|case
name|i8type
case|:
block|{
comment|/* A register identifier and an offset */
comment|/* Most of the fields are the same as I type but the 	   immediate value is of a different length */
name|CORE_ADDR
name|value
decl_stmt|;
if|if
condition|(
name|extension
condition|)
block|{
name|value
operator|=
name|extended_offset
argument_list|(
name|extension
argument_list|)
expr_stmt|;
name|value
operator|=
name|value
operator|<<
literal|8
expr_stmt|;
comment|/* from the original instruction */
name|value
operator||=
name|inst
operator|&
literal|0xff
expr_stmt|;
comment|/* eleven bits from instruction */
name|regx
operator|=
operator|(
name|extension
operator|>>
literal|8
operator|)
operator|&
literal|0x07
expr_stmt|;
comment|/* or i8 funct */
if|if
condition|(
name|value
operator|&
literal|0x4000
condition|)
comment|/* test the sign bit , bit 26 */
block|{
name|value
operator|&=
operator|~
literal|0x3fff
expr_stmt|;
comment|/* remove the sign bit */
name|value
operator|=
operator|-
name|value
expr_stmt|;
block|}
block|}
else|else
block|{
name|value
operator|=
name|inst
operator|&
literal|0xff
expr_stmt|;
comment|/* 8 bits */
name|regx
operator|=
operator|(
name|inst
operator|>>
literal|8
operator|)
operator|&
literal|0x07
expr_stmt|;
comment|/* or i8 funct */
comment|/* FIXME: Do sign extension , this format needs it */
if|if
condition|(
name|value
operator|&
literal|0x80
condition|)
comment|/* THIS CONFUSES ME */
block|{
name|value
operator|&=
literal|0xef
expr_stmt|;
comment|/* remove the sign bit */
name|value
operator|=
operator|-
name|value
expr_stmt|;
block|}
block|}
name|offset
operator|=
name|value
expr_stmt|;
name|regy
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
case|case
name|jalxtype
case|:
block|{
name|unsigned
name|long
name|value
decl_stmt|;
name|unsigned
name|int
name|nexthalf
decl_stmt|;
name|value
operator|=
operator|(
operator|(
name|inst
operator|&
literal|0x1f
operator|)
operator|<<
literal|5
operator|)
operator||
operator|(
operator|(
name|inst
operator|>>
literal|5
operator|)
operator|&
literal|0x1f
operator|)
expr_stmt|;
name|value
operator|=
name|value
operator|<<
literal|16
expr_stmt|;
name|nexthalf
operator|=
name|mips_fetch_instruction
argument_list|(
name|pc
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|/* low bit still set */
name|value
operator||=
name|nexthalf
expr_stmt|;
name|offset
operator|=
name|value
expr_stmt|;
name|regx
operator|=
operator|-
literal|1
expr_stmt|;
name|regy
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
default|default:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"bad switch"
argument_list|)
expr_stmt|;
block|}
name|upk
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
name|upk
operator|->
name|regx
operator|=
name|regx
expr_stmt|;
name|upk
operator|->
name|regy
operator|=
name|regy
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|CORE_ADDR
name|add_offset_16
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
return|return
operator|(
operator|(
name|offset
operator|<<
literal|2
operator|)
operator||
operator|(
operator|(
name|pc
operator|+
literal|2
operator|)
operator|&
operator|(
literal|0xf0000000
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|CORE_ADDR
name|extended_mips16_next_pc
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|unsigned
name|int
name|extension
parameter_list|,
name|unsigned
name|int
name|insn
parameter_list|)
block|{
name|int
name|op
init|=
operator|(
name|insn
operator|>>
literal|11
operator|)
decl_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
literal|2
case|:
comment|/* Branch */
block|{
name|CORE_ADDR
name|offset
decl_stmt|;
name|struct
name|upk_mips16
name|upk
decl_stmt|;
name|unpack_mips16
argument_list|(
name|pc
argument_list|,
name|extension
argument_list|,
name|insn
argument_list|,
name|itype
argument_list|,
operator|&
name|upk
argument_list|)
expr_stmt|;
name|offset
operator|=
name|upk
operator|.
name|offset
expr_stmt|;
if|if
condition|(
name|offset
operator|&
literal|0x800
condition|)
block|{
name|offset
operator|&=
literal|0xeff
expr_stmt|;
name|offset
operator|=
operator|-
name|offset
expr_stmt|;
block|}
name|pc
operator|+=
operator|(
name|offset
operator|<<
literal|1
operator|)
operator|+
literal|2
expr_stmt|;
break|break;
block|}
case|case
literal|3
case|:
comment|/* JAL , JALX - Watch out, these are 32 bit instruction */
block|{
name|struct
name|upk_mips16
name|upk
decl_stmt|;
name|unpack_mips16
argument_list|(
name|pc
argument_list|,
name|extension
argument_list|,
name|insn
argument_list|,
name|jalxtype
argument_list|,
operator|&
name|upk
argument_list|)
expr_stmt|;
name|pc
operator|=
name|add_offset_16
argument_list|(
name|pc
argument_list|,
name|upk
operator|.
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|insn
operator|>>
literal|10
operator|)
operator|&
literal|0x01
condition|)
comment|/* Exchange mode */
name|pc
operator|=
name|pc
operator|&
operator|~
literal|0x01
expr_stmt|;
comment|/* Clear low bit, indicate 32 bit mode */
else|else
name|pc
operator||=
literal|0x01
expr_stmt|;
break|break;
block|}
case|case
literal|4
case|:
comment|/* beqz */
block|{
name|struct
name|upk_mips16
name|upk
decl_stmt|;
name|int
name|reg
decl_stmt|;
name|unpack_mips16
argument_list|(
name|pc
argument_list|,
name|extension
argument_list|,
name|insn
argument_list|,
name|ritype
argument_list|,
operator|&
name|upk
argument_list|)
expr_stmt|;
name|reg
operator|=
name|read_signed_register
argument_list|(
name|upk
operator|.
name|regx
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|==
literal|0
condition|)
name|pc
operator|+=
operator|(
name|upk
operator|.
name|offset
operator|<<
literal|1
operator|)
operator|+
literal|2
expr_stmt|;
else|else
name|pc
operator|+=
literal|2
expr_stmt|;
break|break;
block|}
case|case
literal|5
case|:
comment|/* bnez */
block|{
name|struct
name|upk_mips16
name|upk
decl_stmt|;
name|int
name|reg
decl_stmt|;
name|unpack_mips16
argument_list|(
name|pc
argument_list|,
name|extension
argument_list|,
name|insn
argument_list|,
name|ritype
argument_list|,
operator|&
name|upk
argument_list|)
expr_stmt|;
name|reg
operator|=
name|read_signed_register
argument_list|(
name|upk
operator|.
name|regx
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|!=
literal|0
condition|)
name|pc
operator|+=
operator|(
name|upk
operator|.
name|offset
operator|<<
literal|1
operator|)
operator|+
literal|2
expr_stmt|;
else|else
name|pc
operator|+=
literal|2
expr_stmt|;
break|break;
block|}
case|case
literal|12
case|:
comment|/* I8 Formats btez btnez */
block|{
name|struct
name|upk_mips16
name|upk
decl_stmt|;
name|int
name|reg
decl_stmt|;
name|unpack_mips16
argument_list|(
name|pc
argument_list|,
name|extension
argument_list|,
name|insn
argument_list|,
name|i8type
argument_list|,
operator|&
name|upk
argument_list|)
expr_stmt|;
comment|/* upk.regx contains the opcode */
name|reg
operator|=
name|read_signed_register
argument_list|(
literal|24
argument_list|)
expr_stmt|;
comment|/* Test register is 24 */
if|if
condition|(
operator|(
operator|(
name|upk
operator|.
name|regx
operator|==
literal|0
operator|)
operator|&&
operator|(
name|reg
operator|==
literal|0
operator|)
operator|)
comment|/* BTEZ */
operator|||
operator|(
operator|(
name|upk
operator|.
name|regx
operator|==
literal|1
operator|)
operator|&&
operator|(
name|reg
operator|!=
literal|0
operator|)
operator|)
condition|)
comment|/* BTNEZ */
comment|/* pc = add_offset_16(pc,upk.offset) ; */
name|pc
operator|+=
operator|(
name|upk
operator|.
name|offset
operator|<<
literal|1
operator|)
operator|+
literal|2
expr_stmt|;
else|else
name|pc
operator|+=
literal|2
expr_stmt|;
break|break;
block|}
case|case
literal|29
case|:
comment|/* RR Formats JR, JALR, JALR-RA */
block|{
name|struct
name|upk_mips16
name|upk
decl_stmt|;
comment|/* upk.fmt = rrtype; */
name|op
operator|=
name|insn
operator|&
literal|0x1f
expr_stmt|;
if|if
condition|(
name|op
operator|==
literal|0
condition|)
block|{
name|int
name|reg
decl_stmt|;
name|upk
operator|.
name|regx
operator|=
operator|(
name|insn
operator|>>
literal|8
operator|)
operator|&
literal|0x07
expr_stmt|;
name|upk
operator|.
name|regy
operator|=
operator|(
name|insn
operator|>>
literal|5
operator|)
operator|&
literal|0x07
expr_stmt|;
switch|switch
condition|(
name|upk
operator|.
name|regy
condition|)
block|{
case|case
literal|0
case|:
name|reg
operator|=
name|upk
operator|.
name|regx
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|reg
operator|=
literal|31
expr_stmt|;
break|break;
comment|/* Function return instruction */
case|case
literal|2
case|:
name|reg
operator|=
name|upk
operator|.
name|regx
expr_stmt|;
break|break;
default|default:
name|reg
operator|=
literal|31
expr_stmt|;
break|break;
comment|/* BOGUS Guess */
block|}
name|pc
operator|=
name|read_signed_register
argument_list|(
name|reg
argument_list|)
expr_stmt|;
block|}
else|else
name|pc
operator|+=
literal|2
expr_stmt|;
break|break;
block|}
case|case
literal|30
case|:
comment|/* This is an instruction extension.  Fetch the real instruction          (which follows the extension) and decode things based on          that. */
block|{
name|pc
operator|+=
literal|2
expr_stmt|;
name|pc
operator|=
name|extended_mips16_next_pc
argument_list|(
name|pc
argument_list|,
name|insn
argument_list|,
name|fetch_mips_16
argument_list|(
name|pc
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
block|{
name|pc
operator|+=
literal|2
expr_stmt|;
break|break;
block|}
block|}
return|return
name|pc
return|;
block|}
end_function

begin_function
specifier|static
name|CORE_ADDR
name|mips16_next_pc
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
name|unsigned
name|int
name|insn
init|=
name|fetch_mips_16
argument_list|(
name|pc
argument_list|)
decl_stmt|;
return|return
name|extended_mips16_next_pc
argument_list|(
name|pc
argument_list|,
literal|0
argument_list|,
name|insn
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The mips_next_pc function supports single_step when the remote    target monitor or stub is not developed enough to do a single_step.    It works by decoding the current instruction and predicting where a    branch will go. This isnt hard because all the data is available.    The MIPS32 and MIPS16 variants are quite different */
end_comment

begin_function
name|CORE_ADDR
name|mips_next_pc
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
if|if
condition|(
name|pc
operator|&
literal|0x01
condition|)
return|return
name|mips16_next_pc
argument_list|(
name|pc
argument_list|)
return|;
else|else
return|return
name|mips32_next_pc
argument_list|(
name|pc
argument_list|)
return|;
block|}
end_function

begin_struct
struct|struct
name|mips_frame_cache
block|{
name|CORE_ADDR
name|base
decl_stmt|;
name|struct
name|trad_frame_saved_reg
modifier|*
name|saved_regs
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|struct
name|mips_frame_cache
modifier|*
name|mips_mdebug_frame_cache
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|void
modifier|*
modifier|*
name|this_cache
parameter_list|)
block|{
name|mips_extra_func_info_t
name|proc_desc
decl_stmt|;
name|struct
name|mips_frame_cache
modifier|*
name|cache
decl_stmt|;
name|struct
name|gdbarch
modifier|*
name|gdbarch
init|=
name|get_frame_arch
argument_list|(
name|next_frame
argument_list|)
decl_stmt|;
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|gdbarch
argument_list|)
decl_stmt|;
comment|/* r0 bit means kernel trap */
name|int
name|kernel_trap
decl_stmt|;
comment|/* What registers have been saved?  Bitmasks.  */
name|unsigned
name|long
name|gen_mask
decl_stmt|,
name|float_mask
decl_stmt|;
name|long
name|reg_offset
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|this_cache
operator|)
operator|!=
name|NULL
condition|)
return|return
operator|(
operator|*
name|this_cache
operator|)
return|;
name|cache
operator|=
name|FRAME_OBSTACK_ZALLOC
argument_list|(
expr|struct
name|mips_frame_cache
argument_list|)
expr_stmt|;
operator|(
operator|*
name|this_cache
operator|)
operator|=
name|cache
expr_stmt|;
name|cache
operator|->
name|saved_regs
operator|=
name|trad_frame_alloc_saved_regs
argument_list|(
name|next_frame
argument_list|)
expr_stmt|;
comment|/* Get the mdebug proc descriptor.  */
name|proc_desc
operator|=
name|find_proc_desc
argument_list|(
name|frame_pc_unwind
argument_list|(
name|next_frame
argument_list|)
argument_list|,
name|next_frame
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|proc_desc
operator|==
name|NULL
condition|)
comment|/* I'm not sure how/whether this can happen.  Normally when we        can't find a proc_desc, we "synthesize" one using        heuristic_proc_desc and set the saved_regs right away.  */
return|return
name|cache
return|;
comment|/* Extract the frame's base.  */
name|cache
operator|->
name|base
operator|=
operator|(
name|frame_unwind_register_signed
argument_list|(
name|next_frame
argument_list|,
name|NUM_REGS
operator|+
name|PROC_FRAME_REG
argument_list|(
name|proc_desc
argument_list|)
argument_list|)
operator|+
name|PROC_FRAME_OFFSET
argument_list|(
name|proc_desc
argument_list|)
operator|-
name|PROC_FRAME_ADJUST
argument_list|(
name|proc_desc
argument_list|)
operator|)
expr_stmt|;
comment|/* Save registers offset from scratching by following find_proc_desc call */
name|reg_offset
operator|=
name|PROC_REG_OFFSET
argument_list|(
name|proc_desc
argument_list|)
expr_stmt|;
name|kernel_trap
operator|=
name|PROC_REG_MASK
argument_list|(
name|proc_desc
argument_list|)
operator|&
literal|1
expr_stmt|;
name|gen_mask
operator|=
name|kernel_trap
condition|?
literal|0xFFFFFFFF
else|:
name|PROC_REG_MASK
argument_list|(
name|proc_desc
argument_list|)
expr_stmt|;
name|float_mask
operator|=
name|kernel_trap
condition|?
literal|0xFFFFFFFF
else|:
name|PROC_FREG_MASK
argument_list|(
name|proc_desc
argument_list|)
expr_stmt|;
comment|/* In any frame other than the innermost or a frame interrupted by a      signal, we assume that all registers have been saved.  This      assumes that all register saves in a function happen before the      first function call.  */
if|if
condition|(
name|in_prologue
argument_list|(
name|frame_pc_unwind
argument_list|(
name|next_frame
argument_list|)
argument_list|,
name|PROC_LOW_ADDR
argument_list|(
name|proc_desc
argument_list|)
argument_list|)
comment|/* Not sure exactly what kernel_trap means, but if it means the 	 kernel saves the registers without a prologue doing it, we 	 better not examine the prologue to see whether registers 	 have been saved yet.  */
operator|&&
operator|!
name|kernel_trap
condition|)
block|{
comment|/* We need to figure out whether the registers that the          proc_desc claims are saved have been saved yet.  */
name|CORE_ADDR
name|addr
decl_stmt|;
comment|/* Bitmasks; set if we have found a save for the register.  */
name|unsigned
name|long
name|gen_save_found
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|float_save_found
init|=
literal|0
decl_stmt|;
name|int
name|mips16
decl_stmt|;
comment|/* If the address is odd, assume this is MIPS16 code.  */
name|addr
operator|=
name|PROC_LOW_ADDR
argument_list|(
name|proc_desc
argument_list|)
expr_stmt|;
name|mips16
operator|=
name|pc_is_mips16
argument_list|(
name|addr
argument_list|)
expr_stmt|;
comment|/* Scan through this function's instructions preceding the          current PC, and look for those that save registers.  */
while|while
condition|(
name|addr
operator|<
name|frame_pc_unwind
argument_list|(
name|next_frame
argument_list|)
condition|)
block|{
if|if
condition|(
name|mips16
condition|)
block|{
name|mips16_decode_reg_save
argument_list|(
name|mips16_fetch_instruction
argument_list|(
name|addr
argument_list|)
argument_list|,
operator|&
name|gen_save_found
argument_list|)
expr_stmt|;
name|addr
operator|+=
name|MIPS16_INSTLEN
expr_stmt|;
block|}
else|else
block|{
name|mips32_decode_reg_save
argument_list|(
name|mips32_fetch_instruction
argument_list|(
name|addr
argument_list|)
argument_list|,
operator|&
name|gen_save_found
argument_list|,
operator|&
name|float_save_found
argument_list|)
expr_stmt|;
name|addr
operator|+=
name|MIPS_INSTLEN
expr_stmt|;
block|}
block|}
name|gen_mask
operator|=
name|gen_save_found
expr_stmt|;
name|float_mask
operator|=
name|float_save_found
expr_stmt|;
block|}
comment|/* Fill in the offsets for the registers which gen_mask says were      saved.  */
block|{
name|CORE_ADDR
name|reg_position
init|=
operator|(
name|cache
operator|->
name|base
operator|+
name|reg_offset
operator|)
decl_stmt|;
name|int
name|ireg
decl_stmt|;
for|for
control|(
name|ireg
operator|=
name|MIPS_NUMREGS
operator|-
literal|1
init|;
name|gen_mask
condition|;
operator|--
name|ireg
operator|,
name|gen_mask
operator|<<=
literal|1
control|)
if|if
condition|(
name|gen_mask
operator|&
literal|0x80000000
condition|)
block|{
name|cache
operator|->
name|saved_regs
index|[
name|NUM_REGS
operator|+
name|ireg
index|]
operator|.
name|addr
operator|=
name|reg_position
expr_stmt|;
name|reg_position
operator|-=
name|mips_saved_regsize
argument_list|(
name|tdep
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* The MIPS16 entry instruction saves $s0 and $s1 in the reverse      order of that normally used by gcc.  Therefore, we have to fetch      the first instruction of the function, and if it's an entry      instruction that saves $s0 or $s1, correct their saved addresses.  */
if|if
condition|(
name|pc_is_mips16
argument_list|(
name|PROC_LOW_ADDR
argument_list|(
name|proc_desc
argument_list|)
argument_list|)
condition|)
block|{
name|ULONGEST
name|inst
init|=
name|mips16_fetch_instruction
argument_list|(
name|PROC_LOW_ADDR
argument_list|(
name|proc_desc
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|inst
operator|&
literal|0xf81f
operator|)
operator|==
literal|0xe809
operator|&&
operator|(
name|inst
operator|&
literal|0x700
operator|)
operator|!=
literal|0x700
condition|)
comment|/* entry */
block|{
name|int
name|reg
decl_stmt|;
name|int
name|sreg_count
init|=
operator|(
name|inst
operator|>>
literal|6
operator|)
operator|&
literal|3
decl_stmt|;
comment|/* Check if the ra register was pushed on the stack.  */
name|CORE_ADDR
name|reg_position
init|=
operator|(
name|cache
operator|->
name|base
operator|+
name|PROC_REG_OFFSET
argument_list|(
name|proc_desc
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|inst
operator|&
literal|0x20
condition|)
name|reg_position
operator|-=
name|mips_saved_regsize
argument_list|(
name|tdep
argument_list|)
expr_stmt|;
comment|/* Check if the s0 and s1 registers were pushed on the 	     stack.  */
comment|/* NOTE: cagney/2004-02-08: Huh?  This is doing no such              check.  */
for|for
control|(
name|reg
operator|=
literal|16
init|;
name|reg
operator|<
name|sreg_count
operator|+
literal|16
condition|;
name|reg
operator|++
control|)
block|{
name|cache
operator|->
name|saved_regs
index|[
name|NUM_REGS
operator|+
name|reg
index|]
operator|.
name|addr
operator|=
name|reg_position
expr_stmt|;
name|reg_position
operator|-=
name|mips_saved_regsize
argument_list|(
name|tdep
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Fill in the offsets for the registers which float_mask says were      saved.  */
block|{
name|CORE_ADDR
name|reg_position
init|=
operator|(
name|cache
operator|->
name|base
operator|+
name|PROC_FREG_OFFSET
argument_list|(
name|proc_desc
argument_list|)
operator|)
decl_stmt|;
name|int
name|ireg
decl_stmt|;
comment|/* Fill in the offsets for the float registers which float_mask        says were saved.  */
for|for
control|(
name|ireg
operator|=
name|MIPS_NUMREGS
operator|-
literal|1
init|;
name|float_mask
condition|;
operator|--
name|ireg
operator|,
name|float_mask
operator|<<=
literal|1
control|)
if|if
condition|(
name|float_mask
operator|&
literal|0x80000000
condition|)
block|{
if|if
condition|(
name|mips_saved_regsize
argument_list|(
name|tdep
argument_list|)
operator|==
literal|4
operator|&&
name|TARGET_BYTE_ORDER
operator|==
name|BFD_ENDIAN_BIG
condition|)
block|{
comment|/* On a big endian 32 bit ABI, floating point registers 	         are paired to form doubles such that the most 	         significant part is in $f[N+1] and the least 	         significant in $f[N] vis: $f[N+1] ||| $f[N].  The 	         registers are also spilled as a pair and stored as a 	         double.  	         When little-endian the least significant part is 	         stored first leading to the memory order $f[N] and 	         then $f[N+1].  	         Unfortunately, when big-endian the most significant 	         part of the double is stored first, and the least 	         significant is stored second.  This leads to the 	         registers being ordered in memory as firt $f[N+1] and 	         then $f[N].  	         For the big-endian case make certain that the 	         addresses point at the correct (swapped) locations 	         $f[N] and $f[N+1] pair (keep in mind that 	         reg_position is decremented each time through the 	         loop).  */
if|if
condition|(
operator|(
name|ireg
operator|&
literal|1
operator|)
condition|)
name|cache
operator|->
name|saved_regs
index|[
name|NUM_REGS
operator|+
name|mips_regnum
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|fp0
operator|+
name|ireg
index|]
operator|.
name|addr
operator|=
name|reg_position
operator|-
name|mips_saved_regsize
argument_list|(
name|tdep
argument_list|)
expr_stmt|;
else|else
name|cache
operator|->
name|saved_regs
index|[
name|NUM_REGS
operator|+
name|mips_regnum
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|fp0
operator|+
name|ireg
index|]
operator|.
name|addr
operator|=
name|reg_position
operator|+
name|mips_saved_regsize
argument_list|(
name|tdep
argument_list|)
expr_stmt|;
block|}
else|else
name|cache
operator|->
name|saved_regs
index|[
name|NUM_REGS
operator|+
name|mips_regnum
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|fp0
operator|+
name|ireg
index|]
operator|.
name|addr
operator|=
name|reg_position
expr_stmt|;
name|reg_position
operator|-=
name|mips_saved_regsize
argument_list|(
name|tdep
argument_list|)
expr_stmt|;
block|}
name|cache
operator|->
name|saved_regs
index|[
name|NUM_REGS
operator|+
name|mips_regnum
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|pc
index|]
operator|=
name|cache
operator|->
name|saved_regs
index|[
name|NUM_REGS
operator|+
name|RA_REGNUM
index|]
expr_stmt|;
block|}
comment|/* SP_REGNUM, contains the value and not the address.  */
name|trad_frame_set_value
argument_list|(
name|cache
operator|->
name|saved_regs
argument_list|,
name|NUM_REGS
operator|+
name|SP_REGNUM
argument_list|,
name|cache
operator|->
name|base
argument_list|)
expr_stmt|;
return|return
operator|(
operator|*
name|this_cache
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mips_mdebug_frame_this_id
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|void
modifier|*
modifier|*
name|this_cache
parameter_list|,
name|struct
name|frame_id
modifier|*
name|this_id
parameter_list|)
block|{
name|struct
name|mips_frame_cache
modifier|*
name|info
init|=
name|mips_mdebug_frame_cache
argument_list|(
name|next_frame
argument_list|,
name|this_cache
argument_list|)
decl_stmt|;
operator|(
operator|*
name|this_id
operator|)
operator|=
name|frame_id_build
argument_list|(
name|info
operator|->
name|base
argument_list|,
name|frame_func_unwind
argument_list|(
name|next_frame
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mips_mdebug_frame_prev_register
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|void
modifier|*
modifier|*
name|this_cache
parameter_list|,
name|int
name|regnum
parameter_list|,
name|int
modifier|*
name|optimizedp
parameter_list|,
name|enum
name|lval_type
modifier|*
name|lvalp
parameter_list|,
name|CORE_ADDR
modifier|*
name|addrp
parameter_list|,
name|int
modifier|*
name|realnump
parameter_list|,
name|void
modifier|*
name|valuep
parameter_list|)
block|{
name|struct
name|mips_frame_cache
modifier|*
name|info
init|=
name|mips_mdebug_frame_cache
argument_list|(
name|next_frame
argument_list|,
name|this_cache
argument_list|)
decl_stmt|;
name|trad_frame_prev_register
argument_list|(
name|next_frame
argument_list|,
name|info
operator|->
name|saved_regs
argument_list|,
name|regnum
argument_list|,
name|optimizedp
argument_list|,
name|lvalp
argument_list|,
name|addrp
argument_list|,
name|realnump
argument_list|,
name|valuep
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|frame_unwind
name|mips_mdebug_frame_unwind
init|=
block|{
name|NORMAL_FRAME
block|,
name|mips_mdebug_frame_this_id
block|,
name|mips_mdebug_frame_prev_register
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|const
name|struct
name|frame_unwind
modifier|*
name|mips_mdebug_frame_sniffer
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|)
block|{
return|return
operator|&
name|mips_mdebug_frame_unwind
return|;
block|}
end_function

begin_function
specifier|static
name|CORE_ADDR
name|mips_mdebug_frame_base_address
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|void
modifier|*
modifier|*
name|this_cache
parameter_list|)
block|{
name|struct
name|mips_frame_cache
modifier|*
name|info
init|=
name|mips_mdebug_frame_cache
argument_list|(
name|next_frame
argument_list|,
name|this_cache
argument_list|)
decl_stmt|;
return|return
name|info
operator|->
name|base
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|frame_base
name|mips_mdebug_frame_base
init|=
block|{
operator|&
name|mips_mdebug_frame_unwind
block|,
name|mips_mdebug_frame_base_address
block|,
name|mips_mdebug_frame_base_address
block|,
name|mips_mdebug_frame_base_address
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|const
name|struct
name|frame_base
modifier|*
name|mips_mdebug_frame_base_sniffer
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|)
block|{
return|return
operator|&
name|mips_mdebug_frame_base
return|;
block|}
end_function

begin_function
specifier|static
name|CORE_ADDR
name|read_next_frame_reg
parameter_list|(
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
comment|/* Always a pseudo.  */
name|gdb_assert
argument_list|(
name|regno
operator|>=
name|NUM_REGS
argument_list|)
expr_stmt|;
if|if
condition|(
name|fi
operator|==
name|NULL
condition|)
block|{
name|LONGEST
name|val
decl_stmt|;
name|regcache_cooked_read_signed
argument_list|(
name|current_regcache
argument_list|,
name|regno
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|regno
operator|%
name|NUM_REGS
operator|)
operator|==
name|SP_REGNUM
condition|)
comment|/* The SP_REGNUM is special, its value is stored in saved_regs.        In fact, it is so special that it can even only be fetched        using a raw register number!  Once this code as been converted        to frame-unwind the problem goes away.  */
return|return
name|frame_unwind_register_signed
argument_list|(
name|fi
argument_list|,
name|regno
operator|%
name|NUM_REGS
argument_list|)
return|;
else|else
return|return
name|frame_unwind_register_signed
argument_list|(
name|fi
argument_list|,
name|regno
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* mips_addr_bits_remove - remove useless address bits  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|mips_addr_bits_remove
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|)
block|{
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
decl_stmt|;
if|if
condition|(
name|mips_mask_address_p
argument_list|(
name|tdep
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|ULONGEST
operator|)
name|addr
operator|)
operator|>>
literal|32
operator|==
literal|0xffffffffUL
operator|)
condition|)
comment|/* This hack is a work-around for existing boards using PMON, the        simulator, and any other 64-bit targets that doesn't have true        64-bit addressing.  On these targets, the upper 32 bits of        addresses are ignored by the hardware.  Thus, the PC or SP are        likely to have been sign extended to all 1s by instruction        sequences that load 32-bit addresses.  For example, a typical        piece of code that loads an address is this:         lui $r2,<upper 16 bits>        ori $r2,<lower 16 bits>         But the lui sign-extends the value such that the upper 32 bits        may be all 1s.  The workaround is simply to mask off these        bits.  In the future, gcc may be changed to support true 64-bit        addressing, and this masking will have to be disabled.  */
return|return
name|addr
operator|&=
literal|0xffffffffUL
return|;
else|else
return|return
name|addr
return|;
block|}
end_function

begin_comment
comment|/* mips_software_single_step() is called just before we want to resume    the inferior, if we want to single-step it but there is no hardware    or kernel single-step support (MIPS on GNU/Linux for example).  We find    the target of the coming instruction and breakpoint it.     single_step is also called just after the inferior stops.  If we had    set up a simulated single-step, we undo our damage.  */
end_comment

begin_function
name|void
name|mips_software_single_step
parameter_list|(
name|enum
name|target_signal
name|sig
parameter_list|,
name|int
name|insert_breakpoints_p
parameter_list|)
block|{
specifier|static
name|CORE_ADDR
name|next_pc
decl_stmt|;
typedef|typedef
name|char
name|binsn_quantum
index|[
name|BREAKPOINT_MAX
index|]
typedef|;
specifier|static
name|binsn_quantum
name|break_mem
decl_stmt|;
name|CORE_ADDR
name|pc
decl_stmt|;
if|if
condition|(
name|insert_breakpoints_p
condition|)
block|{
name|pc
operator|=
name|read_register
argument_list|(
name|mips_regnum
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|pc
argument_list|)
expr_stmt|;
name|next_pc
operator|=
name|mips_next_pc
argument_list|(
name|pc
argument_list|)
expr_stmt|;
name|target_insert_breakpoint
argument_list|(
name|next_pc
argument_list|,
name|break_mem
argument_list|)
expr_stmt|;
block|}
else|else
name|target_remove_breakpoint
argument_list|(
name|next_pc
argument_list|,
name|break_mem
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|mips_extra_func_info
name|temp_proc_desc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This hack will go away once the get_prev_frame() code has been    modified to set the frame's type first.  That is BEFORE init extra    frame info et.al.  is called.  This is because it will become    possible to skip the init extra info call for sigtramp and dummy    frames.  */
end_comment

begin_decl_stmt
specifier|static
name|CORE_ADDR
modifier|*
name|temp_saved_regs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set a register's saved stack address in temp_saved_regs.  If an    address has already been set for this register, do nothing; this    way we will only recognize the first save of a given register in a    function prologue.     For simplicity, save the address in both [0 .. NUM_REGS) and    [NUM_REGS .. 2*NUM_REGS).  Strictly speaking, only the second range    is used as it is only second range (the ABI instead of ISA    registers) that comes into play when finding saved registers in a    frame.  */
end_comment

begin_function
specifier|static
name|void
name|set_reg_offset
parameter_list|(
name|CORE_ADDR
modifier|*
name|saved_regs
parameter_list|,
name|int
name|regno
parameter_list|,
name|CORE_ADDR
name|offset
parameter_list|)
block|{
if|if
condition|(
name|saved_regs
index|[
name|regno
index|]
operator|==
literal|0
condition|)
block|{
name|saved_regs
index|[
name|regno
operator|+
literal|0
operator|*
name|NUM_REGS
index|]
operator|=
name|offset
expr_stmt|;
name|saved_regs
index|[
name|regno
operator|+
literal|1
operator|*
name|NUM_REGS
index|]
operator|=
name|offset
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Test whether the PC points to the return instruction at the    end of a function. */
end_comment

begin_function
specifier|static
name|int
name|mips_about_to_return
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
if|if
condition|(
name|pc_is_mips16
argument_list|(
name|pc
argument_list|)
condition|)
comment|/* This mips16 case isn't necessarily reliable.  Sometimes the compiler        generates a "jr $ra"; other times it generates code to load        the return address from the stack to an accessible register (such        as $a3), then a "jr" using that register.  This second case        is almost impossible to distinguish from an indirect jump        used for switch statements, so we don't even try.  */
return|return
name|mips_fetch_instruction
argument_list|(
name|pc
argument_list|)
operator|==
literal|0xe820
return|;
comment|/* jr $ra */
else|else
return|return
name|mips_fetch_instruction
argument_list|(
name|pc
argument_list|)
operator|==
literal|0x3e00008
return|;
comment|/* jr $ra */
block|}
end_function

begin_comment
comment|/* This fencepost looks highly suspicious to me.  Removing it also    seems suspicious as it could affect remote debugging across serial    lines.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|heuristic_proc_start
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
name|CORE_ADDR
name|start_pc
decl_stmt|;
name|CORE_ADDR
name|fence
decl_stmt|;
name|int
name|instlen
decl_stmt|;
name|int
name|seen_adjsp
init|=
literal|0
decl_stmt|;
name|pc
operator|=
name|ADDR_BITS_REMOVE
argument_list|(
name|pc
argument_list|)
expr_stmt|;
name|start_pc
operator|=
name|pc
expr_stmt|;
name|fence
operator|=
name|start_pc
operator|-
name|heuristic_fence_post
expr_stmt|;
if|if
condition|(
name|start_pc
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|heuristic_fence_post
operator|==
name|UINT_MAX
operator|||
name|fence
operator|<
name|VM_MIN_ADDRESS
condition|)
name|fence
operator|=
name|VM_MIN_ADDRESS
expr_stmt|;
name|instlen
operator|=
name|pc_is_mips16
argument_list|(
name|pc
argument_list|)
condition|?
name|MIPS16_INSTLEN
else|:
name|MIPS_INSTLEN
expr_stmt|;
comment|/* search back for previous return */
for|for
control|(
name|start_pc
operator|-=
name|instlen
init|;
condition|;
name|start_pc
operator|-=
name|instlen
control|)
if|if
condition|(
name|start_pc
operator|<
name|fence
condition|)
block|{
comment|/* It's not clear to me why we reach this point when 	   stop_soon, but with this test, at least we 	   don't print out warnings for every child forked (eg, on 	   decstation).  22apr93 rich@cygnus.com.  */
if|if
condition|(
name|stop_soon
operator|==
name|NO_STOP_QUIETLY
condition|)
block|{
specifier|static
name|int
name|blurb_printed
init|=
literal|0
decl_stmt|;
name|warning
argument_list|(
literal|"Warning: GDB can't find the start of the function at 0x%s."
argument_list|,
name|paddr_nz
argument_list|(
name|pc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|blurb_printed
condition|)
block|{
comment|/* This actually happens frequently in embedded 		   development, when you first connect to a board 		   and your stack pointer and pc are nowhere in 		   particular.  This message needs to give people 		   in that situation enough information to 		   determine that it's no big deal.  */
name|printf_filtered
argument_list|(
literal|"\n\     GDB is unable to find the start of the function at 0x%s\n\ and thus can't determine the size of that function's stack frame.\n\ This means that GDB may be unable to access that stack frame, or\n\ the frames below it.\n\     This problem is most likely caused by an invalid program counter or\n\ stack pointer.\n\     However, if you think GDB should simply search farther back\n\ from 0x%s for code which looks like the beginning of a\n\ function, you can increase the range of the search using the `set\n\ heuristic-fence-post' command.\n"
argument_list|,
name|paddr_nz
argument_list|(
name|pc
argument_list|)
argument_list|,
name|paddr_nz
argument_list|(
name|pc
argument_list|)
argument_list|)
expr_stmt|;
name|blurb_printed
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|pc_is_mips16
argument_list|(
name|start_pc
argument_list|)
condition|)
block|{
name|unsigned
name|short
name|inst
decl_stmt|;
comment|/* On MIPS16, any one of the following is likely to be the 	   start of a function: 	   entry 	   addiu sp,-n 	   daddiu sp,-n 	   extend -n followed by 'addiu sp,+n' or 'daddiu sp,+n'  */
name|inst
operator|=
name|mips_fetch_instruction
argument_list|(
name|start_pc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|inst
operator|&
literal|0xf81f
operator|)
operator|==
literal|0xe809
operator|&&
operator|(
name|inst
operator|&
literal|0x700
operator|)
operator|!=
literal|0x700
operator|)
comment|/* entry */
operator|||
operator|(
name|inst
operator|&
literal|0xff80
operator|)
operator|==
literal|0x6380
comment|/* addiu sp,-n */
operator|||
operator|(
name|inst
operator|&
literal|0xff80
operator|)
operator|==
literal|0xfb80
comment|/* daddiu sp,-n */
operator|||
operator|(
operator|(
name|inst
operator|&
literal|0xf810
operator|)
operator|==
literal|0xf010
operator|&&
name|seen_adjsp
operator|)
condition|)
comment|/* extend -n */
break|break;
elseif|else
if|if
condition|(
operator|(
name|inst
operator|&
literal|0xff00
operator|)
operator|==
literal|0x6300
comment|/* addiu sp */
operator|||
operator|(
name|inst
operator|&
literal|0xff00
operator|)
operator|==
literal|0xfb00
condition|)
comment|/* daddiu sp */
name|seen_adjsp
operator|=
literal|1
expr_stmt|;
else|else
name|seen_adjsp
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mips_about_to_return
argument_list|(
name|start_pc
argument_list|)
condition|)
block|{
name|start_pc
operator|+=
literal|2
operator|*
name|MIPS_INSTLEN
expr_stmt|;
comment|/* skip return, and its delay slot */
break|break;
block|}
return|return
name|start_pc
return|;
block|}
end_function

begin_comment
comment|/* Fetch the immediate value from a MIPS16 instruction.    If the previous instruction was an EXTEND, use it to extend    the upper bits of the immediate value.  This is a helper function    for mips16_heuristic_proc_desc.  */
end_comment

begin_function
specifier|static
name|int
name|mips16_get_imm
parameter_list|(
name|unsigned
name|short
name|prev_inst
parameter_list|,
comment|/* previous instruction */
name|unsigned
name|short
name|inst
parameter_list|,
comment|/* current instruction */
name|int
name|nbits
parameter_list|,
comment|/* number of bits in imm field */
name|int
name|scale
parameter_list|,
comment|/* scale factor to be applied to imm */
name|int
name|is_signed
parameter_list|)
comment|/* is the imm field signed? */
block|{
name|int
name|offset
decl_stmt|;
if|if
condition|(
operator|(
name|prev_inst
operator|&
literal|0xf800
operator|)
operator|==
literal|0xf000
condition|)
comment|/* prev instruction was EXTEND? */
block|{
name|offset
operator|=
operator|(
operator|(
name|prev_inst
operator|&
literal|0x1f
operator|)
operator|<<
literal|11
operator|)
operator||
operator|(
name|prev_inst
operator|&
literal|0x7e0
operator|)
expr_stmt|;
if|if
condition|(
name|offset
operator|&
literal|0x8000
condition|)
comment|/* check for negative extend */
name|offset
operator|=
literal|0
operator|-
operator|(
literal|0x10000
operator|-
operator|(
name|offset
operator|&
literal|0xffff
operator|)
operator|)
expr_stmt|;
return|return
name|offset
operator||
operator|(
name|inst
operator|&
literal|0x1f
operator|)
return|;
block|}
else|else
block|{
name|int
name|max_imm
init|=
literal|1
operator|<<
name|nbits
decl_stmt|;
name|int
name|mask
init|=
name|max_imm
operator|-
literal|1
decl_stmt|;
name|int
name|sign_bit
init|=
name|max_imm
operator|>>
literal|1
decl_stmt|;
name|offset
operator|=
name|inst
operator|&
name|mask
expr_stmt|;
if|if
condition|(
name|is_signed
operator|&&
operator|(
name|offset
operator|&
name|sign_bit
operator|)
condition|)
name|offset
operator|=
literal|0
operator|-
operator|(
name|max_imm
operator|-
name|offset
operator|)
expr_stmt|;
return|return
name|offset
operator|*
name|scale
return|;
block|}
block|}
end_function

begin_comment
comment|/* Fill in values in temp_proc_desc based on the MIPS16 instruction    stream from start_pc to limit_pc.  */
end_comment

begin_function
specifier|static
name|void
name|mips16_heuristic_proc_desc
parameter_list|(
name|CORE_ADDR
name|start_pc
parameter_list|,
name|CORE_ADDR
name|limit_pc
parameter_list|,
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|CORE_ADDR
name|sp
parameter_list|)
block|{
name|CORE_ADDR
name|cur_pc
decl_stmt|;
name|CORE_ADDR
name|frame_addr
init|=
literal|0
decl_stmt|;
comment|/* Value of $r17, used as frame pointer */
name|unsigned
name|short
name|prev_inst
init|=
literal|0
decl_stmt|;
comment|/* saved copy of previous instruction */
name|unsigned
name|inst
init|=
literal|0
decl_stmt|;
comment|/* current instruction */
name|unsigned
name|entry_inst
init|=
literal|0
decl_stmt|;
comment|/* the entry instruction */
name|int
name|reg
decl_stmt|,
name|offset
decl_stmt|;
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
decl_stmt|;
name|PROC_FRAME_OFFSET
argument_list|(
operator|&
name|temp_proc_desc
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* size of stack frame */
name|PROC_FRAME_ADJUST
argument_list|(
operator|&
name|temp_proc_desc
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* offset of FP from SP */
for|for
control|(
name|cur_pc
operator|=
name|start_pc
init|;
name|cur_pc
operator|<
name|limit_pc
condition|;
name|cur_pc
operator|+=
name|MIPS16_INSTLEN
control|)
block|{
comment|/* Save the previous instruction.  If it's an EXTEND, we'll extract          the immediate offset extension from it in mips16_get_imm.  */
name|prev_inst
operator|=
name|inst
expr_stmt|;
comment|/* Fetch and decode the instruction.   */
name|inst
operator|=
operator|(
name|unsigned
name|short
operator|)
name|mips_fetch_instruction
argument_list|(
name|cur_pc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|inst
operator|&
literal|0xff00
operator|)
operator|==
literal|0x6300
comment|/* addiu sp */
operator|||
operator|(
name|inst
operator|&
literal|0xff00
operator|)
operator|==
literal|0xfb00
condition|)
comment|/* daddiu sp */
block|{
name|offset
operator|=
name|mips16_get_imm
argument_list|(
name|prev_inst
argument_list|,
name|inst
argument_list|,
literal|8
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
comment|/* negative stack adjustment? */
name|PROC_FRAME_OFFSET
argument_list|(
operator|&
name|temp_proc_desc
argument_list|)
operator|-=
name|offset
expr_stmt|;
else|else
comment|/* Exit loop if a positive stack adjustment is found, which 	       usually means that the stack cleanup code in the function 	       epilogue is reached.  */
break|break;
block|}
elseif|else
if|if
condition|(
operator|(
name|inst
operator|&
literal|0xf800
operator|)
operator|==
literal|0xd000
condition|)
comment|/* sw reg,n($sp) */
block|{
name|offset
operator|=
name|mips16_get_imm
argument_list|(
name|prev_inst
argument_list|,
name|inst
argument_list|,
literal|8
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|reg
operator|=
name|mips16_to_32_reg
index|[
operator|(
name|inst
operator|&
literal|0x700
operator|)
operator|>>
literal|8
index|]
expr_stmt|;
name|PROC_REG_MASK
argument_list|(
operator|&
name|temp_proc_desc
argument_list|)
operator||=
operator|(
literal|1
operator|<<
name|reg
operator|)
expr_stmt|;
name|set_reg_offset
argument_list|(
name|temp_saved_regs
argument_list|,
name|reg
argument_list|,
name|sp
operator|+
name|offset
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|inst
operator|&
literal|0xff00
operator|)
operator|==
literal|0xf900
condition|)
comment|/* sd reg,n($sp) */
block|{
name|offset
operator|=
name|mips16_get_imm
argument_list|(
name|prev_inst
argument_list|,
name|inst
argument_list|,
literal|5
argument_list|,
literal|8
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|reg
operator|=
name|mips16_to_32_reg
index|[
operator|(
name|inst
operator|&
literal|0xe0
operator|)
operator|>>
literal|5
index|]
expr_stmt|;
name|PROC_REG_MASK
argument_list|(
operator|&
name|temp_proc_desc
argument_list|)
operator||=
operator|(
literal|1
operator|<<
name|reg
operator|)
expr_stmt|;
name|set_reg_offset
argument_list|(
name|temp_saved_regs
argument_list|,
name|reg
argument_list|,
name|sp
operator|+
name|offset
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|inst
operator|&
literal|0xff00
operator|)
operator|==
literal|0x6200
condition|)
comment|/* sw $ra,n($sp) */
block|{
name|offset
operator|=
name|mips16_get_imm
argument_list|(
name|prev_inst
argument_list|,
name|inst
argument_list|,
literal|8
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PROC_REG_MASK
argument_list|(
operator|&
name|temp_proc_desc
argument_list|)
operator||=
operator|(
literal|1
operator|<<
name|RA_REGNUM
operator|)
expr_stmt|;
name|set_reg_offset
argument_list|(
name|temp_saved_regs
argument_list|,
name|RA_REGNUM
argument_list|,
name|sp
operator|+
name|offset
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|inst
operator|&
literal|0xff00
operator|)
operator|==
literal|0xfa00
condition|)
comment|/* sd $ra,n($sp) */
block|{
name|offset
operator|=
name|mips16_get_imm
argument_list|(
name|prev_inst
argument_list|,
name|inst
argument_list|,
literal|8
argument_list|,
literal|8
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PROC_REG_MASK
argument_list|(
operator|&
name|temp_proc_desc
argument_list|)
operator||=
operator|(
literal|1
operator|<<
name|RA_REGNUM
operator|)
expr_stmt|;
name|set_reg_offset
argument_list|(
name|temp_saved_regs
argument_list|,
name|RA_REGNUM
argument_list|,
name|sp
operator|+
name|offset
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|inst
operator|==
literal|0x673d
condition|)
comment|/* move $s1, $sp */
block|{
name|frame_addr
operator|=
name|sp
expr_stmt|;
name|PROC_FRAME_REG
argument_list|(
operator|&
name|temp_proc_desc
argument_list|)
operator|=
literal|17
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|inst
operator|&
literal|0xff00
operator|)
operator|==
literal|0x0100
condition|)
comment|/* addiu $s1,sp,n */
block|{
name|offset
operator|=
name|mips16_get_imm
argument_list|(
name|prev_inst
argument_list|,
name|inst
argument_list|,
literal|8
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|frame_addr
operator|=
name|sp
operator|+
name|offset
expr_stmt|;
name|PROC_FRAME_REG
argument_list|(
operator|&
name|temp_proc_desc
argument_list|)
operator|=
literal|17
expr_stmt|;
name|PROC_FRAME_ADJUST
argument_list|(
operator|&
name|temp_proc_desc
argument_list|)
operator|=
name|offset
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|inst
operator|&
literal|0xFF00
operator|)
operator|==
literal|0xd900
condition|)
comment|/* sw reg,offset($s1) */
block|{
name|offset
operator|=
name|mips16_get_imm
argument_list|(
name|prev_inst
argument_list|,
name|inst
argument_list|,
literal|5
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|reg
operator|=
name|mips16_to_32_reg
index|[
operator|(
name|inst
operator|&
literal|0xe0
operator|)
operator|>>
literal|5
index|]
expr_stmt|;
name|PROC_REG_MASK
argument_list|(
operator|&
name|temp_proc_desc
argument_list|)
operator||=
literal|1
operator|<<
name|reg
expr_stmt|;
name|set_reg_offset
argument_list|(
name|temp_saved_regs
argument_list|,
name|reg
argument_list|,
name|frame_addr
operator|+
name|offset
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|inst
operator|&
literal|0xFF00
operator|)
operator|==
literal|0x7900
condition|)
comment|/* sd reg,offset($s1) */
block|{
name|offset
operator|=
name|mips16_get_imm
argument_list|(
name|prev_inst
argument_list|,
name|inst
argument_list|,
literal|5
argument_list|,
literal|8
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|reg
operator|=
name|mips16_to_32_reg
index|[
operator|(
name|inst
operator|&
literal|0xe0
operator|)
operator|>>
literal|5
index|]
expr_stmt|;
name|PROC_REG_MASK
argument_list|(
operator|&
name|temp_proc_desc
argument_list|)
operator||=
literal|1
operator|<<
name|reg
expr_stmt|;
name|set_reg_offset
argument_list|(
name|temp_saved_regs
argument_list|,
name|reg
argument_list|,
name|frame_addr
operator|+
name|offset
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|inst
operator|&
literal|0xf81f
operator|)
operator|==
literal|0xe809
operator|&&
operator|(
name|inst
operator|&
literal|0x700
operator|)
operator|!=
literal|0x700
condition|)
comment|/* entry */
name|entry_inst
operator|=
name|inst
expr_stmt|;
comment|/* save for later processing */
elseif|else
if|if
condition|(
operator|(
name|inst
operator|&
literal|0xf800
operator|)
operator|==
literal|0x1800
condition|)
comment|/* jal(x) */
name|cur_pc
operator|+=
name|MIPS16_INSTLEN
expr_stmt|;
comment|/* 32-bit instruction */
block|}
comment|/* The entry instruction is typically the first instruction in a function,      and it stores registers at offsets relative to the value of the old SP      (before the prologue).  But the value of the sp parameter to this      function is the new SP (after the prologue has been executed).  So we      can't calculate those offsets until we've seen the entire prologue,      and can calculate what the old SP must have been. */
if|if
condition|(
name|entry_inst
operator|!=
literal|0
condition|)
block|{
name|int
name|areg_count
init|=
operator|(
name|entry_inst
operator|>>
literal|8
operator|)
operator|&
literal|7
decl_stmt|;
name|int
name|sreg_count
init|=
operator|(
name|entry_inst
operator|>>
literal|6
operator|)
operator|&
literal|3
decl_stmt|;
comment|/* The entry instruction always subtracts 32 from the SP.  */
name|PROC_FRAME_OFFSET
argument_list|(
operator|&
name|temp_proc_desc
argument_list|)
operator|+=
literal|32
expr_stmt|;
comment|/* Now we can calculate what the SP must have been at the          start of the function prologue.  */
name|sp
operator|+=
name|PROC_FRAME_OFFSET
argument_list|(
operator|&
name|temp_proc_desc
argument_list|)
expr_stmt|;
comment|/* Check if a0-a3 were saved in the caller's argument save area.  */
for|for
control|(
name|reg
operator|=
literal|4
operator|,
name|offset
operator|=
literal|0
init|;
name|reg
operator|<
name|areg_count
operator|+
literal|4
condition|;
name|reg
operator|++
control|)
block|{
name|PROC_REG_MASK
argument_list|(
operator|&
name|temp_proc_desc
argument_list|)
operator||=
literal|1
operator|<<
name|reg
expr_stmt|;
name|set_reg_offset
argument_list|(
name|temp_saved_regs
argument_list|,
name|reg
argument_list|,
name|sp
operator|+
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|mips_saved_regsize
argument_list|(
name|tdep
argument_list|)
expr_stmt|;
block|}
comment|/* Check if the ra register was pushed on the stack.  */
name|offset
operator|=
operator|-
literal|4
expr_stmt|;
if|if
condition|(
name|entry_inst
operator|&
literal|0x20
condition|)
block|{
name|PROC_REG_MASK
argument_list|(
operator|&
name|temp_proc_desc
argument_list|)
operator||=
literal|1
operator|<<
name|RA_REGNUM
expr_stmt|;
name|set_reg_offset
argument_list|(
name|temp_saved_regs
argument_list|,
name|RA_REGNUM
argument_list|,
name|sp
operator|+
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|-=
name|mips_saved_regsize
argument_list|(
name|tdep
argument_list|)
expr_stmt|;
block|}
comment|/* Check if the s0 and s1 registers were pushed on the stack.  */
for|for
control|(
name|reg
operator|=
literal|16
init|;
name|reg
operator|<
name|sreg_count
operator|+
literal|16
condition|;
name|reg
operator|++
control|)
block|{
name|PROC_REG_MASK
argument_list|(
operator|&
name|temp_proc_desc
argument_list|)
operator||=
literal|1
operator|<<
name|reg
expr_stmt|;
name|set_reg_offset
argument_list|(
name|temp_saved_regs
argument_list|,
name|reg
argument_list|,
name|sp
operator|+
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|-=
name|mips_saved_regsize
argument_list|(
name|tdep
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mips32_heuristic_proc_desc
parameter_list|(
name|CORE_ADDR
name|start_pc
parameter_list|,
name|CORE_ADDR
name|limit_pc
parameter_list|,
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|CORE_ADDR
name|sp
parameter_list|)
block|{
name|CORE_ADDR
name|cur_pc
decl_stmt|;
name|CORE_ADDR
name|frame_addr
init|=
literal|0
decl_stmt|;
comment|/* Value of $r30. Used by gcc for frame-pointer */
name|restart
label|:
name|temp_saved_regs
operator|=
name|xrealloc
argument_list|(
name|temp_saved_regs
argument_list|,
name|SIZEOF_FRAME_SAVED_REGS
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|temp_saved_regs
argument_list|,
literal|'\0'
argument_list|,
name|SIZEOF_FRAME_SAVED_REGS
argument_list|)
expr_stmt|;
name|PROC_FRAME_OFFSET
argument_list|(
operator|&
name|temp_proc_desc
argument_list|)
operator|=
literal|0
expr_stmt|;
name|PROC_FRAME_ADJUST
argument_list|(
operator|&
name|temp_proc_desc
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* offset of FP from SP */
for|for
control|(
name|cur_pc
operator|=
name|start_pc
init|;
name|cur_pc
operator|<
name|limit_pc
condition|;
name|cur_pc
operator|+=
name|MIPS_INSTLEN
control|)
block|{
name|unsigned
name|long
name|inst
decl_stmt|,
name|high_word
decl_stmt|,
name|low_word
decl_stmt|;
name|int
name|reg
decl_stmt|;
comment|/* Fetch the instruction.   */
name|inst
operator|=
operator|(
name|unsigned
name|long
operator|)
name|mips_fetch_instruction
argument_list|(
name|cur_pc
argument_list|)
expr_stmt|;
comment|/* Save some code by pre-extracting some useful fields.  */
name|high_word
operator|=
operator|(
name|inst
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
expr_stmt|;
name|low_word
operator|=
name|inst
operator|&
literal|0xffff
expr_stmt|;
name|reg
operator|=
name|high_word
operator|&
literal|0x1f
expr_stmt|;
if|if
condition|(
name|high_word
operator|==
literal|0x27bd
comment|/* addiu $sp,$sp,-i */
operator|||
name|high_word
operator|==
literal|0x23bd
comment|/* addi $sp,$sp,-i */
operator|||
name|high_word
operator|==
literal|0x67bd
condition|)
comment|/* daddiu $sp,$sp,-i */
block|{
if|if
condition|(
name|low_word
operator|&
literal|0x8000
condition|)
comment|/* negative stack adjustment? */
name|PROC_FRAME_OFFSET
argument_list|(
operator|&
name|temp_proc_desc
argument_list|)
operator|+=
literal|0x10000
operator|-
name|low_word
expr_stmt|;
else|else
comment|/* Exit loop if a positive stack adjustment is found, which 	       usually means that the stack cleanup code in the function 	       epilogue is reached.  */
break|break;
block|}
elseif|else
if|if
condition|(
operator|(
name|high_word
operator|&
literal|0xFFE0
operator|)
operator|==
literal|0xafa0
condition|)
comment|/* sw reg,offset($sp) */
block|{
name|PROC_REG_MASK
argument_list|(
operator|&
name|temp_proc_desc
argument_list|)
operator||=
literal|1
operator|<<
name|reg
expr_stmt|;
name|set_reg_offset
argument_list|(
name|temp_saved_regs
argument_list|,
name|reg
argument_list|,
name|sp
operator|+
name|low_word
argument_list|)
expr_stmt|;
comment|/* Do we have registers offset yet? */
if|if
condition|(
operator|!
name|PROC_REG_OFFSET
argument_list|(
operator|&
name|temp_proc_desc
argument_list|)
condition|)
name|PROC_REG_OFFSET
argument_list|(
operator|&
name|temp_proc_desc
argument_list|)
operator|=
name|low_word
operator|-
name|PROC_FRAME_OFFSET
argument_list|(
operator|&
name|temp_proc_desc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|high_word
operator|&
literal|0xFFE0
operator|)
operator|==
literal|0xffa0
condition|)
comment|/* sd reg,offset($sp) */
block|{
name|PROC_REG_MASK
argument_list|(
operator|&
name|temp_proc_desc
argument_list|)
operator||=
literal|1
operator|<<
name|reg
expr_stmt|;
name|set_reg_offset
argument_list|(
name|temp_saved_regs
argument_list|,
name|reg
argument_list|,
name|sp
operator|+
name|low_word
argument_list|)
expr_stmt|;
comment|/* Do we have registers offset yet? */
if|if
condition|(
operator|!
name|PROC_REG_OFFSET
argument_list|(
operator|&
name|temp_proc_desc
argument_list|)
condition|)
name|PROC_REG_OFFSET
argument_list|(
operator|&
name|temp_proc_desc
argument_list|)
operator|=
name|low_word
operator|-
name|PROC_FRAME_OFFSET
argument_list|(
operator|&
name|temp_proc_desc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|high_word
operator|==
literal|0x27be
condition|)
comment|/* addiu $30,$sp,size */
block|{
comment|/* Old gcc frame, r30 is virtual frame pointer.  */
if|if
condition|(
operator|(
name|long
operator|)
name|low_word
operator|!=
name|PROC_FRAME_OFFSET
argument_list|(
operator|&
name|temp_proc_desc
argument_list|)
condition|)
name|frame_addr
operator|=
name|sp
operator|+
name|low_word
expr_stmt|;
elseif|else
if|if
condition|(
name|PROC_FRAME_REG
argument_list|(
operator|&
name|temp_proc_desc
argument_list|)
operator|==
name|SP_REGNUM
condition|)
block|{
name|unsigned
name|alloca_adjust
decl_stmt|;
name|PROC_FRAME_REG
argument_list|(
operator|&
name|temp_proc_desc
argument_list|)
operator|=
literal|30
expr_stmt|;
name|frame_addr
operator|=
name|read_next_frame_reg
argument_list|(
name|next_frame
argument_list|,
name|NUM_REGS
operator|+
literal|30
argument_list|)
expr_stmt|;
name|alloca_adjust
operator|=
call|(
name|unsigned
call|)
argument_list|(
name|frame_addr
operator|-
operator|(
name|sp
operator|+
name|low_word
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|alloca_adjust
operator|>
literal|0
condition|)
block|{
comment|/* FP> SP + frame_size. This may be because 		   * of an alloca or somethings similar. 		   * Fix sp to "pre-alloca" value, and try again. 		   */
name|sp
operator|+=
name|alloca_adjust
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
block|}
block|}
comment|/* move $30,$sp.  With different versions of gas this will be either          `addu $30,$sp,$zero' or `or $30,$sp,$zero' or `daddu 30,sp,$0'.          Accept any one of these.  */
elseif|else
if|if
condition|(
name|inst
operator|==
literal|0x03A0F021
operator|||
name|inst
operator|==
literal|0x03a0f025
operator|||
name|inst
operator|==
literal|0x03a0f02d
condition|)
block|{
comment|/* New gcc frame, virtual frame pointer is at r30 + frame_size.  */
if|if
condition|(
name|PROC_FRAME_REG
argument_list|(
operator|&
name|temp_proc_desc
argument_list|)
operator|==
name|SP_REGNUM
condition|)
block|{
name|unsigned
name|alloca_adjust
decl_stmt|;
name|PROC_FRAME_REG
argument_list|(
operator|&
name|temp_proc_desc
argument_list|)
operator|=
literal|30
expr_stmt|;
name|frame_addr
operator|=
name|read_next_frame_reg
argument_list|(
name|next_frame
argument_list|,
name|NUM_REGS
operator|+
literal|30
argument_list|)
expr_stmt|;
name|alloca_adjust
operator|=
call|(
name|unsigned
call|)
argument_list|(
name|frame_addr
operator|-
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
name|alloca_adjust
operator|>
literal|0
condition|)
block|{
comment|/* FP> SP + frame_size. This may be because 		   * of an alloca or somethings similar. 		   * Fix sp to "pre-alloca" value, and try again. 		   */
name|sp
operator|+=
name|alloca_adjust
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|high_word
operator|&
literal|0xFFE0
operator|)
operator|==
literal|0xafc0
condition|)
comment|/* sw reg,offset($30) */
block|{
name|PROC_REG_MASK
argument_list|(
operator|&
name|temp_proc_desc
argument_list|)
operator||=
literal|1
operator|<<
name|reg
expr_stmt|;
name|set_reg_offset
argument_list|(
name|temp_saved_regs
argument_list|,
name|reg
argument_list|,
name|frame_addr
operator|+
name|low_word
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|mips_extra_func_info_t
name|heuristic_proc_desc
parameter_list|(
name|CORE_ADDR
name|start_pc
parameter_list|,
name|CORE_ADDR
name|limit_pc
parameter_list|,
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|int
name|cur_frame
parameter_list|)
block|{
name|CORE_ADDR
name|sp
decl_stmt|;
if|if
condition|(
name|cur_frame
condition|)
name|sp
operator|=
name|read_next_frame_reg
argument_list|(
name|next_frame
argument_list|,
name|NUM_REGS
operator|+
name|SP_REGNUM
argument_list|)
expr_stmt|;
else|else
name|sp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|start_pc
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
name|memset
argument_list|(
operator|&
name|temp_proc_desc
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|temp_proc_desc
argument_list|)
argument_list|)
expr_stmt|;
name|temp_saved_regs
operator|=
name|xrealloc
argument_list|(
name|temp_saved_regs
argument_list|,
name|SIZEOF_FRAME_SAVED_REGS
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|temp_saved_regs
argument_list|,
literal|'\0'
argument_list|,
name|SIZEOF_FRAME_SAVED_REGS
argument_list|)
expr_stmt|;
name|PROC_LOW_ADDR
argument_list|(
operator|&
name|temp_proc_desc
argument_list|)
operator|=
name|start_pc
expr_stmt|;
name|PROC_FRAME_REG
argument_list|(
operator|&
name|temp_proc_desc
argument_list|)
operator|=
name|SP_REGNUM
expr_stmt|;
name|PROC_PC_REG
argument_list|(
operator|&
name|temp_proc_desc
argument_list|)
operator|=
name|RA_REGNUM
expr_stmt|;
if|if
condition|(
name|start_pc
operator|+
literal|200
operator|<
name|limit_pc
condition|)
name|limit_pc
operator|=
name|start_pc
operator|+
literal|200
expr_stmt|;
if|if
condition|(
name|pc_is_mips16
argument_list|(
name|start_pc
argument_list|)
condition|)
name|mips16_heuristic_proc_desc
argument_list|(
name|start_pc
argument_list|,
name|limit_pc
argument_list|,
name|next_frame
argument_list|,
name|sp
argument_list|)
expr_stmt|;
else|else
name|mips32_heuristic_proc_desc
argument_list|(
name|start_pc
argument_list|,
name|limit_pc
argument_list|,
name|next_frame
argument_list|,
name|sp
argument_list|)
expr_stmt|;
return|return
operator|&
name|temp_proc_desc
return|;
block|}
end_function

begin_struct
struct|struct
name|mips_objfile_private
block|{
name|bfd_size_type
name|size
decl_stmt|;
name|char
modifier|*
name|contents
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Global used to communicate between non_heuristic_proc_desc and    compare_pdr_entries within qsort ().  */
end_comment

begin_decl_stmt
specifier|static
name|bfd
modifier|*
name|the_bfd
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|compare_pdr_entries
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
name|CORE_ADDR
name|lhs
init|=
name|bfd_get_32
argument_list|(
name|the_bfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|a
argument_list|)
decl_stmt|;
name|CORE_ADDR
name|rhs
init|=
name|bfd_get_32
argument_list|(
name|the_bfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|b
argument_list|)
decl_stmt|;
if|if
condition|(
name|lhs
operator|<
name|rhs
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
name|lhs
operator|==
name|rhs
condition|)
return|return
literal|0
return|;
else|else
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|mips_extra_func_info_t
name|non_heuristic_proc_desc
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|CORE_ADDR
modifier|*
name|addrptr
parameter_list|)
block|{
name|CORE_ADDR
name|startaddr
decl_stmt|;
name|mips_extra_func_info_t
name|proc_desc
decl_stmt|;
name|struct
name|block
modifier|*
name|b
init|=
name|block_for_pc
argument_list|(
name|pc
argument_list|)
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|struct
name|obj_section
modifier|*
name|sec
decl_stmt|;
name|struct
name|mips_objfile_private
modifier|*
name|priv
decl_stmt|;
if|if
condition|(
name|DEPRECATED_PC_IN_CALL_DUMMY
argument_list|(
name|pc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|NULL
return|;
name|find_pc_partial_function
argument_list|(
name|pc
argument_list|,
name|NULL
argument_list|,
operator|&
name|startaddr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|addrptr
condition|)
operator|*
name|addrptr
operator|=
name|startaddr
expr_stmt|;
name|priv
operator|=
name|NULL
expr_stmt|;
name|sec
operator|=
name|find_pc_section
argument_list|(
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|!=
name|NULL
condition|)
block|{
name|priv
operator|=
operator|(
expr|struct
name|mips_objfile_private
operator|*
operator|)
name|objfile_data
argument_list|(
name|sec
operator|->
name|objfile
argument_list|,
name|mips_pdr_data
argument_list|)
expr_stmt|;
comment|/* Search the ".pdr" section generated by GAS.  This includes most of          the information normally found in ECOFF PDRs.  */
name|the_bfd
operator|=
name|sec
operator|->
name|objfile
operator|->
name|obfd
expr_stmt|;
if|if
condition|(
name|priv
operator|==
name|NULL
operator|&&
operator|(
name|the_bfd
operator|->
name|format
operator|==
name|bfd_object
operator|&&
name|bfd_get_flavour
argument_list|(
name|the_bfd
argument_list|)
operator|==
name|bfd_target_elf_flavour
operator|&&
name|elf_elfheader
argument_list|(
name|the_bfd
argument_list|)
operator|->
name|e_ident
index|[
name|EI_CLASS
index|]
operator|==
name|ELFCLASS64
operator|)
condition|)
block|{
comment|/* Right now GAS only outputs the address as a four-byte sequence. 	     This means that we should not bother with this method on 64-bit 	     targets (until that is fixed).  */
name|priv
operator|=
name|obstack_alloc
argument_list|(
operator|&
name|sec
operator|->
name|objfile
operator|->
name|objfile_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mips_objfile_private
argument_list|)
argument_list|)
expr_stmt|;
name|priv
operator|->
name|size
operator|=
literal|0
expr_stmt|;
name|set_objfile_data
argument_list|(
name|sec
operator|->
name|objfile
argument_list|,
name|mips_pdr_data
argument_list|,
name|priv
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|priv
operator|==
name|NULL
condition|)
block|{
name|asection
modifier|*
name|bfdsec
decl_stmt|;
name|priv
operator|=
name|obstack_alloc
argument_list|(
operator|&
name|sec
operator|->
name|objfile
operator|->
name|objfile_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mips_objfile_private
argument_list|)
argument_list|)
expr_stmt|;
name|bfdsec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|sec
operator|->
name|objfile
operator|->
name|obfd
argument_list|,
literal|".pdr"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfdsec
operator|!=
name|NULL
condition|)
block|{
name|priv
operator|->
name|size
operator|=
name|bfd_section_size
argument_list|(
name|sec
operator|->
name|objfile
operator|->
name|obfd
argument_list|,
name|bfdsec
argument_list|)
expr_stmt|;
name|priv
operator|->
name|contents
operator|=
name|obstack_alloc
argument_list|(
operator|&
name|sec
operator|->
name|objfile
operator|->
name|objfile_obstack
argument_list|,
name|priv
operator|->
name|size
argument_list|)
expr_stmt|;
name|bfd_get_section_contents
argument_list|(
name|sec
operator|->
name|objfile
operator|->
name|obfd
argument_list|,
name|bfdsec
argument_list|,
name|priv
operator|->
name|contents
argument_list|,
literal|0
argument_list|,
name|priv
operator|->
name|size
argument_list|)
expr_stmt|;
comment|/* In general, the .pdr section is sorted.  However, in the 	         presence of multiple code sections (and other corner cases) 	         it can become unsorted.  Sort it so that we can use a faster 	         binary search.  */
name|qsort
argument_list|(
name|priv
operator|->
name|contents
argument_list|,
name|priv
operator|->
name|size
operator|/
literal|32
argument_list|,
literal|32
argument_list|,
name|compare_pdr_entries
argument_list|)
expr_stmt|;
block|}
else|else
name|priv
operator|->
name|size
operator|=
literal|0
expr_stmt|;
name|set_objfile_data
argument_list|(
name|sec
operator|->
name|objfile
argument_list|,
name|mips_pdr_data
argument_list|,
name|priv
argument_list|)
expr_stmt|;
block|}
name|the_bfd
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|priv
operator|->
name|size
operator|!=
literal|0
condition|)
block|{
name|int
name|low
decl_stmt|,
name|mid
decl_stmt|,
name|high
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|low
operator|=
literal|0
expr_stmt|;
name|high
operator|=
name|priv
operator|->
name|size
operator|/
literal|32
expr_stmt|;
do|do
block|{
name|CORE_ADDR
name|pdr_pc
decl_stmt|;
name|mid
operator|=
operator|(
name|low
operator|+
name|high
operator|)
operator|/
literal|2
expr_stmt|;
name|ptr
operator|=
name|priv
operator|->
name|contents
operator|+
name|mid
operator|*
literal|32
expr_stmt|;
name|pdr_pc
operator|=
name|bfd_get_signed_32
argument_list|(
name|sec
operator|->
name|objfile
operator|->
name|obfd
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|pdr_pc
operator|+=
name|ANOFFSET
argument_list|(
name|sec
operator|->
name|objfile
operator|->
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|(
name|sec
operator|->
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pdr_pc
operator|==
name|startaddr
condition|)
break|break;
if|if
condition|(
name|pdr_pc
operator|>
name|startaddr
condition|)
name|high
operator|=
name|mid
expr_stmt|;
else|else
name|low
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|low
operator|!=
name|high
condition|)
do|;
if|if
condition|(
name|low
operator|!=
name|high
condition|)
block|{
name|struct
name|symbol
modifier|*
name|sym
init|=
name|find_pc_function
argument_list|(
name|pc
argument_list|)
decl_stmt|;
comment|/* Fill in what we need of the proc_desc.  */
name|proc_desc
operator|=
operator|(
name|mips_extra_func_info_t
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|sec
operator|->
name|objfile
operator|->
name|objfile_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mips_extra_func_info
argument_list|)
argument_list|)
expr_stmt|;
name|PROC_LOW_ADDR
argument_list|(
name|proc_desc
argument_list|)
operator|=
name|startaddr
expr_stmt|;
comment|/* Only used for dummy frames.  */
name|PROC_HIGH_ADDR
argument_list|(
name|proc_desc
argument_list|)
operator|=
literal|0
expr_stmt|;
name|PROC_FRAME_OFFSET
argument_list|(
name|proc_desc
argument_list|)
operator|=
name|bfd_get_32
argument_list|(
name|sec
operator|->
name|objfile
operator|->
name|obfd
argument_list|,
name|ptr
operator|+
literal|20
argument_list|)
expr_stmt|;
name|PROC_FRAME_REG
argument_list|(
name|proc_desc
argument_list|)
operator|=
name|bfd_get_32
argument_list|(
name|sec
operator|->
name|objfile
operator|->
name|obfd
argument_list|,
name|ptr
operator|+
literal|24
argument_list|)
expr_stmt|;
name|PROC_FRAME_ADJUST
argument_list|(
name|proc_desc
argument_list|)
operator|=
literal|0
expr_stmt|;
name|PROC_REG_MASK
argument_list|(
name|proc_desc
argument_list|)
operator|=
name|bfd_get_32
argument_list|(
name|sec
operator|->
name|objfile
operator|->
name|obfd
argument_list|,
name|ptr
operator|+
literal|4
argument_list|)
expr_stmt|;
name|PROC_FREG_MASK
argument_list|(
name|proc_desc
argument_list|)
operator|=
name|bfd_get_32
argument_list|(
name|sec
operator|->
name|objfile
operator|->
name|obfd
argument_list|,
name|ptr
operator|+
literal|12
argument_list|)
expr_stmt|;
name|PROC_REG_OFFSET
argument_list|(
name|proc_desc
argument_list|)
operator|=
name|bfd_get_32
argument_list|(
name|sec
operator|->
name|objfile
operator|->
name|obfd
argument_list|,
name|ptr
operator|+
literal|8
argument_list|)
expr_stmt|;
name|PROC_FREG_OFFSET
argument_list|(
name|proc_desc
argument_list|)
operator|=
name|bfd_get_32
argument_list|(
name|sec
operator|->
name|objfile
operator|->
name|obfd
argument_list|,
name|ptr
operator|+
literal|16
argument_list|)
expr_stmt|;
name|PROC_PC_REG
argument_list|(
name|proc_desc
argument_list|)
operator|=
name|bfd_get_32
argument_list|(
name|sec
operator|->
name|objfile
operator|->
name|obfd
argument_list|,
name|ptr
operator|+
literal|28
argument_list|)
expr_stmt|;
name|proc_desc
operator|->
name|pdr
operator|.
name|isym
operator|=
operator|(
name|long
operator|)
name|sym
expr_stmt|;
return|return
name|proc_desc
return|;
block|}
block|}
block|}
if|if
condition|(
name|b
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|startaddr
operator|>
name|BLOCK_START
argument_list|(
name|b
argument_list|)
condition|)
block|{
comment|/* This is the "pathological" case referred to in a comment in          print_frame_info.  It might be better to move this check into          symbol reading.  */
return|return
name|NULL
return|;
block|}
name|sym
operator|=
name|lookup_symbol
argument_list|(
name|MIPS_EFI_SYMBOL_NAME
argument_list|,
name|b
argument_list|,
name|LABEL_DOMAIN
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* If we never found a PDR for this function in symbol reading, then      examine prologues to find the information.  */
if|if
condition|(
name|sym
condition|)
block|{
name|proc_desc
operator|=
operator|(
name|mips_extra_func_info_t
operator|)
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|PROC_FRAME_REG
argument_list|(
name|proc_desc
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
name|NULL
return|;
else|else
return|return
name|proc_desc
return|;
block|}
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|mips_extra_func_info_t
name|find_proc_desc
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|int
name|cur_frame
parameter_list|)
block|{
name|mips_extra_func_info_t
name|proc_desc
decl_stmt|;
name|CORE_ADDR
name|startaddr
init|=
literal|0
decl_stmt|;
name|proc_desc
operator|=
name|non_heuristic_proc_desc
argument_list|(
name|pc
argument_list|,
operator|&
name|startaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|proc_desc
condition|)
block|{
comment|/* IF this is the topmost frame AND        * (this proc does not have debugging information OR        * the PC is in the procedure prologue)        * THEN create a "heuristic" proc_desc (by analyzing        * the actual code) to replace the "official" proc_desc.        */
if|if
condition|(
name|next_frame
operator|==
name|NULL
condition|)
block|{
name|struct
name|symtab_and_line
name|val
decl_stmt|;
name|struct
name|symbol
modifier|*
name|proc_symbol
init|=
name|PROC_DESC_IS_DUMMY
argument_list|(
name|proc_desc
argument_list|)
condition|?
literal|0
else|:
name|PROC_SYMBOL
argument_list|(
name|proc_desc
argument_list|)
decl_stmt|;
if|if
condition|(
name|proc_symbol
condition|)
block|{
name|val
operator|=
name|find_pc_line
argument_list|(
name|BLOCK_START
argument_list|(
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|proc_symbol
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|val
operator|.
name|pc
operator|=
name|val
operator|.
name|end
condition|?
name|val
operator|.
name|end
else|:
name|pc
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|proc_symbol
operator|||
name|pc
operator|<
name|val
operator|.
name|pc
condition|)
block|{
name|mips_extra_func_info_t
name|found_heuristic
init|=
name|heuristic_proc_desc
argument_list|(
name|PROC_LOW_ADDR
argument_list|(
name|proc_desc
argument_list|)
argument_list|,
name|pc
argument_list|,
name|next_frame
argument_list|,
name|cur_frame
argument_list|)
decl_stmt|;
if|if
condition|(
name|found_heuristic
condition|)
name|proc_desc
operator|=
name|found_heuristic
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* Is linked_proc_desc_table really necessary?  It only seems to be used          by procedure call dummys.  However, the procedures being called ought          to have their own proc_descs, and even if they don't,          heuristic_proc_desc knows how to create them! */
name|struct
name|linked_proc_info
modifier|*
name|link
decl_stmt|;
for|for
control|(
name|link
operator|=
name|linked_proc_desc_table
init|;
name|link
condition|;
name|link
operator|=
name|link
operator|->
name|next
control|)
if|if
condition|(
name|PROC_LOW_ADDR
argument_list|(
operator|&
name|link
operator|->
name|info
argument_list|)
operator|<=
name|pc
operator|&&
name|PROC_HIGH_ADDR
argument_list|(
operator|&
name|link
operator|->
name|info
argument_list|)
operator|>
name|pc
condition|)
return|return
operator|&
name|link
operator|->
name|info
return|;
if|if
condition|(
name|startaddr
operator|==
literal|0
condition|)
name|startaddr
operator|=
name|heuristic_proc_start
argument_list|(
name|pc
argument_list|)
expr_stmt|;
name|proc_desc
operator|=
name|heuristic_proc_desc
argument_list|(
name|startaddr
argument_list|,
name|pc
argument_list|,
name|next_frame
argument_list|,
name|cur_frame
argument_list|)
expr_stmt|;
block|}
return|return
name|proc_desc
return|;
block|}
end_function

begin_comment
comment|/* MIPS stack frames are almost impenetrable.  When execution stops,    we basically have to look at symbol information for the function    that we stopped in, which tells us *which* register (if any) is    the base of the frame pointer, and what offset from that register    the frame itself is at.     This presents a problem when trying to examine a stack in memory    (that isn't executing at the moment), using the "frame" command.  We    don't have a PC, nor do we have any registers except SP.     This routine takes two arguments, SP and PC, and tries to make the    cached frames look as if these two arguments defined a frame on the    cache.  This allows the rest of info frame to extract the important    arguments without difficulty.  */
end_comment

begin_function
name|struct
name|frame_info
modifier|*
name|setup_arbitrary_frame
parameter_list|(
name|int
name|argc
parameter_list|,
name|CORE_ADDR
modifier|*
name|argv
parameter_list|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
name|error
argument_list|(
literal|"MIPS frame specifications require two arguments: sp and pc"
argument_list|)
expr_stmt|;
return|return
name|create_new_frame
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* According to the current ABI, should the type be passed in a    floating-point register (assuming that there is space)?  When there    is no FPU, FP are not even considered as possibile candidates for    FP registers and, consequently this returns false - forces FP    arguments into integer registers. */
end_comment

begin_function
specifier|static
name|int
name|fp_register_arg_p
parameter_list|(
name|enum
name|type_code
name|typecode
parameter_list|,
name|struct
name|type
modifier|*
name|arg_type
parameter_list|)
block|{
return|return
operator|(
operator|(
name|typecode
operator|==
name|TYPE_CODE_FLT
operator|||
operator|(
name|MIPS_EABI
operator|&&
operator|(
name|typecode
operator|==
name|TYPE_CODE_STRUCT
operator|||
name|typecode
operator|==
name|TYPE_CODE_UNION
operator|)
operator|&&
name|TYPE_NFIELDS
argument_list|(
name|arg_type
argument_list|)
operator|==
literal|1
operator|&&
name|TYPE_CODE
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|arg_type
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_FLT
operator|)
operator|)
operator|&&
name|MIPS_FPU_TYPE
operator|!=
name|MIPS_FPU_NONE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* On o32, argument passing in GPRs depends on the alignment of the type being    passed.  Return 1 if this type must be aligned to a doubleword boundary. */
end_comment

begin_function
specifier|static
name|int
name|mips_type_needs_double_align
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
name|enum
name|type_code
name|typecode
init|=
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|typecode
operator|==
name|TYPE_CODE_FLT
operator|&&
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|==
literal|8
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|typecode
operator|==
name|TYPE_CODE_STRUCT
condition|)
block|{
if|if
condition|(
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|<
literal|1
condition|)
return|return
literal|0
return|;
return|return
name|mips_type_needs_double_align
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|typecode
operator|==
name|TYPE_CODE_UNION
condition|)
block|{
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|n
operator|=
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|mips_type_needs_double_align
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Adjust the address downward (direction of stack growth) so that it    is correctly aligned for a new stack frame.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|mips_frame_align
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|CORE_ADDR
name|addr
parameter_list|)
block|{
return|return
name|align_down
argument_list|(
name|addr
argument_list|,
literal|16
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Determine how a return value is stored within the MIPS register    file, given the return type `valtype'. */
end_comment

begin_struct
struct|struct
name|return_value_word
block|{
name|int
name|len
decl_stmt|;
name|int
name|reg
decl_stmt|;
name|int
name|reg_offset
decl_stmt|;
name|int
name|buf_offset
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|return_value_location
parameter_list|(
name|struct
name|type
modifier|*
name|valtype
parameter_list|,
name|struct
name|return_value_word
modifier|*
name|hi
parameter_list|,
name|struct
name|return_value_word
modifier|*
name|lo
parameter_list|)
block|{
name|int
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|valtype
argument_list|)
decl_stmt|;
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|valtype
argument_list|)
operator|==
name|TYPE_CODE_FLT
operator|&&
operator|(
operator|(
name|MIPS_FPU_TYPE
operator|==
name|MIPS_FPU_DOUBLE
operator|&&
operator|(
name|len
operator|==
literal|4
operator|||
name|len
operator|==
literal|8
operator|)
operator|)
operator|||
operator|(
name|MIPS_FPU_TYPE
operator|==
name|MIPS_FPU_SINGLE
operator|&&
name|len
operator|==
literal|4
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|FP_REGISTER_DOUBLE
operator|&&
name|len
operator|==
literal|8
condition|)
block|{
comment|/* We need to break a 64bit float in two 32 bit halves and 	     spread them across a floating-point register pair. */
name|lo
operator|->
name|buf_offset
operator|=
name|TARGET_BYTE_ORDER
operator|==
name|BFD_ENDIAN_BIG
condition|?
literal|4
else|:
literal|0
expr_stmt|;
name|hi
operator|->
name|buf_offset
operator|=
name|TARGET_BYTE_ORDER
operator|==
name|BFD_ENDIAN_BIG
condition|?
literal|0
else|:
literal|4
expr_stmt|;
name|lo
operator|->
name|reg_offset
operator|=
operator|(
operator|(
name|TARGET_BYTE_ORDER
operator|==
name|BFD_ENDIAN_BIG
operator|&&
name|register_size
argument_list|(
name|current_gdbarch
argument_list|,
name|mips_regnum
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|fp0
argument_list|)
operator|==
literal|8
operator|)
condition|?
literal|4
else|:
literal|0
operator|)
expr_stmt|;
name|hi
operator|->
name|reg_offset
operator|=
name|lo
operator|->
name|reg_offset
expr_stmt|;
name|lo
operator|->
name|reg
operator|=
name|mips_regnum
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|fp0
operator|+
literal|0
expr_stmt|;
name|hi
operator|->
name|reg
operator|=
name|mips_regnum
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|fp0
operator|+
literal|1
expr_stmt|;
name|lo
operator|->
name|len
operator|=
literal|4
expr_stmt|;
name|hi
operator|->
name|len
operator|=
literal|4
expr_stmt|;
block|}
else|else
block|{
comment|/* The floating point value fits in a single floating-point 	     register. */
name|lo
operator|->
name|reg_offset
operator|=
operator|(
operator|(
name|TARGET_BYTE_ORDER
operator|==
name|BFD_ENDIAN_BIG
operator|&&
name|register_size
argument_list|(
name|current_gdbarch
argument_list|,
name|mips_regnum
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|fp0
argument_list|)
operator|==
literal|8
operator|&&
name|len
operator|==
literal|4
operator|)
condition|?
literal|4
else|:
literal|0
operator|)
expr_stmt|;
name|lo
operator|->
name|reg
operator|=
name|mips_regnum
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|fp0
expr_stmt|;
name|lo
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|lo
operator|->
name|buf_offset
operator|=
literal|0
expr_stmt|;
name|hi
operator|->
name|len
operator|=
literal|0
expr_stmt|;
name|hi
operator|->
name|reg_offset
operator|=
literal|0
expr_stmt|;
name|hi
operator|->
name|buf_offset
operator|=
literal|0
expr_stmt|;
name|hi
operator|->
name|reg
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Locate a result possibly spread across two registers. */
name|int
name|regnum
init|=
literal|2
decl_stmt|;
name|lo
operator|->
name|reg
operator|=
name|regnum
operator|+
literal|0
expr_stmt|;
name|hi
operator|->
name|reg
operator|=
name|regnum
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|TARGET_BYTE_ORDER
operator|==
name|BFD_ENDIAN_BIG
operator|&&
name|len
operator|<
name|mips_saved_regsize
argument_list|(
name|tdep
argument_list|)
condition|)
block|{
comment|/* "un-left-justify" the value in the low register */
name|lo
operator|->
name|reg_offset
operator|=
name|mips_saved_regsize
argument_list|(
name|tdep
argument_list|)
operator|-
name|len
expr_stmt|;
name|lo
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|hi
operator|->
name|reg_offset
operator|=
literal|0
expr_stmt|;
name|hi
operator|->
name|len
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TARGET_BYTE_ORDER
operator|==
name|BFD_ENDIAN_BIG
operator|&&
name|len
operator|>
name|mips_saved_regsize
argument_list|(
name|tdep
argument_list|)
comment|/* odd-size structs */
operator|&&
name|len
operator|<
name|mips_saved_regsize
argument_list|(
name|tdep
argument_list|)
operator|*
literal|2
operator|&&
operator|(
name|TYPE_CODE
argument_list|(
name|valtype
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
operator|||
name|TYPE_CODE
argument_list|(
name|valtype
argument_list|)
operator|==
name|TYPE_CODE_UNION
operator|)
condition|)
block|{
comment|/* "un-left-justify" the value spread across two registers. */
name|lo
operator|->
name|reg_offset
operator|=
literal|2
operator|*
name|mips_saved_regsize
argument_list|(
name|tdep
argument_list|)
operator|-
name|len
expr_stmt|;
name|lo
operator|->
name|len
operator|=
name|mips_saved_regsize
argument_list|(
name|tdep
argument_list|)
operator|-
name|lo
operator|->
name|reg_offset
expr_stmt|;
name|hi
operator|->
name|reg_offset
operator|=
literal|0
expr_stmt|;
name|hi
operator|->
name|len
operator|=
name|len
operator|-
name|lo
operator|->
name|len
expr_stmt|;
block|}
else|else
block|{
comment|/* Only perform a partial copy of the second register. */
name|lo
operator|->
name|reg_offset
operator|=
literal|0
expr_stmt|;
name|hi
operator|->
name|reg_offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|mips_saved_regsize
argument_list|(
name|tdep
argument_list|)
condition|)
block|{
name|lo
operator|->
name|len
operator|=
name|mips_saved_regsize
argument_list|(
name|tdep
argument_list|)
expr_stmt|;
name|hi
operator|->
name|len
operator|=
name|len
operator|-
name|mips_saved_regsize
argument_list|(
name|tdep
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lo
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|hi
operator|->
name|len
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TARGET_BYTE_ORDER
operator|==
name|BFD_ENDIAN_BIG
operator|&&
name|register_size
argument_list|(
name|current_gdbarch
argument_list|,
name|regnum
argument_list|)
operator|==
literal|8
operator|&&
name|mips_saved_regsize
argument_list|(
name|tdep
argument_list|)
operator|==
literal|4
condition|)
block|{
comment|/* Account for the fact that only the least-signficant part 	     of the register is being used */
name|lo
operator|->
name|reg_offset
operator|+=
literal|4
expr_stmt|;
name|hi
operator|->
name|reg_offset
operator|+=
literal|4
expr_stmt|;
block|}
name|lo
operator|->
name|buf_offset
operator|=
literal|0
expr_stmt|;
name|hi
operator|->
name|buf_offset
operator|=
name|lo
operator|->
name|len
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Should call_function allocate stack space for a struct return?  */
end_comment

begin_function
specifier|static
name|int
name|mips_eabi_use_struct_convention
parameter_list|(
name|int
name|gcc_p
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
decl_stmt|;
return|return
operator|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|>
literal|2
operator|*
name|mips_saved_regsize
argument_list|(
name|tdep
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Should call_function pass struct by reference?     For each architecture, structs are passed either by    value or by reference, depending on their size.  */
end_comment

begin_function
specifier|static
name|int
name|mips_eabi_reg_struct_has_addr
parameter_list|(
name|int
name|gcc_p
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
name|enum
name|type_code
name|typecode
init|=
name|TYPE_CODE
argument_list|(
name|check_typedef
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|check_typedef
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
decl_stmt|;
if|if
condition|(
name|typecode
operator|==
name|TYPE_CODE_STRUCT
operator|||
name|typecode
operator|==
name|TYPE_CODE_UNION
condition|)
return|return
operator|(
name|len
operator|>
name|mips_saved_regsize
argument_list|(
name|tdep
argument_list|)
operator|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|CORE_ADDR
name|mips_eabi_push_dummy_call
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|CORE_ADDR
name|func_addr
parameter_list|,
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|CORE_ADDR
name|bp_addr
parameter_list|,
name|int
name|nargs
parameter_list|,
name|struct
name|value
modifier|*
modifier|*
name|args
parameter_list|,
name|CORE_ADDR
name|sp
parameter_list|,
name|int
name|struct_return
parameter_list|,
name|CORE_ADDR
name|struct_addr
parameter_list|)
block|{
name|int
name|argreg
decl_stmt|;
name|int
name|float_argreg
decl_stmt|;
name|int
name|argnum
decl_stmt|;
name|int
name|len
init|=
literal|0
decl_stmt|;
name|int
name|stack_offset
init|=
literal|0
decl_stmt|;
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|gdbarch
argument_list|)
decl_stmt|;
comment|/* For shared libraries, "t9" needs to point at the function      address.  */
name|regcache_cooked_write_signed
argument_list|(
name|regcache
argument_list|,
name|T9_REGNUM
argument_list|,
name|func_addr
argument_list|)
expr_stmt|;
comment|/* Set the return address register to point to the entry point of      the program, where a breakpoint lies in wait.  */
name|regcache_cooked_write_signed
argument_list|(
name|regcache
argument_list|,
name|RA_REGNUM
argument_list|,
name|bp_addr
argument_list|)
expr_stmt|;
comment|/* First ensure that the stack and structure return address (if any)      are properly aligned.  The stack has to be at least 64-bit      aligned even on 32-bit machines, because doubles must be 64-bit      aligned.  For n32 and n64, stack frames need to be 128-bit      aligned, so we round to this widest known alignment.  */
name|sp
operator|=
name|align_down
argument_list|(
name|sp
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|struct_addr
operator|=
name|align_down
argument_list|(
name|struct_addr
argument_list|,
literal|16
argument_list|)
expr_stmt|;
comment|/* Now make space on the stack for the args.  We allocate more      than necessary for EABI, because the first few arguments are      passed in registers, but that's OK.  */
for|for
control|(
name|argnum
operator|=
literal|0
init|;
name|argnum
operator|<
name|nargs
condition|;
name|argnum
operator|++
control|)
name|len
operator|+=
name|align_up
argument_list|(
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|args
index|[
name|argnum
index|]
argument_list|)
argument_list|)
argument_list|,
name|mips_stack_argsize
argument_list|(
name|tdep
argument_list|)
argument_list|)
expr_stmt|;
name|sp
operator|-=
name|align_up
argument_list|(
name|len
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|mips_debug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"mips_eabi_push_dummy_call: sp=0x%s allocated %ld\n"
argument_list|,
name|paddr_nz
argument_list|(
name|sp
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|align_up
argument_list|(
name|len
argument_list|,
literal|16
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize the integer and float register pointers.  */
name|argreg
operator|=
name|A0_REGNUM
expr_stmt|;
name|float_argreg
operator|=
name|mips_fpa0_regnum
argument_list|(
name|current_gdbarch
argument_list|)
expr_stmt|;
comment|/* The struct_return pointer occupies the first parameter-passing reg.  */
if|if
condition|(
name|struct_return
condition|)
block|{
if|if
condition|(
name|mips_debug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"mips_eabi_push_dummy_call: struct_return reg=%d 0x%s\n"
argument_list|,
name|argreg
argument_list|,
name|paddr_nz
argument_list|(
name|struct_addr
argument_list|)
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|argreg
operator|++
argument_list|,
name|struct_addr
argument_list|)
expr_stmt|;
block|}
comment|/* Now load as many as possible of the first arguments into      registers, and push the rest onto the stack.  Loop thru args      from first to last.  */
for|for
control|(
name|argnum
operator|=
literal|0
init|;
name|argnum
operator|<
name|nargs
condition|;
name|argnum
operator|++
control|)
block|{
name|char
modifier|*
name|val
decl_stmt|;
name|char
name|valbuf
index|[
name|MAX_REGISTER_SIZE
index|]
decl_stmt|;
name|struct
name|value
modifier|*
name|arg
init|=
name|args
index|[
name|argnum
index|]
decl_stmt|;
name|struct
name|type
modifier|*
name|arg_type
init|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|arg_type
argument_list|)
decl_stmt|;
name|enum
name|type_code
name|typecode
init|=
name|TYPE_CODE
argument_list|(
name|arg_type
argument_list|)
decl_stmt|;
if|if
condition|(
name|mips_debug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"mips_eabi_push_dummy_call: %d len=%d type=%d"
argument_list|,
name|argnum
operator|+
literal|1
argument_list|,
name|len
argument_list|,
operator|(
name|int
operator|)
name|typecode
argument_list|)
expr_stmt|;
comment|/* The EABI passes structures that do not fit in a register by          reference.  */
if|if
condition|(
name|len
operator|>
name|mips_saved_regsize
argument_list|(
name|tdep
argument_list|)
operator|&&
operator|(
name|typecode
operator|==
name|TYPE_CODE_STRUCT
operator|||
name|typecode
operator|==
name|TYPE_CODE_UNION
operator|)
condition|)
block|{
name|store_unsigned_integer
argument_list|(
name|valbuf
argument_list|,
name|mips_saved_regsize
argument_list|(
name|tdep
argument_list|)
argument_list|,
name|VALUE_ADDRESS
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|typecode
operator|=
name|TYPE_CODE_PTR
expr_stmt|;
name|len
operator|=
name|mips_saved_regsize
argument_list|(
name|tdep
argument_list|)
expr_stmt|;
name|val
operator|=
name|valbuf
expr_stmt|;
if|if
condition|(
name|mips_debug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|" push"
argument_list|)
expr_stmt|;
block|}
else|else
name|val
operator|=
operator|(
name|char
operator|*
operator|)
name|VALUE_CONTENTS
argument_list|(
name|arg
argument_list|)
expr_stmt|;
comment|/* 32-bit ABIs always start floating point arguments in an          even-numbered floating point register.  Round the FP register          up before the check to see if there are any FP registers          left.  Non MIPS_EABI targets also pass the FP in the integer          registers so also round up normal registers.  */
if|if
condition|(
operator|!
name|FP_REGISTER_DOUBLE
operator|&&
name|fp_register_arg_p
argument_list|(
name|typecode
argument_list|,
name|arg_type
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|float_argreg
operator|&
literal|1
operator|)
condition|)
name|float_argreg
operator|++
expr_stmt|;
block|}
comment|/* Floating point arguments passed in registers have to be          treated specially.  On 32-bit architectures, doubles          are passed in register pairs; the even register gets          the low word, and the odd register gets the high word.          On non-EABI processors, the first two floating point arguments are          also copied to general registers, because MIPS16 functions          don't use float registers for arguments.  This duplication of          arguments in general registers can't hurt non-MIPS16 functions          because those registers are normally skipped.  */
comment|/* MIPS_EABI squeezes a struct that contains a single floating          point value into an FP register instead of pushing it onto the          stack.  */
if|if
condition|(
name|fp_register_arg_p
argument_list|(
name|typecode
argument_list|,
name|arg_type
argument_list|)
operator|&&
name|float_argreg
operator|<=
name|MIPS_LAST_FP_ARG_REGNUM
condition|)
block|{
if|if
condition|(
operator|!
name|FP_REGISTER_DOUBLE
operator|&&
name|len
operator|==
literal|8
condition|)
block|{
name|int
name|low_offset
init|=
name|TARGET_BYTE_ORDER
operator|==
name|BFD_ENDIAN_BIG
condition|?
literal|4
else|:
literal|0
decl_stmt|;
name|unsigned
name|long
name|regval
decl_stmt|;
comment|/* Write the low word of the double to the even register(s).  */
name|regval
operator|=
name|extract_unsigned_integer
argument_list|(
name|val
operator|+
name|low_offset
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|mips_debug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|" - fpreg=%d val=%s"
argument_list|,
name|float_argreg
argument_list|,
name|phex
argument_list|(
name|regval
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|float_argreg
operator|++
argument_list|,
name|regval
argument_list|)
expr_stmt|;
comment|/* Write the high word of the double to the odd register(s).  */
name|regval
operator|=
name|extract_unsigned_integer
argument_list|(
name|val
operator|+
literal|4
operator|-
name|low_offset
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|mips_debug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|" - fpreg=%d val=%s"
argument_list|,
name|float_argreg
argument_list|,
name|phex
argument_list|(
name|regval
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|float_argreg
operator|++
argument_list|,
name|regval
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This is a floating point value that fits entirely 	         in a single register.  */
comment|/* On 32 bit ABI's the float_argreg is further adjusted 	         above to ensure that it is even register aligned.  */
name|LONGEST
name|regval
init|=
name|extract_unsigned_integer
argument_list|(
name|val
argument_list|,
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
name|mips_debug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|" - fpreg=%d val=%s"
argument_list|,
name|float_argreg
argument_list|,
name|phex
argument_list|(
name|regval
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|float_argreg
operator|++
argument_list|,
name|regval
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Copy the argument to general registers or the stack in 	     register-sized pieces.  Large arguments are split between 	     registers and stack.  */
comment|/* Note: structs whose size is not a multiple of 	     mips_regsize() are treated specially: Irix cc passes them 	     in registers where gcc sometimes puts them on the stack. 	     For maximum compatibility, we will put them in both 	     places.  */
name|int
name|odd_sized_struct
init|=
operator|(
operator|(
name|len
operator|>
name|mips_saved_regsize
argument_list|(
name|tdep
argument_list|)
operator|)
operator|&&
operator|(
name|len
operator|%
name|mips_saved_regsize
argument_list|(
name|tdep
argument_list|)
operator|!=
literal|0
operator|)
operator|)
decl_stmt|;
comment|/* Note: Floating-point values that didn't fit into an FP 	     register are only written to memory.  */
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
comment|/* Remember if the argument was written to the stack.  */
name|int
name|stack_used_p
init|=
literal|0
decl_stmt|;
name|int
name|partial_len
init|=
operator|(
name|len
operator|<
name|mips_saved_regsize
argument_list|(
name|tdep
argument_list|)
condition|?
name|len
else|:
name|mips_saved_regsize
argument_list|(
name|tdep
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|mips_debug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|" -- partial=%d"
argument_list|,
name|partial_len
argument_list|)
expr_stmt|;
comment|/* Write this portion of the argument to the stack.  */
if|if
condition|(
name|argreg
operator|>
name|MIPS_LAST_ARG_REGNUM
operator|||
name|odd_sized_struct
operator|||
name|fp_register_arg_p
argument_list|(
name|typecode
argument_list|,
name|arg_type
argument_list|)
condition|)
block|{
comment|/* Should shorter than int integer values be 		     promoted to int before being stored? */
name|int
name|longword_offset
init|=
literal|0
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|stack_used_p
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TARGET_BYTE_ORDER
operator|==
name|BFD_ENDIAN_BIG
condition|)
block|{
if|if
condition|(
name|mips_stack_argsize
argument_list|(
name|tdep
argument_list|)
operator|==
literal|8
operator|&&
operator|(
name|typecode
operator|==
name|TYPE_CODE_INT
operator|||
name|typecode
operator|==
name|TYPE_CODE_PTR
operator|||
name|typecode
operator|==
name|TYPE_CODE_FLT
operator|)
operator|&&
name|len
operator|<=
literal|4
condition|)
name|longword_offset
operator|=
name|mips_stack_argsize
argument_list|(
name|tdep
argument_list|)
operator|-
name|len
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|typecode
operator|==
name|TYPE_CODE_STRUCT
operator|||
name|typecode
operator|==
name|TYPE_CODE_UNION
operator|)
operator|&&
operator|(
name|TYPE_LENGTH
argument_list|(
name|arg_type
argument_list|)
operator|<
name|mips_stack_argsize
argument_list|(
name|tdep
argument_list|)
operator|)
condition|)
name|longword_offset
operator|=
name|mips_stack_argsize
argument_list|(
name|tdep
argument_list|)
operator|-
name|len
expr_stmt|;
block|}
if|if
condition|(
name|mips_debug
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|" - stack_offset=0x%s"
argument_list|,
name|paddr_nz
argument_list|(
name|stack_offset
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|" longword_offset=0x%s"
argument_list|,
name|paddr_nz
argument_list|(
name|longword_offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|addr
operator|=
name|sp
operator|+
name|stack_offset
operator|+
name|longword_offset
expr_stmt|;
if|if
condition|(
name|mips_debug
condition|)
block|{
name|int
name|i
decl_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|" @0x%s "
argument_list|,
name|paddr_nz
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|partial_len
condition|;
name|i
operator|++
control|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"%02x"
argument_list|,
name|val
index|[
name|i
index|]
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
block|}
name|write_memory
argument_list|(
name|addr
argument_list|,
name|val
argument_list|,
name|partial_len
argument_list|)
expr_stmt|;
block|}
comment|/* Note!!! This is NOT an else clause.  Odd sized 	         structs may go thru BOTH paths.  Floating point 	         arguments will not.  */
comment|/* Write this portion of the argument to a general 	         purpose register.  */
if|if
condition|(
name|argreg
operator|<=
name|MIPS_LAST_ARG_REGNUM
operator|&&
operator|!
name|fp_register_arg_p
argument_list|(
name|typecode
argument_list|,
name|arg_type
argument_list|)
condition|)
block|{
name|LONGEST
name|regval
init|=
name|extract_unsigned_integer
argument_list|(
name|val
argument_list|,
name|partial_len
argument_list|)
decl_stmt|;
if|if
condition|(
name|mips_debug
condition|)
name|fprintf_filtered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|" - reg=%d val=%s"
argument_list|,
name|argreg
argument_list|,
name|phex
argument_list|(
name|regval
argument_list|,
name|mips_saved_regsize
argument_list|(
name|tdep
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|argreg
argument_list|,
name|regval
argument_list|)
expr_stmt|;
name|argreg
operator|++
expr_stmt|;
block|}
name|len
operator|-=
name|partial_len
expr_stmt|;
name|val
operator|+=
name|partial_len
expr_stmt|;
comment|/* Compute the the offset into the stack at which we 	         will copy the next parameter.  	         In the new EABI (and the NABI32), the stack_offset 	         only needs to be adjusted when it has been used.  */
if|if
condition|(
name|stack_used_p
condition|)
name|stack_offset
operator|+=
name|align_up
argument_list|(
name|partial_len
argument_list|,
name|mips_stack_argsize
argument_list|(
name|tdep
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mips_debug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|regcache_cooked_write_signed
argument_list|(
name|regcache
argument_list|,
name|SP_REGNUM
argument_list|,
name|sp
argument_list|)
expr_stmt|;
comment|/* Return adjusted stack pointer.  */
return|return
name|sp
return|;
block|}
end_function

begin_comment
comment|/* Given a return value in `regbuf' with a type `valtype', extract and    copy its value into `valbuf'. */
end_comment

begin_function
specifier|static
name|void
name|mips_eabi_extract_return_value
parameter_list|(
name|struct
name|type
modifier|*
name|valtype
parameter_list|,
name|char
name|regbuf
index|[]
parameter_list|,
name|char
modifier|*
name|valbuf
parameter_list|)
block|{
name|struct
name|return_value_word
name|lo
decl_stmt|;
name|struct
name|return_value_word
name|hi
decl_stmt|;
name|return_value_location
argument_list|(
name|valtype
argument_list|,
operator|&
name|hi
argument_list|,
operator|&
name|lo
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|valbuf
operator|+
name|lo
operator|.
name|buf_offset
argument_list|,
name|regbuf
operator|+
name|DEPRECATED_REGISTER_BYTE
argument_list|(
name|NUM_REGS
operator|+
name|lo
operator|.
name|reg
argument_list|)
operator|+
name|lo
operator|.
name|reg_offset
argument_list|,
name|lo
operator|.
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|hi
operator|.
name|len
operator|>
literal|0
condition|)
name|memcpy
argument_list|(
name|valbuf
operator|+
name|hi
operator|.
name|buf_offset
argument_list|,
name|regbuf
operator|+
name|DEPRECATED_REGISTER_BYTE
argument_list|(
name|NUM_REGS
operator|+
name|hi
operator|.
name|reg
argument_list|)
operator|+
name|hi
operator|.
name|reg_offset
argument_list|,
name|hi
operator|.
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a return value in `valbuf' with a type `valtype', write it's    value into the appropriate register. */
end_comment

begin_function
specifier|static
name|void
name|mips_eabi_store_return_value
parameter_list|(
name|struct
name|type
modifier|*
name|valtype
parameter_list|,
name|char
modifier|*
name|valbuf
parameter_list|)
block|{
name|char
name|raw_buffer
index|[
name|MAX_REGISTER_SIZE
index|]
decl_stmt|;
name|struct
name|return_value_word
name|lo
decl_stmt|;
name|struct
name|return_value_word
name|hi
decl_stmt|;
name|return_value_location
argument_list|(
name|valtype
argument_list|,
operator|&
name|hi
argument_list|,
operator|&
name|lo
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|raw_buffer
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|raw_buffer
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|raw_buffer
operator|+
name|lo
operator|.
name|reg_offset
argument_list|,
name|valbuf
operator|+
name|lo
operator|.
name|buf_offset
argument_list|,
name|lo
operator|.
name|len
argument_list|)
expr_stmt|;
name|deprecated_write_register_bytes
argument_list|(
name|DEPRECATED_REGISTER_BYTE
argument_list|(
name|lo
operator|.
name|reg
argument_list|)
argument_list|,
name|raw_buffer
argument_list|,
name|register_size
argument_list|(
name|current_gdbarch
argument_list|,
name|lo
operator|.
name|reg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hi
operator|.
name|len
operator|>
literal|0
condition|)
block|{
name|memset
argument_list|(
name|raw_buffer
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|raw_buffer
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|raw_buffer
operator|+
name|hi
operator|.
name|reg_offset
argument_list|,
name|valbuf
operator|+
name|hi
operator|.
name|buf_offset
argument_list|,
name|hi
operator|.
name|len
argument_list|)
expr_stmt|;
name|deprecated_write_register_bytes
argument_list|(
name|DEPRECATED_REGISTER_BYTE
argument_list|(
name|hi
operator|.
name|reg
argument_list|)
argument_list|,
name|raw_buffer
argument_list|,
name|register_size
argument_list|(
name|current_gdbarch
argument_list|,
name|hi
operator|.
name|reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* N32/N64 ABI stuff.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|mips_n32n64_push_dummy_call
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|CORE_ADDR
name|func_addr
parameter_list|,
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|CORE_ADDR
name|bp_addr
parameter_list|,
name|int
name|nargs
parameter_list|,
name|struct
name|value
modifier|*
modifier|*
name|args
parameter_list|,
name|CORE_ADDR
name|sp
parameter_list|,
name|int
name|struct_return
parameter_list|,
name|CORE_ADDR
name|struct_addr
parameter_list|)
block|{
name|int
name|argreg
decl_stmt|;
name|int
name|float_argreg
decl_stmt|;
name|int
name|argnum
decl_stmt|;
name|int
name|len
init|=
literal|0
decl_stmt|;
name|int
name|stack_offset
init|=
literal|0
decl_stmt|;
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|gdbarch
argument_list|)
decl_stmt|;
comment|/* For shared libraries, "t9" needs to point at the function      address.  */
name|regcache_cooked_write_signed
argument_list|(
name|regcache
argument_list|,
name|T9_REGNUM
argument_list|,
name|func_addr
argument_list|)
expr_stmt|;
comment|/* Set the return address register to point to the entry point of      the program, where a breakpoint lies in wait.  */
name|regcache_cooked_write_signed
argument_list|(
name|regcache
argument_list|,
name|RA_REGNUM
argument_list|,
name|bp_addr
argument_list|)
expr_stmt|;
comment|/* First ensure that the stack and structure return address (if any)      are properly aligned.  The stack has to be at least 64-bit      aligned even on 32-bit machines, because doubles must be 64-bit      aligned.  For n32 and n64, stack frames need to be 128-bit      aligned, so we round to this widest known alignment.  */
name|sp
operator|=
name|align_down
argument_list|(
name|sp
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|struct_addr
operator|=
name|align_down
argument_list|(
name|struct_addr
argument_list|,
literal|16
argument_list|)
expr_stmt|;
comment|/* Now make space on the stack for the args.  */
for|for
control|(
name|argnum
operator|=
literal|0
init|;
name|argnum
operator|<
name|nargs
condition|;
name|argnum
operator|++
control|)
name|len
operator|+=
name|align_up
argument_list|(
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|args
index|[
name|argnum
index|]
argument_list|)
argument_list|)
argument_list|,
name|mips_stack_argsize
argument_list|(
name|tdep
argument_list|)
argument_list|)
expr_stmt|;
name|sp
operator|-=
name|align_up
argument_list|(
name|len
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|mips_debug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"mips_n32n64_push_dummy_call: sp=0x%s allocated %ld\n"
argument_list|,
name|paddr_nz
argument_list|(
name|sp
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|align_up
argument_list|(
name|len
argument_list|,
literal|16
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize the integer and float register pointers.  */
name|argreg
operator|=
name|A0_REGNUM
expr_stmt|;
name|float_argreg
operator|=
name|mips_fpa0_regnum
argument_list|(
name|current_gdbarch
argument_list|)
expr_stmt|;
comment|/* The struct_return pointer occupies the first parameter-passing reg.  */
if|if
condition|(
name|struct_return
condition|)
block|{
if|if
condition|(
name|mips_debug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"mips_n32n64_push_dummy_call: struct_return reg=%d 0x%s\n"
argument_list|,
name|argreg
argument_list|,
name|paddr_nz
argument_list|(
name|struct_addr
argument_list|)
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|argreg
operator|++
argument_list|,
name|struct_addr
argument_list|)
expr_stmt|;
block|}
comment|/* Now load as many as possible of the first arguments into      registers, and push the rest onto the stack.  Loop thru args      from first to last.  */
for|for
control|(
name|argnum
operator|=
literal|0
init|;
name|argnum
operator|<
name|nargs
condition|;
name|argnum
operator|++
control|)
block|{
name|char
modifier|*
name|val
decl_stmt|;
name|struct
name|value
modifier|*
name|arg
init|=
name|args
index|[
name|argnum
index|]
decl_stmt|;
name|struct
name|type
modifier|*
name|arg_type
init|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|arg_type
argument_list|)
decl_stmt|;
name|enum
name|type_code
name|typecode
init|=
name|TYPE_CODE
argument_list|(
name|arg_type
argument_list|)
decl_stmt|;
if|if
condition|(
name|mips_debug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"mips_n32n64_push_dummy_call: %d len=%d type=%d"
argument_list|,
name|argnum
operator|+
literal|1
argument_list|,
name|len
argument_list|,
operator|(
name|int
operator|)
name|typecode
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
name|char
operator|*
operator|)
name|VALUE_CONTENTS
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp_register_arg_p
argument_list|(
name|typecode
argument_list|,
name|arg_type
argument_list|)
operator|&&
name|float_argreg
operator|<=
name|MIPS_LAST_FP_ARG_REGNUM
condition|)
block|{
comment|/* This is a floating point value that fits entirely 	     in a single register.  */
comment|/* On 32 bit ABI's the float_argreg is further adjusted 	     above to ensure that it is even register aligned.  */
name|LONGEST
name|regval
init|=
name|extract_unsigned_integer
argument_list|(
name|val
argument_list|,
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
name|mips_debug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|" - fpreg=%d val=%s"
argument_list|,
name|float_argreg
argument_list|,
name|phex
argument_list|(
name|regval
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|float_argreg
operator|++
argument_list|,
name|regval
argument_list|)
expr_stmt|;
if|if
condition|(
name|mips_debug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|" - reg=%d val=%s"
argument_list|,
name|argreg
argument_list|,
name|phex
argument_list|(
name|regval
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|argreg
argument_list|,
name|regval
argument_list|)
expr_stmt|;
name|argreg
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Copy the argument to general registers or the stack in 	     register-sized pieces.  Large arguments are split between 	     registers and stack.  */
comment|/* Note: structs whose size is not a multiple of 	     mips_regsize() are treated specially: Irix cc passes them 	     in registers where gcc sometimes puts them on the stack. 	     For maximum compatibility, we will put them in both 	     places.  */
name|int
name|odd_sized_struct
init|=
operator|(
operator|(
name|len
operator|>
name|mips_saved_regsize
argument_list|(
name|tdep
argument_list|)
operator|)
operator|&&
operator|(
name|len
operator|%
name|mips_saved_regsize
argument_list|(
name|tdep
argument_list|)
operator|!=
literal|0
operator|)
operator|)
decl_stmt|;
comment|/* Note: Floating-point values that didn't fit into an FP 	     register are only written to memory.  */
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
comment|/* Rememer if the argument was written to the stack.  */
name|int
name|stack_used_p
init|=
literal|0
decl_stmt|;
name|int
name|partial_len
init|=
operator|(
name|len
operator|<
name|mips_saved_regsize
argument_list|(
name|tdep
argument_list|)
condition|?
name|len
else|:
name|mips_saved_regsize
argument_list|(
name|tdep
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|mips_debug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|" -- partial=%d"
argument_list|,
name|partial_len
argument_list|)
expr_stmt|;
comment|/* Write this portion of the argument to the stack.  */
if|if
condition|(
name|argreg
operator|>
name|MIPS_LAST_ARG_REGNUM
operator|||
name|odd_sized_struct
operator|||
name|fp_register_arg_p
argument_list|(
name|typecode
argument_list|,
name|arg_type
argument_list|)
condition|)
block|{
comment|/* Should shorter than int integer values be 		     promoted to int before being stored? */
name|int
name|longword_offset
init|=
literal|0
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|stack_used_p
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TARGET_BYTE_ORDER
operator|==
name|BFD_ENDIAN_BIG
condition|)
block|{
if|if
condition|(
name|mips_stack_argsize
argument_list|(
name|tdep
argument_list|)
operator|==
literal|8
operator|&&
operator|(
name|typecode
operator|==
name|TYPE_CODE_INT
operator|||
name|typecode
operator|==
name|TYPE_CODE_PTR
operator|||
name|typecode
operator|==
name|TYPE_CODE_FLT
operator|)
operator|&&
name|len
operator|<=
literal|4
condition|)
name|longword_offset
operator|=
name|mips_stack_argsize
argument_list|(
name|tdep
argument_list|)
operator|-
name|len
expr_stmt|;
block|}
if|if
condition|(
name|mips_debug
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|" - stack_offset=0x%s"
argument_list|,
name|paddr_nz
argument_list|(
name|stack_offset
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|" longword_offset=0x%s"
argument_list|,
name|paddr_nz
argument_list|(
name|longword_offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|addr
operator|=
name|sp
operator|+
name|stack_offset
operator|+
name|longword_offset
expr_stmt|;
if|if
condition|(
name|mips_debug
condition|)
block|{
name|int
name|i
decl_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|" @0x%s "
argument_list|,
name|paddr_nz
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|partial_len
condition|;
name|i
operator|++
control|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"%02x"
argument_list|,
name|val
index|[
name|i
index|]
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
block|}
name|write_memory
argument_list|(
name|addr
argument_list|,
name|val
argument_list|,
name|partial_len
argument_list|)
expr_stmt|;
block|}
comment|/* Note!!! This is NOT an else clause.  Odd sized 	         structs may go thru BOTH paths.  Floating point 	         arguments will not.  */
comment|/* Write this portion of the argument to a general 	         purpose register.  */
if|if
condition|(
name|argreg
operator|<=
name|MIPS_LAST_ARG_REGNUM
operator|&&
operator|!
name|fp_register_arg_p
argument_list|(
name|typecode
argument_list|,
name|arg_type
argument_list|)
condition|)
block|{
name|LONGEST
name|regval
init|=
name|extract_unsigned_integer
argument_list|(
name|val
argument_list|,
name|partial_len
argument_list|)
decl_stmt|;
comment|/* A non-floating-point argument being passed in a 		     general register.  If a struct or union, and if 		     the remaining length is smaller than the register 		     size, we have to adjust the register value on 		     big endian targets.  		     It does not seem to be necessary to do the 		     same for integral types.  		     cagney/2001-07-23: gdb/179: Also, GCC, when 		     outputting LE O32 with sizeof (struct)< 		     mips_saved_regsize(), generates a left shift as 		     part of storing the argument in a register a 		     register (the left shift isn't generated when 		     sizeof (struct)>= mips_saved_regsize()).  Since 		     it is quite possible that this is GCC 		     contradicting the LE/O32 ABI, GDB has not been 		     adjusted to accommodate this.  Either someone 		     needs to demonstrate that the LE/O32 ABI 		     specifies such a left shift OR this new ABI gets 		     identified as such and GDB gets tweaked 		     accordingly.  */
if|if
condition|(
name|TARGET_BYTE_ORDER
operator|==
name|BFD_ENDIAN_BIG
operator|&&
name|partial_len
operator|<
name|mips_saved_regsize
argument_list|(
name|tdep
argument_list|)
operator|&&
operator|(
name|typecode
operator|==
name|TYPE_CODE_STRUCT
operator|||
name|typecode
operator|==
name|TYPE_CODE_UNION
operator|)
condition|)
name|regval
operator|<<=
operator|(
operator|(
name|mips_saved_regsize
argument_list|(
name|tdep
argument_list|)
operator|-
name|partial_len
operator|)
operator|*
name|TARGET_CHAR_BIT
operator|)
expr_stmt|;
if|if
condition|(
name|mips_debug
condition|)
name|fprintf_filtered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|" - reg=%d val=%s"
argument_list|,
name|argreg
argument_list|,
name|phex
argument_list|(
name|regval
argument_list|,
name|mips_saved_regsize
argument_list|(
name|tdep
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|argreg
argument_list|,
name|regval
argument_list|)
expr_stmt|;
name|argreg
operator|++
expr_stmt|;
block|}
name|len
operator|-=
name|partial_len
expr_stmt|;
name|val
operator|+=
name|partial_len
expr_stmt|;
comment|/* Compute the the offset into the stack at which we 	         will copy the next parameter.  	         In N32 (N64?), the stack_offset only needs to be 	         adjusted when it has been used.  */
if|if
condition|(
name|stack_used_p
condition|)
name|stack_offset
operator|+=
name|align_up
argument_list|(
name|partial_len
argument_list|,
name|mips_stack_argsize
argument_list|(
name|tdep
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mips_debug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|regcache_cooked_write_signed
argument_list|(
name|regcache
argument_list|,
name|SP_REGNUM
argument_list|,
name|sp
argument_list|)
expr_stmt|;
comment|/* Return adjusted stack pointer.  */
return|return
name|sp
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|return_value_convention
name|mips_n32n64_return_value
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|void
modifier|*
name|readbuf
parameter_list|,
specifier|const
name|void
modifier|*
name|writebuf
parameter_list|)
block|{
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
operator|||
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_UNION
operator|||
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_ARRAY
operator|||
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|>
literal|2
operator|*
name|mips_saved_regsize
argument_list|(
name|tdep
argument_list|)
condition|)
return|return
name|RETURN_VALUE_STRUCT_CONVENTION
return|;
elseif|else
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_FLT
operator|&&
name|tdep
operator|->
name|mips_fpu_type
operator|!=
name|MIPS_FPU_NONE
condition|)
block|{
comment|/* A floating-point value belongs in the least significant part          of FP0.  */
if|if
condition|(
name|mips_debug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Return float in $fp0\n"
argument_list|)
expr_stmt|;
name|mips_xfer_register
argument_list|(
name|regcache
argument_list|,
name|NUM_REGS
operator|+
name|mips_regnum
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|fp0
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|,
name|TARGET_BYTE_ORDER
argument_list|,
name|readbuf
argument_list|,
name|writebuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|RETURN_VALUE_REGISTER_CONVENTION
return|;
block|}
elseif|else
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
operator|&&
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|<=
literal|2
operator|&&
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|>=
literal|1
operator|&&
operator|(
operator|(
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|==
literal|1
operator|&&
operator|(
name|TYPE_CODE
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_FLT
operator|)
operator|)
operator|||
operator|(
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|==
literal|2
operator|&&
operator|(
name|TYPE_CODE
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_FLT
operator|)
operator|&&
operator|(
name|TYPE_CODE
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_FLT
operator|)
operator|)
operator|)
operator|&&
name|tdep
operator|->
name|mips_fpu_type
operator|!=
name|MIPS_FPU_NONE
condition|)
block|{
comment|/* A struct that contains one or two floats.  Each value is part          in the least significant part of their floating point          register..  */
name|int
name|regnum
decl_stmt|;
name|int
name|field
decl_stmt|;
for|for
control|(
name|field
operator|=
literal|0
operator|,
name|regnum
operator|=
name|mips_regnum
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|fp0
init|;
name|field
operator|<
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
condition|;
name|field
operator|++
operator|,
name|regnum
operator|+=
literal|2
control|)
block|{
name|int
name|offset
init|=
operator|(
name|FIELD_BITPOS
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
index|[
name|field
index|]
argument_list|)
operator|/
name|TARGET_CHAR_BIT
operator|)
decl_stmt|;
if|if
condition|(
name|mips_debug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Return float struct+%d\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|mips_xfer_register
argument_list|(
name|regcache
argument_list|,
name|NUM_REGS
operator|+
name|regnum
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|field
argument_list|)
argument_list|)
argument_list|,
name|TARGET_BYTE_ORDER
argument_list|,
name|readbuf
argument_list|,
name|writebuf
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
return|return
name|RETURN_VALUE_REGISTER_CONVENTION
return|;
block|}
elseif|else
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
operator|||
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_UNION
condition|)
block|{
comment|/* A structure or union.  Extract the left justified value,          regardless of the byte order.  I.e. DO NOT USE          mips_xfer_lower.  */
name|int
name|offset
decl_stmt|;
name|int
name|regnum
decl_stmt|;
for|for
control|(
name|offset
operator|=
literal|0
operator|,
name|regnum
operator|=
name|V0_REGNUM
init|;
name|offset
operator|<
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
condition|;
name|offset
operator|+=
name|register_size
argument_list|(
name|current_gdbarch
argument_list|,
name|regnum
argument_list|)
operator|,
name|regnum
operator|++
control|)
block|{
name|int
name|xfer
init|=
name|register_size
argument_list|(
name|current_gdbarch
argument_list|,
name|regnum
argument_list|)
decl_stmt|;
if|if
condition|(
name|offset
operator|+
name|xfer
operator|>
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
condition|)
name|xfer
operator|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|-
name|offset
expr_stmt|;
if|if
condition|(
name|mips_debug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Return struct+%d:%d in $%d\n"
argument_list|,
name|offset
argument_list|,
name|xfer
argument_list|,
name|regnum
argument_list|)
expr_stmt|;
name|mips_xfer_register
argument_list|(
name|regcache
argument_list|,
name|NUM_REGS
operator|+
name|regnum
argument_list|,
name|xfer
argument_list|,
name|BFD_ENDIAN_UNKNOWN
argument_list|,
name|readbuf
argument_list|,
name|writebuf
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
return|return
name|RETURN_VALUE_REGISTER_CONVENTION
return|;
block|}
else|else
block|{
comment|/* A scalar extract each part but least-significant-byte          justified.  */
name|int
name|offset
decl_stmt|;
name|int
name|regnum
decl_stmt|;
for|for
control|(
name|offset
operator|=
literal|0
operator|,
name|regnum
operator|=
name|V0_REGNUM
init|;
name|offset
operator|<
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
condition|;
name|offset
operator|+=
name|register_size
argument_list|(
name|current_gdbarch
argument_list|,
name|regnum
argument_list|)
operator|,
name|regnum
operator|++
control|)
block|{
name|int
name|xfer
init|=
name|register_size
argument_list|(
name|current_gdbarch
argument_list|,
name|regnum
argument_list|)
decl_stmt|;
if|if
condition|(
name|offset
operator|+
name|xfer
operator|>
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
condition|)
name|xfer
operator|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|-
name|offset
expr_stmt|;
if|if
condition|(
name|mips_debug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Return scalar+%d:%d in $%d\n"
argument_list|,
name|offset
argument_list|,
name|xfer
argument_list|,
name|regnum
argument_list|)
expr_stmt|;
name|mips_xfer_register
argument_list|(
name|regcache
argument_list|,
name|NUM_REGS
operator|+
name|regnum
argument_list|,
name|xfer
argument_list|,
name|TARGET_BYTE_ORDER
argument_list|,
name|readbuf
argument_list|,
name|writebuf
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
return|return
name|RETURN_VALUE_REGISTER_CONVENTION
return|;
block|}
block|}
end_function

begin_comment
comment|/* O32 ABI stuff.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|mips_o32_push_dummy_call
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|CORE_ADDR
name|func_addr
parameter_list|,
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|CORE_ADDR
name|bp_addr
parameter_list|,
name|int
name|nargs
parameter_list|,
name|struct
name|value
modifier|*
modifier|*
name|args
parameter_list|,
name|CORE_ADDR
name|sp
parameter_list|,
name|int
name|struct_return
parameter_list|,
name|CORE_ADDR
name|struct_addr
parameter_list|)
block|{
name|int
name|argreg
decl_stmt|;
name|int
name|float_argreg
decl_stmt|;
name|int
name|argnum
decl_stmt|;
name|int
name|len
init|=
literal|0
decl_stmt|;
name|int
name|stack_offset
init|=
literal|0
decl_stmt|;
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|gdbarch
argument_list|)
decl_stmt|;
comment|/* For shared libraries, "t9" needs to point at the function      address.  */
name|regcache_cooked_write_signed
argument_list|(
name|regcache
argument_list|,
name|T9_REGNUM
argument_list|,
name|func_addr
argument_list|)
expr_stmt|;
comment|/* Set the return address register to point to the entry point of      the program, where a breakpoint lies in wait.  */
name|regcache_cooked_write_signed
argument_list|(
name|regcache
argument_list|,
name|RA_REGNUM
argument_list|,
name|bp_addr
argument_list|)
expr_stmt|;
comment|/* First ensure that the stack and structure return address (if any)      are properly aligned.  The stack has to be at least 64-bit      aligned even on 32-bit machines, because doubles must be 64-bit      aligned.  For n32 and n64, stack frames need to be 128-bit      aligned, so we round to this widest known alignment.  */
name|sp
operator|=
name|align_down
argument_list|(
name|sp
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|struct_addr
operator|=
name|align_down
argument_list|(
name|struct_addr
argument_list|,
literal|16
argument_list|)
expr_stmt|;
comment|/* Now make space on the stack for the args.  */
for|for
control|(
name|argnum
operator|=
literal|0
init|;
name|argnum
operator|<
name|nargs
condition|;
name|argnum
operator|++
control|)
name|len
operator|+=
name|align_up
argument_list|(
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|args
index|[
name|argnum
index|]
argument_list|)
argument_list|)
argument_list|,
name|mips_stack_argsize
argument_list|(
name|tdep
argument_list|)
argument_list|)
expr_stmt|;
name|sp
operator|-=
name|align_up
argument_list|(
name|len
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|mips_debug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"mips_o32_push_dummy_call: sp=0x%s allocated %ld\n"
argument_list|,
name|paddr_nz
argument_list|(
name|sp
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|align_up
argument_list|(
name|len
argument_list|,
literal|16
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize the integer and float register pointers.  */
name|argreg
operator|=
name|A0_REGNUM
expr_stmt|;
name|float_argreg
operator|=
name|mips_fpa0_regnum
argument_list|(
name|current_gdbarch
argument_list|)
expr_stmt|;
comment|/* The struct_return pointer occupies the first parameter-passing reg.  */
if|if
condition|(
name|struct_return
condition|)
block|{
if|if
condition|(
name|mips_debug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"mips_o32_push_dummy_call: struct_return reg=%d 0x%s\n"
argument_list|,
name|argreg
argument_list|,
name|paddr_nz
argument_list|(
name|struct_addr
argument_list|)
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|argreg
operator|++
argument_list|,
name|struct_addr
argument_list|)
expr_stmt|;
name|stack_offset
operator|+=
name|mips_stack_argsize
argument_list|(
name|tdep
argument_list|)
expr_stmt|;
block|}
comment|/* Now load as many as possible of the first arguments into      registers, and push the rest onto the stack.  Loop thru args      from first to last.  */
for|for
control|(
name|argnum
operator|=
literal|0
init|;
name|argnum
operator|<
name|nargs
condition|;
name|argnum
operator|++
control|)
block|{
name|char
modifier|*
name|val
decl_stmt|;
name|struct
name|value
modifier|*
name|arg
init|=
name|args
index|[
name|argnum
index|]
decl_stmt|;
name|struct
name|type
modifier|*
name|arg_type
init|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|arg_type
argument_list|)
decl_stmt|;
name|enum
name|type_code
name|typecode
init|=
name|TYPE_CODE
argument_list|(
name|arg_type
argument_list|)
decl_stmt|;
if|if
condition|(
name|mips_debug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"mips_o32_push_dummy_call: %d len=%d type=%d"
argument_list|,
name|argnum
operator|+
literal|1
argument_list|,
name|len
argument_list|,
operator|(
name|int
operator|)
name|typecode
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
name|char
operator|*
operator|)
name|VALUE_CONTENTS
argument_list|(
name|arg
argument_list|)
expr_stmt|;
comment|/* 32-bit ABIs always start floating point arguments in an          even-numbered floating point register.  Round the FP register          up before the check to see if there are any FP registers          left.  O32/O64 targets also pass the FP in the integer          registers so also round up normal registers.  */
if|if
condition|(
operator|!
name|FP_REGISTER_DOUBLE
operator|&&
name|fp_register_arg_p
argument_list|(
name|typecode
argument_list|,
name|arg_type
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|float_argreg
operator|&
literal|1
operator|)
condition|)
name|float_argreg
operator|++
expr_stmt|;
block|}
comment|/* Floating point arguments passed in registers have to be          treated specially.  On 32-bit architectures, doubles          are passed in register pairs; the even register gets          the low word, and the odd register gets the high word.          On O32/O64, the first two floating point arguments are          also copied to general registers, because MIPS16 functions          don't use float registers for arguments.  This duplication of          arguments in general registers can't hurt non-MIPS16 functions          because those registers are normally skipped.  */
if|if
condition|(
name|fp_register_arg_p
argument_list|(
name|typecode
argument_list|,
name|arg_type
argument_list|)
operator|&&
name|float_argreg
operator|<=
name|MIPS_LAST_FP_ARG_REGNUM
condition|)
block|{
if|if
condition|(
operator|!
name|FP_REGISTER_DOUBLE
operator|&&
name|len
operator|==
literal|8
condition|)
block|{
name|int
name|low_offset
init|=
name|TARGET_BYTE_ORDER
operator|==
name|BFD_ENDIAN_BIG
condition|?
literal|4
else|:
literal|0
decl_stmt|;
name|unsigned
name|long
name|regval
decl_stmt|;
comment|/* Write the low word of the double to the even register(s).  */
name|regval
operator|=
name|extract_unsigned_integer
argument_list|(
name|val
operator|+
name|low_offset
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|mips_debug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|" - fpreg=%d val=%s"
argument_list|,
name|float_argreg
argument_list|,
name|phex
argument_list|(
name|regval
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|float_argreg
operator|++
argument_list|,
name|regval
argument_list|)
expr_stmt|;
if|if
condition|(
name|mips_debug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|" - reg=%d val=%s"
argument_list|,
name|argreg
argument_list|,
name|phex
argument_list|(
name|regval
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|argreg
operator|++
argument_list|,
name|regval
argument_list|)
expr_stmt|;
comment|/* Write the high word of the double to the odd register(s).  */
name|regval
operator|=
name|extract_unsigned_integer
argument_list|(
name|val
operator|+
literal|4
operator|-
name|low_offset
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|mips_debug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|" - fpreg=%d val=%s"
argument_list|,
name|float_argreg
argument_list|,
name|phex
argument_list|(
name|regval
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|float_argreg
operator|++
argument_list|,
name|regval
argument_list|)
expr_stmt|;
if|if
condition|(
name|mips_debug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|" - reg=%d val=%s"
argument_list|,
name|argreg
argument_list|,
name|phex
argument_list|(
name|regval
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|argreg
operator|++
argument_list|,
name|regval
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This is a floating point value that fits entirely 	         in a single register.  */
comment|/* On 32 bit ABI's the float_argreg is further adjusted 	         above to ensure that it is even register aligned.  */
name|LONGEST
name|regval
init|=
name|extract_unsigned_integer
argument_list|(
name|val
argument_list|,
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
name|mips_debug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|" - fpreg=%d val=%s"
argument_list|,
name|float_argreg
argument_list|,
name|phex
argument_list|(
name|regval
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|float_argreg
operator|++
argument_list|,
name|regval
argument_list|)
expr_stmt|;
comment|/* CAGNEY: 32 bit MIPS ABI's always reserve two FP 	         registers for each argument.  The below is (my 	         guess) to ensure that the corresponding integer 	         register has reserved the same space.  */
if|if
condition|(
name|mips_debug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|" - reg=%d val=%s"
argument_list|,
name|argreg
argument_list|,
name|phex
argument_list|(
name|regval
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|argreg
argument_list|,
name|regval
argument_list|)
expr_stmt|;
name|argreg
operator|+=
name|FP_REGISTER_DOUBLE
condition|?
literal|1
else|:
literal|2
expr_stmt|;
block|}
comment|/* Reserve space for the FP register.  */
name|stack_offset
operator|+=
name|align_up
argument_list|(
name|len
argument_list|,
name|mips_stack_argsize
argument_list|(
name|tdep
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Copy the argument to general registers or the stack in 	     register-sized pieces.  Large arguments are split between 	     registers and stack.  */
comment|/* Note: structs whose size is not a multiple of 	     mips_regsize() are treated specially: Irix cc passes them 	     in registers where gcc sometimes puts them on the stack. 	     For maximum compatibility, we will put them in both 	     places.  */
name|int
name|odd_sized_struct
init|=
operator|(
operator|(
name|len
operator|>
name|mips_saved_regsize
argument_list|(
name|tdep
argument_list|)
operator|)
operator|&&
operator|(
name|len
operator|%
name|mips_saved_regsize
argument_list|(
name|tdep
argument_list|)
operator|!=
literal|0
operator|)
operator|)
decl_stmt|;
comment|/* Structures should be aligned to eight bytes (even arg registers) 	     on MIPS_ABI_O32, if their first member has double precision.  */
if|if
condition|(
name|mips_saved_regsize
argument_list|(
name|tdep
argument_list|)
operator|<
literal|8
operator|&&
name|mips_type_needs_double_align
argument_list|(
name|arg_type
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|argreg
operator|&
literal|1
operator|)
condition|)
name|argreg
operator|++
expr_stmt|;
block|}
comment|/* Note: Floating-point values that didn't fit into an FP 	     register are only written to memory.  */
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
comment|/* Remember if the argument was written to the stack.  */
name|int
name|stack_used_p
init|=
literal|0
decl_stmt|;
name|int
name|partial_len
init|=
operator|(
name|len
operator|<
name|mips_saved_regsize
argument_list|(
name|tdep
argument_list|)
condition|?
name|len
else|:
name|mips_saved_regsize
argument_list|(
name|tdep
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|mips_debug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|" -- partial=%d"
argument_list|,
name|partial_len
argument_list|)
expr_stmt|;
comment|/* Write this portion of the argument to the stack.  */
if|if
condition|(
name|argreg
operator|>
name|MIPS_LAST_ARG_REGNUM
operator|||
name|odd_sized_struct
operator|||
name|fp_register_arg_p
argument_list|(
name|typecode
argument_list|,
name|arg_type
argument_list|)
condition|)
block|{
comment|/* Should shorter than int integer values be 		     promoted to int before being stored? */
name|int
name|longword_offset
init|=
literal|0
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|stack_used_p
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TARGET_BYTE_ORDER
operator|==
name|BFD_ENDIAN_BIG
condition|)
block|{
if|if
condition|(
name|mips_stack_argsize
argument_list|(
name|tdep
argument_list|)
operator|==
literal|8
operator|&&
operator|(
name|typecode
operator|==
name|TYPE_CODE_INT
operator|||
name|typecode
operator|==
name|TYPE_CODE_PTR
operator|||
name|typecode
operator|==
name|TYPE_CODE_FLT
operator|)
operator|&&
name|len
operator|<=
literal|4
condition|)
name|longword_offset
operator|=
name|mips_stack_argsize
argument_list|(
name|tdep
argument_list|)
operator|-
name|len
expr_stmt|;
block|}
if|if
condition|(
name|mips_debug
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|" - stack_offset=0x%s"
argument_list|,
name|paddr_nz
argument_list|(
name|stack_offset
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|" longword_offset=0x%s"
argument_list|,
name|paddr_nz
argument_list|(
name|longword_offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|addr
operator|=
name|sp
operator|+
name|stack_offset
operator|+
name|longword_offset
expr_stmt|;
if|if
condition|(
name|mips_debug
condition|)
block|{
name|int
name|i
decl_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|" @0x%s "
argument_list|,
name|paddr_nz
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|partial_len
condition|;
name|i
operator|++
control|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"%02x"
argument_list|,
name|val
index|[
name|i
index|]
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
block|}
name|write_memory
argument_list|(
name|addr
argument_list|,
name|val
argument_list|,
name|partial_len
argument_list|)
expr_stmt|;
block|}
comment|/* Note!!! This is NOT an else clause.  Odd sized 	         structs may go thru BOTH paths.  Floating point 	         arguments will not.  */
comment|/* Write this portion of the argument to a general 	         purpose register.  */
if|if
condition|(
name|argreg
operator|<=
name|MIPS_LAST_ARG_REGNUM
operator|&&
operator|!
name|fp_register_arg_p
argument_list|(
name|typecode
argument_list|,
name|arg_type
argument_list|)
condition|)
block|{
name|LONGEST
name|regval
init|=
name|extract_signed_integer
argument_list|(
name|val
argument_list|,
name|partial_len
argument_list|)
decl_stmt|;
comment|/* Value may need to be sign extended, because 		     mips_regsize() != mips_saved_regsize().  */
comment|/* A non-floating-point argument being passed in a 		     general register.  If a struct or union, and if 		     the remaining length is smaller than the register 		     size, we have to adjust the register value on 		     big endian targets.  		     It does not seem to be necessary to do the 		     same for integral types.  		     Also don't do this adjustment on O64 binaries.  		     cagney/2001-07-23: gdb/179: Also, GCC, when 		     outputting LE O32 with sizeof (struct)< 		     mips_saved_regsize(), generates a left shift as 		     part of storing the argument in a register a 		     register (the left shift isn't generated when 		     sizeof (struct)>= mips_saved_regsize()).  Since 		     it is quite possible that this is GCC 		     contradicting the LE/O32 ABI, GDB has not been 		     adjusted to accommodate this.  Either someone 		     needs to demonstrate that the LE/O32 ABI 		     specifies such a left shift OR this new ABI gets 		     identified as such and GDB gets tweaked 		     accordingly.  */
if|if
condition|(
name|mips_saved_regsize
argument_list|(
name|tdep
argument_list|)
operator|<
literal|8
operator|&&
name|TARGET_BYTE_ORDER
operator|==
name|BFD_ENDIAN_BIG
operator|&&
name|partial_len
operator|<
name|mips_saved_regsize
argument_list|(
name|tdep
argument_list|)
operator|&&
operator|(
name|typecode
operator|==
name|TYPE_CODE_STRUCT
operator|||
name|typecode
operator|==
name|TYPE_CODE_UNION
operator|)
condition|)
name|regval
operator|<<=
operator|(
operator|(
name|mips_saved_regsize
argument_list|(
name|tdep
argument_list|)
operator|-
name|partial_len
operator|)
operator|*
name|TARGET_CHAR_BIT
operator|)
expr_stmt|;
if|if
condition|(
name|mips_debug
condition|)
name|fprintf_filtered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|" - reg=%d val=%s"
argument_list|,
name|argreg
argument_list|,
name|phex
argument_list|(
name|regval
argument_list|,
name|mips_saved_regsize
argument_list|(
name|tdep
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|argreg
argument_list|,
name|regval
argument_list|)
expr_stmt|;
name|argreg
operator|++
expr_stmt|;
comment|/* Prevent subsequent floating point arguments from 		     being passed in floating point registers.  */
name|float_argreg
operator|=
name|MIPS_LAST_FP_ARG_REGNUM
operator|+
literal|1
expr_stmt|;
block|}
name|len
operator|-=
name|partial_len
expr_stmt|;
name|val
operator|+=
name|partial_len
expr_stmt|;
comment|/* Compute the the offset into the stack at which we 	         will copy the next parameter.  	         In older ABIs, the caller reserved space for 	         registers that contained arguments.  This was loosely 	         refered to as their "home".  Consequently, space is 	         always allocated.  */
name|stack_offset
operator|+=
name|align_up
argument_list|(
name|partial_len
argument_list|,
name|mips_stack_argsize
argument_list|(
name|tdep
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mips_debug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|regcache_cooked_write_signed
argument_list|(
name|regcache
argument_list|,
name|SP_REGNUM
argument_list|,
name|sp
argument_list|)
expr_stmt|;
comment|/* Return adjusted stack pointer.  */
return|return
name|sp
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|return_value_convention
name|mips_o32_return_value
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|void
modifier|*
name|readbuf
parameter_list|,
specifier|const
name|void
modifier|*
name|writebuf
parameter_list|)
block|{
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
operator|||
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_UNION
operator|||
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_ARRAY
condition|)
return|return
name|RETURN_VALUE_STRUCT_CONVENTION
return|;
elseif|else
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_FLT
operator|&&
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|==
literal|4
operator|&&
name|tdep
operator|->
name|mips_fpu_type
operator|!=
name|MIPS_FPU_NONE
condition|)
block|{
comment|/* A single-precision floating-point value.  It fits in the          least significant part of FP0.  */
if|if
condition|(
name|mips_debug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Return float in $fp0\n"
argument_list|)
expr_stmt|;
name|mips_xfer_register
argument_list|(
name|regcache
argument_list|,
name|NUM_REGS
operator|+
name|mips_regnum
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|fp0
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|,
name|TARGET_BYTE_ORDER
argument_list|,
name|readbuf
argument_list|,
name|writebuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|RETURN_VALUE_REGISTER_CONVENTION
return|;
block|}
elseif|else
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_FLT
operator|&&
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|==
literal|8
operator|&&
name|tdep
operator|->
name|mips_fpu_type
operator|!=
name|MIPS_FPU_NONE
condition|)
block|{
comment|/* A double-precision floating-point value.  The most          significant part goes in FP1, and the least significant in          FP0.  */
if|if
condition|(
name|mips_debug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Return float in $fp1/$fp0\n"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TARGET_BYTE_ORDER
condition|)
block|{
case|case
name|BFD_ENDIAN_LITTLE
case|:
name|mips_xfer_register
argument_list|(
name|regcache
argument_list|,
name|NUM_REGS
operator|+
name|mips_regnum
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|fp0
operator|+
literal|0
argument_list|,
literal|4
argument_list|,
name|TARGET_BYTE_ORDER
argument_list|,
name|readbuf
argument_list|,
name|writebuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mips_xfer_register
argument_list|(
name|regcache
argument_list|,
name|NUM_REGS
operator|+
name|mips_regnum
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|fp0
operator|+
literal|1
argument_list|,
literal|4
argument_list|,
name|TARGET_BYTE_ORDER
argument_list|,
name|readbuf
argument_list|,
name|writebuf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_ENDIAN_BIG
case|:
name|mips_xfer_register
argument_list|(
name|regcache
argument_list|,
name|NUM_REGS
operator|+
name|mips_regnum
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|fp0
operator|+
literal|1
argument_list|,
literal|4
argument_list|,
name|TARGET_BYTE_ORDER
argument_list|,
name|readbuf
argument_list|,
name|writebuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mips_xfer_register
argument_list|(
name|regcache
argument_list|,
name|NUM_REGS
operator|+
name|mips_regnum
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|fp0
operator|+
literal|0
argument_list|,
literal|4
argument_list|,
name|TARGET_BYTE_ORDER
argument_list|,
name|readbuf
argument_list|,
name|writebuf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
default|default:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"bad switch"
argument_list|)
expr_stmt|;
block|}
return|return
name|RETURN_VALUE_REGISTER_CONVENTION
return|;
block|}
if|#
directive|if
literal|0
if|else if (TYPE_CODE (type) == TYPE_CODE_STRUCT&& TYPE_NFIELDS (type)<= 2&& TYPE_NFIELDS (type)>= 1&& ((TYPE_NFIELDS (type) == 1&& (TYPE_CODE (TYPE_FIELD_TYPE (type, 0)) 		    == TYPE_CODE_FLT)) 	       || (TYPE_NFIELDS (type) == 2&& (TYPE_CODE (TYPE_FIELD_TYPE (type, 0)) 		       == TYPE_CODE_FLT)&& (TYPE_CODE (TYPE_FIELD_TYPE (type, 1)) 		       == TYPE_CODE_FLT)))&& tdep->mips_fpu_type != MIPS_FPU_NONE)     {
comment|/* A struct that contains one or two floats.  Each value is part          in the least significant part of their floating point          register..  */
if|bfd_byte reg[MAX_REGISTER_SIZE];       int regnum;       int field;       for (field = 0, regnum = mips_regnum (current_gdbarch)->fp0; 	   field< TYPE_NFIELDS (type); field++, regnum += 2) 	{ 	  int offset = (FIELD_BITPOS (TYPE_FIELDS (type)[field]) 			/ TARGET_CHAR_BIT); 	  if (mips_debug) 	    fprintf_unfiltered (gdb_stderr, "Return float struct+%d\n", 				offset); 	  mips_xfer_register (regcache, NUM_REGS + regnum, 			      TYPE_LENGTH (TYPE_FIELD_TYPE (type, field)), 			      TARGET_BYTE_ORDER, readbuf, writebuf, offset); 	}       return RETURN_VALUE_REGISTER_CONVENTION;     }
endif|#
directive|endif
if|#
directive|if
literal|0
if|else if (TYPE_CODE (type) == TYPE_CODE_STRUCT 	   || TYPE_CODE (type) == TYPE_CODE_UNION)     {
comment|/* A structure or union.  Extract the left justified value,          regardless of the byte order.  I.e. DO NOT USE          mips_xfer_lower.  */
if|int offset;       int regnum;       for (offset = 0, regnum = V0_REGNUM; 	   offset< TYPE_LENGTH (type); 	   offset += register_size (current_gdbarch, regnum), regnum++) 	{ 	  int xfer = register_size (current_gdbarch, regnum); 	  if (offset + xfer> TYPE_LENGTH (type)) 	    xfer = TYPE_LENGTH (type) - offset; 	  if (mips_debug) 	    fprintf_unfiltered (gdb_stderr, "Return struct+%d:%d in $%d\n", 				offset, xfer, regnum); 	  mips_xfer_register (regcache, NUM_REGS + regnum, xfer, 			      BFD_ENDIAN_UNKNOWN, readbuf, writebuf, offset); 	}       return RETURN_VALUE_REGISTER_CONVENTION;     }
endif|#
directive|endif
else|else
block|{
comment|/* A scalar extract each part but least-significant-byte          justified.  o32 thinks registers are 4 byte, regardless of          the ISA.  mips_stack_argsize controls this.  */
name|int
name|offset
decl_stmt|;
name|int
name|regnum
decl_stmt|;
for|for
control|(
name|offset
operator|=
literal|0
operator|,
name|regnum
operator|=
name|V0_REGNUM
init|;
name|offset
operator|<
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
condition|;
name|offset
operator|+=
name|mips_stack_argsize
argument_list|(
name|tdep
argument_list|)
operator|,
name|regnum
operator|++
control|)
block|{
name|int
name|xfer
init|=
name|mips_stack_argsize
argument_list|(
name|tdep
argument_list|)
decl_stmt|;
if|if
condition|(
name|offset
operator|+
name|xfer
operator|>
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
condition|)
name|xfer
operator|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|-
name|offset
expr_stmt|;
if|if
condition|(
name|mips_debug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Return scalar+%d:%d in $%d\n"
argument_list|,
name|offset
argument_list|,
name|xfer
argument_list|,
name|regnum
argument_list|)
expr_stmt|;
name|mips_xfer_register
argument_list|(
name|regcache
argument_list|,
name|NUM_REGS
operator|+
name|regnum
argument_list|,
name|xfer
argument_list|,
name|TARGET_BYTE_ORDER
argument_list|,
name|readbuf
argument_list|,
name|writebuf
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
return|return
name|RETURN_VALUE_REGISTER_CONVENTION
return|;
block|}
block|}
end_function

begin_comment
comment|/* O64 ABI.  This is a hacked up kind of 64-bit version of the o32    ABI.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|mips_o64_push_dummy_call
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|CORE_ADDR
name|func_addr
parameter_list|,
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|CORE_ADDR
name|bp_addr
parameter_list|,
name|int
name|nargs
parameter_list|,
name|struct
name|value
modifier|*
modifier|*
name|args
parameter_list|,
name|CORE_ADDR
name|sp
parameter_list|,
name|int
name|struct_return
parameter_list|,
name|CORE_ADDR
name|struct_addr
parameter_list|)
block|{
name|int
name|argreg
decl_stmt|;
name|int
name|float_argreg
decl_stmt|;
name|int
name|argnum
decl_stmt|;
name|int
name|len
init|=
literal|0
decl_stmt|;
name|int
name|stack_offset
init|=
literal|0
decl_stmt|;
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|gdbarch
argument_list|)
decl_stmt|;
comment|/* For shared libraries, "t9" needs to point at the function      address.  */
name|regcache_cooked_write_signed
argument_list|(
name|regcache
argument_list|,
name|T9_REGNUM
argument_list|,
name|func_addr
argument_list|)
expr_stmt|;
comment|/* Set the return address register to point to the entry point of      the program, where a breakpoint lies in wait.  */
name|regcache_cooked_write_signed
argument_list|(
name|regcache
argument_list|,
name|RA_REGNUM
argument_list|,
name|bp_addr
argument_list|)
expr_stmt|;
comment|/* First ensure that the stack and structure return address (if any)      are properly aligned.  The stack has to be at least 64-bit      aligned even on 32-bit machines, because doubles must be 64-bit      aligned.  For n32 and n64, stack frames need to be 128-bit      aligned, so we round to this widest known alignment.  */
name|sp
operator|=
name|align_down
argument_list|(
name|sp
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|struct_addr
operator|=
name|align_down
argument_list|(
name|struct_addr
argument_list|,
literal|16
argument_list|)
expr_stmt|;
comment|/* Now make space on the stack for the args.  */
for|for
control|(
name|argnum
operator|=
literal|0
init|;
name|argnum
operator|<
name|nargs
condition|;
name|argnum
operator|++
control|)
name|len
operator|+=
name|align_up
argument_list|(
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|args
index|[
name|argnum
index|]
argument_list|)
argument_list|)
argument_list|,
name|mips_stack_argsize
argument_list|(
name|tdep
argument_list|)
argument_list|)
expr_stmt|;
name|sp
operator|-=
name|align_up
argument_list|(
name|len
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|mips_debug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"mips_o64_push_dummy_call: sp=0x%s allocated %ld\n"
argument_list|,
name|paddr_nz
argument_list|(
name|sp
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|align_up
argument_list|(
name|len
argument_list|,
literal|16
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize the integer and float register pointers.  */
name|argreg
operator|=
name|A0_REGNUM
expr_stmt|;
name|float_argreg
operator|=
name|mips_fpa0_regnum
argument_list|(
name|current_gdbarch
argument_list|)
expr_stmt|;
comment|/* The struct_return pointer occupies the first parameter-passing reg.  */
if|if
condition|(
name|struct_return
condition|)
block|{
if|if
condition|(
name|mips_debug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"mips_o64_push_dummy_call: struct_return reg=%d 0x%s\n"
argument_list|,
name|argreg
argument_list|,
name|paddr_nz
argument_list|(
name|struct_addr
argument_list|)
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|argreg
operator|++
argument_list|,
name|struct_addr
argument_list|)
expr_stmt|;
name|stack_offset
operator|+=
name|mips_stack_argsize
argument_list|(
name|tdep
argument_list|)
expr_stmt|;
block|}
comment|/* Now load as many as possible of the first arguments into      registers, and push the rest onto the stack.  Loop thru args      from first to last.  */
for|for
control|(
name|argnum
operator|=
literal|0
init|;
name|argnum
operator|<
name|nargs
condition|;
name|argnum
operator|++
control|)
block|{
name|char
modifier|*
name|val
decl_stmt|;
name|struct
name|value
modifier|*
name|arg
init|=
name|args
index|[
name|argnum
index|]
decl_stmt|;
name|struct
name|type
modifier|*
name|arg_type
init|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|arg_type
argument_list|)
decl_stmt|;
name|enum
name|type_code
name|typecode
init|=
name|TYPE_CODE
argument_list|(
name|arg_type
argument_list|)
decl_stmt|;
if|if
condition|(
name|mips_debug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"mips_o64_push_dummy_call: %d len=%d type=%d"
argument_list|,
name|argnum
operator|+
literal|1
argument_list|,
name|len
argument_list|,
operator|(
name|int
operator|)
name|typecode
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
name|char
operator|*
operator|)
name|VALUE_CONTENTS
argument_list|(
name|arg
argument_list|)
expr_stmt|;
comment|/* 32-bit ABIs always start floating point arguments in an          even-numbered floating point register.  Round the FP register          up before the check to see if there are any FP registers          left.  O32/O64 targets also pass the FP in the integer          registers so also round up normal registers.  */
if|if
condition|(
operator|!
name|FP_REGISTER_DOUBLE
operator|&&
name|fp_register_arg_p
argument_list|(
name|typecode
argument_list|,
name|arg_type
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|float_argreg
operator|&
literal|1
operator|)
condition|)
name|float_argreg
operator|++
expr_stmt|;
block|}
comment|/* Floating point arguments passed in registers have to be          treated specially.  On 32-bit architectures, doubles          are passed in register pairs; the even register gets          the low word, and the odd register gets the high word.          On O32/O64, the first two floating point arguments are          also copied to general registers, because MIPS16 functions          don't use float registers for arguments.  This duplication of          arguments in general registers can't hurt non-MIPS16 functions          because those registers are normally skipped.  */
if|if
condition|(
name|fp_register_arg_p
argument_list|(
name|typecode
argument_list|,
name|arg_type
argument_list|)
operator|&&
name|float_argreg
operator|<=
name|MIPS_LAST_FP_ARG_REGNUM
condition|)
block|{
if|if
condition|(
operator|!
name|FP_REGISTER_DOUBLE
operator|&&
name|len
operator|==
literal|8
condition|)
block|{
name|int
name|low_offset
init|=
name|TARGET_BYTE_ORDER
operator|==
name|BFD_ENDIAN_BIG
condition|?
literal|4
else|:
literal|0
decl_stmt|;
name|unsigned
name|long
name|regval
decl_stmt|;
comment|/* Write the low word of the double to the even register(s).  */
name|regval
operator|=
name|extract_unsigned_integer
argument_list|(
name|val
operator|+
name|low_offset
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|mips_debug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|" - fpreg=%d val=%s"
argument_list|,
name|float_argreg
argument_list|,
name|phex
argument_list|(
name|regval
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|float_argreg
operator|++
argument_list|,
name|regval
argument_list|)
expr_stmt|;
if|if
condition|(
name|mips_debug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|" - reg=%d val=%s"
argument_list|,
name|argreg
argument_list|,
name|phex
argument_list|(
name|regval
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|argreg
operator|++
argument_list|,
name|regval
argument_list|)
expr_stmt|;
comment|/* Write the high word of the double to the odd register(s).  */
name|regval
operator|=
name|extract_unsigned_integer
argument_list|(
name|val
operator|+
literal|4
operator|-
name|low_offset
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|mips_debug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|" - fpreg=%d val=%s"
argument_list|,
name|float_argreg
argument_list|,
name|phex
argument_list|(
name|regval
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|float_argreg
operator|++
argument_list|,
name|regval
argument_list|)
expr_stmt|;
if|if
condition|(
name|mips_debug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|" - reg=%d val=%s"
argument_list|,
name|argreg
argument_list|,
name|phex
argument_list|(
name|regval
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|argreg
operator|++
argument_list|,
name|regval
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This is a floating point value that fits entirely 	         in a single register.  */
comment|/* On 32 bit ABI's the float_argreg is further adjusted 	         above to ensure that it is even register aligned.  */
name|LONGEST
name|regval
init|=
name|extract_unsigned_integer
argument_list|(
name|val
argument_list|,
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
name|mips_debug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|" - fpreg=%d val=%s"
argument_list|,
name|float_argreg
argument_list|,
name|phex
argument_list|(
name|regval
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|float_argreg
operator|++
argument_list|,
name|regval
argument_list|)
expr_stmt|;
comment|/* CAGNEY: 32 bit MIPS ABI's always reserve two FP 	         registers for each argument.  The below is (my 	         guess) to ensure that the corresponding integer 	         register has reserved the same space.  */
if|if
condition|(
name|mips_debug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|" - reg=%d val=%s"
argument_list|,
name|argreg
argument_list|,
name|phex
argument_list|(
name|regval
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|argreg
argument_list|,
name|regval
argument_list|)
expr_stmt|;
name|argreg
operator|+=
name|FP_REGISTER_DOUBLE
condition|?
literal|1
else|:
literal|2
expr_stmt|;
block|}
comment|/* Reserve space for the FP register.  */
name|stack_offset
operator|+=
name|align_up
argument_list|(
name|len
argument_list|,
name|mips_stack_argsize
argument_list|(
name|tdep
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Copy the argument to general registers or the stack in 	     register-sized pieces.  Large arguments are split between 	     registers and stack.  */
comment|/* Note: structs whose size is not a multiple of 	     mips_regsize() are treated specially: Irix cc passes them 	     in registers where gcc sometimes puts them on the stack. 	     For maximum compatibility, we will put them in both 	     places.  */
name|int
name|odd_sized_struct
init|=
operator|(
operator|(
name|len
operator|>
name|mips_saved_regsize
argument_list|(
name|tdep
argument_list|)
operator|)
operator|&&
operator|(
name|len
operator|%
name|mips_saved_regsize
argument_list|(
name|tdep
argument_list|)
operator|!=
literal|0
operator|)
operator|)
decl_stmt|;
comment|/* Structures should be aligned to eight bytes (even arg registers) 	     on MIPS_ABI_O32, if their first member has double precision.  */
if|if
condition|(
name|mips_saved_regsize
argument_list|(
name|tdep
argument_list|)
operator|<
literal|8
operator|&&
name|mips_type_needs_double_align
argument_list|(
name|arg_type
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|argreg
operator|&
literal|1
operator|)
condition|)
name|argreg
operator|++
expr_stmt|;
block|}
comment|/* Note: Floating-point values that didn't fit into an FP 	     register are only written to memory.  */
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
comment|/* Remember if the argument was written to the stack.  */
name|int
name|stack_used_p
init|=
literal|0
decl_stmt|;
name|int
name|partial_len
init|=
operator|(
name|len
operator|<
name|mips_saved_regsize
argument_list|(
name|tdep
argument_list|)
condition|?
name|len
else|:
name|mips_saved_regsize
argument_list|(
name|tdep
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|mips_debug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|" -- partial=%d"
argument_list|,
name|partial_len
argument_list|)
expr_stmt|;
comment|/* Write this portion of the argument to the stack.  */
if|if
condition|(
name|argreg
operator|>
name|MIPS_LAST_ARG_REGNUM
operator|||
name|odd_sized_struct
operator|||
name|fp_register_arg_p
argument_list|(
name|typecode
argument_list|,
name|arg_type
argument_list|)
condition|)
block|{
comment|/* Should shorter than int integer values be 		     promoted to int before being stored? */
name|int
name|longword_offset
init|=
literal|0
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|stack_used_p
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TARGET_BYTE_ORDER
operator|==
name|BFD_ENDIAN_BIG
condition|)
block|{
if|if
condition|(
name|mips_stack_argsize
argument_list|(
name|tdep
argument_list|)
operator|==
literal|8
operator|&&
operator|(
name|typecode
operator|==
name|TYPE_CODE_INT
operator|||
name|typecode
operator|==
name|TYPE_CODE_PTR
operator|||
name|typecode
operator|==
name|TYPE_CODE_FLT
operator|)
operator|&&
name|len
operator|<=
literal|4
condition|)
name|longword_offset
operator|=
name|mips_stack_argsize
argument_list|(
name|tdep
argument_list|)
operator|-
name|len
expr_stmt|;
block|}
if|if
condition|(
name|mips_debug
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|" - stack_offset=0x%s"
argument_list|,
name|paddr_nz
argument_list|(
name|stack_offset
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|" longword_offset=0x%s"
argument_list|,
name|paddr_nz
argument_list|(
name|longword_offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|addr
operator|=
name|sp
operator|+
name|stack_offset
operator|+
name|longword_offset
expr_stmt|;
if|if
condition|(
name|mips_debug
condition|)
block|{
name|int
name|i
decl_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|" @0x%s "
argument_list|,
name|paddr_nz
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|partial_len
condition|;
name|i
operator|++
control|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"%02x"
argument_list|,
name|val
index|[
name|i
index|]
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
block|}
name|write_memory
argument_list|(
name|addr
argument_list|,
name|val
argument_list|,
name|partial_len
argument_list|)
expr_stmt|;
block|}
comment|/* Note!!! This is NOT an else clause.  Odd sized 	         structs may go thru BOTH paths.  Floating point 	         arguments will not.  */
comment|/* Write this portion of the argument to a general 	         purpose register.  */
if|if
condition|(
name|argreg
operator|<=
name|MIPS_LAST_ARG_REGNUM
operator|&&
operator|!
name|fp_register_arg_p
argument_list|(
name|typecode
argument_list|,
name|arg_type
argument_list|)
condition|)
block|{
name|LONGEST
name|regval
init|=
name|extract_signed_integer
argument_list|(
name|val
argument_list|,
name|partial_len
argument_list|)
decl_stmt|;
comment|/* Value may need to be sign extended, because 		     mips_regsize() != mips_saved_regsize().  */
comment|/* A non-floating-point argument being passed in a 		     general register.  If a struct or union, and if 		     the remaining length is smaller than the register 		     size, we have to adjust the register value on 		     big endian targets.  		     It does not seem to be necessary to do the 		     same for integral types.  		     Also don't do this adjustment on O64 binaries.  		     cagney/2001-07-23: gdb/179: Also, GCC, when 		     outputting LE O32 with sizeof (struct)< 		     mips_saved_regsize(), generates a left shift as 		     part of storing the argument in a register a 		     register (the left shift isn't generated when 		     sizeof (struct)>= mips_saved_regsize()).  Since 		     it is quite possible that this is GCC 		     contradicting the LE/O32 ABI, GDB has not been 		     adjusted to accommodate this.  Either someone 		     needs to demonstrate that the LE/O32 ABI 		     specifies such a left shift OR this new ABI gets 		     identified as such and GDB gets tweaked 		     accordingly.  */
if|if
condition|(
name|mips_saved_regsize
argument_list|(
name|tdep
argument_list|)
operator|<
literal|8
operator|&&
name|TARGET_BYTE_ORDER
operator|==
name|BFD_ENDIAN_BIG
operator|&&
name|partial_len
operator|<
name|mips_saved_regsize
argument_list|(
name|tdep
argument_list|)
operator|&&
operator|(
name|typecode
operator|==
name|TYPE_CODE_STRUCT
operator|||
name|typecode
operator|==
name|TYPE_CODE_UNION
operator|)
condition|)
name|regval
operator|<<=
operator|(
operator|(
name|mips_saved_regsize
argument_list|(
name|tdep
argument_list|)
operator|-
name|partial_len
operator|)
operator|*
name|TARGET_CHAR_BIT
operator|)
expr_stmt|;
if|if
condition|(
name|mips_debug
condition|)
name|fprintf_filtered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|" - reg=%d val=%s"
argument_list|,
name|argreg
argument_list|,
name|phex
argument_list|(
name|regval
argument_list|,
name|mips_saved_regsize
argument_list|(
name|tdep
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|argreg
argument_list|,
name|regval
argument_list|)
expr_stmt|;
name|argreg
operator|++
expr_stmt|;
comment|/* Prevent subsequent floating point arguments from 		     being passed in floating point registers.  */
name|float_argreg
operator|=
name|MIPS_LAST_FP_ARG_REGNUM
operator|+
literal|1
expr_stmt|;
block|}
name|len
operator|-=
name|partial_len
expr_stmt|;
name|val
operator|+=
name|partial_len
expr_stmt|;
comment|/* Compute the the offset into the stack at which we 	         will copy the next parameter.  	         In older ABIs, the caller reserved space for 	         registers that contained arguments.  This was loosely 	         refered to as their "home".  Consequently, space is 	         always allocated.  */
name|stack_offset
operator|+=
name|align_up
argument_list|(
name|partial_len
argument_list|,
name|mips_stack_argsize
argument_list|(
name|tdep
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mips_debug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|regcache_cooked_write_signed
argument_list|(
name|regcache
argument_list|,
name|SP_REGNUM
argument_list|,
name|sp
argument_list|)
expr_stmt|;
comment|/* Return adjusted stack pointer.  */
return|return
name|sp
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mips_o64_extract_return_value
parameter_list|(
name|struct
name|type
modifier|*
name|valtype
parameter_list|,
name|char
name|regbuf
index|[]
parameter_list|,
name|char
modifier|*
name|valbuf
parameter_list|)
block|{
name|struct
name|return_value_word
name|lo
decl_stmt|;
name|struct
name|return_value_word
name|hi
decl_stmt|;
name|return_value_location
argument_list|(
name|valtype
argument_list|,
operator|&
name|hi
argument_list|,
operator|&
name|lo
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|valbuf
operator|+
name|lo
operator|.
name|buf_offset
argument_list|,
name|regbuf
operator|+
name|DEPRECATED_REGISTER_BYTE
argument_list|(
name|NUM_REGS
operator|+
name|lo
operator|.
name|reg
argument_list|)
operator|+
name|lo
operator|.
name|reg_offset
argument_list|,
name|lo
operator|.
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|hi
operator|.
name|len
operator|>
literal|0
condition|)
name|memcpy
argument_list|(
name|valbuf
operator|+
name|hi
operator|.
name|buf_offset
argument_list|,
name|regbuf
operator|+
name|DEPRECATED_REGISTER_BYTE
argument_list|(
name|NUM_REGS
operator|+
name|hi
operator|.
name|reg
argument_list|)
operator|+
name|hi
operator|.
name|reg_offset
argument_list|,
name|hi
operator|.
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mips_o64_store_return_value
parameter_list|(
name|struct
name|type
modifier|*
name|valtype
parameter_list|,
name|char
modifier|*
name|valbuf
parameter_list|)
block|{
name|char
name|raw_buffer
index|[
name|MAX_REGISTER_SIZE
index|]
decl_stmt|;
name|struct
name|return_value_word
name|lo
decl_stmt|;
name|struct
name|return_value_word
name|hi
decl_stmt|;
name|return_value_location
argument_list|(
name|valtype
argument_list|,
operator|&
name|hi
argument_list|,
operator|&
name|lo
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|raw_buffer
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|raw_buffer
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|raw_buffer
operator|+
name|lo
operator|.
name|reg_offset
argument_list|,
name|valbuf
operator|+
name|lo
operator|.
name|buf_offset
argument_list|,
name|lo
operator|.
name|len
argument_list|)
expr_stmt|;
name|deprecated_write_register_bytes
argument_list|(
name|DEPRECATED_REGISTER_BYTE
argument_list|(
name|lo
operator|.
name|reg
argument_list|)
argument_list|,
name|raw_buffer
argument_list|,
name|register_size
argument_list|(
name|current_gdbarch
argument_list|,
name|lo
operator|.
name|reg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hi
operator|.
name|len
operator|>
literal|0
condition|)
block|{
name|memset
argument_list|(
name|raw_buffer
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|raw_buffer
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|raw_buffer
operator|+
name|hi
operator|.
name|reg_offset
argument_list|,
name|valbuf
operator|+
name|hi
operator|.
name|buf_offset
argument_list|,
name|hi
operator|.
name|len
argument_list|)
expr_stmt|;
name|deprecated_write_register_bytes
argument_list|(
name|DEPRECATED_REGISTER_BYTE
argument_list|(
name|hi
operator|.
name|reg
argument_list|)
argument_list|,
name|raw_buffer
argument_list|,
name|register_size
argument_list|(
name|current_gdbarch
argument_list|,
name|hi
operator|.
name|reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Floating point register management.     Background: MIPS1& 2 fp registers are 32 bits wide.  To support    64bit operations, these early MIPS cpus treat fp register pairs    (f0,f1) as a single register (d0).  Later MIPS cpu's have 64 bit fp    registers and offer a compatibility mode that emulates the MIPS2 fp    model.  When operating in MIPS2 fp compat mode, later cpu's split    double precision floats into two 32-bit chunks and store them in    consecutive fp regs.  To display 64-bit floats stored in this    fashion, we have to combine 32 bits from f0 and 32 bits from f1.    Throw in user-configurable endianness and you have a real mess.     The way this works is:      - If we are in 32-bit mode or on a 32-bit processor, then a 64-bit        double-precision value will be split across two logical registers.        The lower-numbered logical register will hold the low-order bits,        regardless of the processor's endianness.      - If we are on a 64-bit processor, and we are looking for a        single-precision value, it will be in the low ordered bits        of a 64-bit GPR (after mfc1, for example) or a 64-bit register        save slot in memory.      - If we are in 64-bit mode, everything is straightforward.     Note that this code only deals with "live" registers at the top of the    stack.  We will attempt to deal with saved registers later, when    the raw/cooked register interface is in place. (We need a general    interface that can deal with dynamic saved register sizes -- fp    regs could be 32 bits wide in one frame and 64 on the frame above    and below).  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|mips_float_register_type
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|TARGET_BYTE_ORDER
operator|==
name|BFD_ENDIAN_BIG
condition|)
return|return
name|builtin_type_ieee_single_big
return|;
else|else
return|return
name|builtin_type_ieee_single_little
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|type
modifier|*
name|mips_double_register_type
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|TARGET_BYTE_ORDER
operator|==
name|BFD_ENDIAN_BIG
condition|)
return|return
name|builtin_type_ieee_double_big
return|;
else|else
return|return
name|builtin_type_ieee_double_little
return|;
block|}
end_function

begin_comment
comment|/* Copy a 32-bit single-precision value from the current frame    into rare_buffer.  */
end_comment

begin_function
specifier|static
name|void
name|mips_read_fp_register_single
parameter_list|(
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|,
name|int
name|regno
parameter_list|,
name|char
modifier|*
name|rare_buffer
parameter_list|)
block|{
name|int
name|raw_size
init|=
name|register_size
argument_list|(
name|current_gdbarch
argument_list|,
name|regno
argument_list|)
decl_stmt|;
name|char
modifier|*
name|raw_buffer
init|=
name|alloca
argument_list|(
name|raw_size
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|frame_register_read
argument_list|(
name|frame
argument_list|,
name|regno
argument_list|,
name|raw_buffer
argument_list|)
condition|)
name|error
argument_list|(
literal|"can't read register %d (%s)"
argument_list|,
name|regno
argument_list|,
name|REGISTER_NAME
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|raw_size
operator|==
literal|8
condition|)
block|{
comment|/* We have a 64-bit value for this register.  Find the low-order          32 bits.  */
name|int
name|offset
decl_stmt|;
if|if
condition|(
name|TARGET_BYTE_ORDER
operator|==
name|BFD_ENDIAN_BIG
condition|)
name|offset
operator|=
literal|4
expr_stmt|;
else|else
name|offset
operator|=
literal|0
expr_stmt|;
name|memcpy
argument_list|(
name|rare_buffer
argument_list|,
name|raw_buffer
operator|+
name|offset
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|rare_buffer
argument_list|,
name|raw_buffer
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Copy a 64-bit double-precision value from the current frame into    rare_buffer.  This may include getting half of it from the next    register.  */
end_comment

begin_function
specifier|static
name|void
name|mips_read_fp_register_double
parameter_list|(
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|,
name|int
name|regno
parameter_list|,
name|char
modifier|*
name|rare_buffer
parameter_list|)
block|{
name|int
name|raw_size
init|=
name|register_size
argument_list|(
name|current_gdbarch
argument_list|,
name|regno
argument_list|)
decl_stmt|;
if|if
condition|(
name|raw_size
operator|==
literal|8
operator|&&
operator|!
name|mips2_fp_compat
argument_list|()
condition|)
block|{
comment|/* We have a 64-bit value for this register, and we should use          all 64 bits.  */
if|if
condition|(
operator|!
name|frame_register_read
argument_list|(
name|frame
argument_list|,
name|regno
argument_list|,
name|rare_buffer
argument_list|)
condition|)
name|error
argument_list|(
literal|"can't read register %d (%s)"
argument_list|,
name|regno
argument_list|,
name|REGISTER_NAME
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|regno
operator|-
name|mips_regnum
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|fp0
operator|)
operator|&
literal|1
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"mips_read_fp_register_double: bad access to "
literal|"odd-numbered FP register"
argument_list|)
expr_stmt|;
comment|/* mips_read_fp_register_single will find the correct 32 bits from          each register.  */
if|if
condition|(
name|TARGET_BYTE_ORDER
operator|==
name|BFD_ENDIAN_BIG
condition|)
block|{
name|mips_read_fp_register_single
argument_list|(
name|frame
argument_list|,
name|regno
argument_list|,
name|rare_buffer
operator|+
literal|4
argument_list|)
expr_stmt|;
name|mips_read_fp_register_single
argument_list|(
name|frame
argument_list|,
name|regno
operator|+
literal|1
argument_list|,
name|rare_buffer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mips_read_fp_register_single
argument_list|(
name|frame
argument_list|,
name|regno
argument_list|,
name|rare_buffer
argument_list|)
expr_stmt|;
name|mips_read_fp_register_single
argument_list|(
name|frame
argument_list|,
name|regno
operator|+
literal|1
argument_list|,
name|rare_buffer
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mips_print_fp_register
parameter_list|(
name|struct
name|ui_file
modifier|*
name|file
parameter_list|,
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|,
name|int
name|regnum
parameter_list|)
block|{
comment|/* do values for FP (float) regs */
name|char
modifier|*
name|raw_buffer
decl_stmt|;
name|double
name|doub
decl_stmt|,
name|flt1
decl_stmt|;
comment|/* doubles extracted from raw hex data */
name|int
name|inv1
decl_stmt|,
name|inv2
decl_stmt|;
name|raw_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|2
operator|*
name|register_size
argument_list|(
name|current_gdbarch
argument_list|,
name|mips_regnum
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|fp0
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|file
argument_list|,
literal|"%s:"
argument_list|,
name|REGISTER_NAME
argument_list|(
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|file
argument_list|,
literal|"%*s"
argument_list|,
literal|4
operator|-
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|REGISTER_NAME
argument_list|(
name|regnum
argument_list|)
argument_list|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|register_size
argument_list|(
name|current_gdbarch
argument_list|,
name|regnum
argument_list|)
operator|==
literal|4
operator|||
name|mips2_fp_compat
argument_list|()
condition|)
block|{
comment|/* 4-byte registers: Print hex and floating.  Also print even          numbered registers as doubles.  */
name|mips_read_fp_register_single
argument_list|(
name|frame
argument_list|,
name|regnum
argument_list|,
name|raw_buffer
argument_list|)
expr_stmt|;
name|flt1
operator|=
name|unpack_double
argument_list|(
name|mips_float_register_type
argument_list|()
argument_list|,
name|raw_buffer
argument_list|,
operator|&
name|inv1
argument_list|)
expr_stmt|;
name|print_scalar_formatted
argument_list|(
name|raw_buffer
argument_list|,
name|builtin_type_uint32
argument_list|,
literal|'x'
argument_list|,
literal|'w'
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|file
argument_list|,
literal|" flt: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|inv1
condition|)
name|fprintf_filtered
argument_list|(
name|file
argument_list|,
literal|"<invalid float> "
argument_list|)
expr_stmt|;
else|else
name|fprintf_filtered
argument_list|(
name|file
argument_list|,
literal|"%-17.9g"
argument_list|,
name|flt1
argument_list|)
expr_stmt|;
if|if
condition|(
name|regnum
operator|%
literal|2
operator|==
literal|0
condition|)
block|{
name|mips_read_fp_register_double
argument_list|(
name|frame
argument_list|,
name|regnum
argument_list|,
name|raw_buffer
argument_list|)
expr_stmt|;
name|doub
operator|=
name|unpack_double
argument_list|(
name|mips_double_register_type
argument_list|()
argument_list|,
name|raw_buffer
argument_list|,
operator|&
name|inv2
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|file
argument_list|,
literal|" dbl: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|inv2
condition|)
name|fprintf_filtered
argument_list|(
name|file
argument_list|,
literal|"<invalid double>"
argument_list|)
expr_stmt|;
else|else
name|fprintf_filtered
argument_list|(
name|file
argument_list|,
literal|"%-24.17g"
argument_list|,
name|doub
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Eight byte registers: print each one as hex, float and double.  */
name|mips_read_fp_register_single
argument_list|(
name|frame
argument_list|,
name|regnum
argument_list|,
name|raw_buffer
argument_list|)
expr_stmt|;
name|flt1
operator|=
name|unpack_double
argument_list|(
name|mips_float_register_type
argument_list|()
argument_list|,
name|raw_buffer
argument_list|,
operator|&
name|inv1
argument_list|)
expr_stmt|;
name|mips_read_fp_register_double
argument_list|(
name|frame
argument_list|,
name|regnum
argument_list|,
name|raw_buffer
argument_list|)
expr_stmt|;
name|doub
operator|=
name|unpack_double
argument_list|(
name|mips_double_register_type
argument_list|()
argument_list|,
name|raw_buffer
argument_list|,
operator|&
name|inv2
argument_list|)
expr_stmt|;
name|print_scalar_formatted
argument_list|(
name|raw_buffer
argument_list|,
name|builtin_type_uint64
argument_list|,
literal|'x'
argument_list|,
literal|'g'
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|file
argument_list|,
literal|" flt: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|inv1
condition|)
name|fprintf_filtered
argument_list|(
name|file
argument_list|,
literal|"<invalid float>"
argument_list|)
expr_stmt|;
else|else
name|fprintf_filtered
argument_list|(
name|file
argument_list|,
literal|"%-17.9g"
argument_list|,
name|flt1
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|file
argument_list|,
literal|" dbl: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|inv2
condition|)
name|fprintf_filtered
argument_list|(
name|file
argument_list|,
literal|"<invalid double>"
argument_list|)
expr_stmt|;
else|else
name|fprintf_filtered
argument_list|(
name|file
argument_list|,
literal|"%-24.17g"
argument_list|,
name|doub
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mips_print_register
parameter_list|(
name|struct
name|ui_file
modifier|*
name|file
parameter_list|,
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|,
name|int
name|regnum
parameter_list|,
name|int
name|all
parameter_list|)
block|{
name|struct
name|gdbarch
modifier|*
name|gdbarch
init|=
name|get_frame_arch
argument_list|(
name|frame
argument_list|)
decl_stmt|;
name|char
name|raw_buffer
index|[
name|MAX_REGISTER_SIZE
index|]
decl_stmt|;
name|int
name|offset
decl_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|gdbarch_register_type
argument_list|(
name|gdbarch
argument_list|,
name|regnum
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_FLT
condition|)
block|{
name|mips_print_fp_register
argument_list|(
name|file
argument_list|,
name|frame
argument_list|,
name|regnum
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Get the data in raw format.  */
if|if
condition|(
operator|!
name|frame_register_read
argument_list|(
name|frame
argument_list|,
name|regnum
argument_list|,
name|raw_buffer
argument_list|)
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|file
argument_list|,
literal|"%s: [Invalid]"
argument_list|,
name|REGISTER_NAME
argument_list|(
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|fputs_filtered
argument_list|(
name|REGISTER_NAME
argument_list|(
name|regnum
argument_list|)
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* The problem with printing numeric register names (r26, etc.) is that      the user can't use them on input.  Probably the best solution is to      fix it so that either the numeric or the funky (a2, etc.) names      are accepted on input.  */
if|if
condition|(
name|regnum
operator|<
name|MIPS_NUMREGS
condition|)
name|fprintf_filtered
argument_list|(
name|file
argument_list|,
literal|"(r%d): "
argument_list|,
name|regnum
argument_list|)
expr_stmt|;
else|else
name|fprintf_filtered
argument_list|(
name|file
argument_list|,
literal|": "
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_BYTE_ORDER
operator|==
name|BFD_ENDIAN_BIG
condition|)
name|offset
operator|=
name|register_size
argument_list|(
name|current_gdbarch
argument_list|,
name|regnum
argument_list|)
operator|-
name|register_size
argument_list|(
name|current_gdbarch
argument_list|,
name|regnum
argument_list|)
expr_stmt|;
else|else
name|offset
operator|=
literal|0
expr_stmt|;
name|print_scalar_formatted
argument_list|(
name|raw_buffer
operator|+
name|offset
argument_list|,
name|gdbarch_register_type
argument_list|(
name|gdbarch
argument_list|,
name|regnum
argument_list|)
argument_list|,
literal|'x'
argument_list|,
literal|0
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Replacement for generic do_registers_info.    Print regs in pretty columns.  */
end_comment

begin_function
specifier|static
name|int
name|print_fp_register_row
parameter_list|(
name|struct
name|ui_file
modifier|*
name|file
parameter_list|,
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|,
name|int
name|regnum
parameter_list|)
block|{
name|fprintf_filtered
argument_list|(
name|file
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|mips_print_fp_register
argument_list|(
name|file
argument_list|,
name|frame
argument_list|,
name|regnum
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
return|return
name|regnum
operator|+
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Print a row's worth of GP (int) registers, with name labels above */
end_comment

begin_function
specifier|static
name|int
name|print_gp_register_row
parameter_list|(
name|struct
name|ui_file
modifier|*
name|file
parameter_list|,
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|,
name|int
name|start_regnum
parameter_list|)
block|{
name|struct
name|gdbarch
modifier|*
name|gdbarch
init|=
name|get_frame_arch
argument_list|(
name|frame
argument_list|)
decl_stmt|;
comment|/* do values for GP (int) regs */
name|char
name|raw_buffer
index|[
name|MAX_REGISTER_SIZE
index|]
decl_stmt|;
name|int
name|ncols
init|=
operator|(
name|mips_regsize
argument_list|(
name|gdbarch
argument_list|)
operator|==
literal|8
condition|?
literal|4
else|:
literal|8
operator|)
decl_stmt|;
comment|/* display cols per row */
name|int
name|col
decl_stmt|,
name|byte
decl_stmt|;
name|int
name|regnum
decl_stmt|;
comment|/* For GP registers, we print a separate row of names above the vals */
name|fprintf_filtered
argument_list|(
name|file
argument_list|,
literal|"     "
argument_list|)
expr_stmt|;
for|for
control|(
name|col
operator|=
literal|0
operator|,
name|regnum
operator|=
name|start_regnum
init|;
name|col
operator|<
name|ncols
operator|&&
name|regnum
operator|<
name|NUM_REGS
operator|+
name|NUM_PSEUDO_REGS
condition|;
name|regnum
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|REGISTER_NAME
argument_list|(
name|regnum
argument_list|)
operator|==
literal|'\0'
condition|)
continue|continue;
comment|/* unused register */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|gdbarch_register_type
argument_list|(
name|gdbarch
argument_list|,
name|regnum
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_FLT
condition|)
break|break;
comment|/* end the row: reached FP register */
name|fprintf_filtered
argument_list|(
name|file
argument_list|,
name|mips_regsize
argument_list|(
name|current_gdbarch
argument_list|)
operator|==
literal|8
condition|?
literal|"%17s"
else|:
literal|"%9s"
argument_list|,
name|REGISTER_NAME
argument_list|(
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
name|col
operator|++
expr_stmt|;
block|}
comment|/* print the R0 to R31 names */
if|if
condition|(
operator|(
name|start_regnum
operator|%
name|NUM_REGS
operator|)
operator|<
name|MIPS_NUMREGS
condition|)
name|fprintf_filtered
argument_list|(
name|file
argument_list|,
literal|"\n R%-4d"
argument_list|,
name|start_regnum
operator|%
name|NUM_REGS
argument_list|)
expr_stmt|;
else|else
name|fprintf_filtered
argument_list|(
name|file
argument_list|,
literal|"\n      "
argument_list|)
expr_stmt|;
comment|/* now print the values in hex, 4 or 8 to the row */
for|for
control|(
name|col
operator|=
literal|0
operator|,
name|regnum
operator|=
name|start_regnum
init|;
name|col
operator|<
name|ncols
operator|&&
name|regnum
operator|<
name|NUM_REGS
operator|+
name|NUM_PSEUDO_REGS
condition|;
name|regnum
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|REGISTER_NAME
argument_list|(
name|regnum
argument_list|)
operator|==
literal|'\0'
condition|)
continue|continue;
comment|/* unused register */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|gdbarch_register_type
argument_list|(
name|gdbarch
argument_list|,
name|regnum
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_FLT
condition|)
break|break;
comment|/* end row: reached FP register */
comment|/* OK: get the data in raw format.  */
if|if
condition|(
operator|!
name|frame_register_read
argument_list|(
name|frame
argument_list|,
name|regnum
argument_list|,
name|raw_buffer
argument_list|)
condition|)
name|error
argument_list|(
literal|"can't read register %d (%s)"
argument_list|,
name|regnum
argument_list|,
name|REGISTER_NAME
argument_list|(
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
comment|/* pad small registers */
for|for
control|(
name|byte
operator|=
literal|0
init|;
name|byte
operator|<
operator|(
name|mips_regsize
argument_list|(
name|current_gdbarch
argument_list|)
operator|-
name|register_size
argument_list|(
name|current_gdbarch
argument_list|,
name|regnum
argument_list|)
operator|)
condition|;
name|byte
operator|++
control|)
name|printf_filtered
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
comment|/* Now print the register value in hex, endian order. */
if|if
condition|(
name|TARGET_BYTE_ORDER
operator|==
name|BFD_ENDIAN_BIG
condition|)
for|for
control|(
name|byte
operator|=
name|register_size
argument_list|(
name|current_gdbarch
argument_list|,
name|regnum
argument_list|)
operator|-
name|register_size
argument_list|(
name|current_gdbarch
argument_list|,
name|regnum
argument_list|)
init|;
name|byte
operator|<
name|register_size
argument_list|(
name|current_gdbarch
argument_list|,
name|regnum
argument_list|)
condition|;
name|byte
operator|++
control|)
name|fprintf_filtered
argument_list|(
name|file
argument_list|,
literal|"%02x"
argument_list|,
operator|(
name|unsigned
name|char
operator|)
name|raw_buffer
index|[
name|byte
index|]
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|byte
operator|=
name|register_size
argument_list|(
name|current_gdbarch
argument_list|,
name|regnum
argument_list|)
operator|-
literal|1
init|;
name|byte
operator|>=
literal|0
condition|;
name|byte
operator|--
control|)
name|fprintf_filtered
argument_list|(
name|file
argument_list|,
literal|"%02x"
argument_list|,
operator|(
name|unsigned
name|char
operator|)
name|raw_buffer
index|[
name|byte
index|]
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|file
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|col
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|col
operator|>
literal|0
condition|)
comment|/* ie. if we actually printed anything... */
name|fprintf_filtered
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
return|return
name|regnum
return|;
block|}
end_function

begin_comment
comment|/* MIPS_DO_REGISTERS_INFO(): called by "info register" command */
end_comment

begin_function
specifier|static
name|void
name|mips_print_registers_info
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|struct
name|ui_file
modifier|*
name|file
parameter_list|,
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|,
name|int
name|regnum
parameter_list|,
name|int
name|all
parameter_list|)
block|{
if|if
condition|(
name|regnum
operator|!=
operator|-
literal|1
condition|)
comment|/* do one specified register */
block|{
name|gdb_assert
argument_list|(
name|regnum
operator|>=
name|NUM_REGS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|REGISTER_NAME
argument_list|(
name|regnum
argument_list|)
operator|)
operator|==
literal|'\0'
condition|)
name|error
argument_list|(
literal|"Not a valid register for the current processor type"
argument_list|)
expr_stmt|;
name|mips_print_register
argument_list|(
name|file
argument_list|,
name|frame
argument_list|,
name|regnum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* do all (or most) registers */
block|{
name|regnum
operator|=
name|NUM_REGS
expr_stmt|;
while|while
condition|(
name|regnum
operator|<
name|NUM_REGS
operator|+
name|NUM_PSEUDO_REGS
condition|)
block|{
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|gdbarch_register_type
argument_list|(
name|gdbarch
argument_list|,
name|regnum
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_FLT
condition|)
block|{
if|if
condition|(
name|all
condition|)
comment|/* true for "INFO ALL-REGISTERS" command */
name|regnum
operator|=
name|print_fp_register_row
argument_list|(
name|file
argument_list|,
name|frame
argument_list|,
name|regnum
argument_list|)
expr_stmt|;
else|else
name|regnum
operator|+=
name|MIPS_NUMREGS
expr_stmt|;
comment|/* skip floating point regs */
block|}
else|else
name|regnum
operator|=
name|print_gp_register_row
argument_list|(
name|file
argument_list|,
name|frame
argument_list|,
name|regnum
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Is this a branch with a delay slot?  */
end_comment

begin_function_decl
specifier|static
name|int
name|is_delayed
parameter_list|(
name|unsigned
name|long
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|is_delayed
parameter_list|(
name|unsigned
name|long
name|insn
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUMOPCODES
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|mips_opcodes
index|[
name|i
index|]
operator|.
name|pinfo
operator|!=
name|INSN_MACRO
operator|&&
operator|(
name|insn
operator|&
name|mips_opcodes
index|[
name|i
index|]
operator|.
name|mask
operator|)
operator|==
name|mips_opcodes
index|[
name|i
index|]
operator|.
name|match
condition|)
break|break;
return|return
operator|(
name|i
operator|<
name|NUMOPCODES
operator|&&
operator|(
name|mips_opcodes
index|[
name|i
index|]
operator|.
name|pinfo
operator|&
operator|(
name|INSN_UNCOND_BRANCH_DELAY
operator||
name|INSN_COND_BRANCH_DELAY
operator||
name|INSN_COND_BRANCH_LIKELY
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|mips_step_skips_delay
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
name|char
name|buf
index|[
name|MIPS_INSTLEN
index|]
decl_stmt|;
comment|/* There is no branch delay slot on MIPS16.  */
if|if
condition|(
name|pc_is_mips16
argument_list|(
name|pc
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|target_read_memory
argument_list|(
name|pc
argument_list|,
name|buf
argument_list|,
name|MIPS_INSTLEN
argument_list|)
operator|!=
literal|0
condition|)
comment|/* If error reading memory, guess that it is not a delayed branch.  */
return|return
literal|0
return|;
return|return
name|is_delayed
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
name|MIPS_INSTLEN
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Skip the PC past function prologue instructions (32-bit version).    This is a helper function for mips_skip_prologue.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|mips32_skip_prologue
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
name|t_inst
name|inst
decl_stmt|;
name|CORE_ADDR
name|end_pc
decl_stmt|;
name|int
name|seen_sp_adjust
init|=
literal|0
decl_stmt|;
name|int
name|load_immediate_bytes
init|=
literal|0
decl_stmt|;
comment|/* Find an upper bound on the prologue.  */
name|end_pc
operator|=
name|skip_prologue_using_sal
argument_list|(
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|end_pc
operator|==
literal|0
condition|)
name|end_pc
operator|=
name|pc
operator|+
literal|100
expr_stmt|;
comment|/* Magic.  */
comment|/* Skip the typical prologue instructions. These are the stack adjustment      instruction and the instructions that save registers on the stack      or in the gcc frame.  */
for|for
control|(
init|;
name|pc
operator|<
name|end_pc
condition|;
name|pc
operator|+=
name|MIPS_INSTLEN
control|)
block|{
name|unsigned
name|long
name|high_word
decl_stmt|;
name|inst
operator|=
name|mips_fetch_instruction
argument_list|(
name|pc
argument_list|)
expr_stmt|;
name|high_word
operator|=
operator|(
name|inst
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
expr_stmt|;
if|if
condition|(
name|high_word
operator|==
literal|0x27bd
comment|/* addiu $sp,$sp,offset */
operator|||
name|high_word
operator|==
literal|0x67bd
condition|)
comment|/* daddiu $sp,$sp,offset */
name|seen_sp_adjust
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|inst
operator|==
literal|0x03a1e823
operator|||
comment|/* subu $sp,$sp,$at */
name|inst
operator|==
literal|0x03a8e823
condition|)
comment|/* subu $sp,$sp,$t0 */
name|seen_sp_adjust
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|(
name|inst
operator|&
literal|0xFFE00000
operator|)
operator|==
literal|0xAFA00000
comment|/* sw reg,n($sp) */
operator|||
operator|(
name|inst
operator|&
literal|0xFFE00000
operator|)
operator|==
literal|0xFFA00000
operator|)
comment|/* sd reg,n($sp) */
operator|&&
operator|(
name|inst
operator|&
literal|0x001F0000
operator|)
condition|)
comment|/* reg != $zero */
continue|continue;
elseif|else
if|if
condition|(
operator|(
name|inst
operator|&
literal|0xFFE00000
operator|)
operator|==
literal|0xE7A00000
condition|)
comment|/* swc1 freg,n($sp) */
continue|continue;
elseif|else
if|if
condition|(
operator|(
name|inst
operator|&
literal|0xF3E00000
operator|)
operator|==
literal|0xA3C00000
operator|&&
operator|(
name|inst
operator|&
literal|0x001F0000
operator|)
condition|)
comment|/* sx reg,n($s8) */
continue|continue;
comment|/* reg != $zero */
comment|/* move $s8,$sp.  With different versions of gas this will be either          `addu $s8,$sp,$zero' or `or $s8,$sp,$zero' or `daddu s8,sp,$0'.          Accept any one of these.  */
elseif|else
if|if
condition|(
name|inst
operator|==
literal|0x03A0F021
operator|||
name|inst
operator|==
literal|0x03a0f025
operator|||
name|inst
operator|==
literal|0x03a0f02d
condition|)
continue|continue;
elseif|else
if|if
condition|(
operator|(
name|inst
operator|&
literal|0xFF9F07FF
operator|)
operator|==
literal|0x00800021
condition|)
comment|/* move reg,$a0-$a3 */
continue|continue;
elseif|else
if|if
condition|(
name|high_word
operator|==
literal|0x3c1c
condition|)
comment|/* lui $gp,n */
continue|continue;
elseif|else
if|if
condition|(
name|high_word
operator|==
literal|0x279c
condition|)
comment|/* addiu $gp,$gp,n */
continue|continue;
elseif|else
if|if
condition|(
name|inst
operator|==
literal|0x0399e021
comment|/* addu $gp,$gp,$t9 */
operator|||
name|inst
operator|==
literal|0x033ce021
condition|)
comment|/* addu $gp,$t9,$gp */
continue|continue;
comment|/* The following instructions load $at or $t0 with an immediate          value in preparation for a stack adjustment via          subu $sp,$sp,[$at,$t0]. These instructions could also initialize          a local variable, so we accept them only before a stack adjustment          instruction was seen.  */
elseif|else
if|if
condition|(
operator|!
name|seen_sp_adjust
condition|)
block|{
if|if
condition|(
name|high_word
operator|==
literal|0x3c01
operator|||
comment|/* lui $at,n */
name|high_word
operator|==
literal|0x3c08
condition|)
comment|/* lui $t0,n */
block|{
name|load_immediate_bytes
operator|+=
name|MIPS_INSTLEN
expr_stmt|;
comment|/* FIXME!! */
continue|continue;
block|}
elseif|else
if|if
condition|(
name|high_word
operator|==
literal|0x3421
operator|||
comment|/* ori $at,$at,n */
name|high_word
operator|==
literal|0x3508
operator|||
comment|/* ori $t0,$t0,n */
name|high_word
operator|==
literal|0x3401
operator|||
comment|/* ori $at,$zero,n */
name|high_word
operator|==
literal|0x3408
condition|)
comment|/* ori $t0,$zero,n */
block|{
name|load_immediate_bytes
operator|+=
name|MIPS_INSTLEN
expr_stmt|;
comment|/* FIXME!! */
continue|continue;
block|}
else|else
break|break;
block|}
else|else
break|break;
block|}
comment|/* In a frameless function, we might have incorrectly      skipped some load immediate instructions. Undo the skipping      if the load immediate was not followed by a stack adjustment.  */
if|if
condition|(
name|load_immediate_bytes
operator|&&
operator|!
name|seen_sp_adjust
condition|)
name|pc
operator|-=
name|load_immediate_bytes
expr_stmt|;
return|return
name|pc
return|;
block|}
end_function

begin_comment
comment|/* Skip the PC past function prologue instructions (16-bit version).    This is a helper function for mips_skip_prologue.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|mips16_skip_prologue
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
name|CORE_ADDR
name|end_pc
decl_stmt|;
name|int
name|extend_bytes
init|=
literal|0
decl_stmt|;
name|int
name|prev_extend_bytes
decl_stmt|;
comment|/* Table of instructions likely to be found in a function prologue.  */
specifier|static
struct|struct
block|{
name|unsigned
name|short
name|inst
decl_stmt|;
name|unsigned
name|short
name|mask
decl_stmt|;
block|}
name|table
index|[]
init|=
block|{
block|{
literal|0x6300
block|,
literal|0xff00
block|}
block|,
comment|/* addiu $sp,offset */
block|{
literal|0xfb00
block|,
literal|0xff00
block|}
block|,
comment|/* daddiu $sp,offset */
block|{
literal|0xd000
block|,
literal|0xf800
block|}
block|,
comment|/* sw reg,n($sp) */
block|{
literal|0xf900
block|,
literal|0xff00
block|}
block|,
comment|/* sd reg,n($sp) */
block|{
literal|0x6200
block|,
literal|0xff00
block|}
block|,
comment|/* sw $ra,n($sp) */
block|{
literal|0xfa00
block|,
literal|0xff00
block|}
block|,
comment|/* sd $ra,n($sp) */
block|{
literal|0x673d
block|,
literal|0xffff
block|}
block|,
comment|/* move $s1,sp */
block|{
literal|0xd980
block|,
literal|0xff80
block|}
block|,
comment|/* sw $a0-$a3,n($s1) */
block|{
literal|0x6704
block|,
literal|0xff1c
block|}
block|,
comment|/* move reg,$a0-$a3 */
block|{
literal|0xe809
block|,
literal|0xf81f
block|}
block|,
comment|/* entry pseudo-op */
block|{
literal|0x0100
block|,
literal|0xff00
block|}
block|,
comment|/* addiu $s1,$sp,n */
block|{
literal|0
block|,
literal|0
block|}
comment|/* end of table marker */
block|}
struct|;
comment|/* Find an upper bound on the prologue.  */
name|end_pc
operator|=
name|skip_prologue_using_sal
argument_list|(
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|end_pc
operator|==
literal|0
condition|)
name|end_pc
operator|=
name|pc
operator|+
literal|100
expr_stmt|;
comment|/* Magic.  */
comment|/* Skip the typical prologue instructions. These are the stack adjustment      instruction and the instructions that save registers on the stack      or in the gcc frame.  */
for|for
control|(
init|;
name|pc
operator|<
name|end_pc
condition|;
name|pc
operator|+=
name|MIPS16_INSTLEN
control|)
block|{
name|unsigned
name|short
name|inst
decl_stmt|;
name|int
name|i
decl_stmt|;
name|inst
operator|=
name|mips_fetch_instruction
argument_list|(
name|pc
argument_list|)
expr_stmt|;
comment|/* Normally we ignore an extend instruction.  However, if it is          not followed by a valid prologue instruction, we must adjust          the pc back over the extend so that it won't be considered          part of the prologue.  */
if|if
condition|(
operator|(
name|inst
operator|&
literal|0xf800
operator|)
operator|==
literal|0xf000
condition|)
comment|/* extend */
block|{
name|extend_bytes
operator|=
name|MIPS16_INSTLEN
expr_stmt|;
continue|continue;
block|}
name|prev_extend_bytes
operator|=
name|extend_bytes
expr_stmt|;
name|extend_bytes
operator|=
literal|0
expr_stmt|;
comment|/* Check for other valid prologue instructions besides extend.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|table
index|[
name|i
index|]
operator|.
name|mask
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|inst
operator|&
name|table
index|[
name|i
index|]
operator|.
name|mask
operator|)
operator|==
name|table
index|[
name|i
index|]
operator|.
name|inst
condition|)
comment|/* found, get out */
break|break;
if|if
condition|(
name|table
index|[
name|i
index|]
operator|.
name|mask
operator|!=
literal|0
condition|)
comment|/* it was in table? */
continue|continue;
comment|/* ignore it */
else|else
comment|/* non-prologue */
block|{
comment|/* Return the current pc, adjusted backwards by 2 if 	     the previous instruction was an extend.  */
return|return
name|pc
operator|-
name|prev_extend_bytes
return|;
block|}
block|}
return|return
name|pc
return|;
block|}
end_function

begin_comment
comment|/* To skip prologues, I use this predicate.  Returns either PC itself    if the code at PC does not look like a function prologue; otherwise    returns an address that (if we're lucky) follows the prologue.  If    LENIENT, then we must skip everything which is involved in setting    up the frame (it's OK to skip more, just so long as we don't skip    anything which might clobber the registers which are being saved.    We must skip more in the case where part of the prologue is in the    delay slot of a non-prologue instruction).  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|mips_skip_prologue
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
comment|/* See if we can determine the end of the prologue via the symbol table.      If so, then return either PC, or the PC after the prologue, whichever      is greater.  */
name|CORE_ADDR
name|post_prologue_pc
init|=
name|after_prologue
argument_list|(
name|pc
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|post_prologue_pc
operator|!=
literal|0
condition|)
return|return
name|max
argument_list|(
name|pc
argument_list|,
name|post_prologue_pc
argument_list|)
return|;
comment|/* Can't determine prologue from the symbol table, need to examine      instructions.  */
if|if
condition|(
name|pc_is_mips16
argument_list|(
name|pc
argument_list|)
condition|)
return|return
name|mips16_skip_prologue
argument_list|(
name|pc
argument_list|)
return|;
else|else
return|return
name|mips32_skip_prologue
argument_list|(
name|pc
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Exported procedure: Is PC in the signal trampoline code */
end_comment

begin_function
specifier|static
name|int
name|mips_pc_in_sigtramp
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|char
modifier|*
name|ignore
parameter_list|)
block|{
if|if
condition|(
name|sigtramp_address
operator|==
literal|0
condition|)
name|fixup_sigtramp
argument_list|()
expr_stmt|;
return|return
operator|(
name|pc
operator|>=
name|sigtramp_address
operator|&&
name|pc
operator|<
name|sigtramp_end
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Root of all "set mips "/"show mips " commands. This will eventually be    used for all MIPS-specific commands.  */
end_comment

begin_function
specifier|static
name|void
name|show_mips_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|help_list
argument_list|(
name|showmipscmdlist
argument_list|,
literal|"show mips "
argument_list|,
name|all_commands
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_mips_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|printf_unfiltered
argument_list|(
literal|"\"set mips\" must be followed by an appropriate subcommand.\n"
argument_list|)
expr_stmt|;
name|help_list
argument_list|(
name|setmipscmdlist
argument_list|,
literal|"set mips "
argument_list|,
name|all_commands
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Commands to show/set the MIPS FPU type.  */
end_comment

begin_function
specifier|static
name|void
name|show_mipsfpu_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|char
modifier|*
name|fpu
decl_stmt|;
switch|switch
condition|(
name|MIPS_FPU_TYPE
condition|)
block|{
case|case
name|MIPS_FPU_SINGLE
case|:
name|fpu
operator|=
literal|"single-precision"
expr_stmt|;
break|break;
case|case
name|MIPS_FPU_DOUBLE
case|:
name|fpu
operator|=
literal|"double-precision"
expr_stmt|;
break|break;
case|case
name|MIPS_FPU_NONE
case|:
name|fpu
operator|=
literal|"absent (none)"
expr_stmt|;
break|break;
default|default:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"bad switch"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mips_fpu_type_auto
condition|)
name|printf_unfiltered
argument_list|(
literal|"The MIPS floating-point coprocessor is set automatically (currently %s)\n"
argument_list|,
name|fpu
argument_list|)
expr_stmt|;
else|else
name|printf_unfiltered
argument_list|(
literal|"The MIPS floating-point coprocessor is assumed to be %s\n"
argument_list|,
name|fpu
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_mipsfpu_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|printf_unfiltered
argument_list|(
literal|"\"set mipsfpu\" must be followed by \"double\", \"single\",\"none\" or \"auto\".\n"
argument_list|)
expr_stmt|;
name|show_mipsfpu_command
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_mipsfpu_single_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|gdbarch_info
name|info
decl_stmt|;
name|gdbarch_info_init
argument_list|(
operator|&
name|info
argument_list|)
expr_stmt|;
name|mips_fpu_type
operator|=
name|MIPS_FPU_SINGLE
expr_stmt|;
name|mips_fpu_type_auto
operator|=
literal|0
expr_stmt|;
comment|/* FIXME: cagney/2003-11-15: Should be setting a field in "info"      instead of relying on globals.  Doing that would let generic code      handle the search for this specific architecture.  */
if|if
condition|(
operator|!
name|gdbarch_update_p
argument_list|(
name|info
argument_list|)
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"set mipsfpu failed"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_mipsfpu_double_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|gdbarch_info
name|info
decl_stmt|;
name|gdbarch_info_init
argument_list|(
operator|&
name|info
argument_list|)
expr_stmt|;
name|mips_fpu_type
operator|=
name|MIPS_FPU_DOUBLE
expr_stmt|;
name|mips_fpu_type_auto
operator|=
literal|0
expr_stmt|;
comment|/* FIXME: cagney/2003-11-15: Should be setting a field in "info"      instead of relying on globals.  Doing that would let generic code      handle the search for this specific architecture.  */
if|if
condition|(
operator|!
name|gdbarch_update_p
argument_list|(
name|info
argument_list|)
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"set mipsfpu failed"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_mipsfpu_none_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|gdbarch_info
name|info
decl_stmt|;
name|gdbarch_info_init
argument_list|(
operator|&
name|info
argument_list|)
expr_stmt|;
name|mips_fpu_type
operator|=
name|MIPS_FPU_NONE
expr_stmt|;
name|mips_fpu_type_auto
operator|=
literal|0
expr_stmt|;
comment|/* FIXME: cagney/2003-11-15: Should be setting a field in "info"      instead of relying on globals.  Doing that would let generic code      handle the search for this specific architecture.  */
if|if
condition|(
operator|!
name|gdbarch_update_p
argument_list|(
name|info
argument_list|)
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"set mipsfpu failed"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_mipsfpu_auto_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|mips_fpu_type_auto
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Attempt to identify the particular processor model by reading the    processor id.  NOTE: cagney/2003-11-15: Firstly it isn't clear that    the relevant processor still exists (it dates back to '94) and    secondly this is not the way to do this.  The processor type should    be set by forcing an architecture change.  */
end_comment

begin_function
name|void
name|deprecated_mips_set_processor_regs_hack
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
decl_stmt|;
name|CORE_ADDR
name|prid
decl_stmt|;
name|prid
operator|=
name|read_register
argument_list|(
name|PRID_REGNUM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|prid
operator|&
operator|~
literal|0xf
operator|)
operator|==
literal|0x700
condition|)
name|tdep
operator|->
name|mips_processor_reg_names
operator|=
name|mips_r3041_reg_names
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Just like reinit_frame_cache, but with the right arguments to be    callable as an sfunc.  */
end_comment

begin_function
specifier|static
name|void
name|reinit_frame_cache_sfunc
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
name|c
parameter_list|)
block|{
name|reinit_frame_cache
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|gdb_print_insn_mips
parameter_list|(
name|bfd_vma
name|memaddr
parameter_list|,
name|struct
name|disassemble_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
decl_stmt|;
name|mips_extra_func_info_t
name|proc_desc
decl_stmt|;
comment|/* Search for the function containing this address.  Set the low bit      of the address when searching, in case we were given an even address      that is the start of a 16-bit function.  If we didn't do this,      the search would fail because the symbol table says the function      starts at an odd address, i.e. 1 byte past the given address.  */
name|memaddr
operator|=
name|ADDR_BITS_REMOVE
argument_list|(
name|memaddr
argument_list|)
expr_stmt|;
name|proc_desc
operator|=
name|non_heuristic_proc_desc
argument_list|(
name|make_mips16_addr
argument_list|(
name|memaddr
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Make an attempt to determine if this is a 16-bit function.  If      the procedure descriptor exists and the address therein is odd,      it's definitely a 16-bit function.  Otherwise, we have to just      guess that if the address passed in is odd, it's 16-bits.  */
comment|/* FIXME: cagney/2003-06-26: Is this even necessary?  The      disassembler needs to be able to locally determine the ISA, and      not rely on GDB.  Otherwize the stand-alone 'objdump -d' will not      work.  */
if|if
condition|(
name|proc_desc
condition|)
block|{
if|if
condition|(
name|pc_is_mips16
argument_list|(
name|PROC_LOW_ADDR
argument_list|(
name|proc_desc
argument_list|)
argument_list|)
condition|)
name|info
operator|->
name|mach
operator|=
name|bfd_mach_mips16
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|pc_is_mips16
argument_list|(
name|memaddr
argument_list|)
condition|)
name|info
operator|->
name|mach
operator|=
name|bfd_mach_mips16
expr_stmt|;
block|}
comment|/* Round down the instruction address to the appropriate boundary.  */
name|memaddr
operator|&=
operator|(
name|info
operator|->
name|mach
operator|==
name|bfd_mach_mips16
condition|?
operator|~
literal|1
else|:
operator|~
literal|3
operator|)
expr_stmt|;
comment|/* Set the disassembler options.  */
if|if
condition|(
name|tdep
operator|->
name|mips_abi
operator|==
name|MIPS_ABI_N32
operator|||
name|tdep
operator|->
name|mips_abi
operator|==
name|MIPS_ABI_N64
condition|)
block|{
comment|/* Set up the disassembler info, so that we get the right          register names from libopcodes.  */
if|if
condition|(
name|tdep
operator|->
name|mips_abi
operator|==
name|MIPS_ABI_N32
condition|)
name|info
operator|->
name|disassembler_options
operator|=
literal|"gpr-names=n32"
expr_stmt|;
else|else
name|info
operator|->
name|disassembler_options
operator|=
literal|"gpr-names=64"
expr_stmt|;
name|info
operator|->
name|flavour
operator|=
name|bfd_target_elf_flavour
expr_stmt|;
block|}
else|else
comment|/* This string is not recognized explicitly by the disassembler,        but it tells the disassembler to not try to guess the ABI from        the bfd elf headers, such that, if the user overrides the ABI        of a program linked as NewABI, the disassembly will follow the        register naming conventions specified by the user.  */
name|info
operator|->
name|disassembler_options
operator|=
literal|"gpr-names=32"
expr_stmt|;
comment|/* Call the appropriate disassembler based on the target endian-ness.  */
if|if
condition|(
name|TARGET_BYTE_ORDER
operator|==
name|BFD_ENDIAN_BIG
condition|)
return|return
name|print_insn_big_mips
argument_list|(
name|memaddr
argument_list|,
name|info
argument_list|)
return|;
else|else
return|return
name|print_insn_little_mips
argument_list|(
name|memaddr
argument_list|,
name|info
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* This function implements the BREAKPOINT_FROM_PC macro.  It uses the program    counter value to determine whether a 16- or 32-bit breakpoint should be    used.  It returns a pointer to a string of bytes that encode a breakpoint    instruction, stores the length of the string to *lenptr, and adjusts pc    (if necessary) to point to the actual memory location where the    breakpoint should be inserted.  */
end_comment

begin_function
specifier|static
specifier|const
name|unsigned
name|char
modifier|*
name|mips_breakpoint_from_pc
parameter_list|(
name|CORE_ADDR
modifier|*
name|pcptr
parameter_list|,
name|int
modifier|*
name|lenptr
parameter_list|)
block|{
if|if
condition|(
name|TARGET_BYTE_ORDER
operator|==
name|BFD_ENDIAN_BIG
condition|)
block|{
if|if
condition|(
name|pc_is_mips16
argument_list|(
operator|*
name|pcptr
argument_list|)
condition|)
block|{
specifier|static
name|unsigned
name|char
name|mips16_big_breakpoint
index|[]
init|=
block|{
literal|0xe8
block|,
literal|0xa5
block|}
decl_stmt|;
operator|*
name|pcptr
operator|=
name|unmake_mips16_addr
argument_list|(
operator|*
name|pcptr
argument_list|)
expr_stmt|;
operator|*
name|lenptr
operator|=
sizeof|sizeof
argument_list|(
name|mips16_big_breakpoint
argument_list|)
expr_stmt|;
return|return
name|mips16_big_breakpoint
return|;
block|}
else|else
block|{
comment|/* The IDT board uses an unusual breakpoint value, and 	     sometimes gets confused when it sees the usual MIPS 	     breakpoint instruction.  */
specifier|static
name|unsigned
name|char
name|big_breakpoint
index|[]
init|=
block|{
literal|0
block|,
literal|0x5
block|,
literal|0
block|,
literal|0xd
block|}
decl_stmt|;
specifier|static
name|unsigned
name|char
name|pmon_big_breakpoint
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0xd
block|}
decl_stmt|;
specifier|static
name|unsigned
name|char
name|idt_big_breakpoint
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0x0a
block|,
literal|0xd
block|}
decl_stmt|;
operator|*
name|lenptr
operator|=
sizeof|sizeof
argument_list|(
name|big_breakpoint
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|target_shortname
argument_list|,
literal|"mips"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|idt_big_breakpoint
return|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|target_shortname
argument_list|,
literal|"ddb"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|target_shortname
argument_list|,
literal|"pmon"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|target_shortname
argument_list|,
literal|"lsi"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|pmon_big_breakpoint
return|;
else|else
return|return
name|big_breakpoint
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|pc_is_mips16
argument_list|(
operator|*
name|pcptr
argument_list|)
condition|)
block|{
specifier|static
name|unsigned
name|char
name|mips16_little_breakpoint
index|[]
init|=
block|{
literal|0xa5
block|,
literal|0xe8
block|}
decl_stmt|;
operator|*
name|pcptr
operator|=
name|unmake_mips16_addr
argument_list|(
operator|*
name|pcptr
argument_list|)
expr_stmt|;
operator|*
name|lenptr
operator|=
sizeof|sizeof
argument_list|(
name|mips16_little_breakpoint
argument_list|)
expr_stmt|;
return|return
name|mips16_little_breakpoint
return|;
block|}
else|else
block|{
specifier|static
name|unsigned
name|char
name|little_breakpoint
index|[]
init|=
block|{
literal|0xd
block|,
literal|0
block|,
literal|0x5
block|,
literal|0
block|}
decl_stmt|;
specifier|static
name|unsigned
name|char
name|pmon_little_breakpoint
index|[]
init|=
block|{
literal|0xd
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
specifier|static
name|unsigned
name|char
name|idt_little_breakpoint
index|[]
init|=
block|{
literal|0xd
block|,
literal|0x0a
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
operator|*
name|lenptr
operator|=
sizeof|sizeof
argument_list|(
name|little_breakpoint
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|target_shortname
argument_list|,
literal|"mips"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|idt_little_breakpoint
return|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|target_shortname
argument_list|,
literal|"ddb"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|target_shortname
argument_list|,
literal|"pmon"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|target_shortname
argument_list|,
literal|"lsi"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|pmon_little_breakpoint
return|;
else|else
return|return
name|little_breakpoint
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* If PC is in a mips16 call or return stub, return the address of the target    PC, which is either the callee or the caller.  There are several    cases which must be handled:     * If the PC is in __mips16_ret_{d,s}f, this is a return stub and the    target PC is in $31 ($ra).    * If the PC is in __mips16_call_stub_{1..10}, this is a call stub    and the target PC is in $2.    * If the PC at the start of __mips16_call_stub_{s,d}f_{0..10}, i.e.    before the jal instruction, this is effectively a call stub    and the the target PC is in $2.  Otherwise this is effectively    a return stub and the target PC is in $18.     See the source code for the stubs in gcc/config/mips/mips16.S for    gory details.     This function implements the SKIP_TRAMPOLINE_CODE macro.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|mips_skip_stub
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|CORE_ADDR
name|start_addr
decl_stmt|;
comment|/* Find the starting address and name of the function containing the PC.  */
if|if
condition|(
name|find_pc_partial_function
argument_list|(
name|pc
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|start_addr
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* If the PC is in __mips16_ret_{d,s}f, this is a return stub and the      target PC is in $31 ($ra).  */
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"__mips16_ret_sf"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"__mips16_ret_df"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|read_signed_register
argument_list|(
name|RA_REGNUM
argument_list|)
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"__mips16_call_stub_"
argument_list|,
literal|19
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* If the PC is in __mips16_call_stub_{1..10}, this is a call stub          and the target PC is in $2.  */
if|if
condition|(
name|name
index|[
literal|19
index|]
operator|>=
literal|'0'
operator|&&
name|name
index|[
literal|19
index|]
operator|<=
literal|'9'
condition|)
return|return
name|read_signed_register
argument_list|(
literal|2
argument_list|)
return|;
comment|/* If the PC at the start of __mips16_call_stub_{s,d}f_{0..10}, i.e.          before the jal instruction, this is effectively a call stub          and the the target PC is in $2.  Otherwise this is effectively          a return stub and the target PC is in $18.  */
elseif|else
if|if
condition|(
name|name
index|[
literal|19
index|]
operator|==
literal|'s'
operator|||
name|name
index|[
literal|19
index|]
operator|==
literal|'d'
condition|)
block|{
if|if
condition|(
name|pc
operator|==
name|start_addr
condition|)
block|{
comment|/* Check if the target of the stub is a compiler-generated 	         stub.  Such a stub for a function bar might have a name 	         like __fn_stub_bar, and might look like this: 	         mfc1    $4,$f13 	         mfc1    $5,$f12 	         mfc1    $6,$f15 	         mfc1    $7,$f14 	         la      $1,bar   (becomes a lui/addiu pair) 	         jr      $1 	         So scan down to the lui/addi and extract the target 	         address from those two instructions.  */
name|CORE_ADDR
name|target_pc
init|=
name|read_signed_register
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|t_inst
name|inst
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* See if the name of the target function is  __fn_stub_*.  */
if|if
condition|(
name|find_pc_partial_function
argument_list|(
name|target_pc
argument_list|,
operator|&
name|name
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
return|return
name|target_pc
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"__fn_stub_"
argument_list|,
literal|10
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"etext"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"_etext"
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|target_pc
return|;
comment|/* Scan through this _fn_stub_ code for the lui/addiu pair. 	         The limit on the search is arbitrarily set to 20 	         instructions.  FIXME.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|pc
operator|=
literal|0
init|;
name|i
operator|<
literal|20
condition|;
name|i
operator|++
operator|,
name|target_pc
operator|+=
name|MIPS_INSTLEN
control|)
block|{
name|inst
operator|=
name|mips_fetch_instruction
argument_list|(
name|target_pc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|inst
operator|&
literal|0xffff0000
operator|)
operator|==
literal|0x3c010000
condition|)
comment|/* lui $at */
name|pc
operator|=
operator|(
name|inst
operator|<<
literal|16
operator|)
operator|&
literal|0xffff0000
expr_stmt|;
comment|/* high word */
elseif|else
if|if
condition|(
operator|(
name|inst
operator|&
literal|0xffff0000
operator|)
operator|==
literal|0x24210000
condition|)
comment|/* addiu $at */
return|return
name|pc
operator||
operator|(
name|inst
operator|&
literal|0xffff
operator|)
return|;
comment|/* low word */
block|}
comment|/* Couldn't find the lui/addui pair, so return stub address.  */
return|return
name|target_pc
return|;
block|}
else|else
comment|/* This is the 'return' part of a call stub.  The return 	       address is in $r18.  */
return|return
name|read_signed_register
argument_list|(
literal|18
argument_list|)
return|;
block|}
block|}
return|return
literal|0
return|;
comment|/* not a stub */
block|}
end_function

begin_comment
comment|/* Return non-zero if the PC is inside a call thunk (aka stub or trampoline).    This implements the IN_SOLIB_CALL_TRAMPOLINE macro.  */
end_comment

begin_function
specifier|static
name|int
name|mips_in_call_stub
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|CORE_ADDR
name|start_addr
decl_stmt|;
comment|/* Find the starting address of the function containing the PC.  If the      caller didn't give us a name, look it up at the same time.  */
if|if
condition|(
name|find_pc_partial_function
argument_list|(
name|pc
argument_list|,
name|name
condition|?
name|NULL
else|:
operator|&
name|name
argument_list|,
operator|&
name|start_addr
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"__mips16_call_stub_"
argument_list|,
literal|19
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* If the PC is in __mips16_call_stub_{1..10}, this is a call stub.  */
if|if
condition|(
name|name
index|[
literal|19
index|]
operator|>=
literal|'0'
operator|&&
name|name
index|[
literal|19
index|]
operator|<=
literal|'9'
condition|)
return|return
literal|1
return|;
comment|/* If the PC at the start of __mips16_call_stub_{s,d}f_{0..10}, i.e.          before the jal instruction, this is effectively a call stub.  */
elseif|else
if|if
condition|(
name|name
index|[
literal|19
index|]
operator|==
literal|'s'
operator|||
name|name
index|[
literal|19
index|]
operator|==
literal|'d'
condition|)
return|return
name|pc
operator|==
name|start_addr
return|;
block|}
return|return
literal|0
return|;
comment|/* not a stub */
block|}
end_function

begin_comment
comment|/* Return non-zero if the PC is inside a return thunk (aka stub or trampoline).    This implements the IN_SOLIB_RETURN_TRAMPOLINE macro.  */
end_comment

begin_function
specifier|static
name|int
name|mips_in_return_stub
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|CORE_ADDR
name|start_addr
decl_stmt|;
comment|/* Find the starting address of the function containing the PC.  */
if|if
condition|(
name|find_pc_partial_function
argument_list|(
name|pc
argument_list|,
name|NULL
argument_list|,
operator|&
name|start_addr
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* If the PC is in __mips16_ret_{d,s}f, this is a return stub.  */
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"__mips16_ret_sf"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"__mips16_ret_df"
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
comment|/* If the PC is in __mips16_call_stub_{s,d}f_{0..10} but not at the start,      i.e. after the jal instruction, this is effectively a return stub.  */
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"__mips16_call_stub_"
argument_list|,
literal|19
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|name
index|[
literal|19
index|]
operator|==
literal|'s'
operator|||
name|name
index|[
literal|19
index|]
operator|==
literal|'d'
operator|)
operator|&&
name|pc
operator|!=
name|start_addr
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
comment|/* not a stub */
block|}
end_function

begin_comment
comment|/* Return non-zero if the PC is in a library helper function that should    be ignored.  This implements the IGNORE_HELPER_CALL macro.  */
end_comment

begin_function
name|int
name|mips_ignore_helper
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Find the starting address and name of the function containing the PC.  */
if|if
condition|(
name|find_pc_partial_function
argument_list|(
name|pc
argument_list|,
operator|&
name|name
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* If the PC is in __mips16_ret_{d,s}f, this is a library helper function      that we want to ignore.  */
return|return
operator|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"__mips16_ret_sf"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"__mips16_ret_df"
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Convert a dbx stab register number (from `r' declaration) to a GDB    [1 * NUM_REGS .. 2 * NUM_REGS) REGNUM.  */
end_comment

begin_function
specifier|static
name|int
name|mips_stab_reg_to_regnum
parameter_list|(
name|int
name|num
parameter_list|)
block|{
name|int
name|regnum
decl_stmt|;
if|if
condition|(
name|num
operator|>=
literal|0
operator|&&
name|num
operator|<
literal|32
condition|)
name|regnum
operator|=
name|num
expr_stmt|;
elseif|else
if|if
condition|(
name|num
operator|>=
literal|38
operator|&&
name|num
operator|<
literal|70
condition|)
name|regnum
operator|=
name|num
operator|+
name|mips_regnum
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|fp0
operator|-
literal|38
expr_stmt|;
elseif|else
if|if
condition|(
name|num
operator|==
literal|70
condition|)
name|regnum
operator|=
name|mips_regnum
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|hi
expr_stmt|;
elseif|else
if|if
condition|(
name|num
operator|==
literal|71
condition|)
name|regnum
operator|=
name|mips_regnum
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|lo
expr_stmt|;
else|else
comment|/* This will hopefully (eventually) provoke a warning.  Should        we be calling complaint() here?  */
return|return
name|NUM_REGS
operator|+
name|NUM_PSEUDO_REGS
return|;
return|return
name|NUM_REGS
operator|+
name|regnum
return|;
block|}
end_function

begin_comment
comment|/* Convert a dwarf, dwarf2, or ecoff register number to a GDB [1 *    NUM_REGS .. 2 * NUM_REGS) REGNUM.  */
end_comment

begin_function
specifier|static
name|int
name|mips_dwarf_dwarf2_ecoff_reg_to_regnum
parameter_list|(
name|int
name|num
parameter_list|)
block|{
name|int
name|regnum
decl_stmt|;
if|if
condition|(
name|num
operator|>=
literal|0
operator|&&
name|num
operator|<
literal|32
condition|)
name|regnum
operator|=
name|num
expr_stmt|;
elseif|else
if|if
condition|(
name|num
operator|>=
literal|32
operator|&&
name|num
operator|<
literal|64
condition|)
name|regnum
operator|=
name|num
operator|+
name|mips_regnum
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|fp0
operator|-
literal|32
expr_stmt|;
elseif|else
if|if
condition|(
name|num
operator|==
literal|64
condition|)
name|regnum
operator|=
name|mips_regnum
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|hi
expr_stmt|;
elseif|else
if|if
condition|(
name|num
operator|==
literal|65
condition|)
name|regnum
operator|=
name|mips_regnum
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|lo
expr_stmt|;
else|else
comment|/* This will hopefully (eventually) provoke a warning.  Should we        be calling complaint() here?  */
return|return
name|NUM_REGS
operator|+
name|NUM_PSEUDO_REGS
return|;
return|return
name|NUM_REGS
operator|+
name|regnum
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mips_register_sim_regno
parameter_list|(
name|int
name|regnum
parameter_list|)
block|{
comment|/* Only makes sense to supply raw registers.  */
name|gdb_assert
argument_list|(
name|regnum
operator|>=
literal|0
operator|&&
name|regnum
operator|<
name|NUM_REGS
argument_list|)
expr_stmt|;
comment|/* FIXME: cagney/2002-05-13: Need to look at the pseudo register to      decide if it is valid.  Should instead define a standard sim/gdb      register numbering scheme.  */
if|if
condition|(
name|REGISTER_NAME
argument_list|(
name|NUM_REGS
operator|+
name|regnum
argument_list|)
operator|!=
name|NULL
operator|&&
name|REGISTER_NAME
argument_list|(
name|NUM_REGS
operator|+
name|regnum
argument_list|)
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
return|return
name|regnum
return|;
else|else
return|return
name|LEGACY_SIM_REGNO_IGNORE
return|;
block|}
end_function

begin_comment
comment|/* Convert an integer into an address.  By first converting the value    into a pointer and then extracting it signed, the address is    guarenteed to be correctly sign extended.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|mips_integer_to_address
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|)
block|{
name|char
modifier|*
name|tmp
init|=
name|alloca
argument_list|(
name|TYPE_LENGTH
argument_list|(
name|builtin_type_void_data_ptr
argument_list|)
argument_list|)
decl_stmt|;
name|LONGEST
name|val
init|=
name|unpack_long
argument_list|(
name|type
argument_list|,
name|buf
argument_list|)
decl_stmt|;
name|store_signed_integer
argument_list|(
name|tmp
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|builtin_type_void_data_ptr
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
name|extract_signed_integer
argument_list|(
name|tmp
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|builtin_type_void_data_ptr
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mips_find_abi_section
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sect
parameter_list|,
name|void
modifier|*
name|obj
parameter_list|)
block|{
name|enum
name|mips_abi
modifier|*
name|abip
init|=
operator|(
expr|enum
name|mips_abi
operator|*
operator|)
name|obj
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sect
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|abip
operator|!=
name|MIPS_ABI_UNKNOWN
condition|)
return|return;
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".mdebug."
argument_list|,
literal|8
argument_list|)
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".mdebug.abi32"
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|abip
operator|=
name|MIPS_ABI_O32
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".mdebug.abiN32"
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|abip
operator|=
name|MIPS_ABI_N32
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".mdebug.abi64"
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|abip
operator|=
name|MIPS_ABI_N64
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".mdebug.abiO64"
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|abip
operator|=
name|MIPS_ABI_O64
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".mdebug.eabi32"
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|abip
operator|=
name|MIPS_ABI_EABI32
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".mdebug.eabi64"
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|abip
operator|=
name|MIPS_ABI_EABI64
expr_stmt|;
else|else
name|warning
argument_list|(
literal|"unsupported ABI %s."
argument_list|,
name|name
operator|+
literal|8
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|enum
name|mips_abi
name|global_mips_abi
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|mips_abi_strings
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|mips_abi_strings
index|[
name|i
index|]
operator|==
name|mips_abi_string
condition|)
return|return
operator|(
expr|enum
name|mips_abi
operator|)
name|i
return|;
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"unknown ABI string"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|gdbarch
modifier|*
name|mips_gdbarch_init
parameter_list|(
name|struct
name|gdbarch_info
name|info
parameter_list|,
name|struct
name|gdbarch_list
modifier|*
name|arches
parameter_list|)
block|{
name|struct
name|gdbarch
modifier|*
name|gdbarch
decl_stmt|;
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
decl_stmt|;
name|int
name|elf_flags
decl_stmt|;
name|enum
name|mips_abi
name|mips_abi
decl_stmt|,
name|found_abi
decl_stmt|,
name|wanted_abi
decl_stmt|;
name|int
name|num_regs
decl_stmt|;
name|enum
name|mips_fpu_type
name|fpu_type
decl_stmt|;
comment|/* First of all, extract the elf_flags, if available.  */
if|if
condition|(
name|info
operator|.
name|abfd
operator|&&
name|bfd_get_flavour
argument_list|(
name|info
operator|.
name|abfd
argument_list|)
operator|==
name|bfd_target_elf_flavour
condition|)
name|elf_flags
operator|=
name|elf_elfheader
argument_list|(
name|info
operator|.
name|abfd
argument_list|)
operator|->
name|e_flags
expr_stmt|;
elseif|else
if|if
condition|(
name|arches
operator|!=
name|NULL
condition|)
name|elf_flags
operator|=
name|gdbarch_tdep
argument_list|(
name|arches
operator|->
name|gdbarch
argument_list|)
operator|->
name|elf_flags
expr_stmt|;
else|else
name|elf_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|gdbarch_debug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"mips_gdbarch_init: elf_flags = 0x%08x\n"
argument_list|,
name|elf_flags
argument_list|)
expr_stmt|;
comment|/* Check ELF_FLAGS to see if it specifies the ABI being used.  */
switch|switch
condition|(
operator|(
name|elf_flags
operator|&
name|EF_MIPS_ABI
operator|)
condition|)
block|{
case|case
name|E_MIPS_ABI_O32
case|:
name|found_abi
operator|=
name|MIPS_ABI_O32
expr_stmt|;
break|break;
case|case
name|E_MIPS_ABI_O64
case|:
name|found_abi
operator|=
name|MIPS_ABI_O64
expr_stmt|;
break|break;
case|case
name|E_MIPS_ABI_EABI32
case|:
name|found_abi
operator|=
name|MIPS_ABI_EABI32
expr_stmt|;
break|break;
case|case
name|E_MIPS_ABI_EABI64
case|:
name|found_abi
operator|=
name|MIPS_ABI_EABI64
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|(
name|elf_flags
operator|&
name|EF_MIPS_ABI2
operator|)
condition|)
name|found_abi
operator|=
name|MIPS_ABI_N32
expr_stmt|;
else|else
name|found_abi
operator|=
name|MIPS_ABI_UNKNOWN
expr_stmt|;
break|break;
block|}
comment|/* GCC creates a pseudo-section whose name describes the ABI.  */
if|if
condition|(
name|found_abi
operator|==
name|MIPS_ABI_UNKNOWN
operator|&&
name|info
operator|.
name|abfd
operator|!=
name|NULL
condition|)
name|bfd_map_over_sections
argument_list|(
name|info
operator|.
name|abfd
argument_list|,
name|mips_find_abi_section
argument_list|,
operator|&
name|found_abi
argument_list|)
expr_stmt|;
comment|/* If we have no usefu BFD information, use the ABI from the last      MIPS architecture (if there is one).  */
if|if
condition|(
name|found_abi
operator|==
name|MIPS_ABI_UNKNOWN
operator|&&
name|info
operator|.
name|abfd
operator|==
name|NULL
operator|&&
name|arches
operator|!=
name|NULL
condition|)
name|found_abi
operator|=
name|gdbarch_tdep
argument_list|(
name|arches
operator|->
name|gdbarch
argument_list|)
operator|->
name|found_abi
expr_stmt|;
comment|/* Try the architecture for any hint of the correct ABI.  */
if|if
condition|(
name|found_abi
operator|==
name|MIPS_ABI_UNKNOWN
operator|&&
name|info
operator|.
name|bfd_arch_info
operator|!=
name|NULL
operator|&&
name|info
operator|.
name|bfd_arch_info
operator|->
name|arch
operator|==
name|bfd_arch_mips
condition|)
block|{
switch|switch
condition|(
name|info
operator|.
name|bfd_arch_info
operator|->
name|mach
condition|)
block|{
case|case
name|bfd_mach_mips3900
case|:
name|found_abi
operator|=
name|MIPS_ABI_EABI32
expr_stmt|;
break|break;
case|case
name|bfd_mach_mips4100
case|:
case|case
name|bfd_mach_mips5000
case|:
name|found_abi
operator|=
name|MIPS_ABI_EABI64
expr_stmt|;
break|break;
case|case
name|bfd_mach_mips8000
case|:
case|case
name|bfd_mach_mips10000
case|:
comment|/* On Irix, ELF64 executables use the N64 ABI.  The 	     pseudo-sections which describe the ABI aren't present 	     on IRIX.  (Even for executables created by gcc.)  */
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|info
operator|.
name|abfd
argument_list|)
operator|==
name|bfd_target_elf_flavour
operator|&&
name|elf_elfheader
argument_list|(
name|info
operator|.
name|abfd
argument_list|)
operator|->
name|e_ident
index|[
name|EI_CLASS
index|]
operator|==
name|ELFCLASS64
condition|)
name|found_abi
operator|=
name|MIPS_ABI_N64
expr_stmt|;
else|else
name|found_abi
operator|=
name|MIPS_ABI_N32
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|gdbarch_debug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"mips_gdbarch_init: found_abi = %d\n"
argument_list|,
name|found_abi
argument_list|)
expr_stmt|;
comment|/* What has the user specified from the command line?  */
name|wanted_abi
operator|=
name|global_mips_abi
argument_list|()
expr_stmt|;
if|if
condition|(
name|gdbarch_debug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"mips_gdbarch_init: wanted_abi = %d\n"
argument_list|,
name|wanted_abi
argument_list|)
expr_stmt|;
comment|/* Now that we have found what the ABI for this binary would be,      check whether the user is overriding it.  */
if|if
condition|(
name|wanted_abi
operator|!=
name|MIPS_ABI_UNKNOWN
condition|)
name|mips_abi
operator|=
name|wanted_abi
expr_stmt|;
elseif|else
if|if
condition|(
name|found_abi
operator|!=
name|MIPS_ABI_UNKNOWN
condition|)
name|mips_abi
operator|=
name|found_abi
expr_stmt|;
else|else
name|mips_abi
operator|=
name|MIPS_ABI_O32
expr_stmt|;
if|if
condition|(
name|gdbarch_debug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"mips_gdbarch_init: mips_abi = %d\n"
argument_list|,
name|mips_abi
argument_list|)
expr_stmt|;
comment|/* Also used when doing an architecture lookup.  */
if|if
condition|(
name|gdbarch_debug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"mips_gdbarch_init: mips64_transfers_32bit_regs_p = %d\n"
argument_list|,
name|mips64_transfers_32bit_regs_p
argument_list|)
expr_stmt|;
comment|/* Determine the MIPS FPU type.  */
if|if
condition|(
operator|!
name|mips_fpu_type_auto
condition|)
name|fpu_type
operator|=
name|mips_fpu_type
expr_stmt|;
elseif|else
if|if
condition|(
name|info
operator|.
name|bfd_arch_info
operator|!=
name|NULL
operator|&&
name|info
operator|.
name|bfd_arch_info
operator|->
name|arch
operator|==
name|bfd_arch_mips
condition|)
switch|switch
condition|(
name|info
operator|.
name|bfd_arch_info
operator|->
name|mach
condition|)
block|{
case|case
name|bfd_mach_mips3900
case|:
case|case
name|bfd_mach_mips4100
case|:
case|case
name|bfd_mach_mips4111
case|:
name|fpu_type
operator|=
name|MIPS_FPU_NONE
expr_stmt|;
break|break;
case|case
name|bfd_mach_mips4650
case|:
name|fpu_type
operator|=
name|MIPS_FPU_SINGLE
expr_stmt|;
break|break;
default|default:
name|fpu_type
operator|=
name|MIPS_FPU_DOUBLE
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|arches
operator|!=
name|NULL
condition|)
name|fpu_type
operator|=
name|gdbarch_tdep
argument_list|(
name|arches
operator|->
name|gdbarch
argument_list|)
operator|->
name|mips_fpu_type
expr_stmt|;
else|else
name|fpu_type
operator|=
name|MIPS_FPU_DOUBLE
expr_stmt|;
if|if
condition|(
name|gdbarch_debug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"mips_gdbarch_init: fpu_type = %d\n"
argument_list|,
name|fpu_type
argument_list|)
expr_stmt|;
comment|/* try to find a pre-existing architecture */
for|for
control|(
name|arches
operator|=
name|gdbarch_list_lookup_by_info
argument_list|(
name|arches
argument_list|,
operator|&
name|info
argument_list|)
init|;
name|arches
operator|!=
name|NULL
condition|;
name|arches
operator|=
name|gdbarch_list_lookup_by_info
argument_list|(
name|arches
operator|->
name|next
argument_list|,
operator|&
name|info
argument_list|)
control|)
block|{
comment|/* MIPS needs to be pedantic about which ABI the object is          using.  */
if|if
condition|(
name|gdbarch_tdep
argument_list|(
name|arches
operator|->
name|gdbarch
argument_list|)
operator|->
name|elf_flags
operator|!=
name|elf_flags
condition|)
continue|continue;
if|if
condition|(
name|gdbarch_tdep
argument_list|(
name|arches
operator|->
name|gdbarch
argument_list|)
operator|->
name|mips_abi
operator|!=
name|mips_abi
condition|)
continue|continue;
comment|/* Need to be pedantic about which register virtual size is          used.  */
if|if
condition|(
name|gdbarch_tdep
argument_list|(
name|arches
operator|->
name|gdbarch
argument_list|)
operator|->
name|mips64_transfers_32bit_regs_p
operator|!=
name|mips64_transfers_32bit_regs_p
condition|)
continue|continue;
comment|/* Be pedantic about which FPU is selected.  */
if|if
condition|(
name|gdbarch_tdep
argument_list|(
name|arches
operator|->
name|gdbarch
argument_list|)
operator|->
name|mips_fpu_type
operator|!=
name|fpu_type
condition|)
continue|continue;
return|return
name|arches
operator|->
name|gdbarch
return|;
block|}
comment|/* Need a new architecture.  Fill in a target specific vector.  */
name|tdep
operator|=
operator|(
expr|struct
name|gdbarch_tdep
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|gdbarch_tdep
argument_list|)
argument_list|)
expr_stmt|;
name|gdbarch
operator|=
name|gdbarch_alloc
argument_list|(
operator|&
name|info
argument_list|,
name|tdep
argument_list|)
expr_stmt|;
name|tdep
operator|->
name|elf_flags
operator|=
name|elf_flags
expr_stmt|;
name|tdep
operator|->
name|mips64_transfers_32bit_regs_p
operator|=
name|mips64_transfers_32bit_regs_p
expr_stmt|;
name|tdep
operator|->
name|found_abi
operator|=
name|found_abi
expr_stmt|;
name|tdep
operator|->
name|mips_abi
operator|=
name|mips_abi
expr_stmt|;
name|tdep
operator|->
name|mips_fpu_type
operator|=
name|fpu_type
expr_stmt|;
comment|/* Initially set everything according to the default ABI/ISA.  */
name|set_gdbarch_short_bit
argument_list|(
name|gdbarch
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|set_gdbarch_int_bit
argument_list|(
name|gdbarch
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|set_gdbarch_float_bit
argument_list|(
name|gdbarch
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|set_gdbarch_double_bit
argument_list|(
name|gdbarch
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|set_gdbarch_long_double_bit
argument_list|(
name|gdbarch
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|set_gdbarch_register_reggroup_p
argument_list|(
name|gdbarch
argument_list|,
name|mips_register_reggroup_p
argument_list|)
expr_stmt|;
name|set_gdbarch_pseudo_register_read
argument_list|(
name|gdbarch
argument_list|,
name|mips_pseudo_register_read
argument_list|)
expr_stmt|;
name|set_gdbarch_pseudo_register_write
argument_list|(
name|gdbarch
argument_list|,
name|mips_pseudo_register_write
argument_list|)
expr_stmt|;
name|set_gdbarch_elf_make_msymbol_special
argument_list|(
name|gdbarch
argument_list|,
name|mips_elf_make_msymbol_special
argument_list|)
expr_stmt|;
comment|/* Fill in the OS dependant register numbers and names.  */
block|{
specifier|const
name|char
modifier|*
modifier|*
name|reg_names
decl_stmt|;
name|struct
name|mips_regnum
modifier|*
name|regnum
init|=
name|GDBARCH_OBSTACK_ZALLOC
argument_list|(
name|gdbarch
argument_list|,
expr|struct
name|mips_regnum
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|.
name|osabi
operator|==
name|GDB_OSABI_IRIX
condition|)
block|{
name|regnum
operator|->
name|fp0
operator|=
literal|32
expr_stmt|;
name|regnum
operator|->
name|pc
operator|=
literal|64
expr_stmt|;
name|regnum
operator|->
name|cause
operator|=
literal|65
expr_stmt|;
name|regnum
operator|->
name|badvaddr
operator|=
literal|66
expr_stmt|;
name|regnum
operator|->
name|hi
operator|=
literal|67
expr_stmt|;
name|regnum
operator|->
name|lo
operator|=
literal|68
expr_stmt|;
name|regnum
operator|->
name|fp_control_status
operator|=
literal|69
expr_stmt|;
name|regnum
operator|->
name|fp_implementation_revision
operator|=
literal|70
expr_stmt|;
name|num_regs
operator|=
literal|71
expr_stmt|;
name|reg_names
operator|=
name|mips_irix_reg_names
expr_stmt|;
block|}
else|else
block|{
name|regnum
operator|->
name|lo
operator|=
name|MIPS_EMBED_LO_REGNUM
expr_stmt|;
name|regnum
operator|->
name|hi
operator|=
name|MIPS_EMBED_HI_REGNUM
expr_stmt|;
name|regnum
operator|->
name|badvaddr
operator|=
name|MIPS_EMBED_BADVADDR_REGNUM
expr_stmt|;
name|regnum
operator|->
name|cause
operator|=
name|MIPS_EMBED_CAUSE_REGNUM
expr_stmt|;
name|regnum
operator|->
name|pc
operator|=
name|MIPS_EMBED_PC_REGNUM
expr_stmt|;
name|regnum
operator|->
name|fp0
operator|=
name|MIPS_EMBED_FP0_REGNUM
expr_stmt|;
name|regnum
operator|->
name|fp_control_status
operator|=
literal|70
expr_stmt|;
name|regnum
operator|->
name|fp_implementation_revision
operator|=
literal|71
expr_stmt|;
name|num_regs
operator|=
literal|90
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|bfd_arch_info
operator|!=
name|NULL
operator|&&
name|info
operator|.
name|bfd_arch_info
operator|->
name|mach
operator|==
name|bfd_mach_mips3900
condition|)
name|reg_names
operator|=
name|mips_tx39_reg_names
expr_stmt|;
else|else
name|reg_names
operator|=
name|mips_generic_reg_names
expr_stmt|;
block|}
comment|/* FIXME: cagney/2003-11-15: For MIPS, hasn't PC_REGNUM been        replaced by read_pc?  */
name|set_gdbarch_pc_regnum
argument_list|(
name|gdbarch
argument_list|,
name|regnum
operator|->
name|pc
argument_list|)
expr_stmt|;
name|set_gdbarch_fp0_regnum
argument_list|(
name|gdbarch
argument_list|,
name|regnum
operator|->
name|fp0
argument_list|)
expr_stmt|;
name|set_gdbarch_num_regs
argument_list|(
name|gdbarch
argument_list|,
name|num_regs
argument_list|)
expr_stmt|;
name|set_gdbarch_num_pseudo_regs
argument_list|(
name|gdbarch
argument_list|,
name|num_regs
argument_list|)
expr_stmt|;
name|set_gdbarch_register_name
argument_list|(
name|gdbarch
argument_list|,
name|mips_register_name
argument_list|)
expr_stmt|;
name|tdep
operator|->
name|mips_processor_reg_names
operator|=
name|reg_names
expr_stmt|;
name|tdep
operator|->
name|regnum
operator|=
name|regnum
expr_stmt|;
block|}
switch|switch
condition|(
name|mips_abi
condition|)
block|{
case|case
name|MIPS_ABI_O32
case|:
name|set_gdbarch_push_dummy_call
argument_list|(
name|gdbarch
argument_list|,
name|mips_o32_push_dummy_call
argument_list|)
expr_stmt|;
name|set_gdbarch_return_value
argument_list|(
name|gdbarch
argument_list|,
name|mips_o32_return_value
argument_list|)
expr_stmt|;
name|tdep
operator|->
name|mips_default_saved_regsize
operator|=
literal|4
expr_stmt|;
name|tdep
operator|->
name|mips_default_stack_argsize
operator|=
literal|4
expr_stmt|;
name|tdep
operator|->
name|mips_fp_register_double
operator|=
literal|0
expr_stmt|;
name|tdep
operator|->
name|mips_last_arg_regnum
operator|=
name|A0_REGNUM
operator|+
literal|4
operator|-
literal|1
expr_stmt|;
name|tdep
operator|->
name|mips_last_fp_arg_regnum
operator|=
name|tdep
operator|->
name|regnum
operator|->
name|fp0
operator|+
literal|12
operator|+
literal|4
operator|-
literal|1
expr_stmt|;
name|tdep
operator|->
name|default_mask_address_p
operator|=
literal|0
expr_stmt|;
name|set_gdbarch_long_bit
argument_list|(
name|gdbarch
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|set_gdbarch_ptr_bit
argument_list|(
name|gdbarch
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|set_gdbarch_long_long_bit
argument_list|(
name|gdbarch
argument_list|,
literal|64
argument_list|)
expr_stmt|;
break|break;
case|case
name|MIPS_ABI_O64
case|:
name|set_gdbarch_push_dummy_call
argument_list|(
name|gdbarch
argument_list|,
name|mips_o64_push_dummy_call
argument_list|)
expr_stmt|;
name|set_gdbarch_deprecated_store_return_value
argument_list|(
name|gdbarch
argument_list|,
name|mips_o64_store_return_value
argument_list|)
expr_stmt|;
name|set_gdbarch_deprecated_extract_return_value
argument_list|(
name|gdbarch
argument_list|,
name|mips_o64_extract_return_value
argument_list|)
expr_stmt|;
name|tdep
operator|->
name|mips_default_saved_regsize
operator|=
literal|8
expr_stmt|;
name|tdep
operator|->
name|mips_default_stack_argsize
operator|=
literal|8
expr_stmt|;
name|tdep
operator|->
name|mips_fp_register_double
operator|=
literal|1
expr_stmt|;
name|tdep
operator|->
name|mips_last_arg_regnum
operator|=
name|A0_REGNUM
operator|+
literal|4
operator|-
literal|1
expr_stmt|;
name|tdep
operator|->
name|mips_last_fp_arg_regnum
operator|=
name|tdep
operator|->
name|regnum
operator|->
name|fp0
operator|+
literal|12
operator|+
literal|4
operator|-
literal|1
expr_stmt|;
name|tdep
operator|->
name|default_mask_address_p
operator|=
literal|0
expr_stmt|;
name|set_gdbarch_long_bit
argument_list|(
name|gdbarch
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|set_gdbarch_ptr_bit
argument_list|(
name|gdbarch
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|set_gdbarch_long_long_bit
argument_list|(
name|gdbarch
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|set_gdbarch_use_struct_convention
argument_list|(
name|gdbarch
argument_list|,
name|always_use_struct_convention
argument_list|)
expr_stmt|;
break|break;
case|case
name|MIPS_ABI_EABI32
case|:
name|set_gdbarch_push_dummy_call
argument_list|(
name|gdbarch
argument_list|,
name|mips_eabi_push_dummy_call
argument_list|)
expr_stmt|;
name|set_gdbarch_deprecated_store_return_value
argument_list|(
name|gdbarch
argument_list|,
name|mips_eabi_store_return_value
argument_list|)
expr_stmt|;
name|set_gdbarch_deprecated_extract_return_value
argument_list|(
name|gdbarch
argument_list|,
name|mips_eabi_extract_return_value
argument_list|)
expr_stmt|;
name|tdep
operator|->
name|mips_default_saved_regsize
operator|=
literal|4
expr_stmt|;
name|tdep
operator|->
name|mips_default_stack_argsize
operator|=
literal|4
expr_stmt|;
name|tdep
operator|->
name|mips_fp_register_double
operator|=
literal|0
expr_stmt|;
name|tdep
operator|->
name|mips_last_arg_regnum
operator|=
name|A0_REGNUM
operator|+
literal|8
operator|-
literal|1
expr_stmt|;
name|tdep
operator|->
name|mips_last_fp_arg_regnum
operator|=
name|tdep
operator|->
name|regnum
operator|->
name|fp0
operator|+
literal|12
operator|+
literal|8
operator|-
literal|1
expr_stmt|;
name|tdep
operator|->
name|default_mask_address_p
operator|=
literal|0
expr_stmt|;
name|set_gdbarch_long_bit
argument_list|(
name|gdbarch
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|set_gdbarch_ptr_bit
argument_list|(
name|gdbarch
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|set_gdbarch_long_long_bit
argument_list|(
name|gdbarch
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|set_gdbarch_deprecated_reg_struct_has_addr
argument_list|(
name|gdbarch
argument_list|,
name|mips_eabi_reg_struct_has_addr
argument_list|)
expr_stmt|;
name|set_gdbarch_use_struct_convention
argument_list|(
name|gdbarch
argument_list|,
name|mips_eabi_use_struct_convention
argument_list|)
expr_stmt|;
break|break;
case|case
name|MIPS_ABI_EABI64
case|:
name|set_gdbarch_push_dummy_call
argument_list|(
name|gdbarch
argument_list|,
name|mips_eabi_push_dummy_call
argument_list|)
expr_stmt|;
name|set_gdbarch_deprecated_store_return_value
argument_list|(
name|gdbarch
argument_list|,
name|mips_eabi_store_return_value
argument_list|)
expr_stmt|;
name|set_gdbarch_deprecated_extract_return_value
argument_list|(
name|gdbarch
argument_list|,
name|mips_eabi_extract_return_value
argument_list|)
expr_stmt|;
name|tdep
operator|->
name|mips_default_saved_regsize
operator|=
literal|8
expr_stmt|;
name|tdep
operator|->
name|mips_default_stack_argsize
operator|=
literal|8
expr_stmt|;
name|tdep
operator|->
name|mips_fp_register_double
operator|=
literal|1
expr_stmt|;
name|tdep
operator|->
name|mips_last_arg_regnum
operator|=
name|A0_REGNUM
operator|+
literal|8
operator|-
literal|1
expr_stmt|;
name|tdep
operator|->
name|mips_last_fp_arg_regnum
operator|=
name|tdep
operator|->
name|regnum
operator|->
name|fp0
operator|+
literal|12
operator|+
literal|8
operator|-
literal|1
expr_stmt|;
name|tdep
operator|->
name|default_mask_address_p
operator|=
literal|0
expr_stmt|;
name|set_gdbarch_long_bit
argument_list|(
name|gdbarch
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|set_gdbarch_ptr_bit
argument_list|(
name|gdbarch
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|set_gdbarch_long_long_bit
argument_list|(
name|gdbarch
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|set_gdbarch_deprecated_reg_struct_has_addr
argument_list|(
name|gdbarch
argument_list|,
name|mips_eabi_reg_struct_has_addr
argument_list|)
expr_stmt|;
name|set_gdbarch_use_struct_convention
argument_list|(
name|gdbarch
argument_list|,
name|mips_eabi_use_struct_convention
argument_list|)
expr_stmt|;
break|break;
case|case
name|MIPS_ABI_N32
case|:
name|set_gdbarch_push_dummy_call
argument_list|(
name|gdbarch
argument_list|,
name|mips_n32n64_push_dummy_call
argument_list|)
expr_stmt|;
name|set_gdbarch_return_value
argument_list|(
name|gdbarch
argument_list|,
name|mips_n32n64_return_value
argument_list|)
expr_stmt|;
name|tdep
operator|->
name|mips_default_saved_regsize
operator|=
literal|8
expr_stmt|;
name|tdep
operator|->
name|mips_default_stack_argsize
operator|=
literal|8
expr_stmt|;
name|tdep
operator|->
name|mips_fp_register_double
operator|=
literal|1
expr_stmt|;
name|tdep
operator|->
name|mips_last_arg_regnum
operator|=
name|A0_REGNUM
operator|+
literal|8
operator|-
literal|1
expr_stmt|;
name|tdep
operator|->
name|mips_last_fp_arg_regnum
operator|=
name|tdep
operator|->
name|regnum
operator|->
name|fp0
operator|+
literal|12
operator|+
literal|8
operator|-
literal|1
expr_stmt|;
name|tdep
operator|->
name|default_mask_address_p
operator|=
literal|0
expr_stmt|;
name|set_gdbarch_long_bit
argument_list|(
name|gdbarch
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|set_gdbarch_ptr_bit
argument_list|(
name|gdbarch
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|set_gdbarch_long_long_bit
argument_list|(
name|gdbarch
argument_list|,
literal|64
argument_list|)
expr_stmt|;
break|break;
case|case
name|MIPS_ABI_N64
case|:
name|set_gdbarch_push_dummy_call
argument_list|(
name|gdbarch
argument_list|,
name|mips_n32n64_push_dummy_call
argument_list|)
expr_stmt|;
name|set_gdbarch_return_value
argument_list|(
name|gdbarch
argument_list|,
name|mips_n32n64_return_value
argument_list|)
expr_stmt|;
name|tdep
operator|->
name|mips_default_saved_regsize
operator|=
literal|8
expr_stmt|;
name|tdep
operator|->
name|mips_default_stack_argsize
operator|=
literal|8
expr_stmt|;
name|tdep
operator|->
name|mips_fp_register_double
operator|=
literal|1
expr_stmt|;
name|tdep
operator|->
name|mips_last_arg_regnum
operator|=
name|A0_REGNUM
operator|+
literal|8
operator|-
literal|1
expr_stmt|;
name|tdep
operator|->
name|mips_last_fp_arg_regnum
operator|=
name|tdep
operator|->
name|regnum
operator|->
name|fp0
operator|+
literal|12
operator|+
literal|8
operator|-
literal|1
expr_stmt|;
name|tdep
operator|->
name|default_mask_address_p
operator|=
literal|0
expr_stmt|;
name|set_gdbarch_long_bit
argument_list|(
name|gdbarch
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|set_gdbarch_ptr_bit
argument_list|(
name|gdbarch
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|set_gdbarch_long_long_bit
argument_list|(
name|gdbarch
argument_list|,
literal|64
argument_list|)
expr_stmt|;
break|break;
default|default:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"unknown ABI in switch"
argument_list|)
expr_stmt|;
block|}
comment|/* FIXME: jlarmour/2000-04-07: There *is* a flag EF_MIPS_32BIT_MODE      that could indicate -gp32 BUT gas/config/tc-mips.c contains the      comment:       ``We deliberately don't allow "-gp32" to set the MIPS_32BITMODE      flag in object files because to do so would make it impossible to      link with libraries compiled without "-gp32".  This is      unnecessarily restrictive.       We could solve this problem by adding "-gp32" multilibs to gcc,      but to set this flag before gcc is built with such multilibs will      break too many systems.''       But even more unhelpfully, the default linker output target for      mips64-elf is elf32-bigmips, and has EF_MIPS_32BIT_MODE set, even      for 64-bit programs - you need to change the ABI to change this,      and not all gcc targets support that currently.  Therefore using      this flag to detect 32-bit mode would do the wrong thing given      the current gcc - it would make GDB treat these 64-bit programs      as 32-bit programs by default.  */
name|set_gdbarch_read_pc
argument_list|(
name|gdbarch
argument_list|,
name|mips_read_pc
argument_list|)
expr_stmt|;
name|set_gdbarch_write_pc
argument_list|(
name|gdbarch
argument_list|,
name|mips_write_pc
argument_list|)
expr_stmt|;
name|set_gdbarch_read_sp
argument_list|(
name|gdbarch
argument_list|,
name|mips_read_sp
argument_list|)
expr_stmt|;
comment|/* Add/remove bits from an address.  The MIPS needs be careful to      ensure that all 32 bit addresses are sign extended to 64 bits.  */
name|set_gdbarch_addr_bits_remove
argument_list|(
name|gdbarch
argument_list|,
name|mips_addr_bits_remove
argument_list|)
expr_stmt|;
comment|/* Unwind the frame.  */
name|set_gdbarch_unwind_pc
argument_list|(
name|gdbarch
argument_list|,
name|mips_unwind_pc
argument_list|)
expr_stmt|;
name|frame_unwind_append_sniffer
argument_list|(
name|gdbarch
argument_list|,
name|mips_mdebug_frame_sniffer
argument_list|)
expr_stmt|;
name|set_gdbarch_unwind_dummy_id
argument_list|(
name|gdbarch
argument_list|,
name|mips_unwind_dummy_id
argument_list|)
expr_stmt|;
name|frame_base_append_sniffer
argument_list|(
name|gdbarch
argument_list|,
name|mips_mdebug_frame_base_sniffer
argument_list|)
expr_stmt|;
comment|/* Map debug register numbers onto internal register numbers.  */
name|set_gdbarch_stab_reg_to_regnum
argument_list|(
name|gdbarch
argument_list|,
name|mips_stab_reg_to_regnum
argument_list|)
expr_stmt|;
name|set_gdbarch_ecoff_reg_to_regnum
argument_list|(
name|gdbarch
argument_list|,
name|mips_dwarf_dwarf2_ecoff_reg_to_regnum
argument_list|)
expr_stmt|;
name|set_gdbarch_dwarf_reg_to_regnum
argument_list|(
name|gdbarch
argument_list|,
name|mips_dwarf_dwarf2_ecoff_reg_to_regnum
argument_list|)
expr_stmt|;
name|set_gdbarch_dwarf2_reg_to_regnum
argument_list|(
name|gdbarch
argument_list|,
name|mips_dwarf_dwarf2_ecoff_reg_to_regnum
argument_list|)
expr_stmt|;
name|set_gdbarch_register_sim_regno
argument_list|(
name|gdbarch
argument_list|,
name|mips_register_sim_regno
argument_list|)
expr_stmt|;
comment|/* MIPS version of CALL_DUMMY */
comment|/* NOTE: cagney/2003-08-05: Eventually call dummy location will be      replaced by a command, and all targets will default to on stack      (regardless of the stack's execute status).  */
name|set_gdbarch_call_dummy_location
argument_list|(
name|gdbarch
argument_list|,
name|AT_SYMBOL
argument_list|)
expr_stmt|;
name|set_gdbarch_frame_align
argument_list|(
name|gdbarch
argument_list|,
name|mips_frame_align
argument_list|)
expr_stmt|;
name|set_gdbarch_convert_register_p
argument_list|(
name|gdbarch
argument_list|,
name|mips_convert_register_p
argument_list|)
expr_stmt|;
name|set_gdbarch_register_to_value
argument_list|(
name|gdbarch
argument_list|,
name|mips_register_to_value
argument_list|)
expr_stmt|;
name|set_gdbarch_value_to_register
argument_list|(
name|gdbarch
argument_list|,
name|mips_value_to_register
argument_list|)
expr_stmt|;
name|set_gdbarch_inner_than
argument_list|(
name|gdbarch
argument_list|,
name|core_addr_lessthan
argument_list|)
expr_stmt|;
name|set_gdbarch_breakpoint_from_pc
argument_list|(
name|gdbarch
argument_list|,
name|mips_breakpoint_from_pc
argument_list|)
expr_stmt|;
name|set_gdbarch_skip_prologue
argument_list|(
name|gdbarch
argument_list|,
name|mips_skip_prologue
argument_list|)
expr_stmt|;
name|set_gdbarch_pointer_to_address
argument_list|(
name|gdbarch
argument_list|,
name|signed_pointer_to_address
argument_list|)
expr_stmt|;
name|set_gdbarch_address_to_pointer
argument_list|(
name|gdbarch
argument_list|,
name|address_to_signed_pointer
argument_list|)
expr_stmt|;
name|set_gdbarch_integer_to_address
argument_list|(
name|gdbarch
argument_list|,
name|mips_integer_to_address
argument_list|)
expr_stmt|;
name|set_gdbarch_register_type
argument_list|(
name|gdbarch
argument_list|,
name|mips_register_type
argument_list|)
expr_stmt|;
name|set_gdbarch_print_registers_info
argument_list|(
name|gdbarch
argument_list|,
name|mips_print_registers_info
argument_list|)
expr_stmt|;
name|set_gdbarch_pc_in_sigtramp
argument_list|(
name|gdbarch
argument_list|,
name|mips_pc_in_sigtramp
argument_list|)
expr_stmt|;
name|set_gdbarch_print_insn
argument_list|(
name|gdbarch
argument_list|,
name|gdb_print_insn_mips
argument_list|)
expr_stmt|;
comment|/* FIXME: cagney/2003-08-29: The macros HAVE_STEPPABLE_WATCHPOINT,      HAVE_NONSTEPPABLE_WATCHPOINT, and HAVE_CONTINUABLE_WATCHPOINT      need to all be folded into the target vector.  Since they are      being used as guards for STOPPED_BY_WATCHPOINT, why not have      STOPPED_BY_WATCHPOINT return the type of watchpoint that the code      is sitting on?  */
name|set_gdbarch_have_nonsteppable_watchpoint
argument_list|(
name|gdbarch
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|set_gdbarch_skip_trampoline_code
argument_list|(
name|gdbarch
argument_list|,
name|mips_skip_stub
argument_list|)
expr_stmt|;
comment|/* NOTE drow/2004-02-11: We overload the core solib trampoline code      to support MIPS16.  This is a bad thing.  Make sure not to do it      if we have an OS ABI that actually supports shared libraries, since      shared library support is more important.  If we have an OS someday      that supports both shared libraries and MIPS16, we'll have to find      a better place for these.  */
if|if
condition|(
name|info
operator|.
name|osabi
operator|==
name|GDB_OSABI_UNKNOWN
condition|)
block|{
name|set_gdbarch_in_solib_call_trampoline
argument_list|(
name|gdbarch
argument_list|,
name|mips_in_call_stub
argument_list|)
expr_stmt|;
name|set_gdbarch_in_solib_return_trampoline
argument_list|(
name|gdbarch
argument_list|,
name|mips_in_return_stub
argument_list|)
expr_stmt|;
block|}
comment|/* Hook in OS ABI-specific overrides, if they have been registered.  */
name|gdbarch_init_osabi
argument_list|(
name|info
argument_list|,
name|gdbarch
argument_list|)
expr_stmt|;
return|return
name|gdbarch
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mips_abi_update
parameter_list|(
name|char
modifier|*
name|ignore_args
parameter_list|,
name|int
name|from_tty
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
name|c
parameter_list|)
block|{
name|struct
name|gdbarch_info
name|info
decl_stmt|;
comment|/* Force the architecture to update, and (if it's a MIPS architecture)      mips_gdbarch_init will take care of the rest.  */
name|gdbarch_info_init
argument_list|(
operator|&
name|info
argument_list|)
expr_stmt|;
name|gdbarch_update_p
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print out which MIPS ABI is in use.  */
end_comment

begin_function
specifier|static
name|void
name|show_mips_abi
parameter_list|(
name|char
modifier|*
name|ignore_args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
if|if
condition|(
name|gdbarch_bfd_arch_info
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|arch
operator|!=
name|bfd_arch_mips
condition|)
name|printf_filtered
argument_list|(
literal|"The MIPS ABI is unknown because the current architecture is not MIPS.\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|enum
name|mips_abi
name|global_abi
init|=
name|global_mips_abi
argument_list|()
decl_stmt|;
name|enum
name|mips_abi
name|actual_abi
init|=
name|mips_abi
argument_list|(
name|current_gdbarch
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|actual_abi_str
init|=
name|mips_abi_strings
index|[
name|actual_abi
index|]
decl_stmt|;
if|if
condition|(
name|global_abi
operator|==
name|MIPS_ABI_UNKNOWN
condition|)
name|printf_filtered
argument_list|(
literal|"The MIPS ABI is set automatically (currently \"%s\").\n"
argument_list|,
name|actual_abi_str
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|global_abi
operator|==
name|actual_abi
condition|)
name|printf_filtered
argument_list|(
literal|"The MIPS ABI is assumed to be \"%s\" (due to user setting).\n"
argument_list|,
name|actual_abi_str
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Probably shouldn't happen...  */
name|printf_filtered
argument_list|(
literal|"The (auto detected) MIPS ABI \"%s\" is in use even though the user setting was \"%s\".\n"
argument_list|,
name|actual_abi_str
argument_list|,
name|mips_abi_strings
index|[
name|global_abi
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mips_dump_tdep
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|current_gdbarch
parameter_list|,
name|struct
name|ui_file
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
decl_stmt|;
if|if
condition|(
name|tdep
operator|!=
name|NULL
condition|)
block|{
name|int
name|ef_mips_arch
decl_stmt|;
name|int
name|ef_mips_32bitmode
decl_stmt|;
comment|/* determine the ISA */
switch|switch
condition|(
name|tdep
operator|->
name|elf_flags
operator|&
name|EF_MIPS_ARCH
condition|)
block|{
case|case
name|E_MIPS_ARCH_1
case|:
name|ef_mips_arch
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|E_MIPS_ARCH_2
case|:
name|ef_mips_arch
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|E_MIPS_ARCH_3
case|:
name|ef_mips_arch
operator|=
literal|3
expr_stmt|;
break|break;
case|case
name|E_MIPS_ARCH_4
case|:
name|ef_mips_arch
operator|=
literal|4
expr_stmt|;
break|break;
default|default:
name|ef_mips_arch
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* determine the size of a pointer */
name|ef_mips_32bitmode
operator|=
operator|(
name|tdep
operator|->
name|elf_flags
operator|&
name|EF_MIPS_32BITMODE
operator|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"mips_dump_tdep: tdep->elf_flags = 0x%x\n"
argument_list|,
name|tdep
operator|->
name|elf_flags
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"mips_dump_tdep: ef_mips_32bitmode = %d\n"
argument_list|,
name|ef_mips_32bitmode
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"mips_dump_tdep: ef_mips_arch = %d\n"
argument_list|,
name|ef_mips_arch
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"mips_dump_tdep: tdep->mips_abi = %d (%s)\n"
argument_list|,
name|tdep
operator|->
name|mips_abi
argument_list|,
name|mips_abi_strings
index|[
name|tdep
operator|->
name|mips_abi
index|]
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"mips_dump_tdep: mips_mask_address_p() %d (default %d)\n"
argument_list|,
name|mips_mask_address_p
argument_list|(
name|tdep
argument_list|)
argument_list|,
name|tdep
operator|->
name|default_mask_address_p
argument_list|)
expr_stmt|;
block|}
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"mips_dump_tdep: FP_REGISTER_DOUBLE = %d\n"
argument_list|,
name|FP_REGISTER_DOUBLE
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"mips_dump_tdep: MIPS_DEFAULT_FPU_TYPE = %d (%s)\n"
argument_list|,
name|MIPS_DEFAULT_FPU_TYPE
argument_list|,
operator|(
name|MIPS_DEFAULT_FPU_TYPE
operator|==
name|MIPS_FPU_NONE
condition|?
literal|"none"
else|:
name|MIPS_DEFAULT_FPU_TYPE
operator|==
name|MIPS_FPU_SINGLE
condition|?
literal|"single"
else|:
name|MIPS_DEFAULT_FPU_TYPE
operator|==
name|MIPS_FPU_DOUBLE
condition|?
literal|"double"
else|:
literal|"???"
operator|)
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"mips_dump_tdep: MIPS_EABI = %d\n"
argument_list|,
name|MIPS_EABI
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"mips_dump_tdep: MIPS_FPU_TYPE = %d (%s)\n"
argument_list|,
name|MIPS_FPU_TYPE
argument_list|,
operator|(
name|MIPS_FPU_TYPE
operator|==
name|MIPS_FPU_NONE
condition|?
literal|"none"
else|:
name|MIPS_FPU_TYPE
operator|==
name|MIPS_FPU_SINGLE
condition|?
literal|"single"
else|:
name|MIPS_FPU_TYPE
operator|==
name|MIPS_FPU_DOUBLE
condition|?
literal|"double"
else|:
literal|"???"
operator|)
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"mips_dump_tdep: FP_REGISTER_DOUBLE = %d\n"
argument_list|,
name|FP_REGISTER_DOUBLE
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"mips_dump_tdep: mips_stack_argsize() = %d\n"
argument_list|,
name|mips_stack_argsize
argument_list|(
name|tdep
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"mips_dump_tdep: A0_REGNUM = %d\n"
argument_list|,
name|A0_REGNUM
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"mips_dump_tdep: ADDR_BITS_REMOVE # %s\n"
argument_list|,
name|XSTRING
argument_list|(
name|ADDR_BITS_REMOVE
argument_list|(
name|ADDR
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"mips_dump_tdep: ATTACH_DETACH # %s\n"
argument_list|,
name|XSTRING
argument_list|(
name|ATTACH_DETACH
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"mips_dump_tdep: DWARF_REG_TO_REGNUM # %s\n"
argument_list|,
name|XSTRING
argument_list|(
name|DWARF_REG_TO_REGNUM
argument_list|(
name|REGNUM
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"mips_dump_tdep: ECOFF_REG_TO_REGNUM # %s\n"
argument_list|,
name|XSTRING
argument_list|(
name|ECOFF_REG_TO_REGNUM
argument_list|(
name|REGNUM
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"mips_dump_tdep: FIRST_EMBED_REGNUM = %d\n"
argument_list|,
name|FIRST_EMBED_REGNUM
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"mips_dump_tdep: IGNORE_HELPER_CALL # %s\n"
argument_list|,
name|XSTRING
argument_list|(
name|IGNORE_HELPER_CALL
argument_list|(
name|PC
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"mips_dump_tdep: IN_SOLIB_CALL_TRAMPOLINE # %s\n"
argument_list|,
name|XSTRING
argument_list|(
name|IN_SOLIB_CALL_TRAMPOLINE
argument_list|(
name|PC
argument_list|,
name|NAME
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"mips_dump_tdep: IN_SOLIB_RETURN_TRAMPOLINE # %s\n"
argument_list|,
name|XSTRING
argument_list|(
name|IN_SOLIB_RETURN_TRAMPOLINE
argument_list|(
name|PC
argument_list|,
name|NAME
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"mips_dump_tdep: LAST_EMBED_REGNUM = %d\n"
argument_list|,
name|LAST_EMBED_REGNUM
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MACHINE_CPROC_FP_OFFSET
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"mips_dump_tdep: MACHINE_CPROC_FP_OFFSET = %d\n"
argument_list|,
name|MACHINE_CPROC_FP_OFFSET
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MACHINE_CPROC_PC_OFFSET
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"mips_dump_tdep: MACHINE_CPROC_PC_OFFSET = %d\n"
argument_list|,
name|MACHINE_CPROC_PC_OFFSET
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MACHINE_CPROC_SP_OFFSET
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"mips_dump_tdep: MACHINE_CPROC_SP_OFFSET = %d\n"
argument_list|,
name|MACHINE_CPROC_SP_OFFSET
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"mips_dump_tdep: MIPS16_INSTLEN = %d\n"
argument_list|,
name|MIPS16_INSTLEN
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"mips_dump_tdep: MIPS_DEFAULT_ABI = FIXME!\n"
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"mips_dump_tdep: MIPS_EFI_SYMBOL_NAME = multi-arch!!\n"
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"mips_dump_tdep: MIPS_INSTLEN = %d\n"
argument_list|,
name|MIPS_INSTLEN
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"mips_dump_tdep: MIPS_LAST_ARG_REGNUM = %d (%d regs)\n"
argument_list|,
name|MIPS_LAST_ARG_REGNUM
argument_list|,
name|MIPS_LAST_ARG_REGNUM
operator|-
name|A0_REGNUM
operator|+
literal|1
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"mips_dump_tdep: MIPS_NUMREGS = %d\n"
argument_list|,
name|MIPS_NUMREGS
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"mips_dump_tdep: mips_saved_regsize() = %d\n"
argument_list|,
name|mips_saved_regsize
argument_list|(
name|tdep
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"mips_dump_tdep: PRID_REGNUM = %d\n"
argument_list|,
name|PRID_REGNUM
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"mips_dump_tdep: PROC_DESC_IS_DUMMY = function?\n"
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"mips_dump_tdep: PROC_FRAME_ADJUST = function?\n"
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"mips_dump_tdep: PROC_FRAME_OFFSET = function?\n"
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"mips_dump_tdep: PROC_FRAME_REG = function?\n"
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"mips_dump_tdep: PROC_FREG_MASK = function?\n"
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"mips_dump_tdep: PROC_FREG_OFFSET = function?\n"
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"mips_dump_tdep: PROC_HIGH_ADDR = function?\n"
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"mips_dump_tdep: PROC_LOW_ADDR = function?\n"
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"mips_dump_tdep: PROC_PC_REG = function?\n"
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"mips_dump_tdep: PROC_REG_MASK = function?\n"
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"mips_dump_tdep: PROC_REG_OFFSET = function?\n"
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"mips_dump_tdep: PROC_SYMBOL = function?\n"
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"mips_dump_tdep: PS_REGNUM = %d\n"
argument_list|,
name|PS_REGNUM
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"mips_dump_tdep: RA_REGNUM = %d\n"
argument_list|,
name|RA_REGNUM
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SAVED_BYTES
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"mips_dump_tdep: SAVED_BYTES = %d\n"
argument_list|,
name|SAVED_BYTES
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SAVED_FP
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"mips_dump_tdep: SAVED_FP = %d\n"
argument_list|,
name|SAVED_FP
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SAVED_PC
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"mips_dump_tdep: SAVED_PC = %d\n"
argument_list|,
name|SAVED_PC
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"mips_dump_tdep: SETUP_ARBITRARY_FRAME # %s\n"
argument_list|,
name|XSTRING
argument_list|(
name|SETUP_ARBITRARY_FRAME
argument_list|(
name|NUMARGS
argument_list|,
name|ARGS
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"mips_dump_tdep: SET_PROC_DESC_IS_DUMMY = function?\n"
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"mips_dump_tdep: SKIP_TRAMPOLINE_CODE # %s\n"
argument_list|,
name|XSTRING
argument_list|(
name|SKIP_TRAMPOLINE_CODE
argument_list|(
name|PC
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"mips_dump_tdep: SOFTWARE_SINGLE_STEP # %s\n"
argument_list|,
name|XSTRING
argument_list|(
name|SOFTWARE_SINGLE_STEP
argument_list|(
name|SIG
argument_list|,
name|BP_P
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"mips_dump_tdep: SOFTWARE_SINGLE_STEP_P () = %d\n"
argument_list|,
name|SOFTWARE_SINGLE_STEP_P
argument_list|()
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"mips_dump_tdep: STAB_REG_TO_REGNUM # %s\n"
argument_list|,
name|XSTRING
argument_list|(
name|STAB_REG_TO_REGNUM
argument_list|(
name|REGNUM
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|STACK_END_ADDR
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"mips_dump_tdep: STACK_END_ADDR = %d\n"
argument_list|,
name|STACK_END_ADDR
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"mips_dump_tdep: STEP_SKIPS_DELAY # %s\n"
argument_list|,
name|XSTRING
argument_list|(
name|STEP_SKIPS_DELAY
argument_list|(
name|PC
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"mips_dump_tdep: STEP_SKIPS_DELAY_P = %d\n"
argument_list|,
name|STEP_SKIPS_DELAY_P
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"mips_dump_tdep: STOPPED_BY_WATCHPOINT # %s\n"
argument_list|,
name|XSTRING
argument_list|(
name|STOPPED_BY_WATCHPOINT
argument_list|(
name|WS
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"mips_dump_tdep: T9_REGNUM = %d\n"
argument_list|,
name|T9_REGNUM
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"mips_dump_tdep: TABULAR_REGISTER_OUTPUT = used?\n"
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"mips_dump_tdep: TARGET_CAN_USE_HARDWARE_WATCHPOINT # %s\n"
argument_list|,
name|XSTRING
argument_list|(
name|TARGET_CAN_USE_HARDWARE_WATCHPOINT
argument_list|(
name|TYPE
argument_list|,
name|CNT
argument_list|,
name|OTHERTYPE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"mips_dump_tdep: TARGET_HAS_HARDWARE_WATCHPOINTS # %s\n"
argument_list|,
name|XSTRING
argument_list|(
name|TARGET_HAS_HARDWARE_WATCHPOINTS
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TRACE_CLEAR
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"mips_dump_tdep: TRACE_CLEAR # %s\n"
argument_list|,
name|XSTRING
argument_list|(
name|TRACE_CLEAR
argument_list|(
name|THREAD
argument_list|,
name|STATE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TRACE_FLAVOR
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"mips_dump_tdep: TRACE_FLAVOR = %d\n"
argument_list|,
name|TRACE_FLAVOR
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TRACE_FLAVOR_SIZE
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"mips_dump_tdep: TRACE_FLAVOR_SIZE = %d\n"
argument_list|,
name|TRACE_FLAVOR_SIZE
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TRACE_SET
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"mips_dump_tdep: TRACE_SET # %s\n"
argument_list|,
name|XSTRING
argument_list|(
name|TRACE_SET
argument_list|(
name|X
argument_list|,
name|STATE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|UNUSED_REGNUM
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"mips_dump_tdep: UNUSED_REGNUM = %d\n"
argument_list|,
name|UNUSED_REGNUM
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"mips_dump_tdep: V0_REGNUM = %d\n"
argument_list|,
name|V0_REGNUM
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"mips_dump_tdep: VM_MIN_ADDRESS = %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|VM_MIN_ADDRESS
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"mips_dump_tdep: ZERO_REGNUM = %d\n"
argument_list|,
name|ZERO_REGNUM
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"mips_dump_tdep: _PROC_MAGIC_ = %d\n"
argument_list|,
name|_PROC_MAGIC_
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|extern
name|initialize_file_ftype
name|_initialize_mips_tdep
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -Wmissing-prototypes */
end_comment

begin_function
name|void
name|_initialize_mips_tdep
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|struct
name|cmd_list_element
modifier|*
name|mipsfpulist
init|=
name|NULL
decl_stmt|;
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
name|mips_abi_string
operator|=
name|mips_abi_strings
index|[
name|MIPS_ABI_UNKNOWN
index|]
expr_stmt|;
if|if
condition|(
name|MIPS_ABI_LAST
operator|+
literal|1
operator|!=
sizeof|sizeof
argument_list|(
name|mips_abi_strings
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|mips_abi_strings
index|[
literal|0
index|]
argument_list|)
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"mips_abi_strings out of sync"
argument_list|)
expr_stmt|;
name|gdbarch_register
argument_list|(
name|bfd_arch_mips
argument_list|,
name|mips_gdbarch_init
argument_list|,
name|mips_dump_tdep
argument_list|)
expr_stmt|;
name|mips_pdr_data
operator|=
name|register_objfile_data
argument_list|()
expr_stmt|;
comment|/* Add root prefix command for all "set mips"/"show mips" commands */
name|add_prefix_cmd
argument_list|(
literal|"mips"
argument_list|,
name|no_class
argument_list|,
name|set_mips_command
argument_list|,
literal|"Various MIPS specific commands."
argument_list|,
operator|&
name|setmipscmdlist
argument_list|,
literal|"set mips "
argument_list|,
literal|0
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"mips"
argument_list|,
name|no_class
argument_list|,
name|show_mips_command
argument_list|,
literal|"Various MIPS specific commands."
argument_list|,
operator|&
name|showmipscmdlist
argument_list|,
literal|"show mips "
argument_list|,
literal|0
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
comment|/* Allow the user to override the saved register size. */
name|add_show_from_set
argument_list|(
name|add_set_enum_cmd
argument_list|(
literal|"saved-gpreg-size"
argument_list|,
name|class_obscure
argument_list|,
name|size_enums
argument_list|,
operator|&
name|mips_saved_regsize_string
argument_list|,
literal|"\ Set size of general purpose registers saved on the stack.\n\ This option can be set to one of:\n\   32    - Force GDB to treat saved GP registers as 32-bit\n\   64    - Force GDB to treat saved GP registers as 64-bit\n\   auto  - Allow GDB to use the target's default setting or autodetect the\n\           saved GP register size from information contained in the executable.\n\           (default: auto)"
argument_list|,
operator|&
name|setmipscmdlist
argument_list|)
argument_list|,
operator|&
name|showmipscmdlist
argument_list|)
expr_stmt|;
comment|/* Allow the user to override the argument stack size. */
name|add_show_from_set
argument_list|(
name|add_set_enum_cmd
argument_list|(
literal|"stack-arg-size"
argument_list|,
name|class_obscure
argument_list|,
name|size_enums
argument_list|,
operator|&
name|mips_stack_argsize_string
argument_list|,
literal|"\ Set the amount of stack space reserved for each argument.\n\ This option can be set to one of:\n\   32    - Force GDB to allocate 32-bit chunks per argument\n\   64    - Force GDB to allocate 64-bit chunks per argument\n\   auto  - Allow GDB to determine the correct setting from the current\n\           target and executable (default)"
argument_list|,
operator|&
name|setmipscmdlist
argument_list|)
argument_list|,
operator|&
name|showmipscmdlist
argument_list|)
expr_stmt|;
comment|/* Allow the user to override the ABI. */
name|c
operator|=
name|add_set_enum_cmd
argument_list|(
literal|"abi"
argument_list|,
name|class_obscure
argument_list|,
name|mips_abi_strings
argument_list|,
operator|&
name|mips_abi_string
argument_list|,
literal|"Set the ABI used by this program.\n"
literal|"This option can be set to one of:\n"
literal|"  auto  - the default ABI associated with the current binary\n"
literal|"  o32\n"
literal|"  o64\n"
literal|"  n32\n"
literal|"  n64\n"
literal|"  eabi32\n"
literal|"  eabi64"
argument_list|,
operator|&
name|setmipscmdlist
argument_list|)
expr_stmt|;
name|set_cmd_sfunc
argument_list|(
name|c
argument_list|,
name|mips_abi_update
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"abi"
argument_list|,
name|class_obscure
argument_list|,
name|show_mips_abi
argument_list|,
literal|"Show ABI in use by MIPS target"
argument_list|,
operator|&
name|showmipscmdlist
argument_list|)
expr_stmt|;
comment|/* Let the user turn off floating point and set the fence post for      heuristic_proc_start.  */
name|add_prefix_cmd
argument_list|(
literal|"mipsfpu"
argument_list|,
name|class_support
argument_list|,
name|set_mipsfpu_command
argument_list|,
literal|"Set use of MIPS floating-point coprocessor."
argument_list|,
operator|&
name|mipsfpulist
argument_list|,
literal|"set mipsfpu "
argument_list|,
literal|0
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"single"
argument_list|,
name|class_support
argument_list|,
name|set_mipsfpu_single_command
argument_list|,
literal|"Select single-precision MIPS floating-point coprocessor."
argument_list|,
operator|&
name|mipsfpulist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"double"
argument_list|,
name|class_support
argument_list|,
name|set_mipsfpu_double_command
argument_list|,
literal|"Select double-precision MIPS floating-point coprocessor."
argument_list|,
operator|&
name|mipsfpulist
argument_list|)
expr_stmt|;
name|add_alias_cmd
argument_list|(
literal|"on"
argument_list|,
literal|"double"
argument_list|,
name|class_support
argument_list|,
literal|1
argument_list|,
operator|&
name|mipsfpulist
argument_list|)
expr_stmt|;
name|add_alias_cmd
argument_list|(
literal|"yes"
argument_list|,
literal|"double"
argument_list|,
name|class_support
argument_list|,
literal|1
argument_list|,
operator|&
name|mipsfpulist
argument_list|)
expr_stmt|;
name|add_alias_cmd
argument_list|(
literal|"1"
argument_list|,
literal|"double"
argument_list|,
name|class_support
argument_list|,
literal|1
argument_list|,
operator|&
name|mipsfpulist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"none"
argument_list|,
name|class_support
argument_list|,
name|set_mipsfpu_none_command
argument_list|,
literal|"Select no MIPS floating-point coprocessor."
argument_list|,
operator|&
name|mipsfpulist
argument_list|)
expr_stmt|;
name|add_alias_cmd
argument_list|(
literal|"off"
argument_list|,
literal|"none"
argument_list|,
name|class_support
argument_list|,
literal|1
argument_list|,
operator|&
name|mipsfpulist
argument_list|)
expr_stmt|;
name|add_alias_cmd
argument_list|(
literal|"no"
argument_list|,
literal|"none"
argument_list|,
name|class_support
argument_list|,
literal|1
argument_list|,
operator|&
name|mipsfpulist
argument_list|)
expr_stmt|;
name|add_alias_cmd
argument_list|(
literal|"0"
argument_list|,
literal|"none"
argument_list|,
name|class_support
argument_list|,
literal|1
argument_list|,
operator|&
name|mipsfpulist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"auto"
argument_list|,
name|class_support
argument_list|,
name|set_mipsfpu_auto_command
argument_list|,
literal|"Select MIPS floating-point coprocessor automatically."
argument_list|,
operator|&
name|mipsfpulist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"mipsfpu"
argument_list|,
name|class_support
argument_list|,
name|show_mipsfpu_command
argument_list|,
literal|"Show current use of MIPS floating-point coprocessor target."
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
comment|/* We really would like to have both "0" and "unlimited" work, but      command.c doesn't deal with that.  So make it a var_zinteger      because the user can always use "999999" or some such for unlimited.  */
name|c
operator|=
name|add_set_cmd
argument_list|(
literal|"heuristic-fence-post"
argument_list|,
name|class_support
argument_list|,
name|var_zinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|heuristic_fence_post
argument_list|,
literal|"\ Set the distance searched for the start of a function.\n\ If you are debugging a stripped executable, GDB needs to search through the\n\ program for the start of a function.  This command sets the distance of the\n\ search.  The only need to set it is when debugging a stripped executable."
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
comment|/* We need to throw away the frame cache when we set this, since it      might change our ability to get backtraces.  */
name|set_cmd_sfunc
argument_list|(
name|c
argument_list|,
name|reinit_frame_cache_sfunc
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|c
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
comment|/* Allow the user to control whether the upper bits of 64-bit      addresses should be zeroed.  */
name|add_setshow_auto_boolean_cmd
argument_list|(
literal|"mask-address"
argument_list|,
name|no_class
argument_list|,
operator|&
name|mask_address_var
argument_list|,
literal|"\ Set zeroing of upper 32 bits of 64-bit addresses.\n\ Use \"on\" to enable the masking, \"off\" to disable it and \"auto\" to \n\ allow GDB to determine the correct value.\n"
argument_list|,
literal|"\ Show zeroing of upper 32 bits of 64-bit addresses."
argument_list|,
name|NULL
argument_list|,
name|show_mask_address
argument_list|,
operator|&
name|setmipscmdlist
argument_list|,
operator|&
name|showmipscmdlist
argument_list|)
expr_stmt|;
comment|/* Allow the user to control the size of 32 bit registers within the      raw remote packet.  */
name|add_setshow_cmd
argument_list|(
literal|"remote-mips64-transfers-32bit-regs"
argument_list|,
name|class_obscure
argument_list|,
name|var_boolean
argument_list|,
operator|&
name|mips64_transfers_32bit_regs_p
argument_list|,
literal|"\ Set compatibility with 64-bit MIPS targets that transfer 32-bit quantities.\n\ Use \"on\" to enable backward compatibility with older MIPS 64 GDB+target\n\ that would transfer 32 bits for some registers (e.g. SR, FSR) and\n\ 64 bits for others.  Use \"off\" to disable compatibility mode"
argument_list|,
literal|"\ Show compatibility with 64-bit MIPS targets that transfer 32-bit quantities.\n\ Use \"on\" to enable backward compatibility with older MIPS 64 GDB+target\n\ that would transfer 32 bits for some registers (e.g. SR, FSR) and\n\ 64 bits for others.  Use \"off\" to disable compatibility mode"
argument_list|,
name|set_mips64_transfers_32bit_regs
argument_list|,
name|NULL
argument_list|,
operator|&
name|setlist
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
comment|/* Debug this files internals. */
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"mips"
argument_list|,
name|class_maintenance
argument_list|,
name|var_zinteger
argument_list|,
operator|&
name|mips_debug
argument_list|,
literal|"Set mips debugging.\n\ When non-zero, mips specific debugging is enabled."
argument_list|,
operator|&
name|setdebuglist
argument_list|)
argument_list|,
operator|&
name|showdebuglist
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

