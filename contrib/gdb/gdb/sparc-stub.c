begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/****************************************************************************  		THIS SOFTWARE IS NOT COPYRIGHTED     HP offers the following for use in the public domain.  HP makes no    warranty with regard to the software or it's performance and the    user accepts the software "AS IS" with all faults.     HP DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED, WITH REGARD    TO THIS SOFTWARE INCLUDING BUT NOT LIMITED TO THE WARRANTIES    OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  ****************************************************************************/
end_comment

begin_comment
comment|/****************************************************************************  *  Header: remcom.c,v 1.34 91/03/09 12:29:49 glenne Exp $  *  *  Module name: remcom.c $  *  Revision: 1.34 $  *  Date: 91/03/09 12:29:49 $  *  Contributor:     Lake Stevens Instrument Division$  *  *  Description:     low level support for gdb debugger. $  *  *  Considerations:  only works on target hardware $  *  *  Written by:      Glenn Engel $  *  ModuleState:     Experimental $  *  *  NOTES:           See Below $  *  *  Modified for SPARC by Stu Grossman, Cygnus Support.  *  *  This code has been extensively tested on the Fujitsu SPARClite demo board.  *  *  To enable debugger support, two things need to happen.  One, a  *  call to set_debug_traps() is necessary in order to allow any breakpoints  *  or error conditions to be properly intercepted and reported to gdb.  *  Two, a breakpoint needs to be generated to begin communication.  This  *  is most easily accomplished by a call to breakpoint().  Breakpoint()  *  simulates a breakpoint by executing a trap #1.  *  *************  *  *    The following gdb commands are supported:  *  * command          function                               Return value  *  *    g             return the value of the CPU registers  hex data or ENN  *    G             set the value of the CPU registers     OK or ENN  *  *    mAA..AA,LLLL  Read LLLL bytes at address AA..AA      hex data or ENN  *    MAA..AA,LLLL: Write LLLL bytes at address AA.AA      OK or ENN  *  *    c             Resume at current address              SNN   ( signal NN)  *    cAA..AA       Continue at address AA..AA             SNN  *  *    s             Step one instruction                   SNN  *    sAA..AA       Step one instruction from AA..AA       SNN  *  *    k             kill  *  *    ?             What was the last sigval ?             SNN   (signal NN)  *  * All commands and responses are sent with a packet which includes a  * checksum.  A packet consists of  *  * $<packet info>#<checksum>.  *  * where  *<packet info> ::<characters representing the command or response>  *<checksum>    ::< two hex digits computed as modulo 256 sum of<packetinfo>>  *  * When a packet is received, it is first acknowledged with either '+' or '-'.  * '+' indicates a successful transfer.  '-' indicates a failed transfer.  *  * Example:  *  * Host:                  Reply:  * $m0,10#2a               +$00010203040506070809101112131415#42  *  ****************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_comment
comment|/************************************************************************  *  * external low-level support routines  */
end_comment

begin_function_decl
specifier|extern
name|void
name|putDebugChar
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* write a single character      */
end_comment

begin_function_decl
specifier|extern
name|int
name|getDebugChar
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* read and return a single char */
end_comment

begin_comment
comment|/************************************************************************/
end_comment

begin_comment
comment|/* BUFMAX defines the maximum number of characters in inbound/outbound buffers*/
end_comment

begin_comment
comment|/* at least NUMREGBYTES*2 are needed for register packets */
end_comment

begin_define
define|#
directive|define
name|BUFMAX
value|2048
end_define

begin_decl_stmt
specifier|static
name|int
name|initialized
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* !0 means we've been initialized */
end_comment

begin_function_decl
specifier|static
name|void
name|set_mem_fault_trap
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
specifier|const
name|char
name|hexchars
index|[]
init|=
literal|"0123456789abcdef"
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NUMREGS
value|72
end_define

begin_comment
comment|/* Number of bytes of registers.  */
end_comment

begin_define
define|#
directive|define
name|NUMREGBYTES
value|(NUMREGS * 4)
end_define

begin_enum
enum|enum
name|regnames
block|{
name|G0
block|,
name|G1
block|,
name|G2
block|,
name|G3
block|,
name|G4
block|,
name|G5
block|,
name|G6
block|,
name|G7
block|,
name|O0
block|,
name|O1
block|,
name|O2
block|,
name|O3
block|,
name|O4
block|,
name|O5
block|,
name|SP
block|,
name|O7
block|,
name|L0
block|,
name|L1
block|,
name|L2
block|,
name|L3
block|,
name|L4
block|,
name|L5
block|,
name|L6
block|,
name|L7
block|,
name|I0
block|,
name|I1
block|,
name|I2
block|,
name|I3
block|,
name|I4
block|,
name|I5
block|,
name|FP
block|,
name|I7
block|,
name|F0
block|,
name|F1
block|,
name|F2
block|,
name|F3
block|,
name|F4
block|,
name|F5
block|,
name|F6
block|,
name|F7
block|,
name|F8
block|,
name|F9
block|,
name|F10
block|,
name|F11
block|,
name|F12
block|,
name|F13
block|,
name|F14
block|,
name|F15
block|,
name|F16
block|,
name|F17
block|,
name|F18
block|,
name|F19
block|,
name|F20
block|,
name|F21
block|,
name|F22
block|,
name|F23
block|,
name|F24
block|,
name|F25
block|,
name|F26
block|,
name|F27
block|,
name|F28
block|,
name|F29
block|,
name|F30
block|,
name|F31
block|,
name|Y
block|,
name|PSR
block|,
name|WIM
block|,
name|TBR
block|,
name|PC
block|,
name|NPC
block|,
name|FPSR
block|,
name|CPSR
block|}
enum|;
end_enum

begin_comment
comment|/***************************  ASSEMBLY CODE MACROS *************************/
end_comment

begin_comment
comment|/* 									   */
end_comment

begin_function_decl
specifier|extern
name|void
name|trap_low
parameter_list|()
function_decl|;
end_function_decl

begin_asm
asm|asm(" 	.reserve trapstack, 1000 * 4, \"bss\", 8  	.data 	.align	4  in_trap_handler: 	.word	0  	.text 	.align 4  ! This function is called when any SPARC trap (except window overflow or ! underflow) occurs.  It makes sure that the invalid register window is still ! available before jumping into C code.  It will also restore the world if you ! return from handle_exception.  	.globl _trap_low _trap_low: 	mov	%psr, %l0 	mov	%wim, %l3  	srl	%l3, %l0, %l4		! wim>> cwp 	cmp	%l4, 1 	bne	window_fine		! Branch if not in the invalid window 	nop  ! Handle window overflow  	mov	%g1, %l4		! Save g1, we use it to hold the wim 	srl	%l3, 1, %g1		! Rotate wim right 	tst	%g1 	bg	good_wim		! Branch if new wim is non-zero 	nop  ! At this point, we need to bring a 1 into the high order bit of the wim. ! Since we don't want to make any assumptions about the number of register ! windows, we figure it out dynamically so as to setup the wim correctly.  	not	%g1			! Fill g1 with ones 	mov	%g1, %wim		! Fill the wim with ones 	nop 	nop 	nop 	mov	%wim, %g1		! Read back the wim 	inc	%g1			! Now g1 has 1 just to left of wim 	srl	%g1, 1, %g1		! Now put 1 at top of wim 	mov	%g0, %wim		! Clear wim so that subsequent save 	nop				!  won't trap 	nop 	nop  good_wim: 	save	%g0, %g0, %g0		! Slip into next window 	mov	%g1, %wim		! Install the new wim  	std	%l0, [%sp + 0 * 4]	! save L& I registers 	std	%l2, [%sp + 2 * 4] 	std	%l4, [%sp + 4 * 4] 	std	%l6, [%sp + 6 * 4]  	std	%i0, [%sp + 8 * 4] 	std	%i2, [%sp + 10 * 4] 	std	%i4, [%sp + 12 * 4] 	std	%i6, [%sp + 14 * 4]  	restore				! Go back to trap window. 	mov	%l4, %g1		! Restore %g1  window_fine: 	sethi	%hi(in_trap_handler), %l4 	ld	[%lo(in_trap_handler) + %l4], %l5 	tst	%l5 	bg	recursive_trap 	inc	%l5  	set	trapstack+1000*4, %sp	! Switch to trap stack  recursive_trap: 	st	%l5, [%lo(in_trap_handler) + %l4] 	sub	%sp,(16+1+6+1+72)*4,%sp	! Make room for input& locals  					! + hidden arg + arg spill 					! + doubleword alignment 					! + registers[72] local var  	std	%g0, [%sp + (24 + 0) * 4] ! registers[Gx] 	std	%g2, [%sp + (24 + 2) * 4] 	std	%g4, [%sp + (24 + 4) * 4] 	std	%g6, [%sp + (24 + 6) * 4]  	std	%i0, [%sp + (24 + 8) * 4] ! registers[Ox] 	std	%i2, [%sp + (24 + 10) * 4] 	std	%i4, [%sp + (24 + 12) * 4] 	std	%i6, [%sp + (24 + 14) * 4] 					! F0->F31 not implemented 	mov	%y, %l4 	mov	%tbr, %l5 	st	%l4, [%sp + (24 + 64) * 4] ! Y 	st	%l0, [%sp + (24 + 65) * 4] ! PSR 	st	%l3, [%sp + (24 + 66) * 4] ! WIM 	st	%l5, [%sp + (24 + 67) * 4] ! TBR 	st	%l1, [%sp + (24 + 68) * 4] ! PC 	st	%l2, [%sp + (24 + 69) * 4] ! NPC  					! CPSR and FPSR not impl  	or	%l0, 0xf20, %l4 	mov	%l4, %psr		! Turn on traps, disable interrupts  	call	_handle_exception 	add	%sp, 24 * 4, %o0	! Pass address of registers  ! Reload all of the registers that aren't on the stack  	ld	[%sp + (24 + 1) * 4], %g1 ! registers[Gx] 	ldd	[%sp + (24 + 2) * 4], %g2 	ldd	[%sp + (24 + 4) * 4], %g4 	ldd	[%sp + (24 + 6) * 4], %g6  	ldd	[%sp + (24 + 8) * 4], %i0 ! registers[Ox] 	ldd	[%sp + (24 + 10) * 4], %i2 	ldd	[%sp + (24 + 12) * 4], %i4 	ldd	[%sp + (24 + 14) * 4], %i6  	ldd	[%sp + (24 + 64) * 4], %l0 ! Y& PSR 	ldd	[%sp + (24 + 68) * 4], %l2 ! PC& NPC  	restore				! Ensure that previous window is valid 	save	%g0, %g0, %g0		!  by causing a window_underflow trap  	mov	%l0, %y 	mov	%l1, %psr		! Make sure that traps are disabled 					! for rett  	sethi	%hi(in_trap_handler), %l4 	ld	[%lo(in_trap_handler) + %l4], %l5 	dec	%l5 	st	%l5, [%lo(in_trap_handler) + %l4]  	jmpl	%l2, %g0		! Restore old PC 	rett	%l3			! Restore old nPC ");
end_asm

begin_comment
comment|/* Convert ch from a hex digit to an int */
end_comment

begin_function
specifier|static
name|int
name|hex
parameter_list|(
name|unsigned
name|char
name|ch
parameter_list|)
block|{
if|if
condition|(
name|ch
operator|>=
literal|'a'
operator|&&
name|ch
operator|<=
literal|'f'
condition|)
return|return
name|ch
operator|-
literal|'a'
operator|+
literal|10
return|;
if|if
condition|(
name|ch
operator|>=
literal|'0'
operator|&&
name|ch
operator|<=
literal|'9'
condition|)
return|return
name|ch
operator|-
literal|'0'
return|;
if|if
condition|(
name|ch
operator|>=
literal|'A'
operator|&&
name|ch
operator|<=
literal|'F'
condition|)
return|return
name|ch
operator|-
literal|'A'
operator|+
literal|10
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
name|remcomInBuffer
index|[
name|BUFMAX
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|remcomOutBuffer
index|[
name|BUFMAX
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* scan for the sequence $<data>#<checksum>     */
end_comment

begin_function
name|unsigned
name|char
modifier|*
name|getpacket
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|buffer
init|=
operator|&
name|remcomInBuffer
index|[
literal|0
index|]
decl_stmt|;
name|unsigned
name|char
name|checksum
decl_stmt|;
name|unsigned
name|char
name|xmitcsum
decl_stmt|;
name|int
name|count
decl_stmt|;
name|char
name|ch
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* wait around for the start character, ignore all other characters */
while|while
condition|(
operator|(
name|ch
operator|=
name|getDebugChar
argument_list|()
operator|)
operator|!=
literal|'$'
condition|)
empty_stmt|;
name|retry
label|:
name|checksum
operator|=
literal|0
expr_stmt|;
name|xmitcsum
operator|=
operator|-
literal|1
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
comment|/* now, read until a # or end of buffer is found */
while|while
condition|(
name|count
operator|<
name|BUFMAX
condition|)
block|{
name|ch
operator|=
name|getDebugChar
argument_list|()
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'$'
condition|)
goto|goto
name|retry
goto|;
if|if
condition|(
name|ch
operator|==
literal|'#'
condition|)
break|break;
name|checksum
operator|=
name|checksum
operator|+
name|ch
expr_stmt|;
name|buffer
index|[
name|count
index|]
operator|=
name|ch
expr_stmt|;
name|count
operator|=
name|count
operator|+
literal|1
expr_stmt|;
block|}
name|buffer
index|[
name|count
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'#'
condition|)
block|{
name|ch
operator|=
name|getDebugChar
argument_list|()
expr_stmt|;
name|xmitcsum
operator|=
name|hex
argument_list|(
name|ch
argument_list|)
operator|<<
literal|4
expr_stmt|;
name|ch
operator|=
name|getDebugChar
argument_list|()
expr_stmt|;
name|xmitcsum
operator|+=
name|hex
argument_list|(
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|checksum
operator|!=
name|xmitcsum
condition|)
block|{
name|putDebugChar
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
comment|/* failed checksum */
block|}
else|else
block|{
name|putDebugChar
argument_list|(
literal|'+'
argument_list|)
expr_stmt|;
comment|/* successful transfer */
comment|/* if a sequence char is present, reply the sequence ID */
if|if
condition|(
name|buffer
index|[
literal|2
index|]
operator|==
literal|':'
condition|)
block|{
name|putDebugChar
argument_list|(
name|buffer
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|putDebugChar
argument_list|(
name|buffer
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|&
name|buffer
index|[
literal|3
index|]
return|;
block|}
return|return
operator|&
name|buffer
index|[
literal|0
index|]
return|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* send the packet in buffer.  */
end_comment

begin_function
specifier|static
name|void
name|putpacket
parameter_list|(
name|unsigned
name|char
modifier|*
name|buffer
parameter_list|)
block|{
name|unsigned
name|char
name|checksum
decl_stmt|;
name|int
name|count
decl_stmt|;
name|unsigned
name|char
name|ch
decl_stmt|;
comment|/*  $<packet info>#<checksum>. */
do|do
block|{
name|putDebugChar
argument_list|(
literal|'$'
argument_list|)
expr_stmt|;
name|checksum
operator|=
literal|0
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|ch
operator|=
name|buffer
index|[
name|count
index|]
condition|)
block|{
name|putDebugChar
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|checksum
operator|+=
name|ch
expr_stmt|;
name|count
operator|+=
literal|1
expr_stmt|;
block|}
name|putDebugChar
argument_list|(
literal|'#'
argument_list|)
expr_stmt|;
name|putDebugChar
argument_list|(
name|hexchars
index|[
name|checksum
operator|>>
literal|4
index|]
argument_list|)
expr_stmt|;
name|putDebugChar
argument_list|(
name|hexchars
index|[
name|checksum
operator|&
literal|0xf
index|]
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|getDebugChar
argument_list|()
operator|!=
literal|'+'
condition|)
do|;
block|}
end_function

begin_comment
comment|/* Indicate to caller of mem2hex or hex2mem that there has been an    error.  */
end_comment

begin_decl_stmt
specifier|static
specifier|volatile
name|int
name|mem_err
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Convert the memory pointed to by mem into hex, placing result in buf.  * Return a pointer to the last char put in buf (null), in case of mem fault,  * return 0.  * If MAY_FAULT is non-zero, then we will handle memory faults by returning  * a 0, else treat a fault like any other fault in the stub.  */
end_comment

begin_function
specifier|static
name|unsigned
name|char
modifier|*
name|mem2hex
parameter_list|(
name|unsigned
name|char
modifier|*
name|mem
parameter_list|,
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|count
parameter_list|,
name|int
name|may_fault
parameter_list|)
block|{
name|unsigned
name|char
name|ch
decl_stmt|;
name|set_mem_fault_trap
argument_list|(
name|may_fault
argument_list|)
expr_stmt|;
while|while
condition|(
name|count
operator|--
operator|>
literal|0
condition|)
block|{
name|ch
operator|=
operator|*
name|mem
operator|++
expr_stmt|;
if|if
condition|(
name|mem_err
condition|)
return|return
literal|0
return|;
operator|*
name|buf
operator|++
operator|=
name|hexchars
index|[
name|ch
operator|>>
literal|4
index|]
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|hexchars
index|[
name|ch
operator|&
literal|0xf
index|]
expr_stmt|;
block|}
operator|*
name|buf
operator|=
literal|0
expr_stmt|;
name|set_mem_fault_trap
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/* convert the hex array pointed to by buf into binary to be placed in mem  * return a pointer to the character AFTER the last byte written */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|hex2mem
parameter_list|(
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|unsigned
name|char
modifier|*
name|mem
parameter_list|,
name|int
name|count
parameter_list|,
name|int
name|may_fault
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|char
name|ch
decl_stmt|;
name|set_mem_fault_trap
argument_list|(
name|may_fault
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|ch
operator|=
name|hex
argument_list|(
operator|*
name|buf
operator|++
argument_list|)
operator|<<
literal|4
expr_stmt|;
name|ch
operator||=
name|hex
argument_list|(
operator|*
name|buf
operator|++
argument_list|)
expr_stmt|;
operator|*
name|mem
operator|++
operator|=
name|ch
expr_stmt|;
if|if
condition|(
name|mem_err
condition|)
return|return
literal|0
return|;
block|}
name|set_mem_fault_trap
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|mem
return|;
block|}
end_function

begin_comment
comment|/* This table contains the mapping between SPARC hardware trap types, and    signals, which are primarily what GDB understands.  It also indicates    which hardware traps we need to commandeer when initializing the stub. */
end_comment

begin_struct
specifier|static
struct|struct
name|hard_trap_info
block|{
name|unsigned
name|char
name|tt
decl_stmt|;
comment|/* Trap type code for SPARClite */
name|unsigned
name|char
name|signo
decl_stmt|;
comment|/* Signal that we map this trap into */
block|}
name|hard_trap_info
index|[]
init|=
block|{
block|{
literal|1
block|,
name|SIGSEGV
block|}
block|,
comment|/* instruction access error */
block|{
literal|2
block|,
name|SIGILL
block|}
block|,
comment|/* privileged instruction */
block|{
literal|3
block|,
name|SIGILL
block|}
block|,
comment|/* illegal instruction */
block|{
literal|4
block|,
name|SIGEMT
block|}
block|,
comment|/* fp disabled */
block|{
literal|36
block|,
name|SIGEMT
block|}
block|,
comment|/* cp disabled */
block|{
literal|7
block|,
name|SIGBUS
block|}
block|,
comment|/* mem address not aligned */
block|{
literal|9
block|,
name|SIGSEGV
block|}
block|,
comment|/* data access exception */
block|{
literal|10
block|,
name|SIGEMT
block|}
block|,
comment|/* tag overflow */
block|{
literal|128
operator|+
literal|1
block|,
name|SIGTRAP
block|}
block|,
comment|/* ta 1 - normal breakpoint instruction */
block|{
literal|0
block|,
literal|0
block|}
comment|/* Must be last */
block|}
struct|;
end_struct

begin_comment
comment|/* Set up exception handlers for tracing and breakpoints */
end_comment

begin_function
name|void
name|set_debug_traps
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|hard_trap_info
modifier|*
name|ht
decl_stmt|;
for|for
control|(
name|ht
operator|=
name|hard_trap_info
init|;
name|ht
operator|->
name|tt
operator|&&
name|ht
operator|->
name|signo
condition|;
name|ht
operator|++
control|)
name|exceptionHandler
argument_list|(
name|ht
operator|->
name|tt
argument_list|,
name|trap_low
argument_list|)
expr_stmt|;
name|initialized
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_asm
asm|asm (" ! Trap handler for memory errors.  This just sets mem_err to be non-zero.  It ! assumes that %l1 is non-zero.  This should be safe, as it is doubtful that ! 0 would ever contain code that could mem fault.  This routine will skip ! past the faulting instruction after setting mem_err.  	.text 	.align 4  _fltr_set_mem_err: 	sethi %hi(_mem_err), %l0 	st %l1, [%l0 + %lo(_mem_err)] 	jmpl %l2, %g0 	rett %l2+4 ");
end_asm

begin_function
specifier|static
name|void
name|set_mem_fault_trap
parameter_list|(
name|int
name|enable
parameter_list|)
block|{
specifier|extern
name|void
name|fltr_set_mem_err
parameter_list|()
function_decl|;
name|mem_err
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|enable
condition|)
name|exceptionHandler
argument_list|(
literal|9
argument_list|,
name|fltr_set_mem_err
argument_list|)
expr_stmt|;
else|else
name|exceptionHandler
argument_list|(
literal|9
argument_list|,
name|trap_low
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Convert the SPARC hardware trap type code to a unix signal number. */
end_comment

begin_function
specifier|static
name|int
name|computeSignal
parameter_list|(
name|int
name|tt
parameter_list|)
block|{
name|struct
name|hard_trap_info
modifier|*
name|ht
decl_stmt|;
for|for
control|(
name|ht
operator|=
name|hard_trap_info
init|;
name|ht
operator|->
name|tt
operator|&&
name|ht
operator|->
name|signo
condition|;
name|ht
operator|++
control|)
if|if
condition|(
name|ht
operator|->
name|tt
operator|==
name|tt
condition|)
return|return
name|ht
operator|->
name|signo
return|;
return|return
name|SIGHUP
return|;
comment|/* default for things we don't know about */
block|}
end_function

begin_comment
comment|/*  * While we find nice hex chars, build an int.  * Return number of chars processed.  */
end_comment

begin_function
specifier|static
name|int
name|hexToInt
parameter_list|(
name|char
modifier|*
modifier|*
name|ptr
parameter_list|,
name|int
modifier|*
name|intValue
parameter_list|)
block|{
name|int
name|numChars
init|=
literal|0
decl_stmt|;
name|int
name|hexValue
decl_stmt|;
operator|*
name|intValue
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
operator|*
name|ptr
condition|)
block|{
name|hexValue
operator|=
name|hex
argument_list|(
operator|*
operator|*
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|hexValue
operator|<
literal|0
condition|)
break|break;
operator|*
name|intValue
operator|=
operator|(
operator|*
name|intValue
operator|<<
literal|4
operator|)
operator||
name|hexValue
expr_stmt|;
name|numChars
operator|++
expr_stmt|;
operator|(
operator|*
name|ptr
operator|)
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|numChars
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This function does all command procesing for interfacing to gdb.  It  * returns 1 if you should skip the instruction at the trap address, 0  * otherwise.  */
end_comment

begin_function_decl
specifier|extern
name|void
name|breakinst
parameter_list|()
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|handle_exception
parameter_list|(
name|unsigned
name|long
modifier|*
name|registers
parameter_list|)
block|{
name|int
name|tt
decl_stmt|;
comment|/* Trap type */
name|int
name|sigval
decl_stmt|;
name|int
name|addr
decl_stmt|;
name|int
name|length
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|unsigned
name|long
modifier|*
name|sp
decl_stmt|;
comment|/* First, we must force all of the windows to be spilled out */
asm|asm("	save %sp, -64, %sp 	save %sp, -64, %sp 	save %sp, -64, %sp 	save %sp, -64, %sp 	save %sp, -64, %sp 	save %sp, -64, %sp 	save %sp, -64, %sp 	save %sp, -64, %sp 	restore 	restore 	restore 	restore 	restore 	restore 	restore 	restore ");
if|if
condition|(
name|registers
index|[
name|PC
index|]
operator|==
operator|(
name|unsigned
name|long
operator|)
name|breakinst
condition|)
block|{
name|registers
index|[
name|PC
index|]
operator|=
name|registers
index|[
name|NPC
index|]
expr_stmt|;
name|registers
index|[
name|NPC
index|]
operator|+=
literal|4
expr_stmt|;
block|}
name|sp
operator|=
operator|(
name|unsigned
name|long
operator|*
operator|)
name|registers
index|[
name|SP
index|]
expr_stmt|;
name|tt
operator|=
operator|(
name|registers
index|[
name|TBR
index|]
operator|>>
literal|4
operator|)
operator|&
literal|0xff
expr_stmt|;
comment|/* reply to host that an exception has occurred */
name|sigval
operator|=
name|computeSignal
argument_list|(
name|tt
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|remcomOutBuffer
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
literal|'T'
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|hexchars
index|[
name|sigval
operator|>>
literal|4
index|]
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|hexchars
index|[
name|sigval
operator|&
literal|0xf
index|]
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|hexchars
index|[
name|PC
operator|>>
literal|4
index|]
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|hexchars
index|[
name|PC
operator|&
literal|0xf
index|]
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
literal|':'
expr_stmt|;
name|ptr
operator|=
name|mem2hex
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|registers
index|[
name|PC
index|]
argument_list|,
name|ptr
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
literal|';'
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|hexchars
index|[
name|FP
operator|>>
literal|4
index|]
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|hexchars
index|[
name|FP
operator|&
literal|0xf
index|]
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
literal|':'
expr_stmt|;
name|ptr
operator|=
name|mem2hex
argument_list|(
name|sp
operator|+
literal|8
operator|+
literal|6
argument_list|,
name|ptr
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* FP */
operator|*
name|ptr
operator|++
operator|=
literal|';'
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|hexchars
index|[
name|SP
operator|>>
literal|4
index|]
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|hexchars
index|[
name|SP
operator|&
literal|0xf
index|]
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
literal|':'
expr_stmt|;
name|ptr
operator|=
name|mem2hex
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|sp
argument_list|,
name|ptr
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
literal|';'
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|hexchars
index|[
name|NPC
operator|>>
literal|4
index|]
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|hexchars
index|[
name|NPC
operator|&
literal|0xf
index|]
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
literal|':'
expr_stmt|;
name|ptr
operator|=
name|mem2hex
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|registers
index|[
name|NPC
index|]
argument_list|,
name|ptr
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
literal|';'
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|hexchars
index|[
name|O7
operator|>>
literal|4
index|]
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|hexchars
index|[
name|O7
operator|&
literal|0xf
index|]
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
literal|':'
expr_stmt|;
name|ptr
operator|=
name|mem2hex
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|registers
index|[
name|O7
index|]
argument_list|,
name|ptr
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
literal|';'
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
literal|0
expr_stmt|;
name|putpacket
argument_list|(
name|remcomOutBuffer
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|remcomOutBuffer
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|ptr
operator|=
name|getpacket
argument_list|()
expr_stmt|;
switch|switch
condition|(
operator|*
name|ptr
operator|++
condition|)
block|{
case|case
literal|'?'
case|:
name|remcomOutBuffer
index|[
literal|0
index|]
operator|=
literal|'S'
expr_stmt|;
name|remcomOutBuffer
index|[
literal|1
index|]
operator|=
name|hexchars
index|[
name|sigval
operator|>>
literal|4
index|]
expr_stmt|;
name|remcomOutBuffer
index|[
literal|2
index|]
operator|=
name|hexchars
index|[
name|sigval
operator|&
literal|0xf
index|]
expr_stmt|;
name|remcomOutBuffer
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
comment|/* toggle debug flag */
break|break;
case|case
literal|'g'
case|:
comment|/* return the value of the CPU registers */
block|{
name|ptr
operator|=
name|remcomOutBuffer
expr_stmt|;
name|ptr
operator|=
name|mem2hex
argument_list|(
operator|(
name|char
operator|*
operator|)
name|registers
argument_list|,
name|ptr
argument_list|,
literal|16
operator|*
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* G& O regs */
name|ptr
operator|=
name|mem2hex
argument_list|(
name|sp
operator|+
literal|0
argument_list|,
name|ptr
argument_list|,
literal|16
operator|*
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* L& I regs */
name|memset
argument_list|(
name|ptr
argument_list|,
literal|'0'
argument_list|,
literal|32
operator|*
literal|8
argument_list|)
expr_stmt|;
comment|/* Floating point */
name|mem2hex
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|registers
index|[
name|Y
index|]
argument_list|,
name|ptr
operator|+
literal|32
operator|*
literal|4
operator|*
literal|2
argument_list|,
literal|8
operator|*
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Y, PSR, WIM, TBR, PC, NPC, FPSR, CPSR */
block|}
break|break;
case|case
literal|'G'
case|:
comment|/* set the value of the CPU registers - return OK */
block|{
name|unsigned
name|long
modifier|*
name|newsp
decl_stmt|,
name|psr
decl_stmt|;
name|psr
operator|=
name|registers
index|[
name|PSR
index|]
expr_stmt|;
name|hex2mem
argument_list|(
name|ptr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|registers
argument_list|,
literal|16
operator|*
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* G& O regs */
name|hex2mem
argument_list|(
name|ptr
operator|+
literal|16
operator|*
literal|4
operator|*
literal|2
argument_list|,
name|sp
operator|+
literal|0
argument_list|,
literal|16
operator|*
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* L& I regs */
name|hex2mem
argument_list|(
name|ptr
operator|+
literal|64
operator|*
literal|4
operator|*
literal|2
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|registers
index|[
name|Y
index|]
argument_list|,
literal|8
operator|*
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Y, PSR, WIM, TBR, PC, NPC, FPSR, CPSR */
comment|/* See if the stack pointer has moved.  If so, then copy the saved 	       locals and ins to the new location.  This keeps the window 	       overflow and underflow routines happy.  */
name|newsp
operator|=
operator|(
name|unsigned
name|long
operator|*
operator|)
name|registers
index|[
name|SP
index|]
expr_stmt|;
if|if
condition|(
name|sp
operator|!=
name|newsp
condition|)
name|sp
operator|=
name|memcpy
argument_list|(
name|newsp
argument_list|,
name|sp
argument_list|,
literal|16
operator|*
literal|4
argument_list|)
expr_stmt|;
comment|/* Don't allow CWP to be modified. */
if|if
condition|(
name|psr
operator|!=
name|registers
index|[
name|PSR
index|]
condition|)
name|registers
index|[
name|PSR
index|]
operator|=
operator|(
name|psr
operator|&
literal|0x1f
operator|)
operator||
operator|(
name|registers
index|[
name|PSR
index|]
operator|&
operator|~
literal|0x1f
operator|)
expr_stmt|;
name|strcpy
argument_list|(
name|remcomOutBuffer
argument_list|,
literal|"OK"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'m'
case|:
comment|/* mAA..AA,LLLL  Read LLLL bytes at address AA..AA */
comment|/* Try to read %x,%x.  */
if|if
condition|(
name|hexToInt
argument_list|(
operator|&
name|ptr
argument_list|,
operator|&
name|addr
argument_list|)
operator|&&
operator|*
name|ptr
operator|++
operator|==
literal|','
operator|&&
name|hexToInt
argument_list|(
operator|&
name|ptr
argument_list|,
operator|&
name|length
argument_list|)
condition|)
block|{
if|if
condition|(
name|mem2hex
argument_list|(
operator|(
name|char
operator|*
operator|)
name|addr
argument_list|,
name|remcomOutBuffer
argument_list|,
name|length
argument_list|,
literal|1
argument_list|)
condition|)
break|break;
name|strcpy
argument_list|(
name|remcomOutBuffer
argument_list|,
literal|"E03"
argument_list|)
expr_stmt|;
block|}
else|else
name|strcpy
argument_list|(
name|remcomOutBuffer
argument_list|,
literal|"E01"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
comment|/* MAA..AA,LLLL: Write LLLL bytes at address AA.AA return OK */
comment|/* Try to read '%x,%x:'.  */
if|if
condition|(
name|hexToInt
argument_list|(
operator|&
name|ptr
argument_list|,
operator|&
name|addr
argument_list|)
operator|&&
operator|*
name|ptr
operator|++
operator|==
literal|','
operator|&&
name|hexToInt
argument_list|(
operator|&
name|ptr
argument_list|,
operator|&
name|length
argument_list|)
operator|&&
operator|*
name|ptr
operator|++
operator|==
literal|':'
condition|)
block|{
if|if
condition|(
name|hex2mem
argument_list|(
name|ptr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|addr
argument_list|,
name|length
argument_list|,
literal|1
argument_list|)
condition|)
name|strcpy
argument_list|(
name|remcomOutBuffer
argument_list|,
literal|"OK"
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|remcomOutBuffer
argument_list|,
literal|"E03"
argument_list|)
expr_stmt|;
block|}
else|else
name|strcpy
argument_list|(
name|remcomOutBuffer
argument_list|,
literal|"E02"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/* cAA..AA    Continue at address AA..AA(optional) */
comment|/* try to read optional parameter, pc unchanged if no parm */
if|if
condition|(
name|hexToInt
argument_list|(
operator|&
name|ptr
argument_list|,
operator|&
name|addr
argument_list|)
condition|)
block|{
name|registers
index|[
name|PC
index|]
operator|=
name|addr
expr_stmt|;
name|registers
index|[
name|NPC
index|]
operator|=
name|addr
operator|+
literal|4
expr_stmt|;
block|}
comment|/* Need to flush the instruction cache here, as we may have deposited a    breakpoint, and the icache probably has no way of knowing that a data ref to    some location may have changed something that is in the instruction cache.  */
name|flush_i_cache
argument_list|()
expr_stmt|;
return|return;
comment|/* kill the program */
case|case
literal|'k'
case|:
comment|/* do nothing */
break|break;
if|#
directive|if
literal|0
block|case 't':
comment|/* Test feature */
block|asm (" std %f30,[%sp]"); 	  break;
endif|#
directive|endif
case|case
literal|'r'
case|:
comment|/* Reset */
asm|asm ("call 0 		nop ");
break|break;
block|}
comment|/* switch */
comment|/* reply to the request */
name|putpacket
argument_list|(
name|remcomOutBuffer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This function will generate a breakpoint exception.  It is used at the    beginning of a program to sync up with a debugger and can be used    otherwise as a quick means to stop program execution and "break" into    the debugger. */
end_comment

begin_function
name|void
name|breakpoint
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|initialized
condition|)
return|return;
asm|asm("	.globl _breakinst  	_breakinst: ta 1       ");
block|}
end_function

end_unit

