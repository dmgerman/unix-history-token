begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Handle HP SOM shared libraries for GDB, the GNU Debugger.    Copyright 1993, 1996, 1999 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  Written by the Center for Software Science at the Univerity of Utah and by Cygnus Support.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"som.h"
end_include

begin_include
include|#
directive|include
file|"libhppa.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"breakpoint.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"gdb-stabs.h"
end_include

begin_include
include|#
directive|include
file|"gdb_stat.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"assert.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|O_BINARY
end_ifndef

begin_define
define|#
directive|define
name|O_BINARY
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Uncomment this to turn on some debugging output.  */
end_comment

begin_comment
comment|/* #define SOLIB_DEBUG  */
end_comment

begin_comment
comment|/* Defined in exec.c; used to prevent dangling pointer bug.  */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|target_ops
name|exec_ops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This lives in hppa-tdep.c. */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|unwind_table_entry
modifier|*
name|find_unwind_entry
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
name|pc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These ought to be defined in some public interface, but aren't.  They    define the meaning of the various bits in the distinguished __dld_flags    variable that is declared in every debuggable a.out on HP-UX, and that    is shared between the debugger and the dynamic linker.    */
end_comment

begin_define
define|#
directive|define
name|DLD_FLAGS_MAPPRIVATE
value|0x1
end_define

begin_define
define|#
directive|define
name|DLD_FLAGS_HOOKVALID
value|0x2
end_define

begin_define
define|#
directive|define
name|DLD_FLAGS_LISTVALID
value|0x4
end_define

begin_define
define|#
directive|define
name|DLD_FLAGS_BOR_ENABLE
value|0x8
end_define

begin_comment
comment|/* TODO:     * Most of this code should work for hp300 shared libraries.  Does    anyone care enough to weed out any SOM-isms.     * Support for hpux8 dynamic linker.  */
end_comment

begin_comment
comment|/* The basic structure which describes a dynamically loaded object.  This    data structure is private to the dynamic linker and isn't found in    any HPUX include file.  */
end_comment

begin_struct
struct|struct
name|som_solib_mapped_entry
block|{
comment|/* The name of the library.  */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Version of this structure (it is expected to change again in hpux10).  */
name|unsigned
name|char
name|struct_version
decl_stmt|;
comment|/* Binding mode for this library.  */
name|unsigned
name|char
name|bind_mode
decl_stmt|;
comment|/* Version of this library.  */
name|short
name|library_version
decl_stmt|;
comment|/* Start of text address,    * link-time text location (length of text area),    * end of text address.  */
name|CORE_ADDR
name|text_addr
decl_stmt|;
name|CORE_ADDR
name|text_link_addr
decl_stmt|;
name|CORE_ADDR
name|text_end
decl_stmt|;
comment|/* Start of data, start of bss and end of data.  */
name|CORE_ADDR
name|data_start
decl_stmt|;
name|CORE_ADDR
name|bss_start
decl_stmt|;
name|CORE_ADDR
name|data_end
decl_stmt|;
comment|/* Value of linkage pointer (%r19).  */
name|CORE_ADDR
name|got_value
decl_stmt|;
comment|/* Next entry.  */
name|struct
name|som_solib_mapped_entry
modifier|*
name|next
decl_stmt|;
comment|/* There are other fields, but I don't have information as to what is      contained in them.  */
comment|/* For versions from HPUX-10.30 and up */
comment|/* Address in target of offset from thread-local register of    * start of this thread's data.  I.e., the first thread-local    * variable in this shared library starts at *(tsd_start_addr)    * from that area pointed to by cr27 (mpsfu_hi).    *    * We do the indirection as soon as we read it, so from then    * on it's the offset itself.    */
name|CORE_ADDR
name|tsd_start_addr
decl_stmt|;
comment|/* Following this are longwords holding:    *    * ?, ?, ?, ptr to -1, ptr to-1, ptr to lib name (leaf name),    * ptr to __data_start, ptr to __data_end    */
block|}
struct|;
end_struct

begin_comment
comment|/* A structure to keep track of all the known shared objects.  */
end_comment

begin_struct
struct|struct
name|so_list
block|{
name|struct
name|som_solib_mapped_entry
name|som_solib
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|section_table
modifier|*
name|sections
decl_stmt|;
name|struct
name|section_table
modifier|*
name|sections_end
decl_stmt|;
comment|/* elz: added this field to store the address in target space (in the    library) of the library descriptor (handle) which we read into    som_solib_mapped_entry structure*/
name|CORE_ADDR
name|solib_addr
decl_stmt|;
name|struct
name|so_list
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|so_list
modifier|*
name|so_list_head
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is the cumulative size in bytes of the symbol tables of all    shared objects on the so_list_head list.  (When we say size, here    we mean of the information before it is brought into memory and    potentially expanded by GDB.)  When adding a new shlib, this value    is compared against the threshold size, held by auto_solib_add    (in megabytes).  If adding symbols for the new shlib would cause    the total size to exceed the threshold, then the new shlib's symbols    are not loaded.    */
end_comment

begin_decl_stmt
specifier|static
name|LONGEST
name|som_solib_total_st_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When the threshold is reached for any shlib, we refuse to add    symbols for subsequent shlibs, even if those shlibs' symbols would    be small enough to fit under the threshold.  (Although this may    result in one, early large shlib preventing the loading of later,    smalller shlibs' symbols, it allows us to issue one informational    message.  The alternative, to issue a message for each shlib whose    symbols aren't loaded, could be a big annoyance where the threshold    is exceeded due to a very large number of shlibs.)    */
end_comment

begin_decl_stmt
specifier|static
name|int
name|som_solib_st_size_threshold_exceeded
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These addresses should be filled in by som_solib_create_inferior_hook.    They are also used elsewhere in this module.    */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|CORE_ADDR
name|address
decl_stmt|;
name|struct
name|unwind_table_entry
modifier|*
name|unwind
decl_stmt|;
block|}
name|addr_and_unwind_t
typedef|;
end_typedef

begin_comment
comment|/* When adding fields, be sure to clear them in _initialize_som_solib. */
end_comment

begin_struct
specifier|static
struct|struct
block|{
name|boolean
name|is_valid
decl_stmt|;
name|addr_and_unwind_t
name|hook
decl_stmt|;
name|addr_and_unwind_t
name|hook_stub
decl_stmt|;
name|addr_and_unwind_t
name|load
decl_stmt|;
name|addr_and_unwind_t
name|load_stub
decl_stmt|;
name|addr_and_unwind_t
name|unload
decl_stmt|;
name|addr_and_unwind_t
name|unload2
decl_stmt|;
name|addr_and_unwind_t
name|unload_stub
decl_stmt|;
block|}
name|dld_cache
struct|;
end_struct

begin_decl_stmt
specifier|static
name|void
name|som_sharedlibrary_info_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|som_solib_sharedlibrary_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|LONGEST
name|som_solib_sizeof_symbol_table
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|int
name|desc
decl_stmt|;
name|char
modifier|*
name|absolute_name
decl_stmt|;
name|LONGEST
name|st_size
init|=
operator|(
name|LONGEST
operator|)
literal|0
decl_stmt|;
name|asection
modifier|*
name|sect
decl_stmt|;
comment|/* We believe that filename was handed to us by the dynamic linker, and      is therefore always an absolute path.      */
name|desc
operator|=
name|openp
argument_list|(
name|getenv
argument_list|(
literal|"PATH"
argument_list|)
argument_list|,
literal|1
argument_list|,
name|filename
argument_list|,
name|O_RDONLY
operator||
name|O_BINARY
argument_list|,
literal|0
argument_list|,
operator|&
name|absolute_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|<
literal|0
condition|)
block|{
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
name|filename
operator|=
name|absolute_name
expr_stmt|;
name|abfd
operator|=
name|bfd_fdopenr
argument_list|(
name|filename
argument_list|,
name|gnutarget
argument_list|,
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|abfd
condition|)
block|{
name|close
argument_list|(
name|desc
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"\"%s\": can't open to read symbols: %s."
argument_list|,
name|filename
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|bfd_check_format
argument_list|(
name|abfd
argument_list|,
name|bfd_object
argument_list|)
condition|)
comment|/* Reads in section info */
block|{
name|bfd_close
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* This also closes desc */
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"\"%s\": can't read symbols: %s."
argument_list|,
name|filename
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Sum the sizes of the various sections that compose debug info. */
comment|/* This contains non-DOC information. */
name|sect
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|"$DEBUG$"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sect
condition|)
name|st_size
operator|+=
operator|(
name|LONGEST
operator|)
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|sect
argument_list|)
expr_stmt|;
comment|/* This contains DOC information. */
name|sect
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|"$PINFO$"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sect
condition|)
name|st_size
operator|+=
operator|(
name|LONGEST
operator|)
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|sect
argument_list|)
expr_stmt|;
name|bfd_close
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* This also closes desc */
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
comment|/* Unfortunately, just summing the sizes of various debug info      sections isn't a very accurate measurement of how much heap      space the debugger will need to hold them.  It also doesn't      account for space needed by linker (aka "minimal") symbols.       Anecdotal evidence suggests that just summing the sizes of      debug-info-related sections understates the heap space needed      to represent it internally by about an order of magnitude.       Since it's not exactly brain surgery we're doing here, rather      than attempt to more accurately measure the size of a shlib's      symbol table in GDB's heap, we'll just apply a 10x fudge-      factor to the debug info sections' size-sum.  No, this doesn't      account for minimal symbols in non-debuggable shlibs.  But it      all roughly washes out in the end.      */
return|return
name|st_size
operator|*
operator|(
name|LONGEST
operator|)
literal|10
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|som_solib_add_solib_objfile
parameter_list|(
name|so
parameter_list|,
name|name
parameter_list|,
name|from_tty
parameter_list|,
name|text_addr
parameter_list|)
name|struct
name|so_list
modifier|*
name|so
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
name|CORE_ADDR
name|text_addr
decl_stmt|;
block|{
name|obj_private_data_t
modifier|*
name|obj_private
decl_stmt|;
name|so
operator|->
name|objfile
operator|=
name|symbol_file_add
argument_list|(
name|name
argument_list|,
name|from_tty
argument_list|,
name|text_addr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|so
operator|->
name|abfd
operator|=
name|so
operator|->
name|objfile
operator|->
name|obfd
expr_stmt|;
comment|/* Mark this as a shared library and save private data.    */
name|so
operator|->
name|objfile
operator|->
name|flags
operator||=
name|OBJF_SHARED
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|objfile
operator|->
name|obj_private
operator|==
name|NULL
condition|)
block|{
name|obj_private
operator|=
operator|(
name|obj_private_data_t
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|so
operator|->
name|objfile
operator|->
name|psymbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
name|obj_private_data_t
argument_list|)
argument_list|)
expr_stmt|;
name|obj_private
operator|->
name|unwind_info
operator|=
name|NULL
expr_stmt|;
name|obj_private
operator|->
name|so_info
operator|=
name|NULL
expr_stmt|;
name|so
operator|->
name|objfile
operator|->
name|obj_private
operator|=
operator|(
name|PTR
operator|)
name|obj_private
expr_stmt|;
block|}
name|obj_private
operator|=
operator|(
name|obj_private_data_t
operator|*
operator|)
name|so
operator|->
name|objfile
operator|->
name|obj_private
expr_stmt|;
name|obj_private
operator|->
name|so_info
operator|=
name|so
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_check_format
argument_list|(
name|so
operator|->
name|abfd
argument_list|,
name|bfd_object
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"\"%s\": not in executable format: %s."
argument_list|,
name|name
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|som_solib_load_symbols
parameter_list|(
name|so
parameter_list|,
name|name
parameter_list|,
name|from_tty
parameter_list|,
name|text_addr
parameter_list|,
name|target
parameter_list|)
name|struct
name|so_list
modifier|*
name|so
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
name|CORE_ADDR
name|text_addr
decl_stmt|;
name|struct
name|target_ops
modifier|*
name|target
decl_stmt|;
block|{
name|struct
name|section_table
modifier|*
name|p
decl_stmt|;
name|int
name|status
decl_stmt|;
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|CORE_ADDR
name|presumed_data_start
decl_stmt|;
ifdef|#
directive|ifdef
name|SOLIB_DEBUG
name|printf
argument_list|(
literal|"--Adding symbols for shared library \"%s\"\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|som_solib_add_solib_objfile
argument_list|(
name|so
argument_list|,
name|name
argument_list|,
name|from_tty
argument_list|,
name|text_addr
argument_list|)
expr_stmt|;
comment|/* Now we need to build a section table for this library since      we might be debugging a core file from a dynamically linked      executable in which the libraries were not privately mapped.  */
if|if
condition|(
name|build_section_table
argument_list|(
name|so
operator|->
name|abfd
argument_list|,
operator|&
name|so
operator|->
name|sections
argument_list|,
operator|&
name|so
operator|->
name|sections_end
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"Unable to build section table for shared library\n."
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Relocate all the sections based on where they got loaded.  */
for|for
control|(
name|p
operator|=
name|so
operator|->
name|sections
init|;
name|p
operator|<
name|so
operator|->
name|sections_end
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|p
operator|->
name|the_bfd_section
operator|->
name|flags
operator|&
name|SEC_CODE
condition|)
block|{
name|p
operator|->
name|addr
operator|+=
name|ANOFFSET
argument_list|(
name|so
operator|->
name|objfile
operator|->
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
expr_stmt|;
name|p
operator|->
name|endaddr
operator|+=
name|ANOFFSET
argument_list|(
name|so
operator|->
name|objfile
operator|->
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|the_bfd_section
operator|->
name|flags
operator|&
name|SEC_DATA
condition|)
block|{
name|p
operator|->
name|addr
operator|+=
name|ANOFFSET
argument_list|(
name|so
operator|->
name|objfile
operator|->
name|section_offsets
argument_list|,
name|SECT_OFF_DATA
argument_list|)
expr_stmt|;
name|p
operator|->
name|endaddr
operator|+=
name|ANOFFSET
argument_list|(
name|so
operator|->
name|objfile
operator|->
name|section_offsets
argument_list|,
name|SECT_OFF_DATA
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now see if we need to map in the text and data for this shared      library (for example debugging a core file which does not use      private shared libraries.).        Carefully peek at the first text address in the library.  If the      read succeeds, then the libraries were privately mapped and were      included in the core dump file.       If the peek failed, then the libraries were not privately mapped      and are not in the core file, we'll have to read them in ourselves.  */
name|status
operator|=
name|target_read_memory
argument_list|(
name|text_addr
argument_list|,
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
name|int
name|old
decl_stmt|,
name|new
decl_stmt|;
name|int
name|update_coreops
decl_stmt|;
name|int
name|update_execops
decl_stmt|;
comment|/* We must update the to_sections field in the core_ops structure          here, otherwise we dereference a potential dangling pointer          for each call to target_read/write_memory within this routine.  */
name|update_coreops
operator|=
name|core_ops
operator|.
name|to_sections
operator|==
name|target
operator|->
name|to_sections
expr_stmt|;
comment|/* Ditto exec_ops (this was a bug).        */
name|update_execops
operator|=
name|exec_ops
operator|.
name|to_sections
operator|==
name|target
operator|->
name|to_sections
expr_stmt|;
name|new
operator|=
name|so
operator|->
name|sections_end
operator|-
name|so
operator|->
name|sections
expr_stmt|;
comment|/* Add sections from the shared library to the core target.  */
if|if
condition|(
name|target
operator|->
name|to_sections
condition|)
block|{
name|old
operator|=
name|target
operator|->
name|to_sections_end
operator|-
name|target
operator|->
name|to_sections
expr_stmt|;
name|target
operator|->
name|to_sections
operator|=
operator|(
expr|struct
name|section_table
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|target
operator|->
name|to_sections
argument_list|,
operator|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|section_table
argument_list|)
operator|)
operator|*
operator|(
name|old
operator|+
name|new
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|old
operator|=
literal|0
expr_stmt|;
name|target
operator|->
name|to_sections
operator|=
operator|(
expr|struct
name|section_table
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|section_table
argument_list|)
operator|)
operator|*
name|new
argument_list|)
expr_stmt|;
block|}
name|target
operator|->
name|to_sections_end
operator|=
operator|(
name|target
operator|->
name|to_sections
operator|+
name|old
operator|+
name|new
operator|)
expr_stmt|;
comment|/* Update the to_sections field in the core_ops structure          if needed, ditto exec_ops.  */
if|if
condition|(
name|update_coreops
condition|)
block|{
name|core_ops
operator|.
name|to_sections
operator|=
name|target
operator|->
name|to_sections
expr_stmt|;
name|core_ops
operator|.
name|to_sections_end
operator|=
name|target
operator|->
name|to_sections_end
expr_stmt|;
block|}
if|if
condition|(
name|update_execops
condition|)
block|{
name|exec_ops
operator|.
name|to_sections
operator|=
name|target
operator|->
name|to_sections
expr_stmt|;
name|exec_ops
operator|.
name|to_sections_end
operator|=
name|target
operator|->
name|to_sections_end
expr_stmt|;
block|}
comment|/* Copy over the old data before it gets clobbered.  */
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|target
operator|->
name|to_sections
operator|+
name|old
operator|)
argument_list|,
name|so
operator|->
name|sections
argument_list|,
operator|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|section_table
argument_list|)
operator|)
operator|*
name|new
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Add symbols from shared libraries into the symtab list, unless the    size threshold (specified by auto_solib_add, in megabytes) would    be exceeded.  */
end_comment

begin_function
name|void
name|som_solib_add
parameter_list|(
name|arg_string
parameter_list|,
name|from_tty
parameter_list|,
name|target
parameter_list|)
name|char
modifier|*
name|arg_string
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
name|struct
name|target_ops
modifier|*
name|target
decl_stmt|;
block|{
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
name|struct
name|so_list
modifier|*
name|so_list_tail
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|asection
modifier|*
name|shlib_info
decl_stmt|;
name|int
name|status
decl_stmt|;
name|unsigned
name|int
name|dld_flags
decl_stmt|;
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|,
modifier|*
name|re_err
decl_stmt|;
name|int
name|threshold_warning_given
init|=
literal|0
decl_stmt|;
comment|/* First validate our arguments.  */
if|if
condition|(
operator|(
name|re_err
operator|=
name|re_comp
argument_list|(
name|arg_string
condition|?
name|arg_string
else|:
literal|"."
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"Invalid regexp: %s"
argument_list|,
name|re_err
argument_list|)
expr_stmt|;
block|}
comment|/* If we're debugging a core file, or have attached to a running      process, then som_solib_create_inferior_hook will not have been      called.       We need to first determine if we're dealing with a dynamically      linked executable.  If not, then return without an error or warning.       We also need to examine __dld_flags to determine if the shared library      list is valid and to determine if the libraries have been privately      mapped.  */
if|if
condition|(
name|symfile_objfile
operator|==
name|NULL
condition|)
return|return;
comment|/* First see if the objfile was dynamically linked.  */
name|shlib_info
operator|=
name|bfd_get_section_by_name
argument_list|(
name|symfile_objfile
operator|->
name|obfd
argument_list|,
literal|"$SHLIB_INFO$"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|shlib_info
condition|)
return|return;
comment|/* It's got a $SHLIB_INFO$ section, make sure it's not empty.  */
if|if
condition|(
name|bfd_section_size
argument_list|(
name|symfile_objfile
operator|->
name|obfd
argument_list|,
name|shlib_info
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|msymbol
operator|=
name|lookup_minimal_symbol
argument_list|(
literal|"__dld_flags"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|msymbol
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"Unable to find __dld_flags symbol in object file.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|addr
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
expr_stmt|;
comment|/* Read the current contents.  */
name|status
operator|=
name|target_read_memory
argument_list|(
name|addr
argument_list|,
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Unable to read __dld_flags\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|dld_flags
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* __dld_list may not be valid.  If not, then we punt, warning the user if      we were called as a result of the add-symfile command.      */
if|if
condition|(
operator|(
name|dld_flags
operator|&
name|DLD_FLAGS_LISTVALID
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|from_tty
condition|)
name|error
argument_list|(
literal|"__dld_list is not valid according to __dld_flags.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If the libraries were not mapped private, warn the user.  */
if|if
condition|(
operator|(
name|dld_flags
operator|&
name|DLD_FLAGS_MAPPRIVATE
operator|)
operator|==
literal|0
condition|)
name|warning
argument_list|(
literal|"The shared libraries were not privately mapped; setting a\nbreakpoint in a shared library will not work until you rerun the program.\n"
argument_list|)
expr_stmt|;
name|msymbol
operator|=
name|lookup_minimal_symbol
argument_list|(
literal|"__dld_list"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|msymbol
condition|)
block|{
comment|/* Older crt0.o files (hpux8) don't have __dld_list as a symbol, 	 but the data is still available if you know where to look.  */
name|msymbol
operator|=
name|lookup_minimal_symbol
argument_list|(
literal|"__dld_flags"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|msymbol
condition|)
block|{
name|error
argument_list|(
literal|"Unable to find dynamic library list.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|addr
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
operator|-
literal|8
expr_stmt|;
block|}
else|else
name|addr
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
expr_stmt|;
name|status
operator|=
name|target_read_memory
argument_list|(
name|addr
argument_list|,
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Unable to find dynamic library list.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|addr
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* If addr is zero, then we're using an old dynamic loader which      doesn't maintain __dld_list.  We'll have to use a completely      different approach to get shared library information.  */
if|if
condition|(
name|addr
operator|==
literal|0
condition|)
goto|goto
name|old_dld
goto|;
comment|/* Using the information in __dld_list is the preferred method      to get at shared library information.  It doesn't depend on      any functions in /opt/langtools/lib/end.o and has a chance of working      with hpux10 when it is released.  */
name|status
operator|=
name|target_read_memory
argument_list|(
name|addr
argument_list|,
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Unable to find dynamic library list.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* addr now holds the address of the first entry in the dynamic      library list.  */
name|addr
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Now that we have a pointer to the dynamic library list, walk      through it and add the symbols for each library.  */
name|so_list_tail
operator|=
name|so_list_head
expr_stmt|;
comment|/* Find the end of the list of shared objects.  */
while|while
condition|(
name|so_list_tail
operator|&&
name|so_list_tail
operator|->
name|next
condition|)
name|so_list_tail
operator|=
name|so_list_tail
operator|->
name|next
expr_stmt|;
ifdef|#
directive|ifdef
name|SOLIB_DEBUG
name|printf
argument_list|(
literal|"--About to read shared library list data\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* "addr" will always point to the base of the    * current data entry describing the current    * shared library.    */
while|while
condition|(
literal|1
condition|)
block|{
name|CORE_ADDR
name|name_addr
decl_stmt|,
name|text_addr
decl_stmt|;
name|unsigned
name|int
name|name_len
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|so_list
modifier|*
name|new_so
decl_stmt|;
name|struct
name|so_list
modifier|*
name|so_list
init|=
name|so_list_head
decl_stmt|;
name|struct
name|stat
name|statbuf
decl_stmt|;
name|LONGEST
name|st_size
decl_stmt|;
name|int
name|is_main_program
decl_stmt|;
if|if
condition|(
name|addr
operator|==
literal|0
condition|)
break|break;
comment|/* Get a pointer to the name of this library.  */
name|status
operator|=
name|target_read_memory
argument_list|(
name|addr
argument_list|,
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
goto|goto
name|err
goto|;
name|name_addr
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|name_len
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|target_read_memory
argument_list|(
name|name_addr
operator|+
name|name_len
argument_list|,
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
goto|goto
name|err
goto|;
name|name_len
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|buf
operator|==
literal|'\0'
condition|)
break|break;
block|}
name|name
operator|=
name|alloca
argument_list|(
name|name_len
argument_list|)
expr_stmt|;
name|status
operator|=
name|target_read_memory
argument_list|(
name|name_addr
argument_list|,
name|name
argument_list|,
name|name_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
goto|goto
name|err
goto|;
comment|/* See if we've already loaded something with this name.  */
while|while
condition|(
name|so_list
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|so_list
operator|->
name|som_solib
operator|.
name|name
argument_list|,
name|name
argument_list|)
condition|)
break|break;
name|so_list
operator|=
name|so_list
operator|->
name|next
expr_stmt|;
block|}
comment|/* See if the file exists.  If not, give a warning, but don't 	 die.  */
name|status
operator|=
name|stat
argument_list|(
name|name
argument_list|,
operator|&
name|statbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
operator|-
literal|1
condition|)
block|{
name|warning
argument_list|(
literal|"Can't find file %s referenced in dld_list."
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|status
operator|=
name|target_read_memory
argument_list|(
name|addr
operator|+
literal|36
argument_list|,
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
goto|goto
name|err
goto|;
name|addr
operator|=
operator|(
name|CORE_ADDR
operator|)
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* If we've already loaded this one or it's the main program, skip it.  */
name|is_main_program
operator|=
operator|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|symfile_objfile
operator|->
name|name
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|so_list
operator|||
name|is_main_program
condition|)
block|{
comment|/* This is the "next" pointer in the strcuture.            */
name|status
operator|=
name|target_read_memory
argument_list|(
name|addr
operator|+
literal|36
argument_list|,
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
goto|goto
name|err
goto|;
name|addr
operator|=
operator|(
name|CORE_ADDR
operator|)
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Record the main program's symbol table size. */
if|if
condition|(
name|is_main_program
operator|&&
operator|!
name|so_list
condition|)
block|{
name|st_size
operator|=
name|som_solib_sizeof_symbol_table
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|som_solib_total_st_size
operator|+=
name|st_size
expr_stmt|;
block|}
comment|/* Was this a shlib that we noted but didn't load the symbols for?              If so, were we invoked this time from the command-line, via              a 'sharedlibrary' or 'add-symbol-file' command?  If yes to              both, we'd better load the symbols this time.              */
if|if
condition|(
name|from_tty
operator|&&
name|so_list
operator|&&
operator|!
name|is_main_program
operator|&&
operator|(
name|so_list
operator|->
name|objfile
operator|==
name|NULL
operator|)
condition|)
name|som_solib_load_symbols
argument_list|(
name|so_list
argument_list|,
name|name
argument_list|,
name|from_tty
argument_list|,
name|so_list
operator|->
name|som_solib
operator|.
name|text_addr
argument_list|,
name|target
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|name
operator|=
name|obsavestring
argument_list|(
name|name
argument_list|,
name|name_len
operator|-
literal|1
argument_list|,
operator|&
name|symfile_objfile
operator|->
name|symbol_obstack
argument_list|)
expr_stmt|;
name|status
operator|=
name|target_read_memory
argument_list|(
name|addr
operator|+
literal|8
argument_list|,
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
goto|goto
name|err
goto|;
name|text_addr
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|new_so
operator|=
operator|(
expr|struct
name|so_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|so_list
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|new_so
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|so_list
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|so_list_head
operator|==
name|NULL
condition|)
block|{
name|so_list_head
operator|=
name|new_so
expr_stmt|;
name|so_list_tail
operator|=
name|new_so
expr_stmt|;
block|}
else|else
block|{
name|so_list_tail
operator|->
name|next
operator|=
name|new_so
expr_stmt|;
name|so_list_tail
operator|=
name|new_so
expr_stmt|;
block|}
comment|/* Fill in all the entries in GDB's shared library list.        */
name|new_so
operator|->
name|solib_addr
operator|=
name|addr
expr_stmt|;
name|new_so
operator|->
name|som_solib
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|status
operator|=
name|target_read_memory
argument_list|(
name|addr
operator|+
literal|4
argument_list|,
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
goto|goto
name|err
goto|;
name|new_so
operator|->
name|som_solib
operator|.
name|struct_version
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
operator|+
literal|3
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|new_so
operator|->
name|som_solib
operator|.
name|bind_mode
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
operator|+
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Following is "high water mark", highest version number          * seen, rather than plain version number.          */
name|new_so
operator|->
name|som_solib
operator|.
name|library_version
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|new_so
operator|->
name|som_solib
operator|.
name|text_addr
operator|=
name|text_addr
expr_stmt|;
comment|/* Q: What about longword at "addr + 8"?          * A: It's read above, out of order, into "text_addr".          */
name|status
operator|=
name|target_read_memory
argument_list|(
name|addr
operator|+
literal|12
argument_list|,
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
goto|goto
name|err
goto|;
name|new_so
operator|->
name|som_solib
operator|.
name|text_link_addr
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|status
operator|=
name|target_read_memory
argument_list|(
name|addr
operator|+
literal|16
argument_list|,
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
goto|goto
name|err
goto|;
name|new_so
operator|->
name|som_solib
operator|.
name|text_end
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|status
operator|=
name|target_read_memory
argument_list|(
name|addr
operator|+
literal|20
argument_list|,
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
goto|goto
name|err
goto|;
name|new_so
operator|->
name|som_solib
operator|.
name|data_start
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|status
operator|=
name|target_read_memory
argument_list|(
name|addr
operator|+
literal|24
argument_list|,
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
goto|goto
name|err
goto|;
name|new_so
operator|->
name|som_solib
operator|.
name|bss_start
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|status
operator|=
name|target_read_memory
argument_list|(
name|addr
operator|+
literal|28
argument_list|,
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
goto|goto
name|err
goto|;
name|new_so
operator|->
name|som_solib
operator|.
name|data_end
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|status
operator|=
name|target_read_memory
argument_list|(
name|addr
operator|+
literal|32
argument_list|,
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
goto|goto
name|err
goto|;
name|new_so
operator|->
name|som_solib
operator|.
name|got_value
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|status
operator|=
name|target_read_memory
argument_list|(
name|addr
operator|+
literal|36
argument_list|,
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
goto|goto
name|err
goto|;
name|new_so
operator|->
name|som_solib
operator|.
name|next
operator|=
operator|(
name|void
operator|*
operator|)
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Note that we don't re-set "addr" to the next pointer        * until after we've read the trailing data.        */
name|status
operator|=
name|target_read_memory
argument_list|(
name|addr
operator|+
literal|40
argument_list|,
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|new_so
operator|->
name|som_solib
operator|.
name|tsd_start_addr
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
goto|goto
name|err
goto|;
comment|/* Now indirect via that value!        */
name|status
operator|=
name|target_read_memory
argument_list|(
name|new_so
operator|->
name|som_solib
operator|.
name|tsd_start_addr
argument_list|,
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|new_so
operator|->
name|som_solib
operator|.
name|tsd_start_addr
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
goto|goto
name|err
goto|;
ifdef|#
directive|ifdef
name|SOLIB_DEBUG
name|printf
argument_list|(
literal|"\n+ library \"%s\" is described at 0x%x\n"
argument_list|,
name|name
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  'version' is %d\n"
argument_list|,
name|new_so
operator|->
name|som_solib
operator|.
name|struct_version
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  'bind_mode' is %d\n"
argument_list|,
name|new_so
operator|->
name|som_solib
operator|.
name|bind_mode
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  'library_version' is %d\n"
argument_list|,
name|new_so
operator|->
name|som_solib
operator|.
name|library_version
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  'text_addr' is 0x%x\n"
argument_list|,
name|new_so
operator|->
name|som_solib
operator|.
name|text_addr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  'text_link_addr' is 0x%x\n"
argument_list|,
name|new_so
operator|->
name|som_solib
operator|.
name|text_link_addr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  'text_end' is 0x%x\n"
argument_list|,
name|new_so
operator|->
name|som_solib
operator|.
name|text_end
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  'data_start' is 0x%x\n"
argument_list|,
name|new_so
operator|->
name|som_solib
operator|.
name|data_start
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  'bss_start' is 0x%x\n"
argument_list|,
name|new_so
operator|->
name|som_solib
operator|.
name|bss_start
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  'data_end' is 0x%x\n"
argument_list|,
name|new_so
operator|->
name|som_solib
operator|.
name|data_end
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  'got_value' is %x\n"
argument_list|,
name|new_so
operator|->
name|som_solib
operator|.
name|got_value
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  'next' is 0x%x\n"
argument_list|,
name|new_so
operator|->
name|som_solib
operator|.
name|next
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  'tsd_start_addr' is 0x%x\n"
argument_list|,
name|new_so
operator|->
name|som_solib
operator|.
name|tsd_start_addr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Go on to the next shared library descriptor.        */
name|addr
operator|=
operator|(
name|CORE_ADDR
operator|)
name|new_so
operator|->
name|som_solib
operator|.
name|next
expr_stmt|;
comment|/* At this point, we have essentially hooked the shlib into the          "info share" command.  However, we haven't yet loaded its          symbol table.  We must now decide whether we ought to, i.e.,          whether doing so would exceed the symbol table size threshold.           If the threshold has just now been exceeded, then we'll issue          a warning message (which explains how to load symbols manually,          if the user so desires).           If the threshold has just now or previously been exceeded,          we'll just add the shlib to the list of object files, but won't          actually load its symbols.  (This is more useful than it might          sound, for it allows us to e.g., still load and use the shlibs'          unwind information for stack tracebacks.)          */
comment|/* Note that we DON'T want to preclude the user from using the          add-symbol-file command!  Thus, we only worry about the threshold          when we're invoked for other reasons.          */
name|st_size
operator|=
name|som_solib_sizeof_symbol_table
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|som_solib_st_size_threshold_exceeded
operator|=
operator|!
name|from_tty
operator|&&
operator|(
operator|(
name|st_size
operator|+
name|som_solib_total_st_size
operator|)
operator|>
operator|(
name|auto_solib_add
operator|*
operator|(
name|LONGEST
operator|)
literal|1000000
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|som_solib_st_size_threshold_exceeded
condition|)
block|{
if|if
condition|(
operator|!
name|threshold_warning_given
condition|)
name|warning
argument_list|(
literal|"Symbols for some libraries have not been loaded, because\ndoing so would exceed the size threshold specified by auto-solib-add.\nTo manually load symbols, use the 'sharedlibrary' command.\nTo raise the threshold, set auto-solib-add to a larger value and rerun\nthe program.\n"
argument_list|)
expr_stmt|;
name|threshold_warning_given
operator|=
literal|1
expr_stmt|;
comment|/* We'll still make note of this shlib, even if we don't              read its symbols.  This allows us to use its unwind              information well enough to know how to e.g., correctly              do a traceback from a PC within the shlib, even if we              can't symbolize those PCs...              */
name|som_solib_add_solib_objfile
argument_list|(
name|new_so
argument_list|,
name|name
argument_list|,
name|from_tty
argument_list|,
name|text_addr
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|som_solib_total_st_size
operator|+=
name|st_size
expr_stmt|;
comment|/* This fills in new_so->objfile, among others. */
name|som_solib_load_symbols
argument_list|(
name|new_so
argument_list|,
name|name
argument_list|,
name|from_tty
argument_list|,
name|text_addr
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SOLIB_DEBUG
name|printf
argument_list|(
literal|"--Done reading shared library data\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Getting new symbols may change our opinion about what is      frameless.  */
name|reinit_frame_cache
argument_list|()
expr_stmt|;
return|return;
name|old_dld
label|:
name|error
argument_list|(
literal|"Debugging dynamic executables loaded via the hpux8 dld.sl is not supported.\n"
argument_list|)
expr_stmt|;
return|return;
name|err
label|:
name|error
argument_list|(
literal|"Error while reading dynamic library list.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* This hook gets called just before the first instruction in the    inferior process is executed.     This is our opportunity to set magic flags in the inferior so    that GDB can be notified when a shared library is mapped in and    to tell the dynamic linker that a private copy of the library is    needed (so GDB can set breakpoints in the library).     __dld_flags is the location of the magic flags; as of this implementation    there are 3 flags of interest:     bit 0 when set indicates that private copies of the libraries are needed    bit 1 when set indicates that the callback hook routine is valid    bit 2 when set indicates that the dynamic linker should maintain the          __dld_list structure when loading/unloading libraries.     Note that shared libraries are not mapped in at this time, so we have    run the inferior until the libraries are mapped in.  Typically this    means running until the "_start" is called.  */
end_comment

begin_function
name|void
name|som_solib_create_inferior_hook
parameter_list|()
block|{
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
name|unsigned
name|int
name|dld_flags
decl_stmt|,
name|status
decl_stmt|,
name|have_endo
decl_stmt|;
name|asection
modifier|*
name|shlib_info
decl_stmt|;
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|CORE_ADDR
name|anaddr
decl_stmt|;
comment|/* First, remove all the solib event breakpoints.  Their addresses      may have changed since the last time we ran the program.  */
name|remove_solib_event_breakpoints
argument_list|()
expr_stmt|;
if|if
condition|(
name|symfile_objfile
operator|==
name|NULL
condition|)
return|return;
comment|/* First see if the objfile was dynamically linked.  */
name|shlib_info
operator|=
name|bfd_get_section_by_name
argument_list|(
name|symfile_objfile
operator|->
name|obfd
argument_list|,
literal|"$SHLIB_INFO$"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|shlib_info
condition|)
return|return;
comment|/* It's got a $SHLIB_INFO$ section, make sure it's not empty.  */
if|if
condition|(
name|bfd_section_size
argument_list|(
name|symfile_objfile
operator|->
name|obfd
argument_list|,
name|shlib_info
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|have_endo
operator|=
literal|0
expr_stmt|;
comment|/* Slam the pid of the process into __d_pid; failing is only a warning!  */
name|msymbol
operator|=
name|lookup_minimal_symbol
argument_list|(
literal|"__d_pid"
argument_list|,
name|NULL
argument_list|,
name|symfile_objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|msymbol
operator|==
name|NULL
condition|)
block|{
name|warning
argument_list|(
literal|"Unable to find __d_pid symbol in object file."
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"Suggest linking with /opt/langtools/lib/end.o."
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"GDB will be unable to track shl_load/shl_unload calls"
argument_list|)
expr_stmt|;
goto|goto
name|keep_going
goto|;
block|}
name|anaddr
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
expr_stmt|;
name|store_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|,
name|inferior_pid
argument_list|)
expr_stmt|;
name|status
operator|=
name|target_write_memory
argument_list|(
name|anaddr
argument_list|,
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"Unable to write __d_pid"
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"Suggest linking with /opt/langtools/lib/end.o."
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"GDB will be unable to track shl_load/shl_unload calls"
argument_list|)
expr_stmt|;
goto|goto
name|keep_going
goto|;
block|}
comment|/* Get the value of _DLD_HOOK (an export stub) and put it in __dld_hook;      This will force the dynamic linker to call __d_trap when significant      events occur.       Note that the above is the pre-HP-UX 9.0 behaviour.  At 9.0 and above,      the dld provides an export stub named "__d_trap" as well as the      function named "__d_trap" itself, but doesn't provide "_DLD_HOOK".      We'll look first for the old flavor and then the new.      */
name|msymbol
operator|=
name|lookup_minimal_symbol
argument_list|(
literal|"_DLD_HOOK"
argument_list|,
name|NULL
argument_list|,
name|symfile_objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|msymbol
operator|==
name|NULL
condition|)
name|msymbol
operator|=
name|lookup_minimal_symbol
argument_list|(
literal|"__d_trap"
argument_list|,
name|NULL
argument_list|,
name|symfile_objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|msymbol
operator|==
name|NULL
condition|)
block|{
name|warning
argument_list|(
literal|"Unable to find _DLD_HOOK symbol in object file."
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"Suggest linking with /opt/langtools/lib/end.o."
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"GDB will be unable to track shl_load/shl_unload calls"
argument_list|)
expr_stmt|;
goto|goto
name|keep_going
goto|;
block|}
name|anaddr
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
expr_stmt|;
name|dld_cache
operator|.
name|hook
operator|.
name|address
operator|=
name|anaddr
expr_stmt|;
comment|/* Grrr, this might not be an export symbol!  We have to find the      export stub.  */
name|ALL_OBJFILES
argument_list|(
argument|objfile
argument_list|)
block|{
name|struct
name|unwind_table_entry
modifier|*
name|u
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|msymbol2
decl_stmt|;
comment|/* What a crock.  */
name|msymbol2
operator|=
name|lookup_minimal_symbol_solib_trampoline
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|msymbol
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* Found a symbol with the right name.  */
if|if
condition|(
name|msymbol2
condition|)
block|{
name|struct
name|unwind_table_entry
modifier|*
name|u
decl_stmt|;
comment|/* It must be a shared library trampoline.  */
if|if
condition|(
name|SYMBOL_TYPE
argument_list|(
name|msymbol2
argument_list|)
operator|!=
name|mst_solib_trampoline
condition|)
continue|continue;
comment|/* It must also be an export stub.  */
name|u
operator|=
name|find_unwind_entry
argument_list|(
name|SYMBOL_VALUE
argument_list|(
name|msymbol2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|u
operator|||
name|u
operator|->
name|stub_unwind
operator|.
name|stub_type
operator|!=
name|EXPORT
condition|)
continue|continue;
comment|/* OK.  Looks like the correct import stub.  */
name|anaddr
operator|=
name|SYMBOL_VALUE
argument_list|(
name|msymbol2
argument_list|)
expr_stmt|;
name|dld_cache
operator|.
name|hook_stub
operator|.
name|address
operator|=
name|anaddr
expr_stmt|;
block|}
block|}
name|store_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|,
name|anaddr
argument_list|)
expr_stmt|;
name|msymbol
operator|=
name|lookup_minimal_symbol
argument_list|(
literal|"__dld_hook"
argument_list|,
name|NULL
argument_list|,
name|symfile_objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|msymbol
operator|==
name|NULL
condition|)
block|{
name|warning
argument_list|(
literal|"Unable to find __dld_hook symbol in object file."
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"Suggest linking with /opt/langtools/lib/end.o."
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"GDB will be unable to track shl_load/shl_unload calls"
argument_list|)
expr_stmt|;
goto|goto
name|keep_going
goto|;
block|}
name|anaddr
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
expr_stmt|;
name|status
operator|=
name|target_write_memory
argument_list|(
name|anaddr
argument_list|,
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Now set a shlib_event breakpoint at __d_trap so we can track      significant shared library events.  */
name|msymbol
operator|=
name|lookup_minimal_symbol
argument_list|(
literal|"__d_trap"
argument_list|,
name|NULL
argument_list|,
name|symfile_objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|msymbol
operator|==
name|NULL
condition|)
block|{
name|warning
argument_list|(
literal|"Unable to find __dld_d_trap symbol in object file."
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"Suggest linking with /opt/langtools/lib/end.o."
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"GDB will be unable to track shl_load/shl_unload calls"
argument_list|)
expr_stmt|;
goto|goto
name|keep_going
goto|;
block|}
name|create_solib_event_breakpoint
argument_list|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We have all the support usually found in end.o, so we can track      shl_load and shl_unload calls.  */
name|have_endo
operator|=
literal|1
expr_stmt|;
name|keep_going
label|:
comment|/* Get the address of __dld_flags, if no such symbol exists, then we can      not debug the shared code.  */
name|msymbol
operator|=
name|lookup_minimal_symbol
argument_list|(
literal|"__dld_flags"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|msymbol
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"Unable to find __dld_flags symbol in object file.\n"
argument_list|)
expr_stmt|;
block|}
name|anaddr
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
expr_stmt|;
comment|/* Read the current contents.  */
name|status
operator|=
name|target_read_memory
argument_list|(
name|anaddr
argument_list|,
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Unable to read __dld_flags\n"
argument_list|)
expr_stmt|;
block|}
name|dld_flags
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Turn on the flags we care about.  */
name|dld_flags
operator||=
name|DLD_FLAGS_MAPPRIVATE
expr_stmt|;
if|if
condition|(
name|have_endo
condition|)
name|dld_flags
operator||=
name|DLD_FLAGS_HOOKVALID
expr_stmt|;
name|store_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|,
name|dld_flags
argument_list|)
expr_stmt|;
name|status
operator|=
name|target_write_memory
argument_list|(
name|anaddr
argument_list|,
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Unable to write __dld_flags\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Now find the address of _start and set a breakpoint there.       We still need this code for two reasons:  	* Not all sites have /opt/langtools/lib/end.o, so it's not always 	possible to track the dynamic linker's events.  	* At this time no events are triggered for shared libraries 	loaded at startup time (what a crock).  */
name|msymbol
operator|=
name|lookup_minimal_symbol
argument_list|(
literal|"_start"
argument_list|,
name|NULL
argument_list|,
name|symfile_objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|msymbol
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"Unable to find _start symbol in object file.\n"
argument_list|)
expr_stmt|;
block|}
name|anaddr
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
expr_stmt|;
comment|/* Make the breakpoint at "_start" a shared library event breakpoint.  */
name|create_solib_event_breakpoint
argument_list|(
name|anaddr
argument_list|)
expr_stmt|;
comment|/* Wipe out all knowledge of old shared libraries since their      mapping can change from one exec to another!  */
while|while
condition|(
name|so_list_head
condition|)
block|{
name|struct
name|so_list
modifier|*
name|temp
decl_stmt|;
name|temp
operator|=
name|so_list_head
expr_stmt|;
name|free
argument_list|(
name|so_list_head
argument_list|)
expr_stmt|;
name|so_list_head
operator|=
name|temp
operator|->
name|next
expr_stmt|;
block|}
name|clear_symtab_users
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|reset_inferior_pid
parameter_list|(
name|saved_inferior_pid
parameter_list|)
name|int
name|saved_inferior_pid
decl_stmt|;
block|{
name|inferior_pid
operator|=
name|saved_inferior_pid
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This operation removes the "hook" between GDB and the dynamic linker,    which causes the dld to notify GDB of shared library events.     After this operation completes, the dld will no longer notify GDB of    shared library events.  To resume notifications, GDB must call    som_solib_create_inferior_hook.     This operation does not remove any knowledge of shared libraries which    GDB may already have been notified of.    */
end_comment

begin_function
name|void
name|som_solib_remove_inferior_hook
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
name|CORE_ADDR
name|addr
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
name|int
name|status
decl_stmt|;
name|char
name|dld_flags_buffer
index|[
name|TARGET_INT_BIT
operator|/
name|TARGET_CHAR_BIT
index|]
decl_stmt|;
name|unsigned
name|int
name|dld_flags_value
decl_stmt|;
name|int
name|saved_inferior_pid
init|=
name|inferior_pid
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_cleanups
init|=
name|make_cleanup
argument_list|(
name|reset_inferior_pid
argument_list|,
name|saved_inferior_pid
argument_list|)
decl_stmt|;
comment|/* Ensure that we're really operating on the specified process. */
name|inferior_pid
operator|=
name|pid
expr_stmt|;
comment|/* We won't bother to remove the solib breakpoints from this process.       In fact, on PA64 the breakpoint is hard-coded into the dld callback,      and thus we're not supposed to remove it.       Rather, we'll merely clear the dld_flags bit that enables callbacks.      */
name|msymbol
operator|=
name|lookup_minimal_symbol
argument_list|(
literal|"__dld_flags"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|addr
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
expr_stmt|;
name|status
operator|=
name|target_read_memory
argument_list|(
name|addr
argument_list|,
name|dld_flags_buffer
argument_list|,
name|TARGET_INT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|)
expr_stmt|;
name|dld_flags_value
operator|=
name|extract_unsigned_integer
argument_list|(
name|dld_flags_buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|dld_flags_value
argument_list|)
argument_list|)
expr_stmt|;
name|dld_flags_value
operator|&=
operator|~
name|DLD_FLAGS_HOOKVALID
expr_stmt|;
name|store_unsigned_integer
argument_list|(
name|dld_flags_buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|dld_flags_value
argument_list|)
argument_list|,
name|dld_flags_value
argument_list|)
expr_stmt|;
name|status
operator|=
name|target_write_memory
argument_list|(
name|addr
argument_list|,
name|dld_flags_buffer
argument_list|,
name|TARGET_INT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_cleanups
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function creates a breakpoint on the dynamic linker hook, which    is called when e.g., a shl_load or shl_unload call is made.  This    breakpoint will only trigger when a shl_load call is made.     If filename is NULL, then loads of any dll will be caught.  Else,    only loads of the file whose pathname is the string contained by    filename will be caught.     Undefined behaviour is guaranteed if this function is called before    som_solib_create_inferior_hook.    */
end_comment

begin_function
name|void
name|som_solib_create_catch_load_hook
parameter_list|(
name|pid
parameter_list|,
name|tempflag
parameter_list|,
name|filename
parameter_list|,
name|cond_string
parameter_list|)
name|int
name|pid
decl_stmt|;
name|int
name|tempflag
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|char
modifier|*
name|cond_string
decl_stmt|;
block|{
name|create_solib_load_event_breakpoint
argument_list|(
literal|"__d_trap"
argument_list|,
name|tempflag
argument_list|,
name|filename
argument_list|,
name|cond_string
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function creates a breakpoint on the dynamic linker hook, which    is called when e.g., a shl_load or shl_unload call is made.  This    breakpoint will only trigger when a shl_unload call is made.     If filename is NULL, then unloads of any dll will be caught.  Else,    only unloads of the file whose pathname is the string contained by    filename will be caught.     Undefined behaviour is guaranteed if this function is called before    som_solib_create_inferior_hook.    */
end_comment

begin_function
name|void
name|som_solib_create_catch_unload_hook
parameter_list|(
name|pid
parameter_list|,
name|tempflag
parameter_list|,
name|filename
parameter_list|,
name|cond_string
parameter_list|)
name|int
name|pid
decl_stmt|;
name|int
name|tempflag
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|char
modifier|*
name|cond_string
decl_stmt|;
block|{
name|create_solib_unload_event_breakpoint
argument_list|(
literal|"__d_trap"
argument_list|,
name|tempflag
argument_list|,
name|filename
argument_list|,
name|cond_string
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|som_solib_have_load_event
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
name|CORE_ADDR
name|event_kind
decl_stmt|;
name|event_kind
operator|=
name|read_register
argument_list|(
name|ARG0_REGNUM
argument_list|)
expr_stmt|;
return|return
operator|(
name|event_kind
operator|==
name|SHL_LOAD
operator|)
return|;
block|}
end_function

begin_function
name|int
name|som_solib_have_unload_event
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
name|CORE_ADDR
name|event_kind
decl_stmt|;
name|event_kind
operator|=
name|read_register
argument_list|(
name|ARG0_REGNUM
argument_list|)
expr_stmt|;
return|return
operator|(
name|event_kind
operator|==
name|SHL_UNLOAD
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|som_solib_library_pathname
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
name|CORE_ADDR
name|dll_handle_address
decl_stmt|;
name|CORE_ADDR
name|dll_pathname_address
decl_stmt|;
name|struct
name|som_solib_mapped_entry
name|dll_descriptor
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
specifier|static
name|char
name|dll_pathname
index|[
literal|1024
index|]
decl_stmt|;
comment|/* Read the descriptor of this newly-loaded library. */
name|dll_handle_address
operator|=
name|read_register
argument_list|(
name|ARG1_REGNUM
argument_list|)
expr_stmt|;
name|read_memory
argument_list|(
name|dll_handle_address
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|dll_descriptor
argument_list|,
sizeof|sizeof
argument_list|(
name|dll_descriptor
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We can find a pointer to the dll's pathname within the descriptor. */
name|dll_pathname_address
operator|=
operator|(
name|CORE_ADDR
operator|)
name|dll_descriptor
operator|.
name|name
expr_stmt|;
comment|/* Read the pathname, one byte at a time. */
name|p
operator|=
name|dll_pathname
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
name|b
decl_stmt|;
name|read_memory
argument_list|(
name|dll_pathname_address
operator|++
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|b
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|b
expr_stmt|;
if|if
condition|(
name|b
operator|==
literal|'\0'
condition|)
break|break;
block|}
return|return
name|dll_pathname
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|som_solib_loaded_library_pathname
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|som_solib_have_load_event
argument_list|(
name|pid
argument_list|)
condition|)
name|error
argument_list|(
literal|"Must have a load event to use this query"
argument_list|)
expr_stmt|;
return|return
name|som_solib_library_pathname
argument_list|(
name|pid
argument_list|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|som_solib_unloaded_library_pathname
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|som_solib_have_unload_event
argument_list|(
name|pid
argument_list|)
condition|)
name|error
argument_list|(
literal|"Must have an unload event to use this query"
argument_list|)
expr_stmt|;
return|return
name|som_solib_library_pathname
argument_list|(
name|pid
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|som_solib_desire_dynamic_linker_symbols
parameter_list|()
block|{
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|unwind_table_entry
modifier|*
name|u
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|dld_msymbol
decl_stmt|;
comment|/* Do we already know the value of these symbols?  If so, then      we've no work to do.       (If you add clauses to this test, be sure to likewise update the      test within the loop.)      */
if|if
condition|(
name|dld_cache
operator|.
name|is_valid
condition|)
return|return;
name|ALL_OBJFILES
argument_list|(
argument|objfile
argument_list|)
block|{
name|dld_msymbol
operator|=
name|lookup_minimal_symbol
argument_list|(
literal|"shl_load"
argument_list|,
name|NULL
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|dld_msymbol
operator|!=
name|NULL
condition|)
block|{
name|dld_cache
operator|.
name|load
operator|.
name|address
operator|=
name|SYMBOL_VALUE
argument_list|(
name|dld_msymbol
argument_list|)
expr_stmt|;
name|dld_cache
operator|.
name|load
operator|.
name|unwind
operator|=
name|find_unwind_entry
argument_list|(
name|dld_cache
operator|.
name|load
operator|.
name|address
argument_list|)
expr_stmt|;
block|}
name|dld_msymbol
operator|=
name|lookup_minimal_symbol_solib_trampoline
argument_list|(
literal|"shl_load"
argument_list|,
name|NULL
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|dld_msymbol
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|SYMBOL_TYPE
argument_list|(
name|dld_msymbol
argument_list|)
operator|==
name|mst_solib_trampoline
condition|)
block|{
name|u
operator|=
name|find_unwind_entry
argument_list|(
name|SYMBOL_VALUE
argument_list|(
name|dld_msymbol
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|u
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|u
operator|->
name|stub_unwind
operator|.
name|stub_type
operator|==
name|EXPORT
operator|)
condition|)
block|{
name|dld_cache
operator|.
name|load_stub
operator|.
name|address
operator|=
name|SYMBOL_VALUE
argument_list|(
name|dld_msymbol
argument_list|)
expr_stmt|;
name|dld_cache
operator|.
name|load_stub
operator|.
name|unwind
operator|=
name|u
expr_stmt|;
block|}
block|}
block|}
name|dld_msymbol
operator|=
name|lookup_minimal_symbol
argument_list|(
literal|"shl_unload"
argument_list|,
name|NULL
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|dld_msymbol
operator|!=
name|NULL
condition|)
block|{
name|dld_cache
operator|.
name|unload
operator|.
name|address
operator|=
name|SYMBOL_VALUE
argument_list|(
name|dld_msymbol
argument_list|)
expr_stmt|;
name|dld_cache
operator|.
name|unload
operator|.
name|unwind
operator|=
name|find_unwind_entry
argument_list|(
name|dld_cache
operator|.
name|unload
operator|.
name|address
argument_list|)
expr_stmt|;
comment|/* ??rehrauer: I'm not sure exactly what this is, but it appears              that on some HPUX 10.x versions, there's two unwind regions to              cover the body of "shl_unload", the second being 4 bytes past              the end of the first.  This is a large hack to handle that              case, but since I don't seem to have any legitimate way to              look for this thing via the symbol table...              */
if|if
condition|(
name|dld_cache
operator|.
name|unload
operator|.
name|unwind
operator|!=
name|NULL
condition|)
block|{
name|u
operator|=
name|find_unwind_entry
argument_list|(
name|dld_cache
operator|.
name|unload
operator|.
name|unwind
operator|->
name|region_end
operator|+
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|u
operator|!=
name|NULL
condition|)
block|{
name|dld_cache
operator|.
name|unload2
operator|.
name|address
operator|=
name|u
operator|->
name|region_start
expr_stmt|;
name|dld_cache
operator|.
name|unload2
operator|.
name|unwind
operator|=
name|u
expr_stmt|;
block|}
block|}
block|}
name|dld_msymbol
operator|=
name|lookup_minimal_symbol_solib_trampoline
argument_list|(
literal|"shl_unload"
argument_list|,
name|NULL
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|dld_msymbol
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|SYMBOL_TYPE
argument_list|(
name|dld_msymbol
argument_list|)
operator|==
name|mst_solib_trampoline
condition|)
block|{
name|u
operator|=
name|find_unwind_entry
argument_list|(
name|SYMBOL_VALUE
argument_list|(
name|dld_msymbol
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|u
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|u
operator|->
name|stub_unwind
operator|.
name|stub_type
operator|==
name|EXPORT
operator|)
condition|)
block|{
name|dld_cache
operator|.
name|unload_stub
operator|.
name|address
operator|=
name|SYMBOL_VALUE
argument_list|(
name|dld_msymbol
argument_list|)
expr_stmt|;
name|dld_cache
operator|.
name|unload_stub
operator|.
name|unwind
operator|=
name|u
expr_stmt|;
block|}
block|}
block|}
comment|/* Did we find everything we were looking for?  If so, stop. */
if|if
condition|(
operator|(
name|dld_cache
operator|.
name|load
operator|.
name|address
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|dld_cache
operator|.
name|load_stub
operator|.
name|address
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|dld_cache
operator|.
name|unload
operator|.
name|address
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|dld_cache
operator|.
name|unload_stub
operator|.
name|address
operator|!=
name|NULL
operator|)
condition|)
block|{
name|dld_cache
operator|.
name|is_valid
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|dld_cache
operator|.
name|hook
operator|.
name|unwind
operator|=
name|find_unwind_entry
argument_list|(
name|dld_cache
operator|.
name|hook
operator|.
name|address
argument_list|)
expr_stmt|;
name|dld_cache
operator|.
name|hook_stub
operator|.
name|unwind
operator|=
name|find_unwind_entry
argument_list|(
name|dld_cache
operator|.
name|hook_stub
operator|.
name|address
argument_list|)
expr_stmt|;
comment|/* We're prepared not to find some of these symbols, which is why      this function is a "desire" operation, and not a "require".      */
block|}
end_function

begin_function
name|int
name|som_solib_in_dynamic_linker
parameter_list|(
name|pid
parameter_list|,
name|pc
parameter_list|)
name|int
name|pid
decl_stmt|;
name|CORE_ADDR
name|pc
decl_stmt|;
block|{
name|struct
name|unwind_table_entry
modifier|*
name|u_pc
decl_stmt|;
comment|/* Are we in the dld itself?       ??rehrauer: Large hack -- We'll assume that any address in a      shared text region is the dld's text.  This would obviously      fall down if the user attached to a process, whose shlibs      weren't mapped to a (writeable) private region.  However, in      that case the debugger probably isn't able to set the fundamental      breakpoint in the dld callback anyways, so this hack should be      safe.      */
if|if
condition|(
operator|(
name|pc
operator|&
operator|(
name|CORE_ADDR
operator|)
literal|0xc0000000
operator|)
operator|==
operator|(
name|CORE_ADDR
operator|)
literal|0xc0000000
condition|)
return|return
literal|1
return|;
comment|/* Cache the address of some symbols that are part of the dynamic      linker, if not already known.      */
name|som_solib_desire_dynamic_linker_symbols
argument_list|()
expr_stmt|;
comment|/* Are we in the dld callback?  Or its export stub? */
name|u_pc
operator|=
name|find_unwind_entry
argument_list|(
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|u_pc
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|u_pc
operator|==
name|dld_cache
operator|.
name|hook
operator|.
name|unwind
operator|)
operator|||
operator|(
name|u_pc
operator|==
name|dld_cache
operator|.
name|hook_stub
operator|.
name|unwind
operator|)
condition|)
return|return
literal|1
return|;
comment|/* Or the interface of the dld (i.e., "shl_load" or friends)? */
if|if
condition|(
operator|(
name|u_pc
operator|==
name|dld_cache
operator|.
name|load
operator|.
name|unwind
operator|)
operator|||
operator|(
name|u_pc
operator|==
name|dld_cache
operator|.
name|unload
operator|.
name|unwind
operator|)
operator|||
operator|(
name|u_pc
operator|==
name|dld_cache
operator|.
name|unload2
operator|.
name|unwind
operator|)
operator|||
operator|(
name|u_pc
operator|==
name|dld_cache
operator|.
name|load_stub
operator|.
name|unwind
operator|)
operator|||
operator|(
name|u_pc
operator|==
name|dld_cache
operator|.
name|unload_stub
operator|.
name|unwind
operator|)
condition|)
return|return
literal|1
return|;
comment|/* Apparently this address isn't part of the dld's text. */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return the GOT value for the shared library in which ADDR belongs.  If    ADDR isn't in any known shared library, return zero.  */
end_comment

begin_function
name|CORE_ADDR
name|som_solib_get_got_by_pc
parameter_list|(
name|addr
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
block|{
name|struct
name|so_list
modifier|*
name|so_list
init|=
name|so_list_head
decl_stmt|;
name|CORE_ADDR
name|got_value
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|so_list
condition|)
block|{
if|if
condition|(
name|so_list
operator|->
name|som_solib
operator|.
name|text_addr
operator|<=
name|addr
operator|&&
name|so_list
operator|->
name|som_solib
operator|.
name|text_end
operator|>
name|addr
condition|)
block|{
name|got_value
operator|=
name|so_list
operator|->
name|som_solib
operator|.
name|got_value
expr_stmt|;
break|break;
block|}
name|so_list
operator|=
name|so_list
operator|->
name|next
expr_stmt|;
block|}
return|return
name|got_value
return|;
block|}
end_function

begin_comment
comment|/*  elz:    Return the address of the handle of the shared library    in which ADDR belongs.  If    ADDR isn't in any known shared library, return zero.  */
end_comment

begin_comment
comment|/* this function is used in hppa_fix_call_dummy in hppa-tdep.c*/
end_comment

begin_function
name|CORE_ADDR
name|som_solib_get_solib_by_pc
parameter_list|(
name|addr
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
block|{
name|struct
name|so_list
modifier|*
name|so_list
init|=
name|so_list_head
decl_stmt|;
while|while
condition|(
name|so_list
condition|)
block|{
if|if
condition|(
name|so_list
operator|->
name|som_solib
operator|.
name|text_addr
operator|<=
name|addr
operator|&&
name|so_list
operator|->
name|som_solib
operator|.
name|text_end
operator|>
name|addr
condition|)
block|{
break|break;
block|}
name|so_list
operator|=
name|so_list
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|so_list
condition|)
return|return
name|so_list
operator|->
name|solib_addr
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|som_solib_section_offsets
parameter_list|(
name|objfile
parameter_list|,
name|offsets
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|section_offsets
modifier|*
name|offsets
decl_stmt|;
block|{
name|struct
name|so_list
modifier|*
name|so_list
init|=
name|so_list_head
decl_stmt|;
while|while
condition|(
name|so_list
condition|)
block|{
comment|/* Oh what a pain!  We need the offsets before so_list->objfile 	 is valid.  The BFDs will never match.  Make a best guess.  */
if|if
condition|(
name|strstr
argument_list|(
name|objfile
operator|->
name|name
argument_list|,
name|so_list
operator|->
name|som_solib
operator|.
name|name
argument_list|)
condition|)
block|{
name|asection
modifier|*
name|private_section
decl_stmt|;
comment|/* The text offset is easy.  */
name|ANOFFSET
argument_list|(
name|offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
operator|=
operator|(
name|so_list
operator|->
name|som_solib
operator|.
name|text_addr
operator|-
name|so_list
operator|->
name|som_solib
operator|.
name|text_link_addr
operator|)
expr_stmt|;
name|ANOFFSET
argument_list|(
name|offsets
argument_list|,
name|SECT_OFF_RODATA
argument_list|)
operator|=
name|ANOFFSET
argument_list|(
name|offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
expr_stmt|;
comment|/* We should look at presumed_dp in the SOM header, but 	     that's not easily available.  This should be OK though.  */
name|private_section
operator|=
name|bfd_get_section_by_name
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
literal|"$PRIVATE$"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|private_section
condition|)
block|{
name|warning
argument_list|(
literal|"Unable to find $PRIVATE$ in shared library!"
argument_list|)
expr_stmt|;
name|ANOFFSET
argument_list|(
name|offsets
argument_list|,
name|SECT_OFF_DATA
argument_list|)
operator|=
literal|0
expr_stmt|;
name|ANOFFSET
argument_list|(
name|offsets
argument_list|,
name|SECT_OFF_BSS
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
name|ANOFFSET
argument_list|(
name|offsets
argument_list|,
name|SECT_OFF_DATA
argument_list|)
operator|=
operator|(
name|so_list
operator|->
name|som_solib
operator|.
name|data_start
operator|-
name|private_section
operator|->
name|vma
operator|)
expr_stmt|;
name|ANOFFSET
argument_list|(
name|offsets
argument_list|,
name|SECT_OFF_BSS
argument_list|)
operator|=
name|ANOFFSET
argument_list|(
name|offsets
argument_list|,
name|SECT_OFF_DATA
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|so_list
operator|=
name|so_list
operator|->
name|next
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Dump information about all the currently loaded shared libraries.  */
end_comment

begin_function
specifier|static
name|void
name|som_sharedlibrary_info_command
parameter_list|(
name|ignore
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|ignore
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|struct
name|so_list
modifier|*
name|so_list
init|=
name|so_list_head
decl_stmt|;
if|if
condition|(
name|exec_bfd
operator|==
name|NULL
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"no exec file.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|so_list
operator|==
name|NULL
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"No shared libraries loaded at this time.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf_unfiltered
argument_list|(
literal|"Shared Object Libraries\n"
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"    %-12s%-12s%-12s%-12s%-12s%-12s\n"
argument_list|,
literal|"  flags"
argument_list|,
literal|"  tstart"
argument_list|,
literal|"   tend"
argument_list|,
literal|"  dstart"
argument_list|,
literal|"   dend"
argument_list|,
literal|"   dlt"
argument_list|)
expr_stmt|;
while|while
condition|(
name|so_list
condition|)
block|{
name|unsigned
name|int
name|flags
decl_stmt|;
name|flags
operator|=
name|so_list
operator|->
name|som_solib
operator|.
name|struct_version
operator|<<
literal|24
expr_stmt|;
name|flags
operator||=
name|so_list
operator|->
name|som_solib
operator|.
name|bind_mode
operator|<<
literal|16
expr_stmt|;
name|flags
operator||=
name|so_list
operator|->
name|som_solib
operator|.
name|library_version
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"%s"
argument_list|,
name|so_list
operator|->
name|som_solib
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|so_list
operator|->
name|objfile
operator|==
name|NULL
condition|)
name|printf_unfiltered
argument_list|(
literal|"  (symbols not loaded)"
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"    %-12s"
argument_list|,
name|local_hex_string_custom
argument_list|(
name|flags
argument_list|,
literal|"08l"
argument_list|)
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"%-12s"
argument_list|,
name|local_hex_string_custom
argument_list|(
name|so_list
operator|->
name|som_solib
operator|.
name|text_addr
argument_list|,
literal|"08l"
argument_list|)
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"%-12s"
argument_list|,
name|local_hex_string_custom
argument_list|(
name|so_list
operator|->
name|som_solib
operator|.
name|text_end
argument_list|,
literal|"08l"
argument_list|)
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"%-12s"
argument_list|,
name|local_hex_string_custom
argument_list|(
name|so_list
operator|->
name|som_solib
operator|.
name|data_start
argument_list|,
literal|"08l"
argument_list|)
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"%-12s"
argument_list|,
name|local_hex_string_custom
argument_list|(
name|so_list
operator|->
name|som_solib
operator|.
name|data_end
argument_list|,
literal|"08l"
argument_list|)
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"%-12s\n"
argument_list|,
name|local_hex_string_custom
argument_list|(
name|so_list
operator|->
name|som_solib
operator|.
name|got_value
argument_list|,
literal|"08l"
argument_list|)
argument_list|)
expr_stmt|;
name|so_list
operator|=
name|so_list
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|som_solib_sharedlibrary_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|dont_repeat
argument_list|()
expr_stmt|;
name|som_solib_add
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|,
operator|(
expr|struct
name|target_ops
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|som_solib_address
parameter_list|(
name|addr
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
block|{
name|struct
name|so_list
modifier|*
name|so
init|=
name|so_list_head
decl_stmt|;
while|while
condition|(
name|so
condition|)
block|{
comment|/* Is this address within this shlib's text range?  If so,          return the shlib's name.          */
if|if
condition|(
operator|(
name|addr
operator|>=
name|so
operator|->
name|som_solib
operator|.
name|text_addr
operator|)
operator|&&
operator|(
name|addr
operator|<=
name|so
operator|->
name|som_solib
operator|.
name|text_end
operator|)
condition|)
return|return
name|so
operator|->
name|som_solib
operator|.
name|name
return|;
comment|/* Nope, keep looking... */
name|so
operator|=
name|so
operator|->
name|next
expr_stmt|;
block|}
comment|/* No, we couldn't prove that the address is within a shlib. */
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|void
name|som_solib_restart
parameter_list|()
block|{
name|struct
name|so_list
modifier|*
name|sl
init|=
name|so_list_head
decl_stmt|;
comment|/* Before the shlib info vanishes, use it to disable any breakpoints      that may still be active in those shlibs.      */
name|disable_breakpoints_in_shlibs
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Discard all the shlib descriptors.      */
while|while
condition|(
name|sl
condition|)
block|{
name|struct
name|so_list
modifier|*
name|next_sl
init|=
name|sl
operator|->
name|next
decl_stmt|;
name|free
argument_list|(
name|sl
argument_list|)
expr_stmt|;
name|sl
operator|=
name|next_sl
expr_stmt|;
block|}
name|so_list_head
operator|=
name|NULL
expr_stmt|;
name|som_solib_total_st_size
operator|=
operator|(
name|LONGEST
operator|)
literal|0
expr_stmt|;
name|som_solib_st_size_threshold_exceeded
operator|=
literal|0
expr_stmt|;
name|dld_cache
operator|.
name|is_valid
operator|=
literal|0
expr_stmt|;
name|dld_cache
operator|.
name|hook
operator|.
name|address
operator|=
literal|0
expr_stmt|;
name|dld_cache
operator|.
name|hook
operator|.
name|unwind
operator|=
name|NULL
expr_stmt|;
name|dld_cache
operator|.
name|hook_stub
operator|.
name|address
operator|=
literal|0
expr_stmt|;
name|dld_cache
operator|.
name|hook_stub
operator|.
name|unwind
operator|=
name|NULL
expr_stmt|;
name|dld_cache
operator|.
name|load
operator|.
name|address
operator|=
literal|0
expr_stmt|;
name|dld_cache
operator|.
name|load
operator|.
name|unwind
operator|=
name|NULL
expr_stmt|;
name|dld_cache
operator|.
name|load_stub
operator|.
name|address
operator|=
literal|0
expr_stmt|;
name|dld_cache
operator|.
name|load_stub
operator|.
name|unwind
operator|=
name|NULL
expr_stmt|;
name|dld_cache
operator|.
name|unload
operator|.
name|address
operator|=
literal|0
expr_stmt|;
name|dld_cache
operator|.
name|unload
operator|.
name|unwind
operator|=
name|NULL
expr_stmt|;
name|dld_cache
operator|.
name|unload2
operator|.
name|address
operator|=
literal|0
expr_stmt|;
name|dld_cache
operator|.
name|unload2
operator|.
name|unwind
operator|=
name|NULL
expr_stmt|;
name|dld_cache
operator|.
name|unload_stub
operator|.
name|address
operator|=
literal|0
expr_stmt|;
name|dld_cache
operator|.
name|unload_stub
operator|.
name|unwind
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_initialize_som_solib
parameter_list|()
block|{
name|add_com
argument_list|(
literal|"sharedlibrary"
argument_list|,
name|class_files
argument_list|,
name|som_solib_sharedlibrary_command
argument_list|,
literal|"Load shared object library symbols for files matching REGEXP."
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"sharedlibrary"
argument_list|,
name|som_sharedlibrary_info_command
argument_list|,
literal|"Status of loaded shared object libraries."
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"auto-solib-add"
argument_list|,
name|class_support
argument_list|,
name|var_zinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|auto_solib_add
argument_list|,
literal|"Set autoloading size threshold (in megabytes) of shared library symbols.\n\ If nonzero, symbols from all shared object libraries will be loaded\n\ automatically when the inferior begins execution or when the dynamic linker\n\ informs gdb that a new library has been loaded, until the symbol table\n\ of the program and libraries exceeds this threshold.\n\ Otherwise, symbols must be loaded manually, using `sharedlibrary'."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
comment|/* ??rehrauer: On HP-UX, the kernel parameter MAXDSIZ limits how much      data space a process can use.  We ought to be reading MAXDSIZ and      setting auto_solib_add to some large fraction of that value.  If      not that, we maybe ought to be setting it smaller than the default      for MAXDSIZ (that being 64Mb, I believe).  However, [1] this threshold      is only crudely approximated rather than actually measured, and [2]      50 Mbytes is too small for debugging gdb itself.  Thus, the arbitrary      100 figure.      */
name|auto_solib_add
operator|=
literal|100
expr_stmt|;
comment|/* Megabytes */
name|som_solib_restart
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get some HPUX-specific data from a shared lib.  */
end_comment

begin_function
name|CORE_ADDR
name|so_lib_thread_start_addr
parameter_list|(
name|so
parameter_list|)
name|struct
name|so_list
modifier|*
name|so
decl_stmt|;
block|{
return|return
name|so
operator|->
name|som_solib
operator|.
name|tsd_start_addr
return|;
block|}
end_function

end_unit

