begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Handle HP SOM shared libraries for GDB, the GNU Debugger.    Copyright 1993, 1996 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  Written by the Center for Software Science at the Univerity of Utah and by Cygnus Support.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"som.h"
end_include

begin_include
include|#
directive|include
file|"libhppa.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"breakpoint.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"gdb-stabs.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_comment
comment|/* TODO:     * Most of this code should work for hp300 shared libraries.  Does    anyone care enough to weed out any SOM-isms.     * Support for hpux8 dynamic linker.  */
end_comment

begin_comment
comment|/* The basic structure which describes a dynamically loaded object.  This    data structure is private to the dynamic linker and isn't found in    any HPUX include file.  */
end_comment

begin_struct
struct|struct
name|som_solib_mapped_entry
block|{
comment|/* The name of the library.  */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Version of this structure (it is expected to change again in hpux10).  */
name|unsigned
name|char
name|struct_version
decl_stmt|;
comment|/* Binding mode for this library.  */
name|unsigned
name|char
name|bind_mode
decl_stmt|;
comment|/* Version of this library.  */
name|short
name|library_version
decl_stmt|;
comment|/* Start of text address, link-time text location, end of text address.  */
name|CORE_ADDR
name|text_addr
decl_stmt|;
name|CORE_ADDR
name|text_link_addr
decl_stmt|;
name|CORE_ADDR
name|text_end
decl_stmt|;
comment|/* Start of data, start of bss and end of data.  */
name|CORE_ADDR
name|data_start
decl_stmt|;
name|CORE_ADDR
name|bss_start
decl_stmt|;
name|CORE_ADDR
name|data_end
decl_stmt|;
comment|/* Value of linkage pointer (%r19).  */
name|CORE_ADDR
name|got_value
decl_stmt|;
comment|/* Next entry.  */
name|struct
name|som_solib_mapped_entry
modifier|*
name|next
decl_stmt|;
comment|/* There are other fields, but I don't have information as to what is      contained in them.  */
block|}
struct|;
end_struct

begin_comment
comment|/* A structure to keep track of all the known shared objects.  */
end_comment

begin_struct
struct|struct
name|so_list
block|{
name|struct
name|som_solib_mapped_entry
name|som_solib
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|section_table
modifier|*
name|sections
decl_stmt|;
name|struct
name|section_table
modifier|*
name|sections_end
decl_stmt|;
name|struct
name|so_list
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|so_list
modifier|*
name|so_list_head
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|som_sharedlibrary_info_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Add symbols from shared libraries into the symtab list.  */
end_comment

begin_function
name|void
name|som_solib_add
parameter_list|(
name|arg_string
parameter_list|,
name|from_tty
parameter_list|,
name|target
parameter_list|)
name|char
modifier|*
name|arg_string
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
name|struct
name|target_ops
modifier|*
name|target
decl_stmt|;
block|{
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
name|struct
name|so_list
modifier|*
name|so_list_tail
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|asection
modifier|*
name|shlib_info
decl_stmt|;
name|int
name|status
decl_stmt|;
name|unsigned
name|int
name|dld_flags
decl_stmt|;
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|,
modifier|*
name|re_err
decl_stmt|;
comment|/* First validate our arguments.  */
if|if
condition|(
operator|(
name|re_err
operator|=
name|re_comp
argument_list|(
name|arg_string
condition|?
name|arg_string
else|:
literal|"."
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"Invalid regexp: %s"
argument_list|,
name|re_err
argument_list|)
expr_stmt|;
block|}
comment|/* If we're debugging a core file, or have attached to a running      process, then som_solib_create_inferior_hook will not have been      called.       We need to first determine if we're dealing with a dynamically      linked executable.  If not, then return without an error or warning.       We also need to examine __dld_flags to determine if the shared library      list is valid and to determine if the libraries have been privately      mapped.  */
if|if
condition|(
name|symfile_objfile
operator|==
name|NULL
condition|)
return|return;
comment|/* First see if the objfile was dynamically linked.  */
name|shlib_info
operator|=
name|bfd_get_section_by_name
argument_list|(
name|symfile_objfile
operator|->
name|obfd
argument_list|,
literal|"$SHLIB_INFO$"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|shlib_info
condition|)
return|return;
comment|/* It's got a $SHLIB_INFO$ section, make sure it's not empty.  */
if|if
condition|(
name|bfd_section_size
argument_list|(
name|symfile_objfile
operator|->
name|obfd
argument_list|,
name|shlib_info
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|msymbol
operator|=
name|lookup_minimal_symbol
argument_list|(
literal|"__dld_flags"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|msymbol
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"Unable to find __dld_flags symbol in object file.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|addr
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
expr_stmt|;
comment|/* Read the current contents.  */
name|status
operator|=
name|target_read_memory
argument_list|(
name|addr
argument_list|,
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Unable to read __dld_flags\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|dld_flags
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* __dld_list may not be valid.  If it's not valid tell the user.  */
if|if
condition|(
operator|(
name|dld_flags
operator|&
literal|4
operator|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"__dld_list is not valid according to __dld_flags.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If the libraries were not mapped private, warn the user.  */
if|if
condition|(
operator|(
name|dld_flags
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
name|warning
argument_list|(
literal|"The shared libraries were not privately mapped; setting a\nbreakpoint in a shared library will not work until you rerun the program.\n"
argument_list|)
expr_stmt|;
name|msymbol
operator|=
name|lookup_minimal_symbol
argument_list|(
literal|"__dld_list"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|msymbol
condition|)
block|{
comment|/* Older crt0.o files (hpux8) don't have __dld_list as a symbol, 	 but the data is still available if you know where to look.  */
name|msymbol
operator|=
name|lookup_minimal_symbol
argument_list|(
literal|"__dld_flags"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|msymbol
condition|)
block|{
name|error
argument_list|(
literal|"Unable to find dynamic library list.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|addr
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
operator|-
literal|8
expr_stmt|;
block|}
else|else
name|addr
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
expr_stmt|;
name|status
operator|=
name|target_read_memory
argument_list|(
name|addr
argument_list|,
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Unable to find dynamic library list.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|addr
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* If addr is zero, then we're using an old dynamic loader which      doesn't maintain __dld_list.  We'll have to use a completely      different approach to get shared library information.  */
if|if
condition|(
name|addr
operator|==
literal|0
condition|)
goto|goto
name|old_dld
goto|;
comment|/* Using the information in __dld_list is the preferred method      to get at shared library information.  It doesn't depend on      any functions in /usr/lib/end.o and has a chance of working      with hpux10 when it is released.  */
name|status
operator|=
name|target_read_memory
argument_list|(
name|addr
argument_list|,
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Unable to find dynamic library list.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* addr now holds the address of the first entry in the dynamic      library list.  */
name|addr
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Now that we have a pointer to the dynamic library list, walk      through it and add the symbols for each library.  */
name|so_list_tail
operator|=
name|so_list_head
expr_stmt|;
comment|/* Find the end of the list of shared objects.  */
while|while
condition|(
name|so_list_tail
operator|&&
name|so_list_tail
operator|->
name|next
condition|)
name|so_list_tail
operator|=
name|so_list_tail
operator|->
name|next
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|CORE_ADDR
name|name_addr
decl_stmt|,
name|text_addr
decl_stmt|;
name|unsigned
name|int
name|name_len
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|so_list
modifier|*
name|new_so
decl_stmt|;
name|struct
name|so_list
modifier|*
name|so_list
init|=
name|so_list_head
decl_stmt|;
name|struct
name|section_table
modifier|*
name|p
decl_stmt|;
name|struct
name|stat
name|statbuf
decl_stmt|;
if|if
condition|(
name|addr
operator|==
literal|0
condition|)
break|break;
comment|/* Get a pointer to the name of this library.  */
name|status
operator|=
name|target_read_memory
argument_list|(
name|addr
argument_list|,
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
goto|goto
name|err
goto|;
name|name_addr
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|name_len
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|target_read_memory
argument_list|(
name|name_addr
operator|+
name|name_len
argument_list|,
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
goto|goto
name|err
goto|;
name|name_len
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|buf
operator|==
literal|'\0'
condition|)
break|break;
block|}
name|name
operator|=
name|alloca
argument_list|(
name|name_len
argument_list|)
expr_stmt|;
name|status
operator|=
name|target_read_memory
argument_list|(
name|name_addr
argument_list|,
name|name
argument_list|,
name|name_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
goto|goto
name|err
goto|;
comment|/* See if we've already loaded something with this name.  */
while|while
condition|(
name|so_list
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|so_list
operator|->
name|som_solib
operator|.
name|name
argument_list|,
name|name
argument_list|)
condition|)
break|break;
name|so_list
operator|=
name|so_list
operator|->
name|next
expr_stmt|;
block|}
comment|/* See if the file exists.  If not, give a warning, but don't 	 die.  */
name|status
operator|=
name|stat
argument_list|(
name|name
argument_list|,
operator|&
name|statbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
operator|-
literal|1
condition|)
block|{
name|warning
argument_list|(
literal|"Can't find file %s referenced in dld_list."
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|status
operator|=
name|target_read_memory
argument_list|(
name|addr
operator|+
literal|36
argument_list|,
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
goto|goto
name|err
goto|;
name|addr
operator|=
operator|(
name|CORE_ADDR
operator|)
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* If we've already loaded this one or it's the main program, skip it.  */
if|if
condition|(
name|so_list
operator|||
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|symfile_objfile
operator|->
name|name
argument_list|)
condition|)
block|{
name|status
operator|=
name|target_read_memory
argument_list|(
name|addr
operator|+
literal|36
argument_list|,
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
goto|goto
name|err
goto|;
name|addr
operator|=
operator|(
name|CORE_ADDR
operator|)
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|name
operator|=
name|obsavestring
argument_list|(
name|name
argument_list|,
name|name_len
operator|-
literal|1
argument_list|,
operator|&
name|symfile_objfile
operator|->
name|symbol_obstack
argument_list|)
expr_stmt|;
name|status
operator|=
name|target_read_memory
argument_list|(
name|addr
operator|+
literal|8
argument_list|,
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
goto|goto
name|err
goto|;
name|text_addr
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|new_so
operator|=
operator|(
expr|struct
name|so_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|so_list
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|new_so
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|so_list
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|so_list_head
operator|==
name|NULL
condition|)
block|{
name|so_list_head
operator|=
name|new_so
expr_stmt|;
name|so_list_tail
operator|=
name|new_so
expr_stmt|;
block|}
else|else
block|{
name|so_list_tail
operator|->
name|next
operator|=
name|new_so
expr_stmt|;
name|so_list_tail
operator|=
name|new_so
expr_stmt|;
block|}
comment|/* Fill in all the entries in GDB's shared library list.  */
name|new_so
operator|->
name|som_solib
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|status
operator|=
name|target_read_memory
argument_list|(
name|addr
operator|+
literal|4
argument_list|,
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
goto|goto
name|err
goto|;
name|new_so
operator|->
name|som_solib
operator|.
name|struct_version
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
operator|+
literal|3
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|new_so
operator|->
name|som_solib
operator|.
name|bind_mode
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
operator|+
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|new_so
operator|->
name|som_solib
operator|.
name|library_version
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|new_so
operator|->
name|som_solib
operator|.
name|text_addr
operator|=
name|text_addr
expr_stmt|;
name|status
operator|=
name|target_read_memory
argument_list|(
name|addr
operator|+
literal|12
argument_list|,
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
goto|goto
name|err
goto|;
name|new_so
operator|->
name|som_solib
operator|.
name|text_link_addr
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|status
operator|=
name|target_read_memory
argument_list|(
name|addr
operator|+
literal|16
argument_list|,
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
goto|goto
name|err
goto|;
name|new_so
operator|->
name|som_solib
operator|.
name|text_end
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|status
operator|=
name|target_read_memory
argument_list|(
name|addr
operator|+
literal|20
argument_list|,
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
goto|goto
name|err
goto|;
name|new_so
operator|->
name|som_solib
operator|.
name|data_start
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|status
operator|=
name|target_read_memory
argument_list|(
name|addr
operator|+
literal|24
argument_list|,
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
goto|goto
name|err
goto|;
name|new_so
operator|->
name|som_solib
operator|.
name|bss_start
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|status
operator|=
name|target_read_memory
argument_list|(
name|addr
operator|+
literal|28
argument_list|,
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
goto|goto
name|err
goto|;
name|new_so
operator|->
name|som_solib
operator|.
name|data_end
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|status
operator|=
name|target_read_memory
argument_list|(
name|addr
operator|+
literal|32
argument_list|,
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
goto|goto
name|err
goto|;
name|new_so
operator|->
name|som_solib
operator|.
name|got_value
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|status
operator|=
name|target_read_memory
argument_list|(
name|addr
operator|+
literal|36
argument_list|,
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
goto|goto
name|err
goto|;
name|new_so
operator|->
name|som_solib
operator|.
name|next
operator|=
operator|(
name|void
operator|*
operator|)
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|addr
operator|=
operator|(
name|CORE_ADDR
operator|)
name|new_so
operator|->
name|som_solib
operator|.
name|next
expr_stmt|;
name|new_so
operator|->
name|objfile
operator|=
name|symbol_file_add
argument_list|(
name|name
argument_list|,
name|from_tty
argument_list|,
name|text_addr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|new_so
operator|->
name|abfd
operator|=
name|new_so
operator|->
name|objfile
operator|->
name|obfd
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_check_format
argument_list|(
name|new_so
operator|->
name|abfd
argument_list|,
name|bfd_object
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"\"%s\": not in executable format: %s."
argument_list|,
name|name
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Now we need to build a section table for this library since 	 we might be debugging a core file from a dynamically linked 	 executable in which the libraries were not privately mapped.  */
if|if
condition|(
name|build_section_table
argument_list|(
name|new_so
operator|->
name|abfd
argument_list|,
operator|&
name|new_so
operator|->
name|sections
argument_list|,
operator|&
name|new_so
operator|->
name|sections_end
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"Unable to build section table for shared library\n."
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Relocate all the sections based on where they got loaded.  */
for|for
control|(
name|p
operator|=
name|new_so
operator|->
name|sections
init|;
name|p
operator|<
name|new_so
operator|->
name|sections_end
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|p
operator|->
name|the_bfd_section
operator|->
name|flags
operator|&
name|SEC_CODE
condition|)
block|{
name|p
operator|->
name|addr
operator|+=
name|text_addr
operator|-
name|new_so
operator|->
name|som_solib
operator|.
name|text_link_addr
expr_stmt|;
name|p
operator|->
name|endaddr
operator|+=
name|text_addr
operator|-
name|new_so
operator|->
name|som_solib
operator|.
name|text_link_addr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|the_bfd_section
operator|->
name|flags
operator|&
name|SEC_DATA
condition|)
block|{
name|p
operator|->
name|addr
operator|+=
name|new_so
operator|->
name|som_solib
operator|.
name|data_start
expr_stmt|;
name|p
operator|->
name|endaddr
operator|+=
name|new_so
operator|->
name|som_solib
operator|.
name|data_start
expr_stmt|;
block|}
block|}
comment|/* Now see if we need to map in the text and data for this shared 	 library (for example debugging a core file which does not use 	 private shared libraries.).   	 Carefully peek at the first text address in the library.  If the 	 read succeeds, then the libraries were privately mapped and were 	 included in the core dump file.  	 If the peek failed, then the libraries were not privately mapped 	 and are not in the core file, we'll have to read them in ourselves.  */
name|status
operator|=
name|target_read_memory
argument_list|(
name|text_addr
argument_list|,
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
name|int
name|old
decl_stmt|,
name|new
decl_stmt|;
name|int
name|update_coreops
decl_stmt|;
comment|/* We must update the to_sections field in the core_ops structure 	     here, otherwise we dereference a potential dangling pointer 	     for each call to target_read/write_memory within this routine.  */
name|update_coreops
operator|=
name|core_ops
operator|.
name|to_sections
operator|==
name|target
operator|->
name|to_sections
expr_stmt|;
name|new
operator|=
name|new_so
operator|->
name|sections_end
operator|-
name|new_so
operator|->
name|sections
expr_stmt|;
comment|/* Add sections from the shared library to the core target.  */
if|if
condition|(
name|target
operator|->
name|to_sections
condition|)
block|{
name|old
operator|=
name|target
operator|->
name|to_sections_end
operator|-
name|target
operator|->
name|to_sections
expr_stmt|;
name|target
operator|->
name|to_sections
operator|=
operator|(
expr|struct
name|section_table
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|target
operator|->
name|to_sections
argument_list|,
operator|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|section_table
argument_list|)
operator|)
operator|*
operator|(
name|old
operator|+
name|new
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|old
operator|=
literal|0
expr_stmt|;
name|target
operator|->
name|to_sections
operator|=
operator|(
expr|struct
name|section_table
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|section_table
argument_list|)
operator|)
operator|*
name|new
argument_list|)
expr_stmt|;
block|}
name|target
operator|->
name|to_sections_end
operator|=
operator|(
name|target
operator|->
name|to_sections
operator|+
name|old
operator|+
name|new
operator|)
expr_stmt|;
comment|/* Update the to_sections field in the core_ops structure 	     if needed.  */
if|if
condition|(
name|update_coreops
condition|)
block|{
name|core_ops
operator|.
name|to_sections
operator|=
name|target
operator|->
name|to_sections
expr_stmt|;
name|core_ops
operator|.
name|to_sections_end
operator|=
name|target
operator|->
name|to_sections_end
expr_stmt|;
block|}
comment|/* Copy over the old data before it gets clobbered.  */
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|target
operator|->
name|to_sections
operator|+
name|old
operator|)
argument_list|,
name|new_so
operator|->
name|sections
argument_list|,
operator|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|section_table
argument_list|)
operator|)
operator|*
name|new
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Getting new symbols may change our opinion about what is      frameless.  */
name|reinit_frame_cache
argument_list|()
expr_stmt|;
return|return;
name|old_dld
label|:
name|error
argument_list|(
literal|"Debugging dynamic executables loaded via the hpux8 dld.sl is not supported.\n"
argument_list|)
expr_stmt|;
return|return;
name|err
label|:
name|error
argument_list|(
literal|"Error while reading dynamic library list.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* This hook gets called just before the first instruction in the    inferior process is executed.     This is our opportunity to set magic flags in the inferior so    that GDB can be notified when a shared library is mapped in and    to tell the dynamic linker that a private copy of the library is    needed (so GDB can set breakpoints in the library).     __dld_flags is the location of the magic flags; as of this implementation    there are 3 flags of interest:     bit 0 when set indicates that private copies of the libraries are needed    bit 1 when set indicates that the callback hook routine is valid    bit 2 when set indicates that the dynamic linker should maintain the          __dld_list structure when loading/unloading libraries.     Note that shared libraries are not mapped in at this time, so we have    run the inferior until the libraries are mapped in.  Typically this    means running until the "_start" is called.  */
end_comment

begin_function
name|void
name|som_solib_create_inferior_hook
parameter_list|()
block|{
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
name|unsigned
name|int
name|dld_flags
decl_stmt|,
name|status
decl_stmt|,
name|have_endo
decl_stmt|;
name|asection
modifier|*
name|shlib_info
decl_stmt|;
name|char
name|shadow_contents
index|[
name|BREAKPOINT_MAX
index|]
decl_stmt|,
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|CORE_ADDR
name|anaddr
decl_stmt|;
comment|/* First, remove all the solib event breakpoints.  Their addresses      may have changed since the last time we ran the program.  */
name|remove_solib_event_breakpoints
argument_list|()
expr_stmt|;
if|if
condition|(
name|symfile_objfile
operator|==
name|NULL
condition|)
return|return;
comment|/* First see if the objfile was dynamically linked.  */
name|shlib_info
operator|=
name|bfd_get_section_by_name
argument_list|(
name|symfile_objfile
operator|->
name|obfd
argument_list|,
literal|"$SHLIB_INFO$"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|shlib_info
condition|)
return|return;
comment|/* It's got a $SHLIB_INFO$ section, make sure it's not empty.  */
if|if
condition|(
name|bfd_section_size
argument_list|(
name|symfile_objfile
operator|->
name|obfd
argument_list|,
name|shlib_info
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|have_endo
operator|=
literal|0
expr_stmt|;
comment|/* Slam the pid of the process into __d_pid; failing is only a warning!  */
name|msymbol
operator|=
name|lookup_minimal_symbol
argument_list|(
literal|"__d_pid"
argument_list|,
name|NULL
argument_list|,
name|symfile_objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|msymbol
operator|==
name|NULL
condition|)
block|{
name|warning
argument_list|(
literal|"Unable to find __d_pid symbol in object file."
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"Suggest linking with /usr/lib/end.o."
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"GDB will be unable to track shl_load/shl_unload calls"
argument_list|)
expr_stmt|;
goto|goto
name|keep_going
goto|;
block|}
name|anaddr
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
expr_stmt|;
name|store_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|,
name|inferior_pid
argument_list|)
expr_stmt|;
name|status
operator|=
name|target_write_memory
argument_list|(
name|anaddr
argument_list|,
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"Unable to write __d_pid"
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"Suggest linking with /usr/lib/end.o."
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"GDB will be unable to track shl_load/shl_unload calls"
argument_list|)
expr_stmt|;
goto|goto
name|keep_going
goto|;
block|}
comment|/* Get the value of _DLD_HOOK (an export stub) and put it in __dld_hook;      This will force the dynamic linker to call __d_trap when significant      events occur.  */
name|msymbol
operator|=
name|lookup_minimal_symbol
argument_list|(
literal|"_DLD_HOOK"
argument_list|,
name|NULL
argument_list|,
name|symfile_objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|msymbol
operator|==
name|NULL
condition|)
block|{
name|warning
argument_list|(
literal|"Unable to find _DLD_HOOK symbol in object file."
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"Suggest linking with /usr/lib/end.o."
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"GDB will be unable to track shl_load/shl_unload calls"
argument_list|)
expr_stmt|;
goto|goto
name|keep_going
goto|;
block|}
name|anaddr
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
expr_stmt|;
comment|/* Grrr, this might not be an export symbol!  We have to find the      export stub.  */
name|ALL_OBJFILES
argument_list|(
argument|objfile
argument_list|)
block|{
name|struct
name|unwind_table_entry
modifier|*
name|u
decl_stmt|;
specifier|extern
name|struct
name|unwind_table_entry
modifier|*
name|find_unwind_entry
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
name|pc
operator|)
argument_list|)
decl_stmt|;
comment|/* What a crock.  */
name|msymbol
operator|=
name|lookup_minimal_symbol_solib_trampoline
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|msymbol
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* Found a symbol with the right name.  */
if|if
condition|(
name|msymbol
condition|)
block|{
name|struct
name|unwind_table_entry
modifier|*
name|u
decl_stmt|;
comment|/* It must be a shared library trampoline.  */
if|if
condition|(
name|SYMBOL_TYPE
argument_list|(
name|msymbol
argument_list|)
operator|!=
name|mst_solib_trampoline
condition|)
continue|continue;
comment|/* It must also be an export stub.  */
name|u
operator|=
name|find_unwind_entry
argument_list|(
name|SYMBOL_VALUE
argument_list|(
name|msymbol
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|u
operator|||
name|u
operator|->
name|stub_type
operator|!=
name|EXPORT
condition|)
continue|continue;
comment|/* OK.  Looks like the correct import stub.  */
name|anaddr
operator|=
name|SYMBOL_VALUE
argument_list|(
name|msymbol
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|store_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|,
name|anaddr
argument_list|)
expr_stmt|;
name|msymbol
operator|=
name|lookup_minimal_symbol
argument_list|(
literal|"__dld_hook"
argument_list|,
name|NULL
argument_list|,
name|symfile_objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|msymbol
operator|==
name|NULL
condition|)
block|{
name|warning
argument_list|(
literal|"Unable to find __dld_hook symbol in object file."
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"Suggest linking with /usr/lib/end.o."
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"GDB will be unable to track shl_load/shl_unload calls"
argument_list|)
expr_stmt|;
goto|goto
name|keep_going
goto|;
block|}
name|anaddr
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
expr_stmt|;
name|status
operator|=
name|target_write_memory
argument_list|(
name|anaddr
argument_list|,
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Now set a shlib_event breakpoint at __d_trap so we can track      significant shared library events.  */
name|msymbol
operator|=
name|lookup_minimal_symbol
argument_list|(
literal|"__d_trap"
argument_list|,
name|NULL
argument_list|,
name|symfile_objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|msymbol
operator|==
name|NULL
condition|)
block|{
name|warning
argument_list|(
literal|"Unable to find __dld_d_trap symbol in object file."
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"Suggest linking with /usr/lib/end.o."
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"GDB will be unable to track shl_load/shl_unload calls"
argument_list|)
expr_stmt|;
goto|goto
name|keep_going
goto|;
block|}
name|create_solib_event_breakpoint
argument_list|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We have all the support usually found in end.o, so we can track      shl_load and shl_unload calls.  */
name|have_endo
operator|=
literal|1
expr_stmt|;
name|keep_going
label|:
comment|/* Get the address of __dld_flags, if no such symbol exists, then we can      not debug the shared code.  */
name|msymbol
operator|=
name|lookup_minimal_symbol
argument_list|(
literal|"__dld_flags"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|msymbol
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"Unable to find __dld_flags symbol in object file.\n"
argument_list|)
expr_stmt|;
goto|goto
name|keep_going
goto|;
return|return;
block|}
name|anaddr
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
expr_stmt|;
comment|/* Read the current contents.  */
name|status
operator|=
name|target_read_memory
argument_list|(
name|anaddr
argument_list|,
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Unable to read __dld_flags\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|dld_flags
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Turn on the flags we care about.  */
name|dld_flags
operator||=
operator|(
literal|0x5
operator||
operator|(
name|have_endo
operator|<<
literal|1
operator|)
operator|)
expr_stmt|;
name|store_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|,
name|dld_flags
argument_list|)
expr_stmt|;
name|status
operator|=
name|target_write_memory
argument_list|(
name|anaddr
argument_list|,
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Unable to write __dld_flags\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Now find the address of _start and set a breakpoint there.       We still need this code for two reasons:  	* Not all sites have /usr/lib/end.o, so it's not always 	possible to track the dynamic linker's events.  	* At this time no events are triggered for shared libraries 	loaded at startup time (what a crock).  */
name|msymbol
operator|=
name|lookup_minimal_symbol
argument_list|(
literal|"_start"
argument_list|,
name|NULL
argument_list|,
name|symfile_objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|msymbol
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"Unable to find _start symbol in object file.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|anaddr
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
expr_stmt|;
comment|/* Make the breakpoint at "_start" a shared library event breakpoint.  */
name|create_solib_event_breakpoint
argument_list|(
name|anaddr
argument_list|)
expr_stmt|;
comment|/* Wipe out all knowledge of old shared libraries since their      mapping can change from one exec to another!  */
while|while
condition|(
name|so_list_head
condition|)
block|{
name|struct
name|so_list
modifier|*
name|temp
decl_stmt|;
name|free_objfile
argument_list|(
name|so_list_head
operator|->
name|objfile
argument_list|)
expr_stmt|;
name|temp
operator|=
name|so_list_head
expr_stmt|;
name|free
argument_list|(
name|so_list_head
argument_list|)
expr_stmt|;
name|so_list_head
operator|=
name|temp
operator|->
name|next
expr_stmt|;
block|}
name|clear_symtab_users
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the GOT value for the shared library in which ADDR belongs.  If    ADDR isn't in any known shared library, return zero.  */
end_comment

begin_function
name|CORE_ADDR
name|som_solib_get_got_by_pc
parameter_list|(
name|addr
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
block|{
name|struct
name|so_list
modifier|*
name|so_list
init|=
name|so_list_head
decl_stmt|;
name|CORE_ADDR
name|got_value
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|so_list
condition|)
block|{
if|if
condition|(
name|so_list
operator|->
name|som_solib
operator|.
name|text_addr
operator|<=
name|addr
operator|&&
name|so_list
operator|->
name|som_solib
operator|.
name|text_end
operator|>
name|addr
condition|)
block|{
name|got_value
operator|=
name|so_list
operator|->
name|som_solib
operator|.
name|got_value
expr_stmt|;
break|break;
block|}
name|so_list
operator|=
name|so_list
operator|->
name|next
expr_stmt|;
block|}
return|return
name|got_value
return|;
block|}
end_function

begin_function
name|int
name|som_solib_section_offsets
parameter_list|(
name|objfile
parameter_list|,
name|offsets
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|section_offsets
modifier|*
name|offsets
decl_stmt|;
block|{
name|struct
name|so_list
modifier|*
name|so_list
init|=
name|so_list_head
decl_stmt|;
while|while
condition|(
name|so_list
condition|)
block|{
comment|/* Oh what a pain!  We need the offsets before so_list->objfile 	 is valid.  The BFDs will never match.  Make a best guess.  */
if|if
condition|(
name|strstr
argument_list|(
name|objfile
operator|->
name|name
argument_list|,
name|so_list
operator|->
name|som_solib
operator|.
name|name
argument_list|)
condition|)
block|{
name|asection
modifier|*
name|private_section
decl_stmt|;
comment|/* The text offset is easy.  */
name|ANOFFSET
argument_list|(
name|offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
operator|=
operator|(
name|so_list
operator|->
name|som_solib
operator|.
name|text_addr
operator|-
name|so_list
operator|->
name|som_solib
operator|.
name|text_link_addr
operator|)
expr_stmt|;
name|ANOFFSET
argument_list|(
name|offsets
argument_list|,
name|SECT_OFF_RODATA
argument_list|)
operator|=
name|ANOFFSET
argument_list|(
name|offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
expr_stmt|;
comment|/* We should look at presumed_dp in the SOM header, but 	     that's not easily available.  This should be OK though.  */
name|private_section
operator|=
name|bfd_get_section_by_name
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
literal|"$PRIVATE$"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|private_section
condition|)
block|{
name|warning
argument_list|(
literal|"Unable to find $PRIVATE$ in shared library!"
argument_list|)
expr_stmt|;
name|ANOFFSET
argument_list|(
name|offsets
argument_list|,
name|SECT_OFF_DATA
argument_list|)
operator|=
literal|0
expr_stmt|;
name|ANOFFSET
argument_list|(
name|offsets
argument_list|,
name|SECT_OFF_BSS
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
name|ANOFFSET
argument_list|(
name|offsets
argument_list|,
name|SECT_OFF_DATA
argument_list|)
operator|=
operator|(
name|so_list
operator|->
name|som_solib
operator|.
name|data_start
operator|-
name|private_section
operator|->
name|vma
operator|)
expr_stmt|;
name|ANOFFSET
argument_list|(
name|offsets
argument_list|,
name|SECT_OFF_BSS
argument_list|)
operator|=
name|ANOFFSET
argument_list|(
name|offsets
argument_list|,
name|SECT_OFF_DATA
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|so_list
operator|=
name|so_list
operator|->
name|next
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Dump information about all the currently loaded shared libraries.  */
end_comment

begin_function
specifier|static
name|void
name|som_sharedlibrary_info_command
parameter_list|(
name|ignore
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|ignore
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|struct
name|so_list
modifier|*
name|so_list
init|=
name|so_list_head
decl_stmt|;
if|if
condition|(
name|exec_bfd
operator|==
name|NULL
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"no exec file.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|so_list
operator|==
name|NULL
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"No shared libraries loaded at this time.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf_unfiltered
argument_list|(
literal|"Shared Object Libraries\n"
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"    %-12s%-12s%-12s%-12s%-12s%-12s\n"
argument_list|,
literal|"  flags"
argument_list|,
literal|"  tstart"
argument_list|,
literal|"   tend"
argument_list|,
literal|"  dstart"
argument_list|,
literal|"   dend"
argument_list|,
literal|"   dlt"
argument_list|)
expr_stmt|;
while|while
condition|(
name|so_list
condition|)
block|{
name|unsigned
name|int
name|flags
decl_stmt|;
name|flags
operator|=
name|so_list
operator|->
name|som_solib
operator|.
name|struct_version
operator|<<
literal|24
expr_stmt|;
name|flags
operator||=
name|so_list
operator|->
name|som_solib
operator|.
name|bind_mode
operator|<<
literal|16
expr_stmt|;
name|flags
operator||=
name|so_list
operator|->
name|som_solib
operator|.
name|library_version
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"%s\n"
argument_list|,
name|so_list
operator|->
name|som_solib
operator|.
name|name
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"    %-12s"
argument_list|,
name|local_hex_string_custom
argument_list|(
name|flags
argument_list|,
literal|"08l"
argument_list|)
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"%-12s"
argument_list|,
name|local_hex_string_custom
argument_list|(
name|so_list
operator|->
name|som_solib
operator|.
name|text_addr
argument_list|,
literal|"08l"
argument_list|)
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"%-12s"
argument_list|,
name|local_hex_string_custom
argument_list|(
name|so_list
operator|->
name|som_solib
operator|.
name|text_end
argument_list|,
literal|"08l"
argument_list|)
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"%-12s"
argument_list|,
name|local_hex_string_custom
argument_list|(
name|so_list
operator|->
name|som_solib
operator|.
name|data_start
argument_list|,
literal|"08l"
argument_list|)
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"%-12s"
argument_list|,
name|local_hex_string_custom
argument_list|(
name|so_list
operator|->
name|som_solib
operator|.
name|data_end
argument_list|,
literal|"08l"
argument_list|)
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"%-12s\n"
argument_list|,
name|local_hex_string_custom
argument_list|(
name|so_list
operator|->
name|som_solib
operator|.
name|got_value
argument_list|,
literal|"08l"
argument_list|)
argument_list|)
expr_stmt|;
name|so_list
operator|=
name|so_list
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|som_solib_sharedlibrary_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|dont_repeat
argument_list|()
expr_stmt|;
name|som_solib_add
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|,
operator|(
expr|struct
name|target_ops
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_initialize_som_solib
parameter_list|()
block|{
name|add_com
argument_list|(
literal|"sharedlibrary"
argument_list|,
name|class_files
argument_list|,
name|som_solib_sharedlibrary_command
argument_list|,
literal|"Load shared object library symbols for files matching REGEXP."
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"sharedlibrary"
argument_list|,
name|som_sharedlibrary_info_command
argument_list|,
literal|"Status of loaded shared object libraries."
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"auto-solib-add"
argument_list|,
name|class_support
argument_list|,
name|var_zinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|auto_solib_add
argument_list|,
literal|"Set autoloading of shared library symbols at startup.\n\ If nonzero, symbols from all shared object libraries will be loaded\n\ automatically when the inferior begins execution or when the dynamic linker\n\ informs gdb that a new library has been loaded.  Otherwise, symbols\n\ must be loaded manually, using `sharedlibrary'."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

