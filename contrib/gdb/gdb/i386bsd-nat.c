begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Native-dependent code for modern i386 BSD's.    Copyright 2000, 2001, 2002, 2003 Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_include
include|#
directive|include
file|"gdb_assert.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/ptrace.h>
end_include

begin_include
include|#
directive|include
file|<machine/reg.h>
end_include

begin_include
include|#
directive|include
file|<machine/frame.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_PROCFS_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/procfs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_GREGSET_T
end_ifndef

begin_typedef
typedef|typedef
name|struct
name|reg
name|gregset_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_FPREGSET_T
end_ifndef

begin_typedef
typedef|typedef
name|struct
name|fpreg
name|fpregset_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"gregset.h"
end_include

begin_include
include|#
directive|include
file|"i386-tdep.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* In older BSD versions we cannot get at some of the segment    registers.  FreeBSD for example didn't support the %fs and %gs    registers until the 3.0 release.  We have autoconf checks for their    presence, and deal gracefully with their absence.  */
end_comment

begin_comment
comment|/* Registers we shouldn't try to fetch.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CANNOT_FETCH_REGISTER
argument_list|)
end_if

begin_define
define|#
directive|define
name|CANNOT_FETCH_REGISTER
parameter_list|(
name|regno
parameter_list|)
value|cannot_fetch_register (regno)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Registers we shouldn't try to store.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CANNOT_STORE_REGISTER
argument_list|)
end_if

begin_define
define|#
directive|define
name|CANNOT_STORE_REGISTER
parameter_list|(
name|regno
parameter_list|)
value|cannot_fetch_register (regno)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Offset to the gregset_t location where REG is stored.  */
end_comment

begin_define
define|#
directive|define
name|REG_OFFSET
parameter_list|(
name|reg
parameter_list|)
value|offsetof (gregset_t, reg)
end_define

begin_comment
comment|/* At reg_offset[REGNO] you'll find the offset to the gregset_t    location where the GDB register REGNO is stored.  Unsupported    registers are marked with `-1'.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|reg_offset
index|[]
init|=
block|{
name|REG_OFFSET
argument_list|(
name|r_eax
argument_list|)
block|,
name|REG_OFFSET
argument_list|(
name|r_ecx
argument_list|)
block|,
name|REG_OFFSET
argument_list|(
name|r_edx
argument_list|)
block|,
name|REG_OFFSET
argument_list|(
name|r_ebx
argument_list|)
block|,
name|REG_OFFSET
argument_list|(
name|r_esp
argument_list|)
block|,
name|REG_OFFSET
argument_list|(
name|r_ebp
argument_list|)
block|,
name|REG_OFFSET
argument_list|(
name|r_esi
argument_list|)
block|,
name|REG_OFFSET
argument_list|(
name|r_edi
argument_list|)
block|,
name|REG_OFFSET
argument_list|(
name|r_eip
argument_list|)
block|,
name|REG_OFFSET
argument_list|(
name|r_eflags
argument_list|)
block|,
name|REG_OFFSET
argument_list|(
name|r_cs
argument_list|)
block|,
name|REG_OFFSET
argument_list|(
name|r_ss
argument_list|)
block|,
name|REG_OFFSET
argument_list|(
name|r_ds
argument_list|)
block|,
name|REG_OFFSET
argument_list|(
name|r_es
argument_list|)
block|,
ifdef|#
directive|ifdef
name|HAVE_STRUCT_REG_R_FS
name|REG_OFFSET
argument_list|(
name|r_fs
argument_list|)
block|,
else|#
directive|else
operator|-
literal|1
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_STRUCT_REG_R_GS
name|REG_OFFSET
argument_list|(
name|r_gs
argument_list|)
else|#
directive|else
operator|-
literal|1
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|REG_ADDR
parameter_list|(
name|regset
parameter_list|,
name|regno
parameter_list|)
value|((char *) (regset) + reg_offset[regno])
end_define

begin_comment
comment|/* Macro to determine if a register is fetched with PT_GETREGS.  */
end_comment

begin_define
define|#
directive|define
name|GETREGS_SUPPLIES
parameter_list|(
name|regno
parameter_list|)
define|\
value|((0<= (regno)&& (regno)<= 15))
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PT_GETXMMREGS
end_ifdef

begin_comment
comment|/* Set to 1 if the kernel supports PT_GETXMMREGS.  Initialized to -1    so that we try PT_GETXMMREGS the first time around.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|have_ptrace_xmmregs
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Return nonzero if we shouldn't try to fetch register REGNO.  */
end_comment

begin_function
specifier|static
name|int
name|cannot_fetch_register
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
return|return
operator|(
name|reg_offset
index|[
name|regno
index|]
operator|==
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Transfering the registers between GDB, inferiors and core files.  */
end_comment

begin_comment
comment|/* Fill GDB's register array with the general-purpose register values    in *GREGSETP.  */
end_comment

begin_function
name|void
name|supply_gregset
parameter_list|(
name|gregset_t
modifier|*
name|gregsetp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|I386_NUM_GREGS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|CANNOT_FETCH_REGISTER
argument_list|(
name|i
argument_list|)
condition|)
name|supply_register
argument_list|(
name|i
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|supply_register
argument_list|(
name|i
argument_list|,
name|REG_ADDR
argument_list|(
name|gregsetp
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Fill register REGNO (if it is a general-purpose register) in    *GREGSETPS with the value in GDB's register array.  If REGNO is -1,    do this for all registers.  */
end_comment

begin_function
name|void
name|fill_gregset
parameter_list|(
name|gregset_t
modifier|*
name|gregsetp
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|I386_NUM_GREGS
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|||
name|regno
operator|==
name|i
operator|)
operator|&&
operator|!
name|CANNOT_STORE_REGISTER
argument_list|(
name|i
argument_list|)
condition|)
name|regcache_collect
argument_list|(
name|i
argument_list|,
name|REG_ADDR
argument_list|(
name|gregsetp
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_include
include|#
directive|include
file|"i387-tdep.h"
end_include

begin_comment
comment|/* Fill GDB's register array with the floating-point register values    in *FPREGSETP.  */
end_comment

begin_function
name|void
name|supply_fpregset
parameter_list|(
name|fpregset_t
modifier|*
name|fpregsetp
parameter_list|)
block|{
name|i387_supply_fsave
argument_list|(
name|current_regcache
argument_list|,
operator|-
literal|1
argument_list|,
name|fpregsetp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fill register REGNO (if it is a floating-point register) in    *FPREGSETP with the value in GDB's register array.  If REGNO is -1,    do this for all registers.  */
end_comment

begin_function
name|void
name|fill_fpregset
parameter_list|(
name|fpregset_t
modifier|*
name|fpregsetp
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
name|i387_fill_fsave
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fpregsetp
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fetch register REGNO from the inferior.  If REGNO is -1, do this    for all registers (including the floating point registers).  */
end_comment

begin_function
name|void
name|fetch_inferior_registers
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
if|if
condition|(
name|regno
operator|==
operator|-
literal|1
operator|||
name|GETREGS_SUPPLIES
argument_list|(
name|regno
argument_list|)
condition|)
block|{
name|gregset_t
name|gregs
decl_stmt|;
if|if
condition|(
name|ptrace
argument_list|(
name|PT_GETREGS
argument_list|,
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
operator|&
name|gregs
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|perror_with_name
argument_list|(
literal|"Couldn't get registers"
argument_list|)
expr_stmt|;
name|supply_gregset
argument_list|(
operator|&
name|gregs
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|!=
operator|-
literal|1
condition|)
return|return;
block|}
if|if
condition|(
name|regno
operator|==
operator|-
literal|1
operator|||
name|regno
operator|>=
name|FP0_REGNUM
condition|)
block|{
name|fpregset_t
name|fpregs
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_PT_GETXMMREGS
name|char
name|xmmregs
index|[
literal|512
index|]
decl_stmt|;
if|if
condition|(
name|have_ptrace_xmmregs
operator|!=
literal|0
operator|&&
name|ptrace
argument_list|(
name|PT_GETXMMREGS
argument_list|,
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|xmmregs
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
name|have_ptrace_xmmregs
operator|=
literal|1
expr_stmt|;
name|i387_supply_fxsave
argument_list|(
name|current_regcache
argument_list|,
operator|-
literal|1
argument_list|,
name|xmmregs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ptrace
argument_list|(
name|PT_GETFPREGS
argument_list|,
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
operator|&
name|fpregs
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|perror_with_name
argument_list|(
literal|"Couldn't get floating point status"
argument_list|)
expr_stmt|;
name|i387_supply_fsave
argument_list|(
name|current_regcache
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|fpregs
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|ptrace
argument_list|(
name|PT_GETFPREGS
argument_list|,
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
operator|&
name|fpregs
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|perror_with_name
argument_list|(
literal|"Couldn't get floating point status"
argument_list|)
expr_stmt|;
name|i387_supply_fsave
argument_list|(
name|current_regcache
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|fpregs
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/* Store register REGNO back into the inferior.  If REGNO is -1, do    this for all registers (including the floating point registers).  */
end_comment

begin_function
name|void
name|store_inferior_registers
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
if|if
condition|(
name|regno
operator|==
operator|-
literal|1
operator|||
name|GETREGS_SUPPLIES
argument_list|(
name|regno
argument_list|)
condition|)
block|{
name|gregset_t
name|gregs
decl_stmt|;
if|if
condition|(
name|ptrace
argument_list|(
name|PT_GETREGS
argument_list|,
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
operator|&
name|gregs
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|perror_with_name
argument_list|(
literal|"Couldn't get registers"
argument_list|)
expr_stmt|;
name|fill_gregset
argument_list|(
operator|&
name|gregs
argument_list|,
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptrace
argument_list|(
name|PT_SETREGS
argument_list|,
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
operator|&
name|gregs
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|perror_with_name
argument_list|(
literal|"Couldn't write registers"
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|!=
operator|-
literal|1
condition|)
return|return;
block|}
if|if
condition|(
name|regno
operator|==
operator|-
literal|1
operator|||
name|regno
operator|>=
name|FP0_REGNUM
condition|)
block|{
name|fpregset_t
name|fpregs
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_PT_GETXMMREGS
name|char
name|xmmregs
index|[
literal|512
index|]
decl_stmt|;
if|if
condition|(
name|have_ptrace_xmmregs
operator|!=
literal|0
operator|&&
name|ptrace
argument_list|(
name|PT_GETXMMREGS
argument_list|,
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|xmmregs
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
name|have_ptrace_xmmregs
operator|=
literal|1
expr_stmt|;
name|i387_fill_fxsave
argument_list|(
name|xmmregs
argument_list|,
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptrace
argument_list|(
name|PT_SETXMMREGS
argument_list|,
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|xmmregs
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|perror_with_name
argument_list|(
literal|"Couldn't write XMM registers"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|have_ptrace_xmmregs
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ptrace
argument_list|(
name|PT_GETFPREGS
argument_list|,
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
operator|&
name|fpregs
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|perror_with_name
argument_list|(
literal|"Couldn't get floating point status"
argument_list|)
expr_stmt|;
name|i387_fill_fsave
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|fpregs
argument_list|,
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptrace
argument_list|(
name|PT_SETFPREGS
argument_list|,
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
operator|&
name|fpregs
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|perror_with_name
argument_list|(
literal|"Couldn't write floating point status"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_PT_GETXMMREGS
block|}
endif|#
directive|endif
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Support for debug registers.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PT_GETDBREGS
end_ifdef

begin_comment
comment|/* Not all versions of FreeBSD/i386 that support the debug registers    have this macro.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DBREG_DRX
end_ifndef

begin_define
define|#
directive|define
name|DBREG_DRX
parameter_list|(
name|d
parameter_list|,
name|x
parameter_list|)
value|((&d->dr0)[x])
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|i386bsd_dr_set
parameter_list|(
name|int
name|regnum
parameter_list|,
name|unsigned
name|int
name|value
parameter_list|)
block|{
name|struct
name|dbreg
name|dbregs
decl_stmt|;
if|if
condition|(
name|ptrace
argument_list|(
name|PT_GETDBREGS
argument_list|,
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
operator|&
name|dbregs
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|perror_with_name
argument_list|(
literal|"Couldn't get debug registers"
argument_list|)
expr_stmt|;
comment|/* For some mysterious reason, some of the reserved bits in the      debug control register get set.  Mask these off, otherwise the      ptrace call below will fail.  */
name|DBREG_DRX
argument_list|(
operator|(
operator|&
name|dbregs
operator|)
argument_list|,
literal|7
argument_list|)
operator|&=
operator|~
operator|(
literal|0x0000fc00
operator|)
expr_stmt|;
name|DBREG_DRX
argument_list|(
operator|(
operator|&
name|dbregs
operator|)
argument_list|,
name|regnum
argument_list|)
operator|=
name|value
expr_stmt|;
if|if
condition|(
name|ptrace
argument_list|(
name|PT_SETDBREGS
argument_list|,
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
operator|&
name|dbregs
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|perror_with_name
argument_list|(
literal|"Couldn't write debug registers"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|i386bsd_dr_set_control
parameter_list|(
name|unsigned
name|long
name|control
parameter_list|)
block|{
name|i386bsd_dr_set
argument_list|(
literal|7
argument_list|,
name|control
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|i386bsd_dr_set_addr
parameter_list|(
name|int
name|regnum
parameter_list|,
name|CORE_ADDR
name|addr
parameter_list|)
block|{
name|gdb_assert
argument_list|(
name|regnum
operator|>=
literal|0
operator|&&
name|regnum
operator|<=
literal|4
argument_list|)
expr_stmt|;
name|i386bsd_dr_set
argument_list|(
name|regnum
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|i386bsd_dr_reset_addr
parameter_list|(
name|int
name|regnum
parameter_list|)
block|{
name|gdb_assert
argument_list|(
name|regnum
operator|>=
literal|0
operator|&&
name|regnum
operator|<=
literal|4
argument_list|)
expr_stmt|;
name|i386bsd_dr_set
argument_list|(
name|regnum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|unsigned
name|long
name|i386bsd_dr_get_status
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|dbreg
name|dbregs
decl_stmt|;
comment|/* FIXME: kettenis/2001-03-31: Calling perror_with_name if the      ptrace call fails breaks debugging remote targets.  The correct      way to fix this is to add the hardware breakpoint and watchpoint      stuff to the target vector.  For now, just return zero if the      ptrace call fails.  */
if|if
condition|(
name|ptrace
argument_list|(
name|PT_GETDBREGS
argument_list|,
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
operator|&
name|dbregs
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
if|#
directive|if
literal|0
then|perror_with_name ("Couldn't read debug registers");
else|#
directive|else
return|return
literal|0
return|;
endif|#
directive|endif
return|return
name|DBREG_DRX
argument_list|(
operator|(
operator|&
name|dbregs
operator|)
argument_list|,
literal|6
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PT_GETDBREGS */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Support for the user struct.  */
end_comment

begin_comment
comment|/* Return the address register REGNO.  BLOCKEND is the value of    u.u_ar0, which should point to the registers.  */
end_comment

begin_function
name|CORE_ADDR
name|register_u_addr
parameter_list|(
name|CORE_ADDR
name|blockend
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
return|return
operator|(
name|CORE_ADDR
operator|)
name|REG_ADDR
argument_list|(
name|blockend
argument_list|,
name|regno
argument_list|)
return|;
block|}
end_function

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_comment
comment|/* Return the size of the user struct.  */
end_comment

begin_function
name|int
name|kernel_u_size
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|user
argument_list|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|_initialize_i386bsd_nat
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|offset
decl_stmt|;
comment|/* To support the recognition of signal handlers, i386bsd-tdep.c      hardcodes some constants.  Inclusion of this file means that we      are compiling a native debugger, which means that we can use the      system header files and sysctl(3) to get at the relevant      information.  */
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD_version
argument_list|)
operator|&&
name|__FreeBSD_version
operator|>=
literal|400011
define|#
directive|define
name|SC_REG_OFFSET
value|i386fbsd4_sc_reg_offset
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD_version
argument_list|)
operator|&&
name|__FreeBSD_version
operator|>=
literal|300005
define|#
directive|define
name|SC_REG_OFFSET
value|i386fbsd_sc_reg_offset
elif|#
directive|elif
name|defined
argument_list|(
name|NetBSD
argument_list|)
operator|||
name|defined
argument_list|(
name|__NetBSD_Version__
argument_list|)
define|#
directive|define
name|SC_REG_OFFSET
value|i386nbsd_sc_reg_offset
elif|#
directive|elif
name|defined
argument_list|(
name|OpenBSD
argument_list|)
define|#
directive|define
name|SC_REG_OFFSET
value|i386obsd_sc_reg_offset
else|#
directive|else
define|#
directive|define
name|SC_REG_OFFSET
value|i386bsd_sc_reg_offset
endif|#
directive|endif
comment|/* We only check the program counter, stack pointer and frame      pointer since these members of `struct sigcontext' are essential      for providing backtraces.  More checks could be added, but would      involve adding configure checks for the appropriate structure      members, since older BSD's don't provide all of them.  */
define|#
directive|define
name|SC_PC_OFFSET
value|SC_REG_OFFSET[I386_EIP_REGNUM]
define|#
directive|define
name|SC_SP_OFFSET
value|SC_REG_OFFSET[I386_ESP_REGNUM]
define|#
directive|define
name|SC_FP_OFFSET
value|SC_REG_OFFSET[I386_EBP_REGNUM]
comment|/* Override the default value for the offset of the program counter      in the sigcontext structure.  */
name|offset
operator|=
name|offsetof
argument_list|(
expr|struct
name|sigcontext
argument_list|,
name|sc_pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|SC_PC_OFFSET
operator|!=
name|offset
condition|)
block|{
name|warning
argument_list|(
literal|"\ offsetof (struct sigcontext, sc_pc) yields %d instead of %d.\n\ Please report this to<bug-gdb@gnu.org>."
argument_list|,
name|offset
argument_list|,
name|SC_PC_OFFSET
argument_list|)
expr_stmt|;
block|}
name|SC_PC_OFFSET
operator|=
name|offset
expr_stmt|;
comment|/* Likewise for the stack pointer.  */
name|offset
operator|=
name|offsetof
argument_list|(
expr|struct
name|sigcontext
argument_list|,
name|sc_sp
argument_list|)
expr_stmt|;
if|if
condition|(
name|SC_SP_OFFSET
operator|!=
name|offset
condition|)
block|{
name|warning
argument_list|(
literal|"\ offsetof (struct sigcontext, sc_sp) yields %d instead of %d.\n\ Please report this to<bug-gdb@gnu.org>."
argument_list|,
name|offset
argument_list|,
name|SC_SP_OFFSET
argument_list|)
expr_stmt|;
block|}
name|SC_SP_OFFSET
operator|=
name|offset
expr_stmt|;
comment|/* And the frame pointer.  */
name|offset
operator|=
name|offsetof
argument_list|(
expr|struct
name|sigcontext
argument_list|,
name|sc_fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|SC_FP_OFFSET
operator|!=
name|offset
condition|)
block|{
name|warning
argument_list|(
literal|"\ offsetof (struct sigcontext, sc_fp) yields %d instead of %d.\n\ Please report this to<bug-gdb@gnu.org>."
argument_list|,
name|offset
argument_list|,
name|SC_FP_OFFSET
argument_list|)
expr_stmt|;
block|}
name|SC_FP_OFFSET
operator|=
name|offset
expr_stmt|;
block|}
end_function

end_unit

