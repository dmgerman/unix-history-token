begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Chill language support routines for GDB, the GNU debugger.    Copyright 1992, 1995, 1996 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_include
include|#
directive|include
file|"parser-defs.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"ch-lang.h"
end_include

begin_decl_stmt
specifier|static
name|value_ptr
name|evaluate_subexp_chill
name|PARAMS
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|,
expr|struct
name|expression
operator|*
operator|,
name|int
operator|*
operator|,
expr|enum
name|noside
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|value_ptr
name|value_chill_max_min
name|PARAMS
argument_list|(
operator|(
expr|enum
name|exp_opcode
operator|,
name|value_ptr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|value_ptr
name|value_chill_card
name|PARAMS
argument_list|(
operator|(
name|value_ptr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|value_ptr
name|value_chill_length
name|PARAMS
argument_list|(
operator|(
name|value_ptr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|chill_create_fundamental_type
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|chill_printstr
name|PARAMS
argument_list|(
operator|(
name|GDB_FILE
operator|*
name|stream
operator|,
name|char
operator|*
name|string
operator|,
name|unsigned
name|int
name|length
operator|,
name|int
name|width
operator|,
name|int
name|force_ellipses
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|chill_printchar
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|GDB_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For now, Chill uses a simple mangling algorithm whereby you simply    discard everything after the occurance of two successive CPLUS_MARKER    characters to derive the demangled form. */
end_comment

begin_function
name|char
modifier|*
name|chill_demangle
parameter_list|(
name|mangled
parameter_list|)
specifier|const
name|char
modifier|*
name|mangled
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|joiner
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|demangled
decl_stmt|;
specifier|const
name|char
modifier|*
name|cp
init|=
name|mangled
decl_stmt|;
while|while
condition|(
operator|*
name|cp
condition|)
block|{
if|if
condition|(
name|is_cplus_marker
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
block|{
name|joiner
operator|=
name|cp
expr_stmt|;
break|break;
block|}
name|cp
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|joiner
operator|!=
name|NULL
operator|&&
operator|*
operator|(
name|joiner
operator|+
literal|1
operator|)
operator|==
operator|*
name|joiner
condition|)
block|{
name|demangled
operator|=
name|savestring
argument_list|(
name|mangled
argument_list|,
name|joiner
operator|-
name|mangled
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|demangled
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|demangled
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|chill_printchar
parameter_list|(
name|c
parameter_list|,
name|stream
parameter_list|)
specifier|register
name|int
name|c
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|c
operator|&=
literal|0xFF
expr_stmt|;
comment|/* Avoid sign bit follies */
if|if
condition|(
name|PRINT_LITERAL_FORM
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\''
operator|||
name|c
operator|==
literal|'^'
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"'%c%c'"
argument_list|,
name|c
argument_list|,
name|c
argument_list|)
expr_stmt|;
else|else
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"'%c'"
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"'^(%u)'"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|c
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print the character string STRING, printing at most LENGTH characters.    Printing stops early if the number hits print_max; repeat counts    are printed as appropriate.  Print ellipses at the end if we    had to stop before printing LENGTH characters, or if FORCE_ELLIPSES.    Note that gdb maintains the length of strings without counting the    terminating null byte, while chill strings are typically written with    an explicit null byte.  So we always assume an implied null byte    until gdb is able to maintain non-null terminated strings as well    as null terminated strings (FIXME).   */
end_comment

begin_function
specifier|static
name|void
name|chill_printstr
parameter_list|(
name|stream
parameter_list|,
name|string
parameter_list|,
name|length
parameter_list|,
name|width
parameter_list|,
name|force_ellipses
parameter_list|)
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|unsigned
name|int
name|length
decl_stmt|;
name|int
name|width
decl_stmt|;
name|int
name|force_ellipses
decl_stmt|;
block|{
specifier|register
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|things_printed
init|=
literal|0
decl_stmt|;
name|int
name|in_literal_form
init|=
literal|0
decl_stmt|;
name|int
name|in_control_form
init|=
literal|0
decl_stmt|;
name|int
name|need_slashslash
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|c
decl_stmt|;
specifier|extern
name|int
name|repeat_count_threshold
decl_stmt|;
specifier|extern
name|int
name|print_max
decl_stmt|;
if|if
condition|(
name|length
operator|==
literal|0
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|"\"\""
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
operator|&&
name|things_printed
operator|<
name|print_max
condition|;
operator|++
name|i
control|)
block|{
comment|/* Position of the character we are examining 	 to see whether it is repeated.  */
name|unsigned
name|int
name|rep1
decl_stmt|;
comment|/* Number of repetitions we have detected so far.  */
name|unsigned
name|int
name|reps
decl_stmt|;
name|QUIT
expr_stmt|;
if|if
condition|(
name|need_slashslash
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|"//"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|need_slashslash
operator|=
literal|0
expr_stmt|;
block|}
name|rep1
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|reps
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|rep1
operator|<
name|length
operator|&&
name|string
index|[
name|rep1
index|]
operator|==
name|string
index|[
name|i
index|]
condition|)
block|{
operator|++
name|rep1
expr_stmt|;
operator|++
name|reps
expr_stmt|;
block|}
name|c
operator|=
name|string
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|reps
operator|>
name|repeat_count_threshold
condition|)
block|{
if|if
condition|(
name|in_control_form
operator|||
name|in_literal_form
condition|)
block|{
if|if
condition|(
name|in_control_form
condition|)
name|fputs_filtered
argument_list|(
literal|")"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"\"//"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|in_control_form
operator|=
name|in_literal_form
operator|=
literal|0
expr_stmt|;
block|}
name|chill_printchar
argument_list|(
name|c
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<repeats %u times>"
argument_list|,
name|reps
argument_list|)
expr_stmt|;
name|i
operator|=
name|rep1
operator|-
literal|1
expr_stmt|;
name|things_printed
operator|+=
name|repeat_count_threshold
expr_stmt|;
name|need_slashslash
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|in_literal_form
operator|&&
operator|!
name|in_control_form
condition|)
name|fputs_filtered
argument_list|(
literal|"\""
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|PRINT_LITERAL_FORM
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|in_literal_form
condition|)
block|{
if|if
condition|(
name|in_control_form
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|")"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|in_control_form
operator|=
literal|0
expr_stmt|;
block|}
name|in_literal_form
operator|=
literal|1
expr_stmt|;
block|}
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'"'
operator|||
name|c
operator|==
literal|'^'
condition|)
comment|/* duplicate this one as must be done at input */
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|in_control_form
condition|)
block|{
if|if
condition|(
name|in_literal_form
condition|)
block|{
name|in_literal_form
operator|=
literal|0
expr_stmt|;
block|}
name|fputs_filtered
argument_list|(
literal|"^("
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|in_control_form
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|c
operator|=
name|c
operator|&
literal|0xff
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%u"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|c
argument_list|)
expr_stmt|;
block|}
operator|++
name|things_printed
expr_stmt|;
block|}
block|}
comment|/* Terminate the quotes if necessary.  */
if|if
condition|(
name|in_control_form
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|")"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|in_literal_form
operator|||
name|in_control_form
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|"\""
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|force_ellipses
operator|||
operator|(
name|i
operator|<
name|length
operator|)
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|"..."
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|type
modifier|*
name|chill_create_fundamental_type
parameter_list|(
name|objfile
parameter_list|,
name|typeid
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|int
name|typeid
decl_stmt|;
block|{
specifier|register
name|struct
name|type
modifier|*
name|type
init|=
name|NULL
decl_stmt|;
switch|switch
condition|(
name|typeid
condition|)
block|{
default|default:
comment|/* FIXME:  For now, if we are asked to produce a type not in this 	   language, create the equivalent of a C integer type with the 	   name "<?type?>".  When all the dust settles from the type 	   reconstruction work, this should probably become an error. */
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"<?type?>"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"internal error: no chill fundamental type %d"
argument_list|,
name|typeid
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_VOID
case|:
comment|/* FIXME:  Currently the GNU Chill compiler emits some DWARF entries for 	   typedefs, unrelated to anything directly in the code being compiled, 	   that have some FT_VOID types.  Just fake it for now. */
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_VOID
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"<?VOID?>"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_BOOLEAN
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_BOOL
argument_list|,
literal|1
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"BOOL"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_CHAR
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_CHAR
argument_list|,
literal|1
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"CHAR"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_SIGNED_CHAR
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"BYTE"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_UNSIGNED_CHAR
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|1
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"UBYTE"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_SHORT
case|:
comment|/* Chill ints are 2 bytes */
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"INT"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_UNSIGNED_SHORT
case|:
comment|/* Chill ints are 2 bytes */
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|2
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"UINT"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_INTEGER
case|:
comment|/* FIXME? */
case|case
name|FT_SIGNED_INTEGER
case|:
comment|/* FIXME? */
case|case
name|FT_LONG
case|:
comment|/* Chill longs are 4 bytes */
case|case
name|FT_SIGNED_LONG
case|:
comment|/* Chill longs are 4 bytes */
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
literal|"LONG"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_UNSIGNED_INTEGER
case|:
comment|/* FIXME? */
case|case
name|FT_UNSIGNED_LONG
case|:
comment|/* Chill longs are 4 bytes */
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|4
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"ULONG"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_FLOAT
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
literal|"REAL"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_DBL_PREC_FLOAT
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
literal|8
argument_list|,
literal|0
argument_list|,
literal|"LONG_REAL"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|type
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Table of operators and their precedences for printing expressions.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|op_print
name|chill_op_print_tab
index|[]
init|=
block|{
block|{
literal|"AND"
block|,
name|BINOP_LOGICAL_AND
block|,
name|PREC_LOGICAL_AND
block|,
literal|0
block|}
block|,
block|{
literal|"OR"
block|,
name|BINOP_LOGICAL_OR
block|,
name|PREC_LOGICAL_OR
block|,
literal|0
block|}
block|,
block|{
literal|"NOT"
block|,
name|UNOP_LOGICAL_NOT
block|,
name|PREC_PREFIX
block|,
literal|0
block|}
block|,
block|{
literal|"MOD"
block|,
name|BINOP_MOD
block|,
name|PREC_MUL
block|,
literal|0
block|}
block|,
block|{
literal|"REM"
block|,
name|BINOP_REM
block|,
name|PREC_MUL
block|,
literal|0
block|}
block|,
block|{
literal|"SIZE"
block|,
name|UNOP_SIZEOF
block|,
name|PREC_BUILTIN_FUNCTION
block|,
literal|0
block|}
block|,
block|{
literal|"LOWER"
block|,
name|UNOP_LOWER
block|,
name|PREC_BUILTIN_FUNCTION
block|,
literal|0
block|}
block|,
block|{
literal|"UPPER"
block|,
name|UNOP_UPPER
block|,
name|PREC_BUILTIN_FUNCTION
block|,
literal|0
block|}
block|,
block|{
literal|"CARD"
block|,
name|UNOP_CARD
block|,
name|PREC_BUILTIN_FUNCTION
block|,
literal|0
block|}
block|,
block|{
literal|"MAX"
block|,
name|UNOP_CHMAX
block|,
name|PREC_BUILTIN_FUNCTION
block|,
literal|0
block|}
block|,
block|{
literal|"MIN"
block|,
name|UNOP_CHMIN
block|,
name|PREC_BUILTIN_FUNCTION
block|,
literal|0
block|}
block|,
block|{
literal|":="
block|,
name|BINOP_ASSIGN
block|,
name|PREC_ASSIGN
block|,
literal|1
block|}
block|,
block|{
literal|"="
block|,
name|BINOP_EQUAL
block|,
name|PREC_EQUAL
block|,
literal|0
block|}
block|,
block|{
literal|"/="
block|,
name|BINOP_NOTEQUAL
block|,
name|PREC_EQUAL
block|,
literal|0
block|}
block|,
block|{
literal|"<="
block|,
name|BINOP_LEQ
block|,
name|PREC_ORDER
block|,
literal|0
block|}
block|,
block|{
literal|">="
block|,
name|BINOP_GEQ
block|,
name|PREC_ORDER
block|,
literal|0
block|}
block|,
block|{
literal|">"
block|,
name|BINOP_GTR
block|,
name|PREC_ORDER
block|,
literal|0
block|}
block|,
block|{
literal|"<"
block|,
name|BINOP_LESS
block|,
name|PREC_ORDER
block|,
literal|0
block|}
block|,
block|{
literal|"+"
block|,
name|BINOP_ADD
block|,
name|PREC_ADD
block|,
literal|0
block|}
block|,
block|{
literal|"-"
block|,
name|BINOP_SUB
block|,
name|PREC_ADD
block|,
literal|0
block|}
block|,
block|{
literal|"*"
block|,
name|BINOP_MUL
block|,
name|PREC_MUL
block|,
literal|0
block|}
block|,
block|{
literal|"/"
block|,
name|BINOP_DIV
block|,
name|PREC_MUL
block|,
literal|0
block|}
block|,
block|{
literal|"//"
block|,
name|BINOP_CONCAT
block|,
name|PREC_PREFIX
block|,
literal|0
block|}
block|,
comment|/* FIXME: precedence? */
block|{
literal|"-"
block|,
name|UNOP_NEG
block|,
name|PREC_PREFIX
block|,
literal|0
block|}
block|,
block|{
literal|"->"
block|,
name|UNOP_IND
block|,
name|PREC_SUFFIX
block|,
literal|1
block|}
block|,
block|{
literal|"->"
block|,
name|UNOP_ADDR
block|,
name|PREC_PREFIX
block|,
literal|0
block|}
block|,
block|{
literal|":"
block|,
name|BINOP_RANGE
block|,
name|PREC_ASSIGN
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* The built-in types of Chill.  */
end_comment

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_chill_bool
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_chill_char
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_chill_long
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_chill_ulong
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_chill_real
decl_stmt|;
end_decl_stmt

begin_function_decl
name|struct
name|type
modifier|*
modifier|*
name|CONST_PTR
parameter_list|(
name|chill_builtin_types
index|[]
parameter_list|)
init|=
block|{
operator|&
name|builtin_type_chill_bool
operator|,
function_decl|&builtin_type_chill_char
operator|,
function_decl|&builtin_type_chill_long
operator|,
function_decl|&builtin_type_chill_ulong
operator|,
function_decl|&builtin_type_chill_real
operator|,
function_decl|0
end_function_decl

begin_comment
unit|};
comment|/* Calculate LOWER or UPPER of TYPE.    Returns the result as an integer.    *RESULT_TYPE is the appropriate type for the result. */
end_comment

begin_function
name|LONGEST
name|type_lower_upper
parameter_list|(
name|op
parameter_list|,
name|type
parameter_list|,
name|result_type
parameter_list|)
name|enum
name|exp_opcode
name|op
decl_stmt|;
comment|/* Either UNOP_LOWER or UNOP_UPPER */
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|struct
name|type
modifier|*
modifier|*
name|result_type
decl_stmt|;
block|{
name|LONGEST
name|low
decl_stmt|,
name|high
decl_stmt|;
operator|*
name|result_type
operator|=
name|type
expr_stmt|;
name|CHECK_TYPEDEF
argument_list|(
name|type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_STRUCT
case|:
operator|*
name|result_type
operator|=
name|builtin_type_int
expr_stmt|;
if|if
condition|(
name|chill_varying_type
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|type_lower_upper
argument_list|(
name|op
argument_list|,
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
literal|1
argument_list|)
argument_list|,
name|result_type
argument_list|)
return|;
break|break;
case|case
name|TYPE_CODE_ARRAY
case|:
case|case
name|TYPE_CODE_BITSTRING
case|:
case|case
name|TYPE_CODE_STRING
case|:
name|type
operator|=
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Get index type */
comment|/* ... fall through ... */
case|case
name|TYPE_CODE_RANGE
case|:
operator|*
name|result_type
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|op
operator|==
name|UNOP_LOWER
condition|?
name|TYPE_LOW_BOUND
argument_list|(
name|type
argument_list|)
else|:
name|TYPE_HIGH_BOUND
argument_list|(
name|type
argument_list|)
return|;
case|case
name|TYPE_CODE_ENUM
case|:
case|case
name|TYPE_CODE_BOOL
case|:
case|case
name|TYPE_CODE_INT
case|:
case|case
name|TYPE_CODE_CHAR
case|:
if|if
condition|(
name|get_discrete_bounds
argument_list|(
name|type
argument_list|,
operator|&
name|low
argument_list|,
operator|&
name|high
argument_list|)
operator|>=
literal|0
condition|)
block|{
operator|*
name|result_type
operator|=
name|type
expr_stmt|;
return|return
name|op
operator|==
name|UNOP_LOWER
condition|?
name|low
else|:
name|high
return|;
block|}
break|break;
case|case
name|TYPE_CODE_UNDEF
case|:
case|case
name|TYPE_CODE_PTR
case|:
case|case
name|TYPE_CODE_UNION
case|:
case|case
name|TYPE_CODE_FUNC
case|:
case|case
name|TYPE_CODE_FLT
case|:
case|case
name|TYPE_CODE_VOID
case|:
case|case
name|TYPE_CODE_SET
case|:
case|case
name|TYPE_CODE_ERROR
case|:
case|case
name|TYPE_CODE_MEMBER
case|:
case|case
name|TYPE_CODE_METHOD
case|:
case|case
name|TYPE_CODE_REF
case|:
case|case
name|TYPE_CODE_COMPLEX
case|:
default|default:
break|break;
block|}
name|error
argument_list|(
literal|"unknown mode for LOWER/UPPER builtin"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|value_ptr
name|value_chill_length
parameter_list|(
name|val
parameter_list|)
name|value_ptr
name|val
decl_stmt|;
block|{
name|LONGEST
name|tmp
decl_stmt|;
name|struct
name|type
modifier|*
name|type
init|=
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
decl_stmt|;
name|struct
name|type
modifier|*
name|ttype
decl_stmt|;
name|CHECK_TYPEDEF
argument_list|(
name|type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_ARRAY
case|:
case|case
name|TYPE_CODE_BITSTRING
case|:
case|case
name|TYPE_CODE_STRING
case|:
name|tmp
operator|=
name|type_lower_upper
argument_list|(
name|UNOP_UPPER
argument_list|,
name|type
argument_list|,
operator|&
name|ttype
argument_list|)
operator|-
name|type_lower_upper
argument_list|(
name|UNOP_LOWER
argument_list|,
name|type
argument_list|,
operator|&
name|ttype
argument_list|)
operator|+
literal|1
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_STRUCT
case|:
if|if
condition|(
name|chill_varying_type
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|tmp
operator|=
name|unpack_long
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* ... else fall through ... */
default|default:
name|error
argument_list|(
literal|"bad argument to LENGTH builtin"
argument_list|)
expr_stmt|;
block|}
return|return
name|value_from_longest
argument_list|(
name|builtin_type_int
argument_list|,
name|tmp
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|value_ptr
name|value_chill_card
parameter_list|(
name|val
parameter_list|)
name|value_ptr
name|val
decl_stmt|;
block|{
name|LONGEST
name|tmp
init|=
literal|0
decl_stmt|;
name|struct
name|type
modifier|*
name|type
init|=
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
decl_stmt|;
name|CHECK_TYPEDEF
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_SET
condition|)
block|{
name|struct
name|type
modifier|*
name|range_type
init|=
name|TYPE_INDEX_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|LONGEST
name|lower_bound
decl_stmt|,
name|upper_bound
decl_stmt|;
name|int
name|i
decl_stmt|;
name|get_discrete_bounds
argument_list|(
name|range_type
argument_list|,
operator|&
name|lower_bound
argument_list|,
operator|&
name|upper_bound
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|lower_bound
init|;
name|i
operator|<=
name|upper_bound
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|value_bit_index
argument_list|(
name|type
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|val
argument_list|)
argument_list|,
name|i
argument_list|)
operator|>
literal|0
condition|)
name|tmp
operator|++
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"bad argument to CARD builtin"
argument_list|)
expr_stmt|;
return|return
name|value_from_longest
argument_list|(
name|builtin_type_int
argument_list|,
name|tmp
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|value_ptr
name|value_chill_max_min
parameter_list|(
name|op
parameter_list|,
name|val
parameter_list|)
name|enum
name|exp_opcode
name|op
decl_stmt|;
name|value_ptr
name|val
decl_stmt|;
block|{
name|LONGEST
name|tmp
init|=
literal|0
decl_stmt|;
name|struct
name|type
modifier|*
name|type
init|=
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
decl_stmt|;
name|struct
name|type
modifier|*
name|elttype
decl_stmt|;
name|CHECK_TYPEDEF
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_SET
condition|)
block|{
name|LONGEST
name|lower_bound
decl_stmt|,
name|upper_bound
decl_stmt|;
name|int
name|i
decl_stmt|,
name|empty
init|=
literal|1
decl_stmt|;
name|elttype
operator|=
name|TYPE_INDEX_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|CHECK_TYPEDEF
argument_list|(
name|elttype
argument_list|)
expr_stmt|;
name|get_discrete_bounds
argument_list|(
name|elttype
argument_list|,
operator|&
name|lower_bound
argument_list|,
operator|&
name|upper_bound
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|UNOP_CHMAX
condition|)
block|{
for|for
control|(
name|i
operator|=
name|upper_bound
init|;
name|i
operator|>=
name|lower_bound
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|value_bit_index
argument_list|(
name|type
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|val
argument_list|)
argument_list|,
name|i
argument_list|)
operator|>
literal|0
condition|)
block|{
name|tmp
operator|=
name|i
expr_stmt|;
name|empty
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
name|lower_bound
init|;
name|i
operator|<=
name|upper_bound
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|value_bit_index
argument_list|(
name|type
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|val
argument_list|)
argument_list|,
name|i
argument_list|)
operator|>
literal|0
condition|)
block|{
name|tmp
operator|=
name|i
expr_stmt|;
name|empty
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|empty
condition|)
name|error
argument_list|(
literal|"%s for empty powerset"
argument_list|,
name|op
operator|==
name|UNOP_CHMAX
condition|?
literal|"MAX"
else|:
literal|"MIN"
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"bad argument to %s builtin"
argument_list|,
name|op
operator|==
name|UNOP_CHMAX
condition|?
literal|"MAX"
else|:
literal|"MIN"
argument_list|)
expr_stmt|;
return|return
name|value_from_longest
argument_list|(
name|TYPE_CODE
argument_list|(
name|elttype
argument_list|)
operator|==
name|TYPE_CODE_RANGE
condition|?
name|TYPE_TARGET_TYPE
argument_list|(
name|elttype
argument_list|)
else|:
name|elttype
argument_list|,
name|tmp
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|value_ptr
name|evaluate_subexp_chill
parameter_list|(
name|expect_type
parameter_list|,
name|exp
parameter_list|,
name|pos
parameter_list|,
name|noside
parameter_list|)
name|struct
name|type
modifier|*
name|expect_type
decl_stmt|;
specifier|register
name|struct
name|expression
modifier|*
name|exp
decl_stmt|;
specifier|register
name|int
modifier|*
name|pos
decl_stmt|;
name|enum
name|noside
name|noside
decl_stmt|;
block|{
name|int
name|pc
init|=
operator|*
name|pos
decl_stmt|;
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|int
name|tem
decl_stmt|,
name|nargs
decl_stmt|;
name|value_ptr
name|arg1
decl_stmt|;
name|value_ptr
modifier|*
name|argvec
decl_stmt|;
name|enum
name|exp_opcode
name|op
init|=
name|exp
operator|->
name|elts
index|[
operator|*
name|pos
index|]
operator|.
name|opcode
decl_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|MULTI_SUBSCRIPT
case|:
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
break|break;
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|3
expr_stmt|;
name|nargs
operator|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|evaluate_subexp_with_coercion
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
name|type
operator|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nargs
operator|==
literal|1
operator|&&
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_INT
condition|)
block|{
comment|/* Looks like string repetition. */
name|value_ptr
name|string
init|=
name|evaluate_subexp_with_coercion
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
decl_stmt|;
return|return
name|value_concat
argument_list|(
name|arg1
argument_list|,
name|string
argument_list|)
return|;
block|}
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_PTR
case|:
name|type
operator|=
name|check_typedef
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|type
operator|||
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_CODE_FUNC
condition|)
name|error
argument_list|(
literal|"reference value used as function"
argument_list|)
expr_stmt|;
comment|/* ... fall through ... */
case|case
name|TYPE_CODE_FUNC
case|:
comment|/* It's a function call. */
if|if
condition|(
name|noside
operator|==
name|EVAL_AVOID_SIDE_EFFECTS
condition|)
break|break;
comment|/* Allocate arg vector, including space for the function to be 	     called in argvec[0] and a terminating NULL */
name|argvec
operator|=
operator|(
name|value_ptr
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|value_ptr
argument_list|)
operator|*
operator|(
name|nargs
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
name|argvec
index|[
literal|0
index|]
operator|=
name|arg1
expr_stmt|;
name|tem
operator|=
literal|1
expr_stmt|;
for|for
control|(
init|;
name|tem
operator|<=
name|nargs
operator|&&
name|tem
operator|<=
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
condition|;
name|tem
operator|++
control|)
block|{
name|argvec
index|[
name|tem
index|]
operator|=
name|evaluate_subexp_chill
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|tem
operator|-
literal|1
argument_list|)
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|tem
operator|<=
name|nargs
condition|;
name|tem
operator|++
control|)
name|argvec
index|[
name|tem
index|]
operator|=
name|evaluate_subexp_with_coercion
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
name|argvec
index|[
name|tem
index|]
operator|=
literal|0
expr_stmt|;
comment|/* signal end of arglist */
return|return
name|call_function_by_hand
argument_list|(
name|argvec
index|[
literal|0
index|]
argument_list|,
name|nargs
argument_list|,
name|argvec
operator|+
literal|1
argument_list|)
return|;
default|default:
break|break;
block|}
while|while
condition|(
name|nargs
operator|--
operator|>
literal|0
condition|)
block|{
name|value_ptr
name|index
init|=
name|evaluate_subexp_with_coercion
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
decl_stmt|;
name|arg1
operator|=
name|value_subscript
argument_list|(
name|arg1
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|arg1
operator|)
return|;
case|case
name|UNOP_LOWER
case|:
case|case
name|UNOP_UPPER
case|:
operator|(
operator|*
name|pos
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
block|{
call|(
modifier|*
name|exp
operator|->
name|language_defn
operator|->
name|evaluate_exp
call|)
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|EVAL_SKIP
argument_list|)
expr_stmt|;
goto|goto
name|nosideret
goto|;
block|}
name|arg1
operator|=
call|(
modifier|*
name|exp
operator|->
name|language_defn
operator|->
name|evaluate_exp
call|)
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|EVAL_AVOID_SIDE_EFFECTS
argument_list|)
expr_stmt|;
name|tem
operator|=
name|type_lower_upper
argument_list|(
name|op
argument_list|,
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
operator|&
name|type
argument_list|)
expr_stmt|;
return|return
name|value_from_longest
argument_list|(
name|type
argument_list|,
name|tem
argument_list|)
return|;
case|case
name|UNOP_LENGTH
case|:
operator|(
operator|*
name|pos
operator|)
operator|++
expr_stmt|;
name|arg1
operator|=
call|(
modifier|*
name|exp
operator|->
name|language_defn
operator|->
name|evaluate_exp
call|)
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
return|return
name|value_chill_length
argument_list|(
name|arg1
argument_list|)
return|;
case|case
name|UNOP_CARD
case|:
operator|(
operator|*
name|pos
operator|)
operator|++
expr_stmt|;
name|arg1
operator|=
call|(
modifier|*
name|exp
operator|->
name|language_defn
operator|->
name|evaluate_exp
call|)
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
return|return
name|value_chill_card
argument_list|(
name|arg1
argument_list|)
return|;
case|case
name|UNOP_CHMAX
case|:
case|case
name|UNOP_CHMIN
case|:
operator|(
operator|*
name|pos
operator|)
operator|++
expr_stmt|;
name|arg1
operator|=
call|(
modifier|*
name|exp
operator|->
name|language_defn
operator|->
name|evaluate_exp
call|)
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
return|return
name|value_chill_max_min
argument_list|(
name|op
argument_list|,
name|arg1
argument_list|)
return|;
case|case
name|BINOP_COMMA
case|:
name|error
argument_list|(
literal|"',' operator used in invalid context"
argument_list|)
expr_stmt|;
default|default:
break|break;
block|}
return|return
name|evaluate_subexp_standard
argument_list|(
name|expect_type
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
return|;
name|nosideret
label|:
return|return
name|value_from_longest
argument_list|(
name|builtin_type_long
argument_list|,
operator|(
name|LONGEST
operator|)
literal|1
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|const
name|struct
name|language_defn
name|chill_language_defn
init|=
block|{
literal|"chill"
block|,
name|language_chill
block|,
name|chill_builtin_types
block|,
name|range_check_on
block|,
name|type_check_on
block|,
name|chill_parse
block|,
comment|/* parser */
name|chill_error
block|,
comment|/* parser error function */
name|evaluate_subexp_chill
block|,
name|chill_printchar
block|,
comment|/* print a character constant */
name|chill_printstr
block|,
comment|/* function to print a string constant */
name|NULL
block|,
comment|/* Function to print a single char */
name|chill_create_fundamental_type
block|,
comment|/* Create fundamental type in this language */
name|chill_print_type
block|,
comment|/* Print a type using appropriate syntax */
name|chill_val_print
block|,
comment|/* Print a value using appropriate syntax */
name|chill_value_print
block|,
comment|/* Print a top-levl value */
block|{
literal|""
block|,
literal|"B'"
block|,
literal|""
block|,
literal|""
block|}
block|,
comment|/* Binary format info */
block|{
literal|"O'%lo"
block|,
literal|"O'"
block|,
literal|"o"
block|,
literal|""
block|}
block|,
comment|/* Octal format info */
block|{
literal|"D'%ld"
block|,
literal|"D'"
block|,
literal|"d"
block|,
literal|""
block|}
block|,
comment|/* Decimal format info */
block|{
literal|"H'%lx"
block|,
literal|"H'"
block|,
literal|"x"
block|,
literal|""
block|}
block|,
comment|/* Hex format info */
name|chill_op_print_tab
block|,
comment|/* expression operators for printing */
literal|0
block|,
comment|/* arrays are first-class (not c-style) */
literal|0
block|,
comment|/* String lower bound */
operator|&
name|builtin_type_chill_char
block|,
comment|/* Type of string elements */
name|LANG_MAGIC
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialization for Chill */
end_comment

begin_function
name|void
name|_initialize_chill_language
parameter_list|()
block|{
name|builtin_type_chill_bool
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_BOOL
argument_list|,
name|TARGET_CHAR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"BOOL"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|builtin_type_chill_char
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_CHAR
argument_list|,
name|TARGET_CHAR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"CHAR"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|builtin_type_chill_long
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_LONG_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"LONG"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|builtin_type_chill_ulong
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_LONG_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"ULONG"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|builtin_type_chill_real
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
name|TARGET_DOUBLE_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"LONG_REAL"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|add_language
argument_list|(
operator|&
name|chill_language_defn
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

