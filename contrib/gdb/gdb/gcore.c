begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Generate a core file for the inferior process.     Copyright 2001, 2002, 2003, 2004 Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_include
include|#
directive|include
file|"infcall.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"cli/cli-decode.h"
end_include

begin_include
include|#
directive|include
file|"gdb_assert.h"
end_include

begin_function_decl
specifier|static
name|char
modifier|*
name|default_gcore_target
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|bfd_architecture
name|default_gcore_arch
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|long
name|default_gcore_mach
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|gcore_memory_sections
parameter_list|(
name|bfd
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Generate a core file from the inferior process.  */
end_comment

begin_function
specifier|static
name|void
name|gcore_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|char
modifier|*
name|corefilename
decl_stmt|,
name|corefilename_buffer
index|[
literal|40
index|]
decl_stmt|;
name|asection
modifier|*
name|note_sec
init|=
name|NULL
decl_stmt|;
name|bfd
modifier|*
name|obfd
decl_stmt|;
name|void
modifier|*
name|note_data
init|=
name|NULL
decl_stmt|;
name|int
name|note_size
init|=
literal|0
decl_stmt|;
comment|/* No use generating a corefile without a target process.  */
if|if
condition|(
operator|!
name|target_has_execution
condition|)
name|noprocess
argument_list|()
expr_stmt|;
if|if
condition|(
name|args
operator|&&
operator|*
name|args
condition|)
name|corefilename
operator|=
name|args
expr_stmt|;
else|else
block|{
comment|/* Default corefile name is "core.PID".  */
name|sprintf
argument_list|(
name|corefilename_buffer
argument_list|,
literal|"core.%d"
argument_list|,
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|)
expr_stmt|;
name|corefilename
operator|=
name|corefilename_buffer
expr_stmt|;
block|}
if|if
condition|(
name|info_verbose
condition|)
name|fprintf_filtered
argument_list|(
name|gdb_stdout
argument_list|,
literal|"Opening corefile '%s' for output.\n"
argument_list|,
name|corefilename
argument_list|)
expr_stmt|;
comment|/* Open the output file.  */
name|obfd
operator|=
name|bfd_openw
argument_list|(
name|corefilename
argument_list|,
name|default_gcore_target
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|obfd
condition|)
name|error
argument_list|(
literal|"Failed to open '%s' for output."
argument_list|,
name|corefilename
argument_list|)
expr_stmt|;
comment|/* Need a cleanup that will close the file (FIXME: delete it?).  */
name|old_chain
operator|=
name|make_cleanup_bfd_close
argument_list|(
name|obfd
argument_list|)
expr_stmt|;
name|bfd_set_format
argument_list|(
name|obfd
argument_list|,
name|bfd_core
argument_list|)
expr_stmt|;
name|bfd_set_arch_mach
argument_list|(
name|obfd
argument_list|,
name|default_gcore_arch
argument_list|()
argument_list|,
name|default_gcore_mach
argument_list|()
argument_list|)
expr_stmt|;
comment|/* An external target method must build the notes section.  */
name|note_data
operator|=
name|target_make_corefile_notes
argument_list|(
name|obfd
argument_list|,
operator|&
name|note_size
argument_list|)
expr_stmt|;
comment|/* Create the note section.  */
if|if
condition|(
name|note_data
operator|!=
name|NULL
operator|&&
name|note_size
operator|!=
literal|0
condition|)
block|{
name|note_sec
operator|=
name|bfd_make_section_anyway
argument_list|(
name|obfd
argument_list|,
literal|"note0"
argument_list|)
expr_stmt|;
if|if
condition|(
name|note_sec
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Failed to create 'note' section for corefile: %s"
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_set_section_vma
argument_list|(
name|obfd
argument_list|,
name|note_sec
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bfd_set_section_flags
argument_list|(
name|obfd
argument_list|,
name|note_sec
argument_list|,
name|SEC_HAS_CONTENTS
operator||
name|SEC_READONLY
operator||
name|SEC_ALLOC
argument_list|)
expr_stmt|;
name|bfd_set_section_alignment
argument_list|(
name|obfd
argument_list|,
name|note_sec
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bfd_set_section_size
argument_list|(
name|obfd
argument_list|,
name|note_sec
argument_list|,
name|note_size
argument_list|)
expr_stmt|;
block|}
comment|/* Now create the memory/load sections.  */
if|if
condition|(
name|gcore_memory_sections
argument_list|(
name|obfd
argument_list|)
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"gcore: failed to get corefile memory sections from target."
argument_list|)
expr_stmt|;
comment|/* Write out the contents of the note section.  */
if|if
condition|(
name|note_data
operator|!=
name|NULL
operator|&&
name|note_size
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|obfd
argument_list|,
name|note_sec
argument_list|,
name|note_data
argument_list|,
literal|0
argument_list|,
name|note_size
argument_list|)
condition|)
name|warning
argument_list|(
literal|"writing note section (%s)"
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Succeeded.  */
name|fprintf_filtered
argument_list|(
name|gdb_stdout
argument_list|,
literal|"Saved corefile %s\n"
argument_list|,
name|corefilename
argument_list|)
expr_stmt|;
comment|/* Clean-ups will close the output file and free malloc memory.  */
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|long
name|default_gcore_mach
parameter_list|(
name|void
parameter_list|)
block|{
if|#
directive|if
literal|1
comment|/* See if this even matters...  */
return|return
literal|0
return|;
else|#
directive|else
ifdef|#
directive|ifdef
name|TARGET_ARCHITECTURE
specifier|const
name|struct
name|bfd_arch_info
modifier|*
name|bfdarch
init|=
name|TARGET_ARCHITECTURE
decl_stmt|;
if|if
condition|(
name|bfdarch
operator|!=
name|NULL
condition|)
return|return
name|bfdarch
operator|->
name|mach
return|;
endif|#
directive|endif
comment|/* TARGET_ARCHITECTURE */
if|if
condition|(
name|exec_bfd
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Can't find default bfd machine type (need execfile)."
argument_list|)
expr_stmt|;
return|return
name|bfd_get_mach
argument_list|(
name|exec_bfd
argument_list|)
return|;
endif|#
directive|endif
comment|/* 1 */
block|}
end_function

begin_function
specifier|static
name|enum
name|bfd_architecture
name|default_gcore_arch
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|TARGET_ARCHITECTURE
specifier|const
name|struct
name|bfd_arch_info
modifier|*
name|bfdarch
init|=
name|TARGET_ARCHITECTURE
decl_stmt|;
if|if
condition|(
name|bfdarch
operator|!=
name|NULL
condition|)
return|return
name|bfdarch
operator|->
name|arch
return|;
endif|#
directive|endif
if|if
condition|(
name|exec_bfd
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Can't find bfd architecture for corefile (need execfile)."
argument_list|)
expr_stmt|;
return|return
name|bfd_get_arch
argument_list|(
name|exec_bfd
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|default_gcore_target
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* FIXME: This may only work for ELF targets.  */
if|if
condition|(
name|exec_bfd
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
else|else
return|return
name|bfd_get_target
argument_list|(
name|exec_bfd
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Derive a reasonable stack segment by unwinding the target stack,    and store its limits in *BOTTOM and *TOP.  Return non-zero if    successful.  */
end_comment

begin_function
specifier|static
name|int
name|derive_stack_segment
parameter_list|(
name|bfd_vma
modifier|*
name|bottom
parameter_list|,
name|bfd_vma
modifier|*
name|top
parameter_list|)
block|{
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|,
modifier|*
name|tmp_fi
decl_stmt|;
name|gdb_assert
argument_list|(
name|bottom
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
name|top
argument_list|)
expr_stmt|;
comment|/* Can't succeed without stack and registers.  */
if|if
condition|(
operator|!
name|target_has_stack
operator|||
operator|!
name|target_has_registers
condition|)
return|return
literal|0
return|;
comment|/* Can't succeed without current frame.  */
name|fi
operator|=
name|get_current_frame
argument_list|()
expr_stmt|;
if|if
condition|(
name|fi
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* Save frame pointer of TOS frame.  */
operator|*
name|top
operator|=
name|get_frame_base
argument_list|(
name|fi
argument_list|)
expr_stmt|;
comment|/* If current stack pointer is more "inner", use that instead.  */
if|if
condition|(
name|INNER_THAN
argument_list|(
name|read_sp
argument_list|()
argument_list|,
operator|*
name|top
argument_list|)
condition|)
operator|*
name|top
operator|=
name|read_sp
argument_list|()
expr_stmt|;
comment|/* Find prev-most frame.  */
while|while
condition|(
operator|(
name|tmp_fi
operator|=
name|get_prev_frame
argument_list|(
name|fi
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|fi
operator|=
name|tmp_fi
expr_stmt|;
comment|/* Save frame pointer of prev-most frame.  */
operator|*
name|bottom
operator|=
name|get_frame_base
argument_list|(
name|fi
argument_list|)
expr_stmt|;
comment|/* Now canonicalize their order, so that BOTTOM is a lower address      (as opposed to a lower stack frame).  */
if|if
condition|(
operator|*
name|bottom
operator|>
operator|*
name|top
condition|)
block|{
name|bfd_vma
name|tmp_vma
decl_stmt|;
name|tmp_vma
operator|=
operator|*
name|top
expr_stmt|;
operator|*
name|top
operator|=
operator|*
name|bottom
expr_stmt|;
operator|*
name|bottom
operator|=
name|tmp_vma
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Derive a reasonable heap segment for ABFD by looking at sbrk and    the static data sections.  Store its limits in *BOTTOM and *TOP.    Return non-zero if successful.  */
end_comment

begin_function
specifier|static
name|int
name|derive_heap_segment
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd_vma
modifier|*
name|bottom
parameter_list|,
name|bfd_vma
modifier|*
name|top
parameter_list|)
block|{
name|bfd_vma
name|top_of_data_memory
init|=
literal|0
decl_stmt|;
name|bfd_vma
name|top_of_heap
init|=
literal|0
decl_stmt|;
name|bfd_size_type
name|sec_size
decl_stmt|;
name|struct
name|value
modifier|*
name|zero
decl_stmt|,
modifier|*
name|sbrk
decl_stmt|;
name|bfd_vma
name|sec_vaddr
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|gdb_assert
argument_list|(
name|bottom
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
name|top
argument_list|)
expr_stmt|;
comment|/* This function depends on being able to call a function in the      inferior.  */
if|if
condition|(
operator|!
name|target_has_execution
condition|)
return|return
literal|0
return|;
comment|/* The following code assumes that the link map is arranged as      follows (low to high addresses):       ---------------------------------      | text sections                 |      ---------------------------------      | data sections (including bss) |      ---------------------------------      | heap                          |      --------------------------------- */
for|for
control|(
name|sec
operator|=
name|abfd
operator|->
name|sections
init|;
name|sec
condition|;
name|sec
operator|=
name|sec
operator|->
name|next
control|)
block|{
if|if
condition|(
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|&
name|SEC_DATA
operator|||
name|strcmp
argument_list|(
literal|".bss"
argument_list|,
name|bfd_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sec_vaddr
operator|=
name|bfd_get_section_vma
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
name|sec_size
operator|=
name|bfd_get_section_size_before_reloc
argument_list|(
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec_vaddr
operator|+
name|sec_size
operator|>
name|top_of_data_memory
condition|)
name|top_of_data_memory
operator|=
name|sec_vaddr
operator|+
name|sec_size
expr_stmt|;
block|}
block|}
comment|/* Now get the top-of-heap by calling sbrk in the inferior.  */
if|if
condition|(
name|lookup_minimal_symbol
argument_list|(
literal|"sbrk"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|sbrk
operator|=
name|find_function_in_inferior
argument_list|(
literal|"sbrk"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sbrk
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|lookup_minimal_symbol
argument_list|(
literal|"_sbrk"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|sbrk
operator|=
name|find_function_in_inferior
argument_list|(
literal|"_sbrk"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sbrk
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
block|}
else|else
return|return
literal|0
return|;
name|zero
operator|=
name|value_from_longest
argument_list|(
name|builtin_type_int
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
name|zero
argument_list|)
expr_stmt|;
name|sbrk
operator|=
name|call_function_by_hand
argument_list|(
name|sbrk
argument_list|,
literal|1
argument_list|,
operator|&
name|zero
argument_list|)
expr_stmt|;
if|if
condition|(
name|sbrk
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|top_of_heap
operator|=
name|value_as_long
argument_list|(
name|sbrk
argument_list|)
expr_stmt|;
comment|/* Return results.  */
if|if
condition|(
name|top_of_heap
operator|>
name|top_of_data_memory
condition|)
block|{
operator|*
name|bottom
operator|=
name|top_of_data_memory
expr_stmt|;
operator|*
name|top
operator|=
name|top_of_heap
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* No additional heap space needs to be saved.  */
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|make_output_phdrs
parameter_list|(
name|bfd
modifier|*
name|obfd
parameter_list|,
name|asection
modifier|*
name|osec
parameter_list|,
name|void
modifier|*
name|ignored
parameter_list|)
block|{
name|int
name|p_flags
init|=
literal|0
decl_stmt|;
name|int
name|p_type
decl_stmt|;
comment|/* FIXME: these constants may only be applicable for ELF.  */
if|if
condition|(
name|strncmp
argument_list|(
name|bfd_section_name
argument_list|(
name|obfd
argument_list|,
name|osec
argument_list|)
argument_list|,
literal|"load"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
name|p_type
operator|=
name|PT_LOAD
expr_stmt|;
else|else
name|p_type
operator|=
name|PT_NOTE
expr_stmt|;
name|p_flags
operator||=
name|PF_R
expr_stmt|;
comment|/* Segment is readable.  */
if|if
condition|(
operator|!
operator|(
name|bfd_get_section_flags
argument_list|(
name|obfd
argument_list|,
name|osec
argument_list|)
operator|&
name|SEC_READONLY
operator|)
condition|)
name|p_flags
operator||=
name|PF_W
expr_stmt|;
comment|/* Segment is writable.  */
if|if
condition|(
name|bfd_get_section_flags
argument_list|(
name|obfd
argument_list|,
name|osec
argument_list|)
operator|&
name|SEC_CODE
condition|)
name|p_flags
operator||=
name|PF_X
expr_stmt|;
comment|/* Segment is executable.  */
name|bfd_record_phdr
argument_list|(
name|obfd
argument_list|,
name|p_type
argument_list|,
literal|1
argument_list|,
name|p_flags
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
operator|&
name|osec
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|gcore_create_callback
parameter_list|(
name|CORE_ADDR
name|vaddr
parameter_list|,
name|unsigned
name|long
name|size
parameter_list|,
name|int
name|read
parameter_list|,
name|int
name|write
parameter_list|,
name|int
name|exec
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|bfd
modifier|*
name|obfd
init|=
name|data
decl_stmt|;
name|asection
modifier|*
name|osec
decl_stmt|;
name|flagword
name|flags
init|=
name|SEC_ALLOC
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_LOAD
decl_stmt|;
comment|/* If the memory segment has no permissions set, ignore it, otherwise      when we later try to access it for read/write, we'll get an error      or jam the kernel.  */
if|if
condition|(
name|read
operator|==
literal|0
operator|&&
name|write
operator|==
literal|0
operator|&&
name|exec
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|info_verbose
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|gdb_stdout
argument_list|,
literal|"Ignore segment, %s bytes at 0x%s\n"
argument_list|,
name|paddr_d
argument_list|(
name|size
argument_list|)
argument_list|,
name|paddr_nz
argument_list|(
name|vaddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
if|if
condition|(
name|write
operator|==
literal|0
condition|)
block|{
comment|/* See if this region of memory lies inside a known file on disk. 	 If so, we can avoid copying its contents by clearing SEC_LOAD.  */
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|obj_section
modifier|*
name|objsec
decl_stmt|;
name|ALL_OBJSECTIONS
argument_list|(
argument|objfile
argument_list|,
argument|objsec
argument_list|)
block|{
name|bfd
modifier|*
name|abfd
init|=
name|objfile
operator|->
name|obfd
decl_stmt|;
name|asection
modifier|*
name|asec
init|=
name|objsec
operator|->
name|the_bfd_section
decl_stmt|;
name|bfd_vma
name|align
init|=
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
name|bfd_get_section_alignment
argument_list|(
name|abfd
argument_list|,
name|asec
argument_list|)
decl_stmt|;
name|bfd_vma
name|start
init|=
name|objsec
operator|->
name|addr
operator|&
operator|-
name|align
decl_stmt|;
name|bfd_vma
name|end
init|=
operator|(
name|objsec
operator|->
name|endaddr
operator|+
name|align
operator|-
literal|1
operator|)
operator|&
operator|-
name|align
decl_stmt|;
comment|/* Match if either the entire memory region lies inside the 	     section (i.e. a mapping covering some pages of a large 	     segment) or the entire section lies inside the memory region 	     (i.e. a mapping covering multiple small sections).  	     This BFD was synthesized from reading target memory, 	     we don't want to omit that.  */
if|if
condition|(
operator|(
operator|(
name|vaddr
operator|>=
name|start
operator|&&
name|vaddr
operator|+
name|size
operator|<=
name|end
operator|)
operator|||
operator|(
name|start
operator|>=
name|vaddr
operator|&&
name|end
operator|<=
name|vaddr
operator|+
name|size
operator|)
operator|)
operator|&&
operator|!
operator|(
name|bfd_get_file_flags
argument_list|(
name|abfd
argument_list|)
operator|&
name|BFD_IN_MEMORY
operator|)
condition|)
block|{
name|flags
operator|&=
operator|~
name|SEC_LOAD
expr_stmt|;
goto|goto
name|keep
goto|;
comment|/* break out of two nested for loops */
block|}
block|}
name|keep
label|:
name|flags
operator||=
name|SEC_READONLY
expr_stmt|;
block|}
if|if
condition|(
name|exec
condition|)
name|flags
operator||=
name|SEC_CODE
expr_stmt|;
else|else
name|flags
operator||=
name|SEC_DATA
expr_stmt|;
name|osec
operator|=
name|bfd_make_section_anyway
argument_list|(
name|obfd
argument_list|,
literal|"load"
argument_list|)
expr_stmt|;
if|if
condition|(
name|osec
operator|==
name|NULL
condition|)
block|{
name|warning
argument_list|(
literal|"Couldn't make gcore segment: %s"
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|info_verbose
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|gdb_stdout
argument_list|,
literal|"Save segment, %s bytes at 0x%s\n"
argument_list|,
name|paddr_d
argument_list|(
name|size
argument_list|)
argument_list|,
name|paddr_nz
argument_list|(
name|vaddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|bfd_set_section_size
argument_list|(
name|obfd
argument_list|,
name|osec
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|bfd_set_section_vma
argument_list|(
name|obfd
argument_list|,
name|osec
argument_list|,
name|vaddr
argument_list|)
expr_stmt|;
name|bfd_section_lma
argument_list|(
name|obfd
argument_list|,
name|osec
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* ??? bfd_set_section_lma?  */
name|bfd_set_section_flags
argument_list|(
name|obfd
argument_list|,
name|osec
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|objfile_find_memory_regions
parameter_list|(
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|CORE_ADDR
parameter_list|,
name|unsigned
name|long
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|obfd
parameter_list|)
block|{
comment|/* Use objfile data to create memory sections.  */
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|obj_section
modifier|*
name|objsec
decl_stmt|;
name|bfd_vma
name|temp_bottom
decl_stmt|,
name|temp_top
decl_stmt|;
comment|/* Call callback function for each objfile section.  */
name|ALL_OBJSECTIONS
argument_list|(
argument|objfile
argument_list|,
argument|objsec
argument_list|)
block|{
name|bfd
modifier|*
name|ibfd
init|=
name|objfile
operator|->
name|obfd
decl_stmt|;
name|asection
modifier|*
name|isec
init|=
name|objsec
operator|->
name|the_bfd_section
decl_stmt|;
name|flagword
name|flags
init|=
name|bfd_get_section_flags
argument_list|(
name|ibfd
argument_list|,
name|isec
argument_list|)
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|||
operator|(
name|flags
operator|&
name|SEC_LOAD
operator|)
condition|)
block|{
name|int
name|size
init|=
name|bfd_section_size
argument_list|(
name|ibfd
argument_list|,
name|isec
argument_list|)
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ret
operator|=
call|(
modifier|*
name|func
call|)
argument_list|(
name|objsec
operator|->
name|addr
argument_list|,
name|bfd_section_size
argument_list|(
name|ibfd
argument_list|,
name|isec
argument_list|)
argument_list|,
literal|1
argument_list|,
comment|/* All sections will be readable.  */
operator|(
name|flags
operator|&
name|SEC_READONLY
operator|)
operator|==
literal|0
argument_list|,
comment|/* Writable.  */
operator|(
name|flags
operator|&
name|SEC_CODE
operator|)
operator|!=
literal|0
argument_list|,
comment|/* Executable.  */
name|obfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
name|ret
return|;
block|}
block|}
comment|/* Make a stack segment.  */
if|if
condition|(
name|derive_stack_segment
argument_list|(
operator|&
name|temp_bottom
argument_list|,
operator|&
name|temp_top
argument_list|)
condition|)
call|(
modifier|*
name|func
call|)
argument_list|(
name|temp_bottom
argument_list|,
name|temp_top
operator|-
name|temp_bottom
argument_list|,
literal|1
argument_list|,
comment|/* Stack section will be readable.  */
literal|1
argument_list|,
comment|/* Stack section will be writable.  */
literal|0
argument_list|,
comment|/* Stack section will not be executable.  */
name|obfd
argument_list|)
expr_stmt|;
comment|/* Make a heap segment. */
if|if
condition|(
name|derive_heap_segment
argument_list|(
name|exec_bfd
argument_list|,
operator|&
name|temp_bottom
argument_list|,
operator|&
name|temp_top
argument_list|)
condition|)
call|(
modifier|*
name|func
call|)
argument_list|(
name|temp_bottom
argument_list|,
name|temp_top
operator|-
name|temp_bottom
argument_list|,
literal|1
argument_list|,
comment|/* Heap section will be readable.  */
literal|1
argument_list|,
comment|/* Heap section will be writable.  */
literal|0
argument_list|,
comment|/* Heap section will not be executable.  */
name|obfd
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|gcore_copy_callback
parameter_list|(
name|bfd
modifier|*
name|obfd
parameter_list|,
name|asection
modifier|*
name|osec
parameter_list|,
name|void
modifier|*
name|ignored
parameter_list|)
block|{
name|bfd_size_type
name|size
init|=
name|bfd_section_size
argument_list|(
name|obfd
argument_list|,
name|osec
argument_list|)
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
init|=
name|NULL
decl_stmt|;
name|void
modifier|*
name|memhunk
decl_stmt|;
comment|/* Read-only sections are marked; we don't have to copy their contents.  */
if|if
condition|(
operator|(
name|bfd_get_section_flags
argument_list|(
name|obfd
argument_list|,
name|osec
argument_list|)
operator|&
name|SEC_LOAD
operator|)
operator|==
literal|0
condition|)
return|return;
comment|/* Only interested in "load" sections.  */
if|if
condition|(
name|strncmp
argument_list|(
literal|"load"
argument_list|,
name|bfd_section_name
argument_list|(
name|obfd
argument_list|,
name|osec
argument_list|)
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
condition|)
return|return;
name|memhunk
operator|=
name|xmalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
comment|/* ??? This is crap since xmalloc should never return NULL.  */
if|if
condition|(
name|memhunk
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Not enough memory to create corefile."
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|memhunk
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_read_memory
argument_list|(
name|bfd_section_vma
argument_list|(
name|obfd
argument_list|,
name|osec
argument_list|)
argument_list|,
name|memhunk
argument_list|,
name|size
argument_list|)
operator|!=
literal|0
condition|)
name|warning
argument_list|(
literal|"Memory read failed for corefile section, %s bytes at 0x%s\n"
argument_list|,
name|paddr_d
argument_list|(
name|size
argument_list|)
argument_list|,
name|paddr
argument_list|(
name|bfd_section_vma
argument_list|(
name|obfd
argument_list|,
name|osec
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|obfd
argument_list|,
name|osec
argument_list|,
name|memhunk
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
condition|)
name|warning
argument_list|(
literal|"Failed to write corefile contents (%s)."
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
comment|/* Frees MEMHUNK.  */
block|}
end_function

begin_function
specifier|static
name|int
name|gcore_memory_sections
parameter_list|(
name|bfd
modifier|*
name|obfd
parameter_list|)
block|{
if|if
condition|(
name|target_find_memory_regions
argument_list|(
name|gcore_create_callback
argument_list|,
name|obfd
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* FIXME: error return/msg?  */
comment|/* Record phdrs for section-to-segment mapping.  */
name|bfd_map_over_sections
argument_list|(
name|obfd
argument_list|,
name|make_output_phdrs
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Copy memory region contents.  */
name|bfd_map_over_sections
argument_list|(
name|obfd
argument_list|,
name|gcore_copy_callback
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|_initialize_gcore
parameter_list|(
name|void
parameter_list|)
block|{
name|add_com
argument_list|(
literal|"generate-core-file"
argument_list|,
name|class_files
argument_list|,
name|gcore_command
argument_list|,
literal|"\ Save a core file with the current state of the debugged process.\n\ Argument is optional filename.  Default filename is 'core.<process_id>'."
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"gcore"
argument_list|,
literal|"generate-core-file"
argument_list|,
name|class_files
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|exec_set_find_memory_regions
argument_list|(
name|objfile_find_memory_regions
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

