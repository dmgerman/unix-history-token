begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Generate a core file for the inferior process.    Copyright 2001, 2002 Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"cli/cli-decode.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_include
include|#
directive|include
file|<sys/procfs.h>
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_function_decl
specifier|static
name|char
modifier|*
name|default_gcore_target
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|bfd_architecture
name|default_gcore_arch
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|long
name|default_gcore_mach
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|gcore_memory_sections
parameter_list|(
name|bfd
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Function: gcore_command    Generate a core file from the inferior process.  */
end_comment

begin_function
specifier|static
name|void
name|gcore_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|char
modifier|*
name|corefilename
decl_stmt|,
name|corefilename_buffer
index|[
literal|40
index|]
decl_stmt|;
name|asection
modifier|*
name|note_sec
init|=
name|NULL
decl_stmt|;
name|bfd
modifier|*
name|obfd
decl_stmt|;
name|void
modifier|*
name|note_data
init|=
name|NULL
decl_stmt|;
name|int
name|note_size
init|=
literal|0
decl_stmt|;
comment|/* No use generating a corefile without a target process.  */
if|if
condition|(
operator|!
operator|(
name|target_has_execution
operator|)
condition|)
name|noprocess
argument_list|()
expr_stmt|;
if|if
condition|(
name|args
operator|&&
operator|*
name|args
condition|)
name|corefilename
operator|=
name|args
expr_stmt|;
else|else
block|{
comment|/* Default corefile name is "core.PID".  */
name|sprintf
argument_list|(
name|corefilename_buffer
argument_list|,
literal|"core.%d"
argument_list|,
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|)
expr_stmt|;
name|corefilename
operator|=
name|corefilename_buffer
expr_stmt|;
block|}
if|if
condition|(
name|info_verbose
condition|)
name|fprintf_filtered
argument_list|(
name|gdb_stdout
argument_list|,
literal|"Opening corefile '%s' for output.\n"
argument_list|,
name|corefilename
argument_list|)
expr_stmt|;
comment|/* Open the output file. */
if|if
condition|(
operator|!
operator|(
name|obfd
operator|=
name|bfd_openw
argument_list|(
name|corefilename
argument_list|,
name|default_gcore_target
argument_list|()
argument_list|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"Failed to open '%s' for output."
argument_list|,
name|corefilename
argument_list|)
expr_stmt|;
block|}
comment|/* Need a cleanup that will close the file (FIXME: delete it?). */
name|old_chain
operator|=
name|make_cleanup_bfd_close
argument_list|(
name|obfd
argument_list|)
expr_stmt|;
name|bfd_set_format
argument_list|(
name|obfd
argument_list|,
name|bfd_core
argument_list|)
expr_stmt|;
name|bfd_set_arch_mach
argument_list|(
name|obfd
argument_list|,
name|default_gcore_arch
argument_list|()
argument_list|,
name|default_gcore_mach
argument_list|()
argument_list|)
expr_stmt|;
comment|/* An external target method must build the notes section. */
name|note_data
operator|=
operator|(
name|char
operator|*
operator|)
name|target_make_corefile_notes
argument_list|(
name|obfd
argument_list|,
operator|&
name|note_size
argument_list|)
expr_stmt|;
comment|/* Create the note section. */
if|if
condition|(
name|note_data
operator|!=
name|NULL
operator|&&
name|note_size
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|note_sec
operator|=
name|bfd_make_section_anyway
argument_list|(
name|obfd
argument_list|,
literal|"note0"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Failed to create 'note' section for corefile: %s"
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_set_section_vma
argument_list|(
name|obfd
argument_list|,
name|note_sec
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bfd_set_section_flags
argument_list|(
name|obfd
argument_list|,
name|note_sec
argument_list|,
name|SEC_HAS_CONTENTS
operator||
name|SEC_READONLY
operator||
name|SEC_ALLOC
argument_list|)
expr_stmt|;
name|bfd_set_section_alignment
argument_list|(
name|obfd
argument_list|,
name|note_sec
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bfd_set_section_size
argument_list|(
name|obfd
argument_list|,
name|note_sec
argument_list|,
name|note_size
argument_list|)
expr_stmt|;
block|}
comment|/* Now create the memory/load sections. */
if|if
condition|(
name|gcore_memory_sections
argument_list|(
name|obfd
argument_list|)
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"gcore: failed to get corefile memory sections from target."
argument_list|)
expr_stmt|;
comment|/* Write out the contents of the note section. */
if|if
condition|(
name|note_data
operator|!=
name|NULL
operator|&&
name|note_size
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|obfd
argument_list|,
name|note_sec
argument_list|,
name|note_data
argument_list|,
literal|0
argument_list|,
name|note_size
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"writing note section (%s)"
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Succeeded. */
name|fprintf_filtered
argument_list|(
name|gdb_stdout
argument_list|,
literal|"Saved corefile %s\n"
argument_list|,
name|corefilename
argument_list|)
expr_stmt|;
comment|/* Clean-ups will close the output file and free malloc memory. */
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|long
name|default_gcore_mach
parameter_list|(
name|void
parameter_list|)
block|{
if|#
directive|if
literal|1
comment|/* See if this even matters... */
return|return
literal|0
return|;
else|#
directive|else
ifdef|#
directive|ifdef
name|TARGET_ARCHITECTURE
specifier|const
name|struct
name|bfd_arch_info
modifier|*
name|bfdarch
init|=
name|TARGET_ARCHITECTURE
decl_stmt|;
if|if
condition|(
name|bfdarch
operator|!=
name|NULL
condition|)
return|return
name|bfdarch
operator|->
name|mach
return|;
endif|#
directive|endif
comment|/* TARGET_ARCHITECTURE */
if|if
condition|(
name|exec_bfd
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Can't find default bfd machine type (need execfile)."
argument_list|)
expr_stmt|;
return|return
name|bfd_get_mach
argument_list|(
name|exec_bfd
argument_list|)
return|;
endif|#
directive|endif
comment|/* 1 */
block|}
end_function

begin_function
specifier|static
name|enum
name|bfd_architecture
name|default_gcore_arch
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|TARGET_ARCHITECTURE
specifier|const
name|struct
name|bfd_arch_info
modifier|*
name|bfdarch
init|=
name|TARGET_ARCHITECTURE
decl_stmt|;
if|if
condition|(
name|bfdarch
operator|!=
name|NULL
condition|)
return|return
name|bfdarch
operator|->
name|arch
return|;
endif|#
directive|endif
if|if
condition|(
name|exec_bfd
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Can't find bfd architecture for corefile (need execfile)."
argument_list|)
expr_stmt|;
return|return
name|bfd_get_arch
argument_list|(
name|exec_bfd
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|default_gcore_target
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* FIXME -- this may only work for ELF targets.  */
if|if
condition|(
name|exec_bfd
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
else|else
return|return
name|bfd_get_target
argument_list|(
name|exec_bfd
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Default method for stack segment (preemptable by target).  */
end_comment

begin_function_decl
specifier|static
name|int
function_decl|(
modifier|*
name|override_derive_stack_segment
function_decl|)
parameter_list|(
name|bfd_vma
modifier|*
parameter_list|,
name|bfd_vma
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|extern
name|void
name|preempt_derive_stack_segment
parameter_list|(
name|int
function_decl|(
modifier|*
name|override_func
function_decl|)
parameter_list|(
name|bfd_vma
modifier|*
parameter_list|,
name|bfd_vma
modifier|*
parameter_list|)
parameter_list|)
block|{
name|override_derive_stack_segment
operator|=
name|override_func
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Function: default_derive_stack_segment    Derive a reasonable stack segment by unwinding the target stack.         Returns 0 for failure, 1 for success.  */
end_comment

begin_function
specifier|static
name|int
name|default_derive_stack_segment
parameter_list|(
name|bfd_vma
modifier|*
name|bottom
parameter_list|,
name|bfd_vma
modifier|*
name|top
parameter_list|)
block|{
name|bfd_vma
name|tmp_vma
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|,
modifier|*
name|tmp_fi
decl_stmt|;
if|if
condition|(
name|bottom
operator|==
name|NULL
operator|||
name|top
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* Paranoia. */
if|if
condition|(
operator|!
name|target_has_stack
operator|||
operator|!
name|target_has_registers
condition|)
return|return
literal|0
return|;
comment|/* Can't succeed without stack and registers. */
if|if
condition|(
operator|(
name|fi
operator|=
name|get_current_frame
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* Can't succeed without current frame. */
comment|/* Save frame pointer of TOS frame. */
operator|*
name|top
operator|=
name|fi
operator|->
name|frame
expr_stmt|;
comment|/* If current stack pointer is more "inner", use that instead. */
if|if
condition|(
name|INNER_THAN
argument_list|(
name|read_sp
argument_list|()
argument_list|,
operator|*
name|top
argument_list|)
condition|)
operator|*
name|top
operator|=
name|read_sp
argument_list|()
expr_stmt|;
comment|/* Find prev-most frame. */
while|while
condition|(
operator|(
name|tmp_fi
operator|=
name|get_prev_frame
argument_list|(
name|fi
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|fi
operator|=
name|tmp_fi
expr_stmt|;
comment|/* Save frame pointer of prev-most frame. */
operator|*
name|bottom
operator|=
name|fi
operator|->
name|frame
expr_stmt|;
comment|/* Now canonicalize their order, so that 'bottom' is a lower address    (as opposed to a lower stack frame). */
if|if
condition|(
operator|*
name|bottom
operator|>
operator|*
name|top
condition|)
block|{
name|tmp_vma
operator|=
operator|*
name|top
expr_stmt|;
operator|*
name|top
operator|=
operator|*
name|bottom
expr_stmt|;
operator|*
name|bottom
operator|=
name|tmp_vma
expr_stmt|;
block|}
return|return
literal|1
return|;
comment|/* success */
block|}
end_function

begin_function
specifier|static
name|int
name|derive_stack_segment
parameter_list|(
name|bfd_vma
modifier|*
name|bottom
parameter_list|,
name|bfd_vma
modifier|*
name|top
parameter_list|)
block|{
if|if
condition|(
name|override_derive_stack_segment
condition|)
return|return
name|override_derive_stack_segment
argument_list|(
name|bottom
argument_list|,
name|top
argument_list|)
return|;
else|else
return|return
name|default_derive_stack_segment
argument_list|(
name|bottom
argument_list|,
name|top
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Default method for heap segment (preemptable by target).  */
end_comment

begin_function_decl
specifier|static
name|int
function_decl|(
modifier|*
name|override_derive_heap_segment
function_decl|)
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|bfd_vma
modifier|*
parameter_list|,
name|bfd_vma
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|extern
name|void
name|preempt_derive_heap_segment
parameter_list|(
name|int
function_decl|(
modifier|*
name|override_func
function_decl|)
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|bfd_vma
modifier|*
parameter_list|,
name|bfd_vma
modifier|*
parameter_list|)
parameter_list|)
block|{
name|override_derive_heap_segment
operator|=
name|override_func
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Function: default_derive_heap_segment    Derive a reasonable heap segment by looking at sbrk and    the static data sections.        Returns 0 for failure, 1 for success.  */
end_comment

begin_function
specifier|static
name|int
name|default_derive_heap_segment
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd_vma
modifier|*
name|bottom
parameter_list|,
name|bfd_vma
modifier|*
name|top
parameter_list|)
block|{
name|bfd_vma
name|top_of_data_memory
init|=
literal|0
decl_stmt|;
name|bfd_vma
name|top_of_heap
init|=
literal|0
decl_stmt|;
name|bfd_size_type
name|sec_size
decl_stmt|;
name|struct
name|value
modifier|*
name|zero
decl_stmt|,
modifier|*
name|sbrk
decl_stmt|;
name|bfd_vma
name|sec_vaddr
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
if|if
condition|(
name|bottom
operator|==
name|NULL
operator|||
name|top
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* Paranoia. */
if|if
condition|(
operator|!
name|target_has_execution
condition|)
return|return
literal|0
return|;
comment|/* This function depends on being able 			   to call a function in the inferior.  */
comment|/* Assumption: link map is arranged as follows (low to high addresses):      text sections      data sections (including bss)      heap   */
for|for
control|(
name|sec
operator|=
name|abfd
operator|->
name|sections
init|;
name|sec
condition|;
name|sec
operator|=
name|sec
operator|->
name|next
control|)
block|{
if|if
condition|(
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|&
name|SEC_DATA
operator|||
name|strcmp
argument_list|(
literal|".bss"
argument_list|,
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sec_vaddr
operator|=
name|bfd_get_section_vma
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
name|sec_size
operator|=
name|bfd_get_section_size_before_reloc
argument_list|(
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec_vaddr
operator|+
name|sec_size
operator|>
name|top_of_data_memory
condition|)
name|top_of_data_memory
operator|=
name|sec_vaddr
operator|+
name|sec_size
expr_stmt|;
block|}
block|}
comment|/* Now get the top-of-heap by calling sbrk in the inferior.  */
if|if
condition|(
operator|(
name|sbrk
operator|=
name|find_function_in_inferior
argument_list|(
literal|"sbrk"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|zero
operator|=
name|value_from_longest
argument_list|(
name|builtin_type_int
argument_list|,
operator|(
name|LONGEST
operator|)
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|sbrk
operator|=
name|call_function_by_hand
argument_list|(
name|sbrk
argument_list|,
literal|1
argument_list|,
operator|&
name|zero
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|top_of_heap
operator|=
name|value_as_long
argument_list|(
name|sbrk
argument_list|)
expr_stmt|;
comment|/* Return results. */
if|if
condition|(
name|top_of_heap
operator|>
name|top_of_data_memory
condition|)
block|{
operator|*
name|bottom
operator|=
name|top_of_data_memory
expr_stmt|;
operator|*
name|top
operator|=
name|top_of_heap
expr_stmt|;
return|return
literal|1
return|;
comment|/* success */
block|}
else|else
return|return
literal|0
return|;
comment|/* No additional heap space needs to be saved. */
block|}
end_function

begin_function
specifier|static
name|int
name|derive_heap_segment
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd_vma
modifier|*
name|bottom
parameter_list|,
name|bfd_vma
modifier|*
name|top
parameter_list|)
block|{
if|if
condition|(
name|override_derive_heap_segment
condition|)
return|return
name|override_derive_heap_segment
argument_list|(
name|abfd
argument_list|,
name|bottom
argument_list|,
name|top
argument_list|)
return|;
else|else
return|return
name|default_derive_heap_segment
argument_list|(
name|abfd
argument_list|,
name|bottom
argument_list|,
name|top
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|make_output_phdrs
parameter_list|(
name|bfd
modifier|*
name|obfd
parameter_list|,
name|asection
modifier|*
name|osec
parameter_list|,
name|void
modifier|*
name|ignored
parameter_list|)
block|{
name|int
name|p_flags
init|=
literal|0
decl_stmt|;
name|int
name|p_type
decl_stmt|;
comment|/* FIXME: these constants may only be applicable for ELF.  */
if|if
condition|(
name|strncmp
argument_list|(
name|osec
operator|->
name|name
argument_list|,
literal|"load"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
name|p_type
operator|=
name|PT_LOAD
expr_stmt|;
else|else
name|p_type
operator|=
name|PT_NOTE
expr_stmt|;
name|p_flags
operator||=
name|PF_R
expr_stmt|;
comment|/* Segment is readable.  */
if|if
condition|(
operator|!
operator|(
name|bfd_get_section_flags
argument_list|(
name|obfd
argument_list|,
name|osec
argument_list|)
operator|&
name|SEC_READONLY
operator|)
condition|)
name|p_flags
operator||=
name|PF_W
expr_stmt|;
comment|/* Segment is writable.  */
if|if
condition|(
name|bfd_get_section_flags
argument_list|(
name|obfd
argument_list|,
name|osec
argument_list|)
operator|&
name|SEC_CODE
condition|)
name|p_flags
operator||=
name|PF_X
expr_stmt|;
comment|/* Segment is executable.  */
name|bfd_record_phdr
argument_list|(
name|obfd
argument_list|,
name|p_type
argument_list|,
literal|1
argument_list|,
name|p_flags
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
operator|&
name|osec
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|asection
modifier|*
name|make_mem_sec
parameter_list|(
name|bfd
modifier|*
name|obfd
parameter_list|,
name|bfd_vma
name|addr
parameter_list|,
name|bfd_size_type
name|size
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|,
name|unsigned
name|int
name|alignment
parameter_list|)
block|{
name|asection
modifier|*
name|osec
decl_stmt|;
if|if
condition|(
operator|(
name|osec
operator|=
name|bfd_make_section_anyway
argument_list|(
name|obfd
argument_list|,
literal|"load"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warning
argument_list|(
literal|"Couldn't make gcore segment: %s"
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|info_verbose
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|gdb_stdout
argument_list|,
literal|"Save segment, %lld bytes at 0x%s\n"
argument_list|,
operator|(
name|long
name|long
operator|)
name|size
argument_list|,
name|paddr_nz
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|bfd_set_section_size
argument_list|(
name|obfd
argument_list|,
name|osec
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|bfd_set_section_vma
argument_list|(
name|obfd
argument_list|,
name|osec
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|osec
operator|->
name|lma
operator|=
literal|0
expr_stmt|;
comment|/* FIXME: there should be a macro for this! */
name|bfd_set_section_alignment
argument_list|(
name|obfd
argument_list|,
name|osec
argument_list|,
name|alignment
argument_list|)
expr_stmt|;
name|bfd_set_section_flags
argument_list|(
name|obfd
argument_list|,
name|osec
argument_list|,
name|flags
operator||
name|SEC_LOAD
operator||
name|SEC_ALLOC
operator||
name|SEC_HAS_CONTENTS
argument_list|)
expr_stmt|;
return|return
name|osec
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|gcore_create_callback
parameter_list|(
name|CORE_ADDR
name|vaddr
parameter_list|,
name|unsigned
name|long
name|size
parameter_list|,
name|int
name|read
parameter_list|,
name|int
name|write
parameter_list|,
name|int
name|exec
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|flagword
name|flags
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|write
operator|==
literal|0
condition|)
block|{
name|flags
operator||=
name|SEC_READONLY
expr_stmt|;
comment|/* Set size == zero for readonly sections. */
name|size
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|exec
condition|)
block|{
name|flags
operator||=
name|SEC_CODE
expr_stmt|;
block|}
else|else
block|{
name|flags
operator||=
name|SEC_DATA
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|make_mem_sec
argument_list|(
operator|(
name|bfd
operator|*
operator|)
name|data
argument_list|,
name|vaddr
argument_list|,
name|size
argument_list|,
name|flags
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|objfile_find_memory_regions
parameter_list|(
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|CORE_ADDR
parameter_list|,
name|unsigned
name|long
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|obfd
parameter_list|)
block|{
comment|/* Use objfile data to create memory sections. */
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|obj_section
modifier|*
name|objsec
decl_stmt|;
name|bfd_vma
name|temp_bottom
decl_stmt|,
name|temp_top
decl_stmt|;
comment|/* Call callback function for each objfile section. */
name|ALL_OBJSECTIONS
argument_list|(
argument|objfile
argument_list|,
argument|objsec
argument_list|)
block|{
name|bfd
modifier|*
name|ibfd
init|=
name|objfile
operator|->
name|obfd
decl_stmt|;
name|asection
modifier|*
name|isec
init|=
name|objsec
operator|->
name|the_bfd_section
decl_stmt|;
name|flagword
name|flags
init|=
name|bfd_get_section_flags
argument_list|(
name|ibfd
argument_list|,
name|isec
argument_list|)
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|||
operator|(
name|flags
operator|&
name|SEC_LOAD
operator|)
condition|)
block|{
name|int
name|size
init|=
name|bfd_section_size
argument_list|(
name|ibfd
argument_list|,
name|isec
argument_list|)
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
call|(
modifier|*
name|func
call|)
argument_list|(
name|objsec
operator|->
name|addr
argument_list|,
name|bfd_section_size
argument_list|(
name|ibfd
argument_list|,
name|isec
argument_list|)
argument_list|,
literal|1
argument_list|,
comment|/* All sections will be readable.  */
operator|(
name|flags
operator|&
name|SEC_READONLY
operator|)
operator|==
literal|0
argument_list|,
comment|/* writable */
operator|(
name|flags
operator|&
name|SEC_CODE
operator|)
operator|!=
literal|0
argument_list|,
comment|/* executable */
name|obfd
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|ret
return|;
block|}
block|}
comment|/* Make a stack segment. */
if|if
condition|(
name|derive_stack_segment
argument_list|(
operator|&
name|temp_bottom
argument_list|,
operator|&
name|temp_top
argument_list|)
condition|)
call|(
modifier|*
name|func
call|)
argument_list|(
name|temp_bottom
argument_list|,
name|temp_top
operator|-
name|temp_bottom
argument_list|,
literal|1
argument_list|,
comment|/* Stack section will be readable */
literal|1
argument_list|,
comment|/* Stack section will be writable */
literal|0
argument_list|,
comment|/* Stack section will not be executable */
name|obfd
argument_list|)
expr_stmt|;
comment|/* Make a heap segment. */
if|if
condition|(
name|derive_heap_segment
argument_list|(
name|exec_bfd
argument_list|,
operator|&
name|temp_bottom
argument_list|,
operator|&
name|temp_top
argument_list|)
condition|)
call|(
modifier|*
name|func
call|)
argument_list|(
name|temp_bottom
argument_list|,
name|temp_top
operator|-
name|temp_bottom
argument_list|,
literal|1
argument_list|,
comment|/* Heap section will be readable */
literal|1
argument_list|,
comment|/* Heap section will be writable */
literal|0
argument_list|,
comment|/* Heap section will not be executable */
name|obfd
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|gcore_copy_callback
parameter_list|(
name|bfd
modifier|*
name|obfd
parameter_list|,
name|asection
modifier|*
name|osec
parameter_list|,
name|void
modifier|*
name|ignored
parameter_list|)
block|{
name|bfd_size_type
name|size
init|=
name|bfd_section_size
argument_list|(
name|obfd
argument_list|,
name|osec
argument_list|)
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
init|=
name|NULL
decl_stmt|;
name|void
modifier|*
name|memhunk
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
return|return;
comment|/* Read-only sections are marked as zero-size. 		   We don't have to copy their contents. */
if|if
condition|(
name|strncmp
argument_list|(
literal|"load"
argument_list|,
name|bfd_get_section_name
argument_list|(
name|obfd
argument_list|,
name|osec
argument_list|)
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
condition|)
return|return;
comment|/* Only interested in "load" sections. */
if|if
condition|(
operator|(
name|memhunk
operator|=
name|xmalloc
argument_list|(
name|size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Not enough memory to create corefile."
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|memhunk
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_read_memory
argument_list|(
name|bfd_section_vma
argument_list|(
name|obfd
argument_list|,
name|osec
argument_list|)
argument_list|,
name|memhunk
argument_list|,
name|size
argument_list|)
operator|!=
literal|0
condition|)
name|warning
argument_list|(
literal|"Memory read failed for corefile section, %ld bytes at 0x%s\n"
argument_list|,
operator|(
name|long
operator|)
name|size
argument_list|,
name|paddr
argument_list|(
name|bfd_section_vma
argument_list|(
name|obfd
argument_list|,
name|osec
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|obfd
argument_list|,
name|osec
argument_list|,
name|memhunk
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
condition|)
name|warning
argument_list|(
literal|"Failed to write corefile contents (%s)."
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
comment|/* frees the xmalloc buffer */
block|}
end_function

begin_function
specifier|static
name|int
name|gcore_memory_sections
parameter_list|(
name|bfd
modifier|*
name|obfd
parameter_list|)
block|{
if|if
condition|(
name|target_find_memory_regions
argument_list|(
name|gcore_create_callback
argument_list|,
name|obfd
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* FIXME error return/msg? */
comment|/* Record phdrs for section-to-segment mapping. */
name|bfd_map_over_sections
argument_list|(
name|obfd
argument_list|,
name|make_output_phdrs
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Copy memory region contents. */
name|bfd_map_over_sections
argument_list|(
name|obfd
argument_list|,
name|gcore_copy_callback
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
comment|/* success */
block|}
end_function

begin_function
name|void
name|_initialize_gcore
parameter_list|(
name|void
parameter_list|)
block|{
name|add_com
argument_list|(
literal|"generate-core-file"
argument_list|,
name|class_files
argument_list|,
name|gcore_command
argument_list|,
literal|"Save a core file with the current state of the debugged process.\n\ Argument is optional filename.  Default filename is 'core.<process_id>'."
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"gcore"
argument_list|,
literal|"generate-core-file"
argument_list|,
name|class_files
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|exec_set_find_memory_regions
argument_list|(
name|objfile_find_memory_regions
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

