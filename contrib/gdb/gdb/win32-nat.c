begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Target-vector operations for controlling win32 child processes, for GDB.     Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003 Free    Software Foundation, Inc.     Contributed by Cygnus Solutions, A Red Hat Company.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without eve nthe implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* Originally by Steve Chamberlain, sac@cygnus.com */
end_comment

begin_comment
comment|/* We assume we're being built with and will be used for cygwin.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_comment
comment|/* required by inferior.h */
end_comment

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"completer.h"
end_include

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_include
include|#
directive|include
file|"top.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<windows.h>
end_include

begin_include
include|#
directive|include
file|<imagehlp.h>
end_include

begin_include
include|#
directive|include
file|<sys/cygwin.h>
end_include

begin_include
include|#
directive|include
file|"buildsym.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"gdbthread.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"exec.h"
end_include

begin_include
include|#
directive|include
file|"i386-tdep.h"
end_include

begin_include
include|#
directive|include
file|"i387-tdep.h"
end_include

begin_comment
comment|/* The ui's event loop. */
end_comment

begin_function_decl
specifier|extern
name|int
function_decl|(
modifier|*
name|ui_loop_hook
function_decl|)
parameter_list|(
name|int
name|signo
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* If we're not using the old Cygwin header file set, define the    following which never should have been in the generic Win32 API    headers in the first place since they were our own invention... */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_GNU_H_WINDOWS_H
end_ifndef

begin_enum
enum|enum
block|{
name|FLAG_TRACE_BIT
init|=
literal|0x100
block|,
name|CONTEXT_DEBUGGER
init|=
operator|(
name|CONTEXT_FULL
operator||
name|CONTEXT_FLOATING_POINT
operator|)
block|}
enum|;
end_enum

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/procfs.h>
end_include

begin_include
include|#
directive|include
file|<psapi.h>
end_include

begin_define
define|#
directive|define
name|CONTEXT_DEBUGGER_DR
value|CONTEXT_DEBUGGER | CONTEXT_DEBUG_REGISTERS \ 	| CONTEXT_EXTENDED_REGISTERS
end_define

begin_decl_stmt
specifier|static
name|unsigned
name|dr
index|[
literal|8
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|debug_registers_changed
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|debug_registers_used
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The string sent by cygwin when it processes a signal.    FIXME: This should be in a cygwin include file. */
end_comment

begin_define
define|#
directive|define
name|CYGWIN_SIGNAL_STRING
value|"cygwin: signal"
end_define

begin_define
define|#
directive|define
name|CHECK
parameter_list|(
name|x
parameter_list|)
value|check (x, __FILE__,__LINE__)
end_define

begin_define
define|#
directive|define
name|DEBUG_EXEC
parameter_list|(
name|x
parameter_list|)
value|if (debug_exec)		printf_unfiltered x
end_define

begin_define
define|#
directive|define
name|DEBUG_EVENTS
parameter_list|(
name|x
parameter_list|)
value|if (debug_events)	printf_unfiltered x
end_define

begin_define
define|#
directive|define
name|DEBUG_MEM
parameter_list|(
name|x
parameter_list|)
value|if (debug_memory)	printf_unfiltered x
end_define

begin_define
define|#
directive|define
name|DEBUG_EXCEPT
parameter_list|(
name|x
parameter_list|)
value|if (debug_exceptions)	printf_unfiltered x
end_define

begin_comment
comment|/* Forward declaration */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|target_ops
name|child_ops
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|child_stop
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|win32_child_thread_alive
parameter_list|(
name|ptid_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|child_kill_inferior
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|enum
name|target_signal
name|last_sig
init|=
name|TARGET_SIGNAL_0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set if a signal was received from the debugged process */
end_comment

begin_comment
comment|/* Thread information structure used to track information that is    not available in gdb's thread structure. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|thread_info_struct
block|{
name|struct
name|thread_info_struct
modifier|*
name|next
decl_stmt|;
name|DWORD
name|id
decl_stmt|;
name|HANDLE
name|h
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|suspend_count
decl_stmt|;
name|int
name|reload_context
decl_stmt|;
name|CONTEXT
name|context
decl_stmt|;
name|STACKFRAME
name|sf
decl_stmt|;
block|}
name|thread_info
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|thread_info
name|thread_head
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The process and thread handles for the above context. */
end_comment

begin_decl_stmt
specifier|static
name|DEBUG_EVENT
name|current_event
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The current debug event from 					   WaitForDebugEvent */
end_comment

begin_decl_stmt
specifier|static
name|HANDLE
name|current_process_handle
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Currently executing process */
end_comment

begin_decl_stmt
specifier|static
name|thread_info
modifier|*
name|current_thread
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Info on currently selected thread */
end_comment

begin_decl_stmt
specifier|static
name|DWORD
name|main_thread_id
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Thread ID of the main thread */
end_comment

begin_comment
comment|/* Counts of things. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|exception_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|event_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|saw_create
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* User options. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|new_console
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|new_group
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|debug_exec
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* show execution */
end_comment

begin_decl_stmt
specifier|static
name|int
name|debug_events
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* show events from kernel */
end_comment

begin_decl_stmt
specifier|static
name|int
name|debug_memory
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* show target memory accesses */
end_comment

begin_decl_stmt
specifier|static
name|int
name|debug_exceptions
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* show target exceptions */
end_comment

begin_decl_stmt
specifier|static
name|int
name|useshell
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* use shell for subprocesses */
end_comment

begin_comment
comment|/* This vector maps GDB's idea of a register's number into an address    in the win32 exception context vector.     It also contains the bit mask needed to load the register in question.     One day we could read a reg, we could inspect the context we    already have loaded, if it doesn't have the bit set that we need,    we read that set of registers in using GetThreadContext.  If the    context already contains what we need, we just unpack it. Then to    write a register, first we have to ensure that the context contains    the other regs of the group, and then we copy the info in and set    out bit. */
end_comment

begin_define
define|#
directive|define
name|context_offset
parameter_list|(
name|x
parameter_list|)
value|((int)&(((CONTEXT *)NULL)->x))
end_define

begin_decl_stmt
specifier|static
specifier|const
name|int
name|mappings
index|[]
init|=
block|{
name|context_offset
argument_list|(
name|Eax
argument_list|)
block|,
name|context_offset
argument_list|(
name|Ecx
argument_list|)
block|,
name|context_offset
argument_list|(
name|Edx
argument_list|)
block|,
name|context_offset
argument_list|(
name|Ebx
argument_list|)
block|,
name|context_offset
argument_list|(
name|Esp
argument_list|)
block|,
name|context_offset
argument_list|(
name|Ebp
argument_list|)
block|,
name|context_offset
argument_list|(
name|Esi
argument_list|)
block|,
name|context_offset
argument_list|(
name|Edi
argument_list|)
block|,
name|context_offset
argument_list|(
name|Eip
argument_list|)
block|,
name|context_offset
argument_list|(
name|EFlags
argument_list|)
block|,
name|context_offset
argument_list|(
name|SegCs
argument_list|)
block|,
name|context_offset
argument_list|(
name|SegSs
argument_list|)
block|,
name|context_offset
argument_list|(
name|SegDs
argument_list|)
block|,
name|context_offset
argument_list|(
name|SegEs
argument_list|)
block|,
name|context_offset
argument_list|(
name|SegFs
argument_list|)
block|,
name|context_offset
argument_list|(
name|SegGs
argument_list|)
block|,
name|context_offset
argument_list|(
name|FloatSave
operator|.
name|RegisterArea
index|[
literal|0
operator|*
literal|10
index|]
argument_list|)
block|,
name|context_offset
argument_list|(
name|FloatSave
operator|.
name|RegisterArea
index|[
literal|1
operator|*
literal|10
index|]
argument_list|)
block|,
name|context_offset
argument_list|(
name|FloatSave
operator|.
name|RegisterArea
index|[
literal|2
operator|*
literal|10
index|]
argument_list|)
block|,
name|context_offset
argument_list|(
name|FloatSave
operator|.
name|RegisterArea
index|[
literal|3
operator|*
literal|10
index|]
argument_list|)
block|,
name|context_offset
argument_list|(
name|FloatSave
operator|.
name|RegisterArea
index|[
literal|4
operator|*
literal|10
index|]
argument_list|)
block|,
name|context_offset
argument_list|(
name|FloatSave
operator|.
name|RegisterArea
index|[
literal|5
operator|*
literal|10
index|]
argument_list|)
block|,
name|context_offset
argument_list|(
name|FloatSave
operator|.
name|RegisterArea
index|[
literal|6
operator|*
literal|10
index|]
argument_list|)
block|,
name|context_offset
argument_list|(
name|FloatSave
operator|.
name|RegisterArea
index|[
literal|7
operator|*
literal|10
index|]
argument_list|)
block|,
name|context_offset
argument_list|(
name|FloatSave
operator|.
name|ControlWord
argument_list|)
block|,
name|context_offset
argument_list|(
name|FloatSave
operator|.
name|StatusWord
argument_list|)
block|,
name|context_offset
argument_list|(
name|FloatSave
operator|.
name|TagWord
argument_list|)
block|,
name|context_offset
argument_list|(
name|FloatSave
operator|.
name|ErrorSelector
argument_list|)
block|,
name|context_offset
argument_list|(
name|FloatSave
operator|.
name|ErrorOffset
argument_list|)
block|,
name|context_offset
argument_list|(
name|FloatSave
operator|.
name|DataSelector
argument_list|)
block|,
name|context_offset
argument_list|(
name|FloatSave
operator|.
name|DataOffset
argument_list|)
block|,
name|context_offset
argument_list|(
name|FloatSave
operator|.
name|ErrorSelector
argument_list|)
comment|/* XMM0-7 */
block|,
name|context_offset
argument_list|(
name|ExtendedRegisters
index|[
literal|10
operator|*
literal|16
index|]
argument_list|)
block|,
name|context_offset
argument_list|(
name|ExtendedRegisters
index|[
literal|11
operator|*
literal|16
index|]
argument_list|)
block|,
name|context_offset
argument_list|(
name|ExtendedRegisters
index|[
literal|12
operator|*
literal|16
index|]
argument_list|)
block|,
name|context_offset
argument_list|(
name|ExtendedRegisters
index|[
literal|13
operator|*
literal|16
index|]
argument_list|)
block|,
name|context_offset
argument_list|(
name|ExtendedRegisters
index|[
literal|14
operator|*
literal|16
index|]
argument_list|)
block|,
name|context_offset
argument_list|(
name|ExtendedRegisters
index|[
literal|15
operator|*
literal|16
index|]
argument_list|)
block|,
name|context_offset
argument_list|(
name|ExtendedRegisters
index|[
literal|16
operator|*
literal|16
index|]
argument_list|)
block|,
name|context_offset
argument_list|(
name|ExtendedRegisters
index|[
literal|17
operator|*
literal|16
index|]
argument_list|)
block|,
comment|/* MXCSR */
name|context_offset
argument_list|(
argument|ExtendedRegisters[
literal|24
argument|]
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|context_offset
end_undef

begin_comment
comment|/* This vector maps the target's idea of an exception (extracted    from the DEBUG_EVENT structure) to GDB's idea. */
end_comment

begin_struct
struct|struct
name|xlate_exception
block|{
name|int
name|them
decl_stmt|;
name|enum
name|target_signal
name|us
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|xlate_exception
name|xlate
index|[]
init|=
block|{
block|{
name|EXCEPTION_ACCESS_VIOLATION
block|,
name|TARGET_SIGNAL_SEGV
block|}
block|,
block|{
name|STATUS_STACK_OVERFLOW
block|,
name|TARGET_SIGNAL_SEGV
block|}
block|,
block|{
name|EXCEPTION_BREAKPOINT
block|,
name|TARGET_SIGNAL_TRAP
block|}
block|,
block|{
name|DBG_CONTROL_C
block|,
name|TARGET_SIGNAL_INT
block|}
block|,
block|{
name|EXCEPTION_SINGLE_STEP
block|,
name|TARGET_SIGNAL_TRAP
block|}
block|,
block|{
name|STATUS_FLOAT_DIVIDE_BY_ZERO
block|,
name|TARGET_SIGNAL_FPE
block|}
block|,
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|check
parameter_list|(
name|BOOL
name|ok
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ok
condition|)
name|printf_filtered
argument_list|(
literal|"error return %s:%d was %lu\n"
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|GetLastError
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find a thread record given a thread id.    If get_context then also retrieve the context for this    thread. */
end_comment

begin_function
specifier|static
name|thread_info
modifier|*
name|thread_rec
parameter_list|(
name|DWORD
name|id
parameter_list|,
name|int
name|get_context
parameter_list|)
block|{
name|thread_info
modifier|*
name|th
decl_stmt|;
for|for
control|(
name|th
operator|=
operator|&
name|thread_head
init|;
operator|(
name|th
operator|=
name|th
operator|->
name|next
operator|)
operator|!=
name|NULL
condition|;
control|)
if|if
condition|(
name|th
operator|->
name|id
operator|==
name|id
condition|)
block|{
if|if
condition|(
operator|!
name|th
operator|->
name|suspend_count
operator|&&
name|get_context
condition|)
block|{
if|if
condition|(
name|get_context
operator|>
literal|0
operator|&&
name|id
operator|!=
name|current_event
operator|.
name|dwThreadId
condition|)
name|th
operator|->
name|suspend_count
operator|=
name|SuspendThread
argument_list|(
name|th
operator|->
name|h
argument_list|)
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|get_context
operator|<
literal|0
condition|)
name|th
operator|->
name|suspend_count
operator|=
operator|-
literal|1
expr_stmt|;
name|th
operator|->
name|reload_context
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|th
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Add a thread to the thread list */
end_comment

begin_function
specifier|static
name|thread_info
modifier|*
name|child_add_thread
parameter_list|(
name|DWORD
name|id
parameter_list|,
name|HANDLE
name|h
parameter_list|)
block|{
name|thread_info
modifier|*
name|th
decl_stmt|;
if|if
condition|(
operator|(
name|th
operator|=
name|thread_rec
argument_list|(
name|id
argument_list|,
name|FALSE
argument_list|)
operator|)
condition|)
return|return
name|th
return|;
name|th
operator|=
operator|(
name|thread_info
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|th
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|th
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|th
argument_list|)
argument_list|)
expr_stmt|;
name|th
operator|->
name|id
operator|=
name|id
expr_stmt|;
name|th
operator|->
name|h
operator|=
name|h
expr_stmt|;
name|th
operator|->
name|next
operator|=
name|thread_head
operator|.
name|next
expr_stmt|;
name|thread_head
operator|.
name|next
operator|=
name|th
expr_stmt|;
name|add_thread
argument_list|(
name|pid_to_ptid
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set the debug registers for the new thread in they are used.  */
if|if
condition|(
name|debug_registers_used
condition|)
block|{
comment|/* Only change the value of the debug registers.  */
name|th
operator|->
name|context
operator|.
name|ContextFlags
operator|=
name|CONTEXT_DEBUG_REGISTERS
expr_stmt|;
name|CHECK
argument_list|(
name|GetThreadContext
argument_list|(
name|th
operator|->
name|h
argument_list|,
operator|&
name|th
operator|->
name|context
argument_list|)
argument_list|)
expr_stmt|;
name|th
operator|->
name|context
operator|.
name|Dr0
operator|=
name|dr
index|[
literal|0
index|]
expr_stmt|;
name|th
operator|->
name|context
operator|.
name|Dr1
operator|=
name|dr
index|[
literal|1
index|]
expr_stmt|;
name|th
operator|->
name|context
operator|.
name|Dr2
operator|=
name|dr
index|[
literal|2
index|]
expr_stmt|;
name|th
operator|->
name|context
operator|.
name|Dr3
operator|=
name|dr
index|[
literal|3
index|]
expr_stmt|;
comment|/* th->context.Dr6 = dr[6];       FIXME: should we set dr6 also ?? */
name|th
operator|->
name|context
operator|.
name|Dr7
operator|=
name|dr
index|[
literal|7
index|]
expr_stmt|;
name|CHECK
argument_list|(
name|SetThreadContext
argument_list|(
name|th
operator|->
name|h
argument_list|,
operator|&
name|th
operator|->
name|context
argument_list|)
argument_list|)
expr_stmt|;
name|th
operator|->
name|context
operator|.
name|ContextFlags
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|th
return|;
block|}
end_function

begin_comment
comment|/* Clear out any old thread list and reintialize it to a    pristine state. */
end_comment

begin_function
specifier|static
name|void
name|child_init_thread_list
parameter_list|(
name|void
parameter_list|)
block|{
name|thread_info
modifier|*
name|th
init|=
operator|&
name|thread_head
decl_stmt|;
name|DEBUG_EVENTS
argument_list|(
operator|(
literal|"gdb: child_init_thread_list\n"
operator|)
argument_list|)
expr_stmt|;
name|init_thread_list
argument_list|()
expr_stmt|;
while|while
condition|(
name|th
operator|->
name|next
operator|!=
name|NULL
condition|)
block|{
name|thread_info
modifier|*
name|here
init|=
name|th
operator|->
name|next
decl_stmt|;
name|th
operator|->
name|next
operator|=
name|here
operator|->
name|next
expr_stmt|;
operator|(
name|void
operator|)
name|CloseHandle
argument_list|(
name|here
operator|->
name|h
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|here
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Delete a thread from the list of threads */
end_comment

begin_function
specifier|static
name|void
name|child_delete_thread
parameter_list|(
name|DWORD
name|id
parameter_list|)
block|{
name|thread_info
modifier|*
name|th
decl_stmt|;
if|if
condition|(
name|info_verbose
condition|)
name|printf_unfiltered
argument_list|(
literal|"[Deleting %s]\n"
argument_list|,
name|target_pid_to_str
argument_list|(
name|pid_to_ptid
argument_list|(
name|id
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|delete_thread
argument_list|(
name|pid_to_ptid
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|th
operator|=
operator|&
name|thread_head
init|;
name|th
operator|->
name|next
operator|!=
name|NULL
operator|&&
name|th
operator|->
name|next
operator|->
name|id
operator|!=
name|id
condition|;
name|th
operator|=
name|th
operator|->
name|next
control|)
continue|continue;
if|if
condition|(
name|th
operator|->
name|next
operator|!=
name|NULL
condition|)
block|{
name|thread_info
modifier|*
name|here
init|=
name|th
operator|->
name|next
decl_stmt|;
name|th
operator|->
name|next
operator|=
name|here
operator|->
name|next
expr_stmt|;
name|CloseHandle
argument_list|(
name|here
operator|->
name|h
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|here
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|do_child_fetch_inferior_registers
parameter_list|(
name|int
name|r
parameter_list|)
block|{
name|char
modifier|*
name|context_offset
init|=
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|current_thread
operator|->
name|context
operator|)
operator|+
name|mappings
index|[
name|r
index|]
decl_stmt|;
name|long
name|l
decl_stmt|;
if|if
condition|(
operator|!
name|current_thread
condition|)
return|return;
comment|/* Windows sometimes uses a non-existent thread id in its 		   events */
if|if
condition|(
name|current_thread
operator|->
name|reload_context
condition|)
block|{
name|thread_info
modifier|*
name|th
init|=
name|current_thread
decl_stmt|;
name|th
operator|->
name|context
operator|.
name|ContextFlags
operator|=
name|CONTEXT_DEBUGGER_DR
expr_stmt|;
name|GetThreadContext
argument_list|(
name|th
operator|->
name|h
argument_list|,
operator|&
name|th
operator|->
name|context
argument_list|)
expr_stmt|;
comment|/* Copy dr values from that thread.  */
name|dr
index|[
literal|0
index|]
operator|=
name|th
operator|->
name|context
operator|.
name|Dr0
expr_stmt|;
name|dr
index|[
literal|1
index|]
operator|=
name|th
operator|->
name|context
operator|.
name|Dr1
expr_stmt|;
name|dr
index|[
literal|2
index|]
operator|=
name|th
operator|->
name|context
operator|.
name|Dr2
expr_stmt|;
name|dr
index|[
literal|3
index|]
operator|=
name|th
operator|->
name|context
operator|.
name|Dr3
expr_stmt|;
name|dr
index|[
literal|6
index|]
operator|=
name|th
operator|->
name|context
operator|.
name|Dr6
expr_stmt|;
name|dr
index|[
literal|7
index|]
operator|=
name|th
operator|->
name|context
operator|.
name|Dr7
expr_stmt|;
name|current_thread
operator|->
name|reload_context
operator|=
literal|0
expr_stmt|;
block|}
define|#
directive|define
name|I387_ST0_REGNUM
value|I386_ST0_REGNUM
if|if
condition|(
name|r
operator|==
name|I387_FISEG_REGNUM
condition|)
block|{
name|l
operator|=
operator|*
operator|(
operator|(
name|long
operator|*
operator|)
name|context_offset
operator|)
operator|&
literal|0xffff
expr_stmt|;
name|supply_register
argument_list|(
name|r
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|l
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r
operator|==
name|I387_FOP_REGNUM
condition|)
block|{
name|l
operator|=
operator|(
operator|*
operator|(
operator|(
name|long
operator|*
operator|)
name|context_offset
operator|)
operator|>>
literal|16
operator|)
operator|&
operator|(
operator|(
literal|1
operator|<<
literal|11
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
name|supply_register
argument_list|(
name|r
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|l
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r
operator|>=
literal|0
condition|)
name|supply_register
argument_list|(
name|r
argument_list|,
name|context_offset
argument_list|)
expr_stmt|;
else|else
block|{
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
name|NUM_REGS
condition|;
name|r
operator|++
control|)
name|do_child_fetch_inferior_registers
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
undef|#
directive|undef
name|I387_ST0_REGNUM
block|}
end_function

begin_function
specifier|static
name|void
name|child_fetch_inferior_registers
parameter_list|(
name|int
name|r
parameter_list|)
block|{
name|current_thread
operator|=
name|thread_rec
argument_list|(
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* Check if current_thread exists.  Windows sometimes uses a non-existent      thread id in its events */
if|if
condition|(
name|current_thread
condition|)
name|do_child_fetch_inferior_registers
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_child_store_inferior_registers
parameter_list|(
name|int
name|r
parameter_list|)
block|{
if|if
condition|(
operator|!
name|current_thread
condition|)
comment|/* Windows sometimes uses a non-existent thread id in its events */
empty_stmt|;
elseif|else
if|if
condition|(
name|r
operator|>=
literal|0
condition|)
name|regcache_collect
argument_list|(
name|r
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|current_thread
operator|->
name|context
operator|)
operator|+
name|mappings
index|[
name|r
index|]
argument_list|)
expr_stmt|;
else|else
block|{
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
name|NUM_REGS
condition|;
name|r
operator|++
control|)
name|do_child_store_inferior_registers
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Store a new register value into the current thread context */
end_comment

begin_function
specifier|static
name|void
name|child_store_inferior_registers
parameter_list|(
name|int
name|r
parameter_list|)
block|{
name|current_thread
operator|=
name|thread_rec
argument_list|(
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* Check if current_thread exists.  Windows sometimes uses a non-existent      thread id in its events */
if|if
condition|(
name|current_thread
condition|)
name|do_child_store_inferior_registers
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|psapi_loaded
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|HMODULE
name|psapi_module_handle
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|BOOL
name|WINAPI
function_decl|(
modifier|*
name|psapi_EnumProcessModules
function_decl|)
parameter_list|(
name|HANDLE
parameter_list|,
name|HMODULE
modifier|*
parameter_list|,
name|DWORD
parameter_list|,
name|LPDWORD
parameter_list|)
init|=
name|NULL
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|BOOL
name|WINAPI
function_decl|(
modifier|*
name|psapi_GetModuleInformation
function_decl|)
parameter_list|(
name|HANDLE
parameter_list|,
name|HMODULE
parameter_list|,
name|LPMODULEINFO
parameter_list|,
name|DWORD
parameter_list|)
init|=
name|NULL
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|DWORD
name|WINAPI
function_decl|(
modifier|*
name|psapi_GetModuleFileNameExA
function_decl|)
parameter_list|(
name|HANDLE
parameter_list|,
name|HMODULE
parameter_list|,
name|LPSTR
parameter_list|,
name|DWORD
parameter_list|)
init|=
name|NULL
function_decl|;
end_function_decl

begin_function
name|int
name|psapi_get_dll_name
parameter_list|(
name|DWORD
name|BaseAddress
parameter_list|,
name|char
modifier|*
name|dll_name_ret
parameter_list|)
block|{
name|DWORD
name|len
decl_stmt|;
name|MODULEINFO
name|mi
decl_stmt|;
name|int
name|i
decl_stmt|;
name|HMODULE
name|dh_buf
index|[
literal|1
index|]
decl_stmt|;
name|HMODULE
modifier|*
name|DllHandle
init|=
name|dh_buf
decl_stmt|;
name|DWORD
name|cbNeeded
decl_stmt|;
name|BOOL
name|ok
decl_stmt|;
if|if
condition|(
operator|!
name|psapi_loaded
operator|||
name|psapi_EnumProcessModules
operator|==
name|NULL
operator|||
name|psapi_GetModuleInformation
operator|==
name|NULL
operator|||
name|psapi_GetModuleFileNameExA
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|psapi_loaded
condition|)
goto|goto
name|failed
goto|;
name|psapi_loaded
operator|=
literal|1
expr_stmt|;
name|psapi_module_handle
operator|=
name|LoadLibrary
argument_list|(
literal|"psapi.dll"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|psapi_module_handle
condition|)
block|{
comment|/* printf_unfiltered ("error loading psapi.dll: %u", GetLastError ()); */
goto|goto
name|failed
goto|;
block|}
name|psapi_EnumProcessModules
operator|=
name|GetProcAddress
argument_list|(
name|psapi_module_handle
argument_list|,
literal|"EnumProcessModules"
argument_list|)
expr_stmt|;
name|psapi_GetModuleInformation
operator|=
name|GetProcAddress
argument_list|(
name|psapi_module_handle
argument_list|,
literal|"GetModuleInformation"
argument_list|)
expr_stmt|;
name|psapi_GetModuleFileNameExA
operator|=
operator|(
name|void
operator|*
operator|)
name|GetProcAddress
argument_list|(
name|psapi_module_handle
argument_list|,
literal|"GetModuleFileNameExA"
argument_list|)
expr_stmt|;
if|if
condition|(
name|psapi_EnumProcessModules
operator|==
name|NULL
operator|||
name|psapi_GetModuleInformation
operator|==
name|NULL
operator|||
name|psapi_GetModuleFileNameExA
operator|==
name|NULL
condition|)
goto|goto
name|failed
goto|;
block|}
name|cbNeeded
operator|=
literal|0
expr_stmt|;
name|ok
operator|=
call|(
modifier|*
name|psapi_EnumProcessModules
call|)
argument_list|(
name|current_process_handle
argument_list|,
name|DllHandle
argument_list|,
sizeof|sizeof
argument_list|(
name|HMODULE
argument_list|)
argument_list|,
operator|&
name|cbNeeded
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
operator|||
operator|!
name|cbNeeded
condition|)
goto|goto
name|failed
goto|;
name|DllHandle
operator|=
operator|(
name|HMODULE
operator|*
operator|)
name|alloca
argument_list|(
name|cbNeeded
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DllHandle
condition|)
goto|goto
name|failed
goto|;
name|ok
operator|=
call|(
modifier|*
name|psapi_EnumProcessModules
call|)
argument_list|(
name|current_process_handle
argument_list|,
name|DllHandle
argument_list|,
name|cbNeeded
argument_list|,
operator|&
name|cbNeeded
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
goto|goto
name|failed
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
call|(
name|int
call|)
argument_list|(
name|cbNeeded
operator|/
sizeof|sizeof
argument_list|(
name|HMODULE
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
call|(
modifier|*
name|psapi_GetModuleInformation
call|)
argument_list|(
name|current_process_handle
argument_list|,
name|DllHandle
index|[
name|i
index|]
argument_list|,
operator|&
name|mi
argument_list|,
sizeof|sizeof
argument_list|(
name|mi
argument_list|)
argument_list|)
condition|)
name|error
argument_list|(
literal|"Can't get module info"
argument_list|)
expr_stmt|;
name|len
operator|=
call|(
modifier|*
name|psapi_GetModuleFileNameExA
call|)
argument_list|(
name|current_process_handle
argument_list|,
name|DllHandle
index|[
name|i
index|]
argument_list|,
name|dll_name_ret
argument_list|,
name|MAX_PATH
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Error getting dll name: %u\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|GetLastError
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
call|(
name|DWORD
call|)
argument_list|(
name|mi
operator|.
name|lpBaseOfDll
argument_list|)
operator|==
name|BaseAddress
condition|)
return|return
literal|1
return|;
block|}
name|failed
label|:
name|dll_name_ret
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Encapsulate the information required in a call to    symbol_file_add_args */
end_comment

begin_struct
struct|struct
name|safe_symbol_file_add_args
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
name|struct
name|section_addr_info
modifier|*
name|addrs
decl_stmt|;
name|int
name|mainline
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|struct
name|ui_file
modifier|*
name|err
decl_stmt|,
modifier|*
name|out
decl_stmt|;
name|struct
name|objfile
modifier|*
name|ret
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Maintain a linked list of "so" information. */
end_comment

begin_struct
struct|struct
name|so_stuff
block|{
name|struct
name|so_stuff
modifier|*
name|next
decl_stmt|;
name|DWORD
name|load_addr
decl_stmt|;
name|DWORD
name|end_addr
decl_stmt|;
name|int
name|loaded
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|char
name|name
index|[
literal|1
index|]
decl_stmt|;
block|}
name|solib_start
struct|,
modifier|*
name|solib_end
struct|;
end_struct

begin_comment
comment|/* Call symbol_file_add with stderr redirected.  We don't care if there    are errors. */
end_comment

begin_function
specifier|static
name|int
name|safe_symbol_file_add_stub
parameter_list|(
name|void
modifier|*
name|argv
parameter_list|)
block|{
define|#
directive|define
name|p
value|((struct safe_symbol_file_add_args *)argv)
name|struct
name|so_stuff
modifier|*
name|so
init|=
operator|&
name|solib_start
decl_stmt|;
while|while
condition|(
operator|(
name|so
operator|=
name|so
operator|->
name|next
operator|)
condition|)
if|if
condition|(
name|so
operator|->
name|loaded
operator|&&
name|strcasecmp
argument_list|(
name|so
operator|->
name|name
argument_list|,
name|p
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|p
operator|->
name|ret
operator|=
name|symbol_file_add
argument_list|(
name|p
operator|->
name|name
argument_list|,
name|p
operator|->
name|from_tty
argument_list|,
name|p
operator|->
name|addrs
argument_list|,
name|p
operator|->
name|mainline
argument_list|,
name|p
operator|->
name|flags
argument_list|)
expr_stmt|;
return|return
operator|!
operator|!
name|p
operator|->
name|ret
return|;
undef|#
directive|undef
name|p
block|}
end_function

begin_comment
comment|/* Restore gdb's stderr after calling symbol_file_add */
end_comment

begin_function
specifier|static
name|void
name|safe_symbol_file_add_cleanup
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
define|#
directive|define
name|sp
value|((struct safe_symbol_file_add_args *)p)
name|gdb_flush
argument_list|(
name|gdb_stderr
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
name|ui_file_delete
argument_list|(
name|gdb_stderr
argument_list|)
expr_stmt|;
name|ui_file_delete
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
name|gdb_stderr
operator|=
name|sp
operator|->
name|err
expr_stmt|;
name|gdb_stdout
operator|=
name|sp
operator|->
name|out
expr_stmt|;
undef|#
directive|undef
name|sp
block|}
end_function

begin_comment
comment|/* symbol_file_add wrapper that prevents errors from being displayed. */
end_comment

begin_function
specifier|static
name|struct
name|objfile
modifier|*
name|safe_symbol_file_add
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|from_tty
parameter_list|,
name|struct
name|section_addr_info
modifier|*
name|addrs
parameter_list|,
name|int
name|mainline
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|safe_symbol_file_add_args
name|p
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|cleanup
decl_stmt|;
name|cleanup
operator|=
name|make_cleanup
argument_list|(
name|safe_symbol_file_add_cleanup
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
name|p
operator|.
name|err
operator|=
name|gdb_stderr
expr_stmt|;
name|p
operator|.
name|out
operator|=
name|gdb_stdout
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stderr
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
name|gdb_stderr
operator|=
name|ui_file_new
argument_list|()
expr_stmt|;
name|gdb_stdout
operator|=
name|ui_file_new
argument_list|()
expr_stmt|;
name|p
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|p
operator|.
name|from_tty
operator|=
name|from_tty
expr_stmt|;
name|p
operator|.
name|addrs
operator|=
name|addrs
expr_stmt|;
name|p
operator|.
name|mainline
operator|=
name|mainline
expr_stmt|;
name|p
operator|.
name|flags
operator|=
name|flags
expr_stmt|;
name|catch_errors
argument_list|(
name|safe_symbol_file_add_stub
argument_list|,
operator|&
name|p
argument_list|,
literal|""
argument_list|,
name|RETURN_MASK_ERROR
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|cleanup
argument_list|)
expr_stmt|;
return|return
name|p
operator|.
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Remember the maximum DLL length for printing in info dll command. */
end_comment

begin_decl_stmt
name|int
name|max_dll_name_len
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|register_loaded_dll
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|DWORD
name|load_addr
parameter_list|)
block|{
name|struct
name|so_stuff
modifier|*
name|so
decl_stmt|;
name|char
name|ppath
index|[
name|MAX_PATH
operator|+
literal|1
index|]
decl_stmt|;
name|char
name|buf
index|[
name|MAX_PATH
operator|+
literal|1
index|]
decl_stmt|;
name|char
name|cwd
index|[
name|MAX_PATH
operator|+
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|WIN32_FIND_DATA
name|w32_fd
decl_stmt|;
name|HANDLE
name|h
init|=
name|FindFirstFile
argument_list|(
name|name
argument_list|,
operator|&
name|w32_fd
argument_list|)
decl_stmt|;
name|MEMORY_BASIC_INFORMATION
name|m
decl_stmt|;
name|size_t
name|len
decl_stmt|;
if|if
condition|(
name|h
operator|==
name|INVALID_HANDLE_VALUE
condition|)
name|strcpy
argument_list|(
name|buf
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
block|{
name|FindClose
argument_list|(
name|h
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|GetCurrentDirectory
argument_list|(
name|MAX_PATH
operator|+
literal|1
argument_list|,
name|cwd
argument_list|)
condition|)
block|{
name|p
operator|=
name|strrchr
argument_list|(
name|buf
argument_list|,
literal|'\\'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
name|p
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|SetCurrentDirectory
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|GetFullPathName
argument_list|(
name|w32_fd
operator|.
name|cFileName
argument_list|,
name|MAX_PATH
argument_list|,
name|buf
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
name|SetCurrentDirectory
argument_list|(
name|cwd
argument_list|)
expr_stmt|;
block|}
block|}
name|cygwin_conv_to_posix_path
argument_list|(
name|buf
argument_list|,
name|ppath
argument_list|)
expr_stmt|;
name|so
operator|=
operator|(
expr|struct
name|so_stuff
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|so_stuff
argument_list|)
operator|+
name|strlen
argument_list|(
name|ppath
argument_list|)
operator|+
literal|8
operator|+
literal|1
argument_list|)
expr_stmt|;
name|so
operator|->
name|loaded
operator|=
literal|0
expr_stmt|;
name|so
operator|->
name|load_addr
operator|=
name|load_addr
expr_stmt|;
if|if
condition|(
name|VirtualQueryEx
argument_list|(
name|current_process_handle
argument_list|,
operator|(
name|void
operator|*
operator|)
name|load_addr
argument_list|,
operator|&
name|m
argument_list|,
sizeof|sizeof
argument_list|(
name|m
argument_list|)
argument_list|)
condition|)
name|so
operator|->
name|end_addr
operator|=
operator|(
name|DWORD
operator|)
name|m
operator|.
name|AllocationBase
operator|+
name|m
operator|.
name|RegionSize
expr_stmt|;
else|else
name|so
operator|->
name|end_addr
operator|=
name|load_addr
operator|+
literal|0x2000
expr_stmt|;
comment|/* completely arbitrary */
name|so
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|so
operator|->
name|objfile
operator|=
name|NULL
expr_stmt|;
name|strcpy
argument_list|(
name|so
operator|->
name|name
argument_list|,
name|ppath
argument_list|)
expr_stmt|;
name|solib_end
operator|->
name|next
operator|=
name|so
expr_stmt|;
name|solib_end
operator|=
name|so
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|ppath
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|max_dll_name_len
condition|)
name|max_dll_name_len
operator|=
name|len
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|get_image_name
parameter_list|(
name|HANDLE
name|h
parameter_list|,
name|void
modifier|*
name|address
parameter_list|,
name|int
name|unicode
parameter_list|)
block|{
specifier|static
name|char
name|buf
index|[
operator|(
literal|2
operator|*
name|MAX_PATH
operator|)
operator|+
literal|1
index|]
decl_stmt|;
name|DWORD
name|size
init|=
name|unicode
condition|?
sizeof|sizeof
argument_list|(
name|WCHAR
argument_list|)
else|:
sizeof|sizeof
argument_list|(
name|char
argument_list|)
decl_stmt|;
name|char
modifier|*
name|address_ptr
decl_stmt|;
name|int
name|len
init|=
literal|0
decl_stmt|;
name|char
name|b
index|[
literal|2
index|]
decl_stmt|;
name|DWORD
name|done
decl_stmt|;
comment|/* Attempt to read the name of the dll that was detected.      This is documented to work only when actively debugging      a program.  It will not work for attached processes. */
if|if
condition|(
name|address
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* See if we could read the address of a string, and that the      address isn't null. */
if|if
condition|(
operator|!
name|ReadProcessMemory
argument_list|(
name|h
argument_list|,
name|address
argument_list|,
operator|&
name|address_ptr
argument_list|,
sizeof|sizeof
argument_list|(
name|address_ptr
argument_list|)
argument_list|,
operator|&
name|done
argument_list|)
operator|||
name|done
operator|!=
sizeof|sizeof
argument_list|(
name|address_ptr
argument_list|)
operator|||
operator|!
name|address_ptr
condition|)
return|return
name|NULL
return|;
comment|/* Find the length of the string */
while|while
condition|(
name|ReadProcessMemory
argument_list|(
name|h
argument_list|,
name|address_ptr
operator|+
name|len
operator|++
operator|*
name|size
argument_list|,
operator|&
name|b
argument_list|,
name|size
argument_list|,
operator|&
name|done
argument_list|)
operator|&&
operator|(
name|b
index|[
literal|0
index|]
operator|!=
literal|0
operator|||
name|b
index|[
name|size
operator|-
literal|1
index|]
operator|!=
literal|0
operator|)
operator|&&
name|done
operator|==
name|size
condition|)
continue|continue;
if|if
condition|(
operator|!
name|unicode
condition|)
name|ReadProcessMemory
argument_list|(
name|h
argument_list|,
name|address_ptr
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
operator|&
name|done
argument_list|)
expr_stmt|;
else|else
block|{
name|WCHAR
modifier|*
name|unicode_address
init|=
operator|(
name|WCHAR
operator|*
operator|)
name|alloca
argument_list|(
name|len
operator|*
sizeof|sizeof
argument_list|(
name|WCHAR
argument_list|)
argument_list|)
decl_stmt|;
name|ReadProcessMemory
argument_list|(
name|h
argument_list|,
name|address_ptr
argument_list|,
name|unicode_address
argument_list|,
name|len
operator|*
sizeof|sizeof
argument_list|(
name|WCHAR
argument_list|)
argument_list|,
operator|&
name|done
argument_list|)
expr_stmt|;
name|WideCharToMultiByte
argument_list|(
name|CP_ACP
argument_list|,
literal|0
argument_list|,
name|unicode_address
argument_list|,
name|len
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/* Wait for child to do something.  Return pid of child, or -1 in case    of error; store status through argument pointer OURSTATUS.  */
end_comment

begin_function
specifier|static
name|int
name|handle_load_dll
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
block|{
name|LOAD_DLL_DEBUG_INFO
modifier|*
name|event
init|=
operator|&
name|current_event
operator|.
name|u
operator|.
name|LoadDll
decl_stmt|;
name|char
name|dll_buf
index|[
name|MAX_PATH
operator|+
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|dll_name
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|dll_buf
index|[
literal|0
index|]
operator|=
name|dll_buf
index|[
sizeof|sizeof
argument_list|(
name|dll_buf
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|psapi_get_dll_name
argument_list|(
call|(
name|DWORD
call|)
argument_list|(
name|event
operator|->
name|lpBaseOfDll
argument_list|)
argument_list|,
name|dll_buf
argument_list|)
condition|)
name|dll_buf
index|[
literal|0
index|]
operator|=
name|dll_buf
index|[
sizeof|sizeof
argument_list|(
name|dll_buf
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|dll_name
operator|=
name|dll_buf
expr_stmt|;
if|if
condition|(
operator|*
name|dll_name
operator|==
literal|'\0'
condition|)
name|dll_name
operator|=
name|get_image_name
argument_list|(
name|current_process_handle
argument_list|,
name|event
operator|->
name|lpImageName
argument_list|,
name|event
operator|->
name|fUnicode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dll_name
condition|)
return|return
literal|1
return|;
name|register_loaded_dll
argument_list|(
name|dll_name
argument_list|,
operator|(
name|DWORD
operator|)
name|event
operator|->
name|lpBaseOfDll
operator|+
literal|0x1000
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|handle_unload_dll
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
block|{
name|DWORD
name|lpBaseOfDll
init|=
operator|(
name|DWORD
operator|)
name|current_event
operator|.
name|u
operator|.
name|UnloadDll
operator|.
name|lpBaseOfDll
operator|+
literal|0x1000
decl_stmt|;
name|struct
name|so_stuff
modifier|*
name|so
decl_stmt|;
for|for
control|(
name|so
operator|=
operator|&
name|solib_start
init|;
name|so
operator|->
name|next
operator|!=
name|NULL
condition|;
name|so
operator|=
name|so
operator|->
name|next
control|)
if|if
condition|(
name|so
operator|->
name|next
operator|->
name|load_addr
operator|==
name|lpBaseOfDll
condition|)
block|{
name|struct
name|so_stuff
modifier|*
name|sodel
init|=
name|so
operator|->
name|next
decl_stmt|;
name|so
operator|->
name|next
operator|=
name|sodel
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|so
operator|->
name|next
condition|)
name|solib_end
operator|=
name|so
expr_stmt|;
if|if
condition|(
name|sodel
operator|->
name|objfile
condition|)
name|free_objfile
argument_list|(
name|sodel
operator|->
name|objfile
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|sodel
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|error
argument_list|(
literal|"Error: dll starting at 0x%lx not found.\n"
argument_list|,
operator|(
name|DWORD
operator|)
name|lpBaseOfDll
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|solib_address
parameter_list|(
name|CORE_ADDR
name|address
parameter_list|)
block|{
name|struct
name|so_stuff
modifier|*
name|so
decl_stmt|;
for|for
control|(
name|so
operator|=
operator|&
name|solib_start
init|;
name|so
operator|->
name|next
operator|!=
name|NULL
condition|;
name|so
operator|=
name|so
operator|->
name|next
control|)
if|if
condition|(
name|address
operator|>=
name|so
operator|->
name|load_addr
operator|&&
name|address
operator|<=
name|so
operator|->
name|end_addr
condition|)
return|return
name|so
operator|->
name|name
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Return name of last loaded DLL. */
end_comment

begin_function
name|char
modifier|*
name|child_solib_loaded_library_pathname
parameter_list|(
name|int
name|pid
parameter_list|)
block|{
return|return
operator|!
name|solib_end
operator|||
operator|!
name|solib_end
operator|->
name|name
index|[
literal|0
index|]
condition|?
name|NULL
else|:
name|solib_end
operator|->
name|name
return|;
block|}
end_function

begin_comment
comment|/* Clear list of loaded DLLs. */
end_comment

begin_function
name|void
name|child_clear_solibs
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|so_stuff
modifier|*
name|so
decl_stmt|,
modifier|*
name|so1
init|=
name|solib_start
operator|.
name|next
decl_stmt|;
while|while
condition|(
operator|(
name|so
operator|=
name|so1
operator|)
operator|!=
name|NULL
condition|)
block|{
name|so1
operator|=
name|so
operator|->
name|next
expr_stmt|;
name|xfree
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
name|solib_start
operator|.
name|next
operator|=
name|NULL
expr_stmt|;
name|solib_start
operator|.
name|objfile
operator|=
name|NULL
expr_stmt|;
name|solib_end
operator|=
operator|&
name|solib_start
expr_stmt|;
name|max_dll_name_len
operator|=
sizeof|sizeof
argument_list|(
literal|"DLL Name"
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get the loaded address of all sections, given that .text was loaded    at text_load. Assumes that all sections are subject to the same    relocation offset. Returns NULL if problems occur or if the    sections were not relocated. */
end_comment

begin_function
specifier|static
name|struct
name|section_addr_info
modifier|*
name|get_relocated_section_addrs
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|CORE_ADDR
name|text_load
parameter_list|)
block|{
name|struct
name|section_addr_info
modifier|*
name|result
init|=
name|NULL
decl_stmt|;
name|int
name|section_count
init|=
name|bfd_count_sections
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|asection
modifier|*
name|text_section
init|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".text"
argument_list|)
decl_stmt|;
name|CORE_ADDR
name|text_vma
decl_stmt|;
if|if
condition|(
operator|!
name|text_section
condition|)
block|{
comment|/* Couldn't get the .text section. Weird. */
block|}
elseif|else
if|if
condition|(
name|text_load
operator|==
operator|(
name|text_vma
operator|=
name|bfd_get_section_vma
argument_list|(
name|abfd
argument_list|,
name|text_section
argument_list|)
operator|)
condition|)
block|{
comment|/* DLL wasn't relocated. */
block|}
else|else
block|{
comment|/* Figure out all sections' loaded addresses. The offset here is 	 such that taking a bfd_get_section_vma() result and adding 	 offset will give the real load address of the section. */
name|CORE_ADDR
name|offset
init|=
name|text_load
operator|-
name|text_vma
decl_stmt|;
name|struct
name|section_table
modifier|*
name|table_start
init|=
name|NULL
decl_stmt|;
name|struct
name|section_table
modifier|*
name|table_end
init|=
name|NULL
decl_stmt|;
name|struct
name|section_table
modifier|*
name|iter
init|=
name|NULL
decl_stmt|;
name|build_section_table
argument_list|(
name|abfd
argument_list|,
operator|&
name|table_start
argument_list|,
operator|&
name|table_end
argument_list|)
expr_stmt|;
for|for
control|(
name|iter
operator|=
name|table_start
init|;
name|iter
operator|<
name|table_end
condition|;
operator|++
name|iter
control|)
block|{
comment|/* Relocated addresses. */
name|iter
operator|->
name|addr
operator|+=
name|offset
expr_stmt|;
name|iter
operator|->
name|endaddr
operator|+=
name|offset
expr_stmt|;
block|}
name|result
operator|=
name|build_section_addr_info_from_section_table
argument_list|(
name|table_start
argument_list|,
name|table_end
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|table_start
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Add DLL symbol information. */
end_comment

begin_function
specifier|static
name|struct
name|objfile
modifier|*
name|solib_symbols_add
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|from_tty
parameter_list|,
name|CORE_ADDR
name|load_addr
parameter_list|)
block|{
name|struct
name|section_addr_info
modifier|*
name|addrs
init|=
name|NULL
decl_stmt|;
specifier|static
name|struct
name|objfile
modifier|*
name|result
init|=
name|NULL
decl_stmt|;
name|bfd
modifier|*
name|abfd
init|=
name|NULL
decl_stmt|;
comment|/* The symbols in a dll are offset by 0x1000, which is the      the offset from 0 of the first byte in an image - because      of the file header and the section alignment. */
if|if
condition|(
operator|!
name|name
operator|||
operator|!
name|name
index|[
literal|0
index|]
condition|)
return|return
name|NULL
return|;
name|abfd
operator|=
name|bfd_openr
argument_list|(
name|name
argument_list|,
literal|"pei-i386"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|abfd
condition|)
block|{
comment|/* pei failed - try pe */
name|abfd
operator|=
name|bfd_openr
argument_list|(
name|name
argument_list|,
literal|"pe-i386"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|abfd
condition|)
block|{
if|if
condition|(
name|bfd_check_format
argument_list|(
name|abfd
argument_list|,
name|bfd_object
argument_list|)
condition|)
block|{
name|addrs
operator|=
name|get_relocated_section_addrs
argument_list|(
name|abfd
argument_list|,
name|load_addr
argument_list|)
expr_stmt|;
block|}
name|bfd_close
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|addrs
condition|)
block|{
name|result
operator|=
name|safe_symbol_file_add
argument_list|(
name|name
argument_list|,
name|from_tty
argument_list|,
name|addrs
argument_list|,
literal|0
argument_list|,
name|OBJF_SHARED
argument_list|)
expr_stmt|;
name|free_section_addr_info
argument_list|(
name|addrs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Fallback on handling just the .text section. */
name|struct
name|cleanup
modifier|*
name|my_cleanups
decl_stmt|;
name|addrs
operator|=
name|alloc_section_addr_info
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|my_cleanups
operator|=
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|addrs
argument_list|)
expr_stmt|;
name|addrs
operator|->
name|other
index|[
literal|0
index|]
operator|.
name|name
operator|=
literal|".text"
expr_stmt|;
name|addrs
operator|->
name|other
index|[
literal|0
index|]
operator|.
name|addr
operator|=
name|load_addr
expr_stmt|;
name|result
operator|=
name|safe_symbol_file_add
argument_list|(
name|name
argument_list|,
name|from_tty
argument_list|,
name|addrs
argument_list|,
literal|0
argument_list|,
name|OBJF_SHARED
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|my_cleanups
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Load DLL symbol info. */
end_comment

begin_function
name|void
name|dll_symbol_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
name|dont_repeat
argument_list|()
expr_stmt|;
if|if
condition|(
name|args
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"dll-symbols requires a file name"
argument_list|)
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|4
operator|&&
name|strcasecmp
argument_list|(
name|args
operator|+
name|n
operator|-
literal|4
argument_list|,
literal|".dll"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|char
modifier|*
name|newargs
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|n
operator|+
literal|4
operator|+
literal|1
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|newargs
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|newargs
argument_list|,
literal|".dll"
argument_list|)
expr_stmt|;
name|args
operator|=
name|newargs
expr_stmt|;
block|}
name|safe_symbol_file_add
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|OBJF_SHARED
operator||
name|OBJF_USERLOADED
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* List currently loaded DLLs. */
end_comment

begin_function
name|void
name|info_dll_command
parameter_list|(
name|char
modifier|*
name|ignore
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|so_stuff
modifier|*
name|so
init|=
operator|&
name|solib_start
decl_stmt|;
if|if
condition|(
operator|!
name|so
operator|->
name|next
condition|)
return|return;
name|printf_filtered
argument_list|(
literal|"%*s  Load Address\n"
argument_list|,
operator|-
name|max_dll_name_len
argument_list|,
literal|"DLL Name"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|so
operator|=
name|so
operator|->
name|next
operator|)
operator|!=
name|NULL
condition|)
name|printf_filtered
argument_list|(
literal|"%*s  %08lx\n"
argument_list|,
operator|-
name|max_dll_name_len
argument_list|,
name|so
operator|->
name|name
argument_list|,
name|so
operator|->
name|load_addr
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Handle DEBUG_STRING output from child process.    Cygwin prepends its messages with a "cygwin:".  Interpret this as    a Cygwin signal.  Otherwise just print the string as a warning. */
end_comment

begin_function
specifier|static
name|int
name|handle_output_debug_string
parameter_list|(
name|struct
name|target_waitstatus
modifier|*
name|ourstatus
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|gotasig
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
operator|!
name|target_read_string
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|current_event
operator|.
name|u
operator|.
name|DebugString
operator|.
name|lpDebugStringData
argument_list|,
operator|&
name|s
argument_list|,
literal|1024
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|s
operator|||
operator|!
operator|*
name|s
condition|)
return|return
name|gotasig
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
name|CYGWIN_SIGNAL_STRING
argument_list|,
sizeof|sizeof
argument_list|(
name|CYGWIN_SIGNAL_STRING
argument_list|)
operator|-
literal|1
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
literal|"cYg"
argument_list|,
literal|3
argument_list|)
operator|!=
literal|0
condition|)
name|warning
argument_list|(
literal|"%s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|sig
init|=
name|strtol
argument_list|(
name|s
operator|+
sizeof|sizeof
argument_list|(
name|CYGWIN_SIGNAL_STRING
argument_list|)
operator|-
literal|1
argument_list|,
operator|&
name|p
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|gotasig
operator|=
name|target_signal_from_host
argument_list|(
name|sig
argument_list|)
expr_stmt|;
name|ourstatus
operator|->
name|value
operator|.
name|sig
operator|=
name|gotasig
expr_stmt|;
if|if
condition|(
name|gotasig
condition|)
name|ourstatus
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_STOPPED
expr_stmt|;
block|}
name|xfree
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|gotasig
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|display_selector
parameter_list|(
name|HANDLE
name|thread
parameter_list|,
name|DWORD
name|sel
parameter_list|)
block|{
name|LDT_ENTRY
name|info
decl_stmt|;
if|if
condition|(
name|GetThreadSelectorEntry
argument_list|(
name|thread
argument_list|,
name|sel
argument_list|,
operator|&
name|info
argument_list|)
condition|)
block|{
name|int
name|base
decl_stmt|,
name|limit
decl_stmt|;
name|printf_filtered
argument_list|(
literal|"0x%03lx: "
argument_list|,
name|sel
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|.
name|HighWord
operator|.
name|Bits
operator|.
name|Pres
condition|)
block|{
name|puts_filtered
argument_list|(
literal|"Segment not present\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|base
operator|=
operator|(
name|info
operator|.
name|HighWord
operator|.
name|Bits
operator|.
name|BaseHi
operator|<<
literal|24
operator|)
operator|+
operator|(
name|info
operator|.
name|HighWord
operator|.
name|Bits
operator|.
name|BaseMid
operator|<<
literal|16
operator|)
operator|+
name|info
operator|.
name|BaseLow
expr_stmt|;
name|limit
operator|=
operator|(
name|info
operator|.
name|HighWord
operator|.
name|Bits
operator|.
name|LimitHi
operator|<<
literal|16
operator|)
operator|+
name|info
operator|.
name|LimitLow
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|HighWord
operator|.
name|Bits
operator|.
name|Granularity
condition|)
name|limit
operator|=
operator|(
name|limit
operator|<<
literal|12
operator|)
operator||
literal|0xfff
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"base=0x%08x limit=0x%08x"
argument_list|,
name|base
argument_list|,
name|limit
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|HighWord
operator|.
name|Bits
operator|.
name|Default_Big
condition|)
name|puts_filtered
argument_list|(
literal|" 32-bit "
argument_list|)
expr_stmt|;
else|else
name|puts_filtered
argument_list|(
literal|" 16-bit "
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|(
name|info
operator|.
name|HighWord
operator|.
name|Bits
operator|.
name|Type
operator|&
literal|0xf
operator|)
operator|>>
literal|1
condition|)
block|{
case|case
literal|0
case|:
name|puts_filtered
argument_list|(
literal|"Data (Read-Only, Exp-up"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|puts_filtered
argument_list|(
literal|"Data (Read/Write, Exp-up"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|puts_filtered
argument_list|(
literal|"Unused segment ("
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|puts_filtered
argument_list|(
literal|"Data (Read/Write, Exp-down"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|puts_filtered
argument_list|(
literal|"Code (Exec-Only, N.Conf"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|puts_filtered
argument_list|(
literal|"Code (Exec/Read, N.Conf"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|puts_filtered
argument_list|(
literal|"Code (Exec-Only, Conf"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|7
case|:
name|puts_filtered
argument_list|(
literal|"Code (Exec/Read, Conf"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf_filtered
argument_list|(
literal|"Unknown type 0x%x"
argument_list|,
name|info
operator|.
name|HighWord
operator|.
name|Bits
operator|.
name|Type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|info
operator|.
name|HighWord
operator|.
name|Bits
operator|.
name|Type
operator|&
literal|0x1
operator|)
operator|==
literal|0
condition|)
name|puts_filtered
argument_list|(
literal|", N.Acc"
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
literal|")\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|info
operator|.
name|HighWord
operator|.
name|Bits
operator|.
name|Type
operator|&
literal|0x10
operator|)
operator|==
literal|0
condition|)
name|puts_filtered
argument_list|(
literal|"System selector "
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Priviledge level = %d. "
argument_list|,
name|info
operator|.
name|HighWord
operator|.
name|Bits
operator|.
name|Dpl
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|HighWord
operator|.
name|Bits
operator|.
name|Granularity
condition|)
name|puts_filtered
argument_list|(
literal|"Page granular.\n"
argument_list|)
expr_stmt|;
else|else
name|puts_filtered
argument_list|(
literal|"Byte granular.\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
name|printf_filtered
argument_list|(
literal|"Invalid selector 0x%lx.\n"
argument_list|,
name|sel
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|display_selectors
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
if|if
condition|(
operator|!
name|current_thread
condition|)
block|{
name|puts_filtered
argument_list|(
literal|"Impossible to display selectors now.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|args
condition|)
block|{
name|puts_filtered
argument_list|(
literal|"Selector $cs\n"
argument_list|)
expr_stmt|;
name|display_selector
argument_list|(
name|current_thread
operator|->
name|h
argument_list|,
name|current_thread
operator|->
name|context
operator|.
name|SegCs
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
literal|"Selector $ds\n"
argument_list|)
expr_stmt|;
name|display_selector
argument_list|(
name|current_thread
operator|->
name|h
argument_list|,
name|current_thread
operator|->
name|context
operator|.
name|SegDs
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
literal|"Selector $es\n"
argument_list|)
expr_stmt|;
name|display_selector
argument_list|(
name|current_thread
operator|->
name|h
argument_list|,
name|current_thread
operator|->
name|context
operator|.
name|SegEs
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
literal|"Selector $ss\n"
argument_list|)
expr_stmt|;
name|display_selector
argument_list|(
name|current_thread
operator|->
name|h
argument_list|,
name|current_thread
operator|->
name|context
operator|.
name|SegSs
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
literal|"Selector $fs\n"
argument_list|)
expr_stmt|;
name|display_selector
argument_list|(
name|current_thread
operator|->
name|h
argument_list|,
name|current_thread
operator|->
name|context
operator|.
name|SegFs
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
literal|"Selector $gs\n"
argument_list|)
expr_stmt|;
name|display_selector
argument_list|(
name|current_thread
operator|->
name|h
argument_list|,
name|current_thread
operator|->
name|context
operator|.
name|SegGs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|sel
decl_stmt|;
name|sel
operator|=
name|parse_and_eval_long
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Selector \"%s\"\n"
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|display_selector
argument_list|(
name|current_thread
operator|->
name|h
argument_list|,
name|sel
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|cmd_list_element
modifier|*
name|info_w32_cmdlist
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|info_w32_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|help_list
argument_list|(
name|info_w32_cmdlist
argument_list|,
literal|"info w32 "
argument_list|,
name|class_info
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|DEBUG_EXCEPTION_SIMPLE
parameter_list|(
name|x
parameter_list|)
value|if (debug_exceptions) \   printf_unfiltered ("gdb: Target exception %s at 0x%08lx\n", x, \   (DWORD) current_event.u.Exception.ExceptionRecord.ExceptionAddress)
end_define

begin_function
specifier|static
name|int
name|handle_exception
parameter_list|(
name|struct
name|target_waitstatus
modifier|*
name|ourstatus
parameter_list|)
block|{
name|thread_info
modifier|*
name|th
decl_stmt|;
name|DWORD
name|code
init|=
name|current_event
operator|.
name|u
operator|.
name|Exception
operator|.
name|ExceptionRecord
operator|.
name|ExceptionCode
decl_stmt|;
name|ourstatus
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_STOPPED
expr_stmt|;
comment|/* Record the context of the current thread */
name|th
operator|=
name|thread_rec
argument_list|(
name|current_event
operator|.
name|dwThreadId
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EXCEPTION_ACCESS_VIOLATION
case|:
name|DEBUG_EXCEPTION_SIMPLE
argument_list|(
literal|"EXCEPTION_ACCESS_VIOLATION"
argument_list|)
expr_stmt|;
name|ourstatus
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_SEGV
expr_stmt|;
break|break;
case|case
name|STATUS_STACK_OVERFLOW
case|:
name|DEBUG_EXCEPTION_SIMPLE
argument_list|(
literal|"STATUS_STACK_OVERFLOW"
argument_list|)
expr_stmt|;
name|ourstatus
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_SEGV
expr_stmt|;
break|break;
case|case
name|STATUS_FLOAT_DENORMAL_OPERAND
case|:
name|DEBUG_EXCEPTION_SIMPLE
argument_list|(
literal|"STATUS_FLOAT_DENORMAL_OPERAND"
argument_list|)
expr_stmt|;
name|ourstatus
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_FPE
expr_stmt|;
break|break;
case|case
name|EXCEPTION_ARRAY_BOUNDS_EXCEEDED
case|:
name|DEBUG_EXCEPTION_SIMPLE
argument_list|(
literal|"EXCEPTION_ARRAY_BOUNDS_EXCEEDED"
argument_list|)
expr_stmt|;
name|ourstatus
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_FPE
expr_stmt|;
break|break;
case|case
name|STATUS_FLOAT_INEXACT_RESULT
case|:
name|DEBUG_EXCEPTION_SIMPLE
argument_list|(
literal|"STATUS_FLOAT_INEXACT_RESULT"
argument_list|)
expr_stmt|;
name|ourstatus
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_FPE
expr_stmt|;
break|break;
case|case
name|STATUS_FLOAT_INVALID_OPERATION
case|:
name|DEBUG_EXCEPTION_SIMPLE
argument_list|(
literal|"STATUS_FLOAT_INVALID_OPERATION"
argument_list|)
expr_stmt|;
name|ourstatus
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_FPE
expr_stmt|;
break|break;
case|case
name|STATUS_FLOAT_OVERFLOW
case|:
name|DEBUG_EXCEPTION_SIMPLE
argument_list|(
literal|"STATUS_FLOAT_OVERFLOW"
argument_list|)
expr_stmt|;
name|ourstatus
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_FPE
expr_stmt|;
break|break;
case|case
name|STATUS_FLOAT_STACK_CHECK
case|:
name|DEBUG_EXCEPTION_SIMPLE
argument_list|(
literal|"STATUS_FLOAT_STACK_CHECK"
argument_list|)
expr_stmt|;
name|ourstatus
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_FPE
expr_stmt|;
break|break;
case|case
name|STATUS_FLOAT_UNDERFLOW
case|:
name|DEBUG_EXCEPTION_SIMPLE
argument_list|(
literal|"STATUS_FLOAT_UNDERFLOW"
argument_list|)
expr_stmt|;
name|ourstatus
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_FPE
expr_stmt|;
break|break;
case|case
name|STATUS_FLOAT_DIVIDE_BY_ZERO
case|:
name|DEBUG_EXCEPTION_SIMPLE
argument_list|(
literal|"STATUS_FLOAT_DIVIDE_BY_ZERO"
argument_list|)
expr_stmt|;
name|ourstatus
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_FPE
expr_stmt|;
break|break;
case|case
name|STATUS_INTEGER_DIVIDE_BY_ZERO
case|:
name|DEBUG_EXCEPTION_SIMPLE
argument_list|(
literal|"STATUS_INTEGER_DIVIDE_BY_ZERO"
argument_list|)
expr_stmt|;
name|ourstatus
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_FPE
expr_stmt|;
break|break;
case|case
name|STATUS_INTEGER_OVERFLOW
case|:
name|DEBUG_EXCEPTION_SIMPLE
argument_list|(
literal|"STATUS_INTEGER_OVERFLOW"
argument_list|)
expr_stmt|;
name|ourstatus
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_FPE
expr_stmt|;
break|break;
case|case
name|EXCEPTION_BREAKPOINT
case|:
name|DEBUG_EXCEPTION_SIMPLE
argument_list|(
literal|"EXCEPTION_BREAKPOINT"
argument_list|)
expr_stmt|;
name|ourstatus
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_TRAP
expr_stmt|;
break|break;
case|case
name|DBG_CONTROL_C
case|:
name|DEBUG_EXCEPTION_SIMPLE
argument_list|(
literal|"DBG_CONTROL_C"
argument_list|)
expr_stmt|;
name|ourstatus
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_INT
expr_stmt|;
break|break;
case|case
name|DBG_CONTROL_BREAK
case|:
name|DEBUG_EXCEPTION_SIMPLE
argument_list|(
literal|"DBG_CONTROL_BREAK"
argument_list|)
expr_stmt|;
name|ourstatus
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_INT
expr_stmt|;
break|break;
case|case
name|EXCEPTION_SINGLE_STEP
case|:
name|DEBUG_EXCEPTION_SIMPLE
argument_list|(
literal|"EXCEPTION_SINGLE_STEP"
argument_list|)
expr_stmt|;
name|ourstatus
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_TRAP
expr_stmt|;
break|break;
case|case
name|EXCEPTION_ILLEGAL_INSTRUCTION
case|:
name|DEBUG_EXCEPTION_SIMPLE
argument_list|(
literal|"EXCEPTION_ILLEGAL_INSTRUCTION"
argument_list|)
expr_stmt|;
name|ourstatus
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_ILL
expr_stmt|;
break|break;
case|case
name|EXCEPTION_PRIV_INSTRUCTION
case|:
name|DEBUG_EXCEPTION_SIMPLE
argument_list|(
literal|"EXCEPTION_PRIV_INSTRUCTION"
argument_list|)
expr_stmt|;
name|ourstatus
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_ILL
expr_stmt|;
break|break;
case|case
name|EXCEPTION_NONCONTINUABLE_EXCEPTION
case|:
name|DEBUG_EXCEPTION_SIMPLE
argument_list|(
literal|"EXCEPTION_NONCONTINUABLE_EXCEPTION"
argument_list|)
expr_stmt|;
name|ourstatus
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_ILL
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|current_event
operator|.
name|u
operator|.
name|Exception
operator|.
name|dwFirstChance
condition|)
return|return
literal|0
return|;
name|printf_unfiltered
argument_list|(
literal|"gdb: unknown target exception 0x%08lx at 0x%08lx\n"
argument_list|,
name|current_event
operator|.
name|u
operator|.
name|Exception
operator|.
name|ExceptionRecord
operator|.
name|ExceptionCode
argument_list|,
operator|(
name|DWORD
operator|)
name|current_event
operator|.
name|u
operator|.
name|Exception
operator|.
name|ExceptionRecord
operator|.
name|ExceptionAddress
argument_list|)
expr_stmt|;
name|ourstatus
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_UNKNOWN
expr_stmt|;
break|break;
block|}
name|exception_count
operator|++
expr_stmt|;
name|last_sig
operator|=
name|ourstatus
operator|->
name|value
operator|.
name|sig
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Resume all artificially suspended threads if we are continuing    execution */
end_comment

begin_function
specifier|static
name|BOOL
name|child_continue
parameter_list|(
name|DWORD
name|continue_status
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|thread_info
modifier|*
name|th
decl_stmt|;
name|BOOL
name|res
decl_stmt|;
name|DEBUG_EVENTS
argument_list|(
operator|(
literal|"ContinueDebugEvent (cpid=%ld, ctid=%ld, %s);\n"
operator|,
name|current_event
operator|.
name|dwProcessId
operator|,
name|current_event
operator|.
name|dwThreadId
operator|,
name|continue_status
operator|==
name|DBG_CONTINUE
condition|?
literal|"DBG_CONTINUE"
else|:
literal|"DBG_EXCEPTION_NOT_HANDLED"
operator|)
argument_list|)
expr_stmt|;
name|res
operator|=
name|ContinueDebugEvent
argument_list|(
name|current_event
operator|.
name|dwProcessId
argument_list|,
name|current_event
operator|.
name|dwThreadId
argument_list|,
name|continue_status
argument_list|)
expr_stmt|;
name|continue_status
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|res
condition|)
for|for
control|(
name|th
operator|=
operator|&
name|thread_head
init|;
operator|(
name|th
operator|=
name|th
operator|->
name|next
operator|)
operator|!=
name|NULL
condition|;
control|)
if|if
condition|(
operator|(
operator|(
name|id
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|id
operator|==
operator|(
name|int
operator|)
name|th
operator|->
name|id
operator|)
operator|)
operator|&&
name|th
operator|->
name|suspend_count
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|th
operator|->
name|suspend_count
condition|;
name|i
operator|++
control|)
operator|(
name|void
operator|)
name|ResumeThread
argument_list|(
name|th
operator|->
name|h
argument_list|)
expr_stmt|;
name|th
operator|->
name|suspend_count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|debug_registers_changed
condition|)
block|{
comment|/* Only change the value of the debug registers */
name|th
operator|->
name|context
operator|.
name|ContextFlags
operator|=
name|CONTEXT_DEBUG_REGISTERS
expr_stmt|;
name|th
operator|->
name|context
operator|.
name|Dr0
operator|=
name|dr
index|[
literal|0
index|]
expr_stmt|;
name|th
operator|->
name|context
operator|.
name|Dr1
operator|=
name|dr
index|[
literal|1
index|]
expr_stmt|;
name|th
operator|->
name|context
operator|.
name|Dr2
operator|=
name|dr
index|[
literal|2
index|]
expr_stmt|;
name|th
operator|->
name|context
operator|.
name|Dr3
operator|=
name|dr
index|[
literal|3
index|]
expr_stmt|;
comment|/* th->context.Dr6 = dr[6]; 		 FIXME: should we set dr6 also ?? */
name|th
operator|->
name|context
operator|.
name|Dr7
operator|=
name|dr
index|[
literal|7
index|]
expr_stmt|;
name|CHECK
argument_list|(
name|SetThreadContext
argument_list|(
name|th
operator|->
name|h
argument_list|,
operator|&
name|th
operator|->
name|context
argument_list|)
argument_list|)
expr_stmt|;
name|th
operator|->
name|context
operator|.
name|ContextFlags
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|debug_registers_changed
operator|=
literal|0
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* Called in pathological case where Windows fails to send a    CREATE_PROCESS_DEBUG_EVENT after an attach.  */
end_comment

begin_function
name|DWORD
name|fake_create_process
parameter_list|(
name|void
parameter_list|)
block|{
name|current_process_handle
operator|=
name|OpenProcess
argument_list|(
name|PROCESS_ALL_ACCESS
argument_list|,
name|FALSE
argument_list|,
name|current_event
operator|.
name|dwProcessId
argument_list|)
expr_stmt|;
name|main_thread_id
operator|=
name|current_event
operator|.
name|dwThreadId
expr_stmt|;
name|current_thread
operator|=
name|child_add_thread
argument_list|(
name|main_thread_id
argument_list|,
name|current_event
operator|.
name|u
operator|.
name|CreateThread
operator|.
name|hThread
argument_list|)
expr_stmt|;
return|return
name|main_thread_id
return|;
block|}
end_function

begin_comment
comment|/* Get the next event from the child.  Return 1 if the event requires    handling by WFI (or whatever).  */
end_comment

begin_function
specifier|static
name|int
name|get_child_debug_event
parameter_list|(
name|int
name|pid
parameter_list|,
name|struct
name|target_waitstatus
modifier|*
name|ourstatus
parameter_list|)
block|{
name|BOOL
name|debug_event
decl_stmt|;
name|DWORD
name|continue_status
decl_stmt|,
name|event_code
decl_stmt|;
name|thread_info
modifier|*
name|th
decl_stmt|;
specifier|static
name|thread_info
name|dummy_thread_info
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|last_sig
operator|=
name|TARGET_SIGNAL_0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|debug_event
operator|=
name|WaitForDebugEvent
argument_list|(
operator|&
name|current_event
argument_list|,
literal|1000
argument_list|)
operator|)
condition|)
goto|goto
name|out
goto|;
name|event_count
operator|++
expr_stmt|;
name|continue_status
operator|=
name|DBG_CONTINUE
expr_stmt|;
name|event_code
operator|=
name|current_event
operator|.
name|dwDebugEventCode
expr_stmt|;
name|ourstatus
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_SPURIOUS
expr_stmt|;
name|th
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|event_code
condition|)
block|{
case|case
name|CREATE_THREAD_DEBUG_EVENT
case|:
name|DEBUG_EVENTS
argument_list|(
operator|(
literal|"gdb: kernel event for pid=%d tid=%x code=%s)\n"
operator|,
operator|(
name|unsigned
operator|)
name|current_event
operator|.
name|dwProcessId
operator|,
operator|(
name|unsigned
operator|)
name|current_event
operator|.
name|dwThreadId
operator|,
literal|"CREATE_THREAD_DEBUG_EVENT"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|saw_create
operator|!=
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|saw_create
operator|&&
name|attach_flag
condition|)
block|{
comment|/* Kludge around a Windows bug where first event is a create 		 thread event.  Caused when attached process does not have 		 a main thread. */
name|retval
operator|=
name|ourstatus
operator|->
name|value
operator|.
name|related_pid
operator|=
name|fake_create_process
argument_list|()
expr_stmt|;
name|saw_create
operator|++
expr_stmt|;
block|}
break|break;
block|}
comment|/* Record the existence of this thread */
name|th
operator|=
name|child_add_thread
argument_list|(
name|current_event
operator|.
name|dwThreadId
argument_list|,
name|current_event
operator|.
name|u
operator|.
name|CreateThread
operator|.
name|hThread
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_verbose
condition|)
name|printf_unfiltered
argument_list|(
literal|"[New %s]\n"
argument_list|,
name|target_pid_to_str
argument_list|(
name|pid_to_ptid
argument_list|(
name|current_event
operator|.
name|dwThreadId
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|retval
operator|=
name|current_event
operator|.
name|dwThreadId
expr_stmt|;
break|break;
case|case
name|EXIT_THREAD_DEBUG_EVENT
case|:
name|DEBUG_EVENTS
argument_list|(
operator|(
literal|"gdb: kernel event for pid=%d tid=%d code=%s)\n"
operator|,
operator|(
name|unsigned
operator|)
name|current_event
operator|.
name|dwProcessId
operator|,
operator|(
name|unsigned
operator|)
name|current_event
operator|.
name|dwThreadId
operator|,
literal|"EXIT_THREAD_DEBUG_EVENT"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_event
operator|.
name|dwThreadId
operator|!=
name|main_thread_id
condition|)
block|{
name|child_delete_thread
argument_list|(
name|current_event
operator|.
name|dwThreadId
argument_list|)
expr_stmt|;
name|th
operator|=
operator|&
name|dummy_thread_info
expr_stmt|;
block|}
break|break;
case|case
name|CREATE_PROCESS_DEBUG_EVENT
case|:
name|DEBUG_EVENTS
argument_list|(
operator|(
literal|"gdb: kernel event for pid=%d tid=%d code=%s)\n"
operator|,
operator|(
name|unsigned
operator|)
name|current_event
operator|.
name|dwProcessId
operator|,
operator|(
name|unsigned
operator|)
name|current_event
operator|.
name|dwThreadId
operator|,
literal|"CREATE_PROCESS_DEBUG_EVENT"
operator|)
argument_list|)
expr_stmt|;
name|CloseHandle
argument_list|(
name|current_event
operator|.
name|u
operator|.
name|CreateProcessInfo
operator|.
name|hFile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|saw_create
operator|!=
literal|1
condition|)
block|{
name|CloseHandle
argument_list|(
name|current_event
operator|.
name|u
operator|.
name|CreateProcessInfo
operator|.
name|hProcess
argument_list|)
expr_stmt|;
break|break;
block|}
name|current_process_handle
operator|=
name|current_event
operator|.
name|u
operator|.
name|CreateProcessInfo
operator|.
name|hProcess
expr_stmt|;
if|if
condition|(
name|main_thread_id
condition|)
name|child_delete_thread
argument_list|(
name|main_thread_id
argument_list|)
expr_stmt|;
name|main_thread_id
operator|=
name|current_event
operator|.
name|dwThreadId
expr_stmt|;
comment|/* Add the main thread */
name|th
operator|=
name|child_add_thread
argument_list|(
name|main_thread_id
argument_list|,
name|current_event
operator|.
name|u
operator|.
name|CreateProcessInfo
operator|.
name|hThread
argument_list|)
expr_stmt|;
name|retval
operator|=
name|ourstatus
operator|->
name|value
operator|.
name|related_pid
operator|=
name|current_event
operator|.
name|dwThreadId
expr_stmt|;
break|break;
case|case
name|EXIT_PROCESS_DEBUG_EVENT
case|:
name|DEBUG_EVENTS
argument_list|(
operator|(
literal|"gdb: kernel event for pid=%d tid=%d code=%s)\n"
operator|,
operator|(
name|unsigned
operator|)
name|current_event
operator|.
name|dwProcessId
operator|,
operator|(
name|unsigned
operator|)
name|current_event
operator|.
name|dwThreadId
operator|,
literal|"EXIT_PROCESS_DEBUG_EVENT"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|saw_create
operator|!=
literal|1
condition|)
break|break;
name|ourstatus
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_EXITED
expr_stmt|;
name|ourstatus
operator|->
name|value
operator|.
name|integer
operator|=
name|current_event
operator|.
name|u
operator|.
name|ExitProcess
operator|.
name|dwExitCode
expr_stmt|;
name|CloseHandle
argument_list|(
name|current_process_handle
argument_list|)
expr_stmt|;
name|retval
operator|=
name|main_thread_id
expr_stmt|;
break|break;
case|case
name|LOAD_DLL_DEBUG_EVENT
case|:
name|DEBUG_EVENTS
argument_list|(
operator|(
literal|"gdb: kernel event for pid=%d tid=%d code=%s)\n"
operator|,
operator|(
name|unsigned
operator|)
name|current_event
operator|.
name|dwProcessId
operator|,
operator|(
name|unsigned
operator|)
name|current_event
operator|.
name|dwThreadId
operator|,
literal|"LOAD_DLL_DEBUG_EVENT"
operator|)
argument_list|)
expr_stmt|;
name|CloseHandle
argument_list|(
name|current_event
operator|.
name|u
operator|.
name|LoadDll
operator|.
name|hFile
argument_list|)
expr_stmt|;
if|if
condition|(
name|saw_create
operator|!=
literal|1
condition|)
break|break;
name|catch_errors
argument_list|(
name|handle_load_dll
argument_list|,
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|""
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
expr_stmt|;
name|registers_changed
argument_list|()
expr_stmt|;
comment|/* mark all regs invalid */
name|ourstatus
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_LOADED
expr_stmt|;
name|ourstatus
operator|->
name|value
operator|.
name|integer
operator|=
literal|0
expr_stmt|;
name|retval
operator|=
name|main_thread_id
expr_stmt|;
name|re_enable_breakpoints_in_shlibs
argument_list|()
expr_stmt|;
break|break;
case|case
name|UNLOAD_DLL_DEBUG_EVENT
case|:
name|DEBUG_EVENTS
argument_list|(
operator|(
literal|"gdb: kernel event for pid=%d tid=%d code=%s)\n"
operator|,
operator|(
name|unsigned
operator|)
name|current_event
operator|.
name|dwProcessId
operator|,
operator|(
name|unsigned
operator|)
name|current_event
operator|.
name|dwThreadId
operator|,
literal|"UNLOAD_DLL_DEBUG_EVENT"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|saw_create
operator|!=
literal|1
condition|)
break|break;
name|catch_errors
argument_list|(
name|handle_unload_dll
argument_list|,
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|""
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
expr_stmt|;
name|registers_changed
argument_list|()
expr_stmt|;
comment|/* mark all regs invalid */
comment|/* ourstatus->kind = TARGET_WAITKIND_UNLOADED; 	 does not exist yet. */
break|break;
case|case
name|EXCEPTION_DEBUG_EVENT
case|:
name|DEBUG_EVENTS
argument_list|(
operator|(
literal|"gdb: kernel event for pid=%d tid=%d code=%s)\n"
operator|,
operator|(
name|unsigned
operator|)
name|current_event
operator|.
name|dwProcessId
operator|,
operator|(
name|unsigned
operator|)
name|current_event
operator|.
name|dwThreadId
operator|,
literal|"EXCEPTION_DEBUG_EVENT"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|saw_create
operator|!=
literal|1
condition|)
break|break;
if|if
condition|(
name|handle_exception
argument_list|(
name|ourstatus
argument_list|)
condition|)
name|retval
operator|=
name|current_event
operator|.
name|dwThreadId
expr_stmt|;
break|break;
case|case
name|OUTPUT_DEBUG_STRING_EVENT
case|:
comment|/* message from the kernel */
name|DEBUG_EVENTS
argument_list|(
operator|(
literal|"gdb: kernel event for pid=%d tid=%d code=%s)\n"
operator|,
operator|(
name|unsigned
operator|)
name|current_event
operator|.
name|dwProcessId
operator|,
operator|(
name|unsigned
operator|)
name|current_event
operator|.
name|dwThreadId
operator|,
literal|"OUTPUT_DEBUG_STRING_EVENT"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|saw_create
operator|!=
literal|1
condition|)
break|break;
if|if
condition|(
name|handle_output_debug_string
argument_list|(
name|ourstatus
argument_list|)
condition|)
name|retval
operator|=
name|main_thread_id
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|saw_create
operator|!=
literal|1
condition|)
break|break;
name|printf_unfiltered
argument_list|(
literal|"gdb: kernel event for pid=%ld tid=%ld\n"
argument_list|,
operator|(
name|DWORD
operator|)
name|current_event
operator|.
name|dwProcessId
argument_list|,
operator|(
name|DWORD
operator|)
name|current_event
operator|.
name|dwThreadId
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"                 unknown event code %ld\n"
argument_list|,
name|current_event
operator|.
name|dwDebugEventCode
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|retval
operator|||
name|saw_create
operator|!=
literal|1
condition|)
name|CHECK
argument_list|(
name|child_continue
argument_list|(
name|continue_status
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|inferior_ptid
operator|=
name|pid_to_ptid
argument_list|(
name|retval
argument_list|)
expr_stmt|;
name|current_thread
operator|=
name|th
condition|?
else|:
name|thread_rec
argument_list|(
name|current_event
operator|.
name|dwThreadId
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
name|out
label|:
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Wait for interesting events to occur in the target process. */
end_comment

begin_function
specifier|static
name|ptid_t
name|child_wait
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
name|struct
name|target_waitstatus
modifier|*
name|ourstatus
parameter_list|)
block|{
name|int
name|pid
init|=
name|PIDGET
argument_list|(
name|ptid
argument_list|)
decl_stmt|;
comment|/* We loop when we get a non-standard exception rather than return      with a SPURIOUS because resume can try and step or modify things,      which needs a current_thread->h.  But some of these exceptions mark      the birth or death of threads, which mean that the current thread      isn't necessarily what you think it is. */
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|retval
init|=
name|get_child_debug_event
argument_list|(
name|pid
argument_list|,
name|ourstatus
argument_list|)
decl_stmt|;
if|if
condition|(
name|retval
condition|)
return|return
name|pid_to_ptid
argument_list|(
name|retval
argument_list|)
return|;
else|else
block|{
name|int
name|detach
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ui_loop_hook
operator|!=
name|NULL
condition|)
name|detach
operator|=
name|ui_loop_hook
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|detach
condition|)
name|child_kill_inferior
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|do_initial_child_stuff
parameter_list|(
name|DWORD
name|pid
parameter_list|)
block|{
specifier|extern
name|int
name|stop_after_trap
decl_stmt|;
name|int
name|i
decl_stmt|;
name|last_sig
operator|=
name|TARGET_SIGNAL_0
expr_stmt|;
name|event_count
operator|=
literal|0
expr_stmt|;
name|exception_count
operator|=
literal|0
expr_stmt|;
name|debug_registers_changed
operator|=
literal|0
expr_stmt|;
name|debug_registers_used
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|dr
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|dr
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
name|dr
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|current_event
operator|.
name|dwProcessId
operator|=
name|pid
expr_stmt|;
name|memset
argument_list|(
operator|&
name|current_event
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|current_event
argument_list|)
argument_list|)
expr_stmt|;
name|push_target
argument_list|(
operator|&
name|child_ops
argument_list|)
expr_stmt|;
name|child_init_thread_list
argument_list|()
expr_stmt|;
name|disable_breakpoints_in_shlibs
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|child_clear_solibs
argument_list|()
expr_stmt|;
name|clear_proceed_status
argument_list|()
expr_stmt|;
name|init_wait_for_inferior
argument_list|()
expr_stmt|;
name|target_terminal_init
argument_list|()
expr_stmt|;
name|target_terminal_inferior
argument_list|()
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|stop_after_trap
operator|=
literal|1
expr_stmt|;
name|wait_for_inferior
argument_list|()
expr_stmt|;
if|if
condition|(
name|stop_signal
operator|!=
name|TARGET_SIGNAL_TRAP
condition|)
name|resume
argument_list|(
literal|0
argument_list|,
name|stop_signal
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
name|stop_after_trap
operator|=
literal|0
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Since Windows XP, detaching from a process is supported by Windows.    The following code tries loading the appropriate functions dynamically.    If loading these functions succeeds use them to actually detach from    the inferior process, otherwise behave as usual, pretending that    detach has worked. */
end_comment

begin_function_decl
specifier|static
name|BOOL
name|WINAPI
function_decl|(
modifier|*
name|DebugSetProcessKillOnExit
function_decl|)
parameter_list|(
name|BOOL
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|BOOL
name|WINAPI
function_decl|(
modifier|*
name|DebugActiveProcessStop
function_decl|)
parameter_list|(
name|DWORD
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|has_detach_ability
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|HMODULE
name|kernel32
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|kernel32
condition|)
name|kernel32
operator|=
name|LoadLibrary
argument_list|(
literal|"kernel32.dll"
argument_list|)
expr_stmt|;
if|if
condition|(
name|kernel32
condition|)
block|{
if|if
condition|(
operator|!
name|DebugSetProcessKillOnExit
condition|)
name|DebugSetProcessKillOnExit
operator|=
name|GetProcAddress
argument_list|(
name|kernel32
argument_list|,
literal|"DebugSetProcessKillOnExit"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DebugActiveProcessStop
condition|)
name|DebugActiveProcessStop
operator|=
name|GetProcAddress
argument_list|(
name|kernel32
argument_list|,
literal|"DebugActiveProcessStop"
argument_list|)
expr_stmt|;
if|if
condition|(
name|DebugSetProcessKillOnExit
operator|&&
name|DebugActiveProcessStop
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Try to set or remove a user privilege to the current process.  Return -1    if that fails, the previous setting of that privilege otherwise.     This code is copied from the Cygwin source code and rearranged to allow    dynamically loading of the needed symbols from advapi32 which is only    available on NT/2K/XP. */
end_comment

begin_function
specifier|static
name|int
name|set_process_privilege
parameter_list|(
specifier|const
name|char
modifier|*
name|privilege
parameter_list|,
name|BOOL
name|enable
parameter_list|)
block|{
specifier|static
name|HMODULE
name|advapi32
init|=
name|NULL
decl_stmt|;
specifier|static
name|BOOL
name|WINAPI
argument_list|(
operator|*
name|OpenProcessToken
argument_list|)
argument_list|(
name|HANDLE
argument_list|,
name|DWORD
argument_list|,
name|PHANDLE
argument_list|)
decl_stmt|;
specifier|static
name|BOOL
name|WINAPI
argument_list|(
operator|*
name|LookupPrivilegeValue
argument_list|)
argument_list|(
name|LPCSTR
argument_list|,
name|LPCSTR
argument_list|,
name|PLUID
argument_list|)
decl_stmt|;
specifier|static
name|BOOL
name|WINAPI
argument_list|(
operator|*
name|AdjustTokenPrivileges
argument_list|)
argument_list|(
name|HANDLE
argument_list|,
name|BOOL
argument_list|,
name|PTOKEN_PRIVILEGES
argument_list|,
name|DWORD
argument_list|,
name|PTOKEN_PRIVILEGES
argument_list|,
name|PDWORD
argument_list|)
decl_stmt|;
name|HANDLE
name|token_hdl
init|=
name|NULL
decl_stmt|;
name|LUID
name|restore_priv
decl_stmt|;
name|TOKEN_PRIVILEGES
name|new_priv
decl_stmt|,
name|orig_priv
decl_stmt|;
name|int
name|ret
init|=
operator|-
literal|1
decl_stmt|;
name|DWORD
name|size
decl_stmt|;
if|if
condition|(
name|GetVersion
argument_list|()
operator|>=
literal|0x80000000
condition|)
comment|/* No security availbale on 9x/Me */
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|advapi32
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|advapi32
operator|=
name|LoadLibrary
argument_list|(
literal|"advapi32.dll"
argument_list|)
operator|)
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|!
name|OpenProcessToken
condition|)
name|OpenProcessToken
operator|=
name|GetProcAddress
argument_list|(
name|advapi32
argument_list|,
literal|"OpenProcessToken"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|LookupPrivilegeValue
condition|)
name|LookupPrivilegeValue
operator|=
name|GetProcAddress
argument_list|(
name|advapi32
argument_list|,
literal|"LookupPrivilegeValueA"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|AdjustTokenPrivileges
condition|)
name|AdjustTokenPrivileges
operator|=
name|GetProcAddress
argument_list|(
name|advapi32
argument_list|,
literal|"AdjustTokenPrivileges"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|OpenProcessToken
operator|||
operator|!
name|LookupPrivilegeValue
operator|||
operator|!
name|AdjustTokenPrivileges
condition|)
block|{
name|advapi32
operator|=
name|NULL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
if|if
condition|(
operator|!
name|OpenProcessToken
argument_list|(
name|GetCurrentProcess
argument_list|()
argument_list|,
name|TOKEN_QUERY
operator||
name|TOKEN_ADJUST_PRIVILEGES
argument_list|,
operator|&
name|token_hdl
argument_list|)
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|!
name|LookupPrivilegeValue
argument_list|(
name|NULL
argument_list|,
name|privilege
argument_list|,
operator|&
name|restore_priv
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|new_priv
operator|.
name|PrivilegeCount
operator|=
literal|1
expr_stmt|;
name|new_priv
operator|.
name|Privileges
index|[
literal|0
index|]
operator|.
name|Luid
operator|=
name|restore_priv
expr_stmt|;
name|new_priv
operator|.
name|Privileges
index|[
literal|0
index|]
operator|.
name|Attributes
operator|=
name|enable
condition|?
name|SE_PRIVILEGE_ENABLED
else|:
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|AdjustTokenPrivileges
argument_list|(
name|token_hdl
argument_list|,
name|FALSE
argument_list|,
operator|&
name|new_priv
argument_list|,
sizeof|sizeof
name|orig_priv
argument_list|,
operator|&
name|orig_priv
argument_list|,
operator|&
name|size
argument_list|)
condition|)
goto|goto
name|out
goto|;
if|#
directive|if
literal|0
comment|/* Disabled, otherwise every `attach' in an unprivileged user session      would raise the "Failed to get SE_DEBUG_NAME privilege" warning in      child_attach(). */
comment|/* AdjustTokenPrivileges returns TRUE even if the privilege could not      be enabled. GetLastError () returns an correct error code, though. */
block|if (enable&& GetLastError () == ERROR_NOT_ALL_ASSIGNED)     goto out;
endif|#
directive|endif
name|ret
operator|=
name|orig_priv
operator|.
name|Privileges
index|[
literal|0
index|]
operator|.
name|Attributes
operator|==
name|SE_PRIVILEGE_ENABLED
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|out
label|:
if|if
condition|(
name|token_hdl
condition|)
name|CloseHandle
argument_list|(
name|token_hdl
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Attach to process PID, then initialize for debugging it.  */
end_comment

begin_function
specifier|static
name|void
name|child_attach
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|BOOL
name|ok
decl_stmt|;
name|DWORD
name|pid
decl_stmt|;
if|if
condition|(
operator|!
name|args
condition|)
name|error_no_arg
argument_list|(
literal|"process-id to attach"
argument_list|)
expr_stmt|;
if|if
condition|(
name|set_process_privilege
argument_list|(
name|SE_DEBUG_NAME
argument_list|,
name|TRUE
argument_list|)
operator|<
literal|0
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"Warning: Failed to get SE_DEBUG_NAME privilege\n"
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"This can cause attach to fail on Windows NT/2K/XP\n"
argument_list|)
expr_stmt|;
block|}
name|pid
operator|=
name|strtoul
argument_list|(
name|args
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Windows pid */
name|ok
operator|=
name|DebugActiveProcess
argument_list|(
name|pid
argument_list|)
expr_stmt|;
name|saw_create
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
block|{
comment|/* Try fall back to Cygwin pid */
name|pid
operator|=
name|cygwin_internal
argument_list|(
name|CW_CYGWIN_PID_TO_WINPID
argument_list|,
name|pid
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|>
literal|0
condition|)
name|ok
operator|=
name|DebugActiveProcess
argument_list|(
name|pid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
name|error
argument_list|(
literal|"Can't attach to process."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|has_detach_ability
argument_list|()
condition|)
name|DebugSetProcessKillOnExit
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|attach_flag
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
block|{
name|char
modifier|*
name|exec_file
init|=
operator|(
name|char
operator|*
operator|)
name|get_exec_file
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|exec_file
condition|)
name|printf_unfiltered
argument_list|(
literal|"Attaching to program `%s', %s\n"
argument_list|,
name|exec_file
argument_list|,
name|target_pid_to_str
argument_list|(
name|pid_to_ptid
argument_list|(
name|pid
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf_unfiltered
argument_list|(
literal|"Attaching to %s\n"
argument_list|,
name|target_pid_to_str
argument_list|(
name|pid_to_ptid
argument_list|(
name|pid
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
name|do_initial_child_stuff
argument_list|(
name|pid
argument_list|)
expr_stmt|;
name|target_terminal_ours
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|child_detach
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|int
name|detached
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|has_detach_ability
argument_list|()
condition|)
block|{
name|delete_command
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|child_continue
argument_list|(
name|DBG_CONTINUE
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DebugActiveProcessStop
argument_list|(
name|current_event
operator|.
name|dwProcessId
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"Can't detach process %lu (error %lu)"
argument_list|,
name|current_event
operator|.
name|dwProcessId
argument_list|,
name|GetLastError
argument_list|()
argument_list|)
expr_stmt|;
name|detached
operator|=
literal|0
expr_stmt|;
block|}
name|DebugSetProcessKillOnExit
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|detached
operator|&&
name|from_tty
condition|)
block|{
name|char
modifier|*
name|exec_file
init|=
name|get_exec_file
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|exec_file
operator|==
literal|0
condition|)
name|exec_file
operator|=
literal|""
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"Detaching from program: %s, Pid %lu\n"
argument_list|,
name|exec_file
argument_list|,
name|current_event
operator|.
name|dwProcessId
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
name|inferior_ptid
operator|=
name|null_ptid
expr_stmt|;
name|unpush_target
argument_list|(
operator|&
name|child_ops
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print status information about what we're accessing.  */
end_comment

begin_function
specifier|static
name|void
name|child_files_info
parameter_list|(
name|struct
name|target_ops
modifier|*
name|ignore
parameter_list|)
block|{
name|printf_unfiltered
argument_list|(
literal|"\tUsing the running image of %s %s.\n"
argument_list|,
name|attach_flag
condition|?
literal|"attached"
else|:
literal|"child"
argument_list|,
name|target_pid_to_str
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|child_open
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|error
argument_list|(
literal|"Use the \"run\" command to start a Unix child process."
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Start an inferior win32 child process and sets inferior_ptid to its pid.    EXEC_FILE is the file to run.    ALLARGS is a string containing the arguments to the program.    ENV is the environment vector to pass.  Errors reported with error().  */
end_comment

begin_function
specifier|static
name|void
name|child_create_inferior
parameter_list|(
name|char
modifier|*
name|exec_file
parameter_list|,
name|char
modifier|*
name|allargs
parameter_list|,
name|char
modifier|*
modifier|*
name|env
parameter_list|)
block|{
name|char
modifier|*
name|winenv
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|;
name|int
name|envlen
decl_stmt|;
name|int
name|i
decl_stmt|;
name|STARTUPINFO
name|si
decl_stmt|;
name|PROCESS_INFORMATION
name|pi
decl_stmt|;
name|BOOL
name|ret
decl_stmt|;
name|DWORD
name|flags
decl_stmt|;
name|char
modifier|*
name|args
decl_stmt|;
name|char
name|real_path
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|char
modifier|*
name|toexec
decl_stmt|;
name|char
name|shell
index|[
name|MAX_PATH
operator|+
literal|1
index|]
decl_stmt|;
comment|/* Path to shell */
specifier|const
name|char
modifier|*
name|sh
decl_stmt|;
name|int
name|tty
decl_stmt|;
name|int
name|ostdin
decl_stmt|,
name|ostdout
decl_stmt|,
name|ostderr
decl_stmt|;
if|if
condition|(
operator|!
name|exec_file
condition|)
name|error
argument_list|(
literal|"No executable specified, use `target exec'.\n"
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|si
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|si
argument_list|)
argument_list|)
expr_stmt|;
name|si
operator|.
name|cb
operator|=
sizeof|sizeof
argument_list|(
name|si
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|useshell
condition|)
block|{
name|flags
operator|=
name|DEBUG_ONLY_THIS_PROCESS
expr_stmt|;
name|cygwin_conv_to_win32_path
argument_list|(
name|exec_file
argument_list|,
name|real_path
argument_list|)
expr_stmt|;
name|toexec
operator|=
name|real_path
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|newallargs
decl_stmt|;
name|sh
operator|=
name|getenv
argument_list|(
literal|"SHELL"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sh
condition|)
name|sh
operator|=
literal|"/bin/sh"
expr_stmt|;
name|cygwin_conv_to_win32_path
argument_list|(
name|sh
argument_list|,
name|shell
argument_list|)
expr_stmt|;
name|newallargs
operator|=
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
literal|" -c 'exec  '"
argument_list|)
operator|+
name|strlen
argument_list|(
name|exec_file
argument_list|)
operator|+
name|strlen
argument_list|(
name|allargs
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|newallargs
argument_list|,
literal|" -c 'exec %s %s'"
argument_list|,
name|exec_file
argument_list|,
name|allargs
argument_list|)
expr_stmt|;
name|allargs
operator|=
name|newallargs
expr_stmt|;
name|toexec
operator|=
name|shell
expr_stmt|;
name|flags
operator|=
name|DEBUG_PROCESS
expr_stmt|;
block|}
if|if
condition|(
name|new_group
condition|)
name|flags
operator||=
name|CREATE_NEW_PROCESS_GROUP
expr_stmt|;
if|if
condition|(
name|new_console
condition|)
name|flags
operator||=
name|CREATE_NEW_CONSOLE
expr_stmt|;
name|attach_flag
operator|=
literal|0
expr_stmt|;
name|args
operator|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|toexec
argument_list|)
operator|+
name|strlen
argument_list|(
name|allargs
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|args
argument_list|,
name|toexec
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|args
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|args
argument_list|,
name|allargs
argument_list|)
expr_stmt|;
comment|/* Prepare the environment vars for CreateProcess.  */
block|{
comment|/* This code used to assume all env vars were file names and would        translate them all to win32 style.  That obviously doesn't work in the        general case.  The current rule is that we only translate PATH.        We need to handle PATH because we're about to call CreateProcess and        it uses PATH to find DLL's.  Fortunately PATH has a well-defined value        in both posix and win32 environments.  cygwin.dll will change it back        to posix style if necessary.  */
specifier|static
specifier|const
name|char
modifier|*
name|conv_path_names
index|[]
init|=
block|{
literal|"PATH="
block|,
literal|0
block|}
decl_stmt|;
comment|/* CreateProcess takes the environment list as a null terminated set of        strings (i.e. two nulls terminate the list).  */
comment|/* Get total size for env strings.  */
for|for
control|(
name|envlen
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|env
index|[
name|i
index|]
operator|&&
operator|*
name|env
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
decl_stmt|,
name|len
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|conv_path_names
index|[
name|j
index|]
condition|;
name|j
operator|++
control|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|conv_path_names
index|[
name|j
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|conv_path_names
index|[
name|j
index|]
argument_list|,
name|env
index|[
name|i
index|]
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|cygwin_posix_path_list_p
argument_list|(
name|env
index|[
name|i
index|]
operator|+
name|len
argument_list|)
condition|)
name|envlen
operator|+=
name|len
operator|+
name|cygwin_posix_to_win32_path_list_buf_size
argument_list|(
name|env
index|[
name|i
index|]
operator|+
name|len
argument_list|)
expr_stmt|;
else|else
name|envlen
operator|+=
name|strlen
argument_list|(
name|env
index|[
name|i
index|]
argument_list|)
operator|+
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|conv_path_names
index|[
name|j
index|]
operator|==
name|NULL
condition|)
name|envlen
operator|+=
name|strlen
argument_list|(
name|env
index|[
name|i
index|]
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
name|winenv
operator|=
name|alloca
argument_list|(
name|envlen
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Copy env strings into new buffer.  */
for|for
control|(
name|temp
operator|=
name|winenv
operator|,
name|i
operator|=
literal|0
init|;
name|env
index|[
name|i
index|]
operator|&&
operator|*
name|env
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
decl_stmt|,
name|len
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|conv_path_names
index|[
name|j
index|]
condition|;
name|j
operator|++
control|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|conv_path_names
index|[
name|j
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|conv_path_names
index|[
name|j
index|]
argument_list|,
name|env
index|[
name|i
index|]
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|cygwin_posix_path_list_p
argument_list|(
name|env
index|[
name|i
index|]
operator|+
name|len
argument_list|)
condition|)
block|{
name|memcpy
argument_list|(
name|temp
argument_list|,
name|env
index|[
name|i
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|cygwin_posix_to_win32_path_list
argument_list|(
name|env
index|[
name|i
index|]
operator|+
name|len
argument_list|,
name|temp
operator|+
name|len
argument_list|)
expr_stmt|;
block|}
else|else
name|strcpy
argument_list|(
name|temp
argument_list|,
name|env
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|conv_path_names
index|[
name|j
index|]
operator|==
name|NULL
condition|)
name|strcpy
argument_list|(
name|temp
argument_list|,
name|env
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|temp
operator|+=
name|strlen
argument_list|(
name|temp
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
comment|/* Final nil string to terminate new env.  */
operator|*
name|temp
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|inferior_io_terminal
condition|)
name|tty
operator|=
name|ostdin
operator|=
name|ostdout
operator|=
name|ostderr
operator|=
operator|-
literal|1
expr_stmt|;
else|else
block|{
name|tty
operator|=
name|open
argument_list|(
name|inferior_io_terminal
argument_list|,
name|O_RDWR
operator||
name|O_NOCTTY
argument_list|)
expr_stmt|;
if|if
condition|(
name|tty
operator|<
literal|0
condition|)
block|{
name|print_sys_errmsg
argument_list|(
name|inferior_io_terminal
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|ostdin
operator|=
name|ostdout
operator|=
name|ostderr
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|ostdin
operator|=
name|dup
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|ostdout
operator|=
name|dup
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|ostderr
operator|=
name|dup
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
name|tty
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
name|tty
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
name|tty
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
name|ret
operator|=
name|CreateProcess
argument_list|(
literal|0
argument_list|,
name|args
argument_list|,
comment|/* command line */
name|NULL
argument_list|,
comment|/* Security */
name|NULL
argument_list|,
comment|/* thread */
name|TRUE
argument_list|,
comment|/* inherit handles */
name|flags
argument_list|,
comment|/* start flags */
name|winenv
argument_list|,
name|NULL
argument_list|,
comment|/* current directory */
operator|&
name|si
argument_list|,
operator|&
name|pi
argument_list|)
expr_stmt|;
if|if
condition|(
name|tty
operator|>=
literal|0
condition|)
block|{
name|close
argument_list|(
name|tty
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
name|ostdin
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
name|ostdout
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
name|ostderr
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|ostdin
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|ostdout
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|ostderr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ret
condition|)
name|error
argument_list|(
literal|"Error creating process %s, (error %d)\n"
argument_list|,
name|exec_file
argument_list|,
operator|(
name|unsigned
operator|)
name|GetLastError
argument_list|()
argument_list|)
expr_stmt|;
name|CloseHandle
argument_list|(
name|pi
operator|.
name|hThread
argument_list|)
expr_stmt|;
name|CloseHandle
argument_list|(
name|pi
operator|.
name|hProcess
argument_list|)
expr_stmt|;
if|if
condition|(
name|useshell
operator|&&
name|shell
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|saw_create
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|saw_create
operator|=
literal|0
expr_stmt|;
name|do_initial_child_stuff
argument_list|(
name|pi
operator|.
name|dwProcessId
argument_list|)
expr_stmt|;
comment|/* child_continue (DBG_CONTINUE, -1); */
name|proceed
argument_list|(
operator|(
name|CORE_ADDR
operator|)
operator|-
literal|1
argument_list|,
name|TARGET_SIGNAL_0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|child_mourn_inferior
parameter_list|(
name|void
parameter_list|)
block|{
operator|(
name|void
operator|)
name|child_continue
argument_list|(
name|DBG_CONTINUE
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|i386_cleanup_dregs
argument_list|()
expr_stmt|;
name|unpush_target
argument_list|(
operator|&
name|child_ops
argument_list|)
expr_stmt|;
name|generic_mourn_inferior
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Send a SIGINT to the process group.  This acts just like the user typed a    ^C on the controlling terminal. */
end_comment

begin_function
specifier|static
name|void
name|child_stop
parameter_list|(
name|void
parameter_list|)
block|{
name|DEBUG_EVENTS
argument_list|(
operator|(
literal|"gdb: GenerateConsoleCtrlEvent (CTRLC_EVENT, 0)\n"
operator|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|GenerateConsoleCtrlEvent
argument_list|(
name|CTRL_C_EVENT
argument_list|,
name|current_event
operator|.
name|dwProcessId
argument_list|)
argument_list|)
expr_stmt|;
name|registers_changed
argument_list|()
expr_stmt|;
comment|/* refresh register state */
block|}
end_function

begin_function
name|int
name|child_xfer_memory
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|char
modifier|*
name|our
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|write
parameter_list|,
name|struct
name|mem_attrib
modifier|*
name|mem
parameter_list|,
name|struct
name|target_ops
modifier|*
name|target
parameter_list|)
block|{
name|DWORD
name|done
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|write
condition|)
block|{
name|DEBUG_MEM
argument_list|(
operator|(
literal|"gdb: write target memory, %d bytes at 0x%08lx\n"
operator|,
name|len
operator|,
operator|(
name|DWORD
operator|)
name|memaddr
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|WriteProcessMemory
argument_list|(
name|current_process_handle
argument_list|,
operator|(
name|LPVOID
operator|)
name|memaddr
argument_list|,
name|our
argument_list|,
name|len
argument_list|,
operator|&
name|done
argument_list|)
condition|)
name|done
operator|=
literal|0
expr_stmt|;
name|FlushInstructionCache
argument_list|(
name|current_process_handle
argument_list|,
operator|(
name|LPCVOID
operator|)
name|memaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DEBUG_MEM
argument_list|(
operator|(
literal|"gdb: read target memory, %d bytes at 0x%08lx\n"
operator|,
name|len
operator|,
operator|(
name|DWORD
operator|)
name|memaddr
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ReadProcessMemory
argument_list|(
name|current_process_handle
argument_list|,
operator|(
name|LPCVOID
operator|)
name|memaddr
argument_list|,
name|our
argument_list|,
name|len
argument_list|,
operator|&
name|done
argument_list|)
condition|)
name|done
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|done
return|;
block|}
end_function

begin_function
name|void
name|child_kill_inferior
parameter_list|(
name|void
parameter_list|)
block|{
name|CHECK
argument_list|(
name|TerminateProcess
argument_list|(
name|current_process_handle
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|child_continue
argument_list|(
name|DBG_CONTINUE
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|WaitForDebugEvent
argument_list|(
operator|&
name|current_event
argument_list|,
name|INFINITE
argument_list|)
condition|)
break|break;
if|if
condition|(
name|current_event
operator|.
name|dwDebugEventCode
operator|==
name|EXIT_PROCESS_DEBUG_EVENT
condition|)
break|break;
block|}
name|CHECK
argument_list|(
name|CloseHandle
argument_list|(
name|current_process_handle
argument_list|)
argument_list|)
expr_stmt|;
comment|/* this may fail in an attached process so don't check. */
if|if
condition|(
name|current_thread
operator|&&
name|current_thread
operator|->
name|h
condition|)
operator|(
name|void
operator|)
name|CloseHandle
argument_list|(
name|current_thread
operator|->
name|h
argument_list|)
expr_stmt|;
name|target_mourn_inferior
argument_list|()
expr_stmt|;
comment|/* or just child_mourn_inferior? */
block|}
end_function

begin_function
name|void
name|child_resume
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
name|int
name|step
parameter_list|,
name|enum
name|target_signal
name|sig
parameter_list|)
block|{
name|thread_info
modifier|*
name|th
decl_stmt|;
name|DWORD
name|continue_status
init|=
name|DBG_CONTINUE
decl_stmt|;
name|int
name|pid
init|=
name|PIDGET
argument_list|(
name|ptid
argument_list|)
decl_stmt|;
if|if
condition|(
name|sig
operator|!=
name|TARGET_SIGNAL_0
condition|)
block|{
if|if
condition|(
name|current_event
operator|.
name|dwDebugEventCode
operator|!=
name|EXCEPTION_DEBUG_EVENT
condition|)
block|{
name|DEBUG_EXCEPT
argument_list|(
operator|(
literal|"Cannot continue with signal %d here.\n"
operator|,
name|sig
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sig
operator|==
name|last_sig
condition|)
name|continue_status
operator|=
name|DBG_EXCEPTION_NOT_HANDLED
expr_stmt|;
else|else
if|#
directive|if
literal|0
comment|/* This code does not seem to work, because   the kernel does probably not consider changes in the ExceptionRecord   structure when passing the exception to the inferior.   Note that this seems possible in the exception handler itself.  */
else|{ 	  int i; 	  for (i = 0; xlate[i].them != -1; i++) 	    if (xlate[i].us == sig) 	      { 		current_event.u.Exception.ExceptionRecord.ExceptionCode = 		  xlate[i].them; 		continue_status = DBG_EXCEPTION_NOT_HANDLED; 		break; 	      } 	  if (continue_status == DBG_CONTINUE) 	    { 	      DEBUG_EXCEPT(("Cannot continue with signal %d.\n",sig)); 	    } 	}
endif|#
directive|endif
name|DEBUG_EXCEPT
argument_list|(
operator|(
literal|"Can only continue with recieved signal %d.\n"
operator|,
name|last_sig
operator|)
argument_list|)
expr_stmt|;
block|}
name|last_sig
operator|=
name|TARGET_SIGNAL_0
expr_stmt|;
name|DEBUG_EXEC
argument_list|(
operator|(
literal|"gdb: child_resume (pid=%d, step=%d, sig=%d);\n"
operator|,
name|pid
operator|,
name|step
operator|,
name|sig
operator|)
argument_list|)
expr_stmt|;
comment|/* Get context for currently selected thread */
name|th
operator|=
name|thread_rec
argument_list|(
name|current_event
operator|.
name|dwThreadId
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|th
condition|)
block|{
if|if
condition|(
name|step
condition|)
block|{
comment|/* Single step by setting t bit */
name|child_fetch_inferior_registers
argument_list|(
name|PS_REGNUM
argument_list|)
expr_stmt|;
name|th
operator|->
name|context
operator|.
name|EFlags
operator||=
name|FLAG_TRACE_BIT
expr_stmt|;
block|}
if|if
condition|(
name|th
operator|->
name|context
operator|.
name|ContextFlags
condition|)
block|{
if|if
condition|(
name|debug_registers_changed
condition|)
block|{
name|th
operator|->
name|context
operator|.
name|Dr0
operator|=
name|dr
index|[
literal|0
index|]
expr_stmt|;
name|th
operator|->
name|context
operator|.
name|Dr1
operator|=
name|dr
index|[
literal|1
index|]
expr_stmt|;
name|th
operator|->
name|context
operator|.
name|Dr2
operator|=
name|dr
index|[
literal|2
index|]
expr_stmt|;
name|th
operator|->
name|context
operator|.
name|Dr3
operator|=
name|dr
index|[
literal|3
index|]
expr_stmt|;
comment|/* th->context.Dr6 = dr[6]; 	       FIXME: should we set dr6 also ?? */
name|th
operator|->
name|context
operator|.
name|Dr7
operator|=
name|dr
index|[
literal|7
index|]
expr_stmt|;
block|}
name|CHECK
argument_list|(
name|SetThreadContext
argument_list|(
name|th
operator|->
name|h
argument_list|,
operator|&
name|th
operator|->
name|context
argument_list|)
argument_list|)
expr_stmt|;
name|th
operator|->
name|context
operator|.
name|ContextFlags
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Allow continuing with the same signal that interrupted us.      Otherwise complain. */
name|child_continue
argument_list|(
name|continue_status
argument_list|,
name|pid
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|child_prepare_to_store
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Do nothing, since we can store individual regs */
block|}
end_function

begin_function
specifier|static
name|int
name|child_can_run
parameter_list|(
name|void
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|child_close
parameter_list|(
name|int
name|x
parameter_list|)
block|{
name|DEBUG_EVENTS
argument_list|(
operator|(
literal|"gdb: child_close, inferior_ptid=%d\n"
operator|,
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|struct
name|target_ops
name|child_ops
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|init_child_ops
parameter_list|(
name|void
parameter_list|)
block|{
name|child_ops
operator|.
name|to_shortname
operator|=
literal|"child"
expr_stmt|;
name|child_ops
operator|.
name|to_longname
operator|=
literal|"Win32 child process"
expr_stmt|;
name|child_ops
operator|.
name|to_doc
operator|=
literal|"Win32 child process (started by the \"run\" command)."
expr_stmt|;
name|child_ops
operator|.
name|to_open
operator|=
name|child_open
expr_stmt|;
name|child_ops
operator|.
name|to_close
operator|=
name|child_close
expr_stmt|;
name|child_ops
operator|.
name|to_attach
operator|=
name|child_attach
expr_stmt|;
name|child_ops
operator|.
name|to_detach
operator|=
name|child_detach
expr_stmt|;
name|child_ops
operator|.
name|to_resume
operator|=
name|child_resume
expr_stmt|;
name|child_ops
operator|.
name|to_wait
operator|=
name|child_wait
expr_stmt|;
name|child_ops
operator|.
name|to_fetch_registers
operator|=
name|child_fetch_inferior_registers
expr_stmt|;
name|child_ops
operator|.
name|to_store_registers
operator|=
name|child_store_inferior_registers
expr_stmt|;
name|child_ops
operator|.
name|to_prepare_to_store
operator|=
name|child_prepare_to_store
expr_stmt|;
name|child_ops
operator|.
name|to_xfer_memory
operator|=
name|child_xfer_memory
expr_stmt|;
name|child_ops
operator|.
name|to_files_info
operator|=
name|child_files_info
expr_stmt|;
name|child_ops
operator|.
name|to_insert_breakpoint
operator|=
name|memory_insert_breakpoint
expr_stmt|;
name|child_ops
operator|.
name|to_remove_breakpoint
operator|=
name|memory_remove_breakpoint
expr_stmt|;
name|child_ops
operator|.
name|to_terminal_init
operator|=
name|terminal_init_inferior
expr_stmt|;
name|child_ops
operator|.
name|to_terminal_inferior
operator|=
name|terminal_inferior
expr_stmt|;
name|child_ops
operator|.
name|to_terminal_ours_for_output
operator|=
name|terminal_ours_for_output
expr_stmt|;
name|child_ops
operator|.
name|to_terminal_ours
operator|=
name|terminal_ours
expr_stmt|;
name|child_ops
operator|.
name|to_terminal_save_ours
operator|=
name|terminal_save_ours
expr_stmt|;
name|child_ops
operator|.
name|to_terminal_info
operator|=
name|child_terminal_info
expr_stmt|;
name|child_ops
operator|.
name|to_kill
operator|=
name|child_kill_inferior
expr_stmt|;
name|child_ops
operator|.
name|to_create_inferior
operator|=
name|child_create_inferior
expr_stmt|;
name|child_ops
operator|.
name|to_mourn_inferior
operator|=
name|child_mourn_inferior
expr_stmt|;
name|child_ops
operator|.
name|to_can_run
operator|=
name|child_can_run
expr_stmt|;
name|child_ops
operator|.
name|to_thread_alive
operator|=
name|win32_child_thread_alive
expr_stmt|;
name|child_ops
operator|.
name|to_pid_to_str
operator|=
name|cygwin_pid_to_str
expr_stmt|;
name|child_ops
operator|.
name|to_stop
operator|=
name|child_stop
expr_stmt|;
name|child_ops
operator|.
name|to_stratum
operator|=
name|process_stratum
expr_stmt|;
name|child_ops
operator|.
name|to_has_all_memory
operator|=
literal|1
expr_stmt|;
name|child_ops
operator|.
name|to_has_memory
operator|=
literal|1
expr_stmt|;
name|child_ops
operator|.
name|to_has_stack
operator|=
literal|1
expr_stmt|;
name|child_ops
operator|.
name|to_has_registers
operator|=
literal|1
expr_stmt|;
name|child_ops
operator|.
name|to_has_execution
operator|=
literal|1
expr_stmt|;
name|child_ops
operator|.
name|to_magic
operator|=
name|OPS_MAGIC
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_initialize_win32_nat
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
name|init_child_ops
argument_list|()
expr_stmt|;
name|c
operator|=
name|add_com
argument_list|(
literal|"dll-symbols"
argument_list|,
name|class_files
argument_list|,
name|dll_symbol_command
argument_list|,
literal|"Load dll library symbols from FILE."
argument_list|)
expr_stmt|;
name|set_cmd_completer
argument_list|(
name|c
argument_list|,
name|filename_completer
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"sharedlibrary"
argument_list|,
literal|"dll-symbols"
argument_list|,
name|class_alias
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"shell"
argument_list|,
name|class_support
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|useshell
argument_list|,
literal|"Set use of shell to start subprocess."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"new-console"
argument_list|,
name|class_support
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|new_console
argument_list|,
literal|"Set creation of new console when creating child process."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"new-group"
argument_list|,
name|class_support
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|new_group
argument_list|,
literal|"Set creation of new group when creating child process."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"debugexec"
argument_list|,
name|class_support
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|debug_exec
argument_list|,
literal|"Set whether to display execution in child process."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"debugevents"
argument_list|,
name|class_support
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|debug_events
argument_list|,
literal|"Set whether to display kernel events in child process."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"debugmemory"
argument_list|,
name|class_support
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|debug_memory
argument_list|,
literal|"Set whether to display memory accesses in child process."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"debugexceptions"
argument_list|,
name|class_support
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|debug_exceptions
argument_list|,
literal|"Set whether to display kernel exceptions in child process."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"dll"
argument_list|,
name|info_dll_command
argument_list|,
literal|"Status of loaded DLLs."
argument_list|)
expr_stmt|;
name|add_info_alias
argument_list|(
literal|"sharedlibrary"
argument_list|,
literal|"dll"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"w32"
argument_list|,
name|class_info
argument_list|,
name|info_w32_command
argument_list|,
literal|"Print information specific to Win32 debugging."
argument_list|,
operator|&
name|info_w32_cmdlist
argument_list|,
literal|"info w32 "
argument_list|,
literal|0
argument_list|,
operator|&
name|infolist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"selector"
argument_list|,
name|class_info
argument_list|,
name|display_selectors
argument_list|,
literal|"Display selectors infos."
argument_list|,
operator|&
name|info_w32_cmdlist
argument_list|)
expr_stmt|;
name|add_target
argument_list|(
operator|&
name|child_ops
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Hardware watchpoint support, adapted from go32-nat.c code.  */
end_comment

begin_comment
comment|/* Pass the address ADDR to the inferior in the I'th debug register.    Here we just store the address in dr array, the registers will be    actually set up when child_continue is called.  */
end_comment

begin_function
name|void
name|cygwin_set_dr
parameter_list|(
name|int
name|i
parameter_list|,
name|CORE_ADDR
name|addr
parameter_list|)
block|{
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|i
operator|>
literal|3
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"Invalid register %d in cygwin_set_dr.\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|dr
index|[
name|i
index|]
operator|=
operator|(
name|unsigned
operator|)
name|addr
expr_stmt|;
name|debug_registers_changed
operator|=
literal|1
expr_stmt|;
name|debug_registers_used
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pass the value VAL to the inferior in the DR7 debug control    register.  Here we just store the address in D_REGS, the watchpoint    will be actually set up in child_wait.  */
end_comment

begin_function
name|void
name|cygwin_set_dr7
parameter_list|(
name|unsigned
name|val
parameter_list|)
block|{
name|dr
index|[
literal|7
index|]
operator|=
name|val
expr_stmt|;
name|debug_registers_changed
operator|=
literal|1
expr_stmt|;
name|debug_registers_used
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get the value of the DR6 debug status register from the inferior.    Here we just return the value stored in dr[6]    by the last call to thread_rec for current_event.dwThreadId id.  */
end_comment

begin_function
name|unsigned
name|cygwin_get_dr6
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|dr
index|[
literal|6
index|]
return|;
block|}
end_function

begin_comment
comment|/* Determine if the thread referenced by "pid" is alive    by "polling" it.  If WaitForSingleObject returns WAIT_OBJECT_0    it means that the pid has died.  Otherwise it is assumed to be alive. */
end_comment

begin_function
specifier|static
name|int
name|win32_child_thread_alive
parameter_list|(
name|ptid_t
name|ptid
parameter_list|)
block|{
name|int
name|pid
init|=
name|PIDGET
argument_list|(
name|ptid
argument_list|)
decl_stmt|;
return|return
name|WaitForSingleObject
argument_list|(
name|thread_rec
argument_list|(
name|pid
argument_list|,
name|FALSE
argument_list|)
operator|->
name|h
argument_list|,
literal|0
argument_list|)
operator|==
name|WAIT_OBJECT_0
condition|?
name|FALSE
else|:
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Convert pid to printable format. */
end_comment

begin_function
name|char
modifier|*
name|cygwin_pid_to_str
parameter_list|(
name|ptid_t
name|ptid
parameter_list|)
block|{
specifier|static
name|char
name|buf
index|[
literal|80
index|]
decl_stmt|;
name|int
name|pid
init|=
name|PIDGET
argument_list|(
name|ptid
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|DWORD
operator|)
name|pid
operator|==
name|current_event
operator|.
name|dwProcessId
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"process %d"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"thread %ld.0x%x"
argument_list|,
name|current_event
operator|.
name|dwProcessId
argument_list|,
name|pid
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|core_dll_symbols_add
parameter_list|(
name|char
modifier|*
name|dll_name
parameter_list|,
name|DWORD
name|base_addr
parameter_list|)
block|{
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|char
modifier|*
name|objfile_basename
decl_stmt|;
specifier|const
name|char
modifier|*
name|dll_basename
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|dll_basename
operator|=
name|strrchr
argument_list|(
name|dll_name
argument_list|,
literal|'/'
argument_list|)
operator|)
condition|)
name|dll_basename
operator|=
name|dll_name
expr_stmt|;
else|else
name|dll_basename
operator|++
expr_stmt|;
name|ALL_OBJFILES
argument_list|(
argument|objfile
argument_list|)
block|{
name|objfile_basename
operator|=
name|strrchr
argument_list|(
name|objfile
operator|->
name|name
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|objfile_basename
operator|&&
name|strcmp
argument_list|(
name|dll_basename
argument_list|,
name|objfile_basename
operator|+
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"%08lx:%s (symbols previously loaded)\n"
argument_list|,
name|base_addr
argument_list|,
name|dll_name
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|register_loaded_dll
argument_list|(
name|dll_name
argument_list|,
name|base_addr
operator|+
literal|0x1000
argument_list|)
expr_stmt|;
name|solib_symbols_add
argument_list|(
name|dll_name
argument_list|,
literal|0
argument_list|,
operator|(
name|CORE_ADDR
operator|)
name|base_addr
operator|+
literal|0x1000
argument_list|)
expr_stmt|;
name|out
label|:
return|return
literal|1
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
block|{
name|struct
name|target_ops
modifier|*
name|target
decl_stmt|;
name|bfd_vma
name|addr
decl_stmt|;
block|}
name|map_code_section_args
typedef|;
end_typedef

begin_function
specifier|static
name|void
name|map_single_dll_code_section
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sect
parameter_list|,
name|void
modifier|*
name|obj
parameter_list|)
block|{
name|int
name|old
decl_stmt|;
name|int
name|update_coreops
decl_stmt|;
name|struct
name|section_table
modifier|*
name|new_target_sect_ptr
decl_stmt|;
name|map_code_section_args
modifier|*
name|args
init|=
operator|(
name|map_code_section_args
operator|*
operator|)
name|obj
decl_stmt|;
name|struct
name|target_ops
modifier|*
name|target
init|=
name|args
operator|->
name|target
decl_stmt|;
if|if
condition|(
name|sect
operator|->
name|flags
operator|&
name|SEC_CODE
condition|)
block|{
name|update_coreops
operator|=
name|core_ops
operator|.
name|to_sections
operator|==
name|target
operator|->
name|to_sections
expr_stmt|;
if|if
condition|(
name|target
operator|->
name|to_sections
condition|)
block|{
name|old
operator|=
name|target
operator|->
name|to_sections_end
operator|-
name|target
operator|->
name|to_sections
expr_stmt|;
name|target
operator|->
name|to_sections
operator|=
operator|(
expr|struct
name|section_table
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|target
operator|->
name|to_sections
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|section_table
argument_list|)
operator|)
operator|*
operator|(
literal|1
operator|+
name|old
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|old
operator|=
literal|0
expr_stmt|;
name|target
operator|->
name|to_sections
operator|=
operator|(
expr|struct
name|section_table
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|section_table
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
name|target
operator|->
name|to_sections_end
operator|=
name|target
operator|->
name|to_sections
operator|+
operator|(
literal|1
operator|+
name|old
operator|)
expr_stmt|;
comment|/* Update the to_sections field in the core_ops structure 	   if needed.  */
if|if
condition|(
name|update_coreops
condition|)
block|{
name|core_ops
operator|.
name|to_sections
operator|=
name|target
operator|->
name|to_sections
expr_stmt|;
name|core_ops
operator|.
name|to_sections_end
operator|=
name|target
operator|->
name|to_sections_end
expr_stmt|;
block|}
name|new_target_sect_ptr
operator|=
name|target
operator|->
name|to_sections
operator|+
name|old
expr_stmt|;
name|new_target_sect_ptr
operator|->
name|addr
operator|=
name|args
operator|->
name|addr
operator|+
name|bfd_section_vma
argument_list|(
name|abfd
argument_list|,
name|sect
argument_list|)
expr_stmt|;
name|new_target_sect_ptr
operator|->
name|endaddr
operator|=
name|args
operator|->
name|addr
operator|+
name|bfd_section_vma
argument_list|(
name|abfd
argument_list|,
name|sect
argument_list|)
operator|+
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|sect
argument_list|)
expr_stmt|;
empty_stmt|;
name|new_target_sect_ptr
operator|->
name|the_bfd_section
operator|=
name|sect
expr_stmt|;
name|new_target_sect_ptr
operator|->
name|bfd
operator|=
name|abfd
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|dll_code_sections_add
parameter_list|(
specifier|const
name|char
modifier|*
name|dll_name
parameter_list|,
name|int
name|base_addr
parameter_list|,
name|struct
name|target_ops
modifier|*
name|target
parameter_list|)
block|{
name|bfd
modifier|*
name|dll_bfd
decl_stmt|;
name|map_code_section_args
name|map_args
decl_stmt|;
name|asection
modifier|*
name|lowest_sect
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|dll_name
operator|==
name|NULL
operator|||
name|target
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|name
operator|=
name|xstrdup
argument_list|(
name|dll_name
argument_list|)
expr_stmt|;
name|dll_bfd
operator|=
name|bfd_openr
argument_list|(
name|name
argument_list|,
literal|"pei-i386"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dll_bfd
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|bfd_check_format
argument_list|(
name|dll_bfd
argument_list|,
name|bfd_object
argument_list|)
condition|)
block|{
name|lowest_sect
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dll_bfd
argument_list|,
literal|".text"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lowest_sect
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|map_args
operator|.
name|target
operator|=
name|target
expr_stmt|;
name|map_args
operator|.
name|addr
operator|=
name|base_addr
operator|-
name|bfd_section_vma
argument_list|(
name|dll_bfd
argument_list|,
name|lowest_sect
argument_list|)
expr_stmt|;
name|bfd_map_over_sections
argument_list|(
name|dll_bfd
argument_list|,
operator|&
name|map_single_dll_code_section
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
operator|&
name|map_args
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|core_section_load_dll_symbols
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sect
parameter_list|,
name|void
modifier|*
name|obj
parameter_list|)
block|{
name|struct
name|target_ops
modifier|*
name|target
init|=
operator|(
expr|struct
name|target_ops
operator|*
operator|)
name|obj
decl_stmt|;
name|DWORD
name|base_addr
decl_stmt|;
name|int
name|dll_name_size
decl_stmt|;
name|char
modifier|*
name|dll_name
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
name|struct
name|win32_pstatus
modifier|*
name|pstatus
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|sect
operator|->
name|name
argument_list|,
literal|".module"
argument_list|,
literal|7
argument_list|)
condition|)
return|return;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|sect
operator|->
name|_raw_size
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"memory allocation failed for %s\n"
argument_list|,
name|sect
operator|->
name|name
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|sect
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|,
name|sect
operator|->
name|_raw_size
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|pstatus
operator|=
operator|(
expr|struct
name|win32_pstatus
operator|*
operator|)
name|buf
expr_stmt|;
name|memmove
argument_list|(
operator|&
name|base_addr
argument_list|,
operator|&
operator|(
name|pstatus
operator|->
name|data
operator|.
name|module_info
operator|.
name|base_address
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|base_addr
argument_list|)
argument_list|)
expr_stmt|;
name|dll_name_size
operator|=
name|pstatus
operator|->
name|data
operator|.
name|module_info
operator|.
name|module_name_size
expr_stmt|;
if|if
condition|(
name|offsetof
argument_list|(
expr|struct
name|win32_pstatus
argument_list|,
name|data
operator|.
name|module_info
operator|.
name|module_name
argument_list|)
operator|+
name|dll_name_size
operator|>
name|sect
operator|->
name|_raw_size
condition|)
goto|goto
name|out
goto|;
name|dll_name
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|dll_name_size
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dll_name
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"memory allocation failed for %s\n"
argument_list|,
name|sect
operator|->
name|name
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|strncpy
argument_list|(
name|dll_name
argument_list|,
name|pstatus
operator|->
name|data
operator|.
name|module_info
operator|.
name|module_name
argument_list|,
name|dll_name_size
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|dll_name
argument_list|,
literal|'\\'
argument_list|)
operator|)
condition|)
operator|*
name|p
operator|=
literal|'/'
expr_stmt|;
if|if
condition|(
operator|!
name|core_dll_symbols_add
argument_list|(
name|dll_name
argument_list|,
operator|(
name|DWORD
operator|)
name|base_addr
argument_list|)
condition|)
name|printf_unfiltered
argument_list|(
literal|"%s: Failed to load dll symbols.\n"
argument_list|,
name|dll_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dll_code_sections_add
argument_list|(
name|dll_name
argument_list|,
operator|(
name|DWORD
operator|)
name|base_addr
operator|+
literal|0x1000
argument_list|,
name|target
argument_list|)
condition|)
name|printf_unfiltered
argument_list|(
literal|"%s: Failed to map dll code sections.\n"
argument_list|,
name|dll_name
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|buf
condition|)
name|xfree
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|dll_name
condition|)
name|xfree
argument_list|(
name|dll_name
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|child_solib_add
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|,
name|int
name|from_tty
parameter_list|,
name|struct
name|target_ops
modifier|*
name|target
parameter_list|,
name|int
name|readsyms
parameter_list|)
block|{
if|if
condition|(
operator|!
name|readsyms
condition|)
return|return;
if|if
condition|(
name|core_bfd
condition|)
block|{
name|child_clear_solibs
argument_list|()
expr_stmt|;
name|bfd_map_over_sections
argument_list|(
name|core_bfd
argument_list|,
operator|&
name|core_section_load_dll_symbols
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|solib_end
operator|&&
name|solib_end
operator|->
name|name
condition|)
name|solib_end
operator|->
name|objfile
operator|=
name|solib_symbols_add
argument_list|(
name|solib_end
operator|->
name|name
argument_list|,
name|from_tty
argument_list|,
name|solib_end
operator|->
name|load_addr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|fetch_elf_core_registers
parameter_list|(
name|char
modifier|*
name|core_reg_sect
parameter_list|,
name|unsigned
name|core_reg_size
parameter_list|,
name|int
name|which
parameter_list|,
name|CORE_ADDR
name|reg_addr
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
if|if
condition|(
name|core_reg_size
operator|<
sizeof|sizeof
argument_list|(
name|CONTEXT
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"Core file register section too small (%u bytes)."
argument_list|,
name|core_reg_size
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
name|NUM_REGS
condition|;
name|r
operator|++
control|)
name|supply_register
argument_list|(
name|r
argument_list|,
name|core_reg_sect
operator|+
name|mappings
index|[
name|r
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|core_fns
name|win32_elf_core_fns
init|=
block|{
name|bfd_target_elf_flavour
block|,
name|default_check_format
block|,
name|default_core_sniffer
block|,
name|fetch_elf_core_registers
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|_initialize_core_win32
parameter_list|(
name|void
parameter_list|)
block|{
name|add_core_fns
argument_list|(
operator|&
name|win32_elf_core_fns
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_initialize_check_for_gdb_ini
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|homedir
decl_stmt|;
if|if
condition|(
name|inhibit_gdbinit
condition|)
return|return;
name|homedir
operator|=
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
expr_stmt|;
if|if
condition|(
name|homedir
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|oldini
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|homedir
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
literal|"/gdb.ini"
argument_list|)
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|oldini
argument_list|,
name|homedir
argument_list|)
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|oldini
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|>
name|oldini
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
operator|*
name|p
operator|++
operator|=
literal|'/'
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
literal|"gdb.ini"
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|oldini
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|oldini
argument_list|)
decl_stmt|;
name|char
modifier|*
name|newini
init|=
name|alloca
argument_list|(
name|len
operator|+
literal|1
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|newini
argument_list|,
literal|"%.*s.gdbinit"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|len
operator|-
operator|(
sizeof|sizeof
argument_list|(
literal|"gdb.ini"
argument_list|)
operator|-
literal|1
operator|)
argument_list|)
argument_list|,
name|oldini
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"obsolete '%s' found. Rename to '%s'."
argument_list|,
name|oldini
argument_list|,
name|newini
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

