begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Remote target communications for the Macraigor Systems BDM Wiggler    talking to a Motorola PPC 8xx ADS board    Copyright 1996, 1997 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"wait.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"gdb-stabs.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"serial.h"
end_include

begin_include
include|#
directive|include
file|"ocd.h"
end_include

begin_decl_stmt
specifier|static
name|void
name|bdm_ppc_open
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|name
operator|,
name|int
name|from_tty
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|bdm_ppc_wait
name|PARAMS
argument_list|(
operator|(
name|int
name|pid
operator|,
expr|struct
name|target_waitstatus
operator|*
name|target_status
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|bdm_ppc_fetch_registers
name|PARAMS
argument_list|(
operator|(
name|int
name|regno
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|bdm_ppc_store_registers
name|PARAMS
argument_list|(
operator|(
name|int
name|regno
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|target_ops
name|bdm_ppc_ops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward decl */
end_comment

begin_escape
end_escape

begin_comment
comment|/*#define BDM_NUM_REGS 71*/
end_comment

begin_define
define|#
directive|define
name|BDM_NUM_REGS
value|24
end_define

begin_define
define|#
directive|define
name|BDM_REGMAP
define|\
value|2048, 2049, 2050, 2051, 2052, 2053, 2054, 2055,
comment|/* r0-r7 */
value|\ 	2056, 2057, 2058, 2059, 2060, 2061, 2062, 2063,
comment|/* r8-r15 */
value|\ 	2064, 2065, 2066, 2067, 2068, 2069, 2070, 2071,
comment|/* r16-r23 */
value|\ 	2072, 2073, 2074, 2075, 2076, 2077, 2078, 2079,
comment|/* r24-r31 */
value|\ \ 	2080, 2082, 2084, 2086, 2088, 2090, 2092, 2094,
comment|/* fp0->fp8 */
value|\ 	2096, 2098, 2100, 2102, 2104, 2106, 2108, 2110,
comment|/* fp0->fp8 */
value|\ 	2112, 2114, 2116, 2118, 2120, 2122, 2124, 2126,
comment|/* fp0->fp8 */
value|\ 	2128, 2130, 2132, 2134, 2136, 2138, 2140, 2142,
comment|/* fp0->fp8 */
value|\ \ 	26,
comment|/* pc (SRR0 (SPR 26)) */
value|\ 	2146,
comment|/* ps (MSR) */
value|\ 	2144,
comment|/* cnd (CR) */
value|\ 	8,
comment|/* lr (SPR 8) */
value|\ 	9,
comment|/* cnt (CTR (SPR 9)) */
value|\ 	1,
comment|/* xer (SPR 1) */
value|\ 	0,
end_define

begin_comment
comment|/* mq (SPR 0) */
end_comment

begin_escape
end_escape

begin_decl_stmt
name|char
name|nowatchdog
index|[
literal|4
index|]
init|=
block|{
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0x88
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Open a connection to a remote debugger.    NAME is the filename used for communication.  */
end_comment

begin_function
specifier|static
name|void
name|bdm_ppc_open
parameter_list|(
name|name
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|CORE_ADDR
name|watchdogaddr
init|=
literal|0xff000004
decl_stmt|;
name|ocd_open
argument_list|(
name|name
argument_list|,
name|from_tty
argument_list|,
name|OCD_TARGET_MOTO_PPC
argument_list|,
operator|&
name|bdm_ppc_ops
argument_list|)
expr_stmt|;
comment|/* We want interrupts to drop us into debugging mode. */
comment|/* Modify the DER register to accomplish this. */
name|ocd_write_bdm_register
argument_list|(
literal|149
argument_list|,
literal|0x20024000
argument_list|)
expr_stmt|;
comment|/* Disable watchdog timer on the board */
name|ocd_write_bytes
argument_list|(
name|watchdogaddr
argument_list|,
name|nowatchdog
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Wait until the remote machine stops, then return,    storing status in STATUS just as `wait' would.    Returns "pid" (though it's not clear what, if anything, that    means in the case of this target).  */
end_comment

begin_function
specifier|static
name|int
name|bdm_ppc_wait
parameter_list|(
name|pid
parameter_list|,
name|target_status
parameter_list|)
name|int
name|pid
decl_stmt|;
name|struct
name|target_waitstatus
modifier|*
name|target_status
decl_stmt|;
block|{
name|int
name|stop_reason
decl_stmt|;
name|target_status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_STOPPED
expr_stmt|;
name|stop_reason
operator|=
name|ocd_wait
argument_list|()
expr_stmt|;
if|if
condition|(
name|stop_reason
condition|)
block|{
name|target_status
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_INT
expr_stmt|;
return|return
name|inferior_pid
return|;
block|}
name|target_status
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_TRAP
expr_stmt|;
comment|/* XXX for now */
if|#
directive|if
literal|0
block|{     unsigned long ecr, der;      ecr = ocd_read_bdm_register (148);
comment|/* Read the exception cause register */
block|der = ocd_read_bdm_register (149);
comment|/* Read the debug enables register */
block|fprintf_unfiltered (gdb_stdout, "ecr = 0x%x, der = 0x%x\n", ecr, der);   }
endif|#
directive|endif
return|return
name|inferior_pid
return|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|int
name|bdm_regmap
index|[]
init|=
block|{
name|BDM_REGMAP
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Read the remote registers into regs.    Fetch register REGNO, or all registers if REGNO == -1     The Wiggler uses the following codes to access the registers:     0 -> 1023		SPR 0 -> 1023 	0 - SPR 0 - MQ 	1 - SPR 1 - XER 	8 - SPR 8 - LR 	9 - SPR 9 - CTR (known as cnt in GDB) 	26 - SPR 26 - SRR0 - pc    1024 -> 2047		DCR 0 -> DCR 1023 (IBM PPC 4xx only)    2048 -> 2079		R0 -> R31    2080 -> 2143		FP0 -> FP31 (64 bit regs) (IBM PPC 5xx only)    2144			CR (known as cnd in GDB)    2145			FPCSR    2146			MSR (known as ps in GDB)  */
end_comment

begin_function
specifier|static
name|void
name|bdm_ppc_fetch_registers
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|char
modifier|*
name|regs
decl_stmt|,
modifier|*
name|beginregs
decl_stmt|,
modifier|*
name|endregs
decl_stmt|,
modifier|*
name|almostregs
decl_stmt|;
name|unsigned
name|char
name|midregs
index|[
literal|32
index|]
decl_stmt|;
name|unsigned
name|char
name|mqreg
index|[
literal|1
index|]
decl_stmt|;
name|int
name|first_regno
decl_stmt|,
name|last_regno
decl_stmt|;
name|int
name|first_bdm_regno
decl_stmt|,
name|last_bdm_regno
decl_stmt|;
name|int
name|reglen
decl_stmt|,
name|beginreglen
decl_stmt|,
name|endreglen
decl_stmt|;
if|#
directive|if
literal|1
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|FPLAST_REGNUM
operator|-
name|FP0_REGNUM
operator|+
literal|1
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|midregs
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|mqreg
index|[
literal|0
index|]
operator|=
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|regno
operator|==
operator|-
literal|1
condition|)
block|{
name|first_regno
operator|=
literal|0
expr_stmt|;
name|last_regno
operator|=
name|NUM_REGS
operator|-
literal|1
expr_stmt|;
name|first_bdm_regno
operator|=
literal|0
expr_stmt|;
name|last_bdm_regno
operator|=
name|BDM_NUM_REGS
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|first_regno
operator|=
name|regno
expr_stmt|;
name|last_regno
operator|=
name|regno
expr_stmt|;
name|first_bdm_regno
operator|=
name|bdm_regmap
index|[
name|regno
index|]
expr_stmt|;
name|last_bdm_regno
operator|=
name|bdm_regmap
index|[
name|regno
index|]
expr_stmt|;
block|}
if|if
condition|(
name|first_bdm_regno
operator|==
operator|-
literal|1
condition|)
block|{
name|supply_register
argument_list|(
name|first_regno
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return;
comment|/* Unsupported register */
block|}
if|#
directive|if
literal|1
comment|/* Can't ask for floating point regs on ppc 8xx, also need to      avoid asking for the mq register. */
if|if
condition|(
name|first_regno
operator|==
name|last_regno
condition|)
comment|/* only want one reg */
block|{
comment|/*      printf("Asking for register %d\n", first_regno); */
comment|/* if asking for an invalid register */
if|if
condition|(
operator|(
name|first_regno
operator|==
name|MQ_REGNUM
operator|)
operator|||
operator|(
operator|(
name|first_regno
operator|>=
name|FP0_REGNUM
operator|)
operator|&&
operator|(
name|first_regno
operator|<=
name|FPLAST_REGNUM
operator|)
operator|)
condition|)
block|{
comment|/*          printf("invalid reg request!\n"); */
name|supply_register
argument_list|(
name|first_regno
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return;
comment|/* Unsupported register */
block|}
else|else
block|{
name|regs
operator|=
name|ocd_read_bdm_registers
argument_list|(
name|first_bdm_regno
argument_list|,
name|last_bdm_regno
argument_list|,
operator|&
name|reglen
argument_list|)
expr_stmt|;
block|}
block|}
else|else
comment|/* want all regs */
block|{
comment|/*      printf("Asking for registers %d to %d\n", first_regno, last_regno); */
name|beginregs
operator|=
name|ocd_read_bdm_registers
argument_list|(
name|first_bdm_regno
argument_list|,
name|FP0_REGNUM
operator|-
literal|1
argument_list|,
operator|&
name|beginreglen
argument_list|)
expr_stmt|;
name|endregs
operator|=
operator|(
name|strcat
argument_list|(
name|midregs
argument_list|,
name|ocd_read_bdm_registers
argument_list|(
name|FPLAST_REGNUM
operator|+
literal|1
argument_list|,
name|last_bdm_regno
operator|-
literal|1
argument_list|,
operator|&
name|endreglen
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|almostregs
operator|=
operator|(
name|strcat
argument_list|(
name|beginregs
argument_list|,
name|endregs
argument_list|)
operator|)
expr_stmt|;
name|regs
operator|=
operator|(
name|strcat
argument_list|(
name|almostregs
argument_list|,
name|mqreg
argument_list|)
operator|)
expr_stmt|;
name|reglen
operator|=
name|beginreglen
operator|+
literal|32
operator|+
name|endreglen
operator|+
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
literal|0
block|regs = ocd_read_bdm_registers (first_bdm_regno, last_bdm_regno,&reglen);
endif|#
directive|endif
for|for
control|(
name|i
operator|=
name|first_regno
init|;
name|i
operator|<=
name|last_regno
condition|;
name|i
operator|++
control|)
block|{
name|int
name|bdm_regno
decl_stmt|,
name|regoffset
decl_stmt|;
name|bdm_regno
operator|=
name|bdm_regmap
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|bdm_regno
operator|!=
operator|-
literal|1
condition|)
block|{
name|regoffset
operator|=
name|bdm_regno
operator|-
name|first_bdm_regno
expr_stmt|;
if|if
condition|(
name|regoffset
operator|>=
name|reglen
operator|/
literal|4
condition|)
continue|continue;
name|supply_register
argument_list|(
name|i
argument_list|,
name|regs
operator|+
literal|4
operator|*
name|regoffset
argument_list|)
expr_stmt|;
block|}
else|else
name|supply_register
argument_list|(
name|i
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Unsupported register */
block|}
block|}
end_function

begin_comment
comment|/* Store register REGNO, or all registers if REGNO == -1, from the contents    of REGISTERS.  FIXME: ignores errors.  */
end_comment

begin_function
specifier|static
name|void
name|bdm_ppc_store_registers
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|first_regno
decl_stmt|,
name|last_regno
decl_stmt|;
name|int
name|first_bdm_regno
decl_stmt|,
name|last_bdm_regno
decl_stmt|;
if|if
condition|(
name|regno
operator|==
operator|-
literal|1
condition|)
block|{
name|first_regno
operator|=
literal|0
expr_stmt|;
name|last_regno
operator|=
name|NUM_REGS
operator|-
literal|1
expr_stmt|;
name|first_bdm_regno
operator|=
literal|0
expr_stmt|;
name|last_bdm_regno
operator|=
name|BDM_NUM_REGS
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|first_regno
operator|=
name|regno
expr_stmt|;
name|last_regno
operator|=
name|regno
expr_stmt|;
name|first_bdm_regno
operator|=
name|bdm_regmap
index|[
name|regno
index|]
expr_stmt|;
name|last_bdm_regno
operator|=
name|bdm_regmap
index|[
name|regno
index|]
expr_stmt|;
block|}
if|if
condition|(
name|first_bdm_regno
operator|==
operator|-
literal|1
condition|)
return|return;
comment|/* Unsupported register */
for|for
control|(
name|i
operator|=
name|first_regno
init|;
name|i
operator|<=
name|last_regno
condition|;
name|i
operator|++
control|)
block|{
name|int
name|bdm_regno
decl_stmt|;
name|bdm_regno
operator|=
name|bdm_regmap
index|[
name|i
index|]
expr_stmt|;
comment|/* only attempt to write if it's a valid ppc 8xx register */
comment|/* (need to avoid FP regs and MQ reg) */
if|if
condition|(
operator|(
name|i
operator|!=
name|MQ_REGNUM
operator|)
operator|&&
operator|(
operator|(
name|i
operator|<
name|FP0_REGNUM
operator|)
operator|||
operator|(
name|i
operator|>
name|FPLAST_REGNUM
operator|)
operator|)
condition|)
block|{
comment|/*          printf("write valid reg %d\n", bdm_regno); */
name|ocd_write_bdm_registers
argument_list|(
name|bdm_regno
argument_list|,
name|registers
operator|+
name|REGISTER_BYTE
argument_list|(
name|i
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
comment|/*       else if (i == MQ_REGNUM)         printf("don't write invalid reg %d (MQ_REGNUM)\n", bdm_regno);       else         printf("don't write invalid reg %d\n", bdm_regno); */
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Define the target subroutine names */
end_comment

begin_decl_stmt
name|struct
name|target_ops
name|bdm_ppc_ops
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|init_bdm_ppc_ops
parameter_list|(
name|void
parameter_list|)
block|{
name|bdm_ppc_ops
operator|.
name|to_shortname
operator|=
literal|"ocd"
expr_stmt|;
name|bdm_ppc_ops
operator|.
name|to_longname
operator|=
literal|"Remote target with On-Chip Debugging"
expr_stmt|;
name|bdm_ppc_ops
operator|.
name|to_doc
operator|=
literal|"Use a remote target with On-Chip Debugging.  To use a target box;\n\ specify the serial device it is connected to (e.g. /dev/ttya).  To use\n\ a wiggler, specify wiggler and then the port it is connected to\n\ (e.g. wiggler lpt1)."
expr_stmt|;
comment|/* to_doc */
name|bdm_ppc_ops
operator|.
name|to_open
operator|=
name|bdm_ppc_open
expr_stmt|;
name|bdm_ppc_ops
operator|.
name|to_close
operator|=
name|ocd_close
expr_stmt|;
name|bdm_ppc_ops
operator|.
name|to_attach
operator|=
name|NULL
expr_stmt|;
name|bdm_ppc_ops
operator|.
name|to_post_attach
operator|=
name|NULL
expr_stmt|;
name|bdm_ppc_ops
operator|.
name|to_require_attach
operator|=
name|NULL
expr_stmt|;
name|bdm_ppc_ops
operator|.
name|to_detach
operator|=
name|ocd_detach
expr_stmt|;
name|bdm_ppc_ops
operator|.
name|to_require_detach
operator|=
name|NULL
expr_stmt|;
name|bdm_ppc_ops
operator|.
name|to_resume
operator|=
name|ocd_resume
expr_stmt|;
name|bdm_ppc_ops
operator|.
name|to_wait
operator|=
name|bdm_ppc_wait
expr_stmt|;
name|bdm_ppc_ops
operator|.
name|to_post_wait
operator|=
name|NULL
expr_stmt|;
name|bdm_ppc_ops
operator|.
name|to_fetch_registers
operator|=
name|bdm_ppc_fetch_registers
expr_stmt|;
name|bdm_ppc_ops
operator|.
name|to_store_registers
operator|=
name|bdm_ppc_store_registers
expr_stmt|;
name|bdm_ppc_ops
operator|.
name|to_prepare_to_store
operator|=
name|ocd_prepare_to_store
expr_stmt|;
name|bdm_ppc_ops
operator|.
name|to_xfer_memory
operator|=
name|ocd_xfer_memory
expr_stmt|;
name|bdm_ppc_ops
operator|.
name|to_files_info
operator|=
name|ocd_files_info
expr_stmt|;
name|bdm_ppc_ops
operator|.
name|to_insert_breakpoint
operator|=
name|ocd_insert_breakpoint
expr_stmt|;
name|bdm_ppc_ops
operator|.
name|to_remove_breakpoint
operator|=
name|ocd_remove_breakpoint
expr_stmt|;
name|bdm_ppc_ops
operator|.
name|to_terminal_init
operator|=
name|NULL
expr_stmt|;
name|bdm_ppc_ops
operator|.
name|to_terminal_inferior
operator|=
name|NULL
expr_stmt|;
name|bdm_ppc_ops
operator|.
name|to_terminal_ours_for_output
operator|=
name|NULL
expr_stmt|;
name|bdm_ppc_ops
operator|.
name|to_terminal_ours
operator|=
name|NULL
expr_stmt|;
name|bdm_ppc_ops
operator|.
name|to_terminal_info
operator|=
name|NULL
expr_stmt|;
name|bdm_ppc_ops
operator|.
name|to_kill
operator|=
name|ocd_kill
expr_stmt|;
name|bdm_ppc_ops
operator|.
name|to_load
operator|=
name|ocd_load
expr_stmt|;
name|bdm_ppc_ops
operator|.
name|to_lookup_symbol
operator|=
name|NULL
expr_stmt|;
name|bdm_ppc_ops
operator|.
name|to_create_inferior
operator|=
name|ocd_create_inferior
expr_stmt|;
name|bdm_ppc_ops
operator|.
name|to_post_startup_inferior
operator|=
name|NULL
expr_stmt|;
name|bdm_ppc_ops
operator|.
name|to_acknowledge_created_inferior
operator|=
name|NULL
expr_stmt|;
name|bdm_ppc_ops
operator|.
name|to_clone_and_follow_inferior
operator|=
name|NULL
expr_stmt|;
name|bdm_ppc_ops
operator|.
name|to_post_follow_inferior_by_clone
operator|=
name|NULL
expr_stmt|;
name|bdm_ppc_ops
operator|.
name|to_insert_fork_catchpoint
operator|=
name|NULL
expr_stmt|;
name|bdm_ppc_ops
operator|.
name|to_remove_fork_catchpoint
operator|=
name|NULL
expr_stmt|;
name|bdm_ppc_ops
operator|.
name|to_insert_vfork_catchpoint
operator|=
name|NULL
expr_stmt|;
name|bdm_ppc_ops
operator|.
name|to_remove_vfork_catchpoint
operator|=
name|NULL
expr_stmt|;
name|bdm_ppc_ops
operator|.
name|to_has_forked
operator|=
name|NULL
expr_stmt|;
name|bdm_ppc_ops
operator|.
name|to_has_vforked
operator|=
name|NULL
expr_stmt|;
name|bdm_ppc_ops
operator|.
name|to_can_follow_vfork_prior_to_exec
operator|=
name|NULL
expr_stmt|;
name|bdm_ppc_ops
operator|.
name|to_post_follow_vfork
operator|=
name|NULL
expr_stmt|;
name|bdm_ppc_ops
operator|.
name|to_insert_exec_catchpoint
operator|=
name|NULL
expr_stmt|;
name|bdm_ppc_ops
operator|.
name|to_remove_exec_catchpoint
operator|=
name|NULL
expr_stmt|;
name|bdm_ppc_ops
operator|.
name|to_has_execd
operator|=
name|NULL
expr_stmt|;
name|bdm_ppc_ops
operator|.
name|to_reported_exec_events_per_exec_call
operator|=
name|NULL
expr_stmt|;
name|bdm_ppc_ops
operator|.
name|to_has_exited
operator|=
name|NULL
expr_stmt|;
name|bdm_ppc_ops
operator|.
name|to_mourn_inferior
operator|=
name|ocd_mourn
expr_stmt|;
name|bdm_ppc_ops
operator|.
name|to_can_run
operator|=
literal|0
expr_stmt|;
name|bdm_ppc_ops
operator|.
name|to_notice_signals
operator|=
literal|0
expr_stmt|;
name|bdm_ppc_ops
operator|.
name|to_thread_alive
operator|=
name|ocd_thread_alive
expr_stmt|;
name|bdm_ppc_ops
operator|.
name|to_stop
operator|=
name|ocd_stop
expr_stmt|;
name|bdm_ppc_ops
operator|.
name|to_pid_to_exec_file
operator|=
name|NULL
expr_stmt|;
name|bdm_ppc_ops
operator|.
name|to_core_file_to_sym_file
operator|=
name|NULL
expr_stmt|;
name|bdm_ppc_ops
operator|.
name|to_stratum
operator|=
name|process_stratum
expr_stmt|;
name|bdm_ppc_ops
operator|.
name|DONT_USE
operator|=
name|NULL
expr_stmt|;
name|bdm_ppc_ops
operator|.
name|to_has_all_memory
operator|=
literal|1
expr_stmt|;
name|bdm_ppc_ops
operator|.
name|to_has_memory
operator|=
literal|1
expr_stmt|;
name|bdm_ppc_ops
operator|.
name|to_has_stack
operator|=
literal|1
expr_stmt|;
name|bdm_ppc_ops
operator|.
name|to_has_registers
operator|=
literal|1
expr_stmt|;
name|bdm_ppc_ops
operator|.
name|to_has_execution
operator|=
literal|1
expr_stmt|;
name|bdm_ppc_ops
operator|.
name|to_sections
operator|=
name|NULL
expr_stmt|;
name|bdm_ppc_ops
operator|.
name|to_sections_end
operator|=
name|NULL
expr_stmt|;
name|bdm_ppc_ops
operator|.
name|to_magic
operator|=
name|OPS_MAGIC
expr_stmt|;
block|}
end_function

begin_comment
comment|/* init_bdm_ppc_ops */
end_comment

begin_function
name|void
name|_initialize_bdm_ppc
parameter_list|()
block|{
name|init_bdm_ppc_ops
argument_list|()
expr_stmt|;
name|add_target
argument_list|(
operator|&
name|bdm_ppc_ops
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

